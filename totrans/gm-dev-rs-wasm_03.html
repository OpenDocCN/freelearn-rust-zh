<html><head></head><body>
		<div><h1 id="_idParaDest-25"><em class="italic"><a id="_idTextAnchor038"/>Chapter 2</em>: Drawing Sprites</h1>
			<p>Now that we've got a working app and we're drawing to the screen, we can start making something that actually looks like a game. That<a id="_idIndexMarker077"/> means <strong class="bold">rendering sprites</strong>, which is just a fancy way of saying drawing pictures. So, in this chapter, we'll start by defining what those pictures are by doing a little bit of game design, and then we'll render a static sprite to the screen. Since a static picture is a pretty boring game, we'll even get the sprite animating too.</p>
			<p>In this chapter, we'll do the following:</p>
			<ul>
				<li>Design our game, Walk the Dog.</li>
				<li>Render a sprite to the Canvas.</li>
				<li>Use a sprite sheet to load many sprites at once.</li>
				<li>Animate a character via the sprite sheet.</li>
			</ul>
			<p>By the end of this chapter, you'll be drawing characters instead of static triangles, and you'll even have them running on the screen.<a id="_idTextAnchor039"/></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor040"/>Technical requirements</h1>
			<p>In addition to the technical requirements of <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>, you'll need to download the assets found at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets</a>. We'll build on top of the results of that chapter as well, so don't throw away the code. If you're reading this book out of order because you can't be tamed by society's rules, then you can get the previous chapter's source code at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1</a> and start there. If you get stumped, you can find the complete source code for this chapter at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_2">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_2</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3wOpCqy">https://bit.ly/3wOpCqy</a></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor041"/>A quick game design session </h1>
			<p>In the previous<a id="_idIndexMarker078"/> chapter, I had you create a project called "Walk the Dog", and you were so engrossed by the process of creating a Rust project and my thrilling prose that you didn't even ask why that was the name of the project. Now we'll dig into the game we're making for this book – <strong class="bold">Walk the Dog</strong>.</p>
			<p><em class="italic">Walk the Dog</em> is an endless runner with a simple concept. You play as a boy walking his dog through the forest when your dog is surprised by a cat that runs by and starts chasing it. You, in turn, begin chasing your dog through the forest, dodging obstacles along the way, until you crash into one and fall down. At which point, of course, the dog turns around and checks on you.</p>
			<p>In case you hadn't guessed, the idea for this game came to me while walking the dog on ice. I've<a id="_idIndexMarker079"/> used <em class="italic">Miro</em> (<a href="https://miro.com">https://miro.com</a>) to make a prototype, just to get a feel for what the game will look like:</p>
			<div><div><img alt="Figure 2.1 – A Walk the Dog screen, hypothetically" src="img/Figure_2.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – A Walk the Dog screen, hypothetically</p>
			<p>Before you get the idea that I'm a great artist, all of the assets I'm using are freely available online via creative commons licenses. You might notice that the background is a little fuzzy relative to the characters, and that's because I made almost no effort to scale the characters to fit beyond copying and pasting them into Miro and dragging the corners around. When we place the actual objects in our game, we'll need to make a better effort than that.</p>
			<p>The temptation at this point is to say, "we're done" and start coding. Given the small size of our game, I don't think we need a full treatment to start coding, but I do want to make sure that we clarify a few things about the game.</p>
			<p>Scoring is done by measuring <a id="_idIndexMarker080"/>how far our little <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong> for short) runs – the same as most endless runners<a id="_idIndexMarker081"/> such as <em class="italic">Canabalt</em> (<a href="http://canabalt.com/">http://canabalt.com/</a>) or the <em class="italic">Dinosaur T-Rex</em> game that shows up when you start Google Chrome without an internet connection. The dog and cat navigate all obstacles effortlessly and are just there to give the player ideas on how to catch the dog, and perhaps mislead the player by taking a path they cannot follow. Obstacles will include rocks and boxes that you can crash into and water that you can fall into. RHB has a slide animation, so sometimes he'll need to slide under little cliffs too, which the dog runs under effortlessly. It's not enough for a fully fledged<a id="_idIndexMarker082"/> game, but it's enough to give us a checklist of features for future chapters. Let's say goodbye to our lovely triangles and begin rendering our adorable Red Hat <a id="_idTextAnchor042"/>Boy.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor043"/>Rendering a sprite</h1>
			<p>Sprite is a term<a id="_idIndexMarker083"/> so commonplace that it's possible to use it in conversation without actually knowing its meaning, yet properly defining it means properly defining bitmap, which in turn means properly defining pixmap. Did you know the term sprite was coined in the 1970s by Danny Hillis (<a href="http://bit.ly/3aZlJ72">http://bit.ly/3aZlJ72</a>)? It's exhausting.</p>
			<p>While I find all of this fascinating, you didn't get this book for that, so for our purposes, a sprite is a 2D image loaded from a file. Red Hat Boy, his dog and cat, and the background will all be sprites. Let's not waste any more time on definitions and start drawing<a id="_idTextAnchor044"/> one.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor045"/>Loading images</h2>
			<p>We'll <a id="_idIndexMarker084"/>start by<a id="_idIndexMarker085"/> unzipping the assets and copying the <code>Idle (1).png</code> file from <code>resized/rhb</code> into the <code>static</code> directory in your project. This will make it reachable from your program. As we build the program out, we'll need further organization, but for one file, this is fine. Next, we'll need to modify our code. You can leave the Sierpiński triangle in there for now as it looks cute next to the sprite, but the first thing to do is use the <code>HTMLImage</code> element to load an image. For now, it's important that you load and draw the image <strong class="bold">before</strong> calling into the Sierpiński triangle. It looks like this:</p>
			<pre>#[wasm_bindgen(start)]
pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {
    ....
    let image = web_sys::HtmlImageElement::new().unwrap();
    image.set_src("Idle (1).png");
    sierpinski(
        &amp;context,
        [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)],
        (0, 255, 0),
        5,
    );
    Ok(())
}</pre>
			<p>You will<a id="_idIndexMarker086"/> once<a id="_idIndexMarker087"/> again get the <code>^^^^^^^^^^^^^^^^ could not find `HtmlImageElement` in `web_sys`</code> error. Remember that the <code>web-sys</code> crate makes heavy use of feature flags, so you'll need to add <code>HtmlImageElement</code> to the feature flag list in <code>Cargo.toml</code>. After you add that, rebuilding will take a little longer, but the application will build again. Now you have loaded the image, and we can draw it.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor046"/>Canvas coordinates </h2>
			<p>Before <a id="_idIndexMarker088"/>we <a id="_idIndexMarker089"/>draw it, we need to cover one thing about the <code>line_to</code> and <code>move_to</code> commands that may not have made sense at the time, which is why we need to discuss the coordinate system:</p>
			<div><div><img alt="Figure 2.2 – Source: Mozilla (http://mzl.la/30NLhxX)" src="img/Figure_2.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Source: Mozilla (http://mzl.la/30NLhxX)</p>
			<p>Our canvas is divided into a 2D grid with dimensions of 600 by 600. Why 600 x 600? Because that's the height and width of our canvas element on the HTML page that we created in <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>. The size itself was completely arbitrary, and we'll probably <a id="_idIndexMarker090"/>change<a id="_idIndexMarker091"/> it as our game grows. The units of the grid are pixels, so when we moved the top of our original triangle to <code>(300.0, 0.0)</code>, we moved it 300 pixels to the right (because <code>(0.0, 0.0)</code> is in the top-left corner of<a id="_idTextAnchor047"/> the canvas.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor048"/>Drawing images</h2>
			<p>Drawing <a id="_idIndexMarker092"/>one image at this point seems uncomplicated – we'll <a id="_idIndexMarker093"/>use the <code>drawImage</code> command from JavaScript; only we'll use the <code>web-sys</code> version for <code>HtmlElement</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Remember that JavaScript functions frequently use function overloading, which Rust doesn't support, so one JavaScript function may have many corresponding variations in Rust.</p>
			<p>So, let's add the draw command right after the code to load the image, and we'll be done:</p>
			<pre>image.set_src("Idle (1).png");
context.draw_image_with_html_image_element(&amp;image, 0.0, 0.0);
...</pre>
			<p>We've ignored <code>Result</code> from the <code>draw_image_with_html_image_element</code> command, but that should draw the image, except, it…doesn't. It turns out you can't draw the image immediately after setting the source of an image element because the image hasn't been loaded yet. In order to wait for the image to be loaded, we'll use the <code>onload</code> callback of <code>HtmlImageElement</code>, which you can set up using <code>set_onload</code> in Rust. To do that, you'll need to learn a little about using JavaScript callbacks from Rust in the WebAssembl<a id="_idTextAnchor049"/>y environment.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor050"/>JavaScript callbacks</h2>
			<p>When you <a id="_idIndexMarker094"/>set the <code>onload</code> callback via the <code>set_onload</code> function<a id="_idIndexMarker095"/> in Rust, you're calling into JavaScript from WebAssembly, via a function that <code>web-sys</code> has generated for you. Unfortunately, translating the following JavaScript to Rust is complicated by the fact that JavaScript is garbage collected whereas Rust uses manual memory management, with its famous borrow checker. Take this code for example:</p>
			<pre>image.onload = () =&gt; { alert("loaded"); }</pre>
			<p>What this means is to actually pass a function to JavaScript, as we want to do here, you have to use a complicated signature as well as think carefully about the borrowing rules of Rust. It's the kind of code that finally makes sense after you get it right but can be hard to write. Let's work through what we need to do here.</p>
			<p>Back in our source code, right after creating <code>HtmlImageElement</code>, we can try to add an <code>onload</code> callback<a id="_idIndexMarker096"/> in a<a id="_idIndexMarker097"/> way that seems intuitive:</p>
			<pre>let image = web_sys::HtmlImageElement::new().unwrap();
image.set_onload(|| {
    web_sys::console::log_1(&amp;JsValue::from_str("loaded"));
});
image.set_src("Idle (1).png");
...</pre>
			<p>Intuitive might be an exaggeration, but that fits with the code we know how to write so far. Unfortunately, that doesn't work, as you'll get compiler errors about mismatched types, as shown here:</p>
			<pre>error[E0308]: mismatched types
  --&gt; src/lib.rs:43:22
   |
   |       image.set_onload(|| {
   |  ______________________^
   | |         web_sys::console.log_1("loaded");
   | |     });
   | |_____^ expected enum `Option`, found closure
   |
   = note: expected enum `Option&lt;&amp;js_sys::Function&gt;`
           found closure `[closure@src/lib.rs:43:22: 45:6]`</pre>
			<p>As the error says, <code>set_onload</code> doesn't take a Rust closure but instead takes <code>Option&lt;&amp;js_sys::Function&gt;</code>. Unfortunately, the error doesn't tell you how to fix it, and it's not clear how to create the <code>js_sys::Function</code> object. What you can do is start by creating a <code>Closure</code> object, with a capital "C," and try passing that into <code>set_onload</code>:</p>
			<pre>let image = web_sys::HtmlImageElement::new().unwrap();
let callback = Closure::once(|| {
    web_sys::console::log_1(&amp;JsValue::from_str("loaded"));
});
image.set_onload(callback);</pre>
			<p><code>Closure</code> is a <code>wasm-bindgen</code> struct that is used to transfer a Rust closure to JavaScript. Here, we <a id="_idIndexMarker098"/>are using the <code>once</code> function on <code>Closure</code> because<a id="_idIndexMarker099"/> we know the <code>onload</code> handler is only called once. However, we still can't just send that to JavaScript as is; trying to via <code>image.set_onload(callback)</code> results in the following error:</p>
			<pre>error[E0308]: mismatched types
  --&gt; src/lib.rs:47:22
   |
47 |     image.set_onload(callback);
   |                      ^^^^^^^^ expected enum `Option`, 
   found struct `wasm_bindgen::prelude::Closure`</pre>
			<p>Remember that <code>set_onload</code> wants <code>Option&lt;&amp;js_sys::Function&gt;</code>, and so far, we've only created <code>Closure</code>. Fortunately, the <code>Closure</code> struct provides a way to make that conversion, which looks like this:</p>
			<pre>image.set_onload(Some(callback.as_ref().unchecked_ref()));</pre>
			<p>First, we call <code>as_ref</code> on the callback, which returns a raw <code>JsValue</code>, and then we call <code>unchecked_ref</code>, which converts it to a <code>&amp;Function</code> object. We pass that into <code>Some</code> because <code>onload</code> can be <code>null</code> in JavaScript. Hooray! It compiles! The draw code now looks like this:</p>
			<pre>let image = web_sys::HtmlImageElement::new().unwrap();
let callback = Closure::once(|| {
    web_sys::console::log_1(&amp;JsValue::from_str("loaded"));
});
image.set_onload(Some(callback.as_ref().unchecked_ref()));
image.set_src("Idle (1).png");
context.draw_image_with_html_image_element(&amp;image, 0.0, 0.0);
...</pre>
			<p>And if you<a id="_idIndexMarker100"/> run the app, it <strong class="bold">still</strong> doesn't show our image, but it<a id="_idIndexMarker101"/> does log an error in the browser's console:</p>
			<pre>Uncaught Error: closure invoked recursively or destroyed already</pre>
			<p>When was the closure destroyed? This is all in the <code>main</code> function, and so the closure is destroyed a couple of lines later when the function completes and the <code>callback</code> variable is no longer in scope. In order to see our log message, we can add one more call to the code after setting the <code>on_load</code> function:</p>
			<pre>image.set_onload(Some(callback.as_ref().unchecked_ref()));
callback.forget();</pre>
			<p>Calling <code>forget()</code> on the callback hands over memory management from Rust to JavaScript, effectively creating a deliberate memory leak. This is not something we want to do often, and it's here strictly to get us past our latest error, by preventing the closure from being destroyed. If you compile that and check your browser console, you'll see the message "loaded" now. This is great and all, but it still doesn't draw our picture because we're not actually waiting for the image to be loaded yet. For that, we'll need an asynchronous function.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Translating Rust closures to JavaScript closures is one of those cases where the abstractions between JavaScript and Rust are leaking all over the place, and it can be "accidentally-swear-in-front-of-your-kids" frustrating. So, don't feel bad when you get this wrong <a id="_idIndexMarker102"/>or get confused; it just means you're <a id="_idIndexMarker103"/>human.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We'll have more examples of sending closures to JavaScript throughout this book, but you may find yourself wanting to cross-reference the official documents at <a href="http://bit.ly/3kSyOSI">http://bit.ly/3kSyOSI</a> an<a id="_idTextAnchor051"/>d <a href="http://bit.ly/3sXt1OW">http://bit.ly/3sXt1OW</a>.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor052"/>Async Rust</h2>
			<p>Rust <a id="_idIndexMarker104"/>added <code>async</code>, letting the runtime know that a function can be made to run asynchronously. Inside that function, you can then use an <code>await</code> call to pause execution of the current thread/process and allow the rest of the application to continue until the function that's being waited for can resume. The key thing is that while <code>await</code> pauses execution of the current execution context, it allows the rest of the code to continue. This makes it ideal for a game that cannot ever stop executing its game loop. It's also significantly cleaner to work with than callback-based code, so we'll be using it here (in combination with channels) to make sure that we don't try to draw our image before it's loaded.</p>
			<p>If you're familiar with using <code>async</code>/<code>.await</code> in traditional Rust, then you know these functions need to execute in a runtime, usually using crates such as <code>tokio</code> or <code>async-std</code>. That runtime is responsible for handing off control and restoring it. Take this simple example from the <code>async-std</code> library's repository:</p>
			<pre>use async_std::task;
fn main() -&gt; Result&lt;(), surf::Error&gt; {
    task::block_on(async {
        let url = "https://www.rust-lang.org";
        let mut response = surf::get(url).send().await?;
        let body = response.body_string().await?;
        dbg!(url);
        dbg!(response.status());
        dbg!(response.version());
        dbg!(response.header_names());
        dbg!(response.header_values());
        dbg!(body.len());
        Ok(())
    })
}</pre>
			<p>Here, the <code>async</code> block<a id="_idIndexMarker107"/> is <a id="_idIndexMarker108"/>wrapped in a function called <code>task::block_on</code>, which handles stopping the execution of this block on each <code>await</code> call and then resuming execution when the <code>await</code> "wakes up" for future processing. All of this requires spawning threads or checking event loops, code that you don't have to write because you're getting it from <code>async-std</code>.</p>
			<p>If you're familiar with other languages that natively support async/.await syntax, such as JavaScript, you might wonder why this additional step is necessary. The answer is that, unlike JavaScript, Rust doesn't <code>async</code> and <code>await</code> keywords exist in the language but don't work without additional crates, but that's a price we pay for additional power.</p>
			<p>That's the bad news, but now for the good news – in WebAssembly, we don't need any additional runtime! Our code runs in the browser and can, therefore, use the browser's runtime; we <a id="_idIndexMarker109"/>just need to use a crate to spawn futures on the local <a id="_idIndexMarker110"/>event loop, and that crate is already present – <code>wasm_bindgen_futures</code>.</p>
			<h3>Spawning a future </h3>
			<p>A <code>Future</code>, naturally, but as a user of futures, you don't generally create the <code>Future</code> type directly. You declare a function or closure as <code>async</code>, and when an <code>async</code> function is called, its return value will be wrapped in <code>Future</code>. Then, the caller can wait for that <code>Future</code> instance to finish by calling <code>await</code>. The benefit of this approach is that while the program doesn't actually stop when you call <code>await</code>, it looks like it does from the perspective of the code author. This makes the code look a lot more linear. In reality, execution of your program continues; otherwise, it would become unresponsive, but the runtime handles picking up the program where it left off when <code>Future</code> completes.</p>
			<p>In case you forgot, we're trying to draw a sprite to the canvas, and to do so, we have to wait for the image to be loaded first. For that, we'll eventually use futures, but there's some infrastructure we need to build first. We'll start by adding an <code>onload</code> callback to <code>HtmlImageElement</code>, which will call a <code>oneshot</code> channel when the image is loaded. A <code>oneshot</code> channel is a channel where the receiver implements the <code>Future</code> trait, so we can call <code>await</code> on it to wait for it to receive a message. If we set up the <code>onload</code> callback to send a message to that channel, we can then call <code>await</code> on the receiver so execution will block until that image is loaded. Then, we can actually draw the image, knowing it's loaded. For all that to work, we need to wrap everything in an <code>async</code> block and spawn the returned future. That's a limitation of the <code>await</code> syntax; it can only work inside an <code>async</code> function of a block. Naturally, we'll start the implementation in the…<code>Cargo.toml</code> file.</p>
			<p>I guess it's not natural to start with the .<code>TOML</code> file, but we need to pull the future dependencies into our WebAssembly project. They're already present in testing, so we'll move <code>futures</code> and <code>wasm-bindgen-futures</code> out of <code>dev-dependencies</code> and into the standard <code>dependencies</code> block. You can put them right under <code>getrandom</code>, as shown in the following code:</p>
			<pre>getrandom = { version = "0.2.3", features = ["js"] }
futures = "0.3.17"
wasm-bindgen-futures = "0.4.28"</pre>
			<p>Now that we have<a id="_idIndexMarker112"/> access to Rust futures, we can use <code>wasm_bindgen_futures::spawn_local</code> to spawn a local future and put all our code for drawing the image into it. Returning to the code we wrote earlier to load <code>HtmlImageElement</code>, we will want to wrap all of it in a call to <code>spawn_local</code>, as shown in the following code:</p>
			<pre>wasm_bindgen_futures::spawn_local(async move {
    let image = web_sys::HtmlImageElement::new().unwrap();
    let callback = Closure::once(move || {
        web_sys::console::log_1(&amp;JsValue::from_str("loaded"));
    });
    image.set_onload(Some(callback.as_ref().unchecked_ref()));
    callback.forget();
    image.set_src("Idle (1).png");
    context.draw_image_with_html_image_element
        (&amp;image, 0.0, 0.0);
    sierpinski(
...
});</pre>
			<p>When you call <code>spawn_local</code>, you need to pass it as a block marked with <code>async,</code> because <code>spawn_local</code> requires <code>Future</code>. We've marked this block as <code>move</code> to give the block ownership of any bindings we reference in it. Later, we'll also need to make sure we deal properly with the lifetime of this closure, which must be <code>'static</code>, but right now, we don't have to worry about that because everything is in the closure. This image is still not going to draw because while <code>Future</code> gets spawned when it runs to completion, our program exits. We need to wait for the image to be loaded, and for that, we'll use the <code>oneshot</code> channel.</p>
			<p>A <code>oneshot</code> channel works like its name; you can call once, at which point it is consumed and cannot be called again. This means that when you move a <code>oneshot</code> channel into a<a id="_idIndexMarker113"/> Rust closure, the closure immediately becomes <code>FnOnce</code>. In fact, if you try to move <code>oneshot</code> into <code>FnMut</code> or <code>Fn</code>, you'll get compiler errors, with a side effect of your hair falling out as you try to figure out what's wrong. So, don't do that – it hurts.</p>
			<p>Instead, let's create the channel inside the <code>spawn_local</code> block, and then replace the <code>web_sys::console::log_1</code> call in the callback by sending a message to the channel. The changes are shown as follows:</p>
			<pre><strong class="bold">let (success_tx, success_rx) = futures::channel::oneshot::channel::&lt;()&gt;();</strong>
let image = web_sys::HtmlImageElement::new().unwrap();
let callback = Closure::once(move || {
    <strong class="bold">success_tx.send(());</strong>
});
...</pre>
			<p>On the first line, we created the <code>oneshot</code> channel of <code>unit</code> type and then moved its transmitter into the callback. We got rid of the log message and replaced it with a call to <code>send</code> on the transmitter. Now, we need to wait for that message to be sent before we try to draw the image. Let's modify the code underneath the closure:</p>
			<pre>image.set_onload(Some(callback.as_ref().unchecked_ref()));
image.set_src("Idle (1).png");
<strong class="bold">success_rx.await;</strong>
context.draw_image_with_html_image_element(&amp;image, 0.0, 0.0);</pre>
			<p>First, we remove<a id="_idIndexMarker114"/> the <code>forget</code> call, as it's no longer necessary since we'll wait for the <code>onload</code> function to be called before we try to draw the image. That makes it okay for the closure to be deleted when the scope completes. Then, we call <code>success_rx.await</code> to block while the load completes. Finally, we'll draw the image as we were doing before, and it shows up!</p>
			<div><div><img alt="Figure 2.3 – It is I, Red Hat Boy, king of the triangle" src="img/Figure_2.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – It is I, Red Hat Boy, king of the triangle</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We're ignoring a lot of results here, which is a bad practice. In the next chapter, we'll start structuring our game to better separate concerns, and when doing so, we'll remove that in favor of explicit error handling or calls to <code>expect</code> if we truly want to halt execution.</p>
			<p>You might wonder why we're using <code>spawn_local</code> at all here, instead of just using a standard Rust channel and calling <code>recv</code> on it, and the reason is that a <code>recv</code> call blocks the main thread's execution, which is a big no-no in the browser. Browser-based code must allow the web browser to continue its event loop, and pausing it will cause the browser itself to become unresponsive. You could use a <code>try_rcv</code> call because that doesn't block, but you'd have to check it in a loop to make sure to wait until the image loads. That would <a id="_idIndexMarker115"/>also pause the browser and would probably cause one of those irritating <code>The browser is not responding</code> errors. Since both the browser and video games coincidentally can't cause the app to become unresponsive, we will use a <code>spawn_local</code> block and the <code>async</code>/<code>await</code> syntax. Remember that while the <code>await</code> context pauses local execution, the program itself actually keeps running, if only to constantly poll and see whether <code>Future</code> is complete. </p>
			<p>Congratulations! You've drawn an image on the screen a mere thousand words after I promised you would, but there's one more thing we have to concern ourselves with. Let's make a small change to the code:</p>
			<pre>image.set_onload(Some(callback.as_ref().unchecked_ref()));
image.set_src("<strong class="bold">rhg.png</strong>");
success_rx.await;</pre>
			<p>Now, if you run the app, the screen doesn't draw anything, including the triangle! This is because we await a successful load, which will never come. We need to handle the error case as well so that we can continue in the event of a failed load rather than hanging, even if we just want to halt the error. What we want to do is send one message (a unit) on success and another message (the error) to the receiver when the image is finished loading, either one way or the other. </p>
			<p>You might think you can change <code>success_tx</code> to take either <code>unit</code> or an error code when the load fails. We can use <code>JsValue</code> for the error since that's the type any error code from the browser will be. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><code>JsValue</code> is a type that represents any value that comes directly from JavaScript. In Rust code, we'll frequently convert these types into more specific Rust types.</p>
			<p>That code <a id="_idIndexMarker116"/>will look like this:</p>
			<pre>let (success_tx, success_rx) = futures::channel::oneshot::channel::&lt;<strong class="bold">Result&lt;(), JsValue&gt;</strong>&gt;();
let image = web_sys::HtmlImageElement::new().unwrap();
let callback = Closure::once(move || {
    success_tx.send(Ok(()));
});
<strong class="bold">let error_callback = Closure::once(move |err| {</strong>
<strong class="bold">    success_tx.send(Err(err)); </strong>
<strong class="bold">});</strong>
image.set_onload(Some(callback.as_ref().unchecked_ref()));
<strong class="bold">image.set_onerror(Some(error_callback.as_ref().unchecked_ref()));</strong></pre>
			<p>This is immediately going to be a compiler error:</p>
			<pre>70 |         let error_callback = Closure::once(move |err| {
   |                                                     
^^^^^^^^^^ value used here after move
71 |             success_tx.send(Err(err));</pre>
			<p><code>success_tx</code>  cannot be moved into both closures at the same time. We're going to need to use one of the Rust constructs to share the channel across threads so that we can use it in both callbacks.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We could use two <code>oneshot</code> channels and a <code>select</code> statement here as well, but at the time of writing, that did not work well in WebAssembly.</p>
			<p>What we'll do is create the channel and then set up a reference counted version of the success and error transmitters. This means that both transmitters will send to the same receiver. Both<a id="_idIndexMarker117"/> of these will need to wrapped inside <code>Mutex</code>, as shown here, replacing the original creation of the <code>oneshot</code> channel:</p>
			<pre>let (success_tx, success_rx) = futures::channel::oneshot::channel::&lt;Result&lt;(), JsValue&gt;&gt;();
let success_tx = Rc::new(Mutex::new(success_tx));
let error_tx = Rc::clone(&amp;success_tx);</pre>
			<p>Note that we will start sending the channel the <code>Result</code>, so we can differentiate between success and failure later. You'll need to make sure that you import <code>std::rc::Rc </code> and <code>std::sync::Mutex</code>. Now that <code>success_tx</code> has been changed into <code>Rc&lt;Mutex&lt;Sender&gt;</code>, you'll need to update the <code>success</code> callback to reflect it. You'll want to lock access to <code>Mutex</code> and then send the <code>success</code> message. Your first try is likely to look like this:</p>
			<pre>let image = web_sys::HtmlImageElement::new().unwrap();
let callback = Closure::once(move || {
    success_tx
        .lock()
        .and_then(|oneshot| Ok(oneshot.send(Ok(()))));
});
...</pre>
			<p>This locks <code>Mutex</code> and then sends its <code>oneshot</code> an <code>Ok(())</code>. This is <em class="italic">almost</em> right, but there's a problem leading to a compiler error, as shown here:</p>
			<pre>error[E0507]: cannot move out of dereference of `std::sync::MutexGuard&lt;'_, futures::futures_channel::oneshot::Sender&lt;Result&lt;(), wasm_bindgen::JsValue&gt;&gt;&gt;`
  --&gt; src/lib.rs:38:40
   |
38 |                 .and_then(|oneshot| Ok(oneshot.send(Ok(()))));
   |                                        ^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `futures::futures_channel::oneshot::Sender&lt;Result&lt;(), wasm_bindgen::JsValue&gt;&gt;`, which does not implement the `Copy` trait</pre>
			<p>The compiler error<a id="_idIndexMarker118"/> is a mouthful, so it's worth breaking it down. As the error says, the<code>.and_then(|oneshot| Ok(oneshot.send(Ok(()))));</code> line requires the <code>oneshot</code> value to be moved into the closure. This is because <code>oneshot</code> doesn't implement copy. This makes sense; if you could copy <code>oneshot</code>, then you could use it more than once. Okay, so <code>oneshot</code> has to be moved into the closure – so what? Moves aren't bad, but the error says, <code>error[E0507]: cannot move out of dereference of `std::sync::MutexGuard</code>. <code>Mutex</code> takes ownership of the value you move into it, and you can't just move out its value leaving it with "nothing." So, the compiler prevents this action.</p>
			<p>These are the kinds of errors that are both a great feature of Rust and the bane of a Rustacean's existence. Here, the compiler is preventing us from making a threading mistake, the kind that would be easy to do in almost any other language, but the side effect is an error that's hard to read. The Rust team continues to work hard on clearer compiler messages, but some things are just hard. When the compiler has you confused, read the errors slowly and carefully, and you'll usually figure out what it's trying to tell you.</p>
			<p>So, how do you get around this problem? What you need to do is make sure to never move out of the <code>Mutex</code> reference while still getting access to the underlying <code>Sender</code>. The way we can do that is to use the <code>Option&lt;T&gt;</code> type, which implements a copy and the <code>take</code> function. That will allow us to replace, inside the locked <code>Mutex</code>, <code>Sender</code> with <code>None</code>. Then, any other user of that <code>Mutex</code> reference will have <code>None</code> and be able to use it appropriately.</p>
			<p>Start by modifying the creation of <code>success_tx</code> to take <code>Option</code>, as shown in the following code:</p>
			<pre>let (success_tx, success_rx) = futures::channel::oneshot::channel::&lt;Result&lt;(), JsValue&gt;&gt;();
let success_tx = Rc::new(Mutex::new(<strong class="bold">Some(success_tx))</strong>);
let error_tx = Rc::clone(&amp;success_tx);</pre>
			<p>Now, in <a id="_idIndexMarker119"/>the <code>success</code> callback, we need to modify the code to account for the transmitter being optional. We'll use <code>take</code> here to immediately replace <code>Some(transmitter)</code> with <code>None</code> when its used. This is the <code>success</code> callback:</p>
			<pre>let callback = Closure::once(move || {
    if let Some(success_tx) = success_tx.lock().ok()
       <strong class="bold">.and_then(|mut opt| opt.take())</strong> {
        success_tx.send(Ok(()));
    }
});</pre>
			<p>Here, we've used the <code>if let</code> construct to get the transmitter out of <code>Mutex</code> and <code>Option</code>. If you follow the code from <code>success_tx.lock()</code>, you'll see we call <code>ok</code> to convert the <code>lock()</code> result to an <code>Option</code>, use the <code>and_then</code> function to operate on the <code>Some</code> version of <code>Option</code>, and then finally use <code>take</code> to get the value of <code>Option</code>. In the <code>if</code> condition, we call the transmitter's <code>send</code> function with an <code>Ok</code> result, and we no longer need the strange <code>Ok</code> wrapper around the <code>send</code> call. The key is that <code>Option</code> never moves out of <code>Mutex</code>; it's replaced by <code>None</code>. Since nobody else can access the <code>oneshot</code> struct while in the lock, the code is thread-safe, and because we use <code>Option</code>, the <code>Mutex</code> always contains something – even if it's <code>None</code>.</p>
			<p>We can finally<a id="_idIndexMarker120"/> write the <code>error</code> callback that started all this, and it's very similar:</p>
			<pre>let error_callback = Closure::once(move |err| {
    if let Some(error_tx) = error_tx.lock().ok()
       .and_then(|mut opt| opt.take()) {
        error_tx.send(Err(err));
    }
});
...</pre>
			<p>That <code>error</code> callback needs to be set using the <code>set_onerror</code> call. We had that previously, but just in case you didn't add that earlier, it looks like the following: </p>
			<pre>image.set_onload(Some(callback.as_ref().unchecked_ref()));
image.set_onerror(Some(error_callback.as_ref().unchecked_ref()));
...</pre>
			<p>I placed the <code>set_onerror</code> call right under the existing <code>set_onload</code> call for symmetry. We do not need to add a second <code>await</code> call for the errors. Both <code>oneshot</code> transmitters send to the same receiver, because <code>error_tx</code> is a clone of <code>success_tx</code>, and we are protected from receiving an error and success because <code>oneshot</code> can only fire one time. </p>
			<p>Now, we're handling the error and success cases correctly, and we aren't getting compiler errors. If you look at your browser right now, you should see just the triangle, as we aren't stuck at the <code>await</code> call anymore. Go ahead and restore the call to <code>image.set_src("Idle (1).png")</code> so that it uses the right file again and the RHB shows back up.</p>
			<p>So, there it is – our<a id="_idIndexMarker121"/> game now displays an image again <em class="italic">and</em> handles errors. But what if your game displays...more than one image?</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor053"/>Sprite sheets </h1>
			<p>Creating a<a id="_idIndexMarker122"/> game where every sprite is its own individual file is certainly possible, but it would mean making the player wait for every file to load individually when the game started. One common way to organize sprites for a game is a <strong class="bold">sprite sheet</strong>, which is made up of two parts. The first is an image file with many sprites in it, like this one:</p>
			<div><div><img alt="Figure 2.4 – The top of the sprite sheet" src="img/Figure_2.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – The top of the sprite sheet</p>
			<p>The second part is a map of coordinates and metadata that lets us "cut out" each image we need, like a cookie cutter. For instance, if we want to show the first sprite in the preceding figure (which happens to be named <code>Dead (7).png</code>), we'll need to know its location and dimensions:</p>
			<div><div><img alt="Figure 2.5 – One sprite in the sheet" src="img/Figure_2.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – One sprite in the sheet</p>
			<p>I've drawn a box marking the frame you'd want to "cut out" of the image when you want to draw <code>Dead (7).png</code>. When you want to draw a different file, say <code>Slide (1).png</code>, you can use the same image but a different frame when drawing.</p>
			<p>In order to know the frame and names of every sprite sheet, we need to load a separate file that stores all that information alongside the image itself. In our case, we will use files I've already<a id="_idIndexMarker123"/> generated for you with a tool called <em class="italic">TexturePacker</em> (<a href="https://www.codeandweb.com/texturepacker">https://www.codeandweb.com/texturepacker</a>), which lets you export a JSON file that looks like this:</p>
			<pre>{"frames": {
"Dead (1).png":
{
     "frame": {"x":0,"y":0,"w":160,"h":136},
     "rotated": false,
     "trimmed": false,
     "spriteSourceSize": {"x":0,"y":0,"w":160,"h":136},
     "sourceSize": {"w":160,"h":136}
}
...</pre>
			<p><em class="italic">TexturePacker</em> generated a JSON file with a lookup table by sprite name. In this case, the "<code>Dead</code> <code>(7).png</code>" sprite is found at (<code>0,0</code>) with a width of 109 pixels and a height of 67 pixels, so in the upper left-hand corner of the larger image. To draw the image, you'll eventually use a version of the <code>drawImage</code> function that takes source coordinates, which are the dimensions you saw in the preceding code, and destination coordinates where you want to position the drawing on the canvas.</p>
			<p>So, to render<a id="_idIndexMarker124"/> the same <code>Idle</code> <code>(1).png</code> that we rendered earlier from the sprite sheet, we need to do the following:</p>
			<ol>
				<li>Load the JSON file.</li>
				<li>Parse the JSON file into a Rust structure.</li>
				<li>Load the image into <code>HtmlImageElement</code>.</li>
				<li>Use the version of <code>drawImage</code> that lets us draw only a part of an image element.</li>
			</ol>
			<p>There isn't <a id="_idTextAnchor054"/>anything else to do, so let's get started.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor055"/>Loading JSON</h2>
			<p>Inside the<a id="_idIndexMarker125"/> assets that you downloaded earlier, there's a directory <a id="_idIndexMarker126"/>called <code>sprite_sheets</code> that has two files, <code>rhb.json</code> and <code>rhb.png</code>. Go ahead and copy both of those to the <code>static</code> directory so that they can be loaded by our project. Now, let's go back and start editing <code>lib.rs</code> to load our sheet.</p>
			<p>In this case, we'll start by writing an entirely new function to call <code>fetch_json</code>. It will use the <code>window.fetch</code> call to retrieve the JSON file and then pull the JSON off of the response body. This requires two asynchronous calls, so we're going to write the entire thing as an <code>async</code> function. Go ahead and put all of this after <code>main</code>:</p>
			<pre>async fn fetch_json(json_path: &amp;str) -&gt; Result&lt;JsValue, JsValue&gt; {
    let window = web_sys::window().unwrap();
    let resp_value = wasm_bindgen_futures::JsFuture::from(
        window.fetch_with_str(json_path)).await?;
    let resp: web_sys::Response = resp_value.dyn_into()?;
    wasm_bindgen_futures::JsFuture::from(resp.json()?).await
}</pre>
			<p>There are a few things that won't even compile yet, and we'll fix them as I walk through this line by line.</p>
			<p>First, we retrieve <code>window</code>. Once again, we're using <code>unwrap</code> because <code>window()</code> is an <code>Option</code>; in the <a id="_idIndexMarker127"/>next chapter, we'll do a better job of dealing with our errors. That second line is a <a id="_idIndexMarker128"/>doozy; we'll go through it in parts:</p>
			<pre>let resp_value = wasm_bindgen_futures::JsFuture::from(
    window.fetch_with_str(&amp;"rhb.json")).await?;</pre>
			<p>The first part is the call to <code>wasm_bindgen_futures::JsFuture::from</code>, which is a little misleading. <code>JsFuture</code> is not a JavaScript future but a Rust future backed by a JavaScript promise. We want a Rust future so that we can eventually call <code>await</code> on it. We call <code>from</code> with the following:</p>
			<pre>window.fetch_with_str(json_path)</pre>
			<p>This corresponds to the <code>window.fetch</code> function in JavaScript, but as with many other JavaScript functions, <code>fetch</code> is overloaded, so we need to explicitly call it <code>with_str</code>. That function returns <code>Promise</code>, which we immediately convert to a future via the <code>from</code> call we discussed earlier. Finally, we call <code>await?</code> , which will block until <code>fetch</code> returns. This is allowed because the <code>fetch_json</code> function is <code>async</code>.</p>
			<p>Still with me? If you understood that, you've figured out the hardest part. Next, we cast the returned <code>resp_value</code> into <code>Response</code> because the <code>fetch</code> call resolves to <code>JsValue</code>. Once again, we must convert from the dynamic typing of JavaScript to the static typing of Rust, and the <code>dyn_into()</code> function does that.</p>
			<p>Now that we've got a response (corresponding to the <code>Response</code> object in the browser), we can call its <code>json()</code> function, corresponding to the <code>json()</code> function on the web's <code>Response</code> object. That function also returns a promise, so we wrap it in <code>JsFuture</code> as well and block on it with an <code>await</code> call.</p>
			<p>Finally, this function returns <code>Result&lt;JsValue, JsValue&gt;</code>, which means it's <code>Result</code> with a dynamic JavaScript object as both its <code>Ok</code> or <code>Err</code> cases. That's why we can use <code>?</code> everywhere.</p>
			<p>But of course, this still doesn't compile because, once again, we're missing a feature flag. Make <a id="_idIndexMarker129"/>sure<a id="_idIndexMarker130"/> you add <code>Response</code> to the list of <code>web-sys</code> dependencies, and you should be green again. Well, except fo<a id="_idTextAnchor056"/>r the warning that says <code>fetch_json</code> isn't called.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor057"/>Parsing JSON</h2>
			<p>Back in <code>main</code>, we'll<a id="_idIndexMarker131"/> make <a id="_idIndexMarker132"/>the draw order as Red Hat Boy, the Sierpiński triangle, and then another Red Hat Boy. So, after the call to <code>sierpinski</code>, let's fetch the "<code>rhb.json</code>" file corresponding to the Red Hat Boy's data file:</p>
			<pre>context.draw_image_with_html_image_element(&amp;image, 0.0, 0.0);
let json = fetch_json("rhb.json").await.unwrap();</pre>
			<p>This fetches the JSON but doesn't parse it into a structure we can use. We have a few options for JSON parsing, including using the browser's built-in facilities, but this is a Rust book, so let's use a Rust <a id="_idIndexMarker133"/>library, <strong class="bold">Serde</strong>.</p>
			<p>Serde is one of the more popular serialization libraries for Rust and is excellent at taking JSON (as well as many other formats) and converting it to Rust structures. Add the necessary dependency to <code>Cargo.toml</code>:</p>
			<pre>serde = {version = "1.0.131", features = ["derive"] }</pre>
			<p>The crate we need is <code>serde</code>, which generically handles serialization and deserialization (<code>rhb.json</code> file that you copied to the <code>static</code> directory earlier in your editor. At the top, you should see something like this:</p>
			<pre>{"frames": {
"Dead (1).png":
{
     "frame": {"x":0,"y":0,"w":160,"h":136},
     "rotated": false,
     "trimmed": false,
     "spriteSourceSize": {"x":0,"y":0,"w":160,"h":136},
     "sourceSize": {"w":160,"h":136}
}
...</pre>
			<p>This JSON document describes a hash of frames, where the key to each frame is the name of the<a id="_idIndexMarker134"/> image <code>("Dead (1).png</code>") and the structure below it <a id="_idIndexMarker135"/>is the properties of that image. The property we care about is <code>frame</code>. The image for "<code>Dead (1).png</code>" is located at (<code>210, 493</code>) with a width of 71 pixels and a height of 115 pixels. Go back to the code, and we can parse that JSON that we fetched earlier.</p>
			<p>First, we need to set up data structures that <code>serde</code> can use. At the top of <code>lib.rs</code>, we can add the <code>Deserialize</code> procedural macro to the scope:</p>
			<pre>use serde::Deserialize;</pre>
			<p>You'll also want to add <code>HashMap</code> from <code>std::collections</code>:</p>
			<pre>use std::collections::HashMap;</pre>
			<p>Now, we'll work backward. You'll have a <code>Sheet</code> class that contains the lookup table from the preceding JSON. You can put this struct anywhere in the <code>lib.rs</code> file, just not inside a function. I put it at the top:</p>
			<pre>#[derive(Deserialize)]
struct Sheet {
    frames: HashMap&lt;String, Cell&gt;,
}</pre>
			<p>The <code>[derive(Deserialize)]</code> macro means we can use <code>Sheet</code> as a target for deserializing the JSON, and <code>HashMap</code> and <code>String</code> work automatically, but we haven't defined <code>Cell</code>. This will represent the portion of the JSON containing <code>frame</code>, which is what we care about because it's where the target sprite is located. We'll add all the structs we<a id="_idIndexMarker136"/> need <a id="_idIndexMarker137"/>above <code>Sheet</code>:</p>
			<pre>#[derive(Deserialize)]
struct Rect {
    x: u16,
    y: u16,
    w: u16,
    h: u16,
}
#[derive(Deserialize)]
struct Cell {
    frame: Rect,
}</pre>
			<p>Great – we have a bunch of structures that can hold the map of data we need to draw our images, but we haven't filled them, but fortunately, <code>wasm-bindgen</code> makes this very easy with the <code>serde-serialize</code> feature. To enable that feature, you'll need to once again update <code>Cargo.toml</code>, replacing the basic <code>wasm-bindgen</code> dependency with the following:</p>
			<pre>wasm-bindgen = { version = "0.2.78", features = ["serde-serialize"] }</pre>
			<p>Where before you only had <code>wasm-bindgen = "0.2.78"</code>, now you'll need to add the <code>serde-serialize</code> feature flag, so you have to use the slightly more complex syntax. After that builds, you can import the JSON data with only one line of code, <code>into_serde</code>, after you fetch the JSON:</p>
			<pre>let json = fetch_json("rhb.json")
    .await
    .expect("Could not fetch rhb.json");
let sheet: Sheet = json
    .into_serde()
    .expect("Could not convert rhb.json into a Sheet 
     structure");</pre>
			<p>I removed the <code>unwrap</code> calls and replaced them with <code>expect</code> because I wanted a specific message in these cases.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Almost all of the dependencies that we are using are very young, and it's unlikely that this book will be able to keep up with every quirk. To follow along, stick to versions the book is<a id="_idIndexMarker138"/> using, but for your own future projects, remember to <a id="_idIndexMarker139"/>check documents for feature flags, version numbers, or both whenever a dependency seemingly doesn't work.</p>
			<p>Now that we have the sheet, we are ready to load the image and draw a sprite in it.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor058"/>Drawing with our "cookie cutter"</h2>
			<p>Recall that <a id="_idIndexMarker140"/>we had four steps to draw from a sprite sheet. We've<a id="_idIndexMarker141"/> completed the first two:</p>
			<ol>
				<li value="1">Load the JSON file.</li>
				<li>Parse the JSON file into a Rust structure.</li>
				<li>Load the image into <code>HtmlImageElement</code>.</li>
				<li>Use the version of <code>drawImage</code> that lets us draw only a part of an image element.</li>
			</ol>
			<p>Step 3 is something you've already done before, and like all good programmers, we go immediately to one tool when we need to write the same code twice…</p>
			<p>Copy and paste, of course! What, you thought that I was gonna say a function? We'll save that for later.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">More seriously, copying and pasting to get something working a second time is perfectly acceptable; just avoid checking that in as the final version.</p>
			<p>Copy<a id="_idIndexMarker142"/> everything<a id="_idIndexMarker143"/> from <code>let (success_tx, success_rx)</code> to <code>success_rx.await</code> and paste it right below, where we converted <code>rhb.json</code> into <code>Sheet</code>:</p>
			<pre>let sheet: Sheet = json
    .into_serde()
    .expect("Could not convert rhb.json into a Sheet 
     structure");
let (success_tx, success_rx) = futures::channel::oneshot::channel::&lt;()&gt;();
...
image.set_src("Idle (1).png");
success_rx.await;</pre>
			<p>Thanks to the way Rust works, you won't need to rename any variables, as every time you use <code>let</code>, you shadow the previous version of that variable and create a new binding. In the pasted code, we only need to make one change – to load the image sheet instead of "<code>Idle (1().png</code>":</p>
			<pre>image.set_src("rhb.png");</pre>
			<p>Step 3 is now complete; we've loaded the large image with many sprites in it. Finally, we'll draw the sprite that we want. Let's go ahead and draw the "<code>Run (1).png</code>" sprite, which will admittedly look similar but will allow us to add some animation to go along with it. We'll use the version of the <code>drawImage</code> call that takes a source location, which is the frame we discussed earlier, and a destination location where we will put the image on the canvas. To make sure that we see the new image, let's stick this image somewhere <a id="_idIndexMarker144"/>near the middle. Add this right after the<a id="_idIndexMarker145"/> last <code>await</code> call:</p>
			<pre>let sprite = sheet.frames.get("Run (1).png").expect("Cell not found");
context.draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh(
    &amp;image,
    sprite.frame.x.into(),
    sprite.frame.y.into(),
    sprite.frame.w.into(),
    sprite.frame.h.into(),
    300.0,
    300.0,
    sprite.frame.w.into(),
    sprite.frame.h.into(),
);</pre>
			<p>The first line, <code>sheet.frames.get</code>, retrieves the sprite by name, with an <code>expect</code> thrown in for when we get the name wrong. The next line is a monster because <code>drawImage</code> has nine argument versions in JavaScript, and it's represented in Rust by the call to <code>draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh</code>. That's a mouthful, but what it means is drawing the image using the source rectangle (our frame) to a destination rectangle, where the source rectangle is represented by four position and size coordinates, and the destination rectangle is also represented by four coordinates. The source rectangle is our frame, drawn from the JSON file we loaded earlier. The destination rectangle starts at (<code>300,300</code>) to put RHB in about the center of the canvas and uses the same width and height because we<a id="_idIndexMarker146"/> don't want to change the size of the image. The <a id="_idIndexMarker147"/>end result is this:</p>
			<div><div><img alt="Figure 2.6 – Multiple Red Hat Boys" src="img/Figure_2.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Multiple Red Hat Boys</p>
			<p>The original RHB is up in the left, using its own image file, and the second RHB from the sprite sheet is approximately in the center of the triangle. You'll notice his right hand is slightly tucked in because it's at the start of his run animation.</p>
			<p>Speaking of the run animation, how about we see it in action?</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Loading the sprite sheet and images the way we did here is just one of many ways to implement this technique. For example, another option would have been to embed the JSON and the images in the Rust executable, perhaps by Base64-encoding them, thereby doing all data loading at once. They could also have been bundled into destination applications via webpack and exposed to our Rust app. All these different ways come with their <a id="_idIndexMarker148"/>own trade-offs, and in our case, we have traded some <a id="_idIndexMarker149"/>complexity and upfront load times for the requirement to make calls to a server. Find the solution that works best for your game.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor059"/>Adding animation </h1>
			<p>Sprite animation works<a id="_idIndexMarker150"/> just like a flip-book or a movie. Show a sequence of images fast enough, where each image is drawn to be only slightly different than the previous one, and it causes the illusion of motion. Animation on the canvas works in much the same way, where each frame in the sprite sheet has the same effect as a drawing in a flip-book:</p>
			<div><div><img alt="Figure 2.7 – The run animation for Red Hat Boy" src="img/Figure_2.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – The run animation for Red Hat Boy</p>
			<p>To draw Red Hat Boy running, we have to simply draw the images in order, one at a time, and loop after drawing the last one. Simple for a loop, right?</p>
			<p>Of course, it's not quite that simple. First, we can't just use an infinite loop, as that would block the browser from any processing, resulting in a frozen browser tab. Second, we have to make sure to clear the canvas between each frame. Otherwise, we'll see all the images merged together as one draws on top of the other. So, each time we draw the canvas, we'll need to clear it first, and then draw the desired frame.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you're familiar with double buffering in traditional game development and are worried about seeing flicker when we clear the canvas and then redraw, don't. The canvas element already handles this for you.</p>
			<p>Fortunately, you already know almost all you need to in order to draw the animated RHB. You'll need to pass a Rust closure to a function and draw a sprite from a sprite sheet. The only thing you don't know is how to clear the canvas, and we'll cover that in a moment, but<a id="_idIndexMarker151"/> we must start by saying goodbye:</p>
			<ol>
				<li value="1"><code>sierpinski</code> and all the code it uses, including the <code>midpoint</code> and <code>draw_triangle</code> functions. They served us well and will be missed.</li>
				<li><strong class="bold">Delete the idle RHB</strong>: We could probably go to the effort of keeping the idle RHB sprite around, but it would require dealing with the duplicated code we wrote to create the sprite sheet. It's best to delete all that copy and paste code before the boss finds out.</li>
			</ol>
			<p>No, go ahead and delete everything inside the <code>spawn_local</code> closure up until we loaded the <code>rhb.json</code> file. After those deletions, your code should look like this around <code>spawn_local</code>:</p>
			<pre>let context = canvas
    .get_context("2d")
    .unwrap()
    .unwrap()
    .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()
    .unwrap();
wasm_bindgen_futures::spawn_local(async move {
    let json = fetch_json("rhb.json")
        .await
        .expect("Could not fetch rhb.json");
    ...</pre>
			<p>So, before spawning the local future, the last thing you do is get the <code>2d</code> context, and the first thing you do after spawning the future is load the JSON.</p>
			<p>Now, it's <a id="_idIndexMarker152"/>time to change the draw into a callback function.</p>
			<ol>
				<li value="3"><code>setInterval</code> function, which is called <code>set_interval_with_callback</code>. First, we need to set up the callback itself, using the <code>Closure</code> <code>struct</code> that we used earlier. Right after the <code>success_rx.await</code> call, add this:<pre>let interval_callback = Closure::wrap(Box::new(move || {}) as Box&lt;dyn FnMut()&gt;);</pre></li>
			</ol>
			<p>This sets up an empty <code>Closure</code>, but unlike the previous time we created <code>Closure</code>, we're using <code>Closure::wrap</code> instead of <code>Closure::once</code>. Why? Well, because this closure will be called multiple times. This also means we need to use <code>Box</code> with an explicit cast, <code>as Box&lt;dyn FnMut()&gt;</code>, because the <code>wrap</code> function requires <code>Box</code>, and there isn't enough information for the compiler to infer the type.</p>
			<p>Now that we have an empty interval callback, we can schedule it to be called. On the next line, add the following:</p>
			<pre>window.set_interval_with_callback_and_timeout_and_arguments_0(
    interval_callback.as_ref().unchecked_ref(),
    50,
);</pre>
			<p>Adding that will start the process of calling our <code>interval_callback</code> every 50 milliseconds; however, doing so will cause an error. If you look into the browser's error log via the <a id="_idIndexMarker153"/>console, you'll see this repeated:</p>
			<pre>Uncaught Error: closure invoked recursively or destroyed already</pre>
			<p>That should sound familiar, as we've already fixed it once this chapter. The fix will be to once again forget the closure that we passed into <code>setInterval</code> so that Rust doesn't destroy it when we leave the scope of this future. Add this right <em class="italic">after</em> the <code>set_interval</code> call:</p>
			<pre>interval_callback.forget();</pre>
			<p>Then, go back and check the console to verify that the error has gone away. You may need to refresh the browser to ensure that you don't get stale error messages showing up to confuse you.</p>
			<p>Now that you've scheduled a regular callback, let's add one line to that callback to clear the screen:</p>
			<pre>let interval_callback = Closure::wrap(Box::new(move || {
    context.clear_rect(0.0, 0.0, 600.0, 600.0);
}) as Box&lt;dyn FnMut()&gt;);</pre>
			<p>This will not compile because outside of this callback, we're still calling <code>draw_image</code>. Since we've moved the <code>context</code> into this <code>Closure</code>, we've run afoul of the borrow checker. To address this, we're going to need to move the drawing code into the closure, like so:</p>
			<pre>let interval_callback = Closure::wrap(Box::new(move || {
    context.clear_rect(0.0, 0.0, 600.0, 600.0);
    let sprite = sheet.frames.get("Run(1).png").expect
        ("Cell not found");
    context.draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh(
        &amp;image,
        sprite.frame.x.into(),
        sprite.frame.y.into(),
        sprite.frame.w.into(),
        sprite.frame.h.into(),
        300.0,
        300.0,
        sprite.frame.w.into(),
        sprite.frame.h.into(),
    );
}) as Box&lt;dyn FnMut()&gt;);</pre>
			<p>Congratulations! You <a id="_idIndexMarker154"/>are now clearing the screen and redrawing it every 50 milliseconds. Unfortunately, it doesn't look like anything because you're always drawing the same image. Let's change the code to loop from "<code>Run (1).png</code>" to "<code>Run (8).png</code>" over and over again.</p>
			<p>Initialize a frame counter outside of the closure:</p>
			<pre>let mut frame = -1;
let interval_callback = Closure::wrap(Box::new(move || {</pre>
			<p>Now, on the inside of the closure, we'll cycle the frame count between 0 and 7:</p>
			<pre>let interval_callback = Closure::wrap(Box::new(move || {
    frame = (frame + 1) % 8;</pre>
			<p>Why 0 to 7 when it goes to frame 8? Because we'll adjust it on the next line when we construct <code>framename</code>:</p>
			<pre>let interval_callback = Closure::wrap(Box::new(move || {
    frame = (frame + 1) % 8;
    let frame_name = format!("Run ({}).png", frame + 1);</pre>
			<p>Finally, instead <a id="_idIndexMarker155"/>of getting "<code>Run (1).png</code>" every time, we'll get the constructed sprite name from the sprite sheet. Just change the <code>sheet.get</code> call to use <code>&amp;frame_name</code>, and we'll move the call to <code>get</code> above the <code>clear_rect</code> call as well:</p>
			<pre>let frame_name = format!("Run ({}).png", frame + 1);
let sprite = sheet.frames.get(&amp;frame_name).expect("Cell not found");</pre>
			<p>Take a look now and, sure enough, Red Hat Bo<a id="_idTextAnchor060"/>y is running!</p>
			<div><div><img alt="Figure 2.8 – You can't see running in a book, trust me" src="img/Figure_2.08_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – You can't see running in a book, trust me</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor061"/>Summary</h1>
			<p>In this chapter, we have covered rendering sprites to the screen, including sprite sheets, but we actually covered so much more than that. We covered how to use futures and <code>async</code> code in a WebAssembly app, how to parse JSON, and perhaps most confusingly how to send Rust closures to JavaScript via the <code>Closure</code> struct. We also reviewed some of the quirks of using Rust in the WebAssembly environment from <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>,<em class="italic"> Hello WebAssembly</em>. This chapter was fun, but we made some messy code.</p>
			<p>In the next chapter, we'll deal with that by setting up a simple architecture for our game and writing a proper game loop. Lest you think <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a><em class="italic">, Creating a Game Loop</em>, is all refactoring, we'll also move our friend Red Hat Boy around the screen. It'll start to look like a real game!</p>
		</div>
	</body></html>