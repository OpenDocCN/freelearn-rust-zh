- en: '*Chapter 3*: Creating a Game Loop'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first two chapters, we focused on getting an application built, an environment
    set up, and graphics on a screen without concerning ourselves with creating an
    actual functioning game. There's no interactivity here, and no straightforward
    way to add more characters without copying and pasting more code. In this chapter,
    that will change, with the addition of a game loop and keyboard events, but first,
    we're going to need to restructure the code to make it ready for our new features.
    Be prepared to dig in – this is going to be a busy chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimal architecture for games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a game loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a keyboard input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving Red Hat Boy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we'll have a mini-game engine that's ready to be
    extended with new features and process input.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no new technical requirements for this chapter; I recommend making
    sure that your editor/IDE setup is comfortable for you. You're going to be making
    a lot of changes and you'll want your editor to help you along. The source code
    for this chapter is available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_3](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3qP5NMa](https://bit.ly/3qP5NMa)'
  prefs: []
  type: TYPE_NORMAL
- en: Minimal architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few years ago, I had a realization while preparing a talk on HTML5 game development.
    The day before I was scheduled to give the talk, I had written the slides and
    prepared my delivery, but I had one small problem – I had no demo! I needed a
    demo of a game to finish off my talk; indeed, I had referenced it in my slides,
    so I had to produce it. If you''ve ever been up against a deadline, you know what
    happens next. All of my ideas about clean code and software architecture were
    thrown to the side, as I hacked and slashed my way to a working prototype of *Asteroids*
    in HTML5\. You can still find it on my GitHub here: [https://github.com/paytonrules/Boberoids](https://github.com/paytonrules/Boberoids),
    complete with a name that doesn''t make sense.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code, by virtually any standard, is pretty terrible. In much the same way
    the code in [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015)*, Hello
    WebAssembly*, and [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)*,*
    *Drawing Sprites*, proceeds in a straight line with no modules, separation of
    concerns, or tests, this code brute-forces its way from the start to the end of
    the program. But a funny thing happened at about 2 AM the day before that presentation
    – it worked! In fact, in preparation for this chapter, I cloned the nearly 10-year-old
    program, ran `python -m http.server`, browsed to `http://localhost:8000`, and,
    well, here you go – a mostly working clone of *Asteroids*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Asteroids with a company logo](img/Figure_3.01_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Asteroids with a company logo
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this code is also nearly impossible to extend or debug. There's no
    encapsulation and it's all in one file; heck, there isn't even a proper `README`
    file. By any objective measure, this is **bad** software.
  prefs: []
  type: TYPE_NORMAL
- en: It was so bad that while working on this presentation, I began simultaneously
    working on an open source project called "*Eskimo*" ([https://github.com/paytonrules/Eskimo](https://github.com/paytonrules/Eskimo)),
    which was meant to be a **good** game framework with the best object-oriented
    design I knew at the time, with a test-first approach and things like CI built
    in. If you look at the commit dates, you may notice that my last commit on this
    project was 2 years after the *Asteroids* clone you can see in the preceding screenshot.
    The code, if you were simply doing a code review, is far better than the code
    for the aforementioned game. It just doesn't actually work.
  prefs: []
  type: TYPE_NORMAL
- en: I never made a working game with *Eskimo*. Like many developers before me, I
    fell into the trap of writing a framework instead of making a game and spent so
    much time "perfecting" my framework that I lost interest in the game I was allegedly
    making. This bothered me for a long time, and I kept asking myself the question,
    "Why did I finish the game when I did everything wrong, and fail when I did it
    right?" Does good code have any real-life meaning?
  prefs: []
  type: TYPE_NORMAL
- en: I won't keep you in suspense; for the purposes of this book, we're going to
    define minimal architecture as one that **makes the next feature easier**. That
    means that we are going to do some architecture but only enough to make things
    easier going forward. We'll be on the lookout for extra complexity and "gold-plating."
    We're making a game, not an engine, and we want to finish the game.
  prefs: []
  type: TYPE_NORMAL
- en: Good? Bad? I'm the guy with code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Minimal architecture sounds simple but can be hard, so let me explain with a
    counter-example.
  prefs: []
  type: TYPE_NORMAL
- en: Eskimo has an `Events` object that is created with a constructor that takes
    `jquery`, the `document`, a `game` object, and a `canvas`. It has all of this
    because I took the principle of dependency injection to an extreme and tried to
    make sure the `Events` object would not depend directly on any of those things.
  prefs: []
  type: TYPE_NORMAL
- en: The problem? Three of those objects are never going to change. You're not going
    to replace `jquery`, the `document`, or the `canvas` in any game, at least not
    with *Eskimo*, and it requires a lot of understanding to follow the Eskimo code
    because of that. While the code is theoretically more flexible and follows the
    dependency inversion principle ([http://bit.ly/3uh7fWU](http://bit.ly/3uh7fWU)),
    it actually made it harder to add future features because I couldn't keep in my
    head what dependencies did what. My mistake was that I injected these dependencies
    before I had a reason to, out of a misplaced sense of "good code."
  prefs: []
  type: TYPE_NORMAL
- en: We are going to stay focused on our goal of making a game and do not want to
    get caught up in making a framework. That means our process for evolving our program
    into a game is going to introduce a little bit of flexibility each time we need
    it. Returning to the two example games, *Asteroids* and *Eskimo*, we can think
    of them as being on a scale of rigidity. The *Asteroids* clone is extremely rigid.
    It's like a steel pole, and if you want to change it, you can't. You can only
    break it. Meanwhile, the *Eskimo* game framework is infinitely flexible, so much
    so that it can't actually do anything. It collapses in on itself in to a lump
    of goo. Our game, which is just Red Hat Boy running so far, is also very rigid.
    Adding a second object, say the dog, would require a lot of code changing throughout
    the small application and would potentially introduce defects.
  prefs: []
  type: TYPE_NORMAL
- en: So in order to take our game and add more features, particularly interactivity,
    we'll need to introduce some flexibility. We'll heat up our steel pole so that
    it can bend, bend it, and then let it harden again.
  prefs: []
  type: TYPE_NORMAL
- en: Layered architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to start by introducing a small layered architecture. Specifically,
    we''ll have three layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – A layered architecture](img/Figure_3.02_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – A layered architecture
  prefs: []
  type: TYPE_NORMAL
- en: The one rule of this architecture is that layers can only use things at or below
    their layer. So working from the bottom, the browser layer is going to be a bunch
    of small functions that are specific to the browser. For instance, our `window`
    function will end up here. Meanwhile, the engine layer is going to be tools that
    work across our game, such as the `GameLoop` structure. Finally, the game is the
    layer that contains our actual game logic. Eventually, we'll spend most of our
    development time in this layer, although initially, we'll spend a lot of time
    in the `Engine` and `Browser` layers until they have settled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do this? Our aforementioned rule was that any change in architecture has
    to make future changes easier, so let''s identify what makes changes hard right
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping everything in one long function makes the code hard to follow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting all the `Browser` code will allow us to unify error handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first point reflects that our brains can only hold so much. Keeping all
    the code in one place means scrolling up and down trying to find where things
    are and trying to remember virtually all of the code. Extracting code into various
    constructs such as modules, functions, and structs with **names** lets us reduce
    the amount of information in our heads. This is why the right design feels good
    to program in. Too much abstraction and you've replaced keeping track of all the
    details of the program with keeping track of all the abstractions. We'll do our
    best to keep things in the sweet spot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second reason for the layered approach is specific to Rust and the `wasm-bindgen`
    functions, which all return `JsValue` as their error type. While this works in
    a browser, it does not work well when intermingling with the rest of a Rust program
    because `JsValue` does not implement the `std::Error::error` type that most other
    Rust errors implement. That means you can''t write a function like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code won't compile because while `ThreadPool::new` returns a `Result<ThreadPool,
    Error>`, `fetch_json` returns `Result<JsValue, JsValue>`, and those results don't
    mix. In the `browser` module, we'll map JsValues to a standard error, using the
    `anyhow` crate. We'll also use it to hide the weird details of the API, creating
    one that's tailored to our purposes. Let's get started creating our `browser`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the browser module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to create a file named `browser.rs` in the `src` directory
    and reference it at the top of `lib.rs` with `mod browser`. While we could, theoretically,
    put every module in `lib.rs`, we''re not monsters, and we''ll break things into
    their own files. By the end of this chapter, `lib.rs` will be very small. Our
    first addition to `browser` is actually going to be a macro, and a completely
    new one, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I''d love to claim that I was a great macro programmer who wrote that in one
    try, but the truth is that that little macro is straight from the Rust and WebAssembly
    docs ([https://bit.ly/3abbdJ9](https://bit.ly/3abbdJ9)). It''s a macro that allows
    you to log in to the console with `log!` using a syntax such as the `format!`
    function. In `lib.rs`, add an annotation to the `browser` module declaration,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes `log!` available whenever the `browser` module is used. Given that
    we''ll be making a lot of changes, we''ll probably want some easy debugging. The
    next step will be to add the `anyhow` crate, which we''ll use to unify the error
    handling across WebAssembly and pure Rust code. The dependency is added to `Cargo.toml`
    as `anyhow = "1.0.51"`. This crate provides a few features that we''ll be using
    extensively:'
  prefs: []
  type: TYPE_NORMAL
- en: An `anyhow::Error` type that conforms to the `std::error::Error` trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `anyhow!` macro that lets us create error messages that conform to the type,
    with strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `anyhow::Result<T>` type that is a shortcut for `Result<T, anyhow::Error>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go ahead and add `use anyhow::{anyhow, Result};` to the top of the use declarations
    now so that we'll have them ready as we create new functions here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `browser` module is prepared, let''s work from the top of `main`
    and work downward, extracting functions. Let''s start here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `wasm_bindgen` macro has to stay there, and it is only compatible with a
    function that returns `Result<(), JsValue>`. This means that while we can use
    proper Rust errors throughout our program, at the end, we'll need to transform
    it back to a `JsValue` if we want it to be returned from this function. Fortunately,
    once we write our game loop, this won't be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Wasm_bindgen` error handling is a little rough, and the Wasm working group
    is aware of it. For reference, you can look at the defect here: [https://bit.ly/3d8x0D7](https://bit.ly/3d8x0D7).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the executing code, there are two functions right off the top
    that can be pulled into `browser.rs`. We''ll take the refactoring step by step.
    First, let''s create a function in the browser module, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That won''t compile because it doesn''t return anything, but also because it
    doesn''t know anything about the `Window` type. Go ahead and import those at the
    top of the file. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already, get Rust Analyzer working with your editor of choice.
    I use emacs and use the keyboard shortcut , `c a` to import modules. It's a great
    timesaver for this kind of work. From this point forward, I won't be documenting
    every `use` declaration you need when moving files over; just follow the compiler
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function also doesn''t compile because you''re not returning anything.
    You can start by directly copying (don''t cut) the call to `window()` from `lib.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You don't need to bind a variable with `let` here. This still won't compile
    because of that `unwrap`. In this case, `web_sys::window` returns `Option<Window>`
    and `unwrap` will extract the `Window` object, or panic. None of that conforms
    to `Result<Window>`, and what we need to do instead is handle the case where `window`
    is somehow missing as an error.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When trying to mix and match `Option` and `Result`, there are two schools of
    thought – make `Result` into `Option` with `ok`, or convert `Result` into `Option`
    with `ok_or_else`. I prefer the second because while that will mean writing a
    lot of error messages that say "`<X>`" (not found), the alternative is losing
    useful error diagnostics.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this function work with the `Result<Window>` return type, which, remember,
    is a shorthand for `Result<Window, anyhow::Error>`, we''re going to use the `anyhow!`
    macro. So, to convert `Option` to `Result` and make this function compile, you
    can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now you've got a function, `browser::window()`, which will return `Window` or
    the appropriate error.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Nightly Rust currently has an error called `NoneError` that helps bridge the
    gap between `Option` and `Result` types, but we'll stick to the standard for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can replace the call to `web_sys::window()` in `lib` with a call
    to `browser::window()` in `lib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `window()` will use `expect` for now to go ahead and crash the
    program if there is no window. Later, you''ll see we can use the `?` operator,
    but for the moment, we''ve got to work around `main_js` returning a `Result<(),
    JsValue>`. If that was the only place we were changing, the introduction of `anyhow`
    wouldn''t make any sense. Fortunately, when we repeat that process with a new
    `document` function in the `browser` module, you can see the advantage. We can
    skip going through each step of that process, and get to the end result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If this doesn't compile, don't forget to add `Document` to the `use` declarations
    at the top of the module. As we make these changes, you'll need to move `use`
    declarations into `browser`, but you'll be able to remove them from `lib.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now actually shrink the two calls to `window()` and `document()` in
    `lib.rs` into one call, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one place in `lib.rs` where we''re using the window variable we just
    deleted. Near the bottom of `spawn_local` `Closure`, right after creating `interval_callback,`
    there is a call to `window.set_interval_with_callback_and_timeout_and_arguments_0`
    that can replace `window` with `browser::window().unwrap()`. That looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next function will get the `canvas` object, but it''s a little more complicated
    than the previous two functions. We were pretty casual with the `unwrap` calls
    for that section, so we''ll have to do some converting to get more specific errors.
    The end result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things worth paying close attention to here. First, the `get_element_by_id`
    call is hardcoded to the `'canvas'` ID. We'll go ahead and leave that as is until
    it causes an issue later, but we're not going to make that configurable until
    we need to. Next, we used `ok_or_else` to convert `get_element_by_id` from `Option`
    to `Result`. Most interesting is the call to the `dyn_into` function. As discussed
    earlier, almost every function that calls into JavaScript will return a `JsValue`
    type, because JavaScript is a dynamically typed language. We know that the element
    returned by `get_element_by_id` will return `HtmlCanvasElement`, at least if we've
    retrieved the right JavaScript node, so we can convert it from `JsValue` to the
    correct element. This is what `dyn_into` does – it converts from `JsValue` to
    appropriate Rust types. In order to use `dyn_into`, you must import `wasm_bindgen::JsCast`,
    which rust-analyzer cannot automatically import. It can import `web_sys::HtmlCanvasElement`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a `context` function that looks very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: One oddity you might see here is that we follow `map_err` immediately with `ok_or`.
    That's because `get_context` returns `Result<Option<Object>, JsValue>`, which
    the old code "solved" by calling `unwrap` twice. So what we do now is map the
    error (`JsValue`) to `Error` and then take the inner `Option` and map the `None`
    case to a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that if you''re following along and having trouble compiling, update
    your `use` declarations. Let''s pick up the pace a little. We can add a function
    for `spawn_local`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you are writing a wrapper like this and aren't sure what the signature should
    be, start by looking at the function you're wrapping and mimic its signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add fetching `JSON` to `browser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I expanded `fetch_json` into two functions because I think `fetch_with_str`
    is going to be reusable, but it's not strictly necessary. The `fetch_json` function
    borders on not belonging in the `browser` module. On the one hand, it exclusively
    calls into the `wasm_bindgen` API, mapping the `JsValue` errors to standard `Error`s;
    on the other hand, there is a tiny amount of behavior there when we decide to
    get `JSON` off of the response. Ultimately, that's a bit of a judgment call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having written all those functions, you can go back to the `lib.rs` module
    and update the main function to use the new ones. As you can see, it''s starting
    to shrink significantly, as the top should look like the following, using the
    new functions from the browser module where appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we removed all the intermediate calls to `window` and `context`
    in favor of one call to `context`. We've also just made a call into `fetch_json`
    using `expect` to call out errors. Finally, you'll see one compiler error when
    you do this on the `window.set_interval_with_callback_and_timeout_and_arguments_0`
    line. You can fix that by replacing `window` with `browser::window().unwrap()`.
    The `unwrap` bit is ugly, but we'll keep refactoring until that's gone as well.
    It's not reproduced in the preceding snippet, but you can also delete the `fetch_json`
    function from `lib.rs`; it's not being used anymore.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the next section to extract – loading an image.
  prefs: []
  type: TYPE_NORMAL
- en: Loading an image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I bet you thought you were done with loading the image, didn''t you? Well,
    we will be as soon as we turn it into a function. Let''s look at the original
    implementation for a moment again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this looks like it's one function in our `browser` module,
    `load_image`, but on closer reflection, there's a lot here for just one function.
    For instance, if you so choose, you can create an image element without worrying
    about whether it's going to be loaded, or you might be willing to use `set_src`
    without concerning yourself with whether or not it's loaded. No, all that stuff
    after `let image = web_sys::HtmlImageElement::new().unwrap()` is really engine
    behavior. That means it's time for us to create our second module, `engine`!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `engine` module will contain libraries and functions that we will use throughout
    our game. We are `engine` module. In fact, to break down this behavior, we''ll
    follow a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `browser` function, `new_image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `browser` function to create JS closures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `engine` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `engine` function, `load_image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with the changes to `browser`; we''ll create two new functions
    to make `Closure` and an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first function is just a wrapper around `HtmlImageElement`; there's not
    much to explain. In the future, we may decide we want our own type for images,
    but for now, we'll stick with the browser-provided type. The `closure_once` function
    is complicated by its type signature. In this case, we just mimic the exact same
    type signature of the `Closure::once` function from `wasm_bindgen`. Later, we'll
    write some utility functions for the `Closure` types to make working with them
    easier, but for this one, we'll just create a straight wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: A compelling argument can be made that we should be converting even more types
    in this module. Specifically, we should use our own types for `Closure`, `HtmlImageElement`,
    and other browser-provided types. It's possible that's a better approach, but
    for now, we're going to stick with the types provided in the interest of both
    learning the material and keeping to a simple architecture. Like all decisions
    in programming, it's a trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: 'That covers *step 1* and *step 2*, and *step 3* is quick – create a file named
    `engine.rs` in the source directory and add a `mod engine` declaration to `lib.rs`.
    Now for *step 4*, the one we''ve been dreading. In `engine.rs`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m intentionally leaving out the `use` statements so that you get used to
    adding them and thinking about which declarations you need and are using. However,
    there are two traps to this code that I want to call out:'
  prefs: []
  type: TYPE_NORMAL
- en: In order for `unchecked_ref` to compile, you need to use `wasm_bindgen:JsCast`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you import `channel`, make sure you choose `futures::channel::oneshot::channel`.
    There are a few different implementations of `channel`, and if you grab the wrong
    one by mistake, this code won't compile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in doubt, take a look at `lib.rs` and verify which dependencies are being
    used there because that's where this code is being pulled from.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the code we added, note that we're using our new `browser` functions
    throughout, with no direct dependencies on the `wasm-bindgen` functions. We are
    still dependent on `wasm_bindgen` for the `Closure` and `JSValue` types, as well
    as the `unchecked_ref` function, but we've reduced the amount of direct platform
    dependencies. Our only JS dependency is on `HtmlImageElement`. Now, take a look
    at the very beginning of the function and you'll see the `new_image` call can
    use the `?` operator to early return in the event of an error, with a standard
    Rust error type. This is why we mapped those errors in the `browser` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Moving past the first two lines of the method, the rest of the function is largely
    the same as before, replacing any direct calls to `wasm-bindgen` functions with
    their corresponding calls in `browser`. We've changed the channel to send `anyhow::Result`
    and used `anyhow!` in `error_callback`. This then allows us to end the function
    with a call to `complete_rx.await??` and `Ok(image)`. Those two `??` are not a
    misprint; `complete_rx.await` returns `Result<Result<(), anyhow::Error>, Canceled>`.
    Since `anyhow::Error` and `Canceled` both conform to `std::error::Error`, we can
    handle those errors with `?` each time.
  prefs: []
  type: TYPE_NORMAL
- en: We still have two warnings in this function because both of the calls to `send`
    return `Result` that we aren't dealing with. We can't just use `?` because those
    results are wrapped in the `Closure` types, so we'll put off dealing with those
    unlikely errors for now and will cover error logging in [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203),
    *Testing, Debugging, and Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''ve done all that you should be able to, replace the code in `main`
    with a call to our new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Nothing about loading `Sheet` has changed; that's just there to make sure you
    put this in the right place. After that, the code for animating our little **Red
    Hat Boy** (**RHB**) starts, but we're not going to be using that at all. That
    will be replaced with our game loop, which we'll start introducing now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core of this game, and virtually every game ever, is just an infinite loop.
    You can boil them all down to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – A basic game loop](img/Figure_3.03_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – A basic game loop
  prefs: []
  type: TYPE_NORMAL
- en: 'That means, theoretically, these are trivial to implement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At its core, that''s what we''re going to write, but as you probably guessed,
    if it was that simple, I wouldn''t have devoted an entire chapter to it. No, there
    are two problems we are going to be dealing with as we write it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`requestAnimationFrame` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frame rates and physics**: The preceding loop we wrote would run as fast
    as the computer could go. Well, is every computer on the internet the same speed?
    No, of course not, so we''ll need to make sure we can account for the differences
    between machine speeds in our loop, as best we can. We''ll do that with what''s
    called a **fixed-step** game loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You could probably write a book on game loops if you so chose, but this section
    owes a heavy debt to [https://gameprogrammingpatterns.com/game-loop.html](https://gameprogrammingpatterns.com/game-loop.html)
    and [https://gafferongames.com/post/fix_your_timestep/](https://gafferongames.com/post/fix_your_timestep/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RequestAnimationFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start with the `requestAnimationFrame` function, which is a browser
    function that "requests" a new frame draw as soon as possible. The browser then
    fits that in frame draw in between handling things such as mouse clicks, operating
    system events, and cat videos. You might think that would be very slow, but in
    fact, typically, it''s able to render at 60 frames per second, provided your game
    can keep up. The catch is that unlike our `setInterval` call from earlier, this
    function needs to be called at the end of every animation. A fairly straightforward
    JavaScript version of an animation might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, `requestAnimationFrame` is called with the `animate` function as its parameter.
    The browser then calls the `animate` function on the next frame, which draws and
    then requests the next frame. This looks like an infinite loop, but, in fact,
    doesn't block the browser because of the calls to `requestAnimationFrame`. This
    also takes a parameter, `now`, which is a timestamp in milliseconds of when the
    callback function was started. We'll use this to fix our physics as we evolve
    our game loop, but writing a game loop in Rust is a little weird because of the
    borrowing guarantees, so let's start by writing a very basic one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start by adding a simple wrapper for `requestAnimationFrame` to `browser`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Function` type is a pure JavaScript type and is only available in the
    `js-sys` package. While we could import that, I''d rather not add another crate
    dependency if possible; however, we don''t actually have to use the `Function`
    type directly if we make a small change to the function signature and the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of taking `&Function`, our `request_animation_frame` will take `&Closure<dyn
    FnMut(f64)>` as its parameter. Then, it will call `callback.as_ref().unchecked_ref()`
    when calling the `web-sys` version of `request_animation_frame`. This converts
    `Closure` into `Function`, without requiring an explicit dependency on the `Function`
    type, and it''s worth thinking about when you''re creating your own versions of
    these functions. The makers of `web-sys` have to match every single potential
    use case, and as such, they are going to create the widest possible interfaces.
    As an application programmer, you do not need most of what''s in that library.
    Therefore, you can and should narrow the interface to your own use cases, making
    it easier for you to work with. In fact, in order to make things a little cleaner,
    we''ll convert that into a type, with one small change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on from my mini-rant, you might think you can now write a simple game
    loop, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah, if only, but remember that we need to pass a JavaScript `Closure`, not
    a Rust `fn`. Using the `Closure::once` that we used before won''t work because
    this closure will be called more than once, but fortunately, there''s `Closure::wrap`,
    which will do just that. We''ll create a function in `browser` to create a `Closure`
    specific to the `request_animation_frame` function, called `create_raf_closure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The function being passed in has a `'static` lifetime. Any `FnMut` passed into
    this function cannot have any non-static references. This wasn't a decision on
    my part; it's a requirement of the `Closure::wrap` function we'll be calling into.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on static lifetimes, take a look at the *Rust by Example*
    book, available for free here: [https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html](https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of `Closure::wrap`, let''s wrap it in a `closure_wrap` function so
    that the code we just added will compile, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is another one of those wrapper functions where we are just matching the
    same signature as the function being wrapped – `Closure::wrap`. Because the `wrap`
    function on `Closure` creates a `Closure` that can be called multiple times, it
    needs to be wrapped in a `Box` and stored on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The nightly build of `wasm-bindgen` provides a more ergonomic `new` function
    that handles the boxing for you. We'll stick to the stable build in this book,
    but you are welcome to try nightly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know the basic game loop and how to call `request_animation_frame`,
    you might think, "I''ve got this" and create the game loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is closer, but it's not there yet. Remember earlier that the `Closure`
    we pass to `create_raf_closure` has to have a `'static` lifetime, meaning everything
    that the `Closure` references must be owned by the closure. That's not the case
    right now. The `animate` variable is owned by the current scope and will be destroyed
    when that scope completes. Of course, `animate` is itselfthe `Closure` because
    this is a self-referencing data structure. The `animate` variable is the `Closure`
    but is also referenced inside the `Closure`. This is a classic Rust problem because
    the `borrow` checker cannot allow it.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine what would happen if this wasn't the case – if `animate` could be referenced
    in the `Closure` but be owned by the scope outside the `Closure`. It would be
    destroyed when the program exited this scope, and `Closure` would no longer be
    valid – a `Null` pointer error, and a crash. This is the trouble with a self-referencing
    data structure, so we'll need a way to work around the `borrow` checker.
  prefs: []
  type: TYPE_NORMAL
- en: 'With nowhere to put this code just yet, let''s have another crack at a hypothetical
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, I kinda wish I was writing JavaScript, but let''s work slowly through
    this code. What we''re doing is creating two references to the same place in memory,
    using `Rc` `struct`, allowing us to both take `f` and `g` and point them at the
    same thing but also move `f` into `animate Closure`. The other trick is that they
    both point to `Option` so that we can move `f` into `Closure` before it is completely
    defined. Finally, when we assign to `g` the `Closure` with `*g.borrow_mut() =
    animate`, we `f` because they are pointing to the same place. Did you get all
    that? No, me neither. Let''s go through the types really quickly to reiterate
    what we did. `f` is set to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Rc` to create a reference-counted pointer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RefCell` to allow for interior mutability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Option` to allow us to assign `f` to `None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoopClosure` to hold a mutable `Closure` that matches the `request_animation_frame`
    parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g` is then set to a clone of `f` so that they point to the same thing, and
    `f` is moved into `animate` `Closure`. `g` is assigned to `animate` via the dereference
    `*` operator and `borrow_mut` functions. Because `f` points to the same place
    as `g`, it will also contain `animate Closure`. Finally, we can call `request_animation_frame`,
    both outside and inside `Closure`, by borrowing it, converting it to a reference,
    and calling `unwrap` to actually get the real `Closure`. Yes, `unwrap` is back;
    we''ll deal with one of those when we create our real function. Finally, `g` can
    be destroyed when it leaves scope because `f` is still in `Closure` and will keep
    the memory around.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Once again, I'd love to take credit for this code, but the truth is that it's
    largely defined in the `wasm-bindgen` guide at [https://bit.ly/3v5FG3j](https://bit.ly/3v5FG3j).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what the core of our game loop is going to look like, how do
    we integrate it with a game?
  prefs: []
  type: TYPE_NORMAL
- en: A game trait
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write our game loop, we have a few options. We could just write the game
    in the loop, but that would look suspiciously similar to what we started with
    before. We could create a `GameLoop` struct with functions for `update` and `draw`,
    which is a significant improvement but still ties everything into one structure.
    We're going to go slightly beyond that and take inspiration from a popular game
    framework, XNA, or MonoGame in its modern incarnation. In the XNA framework, the
    game developer will implement a `Game` type, with methods for `update` and `draw`.
    This is slightly more complex than jamming all the code into one place but is
    significantly less so than a complete entity-component framework. It should work
    well for our purposes since it starts small and should allow for expansion as
    the game gets larger. There's a reason XNA was very successful.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: You can learn about XNA's modern equivalent, MonoGame, at [https://www.monogame.net/](https://www.monogame.net/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a `start` function that accepts anything that implements the
    `Game` trait. The `Game` trait will start with two functions, `update` and `draw`.
    We''ll run that through our game loop to first update and then draw our scene.
    All of this will go into the `engine` module; indeed, arguably, this is our entire
    "engine." Let''s start with the simple version – first, the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good. Note how the `draw` function takes `CanvasRenderingContext2d`
    as a parameter. Now for the rest of the loop – you can add this after the `Game`
    trait or `load_image`; it doesn''t really matter as long as it''s in the `engine`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit larger but it's nothing you haven't seen before. We're going to
    create a `GameLoop` struct with no data and add a `SharedLoopClosure` type to
    simplify the type of the `f` and `g` variables. Then, we'll add an implementation
    of `GameLoop` with one method, `start`, that takes the `Game` trait as a parameter.
    Note that the trait is `'static` because anything moved into the "raf" closure
    has to be `'static`. We follow the snippets we used before to set up our `request_animation_frame`
    loop, and the key change is on the inside where we update and then draw, passing
    the `draw` function `CanvasRenderingContext2d`.
  prefs: []
  type: TYPE_NORMAL
- en: There's a problem with this kind of naive game loop. Typically, `request_animation_frame`
    runs at 60 frames per second, but if either `update` or `draw` takes longer than
    1/60th of a second, it will slow down, making the game move more slowly. A long
    time ago, I recall beating levels by turning off the "**Turbo**" button on my
    desktop, making it possible to beat previously impossible challenges because the
    game became easier to play at slower speeds. Since we want a consistent experience
    across processor speeds, we'll take a common approach called "fixing" the time
    step.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing our time step
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might notice that the `update` function we wrote doesn''t take `perf` as
    a parameter; in fact, it''s unused. Now, imagine trying to simulate a dog running
    across the screen, with no knowledge of how much time has passed between frames.
    Depending on the computer and your guess, the dog could saunter from left to right,
    or shoot past like a bullet. What we could do is send the delta time on each update,
    which can work but gets complicated very quickly. Instead, we''ll assume every
    single tick takes the same amount of time, 1/60th of a second, and call `update`
    several times to "catch up" if we fall behind. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – A fixed step game loop](img/Figure_3.04_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – A fixed step game loop
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn''t a perfect solution; if our game is very slow, it''ll grind to a
    halt, but it should be good enough for our purposes. This is why I had us create
    a `GameLoop` struct – to track the time of the last update. We''ll add two fields
    to the `GameLoop` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds a constant for the length of a frame, converted to milliseconds.
    We''ll track when the previous frame was requested in the `last_frame` field,
    and we''ll accumulate a delta that totals up the physics time since the last render.
    It''s not quite the same thing twice, as you''ll see when we implement that counter
    in the `start` function. Speaking of that function, we''ll need to initialize
    a mutable `GameLoop` at the beginning of that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This initializes `GameLoop` appropriately, using `now` as the time of the last
    frame instead of `0` so that our loop doesn''t perform several million updates
    before the first render. `browser::now()` hasn''t been implemented yet, so you''ll
    need to add it to the `browser` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is just a wrapper around the web browser's `now` function. If you've been
    diligently following, you will probably recognize that this causes a compiler
    error. You'll need to add the "`Performance`" feature flag to the `web-sys` features
    list to bring in that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created a game loop object, inside the `request_animation_frame`
    closure, we''ll add our accumulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: What's changed since last time is that instead of just calling the `update`
    function immediately, we calculate the difference between `perf`, which if you
    remember from earlier is a high-res timestamp of the time that the `request_animation_frame`
    function started executing callback functions. We get the difference between now
    (in `perf`) and the previous frame and add that to `accumulated_delta`. Then,
    we compare this to our desired `FRAME_SIZE` (that's 1/60th of a second), and if
    there's `update`. Then we subtract the frame size from the delta. What is the
    effect of all this? If `game.draw` takes too long so that we cannot complete 1
    frame in 1/60th of a second, the code will run extra updates to catch up.
  prefs: []
  type: TYPE_NORMAL
- en: An example is helpful here. Assume you started playing the game at time `0`,
    the beginning of the world. When the first callback executes for `request_animation_frame`
    its probably very close to `0`, perhaps as low as `1` millisecond, because there's
    no delay on the first frame. The code will add that to `accumulated_delta` and
    then compare it to `FRAME_SIZE` and see that there hasn't been enough delta accumulation,
    so `update` is skipped. The `last_frame` value is stored (again, we'll say it's
    `1`), the screen is drawn, and then `request_animation_frame` is called.
  prefs: []
  type: TYPE_NORMAL
- en: The second time though, the value of `perf` is likely to be about the size of
    the first frame. We'll use `17` milliseconds for simple math. So `perf` is `17`;
    subtract from it the `last_frame`, which is `1`, and add `16` milliseconds to
    `accumulated_delta`. The new value of `accumulated_delta` is `17`, so the game
    is updated once and `accumulated_delta` is reduced to `1`. The game continues
    with one update to one draw until something goes wrong. The `draw` call takes
    `40` milliseconds! Who knows why – maybe an autoplay video started up by surprise,
    taking resources. It doesn't matter because `accumulated_delta` shoots up to `40`,
    which is larger than `2` frames. Now, the loop on `accumulated_delta` runs `update`
    twice, dropping a frame of animation to compensate for the drop in performance.
    The important thing to remember here is that it drops a *draw* but not an *update*,
    so while the player might see some visual artifacts, the physics will still work
    without issue.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder what happens to the extra `accumulated_delta` since it's unlikely
    to be an exact multiple of `FRAME_SIZE`. More advanced game loops will pass that
    into the draw and use it to interpolate between the two update values. We shouldn't
    need that for our game and will just roll that `delta` over to the next frame.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Why use an `f32` for the `accumulated_delta`? That's very observant of you!
    The short version is, because we can. The slightly longer version is that we only
    use `f64` as often as we do because JavaScript uses a 64-bit `Number` type for
    all its numbers. If I could, I'd use smaller values whenever possible, and integers
    as well, because the extra size of `f64` isn't really necessary and can cause
    a surprising drag on performance when repeated everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: So, there you have it – your game loop, at least the "looping" part of it. While
    it's usable now, it doesn't provide an easy way to load our assets. While we could
    just leave things as they are and always load assets before we start our game
    loop, a cleaner solution is to integrate that rule into the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: Loading assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Expanding our game loop to handle loading assets is going to require adding
    a function to our trait, an `async` one to be precise. This will allow us to put
    all our asynchronous code that''s currently wrapped in the `spawn_local` in `lib`
    and put it in a function that returns `Result` with `Game` in it. You can start
    by adding that function to the `Game` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, that doesn''t compile. `async` trait functions haven''t landed
    in stable Rust yet, but fortunately, we can use a crate to get that functionality.
    Add `async-trait = "0.1.52"` to `Cargo.toml` and then add the following attribute
    macro to the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need to import `async_trait::async_trait`. The `async_trait` allows
    us to add `async` functions to a trait. We can use it with the `?Send` trait because
    we don''t need our futures to be thread-safe. Now, we can add this to the game
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! The game gets initialized, asynchronously, and with `Result`
    on the first line. Note that the passed-in `game` no longer has to be mutable
    since we're not mutating it in the function anywhere. We're almost ready to integrate
    our old `set_interval` into this, but there's a little more cleanup I'd like to
    do around drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaner drawing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, we're sending a raw `CanvasRenderingContext2d` to the draw loop,
    with all of its awkward functions such as `draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh`.
    This works but it's ugly, and much like we did with the `browser` module, we can
    use a wrapper to narrow the context's wide interface to a smaller one, tailored
    to our needs. We'll replace passing `CanvasRenderingContext2d` with our own `Renderer`
    object that has easier-to-use functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a structure for our `Renderer` in `engine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple wrapper containing the rendering context. For now, we''ll
    just add the two implementation methods to the `Renderer` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: These two functions, `clear` and `draw_image`, both wrap `context` functions
    but do so using fewer parameters. Instead of four parameters and `clear_rect`,
    we pass `clear` `Rect`. Instead of that incredibly long function name, we pass
    `draw_image` `HtmlImageElement` and two `Rect` structures. Currently, we go ahead
    and use `expect` to panic! here if we can't draw. I am convinced that this should
    return `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: By now, there's been code in this book that you've thought could be done better.
    Try that out! I do that all the time when I follow books, and there's no reason
    you shouldn't too. Just try to remember where you've diverged from the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, both of these functions take `Rect`, but we don''t have a `Rect`
    structure. Let''s add that to the `engine` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can change the draw function to take `Renderer` instead of `CanvasRenderingContext2d`.
    So, we update the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can make a change to the loop. Right now, we create `context` in the
    `Closure` that we pass to `create_raf_closure`. That call returns `Result`, so
    to get access to `context`, we have to call `unwrap` or `expect`. The cleaner
    approach we can use now is to create `Renderer`, with `Context` outside of `Closure`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Moving this outside of the `request_animation_frame` closure means we don't
    need to use the `expect` syntax anymore – nice!
  prefs: []
  type: TYPE_NORMAL
- en: The small change to `draw`, turning it into `game.draw(&renderer)`, will make
    our `draw` function easier to write. I think we're meeting our goal of changing
    the code to make it *easier* to move forward. Let's prove it by taking our animation
    code out of `lib` and using the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the game loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s great that we''ve written this game loop and all, but it''s about time
    we actually use it. Remember that we have our `GameLoop` structure, but it operates
    on a `Game` trait. So in order to use the loop, we need to implement that trait.
    We''ll implement it in another module, `game`, which we''ll create in `game.rs`
    and then add to the library using the `mod game` instruction declaration in `lib.rs`.
    We''ll start with a couple of structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you add the `#[async_trait(?Send)]` annotation, which allows
    you to implement a trait with the `async` functions. Provided you add the required
    `use` declarations from `engine`, this compiles because `Game` implements the
    trait as needed. It doesn't do anything, but it compiles. The `initialize` function
    might look a little strange because we're taking `self` and just throwing it away
    in favor of a new `WalkTheDog` structure – thrown on the heap, no less! We're
    doing that for some changes that you'll see in the next chapter, so just bear
    with me for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take the code that draws from `lib.rs` and move it into `draw`,
    updating it along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This only contains slight changes to the code in `lib.rs`, although it definitely
    won''t compile. Calls to `context` are replaced with calls to `renderer`, and
    we''ve used the new `Rect` structure. This won''t compile because `self` doesn''t
    have `sheet`, `frame`, or `image`. We''ll need to add that to the `game` module,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've moved the structures from `lib.rs` that serialize the JSON from
    our sprite sheet and added fields for `frame`, `HtmlImageElement`, and `Sheet`
    to the `WalkTheDog` struct. Pay close attention to the fact that we've taken `Rect`
    from `lib` and renamed it `SheetRect`. This is the specific rectangle from our
    sprite sheet. In `game`, we also have a `Rect` structure. This is the rectangle
    that we'll use as a game domain object. This rename is confusing right now but
    is done to differentiate the two rectangles and is helpful as we go forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WalkTheDog` structure has the fields needed to make `draw` compile, but
    it may make you wonder about `initialize`. Specifically, if we''re going to move
    our loading code to `initialize`, does the `WalkTheDog` struct really always have
    `HtmlImageElement` and `Sheet`? No, it does not. We''ll need to convert those
    fields to `Option` types and make the `draw` function account for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `as_ref()` function to borrow `image` and `sheet`, and then
    use the `and_then` and `map` `Option` functions to cleanly get the frame and then
    draw it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This is great – we''ve got a game that draws absolutely nothing, but that''s
    okay since our initialize code still doesn''t compile. Let''s prepare to draw
    by copying our loading code from `lib.rs` to the `initialize` function in the
    game loop. Don''t do any cutting and pasting yet; we''ll go ahead and clean up
    `lib.rs` at the end. `Initialize` should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s a great copy and paste, but we can make it far more concise by using
    the `?` operator. Here''s the version with that improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Look how small and clean that function is. It only took us three tries, but
    we got there. Now that we have `initialize` and `draw`, we can write `update`.
    The version we wrote in `lib.rs` used `set_interval_with_callback_and_timeout_and_arguments_0`
    to animate our Red Hat Boy, but that's not going to work anymore. Instead, the
    `update` function will need to keep track of the number of frames that have passed
    and advance when it's appropriate. In the original code, we called the `set_interval`
    callback every `50` milliseconds. In this new code, `update` will be called every
    1/60th of a second, or `16.7` milliseconds. So, in order to approximately match
    the animation, we'll want to update the current sprite frame every three updates;
    otherwise, our little RHB will run very, very fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the `rhb.json` file, you can see that there are eight frames
    in the `Run` animation. If we want to advance a sprite frame every 3 updates,
    that means it will take 24 updates to complete the animation. At that point, we''ll
    want to return to the beginning and play it again. So, we''ll need to calculate
    the sprite frame from the frame count, which is updated in the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This won''t work with our current `draw` code because it uses `frame` to look
    up the sprite to render. It will crash when it looks for `Run (9).png`, which
    doesn''t exist. We''ll update the `draw` function to get the sprite index from
    `frame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `current_sprite` variable will cycle from one to eight, and then loop back
    again. Don't believe me? Feel free to use the `log!` macro we wrote earlier to
    check my work; in fact, I encourage you to. Not because I'm arrogant but because
    it's always good to experiment with the code, rather than blindly typing it in.
    We then take that number and use it to look up the frame name.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that accomplished, we now have a game loop that can render to the canvas
    and a game that renders our running RHB; we just need to integrate it. We''ll
    add a plain constructor to the `WalkTheDog` struct, right under the `struct` definition
    in `engine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing spectacular there – just something to make it easier to create the
    game object. And now for the moment you''ve been waiting for – the new main function
    integrating all these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: No, really, that's it – that's the whole thing. You spawn a local future, create
    a new game, and then call `GameLoop::start(game).await` to start it up. You can
    delete all the unused code from `lib.rs`, such as the extra `use` declarations
    and the structures we defined when everything was here. It looks great!
  prefs: []
  type: TYPE_NORMAL
- en: We changed a lot of code to get here, but now we have a running game with a
    proper loop. We could end the chapter here, but it would be kind of nice if the
    code actually did something new, wouldn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Adding keyboard input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most games have some form of user input; otherwise, they aren't much of a game.
    In this section, we'll start listening to keyboard events and use them to control
    our RHB. That means adding keyboard input to the game loop and passing that into
    the `update` function. What we will *not* be doing is yet more refactoring. The
    system is reasonably well factored at this point and is open to our new changes.
  prefs: []
  type: TYPE_NORMAL
- en: The specific process by which we'll get keyboard events is probably a little
    different than you're used to if you do web development. In a normal program,
    you would listen for keys to get pressed – in other words, pushed down and then
    released – and then do something such as update the screen when the button is
    released. This doesn't fit in with a game because typical players want the action
    to happen as soon as a key is pushed down and want it to continue for as long
    as it's held. Think of moving around the screen with the arrow keys. You expect
    motion to start the second you hit the arrow key, not after you release it. In
    addition, traditional programming doesn't account for things like pressing "up"
    and "right" at the same time. If we process those as two separate actions, we'll
    move right, then up, then right, and then up, like we're moving up the stairs.
    What we'll do is listen to every `keyup` and `keydown` event, and bundle that
    all up into a `keystate` that stores every currently pressed key. Then we'll pass
    that state to the `update` function so that the game can figure out just what
    to do with all the currently pressed keys.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: This approach is common in games, and it leads to one downside. If you want
    to trigger something only when a button is pressed, such as firing a gun, you
    have to keep track of whether or not the previous update had the key up and the
    next update had it down. So, by flipping from an event-driven approach to a global
    key state, we lose the events. Fortunately, this is easily recreated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get keyboard events, we have to listen for the `keydown` and `keyup` events
    on `canvas`. Let''s start with a new function in `engine`, `prepare_input()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you set up your `canvas` element with a `tabIndex` attribute in the
    HTML file; otherwise, it cannot get focus and have keyboard events.
  prefs: []
  type: TYPE_NORMAL
- en: This is enough to get us started. It should look familiar because we're setting
    up `Closure` objects in the same way we did for `load_image` and `request_animation_frame`.
    We have to make sure we call `forget` on both of the `Closure` instances so that
    they aren't deallocated immediately after being set up because nothing in the
    Rust application is holding onto them. You'll also need to add the `KeyboardEvent`
    feature to `web-sys` to include it. Otherwise, there is nothing here you haven't
    seen before. It just doesn't do anything yet.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most things in Rust, if you don't add a `forget` call, you won't get
    a compile-time error. You'll get a panic almost immediately and not always with
    a helpful error message. If you think you've set up callbacks into JavaScript
    and you're getting panics, ask yourself whether anything is holding on to that
    callback in your program. If nothing is, you've probably forgotten to add `forget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re listening to the input, so now we need to keep track of all of it. It''s
    tempting to start trying to condense the events into `keystate` in this function,
    but that''s troublesome because this function only handles one `keyup` or `keydown`
    at a time and doesn''t know anything about all the other keys. If you wanted to
    keep track of an `ArrowUp` and `ArrowRight` being pressed at the same time, you
    couldn''t do it here. What we will do is set up the listeners once before the
    game loop starts, such as with `initialize`, and then process all the new key
    events on every update updating our `keystate`. This will mean sharing state from
    these closures with the closure we passed to `request_animation_frame`. It''s
    time to add a channel. We''ll create an `unbounded` channel, which is a channel
    that will grow forever if you let it, here in `prepare_input` and then return
    its receiver. We''ll pass transmitters to both `onkeyup` and `onkeydown`, and
    send the `KeyboardEvent` to each of those. Let''s take a look at the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The function now returns `Result<UnboundedReceiver<KeyPress>>`. `UnboundedReceiver`
    and `unbounded` are both in the `futures::channel::mspc` module and are declared
    in a `use` declaration at the top of the file. We create the unbounded channel
    on the first line with the `unbounded` function and then create reference counted
    versions of both `keydown_sender` and `keyup_sender`, so that we can move each
    of them into their respective closures while sending both events to the same receiver.
    Note that the `unbounded` channel uses `start_send` instead of `send`. Finally,
    we return `keyevent_receiver` as `Result`. You might consider having two independent
    channels, one for `keyup` and one for `keydown`, and while I'm certain that can
    be done, I tried it and found this way was more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look closely and you might wonder what `KeyPress` is. It turns out you can''t
    tell what kind of `KeyboardEvent` happened simply by inspecting it. In order to
    keep track of whether the event was `keyup` or `keydown`, we wrap those events
    in an enumerated type that we''ll define in `engine.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This `enum` approach means we won''t have to manage two channels. Now that
    we have a function that will listen for and put all our key events into a channel,
    we need to write a second function that grabs all those events off the channel
    and reduces them into `KeyState`. We can do that like so, still in the `engine`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes `KeyState` and `Receiver` and updates `state` by taking
    every entry off of the receiver until its empty. Theoretically, this appears to
    create the possibility for an infinite loop in the event that the receiver is
    constantly filled, but I was unable to do that by normal means (pressing the keyboard
    like a madman), and if somebody decides to write a script that fills this channel
    and break their own game, more power to them. `KeyState` has to be passed as `mut`
    so that we update the current one and do not start from a brand-new state on each
    update. We''ve written this function pretending that `KeyState` already exists,
    but we need to create it as well, again in the `engine` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `KeyState` struct is just a wrapper around `HashMap`, storing a lookup
    of `KeyboardEvent.code` to its `KeyboardEvent`. If the `code` isn''t present,
    then the key isn''t pressed. The code is the actual representation of a physical
    key on the keyboard. You can find a list of all the available `KeyboardEvent`
    codes on MDN Web Docs: [https://mzl.la/3ar9krK](https://mzl.la/3ar9krK).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt, MDN Web Docs from Mozilla is easily the best resource on the
    web for browser libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve created the libraries and structures we need for keyboard input, so
    now we can integrate it into our `GameLoop`. We''ll call `prepare_input` in the
    `start` function before we start looping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll move `keyevent_receiver` into the `request_animation_frame` closure
    and process the input on every update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we initialized an empty `KeyState` right before the `request_animation_frame`
    closure,so that we can start with an empty one. Each frame will now call our `process_input`
    function and generate a new `KeyState`. That''s all the changes we have to do
    to our game loop to keep track of `KeyState`. The only thing that''s remaining
    is to pass it to our `Game` object so that it can be used. Some game implementations
    will store this as a global, but we''ll just pass it to the `Game` trait. We''ll
    update the trait''s `update` function to accept `KeyState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can pass `KeyState` to the `update` function on every loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to keep our game compiling, we will need to update the `WalkTheDog::update`
    signature, over in the `game` module, to match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We've got a `GameLoop` that processes keyboard input and passes that
    state to our `Game`. We've spent a lot of time writing code that makes it possible
    for us to write a game, but we haven't actually updated our game. Our poor little
    RHB still just runs in one place. He looks happy, but now that we've got input,
    how about we move him around?
  prefs: []
  type: TYPE_NORMAL
- en: Moving Red Hat Boy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving game objects means keeping track of a position instead of hardcoding
    it, as you might have expected. We''ll create a `Point` structure in `engine`
    that will hold an *x* and a *y* position for RHB. On every `update` call, we''ll
    also calculate a velocity for him, based on which keys are pressed. Every direction
    will be the same size, so if `ArrowLeft` and `ArrowRight` are pressed at the same
    time, he''ll stop moving. After we calculate his velocity, we''ll update his position
    with that number. That should be enough to allow us to move him around the screen.
    Let''s start by adding `position` to the `WalkTheDog` game struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, `Point` doesn''t exist yet, so we''ll create it in `engine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''re using integers here so that we don''t have to deal with floating
    point math when it''s not necessary. While the `canvas` functions all take `f64`
    values, that''s only because there is only one number type in `JavaScript`, and
    per MDN Web Docs ([https://mzl.la/32PpIhL](https://mzl.la/32PpIhL)), `canvas`
    is faster if you use integer coordinates. You''ll also need to update the `WalkTheDog::new`
    function to fill in a default `position`. Let''s use `0, 0` for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'I promised I would stop reminding you to do this, but do make sure you''ve
    added a `use` declaration for `crate::engine::Point` at the top of the file. The
    `initialize` function also needs to be updated to account for `position`. This
    is actually why we marked `Point` with `Clone` and `Copy`. It makes it possible
    to copy it into the new `WalkTheDog` `initialize` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for `position` to have any meaning, we''ll need to update the `draw`
    function so that it''s actually being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you update the *second* `Rect` and not the first one. The first `Rect`
    is the slice we are taking out of our sprite sheet. The second one is where we
    want to draw it. This should cause a noticeable change to the game, as RHB is
    now in the upper-left corner. Finally, we''re going to modify `update` to calculate
    a velocity based on which keys are pressed in `KeyState`. We''ll add this before
    updating the current frame, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The "`ArrowDown`" and "`ArrowUp`" strings and so on are all listed at [https://mzl.la/3ar9krK](https://mzl.la/3ar9krK),
    although you can also figure them out by simply logging the code when a key is
    pressed. You can see here that if "`ArrowDown`" is pressed we increase `y`, and
    if "`ArrowUp`" is pressed, we decrease it, and that''s because the origin is in
    the upper-left-hand corner, with `y` increasing as you go down, not up. Note also
    that we don''t use `if/else` here. We want to account for every pressed key and
    not short-circuit on the first key that''s pressed. Next, we adjust the position
    based on velocity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Head back to the browser, and you can now use the arrow keys to move RHB around!
    If he doesn't move, make sure you click in the canvas to give it focus. If he
    still doesn't move and you're sure you've gotten everything right, put some `log!`
    messages in the `start` function and make sure `KeyState` is being created, or
    in the `update` function to see if you're actually getting a new `KeyState`. We've
    covered a lot of ground here, and if you're following along, it's very easy to
    make a mistake, but you have a debugging tool to figure out issues now.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'On some browsers, the `canvas` will get a border around it when it has the
    focus, which will appear after you click it. You can remove that by adding a style
    of `outline: none` to the `canvas`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This was a hard, long, and complicated chapter. I''ll quote a phrase Aaron
    Hillegass uses frequently in his books: *"Programming is hard and you are not
    stupid."* There were plenty of areas where a small typo could trip you up, and
    you may have had to go backward and forward several times. That''s all okay –
    it''s part of the learning process. I would encourage you to experiment with the
    skeleton we''ve built, even before moving onto the next chapter, as it''s a great
    way to ensure you understand all the code.'
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we've accomplished a lot. We've created a game loop that will run
    in the browser at 60 frames per second while updating at a fixed step. We've set
    up an XNA-like game "engine" and separated the engine concerns from the game concerns.
    Our browser interface is wrapped in a module so that we can hide some of the details
    of the browser implementation. We're even processing input, making this work like
    a true game engine. We did all this while keeping the code running as we went.
  prefs: []
  type: TYPE_NORMAL
- en: The code should be easier to work with going forward because we now have clear
    places to put things. Browser functions go in a browser, engine functions in an
    engine, and the game in a game module, although you might feel like it's not a
    game because RHB doesn't run, jump, and slide around.
  prefs: []
  type: TYPE_NORMAL
- en: Guess what we're doing next?
  prefs: []
  type: TYPE_NORMAL
