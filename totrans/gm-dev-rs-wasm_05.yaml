- en: '*Chapter 3*: Creating a Game Loop'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：创建游戏循环'
- en: In the first two chapters, we focused on getting an application built, an environment
    set up, and graphics on a screen without concerning ourselves with creating an
    actual functioning game. There's no interactivity here, and no straightforward
    way to add more characters without copying and pasting more code. In this chapter,
    that will change, with the addition of a game loop and keyboard events, but first,
    we're going to need to restructure the code to make it ready for our new features.
    Be prepared to dig in – this is going to be a busy chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们专注于构建应用程序、设置环境和在屏幕上显示图形，而没有关注创建一个实际运行的游戏。这里没有交互性，也没有直接添加更多角色的简单方法，除非复制和粘贴更多代码。在本章中，这将改变，我们将添加游戏循环和键盘事件，但首先，我们需要重构代码，使其为新功能做好准备。准备好深入挖掘——这将是一个繁忙的章节。
- en: 'We''re going to cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下内容：
- en: Minimal architecture for games
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏的最小化架构
- en: Creating a game loop
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏循环
- en: Adding a keyboard input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加键盘输入
- en: Moving Red Hat Boy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动红帽男孩
- en: By the end of the chapter, we'll have a mini-game engine that's ready to be
    extended with new features and process input.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将拥有一个可以扩展新功能和处理输入的迷你游戏引擎。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no new technical requirements for this chapter; I recommend making
    sure that your editor/IDE setup is comfortable for you. You're going to be making
    a lot of changes and you'll want your editor to help you along. The source code
    for this chapter is available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_3](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_3).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有新的技术要求；我建议确保你的编辑器/IDE 设置对你来说很舒适。你将进行很多更改，你希望你的编辑器能帮助你。本章的源代码可在 [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_3](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_3)
    找到。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3qP5NMa](https://bit.ly/3qP5NMa)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的实际效果：[https://bit.ly/3qP5NMa](https://bit.ly/3qP5NMa)
- en: Minimal architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化架构
- en: 'A few years ago, I had a realization while preparing a talk on HTML5 game development.
    The day before I was scheduled to give the talk, I had written the slides and
    prepared my delivery, but I had one small problem – I had no demo! I needed a
    demo of a game to finish off my talk; indeed, I had referenced it in my slides,
    so I had to produce it. If you''ve ever been up against a deadline, you know what
    happens next. All of my ideas about clean code and software architecture were
    thrown to the side, as I hacked and slashed my way to a working prototype of *Asteroids*
    in HTML5\. You can still find it on my GitHub here: [https://github.com/paytonrules/Boberoids](https://github.com/paytonrules/Boberoids),
    complete with a name that doesn''t make sense.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，在准备一场关于 HTML5 游戏开发的演讲时，我有一个顿悟。在我预定演讲的前一天，我已经写好了幻灯片并准备好了演讲稿，但我有一个小问题——我没有演示！我需要一个游戏的演示来结束我的演讲；实际上，我在幻灯片中提到了它，所以我必须制作它。如果你曾经面临过截止日期，你就知道接下来会发生什么。我关于干净代码和软件架构的所有想法都被抛到了一边，我一边破解一边砍伐，最终在
    HTML5 中制作出了 *《小行星》* 的工作原型。你仍然可以在我的 GitHub 上找到它：[https://github.com/paytonrules/Boberoids](https://github.com/paytonrules/Boberoids)，附带一个没有意义的名字。
- en: 'The code, by virtually any standard, is pretty terrible. In much the same way
    the code in [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015)*, Hello
    WebAssembly*, and [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)*,*
    *Drawing Sprites*, proceeds in a straight line with no modules, separation of
    concerns, or tests, this code brute-forces its way from the start to the end of
    the program. But a funny thing happened at about 2 AM the day before that presentation
    – it worked! In fact, in preparation for this chapter, I cloned the nearly 10-year-old
    program, ran `python -m http.server`, browsed to `http://localhost:8000`, and,
    well, here you go – a mostly working clone of *Asteroids*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据几乎任何标准，代码都很糟糕。与 *第 1 章* 中的代码、*《Hello WebAssembly》* 和 *第 2 章* 中的 *《绘制精灵》* 一样，代码直线推进，没有模块、关注点分离或测试，这种代码从程序开始到结束都是暴力破解。但在那次演示的前一天凌晨
    2 点左右，发生了一件有趣的事情——它竟然成功了！事实上，为了准备本章，我克隆了将近 10 年前的程序，运行 `python -m http.server`，浏览到
    `http://localhost:8000`，然后，好吧，这里就是——一个基本上工作的 *《小行星》* 克隆：
- en: '![Figure 3.1 – Asteroids with a company logo](img/Figure_3.01_B17151.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 带有公司标志的《小行星》](img/Figure_3.01_B17151.jpg)'
- en: Figure 3.1 – Asteroids with a company logo
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 带有公司标志的彗星
- en: Of course, this code is also nearly impossible to extend or debug. There's no
    encapsulation and it's all in one file; heck, there isn't even a proper `README`
    file. By any objective measure, this is **bad** software.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码也几乎不可能扩展或调试。没有封装，所有内容都在一个文件中；天哪，甚至没有合适的`README`文件。从任何客观标准来看，这都是**糟糕**的软件。
- en: It was so bad that while working on this presentation, I began simultaneously
    working on an open source project called "*Eskimo*" ([https://github.com/paytonrules/Eskimo](https://github.com/paytonrules/Eskimo)),
    which was meant to be a **good** game framework with the best object-oriented
    design I knew at the time, with a test-first approach and things like CI built
    in. If you look at the commit dates, you may notice that my last commit on this
    project was 2 years after the *Asteroids* clone you can see in the preceding screenshot.
    The code, if you were simply doing a code review, is far better than the code
    for the aforementioned game. It just doesn't actually work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它太糟糕了，以至于在制作这个演示文稿的同时，我开始同时进行一个名为"*Eskimo*"的开源项目（[https://github.com/paytonrules/Eskimo](https://github.com/paytonrules/Eskimo)），该项目旨在成为一个**优秀**的游戏框架，拥有我那时所知的最佳面向对象设计，采用测试先行的方法，并内置了CI等特性。如果你查看提交日期，你可能会注意到我在这个项目上的最后提交是在你可以在前面的屏幕截图中看到的*Asteroids*克隆之后两年。如果你只是简单地做代码审查，代码实际上比上述游戏的代码要好得多。但它实际上并不工作。
- en: I never made a working game with *Eskimo*. Like many developers before me, I
    fell into the trap of writing a framework instead of making a game and spent so
    much time "perfecting" my framework that I lost interest in the game I was allegedly
    making. This bothered me for a long time, and I kept asking myself the question,
    "Why did I finish the game when I did everything wrong, and fail when I did it
    right?" Does good code have any real-life meaning?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未用*Eskimo*制作出一个可工作的游戏。像许多在我之前的开发者一样，我陷入了写框架而不是制作游戏的陷阱，花了很多时间“完善”我的框架，以至于我对我所声称制作的游戏失去了兴趣。这困扰了我很长时间，我一直在问自己这个问题，“为什么我在做所有错误的事情时完成了游戏，而在做正确的事情时失败了？”好的代码在现实生活中有什么真正的意义？
- en: I won't keep you in suspense; for the purposes of this book, we're going to
    define minimal architecture as one that **makes the next feature easier**. That
    means that we are going to do some architecture but only enough to make things
    easier going forward. We'll be on the lookout for extra complexity and "gold-plating."
    We're making a game, not an engine, and we want to finish the game.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会让你保持悬念；为了这本书的目的，我们将把最小架构定义为一种**使下一个功能更容易实现**的架构。这意味着我们将做一些架构工作，但仅足够使未来的事情变得容易。我们将密切关注额外的复杂性和“镀金”。我们正在制作一个游戏，而不是一个引擎，我们希望完成这个游戏。
- en: Good? Bad? I'm the guy with code
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好的吗？糟糕的吗？我是那个有代码的人
- en: Minimal architecture sounds simple but can be hard, so let me explain with a
    counter-example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最小架构听起来很简单，但可能很难，所以让我用一个反例来解释。
- en: Eskimo has an `Events` object that is created with a constructor that takes
    `jquery`, the `document`, a `game` object, and a `canvas`. It has all of this
    because I took the principle of dependency injection to an extreme and tried to
    make sure the `Events` object would not depend directly on any of those things.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Eskimo有一个`Events`对象，它通过一个构造函数创建，该构造函数接受`jquery`、`document`、一个`game`对象和一个`canvas`。它有所有这些，因为我将依赖注入的原则推向了极致，并试图确保`Events`对象不会直接依赖于这些事物中的任何一项。
- en: The problem? Three of those objects are never going to change. You're not going
    to replace `jquery`, the `document`, or the `canvas` in any game, at least not
    with *Eskimo*, and it requires a lot of understanding to follow the Eskimo code
    because of that. While the code is theoretically more flexible and follows the
    dependency inversion principle ([http://bit.ly/3uh7fWU](http://bit.ly/3uh7fWU)),
    it actually made it harder to add future features because I couldn't keep in my
    head what dependencies did what. My mistake was that I injected these dependencies
    before I had a reason to, out of a misplaced sense of "good code."
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是什么？这三个对象永远不会改变。你不会在任何游戏中替换`jquery`、`document`或`canvas`，至少不是用*Eskimo*，而且由于这个原因，理解Eskimo代码需要很多理解。虽然代码在理论上更加灵活，并遵循依赖反转原则（[http://bit.ly/3uh7fWU](http://bit.ly/3uh7fWU)），但它实际上使得添加未来的功能变得更加困难，因为我无法记住这些依赖项具体做了什么。我的错误是在没有理由的情况下，出于一种错误的“好代码”感，提前注入了这些依赖项。
- en: We are going to stay focused on our goal of making a game and do not want to
    get caught up in making a framework. That means our process for evolving our program
    into a game is going to introduce a little bit of flexibility each time we need
    it. Returning to the two example games, *Asteroids* and *Eskimo*, we can think
    of them as being on a scale of rigidity. The *Asteroids* clone is extremely rigid.
    It's like a steel pole, and if you want to change it, you can't. You can only
    break it. Meanwhile, the *Eskimo* game framework is infinitely flexible, so much
    so that it can't actually do anything. It collapses in on itself in to a lump
    of goo. Our game, which is just Red Hat Boy running so far, is also very rigid.
    Adding a second object, say the dog, would require a lot of code changing throughout
    the small application and would potentially introduce defects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于我们的目标，即制作一个游戏，并不想陷入制作框架的困境。这意味着我们使程序演变成游戏的过程将在每次需要时引入一点灵活性。回到两个示例游戏，*Asteroids*
    和 *Eskimo*，我们可以将它们视为在刚性尺度上。*Asteroids* 克隆非常刚性。它就像一根钢杆，如果你想改变它，你就不能。你只能打破它。与此同时，*Eskimo*
    游戏框架具有无限的可塑性，以至于它实际上什么也做不了。它在自己身上坍塌成一块粘稠的物质。我们的游戏，也就是那个跑得这么远的红帽男孩，也是非常刚性的。添加第二个对象，比如狗，就需要在整个小型应用程序中更改大量代码，并可能引入缺陷。
- en: So in order to take our game and add more features, particularly interactivity,
    we'll need to introduce some flexibility. We'll heat up our steel pole so that
    it can bend, bend it, and then let it harden again.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了将我们的游戏添加更多功能，特别是交互性，我们需要引入一些灵活性。我们将加热我们的钢杆，使其可以弯曲，弯曲它，然后让它再次硬化。
- en: Layered architecture
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层架构
- en: 'We''re going to start by introducing a small layered architecture. Specifically,
    we''ll have three layers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先引入一个小型分层架构。具体来说，我们将有三个层：
- en: '![Figure 3.2 – A layered architecture](img/Figure_3.02_B17151.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 分层架构](img/Figure_3.02_B17151.jpg)'
- en: Figure 3.2 – A layered architecture
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 分层架构
- en: The one rule of this architecture is that layers can only use things at or below
    their layer. So working from the bottom, the browser layer is going to be a bunch
    of small functions that are specific to the browser. For instance, our `window`
    function will end up here. Meanwhile, the engine layer is going to be tools that
    work across our game, such as the `GameLoop` structure. Finally, the game is the
    layer that contains our actual game logic. Eventually, we'll spend most of our
    development time in this layer, although initially, we'll spend a lot of time
    in the `Engine` and `Browser` layers until they have settled.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个架构的一条规则是，层只能使用其层或以下的东西。所以从底部开始，浏览器层将是一系列针对浏览器的特定小函数。例如，我们的 `window` 函数最终会在这里。同时，引擎层将是跨越我们游戏工作的工具，例如
    `GameLoop` 结构。最后，游戏是包含我们实际游戏逻辑的层。最终，我们将花费大部分开发时间在这个层，尽管最初，我们将在 `Engine` 和 `Browser`
    层花费大量时间，直到它们稳定下来。
- en: 'Why do this? Our aforementioned rule was that any change in architecture has
    to make future changes easier, so let''s identify what makes changes hard right
    now:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样做？我们之前提到的规则是，任何架构的改变都必须使未来的改变更容易，所以让我们确定一下现在使改变困难的原因：
- en: Keeping everything in one long function makes the code hard to follow.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容都放在一个长函数中使代码难以跟踪。
- en: Extracting all the `Browser` code will allow us to unify error handling.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取所有 `Browser` 代码将使我们能够统一错误处理。
- en: The first point reflects that our brains can only hold so much. Keeping all
    the code in one place means scrolling up and down trying to find where things
    are and trying to remember virtually all of the code. Extracting code into various
    constructs such as modules, functions, and structs with **names** lets us reduce
    the amount of information in our heads. This is why the right design feels good
    to program in. Too much abstraction and you've replaced keeping track of all the
    details of the program with keeping track of all the abstractions. We'll do our
    best to keep things in the sweet spot.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点反映的是我们的大脑只能容纳这么多信息。将所有代码放在一个地方意味着上下滚动试图找到东西的位置，并试图记住几乎所有的代码。将代码提取到各种具有**名称**的结构中，如模块、函数和结构体，让我们减少头脑中的信息量。这就是为什么合适的设计感觉编程起来很舒服。抽象过多，你就把跟踪程序所有细节的工作替换成了跟踪所有抽象的工作。我们将尽最大努力保持事物在最佳状态。
- en: 'The second reason for the layered approach is specific to Rust and the `wasm-bindgen`
    functions, which all return `JsValue` as their error type. While this works in
    a browser, it does not work well when intermingling with the rest of a Rust program
    because `JsValue` does not implement the `std::Error::error` type that most other
    Rust errors implement. That means you can''t write a function like the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 分层方法的原因之二特定于 Rust 和 `wasm-bindgen` 函数，它们都返回 `JsValue` 作为错误类型。虽然这在浏览器中工作得很好，但当与
    Rust 程序的其他部分混合时则不太理想，因为 `JsValue` 没有实现大多数其他 Rust 错误实现的 `std::Error::error` 类型。这意味着你不能编写如下所示的函数：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code won't compile because while `ThreadPool::new` returns a `Result<ThreadPool,
    Error>`, `fetch_json` returns `Result<JsValue, JsValue>`, and those results don't
    mix. In the `browser` module, we'll map JsValues to a standard error, using the
    `anyhow` crate. We'll also use it to hide the weird details of the API, creating
    one that's tailored to our purposes. Let's get started creating our `browser`
    module.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码无法编译，因为虽然 `ThreadPool::new` 返回一个 `Result<ThreadPool, Error>`，但 `fetch_json`
    返回 `Result<JsValue, JsValue>`，这些结果无法混合。在 `browser` 模块中，我们将使用 `anyhow` crate 将
    JsValues 映射到标准错误，同时我们也将用它来隐藏 API 的奇怪细节，创建一个适合我们目的的 API。让我们开始创建我们的 `browser` 模块。
- en: Creating the browser module
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建浏览器模块
- en: 'The first step is to create a file named `browser.rs` in the `src` directory
    and reference it at the top of `lib.rs` with `mod browser`. While we could, theoretically,
    put every module in `lib.rs`, we''re not monsters, and we''ll break things into
    their own files. By the end of this chapter, `lib.rs` will be very small. Our
    first addition to `browser` is actually going to be a macro, and a completely
    new one, listed as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在 `src` 目录下创建一个名为 `browser.rs` 的文件，并在 `lib.rs` 的顶部使用 `mod browser` 引用它。虽然理论上我们可以将每个模块都放在
    `lib.rs` 中，但我们不是怪物，我们会将它们拆分成自己的文件。到本章结束时，`lib.rs` 将非常小。我们添加到 `browser` 的第一个功能实际上将是一个宏，一个全新的宏，如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I''d love to claim that I was a great macro programmer who wrote that in one
    try, but the truth is that that little macro is straight from the Rust and WebAssembly
    docs ([https://bit.ly/3abbdJ9](https://bit.ly/3abbdJ9)). It''s a macro that allows
    you to log in to the console with `log!` using a syntax such as the `format!`
    function. In `lib.rs`, add an annotation to the `browser` module declaration,
    like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我很乐意宣称我是一个伟大的宏程序员，一次就写出了那个宏，但事实是那个小小的宏直接来自 Rust 和 WebAssembly 文档 ([https://bit.ly/3abbdJ9](https://bit.ly/3abbdJ9))。这是一个允许你使用类似于
    `format!` 函数的语法通过 `log!` 在控制台中进行日志记录的宏。在 `lib.rs` 中，给 `browser` 模块声明添加一个注解，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This makes `log!` available whenever the `browser` module is used. Given that
    we''ll be making a lot of changes, we''ll probably want some easy debugging. The
    next step will be to add the `anyhow` crate, which we''ll use to unify the error
    handling across WebAssembly and pure Rust code. The dependency is added to `Cargo.toml`
    as `anyhow = "1.0.51"`. This crate provides a few features that we''ll be using
    extensively:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 `log!` 在使用 `browser` 模块时可用。鉴于我们将进行很多更改，我们可能需要一些简单的调试。下一步将是添加 `anyhow` crate，我们将使用它来统一
    WebAssembly 和纯 Rust 代码的错误处理。依赖项添加到 `Cargo.toml` 中，作为 `anyhow = "1.0.51"`。这个 crate
    提供了一些我们将广泛使用的功能：
- en: An `anyhow::Error` type that conforms to the `std::error::Error` trait
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符合 `std::error::Error` 特质的 `anyhow::Error` 类型
- en: An `anyhow!` macro that lets us create error messages that conform to the type,
    with strings
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `anyhow!` 宏，允许我们创建符合类型的错误消息，并使用字符串
- en: An `anyhow::Result<T>` type that is a shortcut for `Result<T, anyhow::Error>`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `anyhow::Result<T>` 类型，它是 `Result<T, anyhow::Error>` 的快捷方式
- en: Go ahead and add `use anyhow::{anyhow, Result};` to the top of the use declarations
    now so that we'll have them ready as we create new functions here.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请将 `use anyhow::{anyhow, Result};` 添加到使用声明顶部，这样我们就可以在创建新函数时使用它们了。
- en: 'Now that the `browser` module is prepared, let''s work from the top of `main`
    and work downward, extracting functions. Let''s start here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `browser` 模块已经准备好了，让我们从 `main` 的顶部开始向下工作，提取函数。让我们从这里开始：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `wasm_bindgen` macro has to stay there, and it is only compatible with a
    function that returns `Result<(), JsValue>`. This means that while we can use
    proper Rust errors throughout our program, at the end, we'll need to transform
    it back to a `JsValue` if we want it to be returned from this function. Fortunately,
    once we write our game loop, this won't be a problem.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm_bindgen` 宏必须保留在那里，并且它只与返回 `Result<(), JsValue>` 的函数兼容。这意味着虽然我们可以在整个程序中使用适当的
    Rust 错误，但在最后，如果我们想从这个函数返回，我们需要将其转换回 `JsValue`。幸运的是，一旦我们编写了游戏循环，这就不会成为问题。'
- en: Important Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`Wasm_bindgen` error handling is a little rough, and the Wasm working group
    is aware of it. For reference, you can look at the defect here: [https://bit.ly/3d8x0D7](https://bit.ly/3d8x0D7).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wasm_bindgen` 错误处理有点粗糙，Wasm 工作组已经注意到了这一点。为了参考，您可以在以下链接中查看缺陷：[https://bit.ly/3d8x0D7](https://bit.ly/3d8x0D7)。'
- en: 'Moving on to the executing code, there are two functions right off the top
    that can be pulled into `browser.rs`. We''ll take the refactoring step by step.
    First, let''s create a function in the browser module, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是执行代码，有两个函数可以直接拖入 `browser.rs` 文件。我们将一步一步地进行重构。首先，让我们在浏览器模块中创建一个函数，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That won''t compile because it doesn''t return anything, but also because it
    doesn''t know anything about the `Window` type. Go ahead and import those at the
    top of the file. It should look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码无法编译，因为它没有返回任何内容，而且它对 `Window` 类型一无所知。请继续在文件顶部导入这些内容。它应该看起来像这样：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you haven't already, get Rust Analyzer working with your editor of choice.
    I use emacs and use the keyboard shortcut , `c a` to import modules. It's a great
    timesaver for this kind of work. From this point forward, I won't be documenting
    every `use` declaration you need when moving files over; just follow the compiler
    errors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有做，请将 Rust Analyzer 与您选择的编辑器配合使用。我使用 emacs，并使用键盘快捷键 `c a` 来导入模块。这对于这类工作来说是一个节省时间的好方法。从现在开始，我不会记录您在移动文件时需要的每个
    `use` 声明；只需遵循编译器错误即可。
- en: 'The function also doesn''t compile because you''re not returning anything.
    You can start by directly copying (don''t cut) the call to `window()` from `lib.rs`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数也无法编译，因为您没有返回任何内容。您可以开始直接复制（不要剪切）`lib.rs` 中的 `window()` 调用：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You don't need to bind a variable with `let` here. This still won't compile
    because of that `unwrap`. In this case, `web_sys::window` returns `Option<Window>`
    and `unwrap` will extract the `Window` object, or panic. None of that conforms
    to `Result<Window>`, and what we need to do instead is handle the case where `window`
    is somehow missing as an error.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里不需要用 `let` 绑定变量。由于那个 `unwrap`，这段代码仍然无法编译。在这种情况下，`web_sys::window` 返回 `Option<Window>`，`unwrap`
    将提取 `Window` 对象，或者引发 panic。这些都不符合 `Result<Window>`，我们需要做的是处理 `window` 以某种方式缺失的错误情况。
- en: Important Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When trying to mix and match `Option` and `Result`, there are two schools of
    thought – make `Result` into `Option` with `ok`, or convert `Result` into `Option`
    with `ok_or_else`. I prefer the second because while that will mean writing a
    lot of error messages that say "`<X>`" (not found), the alternative is losing
    useful error diagnostics.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试混合使用 `Option` 和 `Result` 时，有两种观点——使用 `ok` 将 `Result` 转换为 `Option`，或者使用 `ok_or_else`
    将 `Result` 转换为 `Option`。我更喜欢后者，因为虽然这意味着要写很多包含 "`<X>`"（未找到）的错误消息，但另一种选择是失去有用的错误诊断。
- en: 'To make this function work with the `Result<Window>` return type, which, remember,
    is a shorthand for `Result<Window, anyhow::Error>`, we''re going to use the `anyhow!`
    macro. So, to convert `Option` to `Result` and make this function compile, you
    can do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个函数与 `Result<Window>` 返回类型兼容，记住，这是一个 `Result<Window, anyhow::Error>` 的缩写，我们将使用
    `anyhow!` 宏。因此，为了将 `Option` 转换为 `Result` 并使这个函数编译，您可以这样做：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now you've got a function, `browser::window()`, which will return `Window` or
    the appropriate error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有一个函数，`browser::window()`，它将返回 `Window` 或适当的错误。
- en: Important Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Nightly Rust currently has an error called `NoneError` that helps bridge the
    gap between `Option` and `Result` types, but we'll stick to the standard for now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Nightly Rust 目前有一个名为 `NoneError` 的错误，它有助于在 `Option` 和 `Result` 类型之间架起桥梁，但我们现在将坚持使用标准。
- en: 'Finally, we can replace the call to `web_sys::window()` in `lib` with a call
    to `browser::window()` in `lib`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将 `lib` 中的 `web_sys::window()` 调用替换为 `lib` 中的 `browser::window()` 调用：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The call to `window()` will use `expect` for now to go ahead and crash the
    program if there is no window. Later, you''ll see we can use the `?` operator,
    but for the moment, we''ve got to work around `main_js` returning a `Result<(),
    JsValue>`. If that was the only place we were changing, the introduction of `anyhow`
    wouldn''t make any sense. Fortunately, when we repeat that process with a new
    `document` function in the `browser` module, you can see the advantage. We can
    skip going through each step of that process, and get to the end result:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`window()`调用将使用`expect`来确保如果没有窗口，程序会崩溃。稍后，你会看到我们可以使用`?`运算符，但到目前为止，我们必须绕过`main_js`返回`Result<(),
    JsValue>`。如果这是唯一需要更改的地方，引入`anyhow`就没有意义了。幸运的是，当我们用`browser`模块中的新`document`函数重复这个过程时，你可以看到优势。我们可以跳过那个过程的每个步骤，直接得到最终结果：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If this doesn't compile, don't forget to add `Document` to the `use` declarations
    at the top of the module. As we make these changes, you'll need to move `use`
    declarations into `browser`, but you'll be able to remove them from `lib.rs`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码无法编译，别忘了在模块顶部的`use`声明中添加`Document`。随着我们做出这些更改，你需要将`use`声明移动到`browser`中，但你将能够从`lib.rs`中删除它们。
- en: 'You can now actually shrink the two calls to `window()` and `document()` in
    `lib.rs` into one call, like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你实际上可以将`lib.rs`中的两个`window()`和`document()`调用缩减为一个调用，如下所示：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is one place in `lib.rs` where we''re using the window variable we just
    deleted. Near the bottom of `spawn_local` `Closure`, right after creating `interval_callback,`
    there is a call to `window.set_interval_with_callback_and_timeout_and_arguments_0`
    that can replace `window` with `browser::window().unwrap()`. That looks like the
    following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lib.rs`中有一个地方我们使用了刚刚删除的window变量。在`spawn_local` `Closure`的底部附近，在创建`interval_callback`之后，有一个调用`window.set_interval_with_callback_and_timeout_and_arguments_0`，可以用`browser::window().unwrap()`替换`window`。它看起来如下所示：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our next function will get the `canvas` object, but it''s a little more complicated
    than the previous two functions. We were pretty casual with the `unwrap` calls
    for that section, so we''ll have to do some converting to get more specific errors.
    The end result looks like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的函数将获取`canvas`对象，但比前两个函数要复杂一些。我们对那个部分的`unwrap`调用相当随意，所以我们需要做一些转换以获取更具体的错误。最终结果看起来像这样：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are a few things worth paying close attention to here. First, the `get_element_by_id`
    call is hardcoded to the `'canvas'` ID. We'll go ahead and leave that as is until
    it causes an issue later, but we're not going to make that configurable until
    we need to. Next, we used `ok_or_else` to convert `get_element_by_id` from `Option`
    to `Result`. Most interesting is the call to the `dyn_into` function. As discussed
    earlier, almost every function that calls into JavaScript will return a `JsValue`
    type, because JavaScript is a dynamically typed language. We know that the element
    returned by `get_element_by_id` will return `HtmlCanvasElement`, at least if we've
    retrieved the right JavaScript node, so we can convert it from `JsValue` to the
    correct element. This is what `dyn_into` does – it converts from `JsValue` to
    appropriate Rust types. In order to use `dyn_into`, you must import `wasm_bindgen::JsCast`,
    which rust-analyzer cannot automatically import. It can import `web_sys::HtmlCanvasElement`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个值得特别注意的地方。首先，`get_element_by_id`调用硬编码为`'canvas'` ID。我们将继续保留这个设置，直到它引起问题为止，但我们将不会在需要之前将其设置为可配置的。接下来，我们使用了`ok_or_else`将`get_element_by_id`从`Option`转换为`Result`。最有趣的是对`dyn_into`函数的调用。如前所述，几乎每个调用JavaScript的函数都会返回`JsValue`类型，因为JavaScript是一种动态类型语言。我们知道`get_element_by_id`返回的元素将返回`HtmlCanvasElement`，至少如果我们已经检索到了正确的JavaScript节点，我们可以将其从`JsValue`转换为正确的元素。这就是`dyn_into`的作用——它将`JsValue`转换为适当的Rust类型。为了使用`dyn_into`，你必须导入`wasm_bindgen::JsCast`，因为rust-analyzer无法自动导入。它可以导入`web_sys::HtmlCanvasElement`。
- en: 'We''ll create a `context` function that looks very similar:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个看起来非常相似的`context`函数：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One oddity you might see here is that we follow `map_err` immediately with `ok_or`.
    That's because `get_context` returns `Result<Option<Object>, JsValue>`, which
    the old code "solved" by calling `unwrap` twice. So what we do now is map the
    error (`JsValue`) to `Error` and then take the inner `Option` and map the `None`
    case to a value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里可能会看到一个奇怪的现象，那就是我们紧接着使用`map_err`和`ok_or`。这是因为`get_context`返回`Result<Option<Object>,
    JsValue>`，而旧代码通过两次调用`unwrap`来“解决”这个问题。所以我们现在所做的就是将错误（`JsValue`）映射到`Error`，然后取内部的`Option`并将`None`情况映射到一个值上。
- en: 'Remember that if you''re following along and having trouble compiling, update
    your `use` declarations. Let''s pick up the pace a little. We can add a function
    for `spawn_local`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你在跟随并遇到编译困难，请更新你的 `use` 声明。让我们稍微加快一点速度。我们可以为 `spawn_local` 添加一个函数：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are writing a wrapper like this and aren't sure what the signature should
    be, start by looking at the function you're wrapping and mimic its signature.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写这样的包装器并且不确定签名应该是什么，首先看看你正在包装的函数，并模仿其签名。
- en: 'Let''s also add fetching `JSON` to `browser`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也在 `browser` 中添加 `JSON` 获取：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I expanded `fetch_json` into two functions because I think `fetch_with_str`
    is going to be reusable, but it's not strictly necessary. The `fetch_json` function
    borders on not belonging in the `browser` module. On the one hand, it exclusively
    calls into the `wasm_bindgen` API, mapping the `JsValue` errors to standard `Error`s;
    on the other hand, there is a tiny amount of behavior there when we decide to
    get `JSON` off of the response. Ultimately, that's a bit of a judgment call.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 `fetch_json` 扩展为两个函数，因为我认为 `fetch_with_str` 将会可重用，但这并不是严格必要的。`fetch_json`
    函数几乎不属于 `browser` 模块。一方面，它专门调用 `wasm_bindgen` API，将 `JsValue` 错误映射到标准的 `Error`；另一方面，当我们决定从响应中获取
    `JSON` 时，那里有一点点行为。最终，这有点像是一种判断。
- en: 'Having written all those functions, you can go back to the `lib.rs` module
    and update the main function to use the new ones. As you can see, it''s starting
    to shrink significantly, as the top should look like the following, using the
    new functions from the browser module where appropriate:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 写完所有这些函数后，你可以回到 `lib.rs` 模块并更新主函数以使用新的函数。正如你所见，它已经开始显著缩小，顶部应该看起来像以下这样，在适当的地方使用浏览器模块中的新函数：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that we removed all the intermediate calls to `window` and `context`
    in favor of one call to `context`. We've also just made a call into `fetch_json`
    using `expect` to call out errors. Finally, you'll see one compiler error when
    you do this on the `window.set_interval_with_callback_and_timeout_and_arguments_0`
    line. You can fix that by replacing `window` with `browser::window().unwrap()`.
    The `unwrap` bit is ugly, but we'll keep refactoring until that's gone as well.
    It's not reproduced in the preceding snippet, but you can also delete the `fetch_json`
    function from `lib.rs`; it's not being used anymore.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们移除了所有中间对 `window` 和 `context` 的调用，转而使用一个对 `context` 的调用。我们还刚刚使用 `expect`
    调用 `fetch_json` 来抛出错误。最后，你会在 `window.set_interval_with_callback_and_timeout_and_arguments_0`
    行看到一条编译错误。你可以通过将 `window` 替换为 `browser::window().unwrap()` 来修复它。`unwrap` 部分看起来很丑，但我们会继续重构，直到它也消失。它在上面的代码片段中没有重现，但你也可以从
    `lib.rs` 中删除 `fetch_json` 函数；它不再被使用了。
- en: This brings us to the next section to extract – loading an image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了下一个要提取的部分——加载图像。
- en: Loading an image
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载图像
- en: 'I bet you thought you were done with loading the image, didn''t you? Well,
    we will be as soon as we turn it into a function. Let''s look at the original
    implementation for a moment again:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你认为你已经完成了图像的加载，不是吗？好吧，当我们将其转换为函数时，我们就会完成。让我们暂时再次看看原始实现：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At first glance, this looks like it's one function in our `browser` module,
    `load_image`, but on closer reflection, there's a lot here for just one function.
    For instance, if you so choose, you can create an image element without worrying
    about whether it's going to be loaded, or you might be willing to use `set_src`
    without concerning yourself with whether or not it's loaded. No, all that stuff
    after `let image = web_sys::HtmlImageElement::new().unwrap()` is really engine
    behavior. That means it's time for us to create our second module, `engine`!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是 `browser` 模块中的一个函数，`load_image`，但仔细思考后，这里有很多内容只是一个函数。例如，如果你选择，你可以创建一个图像元素而不用担心它是否会被加载，或者你可能愿意使用
    `set_src` 而不考虑它是否已加载。不，`let image = web_sys::HtmlImageElement::new().unwrap()`
    之后的所有内容实际上是引擎行为。这意味着是我们创建第二个模块 `engine` 的时候了！
- en: 'The `engine` module will contain libraries and functions that we will use throughout
    our game. We are `engine` module. In fact, to break down this behavior, we''ll
    follow a few steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`engine` 模块将包含我们将贯穿整个游戏使用的库和函数。我们是 `engine` 模块。实际上，为了分解这种行为，我们将遵循几个步骤：'
- en: Create a `browser` function, `new_image`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `browser` 函数，`new_image`。
- en: Create a `browser` function to create JS closures.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `browser` 函数来创建 JS 闭包。
- en: Create an `engine` module.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `engine` 模块。
- en: Create an `engine` function, `load_image`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `engine` 函数，`load_image`。
- en: 'Let''s start with the changes to `browser`; we''ll create two new functions
    to make `Closure` and an image:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对`browser`的更改开始；我们将创建两个新函数来创建`Closure`和图像：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first function is just a wrapper around `HtmlImageElement`; there's not
    much to explain. In the future, we may decide we want our own type for images,
    but for now, we'll stick with the browser-provided type. The `closure_once` function
    is complicated by its type signature. In this case, we just mimic the exact same
    type signature of the `Closure::once` function from `wasm_bindgen`. Later, we'll
    write some utility functions for the `Closure` types to make working with them
    easier, but for this one, we'll just create a straight wrapper.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数只是`HtmlImageElement`的一个包装器；没有太多可解释的。在未来，我们可能会决定我们想要自己的图像类型，但现在我们将坚持使用浏览器提供的类型。`closure_once`函数因其类型签名而变得复杂。在这种情况下，我们只是模仿`wasm_bindgen`中的`Closure::once`函数的完全相同的类型签名。稍后，我们将为`Closure`类型编写一些实用函数，以便更容易地使用它们，但在这个例子中，我们只创建一个直接的包装器。
- en: Important Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A compelling argument can be made that we should be converting even more types
    in this module. Specifically, we should use our own types for `Closure`, `HtmlImageElement`,
    and other browser-provided types. It's possible that's a better approach, but
    for now, we're going to stick with the types provided in the interest of both
    learning the material and keeping to a simple architecture. Like all decisions
    in programming, it's a trade-off.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有力地论证，我们应该在这个模块中转换更多类型。具体来说，我们应该使用我们自己的类型来表示`Closure`、`HtmlImageElement`和其他浏览器提供的类型。这可能是一个更好的方法，但为了现在，我们将坚持使用提供的类型，以便学习材料并保持简单架构。像所有编程决策一样，这是一个权衡。
- en: 'That covers *step 1* and *step 2*, and *step 3* is quick – create a file named
    `engine.rs` in the source directory and add a `mod engine` declaration to `lib.rs`.
    Now for *step 4*, the one we''ve been dreading. In `engine.rs`, add the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了*步骤1*和*步骤2*，*步骤3*很快——在源目录中创建一个名为`engine.rs`的文件，并将`mod engine`声明添加到`lib.rs`中。现在对于*步骤4*，我们一直害怕的那个。在`engine.rs`中，添加以下内容：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I''m intentionally leaving out the `use` statements so that you get used to
    adding them and thinking about which declarations you need and are using. However,
    there are two traps to this code that I want to call out:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意省略了`use`语句，这样你就能习惯于添加它们，并思考你需要和正在使用哪些声明。然而，这段代码有两个陷阱，我想指出：
- en: In order for `unchecked_ref` to compile, you need to use `wasm_bindgen:JsCast`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使`unchecked_ref`编译，你需要使用`wasm_bindgen:JsCast`。
- en: When you import `channel`, make sure you choose `futures::channel::oneshot::channel`.
    There are a few different implementations of `channel`, and if you grab the wrong
    one by mistake, this code won't compile.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你导入`channel`时，确保你选择`futures::channel::oneshot::channel`。`channel`有几种不同的实现，如果你不小心抓错了，这段代码将无法编译。
- en: When in doubt, take a look at `lib.rs` and verify which dependencies are being
    used there because that's where this code is being pulled from.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定时，看看`lib.rs`并验证哪些依赖项在那里被使用，因为这是这段代码被提取的地方。
- en: Returning to the code we added, note that we're using our new `browser` functions
    throughout, with no direct dependencies on the `wasm-bindgen` functions. We are
    still dependent on `wasm_bindgen` for the `Closure` and `JSValue` types, as well
    as the `unchecked_ref` function, but we've reduced the amount of direct platform
    dependencies. Our only JS dependency is on `HtmlImageElement`. Now, take a look
    at the very beginning of the function and you'll see the `new_image` call can
    use the `?` operator to early return in the event of an error, with a standard
    Rust error type. This is why we mapped those errors in the `browser` functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们添加的代码，请注意我们一直在使用我们新的`browser`函数，没有直接依赖于`wasm-bindgen`函数。我们仍然依赖于`wasm-bindgen`的`Closure`和`JSValue`类型，以及`unchecked_ref`函数，但我们已经减少了直接平台依赖的数量。我们唯一的JS依赖是`HtmlImageElement`。现在，看看函数的非常开始处，你会看到`new_image`调用可以使用`?`运算符在出现错误时提前返回，使用标准的Rust错误类型。这就是为什么我们在`browser`函数中映射了那些错误的原因。
- en: Moving past the first two lines of the method, the rest of the function is largely
    the same as before, replacing any direct calls to `wasm-bindgen` functions with
    their corresponding calls in `browser`. We've changed the channel to send `anyhow::Result`
    and used `anyhow!` in `error_callback`. This then allows us to end the function
    with a call to `complete_rx.await??` and `Ok(image)`. Those two `??` are not a
    misprint; `complete_rx.await` returns `Result<Result<(), anyhow::Error>, Canceled>`.
    Since `anyhow::Error` and `Canceled` both conform to `std::error::Error`, we can
    handle those errors with `?` each time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的第一行之后，函数的其余部分与之前基本相同，将任何直接调用`wasm-bindgen`函数替换为`browser`中的相应调用。我们已经将通道改为发送`anyhow::Result`，并在`error_callback`中使用`anyhow!`。这然后允许我们通过调用`complete_rx.await??`和`Ok(image)`来结束函数。这两个`??`不是误印；`complete_rx.await`返回`Result<Result<(),
    anyhow::Error>, Canceled>`。由于`anyhow::Error`和`Canceled`都符合`std::error::Error`，我们可以通过每次使用`?`来处理这些错误。
- en: We still have two warnings in this function because both of the calls to `send`
    return `Result` that we aren't dealing with. We can't just use `?` because those
    results are wrapped in the `Closure` types, so we'll put off dealing with those
    unlikely errors for now and will cover error logging in [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203),
    *Testing, Debugging, and Performance*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个函数中仍然有两个警告，因为两个`send`调用都返回了我们没有处理的`Result`。我们不能只是使用`?`，因为这些结果被`Closure`类型所包裹，所以我们将推迟处理这些不太可能发生的错误，并在[*第9章*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203)中介绍错误记录，*测试、调试和性能*。
- en: 'Now that you''ve done all that you should be able to, replace the code in `main`
    with a call to our new function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了所有这些，你应该能够替换`main`中的代码，调用我们新的函数：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Nothing about loading `Sheet` has changed; that's just there to make sure you
    put this in the right place. After that, the code for animating our little **Red
    Hat Boy** (**RHB**) starts, but we're not going to be using that at all. That
    will be replaced with our game loop, which we'll start introducing now.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加载`Sheet`的内容没有任何变化；那只是为了确保你把它放在正确的位置。之后，动画我们的小**红帽男孩**（**RHB**）的代码开始，但我们根本不会使用它。那将被我们的游戏循环所取代，我们现在开始介绍它。
- en: Creating a game loop
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏循环
- en: 'The core of this game, and virtually every game ever, is just an infinite loop.
    You can boil them all down to something like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏的核心，以及几乎所有游戏，都只是一个无限循环。你可以把它们简化成这样：
- en: '![Figure 3.3 – A basic game loop](img/Figure_3.03_B17151.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 基本游戏循环](img/Figure_3.03_B17151.jpg)'
- en: Figure 3.3 – A basic game loop
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 基本游戏循环
- en: 'That means, theoretically, these are trivial to implement, as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，从理论上讲，这些实现起来非常简单，如下所示：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At its core, that''s what we''re going to write, but as you probably guessed,
    if it was that simple, I wouldn''t have devoted an entire chapter to it. No, there
    are two problems we are going to be dealing with as we write it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 核心来说，这就是我们要写的，但正如你可能猜到的，如果它那么简单，我就不会专门用一整章来介绍它了。不，我们在编写过程中将处理两个问题：
- en: '`requestAnimationFrame` function.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`函数。'
- en: '**Frame rates and physics**: The preceding loop we wrote would run as fast
    as the computer could go. Well, is every computer on the internet the same speed?
    No, of course not, so we''ll need to make sure we can account for the differences
    between machine speeds in our loop, as best we can. We''ll do that with what''s
    called a **fixed-step** game loop.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧率和物理**：我们之前编写的循环会以计算机能运行的最快速度运行。嗯，互联网上的每台计算机速度都一样吗？当然不是，所以我们需要确保我们能在循环中考虑到机器速度的差异，尽可能做到这一点。我们将使用所谓的**固定步长**游戏循环来实现。'
- en: Important Note
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: You could probably write a book on game loops if you so chose, but this section
    owes a heavy debt to [https://gameprogrammingpatterns.com/game-loop.html](https://gameprogrammingpatterns.com/game-loop.html)
    and [https://gafferongames.com/post/fix_your_timestep/](https://gafferongames.com/post/fix_your_timestep/).
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以写一本关于游戏循环的书，但本节在很大程度上借鉴了[https://gameprogrammingpatterns.com/game-loop.html](https://gameprogrammingpatterns.com/game-loop.html)和[https://gafferongames.com/post/fix_your_timestep/](https://gafferongames.com/post/fix_your_timestep/)。
- en: RequestAnimationFrame
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RequestAnimationFrame
- en: 'We''ll start with the `requestAnimationFrame` function, which is a browser
    function that "requests" a new frame draw as soon as possible. The browser then
    fits that in frame draw in between handling things such as mouse clicks, operating
    system events, and cat videos. You might think that would be very slow, but in
    fact, typically, it''s able to render at 60 frames per second, provided your game
    can keep up. The catch is that unlike our `setInterval` call from earlier, this
    function needs to be called at the end of every animation. A fairly straightforward
    JavaScript version of an animation might look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`requestAnimationFrame`函数开始，这是一个浏览器函数，它“请求”尽快绘制新帧。然后浏览器将这个帧绘制在处理鼠标点击、操作系统事件和猫咪视频等事物之间。您可能会认为这会非常慢，但实际上，通常情况下，它能够以每秒60帧的速度渲染，只要您的游戏能够跟上。问题是，与之前我们的`setInterval`调用不同，这个函数需要在每个动画的末尾被调用。一个相当直接的JavaScript动画版本可能看起来像这样：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, `requestAnimationFrame` is called with the `animate` function as its parameter.
    The browser then calls the `animate` function on the next frame, which draws and
    then requests the next frame. This looks like an infinite loop, but, in fact,
    doesn't block the browser because of the calls to `requestAnimationFrame`. This
    also takes a parameter, `now`, which is a timestamp in milliseconds of when the
    callback function was started. We'll use this to fix our physics as we evolve
    our game loop, but writing a game loop in Rust is a little weird because of the
    borrowing guarantees, so let's start by writing a very basic one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`requestAnimationFrame`使用`animate`函数作为其参数被调用。浏览器随后在下一次帧上调用`animate`函数，绘制并请求下一个帧。这看起来像是一个无限循环，但实际上，由于`requestAnimationFrame`的调用，它并不会阻塞浏览器。这还接受一个参数`now`，它是回调函数开始时的毫秒时间戳。我们将使用这个时间戳来调整我们的物理引擎，随着游戏循环的演变。实际上，在Rust中编写游戏循环有点奇怪，因为借用保证，所以让我们先写一个非常基本的循环：
- en: 'You can start by adding a simple wrapper for `requestAnimationFrame` to `browser`,
    as shown in the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从为`requestAnimationFrame`添加一个简单的包装器开始，如以下代码所示：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Function` type is a pure JavaScript type and is only available in the
    `js-sys` package. While we could import that, I''d rather not add another crate
    dependency if possible; however, we don''t actually have to use the `Function`
    type directly if we make a small change to the function signature and the implementation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function`类型是一个纯JavaScript类型，仅在`js-sys`包中可用。虽然我们可以导入它，但如果可能的话，我宁愿不添加另一个crate依赖；然而，如果我们对函数签名和实现进行一些小的修改，实际上我们不必直接使用`Function`类型：'
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Instead of taking `&Function`, our `request_animation_frame` will take `&Closure<dyn
    FnMut(f64)>` as its parameter. Then, it will call `callback.as_ref().unchecked_ref()`
    when calling the `web-sys` version of `request_animation_frame`. This converts
    `Closure` into `Function`, without requiring an explicit dependency on the `Function`
    type, and it''s worth thinking about when you''re creating your own versions of
    these functions. The makers of `web-sys` have to match every single potential
    use case, and as such, they are going to create the widest possible interfaces.
    As an application programmer, you do not need most of what''s in that library.
    Therefore, you can and should narrow the interface to your own use cases, making
    it easier for you to work with. In fact, in order to make things a little cleaner,
    we''ll convert that into a type, with one small change:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用`&Function`，而是`request_animation_frame`将接受`&Closure<dyn FnMut(f64)>`作为其参数。然后，在调用`web-sys`版本的`request_animation_frame`时，它将调用`callback.as_ref().unchecked_ref()`。这会将`Closure`转换为`Function`，而不需要显式依赖`Function`类型，这在您创建这些函数的自己的版本时值得思考。`web-sys`的制作者必须匹配每个潜在的使用场景，因此他们将创建尽可能广泛的接口。作为一个应用程序程序员，您不需要那个库中的大部分内容。因此，您可以将接口缩小到自己的使用场景，这样会使您的工作更加容易。实际上，为了使事情更加简洁，我们将将其转换为一种类型，其中有一个小的变化：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Moving on from my mini-rant, you might think you can now write a simple game
    loop, like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的小抱怨继续，您可能会认为现在可以编写一个简单的游戏循环，如下所示：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Ah, if only, but remember that we need to pass a JavaScript `Closure`, not
    a Rust `fn`. Using the `Closure::once` that we used before won''t work because
    this closure will be called more than once, but fortunately, there''s `Closure::wrap`,
    which will do just that. We''ll create a function in `browser` to create a `Closure`
    specific to the `request_animation_frame` function, called `create_raf_closure`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，如果只有，但请记住，我们需要传递一个JavaScript `Closure`，而不是Rust `fn`。使用我们之前使用的`Closure::once`将不起作用，因为这个闭包将被多次调用，但幸运的是，有`Closure::wrap`，它将做到这一点。我们将在`browser`中创建一个针对`request_animation_frame`函数的特定`Closure`的函数，称为`create_raf_closure`：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The function being passed in has a `'static` lifetime. Any `FnMut` passed into
    this function cannot have any non-static references. This wasn't a decision on
    my part; it's a requirement of the `Closure::wrap` function we'll be calling into.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的函数具有`'static`生命周期。任何传递给这个函数的`FnMut`都不能有任何非静态引用。这不是我个人的决定；这是我们将要调用的`Closure::wrap`函数的要求。
- en: Tip
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For more information on static lifetimes, take a look at the *Rust by Example*
    book, available for free here: [https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html](https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于静态生命周期的信息，请查看*Rust by Example*书籍，免费在此处提供：[https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html](https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html)。
- en: 'Speaking of `Closure::wrap`, let''s wrap it in a `closure_wrap` function so
    that the code we just added will compile, which looks like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 说到`Closure::wrap`，让我们将其包裹在`closure_wrap`函数中，这样我们刚刚添加的代码就可以编译了，如下所示：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is another one of those wrapper functions where we are just matching the
    same signature as the function being wrapped – `Closure::wrap`. Because the `wrap`
    function on `Closure` creates a `Closure` that can be called multiple times, it
    needs to be wrapped in a `Box` and stored on the heap.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包装函数，我们只是匹配被包装函数的相同签名——`Closure::wrap`。因为`Closure`上的`wrap`函数创建了一个可以多次调用的`Closure`，所以它需要被包裹在`Box`中并存储在堆上。
- en: Tip
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The nightly build of `wasm-bindgen` provides a more ergonomic `new` function
    that handles the boxing for you. We'll stick to the stable build in this book,
    but you are welcome to try nightly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-bindgen`的夜间构建提供了一个更方便的`new`函数，它可以为你处理装箱。在这本书中，我们将坚持使用稳定构建，但你可以尝试使用夜间构建。'
- en: 'Now that you know the basic game loop and how to call `request_animation_frame`,
    you might think, "I''ve got this" and create the game loop as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了基本的游戏循环和如何调用`request_animation_frame`，你可能认为，“我已经搞定了”，并创建如下游戏循环：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is closer, but it's not there yet. Remember earlier that the `Closure`
    we pass to `create_raf_closure` has to have a `'static` lifetime, meaning everything
    that the `Closure` references must be owned by the closure. That's not the case
    right now. The `animate` variable is owned by the current scope and will be destroyed
    when that scope completes. Of course, `animate` is itselfthe `Closure` because
    this is a self-referencing data structure. The `animate` variable is the `Closure`
    but is also referenced inside the `Closure`. This is a classic Rust problem because
    the `borrow` checker cannot allow it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这更接近了，但还不是最终结果。记得之前提到的，我们传递给`create_raf_closure`的`Closure`必须具有`'static`生命周期，这意味着`Closure`引用的所有内容都必须由闭包拥有。目前并不是这样。`animate`变量属于当前作用域，并在该作用域完成时被销毁。当然，`animate`本身就是`Closure`，因为这是一个自引用数据结构。`animate`变量是`Closure`，但也在`Closure`内部被引用。这是Rust的一个经典问题，因为`borrow`检查器不允许这样做。
- en: Imagine what would happen if this wasn't the case – if `animate` could be referenced
    in the `Closure` but be owned by the scope outside the `Closure`. It would be
    destroyed when the program exited this scope, and `Closure` would no longer be
    valid – a `Null` pointer error, and a crash. This is the trouble with a self-referencing
    data structure, so we'll need a way to work around the `borrow` checker.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果情况不是这样会怎样——如果`animate`可以在`Closure`中被引用，但属于`Closure`外部的作用域。当程序退出这个作用域时，它将被销毁，而`Closure`将不再有效——这是一个`Null`指针错误，并且会导致崩溃。这就是自引用数据结构的问题，因此我们需要找到一种绕过`borrow`检查器的方法。
- en: 'With nowhere to put this code just yet, let''s have another crack at a hypothetical
    loop:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目前还没有地方放置这段代码，让我们再次尝试一个假设的循环：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Right now, I kinda wish I was writing JavaScript, but let''s work slowly through
    this code. What we''re doing is creating two references to the same place in memory,
    using `Rc` `struct`, allowing us to both take `f` and `g` and point them at the
    same thing but also move `f` into `animate Closure`. The other trick is that they
    both point to `Option` so that we can move `f` into `Closure` before it is completely
    defined. Finally, when we assign to `g` the `Closure` with `*g.borrow_mut() =
    animate`, we `f` because they are pointing to the same place. Did you get all
    that? No, me neither. Let''s go through the types really quickly to reiterate
    what we did. `f` is set to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我有点希望我在写JavaScript，但让我们慢慢地通过这段代码。我们正在做的是创建两个指向内存中同一位置的引用，使用`Rc` `struct`，使我们能够同时将`f`和`g`指向同一事物，同时将`f`移动到`animate
    Closure`中。另一个技巧是它们都指向`Option`，这样我们可以在`f`完全定义之前将其移动到`Closure`中。最后，当我们通过`*g.borrow_mut()
    = animate`将`Closure`赋值给`g`时，我们`f`因为它们指向同一位置。你明白了吗？不，我也不明白。让我们快速回顾一下类型，以重申我们做了什么。`f`被设置为以下内容：
- en: '`Rc` to create a reference-counted pointer'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Rc`创建一个引用计数指针
- en: '`RefCell` to allow for interior mutability'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RefCell`允许内部可变性
- en: '`Option` to allow us to assign `f` to `None`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`允许我们将`f`赋值为`None`'
- en: '`LoopClosure` to hold a mutable `Closure` that matches the `request_animation_frame`
    parameter'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoopClosure`用于持有与`request_animation_frame`参数匹配的可变`Closure`'
- en: '`g` is then set to a clone of `f` so that they point to the same thing, and
    `f` is moved into `animate` `Closure`. `g` is assigned to `animate` via the dereference
    `*` operator and `borrow_mut` functions. Because `f` points to the same place
    as `g`, it will also contain `animate Closure`. Finally, we can call `request_animation_frame`,
    both outside and inside `Closure`, by borrowing it, converting it to a reference,
    and calling `unwrap` to actually get the real `Closure`. Yes, `unwrap` is back;
    we''ll deal with one of those when we create our real function. Finally, `g` can
    be destroyed when it leaves scope because `f` is still in `Closure` and will keep
    the memory around.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`g`被设置为`f`的一个克隆，这样它们就指向同一事物，`f`被移动到`animate` `Closure`中。通过解引用`*`运算符和`borrow_mut`函数，`g`被赋值给`animate`。因为`f`指向与`g`同一位置，它也将包含`animate
    Closure`。最后，我们可以通过借用它，将其转换为引用，并调用`unwrap`来实际获取真正的`Closure`来调用`request_animation_frame`。是的，`unwrap`又回来了；我们将在创建我们的真实函数时处理其中一个。最后，当`g`离开作用域时，它可以被销毁，因为`f`仍然在`Closure`中，并将保留内存。
- en: Important Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Once again, I'd love to take credit for this code, but the truth is that it's
    largely defined in the `wasm-bindgen` guide at [https://bit.ly/3v5FG3j](https://bit.ly/3v5FG3j).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我很想为这段代码争取功劳，但事实是它大部分定义在`wasm-bindgen`指南中，[https://bit.ly/3v5FG3j](https://bit.ly/3v5FG3j)。
- en: Now that we know what the core of our game loop is going to look like, how do
    we integrate it with a game?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了我们的游戏循环的核心将是什么样子，我们该如何将它与一个游戏整合呢？
- en: A game trait
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个游戏特性
- en: To write our game loop, we have a few options. We could just write the game
    in the loop, but that would look suspiciously similar to what we started with
    before. We could create a `GameLoop` struct with functions for `update` and `draw`,
    which is a significant improvement but still ties everything into one structure.
    We're going to go slightly beyond that and take inspiration from a popular game
    framework, XNA, or MonoGame in its modern incarnation. In the XNA framework, the
    game developer will implement a `Game` type, with methods for `update` and `draw`.
    This is slightly more complex than jamming all the code into one place but is
    significantly less so than a complete entity-component framework. It should work
    well for our purposes since it starts small and should allow for expansion as
    the game gets larger. There's a reason XNA was very successful.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写我们的游戏循环，我们有几种选择。我们可以直接在循环中编写游戏，但这会与之前开始的样子非常相似。我们可以创建一个`GameLoop`结构体，包含`update`和`draw`函数，这是一个显著的改进，但仍然将所有内容绑定到一个结构体中。我们将稍微超出这个范围，并从流行的游戏框架XNA或其现代版本MonoGame中汲取灵感。在XNA框架中，游戏开发者将实现一个`Game`类型，包含`update`和`draw`方法。这比将所有代码都堆在一个地方稍微复杂一些，但比完整的实体-组件框架要简单得多。它应该适合我们的目的，因为它从小的开始，并且随着游戏的扩大应该允许扩展。XNA之所以非常成功，是有原因的。
- en: Important Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can learn about XNA's modern equivalent, MonoGame, at [https://www.monogame.net/](https://www.monogame.net/).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.monogame.net/](https://www.monogame.net/)了解XNA的现代等价物，MonoGame。
- en: 'We''ll create a `start` function that accepts anything that implements the
    `Game` trait. The `Game` trait will start with two functions, `update` and `draw`.
    We''ll run that through our game loop to first update and then draw our scene.
    All of this will go into the `engine` module; indeed, arguably, this is our entire
    "engine." Let''s start with the simple version – first, the trait:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个接受任何实现了`Game`特质的`start`函数。`Game`特质将包含两个函数，`update`和`draw`。我们将通过游戏循环首先更新然后绘制场景。所有这些都将放入`engine`模块；实际上，可以说这是我们整个“引擎”。让我们从简单的版本开始——首先，是特质：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So far so good. Note how the `draw` function takes `CanvasRenderingContext2d`
    as a parameter. Now for the rest of the loop – you can add this after the `Game`
    trait or `load_image`; it doesn''t really matter as long as it''s in the `engine`
    module:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。注意`draw`函数如何接受`CanvasRenderingContext2d`作为参数。现在，对于循环的其余部分——你可以在`Game`特质或`load_image`之后添加这个，实际上这并不重要，只要它在`engine`模块中即可：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a bit larger but it's nothing you haven't seen before. We're going to
    create a `GameLoop` struct with no data and add a `SharedLoopClosure` type to
    simplify the type of the `f` and `g` variables. Then, we'll add an implementation
    of `GameLoop` with one method, `start`, that takes the `Game` trait as a parameter.
    Note that the trait is `'static` because anything moved into the "raf" closure
    has to be `'static`. We follow the snippets we used before to set up our `request_animation_frame`
    loop, and the key change is on the inside where we update and then draw, passing
    the `draw` function `CanvasRenderingContext2d`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这稍微大一点，但没有什么是你以前没见过的。我们将创建一个没有数据的`GameLoop`结构体，并添加一个`SharedLoopClosure`类型来简化`f`和`g`变量的类型。然后，我们将添加一个`GameLoop`的实现，包含一个名为`start`的方法，该方法接受`Game`特质作为参数。请注意，特质是`'static`，因为任何移动到“raf”闭包中的内容都必须是`'static`。我们遵循之前使用的片段来设置我们的`request_animation_frame`循环，关键变化在于内部，我们在更新后绘制，传递`draw`函数的`CanvasRenderingContext2d`。
- en: There's a problem with this kind of naive game loop. Typically, `request_animation_frame`
    runs at 60 frames per second, but if either `update` or `draw` takes longer than
    1/60th of a second, it will slow down, making the game move more slowly. A long
    time ago, I recall beating levels by turning off the "**Turbo**" button on my
    desktop, making it possible to beat previously impossible challenges because the
    game became easier to play at slower speeds. Since we want a consistent experience
    across processor speeds, we'll take a common approach called "fixing" the time
    step.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单游戏循环存在一个问题。通常，`request_animation_frame`每秒运行60帧，但如果`update`或`draw`任一函数的执行时间超过1/60秒，它将减慢速度，使游戏运行得更慢。很久以前，我记得通过关闭桌面上的“**Turbo**”按钮来击败关卡，这使得以前不可能的挑战变得容易，因为游戏在较慢的速度下更容易玩。由于我们希望在处理器速度不同的情况下保持一致的游戏体验，我们将采取一个称为“固定”时间步的通用方法。
- en: Fixing our time step
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复我们的时间步
- en: 'You might notice that the `update` function we wrote doesn''t take `perf` as
    a parameter; in fact, it''s unused. Now, imagine trying to simulate a dog running
    across the screen, with no knowledge of how much time has passed between frames.
    Depending on the computer and your guess, the dog could saunter from left to right,
    or shoot past like a bullet. What we could do is send the delta time on each update,
    which can work but gets complicated very quickly. Instead, we''ll assume every
    single tick takes the same amount of time, 1/60th of a second, and call `update`
    several times to "catch up" if we fall behind. It looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们编写的`update`函数没有接受`perf`作为参数；实际上，它是未使用的。现在，想象一下尝试模拟一只狗在屏幕上奔跑，没有任何关于帧间时间间隔的知识。根据计算机和你的猜测，狗可能会悠闲地从左到右漫步，或者像子弹一样飞过去。我们可以做的是在每个更新时发送delta时间，这可以工作，但会很快变得复杂。相反，我们将假设每个tick的时间相同，即1/60秒，并在落后时多次调用`update`以“赶上”。看起来是这样的：
- en: '![Figure 3.4 – A fixed step game loop](img/Figure_3.04_B17151.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 固定步长游戏循环](img/Figure_3.04_B17151.jpg)'
- en: Figure 3.4 – A fixed step game loop
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 固定步长游戏循环
- en: 'This isn''t a perfect solution; if our game is very slow, it''ll grind to a
    halt, but it should be good enough for our purposes. This is why I had us create
    a `GameLoop` struct – to track the time of the last update. We''ll add two fields
    to the `GameLoop` struct:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完美的解决方案；如果我们的游戏非常慢，它将陷入停滞，但应该足够满足我们的需求。这就是为什么我让我们创建了一个`GameLoop`结构体——为了跟踪上一次更新的时间。我们将在`GameLoop`结构体中添加两个字段：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This adds a constant for the length of a frame, converted to milliseconds.
    We''ll track when the previous frame was requested in the `last_frame` field,
    and we''ll accumulate a delta that totals up the physics time since the last render.
    It''s not quite the same thing twice, as you''ll see when we implement that counter
    in the `start` function. Speaking of that function, we''ll need to initialize
    a mutable `GameLoop` at the beginning of that function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了一个表示帧长度的常量，转换为毫秒。我们将在`last_frame`字段中跟踪上一帧何时被请求，并将累积一个delta，总计自上次渲染以来的物理时间。这并不完全相同，正如你将在`start`函数中实现该计数器时看到的那样。说到那个函数，我们将在该函数的开始处初始化一个可变的`GameLoop`：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This initializes `GameLoop` appropriately, using `now` as the time of the last
    frame instead of `0` so that our loop doesn''t perform several million updates
    before the first render. `browser::now()` hasn''t been implemented yet, so you''ll
    need to add it to the `browser` module:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这以适当的方式初始化了`GameLoop`，使用`now`作为上一帧的时间而不是`0`，这样我们的循环就不会在第一次渲染之前执行数百万次更新。`browser::now()`尚未实现，所以你需要将其添加到`browser`模块中：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is just a wrapper around the web browser's `now` function. If you've been
    diligently following, you will probably recognize that this causes a compiler
    error. You'll need to add the "`Performance`" feature flag to the `web-sys` features
    list to bring in that function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个围绕网络浏览器`now`函数的包装器。如果你一直认真跟随，你可能会认识到这会导致编译错误。你需要将"`Performance`"功能标志添加到`web-sys`功能列表中，以引入该函数。
- en: 'Now that we''ve created a game loop object, inside the `request_animation_frame`
    closure, we''ll add our accumulator:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个游戏循环对象，在`request_animation_frame`闭包内部，我们将添加我们的累加器：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What's changed since last time is that instead of just calling the `update`
    function immediately, we calculate the difference between `perf`, which if you
    remember from earlier is a high-res timestamp of the time that the `request_animation_frame`
    function started executing callback functions. We get the difference between now
    (in `perf`) and the previous frame and add that to `accumulated_delta`. Then,
    we compare this to our desired `FRAME_SIZE` (that's 1/60th of a second), and if
    there's `update`. Then we subtract the frame size from the delta. What is the
    effect of all this? If `game.draw` takes too long so that we cannot complete 1
    frame in 1/60th of a second, the code will run extra updates to catch up.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与上次相比，变化的是我们不再立即调用`update`函数，而是计算`perf`与`request_animation_frame`函数开始执行回调函数的时间之间的差异。如果你记得，`perf`是一个高精度时间戳。我们获取现在（在`perf`中）和上一帧之间的差异，并将其添加到`accumulated_delta`中。然后，我们将其与期望的`FRAME_SIZE`（那是1/60秒）进行比较，如果有`update`。然后我们从delta中减去帧大小。这一切的效果是什么？如果`game.draw`执行时间过长，以至于我们无法在1/60秒内完成1帧，代码将运行额外的更新来赶上。
- en: An example is helpful here. Assume you started playing the game at time `0`,
    the beginning of the world. When the first callback executes for `request_animation_frame`
    its probably very close to `0`, perhaps as low as `1` millisecond, because there's
    no delay on the first frame. The code will add that to `accumulated_delta` and
    then compare it to `FRAME_SIZE` and see that there hasn't been enough delta accumulation,
    so `update` is skipped. The `last_frame` value is stored (again, we'll say it's
    `1`), the screen is drawn, and then `request_animation_frame` is called.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里举一个例子很有帮助。假设你在世界开始的时间`0`开始玩游戏。当第一次执行`request_animation_frame`回调时，它可能非常接近`0`，可能低至`1`毫秒，因为没有在第一帧上延迟。代码会将这个值加到`accumulated_delta`上，然后与`FRAME_SIZE`比较，发现积累的delta还不够，所以跳过`update`。`last_frame`值被存储（我们再次说它是`1`），屏幕被绘制，然后调用`request_animation_frame`。
- en: The second time though, the value of `perf` is likely to be about the size of
    the first frame. We'll use `17` milliseconds for simple math. So `perf` is `17`;
    subtract from it the `last_frame`, which is `1`, and add `16` milliseconds to
    `accumulated_delta`. The new value of `accumulated_delta` is `17`, so the game
    is updated once and `accumulated_delta` is reduced to `1`. The game continues
    with one update to one draw until something goes wrong. The `draw` call takes
    `40` milliseconds! Who knows why – maybe an autoplay video started up by surprise,
    taking resources. It doesn't matter because `accumulated_delta` shoots up to `40`,
    which is larger than `2` frames. Now, the loop on `accumulated_delta` runs `update`
    twice, dropping a frame of animation to compensate for the drop in performance.
    The important thing to remember here is that it drops a *draw* but not an *update*,
    so while the player might see some visual artifacts, the physics will still work
    without issue.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次，`perf`的值可能大约是第一帧的大小。我们将使用`17`毫秒进行简单计算。所以`perf`是`17`；从它减去`last_frame`，即`1`，并将`16`毫秒加到`accumulated_delta`上。新的`accumulated_delta`值是`17`，所以游戏更新一次，`accumulated_delta`减少到`1`。游戏继续进行一次更新到一次绘制，直到出现问题。`draw`调用需要`40`毫秒！谁知道为什么——也许是一段意外的自动播放视频启动，消耗了资源。这无关紧要，因为`accumulated_delta`激增到`40`，这比`2`帧大。现在，`accumulated_delta`上的循环运行`update`两次，丢弃一帧动画来补偿性能下降。这里要记住的重要事情是，它丢弃了一个*draw*但不是一个*update*，所以尽管玩家可能会看到一些视觉伪影，物理仍然可以正常工作。
- en: Important Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You might wonder what happens to the extra `accumulated_delta` since it's unlikely
    to be an exact multiple of `FRAME_SIZE`. More advanced game loops will pass that
    into the draw and use it to interpolate between the two update values. We shouldn't
    need that for our game and will just roll that `delta` over to the next frame.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道额外的`accumulated_delta`会发生什么，因为它不太可能是`FRAME_SIZE`的精确倍数。更高级的游戏循环会将这个值传递给绘制，并使用它来在两个更新值之间进行插值。对于我们的游戏，我们不需要这个功能，只需将那个`delta`滚动到下一帧。
- en: Important Note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Why use an `f32` for the `accumulated_delta`? That's very observant of you!
    The short version is, because we can. The slightly longer version is that we only
    use `f64` as often as we do because JavaScript uses a 64-bit `Number` type for
    all its numbers. If I could, I'd use smaller values whenever possible, and integers
    as well, because the extra size of `f64` isn't really necessary and can cause
    a surprising drag on performance when repeated everywhere.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用`f32`作为`accumulated_delta`？你观察得真仔细！简短的版本是，因为我们可以。稍微长一点的版本是，我们只使用`f64`，因为JavaScript使用64位的`Number`类型来表示所有数字。如果我能，我会尽可能使用更小的值，以及整数，因为`f64`的额外大小并不是真的必要，并且当它被重复使用时可能会对性能产生意外的拖累。
- en: So, there you have it – your game loop, at least the "looping" part of it. While
    it's usable now, it doesn't provide an easy way to load our assets. While we could
    just leave things as they are and always load assets before we start our game
    loop, a cleaner solution is to integrate that rule into the game loop.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是你的游戏循环——至少是它的“循环”部分。虽然现在它是可用的，但它不提供一种轻松加载我们资源的方法。虽然我们可以保持现状，并在开始游戏循环之前始终加载资源，但一个更干净的方法是将这个规则集成到游戏循环中。
- en: Loading assets
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载资源
- en: 'Expanding our game loop to handle loading assets is going to require adding
    a function to our trait, an `async` one to be precise. This will allow us to put
    all our asynchronous code that''s currently wrapped in the `spawn_local` in `lib`
    and put it in a function that returns `Result` with `Game` in it. You can start
    by adding that function to the `Game` trait:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的游戏循环扩展以处理加载资源，需要向我们的特质中添加一个函数，一个精确的`async`函数。这将允许我们将目前被`lib`中的`spawn_local`包裹的所有异步代码放入一个返回包含`Game`的`Result`的函数中。你可以从向`Game`特质添加该函数开始：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Unfortunately, that doesn''t compile. `async` trait functions haven''t landed
    in stable Rust yet, but fortunately, we can use a crate to get that functionality.
    Add `async-trait = "0.1.52"` to `Cargo.toml` and then add the following attribute
    macro to the trait:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，这不能编译。`async`特质函数还没有在稳定的Rust中实现，但幸运的是，我们可以使用一个crate来获取这个功能。将`async-trait
    = "0.1.52"`添加到`Cargo.toml`中，然后向特质添加以下属性宏：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You''ll also need to import `async_trait::async_trait`. The `async_trait` allows
    us to add `async` functions to a trait. We can use it with the `?Send` trait because
    we don''t need our futures to be thread-safe. Now, we can add this to the game
    loop:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要导入`async_trait::async_trait`。`async_trait`允许我们在特质中添加`async`函数。我们可以使用它与`?Send`特质一起，因为我们不需要我们的futures是线程安全的。现在，我们可以将其添加到游戏循环中：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And that's it! The game gets initialized, asynchronously, and with `Result`
    on the first line. Note that the passed-in `game` no longer has to be mutable
    since we're not mutating it in the function anywhere. We're almost ready to integrate
    our old `set_interval` into this, but there's a little more cleanup I'd like to
    do around drawing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！游戏被异步初始化，第一行是`Result`。请注意，传入的`game`不再需要是可变的，因为我们没有在任何地方修改它。我们几乎准备好将我们的旧`set_interval`集成到这个中，但我想在绘制周围做一点清理工作。
- en: Cleaner drawing
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁绘图
- en: Currently, we're sending a raw `CanvasRenderingContext2d` to the draw loop,
    with all of its awkward functions such as `draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh`.
    This works but it's ugly, and much like we did with the `browser` module, we can
    use a wrapper to narrow the context's wide interface to a smaller one, tailored
    to our needs. We'll replace passing `CanvasRenderingContext2d` with our own `Renderer`
    object that has easier-to-use functions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在向绘制循环发送原始的`CanvasRenderingContext2d`，带有所有那些尴尬的函数，例如`draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh`。这可以工作，但看起来很糟糕，而且就像我们在`browser`模块中所做的那样，我们可以使用一个包装器来将上下文的宽接口缩小到更小的一个，以适应我们的需求。我们将用我们自己的`Renderer`对象替换传递`CanvasRenderingContext2d`，该对象具有更易于使用的函数。
- en: 'We''ll start by creating a structure for our `Renderer` in `engine`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`engine`中为我们的`Renderer`创建一个结构：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is a simple wrapper containing the rendering context. For now, we''ll
    just add the two implementation methods to the `Renderer` struct:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的包装器，包含渲染上下文。现在，我们只需将两个实现方法添加到`Renderer`结构中：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These two functions, `clear` and `draw_image`, both wrap `context` functions
    but do so using fewer parameters. Instead of four parameters and `clear_rect`,
    we pass `clear` `Rect`. Instead of that incredibly long function name, we pass
    `draw_image` `HtmlImageElement` and two `Rect` structures. Currently, we go ahead
    and use `expect` to panic! here if we can't draw. I am convinced that this should
    return `Result`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数，`clear`和`draw_image`，都封装了`context`函数，但使用更少的参数。我们不是传递四个参数和`clear_rect`，而是传递`clear`
    `Rect`。我们不是传递那个极其长的函数名，而是传递`draw_image` `HtmlImageElement`和两个`Rect`结构。目前，如果我们不能绘制，我们会使用`expect`来panic！我相信这应该返回`Result`。
- en: Important Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: By now, there's been code in this book that you've thought could be done better.
    Try that out! I do that all the time when I follow books, and there's no reason
    you shouldn't too. Just try to remember where you've diverged from the book.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这本书中有些代码你可能认为可以做得更好。试试看！我总是在跟随书籍时这样做，你没有理由不这样做。只是尽量记住你与书籍的不同之处。
- en: 'Of course, both of these functions take `Rect`, but we don''t have a `Rect`
    structure. Let''s add that to the `engine` now:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这两个函数都接受`Rect`，但我们没有`Rect`结构。让我们现在将`Rect`添加到`engine`中：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can change the draw function to take `Renderer` instead of `CanvasRenderingContext2d`.
    So, we update the trait:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将绘制函数更改为接受`Renderer`而不是`CanvasRenderingContext2d`。因此，我们更新了特质：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we can make a change to the loop. Right now, we create `context` in the
    `Closure` that we pass to `create_raf_closure`. That call returns `Result`, so
    to get access to `context`, we have to call `unwrap` or `expect`. The cleaner
    approach we can use now is to create `Renderer`, with `Context` outside of `Closure`,
    as shown here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以对循环进行修改。目前，我们在传递给`create_raf_closure`的`Closure`中创建`context`。这个调用返回`Result`，因此要访问`context`，我们必须调用`unwrap`或`expect`。现在我们可以使用的更简洁的方法是在`Closure`外部创建`Renderer`，如下所示：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Moving this outside of the `request_animation_frame` closure means we don't
    need to use the `expect` syntax anymore – nice!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个移出`request_animation_frame`闭包意味着我们不再需要使用`expect`语法了——太好了！
- en: The small change to `draw`, turning it into `game.draw(&renderer)`, will make
    our `draw` function easier to write. I think we're meeting our goal of changing
    the code to make it *easier* to move forward. Let's prove it by taking our animation
    code out of `lib` and using the game loop.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将`draw`修改为`game.draw(&renderer)`的小改动将使我们的`draw`函数更容易编写。我认为我们正在实现我们的目标，即通过改变代码使其*更容易*前进。让我们通过将我们的动画代码从`lib`中取出并使用游戏循环来证明这一点。
- en: Integrating the game loop
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成游戏循环
- en: 'It''s great that we''ve written this game loop and all, but it''s about time
    we actually use it. Remember that we have our `GameLoop` structure, but it operates
    on a `Game` trait. So in order to use the loop, we need to implement that trait.
    We''ll implement it in another module, `game`, which we''ll create in `game.rs`
    and then add to the library using the `mod game` instruction declaration in `lib.rs`.
    We''ll start with a couple of structures:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了这个游戏循环，这很好，但现在是时候真正使用它了。记住，我们有 `GameLoop` 结构体，但它操作的是 `Game` 特质。因此，为了使用这个循环，我们需要实现这个特质。我们将在另一个模块
    `game` 中实现它，我们将在 `game.rs` 中创建它，然后使用 `lib.rs` 中的 `mod game` 指令声明将其添加到库中。我们将从几个结构体开始：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Make sure that you add the `#[async_trait(?Send)]` annotation, which allows
    you to implement a trait with the `async` functions. Provided you add the required
    `use` declarations from `engine`, this compiles because `Game` implements the
    trait as needed. It doesn't do anything, but it compiles. The `initialize` function
    might look a little strange because we're taking `self` and just throwing it away
    in favor of a new `WalkTheDog` structure – thrown on the heap, no less! We're
    doing that for some changes that you'll see in the next chapter, so just bear
    with me for now.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 确保添加 `#[async_trait(?Send)]` 注解，这允许你实现具有 `async` 函数的特质。只要你从 `engine` 中添加所需的
    `use` 声明，就可以编译，因为 `Game` 按需实现了这个特质。它实际上什么都没做，但可以编译。`initialize` 函数可能看起来有点奇怪，因为我们正在取
    `self` 并将其丢弃，以换取一个新的 `WalkTheDog` 结构体——而且是在堆上丢弃！我们这样做是为了在下一章中看到的一些更改，所以现在就请耐心等待。
- en: 'Now, let''s take the code that draws from `lib.rs` and move it into `draw`,
    updating it along the way:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将来自 `lib.rs` 的绘制代码移动到 `draw` 中，并在过程中更新它：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This only contains slight changes to the code in `lib.rs`, although it definitely
    won''t compile. Calls to `context` are replaced with calls to `renderer`, and
    we''ve used the new `Rect` structure. This won''t compile because `self` doesn''t
    have `sheet`, `frame`, or `image`. We''ll need to add that to the `game` module,
    as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这只包含对 `lib.rs` 中代码的微小更改，尽管它肯定无法编译。对 `context` 的调用被替换为对 `renderer` 的调用，并且我们使用了新的
    `Rect` 结构体。这无法编译，因为 `self` 没有包含 `sheet`、`frame` 或 `image`。我们需要将它们添加到 `game` 模块中，如下所示：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we've moved the structures from `lib.rs` that serialize the JSON from
    our sprite sheet and added fields for `frame`, `HtmlImageElement`, and `Sheet`
    to the `WalkTheDog` struct. Pay close attention to the fact that we've taken `Rect`
    from `lib` and renamed it `SheetRect`. This is the specific rectangle from our
    sprite sheet. In `game`, we also have a `Rect` structure. This is the rectangle
    that we'll use as a game domain object. This rename is confusing right now but
    is done to differentiate the two rectangles and is helpful as we go forward.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从 `lib.rs` 中序列化精灵图精灵的代码移动到 `WalkTheDog` 结构体中，并为 `frame`、`HtmlImageElement`
    和 `Sheet` 添加了字段。请注意，我们从 `lib` 中取出了 `Rect` 并将其重命名为 `SheetRect`。这是从我们的精灵图中特定的矩形。在
    `game` 中，我们也有一个 `Rect` 结构体。这是我们用作游戏域对象的矩形。这种重命名现在可能有些令人困惑，但它是为了区分这两个矩形，并且在我们继续前进时是有帮助的。
- en: 'The `WalkTheDog` structure has the fields needed to make `draw` compile, but
    it may make you wonder about `initialize`. Specifically, if we''re going to move
    our loading code to `initialize`, does the `WalkTheDog` struct really always have
    `HtmlImageElement` and `Sheet`? No, it does not. We''ll need to convert those
    fields to `Option` types and make the `draw` function account for them:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`WalkTheDog` 结构体具有使 `draw` 编译所需的字段，但它可能会让你对 `initialize` 提出疑问。具体来说，如果我们打算将我们的加载代码移动到
    `initialize` 中，`WalkTheDog` 结构体是否真的总是有 `HtmlImageElement` 和 `Sheet`？不，它不是。我们需要将这些字段转换为
    `Option` 类型，并使 `draw` 函数考虑到它们：'
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can use the `as_ref()` function to borrow `image` and `sheet`, and then
    use the `and_then` and `map` `Option` functions to cleanly get the frame and then
    draw it:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `as_ref()` 函数来借用 `image` 和 `sheet`，然后使用 `and_then` 和 `map` `Option` 函数干净地获取帧并绘制它：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is great – we''ve got a game that draws absolutely nothing, but that''s
    okay since our initialize code still doesn''t compile. Let''s prepare to draw
    by copying our loading code from `lib.rs` to the `initialize` function in the
    game loop. Don''t do any cutting and pasting yet; we''ll go ahead and clean up
    `lib.rs` at the end. `Initialize` should now look like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好——我们有一个什么也不绘制的游戏，但这没关系，因为我们的初始化代码仍然无法编译。让我们准备绘制，将 `lib.rs` 中的加载代码复制到游戏循环中的
    `initialize` 函数。现在不要进行任何剪切和粘贴；我们将在最后清理 `lib.rs`。`Initialize` 应该看起来像这样：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That''s a great copy and paste, but we can make it far more concise by using
    the `?` operator. Here''s the version with that improvement:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个很好的复制粘贴，但我们可以通过使用`?`操作符使其更加简洁。这是改进后的版本：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Look how small and clean that function is. It only took us three tries, but
    we got there. Now that we have `initialize` and `draw`, we can write `update`.
    The version we wrote in `lib.rs` used `set_interval_with_callback_and_timeout_and_arguments_0`
    to animate our Red Hat Boy, but that's not going to work anymore. Instead, the
    `update` function will need to keep track of the number of frames that have passed
    and advance when it's appropriate. In the original code, we called the `set_interval`
    callback every `50` milliseconds. In this new code, `update` will be called every
    1/60th of a second, or `16.7` milliseconds. So, in order to approximately match
    the animation, we'll want to update the current sprite frame every three updates;
    otherwise, our little RHB will run very, very fast.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 看看那个函数有多小、多干净。我们只尝试了三次，但最终做到了。现在我们有了`initialize`和`draw`，我们可以编写`update`函数。我们在`lib.rs`中编写的版本使用了`set_interval_with_callback_and_timeout_and_arguments_0`来动画化我们的红帽男孩，但那不再适用了。相反，`update`函数需要跟踪经过的帧数，并在适当的时候前进。在原始代码中，我们每`50`毫秒调用一次`set_interval`回调。在这段新代码中，`update`将每秒的1/60，即`16.7`毫秒被调用。因此，为了大约匹配动画，我们希望每三次更新就更新当前精灵帧；否则，我们的小RHB会跑得非常快。
- en: 'If you look at the `rhb.json` file, you can see that there are eight frames
    in the `Run` animation. If we want to advance a sprite frame every 3 updates,
    that means it will take 24 updates to complete the animation. At that point, we''ll
    want to return to the beginning and play it again. So, we''ll need to calculate
    the sprite frame from the frame count, which is updated in the `update` function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`rhb.json`文件，你会看到`Run`动画中有八个帧。如果我们想每3次更新前进一个精灵帧，这意味着完成动画需要24次更新。到那时，我们将想要回到开始处再次播放。所以，我们需要从`update`函数中更新的帧计数计算精灵帧：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This won''t work with our current `draw` code because it uses `frame` to look
    up the sprite to render. It will crash when it looks for `Run (9).png`, which
    doesn''t exist. We''ll update the `draw` function to get the sprite index from
    `frame`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的当前`draw`代码不兼容，因为它使用`frame`来查找要渲染的精灵。当它查找不存在的`Run (9).png`时，程序会崩溃。我们将更新`draw`函数，从`frame`获取精灵索引：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `current_sprite` variable will cycle from one to eight, and then loop back
    again. Don't believe me? Feel free to use the `log!` macro we wrote earlier to
    check my work; in fact, I encourage you to. Not because I'm arrogant but because
    it's always good to experiment with the code, rather than blindly typing it in.
    We then take that number and use it to look up the frame name.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`current_sprite`变量将从1循环到8，然后再次循环。你信不过我？欢迎使用我们之前编写的`log!`宏来检查我的工作；事实上，我鼓励你这么做。不是因为我很自大，而是因为总是对代码进行实验，而不是盲目地输入，总是好的。然后我们用那个数字来查找帧名。'
- en: 'With that accomplished, we now have a game loop that can render to the canvas
    and a game that renders our running RHB; we just need to integrate it. We''ll
    add a plain constructor to the `WalkTheDog` struct, right under the `struct` definition
    in `engine`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个任务后，我们现在有一个可以渲染到画布上的游戏循环，以及一个渲染我们跑步的RHB的游戏；我们只需要将其集成。我们将在`engine`中的`WalkTheDog`结构体定义下方添加一个普通的构造函数：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Nothing spectacular there – just something to make it easier to create the
    game object. And now for the moment you''ve been waiting for – the new main function
    integrating all these changes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别之处——只是为了让创建游戏对象更容易。现在，对于你一直等待的时刻——整合所有这些更改的新主函数：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: No, really, that's it – that's the whole thing. You spawn a local future, create
    a new game, and then call `GameLoop::start(game).await` to start it up. You can
    delete all the unused code from `lib.rs`, such as the extra `use` declarations
    and the structures we defined when everything was here. It looks great!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 真的，就是这样——这就是全部。你创建一个本地future，创建一个新的游戏，然后调用`GameLoop::start(game).await`来启动它。你可以从`lib.rs`中删除所有未使用的代码，例如额外的`use`声明和当所有内容都在这里时我们定义的结构。看起来很棒！
- en: We changed a lot of code to get here, but now we have a running game with a
    proper loop. We could end the chapter here, but it would be kind of nice if the
    code actually did something new, wouldn't it?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了达到这个目标修改了很多代码，但现在我们有一个带有正确循环的运行游戏。我们本可以在这里结束这一章，但如果代码实际上做了些新的事情，那会更好，不是吗？
- en: Adding keyboard input
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加键盘输入
- en: Most games have some form of user input; otherwise, they aren't much of a game.
    In this section, we'll start listening to keyboard events and use them to control
    our RHB. That means adding keyboard input to the game loop and passing that into
    the `update` function. What we will *not* be doing is yet more refactoring. The
    system is reasonably well factored at this point and is open to our new changes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏都有某种形式的用户输入；否则，它们就不再是游戏了。在本节中，我们将开始监听键盘事件，并使用它们来控制我们的RHB。这意味着将键盘输入添加到游戏循环中，并将其传递给`update`函数。我们不会做的事情是进一步的重构。系统在这个阶段已经相当模块化，并且可以接受我们的新更改。
- en: The specific process by which we'll get keyboard events is probably a little
    different than you're used to if you do web development. In a normal program,
    you would listen for keys to get pressed – in other words, pushed down and then
    released – and then do something such as update the screen when the button is
    released. This doesn't fit in with a game because typical players want the action
    to happen as soon as a key is pushed down and want it to continue for as long
    as it's held. Think of moving around the screen with the arrow keys. You expect
    motion to start the second you hit the arrow key, not after you release it. In
    addition, traditional programming doesn't account for things like pressing "up"
    and "right" at the same time. If we process those as two separate actions, we'll
    move right, then up, then right, and then up, like we're moving up the stairs.
    What we'll do is listen to every `keyup` and `keydown` event, and bundle that
    all up into a `keystate` that stores every currently pressed key. Then we'll pass
    that state to the `update` function so that the game can figure out just what
    to do with all the currently pressed keys.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取键盘事件的具体过程可能与你习惯的Web开发有所不同。在一个普通程序中，你会监听按键被按下——换句话说，按下然后释放——然后做一些事情，比如在按钮释放时更新屏幕。这与游戏不符，因为典型的玩家希望在按键按下时立即发生动作，并且希望它在按下期间持续。想象一下用箭头键在屏幕上移动。你期望在按下箭头键的瞬间开始移动，而不是在释放它之后。此外，传统的编程不考虑像同时按下“上”和“右”这样的情况。如果我们将这些作为两个独立的行为处理，我们将先向右移动，然后向上，然后再次向右，然后向上，就像我们在上楼梯一样。我们将监听每一个`keyup`和`keydown`事件，并将它们全部打包成一个`keystate`，该状态存储了所有当前按下的键。然后我们将这个状态传递给`update`函数，以便游戏可以确定如何处理所有当前按下的键。
- en: Important Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This approach is common in games, and it leads to one downside. If you want
    to trigger something only when a button is pressed, such as firing a gun, you
    have to keep track of whether or not the previous update had the key up and the
    next update had it down. So, by flipping from an event-driven approach to a global
    key state, we lose the events. Fortunately, this is easily recreated.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在游戏中很常见，但也带来一个缺点。如果你想只在按钮被按下时触发某些动作，比如开枪，你必须跟踪前一个更新是否有键被抬起，下一个更新是否有键被按下。因此，通过从事件驱动方法切换到全局键状态，我们失去了事件。幸运的是，这很容易重新创建。
- en: 'To get keyboard events, we have to listen for the `keydown` and `keyup` events
    on `canvas`. Let''s start with a new function in `engine`, `prepare_input()`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取键盘事件，我们必须在`canvas`上监听`keydown`和`keyup`事件。让我们在`engine`中开始一个新的函数`prepare_input()`：
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Tip
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure you set up your `canvas` element with a `tabIndex` attribute in the
    HTML file; otherwise, it cannot get focus and have keyboard events.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在HTML文件中将`canvas`元素设置一个`tabIndex`属性；否则，它无法获得焦点并且无法处理键盘事件。
- en: This is enough to get us started. It should look familiar because we're setting
    up `Closure` objects in the same way we did for `load_image` and `request_animation_frame`.
    We have to make sure we call `forget` on both of the `Closure` instances so that
    they aren't deallocated immediately after being set up because nothing in the
    Rust application is holding onto them. You'll also need to add the `KeyboardEvent`
    feature to `web-sys` to include it. Otherwise, there is nothing here you haven't
    seen before. It just doesn't do anything yet.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够我们开始了。它应该看起来很熟悉，因为我们是以与`load_image`和`request_animation_frame`相同的方式设置`Closure`对象的。我们必须确保在设置后对两个`Closure`实例都调用`forget`，这样它们就不会在设置后立即被释放，因为Rust应用程序中没有东西在持有它们。你还需要将`KeyboardEvent`功能添加到`web-sys`中，以便包含它。否则，这里没有你之前没见过的东西。它只是目前还没有做任何事情。
- en: Tip
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unlike most things in Rust, if you don't add a `forget` call, you won't get
    a compile-time error. You'll get a panic almost immediately and not always with
    a helpful error message. If you think you've set up callbacks into JavaScript
    and you're getting panics, ask yourself whether anything is holding on to that
    callback in your program. If nothing is, you've probably forgotten to add `forget`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 与Rust中的大多数事物不同，如果你没有添加`forget`调用，你不会在编译时遇到错误。你几乎会立即遇到panic，而且并不总是伴随着有用的错误信息。如果你认为你已经设置了JavaScript的回调，并且正在遇到panic，问问自己是否有什么东西在程序中保留了那个回调。如果没有，你可能忘记了添加`forget`。
- en: 'We''re listening to the input, so now we need to keep track of all of it. It''s
    tempting to start trying to condense the events into `keystate` in this function,
    but that''s troublesome because this function only handles one `keyup` or `keydown`
    at a time and doesn''t know anything about all the other keys. If you wanted to
    keep track of an `ArrowUp` and `ArrowRight` being pressed at the same time, you
    couldn''t do it here. What we will do is set up the listeners once before the
    game loop starts, such as with `initialize`, and then process all the new key
    events on every update updating our `keystate`. This will mean sharing state from
    these closures with the closure we passed to `request_animation_frame`. It''s
    time to add a channel. We''ll create an `unbounded` channel, which is a channel
    that will grow forever if you let it, here in `prepare_input` and then return
    its receiver. We''ll pass transmitters to both `onkeyup` and `onkeydown`, and
    send the `KeyboardEvent` to each of those. Let''s take a look at the changes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在监听输入，所以现在我们需要跟踪所有这些输入。在这个函数中尝试将事件压缩到`keystate`中很诱人，但这很麻烦，因为这个函数一次只处理一个`keyup`或`keydown`，并且对其他所有键一无所知。如果你想同时跟踪`ArrowUp`和`ArrowRight`被按下，你在这里无法做到。我们将做的是在游戏循环开始之前设置监听器一次，例如使用`initialize`，然后处理每次更新中的所有新按键事件，更新我们的`keystate`。这意味着需要将这些闭包的状态与传递给`request_animation_frame`的闭包共享。是时候添加一个通道了。我们将在`prepare_input`中创建一个`unbounded`通道，这是一个如果你让它无限增长的话会无限增长的通道，然后返回它的接收器。我们将传递发送器到`onkeyup`和`onkeydown`，并将`KeyboardEvent`发送到每个发送器。让我们看看这些变化：
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The function now returns `Result<UnboundedReceiver<KeyPress>>`. `UnboundedReceiver`
    and `unbounded` are both in the `futures::channel::mspc` module and are declared
    in a `use` declaration at the top of the file. We create the unbounded channel
    on the first line with the `unbounded` function and then create reference counted
    versions of both `keydown_sender` and `keyup_sender`, so that we can move each
    of them into their respective closures while sending both events to the same receiver.
    Note that the `unbounded` channel uses `start_send` instead of `send`. Finally,
    we return `keyevent_receiver` as `Result`. You might consider having two independent
    channels, one for `keyup` and one for `keydown`, and while I'm certain that can
    be done, I tried it and found this way was more straightforward.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 函数现在返回`Result<UnboundedReceiver<KeyPress>>`。`UnboundedReceiver`和`unbounded`都在`futures::channel::mspc`模块中，并在文件顶部的`use`声明中声明。我们使用`unbounded`函数在第一行创建无界通道，然后创建`keydown_sender`和`keyup_sender`的引用计数版本，这样我们就可以在发送两个事件到同一个接收器的同时，将每个事件移动到它们各自的闭包中。请注意，`unbounded`通道使用`start_send`而不是`send`。最后，我们将`keyevent_receiver`作为`Result`返回。你可能考虑有两个独立的通道，一个用于`keyup`，一个用于`keydown`，虽然我确信这是可以做到的，但我尝试了，发现这种方法更直接。
- en: 'Look closely and you might wonder what `KeyPress` is. It turns out you can''t
    tell what kind of `KeyboardEvent` happened simply by inspecting it. In order to
    keep track of whether the event was `keyup` or `keydown`, we wrap those events
    in an enumerated type that we''ll define in `engine.rs`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你可能会想知道`KeyPress`是什么。实际上，你无法仅仅通过检查它来确定发生了什么类型的`KeyboardEvent`。为了跟踪事件是`keyup`还是`keydown`，我们将这些事件包裹在一个我们将在`engine.rs`中定义的枚举类型中：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This `enum` approach means we won''t have to manage two channels. Now that
    we have a function that will listen for and put all our key events into a channel,
    we need to write a second function that grabs all those events off the channel
    and reduces them into `KeyState`. We can do that like so, still in the `engine`
    module:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`enum`方法意味着我们不需要管理两个通道。现在我们有一个函数可以监听并将所有我们的按键事件放入通道，我们需要编写第二个函数来从通道中获取所有这些事件并将它们减少到`KeyState`。我们可以在`engine`模块中这样做，如下所示：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This function takes `KeyState` and `Receiver` and updates `state` by taking
    every entry off of the receiver until its empty. Theoretically, this appears to
    create the possibility for an infinite loop in the event that the receiver is
    constantly filled, but I was unable to do that by normal means (pressing the keyboard
    like a madman), and if somebody decides to write a script that fills this channel
    and break their own game, more power to them. `KeyState` has to be passed as `mut`
    so that we update the current one and do not start from a brand-new state on each
    update. We''ve written this function pretending that `KeyState` already exists,
    but we need to create it as well, again in the `engine` module:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受`KeyState`和`Receiver`，并通过从接收器中取出每个条目来更新`state`，直到其为空。理论上，这看起来在接收器不断被填满的情况下可能会创建无限循环的可能性，但我无法通过正常手段（像疯子一样按键盘）做到这一点，如果有人决定编写一个脚本填充这个通道并破坏他们自己的游戏，那也是他们的自由。`KeyState`必须作为`mut`传递，这样我们就可以更新当前的状态，而不是在每次更新时从一个全新的状态开始。我们假设`KeyState`已经存在而编写了这个函数，但我们也需要在`engine`模块中创建它：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `KeyState` struct is just a wrapper around `HashMap`, storing a lookup
    of `KeyboardEvent.code` to its `KeyboardEvent`. If the `code` isn''t present,
    then the key isn''t pressed. The code is the actual representation of a physical
    key on the keyboard. You can find a list of all the available `KeyboardEvent`
    codes on MDN Web Docs: [https://mzl.la/3ar9krK](https://mzl.la/3ar9krK).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyState`结构体只是`HashMap`的一个包装器，存储了`KeyboardEvent.code`到其`KeyboardEvent`的查找。如果`code`不存在，则表示按键没有被按下。代码是键盘上物理按键的实际表示。你可以在MDN
    Web Docs上找到所有可用的`KeyboardEvent`代码列表：[https://mzl.la/3ar9krK](https://mzl.la/3ar9krK)。'
- en: Tip
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When in doubt, MDN Web Docs from Mozilla is easily the best resource on the
    web for browser libraries.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当有疑问时，Mozilla的MDN Web Docs是网上关于浏览器库的最佳资源。
- en: 'We''ve created the libraries and structures we need for keyboard input, so
    now we can integrate it into our `GameLoop`. We''ll call `prepare_input` in the
    `start` function before we start looping:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了所需的库和结构来处理键盘输入，因此现在我们可以将其集成到我们的`GameLoop`中。在我们开始循环之前，在`start`函数中调用`prepare_input`：
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we''ll move `keyevent_receiver` into the `request_animation_frame` closure
    and process the input on every update:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`keyevent_receiver`移动到`request_animation_frame`闭包中，并在每次更新时处理输入：
- en: '[PRE62]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can see that we initialized an empty `KeyState` right before the `request_animation_frame`
    closure,so that we can start with an empty one. Each frame will now call our `process_input`
    function and generate a new `KeyState`. That''s all the changes we have to do
    to our game loop to keep track of `KeyState`. The only thing that''s remaining
    is to pass it to our `Game` object so that it can be used. Some game implementations
    will store this as a global, but we''ll just pass it to the `Game` trait. We''ll
    update the trait''s `update` function to accept `KeyState`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们在`request_animation_frame`闭包之前初始化了一个空的`KeyState`，这样我们就可以从一个空的状态开始。现在每一帧都会调用我们的`process_input`函数并生成一个新的`KeyState`。这就是我们需要对我们游戏循环所做的所有更改，以跟踪`KeyState`。唯一剩下的事情是将它传递给我们的`Game`对象，以便可以使用它。一些游戏实现会将此存储为全局变量，但我们将只将其传递给`Game`特质。我们将更新特质的`update`函数以接受`KeyState`：
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, we can pass `KeyState` to the `update` function on every loop:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在每个循环中将`KeyState`传递给`update`函数：
- en: '[PRE64]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, to keep our game compiling, we will need to update the `WalkTheDog::update`
    signature, over in the `game` module, to match:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使我们的游戏能够编译，我们需要更新`game`模块中的`WalkTheDog::update`签名，以匹配：
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That's it! We've got a `GameLoop` that processes keyboard input and passes that
    state to our `Game`. We've spent a lot of time writing code that makes it possible
    for us to write a game, but we haven't actually updated our game. Our poor little
    RHB still just runs in one place. He looks happy, but now that we've got input,
    how about we move him around?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们得到了一个处理键盘输入并将状态传递给我们的`Game`的`GameLoop`。我们花费了很多时间编写代码，使得我们可以编写游戏，但实际上我们还没有更新我们的游戏。我们可怜的小RHB仍然只在一个地方运行。他看起来很开心，但现在我们已经有了输入，我们为什么不移动他呢？
- en: Moving Red Hat Boy
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动红帽男孩
- en: 'Moving game objects means keeping track of a position instead of hardcoding
    it, as you might have expected. We''ll create a `Point` structure in `engine`
    that will hold an *x* and a *y* position for RHB. On every `update` call, we''ll
    also calculate a velocity for him, based on which keys are pressed. Every direction
    will be the same size, so if `ArrowLeft` and `ArrowRight` are pressed at the same
    time, he''ll stop moving. After we calculate his velocity, we''ll update his position
    with that number. That should be enough to allow us to move him around the screen.
    Let''s start by adding `position` to the `WalkTheDog` game struct:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 移动游戏对象意味着跟踪位置而不是像你预期的那样硬编码它。我们将在`engine`中创建一个`Point`结构，它将为RHB保存一个*x*和*y*位置。在每次`update`调用时，我们还将根据按下的哪个键为他计算一个速度。每个方向的大小都相同，所以如果同时按下`ArrowLeft`和`ArrowRight`，他将停止移动。在计算他的速度后，我们将使用这个数字更新他的位置。这应该足以让我们在屏幕上移动他。让我们先从向`WalkTheDog`游戏结构体添加`position`开始：
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Of course, `Point` doesn''t exist yet, so we''ll create it in `engine`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`Point`还不存在，所以我们将它在`engine`中创建：
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note that we''re using integers here so that we don''t have to deal with floating
    point math when it''s not necessary. While the `canvas` functions all take `f64`
    values, that''s only because there is only one number type in `JavaScript`, and
    per MDN Web Docs ([https://mzl.la/32PpIhL](https://mzl.la/32PpIhL)), `canvas`
    is faster if you use integer coordinates. You''ll also need to update the `WalkTheDog::new`
    function to fill in a default `position`. Let''s use `0, 0` for now:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用整数，这样我们就不必在不需要时处理浮点数数学。虽然`canvas`函数都接受`f64`值，但这只是因为`JavaScript`中只有一个数字类型，根据MDN
    Web Docs ([https://mzl.la/32PpIhL](https://mzl.la/32PpIhL))，使用整数坐标的`canvas`更快。你还需要更新`WalkTheDog::new`函数以填写默认的`position`。让我们现在使用`0,
    0`：
- en: '[PRE68]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'I promised I would stop reminding you to do this, but do make sure you''ve
    added a `use` declaration for `crate::engine::Point` at the top of the file. The
    `initialize` function also needs to be updated to account for `position`. This
    is actually why we marked `Point` with `Clone` and `Copy`. It makes it possible
    to copy it into the new `WalkTheDog` `initialize` function, as shown here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我承诺我会停止提醒你做这件事，但请确保你已经在文件顶部添加了`crate::engine::Point`的`use`声明。`initialize`函数也需要更新以考虑`position`。这实际上是我们为什么用`Clone`和`Copy`标记`Point`的原因。这使得它能够复制到新的`WalkTheDog`
    `initialize`函数中，如下所示：
- en: '[PRE69]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In order for `position` to have any meaning, we''ll need to update the `draw`
    function so that it''s actually being used:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`position`有任何意义，我们需要更新`draw`函数，使其真正被使用：
- en: '[PRE70]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Make sure you update the *second* `Rect` and not the first one. The first `Rect`
    is the slice we are taking out of our sprite sheet. The second one is where we
    want to draw it. This should cause a noticeable change to the game, as RHB is
    now in the upper-left corner. Finally, we''re going to modify `update` to calculate
    a velocity based on which keys are pressed in `KeyState`. We''ll add this before
    updating the current frame, as shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你更新的是第二个`Rect`而不是第一个。第一个`Rect`是我们从精灵图中取出的切片。第二个是我们想要绘制它的位置。这将导致游戏有明显的改变，因为RHB现在在左上角。最后，我们将修改`update`以根据在`KeyState`中按下的哪个键来计算速度。我们将在更新当前帧之前添加这个，如下所示：
- en: '[PRE71]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The "`ArrowDown`" and "`ArrowUp`" strings and so on are all listed at [https://mzl.la/3ar9krK](https://mzl.la/3ar9krK),
    although you can also figure them out by simply logging the code when a key is
    pressed. You can see here that if "`ArrowDown`" is pressed we increase `y`, and
    if "`ArrowUp`" is pressed, we decrease it, and that''s because the origin is in
    the upper-left-hand corner, with `y` increasing as you go down, not up. Note also
    that we don''t use `if/else` here. We want to account for every pressed key and
    not short-circuit on the first key that''s pressed. Next, we adjust the position
    based on velocity:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '"`ArrowDown`"和"`ArrowUp`"等字符串等都在[https://mzl.la/3ar9krK](https://mzl.la/3ar9krK)中列出，尽管你也可以通过简单地记录按键时的代码来找出它们。你可以看到，如果按下"`ArrowDown`"，我们将增加`y`，如果按下"`ArrowUp`"，我们将减少它，这是因为原点位于左上角，随着向下移动`y`增加，而不是向上。注意，我们在这里没有使用`if/else`。我们想要考虑每个按下的键，而不是在第一个按下的键上短路。接下来，我们根据速度调整位置：'
- en: '[PRE72]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Head back to the browser, and you can now use the arrow keys to move RHB around!
    If he doesn't move, make sure you click in the canvas to give it focus. If he
    still doesn't move and you're sure you've gotten everything right, put some `log!`
    messages in the `start` function and make sure `KeyState` is being created, or
    in the `update` function to see if you're actually getting a new `KeyState`. We've
    covered a lot of ground here, and if you're following along, it's very easy to
    make a mistake, but you have a debugging tool to figure out issues now.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 回到浏览器，你现在可以使用箭头键来移动RHB！如果他不动，确保你点击画布以将其聚焦。如果他仍然不动，而你确信你已经一切都正确，请在`start`函数中添加一些`log!`消息，并确保`KeyState`正在创建，或者在`update`函数中查看你是否真的得到了一个新的`KeyState`。我们在这里覆盖了很多内容，如果你在跟随，很容易出错，但现在你有一个调试工具来找出问题。
- en: Tip
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'On some browsers, the `canvas` will get a border around it when it has the
    focus, which will appear after you click it. You can remove that by adding a style
    of `outline: none` to the `canvas`.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '在某些浏览器上，当`canvas`获得焦点时，它周围会有一条边框，点击后会出现。你可以通过添加样式`outline: none`来移除它。'
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This was a hard, long, and complicated chapter. I''ll quote a phrase Aaron
    Hillegass uses frequently in his books: *"Programming is hard and you are not
    stupid."* There were plenty of areas where a small typo could trip you up, and
    you may have had to go backward and forward several times. That''s all okay –
    it''s part of the learning process. I would encourage you to experiment with the
    skeleton we''ve built, even before moving onto the next chapter, as it''s a great
    way to ensure you understand all the code.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章艰难、漫长且复杂的章节。我将引用亚伦·希莱加斯在其书中经常使用的一句话：“编程很难，你并不愚蠢。”有很多地方，一个小小的打字错误就能让你陷入困境，你可能不得不来回多次检查。这都是正常的——这是学习过程的一部分。我鼓励你在进入下一章之前，先尝试我们构建的框架，因为这是确保你理解所有代码的绝佳方式。
- en: In the end, we've accomplished a lot. We've created a game loop that will run
    in the browser at 60 frames per second while updating at a fixed step. We've set
    up an XNA-like game "engine" and separated the engine concerns from the game concerns.
    Our browser interface is wrapped in a module so that we can hide some of the details
    of the browser implementation. We're even processing input, making this work like
    a true game engine. We did all this while keeping the code running as we went.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们取得了很大的成就。我们创建了一个游戏循环，它将以每秒60帧的速度在浏览器中运行，同时以固定步骤更新。我们设置了一个类似于XNA的游戏“引擎”，并将引擎关注点与游戏关注点分离。我们的浏览器界面被封装在一个模块中，这样我们就可以隐藏浏览器实现的一些细节。我们甚至处理了输入，使这个工作像真正的游戏引擎一样。我们在代码运行的同时完成了所有这些。
- en: The code should be easier to work with going forward because we now have clear
    places to put things. Browser functions go in a browser, engine functions in an
    engine, and the game in a game module, although you might feel like it's not a
    game because RHB doesn't run, jump, and slide around.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的前进，代码应该更容易处理，因为我们现在有明确的地方来放置东西。浏览器函数放在浏览器中，引擎函数放在引擎中，游戏放在游戏模块中，尽管你可能觉得这不是一个游戏，因为RHB不能跑、跳和滑动。
- en: Guess what we're doing next?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜我们接下来要做什么？
