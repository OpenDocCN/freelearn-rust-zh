- en: Integrating Rust with Other Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be covering the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling C operations from Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Rust commands from C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Rust operations from Node.js apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Rust operations from Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a Python module in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the techniques and steps that will help us create
    Rust units in our existing applications that are written in other languages, such
    as C, Node.js, and Python. We will deep dive into the concept of foreign function
    interface, which helps us in writing bindings for a foreign code base. Rust outperforms
    many programming languages in the aspect of stability and safer parallelism. It
    would be ideal for production level application developers to try out Rust for
    building small units in the code, and test to see if there is a considerable amount
    of performance change. This chapter helps to facilitate these kinds of thoughts
    and ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Calling C operations from Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will call an external C function from a Rust application.
    This technique can be really helpful when a developer wants to use some project-specific
    C library dependencies in the Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have to install the following crate before we can go ahead and create
    the binding between Rust and C. Follow the given steps to download and set up
    the `libc` crate, `gcc` crate, and `gcc` compiler for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Rust library project using the Cargo tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the newly created Rust library project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot. Here, we''ll use `libc` version `0.1` and `gcc`
    version `0.3`, and we''ll also mention the `build` script, which is `build.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7b38900-6992-40b6-a9d5-d7c05456eac6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Install the `gcc` compiler on your machine, which is usually present by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `build.rs` in the root location of the project and open
    it your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Change to the `src` directory in the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `double.c` script, which is the C application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `double_input` function in the `double.c` application, which we will
    use in the Rust application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `main.rs` script and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8ca9761-3f76-4e74-801d-b0d27d75bd15.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created a Rust project that can be used as a third-party
    package C application in the Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `libc` crate, which is used as a library for types and bindings
    to native C functions that are often found in other common platform libraries.
    This project dependency is mentioned in the `Cargo.toml` file under the `dependencies`
    field, and, then, in the `build-dependencies` section of the manifest, we have
    `gcc` = `0.3`, which is the dependency of the `build` script.
  prefs: []
  type: TYPE_NORMAL
- en: The `build` script does not have the access to dependencies listed in the dependencies
    of the `Cargo.toml` manifest section. The `build` dependencies will not be available
    to the package files; this is done by the Cargo tool so that the package and the
    build script are compiled separately, so their dependencies need not coincide.
  prefs: []
  type: TYPE_NORMAL
- en: Rust provides a `build` script support where some packages need to compile third-party
    non-Rust code; for example, in our case we have a C script called `double.c`.
    The packages needed to link to C script, which can either be located on the system
    or possibly need to be built from source. Cargo does not replace other tools for
    building these packages, but it integrates them with the `build` configuration
    option, like, in our case, in the `package` section of the manifest, where we
    have a file named `build` with the `build.rs` script.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust file designated by the `build` command, which, in our case, is `build.rs`,
    will be compiled first, before anything else is compiled in the package. This
    allows your Rust code to depend on the built or generated artifacts. In the `build.rs`
    script, we are building the native C code as part of the package; this package
    will later be used by the Rust code. We use an external crate named `gcc`, which
    invokes the externally maintained C compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The `build` script starts out in the `main` function where `gcc::Config::new().file("src/double.c").compile("libdouble.a")`
    starts off by compiling our C file into an object file (by invoking `gcc`) and
    then converting the object file (`double.o`) into a static library (`libdouble.a`).
    The object file is stored in `target/debug/build/<package>/out location`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `src` directory, we have the Rust project package file in which we have
    the native C script, `double.c`. The `double.c` script has a function named `double_input`,
    which takes in an integer argument named `input` and returns `input * 2`, which
    basically doubles the value passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.rs`, we first import the `libc` crate and then define the function
    signature in the `extern` block (since it''s a third-party package) as `fn double_input(input:
    libc::c_int) -> libc::c_int`. Here, we use the `libc` type so that there is a
    smooth conversion of types between Rust and C, which we do not have to handle
    while calling the foreign function, `double_input`. From the `main` function,
    we place it in the `unsafe` block.'
  prefs: []
  type: TYPE_NORMAL
- en: The `extern` block is a list of function signatures in a foreign library and
    the foreign functions are assumed to be unsafe. So, when we call them, they need
    to be wrapped with the `unsafe` block as a promise to the compiler that everything
    contained within is truly safe.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Rust commands from C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will perform the exact opposite operation of the last recipe.
    Here, we will call a Rust function from the C script. This technique can be really
    helpful when the developer wants to build a specific Rust unit in their C project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have to install the following system dependencies before we can go
    ahead and create a Rust unit for the C project. Follow the given steps to download
    and install the `build-essential` package for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Rust library project using the Cargo tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the newly created Rust library project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3432406c-c878-41d2-8a5e-a4ba0d8b6af1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Install the `build-essential` tool on your machine, which is usually present
    by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `lib.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `double_input` function in `lib.rs` Rust script with the given attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the file `main.c` in the `c_to_rust`/`src` directory, which is the C
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `Makefile` in the root location of the project directory, `c_to_rust`,
    for creating the `build` rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cb5a30d-14f0-4b52-b39a-7641619ddfd3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created an external library in Rust, which can be used by
    other foreign code. The `lib.rs` file inside the `src` folder is the entry point
    for packages and libraries in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: In `Cargo.toml`, while setting up the project, we set the `crate-type` field
    as `["staticlib"]`, which lets Cargo know the project should be compiled as a
    library.
  prefs: []
  type: TYPE_NORMAL
- en: The `lib` section helps when building a specific target. In our case, it is
    to `build` a package. The `name` field of a target is the name of the library
    that will be generated and it is the default name of the package or project. The
    dashes in the name of the project will be replaced with underscores.
  prefs: []
  type: TYPE_NORMAL
- en: In `lib.rs`, we created a `staticlib` type crate where we have the `double_input`
    function, which takes an integer input and returns an integer output by multiplying
    the input by `2`. We set the `double_input` function as public using the `pub`
    keyword, which allows external sources to call the function and the `extern` keyword
    makes this function stick to the C calling conventions. The `no_mangle` attribute
    turns off Rust's name mangling so that it is easier to link.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main.c` file, we call the externally created `double_input` function
    using the `extern` keyword with the declaration of `int32_t double_input(int32_t
    input)`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to compile and run this program, we used the `make` tool and created
    some rules, which are sequential steps for executing the project. We created `Makefile`
    where we first determined the shell using the command `($(shell uname),Darwin)`
    for detecting the OS type for setting the corresponding flags. If the OS is `Darwin`,
    then the `LDFLAGS` would be `-Wl,-dead_strip`; else `LDFLAGS` is set as `-Wl,--gc-sections
    -lpthread`. These are the flags to the linker (lD). The `all` rule is dependant
    on the `target/double` rule and it executes the same rule once the rules dependant
    to`target/double` are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: The `target` rule creates the target directory using the command `mkdir -p $@`,
    where `$@` refers to the left of the `:` in the rule. The `target/double` is dependent
    on the rules, `target/main.o` and `target/debug/libdouble_input.a`. When `target/main.o`
    runs, we are basically running `cc -o target/main.o -c src/main.c`, which creates
    the `main.o` in the `target` directory. The `target/debug/libdouble_input.a` runs
    `cargo build` command, which creates `libdouble_input.a`. The `target/double`
    is run with `cc -o target/double target/main.o target/debug/libdouble_input.a
    -Wl,--gc-sections -lpthread`, where the links are created. Finally, the executable
    `double` is run.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Rust operations from Node.js apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a Rust function, which can be called from JavaScript,
    and this technique can be really helpful when the developer wants to improve the
    performance of a certain unit of their web application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have to install the following system dependencies before we can go
    ahead and create a Rust unit for the Node.js project. Follow the given steps to
    download and install the node dependencies package for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Rust library project using the Cargo tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the newly created Rust library project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df0bb655-741d-4c15-8969-504e2df7d602.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Install Node.js and `npm` in your machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a file named `lib.rs` located in the `node_to_rust/src` directory and open
    it your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `double_input` function in the Rust script with the given attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `main.js` file in the `node_to_rust/src` directory, which is the
    JavaScript code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `Makefile` in the `node_to_rust/` directory for creating `build` rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08534f2a-ec5f-4494-a862-47a2acec8385.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we create an external library in Rust, which can be used by
    other foreign code. The `lib.rs` file inside the `src` folder is the entry point
    for packages and libraries in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: In `Cargo.toml`, while setting up the project, we set the `crate-type` field
    as `["dylib"]`, which lets Cargo know the project should be compiled as a dynamic
    library.
  prefs: []
  type: TYPE_NORMAL
- en: In `lib.rs`, we created a `dylib` type crate and we have a `double_input` function,
    which takes an integer input and returns an integer output by doubling the given
    input. We can see that it's the `pub` keyword that allows external sources to
    call the function, and `extern` makes this function stick to the Js calling conventions.
    The `no_mangle` attribute turns off Rust's name mangling so that it is easier
    to link.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main.js` file, where we call the externally created `double_input` function
    using the `ffi` node package, we create a variable, `ffi`, which is loaded with
    the units of `ffi` node module using the `require` keyword. Using the inbuilt
    `ffi.library` function, we load the `build` package at `target/debug/libdouble_input`
    and assign the return object type to the variable `lib`, which contains the method
    `double_input`. Later, we can use this function as `lib.double_int(input)`, where
    the `input` variable is assigned to a value of `4` in the previous statements
    of the Js code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to compile and run this program, we use the `make` tool and create
    certain rules, which are sequential steps for executing the project. We create
    `Makefile` where we first determine the `($(shell uname),Darwin)` shell for detecting
    the OS type to set the flags. If the OS is `Darwin`, then `EXT` would be `EXT
    := dylib`; else `EXT` is set to `so`. The `all` rule runs `target/debug/libdouble_input.$(EXT)`
    and `node_modules/ffi` before executing `node src/main.js`, which will run the
    JavaScript and produce the logs. The first rule is `target/debug/libdouble_input.$(EXT)`,
    which creates the crate by building the Rust project using the `cargo build` command,
    and the next rule is `node_modules/ffi`, which installs the node package `ffi`
    by `npm install ffi`.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Rust operations from Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will follow the steps that we implemented for the last two
    recipes where we created a Rust function and used it in other languages as integral
    units. Here, we will call the Rust unit using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have to install the following system dependencies before we can go
    ahead and create a Rust unit for the Python project. Follow the given steps to
    download and install the node dependencies package for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Rust library project using the Cargo tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the newly created Rust library project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e7b81156-7984-4ddb-b310-c8f80b010461.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Install Python on your machine, which is pre-installed on your machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `lib.rs` and open it your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `double_input` function in the Rust script with the given attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `main.py` file, which is the Python code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `Makefile` for creating the `build` rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/991e769c-87fe-42aa-8b20-8f80b407658a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created an external library in Rust, which can be used by
    other foreign code. The `lib.rs` file inside the `src` folder is the entry point
    for packages and libraries in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: In `Cargo.toml`, while setting up the project, we set the `crate-type` field
    as `["dylib"]`, which lets Cargo know the project should be compiled as a dynamic
    library.
  prefs: []
  type: TYPE_NORMAL
- en: In `lib.rs`, we created a `dylib` type crate and we have a `double_input` function,
    which takes an integer input and returns an integer output by doubling the given
    input. We can see that it's the `pub` keyword that allows external sources to
    call the function, and `extern` makes this function stick to the Js calling conventions.
    The `no_mangle` attribute turns off Rust's name mangling so that it is easier
    to link.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main.py` file, we call the externally created `double_input` function
    build using Rust code by using the `cdll` unit of the `ctypes` Python module where
    we use the `LoadLibrary` function. We pass the location of the `so`(shared object)
    file generated after compilation of the Rust project to the `LoadLibrary` Python
    function, which in our case is located at `target/debug/libdouble_input.so`. On
    successful loading of the `so` file, we assign `double_input` as `lib.double_input`
    and call it later in the script.
  prefs: []
  type: TYPE_NORMAL
- en: In order to compile and run this program, we use the `make` tool and create
    certain rules, which are sequential steps for executing the project. We create
    a `Makefile` where we first determine the `($(shell uname),Darwin)` shell for
    detecting the OS type to set the flags. If the OS is `Darwin` then `EXT` would
    be `EXT := dylib`; else `EXT` is set as `so`. The `all` rule runs `target/debug/libdouble_input.$(EXT)`
    before running the Python `src/main.py`. The other rule basically builds the Rust
    project to build the `libdouble_input.so` file, which is used by the Python script
    to run the corresponding `double_input` function.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Python module in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a Python module or library in Rust and import
    the `create` module in the Python script. Rust provides a great list of safe production-level
    type systems, so the current Python units of a project can be rewritten in Rust
    to achieve faster processing and a safer application. Here, we create a library
    in Rust named `example` with a function named `fibo`, which takes in an index
    value and produces the Fibonacci sequence value at the index.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have to install the following system dependencies before we can go
    ahead and create a Python module using Rust. Follow the given steps to download
    and install the dependencies package for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Rust library project using the Cargo tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the newly created Rust library project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/72a8d93d-4ab0-4b37-bb86-b46b5208027e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to have Python installed on the machine for the executing the steps
    in this recipe. In most of the systems Python comes pre-installed on the machine,
    if not run the following commands below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `lib.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `cpython` library and the corresponding module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `fibo` function in the Rust language, which is an implementation
    of the Fibonacci sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Python module interface, which exposes the `fibo` function to Python
    calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `test.py` file outside the `src` directory, which is the Python
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `Makefile` for creating `build` rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1d5f620-4601-4b7b-a74a-44283692f9ba.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we create an external library in Rust, which can be used by
    other foreign code. The `lib.rs` file inside the `src` folder is the entry point
    for packages and libraries in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: In `Cargo.toml`, while setting up the project, we set the `crate-type` field
    as `["dylib"]`, which lets Cargo know that the project should be compiled as a
    dynamic library. The name of the library is `example`.
  prefs: []
  type: TYPE_NORMAL
- en: We installed the latest `rust-cpython` crate from git, which makes it possible
    to execute Python code from Rust and build a module in Rust for Python. The Python
    module created can be used for both Python 2.7 and 3; for Python 2.7 we have to
    enable `features = ["python27-sys"]` while building the Rust project for the first
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `lib.rs`, we import the `cpython` crate and use the modules `Python` and
    `PyResult`. Then, we create a Rust function named `fibo`, which has taken in arguments
    of the `py: Python` and `n : u64` types, and the return type is `PyResult<u64>`.
    Here the `py` argument is of the `Python` type and the return value is wrapped
    to be a `PyResult` type, which is an alias to the Result type curated for custom
    made Python operations. Since we have these types in the `rust-cpython` project,
    we don''t have to explicitly handle type conversions from Python to Rust. In the
    `fibo` function, we implement the sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the entered `n` value is less than `2`, we return `OK(1)`, and, for all
    other values greater than `2`, we have two mutable variable `prev1` and `prev2`
    initially assigned to `1`. We then iterate using a `for` loop till `n`. Inside
    the `for` loop, we create an immutable variable, `new`, which is the sum of `prev1`
    and `prev2`. After the sum operation, the `prev1` value is assigned to `prev2`
    and `new` is assigned to `prev1`. We then return `OK(prev1)` once the loop ends.
    The next step is to expose the `fibo` function as part of the module; this can
    be done with the `py_module_initializer!` and `py_fn!` macros. The `py_module_initializer`
    macro basically creates a Python-compatible module. We need an initializer that
    exposes the public interface. To expose the `fibo` function, we use the `try!`
    macro by calling `m.add(py, "fibo", py_fn!(py, fibo(rand_int: u64)))`, where `m.add`
    adds the `fibo` function with the `py_fn!` macro defining the Python module. The
    initializer''s macro needs a `Result<>` as the return value. So, we return `Ok(())`
    at the end of the macro.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `test.py` file, we import the `example` module and print the result of
    the Fibonacci function for an input index `4` using `print(example.fibo(4))`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to compile and run this program, we use the `make` tool and create
    certain rules, which are sequential steps for executing the project. We create
    `Makefile` where we have the `all` rule, which depends on `run`. The `run` rule,
    in turn, depends on `build`. In the `build` step, the Rust projects are built
    using `cargo build --release`, which creates the external shared object file `libexample.so`
    in `target/release`. Post building, we copy the created `so` file as `example.so`
    in the home directory of the project where the `test.py` code is located. We then
    execute the `run` rule, which basically runs the `test.py` code and prints the
    result.
  prefs: []
  type: TYPE_NORMAL
