- en: Built-in Macros and Configuration Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to improve our code efficiency, we can learn how to make
    it work on multiple platforms and how to make sure we take advantage of all possible
    native optimizations, while we make the code faster and easier to implement. Metaprogramming
    allows us to do all that with really easy code snippets, and you probably know
    some of these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to use the following macros and configuration
    items built in with the compiler and the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crate features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nightly functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust allows us to conditionally compile certain parts of the code depending
    on what we call attributes. These attributes can be applied to either complete
    crates/modules or to specific functions, scopes, or even structure fields or enumeration
    variants. We saw some examples when we talked about Clippy, but these attributes
    allow for so much more that we will now look at them in depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first see how an attribute works. An attribute that you want to apply
    to the whole current module/crate will be written like this: `#![{attribute}]`.
    Ones that apply to the scope/function/field/variant next to it will be written
    like this: `#[{attribute}]`. Note that the first has the `!` symbol between the
    hash tag and the attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: You have probably seen attributes such as `#[macro_use]` or `#[derive(Debug)]`
    somewhere in some code. The first one will allow using macros from an external
    crate, while the second one will derive the `Debug` trait in the given structure
    or enumeration. Let's start by checking what can we avoid typing thanks to the
    derivation of traits.
  prefs: []
  type: TYPE_NORMAL
- en: Trait derivations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of trait derivations: built-in derives and custom derives.
    We will talk about the second ones in [Chapter 9](e869a4d7-e2a8-488a-a767-8c75364a8962.xhtml),
    *Creating Your Own Macros*, but let''s see what deriving can help us achieve.
    Let''s imagine the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s recommended that every structure implements the `Debug` trait so that
    if, for example, we need to debug what is happening with some part of the code,
    we can use the `println!("{:?}", element);` syntax. It should show the contents
    of the fields, so we could imagine something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the field information. For example, suppose we have the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is good, since it enables us to get information about our structure, but
    it's difficult to maintain and adds a lot of boilerplate code to our code base.
    Let's suppose we have a 20-field structure, and we need to remove 2 fields, and
    add 4 new ones. This rapidly escalates to a big mess. We will need to modify the
    trait implementation, maybe change the order of the fields, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the `#[derive]` attribute comes into play: it will write that
    code for us, and if we change our structure it will rewrite that code. And, even
    better, it will not pollute our code base, since that code will be written at
    compile time. The whole `Debug` trait implementation can be replaced by adding
    `#[derive(Debug)]` to the beginning of the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And, if we run the program again, we will see that nothing has changed. There
    are multiple traits that can be derived: comparison traits (`PartialEq`, `Eq`,
    `PartialOrd`, and `Ord`), `Copy`, `Clone`, `Hash`, `Default` and, as we saw, `Debug`.
    Let''s see what each of these traits does. We already talked about the `Debug`
    trait, so let''s start with comparison traits.'
  prefs: []
  type: TYPE_NORMAL
- en: The first two derivable traits are `PartialEq` and `Eq`. Both of them make it
    possible to use the `==` and the `!=` operators with the structure, but how do
    they work?
  prefs: []
  type: TYPE_NORMAL
- en: '`PartialEq` is meant to describe a partial equivalence relation, which means
    that if *A* is partially equal to *B*, *B* is partially equal to *A*, and if,
    in that example, *B* is partially equal to *C*, *A* is also partially equal to
    *C*, since the property is symmetric and transitive.'
  prefs: []
  type: TYPE_NORMAL
- en: When derived for structures or enumerations, it will only be available if all
    members of the structure or enumeration already implement `PartialEq`, and it
    will consider two structures or enumerations equal if all of their fields are
    equal.
  prefs: []
  type: TYPE_NORMAL
- en: The `Eq` trait requires an extra condition, and it cannot be checked at compile
    time. It requires that *A* is equal to *A*. This might sound strange if we are
    talking about structures with simple fields, but there is a simple type in the
    standard library that shows the opposite behavior. The floating point types (`f32`
    and `f64`) do not respect this when they are **NaN** (**Not a Number**). Two `NaN`
    are not equal, even if both of them are `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: To derive the `Eq` trait, it requires all the fields in the structure or enumeration
    to implement `Eq`. This means that you will not be able to implement `Eq` for
    any structure or enumeration containing a floating point number. This trait does
    not require any method implementation, it just tells the compiler that the structure
    or enumeration is always equal to itself, without any extra code.
  prefs: []
  type: TYPE_NORMAL
- en: The next two traits, `PartialOrd` and `Ord`, work similarly to `PartialEq` and
    `Eq`, but they add the ability to compare two elements to know their order, so
    it allows you to use the `<`, `<=`, `=>` and `>` operators with the structure
    or enumeration. Both require that if *A < B* and *B < C*, then *A < C* (and the
    same for `==` and `>`), and that if *A > B*, then *A < B* is false. The `Ord`
    trait also requires that one and only one of *A < B*, *A == B*, or *A > B* is
    true.
  prefs: []
  type: TYPE_NORMAL
- en: As an extra point of information, the `PartialOrd` trait adds a `partial_cmp()`
    function, while the `Ord` trait adds the `cmp()` function. Both return an `Ordering`,
    but for the first function, it is optional (`Option<Ordering>`) and for the second
    one, it is mandatory. This is because a partial comparison could not have any
    defined order for a particular value; remember the `NaN` case for floats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this function for structures that contain only `PartialOrd` or
    `Ord` fields is pretty easy: define which is the most relevant field for ordering
    and compare them between structures, then, if equal, compare the next relevant
    field. This can be avoided by using `#[derive(PartialOrd)]` or `#[derive(PartialOrd,
    Ord)]`.'
  prefs: []
  type: TYPE_NORMAL
- en: The derivation will compare fields from first to last, so make sure you put
    the most relevant fields first. In the case of enumerations, it will consider
    first variants *smaller* than latest variants. If you want to change that, you
    can either change the order of fields or variants, or implement the trait yourself.
    You might also want to only compare one of the fields of a structure and consider
    the rest irrelevant. In this case, you will need to implement the trait yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement any of these traits, you can simply compare the fields one by
    one. Note that `Ord` requires `Eq`, so we need to implement `PartialEq` to check
    only the day, month, and year and then derive `Eq`. You can check the details
    of the implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we compare the date by first checking the year. If the year
    is the same, we compare the month, and if the month is equal, we compare the day.
    We do not check which comments are associated to the date because we do not need
    to. The `PartialOrd` trait implementation only returns the result from the `Ord`
    trait wrapped in an `Option::Some`.
  prefs: []
  type: TYPE_NORMAL
- en: The next two, the `Copy` and `Clone` traits, allow for a structure to be copied
    in memory. This means that you will be able to copy, one by one, all the contents
    of the instance to another instance. The `Clone` trait enables this by adding
    the `clone()` method, which usually only calls the `clone()` method of each of
    the fields. It can run any arbitrary code, though, and you never know whether
    it will be expensive to clone the object or not. This is why using it requires
    an explicit call to the `clone()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Copy` trait, on the other hand, makes it implicit to copy one element.
    It means that, for example, when moving a variable to a function, if it's a `Copy`
    variable, you will be able to still use it after the move, because only a copy
    of it will be moved. We saw some examples of the benefits and drawbacks of this
    approach in [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml),* Common Performance
    Pitfalls*.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot implement the `Copy` trait, though, since Rust requires it to be
    extremely inexpensive and it's implemented using compiler intrinsics. So, you
    can safely use a `Copy` type knowing it will not be expensive to copy it, but
    you cannot implement it by yourself. You can derive it though. Deriving `Copy`
    for a structure or an enumeration requires the structure or enumeration to implement
    `Clone` (you can derive it too if all elements inside implement `Clone`) and all
    elements inside to implement `Copy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you can derive `Copy` for a structure with basic types such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But, you cannot derive it for structures with complex non-copyable types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can derive `Clone` in most cases, though, since most of the standard library
    types implement it. But, remember that the `clone()` method is usually expensive
    and should not be used too much. In fact, it's commonly said that if you use the
    `clone()` method directly, you are probably doing something wrong, and in most
    cases, it's true that other methods, such as `to_owned()` or `into()`, will do
    the trick more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '`to_owned()` will get the owned version of a variable, which in slices and
    strings means only to `memcpy()` the heap. The `into()` method, on the other hand,
    will use the specialized conversion implementation so that it produces the best
    output code. Both of them will change the type of the variable. Finally, `clone()`
    is usually generic, which means it will call `clone()` for each of its member
    attributes, making it slower sometimes.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now talk about the `Hash` trait. This trait enables the use of the given
    structure or enumeration as a key in hashed structures such as `HashMap`. It gives
    us the possibility to hash the structure with a `Hasher` to get a hash of the
    information contained. A `Hasher` is a trait that receives input such as bytes
    or numbers, and once you call `finish()` on it, it will return a `u64` with the
    hash value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `Hasher` is a trait, implementation details are not provided by the trait
    itself, but as we saw in [Chapter 2](da2d0480-3314-408b-9cad-60987754f45d.xhtml),
    *Extra Performance Enhancements*, some default implementations are provided in
    the standard library: `SipHasher`, `SipHasher13`, `SipHasher24`, and `DefaultHasher`.
    We have already seen some differences between them.'
  prefs: []
  type: TYPE_NORMAL
- en: The main idea behind the `Hash` trait is that it enables hashing any structure
    and does not limit `HashMap` keys, for example, to be bytes or numbers. You could
    implement the trait yourself for your structure (if you want to fine-tune how
    the hashing is done), but if what you want is to simply be able to use your structure
    or enumeration as a key in a `HashMap`, you can simply derive the `Hash` trait
    and the compiler will write that code for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only that, you will probably want to also implement the `Eq` trait for
    it since, for `HashMap` keys, it''s required. If you implement it yourself, you
    will need to make sure that if *A = B* then *hash(A) = hash(B)*, which might not
    be trivial. The best thing is to simply derive both. Let''s check this example
    code with the structure we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first derive `Hash`, `PartialEq`, and `Eq` in the `MyData` structure,
    then we create two identical keys and a different one. I used clone for easier
    understanding, but creating another one with the same values would work too. We
    add a value to the map using the first key and check whether we can retrieve the
    element with the clone of the key without any issues. If we try with a different
    key, though, we won't be able to get the value. You can also check that if the
    `MyData` structure does not implement `Eq` or `Hash`, you won't be able to use
    the `HashMap` with it as a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the only requirement for a structure to derive `Hash` is that all
    of its members already implement it, and most of the standard library types implement
    `Hash`. The default implementation will simply hash all attributes one by one
    with the given `Hasher`, which is what you would probably implement manually.
    An example of this implementation could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's simple code, but you will keep everything cleaner and easier
    to maintain if you derive it. Implementing it yourself, though, can help you deal
    with fields that do not implement `Hash`, custom hashing techniques or avoiding
    some fields to be hashed for a little better performance if the comparison of
    the structure is still valid without taking them into account.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last trait that you can derive out of the box with Rust is the
    `Default` trait. This trait gives the structure, or enumeration, a `default()`
    method that will create a structure with default values. These default values
    are, for example, `0` for numbers, empty strings for strings, empty vectors for
    vectors, and so on. It's usually used as a placeholder for future calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a structure where you would like to have a default value, you can
    implement the `Default` trait. And, doing it can be as simple as giving a value
    to each of the attributes. If you don''t need particular default value (all zeros
    is OK with you), you will probably prefer to simply derive the `Default` trait.
    Let''s check an example with the `MyData` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, I derived the `Default` trait (and the `Debug` trait, just
    to print the structure). This allows to create the `test2` variable by only calling
    `MyData::default()`. You can also call `Default::default()` if you give a type
    hint for the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if some fields of a structure implement `Default`, you can use
    the trait to complete the fields you don't want to specify, as you can see with
    the `test1` variable. Simply specify the non-default fields, and then, after the
    last comma, add a couple of periods (`..`) and then `Default::default()`, so that
    the compiler uses the `Default` trait to fill the other fields. You can use any
    function that is generic over the rest of the fields with this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `Default` trait is a pretty useful trait and if you don''t
    need any special treatment of any field for the default value of your structure,
    deriving it is a great idea. A potential implementation that you would be avoiding
    by doing this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, deriving it makes your work much easier. You can use this implementation,
    though, to customize any of the fields for a default instance of your structure,
    which could be a good idea if, for example, you would like all your structures
    to have the string field set to `"This is my data"` by default. Implementing it
    yourself will also enable you to customize it if any of your fields do not implement
    `Default`, which is rarely the case if using types of the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Crate features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second, very interesting, attribute use is to enable crate features. These
    features might encapsulate some functionality that some people using the crate
    don't need, therefore making it optional to compile. The Rust compiler will remove
    any unused code during the compilation, but not having some part of the code compile
    from the beginning will speed up the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define crate features in the `Cargo.toml` file by using the `[features]`
    section. You can specify some default features for the crate that will be built
    if nothing is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, two features have been defined, the `add` feature and the
    `multiply` feature. The `add` feature does not have any extra dependency, but
    the `multiply` feature depends on the `expensive_dependency` crate. By default,
    only the `add` feature will be built. If this were a binary crate, you could specify
    which features to build with the `--features` command-line option for `cargo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to opt out of default features, simply run it with the `--no-default-features`
    command-line option. If you want to use a crate that has features as a dependency
    for your project, you can specify which features to include when declaring the
    dependency in the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `[section.subsection]` syntax is only so that we do not need to add an inline
    object to the `dependencies` section. In this case, it opts out of the default
    features and requests the `nice_feat` feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, how does this look in the code? Let''s see. If we have an `add` feature
    as we saw before, we might add an attribute to enable one function, or module,
    only for that case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will only be compiled when the `add` feature is requested. We already saw
    a similar syntax when using `cargo clippy`, since it will request the `cargo-clippy`
    feature from our crate, enabling us to cherry-pick the lints.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final type of attributes are `#[cfg]` attributes. These attributes are incredibly
    powerful, enabling us to compile certain parts of the code depending on the target
    we are compiling to. For example, we might want to use a specific Windows function
    and have a backup one for the rest, or we might want the code to do different
    things in little- and big-endian machines.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is pretty easy. For example, if you want to check the system architecture,
    you can use `#[cfg(target_arch = "arm")]`, and instead of ARM, you can check for
    `"x86"`, `"x86_64"`, `"mips"`, `"powerpc"`, `"powerpc64"`, or `"aarch64"` too.
    To compile something only for FreeBSD, we can use `#[cfg(target_os = "freebsd")]`.
    You can compare the `target_os` configuration attribute with `"windows"`, `"macos"`,
    `"ios"`, `"linux"`, `"android"`, `"freebsd"`, `"dragonfly"`, `"bitrig"` , `"openbsd"`,
    or `"netbsd"`.
  prefs: []
  type: TYPE_NORMAL
- en: If you only care about Windows/Unix differences, you can use `#[cfg(target_family
    = "windows")]` or `#[cfg(target_family = "unix")]`, or even directly `#[windows]`
    and `#[unix]`. This can be specified further by using `#[cfg(target_env = "gnu")]`,
    or `"msvc"`, or `"musl"`. The endianness of the system can be checked with `#[cfg(target_endian
    = "little")]` or `#[cfg(target_endian = "big")]`, and the pointer width (32 or
    64 bits) with `#[cfg(target_pointer_width = "32")]` or `#[cfg(target_pointer_width
    = "64")]` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: More complex details can also be checked, such as whether the target has atomic
    integer types, and what size those atomic integers are. For example, to check
    whether the target platform has atomic 8 bit integers, you will use `#[cfg(target_has_atomic
    = "8")]`. You can check for `8`, `16`, `32`, `64`, and pointer width integers
    (with `"ptr"`). You can even check the vendor of the target architecture by checking
    `#[cfg(target_vendor = "apple")]`. You can check for `"apple"`, `"pc"`, or `"unknown"`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a couple of attributes let you know whether you are doing a test (using
    `#[test]`) and whether the debug assertions are turned on (using `#[debug_assertions]`).
    The first one could be useful if you want to change any particular behavior only
    for tests (not recommended; tests should run the same code as in production),
    and the second one lets you, for example, add some debug information if the application
    was compiled in debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: You can set/use a configuration item selectively by using `#[cfg_attr(a, b)]`.
    This will have the same effect as doing `#[b]`, but will only do something if
    `a` is true. If it's false, it will be like nothing was written. This is useful,
    for example, if you want to enable or disable lints depending on other attributes,
    or if you want to derive a trait only for certain targets, and implement it for
    the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check these configuration attributes in the code inside the logic
    by using the `cfg!()` macro. Simply use the same syntax as with attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most useful Rust functionalities is its macro ecosystem. You probably
    already know the `println!()` macro, but there are many more. These macros allow
    you to write complex boilerplate code (such as `stdio` handling in the `println!()`
    case) in a simple way and without having to add a ton of boilerplate code. Let's
    check out some of the most used ones.
  prefs: []
  type: TYPE_NORMAL
- en: Console printing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to lock the standard I/O interface, then write bytes to it, and
    finally flush it for each call, the `print!()` and `println!()` macros allow you
    to do that by just giving them a formatting static string and a series of parameters.
    Not only that, you can use the whole `std::fmt` module to specify number precision,
    format things in debug mode, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Similar macros exist for the standard error output interface or `stderr`. They
    are called `eprint!()` and `eprintln!()`, and allow you to easily print in `stderr`
    with the same format as `print!()` and `println!()`. The four macros use the syntax
    from the `format!()` macro, which we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: String formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating strings is easy: you just call `String::new()` and then use a static
    string or add characters to it. Sometimes, you might want easier access to how
    the string gets created. If you, for example, want the string to say `Hello {user}!`,
    even though you can probably do something such as creating a `String` with `Hello` in
    it, then appending the username and then the exclamation mark, this is not ideal.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `std::fmt` module comes in handy, with its `format!()` macro
    and all of its formatting options. These options apply to console printing, string
    formatting, and even buffer writing with `write!()` and `writeln!()` macros. You
    can find the complete guide in the `std::fmt` module documentation at the standard
    library documentation, by running `rustup doc --open`.
  prefs: []
  type: TYPE_NORMAL
- en: Compilation environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check environment variables at compile time by using the `env!("VAR")`
    and `option_env!("VAR")` macros. The first will retrieve the environment variable
    as `&''static str`. If the variable is not defined, the compilation will fail.
    The `option_env!()` macro avoids this by returning an `Option::None` if the environment
    variable is not set and an `Option::Some(&''static str)` if the variable is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Loading byte arrays and strings at compile time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can load various types of constants at compile time. The `include_bytes!()`
    macro will create a byte (`u8`) array with the contents of the specified file.
    The `include_str!()` macro, on the other hand, will get the contents of the file
    as a string and create a `&static str`. Both will make the compilation fail if
    the file does not exist at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `include!()` macro that will include the code of the given
    file and add it to the current file at compile time. The compilation will also
    fail if the code in that file is not valid Rust code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Code paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some paths should never be traversed and, in our code, that is usually a condition
    for our code to work properly. If we are receiving bad input data, we might want
    to return an error, but if our library is being misused, we might prefer to panic.
    Sometimes, we also want to make sure that it's impossible for a variable to be
    out of some bounds once it gets to the logic of our function, to avoid security
    flaws, for example. In those cases, the `unreachable!()` macro, or even the explicit
    `panic!()` macro, can help us.
  prefs: []
  type: TYPE_NORMAL
- en: There is another path that might not be ready to be traversed yet. While our
    crate is being implemented, we can use the `unimplemented!()` macro, as we saw
    before in some examples, to indicate that the code we are writing is not implemented.
    This will enable the code to compile but, if executed, it will panic with the
    *not yet implemented* message.
  prefs: []
  type: TYPE_NORMAL
- en: Checking preconditions and postconditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When testing, and even in our everyday code, we probably want to have some preconditions
    to our functions, or we might want to check some postconditions. We use assertions
    for this. They come in two variants, debug assertions and normal assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Normal assertions will always be checked, but will slow down your production
    code since they need to run every time. Debug assertions will only run when compiling
    in debug mode, so you will be able to catch errors then, and the production code
    will run without performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should use all the debug assertions you can, and use normal
    assertions only in places where you receive output from the user or another crate
    (if building a library).
  prefs: []
  type: TYPE_NORMAL
- en: The three macros are `assert!()`, `assert_eq!()`, and `assert_ne!()`, and their
    debug counterparts are `debug_assert!()`, `debug_assert_eq!()`, and `debug_assert_ne!()`.
    The first accepts a Boolean returning expression as the first argument and an
    optional second argument can contain a message that will be printed when panicking
    if the first argument is false.
  prefs: []
  type: TYPE_NORMAL
- en: The other two macros accept two arguments that will be compared between them
    and a third optional comment string. The `assert_eq!()` macro will panic if the
    two elements are different and the `assert_ne!()` will panic if they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: Others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many more macros. We have already used some of them, such as the `cfg!()`
    and `vec![]` macros. You can also cause an explicit compile error with the `compile_error!("message")`
    macro, or use the `file!()`, `line!()`, and `column!()` macros to get the current
    position in the code, or even the `module_path!()` macro to get the current module.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know more, open the standard library documentation by running
    `rustup doc --open` and check out the rest of the macros there.
  prefs: []
  type: TYPE_NORMAL
- en: Nightly Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nightly Rust can speed up your code even more in certain situations. If you
    don''t need compatibility with stable Rust, you might want to check all the nightly
    features. In some cases, such as kernel development, it''s impossible to get all
    the required functionality using stable Rust. You can use nightly Rust by overriding
    the default compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Or, you can call cargo with the `+nightly` flag. These methods will only work
    if you use `rustup` to manage your Rust installation, which you probably should
    if you have the option.
  prefs: []
  type: TYPE_NORMAL
- en: To use nightly features, you will need to use the `#![feature]` attribute at
    the crate level. For example, if you want to use the `conservative_impl_trait`
    feature, you will need to add `#![feature(conservative_impl_trait)]` to the beginning
    of your `main.rs` or `lib.rs` files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some of the most interesting unstable features. Note that these features
    will probably change rapidly, and they might have already changed by the time
    you read this book. Always check the latest Rust's unstable feature list ([https://doc.rust-lang.org/unstable-book/the-unstable-book.html](https://doc.rust-lang.org/unstable-book/the-unstable-book.html))
    to get the latest information. There are dozens of features and it's impossible
    to check all of them in this chapter, but here you can find an explanation of
    the most relevant ones so that you understand what can they do for you and how
    you can use them to improve the performance of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Conservative trait return
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This feature enables you to directly return a trait from a function. This means
    that in stable Rust, you will need to write this if you want to return a type
    that implements a trait without specifying the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This means that, before returning the iterator, you will need to move all of
    its information to the heap (this is done easily, but is costly with `Box::new()`)
    and then return it. This should not be necessary, since Rust should be able to
    know what type you are returning at compile time and allocate stack accordingly,
    then only let you use the trait, since it's what you specified beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this has already been implemented in nightly Rust, but you will need
    to use the `conservative_impl_trait` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This allows Rust to use the stack directly, which will avoid a costly allocation
    and make your code faster.
  prefs: []
  type: TYPE_NORMAL
- en: Constant functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `const_fn` feature enables you to declare some functions as constant so
    that they can receive constant arguments at compile time and be executed then
    instead of at runtime. This is particularly useful for constructors or for constants
    that need to create an object as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: For this last option, we have the `lazy_static!{}` macro, as we will see in
    the next chapter, but this macro runs all of its code at its first use, and not
    at compile time. Doing it at compile time would make compilations take a bit longer,
    but when running, it would not require computing anything as everything would
    already be a constant. It seems that not all `lazy_static!{}` cases can be solved
    with `const_fn`, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, as you can see, we created two constants that use the `MyData::new()`
    method to create them. The same method is then used at runtime in the `main()`
    function. The things you can do in a constant function are very limited. You cannot,
    for example, create bindings, and if you call another function or macro, it must
    also be constant. But you can still do pretty complex operations that won''t affect
    the performance of the application. As you can imagine, this is the output of
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Inline assembly and naked functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This might be one of the most interesting nightly features of Rust. Using `#[feature(asm)]`,
    we will get a new macro, `asm!()`, which we will be able to use in our code. With
    this macro, we can write inline assembly to perform fine-grained operations in
    the code if we need further performance optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: The exact syntax is still being worked on, but it already enables you to write
    arbitrary assembly code within your functions. This is a must for kernel development,
    for example, where access to CPU features can only be done by direct CPU instructions.
    Make sure you thoroughly test this code, since it will be unsafe to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, `#[feature(naked_functions)]` allows you to add the `#[naked]`
    attribute to a function. This will remove some boilerplate assembly that gets
    added before and after each function so that you can write plain assembly code.
    Many times, this is essential for using some CPU intrinsics.
  prefs: []
  type: TYPE_NORMAL
- en: Using bigger integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `i128_type` feature gives us the `i128` and `u128` integers, which work
    the same way as `i64` and `u64` types, but with 128 bits instead of 64, which
    gives them more capacity. They have the same API as the rest of the integers,
    so you can perform the same kind of operations. Sometimes it''s great to have
    a bigger, full-precision integer and, in this case, since it uses LLVM intrinsics,
    the type is almost as lightweight as a `u64` or `i64` (more or less double the
    processing time in a 64-bit machine; it should be around the same in a 128-bit
    machine). A simple example is given in the main documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Single instruction multiple data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **single instruction multiple data** (**SIMD**) CPU features have revolutionized
    the way operations are performed in our CPUs. Using processor-specific features,
    we can now run the same operation with multiple inputs simultaneously. Let's suppose
    that we need to add four numbers in pairs. We could first add the first two and
    then the second two, and get the two results. SIMD allows us to compute both results
    at the same time, by applying that adding operation to both pairs at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: This requires assembly, though, and even though LLVM does the best job it can
    to use as much SIMD as possible, it's sometimes not enough for some high-performance
    applications. We could use inline assembly, of course, but it's not rare to mess
    things up when using assembly, and you will need to rewrite it for each target,
    so a SIMD specific frontend is being developed.
  prefs: []
  type: TYPE_NORMAL
- en: The API is still a work in progress, but check the `simd` feature to get a grasp
    on how it will be done. It seems, for now, that an external crate will be developed
    with all the intrinsics. You will be able to generate groups of data and apply
    simultaneous operations to every element in supporting processors.
  prefs: []
  type: TYPE_NORMAL
- en: Allocation API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some specific projects require the ability to change the default heap allocation
    algorithm. Rust uses jemalloc by default for targets that allow it. As we saw
    in previous chapters, one of the features of this allocator is that, in collections,
    it will allocate the multiple of two of the last allocations.
  prefs: []
  type: TYPE_NORMAL
- en: You can change that by using the `alloc`, `allocator_api`, `alloc_jemalloc`,
    and `alloc_system` features. The last two specify the global allocator of the
    crate, which, in cases such as kernel development, must be specified and some
    functions implemented so that collections work. The other two allow for more customized
    allocator manipulation, even giving you the option to change the allocator for
    each collection.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To finish with this list, we will talk about the compiler plugins. These plugins
    can be used by adding `#![feature(plugin)]` to the top of the `main.rs` or `lib.rs`
    files, as with the rest of the nightly features. If you want to actually create
    a plugin, you will need to use the `plugin_registrar` and `rustc_private` features.
  prefs: []
  type: TYPE_NORMAL
- en: The unstable feature list has an interesting guide to create plugins, which
    will be extended in [Chapter 9](e869a4d7-e2a8-488a-a767-8c75364a8962.xhtml), *Creating
    Your Own Macros*. You will need to use the `libsyntax` crate, along with the internals
    of the compiler syntax, and the compiler internals themselves, so that you can
    parse the **advanced source tree (AST****)** tokens, and perform the operations
    required by your plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins enable big syntax extensions to the language, which can let you run
    arbitrary Rust code inside a macro or derive any kind of boilerplate code. We
    will see a real example of a crate that makes heavy use of plugins to create a
    great web development experience in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these features might not get stabilized in the short term, some might
    change a lot, and some might not even get implemented, even though I doubt it
    will happen for the list you just read. These changes could make your code obsolete
    from one day to the next, so you have to make sure that, if you use some of these
    features, you can maintain an always changing ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with metaprogramming by learning about attributes
    and macros. Both of them will help you write less code and make sure that you
    get the best possible implementation for trivial details.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned about nightly Rust and how some nightly features give us new
    language extensions that can greatly help improve the efficiency, performance,
    and clarity of our code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how crates in [crates.io](https://crates.io/)
    bring new macros and plugins to the ecosystem, and we will go through the most-used
    ones that improve the performance and development time for your applications.
  prefs: []
  type: TYPE_NORMAL
