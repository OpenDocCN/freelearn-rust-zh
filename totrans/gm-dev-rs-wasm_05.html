<html><head></head><body>
		<div><h1 id="_idParaDest-41"><em class="italic"><a id="_idTextAnchor063"/>Chapter 3</em>: Creating a Game Loop</h1>
			<p>In the first two chapters, we focused on getting an application built, an environment set up, and graphics on a screen without concerning ourselves with creating an actual functioning game. There's no interactivity here, and no straightforward way to add more characters without copying and pasting more code. In this chapter, that will change, with the addition of a game loop and keyboard events, but first, we're going to need to restructure the code to make it ready for our new features. Be prepared to dig in – this is going to be a busy chapter.</p>
			<p>We're going to cover the following:</p>
			<ul>
				<li>Minimal architecture for games</li>
				<li>Creating a game loop</li>
				<li>Adding a keyboard input</li>
				<li>Moving Red Hat Boy</li>
			</ul>
			<p>By the end of the chapter, we'll have a mini-game engine that's ready to be extended with new features and process input.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor064"/>Technical requirements</h1>
			<p>There are no new technical requirements for this chapter; I recommend making sure that your editor/IDE setup is comfortable for you. You're going to be making a lot of changes and you'll want your editor to help you along. The source code for this chapter is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_3">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_3</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3qP5NMa">https://bit.ly/3qP5NMa</a></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor065"/>Minimal architecture </h1>
			<p>A few years ago, I had<a id="_idIndexMarker156"/> a realization while preparing a talk on HTML5 game development. The day before I was scheduled to give the talk, I had written the slides and prepared my delivery, but I had one small problem – I had no demo! I needed a demo of a game to finish off my talk; indeed, I had referenced it in my slides, so I had to produce it. If you've ever been up against a deadline, you know what happens next. All of my ideas about<a id="_idIndexMarker157"/> clean code and software architecture were thrown to the side, as I hacked and slashed my way to a working prototype of <em class="italic">Asteroids</em> in HTML5. You can still find it on my GitHub here: <a href="https://github.com/paytonrules/Boberoids">https://github.com/paytonrules/Boberoids</a>, complete with a name that doesn't make sense.</p>
			<p>The code, by virtually any standard, is pretty terrible. In much the same way the code in <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">, Hello WebAssembly</em>, and <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Drawing Sprites</em>, proceeds in a straight line with no modules, separation of concerns, or tests, this code brute-forces its way from the start to the end of the program. But a funny thing happened at about 2 AM the day before that presentation – it worked! In fact, in preparation for this chapter, I cloned the nearly 10-year-old program, ran <code>python -m http.server</code>, browsed to <code>http://localhost:8000</code>, and, well, here you go – a mostly working clone of <em class="italic">Asteroids</em>:</p>
			<div><div><img alt="Figure 3.1 – Asteroids with a company logo" src="img/Figure_3.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Asteroids with a company logo</p>
			<p>Of course, this code is also nearly<a id="_idIndexMarker158"/> impossible to extend or debug. There's no encapsulation and it's all in one file; heck, there isn't even a proper <code>README</code> file. By any objective measure, this is <strong class="bold">bad</strong> software.</p>
			<p>It was so bad that while working on this presentation, I began simultaneously working on an open source project called "<em class="italic">Eskimo</em>" (<a href="https://github.com/paytonrules/Eskimo">https://github.com/paytonrules/Eskimo</a>), which was meant to be a <strong class="bold">good</strong> game framework with the best object-oriented design I knew at the time, with a test-first approach and things like CI built in. If you look at the commit dates, you may notice that my last commit on this project was 2 years after the <em class="italic">Asteroids</em> clone you can see in the preceding screenshot. The code, if you were simply doing a code review, is far better than the code for the aforementioned game. It just doesn't actually work.</p>
			<p>I never made a working game with <em class="italic">Eskimo</em>. Like many developers before me, I fell into the trap of writing a framework instead of making a game and spent so much time "perfecting" my framework that I lost interest in the game I was allegedly making. This bothered me for a long time, and I kept asking myself the question, "Why did I finish the game when I did everything wrong, and fail when I did it right?" Does good code have any real-life meaning?</p>
			<p>I won't keep you <a id="_idIndexMarker159"/>in suspense; for the purposes of this book, we're going to define minimal architecture as one that <strong class="bold">makes the next feature easier</strong>. That means that we are going to do some architecture but only enough to make things easier going forward. We'll be on the lookout for extra complexity and "gold-plating." We're making a game, not an engine, and we want to finish the gam<a id="_idTextAnchor066"/>e.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor067"/>Good? Bad? I'm the guy with code</h2>
			<p>Minimal architecture sounds simple <a id="_idIndexMarker160"/>but can be hard, so let me explain with a counter-example.</p>
			<p>Eskimo has an <code>Events</code> object that is created with a constructor that takes <code>jquery</code>, the <code>document</code>, a <code>game</code> object, and a <code>canvas</code>. It has all of this because I took the principle of dependency injection to an extreme and tried to make sure the <code>Events</code> object would not depend directly on any of those things.</p>
			<p>The problem? Three of those objects are never going to change. You're not going to replace <code>jquery</code>, the <code>document</code>, or the <code>canvas</code> in any game, at least not with <em class="italic">Eskimo</em>, and it requires a lot of understanding to follow the Eskimo code because of that. While the code is theoretically more flexible and follows the dependency inversion principle (<a href="http://bit.ly/3uh7fWU">http://bit.ly/3uh7fWU</a>), it actually made it harder to add future features because I couldn't keep in my head what dependencies did what. My mistake was that I injected these dependencies before I had a reason to, out of a misplaced sense of "good code."</p>
			<p>We are going to stay focused on our goal of making a game and do not want to get caught up in making a framework. That means our process for evolving our program into a game is going to introduce a little bit of flexibility each time we need it. Returning to the two example games, <em class="italic">Asteroids</em> and <em class="italic">Eskimo</em>, we can think of them as being on a scale of rigidity. The <em class="italic">Asteroids</em> clone is extremely rigid. It's like a steel pole, and if you want to change it, you can't. You can only break it. Meanwhile, the <em class="italic">Eskimo</em> game framework is infinitely flexible, so much so that it can't actually do anything. It collapses in on itself in to a lump of goo. Our game, which is just Red Hat Boy running so far, is also very rigid. Adding a second object, say the dog, would require a lot of code changing throughout the small <a id="_idIndexMarker161"/>application and would potentially introduce defects.</p>
			<p>So in order to take our game and add more features, particularly interactivity, we'll need to introduce some flexibility. We'll heat up our steel pole so that it can bend, bend it, and then let it harden again.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor068"/>Layered architecture </h2>
			<p>We're going to <a id="_idIndexMarker162"/>start by introducing a small layered architecture. Specifically, we'll have three layers:</p>
			<div><div><img alt="Figure 3.2 – A layered architecture" src="img/Figure_3.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – A layered architecture</p>
			<p>The one rule of this architecture is that layers can only use things at or below their layer. So working from the bottom, the browser layer is going to be a bunch of small functions that are specific to the browser. For instance, our <code>window</code> function will end up here. Meanwhile, the engine layer is going to be tools that work across our game, such as the <code>GameLoop</code> structure. Finally, the game is the layer that contains our actual game logic. Eventually, we'll spend most of our development time in this layer, although initially, we'll spend a lot of time in the <code>Engine</code> and <code>Browser</code> layers until they have settled.</p>
			<p>Why do this? Our <a id="_idIndexMarker163"/>aforementioned rule was that any change in architecture has to make future changes easier, so let's identify what makes changes hard right now:</p>
			<ul>
				<li>Keeping everything in one long function makes the code hard to follow.</li>
				<li>Extracting all the <code>Browser</code> code will allow us to unify error handling.</li>
			</ul>
			<p>The first point reflects that our brains can only hold so much. Keeping all the code in one place means scrolling up and down trying to find where things are and trying to remember virtually all of the code. Extracting code into various constructs such as modules, functions, and structs with <strong class="bold">names</strong> lets us reduce the amount of information in our heads. This is why the right design feels good to program in. Too much abstraction and you've replaced keeping track of all the details of the program with keeping track of all the abstractions. We'll do our best to keep things in the sweet spot.</p>
			<p>The second reason for the layered approach is specific to Rust and the <code>wasm-bindgen</code> functions, which all return <code>JsValue</code> as their error type. While this works in a browser, it does not work well when intermingling with the rest of a Rust program because <code>JsValue</code> does not implement the <code>std::Error::error</code> type that most other Rust errors implement. That means you can't write a function like the following:</p>
			<pre>async fn doesnt_compile() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let window = web_sys::window()?;
    let json = fetch_json("rhb.json").await?;
    ...
}</pre>
			<p>The preceding code won't compile because while <code>ThreadPool::new</code> returns a <code>Result&lt;ThreadPool, Error&gt;</code>, <code>fetch_json</code> returns <code>Result&lt;JsValue, JsValue&gt;</code>, and those results don't mix. In the <code>browser</code> module, we'll map JsValues to a standard error, using the <code>anyhow</code> crate. We'll also use it to hide the weird details of the API, creating one that's tailored to <a id="_idIndexMarker164"/>our purposes. Let's get started creating our <code>browser</code> m<a id="_idTextAnchor069"/>odule.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor070"/>Creating the browser module</h2>
			<p>The first <a id="_idIndexMarker165"/>step is <a id="_idIndexMarker166"/>to create a file named <code>browser.rs</code> in the <code>src</code> directory and reference it at the top of <code>lib.rs</code> with <code>mod browser</code>. While we could, theoretically, put every module in <code>lib.rs</code>, we're not monsters, and we'll break things into their own files. By the end of this chapter, <code>lib.rs</code> will be very small. Our first addition to <code>browser</code> is actually going to be a macro, and a completely new one, listed as follows:</p>
			<pre>macro_rules! log {
    ( $( $t:tt )* ) =&gt; {
        web_sys::console::log_1(&amp;format!( $( $t )*
          ).into());
    }
}</pre>
			<p>I'd love to claim that I was a great macro programmer who wrote that in one try, but the truth is that that little macro is straight from the Rust and WebAssembly docs (<a href="https://bit.ly/3abbdJ9">https://bit.ly/3abbdJ9</a>). It's a macro that allows you to log in to the console with <code>log!</code> using a syntax such as the <code>format!</code> function. In <code>lib.rs</code>, add an annotation to the <code>browser</code> module declaration, like so:</p>
			<pre>#[macro_use]
mod browser;</pre>
			<p>This makes <code>log!</code> available whenever the <code>browser</code> module is used. Given that we'll be making a lot of changes, we'll probably want some easy debugging. The next step will be to add the <code>anyhow</code> crate, which we'll use to unify the error handling across WebAssembly and pure Rust code. The dependency is added to <code>Cargo.toml</code> as <code>anyhow = "1.0.51"</code>. This crate provides a few features that we'll be using extensively:</p>
			<ul>
				<li>An <code>anyhow::Error</code> type that conforms to the <code>std::error::Error</code> trait</li>
				<li>An <code>anyhow!</code> macro that lets us create error messages that conform to the type, with strings</li>
				<li>An <code>anyhow::Result&lt;T&gt;</code> type that is a shortcut for <code>Result&lt;T, anyhow::Error&gt;</code></li>
			</ul>
			<p>Go ahead and add <code>use anyhow::{anyhow, Result};</code> to the top of the use declarations now so that we'll have <a id="_idIndexMarker167"/>them ready as we create new functions<a id="_idIndexMarker168"/> here.</p>
			<p>Now that the <code>browser</code> module is prepared, let's work from the top of <code>main</code> and work downward, extracting functions. Let's start here:</p>
			<pre>#[wasm_bindgen(start)]
pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {
    console_error_panic_hook::set_once();
    let window = web_sys::window().unwrap();
    let document = window.document().unwrap();</pre>
			<p>The <code>wasm_bindgen</code> macro has to stay there, and it is only compatible with a function that returns <code>Result&lt;(), JsValue&gt;</code>. This means that while we can use proper Rust errors throughout our program, at the end, we'll need to transform it back to a <code>JsValue</code> if we want it to be returned from this function. Fortunately, once we write our game loop, this won't be a problem.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><code>Wasm_bindgen</code> error handling is a little rough, and the Wasm working group is aware of it. For reference, you can look at the defect here: <a href="https://bit.ly/3d8x0D7">https://bit.ly/3d8x0D7</a>.</p>
			<p>Moving on to the executing code, there are two functions right off the top that can be pulled into <code>browser.rs</code>. We'll take the refactoring step by step. First, let's create a function in the browser module, like this:</p>
			<pre>pub fn window() -&gt; Result&lt;Window&gt; {}</pre>
			<p>That won't compile because it doesn't return anything, but also because it doesn't know anything about the <code>Window</code> type. Go ahead and import those at the top of the file. It should look like this:</p>
			<pre>use web_sys::Window;</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you haven't already, get Rust Analyzer working with your editor of choice. I use emacs and use the keyboard shortcut , <code>c a</code> to import modules. It's a great timesaver for this kind of work. From this point forward, I won't be documenting every <code>use</code> declaration you need when moving files over; just follow the compiler errors.</p>
			<p>The function also doesn't compile<a id="_idIndexMarker169"/> because you're not returning anything. You <a id="_idIndexMarker170"/>can start by directly copying (don't cut) the call to <code>window()</code> from <code>lib.rs</code>:</p>
			<pre>pub fn window() -&gt; Result&lt;Window&gt; {
    web_sys::window().unwrap()
}</pre>
			<p>You don't need to bind a variable with <code>let</code> here. This still won't compile because of that <code>unwrap</code>. In this case, <code>web_sys::window</code> returns <code>Option&lt;Window&gt;</code> and <code>unwrap</code> will extract the <code>Window</code> object, or panic. None of that conforms to <code>Result&lt;Window&gt;</code>, and what we need to do instead is handle the case where <code>window</code> is somehow missing as an error.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When trying to mix and match <code>Option</code> and <code>Result</code>, there are two schools of thought – make <code>Result</code> into <code>Option</code> with <code>ok</code>, or convert <code>Result</code> into <code>Option</code> with <code>ok_or_else</code>. I prefer the second because while that will mean writing a lot of error messages that say "<code>&lt;X&gt;</code>" (not found), the alternative is losing useful error diagnostics.</p>
			<p>To make this function work with the <code>Result&lt;Window&gt;</code> return type, which, remember, is a shorthand for <code>Result&lt;Window, anyhow::Error&gt;</code>, we're going to use the <code>anyhow!</code> macro. So, to convert <code>Option</code> to <code>Result</code> and make this function compile, you can do the following:</p>
			<pre>pub fn window() -&gt; Result&lt;Window&gt; {
    web_sys::window().ok_or_else(|| anyhow!("No Window Found"))
}</pre>
			<p>Now you've<a id="_idIndexMarker171"/> got a <a id="_idIndexMarker172"/>function, <code>browser::window()</code>, which will return <code>Window</code> or the appropriate error.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Nightly Rust currently has an error called <code>NoneError</code> that helps bridge the gap between <code>Option</code> and <code>Result</code> types, but we'll stick to the standard for now.</p>
			<p>Finally, we can replace the call to <code>web_sys::window()</code> in <code>lib</code> with a call to <code>browser::window()</code> in <code>lib</code>:</p>
			<pre>let window = browser::window().expect("No Window Found");
let document = window.document().unwrap();</pre>
			<p>The call to <code>window()</code> will use <code>expect</code> for now to go ahead and crash the program if there is no window. Later, you'll see we can use the <code>?</code> operator, but for the moment, we've got to work around <code>main_js</code> returning a <code>Result&lt;(), JsValue&gt;</code>. If that was the only place we were changing, the introduction of <code>anyhow</code> wouldn't make any sense. Fortunately, when we repeat that process with a new <code>document</code> function in the <code>browser</code> module, you can see the advantage. We can skip going through each step of that process, and get to the end result:</p>
			<pre>pub fn document() -&gt; Result&lt;Document&gt; {
    window()?.document().ok_or_else(|| anyhow!
        ("No Document Found"))
}</pre>
			<p>If this doesn't compile, don't forget to add <code>Document</code> to the <code>use</code> declarations at the top of the module. As we make these changes, you'll need to move <code>use</code> declarations into <code>browser</code>, but you'll be able to remove them from <code>lib.rs</code>.</p>
			<p>You can now actually shrink<a id="_idIndexMarker173"/> the two<a id="_idIndexMarker174"/> calls to <code>window()</code> and <code>document()</code> in <code>lib.rs</code> into one call, like so:</p>
			<pre>pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {
    console_error_panic_hook::set_once();
let document = browser::document().expect("No Document Found");
...</pre>
			<p>There is one place in <code>lib.rs</code> where we're using the window variable we just deleted. Near the bottom of <code>spawn_local</code> <code>Closure</code>, right after creating <code>interval_callback,</code> there is a call to <code>window.set_interval_with_callback_and_timeout_and_arguments_0</code> that can replace <code>window</code> with <code>browser::window().unwrap()</code>. That looks like the following:</p>
			<pre>let interval_callback = Closure::wrap(Box::new(move || {
    ...
}) as Box&lt;dyn FnMut()&gt;);
<strong class="bold">browser::window()</strong>
<strong class="bold">    .unwrap()</strong>
<strong class="bold">    .set_interval_with_callback_and_timeout_and_arguments_0(</strong>
<strong class="bold">        interval_callback.as_ref().unchecked_ref(),</strong>
<strong class="bold">        50,</strong>
<strong class="bold">    );</strong>
interval_callback.forget();</pre>
			<p>Our next function will get the <code>canvas</code> object, but it's a little more complicated than the previous two functions. We were pretty <a id="_idIndexMarker175"/>casual with the <code>unwrap</code> calls for that section, so we'll have to do some converting to get more specific errors. The end result <a id="_idIndexMarker176"/>looks like this:</p>
			<pre>pub fn canvas() -&gt; Result&lt;HtmlCanvasElement&gt; {
    document()?
        .get_element_by_id("canvas")
        .ok_or_else(|| anyhow!
            ("No Canvas Element found with ID 'canvas'"))?
        .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()
        .map_err(|element| anyhow!("Error converting {:#?}
          to HtmlCanvasElement", element))
}</pre>
			<p>There are a few things worth paying close attention to here. First, the <code>get_element_by_id</code> call is hardcoded to the <code>'canvas'</code> ID. We'll go ahead and leave that as is until it causes an issue later, but we're not going to make that configurable until we need to. Next, we used <code>ok_or_else</code> to convert <code>get_element_by_id</code> from <code>Option</code> to <code>Result</code>. Most interesting is the call to the <code>dyn_into</code> function. As discussed earlier, almost every function that calls into JavaScript will return a <code>JsValue</code> type, because JavaScript is a dynamically typed language. We know that the element returned by <code>get_element_by_id</code> will return <code>HtmlCanvasElement</code>, at least if we've retrieved the right JavaScript node, so we can convert it from <code>JsValue</code> to the correct element. This is what <code>dyn_into</code> does – it converts from <code>JsValue</code> to appropriate Rust types. In order to use <code>dyn_into</code>, you must import <code>wasm_bindgen::JsCast</code>, which rust-analyzer cannot automatically import. It can import <code>web_sys::HtmlCanvasElement</code>.</p>
			<p>We'll create a <code>context</code> function that looks very similar:</p>
			<pre>pub fn context() -&gt; Result&lt;CanvasRenderingContext2d&gt; {
    canvas()?
        .get_context("2d")
        .map_err(|js_value| anyhow!("Error getting 2d 
          context {:#?}", js_value))?
        .ok_or_else(|| anyhow!("No 2d context found"))?
        .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()
        .map_err(|element| {
            anyhow!( "Error converting {:#?} to
                      CanvasRenderingContext2d",
                      element
            )
        })
}</pre>
			<p>One oddity you might <a id="_idIndexMarker177"/>see here is that <a id="_idIndexMarker178"/>we follow <code>map_err</code> immediately with <code>ok_or</code>. That's because <code>get_context</code> returns <code>Result&lt;Option&lt;Object&gt;, JsValue&gt;</code>, which the old code "solved" by calling <code>unwrap</code> twice. So what we do now is map the error (<code>JsValue</code>) to <code>Error</code> and then take the inner <code>Option</code> and map the <code>None</code> case to a value.</p>
			<p>Remember that if you're following along and having trouble compiling, update your <code>use</code> declarations. Let's pick up the pace a little. We can add a function for <code>spawn_local</code>:</p>
			<pre>pub fn spawn_local&lt;F&gt;(future: F)
where
    F: Future&lt;Output = ()&gt; + 'static,
{
    wasm_bindgen_futures::spawn_local(future);
}</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you are writing a wrapper like this and aren't sure what the signature should be, start by looking at the function you're wrapping and mimic its signature.</p>
			<p>Let's also <a id="_idIndexMarker179"/>add<a id="_idIndexMarker180"/> fetching <code>JSON</code> to <code>browser</code>:</p>
			<pre>pub async fn fetch_with_str(resource: &amp;str) -&gt;
  Result&lt;JsValue&gt; {
    JsFuture::from(window()?.fetch_with_str(resource))
        .await
        .map_err(|err| anyhow!("error fetching {:#?}", 
                                err))
}
pub async fn fetch_json(json_path: &amp;str) -&gt; Result&lt;JsValue&gt; {
    let resp_value = fetch_with_str(json_path).await?;
    let resp: Response = resp_value
        .dyn_into()
        .map_err(|element| anyhow!("Error converting {:#?}
           to Response", element))?;
    JsFuture::from(
        resp.json()
            .map_err(|err| anyhow!("Could not get JSON from 
              response {:#?}", err))?,
    )
    .await
    .map_err(|err| anyhow!("error fetching JSON {:#?}", err))
}</pre>
			<p>I expanded <code>fetch_json</code> into two functions because I think <code>fetch_with_str</code> is going to be reusable, but it's not strictly necessary. The <code>fetch_json</code> function borders on not belonging in the <code>browser</code> module. On the one hand, it exclusively calls into the <code>wasm_bindgen</code> API, mapping the <code>JsValue</code> errors to standard <code>Error</code>s; on the other hand, there is a tiny amount of behavior there when we decide to get <code>JSON</code> off of the response. Ultimately, that's a bit of a judgment call.</p>
			<p>Having written all those functions, you can go back to the <code>lib.rs</code> module and update the main function to use the<a id="_idIndexMarker181"/> new <a id="_idIndexMarker182"/>ones. As you can see, it's starting to shrink significantly, as the top should look like the following, using the new functions from the browser module where appropriate:</p>
			<pre>#[wasm_bindgen(start)]
pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {
    console_error_panic_hook::set_once();
    <strong class="bold">let context = browser::context().expect("Could not get </strong>
<strong class="bold">      browser context");</strong>
<strong class="bold">    browser::spawn_local(</strong>async move {
        let sheet: Sheet = <strong class="bold">browser::fetch_json("rhb.json")</strong>
            <strong class="bold">.await</strong>
            <strong class="bold">.expect("Could not fetch rhb.json")</strong>
            .into_serde()
            .expect("Could not convert rhb.json into a 
                     Sheet structure");
        let image =
          web_sys::HtmlImageElement::new().unwrap();
...</pre>
			<p>You can see that we removed all the intermediate calls to <code>window </code>and <code>context</code> in favor of one call to <code>context</code>. We've also just made a call into <code>fetch_json</code> using <code>expect</code> to call out errors. Finally, you'll see one compiler error when you do this on the <code>window.set_interval_with_callback_and_timeout_and_arguments_0</code> line. You can fix that by replacing <code>window</code> with <code>browser::window().unwrap()</code>. The <code>unwrap</code> bit is ugly, but we'll keep refactoring until that's gone as well. It's not reproduced in the preceding snippet, but you can also<a id="_idIndexMarker183"/> delete the <code>fetch_json</code> function from <code>lib.rs</code>; it's not <a id="_idIndexMarker184"/>being used anymore. </p>
			<p>This brings us to the next section to e<a id="_idTextAnchor071"/>xtract – loading an image.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor072"/>Loading an image</h2>
			<p>I bet you <a id="_idIndexMarker185"/>thought you were done <a id="_idIndexMarker186"/>with loading the image, didn't you? Well, we will be as soon as we turn it into a function. Let's look at the original implementation for a moment again:</p>
			<pre>let image = web_sys::HtmlImageElement::new().unwrap();
let (success_tx, success_rx) =
   futures::channel::oneshot::channel::&lt;Result&lt;(),JsValue&gt;&gt;();
let success_tx = Rc::new(Mutex::new(Some(success_tx)));
let error_tx = Rc::clone(&amp;success_tx);
let callback = Closure::once(Box::new(move || {
    if let Some(success_tx) = 
      success_tx.lock().ok().and_then(|mut opt| opt.take())
    {
        success_tx.send(Ok(()));
    }
}));
let error_callback = Closure::once(Box::new(move |err| {
    if let Some(error_tx) = 
      error_tx.lock().ok().and_then(|mut opt| opt.take()) {
        error_tx.send(Err(err));
    }
}));
image.set_onload(Some(callback.as_ref().unchecked_ref()));
image.set_onload(Some(error_callback.as_ref().unchecked_ref()));
image.set_src("rhb.png");
success_rx.await;</pre>
			<p>At first glance, this looks like it's one function in our <code>browser</code> module, <code>load_image</code>, but on closer<a id="_idIndexMarker187"/> reflection, there's a lot here for just one function. For instance, if you <a id="_idIndexMarker188"/>so choose, you can create an image element without worrying about whether it's going to be loaded, or you might be willing to use <code>set_src</code> without concerning yourself with whether or not it's loaded. No, all that stuff after <code>let image = web_sys::HtmlImageElement::new().unwrap()</code> is really engine behavior. That means it's time for us to create our second module, <code>engine</code>!</p>
			<p>The <code>engine</code> module will contain libraries and functions that we will use throughout our game. We are <code>engine</code> module. In fact, to break down this behavior, we'll follow a few steps:</p>
			<ol>
				<li>Create a <code>browser</code> function, <code>new_image</code>.</li>
				<li>Create a <code>browser</code> function to create JS closures.</li>
				<li>Create an <code>engine</code> module.</li>
				<li>Create an <code>engine</code> function, <code>load_image</code>.</li>
			</ol>
			<p>Let's start with the changes to <code>browser</code>; we'll create two new functions to make <code>Closure</code> and an image:</p>
			<pre>pub fn new_image() -&gt; Result&lt;HtmlImageElement&gt; {
    HtmlImageElement::new().map_err(|err| anyhow!("Could 
      not create HtmlImageElement: {:#?}", err))
}
pub fn closure_once&lt;F, A, R&gt;(fn_once: F) -&gt;
  Closure&lt;F::FnMut&gt;
where
    F: 'static + WasmClosureFnOnce&lt;A, R&gt;,
{
    Closure::once(fn_once)
}</pre>
			<p>The first function is just a wrapper around <code>HtmlImageElement</code>; there's not much to explain. In the future, we may decide we want our own type for images, but for now, we'll stick with the browser-provided type. The <code>closure_once</code> function is complicated by its type signature. In this case, we just mimic the exact same type signature of the <code>Closure::once</code> function from <code>wasm_bindgen</code>. Later, we'll write some utility functions for the <code>Closure</code> types to make working with them easier, but for this one, we'll just create a straight wrapper.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">A compelling argument can be made that we should be converting even more types in this module. Specifically, we should use our own types for <code>Closure</code>, <code>HtmlImageElement</code>, and other browser-provided types. It's possible that's a better approach, but for now, we're going to stick with the types provided in the interest of both learning the material and keeping to a simple architecture. Like all decisions in programming, it's a trade-off.</p>
			<p>That covers <em class="italic">step 1</em> and <em class="italic">step 2</em>, and <em class="italic">step 3</em> is quick – create a file named <code>engine.rs</code> in the source directory and add a <code>mod engine</code> declaration to <code>lib.rs</code>. Now for <em class="italic">step 4</em>, the one we've <a id="_idIndexMarker190"/>been <a id="_idIndexMarker191"/>dreading. In <code>engine.rs</code>, add the following:</p>
			<pre>pub async fn load_image(source: &amp;str) -&gt; Result&lt;HtmlImageElement&gt; {
    let image = browser::new_image()?;
    let (complete_tx, complete_rx) = 
      channel::&lt;Result&lt;()&gt;&gt;();
    let success_tx = 
      Rc::new(Mutex::new(Some(complete_tx)));
    let error_tx = Rc::clone(&amp;success_tx);
    let success_callback = browser::closure_once(move || {
        if let Some(success_tx) =
          success_tx.lock().ok().and_then(
          |mut opt| opt.take()) {
            success_tx.send(Ok(()));
        }
    });
    let error_callback: Closure&lt;dyn FnMut(JsValue)&gt; = 
      browser::closure_once(move |err| {
        if let Some(error_tx) =
          error_tx.lock().ok().and_then(
          |mut opt| opt.take()) {
            error_tx.send(Err(anyhow!("Error Loading Image:
              {:#?}", err)));
        }
    });
    image.set_onload(Some(
      success_callback.as_ref().unchecked_ref()));
    image.set_onerror(Some(
      error_callback.as_ref().unchecked_ref()));
    image.set_src(source);
    complete_rx.await??;
    Ok(image)
}</pre>
			<p>I'm intentionally leaving out the <code>use</code> statements so that you get used to adding them and thinking about which declarations you need and are using. However, there are two traps to this code that I want to call out:</p>
			<ul>
				<li>In order for <code>unchecked_ref</code> to compile, you need to use <code>wasm_bindgen:JsCast</code>.</li>
				<li>When you import <code>channel</code>, make sure you choose <code>futures::channel::oneshot::channel</code>. There are a few different implementations of <code>channel</code>, and if you grab the wrong one by mistake, this code won't compile. </li>
			</ul>
			<p>When in doubt, take a look at <code>lib.rs</code> and verify which dependencies are being used there because that's <a id="_idIndexMarker192"/>where<a id="_idIndexMarker193"/> this code is being pulled from.</p>
			<p>Returning to the code we added, note that we're using our new <code>browser</code> functions throughout, with no direct dependencies on the <code>wasm-bindgen</code> functions. We are still dependent on <code>wasm_bindgen</code> for the <code>Closure</code> and <code>JSValue</code> types, as well as the <code>unchecked_ref</code> function, but we've reduced the amount of direct platform dependencies. Our only JS dependency is on <code>HtmlImageElement</code>. Now, take a look at the very beginning of the function and you'll see the <code>new_image</code> call can use the <code>?</code> operator to early return in the event of an error, with a standard Rust error type. This is why we mapped those errors in the <code>browser</code> functions.</p>
			<p>Moving past the first two lines of the method, the rest of the function is largely the same as before, replacing any direct calls to <code>wasm-bindgen</code> functions with their corresponding calls in <code>browser</code>. We've changed the channel to send <code>anyhow::Result</code> and used <code>anyhow!</code> in <code>error_callback</code>. This then allows us to end the function with a call to <code>complete_rx.await??</code> and <code>Ok(image)</code>. Those two <code>??</code> are not a misprint; <code>complete_rx.await</code> returns <code>Result&lt;Result&lt;(), anyhow::Error&gt;, Canceled&gt;</code>. Since <code>anyhow::Error</code> and <code>Canceled</code> both conform to <code>std::error::Error</code>, we can handle those errors with <code>?</code> each time.</p>
			<p>We still have two warnings in this function because both of the calls to <code>send</code> return <code>Result</code> that we aren't dealing with. We can't just use <code>?</code> because those results are wrapped in the <code>Closure</code> types, so we'll put off dealing with those unlikely errors for now and will cover error logging in <a href="B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203"><em class="italic">Chapter 9</em></a>, <em class="italic">Testing, Debugging, and Performance</em>.</p>
			<p>Now that you've done all that you should be able to, replace the code in <code>main</code> with a call to our new function:</p>
			<pre>let sheet: Sheet = json
    .into_serde()
    .expect("Could not convert rhb.json into a Sheet 
             structure");
<strong class="bold">let image = engine::load_image("rhb.png")</strong>
<strong class="bold">    .await</strong>
<strong class="bold">    .expect("Could not load rhb.png");</strong>
let mut frame = -1;</pre>
			<p>Nothing <a id="_idIndexMarker194"/>about <a id="_idIndexMarker195"/>loading <code>Sheet</code> has changed; that's just there to make sure you put this in the right place. After that, the code for <a id="_idIndexMarker196"/>animating our little <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) starts, but we're not going to be using that at all. That will be replaced with our game lo<a id="_idTextAnchor073"/>op, which we'll start introducing now.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor074"/>Creating a game loop</h1>
			<p>The <a id="_idIndexMarker197"/>core of this game, and virtually every game ever, is just an infinite loop. You can boil them all down to something like this:</p>
			<div><div><img alt="Figure 3.3 – A basic game loop" src="img/Figure_3.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – A basic game loop</p>
			<p>That means, theoretically, these are<a id="_idIndexMarker198"/> trivial to implement, as shown here:</p>
			<pre>while(!quit) {
    handleInput()
    updateGame()
    drawGame()
}</pre>
			<p>At its core, that's what we're going to write, but as you probably guessed, if it was that simple, I wouldn't have devoted an entire chapter to it. No, there are two problems we are going to be dealing with as we write it:</p>
			<ul>
				<li><code>requestAnimationFrame</code> function.</li>
				<li><strong class="bold">Frame rates and physics</strong>: The preceding loop we wrote would run as fast as the computer could go. Well, is every computer on the internet the same speed? No, of course not, so<a id="_idIndexMarker199"/> we'll need to make sure we can account for the <a id="_idIndexMarker200"/>differences between machine speeds in our loop, as best we can. We'll do that with what's called a <strong class="bold">fixed-step</strong> game loop.<p class="callout-heading">Important Note</p><p class="callout">You could probably write a book on game loops if you so chose, but this section owes a heavy debt to <a href="https://gameprogrammingpatterns.com/game-loop.html">https://gameprogrammingpatterns.com/game-loop.html</a> and <a href="https://gafferongames.com/post/fix_your_timestep/">https://gafferongames.com/post/fix_your_timestep/</a>.</p></li>
			</ul>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor076"/>RequestAnimationFrame</h2>
			<p>We'll start with the <code>requestAnimationFrame</code> function, which is a browser function that "requests" a new frame<a id="_idIndexMarker201"/> draw as soon as possible. The browser then fits that in frame draw in between handling things such as mouse clicks, operating system events, and cat videos. You might think that would be very slow, but in fact, typically, it's able to render at 60 frames per second, provided your game can keep up. The catch is that unlike our <code>setInterval</code> call from earlier, this function needs to be called at the end of every animation. A fairly straightforward JavaScript version of an animation might look like this:</p>
			<pre>function animate(now) {
    draw(now);
    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);</pre>
			<p>So, <code>requestAnimationFrame</code> is called with the <code>animate</code> function as its parameter. The browser then calls the <code>animate</code> function on the next frame, which draws and then requests the next frame. This looks like an infinite loop, but, in fact, doesn't block the browser because of the calls to <code>requestAnimationFrame</code>. This also takes a parameter, <code>now</code>, which is a timestamp in milliseconds of when the callback function was started. We'll use<a id="_idIndexMarker202"/> this to fix our physics as we evolve our game loop, but writing a game loop in Rust is a little weird because of the borrowing guarantees, so let's start by writing a very basic one.</p>
			<p>You can start by adding a simple wrapper for <code>requestAnimationFrame</code> to <code>browser</code>, as shown in the following code:</p>
			<pre>pub fn request_animation_frame(callback: &amp;Function) -&gt; 
  Result&lt;i32&gt; {
    window()?
        .request_animation_frame(callback)
        .map_err(|err| anyhow!("Cannot request animation
                                frame {:#?}", err))
}</pre>
			<p>The <code>Function</code> type is a pure JavaScript type and is only available in the <code>js-sys</code> package. While we could import that, I'd rather not add another crate dependency if possible; however, we don't actually have to use the <code>Function</code> type directly if we make a small change to the function signature and the implementation:</p>
			<pre>pub fn request_animation_frame(<strong class="bold">callback: &amp;Closure&lt;</strong>
<strong class="bold">  dyn FnMut(f64)&gt;</strong>) -&gt; Result&lt;i32&gt; {
    window()?
        .request_animation_frame(<strong class="bold">callback.as_ref().unchecked_ref()</strong>)
        .map_err(|err| anyhow!("Cannot request animation
                                frame {:#?}", err))
}</pre>
			<p>Instead of taking <code>&amp;Function</code>, our <code>request_animation_frame</code> will take <code>&amp;Closure&lt;dyn FnMut(f64)&gt;</code> as its parameter. Then, it will call <code>callback.as_ref().unchecked_ref()</code> when calling the <code>web-sys</code> version of <code>request_animation_frame</code>. This converts <code>Closure</code> into <code>Function</code>, without requiring an explicit dependency on the <code>Function</code> type, and it's worth thinking about when you're creating your own versions of these functions. The makers of <code>web-sys</code> have to match every single potential use case, and as such, they are going to create the widest possible interfaces. As an application programmer, you do not need most of what's in that library. Therefore, you can and should narrow the interface to your own use cases, making it easier for you to work with. In fact, in order to make things a little cleaner, we'll convert that into a type, with one small change:</p>
			<pre>pub type LoopClosure = Closure&lt;dyn FnMut(f64)&gt;;
pub fn request_animation_frame(callback: &amp;LoopClosure) -&gt;
  Result&lt;i32&gt; {
// ...</pre>
			<p>Moving on from my <a id="_idIndexMarker203"/>mini-rant, you might think you can now write a simple game loop, like so:</p>
			<pre>pub fn animate(perf: f64) {
    browser::request_animation_frame(animate);
}</pre>
			<p>Ah, if only, but remember that we need to pass a JavaScript <code>Closure</code>, not a Rust <code>fn</code>. Using the <code>Closure::once</code> that we used before won't work because this closure will be called more than once, but fortunately, there's <code>Closure::wrap</code>, which will do just that. We'll create a function in <code>browser</code> to create a <code>Closure</code> specific to the <code>request_animation_frame</code> function, called <code>create_raf_closure</code>:</p>
			<pre>pub fn create_raf_closure(f: impl FnMut(f64) + 'static) -&gt;
  LoopClosure {
    closure_wrap(Box::new(f))
}</pre>
			<p>The function being passed in has a <code>'static</code> lifetime. Any <code>FnMut</code> passed into this function cannot have any non-static references. This wasn't a decision on my part; it's a requirement of the <code>Closure::wrap</code> function we'll be calling into.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">For more information on static lifetimes, take a look at the <em class="italic">Rust by Example</em> book, available for free here: <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html">https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html</a>. </p>
			<p>Speaking of <code>Closure::wrap</code>, let's wrap it in a <code>closure_wrap</code> function so that the code we just added will compile, which looks like the following:</p>
			<pre>pub fn closure_wrap&lt;T: WasmClosure + ?Sized&gt;(data: Box&lt;T&gt;)
  -&gt; Closure&lt;T&gt; {
    Closure::wrap(data)
}</pre>
			<p>This is another one of<a id="_idIndexMarker204"/> those wrapper functions where we are just matching the same signature as the function being wrapped – <code>Closure::wrap</code>. Because the <code>wrap</code> function on <code>Closure</code> creates a <code>Closure</code> that can be called multiple times, it needs to be wrapped in a <code>Box</code> and stored on the heap.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The nightly build of <code>wasm-bindgen</code> provides a more ergonomic <code>new</code> function that handles the boxing for you. We'll stick to the stable build in this book, but you are welcome to try nightly.</p>
			<p>Now that you know the basic game loop and how to call <code>request_animation_frame</code>, you might think, "I've got this" and create the game loop as follows:</p>
			<pre>let animate = create_raf_closure(move |perf| {
    request_animation_frame(animate);
});
request_animation_frame(animate);</pre>
			<p>This is closer, but it's not there yet. Remember earlier that the <code>Closure</code> we pass to <code>create_raf_closure</code> has to have a <code>'static</code> lifetime, meaning everything that the <code>Closure</code> references must be owned by the closure. That's not the case right now. The <code>animate</code> variable is owned by the current scope and will be destroyed when that scope completes. Of course, <code>animate</code> is itself<em class="italic"> </em>the <code>Closure</code> because this is a self-referencing data<a id="_idIndexMarker205"/> structure. The <code>animate</code> variable is the <code>Closure</code> but is also referenced inside the <code>Closure</code>. This is a classic Rust problem because the <code>borrow</code> checker cannot allow it.</p>
			<p>Imagine what would happen if this wasn't the case – if <code>animate</code> could be referenced in the <code>Closure</code> but be owned by the scope outside the <code>Closure</code>. It would be destroyed when the program exited this scope, and <code>Closure</code> would no longer be valid – a <code>Null</code> pointer error, and a crash. This is the trouble with a self-referencing data structure, so we'll need a way to work around the <code>borrow</code> checker.</p>
			<p>With nowhere to put this code just yet, let's have another crack at a hypothetical loop:</p>
			<pre>let f = Rc&lt;RefCell&lt;Option&lt;LoopClosure&gt;&gt;&gt; =  
  Rc::new(RefCell::new(None));
let g = f.clone();
let animate = Some(create_raf_closure(move |perf: f64| {
    request_animation_frame(f.borrow().as_ref().unwrap());
});
*g.borrow_mut() = animate;
request_animation_frame(g.borrow().as_ref().unwrap());</pre>
			<p>Right now, I kinda wish I was writing JavaScript, but let's work slowly through this code. What we're doing is creating two references to the same place in memory, using <code>Rc</code> <code>struct</code>, allowing us to both take <code>f</code> and <code>g</code> and point them at the same thing but also move <code>f</code> into <code>animate Closure</code>. The other trick is that they both point to <code>Option</code> so that we can move <code>f</code> into <code>Closure</code> before it is completely defined. Finally, when we assign to <code>g</code> the <code>Closure</code> with <code>*g.borrow_mut() = animate</code>, we <code>f</code> because they are <a id="_idIndexMarker206"/>pointing to the same place. Did you get all that? No, me neither. Let's go through the types really quickly to reiterate what we did. <code>f</code> is set to the following:</p>
			<ul>
				<li><code>Rc</code> to create a reference-counted pointer</li>
				<li><code>RefCell</code> to allow for interior mutability</li>
				<li><code>Option</code> to allow us to assign <code>f</code> to <code>None</code></li>
				<li><code>LoopClosure</code> to hold a mutable <code>Closure</code> that matches the <code>request_animation_frame</code> parameter</li>
			</ul>
			<p><code>g</code> is then set to a clone of <code>f</code> so that they point to the same thing, and <code>f</code> is moved into <code>animate</code> <code>Closure</code>. <code>g</code> is assigned to <code>animate</code> via the dereference <code>*</code> operator and <code>borrow_mut</code> functions. Because <code>f</code> points to the same place as <code>g</code>, it will also contain <code>animate Closure</code>. Finally, we can call <code>request_animation_frame</code>, both outside and inside <code>Closure</code>, by borrowing it, converting it to a reference, and calling <code>unwrap</code> to actually get the real <code>Closure</code>. Yes, <code>unwrap</code> is back; we'll deal with one of those when we create our real function. Finally, <code>g</code> can be destroyed when it leaves scope because <code>f</code> is still in <code>Closure</code> and will keep the memory around.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Once again, I'd love to take credit for this code, but the truth is that it's largely defined in the <code>wasm-bindgen</code> guide at <a href="https://bit.ly/3v5FG3j">https://bit.ly/3v5FG3j</a>.</p>
			<p>Now that we<a id="_idIndexMarker207"/> know what the core of our game loop is going t<a id="_idTextAnchor077"/>o look like, how do we integrate it with a game?</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor078"/>A game trait</h2>
			<p>To write our game loop, we have a few options. We could just write the game in the loop, but that would look <a id="_idIndexMarker208"/>suspiciously similar to what we started with before. We could create a <code>GameLoop</code> struct with functions for <code>update</code> and <code>draw</code>, which is a significant improvement but still ties everything into one structure. We're going to go slightly beyond that and take inspiration from a popular game framework, XNA, or MonoGame in its modern incarnation. In the XNA framework, the game developer will implement a <code>Game</code> type, with methods for <code>update</code> and <code>draw</code>. This is slightly more complex than jamming all the code into one place but is significantly less so than a complete entity-component framework. It should work well for our purposes since it starts small and should allow for expansion as the game gets larger. There's a reason XNA was very successful.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can learn about XNA's modern equivalent, MonoGame, at <a href="https://www.monogame.net/">https://www.monogame.net/</a>.</p>
			<p>We'll create a <code>start</code> function that accepts anything that implements the <code>Game</code> trait. The <code>Game</code> trait will start with two functions, <code>update</code> and <code>draw</code>. We'll run that through our game loop to first update and then draw our scene. All of this will go into the <code>engine</code> module; indeed, arguably, this is our entire "engine." Let's start with the simple version – first, the trait:</p>
			<pre>pub trait Game {
    fn update(&amp;mut self);
    fn draw(&amp;self, context: &amp;CanvasRenderingContext2d);
}</pre>
			<p>So far so good. Note how the <code>draw</code> function takes <code>CanvasRenderingContext2d</code> as a parameter. Now for the rest of the loop – you can add this after the <code>Game</code> trait or <code>load_image</code>; it doesn't really matter as long as it's in the <code>engine</code> module:</p>
			<pre>pub struct GameLoop;
type SharedLoopClosure = Rc&lt;RefCell&lt;Option&lt;LoopClosure&gt;&gt;&gt;;
impl GameLoop {
    pub async fn start(mut game: impl Game + 'static) -&gt; 
      Result&lt;()&gt; {
        let f: SharedLoopClosure =
          Rc::new(RefCell::new(None));
        let g = f.clone();
        *g.borrow_mut() = Some(
          browser::create_raf_closure(move |perf: f64| {
            game.update();
            game.draw(&amp;browser::context().expect("Context
              should exist"));
            browser::request_animation_frame(
              f.borrow().as_ref().unwrap());
        }));
        browser::request_animation_frame(
            g.borrow()
                .as_ref()
                .ok_or_else(|| anyhow!("GameLoop: Loop is 
                                        None"))?,
        )?;
        Ok(())
    }
}</pre>
			<p>This is a bit larger but it's nothing you haven't seen before. We're going to create a <code>GameLoop</code> struct with no data and add a <code>SharedLoopClosure</code> type to simplify the type of the <code>f</code> and <code>g</code> variables. Then, we'll add an implementation of <code>GameLoop</code> with one method, <code>start</code>, that takes the <code>Game</code> trait as a parameter. Note that the trait is <code>'static</code> because anything moved into the "raf" closure has to be <code>'static</code>. We follow the snippets we<a id="_idIndexMarker209"/> used before to set up our <code>request_animation_frame</code> loop, and the key change is on the inside where we update and then draw, passing the <code>draw</code> function <code>CanvasRenderingContext2d</code>.</p>
			<p>There's a problem with this kind of naive game loop. Typically, <code>request_animation_frame</code> runs at 60 frames per second, but if either <code>update</code> or <code>draw</code> takes longer than 1/60th of a second, it will slow down, making the game move more slowly. A long time ago, I recall beating levels by turning off the "<strong class="bold">Turbo</strong>" button on my desktop, making it possible to beat previously impossible challenges because the game became easier to play at slower speeds. Since we want a consistent experience across processor speeds, we'll tak<a id="_idTextAnchor079"/>e a common approach called "fixing" the time step.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor080"/>Fixing our time step</h2>
			<p>You might <a id="_idIndexMarker210"/>notice that the <code>update</code> function we wrote doesn't take <code>perf</code> as a parameter; in fact, it's unused. Now, imagine trying to simulate a dog running across the screen, with no knowledge of how much time has passed between frames. Depending on the computer and your guess, the dog could saunter from left to right, or shoot past like a bullet. What we could do is send the delta time on each update, which can work but gets complicated very quickly. Instead, we'll assume every single tick takes the same amount of time, 1/60th of a second, and call <code>update</code> several times to "catch up" if we fall behind. It looks like this:</p>
			<div><div><img alt="Figure 3.4 – A fixed step game loop" src="img/Figure_3.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – A fixed step game loop</p>
			<p>This isn't a perfect<a id="_idIndexMarker211"/> solution; if our game is very slow, it'll grind to a halt, but it should be good enough for our purposes. This is why I had us create a <code>GameLoop</code> struct – to track the time of the last update. We'll add two fields to the <code>GameLoop</code> struct:</p>
			<pre>const FRAME_SIZE: f32 = 1.0 / 60.0 * 1000.0;
pub struct GameLoop {
    last_frame: f64,
    accumulated_delta: f32,
}</pre>
			<p>This adds a constant for the<a id="_idIndexMarker212"/> length of a frame, converted to milliseconds. We'll track when the previous frame was requested in the <code>last_frame</code> field, and we'll accumulate a delta that totals up the physics time since the last render. It's not quite the same thing twice, as you'll see when we implement that counter in the <code>start</code> function. Speaking of that function, we'll need to initialize a mutable <code>GameLoop</code> at the beginning of that function:</p>
			<pre>impl GameLoop {
    pub async fn start(mut game: impl Game + 'static) -&gt;
      Result&lt;()&gt; {
        let mut game_loop = GameLoop {
            last_frame: browser::now()?,
            accumulated_delta: 0.0,
        };
        ...</pre>
			<p>This initializes <code>GameLoop</code> appropriately, using <code>now</code> as the time of the last frame instead of <code>0</code> so that our loop doesn't perform several million updates before the first render. <code>browser::now()</code> hasn't been implemented yet, so you'll need to add it to the <code>browser</code> module:</p>
			<pre>pub fn now() -&gt; Result&lt;f64&gt; {
    Ok(window()?
        .performance()
        .ok_or_else(|| anyhow!
            ("Performance object not found"))?
        .now())
}</pre>
			<p>This is just a wrapper around the web browser's <code>now</code> function. If you've been diligently following, you will probably recognize that this causes a compiler error. You'll need to add the "<code>Performance</code>" feature flag to the <code>web-sys</code> features list to bring in that function.</p>
			<p>Now that we've created a game loop object, inside the <code>request_animation_frame</code> closure, we'll add our accumulator:</p>
			<pre>*g.borrow_mut() = Some(browser::create_raf_closure(move 
  |perf: f64| {
    game_loop.accumulated_delta += (
      perf - game_loop.last_frame) as f32;
    while game_loop.accumulated_delta &gt; FRAME_SIZE {
        game.update();
        game_loop.accumulated_delta -= FRAME_SIZE;
    }
    game_loop.last_frame = perf;
    game.draw(&amp;browser::context().expect("Context should
      exist"));</pre>
			<p>What's changed since<a id="_idIndexMarker213"/> last time is that instead of just calling the <code>update</code> function immediately, we calculate the difference between <code>perf</code>, which if you remember from earlier is a high-res timestamp of the time that the <code>request_animation_frame</code> function started executing callback functions. We get the difference between now (in <code>perf</code>) and the previous frame and add that to <code>accumulated_delta</code>. Then, we compare this to our desired <code>FRAME_SIZE</code> (that's 1/60th of a second), and if there's <code>update</code>. Then we subtract the frame size from the delta. What is the effect of all this? If <code>game.draw</code> takes too long so that we cannot complete 1 frame in 1/60th of a second, the code will run extra updates to catch up.</p>
			<p>An example is helpful here. Assume you started playing the game at time <code>0</code>, the beginning of the world. When the first callback executes for <code>request_animation_frame</code> its probably very close to <code>0</code>, perhaps as low as <code>1</code> millisecond, because there's no delay on the first frame. The code will add that to <code>accumulated_delta</code> and then compare it to <code>FRAME_SIZE</code> and see that there hasn't been enough delta accumulation, so <code>update</code> is skipped. The <code>last_frame</code> value is stored (again, we'll say it's <code>1</code>), the screen is drawn, and then <code>request_animation_frame</code> is called.</p>
			<p>The second time though, the value of <code>perf</code> is likely to be about the size of the first frame. We'll use <code>17</code> milliseconds for simple math. So <code>perf</code> is <code>17</code>; subtract from it the <code>last_frame</code>, which is <code>1</code>, and add <code>16</code> milliseconds to <code>accumulated_delta</code>. The new value of <code>accumulated_delta</code> is <code>17</code>, so the game is updated once and <code>accumulated_delta</code> is reduced to <code>1</code>. The game continues with one update to one draw until something goes <a id="_idIndexMarker214"/>wrong. The <code>draw</code> call takes <code>40</code> milliseconds! Who knows why – maybe an autoplay video started up by surprise, taking resources. It doesn't matter because <code>accumulated_delta</code> shoots up to <code>40</code>, which is larger than <code>2</code> frames. Now, the loop on <code>accumulated_delta</code> runs <code>update</code> twice, dropping a frame of animation to compensate for the drop in performance. The important thing to remember here is that it drops a <em class="italic">draw</em> but not an <em class="italic">update</em>, so while the player might see some visual artifacts, the physics will still work without issue.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You might wonder what happens to the extra <code>accumulated_delta</code> since it's unlikely to be an exact multiple of <code>FRAME_SIZE</code>. More advanced game loops will pass that into the draw and use it to interpolate between the two update values. We shouldn't need that for our game and will just roll that <code>delta</code> over to the next frame.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Why use an <code>f32</code> for the <code>accumulated_delta</code>? That's very observant of you! The short version is, because we can. The slightly longer version is that we only use <code>f64</code> as often as we do because JavaScript uses a 64-bit <code>Number</code> type for all its numbers. If I could, I'd use smaller values whenever possible, and integers as well, because the extra size of <code>f64</code> isn't really necessary and can cause a surprising drag on performance when repeated everywhere.</p>
			<p>So, there you have it – your game loop, at least the "looping" part of it. While it's usable now, it doesn't provide an easy way to load our assets. While we could just leave things as they are and always<a id="_idIndexMarker215"/> load assets before we start our game loop, a cleaner<a id="_idTextAnchor081"/> solution is to integrate that rule into the game loop.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor082"/>Loading assets</h2>
			<p>Expanding our game loop to <a id="_idIndexMarker216"/>handle loading assets is going to require adding a function to our trait, an <code>async</code> one to be precise. This will allow us to put all our asynchronous code that's currently wrapped in the <code>spawn_local</code> in <code>lib</code> and put it in a function that returns <code>Result</code> with <code>Game</code> in it. You can start by adding that function to the <code>Game</code> trait:</p>
			<pre>pub trait Game {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt;;
    fn update(&amp;mut self);
    fn draw(&amp;self, context: &amp;Renderer);
}</pre>
			<p>Unfortunately, that doesn't compile. <code>async</code> trait functions haven't landed in stable Rust yet, but fortunately, we can use a crate to get that functionality. Add <code>async-trait = "0.1.52"</code> to <code>Cargo.toml</code> and then add the following attribute macro to the trait:</p>
			<pre>#[async_trait(?Send)]
pub trait Game {</pre>
			<p>You'll also need to import <code>async_trait::async_trait</code>. The <code>async_trait</code> allows us to add <code>async</code> functions to a trait. We can use it with the <code>?Send</code> trait because we don't need our futures to be thread-safe. Now, we can add this to the game loop:</p>
			<pre>impl GameLoop {
    pub async fn start(game: impl Game + 'static) -&gt;
      Result&lt;()&gt; {
        let mut game = game.initialize().await?;
        ....</pre>
			<p>And that's it! The game gets initialized, asynchronously, and with <code>Result</code> on the first line. Note that the passed-in <code>game</code> no longer has to be mutable since we're not mutating it in the function <a id="_idIndexMarker217"/>anywhere. We're almost ready to integrate our old <code>set_interval</code> into this, but the<a id="_idTextAnchor083"/>re's a little more cleanup I'd like to do around drawing.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor084"/>Cleaner drawing</h2>
			<p>Currently, we're <a id="_idIndexMarker218"/>sending a raw <code>CanvasRenderingContext2d</code> to the draw loop, with all of its awkward functions such as <code>draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh</code>. This works but it's ugly, and much like we did with the <code>browser</code> module, we can use a wrapper to narrow the context's wide interface to a smaller one, tailored to our needs. We'll replace passing <code>CanvasRenderingContext2d</code> with our own <code>Renderer</code> object that has easier-to-use functions.</p>
			<p>We'll start by creating a structure for our <code>Renderer</code> in <code>engine</code>:</p>
			<pre>pub struct Renderer {
    context: CanvasRenderingContext2d,
}</pre>
			<p>This is a simple wrapper containing the rendering context. For now, we'll just add the two implementation methods to the <code>Renderer</code> struct:</p>
			<pre>impl Renderer {
    pub fn clear(&amp;self, rect: &amp;Rect) {
        self.context.clear_rect(
            rect.x.into(),
            rect.y.into(),
            rect.width.into(),
            rect.height.into(),
        );
    }
    pub fn draw_image(&amp;self, image: &amp;HtmlImageElement,
      frame: &amp;Rect, destination: &amp;Rect) {
        self.context
            .draw_image_with_html_image_element_and_sw_and_sh_                and_dx_and_dy_and_dw_and_dh(
                &amp;image,
                frame.x.into(),
                frame.y.into(),
                frame.width.into(),
                frame.height.into(),
                destination.x.into(),
                destination.y.into(),
                destination.width.into(),
                destination.height.into(),
            )
            .expect("Drawing is throwing exceptions!
                     Unrecoverable error.");
    }
}</pre>
			<p>These two functions, <code>clear</code> and <code>draw_image</code>, both wrap <code>context</code> functions but do so using fewer parameters. Instead<a id="_idIndexMarker219"/> of four parameters and <code>clear_rect</code>, we pass <code>clear</code> <code>Rect</code>. Instead of that incredibly long function name, we pass <code>draw_image</code> <code>HtmlImageElement</code> and two <code>Rect</code> structures. Currently, we go ahead and use <code>expect</code> to panic! here if we can't draw. I am convinced that this should return <code>Result</code>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">By now, there's been code in this book that you've thought could be done better. Try that out! I do that all the time when I follow books, and there's no reason you shouldn't too. Just try to remember where you've diverged from the book.</p>
			<p>Of course, both of these<a id="_idIndexMarker220"/> functions take <code>Rect</code>, but we don't have a <code>Rect</code> structure. Let's add that to the <code>engine</code> now:</p>
			<pre>pub struct Rect {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}</pre>
			<p>Now we can change the draw function to take <code>Renderer</code> instead of <code>CanvasRenderingContext2d</code>. So, we update the trait:</p>
			<pre>#[async_trait(?Send)]
pub trait Game {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer);
}</pre>
			<p>Then, we can make a change to the loop. Right now, we create <code>context</code> in the <code>Closure</code> that we pass to <code>create_raf_closure</code>. That call returns <code>Result</code>, so to get access to <code>context</code>, we have to call <code>unwrap</code> or <code>expect</code>. The cleaner approach we can use now is to create <code>Renderer</code>, with <code>Context</code> outside of <code>Closure</code>, as shown here:</p>
			<pre>let mut game_loop = GameLoop {
    last_frame: browser::now()?,
    accumulated_delta: 0.0,
};
<strong class="bold">let renderer = Renderer {</strong>
<strong class="bold">    context: browser::context()?,</strong>
<strong class="bold">};</strong>
...
*g.borrow_mut() = Some(browser::create_raf_closure(
  move |perf: f64| {
    ...
<strong class="bold">    game.draw(&amp;renderer);</strong>
    browser::request_animation_frame(f.borrow().as_ref().        unwrap());
}));</pre>
			<p>Moving this <a id="_idIndexMarker221"/>outside of the <code>request_animation_frame</code> closure means we don't need to use the <code>expect</code> syntax anymore – nice! </p>
			<p>The small change to <code>draw</code>, turning it into <code>game.draw(&amp;renderer)</code>, will make our <code>draw</code> function easier to write. I think we're meeting our goal of changing the code to make it <em class="italic">easier</em> to move forward. Let's prove it by <a id="_idTextAnchor085"/>taking our animation code out of <code>lib</code> and using the game loop.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor086"/>Integrating the game loop</h2>
			<p>It's great that we've <a id="_idIndexMarker222"/>written this game loop and all, but it's about time we actually use it. Remember that we have our <code>GameLoop</code> structure, but it operates on a <code>Game</code> trait. So in order to use the loop, we need to implement that trait. We'll implement it in another module, <code>game</code>, which we'll create in <code>game.rs</code> and then add to the library using the <code>mod game</code> instruction declaration in <code>lib.rs</code>. We'll start with a couple of structures:</p>
			<pre>use crate::engine::{Game, Renderer};
use anyhow::Result;
use async_trait::async_trait;
pub struct WalkTheDog;
#[async_trait(?Send)]
impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        Ok(Box::new(WalkTheDog {}))
    }
    fn update(&amp;mut self) {}
    fn draw(&amp;self, renderer: &amp;Renderer) {}
}</pre>
			<p>Make sure that you add the <code>#[async_trait(?Send)]</code> annotation, which allows you to implement a trait with the <code>async</code> functions. Provided you add the required <code>use</code> declarations from <code>engine</code>, this compiles because <code>Game</code> implements the trait as needed. It doesn't do anything, but it compiles. The <code>initialize</code> function might look a little strange because we're taking <code>self</code> and just throwing it away in favor of a new <code>WalkTheDog</code> structure – thrown on the heap, no less! We're doing that for some changes that you'll see in the next chapter, so just bear with me for now. </p>
			<p>Now, let's take the <a id="_idIndexMarker223"/>code that draws from <code>lib.rs</code> and move it into <code>draw</code>, updating it along the way:</p>
			<pre>fn draw(&amp;self, renderer: &amp;Renderer) {
    let frame_name = format!("Run ({}).png", self.frame +
                              1);
    let sprite = self.sheet.frames.get(&amp;frame_name).expect(
      "Cell not found");
    renderer.clear(Rect {
        x: 0.0,
        y: 0.0,
        width: 600.0,
        height: 600.0,
    });
    renderer.draw_image(
        &amp;self.image,
        Rect {
            x: sprite.frame.x.into(),
            y: sprite.frame.y.into(),
            width: sprite.frame.w.into(),
            height: sprite.frame.h.into(),
        },
        Rect {
            x: 300.0,
            y: 300.0,
            width: sprite.frame.w.into(),
            height: sprite.frame.h.into(),
        },
    );
}</pre>
			<p>This only contains slight changes to the code in <code>lib.rs</code>, although it definitely won't compile. Calls to <code>context</code> are replaced with calls to <code>renderer</code>, and we've used the new <code>Rect</code> structure. This won't <a id="_idIndexMarker224"/>compile because <code>self</code> doesn't have <code>sheet</code>, <code>frame</code>, or <code>image</code>. We'll need to add that to the <code>game</code> module, as follows:</p>
			<pre>#[derive(Deserialize)]
struct SheetRect {
    x: i16,
    y: i16,
    w: i16,
    h: i16,
}
#[derive(Deserialize)]
struct Cell {
    frame: SheetRect,
}
#[derive(Deserialize)]
pub struct Sheet {
    frames: HashMap&lt;String, Cell&gt;,
}
pub struct WalkTheDog {
    image: HtmlImageElement,
    sheet: Sheet,
    frame: u8,
}</pre>
			<p>Here, we've moved the structures from <code>lib.rs</code> that serialize the JSON from our sprite sheet and added fields for <code>frame</code>, <code>HtmlImageElement</code>, and <code>Sheet</code> to the <code>WalkTheDog</code> struct. Pay close attention to the fact that we've taken <code>Rect</code> from <code>lib</code> and renamed it <code>SheetRect</code>. This is the specific rectangle from our sprite sheet. In <code>game</code>, we also have a <code>Rect</code> structure. This is the rectangle that we'll use as a game domain object. This rename is<a id="_idIndexMarker225"/> confusing right now but is done to differentiate the two rectangles and is helpful as we go forward.</p>
			<p>The <code>WalkTheDog</code> structure has the fields needed to make <code>draw</code> compile, but it may make you wonder about <code>initialize</code>. Specifically, if we're going to move our loading code to <code>initialize</code>, does the <code>WalkTheDog</code> struct really always have <code>HtmlImageElement</code> and <code>Sheet</code>? No, it does not. We'll need to convert those fields to <code>Option</code> types and make the <code>draw</code> function account for them:</p>
			<pre>pub struct WalkTheDog {
    image: Option&lt;HtmlImageElement&gt;,
    sheet: Option&lt;Sheet&gt;,
    frame: u8,
}</pre>
			<p>We can use the <code>as_ref()</code> function to borrow <code>image</code> and <code>sheet</code>, and then use the <code>and_then</code> and <code>map</code> <code>Option</code> functions to cleanly get the frame and then draw it:</p>
			<pre>fn draw(&amp;self, renderer: &amp;Renderer) {
    let frame_name = format!("Run ({}).png", self.frame + 1);
    let sprite = self
        .sheet
        <strong class="bold">.as_ref()</strong>
        .and_then(|sheet| sheet.frames.get(&amp;frame_name))
        .expect("Cell not found");
    renderer.clear(&amp;Rect {
        x: 0.0,
        y: 0.0,
        width: 600.0,
        height: 600.0,
    });
    <strong class="bold">self.image.as_ref().map(|image| {</strong>
        renderer.draw_image(
            &amp;image,
            &amp;Rect {
                x: sprite.frame.x.into(),
                y: sprite.frame.y.into(),
                width: sprite.frame.w.into(),
                height: sprite.frame.h.into(),
            },
            &amp;Rect {
                x: 300.0,
                y: 300.0,
                width: sprite.frame.w.into(),
                height: sprite.frame.h.into(),
            },
        );
    });</pre>
			<p>This is great – we've got a game that draws absolutely nothing, but that's okay since our initialize code still doesn't compile. Let's prepare to draw by copying our loading code from <code>lib.rs</code> to the <code>initialize</code> function in the game loop. Don't do any cutting and pasting yet; we'll go ahead <a id="_idIndexMarker226"/>and clean up <code>lib.rs</code> at the end. <code>Initialize</code> should now look like this:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        let sheet: Sheet = browser::fetch_json("rhb.json")
            .await
            .expect("Could not fetch rhb.json")
            .into_serde()
            .expect("Could not convert rhb.json into a 
                     Sheet structure");
        let image = engine::load_image("rhb.png")
            .await
            .expect("Could not load rhb.png");
        Ok(Box::new(WalkTheDog {
            image: Some(image),
            sheet: Some(sheet),
            frame: self.frame,
        }))
    }
    ...</pre>
			<p>That's a great copy and paste, but we can make it far more concise by using the <code>?</code> operator. Here's the version with that improvement:</p>
			<pre>    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        let sheet = browser::fetch_json(
          "rhb.json").await?.into_serde()?;
        let image = 
          Some(engine::load_image("rhb.png").await?);
        Ok(Box::new(WalkTheDog {
            image,
            sheet,
            frame: self.frame,
        }))
    }</pre>
			<p>Look how small and clean that function is. It only took us three tries, but we got there. Now that we have <code>initialize</code> and <code>draw</code>, we can write <code>update</code>. The version we wrote in <code>lib.rs</code> used <code>set_interval_with_callback_and_timeout_and_arguments_0</code> to animate our Red Hat Boy, but that's not going to work anymore. Instead, the <code>update</code> function will need to keep <a id="_idIndexMarker227"/>track of the number of frames that have passed and advance when it's appropriate. In the original code, we called the <code>set_interval</code> callback every <code>50</code> milliseconds. In this new code, <code>update</code> will be called every 1/60th of a second, or <code>16.7</code> milliseconds. So, in order to approximately match the animation, we'll want to update the current sprite frame every three updates; otherwise, our little RHB will run very, very fast.</p>
			<p>If you look at the <code>rhb.json</code> file, you can see that there are eight frames in the <code>Run</code> animation. If we want to advance a sprite frame every 3 updates, that means it will take 24 updates to complete the animation. At that point, we'll want to return to the beginning and play it again. So, we'll need to calculate the sprite frame from the frame count, which is updated in the <code>update</code> function:</p>
			<pre>fn update(&amp;mut self) {
    if self.frame &lt; 23 {
        self.frame += 1;
    } else {
        self.frame = 0;
    }
}</pre>
			<p>This won't work with our current <code>draw</code> code because it uses <code>frame</code> to look up the sprite to render. It will crash when it looks for <code>Run (9).png</code>, which doesn't exist. We'll update the <code>draw</code> function to get the sprite index from <code>frame</code>:</p>
			<pre>fn draw(&amp;self, renderer: &amp;Renderer) {
    let current_sprite = (self.frame / 3) + 1;
    let frame_name = format!("Run ({}).png", 
      current_sprite);
    ...</pre>
			<p>The <code>current_sprite</code> variable will cycle from one to eight, and then loop back again. Don't believe me? Feel free to use the <code>log!</code> macro we wrote earlier to check my work; in fact, I encourage you to. Not <a id="_idIndexMarker228"/>because I'm arrogant but because it's always good to experiment with the code, rather than blindly typing it in. We then take that number and use it to look up the frame name.</p>
			<p>With that accomplished, we now have a game loop that can render to the canvas and a game that renders our running RHB; we just need to integrate it. We'll add a plain constructor to the <code>WalkTheDog</code> struct, right under the <code>struct</code> definition in <code>engine</code>:</p>
			<pre>impl WalkTheDog {
    pub fn new() -&gt; Self {
        WalkTheDog {
            image: None,
            sheet: None,
            frame: 0,
        }
    }
}</pre>
			<p>Nothing spectacular there – just something to make it easier to create the game object. And now for the moment you've been waiting for – the new main function integrating all these changes:</p>
			<pre>#[wasm_bindgen(start)]
pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {
    console_error_panic_hook::set_once();
    browser::spawn_local(async move {
        let game = WalkTheDog::new();
        GameLoop::start(game)
            .await
            .expect("Could not start game loop");
    });
    Ok(())
}</pre>
			<p>No, really, that's it – that's the <a id="_idIndexMarker229"/>whole thing. You spawn a local future, create a new game, and then call <code>GameLoop::start(game).await</code> to start it up. You can delete all the unused code from <code>lib.rs</code>, such as the extra <code>use</code> declarations and the structures we defined when everything was here. It looks great!</p>
			<p>We changed a lot of code to get<a id="_idIndexMarker230"/> here, but now we have a running game with a proper loop. We could end the chapter here, but it woul<a id="_idTextAnchor087"/>d be kind of nice if the code actually did something new, wouldn't it?</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor088"/>Adding keyboard input</h1>
			<p>Most games have<a id="_idIndexMarker231"/> some form of user input; otherwise, they aren't much of a game. In this section, we'll start listening to keyboard events and use them to control our RHB. That means adding keyboard input to the game loop and passing that into the <code>update</code> function. What we will <em class="italic">not</em> be doing is yet more refactoring. The system is reasonably well factored at this point and is open to our new changes.</p>
			<p>The specific process by which we'll get keyboard events is probably a little different than you're used to if you do web development. In a normal program, you would listen for keys to get pressed – in other words, pushed down and then released – and then do something such as update the screen when the button is released. This doesn't fit in with a game because typical players want the action to happen as soon as a key is pushed down and want it to continue for as long as it's held. Think of moving around the screen with the arrow keys. You expect motion to start the second you hit the arrow key, not after you release it. In addition, traditional programming doesn't account for things like pressing "up" and "right" at the same time. If we process those as two separate actions, we'll move right, then up, then right, and then up, like we're moving up the stairs. What we'll do is listen to every <code>keyup</code> and <code>keydown</code> event, and bundle that all up into a <code>keystate</code> that stores every currently pressed key. Then we'll pass that state to the <code>update</code> function so that the game can figure out just what to do with all the currently pressed keys.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">This approach is common in games, and it leads to one downside. If you want to trigger something only when a button is pressed, such as firing a gun, you have to keep track of whether or not the previous update had the key up and the next update had it down. So, by flipping from an event-driven approach to a global key state, we lose the events. Fortunately, this is easily recreated.</p>
			<p>To get keyboard events, we have to listen for the <code>keydown</code> and <code>keyup</code> events on <code>canvas</code>. Let's start with a <a id="_idIndexMarker232"/>new function in <code>engine</code>, <code>prepare_input()</code>:</p>
			<pre>fn prepare_input() {
    let onkeydown = browser::closure_wrap(
      Box::new(move |keycode: web_sys::KeyboardEvent| {})
        as Box&lt;dyn FnMut(web_sys::KeyboardEvent)&gt;);
    let onkeyup = browser::closure_wrap(Box::new(
      move |keycode: web_sys::KeyboardEvent| {})
        as Box&lt;dyn FnMut(web_sys::KeyboardEvent)&gt;);
    browser::canvas()
        .unwrap()
        .set_onkeydown(Some(onkeydown.as_ref().unchecked_ref()));
    browser::canvas()
        .unwrap()
        .set_onkeyup(Some(onkeyup.as_ref().unchecked_ref()));
    onkeydown.forget();
    onkeyup.forget();
}</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">Make sure you set up your <code>canvas</code> element with a <code>tabIndex</code> attribute in the HTML file; otherwise, it cannot get focus and have keyboard events.</p>
			<p>This is enough to get us started. It should look familiar because we're setting up <code>Closure</code> objects in the <a id="_idIndexMarker233"/>same way we did for <code>load_image</code> and <code>request_animation_frame</code>. We have to make sure we call <code>forget</code> on both of the <code>Closure</code> instances so that they aren't deallocated immediately after being set up because nothing in the Rust application is holding onto them. You'll also need to add the <code>KeyboardEvent</code> feature to <code>web-sys</code> to include it. Otherwise, there is nothing here you haven't seen before. It just doesn't do anything yet.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Unlike most things in Rust, if you don't add a <code>forget</code> call, you won't get a compile-time error. You'll get a panic almost immediately and not always with a helpful error message. If you think you've set up callbacks into JavaScript and you're getting panics, ask yourself whether anything is holding on to that callback in your program. If nothing is, you've probably forgotten to add <code>forget</code>.</p>
			<p>We're listening to the input, so now we need to keep track of all of it. It's tempting to start trying to condense the events into <code>keystate</code> in this function, but that's troublesome because this function only handles one <code>keyup</code> or <code>keydown</code> at a time and doesn't know anything about all the other keys. If you wanted to keep track of an <code>ArrowUp</code> and <code>ArrowRight</code> being pressed at the same time, you couldn't do it here. What we will do is set up the listeners once before the game loop starts, such as with <code>initialize</code>, and then process all the new key events on every update updating our <code>keystate</code>. This will mean sharing state from these closures with the closure we passed to <code>request_animation_frame</code>. It's time to add a channel. We'll create an <code>unbounded</code> channel, which is a channel that will grow forever if you let it, here in <code>prepare_input</code> and then return its receiver. We'll pass transmitters to both <code>onkeyup</code> and <code>onkeydown</code>, and send the <code>KeyboardEvent</code> to each of those. Let's take a look at the changes:</p>
			<pre>fn prepare_input() -&gt; Result&lt;UnboundedReceiver&lt;KeyPress&gt;&gt; {
    let (keydown_sender, keyevent_receiver) = unbounded();
    let keydown_sender = Rc::new(RefCell::new(keydown_sender));
    let keyup_sender = Rc::clone(&amp;keydown_sender);
    let onkeydown = browser::closure_wrap(Box::new(move |keycode: web_sys::KeyboardEvent| {
        keydown_sender
            .borrow_mut()
            .start_send(KeyPress::KeyDown(keycode));
    }) as Box&lt;dyn FnMut(web_sys::KeyboardEvent)&gt;);
    let onkeyup = browser::closure_wrap(Box::new(move |keycode: web_sys::KeyboardEvent| {
        keyup_sender
            .borrow_mut()
            .start_send(KeyPress::KeyUp(keycode));
    }) as Box&lt;dyn FnMut(web_sys::KeyboardEvent)&gt;);
    browser::window()?.set_onkeydown(Some(onkeydown.as_ref().unchecked_ref()));
    browser::window()?.set_onkeyup(Some(onkeyup.as_ref().unchecked_ref()));
    onkeydown.forget();
    onkeyup.forget();
    Ok(keyevent_receiver)
}</pre>
			<p>The function now returns <code>Result&lt;UnboundedReceiver&lt;KeyPress&gt;&gt;</code>. <code>UnboundedReceiver</code> and <code>unbounded</code> are both in the <code>futures::channel::mspc</code> module and are declared in a <code>use</code> declaration at the top of the file. We create the unbounded channel on the first line with the <code>unbounded</code> function and then create reference counted versions of both <code>keydown_sender</code> and <code>keyup_sender</code>, so that we can move each of them into their respective closures while sending both events to the same receiver. Note that the <code>unbounded</code> channel uses <code>start_send</code> instead of <code>send</code>. Finally, we return <code>keyevent_receiver</code> as <code>Result</code>. You might <a id="_idIndexMarker234"/>consider having two independent channels, one for <code>keyup</code> and one for <code>keydown</code>, and while I'm certain that can be done, I tried it and found this way was more straightforward.</p>
			<p>Look closely and you might wonder what <code>KeyPress</code> is. It turns out you can't tell what kind of <code>KeyboardEvent</code> happened simply by inspecting it. In order to keep track of whether the event was <code>keyup</code> or <code>keydown</code>, we wrap those events in an enumerated type that we'll define in <code>engine.rs</code>:</p>
			<pre>enum KeyPress {
    KeyUp(web_sys::KeyboardEvent),
    KeyDown(web_sys::KeyboardEvent),
}</pre>
			<p>This <code>enum</code> approach means we won't have to manage two channels. Now that we have a function that will listen for and put all our key events into a channel, we need to write a second function that grabs all those events off the channel and reduces them into <code>KeyState</code>. We can do that like so, still in the <code>engine</code> module:</p>
			<pre>fn process_input(state: &amp;mut KeyState, keyevent_receiver: &amp;mut UnboundedReceiver&lt;KeyPress&gt;) {
    loop {
        match keyevent_receiver.try_next() {
            Ok(None) =&gt; break,
            Err(_err) =&gt; break,
            Ok(Some(evt)) =&gt; match evt {
                KeyPress::KeyUp(evt) =&gt; state.set_released(&amp;evt.code()),
                KeyPress::KeyDown(evt) =&gt; state.set_pressed(&amp;evt.code(), evt),
            },
        };
    }
}</pre>
			<p>This function takes <code>KeyState</code> and <code>Receiver</code> and updates <code>state</code> by taking every entry off of the receiver until its empty. Theoretically, this appears to create the possibility for an infinite loop <a id="_idIndexMarker235"/>in the event that the receiver is constantly filled, but I was unable to do that by normal means (pressing the keyboard like a madman), and if somebody decides to write a script that fills this channel and break their own game, more power to them. <code>KeyState</code> has to be passed as <code>mut</code> so that we update the current one and do not start from a brand-new state on each update. We've written this function pretending that <code>KeyState</code> already exists, but we need to create it as well, again in the <code>engine</code> module:</p>
			<pre>pub struct KeyState {
    pressed_keys: HashMap&lt;String, web_sys::KeyboardEvent&gt;,
}
impl KeyState {
    fn new() -&gt; Self {
        KeyState {
            pressed_keys: HashMap::new(),
        }
    }
    pub fn is_pressed(&amp;self, code: &amp;str) -&gt; bool {
        self.pressed_keys.contains_key(code)
    }
    fn set_pressed(&amp;mut self, code: &amp;str, event: web_sys::KeyboardEvent) {
        self.pressed_keys.insert(code.into(), event);
    }
    fn set_released(&amp;mut self, code: &amp;str) {
        self.pressed_keys.remove(code.into());
    }
}</pre>
			<p>The <code>KeyState</code> struct is just a wrapper around <code>HashMap</code>, storing a lookup of <code>KeyboardEvent.code</code> to its <code>KeyboardEvent</code>. If the <code>code</code> isn't present, then the key isn't pressed. The code is the <a id="_idIndexMarker236"/>actual representation of a physical key on the keyboard. You can find a list of all the available <code>KeyboardEvent</code> codes on MDN Web Docs: <a href="https://mzl.la/3ar9krK">https://mzl.la/3ar9krK</a>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When in doubt, MDN Web Docs from Mozilla is easily the best resource on the web for browser libraries.</p>
			<p>We've created the libraries and structures we need for keyboard input, so now we can integrate it into our <code>GameLoop</code>. We'll call <code>prepare_input</code> in the <code>start</code> function before we start looping:</p>
			<pre>pub async fn start(mut game: impl Game + 'static) -&gt; Result&lt;()&gt; {
    <strong class="bold">let mut keyevent_receiver = prepare_input()?;</strong>
    game.initialize().await?;</pre>
			<p>Then, we'll move <code>keyevent_receiver</code> into the <code>request_animation_frame</code> closure and process the input on every update:</p>
			<pre><strong class="bold">let mut keystate = KeyState::new();</strong>
*g.borrow_mut() = Some(browser::create_raf_closure(move |perf: f64| {
    <strong class="bold">process_input(&amp;mut keystate, &amp;mut keyevent_receiver);</strong></pre>
			<p>You can see that we initialized an empty <code>KeyState</code> right before the <code>request_animation_frame</code> closure,so that we can start with an empty one. Each frame will now call our <code>process_input</code> function and generate a new <code>KeyState</code>. That's all the changes we have to do to our game loop to keep track of <code>KeyState</code>. The only thing that's remaining is to pass it to our <code>Game</code> object so that it can be used. Some game implementations will<a id="_idIndexMarker237"/> store this as a global, but we'll just pass it to the <code>Game</code> trait. We'll update the trait's <code>update</code> function to accept <code>KeyState</code>:</p>
			<pre>pub trait Game {
    ...
    fn update(&amp;mut self<strong class="bold">, keystate: &amp;KeyState</strong>);
    ...</pre>
			<p>Now, we can pass <code>KeyState</code> to the <code>update</code> function on every loop:</p>
			<pre>while game_loop.accumulated_delta &gt; frame_size {
    game.update(<strong class="bold">&amp;keystate</strong>);
    game_loop.accumulated_delta -= frame_size;
}</pre>
			<p>Finally, to keep our game compiling, we will need to update the <code>WalkTheDog::update</code> signature, over in the <code>game</code> module, to match:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {</pre>
			<p>That's it! We've got a <code>GameLoop</code> that processes keyboard input and passes that state to our <code>Game</code>. We've spent a lot of time writing code that makes it possible for us to write a game, but we<a id="_idIndexMarker238"/> haven't actually updated our game. Our poor little RHB still just runs in one plac<a id="_idTextAnchor089"/>e. He looks happy, but now that we've got input, how about we move him around?</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor090"/>Moving Red Hat Boy</h1>
			<p>Moving game objects means keeping track of a position instead of hardcoding it, as you might have expected. We'll create a <code>Point</code> structure in <code>engine</code> that will hold an <em class="italic">x</em> and a <em class="italic">y</em> position for RHB. On every <code>update</code> call, we'll also <a id="_idIndexMarker239"/>calculate a velocity for him, based on which keys are pressed. Every direction will be the same size, so if <code>ArrowLeft</code> and <code>ArrowRight</code> are pressed at the same time, he'll stop moving. After we calculate his velocity, we'll update his position with that number. That should be enough to allow us to move him around the screen. Let's start by adding <code>position</code> to the <code>WalkTheDog</code> game struct:</p>
			<pre>pub struct WalkTheDog {
    image: Option&lt;HtmlImageElement&gt;,
    sheet: Option&lt;Sheet&gt;,
    frame: u8,
    <strong class="bold">position: Point,</strong>
}</pre>
			<p>Of course, <code>Point</code> doesn't exist yet, so we'll create it in <code>engine</code>:</p>
			<pre>#[derive(Clone, Copy)]
pub struct Point {
    pub x: i16,
    pub y: i16,
}</pre>
			<p>Note that we're using integers here so that we don't have to deal with floating point math when it's not necessary. While the <code>canvas</code> functions all take <code>f64</code> values, that's only because there is only one number type in <code>JavaScript</code>, and per MDN Web Docs (<a href="https://mzl.la/32PpIhL">https://mzl.la/32PpIhL</a>), <code>canvas</code> is faster <a id="_idIndexMarker240"/>if you use integer coordinates. You'll also need to update the <code>WalkTheDog::new</code> function to fill in a default <code>position</code>. Let's use <code>0, 0</code> for now:</p>
			<pre>impl WalkTheDog {
    pub fn new() -&gt; Self {
        WalkTheDog {
            image: None,
            sheet: None,
            frame: 0,
            position: Point { x: 0, y: 0 },
        }
    }
}</pre>
			<p>I promised I would stop reminding you to do this, but do make sure you've added a <code>use</code> declaration for <code>crate::engine::Point</code> at the top of the file. The <code>initialize</code> function also needs to be updated to account for <code>position</code>. This is actually why we marked <code>Point</code> with <code>Clone</code> and <code>Copy</code>. It makes it possible to copy it into the new <code>WalkTheDog</code> <code>initialize</code> function, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        let json = browser::fetch_json("rhb.json").await?;
        let sheet = json.into_serde()?;
        let image =
          Some(engine::load_image("rhb.png").await?);
        Ok(Box::new(WalkTheDog {
            image,
            sheet,
            <strong class="bold">position: self.position,</strong>
            frame: self.frame,
        }))
}
....</pre>
			<p>In order for <code>position</code> to have any <a id="_idIndexMarker241"/>meaning, we'll need to update the <code>draw</code> function so that it's actually being used:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        ....
        self.image.as_ref().map(|image| {
            renderer.draw_image(
                &amp;image,
                &amp;Rect {
                    x: sprite.frame.x.into(),
                    y: sprite.frame.y.into(),
                    width: sprite.frame.w.into(),
                    height: sprite.frame.h.into(),
                },
                &amp;Rect {
                    <strong class="bold">x: self.position.into(),</strong>
                    <strong class="bold">y: self.position.into(),</strong>
                    width: sprite.frame.w.into(),
                    height: sprite.frame.h.into(),
                },
            );
        });
    }
}</pre>
			<p>Make sure you update the <em class="italic">second</em> <code>Rect</code> and not the first one. The first <code>Rect</code> is the slice we are taking out of our sprite sheet. The second one is where we want to draw it. This should cause a noticeable <a id="_idIndexMarker242"/>change to the game, as RHB is now in the upper-left corner. Finally, we're going to modify <code>update</code> to calculate a velocity based on which keys are pressed in <code>KeyState</code>. We'll add this before updating the current frame, as shown here:</p>
			<pre>fn update(&amp;mut self, keystate: &amp;KeyState) {
    let mut velocity = Point { x: 0, y: 0 };
    if keystate.is_pressed("ArrowDown") {
        velocity.y += 3;
    }
    if keystate.is_pressed("ArrowUp") {
        velocity.y -= 3;
    }
    if keystate.is_pressed("ArrowRight") {
        velocity.x += 3;
    }
    if keystate.is_pressed("ArrowLeft") {
        velocity.x -= 3;
    }</pre>
			<p>The "<code>ArrowDown</code>" and "<code>ArrowUp</code>" strings and so on are all listed at <a href="https://mzl.la/3ar9krK">https://mzl.la/3ar9krK</a>, although you can also figure them out by simply logging the code when a key is pressed. You can see here that if "<code>ArrowDown</code>" is pressed we increase <code>y</code>, and if "<code>ArrowUp</code>" is pressed, we decrease it, and that's because the origin is in the upper-left-hand corner, with <code>y</code> increasing as you go down, not up. Note also that we don't use <code>if/else</code> here. We want to <a id="_idIndexMarker243"/>account for every pressed key and not short-circuit on the first key that's pressed. Next, we adjust the position based on velocity:</p>
			<pre>if keystate.is_pressed("ArrowLeft") {
    velocity.x -= 3;
}
self.position.x += velocity.x;
self.position.y += velocity.y;</pre>
			<p>Head back to the browser, and you can now use the arrow keys to move RHB around! If he doesn't move, make sure you click in the canvas to give it focus. If he still doesn't move and you're sure you've gotten everything right, put some <code>log!</code> messages in the <code>start</code> function and make sure <code>KeyState</code> is being created, or in the <code>update</code> function to see if you're actually getting a new <code>KeyState</code>. We've covered a lot of ground here, and if you're following along, it's very easy to make a mistake, but you have a debugging tool to figure out issues now.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">On some browsers, the <code>canvas</code> will get a border around it when it has the focus, which will appear after <a id="_idTextAnchor091"/>you click it. You<a id="_idIndexMarker244"/> can remove that by adding a style of <code>outline: none</code> to the <code>canvas</code>.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor092"/>Summary</h1>
			<p>This was a hard, long, and complicated chapter. I'll quote a phrase Aaron Hillegass uses frequently in his books: <em class="italic">"Programming is hard and you are not stupid."</em> There were plenty of areas where a small typo could trip you up, and you may have had to go backward and forward several times. That's all okay – it's part of the learning process. I would encourage you to experiment with the skeleton we've built, even before moving onto the next chapter, as it's a great way to ensure you understand all the code.</p>
			<p>In the end, we've accomplished a lot. We've created a game loop that will run in the browser at 60 frames per second while updating at a fixed step. We've set up an XNA-like game "engine" and separated the engine concerns from the game concerns. Our browser interface is wrapped in a module so that we can hide some of the details of the browser implementation. We're even processing input, making this work like a true game engine. We did all this while keeping the code running as we went. </p>
			<p>The code should be easier to work with going forward because we now have clear places to put things. Browser functions go in a browser, engine functions in an engine, and the game in a game module, although you might feel like it's not a game because RHB doesn't run, jump, and slide around.</p>
			<p>Guess what we're doing next?</p>
		</div>
	</body></html>