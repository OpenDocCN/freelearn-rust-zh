<html><head></head><body>
		<div id="_idContainer028">
			<h1 id="_idParaDest-41"><em class="italic"><a id="_idTextAnchor063"/>Chapter 3</em>: Creating a Game Loop</h1>
			<p>In the first two chapters, we focused on getting an application built, an environment set up, and graphics on a screen without concerning ourselves with creating an actual functioning game. There's no interactivity here, and no straightforward way to add more characters without copying and pasting more code. In this chapter, that will change, with the addition of a game loop and keyboard events, but first, we're going to need to restructure the code to make it ready for our new features. Be prepared to dig in – this is going to be a busy chapter.</p>
			<p>We're going to cover the following:</p>
			<ul>
				<li>Minimal architecture for games</li>
				<li>Creating a game loop</li>
				<li>Adding a keyboard input</li>
				<li>Moving Red Hat Boy</li>
			</ul>
			<p>By the end of the chapter, we'll have a mini-game engine that's ready to be extended with new features and process input.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor064"/>Technical requirements</h1>
			<p>There are no new technical requirements for this chapter; I recommend making sure that your editor/IDE setup is comfortable for you. You're going to be making a lot of changes and you'll want your editor to help you along. The source code for this chapter is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_3">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_3</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3qP5NMa">https://bit.ly/3qP5NMa</a></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor065"/>Minimal architecture </h1>
			<p>A few years ago, I had<a id="_idIndexMarker156"/> a realization while preparing a talk on HTML5 game development. The day before I was scheduled to give the talk, I had written the slides and prepared my delivery, but I had one small problem – I had no demo! I needed a demo of a game to finish off my talk; indeed, I had referenced it in my slides, so I had to produce it. If you've ever been up against a deadline, you know what happens next. All of my ideas about<a id="_idIndexMarker157"/> clean code and software architecture were thrown to the side, as I hacked and slashed my way to a working prototype of <em class="italic">Asteroids</em> in HTML5. You can still find it on my GitHub here: <a href="https://github.com/paytonrules/Boberoids">https://github.com/paytonrules/Boberoids</a>, complete with a name that doesn't make sense.</p>
			<p>The code, by virtually any standard, is pretty terrible. In much the same way the code in <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">, Hello WebAssembly</em>, and <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Drawing Sprites</em>, proceeds in a straight line with no modules, separation of concerns, or tests, this code brute-forces its way from the start to the end of the program. But a funny thing happened at about 2 AM the day before that presentation – it worked! In fact, in preparation for this chapter, I cloned the nearly 10-year-old program, ran <strong class="source-inline">python -m http.server</strong>, browsed to <strong class="source-inline">http://localhost:8000</strong>, and, well, here you go – a mostly working clone of <em class="italic">Asteroids</em>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer024">
					<img alt="Figure 3.1 – Asteroids with a company logo" src="image/Figure_3.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Asteroids with a company logo</p>
			<p>Of course, this code is also nearly<a id="_idIndexMarker158"/> impossible to extend or debug. There's no encapsulation and it's all in one file; heck, there isn't even a proper <strong class="source-inline">README</strong> file. By any objective measure, this is <strong class="bold">bad</strong> software.</p>
			<p>It was so bad that while working on this presentation, I began simultaneously working on an open source project called "<em class="italic">Eskimo</em>" (<a href="https://github.com/paytonrules/Eskimo">https://github.com/paytonrules/Eskimo</a>), which was meant to be a <strong class="bold">good</strong> game framework with the best object-oriented design I knew at the time, with a test-first approach and things like CI built in. If you look at the commit dates, you may notice that my last commit on this project was 2 years after the <em class="italic">Asteroids</em> clone you can see in the preceding screenshot. The code, if you were simply doing a code review, is far better than the code for the aforementioned game. It just doesn't actually work.</p>
			<p>I never made a working game with <em class="italic">Eskimo</em>. Like many developers before me, I fell into the trap of writing a framework instead of making a game and spent so much time "perfecting" my framework that I lost interest in the game I was allegedly making. This bothered me for a long time, and I kept asking myself the question, "Why did I finish the game when I did everything wrong, and fail when I did it right?" Does good code have any real-life meaning?</p>
			<p>I won't keep you <a id="_idIndexMarker159"/>in suspense; for the purposes of this book, we're going to define minimal architecture as one that <strong class="bold">makes the next feature easier</strong>. That means that we are going to do some architecture but only enough to make things easier going forward. We'll be on the lookout for extra complexity and "gold-plating." We're making a game, not an engine, and we want to finish the gam<a id="_idTextAnchor066"/>e.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor067"/>Good? Bad? I'm the guy with code</h2>
			<p>Minimal architecture sounds simple <a id="_idIndexMarker160"/>but can be hard, so let me explain with a counter-example.</p>
			<p>Eskimo has an <strong class="source-inline">Events</strong> object that is created with a constructor that takes <strong class="source-inline">jquery</strong>, the <strong class="source-inline">document</strong>, a <strong class="source-inline">game</strong> object, and a <strong class="source-inline">canvas</strong>. It has all of this because I took the principle of dependency injection to an extreme and tried to make sure the <strong class="source-inline">Events</strong> object would not depend directly on any of those things.</p>
			<p>The problem? Three of those objects are never going to change. You're not going to replace <strong class="source-inline">jquery</strong>, the <strong class="source-inline">document</strong>, or the <strong class="source-inline">canvas</strong> in any game, at least not with <em class="italic">Eskimo</em>, and it requires a lot of understanding to follow the Eskimo code because of that. While the code is theoretically more flexible and follows the dependency inversion principle (<a href="http://bit.ly/3uh7fWU">http://bit.ly/3uh7fWU</a>), it actually made it harder to add future features because I couldn't keep in my head what dependencies did what. My mistake was that I injected these dependencies before I had a reason to, out of a misplaced sense of "good code."</p>
			<p>We are going to stay focused on our goal of making a game and do not want to get caught up in making a framework. That means our process for evolving our program into a game is going to introduce a little bit of flexibility each time we need it. Returning to the two example games, <em class="italic">Asteroids</em> and <em class="italic">Eskimo</em>, we can think of them as being on a scale of rigidity. The <em class="italic">Asteroids</em> clone is extremely rigid. It's like a steel pole, and if you want to change it, you can't. You can only break it. Meanwhile, the <em class="italic">Eskimo</em> game framework is infinitely flexible, so much so that it can't actually do anything. It collapses in on itself in to a lump of goo. Our game, which is just Red Hat Boy running so far, is also very rigid. Adding a second object, say the dog, would require a lot of code changing throughout the small <a id="_idIndexMarker161"/>application and would potentially introduce defects.</p>
			<p>So in order to take our game and add more features, particularly interactivity, we'll need to introduce some flexibility. We'll heat up our steel pole so that it can bend, bend it, and then let it harden again.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor068"/>Layered architecture </h2>
			<p>We're going to <a id="_idIndexMarker162"/>start by introducing a small layered architecture. Specifically, we'll have three layers:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer025">
					<img alt="Figure 3.2 – A layered architecture" src="image/Figure_3.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – A layered architecture</p>
			<p>The one rule of this architecture is that layers can only use things at or below their layer. So working from the bottom, the browser layer is going to be a bunch of small functions that are specific to the browser. For instance, our <strong class="source-inline">window</strong> function will end up here. Meanwhile, the engine layer is going to be tools that work across our game, such as the <strong class="source-inline">GameLoop</strong> structure. Finally, the game is the layer that contains our actual game logic. Eventually, we'll spend most of our development time in this layer, although initially, we'll spend a lot of time in the <strong class="source-inline">Engine</strong> and <strong class="source-inline">Browser</strong> layers until they have settled.</p>
			<p>Why do this? Our <a id="_idIndexMarker163"/>aforementioned rule was that any change in architecture has to make future changes easier, so let's identify what makes changes hard right now:</p>
			<ul>
				<li>Keeping everything in one long function makes the code hard to follow.</li>
				<li>Extracting all the <strong class="source-inline">Browser</strong> code will allow us to unify error handling.</li>
			</ul>
			<p>The first point reflects that our brains can only hold so much. Keeping all the code in one place means scrolling up and down trying to find where things are and trying to remember virtually all of the code. Extracting code into various constructs such as modules, functions, and structs with <strong class="bold">names</strong> lets us reduce the amount of information in our heads. This is why the right design feels good to program in. Too much abstraction and you've replaced keeping track of all the details of the program with keeping track of all the abstractions. We'll do our best to keep things in the sweet spot.</p>
			<p>The second reason for the layered approach is specific to Rust and the <strong class="source-inline">wasm-bindgen</strong> functions, which all return <strong class="source-inline">JsValue</strong> as their error type. While this works in a browser, it does not work well when intermingling with the rest of a Rust program because <strong class="source-inline">JsValue</strong> does not implement the <strong class="source-inline">std::Error::error</strong> type that most other Rust errors implement. That means you can't write a function like the following:</p>
			<p class="source-code">async fn doesnt_compile() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</p>
			<p class="source-code">    let window = web_sys::window()?;</p>
			<p class="source-code">    let json = fetch_json("rhb.json").await?;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>The preceding code won't compile because while <strong class="source-inline">ThreadPool::new</strong> returns a <strong class="source-inline">Result&lt;ThreadPool, Error&gt;</strong>, <strong class="source-inline">fetch_json</strong> returns <strong class="source-inline">Result&lt;JsValue, JsValue&gt;</strong>, and those results don't mix. In the <strong class="source-inline">browser</strong> module, we'll map JsValues to a standard error, using the <strong class="source-inline">anyhow</strong> crate. We'll also use it to hide the weird details of the API, creating one that's tailored to <a id="_idIndexMarker164"/>our purposes. Let's get started creating our <strong class="source-inline">browser</strong> m<a id="_idTextAnchor069"/>odule.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor070"/>Creating the browser module</h2>
			<p>The first <a id="_idIndexMarker165"/>step is <a id="_idIndexMarker166"/>to create a file named <strong class="source-inline">browser.rs</strong> in the <strong class="source-inline">src</strong> directory and reference it at the top of <strong class="source-inline">lib.rs</strong> with <strong class="source-inline">mod browser</strong>. While we could, theoretically, put every module in <strong class="source-inline">lib.rs</strong>, we're not monsters, and we'll break things into their own files. By the end of this chapter, <strong class="source-inline">lib.rs</strong> will be very small. Our first addition to <strong class="source-inline">browser</strong> is actually going to be a macro, and a completely new one, listed as follows:</p>
			<p class="source-code">macro_rules! log {</p>
			<p class="source-code">    ( $( $t:tt )* ) =&gt; {</p>
			<p class="source-code">        web_sys::console::log_1(&amp;format!( $( $t )*</p>
			<p class="source-code">          ).into());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>I'd love to claim that I was a great macro programmer who wrote that in one try, but the truth is that that little macro is straight from the Rust and WebAssembly docs (<a href="https://bit.ly/3abbdJ9">https://bit.ly/3abbdJ9</a>). It's a macro that allows you to log in to the console with <strong class="source-inline">log!</strong> using a syntax such as the <strong class="source-inline">format!</strong> function. In <strong class="source-inline">lib.rs</strong>, add an annotation to the <strong class="source-inline">browser</strong> module declaration, like so:</p>
			<p class="source-code">#[macro_use]</p>
			<p class="source-code">mod browser;</p>
			<p>This makes <strong class="source-inline">log!</strong> available whenever the <strong class="source-inline">browser</strong> module is used. Given that we'll be making a lot of changes, we'll probably want some easy debugging. The next step will be to add the <strong class="source-inline">anyhow</strong> crate, which we'll use to unify the error handling across WebAssembly and pure Rust code. The dependency is added to <strong class="source-inline">Cargo.toml</strong> as <strong class="source-inline">anyhow = "1.0.51"</strong>. This crate provides a few features that we'll be using extensively:</p>
			<ul>
				<li>An <strong class="source-inline">anyhow::Error</strong> type that conforms to the <strong class="source-inline">std::error::Error</strong> trait</li>
				<li>An <strong class="source-inline">anyhow!</strong> macro that lets us create error messages that conform to the type, with strings</li>
				<li>An <strong class="source-inline">anyhow::Result&lt;T&gt;</strong> type that is a shortcut for <strong class="source-inline">Result&lt;T, anyhow::Error&gt;</strong></li>
			</ul>
			<p>Go ahead and add <strong class="source-inline">use anyhow::{anyhow, Result};</strong> to the top of the use declarations now so that we'll have <a id="_idIndexMarker167"/>them ready as we create new functions<a id="_idIndexMarker168"/> here.</p>
			<p>Now that the <strong class="source-inline">browser</strong> module is prepared, let's work from the top of <strong class="source-inline">main</strong> and work downward, extracting functions. Let's start here:</p>
			<p class="source-code">#[wasm_bindgen(start)]</p>
			<p class="source-code">pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {</p>
			<p class="source-code">    console_error_panic_hook::set_once();</p>
			<p class="source-code">    let window = web_sys::window().unwrap();</p>
			<p class="source-code">    let document = window.document().unwrap();</p>
			<p>The <strong class="source-inline">wasm_bindgen</strong> macro has to stay there, and it is only compatible with a function that returns <strong class="source-inline">Result&lt;(), JsValue&gt;</strong>. This means that while we can use proper Rust errors throughout our program, at the end, we'll need to transform it back to a <strong class="source-inline">JsValue</strong> if we want it to be returned from this function. Fortunately, once we write our game loop, this won't be a problem.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><strong class="source-inline">Wasm_bindgen</strong> error handling is a little rough, and the Wasm working group is aware of it. For reference, you can look at the defect here: <a href="https://bit.ly/3d8x0D7">https://bit.ly/3d8x0D7</a>.</p>
			<p>Moving on to the executing code, there are two functions right off the top that can be pulled into <strong class="source-inline">browser.rs</strong>. We'll take the refactoring step by step. First, let's create a function in the browser module, like this:</p>
			<p class="source-code">pub fn window() -&gt; Result&lt;Window&gt; {}</p>
			<p>That won't compile because it doesn't return anything, but also because it doesn't know anything about the <strong class="source-inline">Window</strong> type. Go ahead and import those at the top of the file. It should look like this:</p>
			<p class="source-code">use web_sys::Window;</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you haven't already, get Rust Analyzer working with your editor of choice. I use emacs and use the keyboard shortcut , <strong class="source-inline">c a</strong> to import modules. It's a great timesaver for this kind of work. From this point forward, I won't be documenting every <strong class="source-inline">use</strong> declaration you need when moving files over; just follow the compiler errors.</p>
			<p>The function also doesn't compile<a id="_idIndexMarker169"/> because you're not returning anything. You <a id="_idIndexMarker170"/>can start by directly copying (don't cut) the call to <strong class="source-inline">window()</strong> from <strong class="source-inline">lib.rs</strong>:</p>
			<p class="source-code">pub fn window() -&gt; Result&lt;Window&gt; {</p>
			<p class="source-code">    web_sys::window().unwrap()</p>
			<p class="source-code">}</p>
			<p>You don't need to bind a variable with <strong class="source-inline">let</strong> here. This still won't compile because of that <strong class="source-inline">unwrap</strong>. In this case, <strong class="source-inline">web_sys::window</strong> returns <strong class="source-inline">Option&lt;Window&gt;</strong> and <strong class="source-inline">unwrap</strong> will extract the <strong class="source-inline">Window</strong> object, or panic. None of that conforms to <strong class="source-inline">Result&lt;Window&gt;</strong>, and what we need to do instead is handle the case where <strong class="source-inline">window</strong> is somehow missing as an error.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When trying to mix and match <strong class="source-inline">Option</strong> and <strong class="source-inline">Result</strong>, there are two schools of thought – make <strong class="source-inline">Result</strong> into <strong class="source-inline">Option</strong> with <strong class="source-inline">ok</strong>, or convert <strong class="source-inline">Result</strong> into <strong class="source-inline">Option</strong> with <strong class="source-inline">ok_or_else</strong>. I prefer the second because while that will mean writing a lot of error messages that say "<strong class="source-inline">&lt;X&gt;</strong>" (not found), the alternative is losing useful error diagnostics.</p>
			<p>To make this function work with the <strong class="source-inline">Result&lt;Window&gt;</strong> return type, which, remember, is a shorthand for <strong class="source-inline">Result&lt;Window, anyhow::Error&gt;</strong>, we're going to use the <strong class="source-inline">anyhow!</strong> macro. So, to convert <strong class="source-inline">Option</strong> to <strong class="source-inline">Result</strong> and make this function compile, you can do the following:</p>
			<p class="source-code">pub fn window() -&gt; Result&lt;Window&gt; {</p>
			<p class="source-code">    web_sys::window().ok_or_else(|| anyhow!("No Window Found"))</p>
			<p class="source-code">}</p>
			<p>Now you've<a id="_idIndexMarker171"/> got a <a id="_idIndexMarker172"/>function, <strong class="source-inline">browser::window()</strong>, which will return <strong class="source-inline">Window</strong> or the appropriate error.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Nightly Rust currently has an error called <strong class="source-inline">NoneError</strong> that helps bridge the gap between <strong class="source-inline">Option</strong> and <strong class="source-inline">Result</strong> types, but we'll stick to the standard for now.</p>
			<p>Finally, we can replace the call to <strong class="source-inline">web_sys::window()</strong> in <strong class="source-inline">lib</strong> with a call to <strong class="source-inline">browser::window()</strong> in <strong class="source-inline">lib</strong>:</p>
			<p class="source-code">let window = browser::window().expect("No Window Found");</p>
			<p class="source-code">let document = window.document().unwrap();</p>
			<p>The call to <strong class="source-inline">window()</strong> will use <strong class="source-inline">expect</strong> for now to go ahead and crash the program if there is no window. Later, you'll see we can use the <strong class="source-inline">?</strong> operator, but for the moment, we've got to work around <strong class="source-inline">main_js</strong> returning a <strong class="source-inline">Result&lt;(), JsValue&gt;</strong>. If that was the only place we were changing, the introduction of <strong class="source-inline">anyhow</strong> wouldn't make any sense. Fortunately, when we repeat that process with a new <strong class="source-inline">document</strong> function in the <strong class="source-inline">browser</strong> module, you can see the advantage. We can skip going through each step of that process, and get to the end result:</p>
			<p class="source-code">pub fn document() -&gt; Result&lt;Document&gt; {</p>
			<p class="source-code">    window()?.document().ok_or_else(|| anyhow!</p>
			<p class="source-code">        ("No Document Found"))</p>
			<p class="source-code">}</p>
			<p>If this doesn't compile, don't forget to add <strong class="source-inline">Document</strong> to the <strong class="source-inline">use</strong> declarations at the top of the module. As we make these changes, you'll need to move <strong class="source-inline">use</strong> declarations into <strong class="source-inline">browser</strong>, but you'll be able to remove them from <strong class="source-inline">lib.rs</strong>.</p>
			<p>You can now actually shrink<a id="_idIndexMarker173"/> the two<a id="_idIndexMarker174"/> calls to <strong class="source-inline">window()</strong> and <strong class="source-inline">document()</strong> in <strong class="source-inline">lib.rs</strong> into one call, like so:</p>
			<p class="source-code">pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {</p>
			<p class="source-code">    console_error_panic_hook::set_once();</p>
			<p class="source-code">let document = browser::document().expect("No Document Found");</p>
			<p class="source-code">...</p>
			<p>There is one place in <strong class="source-inline">lib.rs</strong> where we're using the window variable we just deleted. Near the bottom of <strong class="source-inline">spawn_local</strong> <strong class="source-inline">Closure</strong>, right after creating <strong class="source-inline">interval_callback,</strong> there is a call to <strong class="source-inline">window.set_interval_with_callback_and_timeout_and_arguments_0</strong> that can replace <strong class="source-inline">window</strong> with <strong class="source-inline">browser::window().unwrap()</strong>. That looks like the following:</p>
			<p class="source-code">let interval_callback = Closure::wrap(Box::new(move || {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}) as Box&lt;dyn FnMut()&gt;);</p>
			<p class="source-code"><strong class="bold">browser::window()</strong></p>
			<p class="source-code"><strong class="bold">    .unwrap()</strong></p>
			<p class="source-code"><strong class="bold">    .set_interval_with_callback_and_timeout_and_arguments_0(</strong></p>
			<p class="source-code"><strong class="bold">        interval_callback.as_ref().unchecked_ref(),</strong></p>
			<p class="source-code"><strong class="bold">        50,</strong></p>
			<p class="source-code"><strong class="bold">    );</strong></p>
			<p class="source-code">interval_callback.forget();</p>
			<p>Our next function will get the <strong class="source-inline">canvas</strong> object, but it's a little more complicated than the previous two functions. We were pretty <a id="_idIndexMarker175"/>casual with the <strong class="source-inline">unwrap</strong> calls for that section, so we'll have to do some converting to get more specific errors. The end result <a id="_idIndexMarker176"/>looks like this:</p>
			<p class="source-code">pub fn canvas() -&gt; Result&lt;HtmlCanvasElement&gt; {</p>
			<p class="source-code">    document()?</p>
			<p class="source-code">        .get_element_by_id("canvas")</p>
			<p class="source-code">        .ok_or_else(|| anyhow!</p>
			<p class="source-code">            ("No Canvas Element found with ID 'canvas'"))?</p>
			<p class="source-code">        .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()</p>
			<p class="source-code">        .map_err(|element| anyhow!("Error converting {:#?}</p>
			<p class="source-code">          to HtmlCanvasElement", element))</p>
			<p class="source-code">}</p>
			<p>There are a few things worth paying close attention to here. First, the <strong class="source-inline">get_element_by_id</strong> call is hardcoded to the <strong class="source-inline">'canvas'</strong> ID. We'll go ahead and leave that as is until it causes an issue later, but we're not going to make that configurable until we need to. Next, we used <strong class="source-inline">ok_or_else</strong> to convert <strong class="source-inline">get_element_by_id</strong> from <strong class="source-inline">Option</strong> to <strong class="source-inline">Result</strong>. Most interesting is the call to the <strong class="source-inline">dyn_into</strong> function. As discussed earlier, almost every function that calls into JavaScript will return a <strong class="source-inline">JsValue</strong> type, because JavaScript is a dynamically typed language. We know that the element returned by <strong class="source-inline">get_element_by_id</strong> will return <strong class="source-inline">HtmlCanvasElement</strong>, at least if we've retrieved the right JavaScript node, so we can convert it from <strong class="source-inline">JsValue</strong> to the correct element. This is what <strong class="source-inline">dyn_into</strong> does – it converts from <strong class="source-inline">JsValue</strong> to appropriate Rust types. In order to use <strong class="source-inline">dyn_into</strong>, you must import <strong class="source-inline">wasm_bindgen::JsCast</strong>, which rust-analyzer cannot automatically import. It can import <strong class="source-inline">web_sys::HtmlCanvasElement</strong>.</p>
			<p>We'll create a <strong class="source-inline">context</strong> function that looks very similar:</p>
			<p class="source-code">pub fn context() -&gt; Result&lt;CanvasRenderingContext2d&gt; {</p>
			<p class="source-code">    canvas()?</p>
			<p class="source-code">        .get_context("2d")</p>
			<p class="source-code">        .map_err(|js_value| anyhow!("Error getting 2d </p>
			<p class="source-code">          context {:#?}", js_value))?</p>
			<p class="source-code">        .ok_or_else(|| anyhow!("No 2d context found"))?</p>
			<p class="source-code">        .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()</p>
			<p class="source-code">        .map_err(|element| {</p>
			<p class="source-code">            anyhow!( "Error converting {:#?} to</p>
			<p class="source-code">                      CanvasRenderingContext2d",</p>
			<p class="source-code">                      element</p>
			<p class="source-code">            )</p>
			<p class="source-code">        })</p>
			<p class="source-code">}</p>
			<p>One oddity you might <a id="_idIndexMarker177"/>see here is that <a id="_idIndexMarker178"/>we follow <strong class="source-inline">map_err</strong> immediately with <strong class="source-inline">ok_or</strong>. That's because <strong class="source-inline">get_context</strong> returns <strong class="source-inline">Result&lt;Option&lt;Object&gt;, JsValue&gt;</strong>, which the old code "solved" by calling <strong class="source-inline">unwrap</strong> twice. So what we do now is map the error (<strong class="source-inline">JsValue</strong>) to <strong class="source-inline">Error</strong> and then take the inner <strong class="source-inline">Option</strong> and map the <strong class="source-inline">None</strong> case to a value.</p>
			<p>Remember that if you're following along and having trouble compiling, update your <strong class="source-inline">use</strong> declarations. Let's pick up the pace a little. We can add a function for <strong class="source-inline">spawn_local</strong>:</p>
			<p class="source-code">pub fn spawn_local&lt;F&gt;(future: F)</p>
			<p class="source-code">where</p>
			<p class="source-code">    F: Future&lt;Output = ()&gt; + 'static,</p>
			<p class="source-code">{</p>
			<p class="source-code">    wasm_bindgen_futures::spawn_local(future);</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you are writing a wrapper like this and aren't sure what the signature should be, start by looking at the function you're wrapping and mimic its signature.</p>
			<p>Let's also <a id="_idIndexMarker179"/>add<a id="_idIndexMarker180"/> fetching <strong class="source-inline">JSON</strong> to <strong class="source-inline">browser</strong>:</p>
			<p class="source-code">pub async fn fetch_with_str(resource: &amp;str) -&gt;</p>
			<p class="source-code">  Result&lt;JsValue&gt; {</p>
			<p class="source-code">    JsFuture::from(window()?.fetch_with_str(resource))</p>
			<p class="source-code">        .await</p>
			<p class="source-code">        .map_err(|err| anyhow!("error fetching {:#?}", </p>
			<p class="source-code">                                err))</p>
			<p class="source-code">}</p>
			<p class="source-code">pub async fn fetch_json(json_path: &amp;str) -&gt; Result&lt;JsValue&gt; {</p>
			<p class="source-code">    let resp_value = fetch_with_str(json_path).await?;</p>
			<p class="source-code">    let resp: Response = resp_value</p>
			<p class="source-code">        .dyn_into()</p>
			<p class="source-code">        .map_err(|element| anyhow!("Error converting {:#?}</p>
			<p class="source-code">           to Response", element))?;</p>
			<p class="source-code">    JsFuture::from(</p>
			<p class="source-code">        resp.json()</p>
			<p class="source-code">            .map_err(|err| anyhow!("Could not get JSON from </p>
			<p class="source-code">              response {:#?}", err))?,</p>
			<p class="source-code">    )</p>
			<p class="source-code">    .await</p>
			<p class="source-code">    .map_err(|err| anyhow!("error fetching JSON {:#?}", err))</p>
			<p class="source-code">}</p>
			<p>I expanded <strong class="source-inline">fetch_json</strong> into two functions because I think <strong class="source-inline">fetch_with_str</strong> is going to be reusable, but it's not strictly necessary. The <strong class="source-inline">fetch_json</strong> function borders on not belonging in the <strong class="source-inline">browser</strong> module. On the one hand, it exclusively calls into the <strong class="source-inline">wasm_bindgen</strong> API, mapping the <strong class="source-inline">JsValue</strong> errors to standard <strong class="source-inline">Error</strong>s; on the other hand, there is a tiny amount of behavior there when we decide to get <strong class="source-inline">JSON</strong> off of the response. Ultimately, that's a bit of a judgment call.</p>
			<p>Having written all those functions, you can go back to the <strong class="source-inline">lib.rs</strong> module and update the main function to use the<a id="_idIndexMarker181"/> new <a id="_idIndexMarker182"/>ones. As you can see, it's starting to shrink significantly, as the top should look like the following, using the new functions from the browser module where appropriate:</p>
			<p class="source-code">#[wasm_bindgen(start)]</p>
			<p class="source-code">pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {</p>
			<p class="source-code">    console_error_panic_hook::set_once();</p>
			<p class="source-code">    <strong class="bold">let context = browser::context().expect("Could not get </strong></p>
			<p class="source-code"><strong class="bold">      browser context");</strong></p>
			<p class="source-code"><strong class="bold">    browser::spawn_local(</strong>async move {</p>
			<p class="source-code">        let sheet: Sheet = <strong class="bold">browser::fetch_json("rhb.json")</strong></p>
			<p class="source-code">            <strong class="bold">.await</strong></p>
			<p class="source-code">            <strong class="bold">.expect("Could not fetch rhb.json")</strong></p>
			<p class="source-code">            .into_serde()</p>
			<p class="source-code">            .expect("Could not convert rhb.json into a </p>
			<p class="source-code">                     Sheet structure");</p>
			<p class="source-code">        let image =</p>
			<p class="source-code">          web_sys::HtmlImageElement::new().unwrap();</p>
			<p class="source-code">...</p>
			<p>You can see that we removed all the intermediate calls to <strong class="source-inline">window </strong>and <strong class="source-inline">context</strong> in favor of one call to <strong class="source-inline">context</strong>. We've also just made a call into <strong class="source-inline">fetch_json</strong> using <strong class="source-inline">expect</strong> to call out errors. Finally, you'll see one compiler error when you do this on the <strong class="source-inline">window.set_interval_with_callback_and_timeout_and_arguments_0</strong> line. You can fix that by replacing <strong class="source-inline">window</strong> with <strong class="source-inline">browser::window().unwrap()</strong>. The <strong class="source-inline">unwrap</strong> bit is ugly, but we'll keep refactoring until that's gone as well. It's not reproduced in the preceding snippet, but you can also<a id="_idIndexMarker183"/> delete the <strong class="source-inline">fetch_json</strong> function from <strong class="source-inline">lib.rs</strong>; it's not <a id="_idIndexMarker184"/>being used anymore. </p>
			<p>This brings us to the next section to e<a id="_idTextAnchor071"/>xtract – loading an image.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor072"/>Loading an image</h2>
			<p>I bet you <a id="_idIndexMarker185"/>thought you were done <a id="_idIndexMarker186"/>with loading the image, didn't you? Well, we will be as soon as we turn it into a function. Let's look at the original implementation for a moment again:</p>
			<p class="source-code">let image = web_sys::HtmlImageElement::new().unwrap();</p>
			<p class="source-code">let (success_tx, success_rx) =</p>
			<p class="source-code">   futures::channel::oneshot::channel::&lt;Result&lt;(),JsValue&gt;&gt;();</p>
			<p class="source-code">let success_tx = Rc::new(Mutex::new(Some(success_tx)));</p>
			<p class="source-code">let error_tx = Rc::clone(&amp;success_tx);</p>
			<p class="source-code">let callback = Closure::once(Box::new(move || {</p>
			<p class="source-code">    if let Some(success_tx) = </p>
			<p class="source-code">      success_tx.lock().ok().and_then(|mut opt| opt.take())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        success_tx.send(Ok(()));</p>
			<p class="source-code">    }</p>
			<p class="source-code">}));</p>
			<p class="source-code">let error_callback = Closure::once(Box::new(move |err| {</p>
			<p class="source-code">    if let Some(error_tx) = </p>
			<p class="source-code">      error_tx.lock().ok().and_then(|mut opt| opt.take()) {</p>
			<p class="source-code">        error_tx.send(Err(err));</p>
			<p class="source-code">    }</p>
			<p class="source-code">}));</p>
			<p class="source-code">image.set_onload(Some(callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">image.set_onload(Some(error_callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">image.set_src("rhb.png");</p>
			<p class="source-code">success_rx.await;</p>
			<p>At first glance, this looks like it's one function in our <strong class="source-inline">browser</strong> module, <strong class="source-inline">load_image</strong>, but on closer<a id="_idIndexMarker187"/> reflection, there's a lot here for just one function. For instance, if you <a id="_idIndexMarker188"/>so choose, you can create an image element without worrying about whether it's going to be loaded, or you might be willing to use <strong class="source-inline">set_src</strong> without concerning yourself with whether or not it's loaded. No, all that stuff after <strong class="source-inline">let image = web_sys::HtmlImageElement::new().unwrap()</strong> is really engine behavior. That means it's time for us to create our second module, <strong class="source-inline">engine</strong>!</p>
			<p>The <strong class="source-inline">engine</strong> module will contain libraries and functions that we will use throughout our game. We are <strong class="bold">not</strong> going to write a fully fledged commercial-quality engine in this book because we want to finish an <a id="_idIndexMarker189"/>actual game, but we are going to have engine-like functions and structures, and we'll put those in the <strong class="source-inline">engine</strong> module. In fact, to break down this behavior, we'll follow a few steps:</p>
			<ol>
				<li>Create a <strong class="source-inline">browser</strong> function, <strong class="source-inline">new_image</strong>.</li>
				<li>Create a <strong class="source-inline">browser</strong> function to create JS closures.</li>
				<li>Create an <strong class="source-inline">engine</strong> module.</li>
				<li>Create an <strong class="source-inline">engine</strong> function, <strong class="source-inline">load_image</strong>.</li>
			</ol>
			<p>Let's start with the changes to <strong class="source-inline">browser</strong>; we'll create two new functions to make <strong class="source-inline">Closure</strong> and an image:</p>
			<p class="source-code">pub fn new_image() -&gt; Result&lt;HtmlImageElement&gt; {</p>
			<p class="source-code">    HtmlImageElement::new().map_err(|err| anyhow!("Could </p>
			<p class="source-code">      not create HtmlImageElement: {:#?}", err))</p>
			<p class="source-code">}</p>
			<p class="source-code">pub fn closure_once&lt;F, A, R&gt;(fn_once: F) -&gt;</p>
			<p class="source-code">  Closure&lt;F::FnMut&gt;</p>
			<p class="source-code">where</p>
			<p class="source-code">    F: 'static + WasmClosureFnOnce&lt;A, R&gt;,</p>
			<p class="source-code">{</p>
			<p class="source-code">    Closure::once(fn_once)</p>
			<p class="source-code">}</p>
			<p>The first function is just a wrapper around <strong class="source-inline">HtmlImageElement</strong>; there's not much to explain. In the future, we may decide we want our own type for images, but for now, we'll stick with the browser-provided type. The <strong class="source-inline">closure_once</strong> function is complicated by its type signature. In this case, we just mimic the exact same type signature of the <strong class="source-inline">Closure::once</strong> function from <strong class="source-inline">wasm_bindgen</strong>. Later, we'll write some utility functions for the <strong class="source-inline">Closure</strong> types to make working with them easier, but for this one, we'll just create a straight wrapper.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">A compelling argument can be made that we should be converting even more types in this module. Specifically, we should use our own types for <strong class="source-inline">Closure</strong>, <strong class="source-inline">HtmlImageElement</strong>, and other browser-provided types. It's possible that's a better approach, but for now, we're going to stick with the types provided in the interest of both learning the material and keeping to a simple architecture. Like all decisions in programming, it's a trade-off.</p>
			<p>That covers <em class="italic">step 1</em> and <em class="italic">step 2</em>, and <em class="italic">step 3</em> is quick – create a file named <strong class="source-inline">engine.rs</strong> in the source directory and add a <strong class="source-inline">mod engine</strong> declaration to <strong class="source-inline">lib.rs</strong>. Now for <em class="italic">step 4</em>, the one we've <a id="_idIndexMarker190"/>been <a id="_idIndexMarker191"/>dreading. In <strong class="source-inline">engine.rs</strong>, add the following:</p>
			<p class="source-code">pub async fn load_image(source: &amp;str) -&gt; Result&lt;HtmlImageElement&gt; {</p>
			<p class="source-code">    let image = browser::new_image()?;</p>
			<p class="source-code">    let (complete_tx, complete_rx) = </p>
			<p class="source-code">      channel::&lt;Result&lt;()&gt;&gt;();</p>
			<p class="source-code">    let success_tx = </p>
			<p class="source-code">      Rc::new(Mutex::new(Some(complete_tx)));</p>
			<p class="source-code">    let error_tx = Rc::clone(&amp;success_tx);</p>
			<p class="source-code">    let success_callback = browser::closure_once(move || {</p>
			<p class="source-code">        if let Some(success_tx) =</p>
			<p class="source-code">          success_tx.lock().ok().and_then(</p>
			<p class="source-code">          |mut opt| opt.take()) {</p>
			<p class="source-code">            success_tx.send(Ok(()));</p>
			<p class="source-code">        }</p>
			<p class="source-code">    });</p>
			<p class="source-code">    let error_callback: Closure&lt;dyn FnMut(JsValue)&gt; = </p>
			<p class="source-code">      browser::closure_once(move |err| {</p>
			<p class="source-code">        if let Some(error_tx) =</p>
			<p class="source-code">          error_tx.lock().ok().and_then(</p>
			<p class="source-code">          |mut opt| opt.take()) {</p>
			<p class="source-code">            error_tx.send(Err(anyhow!("Error Loading Image:</p>
			<p class="source-code">              {:#?}", err)));</p>
			<p class="source-code">        }</p>
			<p class="source-code">    });</p>
			<p class="source-code">    image.set_onload(Some(</p>
			<p class="source-code">      success_callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">    image.set_onerror(Some(</p>
			<p class="source-code">      error_callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">    image.set_src(source);</p>
			<p class="source-code">    complete_rx.await??;</p>
			<p class="source-code">    Ok(image)</p>
			<p class="source-code">}</p>
			<p>I'm intentionally leaving out the <strong class="source-inline">use</strong> statements so that you get used to adding them and thinking about which declarations you need and are using. However, there are two traps to this code that I want to call out:</p>
			<ul>
				<li>In order for <strong class="source-inline">unchecked_ref</strong> to compile, you need to use <strong class="source-inline">wasm_bindgen:JsCast</strong>.</li>
				<li>When you import <strong class="source-inline">channel</strong>, make sure you choose <strong class="source-inline">futures::channel::oneshot::channel</strong>. There are a few different implementations of <strong class="source-inline">channel</strong>, and if you grab the wrong one by mistake, this code won't compile. </li>
			</ul>
			<p>When in doubt, take a look at <strong class="source-inline">lib.rs</strong> and verify which dependencies are being used there because that's <a id="_idIndexMarker192"/>where<a id="_idIndexMarker193"/> this code is being pulled from.</p>
			<p>Returning to the code we added, note that we're using our new <strong class="source-inline">browser</strong> functions throughout, with no direct dependencies on the <strong class="source-inline">wasm-bindgen</strong> functions. We are still dependent on <strong class="source-inline">wasm_bindgen</strong> for the <strong class="source-inline">Closure</strong> and <strong class="source-inline">JSValue</strong> types, as well as the <strong class="source-inline">unchecked_ref</strong> function, but we've reduced the amount of direct platform dependencies. Our only JS dependency is on <strong class="source-inline">HtmlImageElement</strong>. Now, take a look at the very beginning of the function and you'll see the <strong class="source-inline">new_image</strong> call can use the <strong class="source-inline">?</strong> operator to early return in the event of an error, with a standard Rust error type. This is why we mapped those errors in the <strong class="source-inline">browser</strong> functions.</p>
			<p>Moving past the first two lines of the method, the rest of the function is largely the same as before, replacing any direct calls to <strong class="source-inline">wasm-bindgen</strong> functions with their corresponding calls in <strong class="source-inline">browser</strong>. We've changed the channel to send <strong class="source-inline">anyhow::Result</strong> and used <strong class="source-inline">anyhow!</strong> in <strong class="source-inline">error_callback</strong>. This then allows us to end the function with a call to <strong class="source-inline">complete_rx.await??</strong> and <strong class="source-inline">Ok(image)</strong>. Those two <strong class="source-inline">??</strong> are not a misprint; <strong class="source-inline">complete_rx.await</strong> returns <strong class="source-inline">Result&lt;Result&lt;(), anyhow::Error&gt;, Canceled&gt;</strong>. Since <strong class="source-inline">anyhow::Error</strong> and <strong class="source-inline">Canceled</strong> both conform to <strong class="source-inline">std::error::Error</strong>, we can handle those errors with <strong class="source-inline">?</strong> each time.</p>
			<p>We still have two warnings in this function because both of the calls to <strong class="source-inline">send</strong> return <strong class="source-inline">Result</strong> that we aren't dealing with. We can't just use <strong class="source-inline">?</strong> because those results are wrapped in the <strong class="source-inline">Closure</strong> types, so we'll put off dealing with those unlikely errors for now and will cover error logging in <a href="B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203"><em class="italic">Chapter 9</em></a>, <em class="italic">Testing, Debugging, and Performance</em>.</p>
			<p>Now that you've done all that you should be able to, replace the code in <strong class="source-inline">main</strong> with a call to our new function:</p>
			<p class="source-code">let sheet: Sheet = json</p>
			<p class="source-code">    .into_serde()</p>
			<p class="source-code">    .expect("Could not convert rhb.json into a Sheet </p>
			<p class="source-code">             structure");</p>
			<p class="source-code"><strong class="bold">let image = engine::load_image("rhb.png")</strong></p>
			<p class="source-code"><strong class="bold">    .await</strong></p>
			<p class="source-code"><strong class="bold">    .expect("Could not load rhb.png");</strong></p>
			<p class="source-code">let mut frame = -1;</p>
			<p>Nothing <a id="_idIndexMarker194"/>about <a id="_idIndexMarker195"/>loading <strong class="source-inline">Sheet</strong> has changed; that's just there to make sure you put this in the right place. After that, the code for <a id="_idIndexMarker196"/>animating our little <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) starts, but we're not going to be using that at all. That will be replaced with our game lo<a id="_idTextAnchor073"/>op, which we'll start introducing now.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor074"/>Creating a game loop</h1>
			<p>The <a id="_idIndexMarker197"/>core of this game, and virtually every game ever, is just an infinite loop. You can boil them all down to something like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 3.3 – A basic game loop" src="image/Figure_3.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – A basic game loop</p>
			<p>That means, theoretically, these are<a id="_idIndexMarker198"/> trivial to implement, as shown here:</p>
			<p class="source-code">while(!quit) {</p>
			<p class="source-code">    handleInput()</p>
			<p class="source-code">    updateGame()</p>
			<p class="source-code">    drawGame()</p>
			<p class="source-code">}</p>
			<p>At its core, that's what we're going to write, but as you probably guessed, if it was that simple, I wouldn't have devoted an entire chapter to it. No, there are two problems we are going to be dealing with as we write it:</p>
			<ul>
				<li><strong class="bold">The browser</strong>: If we were writing this game as a command-line program, we'd be able to use the preceding loop, but not in the browser. Any program running in the browser <strong class="bold">must</strong> give up control to the browser itself so that it can do whatever a browser does when it's not showing cat videos, and this kind of loop would cause the current browser tab to hang. It's a big no-no, and to get around it, we need to use the <strong class="source-inline">requestAnimationFrame</strong> function.</li>
				<li><strong class="bold">Frame rates and physics</strong>: The preceding loop we wrote would run as fast as the computer could go. Well, is every computer on the internet the same speed? No, of course not, so<a id="_idIndexMarker199"/> we'll need to make sure we can account for the <a id="_idIndexMarker200"/>differences between machine speeds in our loop, as best we can. We'll do that with what's called a <strong class="bold">fixed-step</strong> game loop.<p class="callout-heading">Important Note</p><p class="callout">You could probably write a book on game loops if you so chose, but this section owes a heavy debt to <a href="https://gameprogrammingpatterns.com/game-loop.html">https://gameprogrammingpatterns.com/game-loop.html</a> and <a href="https://gafferongames.com/post/fix_your_timestep/">https://g<span id="_idTextAnchor075"/>afferongames.com/post/fix_your_timestep/</a>.</p></li>
			</ul>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor076"/>RequestAnimationFrame</h2>
			<p>We'll start with the <strong class="source-inline">requestAnimationFrame</strong> function, which is a browser function that "requests" a new frame<a id="_idIndexMarker201"/> draw as soon as possible. The browser then fits that in frame draw in between handling things such as mouse clicks, operating system events, and cat videos. You might think that would be very slow, but in fact, typically, it's able to render at 60 frames per second, provided your game can keep up. The catch is that unlike our <strong class="source-inline">setInterval</strong> call from earlier, this function needs to be called at the end of every animation. A fairly straightforward JavaScript version of an animation might look like this:</p>
			<p class="source-code">function animate(now) {</p>
			<p class="source-code">    draw(now);</p>
			<p class="source-code">    requestAnimationFrame(animate);</p>
			<p class="source-code">}</p>
			<p class="source-code">requestAnimationFrame(animate);</p>
			<p>So, <strong class="source-inline">requestAnimationFrame</strong> is called with the <strong class="source-inline">animate</strong> function as its parameter. The browser then calls the <strong class="source-inline">animate</strong> function on the next frame, which draws and then requests the next frame. This looks like an infinite loop, but, in fact, doesn't block the browser because of the calls to <strong class="source-inline">requestAnimationFrame</strong>. This also takes a parameter, <strong class="source-inline">now</strong>, which is a timestamp in milliseconds of when the callback function was started. We'll use<a id="_idIndexMarker202"/> this to fix our physics as we evolve our game loop, but writing a game loop in Rust is a little weird because of the borrowing guarantees, so let's start by writing a very basic one.</p>
			<p>You can start by adding a simple wrapper for <strong class="source-inline">requestAnimationFrame</strong> to <strong class="source-inline">browser</strong>, as shown in the following code:</p>
			<p class="source-code">pub fn request_animation_frame(callback: &amp;Function) -&gt; </p>
			<p class="source-code">  Result&lt;i32&gt; {</p>
			<p class="source-code">    window()?</p>
			<p class="source-code">        .request_animation_frame(callback)</p>
			<p class="source-code">        .map_err(|err| anyhow!("Cannot request animation</p>
			<p class="source-code">                                frame {:#?}", err))</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Function</strong> type is a pure JavaScript type and is only available in the <strong class="source-inline">js-sys</strong> package. While we could import that, I'd rather not add another crate dependency if possible; however, we don't actually have to use the <strong class="source-inline">Function</strong> type directly if we make a small change to the function signature and the implementation:</p>
			<p class="source-code">pub fn request_animation_frame(<strong class="bold">callback: &amp;Closure&lt;</strong></p>
			<p class="source-code"><strong class="bold">  dyn FnMut(f64)&gt;</strong>) -&gt; Result&lt;i32&gt; {</p>
			<p class="source-code">    window()?</p>
			<p class="source-code">        .request_animation_frame(<strong class="bold">callback.as_ref().unchecked_ref()</strong>)</p>
			<p class="source-code">        .map_err(|err| anyhow!("Cannot request animation</p>
			<p class="source-code">                                frame {:#?}", err))</p>
			<p class="source-code">}</p>
			<p>Instead of taking <strong class="source-inline">&amp;Function</strong>, our <strong class="source-inline">request_animation_frame</strong> will take <strong class="source-inline">&amp;Closure&lt;dyn FnMut(f64)&gt;</strong> as its parameter. Then, it will call <strong class="source-inline">callback.as_ref().unchecked_ref()</strong> when calling the <strong class="source-inline">web-sys</strong> version of <strong class="source-inline">request_animation_frame</strong>. This converts <strong class="source-inline">Closure</strong> into <strong class="source-inline">Function</strong>, without requiring an explicit dependency on the <strong class="source-inline">Function</strong> type, and it's worth thinking about when you're creating your own versions of these functions. The makers of <strong class="source-inline">web-sys</strong> have to match every single potential use case, and as such, they are going to create the widest possible interfaces. As an application programmer, you do not need most of what's in that library. Therefore, you can and should narrow the interface to your own use cases, making it easier for you to work with. In fact, in order to make things a little cleaner, we'll convert that into a type, with one small change:</p>
			<p class="source-code">pub type LoopClosure = Closure&lt;dyn FnMut(f64)&gt;;</p>
			<p class="source-code">pub fn request_animation_frame(callback: &amp;LoopClosure) -&gt;</p>
			<p class="source-code">  Result&lt;i32&gt; {</p>
			<p class="source-code">// ...</p>
			<p>Moving on from my <a id="_idIndexMarker203"/>mini-rant, you might think you can now write a simple game loop, like so:</p>
			<p class="source-code">pub fn animate(perf: f64) {</p>
			<p class="source-code">    browser::request_animation_frame(animate);</p>
			<p class="source-code">}</p>
			<p>Ah, if only, but remember that we need to pass a JavaScript <strong class="source-inline">Closure</strong>, not a Rust <strong class="source-inline">fn</strong>. Using the <strong class="source-inline">Closure::once</strong> that we used before won't work because this closure will be called more than once, but fortunately, there's <strong class="source-inline">Closure::wrap</strong>, which will do just that. We'll create a function in <strong class="source-inline">browser</strong> to create a <strong class="source-inline">Closure</strong> specific to the <strong class="source-inline">request_animation_frame</strong> function, called <strong class="source-inline">create_raf_closure</strong>:</p>
			<p class="source-code">pub fn create_raf_closure(f: impl FnMut(f64) + 'static) -&gt;</p>
			<p class="source-code">  LoopClosure {</p>
			<p class="source-code">    closure_wrap(Box::new(f))</p>
			<p class="source-code">}</p>
			<p>The function being passed in has a <strong class="source-inline">'static</strong> lifetime. Any <strong class="source-inline">FnMut</strong> passed into this function cannot have any non-static references. This wasn't a decision on my part; it's a requirement of the <strong class="source-inline">Closure::wrap</strong> function we'll be calling into.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">For more information on static lifetimes, take a look at the <em class="italic">Rust by Example</em> book, available for free here: <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html">https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html</a>. </p>
			<p>Speaking of <strong class="source-inline">Closure::wrap</strong>, let's wrap it in a <strong class="source-inline">closure_wrap</strong> function so that the code we just added will compile, which looks like the following:</p>
			<p class="source-code">pub fn closure_wrap&lt;T: WasmClosure + ?Sized&gt;(data: Box&lt;T&gt;)</p>
			<p class="source-code">  -&gt; Closure&lt;T&gt; {</p>
			<p class="source-code">    Closure::wrap(data)</p>
			<p class="source-code">}</p>
			<p>This is another one of<a id="_idIndexMarker204"/> those wrapper functions where we are just matching the same signature as the function being wrapped – <strong class="source-inline">Closure::wrap</strong>. Because the <strong class="source-inline">wrap</strong> function on <strong class="source-inline">Closure</strong> creates a <strong class="source-inline">Closure</strong> that can be called multiple times, it needs to be wrapped in a <strong class="source-inline">Box</strong> and stored on the heap.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The nightly build of <strong class="source-inline">wasm-bindgen</strong> provides a more ergonomic <strong class="source-inline">new</strong> function that handles the boxing for you. We'll stick to the stable build in this book, but you are welcome to try nightly.</p>
			<p>Now that you know the basic game loop and how to call <strong class="source-inline">request_animation_frame</strong>, you might think, "I've got this" and create the game loop as follows:</p>
			<p class="source-code">let animate = create_raf_closure(move |perf| {</p>
			<p class="source-code">    request_animation_frame(animate);</p>
			<p class="source-code">});</p>
			<p class="source-code">request_animation_frame(animate);</p>
			<p>This is closer, but it's not there yet. Remember earlier that the <strong class="source-inline">Closure</strong> we pass to <strong class="source-inline">create_raf_closure</strong> has to have a <strong class="source-inline">'static</strong> lifetime, meaning everything that the <strong class="source-inline">Closure</strong> references must be owned by the closure. That's not the case right now. The <strong class="source-inline">animate</strong> variable is owned by the current scope and will be destroyed when that scope completes. Of course, <strong class="source-inline">animate</strong> is itself<em class="italic"> </em>the <strong class="source-inline">Closure</strong> because this is a self-referencing data<a id="_idIndexMarker205"/> structure. The <strong class="source-inline">animate</strong> variable is the <strong class="source-inline">Closure</strong> but is also referenced inside the <strong class="source-inline">Closure</strong>. This is a classic Rust problem because the <strong class="source-inline">borrow</strong> checker cannot allow it.</p>
			<p>Imagine what would happen if this wasn't the case – if <strong class="source-inline">animate</strong> could be referenced in the <strong class="source-inline">Closure</strong> but be owned by the scope outside the <strong class="source-inline">Closure</strong>. It would be destroyed when the program exited this scope, and <strong class="source-inline">Closure</strong> would no longer be valid – a <strong class="source-inline">Null</strong> pointer error, and a crash. This is the trouble with a self-referencing data structure, so we'll need a way to work around the <strong class="source-inline">borrow</strong> checker.</p>
			<p>With nowhere to put this code just yet, let's have another crack at a hypothetical loop:</p>
			<p class="source-code">let f = Rc&lt;RefCell&lt;Option&lt;LoopClosure&gt;&gt;&gt; =  </p>
			<p class="source-code">  Rc::new(RefCell::new(None));</p>
			<p class="source-code">let g = f.clone();</p>
			<p class="source-code">let animate = Some(create_raf_closure(move |perf: f64| {</p>
			<p class="source-code">    request_animation_frame(f.borrow().as_ref().unwrap());</p>
			<p class="source-code">});</p>
			<p class="source-code">*g.borrow_mut() = animate;</p>
			<p class="source-code">request_animation_frame(g.borrow().as_ref().unwrap());</p>
			<p>Right now, I kinda wish I was writing JavaScript, but let's work slowly through this code. What we're doing is creating two references to the same place in memory, using <strong class="source-inline">Rc</strong> <strong class="source-inline">struct</strong>, allowing us to both take <strong class="source-inline">f</strong> and <strong class="source-inline">g</strong> and point them at the same thing but also move <strong class="source-inline">f</strong> into <strong class="source-inline">animate Closure</strong>. The other trick is that they both point to <strong class="source-inline">Option</strong> so that we can move <strong class="source-inline">f</strong> into <strong class="source-inline">Closure</strong> before it is completely defined. Finally, when we assign to <strong class="source-inline">g</strong> the <strong class="source-inline">Closure</strong> with <strong class="source-inline">*g.borrow_mut() = animate</strong>, we <strong class="bold">also</strong> assign to <strong class="source-inline">f</strong> because they are <a id="_idIndexMarker206"/>pointing to the same place. Did you get all that? No, me neither. Let's go through the types really quickly to reiterate what we did. <strong class="source-inline">f</strong> is set to the following:</p>
			<ul>
				<li><strong class="source-inline">Rc</strong> to create a reference-counted pointer</li>
				<li><strong class="source-inline">RefCell</strong> to allow for interior mutability</li>
				<li><strong class="source-inline">Option</strong> to allow us to assign <strong class="source-inline">f</strong> to <strong class="source-inline">None</strong></li>
				<li><strong class="source-inline">LoopClosure</strong> to hold a mutable <strong class="source-inline">Closure</strong> that matches the <strong class="source-inline">request_animation_frame</strong> parameter</li>
			</ul>
			<p><strong class="source-inline">g</strong> is then set to a clone of <strong class="source-inline">f</strong> so that they point to the same thing, and <strong class="source-inline">f</strong> is moved into <strong class="source-inline">animate</strong> <strong class="source-inline">Closure</strong>. <strong class="source-inline">g</strong> is assigned to <strong class="source-inline">animate</strong> via the dereference <strong class="source-inline">*</strong> operator and <strong class="source-inline">borrow_mut</strong> functions. Because <strong class="source-inline">f</strong> points to the same place as <strong class="source-inline">g</strong>, it will also contain <strong class="source-inline">animate Closure</strong>. Finally, we can call <strong class="source-inline">request_animation_frame</strong>, both outside and inside <strong class="source-inline">Closure</strong>, by borrowing it, converting it to a reference, and calling <strong class="source-inline">unwrap</strong> to actually get the real <strong class="source-inline">Closure</strong>. Yes, <strong class="source-inline">unwrap</strong> is back; we'll deal with one of those when we create our real function. Finally, <strong class="source-inline">g</strong> can be destroyed when it leaves scope because <strong class="source-inline">f</strong> is still in <strong class="source-inline">Closure</strong> and will keep the memory around.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Once again, I'd love to take credit for this code, but the truth is that it's largely defined in the <strong class="source-inline">wasm-bindgen</strong> guide at <a href="https://bit.ly/3v5FG3j">https://bit.ly/3v5FG3j</a>.</p>
			<p>Now that we<a id="_idIndexMarker207"/> know what the core of our game loop is going t<a id="_idTextAnchor077"/>o look like, how do we integrate it with a game?</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor078"/>A game trait</h2>
			<p>To write our game loop, we have a few options. We could just write the game in the loop, but that would look <a id="_idIndexMarker208"/>suspiciously similar to what we started with before. We could create a <strong class="source-inline">GameLoop</strong> struct with functions for <strong class="source-inline">update</strong> and <strong class="source-inline">draw</strong>, which is a significant improvement but still ties everything into one structure. We're going to go slightly beyond that and take inspiration from a popular game framework, XNA, or MonoGame in its modern incarnation. In the XNA framework, the game developer will implement a <strong class="source-inline">Game</strong> type, with methods for <strong class="source-inline">update</strong> and <strong class="source-inline">draw</strong>. This is slightly more complex than jamming all the code into one place but is significantly less so than a complete entity-component framework. It should work well for our purposes since it starts small and should allow for expansion as the game gets larger. There's a reason XNA was very successful.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can learn about XNA's modern equivalent, MonoGame, at <a href="https://www.monogame.net/">https://www.monogame.net/</a>.</p>
			<p>We'll create a <strong class="source-inline">start</strong> function that accepts anything that implements the <strong class="source-inline">Game</strong> trait. The <strong class="source-inline">Game</strong> trait will start with two functions, <strong class="source-inline">update</strong> and <strong class="source-inline">draw</strong>. We'll run that through our game loop to first update and then draw our scene. All of this will go into the <strong class="source-inline">engine</strong> module; indeed, arguably, this is our entire "engine." Let's start with the simple version – first, the trait:</p>
			<p class="source-code">pub trait Game {</p>
			<p class="source-code">    fn update(&amp;mut self);</p>
			<p class="source-code">    fn draw(&amp;self, context: &amp;CanvasRenderingContext2d);</p>
			<p class="source-code">}</p>
			<p>So far so good. Note how the <strong class="source-inline">draw</strong> function takes <strong class="source-inline">CanvasRenderingContext2d</strong> as a parameter. Now for the rest of the loop – you can add this after the <strong class="source-inline">Game</strong> trait or <strong class="source-inline">load_image</strong>; it doesn't really matter as long as it's in the <strong class="source-inline">engine</strong> module:</p>
			<p class="source-code">pub struct GameLoop;</p>
			<p class="source-code">type SharedLoopClosure = Rc&lt;RefCell&lt;Option&lt;LoopClosure&gt;&gt;&gt;;</p>
			<p class="source-code">impl GameLoop {</p>
			<p class="source-code">    pub async fn start(mut game: impl Game + 'static) -&gt; </p>
			<p class="source-code">      Result&lt;()&gt; {</p>
			<p class="source-code">        let f: SharedLoopClosure =</p>
			<p class="source-code">          Rc::new(RefCell::new(None));</p>
			<p class="source-code">        let g = f.clone();</p>
			<p class="source-code">        *g.borrow_mut() = Some(</p>
			<p class="source-code">          browser::create_raf_closure(move |perf: f64| {</p>
			<p class="source-code">            game.update();</p>
			<p class="source-code">            game.draw(&amp;browser::context().expect("Context</p>
			<p class="source-code">              should exist"));</p>
			<p class="source-code">            browser::request_animation_frame(</p>
			<p class="source-code">              f.borrow().as_ref().unwrap());</p>
			<p class="source-code">        }));</p>
			<p class="source-code">        browser::request_animation_frame(</p>
			<p class="source-code">            g.borrow()</p>
			<p class="source-code">                .as_ref()</p>
			<p class="source-code">                .ok_or_else(|| anyhow!("GameLoop: Loop is </p>
			<p class="source-code">                                        None"))?,</p>
			<p class="source-code">        )?;</p>
			<p class="source-code">        Ok(())</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This is a bit larger but it's nothing you haven't seen before. We're going to create a <strong class="source-inline">GameLoop</strong> struct with no data and add a <strong class="source-inline">SharedLoopClosure</strong> type to simplify the type of the <strong class="source-inline">f</strong> and <strong class="source-inline">g</strong> variables. Then, we'll add an implementation of <strong class="source-inline">GameLoop</strong> with one method, <strong class="source-inline">start</strong>, that takes the <strong class="source-inline">Game</strong> trait as a parameter. Note that the trait is <strong class="source-inline">'static</strong> because anything moved into the "raf" closure has to be <strong class="source-inline">'static</strong>. We follow the snippets we<a id="_idIndexMarker209"/> used before to set up our <strong class="source-inline">request_animation_frame</strong> loop, and the key change is on the inside where we update and then draw, passing the <strong class="source-inline">draw</strong> function <strong class="source-inline">CanvasRenderingContext2d</strong>.</p>
			<p>There's a problem with this kind of naive game loop. Typically, <strong class="source-inline">request_animation_frame</strong> runs at 60 frames per second, but if either <strong class="source-inline">update</strong> or <strong class="source-inline">draw</strong> takes longer than 1/60th of a second, it will slow down, making the game move more slowly. A long time ago, I recall beating levels by turning off the "<strong class="bold">Turbo</strong>" button on my desktop, making it possible to beat previously impossible challenges because the game became easier to play at slower speeds. Since we want a consistent experience across processor speeds, we'll tak<a id="_idTextAnchor079"/>e a common approach called "fixing" the time step.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor080"/>Fixing our time step</h2>
			<p>You might <a id="_idIndexMarker210"/>notice that the <strong class="source-inline">update</strong> function we wrote doesn't take <strong class="source-inline">perf</strong> as a parameter; in fact, it's unused. Now, imagine trying to simulate a dog running across the screen, with no knowledge of how much time has passed between frames. Depending on the computer and your guess, the dog could saunter from left to right, or shoot past like a bullet. What we could do is send the delta time on each update, which can work but gets complicated very quickly. Instead, we'll assume every single tick takes the same amount of time, 1/60th of a second, and call <strong class="source-inline">update</strong> several times to "catch up" if we fall behind. It looks like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer027">
					<img alt="Figure 3.4 – A fixed step game loop" src="image/Figure_3.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – A fixed step game loop</p>
			<p>This isn't a perfect<a id="_idIndexMarker211"/> solution; if our game is very slow, it'll grind to a halt, but it should be good enough for our purposes. This is why I had us create a <strong class="source-inline">GameLoop</strong> struct – to track the time of the last update. We'll add two fields to the <strong class="source-inline">GameLoop</strong> struct:</p>
			<p class="source-code">const FRAME_SIZE: f32 = 1.0 / 60.0 * 1000.0;</p>
			<p class="source-code">pub struct GameLoop {</p>
			<p class="source-code">    last_frame: f64,</p>
			<p class="source-code">    accumulated_delta: f32,</p>
			<p class="source-code">}</p>
			<p>This adds a constant for the<a id="_idIndexMarker212"/> length of a frame, converted to milliseconds. We'll track when the previous frame was requested in the <strong class="source-inline">last_frame</strong> field, and we'll accumulate a delta that totals up the physics time since the last render. It's not quite the same thing twice, as you'll see when we implement that counter in the <strong class="source-inline">start</strong> function. Speaking of that function, we'll need to initialize a mutable <strong class="source-inline">GameLoop</strong> at the beginning of that function:</p>
			<p class="source-code">impl GameLoop {</p>
			<p class="source-code">    pub async fn start(mut game: impl Game + 'static) -&gt;</p>
			<p class="source-code">      Result&lt;()&gt; {</p>
			<p class="source-code">        let mut game_loop = GameLoop {</p>
			<p class="source-code">            last_frame: browser::now()?,</p>
			<p class="source-code">            accumulated_delta: 0.0,</p>
			<p class="source-code">        };</p>
			<p class="source-code">        ...</p>
			<p>This initializes <strong class="source-inline">GameLoop</strong> appropriately, using <strong class="source-inline">now</strong> as the time of the last frame instead of <strong class="source-inline">0</strong> so that our loop doesn't perform several million updates before the first render. <strong class="source-inline">browser::now()</strong> hasn't been implemented yet, so you'll need to add it to the <strong class="source-inline">browser</strong> module:</p>
			<p class="source-code">pub fn now() -&gt; Result&lt;f64&gt; {</p>
			<p class="source-code">    Ok(window()?</p>
			<p class="source-code">        .performance()</p>
			<p class="source-code">        .ok_or_else(|| anyhow!</p>
			<p class="source-code">            ("Performance object not found"))?</p>
			<p class="source-code">        .now())</p>
			<p class="source-code">}</p>
			<p>This is just a wrapper around the web browser's <strong class="source-inline">now</strong> function. If you've been diligently following, you will probably recognize that this causes a compiler error. You'll need to add the "<strong class="source-inline">Performance</strong>" feature flag to the <strong class="source-inline">web-sys</strong> features list to bring in that function.</p>
			<p>Now that we've created a game loop object, inside the <strong class="source-inline">request_animation_frame</strong> closure, we'll add our accumulator:</p>
			<p class="source-code">*g.borrow_mut() = Some(browser::create_raf_closure(move </p>
			<p class="source-code">  |perf: f64| {</p>
			<p class="source-code">    game_loop.accumulated_delta += (</p>
			<p class="source-code">      perf - game_loop.last_frame) as f32;</p>
			<p class="source-code">    while game_loop.accumulated_delta &gt; FRAME_SIZE {</p>
			<p class="source-code">        game.update();</p>
			<p class="source-code">        game_loop.accumulated_delta -= FRAME_SIZE;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    game_loop.last_frame = perf;</p>
			<p class="source-code">    game.draw(&amp;browser::context().expect("Context should</p>
			<p class="source-code">      exist"));</p>
			<p>What's changed since<a id="_idIndexMarker213"/> last time is that instead of just calling the <strong class="source-inline">update</strong> function immediately, we calculate the difference between <strong class="source-inline">perf</strong>, which if you remember from earlier is a high-res timestamp of the time that the <strong class="source-inline">request_animation_frame</strong> function started executing callback functions. We get the difference between now (in <strong class="source-inline">perf</strong>) and the previous frame and add that to <strong class="source-inline">accumulated_delta</strong>. Then, we compare this to our desired <strong class="source-inline">FRAME_SIZE</strong> (that's 1/60th of a second), and if there's <strong class="bold">more </strong>accumulated delta than the frame size, we call <strong class="source-inline">update</strong>. Then we subtract the frame size from the delta. What is the effect of all this? If <strong class="source-inline">game.draw</strong> takes too long so that we cannot complete 1 frame in 1/60th of a second, the code will run extra updates to catch up.</p>
			<p>An example is helpful here. Assume you started playing the game at time <strong class="source-inline">0</strong>, the beginning of the world. When the first callback executes for <strong class="source-inline">request_animation_frame</strong> its probably very close to <strong class="source-inline">0</strong>, perhaps as low as <strong class="source-inline">1</strong> millisecond, because there's no delay on the first frame. The code will add that to <strong class="source-inline">accumulated_delta</strong> and then compare it to <strong class="source-inline">FRAME_SIZE</strong> and see that there hasn't been enough delta accumulation, so <strong class="source-inline">update</strong> is skipped. The <strong class="source-inline">last_frame</strong> value is stored (again, we'll say it's <strong class="source-inline">1</strong>), the screen is drawn, and then <strong class="source-inline">request_animation_frame</strong> is called.</p>
			<p>The second time though, the value of <strong class="source-inline">perf</strong> is likely to be about the size of the first frame. We'll use <strong class="source-inline">17</strong> milliseconds for simple math. So <strong class="source-inline">perf</strong> is <strong class="source-inline">17</strong>; subtract from it the <strong class="source-inline">last_frame</strong>, which is <strong class="source-inline">1</strong>, and add <strong class="source-inline">16</strong> milliseconds to <strong class="source-inline">accumulated_delta</strong>. The new value of <strong class="source-inline">accumulated_delta</strong> is <strong class="source-inline">17</strong>, so the game is updated once and <strong class="source-inline">accumulated_delta</strong> is reduced to <strong class="source-inline">1</strong>. The game continues with one update to one draw until something goes <a id="_idIndexMarker214"/>wrong. The <strong class="source-inline">draw</strong> call takes <strong class="source-inline">40</strong> milliseconds! Who knows why – maybe an autoplay video started up by surprise, taking resources. It doesn't matter because <strong class="source-inline">accumulated_delta</strong> shoots up to <strong class="source-inline">40</strong>, which is larger than <strong class="source-inline">2</strong> frames. Now, the loop on <strong class="source-inline">accumulated_delta</strong> runs <strong class="source-inline">update</strong> twice, dropping a frame of animation to compensate for the drop in performance. The important thing to remember here is that it drops a <em class="italic">draw</em> but not an <em class="italic">update</em>, so while the player might see some visual artifacts, the physics will still work without issue.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You might wonder what happens to the extra <strong class="source-inline">accumulated_delta</strong> since it's unlikely to be an exact multiple of <strong class="source-inline">FRAME_SIZE</strong>. More advanced game loops will pass that into the draw and use it to interpolate between the two update values. We shouldn't need that for our game and will just roll that <strong class="source-inline">delta</strong> over to the next frame.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Why use an <strong class="source-inline">f32</strong> for the <strong class="source-inline">accumulated_delta</strong>? That's very observant of you! The short version is, because we can. The slightly longer version is that we only use <strong class="source-inline">f64</strong> as often as we do because JavaScript uses a 64-bit <strong class="source-inline">Number</strong> type for all its numbers. If I could, I'd use smaller values whenever possible, and integers as well, because the extra size of <strong class="source-inline">f64</strong> isn't really necessary and can cause a surprising drag on performance when repeated everywhere.</p>
			<p>So, there you have it – your game loop, at least the "looping" part of it. While it's usable now, it doesn't provide an easy way to load our assets. While we could just leave things as they are and always<a id="_idIndexMarker215"/> load assets before we start our game loop, a cleaner<a id="_idTextAnchor081"/> solution is to integrate that rule into the game loop.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor082"/>Loading assets</h2>
			<p>Expanding our game loop to <a id="_idIndexMarker216"/>handle loading assets is going to require adding a function to our trait, an <strong class="source-inline">async</strong> one to be precise. This will allow us to put all our asynchronous code that's currently wrapped in the <strong class="source-inline">spawn_local</strong> in <strong class="source-inline">lib</strong> and put it in a function that returns <strong class="source-inline">Result</strong> with <strong class="source-inline">Game</strong> in it. You can start by adding that function to the <strong class="source-inline">Game</strong> trait:</p>
			<p class="source-code">pub trait Game {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt;;</p>
			<p class="source-code">    fn update(&amp;mut self);</p>
			<p class="source-code">    fn draw(&amp;self, context: &amp;Renderer);</p>
			<p class="source-code">}</p>
			<p>Unfortunately, that doesn't compile. <strong class="source-inline">async</strong> trait functions haven't landed in stable Rust yet, but fortunately, we can use a crate to get that functionality. Add <strong class="source-inline">async-trait = "0.1.52"</strong> to <strong class="source-inline">Cargo.toml</strong> and then add the following attribute macro to the trait:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">pub trait Game {</p>
			<p>You'll also need to import <strong class="source-inline">async_trait::async_trait</strong>. The <strong class="source-inline">async_trait</strong> allows us to add <strong class="source-inline">async</strong> functions to a trait. We can use it with the <strong class="source-inline">?Send</strong> trait because we don't need our futures to be thread-safe. Now, we can add this to the game loop:</p>
			<p class="source-code">impl GameLoop {</p>
			<p class="source-code">    pub async fn start(game: impl Game + 'static) -&gt;</p>
			<p class="source-code">      Result&lt;()&gt; {</p>
			<p class="source-code">        let mut game = game.initialize().await?;</p>
			<p class="source-code">        ....</p>
			<p>And that's it! The game gets initialized, asynchronously, and with <strong class="source-inline">Result</strong> on the first line. Note that the passed-in <strong class="source-inline">game</strong> no longer has to be mutable since we're not mutating it in the function <a id="_idIndexMarker217"/>anywhere. We're almost ready to integrate our old <strong class="source-inline">set_interval</strong> into this, but the<a id="_idTextAnchor083"/>re's a little more cleanup I'd like to do around drawing.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor084"/>Cleaner drawing</h2>
			<p>Currently, we're <a id="_idIndexMarker218"/>sending a raw <strong class="source-inline">CanvasRenderingContext2d</strong> to the draw loop, with all of its awkward functions such as <strong class="source-inline">draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh</strong>. This works but it's ugly, and much like we did with the <strong class="source-inline">browser</strong> module, we can use a wrapper to narrow the context's wide interface to a smaller one, tailored to our needs. We'll replace passing <strong class="source-inline">CanvasRenderingContext2d</strong> with our own <strong class="source-inline">Renderer</strong> object that has easier-to-use functions.</p>
			<p>We'll start by creating a structure for our <strong class="source-inline">Renderer</strong> in <strong class="source-inline">engine</strong>:</p>
			<p class="source-code">pub struct Renderer {</p>
			<p class="source-code">    context: CanvasRenderingContext2d,</p>
			<p class="source-code">}</p>
			<p>This is a simple wrapper containing the rendering context. For now, we'll just add the two implementation methods to the <strong class="source-inline">Renderer</strong> struct:</p>
			<p class="source-code">impl Renderer {</p>
			<p class="source-code">    pub fn clear(&amp;self, rect: &amp;Rect) {</p>
			<p class="source-code">        self.context.clear_rect(</p>
			<p class="source-code">            rect.x.into(),</p>
			<p class="source-code">            rect.y.into(),</p>
			<p class="source-code">            rect.width.into(),</p>
			<p class="source-code">            rect.height.into(),</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p class="source-code">    pub fn draw_image(&amp;self, image: &amp;HtmlImageElement,</p>
			<p class="source-code">      frame: &amp;Rect, destination: &amp;Rect) {</p>
			<p class="source-code">        self.context</p>
			<p class="source-code">            .draw_image_with_html_image_element_and_sw_and_sh_                and_dx_and_dy_and_dw_and_dh(</p>
			<p class="source-code">                &amp;image,</p>
			<p class="source-code">                frame.x.into(),</p>
			<p class="source-code">                frame.y.into(),</p>
			<p class="source-code">                frame.width.into(),</p>
			<p class="source-code">                frame.height.into(),</p>
			<p class="source-code">                destination.x.into(),</p>
			<p class="source-code">                destination.y.into(),</p>
			<p class="source-code">                destination.width.into(),</p>
			<p class="source-code">                destination.height.into(),</p>
			<p class="source-code">            )</p>
			<p class="source-code">            .expect("Drawing is throwing exceptions!</p>
			<p class="source-code">                     Unrecoverable error.");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>These two functions, <strong class="source-inline">clear</strong> and <strong class="source-inline">draw_image</strong>, both wrap <strong class="source-inline">context</strong> functions but do so using fewer parameters. Instead<a id="_idIndexMarker219"/> of four parameters and <strong class="source-inline">clear_rect</strong>, we pass <strong class="source-inline">clear</strong> <strong class="source-inline">Rect</strong>. Instead of that incredibly long function name, we pass <strong class="source-inline">draw_image</strong> <strong class="source-inline">HtmlImageElement</strong> and two <strong class="source-inline">Rect</strong> structures. Currently, we go ahead and use <strong class="source-inline">expect</strong> to panic! here if we can't draw. I am convinced that this should return <strong class="source-inline">Result</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">By now, there's been code in this book that you've thought could be done better. Try that out! I do that all the time when I follow books, and there's no reason you shouldn't too. Just try to remember where you've diverged from the book.</p>
			<p>Of course, both of these<a id="_idIndexMarker220"/> functions take <strong class="source-inline">Rect</strong>, but we don't have a <strong class="source-inline">Rect</strong> structure. Let's add that to the <strong class="source-inline">engine</strong> now:</p>
			<p class="source-code">pub struct Rect {</p>
			<p class="source-code">    pub x: f32,</p>
			<p class="source-code">    pub y: f32,</p>
			<p class="source-code">    pub width: f32,</p>
			<p class="source-code">    pub height: f32,</p>
			<p class="source-code">}</p>
			<p>Now we can change the draw function to take <strong class="source-inline">Renderer</strong> instead of <strong class="source-inline">CanvasRenderingContext2d</strong>. So, we update the trait:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">pub trait Game {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer);</p>
			<p class="source-code">}</p>
			<p>Then, we can make a change to the loop. Right now, we create <strong class="source-inline">context</strong> in the <strong class="source-inline">Closure</strong> that we pass to <strong class="source-inline">create_raf_closure</strong>. That call returns <strong class="source-inline">Result</strong>, so to get access to <strong class="source-inline">context</strong>, we have to call <strong class="source-inline">unwrap</strong> or <strong class="source-inline">expect</strong>. The cleaner approach we can use now is to create <strong class="source-inline">Renderer</strong>, with <strong class="source-inline">Context</strong> outside of <strong class="source-inline">Closure</strong>, as shown here:</p>
			<p class="source-code">let mut game_loop = GameLoop {</p>
			<p class="source-code">    last_frame: browser::now()?,</p>
			<p class="source-code">    accumulated_delta: 0.0,</p>
			<p class="source-code">};</p>
			<p class="source-code"><strong class="bold">let renderer = Renderer {</strong></p>
			<p class="source-code"><strong class="bold">    context: browser::context()?,</strong></p>
			<p class="source-code"><strong class="bold">};</strong></p>
			<p class="source-code">...</p>
			<p class="source-code">*g.borrow_mut() = Some(browser::create_raf_closure(</p>
			<p class="source-code">  move |perf: f64| {</p>
			<p class="source-code">    ...</p>
			<p class="source-code"><strong class="bold">    game.draw(&amp;renderer);</strong></p>
			<p class="source-code">    browser::request_animation_frame(f.borrow().as_ref().        unwrap());</p>
			<p class="source-code">}));</p>
			<p>Moving this <a id="_idIndexMarker221"/>outside of the <strong class="source-inline">request_animation_frame</strong> closure means we don't need to use the <strong class="source-inline">expect</strong> syntax anymore – nice! </p>
			<p>The small change to <strong class="source-inline">draw</strong>, turning it into <strong class="source-inline">game.draw(&amp;renderer)</strong>, will make our <strong class="source-inline">draw</strong> function easier to write. I think we're meeting our goal of changing the code to make it <em class="italic">easier</em> to move forward. Let's prove it by <a id="_idTextAnchor085"/>taking our animation code out of <strong class="source-inline">lib</strong> and using the game loop.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor086"/>Integrating the game loop</h2>
			<p>It's great that we've <a id="_idIndexMarker222"/>written this game loop and all, but it's about time we actually use it. Remember that we have our <strong class="source-inline">GameLoop</strong> structure, but it operates on a <strong class="source-inline">Game</strong> trait. So in order to use the loop, we need to implement that trait. We'll implement it in another module, <strong class="source-inline">game</strong>, which we'll create in <strong class="source-inline">game.rs</strong> and then add to the library using the <strong class="source-inline">mod game</strong> instruction declaration in <strong class="source-inline">lib.rs</strong>. We'll start with a couple of structures:</p>
			<p class="source-code">use crate::engine::{Game, Renderer};</p>
			<p class="source-code">use anyhow::Result;</p>
			<p class="source-code">use async_trait::async_trait;</p>
			<p class="source-code">pub struct WalkTheDog;</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        Ok(Box::new(WalkTheDog {}))</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fn update(&amp;mut self) {}</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {}</p>
			<p class="source-code">}</p>
			<p>Make sure that you add the <strong class="source-inline">#[async_trait(?Send)]</strong> annotation, which allows you to implement a trait with the <strong class="source-inline">async</strong> functions. Provided you add the required <strong class="source-inline">use</strong> declarations from <strong class="source-inline">engine</strong>, this compiles because <strong class="source-inline">Game</strong> implements the trait as needed. It doesn't do anything, but it compiles. The <strong class="source-inline">initialize</strong> function might look a little strange because we're taking <strong class="source-inline">self</strong> and just throwing it away in favor of a new <strong class="source-inline">WalkTheDog</strong> structure – thrown on the heap, no less! We're doing that for some changes that you'll see in the next chapter, so just bear with me for now. </p>
			<p>Now, let's take the <a id="_idIndexMarker223"/>code that draws from <strong class="source-inline">lib.rs</strong> and move it into <strong class="source-inline">draw</strong>, updating it along the way:</p>
			<p class="source-code">fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">    let frame_name = format!("Run ({}).png", self.frame +</p>
			<p class="source-code">                              1);</p>
			<p class="source-code">    let sprite = self.sheet.frames.get(&amp;frame_name).expect(</p>
			<p class="source-code">      "Cell not found");</p>
			<p class="source-code">    renderer.clear(Rect {</p>
			<p class="source-code">        x: 0.0,</p>
			<p class="source-code">        y: 0.0,</p>
			<p class="source-code">        width: 600.0,</p>
			<p class="source-code">        height: 600.0,</p>
			<p class="source-code">    });</p>
			<p class="source-code">    renderer.draw_image(</p>
			<p class="source-code">        &amp;self.image,</p>
			<p class="source-code">        Rect {</p>
			<p class="source-code">            x: sprite.frame.x.into(),</p>
			<p class="source-code">            y: sprite.frame.y.into(),</p>
			<p class="source-code">            width: sprite.frame.w.into(),</p>
			<p class="source-code">            height: sprite.frame.h.into(),</p>
			<p class="source-code">        },</p>
			<p class="source-code">        Rect {</p>
			<p class="source-code">            x: 300.0,</p>
			<p class="source-code">            y: 300.0,</p>
			<p class="source-code">            width: sprite.frame.w.into(),</p>
			<p class="source-code">            height: sprite.frame.h.into(),</p>
			<p class="source-code">        },</p>
			<p class="source-code">    );</p>
			<p class="source-code">}</p>
			<p>This only contains slight changes to the code in <strong class="source-inline">lib.rs</strong>, although it definitely won't compile. Calls to <strong class="source-inline">context</strong> are replaced with calls to <strong class="source-inline">renderer</strong>, and we've used the new <strong class="source-inline">Rect</strong> structure. This won't <a id="_idIndexMarker224"/>compile because <strong class="source-inline">self</strong> doesn't have <strong class="source-inline">sheet</strong>, <strong class="source-inline">frame</strong>, or <strong class="source-inline">image</strong>. We'll need to add that to the <strong class="source-inline">game</strong> module, as follows:</p>
			<p class="source-code">#[derive(Deserialize)]</p>
			<p class="source-code">struct SheetRect {</p>
			<p class="source-code">    x: i16,</p>
			<p class="source-code">    y: i16,</p>
			<p class="source-code">    w: i16,</p>
			<p class="source-code">    h: i16,</p>
			<p class="source-code">}</p>
			<p class="source-code">#[derive(Deserialize)]</p>
			<p class="source-code">struct Cell {</p>
			<p class="source-code">    frame: SheetRect,</p>
			<p class="source-code">}</p>
			<p class="source-code">#[derive(Deserialize)]</p>
			<p class="source-code">pub struct Sheet {</p>
			<p class="source-code">    frames: HashMap&lt;String, Cell&gt;,</p>
			<p class="source-code">}</p>
			<p class="source-code">pub struct WalkTheDog {</p>
			<p class="source-code">    image: HtmlImageElement,</p>
			<p class="source-code">    sheet: Sheet,</p>
			<p class="source-code">    frame: u8,</p>
			<p class="source-code">}</p>
			<p>Here, we've moved the structures from <strong class="source-inline">lib.rs</strong> that serialize the JSON from our sprite sheet and added fields for <strong class="source-inline">frame</strong>, <strong class="source-inline">HtmlImageElement</strong>, and <strong class="source-inline">Sheet</strong> to the <strong class="source-inline">WalkTheDog</strong> struct. Pay close attention to the fact that we've taken <strong class="source-inline">Rect</strong> from <strong class="source-inline">lib</strong> and renamed it <strong class="source-inline">SheetRect</strong>. This is the specific rectangle from our sprite sheet. In <strong class="source-inline">game</strong>, we also have a <strong class="source-inline">Rect</strong> structure. This is the rectangle that we'll use as a game domain object. This rename is<a id="_idIndexMarker225"/> confusing right now but is done to differentiate the two rectangles and is helpful as we go forward.</p>
			<p>The <strong class="source-inline">WalkTheDog</strong> structure has the fields needed to make <strong class="source-inline">draw</strong> compile, but it may make you wonder about <strong class="source-inline">initialize</strong>. Specifically, if we're going to move our loading code to <strong class="source-inline">initialize</strong>, does the <strong class="source-inline">WalkTheDog</strong> struct really always have <strong class="source-inline">HtmlImageElement</strong> and <strong class="source-inline">Sheet</strong>? No, it does not. We'll need to convert those fields to <strong class="source-inline">Option</strong> types and make the <strong class="source-inline">draw</strong> function account for them:</p>
			<p class="source-code">pub struct WalkTheDog {</p>
			<p class="source-code">    image: Option&lt;HtmlImageElement&gt;,</p>
			<p class="source-code">    sheet: Option&lt;Sheet&gt;,</p>
			<p class="source-code">    frame: u8,</p>
			<p class="source-code">}</p>
			<p>We can use the <strong class="source-inline">as_ref()</strong> function to borrow <strong class="source-inline">image</strong> and <strong class="source-inline">sheet</strong>, and then use the <strong class="source-inline">and_then</strong> and <strong class="source-inline">map</strong> <strong class="source-inline">Option</strong> functions to cleanly get the frame and then draw it:</p>
			<p class="source-code">fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">    let frame_name = format!("Run ({}).png", self.frame + 1);</p>
			<p class="source-code">    let sprite = self</p>
			<p class="source-code">        .sheet</p>
			<p class="source-code">        <strong class="bold">.as_ref()</strong></p>
			<p class="source-code">        .and_then(|sheet| sheet.frames.get(&amp;frame_name))</p>
			<p class="source-code">        .expect("Cell not found");</p>
			<p class="source-code">    renderer.clear(&amp;Rect {</p>
			<p class="source-code">        x: 0.0,</p>
			<p class="source-code">        y: 0.0,</p>
			<p class="source-code">        width: 600.0,</p>
			<p class="source-code">        height: 600.0,</p>
			<p class="source-code">    });</p>
			<p class="source-code">    <strong class="bold">self.image.as_ref().map(|image| {</strong></p>
			<p class="source-code">        renderer.draw_image(</p>
			<p class="source-code">            &amp;image,</p>
			<p class="source-code">            &amp;Rect {</p>
			<p class="source-code">                x: sprite.frame.x.into(),</p>
			<p class="source-code">                y: sprite.frame.y.into(),</p>
			<p class="source-code">                width: sprite.frame.w.into(),</p>
			<p class="source-code">                height: sprite.frame.h.into(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">            &amp;Rect {</p>
			<p class="source-code">                x: 300.0,</p>
			<p class="source-code">                y: 300.0,</p>
			<p class="source-code">                width: sprite.frame.w.into(),</p>
			<p class="source-code">                height: sprite.frame.h.into(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">        );</p>
			<p class="source-code">    });</p>
			<p>This is great – we've got a game that draws absolutely nothing, but that's okay since our initialize code still doesn't compile. Let's prepare to draw by copying our loading code from <strong class="source-inline">lib.rs</strong> to the <strong class="source-inline">initialize</strong> function in the game loop. Don't do any cutting and pasting yet; we'll go ahead <a id="_idIndexMarker226"/>and clean up <strong class="source-inline">lib.rs</strong> at the end. <strong class="source-inline">Initialize</strong> should now look like this:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        let sheet: Sheet = browser::fetch_json("rhb.json")</p>
			<p class="source-code">            .await</p>
			<p class="source-code">            .expect("Could not fetch rhb.json")</p>
			<p class="source-code">            .into_serde()</p>
			<p class="source-code">            .expect("Could not convert rhb.json into a </p>
			<p class="source-code">                     Sheet structure");</p>
			<p class="source-code">        let image = engine::load_image("rhb.png")</p>
			<p class="source-code">            .await</p>
			<p class="source-code">            .expect("Could not load rhb.png");</p>
			<p class="source-code">        Ok(Box::new(WalkTheDog {</p>
			<p class="source-code">            image: Some(image),</p>
			<p class="source-code">            sheet: Some(sheet),</p>
			<p class="source-code">            frame: self.frame,</p>
			<p class="source-code">        }))</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p>That's a great copy and paste, but we can make it far more concise by using the <strong class="source-inline">?</strong> operator. Here's the version with that improvement:</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        let sheet = browser::fetch_json(</p>
			<p class="source-code">          "rhb.json").await?.into_serde()?;</p>
			<p class="source-code">        let image = </p>
			<p class="source-code">          Some(engine::load_image("rhb.png").await?);</p>
			<p class="source-code">        Ok(Box::new(WalkTheDog {</p>
			<p class="source-code">            image,</p>
			<p class="source-code">            sheet,</p>
			<p class="source-code">            frame: self.frame,</p>
			<p class="source-code">        }))</p>
			<p class="source-code">    }</p>
			<p>Look how small and clean that function is. It only took us three tries, but we got there. Now that we have <strong class="source-inline">initialize</strong> and <strong class="source-inline">draw</strong>, we can write <strong class="source-inline">update</strong>. The version we wrote in <strong class="source-inline">lib.rs</strong> used <strong class="source-inline">set_interval_with_callback_and_timeout_and_arguments_0</strong> to animate our Red Hat Boy, but that's not going to work anymore. Instead, the <strong class="source-inline">update</strong> function will need to keep <a id="_idIndexMarker227"/>track of the number of frames that have passed and advance when it's appropriate. In the original code, we called the <strong class="source-inline">set_interval</strong> callback every <strong class="source-inline">50</strong> milliseconds. In this new code, <strong class="source-inline">update</strong> will be called every 1/60th of a second, or <strong class="source-inline">16.7</strong> milliseconds. So, in order to approximately match the animation, we'll want to update the current sprite frame every three updates; otherwise, our little RHB will run very, very fast.</p>
			<p>If you look at the <strong class="source-inline">rhb.json</strong> file, you can see that there are eight frames in the <strong class="source-inline">Run</strong> animation. If we want to advance a sprite frame every 3 updates, that means it will take 24 updates to complete the animation. At that point, we'll want to return to the beginning and play it again. So, we'll need to calculate the sprite frame from the frame count, which is updated in the <strong class="source-inline">update</strong> function:</p>
			<p class="source-code">fn update(&amp;mut self) {</p>
			<p class="source-code">    if self.frame &lt; 23 {</p>
			<p class="source-code">        self.frame += 1;</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        self.frame = 0;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This won't work with our current <strong class="source-inline">draw</strong> code because it uses <strong class="source-inline">frame</strong> to look up the sprite to render. It will crash when it looks for <strong class="source-inline">Run (9).png</strong>, which doesn't exist. We'll update the <strong class="source-inline">draw</strong> function to get the sprite index from <strong class="source-inline">frame</strong>:</p>
			<p class="source-code">fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">    let current_sprite = (self.frame / 3) + 1;</p>
			<p class="source-code">    let frame_name = format!("Run ({}).png", </p>
			<p class="source-code">      current_sprite);</p>
			<p class="source-code">    ...</p>
			<p>The <strong class="source-inline">current_sprite</strong> variable will cycle from one to eight, and then loop back again. Don't believe me? Feel free to use the <strong class="source-inline">log!</strong> macro we wrote earlier to check my work; in fact, I encourage you to. Not <a id="_idIndexMarker228"/>because I'm arrogant but because it's always good to experiment with the code, rather than blindly typing it in. We then take that number and use it to look up the frame name.</p>
			<p>With that accomplished, we now have a game loop that can render to the canvas and a game that renders our running RHB; we just need to integrate it. We'll add a plain constructor to the <strong class="source-inline">WalkTheDog</strong> struct, right under the <strong class="source-inline">struct</strong> definition in <strong class="source-inline">engine</strong>:</p>
			<p class="source-code">impl WalkTheDog {</p>
			<p class="source-code">    pub fn new() -&gt; Self {</p>
			<p class="source-code">        WalkTheDog {</p>
			<p class="source-code">            image: None,</p>
			<p class="source-code">            sheet: None,</p>
			<p class="source-code">            frame: 0,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Nothing spectacular there – just something to make it easier to create the game object. And now for the moment you've been waiting for – the new main function integrating all these changes:</p>
			<p class="source-code">#[wasm_bindgen(start)]</p>
			<p class="source-code">pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {</p>
			<p class="source-code">    console_error_panic_hook::set_once();</p>
			<p class="source-code">    browser::spawn_local(async move {</p>
			<p class="source-code">        let game = WalkTheDog::new();</p>
			<p class="source-code">        GameLoop::start(game)</p>
			<p class="source-code">            .await</p>
			<p class="source-code">            .expect("Could not start game loop");</p>
			<p class="source-code">    });</p>
			<p class="source-code">    Ok(())</p>
			<p class="source-code">}</p>
			<p>No, really, that's it – that's the <a id="_idIndexMarker229"/>whole thing. You spawn a local future, create a new game, and then call <strong class="source-inline">GameLoop::start(game).await</strong> to start it up. You can delete all the unused code from <strong class="source-inline">lib.rs</strong>, such as the extra <strong class="source-inline">use</strong> declarations and the structures we defined when everything was here. It looks great!</p>
			<p>We changed a lot of code to get<a id="_idIndexMarker230"/> here, but now we have a running game with a proper loop. We could end the chapter here, but it woul<a id="_idTextAnchor087"/>d be kind of nice if the code actually did something new, wouldn't it?</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor088"/>Adding keyboard input</h1>
			<p>Most games have<a id="_idIndexMarker231"/> some form of user input; otherwise, they aren't much of a game. In this section, we'll start listening to keyboard events and use them to control our RHB. That means adding keyboard input to the game loop and passing that into the <strong class="source-inline">update</strong> function. What we will <em class="italic">not</em> be doing is yet more refactoring. The system is reasonably well factored at this point and is open to our new changes.</p>
			<p>The specific process by which we'll get keyboard events is probably a little different than you're used to if you do web development. In a normal program, you would listen for keys to get pressed – in other words, pushed down and then released – and then do something such as update the screen when the button is released. This doesn't fit in with a game because typical players want the action to happen as soon as a key is pushed down and want it to continue for as long as it's held. Think of moving around the screen with the arrow keys. You expect motion to start the second you hit the arrow key, not after you release it. In addition, traditional programming doesn't account for things like pressing "up" and "right" at the same time. If we process those as two separate actions, we'll move right, then up, then right, and then up, like we're moving up the stairs. What we'll do is listen to every <strong class="source-inline">keyup</strong> and <strong class="source-inline">keydown</strong> event, and bundle that all up into a <strong class="source-inline">keystate</strong> that stores every currently pressed key. Then we'll pass that state to the <strong class="source-inline">update</strong> function so that the game can figure out just what to do with all the currently pressed keys.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">This approach is common in games, and it leads to one downside. If you want to trigger something only when a button is pressed, such as firing a gun, you have to keep track of whether or not the previous update had the key up and the next update had it down. So, by flipping from an event-driven approach to a global key state, we lose the events. Fortunately, this is easily recreated.</p>
			<p>To get keyboard events, we have to listen for the <strong class="source-inline">keydown</strong> and <strong class="source-inline">keyup</strong> events on <strong class="source-inline">canvas</strong>. Let's start with a <a id="_idIndexMarker232"/>new function in <strong class="source-inline">engine</strong>, <strong class="source-inline">prepare_input()</strong>:</p>
			<p class="source-code">fn prepare_input() {</p>
			<p class="source-code">    let onkeydown = browser::closure_wrap(</p>
			<p class="source-code">      Box::new(move |keycode: web_sys::KeyboardEvent| {})</p>
			<p class="source-code">        as Box&lt;dyn FnMut(web_sys::KeyboardEvent)&gt;);</p>
			<p class="source-code">    let onkeyup = browser::closure_wrap(Box::new(</p>
			<p class="source-code">      move |keycode: web_sys::KeyboardEvent| {})</p>
			<p class="source-code">        as Box&lt;dyn FnMut(web_sys::KeyboardEvent)&gt;);</p>
			<p class="source-code">    browser::canvas()</p>
			<p class="source-code">        .unwrap()</p>
			<p class="source-code">        .set_onkeydown(Some(onkeydown.as_ref().unchecked_ref()));</p>
			<p class="source-code">    browser::canvas()</p>
			<p class="source-code">        .unwrap()</p>
			<p class="source-code">        .set_onkeyup(Some(onkeyup.as_ref().unchecked_ref()));</p>
			<p class="source-code">    onkeydown.forget();</p>
			<p class="source-code">    onkeyup.forget();</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Make sure you set up your <strong class="source-inline">canvas</strong> element with a <strong class="source-inline">tabIndex</strong> attribute in the HTML file; otherwise, it cannot get focus and have keyboard events.</p>
			<p>This is enough to get us started. It should look familiar because we're setting up <strong class="source-inline">Closure</strong> objects in the <a id="_idIndexMarker233"/>same way we did for <strong class="source-inline">load_image</strong> and <strong class="source-inline">request_animation_frame</strong>. We have to make sure we call <strong class="source-inline">forget</strong> on both of the <strong class="source-inline">Closure</strong> instances so that they aren't deallocated immediately after being set up because nothing in the Rust application is holding onto them. You'll also need to add the <strong class="source-inline">KeyboardEvent</strong> feature to <strong class="source-inline">web-sys</strong> to include it. Otherwise, there is nothing here you haven't seen before. It just doesn't do anything yet.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Unlike most things in Rust, if you don't add a <strong class="source-inline">forget</strong> call, you won't get a compile-time error. You'll get a panic almost immediately and not always with a helpful error message. If you think you've set up callbacks into JavaScript and you're getting panics, ask yourself whether anything is holding on to that callback in your program. If nothing is, you've probably forgotten to add <strong class="source-inline">forget</strong>.</p>
			<p>We're listening to the input, so now we need to keep track of all of it. It's tempting to start trying to condense the events into <strong class="source-inline">keystate</strong> in this function, but that's troublesome because this function only handles one <strong class="source-inline">keyup</strong> or <strong class="source-inline">keydown</strong> at a time and doesn't know anything about all the other keys. If you wanted to keep track of an <strong class="source-inline">ArrowUp</strong> and <strong class="source-inline">ArrowRight</strong> being pressed at the same time, you couldn't do it here. What we will do is set up the listeners once before the game loop starts, such as with <strong class="source-inline">initialize</strong>, and then process all the new key events on every update updating our <strong class="source-inline">keystate</strong>. This will mean sharing state from these closures with the closure we passed to <strong class="source-inline">request_animation_frame</strong>. It's time to add a channel. We'll create an <strong class="source-inline">unbounded</strong> channel, which is a channel that will grow forever if you let it, here in <strong class="source-inline">prepare_input</strong> and then return its receiver. We'll pass transmitters to both <strong class="source-inline">onkeyup</strong> and <strong class="source-inline">onkeydown</strong>, and send the <strong class="source-inline">KeyboardEvent</strong> to each of those. Let's take a look at the changes:</p>
			<p class="source-code">fn prepare_input() -&gt; Result&lt;UnboundedReceiver&lt;KeyPress&gt;&gt; {</p>
			<p class="source-code">    let (keydown_sender, keyevent_receiver) = unbounded();</p>
			<p class="source-code">    let keydown_sender = Rc::new(RefCell::new(keydown_sender));</p>
			<p class="source-code">    let keyup_sender = Rc::clone(&amp;keydown_sender);</p>
			<p class="source-code">    let onkeydown = browser::closure_wrap(Box::new(move |keycode: web_sys::KeyboardEvent| {</p>
			<p class="source-code">        keydown_sender</p>
			<p class="source-code">            .borrow_mut()</p>
			<p class="source-code">            .start_send(KeyPress::KeyDown(keycode));</p>
			<p class="source-code">    }) as Box&lt;dyn FnMut(web_sys::KeyboardEvent)&gt;);</p>
			<p class="source-code">    let onkeyup = browser::closure_wrap(Box::new(move |keycode: web_sys::KeyboardEvent| {</p>
			<p class="source-code">        keyup_sender</p>
			<p class="source-code">            .borrow_mut()</p>
			<p class="source-code">            .start_send(KeyPress::KeyUp(keycode));</p>
			<p class="source-code">    }) as Box&lt;dyn FnMut(web_sys::KeyboardEvent)&gt;);</p>
			<p class="source-code">    browser::window()?.set_onkeydown(Some(onkeydown.as_ref().unchecked_ref()));</p>
			<p class="source-code">    browser::window()?.set_onkeyup(Some(onkeyup.as_ref().unchecked_ref()));</p>
			<p class="source-code">    onkeydown.forget();</p>
			<p class="source-code">    onkeyup.forget();</p>
			<p class="source-code">    Ok(keyevent_receiver)</p>
			<p class="source-code">}</p>
			<p>The function now returns <strong class="source-inline">Result&lt;UnboundedReceiver&lt;KeyPress&gt;&gt;</strong>. <strong class="source-inline">UnboundedReceiver</strong> and <strong class="source-inline">unbounded</strong> are both in the <strong class="source-inline">futures::channel::mspc</strong> module and are declared in a <strong class="source-inline">use</strong> declaration at the top of the file. We create the unbounded channel on the first line with the <strong class="source-inline">unbounded</strong> function and then create reference counted versions of both <strong class="source-inline">keydown_sender</strong> and <strong class="source-inline">keyup_sender</strong>, so that we can move each of them into their respective closures while sending both events to the same receiver. Note that the <strong class="source-inline">unbounded</strong> channel uses <strong class="source-inline">start_send</strong> instead of <strong class="source-inline">send</strong>. Finally, we return <strong class="source-inline">keyevent_receiver</strong> as <strong class="source-inline">Result</strong>. You might <a id="_idIndexMarker234"/>consider having two independent channels, one for <strong class="source-inline">keyup</strong> and one for <strong class="source-inline">keydown</strong>, and while I'm certain that can be done, I tried it and found this way was more straightforward.</p>
			<p>Look closely and you might wonder what <strong class="source-inline">KeyPress</strong> is. It turns out you can't tell what kind of <strong class="source-inline">KeyboardEvent</strong> happened simply by inspecting it. In order to keep track of whether the event was <strong class="source-inline">keyup</strong> or <strong class="source-inline">keydown</strong>, we wrap those events in an enumerated type that we'll define in <strong class="source-inline">engine.rs</strong>:</p>
			<p class="source-code">enum KeyPress {</p>
			<p class="source-code">    KeyUp(web_sys::KeyboardEvent),</p>
			<p class="source-code">    KeyDown(web_sys::KeyboardEvent),</p>
			<p class="source-code">}</p>
			<p>This <strong class="source-inline">enum</strong> approach means we won't have to manage two channels. Now that we have a function that will listen for and put all our key events into a channel, we need to write a second function that grabs all those events off the channel and reduces them into <strong class="source-inline">KeyState</strong>. We can do that like so, still in the <strong class="source-inline">engine</strong> module:</p>
			<p class="source-code">fn process_input(state: &amp;mut KeyState, keyevent_receiver: &amp;mut UnboundedReceiver&lt;KeyPress&gt;) {</p>
			<p class="source-code">    loop {</p>
			<p class="source-code">        match keyevent_receiver.try_next() {</p>
			<p class="source-code">            Ok(None) =&gt; break,</p>
			<p class="source-code">            Err(_err) =&gt; break,</p>
			<p class="source-code">            Ok(Some(evt)) =&gt; match evt {</p>
			<p class="source-code">                KeyPress::KeyUp(evt) =&gt; state.set_released(&amp;evt.code()),</p>
			<p class="source-code">                KeyPress::KeyDown(evt) =&gt; state.set_pressed(&amp;evt.code(), evt),</p>
			<p class="source-code">            },</p>
			<p class="source-code">        };</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This function takes <strong class="source-inline">KeyState</strong> and <strong class="source-inline">Receiver</strong> and updates <strong class="source-inline">state</strong> by taking every entry off of the receiver until its empty. Theoretically, this appears to create the possibility for an infinite loop <a id="_idIndexMarker235"/>in the event that the receiver is constantly filled, but I was unable to do that by normal means (pressing the keyboard like a madman), and if somebody decides to write a script that fills this channel and break their own game, more power to them. <strong class="source-inline">KeyState</strong> has to be passed as <strong class="source-inline">mut</strong> so that we update the current one and do not start from a brand-new state on each update. We've written this function pretending that <strong class="source-inline">KeyState</strong> already exists, but we need to create it as well, again in the <strong class="source-inline">engine</strong> module:</p>
			<p class="source-code">pub struct KeyState {</p>
			<p class="source-code">    pressed_keys: HashMap&lt;String, web_sys::KeyboardEvent&gt;,</p>
			<p class="source-code">}</p>
			<p class="source-code">impl KeyState {</p>
			<p class="source-code">    fn new() -&gt; Self {</p>
			<p class="source-code">        KeyState {</p>
			<p class="source-code">            pressed_keys: HashMap::new(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    pub fn is_pressed(&amp;self, code: &amp;str) -&gt; bool {</p>
			<p class="source-code">        self.pressed_keys.contains_key(code)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fn set_pressed(&amp;mut self, code: &amp;str, event: web_sys::KeyboardEvent) {</p>
			<p class="source-code">        self.pressed_keys.insert(code.into(), event);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fn set_released(&amp;mut self, code: &amp;str) {</p>
			<p class="source-code">        self.pressed_keys.remove(code.into());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">KeyState</strong> struct is just a wrapper around <strong class="source-inline">HashMap</strong>, storing a lookup of <strong class="source-inline">KeyboardEvent.code</strong> to its <strong class="source-inline">KeyboardEvent</strong>. If the <strong class="source-inline">code</strong> isn't present, then the key isn't pressed. The code is the <a id="_idIndexMarker236"/>actual representation of a physical key on the keyboard. You can find a list of all the available <strong class="source-inline">KeyboardEvent</strong> codes on MDN Web Docs: <a href="https://mzl.la/3ar9krK">https://mzl.la/3ar9krK</a>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When in doubt, MDN Web Docs from Mozilla is easily the best resource on the web for browser libraries.</p>
			<p>We've created the libraries and structures we need for keyboard input, so now we can integrate it into our <strong class="source-inline">GameLoop</strong>. We'll call <strong class="source-inline">prepare_input</strong> in the <strong class="source-inline">start</strong> function before we start looping:</p>
			<p class="source-code">pub async fn start(mut game: impl Game + 'static) -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">    <strong class="bold">let mut keyevent_receiver = prepare_input()?;</strong></p>
			<p class="source-code">    game.initialize().await?;</p>
			<p>Then, we'll move <strong class="source-inline">keyevent_receiver</strong> into the <strong class="source-inline">request_animation_frame</strong> closure and process the input on every update:</p>
			<p class="source-code"><strong class="bold">let mut keystate = KeyState::new();</strong></p>
			<p class="source-code">*g.borrow_mut() = Some(browser::create_raf_closure(move |perf: f64| {</p>
			<p class="source-code">    <strong class="bold">process_input(&amp;mut keystate, &amp;mut keyevent_receiver);</strong></p>
			<p>You can see that we initialized an empty <strong class="source-inline">KeyState</strong> right before the <strong class="source-inline">request_animation_frame</strong> closure,so that we can start with an empty one. Each frame will now call our <strong class="source-inline">process_input</strong> function and generate a new <strong class="source-inline">KeyState</strong>. That's all the changes we have to do to our game loop to keep track of <strong class="source-inline">KeyState</strong>. The only thing that's remaining is to pass it to our <strong class="source-inline">Game</strong> object so that it can be used. Some game implementations will<a id="_idIndexMarker237"/> store this as a global, but we'll just pass it to the <strong class="source-inline">Game</strong> trait. We'll update the trait's <strong class="source-inline">update</strong> function to accept <strong class="source-inline">KeyState</strong>:</p>
			<p class="source-code">pub trait Game {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self<strong class="bold">, keystate: &amp;KeyState</strong>);</p>
			<p class="source-code">    ...</p>
			<p>Now, we can pass <strong class="source-inline">KeyState</strong> to the <strong class="source-inline">update</strong> function on every loop:</p>
			<p class="source-code">while game_loop.accumulated_delta &gt; frame_size {</p>
			<p class="source-code">    game.update(<strong class="bold">&amp;keystate</strong>);</p>
			<p class="source-code">    game_loop.accumulated_delta -= frame_size;</p>
			<p class="source-code">}</p>
			<p>Finally, to keep our game compiling, we will need to update the <strong class="source-inline">WalkTheDog::update</strong> signature, over in the <strong class="source-inline">game</strong> module, to match:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p>That's it! We've got a <strong class="source-inline">GameLoop</strong> that processes keyboard input and passes that state to our <strong class="source-inline">Game</strong>. We've spent a lot of time writing code that makes it possible for us to write a game, but we<a id="_idIndexMarker238"/> haven't actually updated our game. Our poor little RHB still just runs in one plac<a id="_idTextAnchor089"/>e. He looks happy, but now that we've got input, how about we move him around?</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor090"/>Moving Red Hat Boy</h1>
			<p>Moving game objects means keeping track of a position instead of hardcoding it, as you might have expected. We'll create a <strong class="source-inline">Point</strong> structure in <strong class="source-inline">engine</strong> that will hold an <em class="italic">x</em> and a <em class="italic">y</em> position for RHB. On every <strong class="source-inline">update</strong> call, we'll also <a id="_idIndexMarker239"/>calculate a velocity for him, based on which keys are pressed. Every direction will be the same size, so if <strong class="source-inline">ArrowLeft</strong> and <strong class="source-inline">ArrowRight</strong> are pressed at the same time, he'll stop moving. After we calculate his velocity, we'll update his position with that number. That should be enough to allow us to move him around the screen. Let's start by adding <strong class="source-inline">position</strong> to the <strong class="source-inline">WalkTheDog</strong> game struct:</p>
			<p class="source-code">pub struct WalkTheDog {</p>
			<p class="source-code">    image: Option&lt;HtmlImageElement&gt;,</p>
			<p class="source-code">    sheet: Option&lt;Sheet&gt;,</p>
			<p class="source-code">    frame: u8,</p>
			<p class="source-code">    <strong class="bold">position: Point,</strong></p>
			<p class="source-code">}</p>
			<p>Of course, <strong class="source-inline">Point</strong> doesn't exist yet, so we'll create it in <strong class="source-inline">engine</strong>:</p>
			<p class="source-code">#[derive(Clone, Copy)]</p>
			<p class="source-code">pub struct Point {</p>
			<p class="source-code">    pub x: i16,</p>
			<p class="source-code">    pub y: i16,</p>
			<p class="source-code">}</p>
			<p>Note that we're using integers here so that we don't have to deal with floating point math when it's not necessary. While the <strong class="source-inline">canvas</strong> functions all take <strong class="source-inline">f64</strong> values, that's only because there is only one number type in <strong class="source-inline">JavaScript</strong>, and per MDN Web Docs (<a href="https://mzl.la/32PpIhL">https://mzl.la/32PpIhL</a>), <strong class="source-inline">canvas</strong> is faster <a id="_idIndexMarker240"/>if you use integer coordinates. You'll also need to update the <strong class="source-inline">WalkTheDog::new</strong> function to fill in a default <strong class="source-inline">position</strong>. Let's use <strong class="source-inline">0, 0</strong> for now:</p>
			<p class="source-code">impl WalkTheDog {</p>
			<p class="source-code">    pub fn new() -&gt; Self {</p>
			<p class="source-code">        WalkTheDog {</p>
			<p class="source-code">            image: None,</p>
			<p class="source-code">            sheet: None,</p>
			<p class="source-code">            frame: 0,</p>
			<p class="source-code">            position: Point { x: 0, y: 0 },</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>I promised I would stop reminding you to do this, but do make sure you've added a <strong class="source-inline">use</strong> declaration for <strong class="source-inline">crate::engine::Point</strong> at the top of the file. The <strong class="source-inline">initialize</strong> function also needs to be updated to account for <strong class="source-inline">position</strong>. This is actually why we marked <strong class="source-inline">Point</strong> with <strong class="source-inline">Clone</strong> and <strong class="source-inline">Copy</strong>. It makes it possible to copy it into the new <strong class="source-inline">WalkTheDog</strong> <strong class="source-inline">initialize</strong> function, as shown here:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        let json = browser::fetch_json("rhb.json").await?;</p>
			<p class="source-code">        let sheet = json.into_serde()?;</p>
			<p class="source-code">        let image =</p>
			<p class="source-code">          Some(engine::load_image("rhb.png").await?);</p>
			<p class="source-code">        Ok(Box::new(WalkTheDog {</p>
			<p class="source-code">            image,</p>
			<p class="source-code">            sheet,</p>
			<p class="source-code">            <strong class="bold">position: self.position,</strong></p>
			<p class="source-code">            frame: self.frame,</p>
			<p class="source-code">        }))</p>
			<p class="source-code">}</p>
			<p class="source-code">....</p>
			<p>In order for <strong class="source-inline">position</strong> to have any <a id="_idIndexMarker241"/>meaning, we'll need to update the <strong class="source-inline">draw</strong> function so that it's actually being used:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        ....</p>
			<p class="source-code">        self.image.as_ref().map(|image| {</p>
			<p class="source-code">            renderer.draw_image(</p>
			<p class="source-code">                &amp;image,</p>
			<p class="source-code">                &amp;Rect {</p>
			<p class="source-code">                    x: sprite.frame.x.into(),</p>
			<p class="source-code">                    y: sprite.frame.y.into(),</p>
			<p class="source-code">                    width: sprite.frame.w.into(),</p>
			<p class="source-code">                    height: sprite.frame.h.into(),</p>
			<p class="source-code">                },</p>
			<p class="source-code">                &amp;Rect {</p>
			<p class="source-code">                    <strong class="bold">x: self.position.into(),</strong></p>
			<p class="source-code">                    <strong class="bold">y: self.position.into(),</strong></p>
			<p class="source-code">                    width: sprite.frame.w.into(),</p>
			<p class="source-code">                    height: sprite.frame.h.into(),</p>
			<p class="source-code">                },</p>
			<p class="source-code">            );</p>
			<p class="source-code">        });</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Make sure you update the <em class="italic">second</em> <strong class="source-inline">Rect</strong> and not the first one. The first <strong class="source-inline">Rect</strong> is the slice we are taking out of our sprite sheet. The second one is where we want to draw it. This should cause a noticeable <a id="_idIndexMarker242"/>change to the game, as RHB is now in the upper-left corner. Finally, we're going to modify <strong class="source-inline">update</strong> to calculate a velocity based on which keys are pressed in <strong class="source-inline">KeyState</strong>. We'll add this before updating the current frame, as shown here:</p>
			<p class="source-code">fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">    let mut velocity = Point { x: 0, y: 0 };</p>
			<p class="source-code">    if keystate.is_pressed("ArrowDown") {</p>
			<p class="source-code">        velocity.y += 3;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if keystate.is_pressed("ArrowUp") {</p>
			<p class="source-code">        velocity.y -= 3;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if keystate.is_pressed("ArrowRight") {</p>
			<p class="source-code">        velocity.x += 3;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if keystate.is_pressed("ArrowLeft") {</p>
			<p class="source-code">        velocity.x -= 3;</p>
			<p class="source-code">    }</p>
			<p>The "<strong class="source-inline">ArrowDown</strong>" and "<strong class="source-inline">ArrowUp</strong>" strings and so on are all listed at <a href="https://mzl.la/3ar9krK">https://mzl.la/3ar9krK</a>, although you can also figure them out by simply logging the code when a key is pressed. You can see here that if "<strong class="source-inline">ArrowDown</strong>" is pressed we increase <strong class="source-inline">y</strong>, and if "<strong class="source-inline">ArrowUp</strong>" is pressed, we decrease it, and that's because the origin is in the upper-left-hand corner, with <strong class="source-inline">y</strong> increasing as you go down, not up. Note also that we don't use <strong class="source-inline">if/else</strong> here. We want to <a id="_idIndexMarker243"/>account for every pressed key and not short-circuit on the first key that's pressed. Next, we adjust the position based on velocity:</p>
			<p class="source-code">if keystate.is_pressed("ArrowLeft") {</p>
			<p class="source-code">    velocity.x -= 3;</p>
			<p class="source-code">}</p>
			<p class="source-code">self.position.x += velocity.x;</p>
			<p class="source-code">self.position.y += velocity.y;</p>
			<p>Head back to the browser, and you can now use the arrow keys to move RHB around! If he doesn't move, make sure you click in the canvas to give it focus. If he still doesn't move and you're sure you've gotten everything right, put some <strong class="source-inline">log!</strong> messages in the <strong class="source-inline">start</strong> function and make sure <strong class="source-inline">KeyState</strong> is being created, or in the <strong class="source-inline">update</strong> function to see if you're actually getting a new <strong class="source-inline">KeyState</strong>. We've covered a lot of ground here, and if you're following along, it's very easy to make a mistake, but you have a debugging tool to figure out issues now.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">On some browsers, the <strong class="source-inline">canvas</strong> will get a border around it when it has the focus, which will appear after <a id="_idTextAnchor091"/>you click it. You<a id="_idIndexMarker244"/> can remove that by adding a style of <strong class="source-inline">outline: none</strong> to the <strong class="source-inline">canvas</strong>.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor092"/>Summary</h1>
			<p>This was a hard, long, and complicated chapter. I'll quote a phrase Aaron Hillegass uses frequently in his books: <em class="italic">"Programming is hard and you are not stupid."</em> There were plenty of areas where a small typo could trip you up, and you may have had to go backward and forward several times. That's all okay – it's part of the learning process. I would encourage you to experiment with the skeleton we've built, even before moving onto the next chapter, as it's a great way to ensure you understand all the code.</p>
			<p>In the end, we've accomplished a lot. We've created a game loop that will run in the browser at 60 frames per second while updating at a fixed step. We've set up an XNA-like game "engine" and separated the engine concerns from the game concerns. Our browser interface is wrapped in a module so that we can hide some of the details of the browser implementation. We're even processing input, making this work like a true game engine. We did all this while keeping the code running as we went. </p>
			<p>The code should be easier to work with going forward because we now have clear places to put things. Browser functions go in a browser, engine functions in an engine, and the game in a game module, although you might feel like it's not a game because RHB doesn't run, jump, and slide around.</p>
			<p>Guess what we're doing next?</p>
		</div>
	</body></html>