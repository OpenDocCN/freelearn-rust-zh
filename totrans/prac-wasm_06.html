<html><head></head><body>
		<div><h1 id="_idParaDest-44"><em class="italic"><a id="_idTextAnchor052"/>Chapter 4</em>: Understanding WebAssembly Binary Toolkit </h1>
			<p>The Rust compiler chain converts Rust code into WebAssembly binary. But the generated binaries are both size- and performance-optimized. It is difficult to understand, debug, and validate binary code (it is a bunch of hexadecimal numbers). Converting WebAssembly binary back into the original source code is very difficult. <strong class="bold">WebAssembly Binary Toolkit</strong> (<strong class="bold">WABT</strong>) helps to convert WebAssembly binary into a human-readable format, such as the <strong class="bold">WebAssembly text</strong> (<strong class="bold">WAST</strong>) format or C-native code.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Native code here does not refer to the original source of truth; instead, it refers to C-native code that the machine interprets.</p>
			<p>WebAssembly Binary Toolkit is abbreviated as WABT and pronounced as "<em class="italic">wabbit</em>." WABT provides a set of tools for converting, analyzing, and testing WebAssembly binaries.</p>
			<p>In this chapter, we will explore WABT and how it helps to convert WebAssembly binary into various formats and why it is useful. We will cover the following main topics in this chapter:</p>
			<ul>
				<li>Getting started with WABT</li>
				<li>Converting WAST into WASM</li>
				<li>Converting WASM into WAST</li>
				<li>Converting WASM into C</li>
				<li>Converting WAST into JSON </li>
				<li>Understanding a few other tools provided by WABT</li>
			</ul>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor053"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor054"/>Getting started with WABT</h1>
			<p>Let's first install WABT and then explore the various options provided by the WABT tool. </p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor055"/>Installing WABT</h2>
			<p>In order to install WABT, first clone<a id="_idIndexMarker156"/> the repository from GitHub:</p>
			<pre>$ git clone --recursive https://github.com/WebAssembly/wabt</pre>
			<p class="callout-heading">Note </p>
			<p class="callout">We use the <code>--recursive</code> flag here as it ensures that after the clone is created, all submodules within the repository (such as <code>test-suite</code>) are initialized.</p>
			<p>Go into the cloned repository, create a folder named <code>build</code>, and then go inside the <code>build</code> folder. This is where we will generate the binaries:</p>
			<pre>$ cd wabt
$ mkdir build
$ cd build</pre>
			<p class="callout-heading">Note </p>
			<p class="callout">You will also need<a id="_idIndexMarker157"/> to install CMake. Refer to <a href="https://cmake.org/download/">https://cmake.org/download/</a> for more instructions.</p>
			<p>To build the binary with CMake, we first need<a id="_idIndexMarker158"/> to generate the build system. We specify the source to the <code>cmake</code> command. CMake will then build trees and generate a build system for the specified source, using the <code>CMakeLists.txt</code> file.</p>
			<h3>Linux or macOS</h3>
			<p>In order to generate<a id="_idIndexMarker159"/> the project build system, we run the <code>cmake</code> command<a id="_idIndexMarker160"/> with the path to the <code>wabt</code> folder. The <code>cmake</code> command accepts both a relative and absolute path. We are using the relative path here (<code>..</code>):</p>
			<pre>$ cmake ..</pre>
			<p>Now we can build the project using cmake build. <code>cmake build</code> makes use of the generated project binary tree to generate the binaries:</p>
			<pre>Usage: cmake --build &lt;dir&gt; [options] [-- [native-options]]
Options:
  &lt;dir&gt; = Project binary directory to be built.
  --parallel [&lt;jobs&gt;], -j [&lt;jobs&gt;]
        = Build in parallel using the given number of jobs.
                   If &lt;jobs&gt; is omitted the native build
                   tool's
                   default number is used.
                   The CMAKE_BUILD_PARALLEL_LEVEL
                   environment variable
                   specifies a default parallel level when
                   this option
                   is not given.
  --target &lt;tgt&gt;..., -t &lt;tgt&gt;...
                 = Build &lt;tgt&gt; instead of default targets.
  --config &lt;cfg&gt; = For multi-configuration tools, choose
    &lt;cfg&gt;.
  --clean-first  = Build target 'clean' first, then build.
                   (To clean only, use --target 'clean'.)
  --verbose, -v  = Enable verbose output - if supported –
    including the build commands to be executed.
  --             = Pass remaining options to the native
    tool.</pre>
			<p>The <code>cmake build</code> command<a id="_idIndexMarker161"/> requires the <code>&lt;dir&gt;</code> option to generate<a id="_idIndexMarker162"/> the binaries. The cmake build command accepts the flags listed in the preceding code block:</p>
			<pre>$ cmake --build .
....
[100%] Built target spectest-interp-copy-to-bin</pre>
			<h3>Windows</h3>
			<p>Install CMake and Visual Studio (&gt;= 2015). Then, run <code>cmake</code><a id="_idIndexMarker163"/> inside the <code>build</code> folder:</p>
			<pre>$ cmake [wabt project root] -DCMAKE_BUILD_TYPE=[config] –
  DCMAKE_INSTALL_PREFIX=[install directory] -G [generator]</pre>
			<p>The <code>[config]</code> parameter can be either <code>DEBUG</code> or <code>RELEASE</code>.</p>
			<p>The <code>[install directory]</code> parameter should be the folder where you want to install the binaries.</p>
			<p>The <code>[generator]</code> parameter should be the type of project you want to generate, for example, Visual Studio 14 2015. You can see the list of available generators by running <code>cmake –help</code>.</p>
			<p>This will build and install all the required<a id="_idIndexMarker164"/> executables inside the folder specified:</p>
			<pre>$ cd build
$ cmake --build .. --config RELEASE --target install</pre>
			<p>Once you have successfully installed all the WABT tools, you can either add them to your path or call them from their path.</p>
			<p>The <code>build</code> folder contains the following binaries:</p>
			<pre>$ tree -L 1
├── dummy
├── hexfloat_test
├── spectest-interp
├── wabt-unittests
├── wasm-c-api-global
├── wasm-c-api-hello
├── wasm-c-api-hostref
├── wasm-c-api-memory
├── wasm-c-api-multi
├── wasm-c-api-reflect
├── wasm-c-api-serialize
├── wasm-c-api-start
├── wasm-c-api-table
├── wasm-c-api-threads
├── wasm-c-api-trap
├── wasm-decompile
├── wasm-interp
├── wasm-objdump
├── wasm-opcodecnt
├── wasm-strip
├── wasm-validate
├── wasm2c
├── wasm2wat
├── wast2json
├── wat-desugar
└── wat2wasm</pre>
			<p>That sure is a huge<a id="_idIndexMarker165"/> list of binaries. Let's see what each one is capable of, in detail:</p>
			<ul>
				<li><code>wat2wasm</code> – This tool helps to convert the WAST format into a <strong class="bold">WebAssembly module</strong> (<strong class="bold">WASM</strong>).</li>
				<li><code>wat-desugar</code> – This tool reads a file in a WASM S-expression and formats it.</li>
				<li><code>wast2json</code> – This tool validates and converts WAST format into JSON format.</li>
				<li><code>wasm2wat</code> – This tool converts WASM into WAST format.</li>
				<li><code>wasm2c</code> – This tool converts WASM into C-native code.</li>
				<li><code>wasm-validate</code> – This tool validates whether the given WebAssembly is constructed as per the specification.</li>
				<li><code>wasm-strip</code> – As we saw in the previous chapter, WASM consists of various sections. The custom section in the module is used only for extra meta-information about the module and the tools used in its generation. <code>wasm-strip</code> removes the custom section from the WASM.</li>
				<li><code>wasm-opcodecnt</code> – This tool reads the WASM and counts the use of opcode instructions in the WebAssembly Module.</li>
				<li><code>wasm-objdump</code> – This tool helps to print information about<a id="_idIndexMarker166"/> a WASM binary. It is similar to objdump (<a href="https://en.wikipedia.org/wiki/Objdump">https://en.wikipedia.org/wiki/Objdump</a>) but for WebAssembly Modules.</li>
				<li><code>wasm-interp</code> – This tool decodes and runs a WebAssembly binary file using a stack-based interpreter.</li>
				<li><code>wasm-decompile</code> – This tool helps to decompile a WASM binary into readable C-like syntax.</li>
			</ul>
			<p>The following<a id="_idIndexMarker167"/> are the testing binaries:</p>
			<ul>
				<li><code>hexfloat_test</code></li>
				<li><code>spectest-interp</code></li>
				<li><code>wabt-unittests</code><p class="callout-heading">Note</p><p class="callout">Explore various supported proposals by WABT at <a href="https://github.com/WebAssembly/wabt#supported-proposals">https://github.com/WebAssembly/wabt#supported-proposals</a>.</p></li>
			</ul>
			<p>We have built WABT and generated the tools. Now, let's explore the most important and useful tools. </p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor056"/>Converting WAST into WASM</h1>
			<p><code>wat2wasm</code> helps to convert the WAST format<a id="_idIndexMarker168"/> into WASM. Let's take<a id="_idIndexMarker169"/> it for a spin:</p>
			<ol>
				<li>Create a new folder called <code>wabt-playground</code> and go into the folder:<pre><strong class="bold">$ mkdir wabt-playground</strong>
<strong class="bold">$ cd wabt-playground</strong></pre></li>
				<li>Create a <code>.wat</code> file called <code>add.wat</code>:<pre><strong class="bold">$ touch add.wat</strong></pre></li>
				<li>Add the<a id="_idIndexMarker170"/> following contents<a id="_idIndexMarker171"/> to <code>add.wat</code>:<pre><strong class="bold">(module</strong>
<strong class="bold">(func $add (param $lhs i32) (param $rhs i32) (result i32)</strong>
<strong class="bold"> get_local $lhs </strong>
<strong class="bold">  get_local $rhs</strong>
<strong class="bold">    i32.add</strong>
<strong class="bold">)</strong>
<strong class="bold">)</strong></pre></li>
				<li>Convert the WAST format into WASM using the <code>wat2wasm</code> binary:<pre><strong class="bold">$ /path/to/build/directory/of/wabt/wat2wasm add.wat</strong></pre></li>
			</ol>
			<p>This generates a valid WebAssembly binary in <code>add.wasm</code> file:</p>
			<pre><strong class="bold">00 61 73 6d 01 00 00 00 01 07 01 60 02 7f 7f 017f 03</strong>
<strong class="bold"> 02 01 00 0a 09 01 07 00 20 00 20 01 6a 0b</strong></pre>
			<p>Note that the size of the generated binary is 32 bytes.</p>
			<ol>
				<li value="5">WABT reads the WAST format file (<code>.wat</code>) and converts it into a WebAssembly module (<code>.wasm</code>). <code>wat2wasm</code> first validates the given file (<code>.wat</code>) and then converts it into a <code>.wasm</code> file. To check the various options supported by <code>wat2wasm</code>, we can run the following command:<pre><strong class="bold">$ /path/to/build/directory/of/wabt/wat2wasm --help</strong>
<strong class="bold">usage: wat2wasm [options] filename</strong>
<strong class="bold">  read a file in the wasm text format, check it for</strong>
<strong class="bold">  errors, and</strong>
<strong class="bold">  convert it to the wasm binary format.</strong>
<strong class="bold">examples:</strong>
<strong class="bold">  # parse and typecheck test.wat</strong>
<strong class="bold">  $ wat2wasm test.wat</strong>
<strong class="bold">  # parse test.wat and write to binary file test.wasm</strong>
<strong class="bold">  $ wat2wasm test.wat -o test.wasm</strong>
<strong class="bold">  # parse spec-test.wast, and write verbose output to</strong>
<strong class="bold">    stdout (including</strong>
<strong class="bold">  # the meaning of every byte)</strong>
<strong class="bold">  $ wat2wasm spec-test.wast -v</strong>
<strong class="bold">options:</strong>
<strong class="bold">      --help              Print this help message</strong>
<strong class="bold">      --version           Print version information</strong>
<strong class="bold">  -v, --verbose       Use multiple times for more info</strong>
<strong class="bold">      --debug-parser      Turn on debugging the parser</strong>
<strong class="bold">                          of wat files</strong>
<strong class="bold">  ...</strong>
<strong class="bold">      --debug-names       Write debug names to the</strong>
<strong class="bold">                          generated binary file</strong>
<strong class="bold">      --no-check          Don't check for invalid</strong>
<strong class="bold">                          modules</strong></pre></li>
			</ol>
			<p>If we need to generate the WASM file in a different name, we can use the <code>-o</code> option with the filename. For example, <code>wat2wasm add.wat -o add.wasm</code> will generate <code>add.wasm</code>.</p>
			<ol>
				<li value="6"><code>wat2wasm</code> also provides<a id="_idIndexMarker172"/> verbose output that clearly explains<a id="_idIndexMarker173"/> how the WASM is structured. In order to see the structure of the WASM, we run it with the <code>-v</code> option:<pre><strong class="bold"> $ /path/to/build/directory/of/wabt/wat2wasm add.wat -v</strong>
<strong class="bold">0000000: 0061 736d     ; WASM_BINARY_MAGIC</strong>
<strong class="bold">0000004: 0100 0000     ; WASM_BINARY_VERSION</strong>
<strong class="bold">; section "Type" (1)</strong>
<strong class="bold">0000008: 01            ; section code</strong>
<strong class="bold">0000009: 00            ; section size (guess)</strong>
<strong class="bold">000000a: 01            ; num types</strong>
<strong class="bold">; type 0</strong>
<strong class="bold">000000b: 60            ; func</strong>
<strong class="bold">000000c: 02            ; num params</strong>
<strong class="bold">000000d: 7f            ; i32</strong>
<strong class="bold">000000e: 7f            ; i32</strong>
<strong class="bold">000000f: 01            ; num results</strong>
<strong class="bold">0000010: 7f            ; i32</strong>
<strong class="bold">0000009: 07            ; FIXUP section size</strong>
<strong class="bold">; section "Function" (3)</strong>
<strong class="bold">0000011: 03            ; section code</strong>
<strong class="bold">0000012: 00            ; section size (guess)</strong>
<strong class="bold">0000013: 01            ; num functions</strong>
<strong class="bold">0000014: 00            ; function 0 signature index</strong>
<strong class="bold">0000012: 02            ; FIXUP section size</strong>
<strong class="bold">; section "Code" (10)</strong>
<strong class="bold">0000015: 0a            ; section code</strong>
<strong class="bold">0000016: 00            ; section size (guess)</strong>
<strong class="bold">0000017: 01            ; num functions</strong>
<strong class="bold">; function body 0</strong>
<strong class="bold">0000018: 00            ; func body size (guess)</strong>
<strong class="bold">0000019: 00            ; local decl count</strong>
<strong class="bold">000001a: 20            ; local.get</strong>
<strong class="bold">000001b: 00            ; local index</strong>
<strong class="bold">000001c: 20            ; local.get</strong>
<strong class="bold">000001d: 01            ; local index</strong>
<strong class="bold">000001e: 6a            ; i32.add</strong>
<strong class="bold">000001f: 0b            ; end</strong>
<strong class="bold">0000018: 07            ; FIXUP func body size</strong>
<strong class="bold">0000016: 09            ; FIXUP section size</strong></pre></li>
			</ol>
			<p>The preceding output is a detailed description of the binary generated. The leftmost seven numbers<a id="_idIndexMarker174"/> are the index, followed by a colon. The next two characters are the actual binary<a id="_idIndexMarker175"/> code, and then comments. The comment describes what the binary (op)code does.</p>
			<p>The first two lines specify <code>wasm_magic_header</code> and its version. The next segment is the <code>Type</code> section. The <code>Type</code> section defines the section ID, followed by the size of the section, and then the number of type blocks. In our case, we have only one type. The <code>type 0</code> section defines the <code>type</code> signature of the <code>add</code> function.</p>
			<p>Then, we have the <code>Function</code> section. In the <code>Function</code> section, we have the section ID, followed<a id="_idIndexMarker176"/> by the section size, and then the number of functions. The function<a id="_idIndexMarker177"/> section does not have the function body. The function body is defined in the <code>Code</code> section.</p>
			<p>While generating the binary, we can enable the compiler to include the new and shiny features and disable various existing features using the appropriate <code>enable-*</code> and <code>disable-*</code> options, respectively.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also check the online version at <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">https://webassembly.github.io/wabt/demo/wat2wasm/</a> to explore the WABT tools.</p>
			<p>We have converted WAST into WASM. Now, let's explore how to convert WASM into WAST with <code>wasm2wat</code>.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor057"/>Converting WASM into WAST</h1>
			<p>Sometimes, for debugging<a id="_idIndexMarker178"/> or understanding, we need <a id="_idIndexMarker179"/>to know what the WASM is doing. WABT has a <code>wasm2wat</code> converter. It helps to convert WASM into WAST format:</p>
			<pre>$ /path/to/build/directory/of/wabt/wasm2wat add.wasm
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (func (;0;) (type 0) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    i32.add))</pre>
			<p>Running the previous command will convert <code>add.wasm</code> back into WAST format and print the output in the console.</p>
			<p>If you want to save<a id="_idIndexMarker180"/> it as a file, you can do so<a id="_idIndexMarker181"/> by using the <code>-o</code> flag:</p>
			<pre>$ /path/to/build/directory/of/wabt/wasm2wat add.wasm -o new_
  add.wat</pre>
			<p>This command creates a <code>new_add.wat</code> file.</p>
			<p>To check the various options supported by <code>wasm2wat</code>, we can run the following command:</p>
			<pre>$ wasm2wat --help
usage: wasm2wat [options] filename
 
  Read a file in the WebAssembly binary format, and convert 
  it to
  the WebAssembly text format.
 
examples:
  # parse binary file test.wasm and write text file test.wast
  $ wasm2wat test.wasm -o test.wat
 
  # parse test.wasm, write test.wat, but ignore the debug names, if any
  $ wasm2wat test.wasm --no-debug-names -o test.wat
 
options:
      --help                                Print this help 
        message
      --version                             Print version 
        information
  -v, --verbose                             Use multiple times 
   for more info
  -o, --output=FILENAME                     Output file for the 
   generated wast file, by default use stdout
  -f, --fold-exprs                          Write folded 
   expressions where possible
  ....
      --no-debug-names                      Ignore debug names 
        in the binary file
      --ignore-custom-section-errors        Ignore errors in 
        custom sections
      --generate-names                      Give auto-generated
        names to non-named functions, types, etc.
      --no-check                            Don't check for 
        invalid modules</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Both <code>wasm2wat</code> and <code>wat2wasm</code> have almost identical options.</p>
			<p>Running the previous command<a id="_idIndexMarker182"/> with the <code>-v</code> option prints<a id="_idIndexMarker183"/> the AST syntax of the WAST format:</p>
			<pre>$ /path/to/build/directory/of/wabt/wasm2wat add.wasm -o new_
  add.wat -v
BeginModule(version: 1)
  BeginTypeSection(7)
    OnTypeCount(1)
    OnType(index: 0, params: [i32, i32], results: [i32])
  EndTypeSection
  BeginFunctionSection(2)
    OnFunctionCount(1)
    OnFunction(index: 0, sig_index: 0)
  EndFunctionSection
  BeginCodeSection(9)
    OnFunctionBodyCount(1)
    BeginFunctionBody(0, size:7)
    OnLocalDeclCount(0)
    OnLocalGetExpr(index: 0)
    OnLocalGetExpr(index: 1)
    OnBinaryExpr("i32.add" (106))
    EndFunctionBody(0)
  EndCodeSection
  BeginCustomSection('name', size: 28)
    BeginNamesSection(28)
      OnNameSubsection(index: 0, type: function, size:6)
      OnFunctionNameSubsection(index:0, nametype:1, size:6)
      OnFunctionNamesCount(1)
      OnFunctionName(index: 0, name: "add")
      OnNameSubsection(index: 1, type: local, size:13)
      OnLocalNameSubsection(index:1, nametype:2, size:13)
      OnLocalNameFunctionCount(1)
      OnLocalNameLocalCount(index: 0, count: 2)
      OnLocalName(func_index: 0, local_index: 0, name: "lhs")
      OnLocalName(func_index: 0, local_index: 1, name: "rhs")
    EndNamesSection
  EndCustomSection
EndModule</pre>
			<p>The entire code block is wrapped inside <code>BeginModule</code> and <code>EndModule</code>. <code>BeginModule</code> includes the version of the WebAssembly binary.</p>
			<p>Inside the BeginModule, the <code>BeginTypeSection</code> starts with the section<a id="_idIndexMarker184"/> index of type (that is, <code>7</code>), followed by <code>OnTypeCount</code>, the number<a id="_idIndexMarker185"/> of types defined. Then, we have the actual definition of the type with <code>OnType</code>. We end the type section with <code>EndTypeSection</code>.</p>
			<p>Then, we have the <code>Function</code> section marked by <code>BeginFunctionSection</code> and <code>EndFunctionSection</code>. This contains the function count (<code>OnFunctionCount</code>) and the function definition (<code>OnFunction</code>).</p>
			<p>Finally, we have the code section, which holds the actual body of the function. The code section begins and ends with <code>BeginCodeSection</code> and <code>EndCodeSection</code>.</p>
			<p>Sometimes, WASM may contain debug names. We can ignore them using the <code>--no-debug-names</code> flag:</p>
			<pre> $ /path/to/build/directory/of/wabt/wasm2wat add.wasm -o new_
  add.wat -v --no-debug-names
BeginModule(version: 1)
  BeginTypeSection(7)
    OnTypeCount(1)
    OnType(index: 0, params: [i32, i32], results: [i32])
  EndTypeSection
  BeginFunctionSection(2)
    OnFunctionCount(1)
    OnFunction(index: 0, sig_index: 0)
  EndFunctionSection
  BeginCodeSection(9)
    OnFunctionBodyCount(1)
    BeginFunctionBody(0, size:7)
    OnLocalDeclCount(0)
    OnLocalGetExpr(index: 0)
    OnLocalGetExpr(index: 1)
    OnBinaryExpr("i32.add" (106))
    EndFunctionBody(0)
  EndCodeSection
  BeginCustomSection('name', size: 28)
  EndCustomSection
EndModule</pre>
			<p>Note <code>BeginCustomSection</code> and <code>EndCustomSection</code>. Compare<a id="_idIndexMarker186"/> it with<a id="_idIndexMarker187"/> the previous output; it is missing <code>NamesSection</code>. Now, let's check out the various options provided by the <code>wasm2wat</code> tool.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor058"/>-f or --fold-exprs</h2>
			<p>As a big fan of functional<a id="_idIndexMarker188"/> programming, this is one of the coolest options available. It folds<a id="_idIndexMarker189"/> over the expression; that is, it converts expression 1 &gt;&gt; expression 2 &gt;&gt; operation into operation &gt;&gt; expression 1 &gt;&gt; expression2.</p>
			<p>Let's see that in action:</p>
			<ol>
				<li value="1">Create a WAST file called <code>fold.wat</code> and fill it with the following contents:<pre><strong class="bold">(module</strong>
<strong class="bold">    (func $fold (result i32)</strong>
<strong class="bold">        i32.const 22</strong>
<strong class="bold">        i32.const 20</strong>
<strong class="bold">        i32.add</strong>
<strong class="bold">    )</strong>
<strong class="bold">)</strong></pre></li>
				<li>Let's first convert it into WASM using <code>wat2wasm</code>:<pre><strong class="bold">$ /path/to/build/directory/of/wabt/wat2wasm -v</strong>
<strong class="bold">  fold.wat</strong>
<strong class="bold">; some contents</strong>
<strong class="bold">0000018: 41                                        ;</strong>
<strong class="bold">  i32.const</strong>
<strong class="bold">0000019: 16                                        ;</strong>
<strong class="bold">  i32 literal</strong>
<strong class="bold">000001a: 41                                        ;</strong>
<strong class="bold">  i32.const</strong>
<strong class="bold">000001b: 14                                        ;</strong>
<strong class="bold">  i32 literal</strong>
<strong class="bold">000001c: 6a                                        ;</strong>
<strong class="bold">  i32.add</strong>
<strong class="bold">; other contents</strong></pre></li>
			</ol>
			<p>This creates <code>fold.wasm</code>. </p>
			<ol>
				<li value="3">Now, convert the WASM<a id="_idIndexMarker190"/> into the WAST format using <code>wasm2wat</code> and pass<a id="_idIndexMarker191"/> in the <code>-f</code> option:<pre><strong class="bold">$ /path/to/build/directory/of/wabt/wasm2wat -v</strong>
<strong class="bold">  fold.wasm -o converted_fold.wat -f</strong></pre></li>
			</ol>
			<p>This will create a file called <code>converted_fold.wat</code>:</p>
			<pre><strong class="bold">(module</strong>
<strong class="bold">    (type (;0;) (func (result i32)))</strong>
<strong class="bold">    (func (;0;) (type 0) (result i32)</strong>
<strong class="bold">        (i32.add</strong>
<strong class="bold">            (i32.const 1)</strong>
<strong class="bold">            (i32.const 2))))</strong></pre>
			<p>Instead of using <code>i32.const 1</code> (expression 1) and <code>i32.const 2</code> (expression 2) and then doing <code>i32.add</code> (operation), this generates an output, <code>i32.add</code> (operation), followed by <code>i32.const 1</code> (expression 1) and <code>i32.const 2</code> (expression 2).</p>
			<p>While generating <code>wat</code>, we can enable the compiler to include the new and shiny features and disable various existing features using the appropriate <code>enable-*</code> and <code>disable-*</code> options, respectively.</p>
			<p>We have converted WASM into WAST. Now, let's explore how to convert WASM into native code (C) using <code>wasm2c</code>.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor059"/>Converting WASM into C</h1>
			<p>WABT has a <code>wasm2c</code> converter that converts<a id="_idIndexMarker192"/> WASM into C source c<a id="_idIndexMarker193"/>ode and a header.</p>
			<p>Let's create a <code>simple.wat</code> file:</p>
			<pre>$ touch simple.wat</pre>
			<p>Add the following contents to <code>simple.wat</code>:</p>
			<pre>(module
    (func $uanswer (result i32)
        i32.const 22
        i32.const 20
        i32.add
    )
)</pre>
			<p><code>wat</code> here defines a <code>uanswer</code> function that adds <code>22</code> and <code>20</code> to give <code>42</code> as the answer. Let's create a WebAssembly binary using <code>wat2wasm</code>:</p>
			<pre>$ /path/to/build/directory/of/wabt/wat2wasm simple.wat -o 
  simple.wasm</pre>
			<p>This generates the <code>simple.wasm</code> binary. Now, convert the binary into C code using <code>wasm2c</code>:</p>
			<pre>$ /path/to/build/directory/of/wabt/wasm2c simple.wasm -o 
  simple.c</pre>
			<p>This generates <code>simple.c</code> and <code>simple.h</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Both <code>simple.c</code> and <code>simple.h</code> might look huge. Remember this is an autogenerated file and it includes all the necessary headers and configuration needed for the program to run. </p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor060"/>simple.h</h2>
			<p><code>simple.h</code> (the header file) includes standard boilerplate<a id="_idIndexMarker194"/> for the header. It also includes the <code>_cplusplus</code> condition to prevent name mangling in C++:</p>
			<pre>#ifndef SIMPLE_H_GENERATED_
#define SIMPLE_H_GENERATED_
#ifdef __cplusplus
extern "C" {
#endif
 
...
 
#ifdef __cplusplus
}
#endif
#endif</pre>
			<p>Since we have used <code>i32.const</code> and <code>i32.add</code>, the header file also imports <code>stdint.h</code>. It includes <code>wasm-rt.h</code>. The <code>wasm-rt.h</code> header imports the necessary WASM runtime variables.</p>
			<p>Next, we can specify a module prefix. The module prefix is useful when using multiple modules. Since we only have one module, we use an empty prefix:</p>
			<pre> 
#ifndef WASM_RT_MODULE_PREFIX
#define WASM_RT_MODULE_PREFIX
#endif
 
#define WASM_RT_PASTE_(x, y) x ## y
#define WASM_RT_PASTE(x, y) WASM_RT_PASTE_(x, y)
#define WASM_RT_ADD_PREFIX(x) WASM_RT_PASTE(WASM_RT_MODULE_PREFIX, x)</pre>
			<p>Next, we have some typedefs<a id="_idIndexMarker195"/> for the various number formats that WASM supports:</p>
			<pre>typedef uint8_t u8;
typedef int8_t s8;
typedef uint16_t u16;
typedef int16_t s16;
typedef uint32_t u32;
typedef int32_t s32;
typedef uint64_t u64;
typedef int64_t s64;
typedef float f32;
typedef double f64;</pre>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor061"/>simple.c</h2>
			<p><code>simple.c</code> provides the actual C code<a id="_idIndexMarker196"/> generated from the WASM binary. The generated code has the following:</p>
			<ol>
				<li value="1">We'll require the following list of libraries to use in the code:<pre><strong class="bold">#include &lt;math.h&gt;</strong>
<strong class="bold">#include &lt;string.h&gt;</strong>
<strong class="bold"> </strong>
<strong class="bold">#include "simple.h"</strong></pre></li>
				<li>Next, we define the trap<a id="_idIndexMarker197"/> that is called when an error occurs:<pre><strong class="bold">#define TRAP(x) (wasm_rt_trap(WASM_RT_TRAP_##x), 0)</strong></pre></li>
				<li>Then, we define <code>PROLOGUE</code>, <code>EPILOGUE</code>, and <code>UNREACHABLE_TRAP</code>, which are called before the start of execution, after execution, and when the execution meets an unreachable exception, respectively:<pre><strong class="bold">#define FUNC_PROLOGUE                                            \</strong>
<strong class="bold">  if (++wasm_rt_call_stack_depth &gt;</strong>
<strong class="bold">    WASM_RT_MAX_CALL_STACK_DEPTH) \</strong>
<strong class="bold">    TRAP(EXHAUSTION)</strong>
<strong class="bold"> </strong>
<strong class="bold">#define FUNC_EPILOGUE --wasm_rt_call_stack_depth</strong>
<strong class="bold"> </strong>
<strong class="bold">#define UNREACHABLE TRAP(UNREACHABLE)</strong></pre></li>
			</ol>
			<p><code>WASM_RT_MAX_CALL_STACK_DEPTH</code> is the maximum depth of the stack. By default, the value is <code>500</code> but we can change it. Note that if it reaches the limit, then an exception is thrown.</p>
			<ol>
				<li value="4">Next, we define the memory manipulations:<pre><code>    addr) {   \</code>
<code>    addr, t2 value) { \</code>
<strong class="bold">    MEMCHECK(mem, addr, t1);       </strong>
<strong class="bold">\</strong>
<strong class="bold">    t1 wrapped = (t1)value;      </strong>
<strong class="bold">\</strong>
<strong class="bold">    __builtin_memcpy(&amp;mem-&gt;data[addr], &amp;wrapped,</strong>
<strong class="bold">      sizeof(t1));          \</strong>
<strong class="bold">  }</strong></pre></li>
			</ol>
			<p><code>MEMCHECK</code> checks<a id="_idIndexMarker198"/> for memory. The <code>DEFINE_LOAD</code> and <code>DEFINE_STORE</code> blocks define how to load and store a value in memory.</p>
			<ol>
				<li value="5">Next, we define a bunch of load <a id="_idIndexMarker199"/>and store operations for various data types that we have in this example:<pre><strong class="bold">DEFINE_LOAD(i32_load, u32, u32, u32);</strong>
<strong class="bold">DEFINE_LOAD(i64_load, u64, u64, u64);</strong>
<strong class="bold">...</strong>
<strong class="bold">DEFINE_LOAD(i64_load32_u, u32, u64, u64);</strong>
<strong class="bold">DEFINE_STORE(i32_store, u32, u32);</strong>
<strong class="bold">DEFINE_STORE(i64_store, u64, u64);</strong>
<strong class="bold">...</strong>
<strong class="bold">DEFINE_STORE(i64_store32, u32, u64);</strong></pre></li>
			</ol>
			<p>Then, we define various functions that each of the data types supports, such as <code>TRUNC</code>, <code>DIV</code>, and <code>REM</code>.</p>
			<ol>
				<li value="6">Next, we initialize the function types using <code>func_types</code>:<pre><strong class="bold">static u32 func_types[1];</strong>
<strong class="bold"> </strong>
<strong class="bold">static void init_func_types(void) {</strong>
<strong class="bold">  func_types[0] = wasm_rt_register_func_type(0, 1,</strong>
<strong class="bold">    WASM_RT_I32);</strong>
<strong class="bold">}</strong></pre></li>
			</ol>
			<p>This registers the (result i32) type in the WASM provided.</p>
			<ol>
				<li value="7">Next, we initialize <code>globals</code>, <code>memory</code>, <code>table</code>, and <code>exports</code>:<pre><strong class="bold">static void init_globals(void) {</strong>
<strong class="bold">}</strong>
<strong class="bold"> </strong>
<strong class="bold">static void init_memory(void) {</strong>
<strong class="bold">}</strong>
<strong class="bold"> </strong>
<strong class="bold">static void init_table(void) {</strong>
<strong class="bold">  uint32_t offset;</strong>
<strong class="bold">}</strong>
<strong class="bold"> </strong>
<strong class="bold">static void init_exports(void) {</strong>
<strong class="bold">}</strong></pre></li>
				<li>Now, we implement<a id="_idIndexMarker200"/> the actual function:<pre><strong class="bold">static u32 w2c_f0(void) {</strong>
<strong class="bold">  FUNC_PROLOGUE;</strong>
<strong class="bold">  u32 w2c_i0, w2c_i1;</strong>
<strong class="bold">  w2c_i0 = 22u;</strong>
<strong class="bold">  w2c_i1 = 20u;</strong>
<strong class="bold">  w2c_i0 += w2c_i1;</strong>
<strong class="bold">  FUNC_EPILOGUE;</strong>
<strong class="bold">  return w2c_i0;</strong>
<strong class="bold">}</strong></pre></li>
			</ol>
			<p>The function is static. It calls <code>FUNC_PROLOGUE</code> before the execution. Then, it creates two variables (both are unsigned u32). Then, we define the value of both the variables, <code>22</code> and <code>20</code>, respectively. After that, we add them both. Once the execution is complete, we call <code>FUNC_EPILOGUE</code>. Finally, we return the value.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since we have not exported anything in <code>wat</code>, <code>init_exports</code> is empty.</p>
			<p>We have converted WASM into C. The generated code is slightly different from the original code. Let's explore how to convert WAST into JSON with <code>wast2json</code>.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor062"/>Converting WAST into JSON </h1>
			<p>The <code>wast2json</code> tool reads the WAST format<a id="_idIndexMarker201"/> and parses it, checks for errors, and then converts WAST<a id="_idIndexMarker202"/> into the JSON file. It generates a JSON and WASM file associated with the WAST file. Then, it links the WASM inside the JSON:</p>
			<pre>$ /path/to/build/directory/of/wabt/wast2json add.wat -o add.
  json
$ cat add.json
{"source_filename": "add.wat",
"commands": [
{"type": "module", "line": 1, "filename": "add.0.wasm"}]}</pre>
			<p>To check the various options supported by <code>wast2json</code>, run the following command:</p>
			<pre>$ /path/to/build/directory/of/wabt/wast2json --help
usage: wast2json [options] filename
 
  read a file in the wasm spec test format, check it for 
  errors, and
  convert it to a JSON file and associated wasm binary files.
 
examples:
  # parse spec-test.wast, and write files to spec-test.json. 
  Modules are
  # written to spec-test.0.wasm, spec-test.1.wasm, etc.
  $ wast2json spec-test.wast -o spec-test.json
 
options:
      --help                                Print this help 
        message
      --version                             Print version 
        information
  -v, --verbose                             Use multiple times 
   for more info
      --debug-parser                        Turn on debugging 
        the parser of wast files
      --enable-exceptions                   Enable Experimental 
        exception handling
      --disable-mutable-globals             Disable Import/
        export mutable globals
      --disable-saturating-float-to-int     Disable Saturating
        float-to-int operators
      --disable-sign-extension              Disable Sign-
        extension operators
      --enable-simd                         Enable SIMD support
      --enable-threads                      Enable Threading 
        support
      --disable-multi-value                 Disable Multi-value
      --enable-tail-call                    Enable Tail-call 
        support
      --enable-bulk-memory                  Enable Bulk-memory 
        operations
      --enable-reference-types              Enable Reference 
        types (externref)
      --enable-annotations                  Enable Custom 
        annotation syntax
      --enable-gc                           Enable Garbage 
        collection
      --enable-memory64                     Enable 64-bit 
        memory
      --enable-all                          Enable all features
  -o, --output=FILE                         output JSON file
  -r, --relocatable                         Create a 
   relocatable wasm binary (suitable for linking with e.g. lld)
      --no-canonicalize-leb128s             Write all LEB128 
        sizes as 5-bytes instead of their minimal size
      --debug-names                         Write debug names 
        to the generated binary file
      --no-check                            Don't check for 
        invalid modules</pre>
			<p>These are the frequently<a id="_idIndexMarker203"/> used WABT tools. There are a few other tools<a id="_idIndexMarker204"/> provided by WABT that help with debugging and understanding WASM better.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor063"/>Understanding a few other tools provided by WABT</h1>
			<p>In addition to the converters, WABT also provides a few tools<a id="_idIndexMarker205"/> that help us to understand WASM better. In this section, let's explore the following tools provided by WABT:</p>
			<ul>
				<li><code>wasm-objdump</code></li>
				<li><code>wasm-strip</code></li>
				<li><code>wasm-validate</code></li>
				<li><code>wasm-interp</code> </li>
			</ul>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor064"/>wasm-objdump</h2>
			<p>Object code is nothing more than a sequence<a id="_idIndexMarker206"/> of instructions or statements in the computer language. Object code is what the compiler produces. The object code is then collected together and then stored inside the object file. The object file is the metadata holder for linking and debugging information. The machine code in the object file is not directly executable, but it provides valuable information when debugging and also helps with linking.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><code>objdump</code> is the tool that is available in POSIX systems that provides a way to disassemble the binary format and print the assembly format of the code that is running.</p>
			<p>The <code>wasm-objdump</code> tool provides the following options:</p>
			<pre>$ /path/to/build/directory/of/wabt/wasm-objdump --help
usage: wasm-objdump [options] filename+
 
  Print information about the contents of wasm binaries.
 
examples:
  $ wasm-objdump test.wasm
 
options:
      --help                   Print this help message
      --version                Print version information
  -h, --headers                Print headers
  -j, --section=SECTION        Select just one section
  -s, --full-contents          Print raw section contents
  -d, --disassemble            Disassemble function bodies
      --debug                  Print extra debug information
  -x, --details                Show section details
  -r, --reloc                  Show relocations inline with 
   disassembly</pre>
			<p>At least one of the following options <a id="_idIndexMarker207"/>should be provided to the <code>wasm-objdump</code> command:</p>
			<pre>-d/--disassemble
-h/--headers
-x/--details
-s/--full-contents</pre>
			<p>The <code>-h</code> option prints all the available headers in WASM. For example, in our add example (<code>add.wasm</code>), we have the following:</p>
			<pre>$ /path/to/build/directory/of/wabt/wasm-objdump add.wasm -h
add.wasm: file format wasm 0x1
 
Sections:
 
     Type start=0x0000000a end=0x00000011 (size=0x00000007)
  count: 1
Function start=0x00000013 end=0x00000015 (size=0x00000002) 
  count: 1
     Code start=0x00000017 end=0x00000020 (size=0x00000009) 
  count: 1</pre>
			<p>Here, we have three sections<a id="_idIndexMarker208"/> available:</p>
			<ul>
				<li><code>Type</code></li>
				<li><code>Function</code></li>
				<li><code>Code</code></li>
			</ul>
			<p>The <code>-d</code> option prints the actual body of the function available: </p>
			<pre> 
$/path/to/build/directory/of/wabt/wasm-objdump add.wasm -d
add.wasm: file format wasm 0x1
 
Code Disassembly:
 
000019 func[0]:
00001a: 20 00 | local.get 0
00001c: 20 01 | local.get 1
00001e: 6a | i32.add
00001f: 0b | end</pre>
			<p>It dissembles the assembly function and prints only the function body.</p>
			<p>The <code>-x</code> option prints the section details of the WebAssembly binary file:</p>
			<pre>$ /path/to/build/directory/of/wabt/wasm-objdump add.wasm -x
 
add.wasm: file format wasm 0x1
 
Section Details:
 
Type[1]:
- type[0] (i32, i32) -&gt; i32
Function[1]:
- func[0] sig=0
Code[1]:
- func[0] size=7</pre>
			<p>The <code>-s</code> option prints the contents<a id="_idIndexMarker209"/> of all the sections that are available:</p>
			<pre>$ /path/to/build/directory/of/wabt/wasm-objdump add.wasm -s
 
add.wasm: file format wasm 0x1
 
Contents of section Type:
000000a: 0160 027f 7f01 7f .`.....
 
Contents of section Function:
0000013: 0100 ..
 
Contents of section Code:
0000017: 0107 0020 0020 016a 0b ... . .j.</pre>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor065"/>wasm-strip</h2>
			<p>The custom section in a WASM holds information<a id="_idIndexMarker210"/> about the names of the function and all locals defined in the WASM. It may contain information about the build and how the WASM was created. This is additional information. It bloats the binary and does not add any functionality.</p>
			<p>We can strip the custom section to trim the binary size using the <code>wasm-strip</code> tool:</p>
			<ol>
				<li value="1">Create a <code>wat</code> file with the following<a id="_idIndexMarker211"/> contents:<pre><strong class="bold">$ touch simple.wat</strong>
<strong class="bold">(module</strong>
<strong class="bold">    (func $fold (result i32)</strong>
<strong class="bold">        i32.const 22</strong>
<strong class="bold">        i32.const 20</strong>
<strong class="bold">        i32.add</strong>
<strong class="bold">    )</strong>
<strong class="bold">)</strong></pre></li>
				<li>Now, convert that into a WASM with <code>wat2wasm</code>:<pre><strong class="bold">$ /path/to/build/directory/of/wabt/wat2wasm simple.wat</strong>
<strong class="bold">  --debug-names</strong>
<strong class="bold">$ l simple.wasm</strong>
<strong class="bold">51B simple.wasm</strong></pre></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>--debug-names</code> option provided generates the custom section and adds it to the binary generated.</p>
			<p>The previous command generates a <code>simple.wasm</code> file and it is 51 bytes in size. </p>
			<ol>
				<li value="3">Now, let's remove the custom section from the binary using the following:<pre><strong class="bold">$ /path/to/build/directory/of/wabt/wasm-strip add.wasm</strong>
<strong class="bold">$ l simple.wasm</strong>
<strong class="bold">30B simple.wasm</strong></pre></li>
			</ol>
			<p>As you can see, it removed 21 bytes of unnecessary information. Some WASM generators add the custom section<a id="_idIndexMarker212"/> for a better debugging experience but when deploying in production, we do not need the custom section. Use <code>wasm-strip</code> to remove it.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor066"/>wasm-validate</h2>
			<p>We can validate the WASM<a id="_idIndexMarker213"/> using <code>wasm-validate</code>:</p>
			<ol>
				<li value="1">Create <code>error.wasm</code> with the following contents:<pre><strong class="bold">00 61 73 6d 03 00 00 00</strong>
<strong class="bold">            |</strong>
<strong class="bold">        Error value</strong></pre></li>
				<li>Now, run <code>wasm-validate</code> to check whether the WASM is valid or not:<pre><strong class="bold">$ /path/to/build/directory/of/wabt/wasm-validate</strong>
<strong class="bold">  error.wasm</strong>
<strong class="bold">0000004: error: bad magic value</strong></pre></li>
				<li>The <code>wasm-validate</code> tool provides the following options:<pre><strong class="bold">usage: wasm-validate [options] filename</strong></pre></li>
				<li> Read a file in the WebAssembly binary format and validate it:<pre><strong class="bold">examples:</strong>
<strong class="bold">  # validate binary file test.wasm</strong>
<strong class="bold">  $ wasm-validate test.wasm</strong>
<strong class="bold"> </strong>
<strong class="bold">options:</strong>
<strong class="bold">      --help                Print this help message</strong>
<strong class="bold">      --version             Print version information</strong>
<strong class="bold">  -v, --verbose             Use multiple times for </strong>
<strong class="bold">   more info</strong>
<strong class="bold">      --enable-exceptions   Enable Experimental</strong>
<strong class="bold">        exception handling</strong>
<strong class="bold">      --disable-mutable-globals     Disable</strong>
<strong class="bold">        Import/export mutable globals</strong>
<strong class="bold">      --disable-saturating-float-to-int        Disable</strong>
<strong class="bold">        Saturating float-to-int operators</strong>
<strong class="bold">      --disable-sign-extension                 Disable</strong>
<strong class="bold">        Sign-extension operators</strong>
<strong class="bold">      --enable-simd                            Enable</strong>
<strong class="bold">        SIMD support</strong>
<strong class="bold">      --enable-threads                         Enable</strong>
<strong class="bold">        Threading support</strong>
<strong class="bold">      --disable-multi-value                    Disable</strong>
<strong class="bold">        Multi-value</strong>
<strong class="bold">      --enable-tail-call                       Enable</strong>
<strong class="bold">        Tail-call support</strong>
<strong class="bold">      --enable-bulk-memory                     Enable</strong>
<strong class="bold">        Bulk-memory operations</strong>
<strong class="bold">      --enable-reference-types                 Enable</strong>
<strong class="bold">        Reference types (externref)</strong>
<strong class="bold">      --enable-annotations                     Enable</strong>
<strong class="bold">        Custom annotation syntax</strong>
<strong class="bold">      --enable-gc                              Enable</strong>
<strong class="bold">        Garbage collection</strong>
<strong class="bold">      --enable-memory64                        Enable</strong>
<strong class="bold">        64-bit memory</strong>
<strong class="bold">      --enable-all                             Enable</strong>
<strong class="bold">        all features</strong>
<strong class="bold">      --no-debug-names                         Ignore</strong>
<strong class="bold">        debug names in the binary file</strong>
<strong class="bold">      --ignore-custom-section-errors           Ignore</strong>
<strong class="bold">        errors in custom sections</strong></pre></li>
			</ol>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor067"/>wasm-interp</h2>
			<p><code>wasm-interp</code> reads a file in the WebAssembly binary format<a id="_idIndexMarker214"/> and runs it in a stack-based interpreter. The <code>wasm-interp</code> tool parses the binary file and then type checks it:</p>
			<pre>$ /path/to/build/directory/of/wabt/wasm-interp add.wasm -v
BeginModule(version: 1)
  BeginTypeSection(7)
    OnTypeCount(1)
    OnType(index: 0, params: [i32, i32], results: [i32])
  EndTypeSection
  BeginFunctionSection(2)
    OnFunctionCount(1)
    OnFunction(index: 0, sig_index: 0)
  EndFunctionSection
  BeginCodeSection(9)
    OnFunctionBodyCount(1)
    BeginFunctionBody(0, size:7)
    OnLocalDeclCount(0)
    OnLocalGetExpr(index: 0)
    OnLocalGetExpr(index: 1)
    OnBinaryExpr("i32.add" (106))
    EndFunctionBody(0)
  EndCodeSection
EndModule
   0| local.get $2
   8| local.get $2
  16| i32.add %[-2], %[-1]
  20| drop_keep $2 $1
  32| return</pre>
			<p>The last five lines are how the stack<a id="_idIndexMarker215"/> interpreter executes the code.</p>
			<p>The <code>wasm-interp</code> tool provides the following options:</p>
			<pre> 
usage: wasm-interp [options] filename [arg]...
 
  read a file in the wasm binary format and run it in a stack-
  based
  interpreter.
 
examples:
  ...
 
options:
      --help                                Print this help 
        message
      --version                             Print version 
        information
  ...</pre>
			<p>WABT provides a list of tools that make WASM<a id="_idIndexMarker216"/> easier to understand, debug, and convert into various human-readable formats. It is one of the most important toolkits that allows developers to explore the WASM better.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor068"/>Summary</h1>
			<p>In this chapter, we saw what WABT is and how to install and use various tools provided by it. The WABT tool is very important in the WebAssembly ecosystem as it provides an easy option to convert non-readable, compact binaries into readable, expanded source code. </p>
			<p>In the next chapter, we will explore various sections inside the WASM.</p>
		</div>
	</body></html>