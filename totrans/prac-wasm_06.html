<html><head></head><body>
		<div id="_idContainer015">
			<h1 id="_idParaDest-44"><em class="italic"><a id="_idTextAnchor052"/>Chapter 4</em>: Understanding WebAssembly Binary Toolkit </h1>
			<p>The Rust compiler chain converts Rust code into WebAssembly binary. But the generated binaries are both size- and performance-optimized. It is difficult to understand, debug, and validate binary code (it is a bunch of hexadecimal numbers). Converting WebAssembly binary back into the original source code is very difficult. <strong class="bold">WebAssembly Binary Toolkit</strong> (<strong class="bold">WABT</strong>) helps to convert WebAssembly binary into a human-readable format, such as the <strong class="bold">WebAssembly text</strong> (<strong class="bold">WAST</strong>) format or C-native code.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Native code here does not refer to the original source of truth; instead, it refers to C-native code that the machine interprets.</p>
			<p>WebAssembly Binary Toolkit is abbreviated as WABT and pronounced as "<em class="italic">wabbit</em>." WABT provides a set of tools for converting, analyzing, and testing WebAssembly binaries.</p>
			<p>In this chapter, we will explore WABT and how it helps to convert WebAssembly binary into various formats and why it is useful. We will cover the following main topics in this chapter:</p>
			<ul>
				<li>Getting started with WABT</li>
				<li>Converting WAST into WASM</li>
				<li>Converting WASM into WAST</li>
				<li>Converting WASM into C</li>
				<li>Converting WAST into JSON </li>
				<li>Understanding a few other tools provided by WABT</li>
			</ul>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor053"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor054"/>Getting started with WABT</h1>
			<p>Let's first install WABT and then explore the various options provided by the WABT tool. </p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor055"/>Installing WABT</h2>
			<p>In order to install WABT, first clone<a id="_idIndexMarker156"/> the repository from GitHub:</p>
			<p class="source-code">$ git clone --recursive https://github.com/WebAssembly/wabt</p>
			<p class="callout-heading">Note </p>
			<p class="callout">We use the <strong class="source-inline">--recursive</strong> flag here as it ensures that after the clone is created, all submodules within the repository (such as <strong class="source-inline">test-suite</strong>) are initialized.</p>
			<p>Go into the cloned repository, create a folder named <strong class="source-inline">build</strong>, and then go inside the <strong class="source-inline">build</strong> folder. This is where we will generate the binaries:</p>
			<p class="source-code">$ cd wabt</p>
			<p class="source-code">$ mkdir build</p>
			<p class="source-code">$ cd build</p>
			<p class="callout-heading">Note </p>
			<p class="callout">You will also need<a id="_idIndexMarker157"/> to install CMake. Refer to <a href="https://cmake.org/download/">https://cmake.org/download/</a> for more instructions.</p>
			<p>To build the binary with CMake, we first need<a id="_idIndexMarker158"/> to generate the build system. We specify the source to the <strong class="source-inline">cmake</strong> command. CMake will then build trees and generate a build system for the specified source, using the <strong class="source-inline">CMakeLists.txt</strong> file.</p>
			<h3>Linux or macOS</h3>
			<p>In order to generate<a id="_idIndexMarker159"/> the project build system, we run the <strong class="source-inline">cmake</strong> command<a id="_idIndexMarker160"/> with the path to the <strong class="source-inline">wabt</strong> folder. The <strong class="source-inline">cmake</strong> command accepts both a relative and absolute path. We are using the relative path here (<strong class="source-inline">..</strong>):</p>
			<p class="source-code">$ cmake ..</p>
			<p>Now we can build the project using cmake build. <strong class="source-inline">cmake build</strong> makes use of the generated project binary tree to generate the binaries:</p>
			<p class="source-code">Usage: cmake --build &lt;dir&gt; [options] [-- [native-options]]</p>
			<p class="source-code">Options:</p>
			<p class="source-code">  &lt;dir&gt; = Project binary directory to be built.</p>
			<p class="source-code">  --parallel [&lt;jobs&gt;], -j [&lt;jobs&gt;]</p>
			<p class="source-code">        = Build in parallel using the given number of jobs.</p>
			<p class="source-code">                   If &lt;jobs&gt; is omitted the native build</p>
			<p class="source-code">                   tool's</p>
			<p class="source-code">                   default number is used.</p>
			<p class="source-code">                   The CMAKE_BUILD_PARALLEL_LEVEL</p>
			<p class="source-code">                   environment variable</p>
			<p class="source-code">                   specifies a default parallel level when</p>
			<p class="source-code">                   this option</p>
			<p class="source-code">                   is not given.</p>
			<p class="source-code">  --target &lt;tgt&gt;..., -t &lt;tgt&gt;...</p>
			<p class="source-code">                 = Build &lt;tgt&gt; instead of default targets.</p>
			<p class="source-code">  --config &lt;cfg&gt; = For multi-configuration tools, choose</p>
			<p class="source-code">    &lt;cfg&gt;.</p>
			<p class="source-code">  --clean-first  = Build target 'clean' first, then build.</p>
			<p class="source-code">                   (To clean only, use --target 'clean'.)</p>
			<p class="source-code">  --verbose, -v  = Enable verbose output - if supported –</p>
			<p class="source-code">    including the build commands to be executed.</p>
			<p class="source-code">  --             = Pass remaining options to the native</p>
			<p class="source-code">    tool.</p>
			<p>The <strong class="source-inline">cmake build</strong> command<a id="_idIndexMarker161"/> requires the <strong class="source-inline">&lt;dir&gt;</strong> option to generate<a id="_idIndexMarker162"/> the binaries. The cmake build command accepts the flags listed in the preceding code block:</p>
			<p class="source-code">$ cmake --build .</p>
			<p class="source-code">....</p>
			<p class="source-code">[100%] Built target spectest-interp-copy-to-bin</p>
			<h3>Windows</h3>
			<p>Install CMake and Visual Studio (&gt;= 2015). Then, run <strong class="source-inline">cmake</strong><a id="_idIndexMarker163"/> inside the <strong class="source-inline">build</strong> folder:</p>
			<p class="source-code">$ cmake [wabt project root] -DCMAKE_BUILD_TYPE=[config] –</p>
			<p class="source-code">  DCMAKE_INSTALL_PREFIX=[install directory] -G [generator]</p>
			<p>The <strong class="source-inline">[config]</strong> parameter can be either <strong class="source-inline">DEBUG</strong> or <strong class="source-inline">RELEASE</strong>.</p>
			<p>The <strong class="source-inline">[install directory]</strong> parameter should be the folder where you want to install the binaries.</p>
			<p>The <strong class="source-inline">[generator]</strong> parameter should be the type of project you want to generate, for example, Visual Studio 14 2015. You can see the list of available generators by running <strong class="source-inline">cmake –help</strong>.</p>
			<p>This will build and install all the required<a id="_idIndexMarker164"/> executables inside the folder specified:</p>
			<p class="source-code">$ cd build</p>
			<p class="source-code">$ cmake --build .. --config RELEASE --target install</p>
			<p>Once you have successfully installed all the WABT tools, you can either add them to your path or call them from their path.</p>
			<p>The <strong class="source-inline">build</strong> folder contains the following binaries:</p>
			<p class="source-code">$ tree -L 1</p>
			<p class="source-code">├── dummy</p>
			<p class="source-code">├── hexfloat_test</p>
			<p class="source-code">├── spectest-interp</p>
			<p class="source-code">├── wabt-unittests</p>
			<p class="source-code">├── wasm-c-api-global</p>
			<p class="source-code">├── wasm-c-api-hello</p>
			<p class="source-code">├── wasm-c-api-hostref</p>
			<p class="source-code">├── wasm-c-api-memory</p>
			<p class="source-code">├── wasm-c-api-multi</p>
			<p class="source-code">├── wasm-c-api-reflect</p>
			<p class="source-code">├── wasm-c-api-serialize</p>
			<p class="source-code">├── wasm-c-api-start</p>
			<p class="source-code">├── wasm-c-api-table</p>
			<p class="source-code">├── wasm-c-api-threads</p>
			<p class="source-code">├── wasm-c-api-trap</p>
			<p class="source-code">├── wasm-decompile</p>
			<p class="source-code">├── wasm-interp</p>
			<p class="source-code">├── wasm-objdump</p>
			<p class="source-code">├── wasm-opcodecnt</p>
			<p class="source-code">├── wasm-strip</p>
			<p class="source-code">├── wasm-validate</p>
			<p class="source-code">├── wasm2c</p>
			<p class="source-code">├── wasm2wat</p>
			<p class="source-code">├── wast2json</p>
			<p class="source-code">├── wat-desugar</p>
			<p class="source-code">└── wat2wasm</p>
			<p>That sure is a huge<a id="_idIndexMarker165"/> list of binaries. Let's see what each one is capable of, in detail:</p>
			<ul>
				<li><strong class="source-inline">wat2wasm</strong> – This tool helps to convert the WAST format into a <strong class="bold">WebAssembly module</strong> (<strong class="bold">WASM</strong>).</li>
				<li><strong class="source-inline">wat-desugar</strong> – This tool reads a file in a WASM S-expression and formats it.</li>
				<li><strong class="source-inline">wast2json</strong> – This tool validates and converts WAST format into JSON format.</li>
				<li><strong class="source-inline">wasm2wat</strong> – This tool converts WASM into WAST format.</li>
				<li><strong class="source-inline">wasm2c</strong> – This tool converts WASM into C-native code.</li>
				<li><strong class="source-inline">wasm-validate</strong> – This tool validates whether the given WebAssembly is constructed as per the specification.</li>
				<li><strong class="source-inline">wasm-strip</strong> – As we saw in the previous chapter, WASM consists of various sections. The custom section in the module is used only for extra meta-information about the module and the tools used in its generation. <strong class="source-inline">wasm-strip</strong> removes the custom section from the WASM.</li>
				<li><strong class="source-inline">wasm-opcodecnt</strong> – This tool reads the WASM and counts the use of opcode instructions in the WebAssembly Module.</li>
				<li><strong class="source-inline">wasm-objdump</strong> – This tool helps to print information about<a id="_idIndexMarker166"/> a WASM binary. It is similar to objdump (<a href="https://en.wikipedia.org/wiki/Objdump">https://en.wikipedia.org/wiki/Objdump</a>) but for WebAssembly Modules.</li>
				<li><strong class="source-inline">wasm-interp</strong> – This tool decodes and runs a WebAssembly binary file using a stack-based interpreter.</li>
				<li><strong class="source-inline">wasm-decompile</strong> – This tool helps to decompile a WASM binary into readable C-like syntax.</li>
			</ul>
			<p>The following<a id="_idIndexMarker167"/> are the testing binaries:</p>
			<ul>
				<li><strong class="source-inline">hexfloat_test</strong></li>
				<li><strong class="source-inline">spectest-interp</strong></li>
				<li><strong class="source-inline">wabt-unittests</strong><p class="callout-heading">Note</p><p class="callout">Explore various supported proposals by WABT at <a href="https://github.com/WebAssembly/wabt#supported-proposals">https://github.com/WebAssembly/wabt#supported-proposals</a>.</p></li>
			</ul>
			<p>We have built WABT and generated the tools. Now, let's explore the most important and useful tools. </p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor056"/>Converting WAST into WASM</h1>
			<p><strong class="source-inline">wat2wasm</strong> helps to convert the WAST format<a id="_idIndexMarker168"/> into WASM. Let's take<a id="_idIndexMarker169"/> it for a spin:</p>
			<ol>
				<li>Create a new folder called <strong class="source-inline">wabt-playground</strong> and go into the folder:<p class="source-code"><strong class="bold">$ mkdir wabt-playground</strong></p><p class="source-code"><strong class="bold">$ cd wabt-playground</strong></p></li>
				<li>Create a <strong class="source-inline">.wat</strong> file called <strong class="source-inline">add.wat</strong>:<p class="source-code"><strong class="bold">$ touch add.wat</strong></p></li>
				<li>Add the<a id="_idIndexMarker170"/> following contents<a id="_idIndexMarker171"/> to <strong class="source-inline">add.wat</strong>:<p class="source-code"><strong class="bold">(module</strong></p><p class="source-code"><strong class="bold">(func $add (param $lhs i32) (param $rhs i32) (result i32)</strong></p><p class="source-code"><strong class="bold"> get_local $lhs </strong></p><p class="source-code"><strong class="bold">  get_local $rhs</strong></p><p class="source-code"><strong class="bold">    i32.add</strong></p><p class="source-code"><strong class="bold">)</strong></p><p class="source-code"><strong class="bold">)</strong></p></li>
				<li>Convert the WAST format into WASM using the <strong class="source-inline">wat2wasm</strong> binary:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/wabt/wat2wasm add.wat</strong></p></li>
			</ol>
			<p>This generates a valid WebAssembly binary in <strong class="source-inline">add.wasm</strong> file:</p>
			<p class="source-code"><strong class="bold">00 61 73 6d 01 00 00 00 01 07 01 60 02 7f 7f 017f 03</strong></p>
			<p class="source-code"><strong class="bold"> 02 01 00 0a 09 01 07 00 20 00 20 01 6a 0b</strong></p>
			<p>Note that the size of the generated binary is 32 bytes.</p>
			<ol>
				<li value="5">WABT reads the WAST format file (<strong class="source-inline">.wat</strong>) and converts it into a WebAssembly module (<strong class="source-inline">.wasm</strong>). <strong class="source-inline">wat2wasm</strong> first validates the given file (<strong class="source-inline">.wat</strong>) and then converts it into a <strong class="source-inline">.wasm</strong> file. To check the various options supported by <strong class="source-inline">wat2wasm</strong>, we can run the following command:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/wabt/wat2wasm --help</strong></p><p class="source-code"><strong class="bold">usage: wat2wasm [options] filename</strong></p><p class="source-code"><strong class="bold">  read a file in the wasm text format, check it for</strong></p><p class="source-code"><strong class="bold">  errors, and</strong></p><p class="source-code"><strong class="bold">  convert it to the wasm binary format.</strong></p><p class="source-code"><strong class="bold">examples:</strong></p><p class="source-code"><strong class="bold">  # parse and typecheck test.wat</strong></p><p class="source-code"><strong class="bold">  $ wat2wasm test.wat</strong></p><p class="source-code"><strong class="bold">  # parse test.wat and write to binary file test.wasm</strong></p><p class="source-code"><strong class="bold">  $ wat2wasm test.wat -o test.wasm</strong></p><p class="source-code"><strong class="bold">  # parse spec-test.wast, and write verbose output to</strong></p><p class="source-code"><strong class="bold">    stdout (including</strong></p><p class="source-code"><strong class="bold">  # the meaning of every byte)</strong></p><p class="source-code"><strong class="bold">  $ wat2wasm spec-test.wast -v</strong></p><p class="source-code"><strong class="bold">options:</strong></p><p class="source-code"><strong class="bold">      --help              Print this help message</strong></p><p class="source-code"><strong class="bold">      --version           Print version information</strong></p><p class="source-code"><strong class="bold">  -v, --verbose       Use multiple times for more info</strong></p><p class="source-code"><strong class="bold">      --debug-parser      Turn on debugging the parser</strong></p><p class="source-code"><strong class="bold">                          of wat files</strong></p><p class="source-code"><strong class="bold">  ...</strong></p><p class="source-code"><strong class="bold">      --debug-names       Write debug names to the</strong></p><p class="source-code"><strong class="bold">                          generated binary file</strong></p><p class="source-code"><strong class="bold">      --no-check          Don't check for invalid</strong></p><p class="source-code"><strong class="bold">                          modules</strong></p></li>
			</ol>
			<p>If we need to generate the WASM file in a different name, we can use the <strong class="source-inline">-o</strong> option with the filename. For example, <strong class="source-inline">wat2wasm add.wat -o add.wasm</strong> will generate <strong class="source-inline">add.wasm</strong>.</p>
			<ol>
				<li value="6"><strong class="source-inline">wat2wasm</strong> also provides<a id="_idIndexMarker172"/> verbose output that clearly explains<a id="_idIndexMarker173"/> how the WASM is structured. In order to see the structure of the WASM, we run it with the <strong class="source-inline">-v</strong> option:<p class="source-code"><strong class="bold"> $ /path/to/build/directory/of/wabt/wat2wasm add.wat -v</strong></p><p class="source-code"><strong class="bold">0000000: 0061 736d     ; WASM_BINARY_MAGIC</strong></p><p class="source-code"><strong class="bold">0000004: 0100 0000     ; WASM_BINARY_VERSION</strong></p><p class="source-code"><strong class="bold">; section "Type" (1)</strong></p><p class="source-code"><strong class="bold">0000008: 01            ; section code</strong></p><p class="source-code"><strong class="bold">0000009: 00            ; section size (guess)</strong></p><p class="source-code"><strong class="bold">000000a: 01            ; num types</strong></p><p class="source-code"><strong class="bold">; type 0</strong></p><p class="source-code"><strong class="bold">000000b: 60            ; func</strong></p><p class="source-code"><strong class="bold">000000c: 02            ; num params</strong></p><p class="source-code"><strong class="bold">000000d: 7f            ; i32</strong></p><p class="source-code"><strong class="bold">000000e: 7f            ; i32</strong></p><p class="source-code"><strong class="bold">000000f: 01            ; num results</strong></p><p class="source-code"><strong class="bold">0000010: 7f            ; i32</strong></p><p class="source-code"><strong class="bold">0000009: 07            ; FIXUP section size</strong></p><p class="source-code"><strong class="bold">; section "Function" (3)</strong></p><p class="source-code"><strong class="bold">0000011: 03            ; section code</strong></p><p class="source-code"><strong class="bold">0000012: 00            ; section size (guess)</strong></p><p class="source-code"><strong class="bold">0000013: 01            ; num functions</strong></p><p class="source-code"><strong class="bold">0000014: 00            ; function 0 signature index</strong></p><p class="source-code"><strong class="bold">0000012: 02            ; FIXUP section size</strong></p><p class="source-code"><strong class="bold">; section "Code" (10)</strong></p><p class="source-code"><strong class="bold">0000015: 0a            ; section code</strong></p><p class="source-code"><strong class="bold">0000016: 00            ; section size (guess)</strong></p><p class="source-code"><strong class="bold">0000017: 01            ; num functions</strong></p><p class="source-code"><strong class="bold">; function body 0</strong></p><p class="source-code"><strong class="bold">0000018: 00            ; func body size (guess)</strong></p><p class="source-code"><strong class="bold">0000019: 00            ; local decl count</strong></p><p class="source-code"><strong class="bold">000001a: 20            ; local.get</strong></p><p class="source-code"><strong class="bold">000001b: 00            ; local index</strong></p><p class="source-code"><strong class="bold">000001c: 20            ; local.get</strong></p><p class="source-code"><strong class="bold">000001d: 01            ; local index</strong></p><p class="source-code"><strong class="bold">000001e: 6a            ; i32.add</strong></p><p class="source-code"><strong class="bold">000001f: 0b            ; end</strong></p><p class="source-code"><strong class="bold">0000018: 07            ; FIXUP func body size</strong></p><p class="source-code"><strong class="bold">0000016: 09            ; FIXUP section size</strong></p></li>
			</ol>
			<p>The preceding output is a detailed description of the binary generated. The leftmost seven numbers<a id="_idIndexMarker174"/> are the index, followed by a colon. The next two characters are the actual binary<a id="_idIndexMarker175"/> code, and then comments. The comment describes what the binary (op)code does.</p>
			<p>The first two lines specify <strong class="source-inline">wasm_magic_header</strong> and its version. The next segment is the <strong class="source-inline">Type</strong> section. The <strong class="source-inline">Type</strong> section defines the section ID, followed by the size of the section, and then the number of type blocks. In our case, we have only one type. The <strong class="source-inline">type 0</strong> section defines the <strong class="source-inline">type</strong> signature of the <strong class="source-inline">add</strong> function.</p>
			<p>Then, we have the <strong class="source-inline">Function</strong> section. In the <strong class="source-inline">Function</strong> section, we have the section ID, followed<a id="_idIndexMarker176"/> by the section size, and then the number of functions. The function<a id="_idIndexMarker177"/> section does not have the function body. The function body is defined in the <strong class="source-inline">Code</strong> section.</p>
			<p>While generating the binary, we can enable the compiler to include the new and shiny features and disable various existing features using the appropriate <strong class="source-inline">enable-*</strong> and <strong class="source-inline">disable-*</strong> options, respectively.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also check the online version at <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">https://webassembly.github.io/wabt/demo/wat2wasm/</a> to explore the WABT tools.</p>
			<p>We have converted WAST into WASM. Now, let's explore how to convert WASM into WAST with <strong class="source-inline">wasm2wat</strong>.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor057"/>Converting WASM into WAST</h1>
			<p>Sometimes, for debugging<a id="_idIndexMarker178"/> or understanding, we need <a id="_idIndexMarker179"/>to know what the WASM is doing. WABT has a <strong class="source-inline">wasm2wat</strong> converter. It helps to convert WASM into WAST format:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wasm2wat add.wasm</p>
			<p class="source-code">(module</p>
			<p class="source-code">  (type (;0;) (func (param i32 i32) (result i32)))</p>
			<p class="source-code">  (func (;0;) (type 0) (param i32 i32) (result i32)</p>
			<p class="source-code">    local.get 0</p>
			<p class="source-code">    local.get 1</p>
			<p class="source-code">    i32.add))</p>
			<p>Running the previous command will convert <strong class="source-inline">add.wasm</strong> back into WAST format and print the output in the console.</p>
			<p>If you want to save<a id="_idIndexMarker180"/> it as a file, you can do so<a id="_idIndexMarker181"/> by using the <strong class="source-inline">-o</strong> flag:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wasm2wat add.wasm -o new_</p>
			<p class="source-code">  add.wat</p>
			<p>This command creates a <strong class="source-inline">new_add.wat</strong> file.</p>
			<p>To check the various options supported by <strong class="source-inline">wasm2wat</strong>, we can run the following command:</p>
			<p class="source-code">$ wasm2wat --help</p>
			<p class="source-code">usage: wasm2wat [options] filename</p>
			<p class="source-code"> </p>
			<p class="source-code">  Read a file in the WebAssembly binary format, and convert </p>
			<p class="source-code">  it to</p>
			<p class="source-code">  the WebAssembly text format.</p>
			<p class="source-code"> </p>
			<p class="source-code">examples:</p>
			<p class="source-code">  # parse binary file test.wasm and write text file test.wast</p>
			<p class="source-code">  $ wasm2wat test.wasm -o test.wat</p>
			<p class="source-code"> </p>
			<p class="source-code">  # parse test.wasm, write test.wat, but ignore the debug names, if any</p>
			<p class="source-code">  $ wasm2wat test.wasm --no-debug-names -o test.wat</p>
			<p class="source-code"> </p>
			<p class="source-code">options:</p>
			<p class="source-code">      --help                                Print this help </p>
			<p class="source-code">        message</p>
			<p class="source-code">      --version                             Print version </p>
			<p class="source-code">        information</p>
			<p class="source-code">  -v, --verbose                             Use multiple times </p>
			<p class="source-code">   for more info</p>
			<p class="source-code">  -o, --output=FILENAME                     Output file for the </p>
			<p class="source-code">   generated wast file, by default use stdout</p>
			<p class="source-code">  -f, --fold-exprs                          Write folded </p>
			<p class="source-code">   expressions where possible</p>
			<p class="source-code">  ....</p>
			<p class="source-code">      --no-debug-names                      Ignore debug names </p>
			<p class="source-code">        in the binary file</p>
			<p class="source-code">      --ignore-custom-section-errors        Ignore errors in </p>
			<p class="source-code">        custom sections</p>
			<p class="source-code">      --generate-names                      Give auto-generated</p>
			<p class="source-code">        names to non-named functions, types, etc.</p>
			<p class="source-code">      --no-check                            Don't check for </p>
			<p class="source-code">        invalid modules</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Both <strong class="source-inline">wasm2wat</strong> and <strong class="source-inline">wat2wasm</strong> have almost identical options.</p>
			<p>Running the previous command<a id="_idIndexMarker182"/> with the <strong class="source-inline">-v</strong> option prints<a id="_idIndexMarker183"/> the AST syntax of the WAST format:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wasm2wat add.wasm -o new_</p>
			<p class="source-code">  add.wat -v</p>
			<p class="source-code">BeginModule(version: 1)</p>
			<p class="source-code">  BeginTypeSection(7)</p>
			<p class="source-code">    OnTypeCount(1)</p>
			<p class="source-code">    OnType(index: 0, params: [i32, i32], results: [i32])</p>
			<p class="source-code">  EndTypeSection</p>
			<p class="source-code">  BeginFunctionSection(2)</p>
			<p class="source-code">    OnFunctionCount(1)</p>
			<p class="source-code">    OnFunction(index: 0, sig_index: 0)</p>
			<p class="source-code">  EndFunctionSection</p>
			<p class="source-code">  BeginCodeSection(9)</p>
			<p class="source-code">    OnFunctionBodyCount(1)</p>
			<p class="source-code">    BeginFunctionBody(0, size:7)</p>
			<p class="source-code">    OnLocalDeclCount(0)</p>
			<p class="source-code">    OnLocalGetExpr(index: 0)</p>
			<p class="source-code">    OnLocalGetExpr(index: 1)</p>
			<p class="source-code">    OnBinaryExpr("i32.add" (106))</p>
			<p class="source-code">    EndFunctionBody(0)</p>
			<p class="source-code">  EndCodeSection</p>
			<p class="source-code">  BeginCustomSection('name', size: 28)</p>
			<p class="source-code">    BeginNamesSection(28)</p>
			<p class="source-code">      OnNameSubsection(index: 0, type: function, size:6)</p>
			<p class="source-code">      OnFunctionNameSubsection(index:0, nametype:1, size:6)</p>
			<p class="source-code">      OnFunctionNamesCount(1)</p>
			<p class="source-code">      OnFunctionName(index: 0, name: "add")</p>
			<p class="source-code">      OnNameSubsection(index: 1, type: local, size:13)</p>
			<p class="source-code">      OnLocalNameSubsection(index:1, nametype:2, size:13)</p>
			<p class="source-code">      OnLocalNameFunctionCount(1)</p>
			<p class="source-code">      OnLocalNameLocalCount(index: 0, count: 2)</p>
			<p class="source-code">      OnLocalName(func_index: 0, local_index: 0, name: "lhs")</p>
			<p class="source-code">      OnLocalName(func_index: 0, local_index: 1, name: "rhs")</p>
			<p class="source-code">    EndNamesSection</p>
			<p class="source-code">  EndCustomSection</p>
			<p class="source-code">EndModule</p>
			<p>The entire code block is wrapped inside <strong class="source-inline">BeginModule</strong> and <strong class="source-inline">EndModule</strong>. <strong class="source-inline">BeginModule</strong> includes the version of the WebAssembly binary.</p>
			<p>Inside the BeginModule, the <strong class="source-inline">BeginTypeSection</strong> starts with the section<a id="_idIndexMarker184"/> index of type (that is, <strong class="source-inline">7</strong>), followed by <strong class="source-inline">OnTypeCount</strong>, the number<a id="_idIndexMarker185"/> of types defined. Then, we have the actual definition of the type with <strong class="source-inline">OnType</strong>. We end the type section with <strong class="source-inline">EndTypeSection</strong>.</p>
			<p>Then, we have the <strong class="source-inline">Function</strong> section marked by <strong class="source-inline">BeginFunctionSection</strong> and <strong class="source-inline">EndFunctionSection</strong>. This contains the function count (<strong class="source-inline">OnFunctionCount</strong>) and the function definition (<strong class="source-inline">OnFunction</strong>).</p>
			<p>Finally, we have the code section, which holds the actual body of the function. The code section begins and ends with <strong class="source-inline">BeginCodeSection</strong> and <strong class="source-inline">EndCodeSection</strong>.</p>
			<p>Sometimes, WASM may contain debug names. We can ignore them using the <strong class="source-inline">--no-debug-names</strong> flag:</p>
			<p class="source-code"> $ /path/to/build/directory/of/wabt/wasm2wat add.wasm -o new_</p>
			<p class="source-code">  add.wat -v --no-debug-names</p>
			<p class="source-code">BeginModule(version: 1)</p>
			<p class="source-code">  BeginTypeSection(7)</p>
			<p class="source-code">    OnTypeCount(1)</p>
			<p class="source-code">    OnType(index: 0, params: [i32, i32], results: [i32])</p>
			<p class="source-code">  EndTypeSection</p>
			<p class="source-code">  BeginFunctionSection(2)</p>
			<p class="source-code">    OnFunctionCount(1)</p>
			<p class="source-code">    OnFunction(index: 0, sig_index: 0)</p>
			<p class="source-code">  EndFunctionSection</p>
			<p class="source-code">  BeginCodeSection(9)</p>
			<p class="source-code">    OnFunctionBodyCount(1)</p>
			<p class="source-code">    BeginFunctionBody(0, size:7)</p>
			<p class="source-code">    OnLocalDeclCount(0)</p>
			<p class="source-code">    OnLocalGetExpr(index: 0)</p>
			<p class="source-code">    OnLocalGetExpr(index: 1)</p>
			<p class="source-code">    OnBinaryExpr("i32.add" (106))</p>
			<p class="source-code">    EndFunctionBody(0)</p>
			<p class="source-code">  EndCodeSection</p>
			<p class="source-code">  BeginCustomSection('name', size: 28)</p>
			<p class="source-code">  EndCustomSection</p>
			<p class="source-code">EndModule</p>
			<p>Note <strong class="source-inline">BeginCustomSection</strong> and <strong class="source-inline">EndCustomSection</strong>. Compare<a id="_idIndexMarker186"/> it with<a id="_idIndexMarker187"/> the previous output; it is missing <strong class="source-inline">NamesSection</strong>. Now, let's check out the various options provided by the <strong class="source-inline">wasm2wat</strong> tool.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor058"/>-f or --fold-exprs</h2>
			<p>As a big fan of functional<a id="_idIndexMarker188"/> programming, this is one of the coolest options available. It folds<a id="_idIndexMarker189"/> over the expression; that is, it converts expression 1 &gt;&gt; expression 2 &gt;&gt; operation into operation &gt;&gt; expression 1 &gt;&gt; expression2.</p>
			<p>Let's see that in action:</p>
			<ol>
				<li value="1">Create a WAST file called <strong class="source-inline">fold.wat</strong> and fill it with the following contents:<p class="source-code"><strong class="bold">(module</strong></p><p class="source-code"><strong class="bold">    (func $fold (result i32)</strong></p><p class="source-code"><strong class="bold">        i32.const 22</strong></p><p class="source-code"><strong class="bold">        i32.const 20</strong></p><p class="source-code"><strong class="bold">        i32.add</strong></p><p class="source-code"><strong class="bold">    )</strong></p><p class="source-code"><strong class="bold">)</strong></p></li>
				<li>Let's first convert it into WASM using <strong class="source-inline">wat2wasm</strong>:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/wabt/wat2wasm -v</strong></p><p class="source-code"><strong class="bold">  fold.wat</strong></p><p class="source-code"><strong class="bold">; some contents</strong></p><p class="source-code"><strong class="bold">0000018: 41                                        ;</strong></p><p class="source-code"><strong class="bold">  i32.const</strong></p><p class="source-code"><strong class="bold">0000019: 16                                        ;</strong></p><p class="source-code"><strong class="bold">  i32 literal</strong></p><p class="source-code"><strong class="bold">000001a: 41                                        ;</strong></p><p class="source-code"><strong class="bold">  i32.const</strong></p><p class="source-code"><strong class="bold">000001b: 14                                        ;</strong></p><p class="source-code"><strong class="bold">  i32 literal</strong></p><p class="source-code"><strong class="bold">000001c: 6a                                        ;</strong></p><p class="source-code"><strong class="bold">  i32.add</strong></p><p class="source-code"><strong class="bold">; other contents</strong></p></li>
			</ol>
			<p>This creates <strong class="source-inline">fold.wasm</strong>. </p>
			<ol>
				<li value="3">Now, convert the WASM<a id="_idIndexMarker190"/> into the WAST format using <strong class="source-inline">wasm2wat</strong> and pass<a id="_idIndexMarker191"/> in the <strong class="source-inline">-f</strong> option:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/wabt/wasm2wat -v</strong></p><p class="source-code"><strong class="bold">  fold.wasm -o converted_fold.wat -f</strong></p></li>
			</ol>
			<p>This will create a file called <strong class="source-inline">converted_fold.wat</strong>:</p>
			<p class="source-code"><strong class="bold">(module</strong></p>
			<p class="source-code"><strong class="bold">    (type (;0;) (func (result i32)))</strong></p>
			<p class="source-code"><strong class="bold">    (func (;0;) (type 0) (result i32)</strong></p>
			<p class="source-code"><strong class="bold">        (i32.add</strong></p>
			<p class="source-code"><strong class="bold">            (i32.const 1)</strong></p>
			<p class="source-code"><strong class="bold">            (i32.const 2))))</strong></p>
			<p>Instead of using <strong class="source-inline">i32.const 1</strong> (expression 1) and <strong class="source-inline">i32.const 2</strong> (expression 2) and then doing <strong class="source-inline">i32.add</strong> (operation), this generates an output, <strong class="source-inline">i32.add</strong> (operation), followed by <strong class="source-inline">i32.const 1</strong> (expression 1) and <strong class="source-inline">i32.const 2</strong> (expression 2).</p>
			<p>While generating <strong class="source-inline">wat</strong>, we can enable the compiler to include the new and shiny features and disable various existing features using the appropriate <strong class="source-inline">enable-*</strong> and <strong class="source-inline">disable-*</strong> options, respectively.</p>
			<p>We have converted WASM into WAST. Now, let's explore how to convert WASM into native code (C) using <strong class="source-inline">wasm2c</strong>.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor059"/>Converting WASM into C</h1>
			<p>WABT has a <strong class="source-inline">wasm2c</strong> converter that converts<a id="_idIndexMarker192"/> WASM into C source c<a id="_idIndexMarker193"/>ode and a header.</p>
			<p>Let's create a <strong class="source-inline">simple.wat</strong> file:</p>
			<p class="source-code">$ touch simple.wat</p>
			<p>Add the following contents to <strong class="source-inline">simple.wat</strong>:</p>
			<p class="source-code">(module</p>
			<p class="source-code">    (func $uanswer (result i32)</p>
			<p class="source-code">        i32.const 22</p>
			<p class="source-code">        i32.const 20</p>
			<p class="source-code">        i32.add</p>
			<p class="source-code">    )</p>
			<p class="source-code">)</p>
			<p><strong class="source-inline">wat</strong> here defines a <strong class="source-inline">uanswer</strong> function that adds <strong class="source-inline">22</strong> and <strong class="source-inline">20</strong> to give <strong class="source-inline">42</strong> as the answer. Let's create a WebAssembly binary using <strong class="source-inline">wat2wasm</strong>:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wat2wasm simple.wat -o </p>
			<p class="source-code">  simple.wasm</p>
			<p>This generates the <strong class="source-inline">simple.wasm</strong> binary. Now, convert the binary into C code using <strong class="source-inline">wasm2c</strong>:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wasm2c simple.wasm -o </p>
			<p class="source-code">  simple.c</p>
			<p>This generates <strong class="source-inline">simple.c</strong> and <strong class="source-inline">simple.h</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Both <strong class="source-inline">simple.c</strong> and <strong class="source-inline">simple.h</strong> might look huge. Remember this is an autogenerated file and it includes all the necessary headers and configuration needed for the program to run. </p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor060"/>simple.h</h2>
			<p><strong class="source-inline">simple.h</strong> (the header file) includes standard boilerplate<a id="_idIndexMarker194"/> for the header. It also includes the <strong class="source-inline">_cplusplus</strong> condition to prevent name mangling in C++:</p>
			<p class="source-code">#ifndef SIMPLE_H_GENERATED_</p>
			<p class="source-code">#define SIMPLE_H_GENERATED_</p>
			<p class="source-code">#ifdef __cplusplus</p>
			<p class="source-code">extern "C" {</p>
			<p class="source-code">#endif</p>
			<p class="source-code"> </p>
			<p class="source-code">...</p>
			<p class="source-code"> </p>
			<p class="source-code">#ifdef __cplusplus</p>
			<p class="source-code">}</p>
			<p class="source-code">#endif</p>
			<p class="source-code">#endif</p>
			<p>Since we have used <strong class="source-inline">i32.const</strong> and <strong class="source-inline">i32.add</strong>, the header file also imports <strong class="source-inline">stdint.h</strong>. It includes <strong class="source-inline">wasm-rt.h</strong>. The <strong class="source-inline">wasm-rt.h</strong> header imports the necessary WASM runtime variables.</p>
			<p>Next, we can specify a module prefix. The module prefix is useful when using multiple modules. Since we only have one module, we use an empty prefix:</p>
			<p class="source-code"> </p>
			<p class="source-code">#ifndef WASM_RT_MODULE_PREFIX</p>
			<p class="source-code">#define WASM_RT_MODULE_PREFIX</p>
			<p class="source-code">#endif</p>
			<p class="source-code"> </p>
			<p class="source-code">#define WASM_RT_PASTE_(x, y) x ## y</p>
			<p class="source-code">#define WASM_RT_PASTE(x, y) WASM_RT_PASTE_(x, y)</p>
			<p class="source-code">#define WASM_RT_ADD_PREFIX(x) WASM_RT_PASTE(WASM_RT_MODULE_PREFIX, x)</p>
			<p>Next, we have some typedefs<a id="_idIndexMarker195"/> for the various number formats that WASM supports:</p>
			<p class="source-code">typedef uint8_t u8;</p>
			<p class="source-code">typedef int8_t s8;</p>
			<p class="source-code">typedef uint16_t u16;</p>
			<p class="source-code">typedef int16_t s16;</p>
			<p class="source-code">typedef uint32_t u32;</p>
			<p class="source-code">typedef int32_t s32;</p>
			<p class="source-code">typedef uint64_t u64;</p>
			<p class="source-code">typedef int64_t s64;</p>
			<p class="source-code">typedef float f32;</p>
			<p class="source-code">typedef double f64;</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor061"/>simple.c</h2>
			<p><strong class="source-inline">simple.c</strong> provides the actual C code<a id="_idIndexMarker196"/> generated from the WASM binary. The generated code has the following:</p>
			<ol>
				<li value="1">We'll require the following list of libraries to use in the code:<p class="source-code"><strong class="bold">#include &lt;math.h&gt;</strong></p><p class="source-code"><strong class="bold">#include &lt;string.h&gt;</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">#include "simple.h"</strong></p></li>
				<li>Next, we define the trap<a id="_idIndexMarker197"/> that is called when an error occurs:<p class="source-code"><strong class="bold">#define TRAP(x) (wasm_rt_trap(WASM_RT_TRAP_##x), 0)</strong></p></li>
				<li>Then, we define <strong class="source-inline">PROLOGUE</strong>, <strong class="source-inline">EPILOGUE</strong>, and <strong class="source-inline">UNREACHABLE_TRAP</strong>, which are called before the start of execution, after execution, and when the execution meets an unreachable exception, respectively:<p class="source-code"><strong class="bold">#define FUNC_PROLOGUE                                            \</strong></p><p class="source-code"><strong class="bold">  if (++wasm_rt_call_stack_depth &gt;</strong></p><p class="source-code"><strong class="bold">    WASM_RT_MAX_CALL_STACK_DEPTH) \</strong></p><p class="source-code"><strong class="bold">    TRAP(EXHAUSTION)</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">#define FUNC_EPILOGUE --wasm_rt_call_stack_depth</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">#define UNREACHABLE TRAP(UNREACHABLE)</strong></p></li>
			</ol>
			<p><strong class="source-inline">WASM_RT_MAX_CALL_STACK_DEPTH</strong> is the maximum depth of the stack. By default, the value is <strong class="source-inline">500</strong> but we can change it. Note that if it reaches the limit, then an exception is thrown.</p>
			<ol>
				<li value="4">Next, we define the memory manipulations:<p class="source-code"><strong class="bold">#if WASM_RT_MEMCHECK_SIGNAL_HANDLER</strong></p><p class="source-code"><strong class="bold">#define MEMCHECK(mem, a, t)</strong></p><p class="source-code"><strong class="bold">#else</strong></p><p class="source-code"><strong class="bold">#define MEMCHECK(mem, a, t)  \</strong></p><p class="source-code"><strong class="bold">  if (UNLIKELY((a) + sizeof(t) &gt; mem-&gt;size)) TRAP(OOB)</strong></p><p class="source-code"><strong class="bold">#endif</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">#define DEFINE_LOAD(name, t1, t2, t3)       </strong></p><p class="source-code"><strong class="bold">\</strong></p><p class="source-code"><strong class="bold">  static inline t3 name(wasm_rt_memory_t* mem, u64</strong></p><p class="source-code"><strong class="bold">    addr) {   \</strong></p><p class="source-code"><strong class="bold">    MEMCHECK(mem, addr, t1);        </strong></p><p class="source-code"><strong class="bold">\</strong></p><p class="source-code"><strong class="bold">    t1 result;        </strong></p><p class="source-code"><strong class="bold">\</strong></p><p class="source-code"><strong class="bold">    __builtin_memcpy(&amp;result, &amp;mem-&gt;data[addr],</strong></p><p class="source-code"><strong class="bold">      sizeof(t1)); \</strong></p><p class="source-code"><strong class="bold">    return (t3)(t2)result;        </strong></p><p class="source-code"><strong class="bold">\</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">#define DEFINE_STORE(name, t1, t2)          </strong></p><p class="source-code"><strong class="bold">\</strong></p><p class="source-code"><strong class="bold">  static inline void name(wasm_rt_memory_t* mem, u64</strong></p><p class="source-code"><strong class="bold">    addr, t2 value) { \</strong></p><p class="source-code"><strong class="bold">    MEMCHECK(mem, addr, t1);       </strong></p><p class="source-code"><strong class="bold">\</strong></p><p class="source-code"><strong class="bold">    t1 wrapped = (t1)value;      </strong></p><p class="source-code"><strong class="bold">\</strong></p><p class="source-code"><strong class="bold">    __builtin_memcpy(&amp;mem-&gt;data[addr], &amp;wrapped,</strong></p><p class="source-code"><strong class="bold">      sizeof(t1));          \</strong></p><p class="source-code"><strong class="bold">  }</strong></p></li>
			</ol>
			<p><strong class="source-inline">MEMCHECK</strong> checks<a id="_idIndexMarker198"/> for memory. The <strong class="source-inline">DEFINE_LOAD</strong> and <strong class="source-inline">DEFINE_STORE</strong> blocks define how to load and store a value in memory.</p>
			<ol>
				<li value="5">Next, we define a bunch of load <a id="_idIndexMarker199"/>and store operations for various data types that we have in this example:<p class="source-code"><strong class="bold">DEFINE_LOAD(i32_load, u32, u32, u32);</strong></p><p class="source-code"><strong class="bold">DEFINE_LOAD(i64_load, u64, u64, u64);</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">DEFINE_LOAD(i64_load32_u, u32, u64, u64);</strong></p><p class="source-code"><strong class="bold">DEFINE_STORE(i32_store, u32, u32);</strong></p><p class="source-code"><strong class="bold">DEFINE_STORE(i64_store, u64, u64);</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">DEFINE_STORE(i64_store32, u32, u64);</strong></p></li>
			</ol>
			<p>Then, we define various functions that each of the data types supports, such as <strong class="source-inline">TRUNC</strong>, <strong class="source-inline">DIV</strong>, and <strong class="source-inline">REM</strong>.</p>
			<ol>
				<li value="6">Next, we initialize the function types using <strong class="source-inline">func_types</strong>:<p class="source-code"><strong class="bold">static u32 func_types[1];</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">static void init_func_types(void) {</strong></p><p class="source-code"><strong class="bold">  func_types[0] = wasm_rt_register_func_type(0, 1,</strong></p><p class="source-code"><strong class="bold">    WASM_RT_I32);</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
			</ol>
			<p>This registers the (result i32) type in the WASM provided.</p>
			<ol>
				<li value="7">Next, we initialize <strong class="source-inline">globals</strong>, <strong class="source-inline">memory</strong>, <strong class="source-inline">table</strong>, and <strong class="source-inline">exports</strong>:<p class="source-code"><strong class="bold">static void init_globals(void) {</strong></p><p class="source-code"><strong class="bold">}</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">static void init_memory(void) {</strong></p><p class="source-code"><strong class="bold">}</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">static void init_table(void) {</strong></p><p class="source-code"><strong class="bold">  uint32_t offset;</strong></p><p class="source-code"><strong class="bold">}</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">static void init_exports(void) {</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
				<li>Now, we implement<a id="_idIndexMarker200"/> the actual function:<p class="source-code"><strong class="bold">static u32 w2c_f0(void) {</strong></p><p class="source-code"><strong class="bold">  FUNC_PROLOGUE;</strong></p><p class="source-code"><strong class="bold">  u32 w2c_i0, w2c_i1;</strong></p><p class="source-code"><strong class="bold">  w2c_i0 = 22u;</strong></p><p class="source-code"><strong class="bold">  w2c_i1 = 20u;</strong></p><p class="source-code"><strong class="bold">  w2c_i0 += w2c_i1;</strong></p><p class="source-code"><strong class="bold">  FUNC_EPILOGUE;</strong></p><p class="source-code"><strong class="bold">  return w2c_i0;</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
			</ol>
			<p>The function is static. It calls <strong class="source-inline">FUNC_PROLOGUE</strong> before the execution. Then, it creates two variables (both are unsigned u32). Then, we define the value of both the variables, <strong class="source-inline">22</strong> and <strong class="source-inline">20</strong>, respectively. After that, we add them both. Once the execution is complete, we call <strong class="source-inline">FUNC_EPILOGUE</strong>. Finally, we return the value.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since we have not exported anything in <strong class="source-inline">wat</strong>, <strong class="source-inline">init_exports</strong> is empty.</p>
			<p>We have converted WASM into C. The generated code is slightly different from the original code. Let's explore how to convert WAST into JSON with <strong class="source-inline">wast2json</strong>.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor062"/>Converting WAST into JSON </h1>
			<p>The <strong class="source-inline">wast2json</strong> tool reads the WAST format<a id="_idIndexMarker201"/> and parses it, checks for errors, and then converts WAST<a id="_idIndexMarker202"/> into the JSON file. It generates a JSON and WASM file associated with the WAST file. Then, it links the WASM inside the JSON:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wast2json add.wat -o add.</p>
			<p class="source-code">  json</p>
			<p class="source-code">$ cat add.json</p>
			<p class="source-code">{"source_filename": "add.wat",</p>
			<p class="source-code">"commands": [</p>
			<p class="source-code">{"type": "module", "line": 1, "filename": "add.0.wasm"}]}</p>
			<p>To check the various options supported by <strong class="source-inline">wast2json</strong>, run the following command:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wast2json --help</p>
			<p class="source-code">usage: wast2json [options] filename</p>
			<p class="source-code"> </p>
			<p class="source-code">  read a file in the wasm spec test format, check it for </p>
			<p class="source-code">  errors, and</p>
			<p class="source-code">  convert it to a JSON file and associated wasm binary files.</p>
			<p class="source-code"> </p>
			<p class="source-code">examples:</p>
			<p class="source-code">  # parse spec-test.wast, and write files to spec-test.json. </p>
			<p class="source-code">  Modules are</p>
			<p class="source-code">  # written to spec-test.0.wasm, spec-test.1.wasm, etc.</p>
			<p class="source-code">  $ wast2json spec-test.wast -o spec-test.json</p>
			<p class="source-code"> </p>
			<p class="source-code">options:</p>
			<p class="source-code">      --help                                Print this help </p>
			<p class="source-code">        message</p>
			<p class="source-code">      --version                             Print version </p>
			<p class="source-code">        information</p>
			<p class="source-code">  -v, --verbose                             Use multiple times </p>
			<p class="source-code">   for more info</p>
			<p class="source-code">      --debug-parser                        Turn on debugging </p>
			<p class="source-code">        the parser of wast files</p>
			<p class="source-code">      --enable-exceptions                   Enable Experimental </p>
			<p class="source-code">        exception handling</p>
			<p class="source-code">      --disable-mutable-globals             Disable Import/</p>
			<p class="source-code">        export mutable globals</p>
			<p class="source-code">      --disable-saturating-float-to-int     Disable Saturating</p>
			<p class="source-code">        float-to-int operators</p>
			<p class="source-code">      --disable-sign-extension              Disable Sign-</p>
			<p class="source-code">        extension operators</p>
			<p class="source-code">      --enable-simd                         Enable SIMD support</p>
			<p class="source-code">      --enable-threads                      Enable Threading </p>
			<p class="source-code">        support</p>
			<p class="source-code">      --disable-multi-value                 Disable Multi-value</p>
			<p class="source-code">      --enable-tail-call                    Enable Tail-call </p>
			<p class="source-code">        support</p>
			<p class="source-code">      --enable-bulk-memory                  Enable Bulk-memory </p>
			<p class="source-code">        operations</p>
			<p class="source-code">      --enable-reference-types              Enable Reference </p>
			<p class="source-code">        types (externref)</p>
			<p class="source-code">      --enable-annotations                  Enable Custom </p>
			<p class="source-code">        annotation syntax</p>
			<p class="source-code">      --enable-gc                           Enable Garbage </p>
			<p class="source-code">        collection</p>
			<p class="source-code">      --enable-memory64                     Enable 64-bit </p>
			<p class="source-code">        memory</p>
			<p class="source-code">      --enable-all                          Enable all features</p>
			<p class="source-code">  -o, --output=FILE                         output JSON file</p>
			<p class="source-code">  -r, --relocatable                         Create a </p>
			<p class="source-code">   relocatable wasm binary (suitable for linking with e.g. lld)</p>
			<p class="source-code">      --no-canonicalize-leb128s             Write all LEB128 </p>
			<p class="source-code">        sizes as 5-bytes instead of their minimal size</p>
			<p class="source-code">      --debug-names                         Write debug names </p>
			<p class="source-code">        to the generated binary file</p>
			<p class="source-code">      --no-check                            Don't check for </p>
			<p class="source-code">        invalid modules</p>
			<p>These are the frequently<a id="_idIndexMarker203"/> used WABT tools. There are a few other tools<a id="_idIndexMarker204"/> provided by WABT that help with debugging and understanding WASM better.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor063"/>Understanding a few other tools provided by WABT</h1>
			<p>In addition to the converters, WABT also provides a few tools<a id="_idIndexMarker205"/> that help us to understand WASM better. In this section, let's explore the following tools provided by WABT:</p>
			<ul>
				<li><strong class="source-inline">wasm-objdump</strong></li>
				<li><strong class="source-inline">wasm-strip</strong></li>
				<li><strong class="source-inline">wasm-validate</strong></li>
				<li><strong class="source-inline">wasm-interp</strong> </li>
			</ul>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor064"/>wasm-objdump</h2>
			<p>Object code is nothing more than a sequence<a id="_idIndexMarker206"/> of instructions or statements in the computer language. Object code is what the compiler produces. The object code is then collected together and then stored inside the object file. The object file is the metadata holder for linking and debugging information. The machine code in the object file is not directly executable, but it provides valuable information when debugging and also helps with linking.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">objdump</strong> is the tool that is available in POSIX systems that provides a way to disassemble the binary format and print the assembly format of the code that is running.</p>
			<p>The <strong class="source-inline">wasm-objdump</strong> tool provides the following options:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wasm-objdump --help</p>
			<p class="source-code">usage: wasm-objdump [options] filename+</p>
			<p class="source-code"> </p>
			<p class="source-code">  Print information about the contents of wasm binaries.</p>
			<p class="source-code"> </p>
			<p class="source-code">examples:</p>
			<p class="source-code">  $ wasm-objdump test.wasm</p>
			<p class="source-code"> </p>
			<p class="source-code">options:</p>
			<p class="source-code">      --help                   Print this help message</p>
			<p class="source-code">      --version                Print version information</p>
			<p class="source-code">  -h, --headers                Print headers</p>
			<p class="source-code">  -j, --section=SECTION        Select just one section</p>
			<p class="source-code">  -s, --full-contents          Print raw section contents</p>
			<p class="source-code">  -d, --disassemble            Disassemble function bodies</p>
			<p class="source-code">      --debug                  Print extra debug information</p>
			<p class="source-code">  -x, --details                Show section details</p>
			<p class="source-code">  -r, --reloc                  Show relocations inline with </p>
			<p class="source-code">   disassembly</p>
			<p>At least one of the following options <a id="_idIndexMarker207"/>should be provided to the <strong class="source-inline">wasm-objdump</strong> command:</p>
			<p class="source-code">-d/--disassemble</p>
			<p class="source-code">-h/--headers</p>
			<p class="source-code">-x/--details</p>
			<p class="source-code">-s/--full-contents</p>
			<p>The <strong class="source-inline">-h</strong> option prints all the available headers in WASM. For example, in our add example (<strong class="source-inline">add.wasm</strong>), we have the following:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wasm-objdump add.wasm -h</p>
			<p class="source-code">add.wasm: file format wasm 0x1</p>
			<p class="source-code"> </p>
			<p class="source-code">Sections:</p>
			<p class="source-code"> </p>
			<p class="source-code">     Type start=0x0000000a end=0x00000011 (size=0x00000007)</p>
			<p class="source-code">  count: 1</p>
			<p class="source-code">Function start=0x00000013 end=0x00000015 (size=0x00000002) </p>
			<p class="source-code">  count: 1</p>
			<p class="source-code">     Code start=0x00000017 end=0x00000020 (size=0x00000009) </p>
			<p class="source-code">  count: 1</p>
			<p>Here, we have three sections<a id="_idIndexMarker208"/> available:</p>
			<ul>
				<li><strong class="source-inline">Type</strong></li>
				<li><strong class="source-inline">Function</strong></li>
				<li><strong class="source-inline">Code</strong></li>
			</ul>
			<p>The <strong class="source-inline">-d</strong> option prints the actual body of the function available: </p>
			<p class="source-code"> </p>
			<p class="source-code">$/path/to/build/directory/of/wabt/wasm-objdump add.wasm -d</p>
			<p class="source-code">add.wasm: file format wasm 0x1</p>
			<p class="source-code"> </p>
			<p class="source-code">Code Disassembly:</p>
			<p class="source-code"> </p>
			<p class="source-code">000019 func[0]:</p>
			<p class="source-code">00001a: 20 00 | local.get 0</p>
			<p class="source-code">00001c: 20 01 | local.get 1</p>
			<p class="source-code">00001e: 6a | i32.add</p>
			<p class="source-code">00001f: 0b | end</p>
			<p>It dissembles the assembly function and prints only the function body.</p>
			<p>The <strong class="source-inline">-x</strong> option prints the section details of the WebAssembly binary file:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wasm-objdump add.wasm -x</p>
			<p class="source-code"> </p>
			<p class="source-code">add.wasm: file format wasm 0x1</p>
			<p class="source-code"> </p>
			<p class="source-code">Section Details:</p>
			<p class="source-code"> </p>
			<p class="source-code">Type[1]:</p>
			<p class="source-code">- type[0] (i32, i32) -&gt; i32</p>
			<p class="source-code">Function[1]:</p>
			<p class="source-code">- func[0] sig=0</p>
			<p class="source-code">Code[1]:</p>
			<p class="source-code">- func[0] size=7</p>
			<p>The <strong class="source-inline">-s</strong> option prints the contents<a id="_idIndexMarker209"/> of all the sections that are available:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wasm-objdump add.wasm -s</p>
			<p class="source-code"> </p>
			<p class="source-code">add.wasm: file format wasm 0x1</p>
			<p class="source-code"> </p>
			<p class="source-code">Contents of section Type:</p>
			<p class="source-code">000000a: 0160 027f 7f01 7f .`.....</p>
			<p class="source-code"> </p>
			<p class="source-code">Contents of section Function:</p>
			<p class="source-code">0000013: 0100 ..</p>
			<p class="source-code"> </p>
			<p class="source-code">Contents of section Code:</p>
			<p class="source-code">0000017: 0107 0020 0020 016a 0b ... . .j.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor065"/>wasm-strip</h2>
			<p>The custom section in a WASM holds information<a id="_idIndexMarker210"/> about the names of the function and all locals defined in the WASM. It may contain information about the build and how the WASM was created. This is additional information. It bloats the binary and does not add any functionality.</p>
			<p>We can strip the custom section to trim the binary size using the <strong class="source-inline">wasm-strip</strong> tool:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">wat</strong> file with the following<a id="_idIndexMarker211"/> contents:<p class="source-code"><strong class="bold">$ touch simple.wat</strong></p><p class="source-code"><strong class="bold">(module</strong></p><p class="source-code"><strong class="bold">    (func $fold (result i32)</strong></p><p class="source-code"><strong class="bold">        i32.const 22</strong></p><p class="source-code"><strong class="bold">        i32.const 20</strong></p><p class="source-code"><strong class="bold">        i32.add</strong></p><p class="source-code"><strong class="bold">    )</strong></p><p class="source-code"><strong class="bold">)</strong></p></li>
				<li>Now, convert that into a WASM with <strong class="source-inline">wat2wasm</strong>:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/wabt/wat2wasm simple.wat</strong></p><p class="source-code"><strong class="bold">  --debug-names</strong></p><p class="source-code"><strong class="bold">$ l simple.wasm</strong></p><p class="source-code"><strong class="bold">51B simple.wasm</strong></p></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">--debug-names</strong> option provided generates the custom section and adds it to the binary generated.</p>
			<p>The previous command generates a <strong class="source-inline">simple.wasm</strong> file and it is 51 bytes in size. </p>
			<ol>
				<li value="3">Now, let's remove the custom section from the binary using the following:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/wabt/wasm-strip add.wasm</strong></p><p class="source-code"><strong class="bold">$ l simple.wasm</strong></p><p class="source-code"><strong class="bold">30B simple.wasm</strong></p></li>
			</ol>
			<p>As you can see, it removed 21 bytes of unnecessary information. Some WASM generators add the custom section<a id="_idIndexMarker212"/> for a better debugging experience but when deploying in production, we do not need the custom section. Use <strong class="source-inline">wasm-strip</strong> to remove it.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor066"/>wasm-validate</h2>
			<p>We can validate the WASM<a id="_idIndexMarker213"/> using <strong class="source-inline">wasm-validate</strong>:</p>
			<ol>
				<li value="1">Create <strong class="source-inline">error.wasm</strong> with the following contents:<p class="source-code"><strong class="bold">00 61 73 6d 03 00 00 00</strong></p><p class="source-code"><strong class="bold">            |</strong></p><p class="source-code"><strong class="bold">        Error value</strong></p></li>
				<li>Now, run <strong class="source-inline">wasm-validate</strong> to check whether the WASM is valid or not:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/wabt/wasm-validate</strong></p><p class="source-code"><strong class="bold">  error.wasm</strong></p><p class="source-code"><strong class="bold">0000004: error: bad magic value</strong></p></li>
				<li>The <strong class="source-inline">wasm-validate</strong> tool provides the following options:<p class="source-code"><strong class="bold">usage: wasm-validate [options] filename</strong></p></li>
				<li> Read a file in the WebAssembly binary format and validate it:<p class="source-code"><strong class="bold">examples:</strong></p><p class="source-code"><strong class="bold">  # validate binary file test.wasm</strong></p><p class="source-code"><strong class="bold">  $ wasm-validate test.wasm</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">options:</strong></p><p class="source-code"><strong class="bold">      --help                Print this help message</strong></p><p class="source-code"><strong class="bold">      --version             Print version information</strong></p><p class="source-code"><strong class="bold">  -v, --verbose             Use multiple times for </strong></p><p class="source-code"><strong class="bold">   more info</strong></p><p class="source-code"><strong class="bold">      --enable-exceptions   Enable Experimental</strong></p><p class="source-code"><strong class="bold">        exception handling</strong></p><p class="source-code"><strong class="bold">      --disable-mutable-globals     Disable</strong></p><p class="source-code"><strong class="bold">        Import/export mutable globals</strong></p><p class="source-code"><strong class="bold">      --disable-saturating-float-to-int        Disable</strong></p><p class="source-code"><strong class="bold">        Saturating float-to-int operators</strong></p><p class="source-code"><strong class="bold">      --disable-sign-extension                 Disable</strong></p><p class="source-code"><strong class="bold">        Sign-extension operators</strong></p><p class="source-code"><strong class="bold">      --enable-simd                            Enable</strong></p><p class="source-code"><strong class="bold">        SIMD support</strong></p><p class="source-code"><strong class="bold">      --enable-threads                         Enable</strong></p><p class="source-code"><strong class="bold">        Threading support</strong></p><p class="source-code"><strong class="bold">      --disable-multi-value                    Disable</strong></p><p class="source-code"><strong class="bold">        Multi-value</strong></p><p class="source-code"><strong class="bold">      --enable-tail-call                       Enable</strong></p><p class="source-code"><strong class="bold">        Tail-call support</strong></p><p class="source-code"><strong class="bold">      --enable-bulk-memory                     Enable</strong></p><p class="source-code"><strong class="bold">        Bulk-memory operations</strong></p><p class="source-code"><strong class="bold">      --enable-reference-types                 Enable</strong></p><p class="source-code"><strong class="bold">        Reference types (externref)</strong></p><p class="source-code"><strong class="bold">      --enable-annotations                     Enable</strong></p><p class="source-code"><strong class="bold">        Custom annotation syntax</strong></p><p class="source-code"><strong class="bold">      --enable-gc                              Enable</strong></p><p class="source-code"><strong class="bold">        Garbage collection</strong></p><p class="source-code"><strong class="bold">      --enable-memory64                        Enable</strong></p><p class="source-code"><strong class="bold">        64-bit memory</strong></p><p class="source-code"><strong class="bold">      --enable-all                             Enable</strong></p><p class="source-code"><strong class="bold">        all features</strong></p><p class="source-code"><strong class="bold">      --no-debug-names                         Ignore</strong></p><p class="source-code"><strong class="bold">        debug names in the binary file</strong></p><p class="source-code"><strong class="bold">      --ignore-custom-section-errors           Ignore</strong></p><p class="source-code"><strong class="bold">        errors in custom sections</strong></p></li>
			</ol>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor067"/>wasm-interp</h2>
			<p><strong class="source-inline">wasm-interp</strong> reads a file in the WebAssembly binary format<a id="_idIndexMarker214"/> and runs it in a stack-based interpreter. The <strong class="source-inline">wasm-interp</strong> tool parses the binary file and then type checks it:</p>
			<p class="source-code">$ /path/to/build/directory/of/wabt/wasm-interp add.wasm -v</p>
			<p class="source-code">BeginModule(version: 1)</p>
			<p class="source-code">  BeginTypeSection(7)</p>
			<p class="source-code">    OnTypeCount(1)</p>
			<p class="source-code">    OnType(index: 0, params: [i32, i32], results: [i32])</p>
			<p class="source-code">  EndTypeSection</p>
			<p class="source-code">  BeginFunctionSection(2)</p>
			<p class="source-code">    OnFunctionCount(1)</p>
			<p class="source-code">    OnFunction(index: 0, sig_index: 0)</p>
			<p class="source-code">  EndFunctionSection</p>
			<p class="source-code">  BeginCodeSection(9)</p>
			<p class="source-code">    OnFunctionBodyCount(1)</p>
			<p class="source-code">    BeginFunctionBody(0, size:7)</p>
			<p class="source-code">    OnLocalDeclCount(0)</p>
			<p class="source-code">    OnLocalGetExpr(index: 0)</p>
			<p class="source-code">    OnLocalGetExpr(index: 1)</p>
			<p class="source-code">    OnBinaryExpr("i32.add" (106))</p>
			<p class="source-code">    EndFunctionBody(0)</p>
			<p class="source-code">  EndCodeSection</p>
			<p class="source-code">EndModule</p>
			<p class="source-code">   0| local.get $2</p>
			<p class="source-code">   8| local.get $2</p>
			<p class="source-code">  16| i32.add %[-2], %[-1]</p>
			<p class="source-code">  20| drop_keep $2 $1</p>
			<p class="source-code">  32| return</p>
			<p>The last five lines are how the stack<a id="_idIndexMarker215"/> interpreter executes the code.</p>
			<p>The <strong class="source-inline">wasm-interp</strong> tool provides the following options:</p>
			<p class="source-code"> </p>
			<p class="source-code">usage: wasm-interp [options] filename [arg]...</p>
			<p class="source-code"> </p>
			<p class="source-code">  read a file in the wasm binary format and run it in a stack-</p>
			<p class="source-code">  based</p>
			<p class="source-code">  interpreter.</p>
			<p class="source-code"> </p>
			<p class="source-code">examples:</p>
			<p class="source-code">  ...</p>
			<p class="source-code"> </p>
			<p class="source-code">options:</p>
			<p class="source-code">      --help                                Print this help </p>
			<p class="source-code">        message</p>
			<p class="source-code">      --version                             Print version </p>
			<p class="source-code">        information</p>
			<p class="source-code">  ...</p>
			<p>WABT provides a list of tools that make WASM<a id="_idIndexMarker216"/> easier to understand, debug, and convert into various human-readable formats. It is one of the most important toolkits that allows developers to explore the WASM better.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor068"/>Summary</h1>
			<p>In this chapter, we saw what WABT is and how to install and use various tools provided by it. The WABT tool is very important in the WebAssembly ecosystem as it provides an easy option to convert non-readable, compact binaries into readable, expanded source code. </p>
			<p>In the next chapter, we will explore various sections inside the WASM.</p>
		</div>
	</body></html>