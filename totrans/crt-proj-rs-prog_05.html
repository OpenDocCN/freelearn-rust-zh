<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Creating a Client-Side WebAssembly App Using Yew
                </header>
            
            <article>
                
<p>In this chapter, you will see how Rust can be used to build the frontend of a web application, as an alternative to using HTML, CSS, and JavaScript (typically using a JavaScript frontend framework, such as React) or another language generating JavaScript code (such as Elm or TypeScript).</p>
<p>To build a Rust app for a web browser, the Rust code must be translated to WebAssembly code, which can be supported by all modern web browsers. The capability to translate Rust code into <span>WebAssembly code </span>is now included in the stable Rust compiler.</p>
<p>To develop large projects, a web frontend framework is needed. In this chapter, the Yew framework will be presented. It is a framework that supports the development of frontend web applications, using the <strong>Model-View-Controller</strong> (<strong>MVC</strong>)<strong> </strong>architectural pattern, and generating WebAssembly code.</p>
<p><span>The following topics will be covered in this chapter:</span></p>
<ul>
<li>Understanding the MVC architectural pattern and its usage in web pages</li>
<li>Building WebAssembly apps using the Yew framework</li>
<li>How to use the Yew crate to create web pages designed with the MVC pattern (<kbd>incr</kbd> and <kbd>adder</kbd>) </li>
<li>Creating a web app having several pages with a common header and footer (<kbd>login</kbd> and <kbd>yauth</kbd>)</li>
<li>Creating a web app having both a frontend and a backend, in two distinct projects (<kbd>yclient</kbd> and <kbd>persons_db</kbd>)</li>
</ul>
<div class="packt_infobox">The frontend is developed using Yew, and the backend, which is an HTTP RESTful service, is developed using Actix web.</div>
<h1 id="uuid-9466da2b-0f70-4ece-8cb7-fccb0aa218de">Technical requirements</h1>
<p>This chapter assumes you have already read the previous chapters, also, prior knowledge of HTML is required.</p>
<p>To run the projects in this chapter, it is enough to install the generator of WebAssembly code (Wasm, for short). Probably the simplest way to do this is by typing <span>the following command:</span></p>
<pre><strong>cargo install cargo-web</strong></pre>
<p>After 13 minutes, your Cargo tool will be enriched by several commands. A few of which are as follows:</p>
<ul>
<li><kbd>cargo web build</kbd> (or <kbd>cargo-web build</kbd>): It builds Rust projects designed to run in a web browser. It is similar to the <kbd>cargo build</kbd> command, but for Wasm.</li>
<li><kbd>cargo web start</kbd> (or <kbd>cargo-web start</kbd>): It performs a <kbd>cargo web build</kbd> command, and then starts a web server where every time it is visited by a client, it sends a complete <span>Wasm </span>frontend app to the client. It is similar to the <kbd>cargo run</kbd> command, <span>but for serving Wasm apps.</span></li>
</ul>
<p><span>The complete source code for this chapter is in the <kbd>Chapter05</kbd> folder of the repository at: <a href="https://github.com/PacktPublishing/Rust-2018-Projects">https://github.com/PacktPublishing/</a><a href="https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers">Creative-Projects-for-Rust-Programmers</a>.</span></p>
<h1 id="uuid-1fd4df4c-3c87-44b6-b7ce-af3a91dd1772">Introducing Wasm</h1>
<p>Wasm is a powerful new technology to deliver interactive applications. Before the advent of the web, there were already many developers building client/server applications, where the client apps ran on a P<span>C (typically with Microsoft</span><span> </span>Windows) and the server apps ran on a company-owned system (typically with NetWare, OS/2, Windows NT, or Unix). In such systems, developers could choose their favorite language for the client app. Some people used Visual Basic, others used FoxPro or Delphi, and many other languages were in wide use.</p>
<p>However<span>,</span> for such systems,<span> the deployment of updates was a kind of hell, because of several possible issues, such as ensuring that every client PC had the proper runtime system and that all clients got the updates at the same time. </span>These problems were solved by JavaScript running in web browsers, as it is a ubiquitous platform on which frontend software could be downloaded and executed. This had some drawbacks though: developers were forced to use <span>HTML + CSS + JavaScript to</span> develop <span>frontend </span>software, and sometimes such software had poor performance.</p>
<p>Here comes Wasm, which is a machine-language-like programming language, like Java bytecode or Microsoft .NET CIL code, but it is a standard accepted by all major web browsers. Version 1.0 of its specification appeared in October 2017, and in 2019 it appears that already more than 80% of web browsers <span>running </span>in the world support it. This means that it can be more efficient and that it can be rather easily generated from several programming languages, including Rust.</p>
<p>So, if Wasm is set as the target architecture of the Rust compiler, a program written in Rust can be run on any major modern web browser.</p>
<h1 id="uuid-d7e4b9ea-b5cb-427e-b074-fd2b4aa6788f">Understanding the MVC architectural pattern</h1>
<p>This chapter is about creating web apps. So, to make things more concrete, let's look straight away at<span> </span>two toy web applications named <kbd>incr</kbd> and <kbd>adder</kbd>.</p>
<h2 id="uuid-b98a50f8-654c-4996-8b2e-899b161a5499">Implementing two toy web apps</h2>
<p>To run the first toy application, let's take the following steps:</p>
<ol>
<li>Go into the <kbd>incr</kbd> folder and type <kbd>cargo web start</kbd>.</li>
<li>After a few minutes, a message will appear on the console, ending with the following line:</li>
</ol>
<pre style="padding-left: 60px"><strong>You can access the web server at `http://127.0.0.1:8000`.</strong></pre>
<ol start="3">
<li>Now, in the address box of a web browser, type: <span><kbd>127.0.0.1:8000</kbd> or <kbd>localhost:8000</kbd>, and immediately you will see the following contents:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c46a2847-2d66-493e-8ca1-7ad985362d8c.png" style="width:20.08em;height:2.33em;"/></p>
<ol start="4">
<li>Click on the two buttons, or select the following textbox and then press the <em>+</em> or the <em>0</em> keys on the keyboard.</li>
</ol>
<div class="packt_infobox">
<ul>
<li>If you click once on the <span class="packt_screen">Increment</span> button, the contents of the box to the right change from <span class="packt_screen">0</span> to <span class="packt_screen">1</span>.</li>
<li>If you click another time, it changes to <span class="packt_screen">2</span>, and so on.</li>
<li>If you click on the <span class="packt_screen">Reset</span> button, the value changes to <span class="packt_screen">0</span> (zero).</li>
<li>If you select the textbox by clicking on it and then press the <em>+</em> key, you increment the number like the <span class="packt_screen">Increment</span> button does. Instead, if you press the <em>0</em> key, the number is set to zero.</li>
</ul>
</div>
<ol start="5">
<li>To stop the server, go to the console and press <em>Ctrl </em>+ <em>C</em>.</li>
<li>To run the <kbd>adder</kbd> app, go into the <kbd>adder</kbd> folder and type<span> </span><kbd>cargo web start</kbd><span>.</span></li>
<li><span>Similarly, for the other app, when the server app has started, you can refresh your web browser page and you will see the following page:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/453816c4-97e3-48da-9d8d-2aa92aab4a0b.png" style="width:16.00em;height:7.67em;"/></p>
<ol start="8">
<li>Here, you can insert a number in the first box, to the right of the <span class="packt_screen">Addend 1</span> label, another number in the second box, and then press the <span class="packt_screen">Add</span> button. After that, you will see the sum of those numbers in the textbox at the bottom, which has turned from yellow to light green, as in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3c8ac8a3-0f08-45ce-9ef6-b399beeedd28.png" style="width:16.50em;height:7.75em;"/></p>
<p>After the addition, the <span class="packt_screen">Add</span> button has become disabled. If one of the first two boxes is empty, the sum fails and nothing happens. Also, if you change the value of any of the two first boxes, the <span class="packt_screen">Add</span> button becomes enabled, and the last textbox becomes empty and yellow.</p>
<h2 id="uuid-b615ebb4-c3e4-457c-93af-f8ad09f537eb">What is the MVC pattern?</h2>
<p>Now that we have seen some very simple web applications, we can explain what the MVC architectural pattern is using these apps as an example. The MVC pattern is an architecture regarding event-driven interactive programs.</p>
<p>Let's see what event-driven<span> </span>interactive<em> </em>programs are. The word <strong>interactive</strong> is the opposite of <strong>batch</strong>. A batch program is a program in which the user prepares all the input at the beginning, and then the program runs without asking for further input. <span>Instead, a</span>n interactive program has the following steps:</p>
<ul>
<li>Initialization.</li>
<li>Waiting for some actions from the user.</li>
<li>When the user acts on an input device, the program processes the related input, and then goes to the preceding step, to wait for further input.</li>
</ul>
<p>For example, console command interpreters are interactive programs, and all web apps are <span>interactive too.</span></p>
<p>The phrase <em>event-driven</em> means that the<span> application, after initialization, does nothing until the user performs something on the user interface. When the user acts on an input device, the app processes such inputs and updates the screen only as a reaction to the user input. Most web applications are event-driven. The main exceptions are games and virtual reality or augmented reality environments, where animations go on even if the user does nothing.</span></p>
<p class="mce-root">Our examples in this chapter are all event-driven interactive programs, as after initialization, they do something only when the user clicks with the mouse (or touches the touchscreen) or presses any key on the keyboard. Some such clicks and key presses cause a change on the screen. Therefore, the MVC architecture can be applied to these example projects.</p>
<p>There are several dialects of this pattern. The one used by Yew derives from the one implemented by the Elm language, and so it is named the <strong>Elm Architecture</strong>.</p>
<h2 id="uuid-f4e142fa-703a-4818-ab8c-c921f202c41b">The model</h2>
<p class="mce-root">In any MVC program, there is a data structure, named <kbd>model</kbd>, that contains all the dynamic data required to represent the user interface.</p>
<p class="mce-root">For example, in the <kbd>incr</kbd> app, the value of the number contained in the box to the right is required to represent the box, and it can change at runtime. Hence, that numeric value must be in the model.</p>
<p class="mce-root">Here, the width and height of the browser window are usually not required to generate the HTML code and so they shouldn't be a part of the model. Also, the sizes and texts of the buttons shouldn't be a part of the model, but for another reason: they cannot change at runtime in this app. Though, if it were an internationalized app, all the texts should be in the model too.</p>
<p class="mce-root">In the <kbd>adder</kbd> app, the model should contain only the three values contained in the three textboxes. It doesn't matter that two of them are directly inputted by the user and the third one is calculated. The labels and the background color of the textboxes shouldn't be a part of the model.</p>
<h2 id="uuid-5ba45bed-3e7e-4fc5-a90e-3ae015fc51ab" class="mce-root">The view</h2>
<p class="mce-root">The next portion of the MVC architecture is the <strong>view</strong>. It is a specification of how to represent (or render) the graphical contents of the screen, depending on the value of the model. It can be a declarative specification, such as pure HTML code, or a procedural specification, such as some JavaScript or Rust code, or a mix of them.</p>
<p class="mce-root">For example, in the <kbd>incr</kbd> app, the view shows two push-buttons and one read-only textbox, whereas, in the <kbd>adder</kbd> app, the view shows three labels, three textboxes, and one push-button.</p>
<p class="mce-root">All the shown push-buttons have a constant appearance, but the views must change the display of the numbers when the models change.</p>
<h2 id="uuid-b93586a5-9de9-499d-872f-3660689e85d3" class="mce-root">The controller</h2>
<p class="mce-root">The last portion of the MVC architecture is the <em>controller</em>. It is always a routine or a set of routines that are invoked by the view when the user, <span>using an input device,</span> interacts with the app. When a user performs an action with an input device, all the view has to do is to notify the controller that the user has performed that action, specifying which action (for example, which mouse key has been pressed), and where (for example, in which position of the screen).</p>
<p class="mce-root">In the <kbd>incr</kbd> app, the three possible input actions are as follows:</p>
<ul>
<li class="mce-root">A click on the <span class="packt_screen">Increment</span> button</li>
<li class="mce-root">A click on the <span class="packt_screen">R</span><span class="packt_screen">eset</span> button</li>
<li class="mce-root">A press of a key on the keyboard when the textbox is selected</li>
</ul>
<p>Usually, it is also possible to press a push-button using the keyboard, but such an action can be considered equivalent to a mouse click, and so a single input action type is notified for each button.</p>
<p class="mce-root">In the <kbd>adder</kbd> app, the three possible input actions are as follows:</p>
<ul>
<li class="mce-root">A change of the value in the <span class="packt_screen">Addend 1</span> textbox</li>
<li class="mce-root">A change of the value in the <span class="packt_screen">Addend 2</span> textbox</li>
<li class="mce-root">A click on the <span class="packt_screen">Add</span> button</li>
</ul>
<p>It is possible to change the value of a textbox in several ways:</p>
<ul>
<li class="mce-root">By typing when no text is selected, inserting additional characters</li>
<li class="mce-root">By typing when some text is selected, and so replacing the selected text with a character</li>
<li class="mce-root">By pasting some text from the clipboard</li>
<li class="mce-root">By dragging and dropping some text from another element of the screen</li>
<li class="mce-root">By using the mouse on the up-down spinner</li>
</ul>
<p class="mce-root">We are not interested in these, because they are handled by the browser or by the framework. All that matters for application code is that when the user performs an input action, a textbox changes its value.</p>
<p class="mce-root">The job of the controller is just to use such input information to update the model. When the model is completely updated, the framework notifies the view about the need to refresh the look of the screen, taking into account the new values of the model.</p>
<p class="mce-root">In the case of the <kbd>incr</kbd><em> </em>app, the controller, when it is notified of the pressing of the <span class="packt_screen">Increment</span> button, increments the number contained in the model; when it is notified of the pressing of the <span class="packt_screen">Reset</span> button, it sets to zero that number in the model; when it is notified of the pressing of a key on the textbox, it checks whether the pressed key is <em>+</em>, or <em>0</em>, or something else, and the appropriate change is applied to the model. After such changes, the view is notified to update the display of such a number.</p>
<p class="mce-root">In the case of the <kbd>adder</kbd> app, the controller, when it is notified of the change of the <span class="packt_screen">Addend 1</span> textbox, updates the model with the new value contained in the edit box. Similar behavior happens for the <span class="packt_screen">Addend 2</span> textbox; and when the controller is notified of the pressing of the <span class="packt_screen">Add</span> button, it adds the two addends contained in the model and stores the result in the third field of the model. After such changes, the view is notified to update the display of such a result.</p>
<h2 id="uuid-d57d93a6-1a22-45fc-8345-336f3e6c82cd" class="mce-root">View implementation</h2>
<p class="mce-root">Regarding web pages, the representation of pages is usually made up of HTML code, and so, using the Yew framework, the view function must generate HTML code. Such generations contain in themselves the constant portions of HTML code, but they also access the model to get the information that can change at runtime.</p>
<p class="mce-root">In the <kbd>incr</kbd> app, the view composes the HTML code that defines two buttons and one read-only numeric <em>input</em> element and puts in such an <em>input</em> element the value taken from the model. The view includes the handling of the HTML <em>click</em> events on the two buttons by forwarding them to the controller.</p>
<p class="mce-root">In the <kbd>adder</kbd> app, the view composes the HTML code that defines three labels, three numeric input elements, and one button, and puts in the last <em>input</em> element the value taken from the model. It includes the handling of the HTML <em>input</em> events in the first two textboxes and the <em>click</em> event on the button, by forwarding them to the controller. Regarding the first two textbox events, the values contained in the boxes are forwarded to the controller.</p>
<h2 id="uuid-d9e3c005-1d8f-4017-97f3-252aad18d78a" class="mce-root">Controller implementation</h2>
<p class="mce-root">Using Yew, the controller is implemented by an <em>update</em> routine, which processes the messages regarding user actions coming from the view and uses such input to change the model. After the controller has completed all the required changes to the model, the view must be notified to apply the changes of the model to the user interface.</p>
<p class="mce-root">In some frameworks, such as in Yew, such an invocation of the view is automatic; that mechanism has the following steps:</p>
<ul>
<li class="mce-root"><span>For any user action handled by the view,</span> the framework calls the <kbd>update</kbd> function, that is, the controller. In this call, the framework passes to the controller the details regarding the user action; for example, which value has been typed in a textbox.</li>
<li>The controller, typically, changes the state of the model.</li>
<li>If the controller has successfully applied some changes to the model, the framework calls the view function, which is the <em>view</em> of the MVC architecture.</li>
</ul>
<h2 id="uuid-3adc4f87-1298-4e9f-953c-dc43f1570194" class="mce-root">Understanding the MVC architecture</h2>
<p class="mce-root">The general flow of control of the MVC architecture is shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e1ea5bec-c3d3-43d2-963f-a0a3f4c54ed9.png" style="width:27.83em;height:25.33em;"/></p>
<p>The iteration of every user action is this sequence of operations:</p>
<ol>
<li class="mce-root">The user sees a static representation of graphical elements on the screen.</li>
<li class="mce-root">The user acts on the graphical elements using an input device.</li>
<li class="mce-root">The view receives a user action and notifies the controller.</li>
<li class="mce-root">The controller updates the model.</li>
<li class="mce-root">The view reads the new state of the model to update the contents of the screen.</li>
<li>The user sees the new state of the <span>screen.</span></li>
</ol>
<p class="mce-root">The main concepts of the MVC architecture are as follows:</p>
<ul>
<li>All the mutable data that is needed to <span>correctly</span> build the display<span> </span>must be in a single data structure, named <strong>model</strong>. The model may be associated with some code, but such code does not get direct user input, nor does it give output to the user. It may access files, databases, or other processes, though. Because the model does not interact directly with the user interface, the code implementing the model shouldn't change if the application user interface is ported from text mode to GUI/web/mobile.</li>
<li>The logic that draws on the display and captures user input is named the <em>view</em>. The view, of course, must know about screen rendering, input devices and events, and also about the model. Though, the view just <em>reads</em> the model, it never changes it directly. When an interesting event happens, the view notifies the controller of that event.</li>
<li>When the controller is notified of an interesting event by the view, it changes the model accordingly, and when it has finished, the framework notifies the view to refresh itself using the new state of the model.</li>
</ul>
<h1 id="uuid-869aade6-925d-4e62-960c-97398e399569">Project overview</h1>
<p>This chapter will present four projects that will get more and more complex. You have already seen the first two projects in action: <kbd>incr</kbd> and <kbd>adder</kbd>. The third project, named <kbd>login</kbd>, shows how to create a login page for authentication on a website.</p>
<p>The fourth project, named <kbd>yauth,</kbd> extends the <kbd>login</kbd> project adding the CRUD handling of a list of persons. Its behavior is almost identical to that of the <kbd>auth</kbd> project in <a href="27918752-3cb8-4b2f-9508-a439ad1745ab.xhtml">Chapter 4</a>, <em>Creating a Full Server-Side Web App</em>. Each project will require from 1 to 3 minutes to download and compile from scratch.</p>
<h2 id="uuid-e7f013c3-f60d-4349-9a17-dee7bfaaa4bc">Getting started</h2>
<p>To start all the machinery, a very simple statement <span>is enough –</span> the body of the<span> </span><kbd>main</kbd><span> </span>function:</p>
<pre> yew::start_app::&lt;Model&gt;();</pre>
<p>It creates a web app based on the specified<span> </span><kbd>Model</kbd>, starts it, and waits on the default TCP port. Of course, the TCP port can be changed. It is a server that will serve the app to any browser navigating to it.</p>
<h1 id="uuid-f8050763-f942-4959-aec6-a9f4b12c7dd0">The incr app</h1>
<p>Here, we'll see the implementation of the <kbd>incr</kbd> project, which we already saw how to build and use. The only dependency is on the Yew framework, and so, the TOML file contains the following line:</p>
<pre>yew = "0.6"</pre>
<p>All the source code is in the <kbd>main.rs</kbd> file. The model is implemented by the following simple declaration:</p>
<div>
<pre><span>struct</span><span> Model {<br/></span><span>    value: </span><span>u64</span><span>,<br/></span><span>}<br/></span></pre></div>
<p>It just has to be a struct that will be instantiated by the framework, read by the view, and read and written by the controller. Its name and the name of its fields are arbitrary.</p>
<p>Then the possible notifications from the view to the controller must be declared as an <kbd>enum</kbd> type. Here is that of <kbd>incr</kbd>:</p>
<pre>enum Msg {<br/>    Increment,<br/>    Reset,<br/>    KeyDown(String),<br/>}</pre>
<p>Also, here, the names are arbitrary:</p>
<ul>
<li><kbd>Msg</kbd> is short for <em>message</em>, as such notifications are in a sense messages from the view to the controller.</li>
<li>The <kbd>Increment</kbd> <span>message notifies a click on the <span class="packt_screen">Increment</span> button.</span><span>The</span> <kbd>Reset</kbd> <span>message notifies a click on the <span class="packt_screen">Reset</span> button.</span></li>
<li><span>The</span> <kbd>KeyDown</kbd> <span>message notifies a press of any key on the keyboard; its argument communicates which key has been pressed.</span></li>
</ul>
<p>To implement the controller, the <kbd>yew::Component</kbd> trait must be implemented for our model. The code for our project is as follows:</p>
<pre>impl Component for Model {<br/>    type Message = Msg;<br/>    type Properties = ();<br/>    fn create(_: Self::Properties, _: ComponentLink&lt;Self&gt;) -&gt; Self {<br/>        Self { value: 0 }<br/>    }<br/>    fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender { ... }<br/>}</pre>
<p>The required implementations are as follows:</p>
<ul>
<li><kbd>Message</kbd>: It is the <kbd>enum</kbd> defined before, describing all possible notifications from the view to the controller.</li>
<li><kbd>Properties</kbd>: It is not used in this project. When not used, it must be an empty tuple.</li>
<li><kbd>create</kbd>: It is invoked by the framework to let the controller initialize the model. It can use two arguments, but here we are not interested in them, and it must return an instance of the model with its initial value. As we want to show the number zero at the beginning, we set <kbd>value</kbd> to <kbd>0</kbd>.</li>
<li><kbd>update</kbd>: It is invoked by the framework any time the user acts on the page in some way handled by the view. The two arguments are the mutable model itself (<kbd>self</kbd>) and the notification from the view (<kbd>msg</kbd>). This method should return a value of type <kbd>ShouldRender</kbd>, but a <kbd>bool</kbd> value will be good. Returning <kbd>true</kbd> means that the model has been changed, and so a refresh of the view is required. Returning <kbd>false</kbd> <span>means that the model has not been changed, and so a refresh of the view would be a waste of time.</span></li>
</ul>
<p>The <kbd>update</kbd> method contains a <kbd>match</kbd> on the message type. The first two message types are quite simple:</p>
<pre>match msg {<br/>    Msg::Increment =&gt; {<br/>        self.value += 1;<br/>        true<br/>    }<br/>    Msg::Reset =&gt; {<br/>        self.value = 0;<br/>        true<br/>    }</pre>
<p>If the <kbd>Increment</kbd> message is notified, the value is incremented. If<span> the </span><kbd>Reset</kbd><span> message is notified, the value is zeroed. In both cases, the view must be refreshed.</span></p>
<p>The handling of the keypress is a bit more complex:</p>
<pre>Msg::KeyDown(s) =&gt; match s.as_ref() {<br/>    "+" =&gt; {<br/>        self.value += 1;<br/>        true<br/>    }<br/>    "0" =&gt; {<br/>        self.value = 0;<br/>        true<br/>    }<br/>    _ =&gt; false,<br/>}</pre>
<p>The <kbd>KeyDown</kbd> match arm assigns the key pressed to the <kbd>s</kbd> variable. As we are interested only in two possible keys, there is a nested <kbd>match</kbd> statement on the <kbd>s</kbd> variable. For the two-handled keys (<kbd>+</kbd> and <kbd>0</kbd>), the model is updated, and <kbd>true</kbd> is returned to refresh the view. For any other key pressed, nothing is done.</p>
<p>To implement the view part of MVC, the <kbd>yew::Renderable</kbd> trait must be implemented for our model. The only required method is <kbd>view</kbd>, which gets an immutable reference to the model, and returns an object that represents some HTML code, but that is capable of reading the model and notifying the controller:</p>
<pre>impl Renderable&lt;Model&gt; for Model {<br/>    fn view(&amp;self) -&gt; Html&lt;Self&gt; {<br/>        html! { ... }<br/>    }<br/>}</pre>
<p>The body of such a method is constructed with the powerful <kbd>yew::html</kbd> macro. Here is the body of such a macro invocation:</p>
<pre>&lt;div&gt;<br/>    &lt;button onclick=|_| Msg::Increment,&gt;{"Increment"}&lt;/button&gt;<br/>    &lt;button onclick=|_| Msg::Reset,&gt;{"Reset"}&lt;/button&gt;<br/>    &lt;input<br/>        readonly="true",<br/>        value={self.value},<br/>        onkeydown=|e| Msg::KeyDown(e.key()),<br/>    /&gt;<br/>&lt;/div&gt;</pre>
<p>It looks very similar to the actual HTML code. It is equivalent to the following HTML pseudo-code:</p>
<pre>&lt;div&gt;<br/>    &lt;button onclick="notify(Increment)"&gt;Increment&lt;/button&gt;<br/>    &lt;button onclick="notify(Reset)"&gt;Reset&lt;/button&gt;<br/>    &lt;input<br/>        readonly="true"<br/>        value="[value]"<br/>        onkeydown="notify(KeyDown, [key])"),<br/>    /&gt;<br/>&lt;/div&gt;</pre>
<p>Notice that at any HTML event, in the HTML pseudo-code, a JavaScript function is invoked (here, named <kbd>notify</kbd>). Instead, in Rust, there is a closure that returns a message for the controller. Such a message must have the arguments of the appropriate type. While the <kbd>onclick</kbd> event has no arguments, the <kbd>onkeydown</kbd> event has one argument, captured in the <kbd>e</kbd> variable, and by calling the <kbd>key</kbd> method on that argument, the pressed key is passed to the controller.</p>
<p>Also notice in the HTML pseudo-code the <kbd>[value]</kbd> symbol, which at runtime will be replaced by an actual value.</p>
<p>Finally, notice that the body of the macro has three features that differentiate it from HTML code:</p>
<ul>
<li>All the arguments of HTML elements must end with a comma.</li>
<li>Any Rust expression can be evaluated inside HTML code, as long as it is enclosed in braces.</li>
<li>Literal strings are not allowed in this HTML code, so they must be inserted as Rust literals (by including them in braces).</li>
</ul>
<h1 id="uuid-8755b4d7-bc72-433d-845c-6c3f062abc98">The adder app</h1>
<p>Here, we'll see the implementation of the <kbd>adder</kbd> project, which we already saw how to build and use. Only that which differentiates it from the <kbd>incr</kbd> project will be examined.</p>
<p>First of all, there is a problem with the <kbd>html</kbd> macro expansion recursion level. It is so deep that it must be increased using the following directives at the beginning of the program:</p>
<pre>#![recursion_limit = "128"]<br/>#[macro_use]<br/>extern crate yew;</pre>
<p>Without them, a compilation error is generated. With more complex views, an even larger limit is required. The model contains the following fields:</p>
<pre>addend1: String,<br/>addend2: String,<br/>sum: Option&lt;f64&gt;,</pre>
<p>They represent the following, respectively:</p>
<ul>
<li>The text inserted in the first box (<kbd>addend1</kbd>).</li>
<li><span>The text inserted in the second box (<kbd>addend2</kbd>).</span></li>
<li><span>The number calculated and to be displayed in the third box, if the calculation was performed and was successful, or nothing otherwise.</span></li>
</ul>
<p>The handled events (that is, the messages) are as follows:</p>
<pre> ChangedAddend1(String),<br/> ChangedAddend2(String),<br/> ComputeSum,</pre>
<p>They represent the following, respectively:</p>
<ul>
<li>Any change to the contents of the first box, with the new value contained in the box (<kbd>ChangedAddend1</kbd>).</li>
<li>Any change to the contents of the second box, with its value (<kbd><span>ChangedAddend2</span></kbd>).</li>
<li>A click on the <span class="packt_screen">Add</span> button.</li>
</ul>
<p>The <kbd>create</kbd> function initializes the three fields of the model: the two addends are set to empty strings, and the <kbd>sum</kbd> field is set to <kbd>None</kbd>. With these initial values, no number is displayed in the <span class="packt_screen">Sum</span> textbox.</p>
<p>The <kbd>update</kbd> function processes the three possible messages. For the <kbd>ComputeSum</kbd> message, it does the following:</p>
<pre>self.sum = match (self.addend1.parse::&lt;f64&gt;(), self.addend2.parse::&lt;f64&gt;()) {<br/>    (Ok(a1), Ok(a2)) =&gt; Some(a1 + a2),<br/>    _ =&gt; None,<br/>};</pre>
<p>The <kbd>addend1</kbd> and <kbd>addend2</kbd> fields of the model are parsed to convert them into numbers. If both conversions are successful, the first arm matches, and so the <kbd>a1</kbd> and <kbd>a2</kbd> values are added, and their sum is assigned to the <kbd>sum</kbd> field. If some conversion fails, <kbd>None</kbd> is assigned to the sum field.</p>
<p>The arm regarding the first addend is as follows:</p>
<pre>Msg::ChangedAddend1(value) =&gt; {<br/>    self.addend1 = value;<br/>    self.sum = None;<br/>}</pre>
<p>The current value of the textbox is assigned to the <kbd>addend1</kbd> field of the model, and the <kbd>sum</kbd> field is set to <kbd>None</kbd>. Similar behavior is performed for a change to the other addend.</p>
<p>Let's see the most interesting parts of the <kbd>view</kbd> method:</p>
<pre> let numeric = "text-align: right;";</pre>
<p>It assigns to a Rust variable a snippet of CSS code. Then, the textbox for the first <kbd>addend</kbd> is created by the following code:</p>
<pre>&lt;input type="number", style=numeric,<br/>    oninput=|e| Msg::ChangedAddend1(e.value),/&gt;</pre>
<p>Notice that to the <kbd>style</kbd> attribute, the value of the <kbd>numeric</kbd> variable is assigned. The values of these attributes are just Rust expressions.</p>
<p>The <kbd>sum</kbd> textbox is created by the following code:</p>
<pre>&lt;input type="number",</pre>
<pre><br/>    style=numeric.to_string()<br/>        + "background-color: "<br/>        + if self.sum.is_some() { "lightgreen;" } else { "yellow;" },<br/>         readonly="true", value={<br/>        match self.sum { Some(n) =&gt; n.to_string(), None =&gt; "".to_string() }<br/>    },<br/>/&gt;</pre>
<p>The <kbd>style</kbd> attribute is composed by concatenating the <kbd>numeric</kbd> string seen before with the background color. Such a color is light green if <kbd>sum</kbd> has a numeric value, or yellow if it is <kbd>None</kbd>. Also, the <kbd>value</kbd> attribute is assigned using an expression, to assign an empty string if <kbd>sum</kbd> is <kbd>None</kbd>.</p>
<h1 id="uuid-48ec4614-f5d7-427d-849c-9d342f41e0ba">The<span> </span>login app</h1>
<p>So far, we have seen that an app contains just one model struct, one <kbd>enum</kbd> of messages, one <kbd>create</kbd> function, one <kbd>update</kbd> <span>method</span>, and one <kbd>view</kbd> method. This is good for very simple apps, but with more complex apps, this simple architecture becomes unwieldy. There is a need to separate different portions of the app in different components, where each component is designed with the MVC pattern and so it has its own model, controller, and view.</p>
<p>Typically, but not necessarily, there is a general component that contains the portions of the app that remain the same for all of the app:</p>
<ul>
<li>A header with a logo, a menu, and the name of the current user</li>
<li>A footer containing copyright information and contact information</li>
</ul>
<p>And then in the middle of the page, there is the inner part (also named the <em>body</em>, although it is not the <kbd>body</kbd> HTML element). This inner part contains the real information of the app and is one of many possible components or forms (or pages):</p>
<ol>
<li>Let's run the <kbd>login</kbd> app by typing <kbd>cargo web start</kbd> in its folder.</li>
<li>When navigating to <kbd>localhost:8000</kbd><span>, the following page appears:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bd6d7092-fd8e-49fe-a4db-bb6c4c68ab50.png" style="width:18.08em;height:12.67em;"/></p>
<p>There are two horizontal lines. The part above the first line is meant to be a header, which must remain for the whole app. <span>The part underneath the second line is meant to be a footer, which must remain for the whole app, too. The median part is the <kbd>Login</kbd> component, which appears only when the user must be authenticated. This portion will be replaced by other components when the user is authenticated.</span></p>
<p>First of all, let's see some authentication failures:</p>
<ul>
<li>If you click on <span class="packt_screen">Log in</span> straightaway, a message box appears saying: <span class="packt_screen">User not found</span>. The same happens if you type some random characters in the <span class="packt_screen">User name</span> textbox. The only allowed user names are <kbd>susan</kbd> and <kbd>joe</kbd>.</li>
<li>If you insert one of the two allowed user names, and then you click on <span class="packt_screen">Log in</span>, you get the message <span class="packt_screen">Invalid password for the specified user</span>.</li>
<li>The same happens if you type some random <span>characters in the <span class="packt_screen">Password</span> textbox. The only allowed passwords are <kbd>xsusan</kbd> for the user <kbd>susan</kbd>, and <kbd>xjoe</kbd> for the user <kbd>joe</kbd>. </span>If you type <kbd>susan</kbd> and then <kbd>xsusan</kbd>, just before clicking on <span class="packt_screen">Log in</span>, you will see the following:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18689f3c-6ab5-4d13-bcdb-802598f81924.png" style="width:17.92em;height:12.92em;"/> </p>
<p style="padding-left: 60px">And just after, you will see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-674 image-border" src="assets/fd96a096-7cb2-475f-80a2-f4b36a4cf74f.png" style="width:17.75em;height:12.25em;"/></p>
<p>Three things have changed:</p>
<ul>
<li>At the right of the label—<span class="packt_screen">Current user</span>—the blue text <span class="packt_screen">---</span> has been replaced by <span class="packt_screen">susan</span>.</li>
<li><span>At the right of that blue text, the <span class="packt_screen">Change User</span> </span>button has appeared.</li>
<li>Between the two horizontal lines, all the HTML elements have been replaced by the large text reading <span class="packt_screen">Page to be implemented</span>. Of course, this situation would represent a case in which the user has been successfully authenticated and is using the rest of the app.</li>
</ul>
<p>If you were to click the <span class="packt_screen">Change User</span> button, you will get the following page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/29b734ef-1c56-496b-89ba-712832a89eab.png" style="width:17.67em;height:12.75em;"/></p>
<p>It is similar to the first page, but the name <span class="packt_screen">susan</span> appears both as <span class="packt_screen">Current user</span>, and as <span class="packt_screen">User name</span>.</p>
<h2 id="uuid-19a2ec56-bb1a-4080-a734-33a618a8bb08">Organization of the project</h2>
<p>The source code of this project has been split into three files (which you will find in the book's GitHub repository at <kbd>Chapter05/login/src/db_access.rs</kbd>:</p>
<ul>
<li><kbd>db_access.rs</kbd>: Contains a stub of a user directory to handle authentication</li>
<li><kbd>main.rs</kbd>: Contains the one-line <kbd>main</kbd> function, and an MVC component that handles the header and the footer of the page, and delegates the inner section to the authentication component</li>
<li><kbd>login.rs</kbd>: <span>Contains </span><span>the MVC component to handle the authentication, to be used as an inner section of the</span> main component</li>
</ul>
<h3 id="uuid-5208e886-7286-466d-9b20-f8e5a794b835">The db_access.rs file</h3>
<p>The <kbd>db_access</kbd> module is a subset of that of the previous chapter. It declares a <kbd>DbConnection</kbd> struct that simulates a connection to a database. Actually, for simplicity, it contains just <kbd>Vec&lt;User&gt;</kbd>, where <kbd>User</kbd> is an account of the app:</p>
<pre>#[derive(PartialEq, Clone)]<br/>pub struct DbConnection {<br/>    users: Vec&lt;User&gt;,<br/>}</pre>
<p>The definition of the <kbd>User</kbd> type is this:</p>
<pre>pub enum DbPrivilege {<br/>    CanRead,<br/>    CanWrite,<br/>}<br/><br/>pub struct User {<br/>    pub username: String,<br/>    pub password: String,<br/>    pub privileges: Vec&lt;DbPrivilege&gt;,<br/>}</pre>
<p>Any user of the app has a name, a password, and some privileges. In this simple system, there are only two possible privileges:</p>
<ul>
<li><kbd>CanRead</kbd>, which means that the user can read all of the database</li>
<li><kbd>CanWrite</kbd>, which means that the user can change all of the database (that is, inserting, updating, and deleting records)</li>
</ul>
<p>Two users are wired in:</p>
<ul>
<li><kbd>joe</kbd> with the password <kbd>xjoe</kbd>, capable only of reading from the database</li>
<li><kbd>susan</kbd> with the password <kbd>xsusan</kbd>, capable of reading and writing the data</li>
</ul>
<p>The only functions are as follows:</p>
<ul>
<li><kbd>new</kbd>, to create a <kbd>DbConnection</kbd>:</li>
</ul>
<pre style="padding-left: 60px">pub fn new() -&gt; DbConnection {<br/>    DbConnection {<br/>        users: vec![<br/>            User {<br/>                username: "joe".to_string(),<br/>                password: "xjoe".to_string(),<br/>                privileges: vec![DbPrivilege::CanRead],<br/>            },<br/>            User {<br/>                username: "susan".to_string(),<br/>                password: "xsusan".to_string(),<br/>                privileges: vec![DbPrivilege::CanRead, <br/>                 DbPrivilege::CanWrite],<br/>            },<br/>        ],<br/>    }<br/>}</pre>
<ul>
<li><kbd>get_user_by_username</kbd>, to get a reference to the user having the specified name, or <kbd>None</kbd> if there is no user with that name:</li>
</ul>
<pre style="padding-left: 60px">pub fn get_user_by_username(&amp;self, username: &amp;str) -&gt; Option&lt;&amp;User&gt; {<br/>    if let Some(u) = self.users.iter().find(|u| <br/>     u.username == username) {<br/>        Some(u)<br/>    } else {<br/>        None<br/>    }<br/>}</pre>
<p>Of course, first, we will create a <kbd>DbConnection</kbd> object, using the <kbd>new</kbd> function, and then we will get a <kbd>User</kbd> from that object, using the <kbd>get_user_by_username</kbd> method.</p>
<h3 id="uuid-fa651772-9dcf-4a4e-bc2d-b91f349b6a36">The main.rs file</h3>
<p>The <kbd>main.rs</kbd> file begins with the following declarations:</p>
<pre>mod login;<br/><br/>enum Page {<br/>    Login,<br/>    PersonsList,<br/>}</pre>
<p>The first declaration imports the <kbd>login</kbd> module, which will be referenced by the <kbd>main</kbd> module. Any inner section module must be imported here.</p>
<p>The second statement declares all the components that will be used as inner sections. Here, we have only the authentication component (<kbd>Login</kbd>) and a component that is not yet implemented (<kbd>PersonsList</kbd>).</p>
<p><span>Then, there is the model of the MVC component of the main page:</span></p>
<pre>struct MainModel {<br/>    page: Page,<br/>    current_user: Option&lt;String&gt;,<br/>    can_write: bool,<br/>    db_connection: std::rc::Rc&lt;std::cell::RefCell&lt;DbConnection&gt;&gt;,<br/>}</pre>
<p>As a convention, the name of any model ends with <kbd>Model</kbd>:</p>
<ul>
<li>The first field of the model is the most important one. It represents which inner section (or <kbd>page</kbd>) is currently active.</li>
<li>The other fields contain global information, that is, information useful for displaying the header, the footer, or that must be shared with the inner components.</li>
<li>The <kbd>current_user</kbd><span> field contains the name of the logged-in user, or</span> <kbd>None</kbd><span> if no user is logged in.</span></li>
<li><span>The</span> <kbd>can_write</kbd><span> flag is a simplistic description of user privileges; here, both users can read, but only one can also write, and so this flag is</span> <kbd>true</kbd> <span>when they are logged in.</span></li>
<li>The <kbd>db_connection</kbd><span> field is a reference to the database stub. It must be shared with an inner component, and so it is implemented as a reference-counted smart pointer to</span> <kbd>RefCell</kbd><span>, containing the actual</span> <kbd>DbConnection</kbd><span>. Using this wrapping, any object can be shared with other components, as long as one thread at a time accesses them.</span></li>
</ul>
<p>The possible notifications from the view to the controller are these:</p>
<pre>enum MainMsg {<br/>    LoggedIn(User),<br/>    ChangeUserPressed,<br/>}</pre>
<p>Remember that the footer has no elements that can get input, and for the header, there is only the <span class="packt_screen">Change User</span> button that can get input, when it is visible. By pressing such a button, the <kbd>ChangeUserPressed</kbd> message is sent.</p>
<p>So, it appears there is no way to send the <kbd>LoggedIn</kbd> message! Actually, <span>the <kbd>Login</kbd> component </span>can send it to the main component.</p>
<p>The update function of the controller has the following body:</p>
<pre>match msg {<br/>    MainMsg::LoggedIn(user) =&gt; {<br/>        self.page = Page::PersonsList;<br/>        self.current_user = Some(user.username);<br/>        self.can_write = user.privileges.contains(&amp;DbPrivilege::CanWrite);<br/>    }<br/>    MainMsg::ChangeUserPressed =&gt; self.page = Page::Login,</pre>
<p>When the <kbd>Login</kbd> component notifies the main component of successful authentication, thus specifying the authenticated user, the main controller sets <kbd>PersonsList</kbd> as the page to go to, saves the name of the newly authenticated user, and extracts the privileges from that user. </p>
<p>When the <span class="packt_screen">Change User</span> button is clicked, the <em>page to go to</em> becomes the <kbd>Login</kbd> page. The <kbd>view</kbd> method contains just an invocation of the <kbd>html</kbd> macro. Such a macro must contain one HTML element, and in this case, it is a <kbd>div</kbd> element.</p>
<p>That <kbd>div</kbd> element contains three HTML elements: a <kbd>style</kbd> element, a <kbd>header</kbd> element, and a <kbd>footer</kbd> element. But between the header and the footer, there is some Rust code to create the inner section of the main page.</p>
<p>To insert Rust code inside an <kbd>html</kbd> macro, there are two possibilities:</p>
<ul>
<li>Attributes of HTML elements are just Rust code.</li>
<li>At any point, a pair of braces encloses Rust code.</li>
</ul>
<p>In the first case, the evaluation of such Rust code must return a value convertible to a string through the <kbd>Display</kbd> trait.</p>
<p>In the second case, the evaluation of the Rust code in braces must return an HTML element. And how can you return an HTML element from Rust code? Using an <kbd>html</kbd> macro!</p>
<p>So, the Rust code that implements the <kbd>view</kbd> method contains an <kbd>html</kbd> macro invocation that contains a block of Rust code, which contains <span>an </span><kbd>html</kbd><span> macro invocation, and so on. This recursion is performed at compile time and has a limit that can be overridden using the <kbd>recursion_limit</kbd> Rust attribute.</span></p>
<div class="packt_tip">Notice that both the header and the inner section contain a <kbd>match self.page</kbd> expression.</div>
<p>In the header, it is used to show the <span class="packt_screen">Change User</span> button only if the current page is not the login page, for which it would be pointless.</p>
<p>In the inner section, the body of such a statement is the following:</p>
<pre>Page::Login =&gt; html! {<br/>    &lt;LoginModel:<br/>        current_username=&amp;self.current_user,<br/>        when_logged_in=|u| MainMsg::LoggedIn(u),<br/>        db_connection=Some(self.db_connection.clone()),<br/>    /&gt;<br/>},<br/>Page::PersonsList =&gt; html! {<br/>    &lt;h2&gt;{ "Page to be implemented" }&lt;/h2&gt;<br/>},</pre>
<p>If the current page is <kbd>Login</kbd>, an invocation to the <kbd>html</kbd> macro contains the <kbd>LoginModel:</kbd> HTML element. Actually, the HTML language doesn't have such an element type. This is the way to embed another Yew component in the current component. The <kbd>LoginModel</kbd> component is declared in the <kbd>login.rs</kbd> source file. Its construction requires some arguments:</p>
<ul>
<li><kbd>current_username</kbd> is the name of the current user.</li>
<li><kbd>when_logged_in</kbd> is a callback that the component should invoke when it has performed a successful authentication.</li>
<li><kbd>db_connection</kbd> is a (reference-counted) copy of the database.</li>
</ul>
<p>Regarding the callback, notice that it receives a user (<kbd>u</kbd>) as an argument and returns the message <kbd>LoggedIn</kbd> decorated by that user. Sending this message to the controller of the main component is the way the <kbd>Login</kbd> component communicates to the main component who the user is that has just logged in.</p>
<h3 id="uuid-5a3dbc03-0388-466d-9049-288f8991d067">The<span> </span>login.rs file</h3>
<p>The <kbd>login</kbd> module begins by defining the model of the <kbd>Login</kbd> component:</p>
<pre>pub struct LoginModel {<br/>    dialog: DialogService,<br/>    username: String,<br/>    password: String,<br/>    when_logged_in: Option&lt;Callback&lt;User&gt;&gt;,<br/>    db_connection: std::rc::Rc&lt;std::cell::RefCell&lt;DbConnection&gt;&gt;,<br/>}</pre>
<p>This model must be used by the main component, and so it must be public.</p>
<p>Its fields are as follows:</p>
<ul>
<li><kbd>dialog</kbd> is a reference to a Yew service, which is a way to ask the framework to do something more than implementing the MVC architecture. A dialog service is the ability to show message boxes to the user, through the JavaScript engine of the browser.</li>
<li><kbd>username</kbd> and <kbd>password</kbd> are the values of the text that the user has typed in the two textboxes.</li>
<li><kbd>when_logged_in</kbd> is a possible callback function, to call when a successful authentication is completed.</li>
<li><kbd>db_connection</kbd> is a reference to the database.</li>
</ul>
<p>The possible notification messages are these:</p>
<pre>pub enum LoginMsg {<br/>    UsernameChanged(String),<br/>    PasswordChanged(String),<br/>    LoginPressed,<br/>}</pre>
<p>The first two messages mean that the respective fields have changed values, and the third message says that the push-button has been pressed.</p>
<p>So far, we have seen that this component has a model and some messages, like the components we saw before; but now we'll see that it also has something that we've never seen:</p>
<pre>pub struct LoginProps {<br/>    pub current_username: Option&lt;String&gt;,<br/>    pub when_logged_in: Option&lt;Callback&lt;User&gt;&gt;,<br/>    pub db_connection: <br/>     Option&lt;std::rc::Rc&lt;std::cell::RefCell&lt;DbConnection&gt;&gt;&gt;,<br/>}</pre>
<p>This structure represents the arguments that every parent of this component must pass to create the component. In this project, there is only one parent of the <kbd>Login</kbd> component, that is, the main component, and that component created a <kbd>LoginModel</kbd>: element having the fields of <kbd>LoginProps</kbd> as attributes. Notice that all the fields are specializations of <kbd>Option</kbd>: it is required by the Yew framework, even if you don't pass an <kbd>Option</kbd> as an attribute.</p>
<p>This <kbd>LoginProps</kbd> type must be used in four points:</p>
<ul>
<li>First, it must implement the <kbd>Default</kbd> trait, to ensure its fields are properly initialized when the framework needs an object of this type:</li>
</ul>
<pre style="padding-left: 60px">impl Default for LoginProps {<br/>    fn default() -&gt; Self {<br/>        LoginProps {<br/>            current_username: None,<br/>            when_logged_in: None,<br/>            db_connection: None,<br/>        }<br/>    }<br/>}</pre>
<ul>
<li>Second, we already saw that the implementation of the <kbd>Component</kbd> trait for the model has to define a <kbd>Properties</kbd> type. In this case, it must be like so:</li>
</ul>
<pre style="padding-left: 60px">impl Component for LoginModel {<br/>    type Message = LoginMsg;<br/>    type Properties = LoginProps;</pre>
<div class="packt_tip">That is, this type is passed into the implementation of the <kbd>Component</kbd> trait for the <kbd>LoginModel</kbd> type.</div>
<ul>
<li>Third, the <kbd>create</kbd> function must use its first argument, containing the values passed in by the parent component. Here is that function:</li>
</ul>
<pre style="padding-left: 60px">fn create(props: Self::Properties, _link: ComponentLink&lt;Self&gt;)<br/>-&gt; Self {<br/>    LoginModel {<br/>        dialog: DialogService::new(),<br/>        username: props.current_username.unwrap_or(String::new()),<br/>        password: String::new(),<br/>        when_logged_in: props.when_logged_in,<br/>        db_connection: props.db_connection.unwrap(),<br/>    }<br/>}</pre>
<p>All the fields of the model are initialized, but while the <kbd>dialog</kbd> and <kbd>password</kbd> fields receive default values, the other fields receive a value from the <kbd>props</kbd> object received from the parent component, that is, <kbd>MainModel</kbd>. As we are sure that the <kbd>db_connection</kbd> field of <kbd>props</kbd> will be <kbd>None</kbd>, we call <kbd>unwrap</kbd> for it. Instead, the <kbd>current_username</kbd> field may be <kbd>None</kbd>, and so, in that case, an empty string is used.</p>
<p>Then there is the <kbd>update</kbd> function, which is the controller of the <kbd>Login</kbd> component.</p>
<p>When the user presses the <span class="packt_screen">Log in</span> button, the following code is executed:</p>
<pre>if let Some(user) = self.db_connection.borrow()<br/>    .get_user_by_username(&amp;self.username)<br/>{<br/>    if user.password == self.password {<br/>        if let Some(ref go_to_page) = self.when_logged_in {<br/>            go_to_page.emit(user.clone());<br/>        }<br/>    } else {<br/>        self.dialog.alert("Invalid password for the specified user.");<br/>    }<br/>} else {<br/>    self.dialog.alert("User not found.");<br/>}</pre>
<p>The connection to the database is extracted from <kbd>RefCell</kbd> using the <kbd>borrow</kbd> method, and then the user with the current name is looked for. If the user is found, and if their stored password is the same as that typed by the user, the callback kept in the <kbd>when_logged_in</kbd> field is extracted, and then its <kbd>emit</kbd> method is invoked, passing a copy of the user name as argument. So, the routine passed by the parent, that is, the <kbd>|u| MainMsg::LoggedIn(u)</kbd> closure, is executed.</p>
<p>In the event of a missing user or mismatching password, a message box is displayed using the <kbd>alert</kbd> method of the dialog service. The controllers that we saw before had just two functions: <kbd>create</kbd> and <kbd>update</kbd>. This one has another function, though; it is the <kbd>change</kbd> method:</p>
<pre>fn change(&amp;mut self, props: Self::Properties) -&gt; ShouldRender {<br/>    self.username = props.current_username.unwrap_or(String::new());<br/>    self.when_logged_in = props.when_logged_in;<br/>    self.db_connection = props.db_connection.unwrap();<br/>    true<br/>}</pre>
<p>This method allows the parent to re-send to this component updated arguments using the <kbd>Properties</kbd> structure. The <kbd>create</kbd> method is invoked just one time, while the <kbd>change</kbd> method is invoked any time the parent will need to update the arguments to pass to the child component.</p>
<p>The view <span>is easy to understand by reading its code and does not require</span> explanation.</p>
<h1 id="uuid-effb9847-5162-4969-888b-d7254da93066">The yauth app</h1>
<p>The <kbd>login</kbd> app, presented in the previous section, showed how to create a parent component containing one of several possible child components. However, it implemented just one child component, the <kbd>Login</kbd> component. So, in this section, a more complete example will be presented, having three different possible child components, corresponding to three different pages of a classical web application.</p>
<p>It is named <kbd>yauth</kbd>, short for <strong>Yew Auth</strong>, as its behavior is almost identical to the <kbd>auth</kbd> project shown in the previous chapter, although, it is completely based on the Yew framework, instead of being based on Actix web and Tera.</p>
<h2 id="uuid-ce14d6c9-5f01-4d70-8b91-7e4eb443a792">Understanding the behavior of the app</h2>
<p>This app is built and launched like the ones in the previous sections, and its first page is identical to the first page of the <kbd>login</kbd> app. Though, if you type <kbd>susan</kbd> as the username and <kbd>xsusan</kbd> as the password, and then click on the <span class="packt_screen">Log in</span> button, you'll see the following page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dcccef8b-c1b6-4512-bfe5-60f3d53696f4.png" style="width:18.92em;height:14.67em;"/></p>
<p>This page and the other page that you will see in this app, and their behavior, are almost identical to those of the <kbd>auth</kbd> app described in the previous chapter. The only differences are as follows:</p>
<ul>
<li>Any error message is not shown as red text embedded in the page but as a pop-up message box.</li>
<li>The header and the footer are implemented by the main component, and they look and behave as already described in the previous section of this chapter.</li>
</ul>
<p>So, we just need to examine the implementation of this app.</p>
<h2 id="uuid-76926969-19dc-4316-9bf5-ac0e1dd54ad0">Organization of the project</h2>
<p>The source code of this project has been split into five files:</p>
<ul>
<li><kbd>db_access.rs</kbd>: It contains a stub of a connection to a database, providing access to a user directory to handle authentication and to a list of persons; it actually contains such data as vectors. It is virtually identical to the file with the same name in the <kbd>auth</kbd> project of the previous chapter. The only relevant difference is that the <kbd>Serialize</kbd> trait is not implemented, because it's not required by the Yew framework.</li>
<li><kbd>main.rs</kbd>: It contains the one-line<span> </span><kbd>main</kbd><span> </span>function, and an MVC component that handles the header and the footer of the page, and delegates the inner section to one of the other three components of the app.</li>
<li><kbd>login.rs</kbd>: It c<span>ontains </span><span>the MVC component to handle the authentication. It is to be used as an inner section of the main component. It is identical to the module having the same name in the <kbd>login</kbd> project.</span></li>
<li><span><kbd>persons_list.rs</kbd>: It contains the MVC component to handle the list of persons. It is to be used as an inner section of the main component.</span></li>
<li><kbd>one_person.rs</kbd>: It c<span>ontains </span><span>the MVC component to view, edit, or insert a single person; it is to be used as an inner section of the main component.</span></li>
</ul>
<p>We will only discuss the files <span>unique to the <kbd>yauth</kbd> app, as follows</span>.</p>
<h3 id="uuid-a55b075e-b567-43c7-9029-1f68fddc6064">The<span> </span>persons_list.rs file</h3>
<p>This file contains the definition of the component to let the user manage the list of persons, and so it defines the following struct as a model:</p>
<pre>pub struct PersonsListModel {<br/>    dialog: DialogService,<br/>    id_to_find: Option&lt;u32&gt;,<br/>    name_portion: String,<br/>    filtered_persons: Vec&lt;Person&gt;,<br/>    selected_ids: std::collections::HashSet&lt;u32&gt;,<br/>    can_write: bool,<br/>    go_to_one_person_page: Option&lt;Callback&lt;Option&lt;Person&gt;&gt;&gt;,<br/>    db_connection: std::rc::Rc&lt;std::cell::RefCell&lt;DbConnection&gt;&gt;,<br/>}</pre>
<p>Let's see what each line in the previous code says:</p>
<ul>
<li>The <kbd>dialog</kbd> field contains a service to open message boxes.</li>
<li>The <kbd>id_to_find</kbd> <span>field contains the value typed by the user in the <span class="packt_screen">Id</span> textbox if the box contains a number, or</span> <kbd>None</kbd> <span>otherwise.</span></li>
<li>The <kbd>name_portion</kbd> <span>field contains the value contained in the</span> <span class="packt_screen">Name portion<span><span class="packt_screen">:</span></span></span> <span>textbox. In particular, if that box is empty, this field of the model contains an empty string. </span>The <kbd>filtered_persons</kbd> <span>field contains a list of the persons extracted from the database using the specified filter. Initially, the filter specifies to extract all the persons whose names contain an empty string. Of course, all the persons satisfy that filter, and so all the persons in the database are added to this vector, though the database is empty, and so this vector is too.</span></li>
<li>The <kbd>selected_ids</kbd><span> field contains the IDs of all the listed people whose checkbox is set, and so they are selected for further operation.</span></li>
<li>The <kbd>can_write</kbd><span> field specifies whether the current user has the privilege to modify the data.</span></li>
<li>The <kbd>go_to_one_person_page</kbd> <span>field contains the callback to call to pass to the page to view/edit/insert a single person. Such a callback function receives one argument, which is the person to view/edit, or</span> <kbd>None</kbd><span> to open the page to insert a new person.</span></li>
<li>The <kbd>db_connection</kbd> <span>field contains a shared reference to the database connection.</span></li>
</ul>
<p>The possible notifications from the view to the controllers are defined by this structure:</p>
<pre>pub enum PersonsListMsg {<br/>    IdChanged(String),<br/>    FindPressed,<br/>    PartialNameChanged(String),<br/>    FilterPressed,<br/>    DeletePressed,<br/>    AddPressed,<br/>    SelectionToggled(u32),<br/>    EditPressed(u32),<br/>}</pre>
<p>Let's see what we did in the previous code:</p>
<ul>
<li>The <kbd>IdChanged</kbd> message must be sent when the text in the <span class="packt_screen">Id:</span> textbox is changed. Its argument is the new text value of the field.</li>
<li>The <kbd>FindPressed</kbd><span> message must be sent when the <span class="packt_screen">Find</span> push-button is clicked. </span></li>
<li>The <kbd>PartialNameChanged</kbd><span> message must be sent when the text in the <span class="packt_screen">Name portion:</span> textbox is changed. Its argument is the new text value of the field.</span></li>
<li>The <kbd>FilterPressed</kbd><span> message must be sent when the <span class="packt_screen">Filter</span> push-button is clicked.</span></li>
<li>The <kbd>DeletePressed</kbd><span> message must be sent when the <span class="packt_screen">Delete Selected Persons</span> push-button is clicked.</span></li>
<li>The <kbd>AddPressed</kbd><span> message must be sent when the <span class="packt_screen">Add New Person</span> push-button is clicked.</span></li>
<li>The <kbd>SelectionToggled</kbd><span> message must be sent when a checkbox in the list of persons is toggled (that is, checked or unchecked). Its argument is the ID of the person specified by that line of the list.</span></li>
<li>The <kbd>EditPressed</kbd><span> message must be sent when any <span class="packt_screen">Edit</span> push-button in the list of persons is clicked. Its argument is the ID of the person specified by that line of the list.</span></li>
</ul>
<p>Then, the structure of the initialization arguments for the component is defined:</p>
<pre>pub struct PersonsListProps {<br/>    pub can_write: bool,<br/>    pub go_to_one_person_page: Option&lt;Callback&lt;Option&lt;Person&gt;&gt;&gt;,<br/>    pub db_connection: <br/>     Option&lt;std::rc::Rc&lt;std::cell::RefCell&lt;DbConnection&gt;&gt;&gt;,<br/>}</pre>
<p>Let's look at how this works:</p>
<ul>
<li>Using the <kbd>can_write</kbd> field, the main component specifies a simple definition of the privileges of the current user. A more complex application could have a more complex definition of privileges.</li>
<li>Using the <kbd>go_to_one_person_page</kbd> field, <span>the main component passes a reference to a function, which must be called to go to the page for showing, editing, or inserting a single person.</span></li>
<li>Using the <kbd>db_connection</kbd> field, the main component passes a shared reference to the database connection.</li>
</ul>
<p>The initialization of the <kbd>PersonsListProps</kbd> struct by implementing the <kbd>Default</kbd> trait and of the <kbd>PersonsListModel</kbd> struct by implementing the <kbd>Component</kbd> trait is trivial, except for the <kbd>filtered_persons</kbd> field. Instead of leaving it as an empty vector, it is first set as an empty vector, and then modified by the following statement:</p>
<pre>model.filtered_persons = model.db_connection.borrow()<br/>    .get_persons_by_partial_name("");</pre>
<h4 id="uuid-d66c9e05-6141-469e-aaad-177a200046b5">Why an empty collection wouldn't be good for filtered_persons</h4>
<p>Every time the <kbd>PersonsList</kbd> page is opened, both from the login page and from the <kbd>OnePerson</kbd> page, the model is initialized by the <kbd>create</kbd> function, and all the user interface elements of the page are initialized using that model.</p>
<p>So, if you type something in the <kbd>PersonsList</kbd> page, and then you go to another page, and then you go back to the <kbd>PersonsList</kbd> page, everything you typed is cleared unless you set it in the <kbd>create</kbd> function.</p>
<p>Probably, the fact that the <span><span class="packt_screen">Id</span> </span><span>textbox</span><span>, the</span> <span><span class="packt_screen">Name portion</span> textbox, or the selected persons are cleared is not very annoying, but the fact that the list of persons is cleared means that you will get the following behavior:</span></p>
<ul>
<li><span>You filter the persons to see some persons listed.</span></li>
<li><span>You click on the <span class="packt_screen">Edit</span> button in the row of one person, to change the name of that person, and so you go to the <kbd>OnePerson</kbd> page.</span></li>
<li>You change the name and press the <span class="packt_screen">Update</span> button, <span>and so you go back to the <kbd>PersonsList</kbd> page.</span></li>
<li>You see the text <span class="packt_screen">No persons.</span> instead of the list of persons.</li>
</ul>
<p><span>You don't see the person that you have just modified in the <kbd>OnePerson</kbd> page anymore. This is inconvenient.</span></p>
<p>To see that person listed, you need to set <kbd>filtered_persons</kbd> to a value containing that person. The solution chosen has been to show all the persons existing in the database, and this is performed by calling the <kbd>get_persons_by_partial_name("")</kbd> function.</p>
<p>Now, let's see how the <kbd>update</kbd> method handles the messages from the view.</p>
<p>When the <span><kbd>IdChanged</kbd> </span>message is received, the following statement is executed:</p>
<pre>self.id_to_find = id_str.parse::&lt;u32&gt;().ok(),</pre>
<p>It tries to store in the model the value of the textbox, or <kbd>None</kbd> if the value is not convertible to a number.</p>
<p>When the <kbd>FindPressed</kbd> <span>message </span>is received<span>, the following statement is executed:</span></p>
<pre>match self.id_to_find {<br/>    Some(id) =&gt; { self.update(PersonsListMsg::EditPressed(id)); }<br/>    None =&gt; { self.dialog.alert("No id specified."); }<br/>},</pre>
<p>If the <span class="packt_screen">Id</span> textbox contained a valid number, another message would be sent recursively: it is the <kbd>EditPressed</kbd> message. Pressing the <span class="packt_screen">Find</span> button must have the same behavior as pressing the <span class="packt_screen">Edit</span> button in the row with the same ID contained in the <span class="packt_screen">Id</span> textbox, and so the message is forwarded to the same function. If there is no ID in the text field, a message box is displayed.</p>
<p>When the <kbd>PartialNameChanged</kbd> message is received, the new partial name is just saved in the <kbd>name_portion</kbd> field of the model. When the <kbd>FilterPressed</kbd> message is received, the following statement is executed:</p>
<pre>self.filtered_persons = self<br/>    .db_connection<br/>    .borrow()<br/>    .get_persons_by_partial_name(&amp;self.name_portion);</pre>
<p>The connection to the database is encapsulated in a <kbd>RefCell</kbd> object, which is further <span>encapsulated</span> <span>in an <kbd>Rc</kbd> object. The access inside <kbd>Rc</kbd> is implicit, but to access inside <kbd>RefCell</kbd>, it is required to call the <kbd>borrow</kbd> method.</span> Then the database is queried to get the list of all the persons whose names contain the current name portion. This list is finally assigned to the <kbd>filtered_persons</kbd> field of the model.</p>
<p>When the <kbd>DeletePressed</kbd> message is received, <span>the following statement is executed:</span></p>
<pre>if self<br/>    .dialog<br/>    .confirm("Do you confirm to delete the selected persons?") {<br/>    {<br/>        let mut db = self.db_connection.borrow_mut();<br/>        for id in &amp;self.selected_ids {<br/>            db.delete_by_id(*id);<br/>        }<br/>    }<br/>    self.update(PersonsListMsg::FilterPressed);<br/>    self.dialog.alert("Deleted.");<br/>}</pre>
<p>The following pop-up box <span>is shown </span>for confirmation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5cb323eb-f775-451c-b4e4-0c99fd004f03.png" style="width:25.17em;height:6.75em;"/></p>
<p>If the user clicks on the <span class="packt_screen">OK</span> button (or presses <em>Enter</em>), then the deletion is performed in the following way: a mutable reference is borrowed from the shared connection to the database, and for any ID selected through the checkboxes, the respective person is deleted from the database.</p>
<p>The closing of the scope releases the borrowing. Then, a recursive call to <kbd>update</kbd> triggers the <kbd>FilterPressed</kbd> message, whose purpose is to refresh the list of persons shown. Finally, the following message box communicates the completion of the operation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/15d80085-c33a-454d-90a2-d56087596ad3.png" style="width:26.33em;height:7.00em;"/></p>
<p>When the <kbd>AddPressed</kbd> message is received, <span>the following code is executed:</span></p>
<pre>if let Some(ref go_to_page) = self.go_to_one_person_page {<br/>    go_to_page.emit(None);<br/>}</pre>
<p>Here, a reference to the <span><kbd>go_to_one_person_page</kbd> callback is taken, and then it is invoked using the <kbd>emit</kbd> method. The effect of such an invocation is to go to the <kbd>OnePerson</kbd> page. The argument of <kbd>emit</kbd> specifies which person will be edited on the page. If it is <kbd>None</kbd>, as in this case, the page is opened in insertion mode.<br/></span></p>
<p>When the <kbd>SelectionToggled</kbd> message is received, it specifies an ID of a person, but it does not specify whether that person is to be selected or deselected. So, the following code is executed:</p>
<pre>if self.selected_ids.contains(&amp;id) {<br/>    self.selected_ids.remove(&amp;id);<br/>} else {<br/>    self.selected_ids.insert(id);<br/>}</pre>
<p class="mce-root"/>
<p>We want to invert the status of the person on which the user has clicked, that is, to select it if it was not selected, and to unselect it if it was selected. The <kbd>selected_ids</kbd> field of the model contains the set of all the selected persons. So, if the clicked ID is contained in the set of selected IDs, it is removed from this set by calling the <kbd>remove</kbd> method; otherwise, it is added to the list, by calling the <kbd>insert</kbd> method.</p>
<p>At last, when the <kbd>EditPressed</kbd> message is received (specifying the <kbd>id</kbd> of the person to view/change), the<span> following code is executed:</span></p>
<pre>match self.db_connection.borrow().get_person_by_id(id) {<br/>    Some(person) =&gt; {<br/>        if let Some(ref go_to_page) = self.go_to_one_person_page {<br/>            go_to_page.emit(Some(person.clone()));<br/>        }<br/>    }<br/>    None =&gt; self.dialog.alert("No person found with the indicated id."),<br/>}</pre>
<p>The database is searched for a person with the specified ID. If such a person is found, the <kbd>go_to_one_person_page</kbd> callback is invoked, passing a clone of the person found. Otherwise, a message box explains the error. The <kbd>change</kbd> method keeps the fields of the model <span>updated </span>when any property coming from the parent component would change.</p>
<p>Then there is the view. The messages sent by the view were described when the messages were presented. The other interesting aspects of the view are the following ones.</p>
<p>The <span><span class="packt_screen">Delete Selected Persons</span> button and the <span class="packt_screen">Add New Person</span> button have the attribute <kbd>disabled=!self.can_write</kbd>. This enables such commands only if the user has the privilege to change the data.</span></p>
<p>The <kbd>if !self.filtered_persons.is_empty()</kbd> <span>clause </span>causes the table of persons to be displayed only if there is at least one person filtered. Otherwise, the text <span class="packt_screen">No persons.</span> is displayed.</p>
<p>The body of the table begins and ends with the following lines:</p>
<pre>for self.filtered_persons.iter().map(|p| {<br/>    let id = p.id;<br/>    let name = p.name.clone();<br/>    html! {<br/>        ...<br/>    }<br/>})</pre>
<p>This is the required syntax for generating sequences of HTML elements based on an iterator.</p>
<p>The <kbd>for</kbd> keyword is immediately followed by an iterator (in this case, the expression <kbd>self.filtered_persons.iter()</kbd>), followed by the expression <kbd>.map(|p|</kbd>, where <kbd>p</kbd> is the loop variable. In this way, it is possible to insert into the map closure a call to the <kbd>html</kbd> macro that generates the elements of the sequence. In this case, such elements are the lines of the HTML table.</p>
<p>The last noteworthy point is the way to show which persons are selected. Every checkbox has the attribute <kbd>checked=self.selected_ids.contains(&amp;id),</kbd>. The checked attribute expects a <kbd>bool</kbd> value. That expression sets as checked the checkbox relative to the persons whose <kbd>id</kbd> is contained in the list of the selected IDs.</p>
<h3 id="uuid-9b7260a4-2f40-4c11-b9ae-6e5d4fd824f3">The<span> </span>one_person.rs file</h3>
<p>This file contains the definition of the component to let the user view or edit the details of one person or to fill in the details and insert a new person. Of course, to view the details of an existing record, such details must be passed as arguments to the component; instead, to insert a new person, no data must be passed to the component.</p>
<p>This component does not return its changes directly to the parent that created it. Such changes are saved to the database, if the user requested that, and the parent can retrieve them from the database.</p>
<p>Therefore the model is defined by the following struct:</p>
<pre>pub struct OnePersonModel {<br/>    id: Option&lt;u32&gt;,<br/>    name: String,<br/>    can_write: bool,<br/>    is_inserting: bool,<br/>    go_to_persons_list_page: Option&lt;Callback&lt;()&gt;&gt;,<br/>    db_connection: std::rc::Rc&lt;std::cell::RefCell&lt;DbConnection&gt;&gt;,<br/>}</pre>
<p>With the preceding code, we understood the following things:</p>
<ul>
<li>The <kbd>id</kbd><span> </span>field contains the value contained in the <span class="packt_screen">Id</span> textbox if the box contains a number, or<span> </span><kbd>None</kbd><span> </span>otherwise.</li>
<li>The <kbd>name</kbd><span> </span><span><span>field contains the value contained in the <span class="packt_screen">Name</span> textbox. In particular, if the box is empty, this field of the model contains an empty string.</span></span></li>
<li>The <kbd>can_write</kbd><span> </span><span>field specifies whether the current privileges allow the user to change the data or only to see it.</span></li>
<li>The <kbd>is_inserting</kbd><span> field specifies </span><span>whether this component has received no data, to insert a new person into the database, or whether it has received the data of a person, to view or edit them</span><span>. </span></li>
<li>The <kbd>go_to_persons_list_page</kbd><span> field is a callback with no arguments that must be invoked by this component when the user closes this page to go to the page to manage the list of persons.</span></li>
<li>The <kbd>db_connection</kbd><span> field is a shared connection to the database.</span></li>
</ul>
<p><span>Of course, it is pointless to open a page for insertion without allowing the user to change the values. So, the possible combinations are the following ones:</span></p>
<ul>
<li><span><strong>Insertion mode</strong>: The <kbd>id</kbd> field is <kbd>None</kbd>, the <kbd>can_write</kbd> field is <kbd>true</kbd>, and the <kbd>is_inserting</kbd> field is </span><kbd>true</kbd><span>.</span></li>
<li><strong>Editing mode</strong>: <span>The <kbd>id</kbd> field is <kbd>Some</kbd>, the <kbd>can_write</kbd> field is <kbd>true</kbd>, and the <kbd>is_inserting</kbd> field is </span><kbd>false</kbd><span>.</span></li>
<li><span><strong>Read-only mode</strong>: The <kbd>id</kbd> field is <kbd>Some</kbd>, the <kbd>can_write</kbd> field is <kbd>false</kbd>, and the <kbd>is_inserting</kbd> field is </span><kbd>false</kbd><span>.</span></li>
</ul>
<p>The possible notifications from the view to the controller are defined by the following <kbd>enum</kbd>:</p>
<pre>pub enum OnePersonMsg {<br/>    NameChanged(String),<br/>    SavePressed,<br/>    CancelPressed,<br/>}</pre>
<p>Let's see what happened in the code:</p>
<ul>
<li>When the user changes the contents of the <span class="packt_screen">Name</span> <span>textbox</span>, the <kbd>NameChanged</kbd> message is sent, which also specifies the current contents of that textbox.</li>
<li>When the user clicks on the <span><span class="packt_screen">Insert</span> button or on the </span><span class="packt_screen">Update</span> button, the <kbd>SavePressed</kbd> message is sent. To distinguish between the two buttons, the<span> </span><kbd>is_inserting</kbd><span> field can be used.</span></li>
<li>When the user presses the <span class="packt_screen">Cancel</span> button, the <kbd>CancelPressed</kbd> message is sent.</li>
</ul>
<p>The value of the <span class="packt_screen">Id</span> textbox can never be changed during the life of this component, and so no message is required for it. The data received from the parent is defined by the following structure:</p>
<pre>pub struct OnePersonProps {<br/>    pub id: Option&lt;u32&gt;,<br/>    pub name: String,<br/>    pub can_write: bool,<br/>    pub go_to_persons_list_page: Option&lt;Callback&lt;()&gt;&gt;,<br/>    pub db_connection: <br/>     Option&lt;std::rc::Rc&lt;std::cell::RefCell&lt;DbConnection&gt;&gt;&gt;,<br/>}</pre>
<p>In the preceding code, we have the following things to check:</p>
<ul>
<li>The <kbd>id</kbd> field is <kbd>None</kbd> in case the parent wants to open the page to let the user insert a new person, and contains the ID of an existing person in case the page is for viewing or editing the data of that person.</li>
<li>The <kbd>name</kbd> field is the only changeable data of any person. It is an empty string if the page is created for inserting a new person. Otherwise, the parent passes the current name of the person.</li>
<li>The <kbd>can_write</kbd> field specifies whether the user is allowed to change the displayed data. This field should be <kbd>true</kbd> if the <kbd>id</kbd> <span>field is</span> <kbd>None</kbd><span>.</span></li>
<li><kbd>go_to_persons_list_page</kbd> is the callback that will activate the <kbd>PersonsList</kbd> component in the parent.</li>
<li>The <kbd>db_connection</kbd> field is the shared database connection.</li>
</ul>
<p>In the rest of the module, there is nothing new. The only thing to stress is that the use of conditional expressions based on the <kbd>can_write</kbd> and <kbd>is_inserting</kbd> flags of the model allows having just one component with a mutant view.</p>
<h1 id="uuid-e8e07d82-217a-4bfa-a6f4-a38197a95d43">A web app accessing a RESTful service</h1>
<p>The previous section described a rather complex software architecture, but still running only in the user's web browser, after having being served by the site where it is installed. This is quite unusual, as most web apps actually communicate with some other process. Typically, the same site that provides the frontend app also provides a backend service, that is, a web service to let the app access shared data residing on the server.</p>
<p>In this section, we'll see a pair of projects that can be downloaded from the repository:</p>
<ul>
<li><kbd>yclient</kbd>: This is an app quite similar to the <kbd>yauth</kbd> app. Actually, it is developed using Yew and Wasm, and it has the same look and behavior as <span><kbd>yauth</kbd>; though its data, which is the authorized users and the persons stored in the mock database, no longer resides in the app itself, but in another app, which is accessed through </span><span>an HTTP connection.</span></li>
<li><kbd>persons_db</kbd>: This is the RESTful service that provides access to the data for the <kbd>yclient</kbd> app. It is developed using the Actix web framework, as explained in the previous chapter. Even this app does not manage a real database, only a mock, in-memory database.</li>
</ul>
<p>To run the system, two commands are required: one to run the frontend provider, <kbd>yclient</kbd>, and one to run the web service, <kbd>persons_db</kbd>.</p>
<p>To run the frontend provider, go into the <kbd>yclient</kbd> folder, and type the following:</p>
<pre><strong>cargo web start</strong></pre>
<p>After downloading and compiling all the required crates, it will print the following:</p>
<pre><strong>You can access the web server at `http://127.0.0.1:8000`.</strong></pre>
<p>To run the backend, in another console window, go into the <kbd>db_persons</kbd> folder and type the following:</p>
<pre><strong>cargo run</strong></pre>
<p>Or, we can use the following command:</p>
<pre><strong>cargo run --release</strong></pre>
<p>Both these commands will end by printing the following:</p>
<pre><strong> Listening at address 127.0.0.1:8080</strong></pre>
<p>Now you can use your web browser and navigate to <kbd>localhost:8000</kbd>. The app that will be opened will be quite similar to both the <kbd>yauth</kbd> app, shown in the previous section, and to the <kbd>auth</kbd> app, shown in the previous chapter.</p>
<p>Let's first see how <kbd>persons_db</kbd> is organized.</p>
<h2 id="uuid-48922040-648a-49b7-8be7-f1a49edca496">The persons_db app</h2>
<p>This app uses the Actix web framework, described in the previous two chapters. In particular, this project has some features taken from the <kbd>json_db</kbd> project, described in <a href="febceb22-18dd-437f-bd27-9895aef47384.xhtml">Chapter 3</a>, <em>Creating a REST Web Service</em>, and some from the <kbd>auth</kbd> project, described in <a href="27918752-3cb8-4b2f-9508-a439ad1745ab.xhtml">Chapter 4</a>, <em>Creating a Full Server-Side Web App</em>.</p>
<p>Here, we'll see only the new features that haven't been described so far. The <kbd>Cargo.toml</kbd> file contains the following new line:</p>
<pre>actix-cors = "0.1"</pre>
<p>This crate allows the handling of the <strong>Cross-Origin Resource Sharing</strong> (<strong><span>CORS</span></strong>) checks, usually performed by browsers. When some code running inside a browser tries to access an external resource using a network connection, the browser, <span>for security reasons, checks whether the addressed host is just the</span><span> one that provided the code that is performing the request. That means that the frontend and the backend are actually the same website.</span></p>
<p>If the check fails, that is, the frontend app is trying to communicate with a different site, the browser sends <span>an HTTP request using the <kbd>OPTION</kbd> method to check whether the site agrees to cooperate with that web app on this resource sharing. Only if the response to the <kbd>OPTION</kbd> request allows the required kind of access can the original request be forwarded.</span></p>
<p>In our case, both the frontend app and the web service run on localhost; though, they use different TCP ports: <kbd>8000</kbd> for the frontend and <kbd>8080</kbd> for the backend. So, they are considered as different origins, and CORS handling is needed. The <kbd>actix-cors</kbd> crate provides features to allow such cross-origin access for backends developed using Actix web.</p>
<p>One of these features is used in the <kbd>main</kbd> function, as in the following code snippet:</p>
<pre>.wrap(<br/>    actix_cors::Cors::new()<br/>        .allowed_methods(vec!["GET", "POST", "PUT", "DELETE"])<br/>)</pre>
<p>This code is a so-called <strong>middleware</strong>, meaning that it will be run for every request received by the service, and so it is a piece of software that stays in the middle between the client and the server.</p>
<p>The <kbd>wrap</kbd> method is the one to use to add a piece of middleware. This word means that the following code must be <em>around</em> every handler, possibly filtering both requests and responses.</p>
<p>Such code creates an object of type <kbd>Cors</kbd> and specifies for it w<span>hich HTTP methods will be accepted.</span></p>
<p>The rest of this web service should be clear to those who have learned what has already been described about the Actix web framework. It is a RESTful web service that accepts requests as URI paths and queries and returns responses as JSON bodies, and for which authentication is provided in any request by the basic authentication header.</p>
<p>The API has a new route for the <kbd>GET</kbd> method and the <kbd>/authenticate</kbd> path, which calls the <kbd>authenticate</kbd> handler, which is used to get a whole user object with the list of their privileges.</p>
<p>Now let's see how <kbd>yclient</kbd> is organized.</p>
<h2 id="uuid-8ba3ce9b-2842-4b26-87ec-300e5721d99e">The<span> </span>yclient app</h2>
<p>This app starts from where the <kbd>yauth</kbd> app left off. The <kbd>yauth</kbd> apps contain its own in-memory database, while the app described here communicates with the <kbd>person_db</kbd> web service to access its database.</p>
<p>Here, we'll see only the new features, with respect to the <kbd>yauth</kbd> project.</p>
<h3 id="uuid-4b48369f-1216-4da7-973f-8512e1b641e3">The imported crates</h3>
<p>The <kbd>Cargo.toml</kbd> file contains new lines:</p>
<pre>failure = "0.1"<br/>serde = "1"<br/>serde_derive = "1"<br/>url = "1"<br/>base64 = "0.10"</pre>
<p>For the preceding code, let's have a look at the following things:</p>
<ul>
<li>The <kbd>failure</kbd> crate is used to encapsulate communication errors.</li>
<li>The  <kbd>serde</kbd> and <kbd>serde_derive</kbd> crates are needed to transfer whole objects from server to client, using deserialization. In particular, the whole object of the types <kbd>Person</kbd><span>,</span> <kbd>User</kbd><span>, and</span> <kbd>DbPrivilege</kbd> <span><span>are transferred in server responses.</span></span></li>
<li>The <kbd>url</kbd> crate is used for encoding information in a URL. In a URL path or a URL query, you can <span>easily put only identifiers or integer numbers, such as</span><span>, say, </span><kbd>/person/id/478</kbd><span> or</span> <kbd>/persons?ids=1,3,39</kbd><span>, but more complex data, such as the name of a person, is not allowed</span> <em>as is</em><span>. You cannot have a URL as </span><kbd>/persons?partial_name=John Doe</kbd><span>, because it contains whitespace. In general, you have to encode it in coding allowed in a URL, and that is provided by the call to</span> <kbd>url::form_urlencoded::byte_serialize</kbd><span>, which gets a slice of bytes and returns an iterator generating chars. If you call</span> <kbd>collect::&lt;String&gt;()</kbd><span> on this iterator, you get a string that can be safely put into a web URI.</span></li>
<li>The <kbd>base64</kbd> crate is used to perform a similar encoding of binary data into textual data, but for the header or the body of an HTTP request. In particular, it is required <span>to encode usernames and passwords </span><span>in the basic authentication header.</span></li>
</ul>
<h3 id="uuid-4f59ed6a-a58c-461c-9a20-85f8b9d63124">The source files</h3>
<p>The source file names are the same as the <kbd>yauth</kbd> project, except that the <kbd>db_access.rs</kbd> file has been renamed as <kbd>common.rs</kbd>. Actually, in this project, there is no code required to access the database, as access is now performed only by the service. The <kbd>common</kbd> module contains definitions of a constant, two structs, an enum, and a function needed by several components.</p>
<h3 id="uuid-c98e4fa7-7600-4a07-9269-625af62dec12">The changes to the models</h3>
<p>The models of the components have the following changes.</p>
<p>All the <kbd>db_connection</kbd> fields have been removed, as the app now does not directly access the database. That has become the responsibility of the server.</p>
<p>The Boolean <kbd>fetching</kbd> field has been added. It is set to true when a request is sent to the server and reset to false when the response is received, or the request has failed. It is not really necessary in this app, but it may be useful when using a slower communication (with a remote server) or some more lengthy requests. It may be used to show to the user that a request is pending, and also to disable other requests in the meantime.</p>
<p>The <kbd>fetch_service</kbd> field has been added to provide the communication feature. The <kbd>ft</kbd> field has been added to contain a reference to the current <kbd>FetchTask</kbd> object during a request, or <kbd>Nothing</kbd> when no request has <span>already </span>been sent. This field is not actually used; this is just a trick to keep the current request alive, because otherwise after the request is sent and the <kbd>update</kbd> function returns, the local variables would be dropped.</p>
<p>The <kbd>link</kbd> field has been added for forwarding to the current model the callback that will be called when the response is received.</p>
<p>The <kbd>console</kbd> field has been added to provide a way to print to the console of the browser, for debugging purposes. In Yew, the <kbd>print!</kbd> and <kbd>println!</kbd> macros are ineffective, as there is no system console on which to print. But the web browser has a console, which is accessed using the <kbd>console.log()</kbd> JavaScript function call. This Yew service provides access to such a feature.</p>
<p>The <kbd>username</kbd> and <kbd>password</kbd> fields have been added to send authentication data with any requests.</p>
<p>But let's see the changes required to the code because of the need to communicate with the server.</p>
<h3 id="uuid-629d1d58-e932-4bd4-8a36-c26ace08dd7b">A typical client/server request</h3>
<p>For any user command that, in the <kbd>yauth</kbd> project, required access to the database, such access has been removed, and the following changes have been applied, instead.</p>
<p>Such a user command now sends a request to a web service, and then a response from that service must be handled. In our examples, the time between the user command and the reception of the response from the service is quite short – just a few milliseconds, for the following reasons:</p>
<ul>
<li>Both client and server run in the same computer, and so the TCP/IP packets actually don't exit the computer.</li>
<li>The computer has nothing else to do.</li>
<li>The database is actually a very short memory vector, and so its operations are very fast.</li>
</ul>
<p>Though, in a real system, much more time is spent processing a user command that causes communication. If everything is good, a command takes only half a second, but sometimes it may take several seconds. So, synchronous communication is not acceptable. Your app cannot just wait for a response from the server, because it would appear to be stuck.</p>
<p>So, the <span><kbd>FetchService</kbd> object of the Yew framework provides an asynchronous communication model.</span></p>
<p><span>The controller routine triggered by the user command prepares the request to be sent to the server, and also prepares a callback routine, to handle the response from the server, and then sends the request, and so the app is free to handle other messages.</span></p>
<p>When the response comes from the server, the response triggers a message that is handled by the controller. The handling of the message invokes the callback prepared in advance.</p>
<p>So, in addition to the messages signaling a user command, other messages have been added. Some of them report the reception of a response, that is, the successful completion of a request; and others report a failure of the request coming from the server, that is, the unsuccessful <span>completion of a request</span>. For example, in the <kbd>PersonsListModel</kbd> component, implemented in the <kbd>persons_list.rs</kbd> file, the following user actions required communication:</p>
<ul>
<li>Pressing the <span class="packt_screen">Find</span> button (triggering the <kbd>FindPressed</kbd> message)</li>
<li>Pressing the <span class="packt_screen">Filter</span> button (triggering the <kbd>FilterPressed</kbd> message)</li>
<li>Pressing the <span class="packt_screen">Delete Selected Persons </span>button (triggering the<span> </span><kbd>DeletePressed</kbd><span> </span>message)</li>
<li>Pressing one of the <span class="packt_screen">Edit</span> buttons (triggering the<span> </span><kbd>EditPressed</kbd><span> </span><span>message)</span></li>
</ul>
<p>For them, the following messages have been added:</p>
<ul>
<li><kbd>ReadyFilteredPersons(Result&lt;Vec&lt;Person&gt;, Error&gt;)</kbd>: This is triggered by the <kbd>FetchService</kbd> instance when a list of filtered persons is received from the service. Such a list is contained in a <kbd>Vec</kbd> of <kbd>Person</kbd>. This may happen after processing the<span> </span><kbd>FilterPressed</kbd><span> message.</span></li>
<li><kbd>ReadyDeletedPersons(Result&lt;u32, Error&gt;)</kbd>:<span> This is triggered by the <kbd>FetchService</kbd> instance when the report that </span><span>a command to delete some persons has been completed by the service. The number of deleted persons is contained in <kbd>u32</kbd>. This may happen after processing the <kbd>DeletePressed</kbd> message.</span></li>
<li><kbd>ReadyPersonToEdit(Result&lt;Person, Error&gt;)</kbd>: <span>This is sent by <kbd>FetchService</kbd> when the requested <kbd>Person</kbd> object is received from the service, and so it can be edited (or simply displayed). This may happen after processing the <kbd>FindPressed</kbd> message or the <kbd>EditPressed</kbd> message.</span></li>
<li><kbd>Failure(String)</kbd>: This is sent <span>by <kbd>FetchService</kbd> when any of the preceding requests have failed as the service returns a failure response.</span></li>
</ul>
<p>For example, let's see the code that handles the <kbd>EditPressed</kbd> message. Its first part is as follows:</p>
<pre>self.fetching = true;<br/>self.console.log(&amp;format!("EditPressed: {:?}.", id));<br/>let callback =<br/>    self.link<br/>        .send_back(move |response: Response&lt;Json&lt;Result&lt;Person, Error&gt;&gt;&gt;| {<br/>            let (meta, Json(data)) = response.into_parts();<br/>            if meta.status.is_success() {<br/>                PersonsListMsg::ReadyPersonToEdit(data)<br/>            } else {<br/>                PersonsListMsg::Failure(<br/>                    "No person found with the indicated id".to_string(),<br/>                )<br/>            }<br/>        });</pre>
<p>Let's check the working of the code:</p>
<ul>
<li>First, the <span><kbd>fetching</kbd> state </span>is set to <kbd>true</kbd>, to take note that communication is underway.</li>
<li>Then a debug message is printed to the console of the browser.</li>
<li>Then, a callback is prepared to handle the response. To prepare such a callback, a <em>move</em> <span>closure, that is, a closure that gets ownership of all the variables it uses, is passed to the </span><kbd>send_back</kbd> function <span>of the</span> <kbd>link</kbd> <span>object.</span></li>
</ul>
<div class="packt_tip"><span>Remember that we come here when the user has pressed a button to edit a person specified by their ID; and so we need the whole of the person data to display it to the user.</span></div>
<p>The body of the callback is the code that we want to be executed after receiving a response from the server. Such a response, if successful, must contain all the data regarding the person we want to edit. So, this closure gets a <kbd>Response</kbd> object from the service. This type is actually parameterized by the possible contents of the response. In this project, we always expect a <kbd>yew::format::Json</kbd> payload and such a payload is a <kbd>Result</kbd>, which always has <kbd>failure::Error</kbd> as its error type. Though, the success type varies depending on the request type. In this particular request, we expect a <kbd>Person</kbd> object as a successful result.</p>
<p>The body of the closure calls the <kbd>into_parts</kbd> method on the response to destructure the response into the metadata and the data. The metadata is HTTP-specific information, while the data is the JSON payload.</p>
<p>Using the metadata, it is possible to check whether the response was successful (<kbd>meta.status.is_success()</kbd>). In such a case, the Yew message <kbd>ReadyPersonToEdit(data)</kbd> is triggered; such a message will handle the response payload. In the event of an error, a <span>Yew message of </span><kbd>Failure</kbd><span> is triggered; such a message will display the specified error message.</span></p>
<p>You could ask: "Why does the callback forward the payload to the Yew framework, specifying another message, instead of doing anything that should be done upon receipt of the response?"</p>
<p>The reason is that the callback, to be executed out of context by the framework, must be the owner of any variable it accesses after its creation, that is, when the request is sent, up to the time of its destruction (when the response is received). So, it cannot use the model or any other external variable. You cannot even print on the console or open an alert box inside such a callback. So you need to <span>asynchronously forward </span>the response to a message handler, which will be able to access the model.</p>
<p><span>The remaining part of the handler of the</span> <kbd>EditPressed</kbd> <span>message is this:</span></p>
<pre>let mut request = Request::get(format!("{}person/id/{}", BACKEND_SITE, id))<br/>    .body(Nothing)<br/>    .unwrap();<br/><br/>add_auth(&amp;self.username, &amp;self.password, &amp;mut request);<br/>self.ft = Some(self.fetch_service.fetch(request, callback));</pre>
<p>First, a web request is prepared, using the <kbd>get</kbd> method, which uses the <kbd>GET</kbd> HTTP method, and optionally specifying a <kbd>body</kbd>, which in this case is empty (<kbd>Nothing</kbd>).</p>
<p>Such a request is enriched with authentication information by a call of the <kbd>add_auth</kbd> common function, and finally, the <kbd>fetch</kbd> method of the <kbd>FetchService</kbd> object is invoked. This method uses the request and the callback to begin the communication with the server. It immediately returns a handle, stored in the <kbd>ft</kbd> field of the model.</p>
<p>Then the control returns to Yew, which can process other messages, until a response comes from the server. Such a response will be forwarded to the callback defined before.</p>
<p>Now, let's see the handler of the <kbd>ReadyPersonToEdit(person)</kbd> message, forwarded when a person structure is received from the server as a response to the request of editing a person by their <kbd>id</kbd>. Its code is as follows:</p>
<pre>self.fetching = false;<br/>let person = person.unwrap_or(Person {<br/>    id: 0,<br/>    name: "".to_string(),<br/>});<br/>if let Some(ref go_to_page) = self.go_to_one_person_page {<br/>    self.console<br/>        .log(&amp;format!("ReadyPersonToEdit: {:?}.", person));<br/>    go_to_page.emit(Some(person.clone()));<br/>}</pre>
<p>First, the <span><kbd>fetching</kbd> state </span>is set to<span> </span><kbd>false</kbd>, to take note that the current communication is ended.</p>
<p>Then, if the received person was <kbd>None</kbd>,  such a value is replaced by a person having zero as <kbd>id</kbd> and an empty string as a name. Of course, it is an invalid person.</p>
<p>Then, a reference to the <kbd>go_to_one_person_page</kbd> field of the model is taken. This field can be <kbd>None</kbd> (in fact, only at the initialization stage), so, if it is not defined, nothing is done. This field is a Yew callback to jump to another page.</p>
<p>At last, a debug message is printed, and the callback is invoked using the <kbd>emit</kbd> method. This call receives a copy of the person to display on that page.</p>
<p><span>Now, let's see the handler of the </span><kbd>Failure(msg)</kbd><span> message, forwarded when an error is received from the server. This handler is shared by other requests, as it has the same behavior. Its code is as follows:</span></p>
<pre>self.fetching = false;<br/>self.console.log(&amp;format!("Failure: {:?}.", msg));<br/>self.dialog.alert(&amp;msg);<br/>return false;</pre>
<p>Again, the fetching state is set to <kbd>false</kbd> since the communication is ended.</p>
<p>A debug message is printed, and a message box is opened to show the user the error message. As long as such a message box is opened, the component is frozen, as no other message can be processed.</p>
<p>At last, the controller returns <kbd>false</kbd> to signal that no view needs to be refreshed. Notice that the default return value is <kbd>true</kbd> as, usually, the controller changes the model, and so the view must be refreshed as a consequence of that.</p>
<h1 id="uuid-53ed2e3d-21cb-4e3d-892c-ac86815f0de8">Summary</h1>
<p>We have seen how a complete frontend web app can be built using Rust, by using the <kbd>cargo-web</kbd> command, the Wasm code generator, and the Yew framework. Such apps are modular and well structured, as they use the Elm Architecture, which is a variant of the MVC architectural pattern.</p>
<p>We created six apps, and we <span>saw how they worked—</span><kbd>incr</kbd>, <kbd>adder</kbd>, <kbd>login</kbd>, <kbd>yauth</kbd>, <kbd>persons_db</kbd>, and <kbd>yclient</kbd>.</p>
<p>In particular, you learned h<span>ow to build and run a Wasm project. We looked at</span><span> the MVC architectural pattern for building interactive apps. We covered h</span><span>ow the Yew framework supports the creation of apps implementing an MVC pattern, specifically according to the Elm Architecture. We also saw h</span><span>ow to structure an app in several components and h</span><span>ow to keep a common header and footer, while the body of the app changes from page to page. And at the end, we learned h</span><span>ow to use Yew to communicate with a backend app, possibly running on a different computer, packaging data in JSON format.</span></p>
<p>In the next chapter, we will see how to build a web game using Wasm and the Quicksilver framework.</p>
<h1 id="uuid-14a3a3a0-5852-4a2b-a6c2-dc0a6f90c663">Questions</h1>
<ol>
<li>What is WebAssembly, and what are its advantages?</li>
<li>What is the MVC pattern?</li>
<li>What are messages in the Elm Architecture?</li>
<li>What are components in the Yew framework?</li>
<li>What are properties in the Yew framework?</li>
<li>How can you build a web app with a fixed header and footer and change the inner section using the Yew framework?</li>
<li>What are callbacks in the Yew framework?</li>
<li>How can you pass a shared object, such as a database connection, between Yew components?</li>
<li>Why you must keep in the model a field having type FetchTask, when you communicate with a server, even if you don't need to use it?</li>
<li>How can you open JavaScript-style alert boxes and confirm boxes using the Yew framework?</li>
</ol>
<h1 id="uuid-23110c89-a8c7-4a9a-a506-5e0df3c6ef4a">Further reading</h1>
<ul>
<li>The Yew project can be downloaded from here: <a href="https://github.com/DenisKolodin/yew">https://github.com/DenisKolodin/yew</a>. The repository contains a very short tutorial and many examples.</li>
<li>You can find other info about generating Wasm code from a Rust project at: <a href="https://github.com/koute/cargo-web">https://github.com/koute/cargo-web</a>.</li>
<li><span>The status of web development libraries and frameworks: </span><a href="https://www.arewewebyet.org/">https://www.arewewebyet.org/</a></li>
<li><span>The status of game development libraries and frameworks: </span><a href="https://arewegameyet.com/">https://arewegameyet.com/</a></li>
<li><span>The status of programmers' editors and IDEs: </span><a href="https://areweideyet.com/">https://areweideyet.com/</a></li>
<li><span>The status of asynchronous programming libraries: </span><a href="https://areweasyncyet.rs/">https://areweasyncyet.rs/</a></li>
<li><span>The status of GUI development libraries and frameworks: </span><a href="https://areweguiyet.com/">https://areweguiyet.com/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>