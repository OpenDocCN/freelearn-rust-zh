["```rs\n        //-- #########################\n        //-- Task: To create a sample module to illustrate\n        how to use a module in rust\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        // Defined module named `sample_mod`\n        mod sample_mod {\n          // By default all the items in module have private\n          visibility\n\n        fn private_function() {\n          println!(\"called `sample_mod::private_function()`\n          \\n\");\n        }\n\n```", "```rs\n        // Using the `pub` keyword changes it visibility to public\n        pub fn sample_function() {\n          println!(\"called `sample_mod::sample_function()` \\n\");\n        }\n\n```", "```rs\n        // Public items of the module can access the private visible\n        items \n        pub fn indirect_private_fn() {\n          print!(\"called `sample_mod::indirect_access()`, that \\n \");\n          private_function();\n        }\n       }\n\n```", "```rs\n        // Created a sample function to illustrate calling of \n        fn sample_function() {\n          println!(\"Called the `sample_function()` which is not a part\n          of\n          mod `sample_mod` \\n\");\n        }\n\n```", "```rs\n        // Execution of the program starts from here\n        fn main() {\n          // Calling the sample_function which is outside module\n          sample_function();\n\n          // Calling the public visible sample_mod's sample_function\n          sample_mod::sample_function();\n\n          // Accessing the private function indirectly\n          sample_mod::indirect_private_fn();\n\n          // Error! `private_function` is private\n          //sample_mod::private_function(); // TODO ^ Try uncommenting\n          this line \n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: To create a sample nested_mod module\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        // Defined module named `sample_mod`\n        mod sample_mod {\n\n```", "```rs\n        // Defined public Nested module named `nested_mod`\n         pub mod nested_mod {\n           pub fn function() {\n             println!(\"called `sample_mod::nested_mod::function()`\");\n           }\n\n```", "```rs\n        #[allow(dead_code)]\n        fn private_function() {\n          println!(\"called\n          `sample_mod::nested_mod::private_function()`\");\n        }\n        }\n\n```", "```rs\n        // Nested modules follow the same rules for visibility\n        mod private_nested_mod {\n          #[allow(dead_code)]\n          pub fn function() {\n            println!(\"called\n            `sample_mod::private_nested_mod::function()`\");\n          }\n        }\n        }\n\n```", "```rs\n        // Execution starts from main function\n        fn main() {\n          sample_mod::nested_mod::function();\n          // Private items of a module cannot be directly accessed,even\n          if nested_mod in a public module\n\n          // Error! `private_function` is private\n          //sample_mod::nested_mod::private_function(); // TODO ^ Try\n          uncommenting this line\n\n          // Error! `private_nested_mod` is a private module\n          //sample_mod::private_nested_mod::function(); // TODO ^ Try\n          uncommenting this line\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: To create a sample nested_mod module\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        // Sample module which has struct item\n        mod sample_struct {\n          // A public struct with a public field of generic type `T`\n          pub struct WhiteBox<T> {\n            pub information: T,\n          }\n\n```", "```rs\n        // A public struct with a private field of generic type `T`\n        #[allow(dead_code)]\n        pub struct BlackBox<T> {\n        information: T,\n        }\n\n```", "```rs\n        impl<T> BlackBox<T> {\n          // A public constructor method\n          pub fn const_new(information: T) -> BlackBox<T> {\n            BlackBox {\n              information: information,\n            }\n          }\n        }\n        }\n\n```", "```rs\n        // Execution starts here\n        fn main() {\n\n          // Public structs with public fields can be constructed as\n          usual\n          let white_box = sample_struct::WhiteBox { information:\n          \"public\n          information n\" };\n\n        // and their fields can be normally accessed.\n        println!(\"The white box contains: {} \\n\",\n        white_box.information);\n        // Public structs with private fields cannot be constructed\n        using field names.\n        // Error! `BlackBox` has private fields\n        //let black_box = sample_struct::BlackBox { information:\n        \"classified information\" };\n        // TODO ^ Try uncommenting this line\n        // However, structs with private fields can be created using\n\n        // public constructors\n        let _black_box = sample_struct::BlackBox::const_new(\"classified\n        information \\n\");\n\n        // and the private fields of a public struct cannot be\n        accessed.\n        // Error! The `information` field is private\n        //println!(\"The black box contains: {}\",\n        _black_box.information);\n        // TODO ^ Try uncommenting this line\n        }\n\n```", "```rs\npub mod root {\n    use self::foo::create_foo;\n    mod foo {\n        pub struct Foo {\n            i: i32,\n        }\n        impl Foo{\n            pub fn hello_foo(&self){\n                println!(\"Hello foo\");\n            }\n        }\n        pub fn create_foo(i: i32) -> Foo{\n            Foo { i: i }\n        }\n    }\n    pub mod bar {\n        pub struct Bar {\n            pub f: ::root::foo::Foo,\n        }\n        impl Bar {\n            pub fn new(i: i32) -> Self {\n                Bar { f: ::root::foo::create_foo(i) }\n            }\n        }\n    }\n}\nfn main() {\n    //still private\n    //let f = root::foo::create_foo(42);\n    let b = root::bar::Bar::new(42);\n    b.f.hello_foo();\n}\n\n```", "```rs\n        //-- #########################\n        //-- Task: To create a sample module to illustrating `use`\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        // Bind the `deeply::nested::function` path to\n        `other_function`.\n        use deeply::nested::sample_function as other_function;\n\n```", "```rs\n        // Defined a nested \n        mod deeply {\n          pub mod nested {\n            pub fn sample_function() {\n              println!(\"called `deeply::nested::function()` \\n\")\n            }\n          }\n        }\n\n```", "```rs\n        fn sample_function() {\n          println!(\"called `function()` \\n\");\n        } \n\n```", "```rs\n        fn main() {\n          // Easier access to `deeply::nested::function`\n          other_function();\n\n```", "```rs\n        println!(\"Entering a block n\");\n        {\n          // This is equivalent to `use deeply::nested::sample_function\n          as sample_function`.\n          // This `sample_function()` will shadow the outer one.\n          use deeply::nested::sample_function;\n          sample_function();\n\n        // `use` bindings have a local scope. In this case, the\n        // shadowing of `function()` is only in this block.\n        println!(\"Leaving the block \\n\");\n        }\n\n```", "```rs\n        sample_function();\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: To create a sample module to illustrating `self` and\n        `super`\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        fn sample_function() {\n          println!(\"called `sample_function()`\");\n        }\n\n```", "```rs\n        // Ddefined a module names cool\n        mod cool {\n          pub fn sample_function() {\n            println!(\"called `cool::sample_function()` \\n\");\n          }\n        }\n\n```", "```rs\n        mod sample_mod {\n          fn sample_function() {\n            println!(\"called `sample_mod::sample_function()` \\n\");\n          }\n\n```", "```rs\n        mod cool {\n          pub fn sample_function() {\n            println!(\"called `sample_mod::cool::sample_function()`\n            \\n\");\n          }\n        }\n\n```", "```rs\n        pub fn indirect_call() {\n          // Let's access all the sample_functions named\n          `sample_function` from\n          this scope!\n          print!(\"called `sample_mod::indirect_call()`, that \\n > \");\n\n```", "```rs\n        // The `self` keyword refers to the current module scope - in\n        this case\n        `sample_mod`.\n        // Calling `self::sample_function()` and calling\n        `sample_function()`\n        directly both give\n        // the same result, because they refer to the same\n        sample_function.\n        self::sample_function();\n        sample_function();\n\n        // We can also use `self` to access another module inside\n        `sample_mod`:\n        self::cool::sample_function();\n\n        // The `super` keyword refers to the parent scope (outside the\n        `sample_mod` module).\n        super::sample_function();\n\n```", "```rs\n        // This will bind to the `cool::sample_function` in the *crate*\n        scope.\n        // In this case the crate scope is the outermost scope.\n        {\n          use cool::sample_function as root_sample_function;\n          root_sample_function();\n        }\n        }\n        }\n\n```", "```rs\n        // Execution starts here\n        fn main() {\n          // Calling the sample_mod module's item \n          sample_mod::indirect_call();\n        }\n\n```", "```rs\n touch sample_split.rs && mkdir sample_module\n\n```", "```rs\n cd sample_module && touch mod.rs nested_mod.rs\n sample_private.rs\n\n```", "```rs\n        //-- #########################\n        //-- Task: To create a sample file structure\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        // Using the contents of sample_module\n        mod sample_module;\n\n```", "```rs\n        // Defining a local sample_function\n        fn sample_function() {\n          println!(\"called `sample_function()`\");\n        }\n\n```", "```rs\n        // Execution starts here\n        fn main() {\n          sample_module::sample_function();\n          sample_function();\n          sample_module::indirect_access();\n          sample_module::nested_mod::sample_function();\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: To create a sample file structure\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        // Similarly `mod sample_private` and `mod nested_mod` will\n        locate the\n        `nested_mod.rs`\n        // and `sample_private.rs` files and insert them here under\n        their\n        respective\n        // modules\n        mod sample_private;\n        pub mod nested_mod;\n\n```", "```rs\n        pub fn sample_function() {\n          println!(\"called `sample_module::sample_function()`\");\n        }\n\n```", "```rs\n        fn private_function() {\n          println!(\"called `sample_module::private_function()`\");\n        }\n\n```", "```rs\n        pub fn indirect_access() {\n          print!(\"called `sample_module::indirect_access()`, that \\n>\n          \");\n          private_function();\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Nested module\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        // sample_mod/nested.rs\n        pub fn sample_function() {\n          println!(\"called\n          `sample_module::nested::sample_function()`\");\n        }\n\n```", "```rs\n        #[allow(dead_code)]\n        fn private_function() {\n          println!(\"called\n          `sample_module::nested::private_function()`\");\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Inaccessible script\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        #[allow(dead_code)]\n        pub fn public_function() {\n          println!(\"called\n          `sample_module::sample_private::public_function()`\");\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: To create a sample library in rust\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        pub fn public_function() {\n          println!(\"called sample_lib `public_function()`\");\n        }\n\n```", "```rs\n        fn private_function() {\n          println!(\"called sample_lib `private_function()`\");\n        }\n\n```", "```rs\n        pub fn indirect_access() {\n          print!(\"called sample_lib `indirect_access()`, that \\n > \");\n          private_function();\n        }\n\n```", "```rs\nrustc --crate-type=lib sample_lib.rs\n\n```", "```rs\n        //-- #########################\n        //-- Task: To create a sample executor of sample_lib in rust\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 4 March 17\n        //-- #########################\n\n```", "```rs\n        // Imports all items under sample_lib\n        extern crate sample_lib;\n\n```", "```rs\n        fn main() {\n          // Calling public_function\n          sample_lib::public_function();\n          // Calling indirect_access to private_function\n          sample_lib::indirect_access();\n        }\n\n```", "```rs\nrustc sample_exec.rs --extern sample_lib=libsample_lib.rlib\n\n```"]