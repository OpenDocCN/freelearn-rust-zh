["```rs\n> echo hope | cargo +nightly run --release --example hex -p stdsimd\n    Finished release [optimized + debuginfo] target(s) in 0.52s\n     Running `target/release/examples/hex`\n686f70650a\n```", "```rs\n#![feature(stdsimd)]\n#![cfg_attr(test, feature(test))]\n#![cfg_attr(feature = \"cargo-clippy\",\n            allow(result_unwrap_used, print_stdout, option_unwrap_used,\n                  shadow_reuse, cast_possible_wrap, cast_sign_loss,\n                  missing_docs_in_private_items))]\n\n#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n#[macro_use]\nextern crate stdsimd;\n\n#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\nextern crate stdsimd;\n```", "```rs\n#[cfg(test)]\n#[macro_use]\nextern crate quickcheck;\n\nuse std::io::{self, Read};\nuse std::str;\n\n#[cfg(target_arch = \"x86\")]\nuse stdsimd::arch::x86::*;\n#[cfg(target_arch = \"x86_64\")]\nuse stdsimd::arch::x86_64::*;\n```", "```rs\nfn main() {\n    let mut input = Vec::new();\n    io::stdin().read_to_end(&mut input).unwrap();\n    let mut dst = vec![0; 2 * input.len()];\n    let s = hex_encode(&input, &mut dst).unwrap();\n    println!(\"{}\", s);\n}\n```", "```rs\nfn hex_encode<'a>(src: &[u8], dst: &'a mut [u8]) -> Result<&'a str, usize> {\n    let len = src.len().checked_mul(2).unwrap();\n    if dst.len() < len {\n        return Err(len);\n    }\n```", "```rs\n    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        if is_x86_feature_detected!(\"avx2\") {\n            return unsafe { hex_encode_avx2(src, dst) };\n        }\n        if is_x86_feature_detected!(\"sse4.1\") {\n            return unsafe { hex_encode_sse41(src, dst) };\n        }\n    }\n\n    hex_encode_fallback(src, dst)\n}\n```", "```rs\nfn hex_encode_fallback<'a>(\n    src: &[u8], dst: &'a mut [u8]\n) -> Result<&'a str, usize> {\n    fn hex(byte: u8) -> u8 {\n        static TABLE: &[u8] = b\"0123456789abcdef\";\n        TABLE[byte as usize]\n    }\n\n    for (byte, slots) in src.iter().zip(dst.chunks_mut(2)) {\n        slots[0] = hex((*byte >> 4) & 0xf);\n        slots[1] = hex(*byte & 0xf);\n    }\n\n    unsafe { Ok(str::from_utf8_unchecked(&dst[..src.len() * 2])) }\n}\n```", "```rs\n#[target_feature(enable = \"avx2\")]\n#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\nunsafe fn hex_encode_avx2<'a>(\n    mut src: &[u8], dst: &'a mut [u8]\n) -> Result<&'a str, usize> {\n```", "```rs\n    let ascii_zero = _mm256_set1_epi8(b'0' as i8);\n    let nines = _mm256_set1_epi8(9);\n    let ascii_a = _mm256_set1_epi8((b'a' - 9 - 1) as i8);\n    let and4bits = _mm256_set1_epi8(0xf);\n```", "```rs\n    let mut i = 0_isize;\n    while src.len() >= 32 {\n        let invec = _mm256_loadu_si256(src.as_ptr() as *const _);\n```", "```rs\n        let masked1 = _mm256_and_si256(invec, and4bits);\n        let masked2 = _mm256_and_si256(\n            _mm256_srli_epi64(invec, 4),\n            and4bits\n        );\n```", "```rs\n        let cmpmask1 = _mm256_cmpgt_epi8(masked1, nines);\n        let cmpmask2 = _mm256_cmpgt_epi8(masked2, nines);\n```", "```rs\n        let masked1 = _mm256_add_epi8(\n            masked1,\n            _mm256_blendv_epi8(ascii_zero, ascii_a, cmpmask1),\n        );\n        let masked2 = _mm256_add_epi8(\n            masked2,\n            _mm256_blendv_epi8(ascii_zero, ascii_a, cmpmask2),\n        );\n```", "```rs\n        let res1 = _mm256_unpacklo_epi8(masked2, masked1);\n        let res2 = _mm256_unpackhi_epi8(masked2, masked1);\n```", "```rs\n        let base = dst.as_mut_ptr().offset(i * 2);\n        let base1 = base.offset(0) as *mut _;\n        let base2 = base.offset(16) as *mut _;\n        let base3 = base.offset(32) as *mut _;\n        let base4 = base.offset(48) as *mut _;\n        _mm256_storeu2_m128i(base3, base1, res1);\n        _mm256_storeu2_m128i(base4, base2, res2);\n        src = &src[32..];\n        i += 32;\n    }\n```", "```rs\n    let i = i as usize;\n    let _ = hex_encode_sse41(src, &mut dst[i * 2..]);\n\n    Ok(str::from_utf8_unchecked(\n        &dst[..src.len() * 2 + i * 2],\n    ))\n}\n```", "```rs\ntrait Bad1 {\n    fn bad1(&self);\n}\n\nimpl<T> Bad1 for T {\n    default fn bad1(&self) {\n        println!(\"generic\");\n    }\n}\n\n// Specialization cannot work: trans doesn't know if T: 'static\nimpl<T: 'static> Bad1 for T {\n    fn bad1(&self) {\n        println!(\"specialized\");\n    }\n}\n\nfn main() {\n    \"test\".bad1()\n}\n```"]