- en: '*Chapter 4*: Managing Environment, Command Line, and Time'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how the Rust Standard Library is structured.
    We also wrote a portion of a basic template engine that can generate dynamic HTML
    page components given an HTML template and data. From here onward, we will start
    to deep-dive into specific modules of the standard library grouped by functional
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at Rust Standard Library modules that pertain
    to working with system environment, command-line, and time-related functions.
    The goal of this chapter is for you to gain more proficiency in working with *command-line
    parameters*, *path manipulation, environment variables*, and *time measurements.*
  prefs: []
  type: TYPE_NORMAL
- en: What is the benefit of learning about these?
  prefs: []
  type: TYPE_NORMAL
- en: Working with *command-line arguments* is a required skill for writing any program
    that accepts user inputs from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine how you would write a tool (such as **find** or **grep**) that deals
    with searching for files and patterns within folders and subfolders. This requires
    knowledge of *path manipulation*, including navigating paths and reading and manipulating
    path entries.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to use *environment variables* is an essential part of separating the
    code from the configuration, which is a good practice for any kind of program.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to work with time is required for programs that deal with timestamps
    of resources and activities. Learning how to do *time measurements* to record
    time intervals between events is needed for benchmarking the time taken for various
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing Rust programs that can discover and manipulate the system environment
    and filesystem across Linux, Unix, and Windows platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating programs that can use command-line arguments to accept configuration
    parameters and user inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing elapsed time between events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are relevant skills to have for systems programming in Rust. We will learn
    these topics in a practical way by developing a command-line application for image
    processing. Along the way, we will see more details about the `path`, `time`,
    `env`, and `fs` modules of the Rust Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's see what we will be building.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we had a tool for bulk image resizing – tool that would look through
    a filesystem directory on a desktop or server, pull out all the image files (for
    instance, `.png` and `.jpg`), and resize all of them to predefined sizes (for
    example, small, medium, or large).
  prefs: []
  type: TYPE_NORMAL
- en: Think about how helpful such a tool would be for freeing up space on the hard
    disk, or for uploading pictures to show in a mobile or web app. We will be building
    such a tool. Fasten your seat belts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the topics in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Project scope and design overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the image resizing library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the command-line application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GitHub repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Project scope and design overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will first define what we are going to build and look at
    the technical design. We will then code a Rust library for image processing. Finally,
    we will build a command-line application that accepts user inputs through the
    command line and uses the image resizing library we have built to perform user-specified
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: What will we build?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will describe the functional requirements, technical
    requirements, and project structure for the tool we are building.
  prefs: []
  type: TYPE_NORMAL
- en: Functional requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will build a command-line tool that performs the following two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image resize**: Resizes one or more images in a source folder to a specified
    size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image stats**: Provides some statistics on the image files present in the
    source folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s name the tool **ImageCLI**. *Figure 4.1* shows the two main features
    of the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Features of ImageCLI tool](img/Figure_4.1_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Features of ImageCLI tool
  prefs: []
  type: TYPE_NORMAL
- en: 'Users will be able to resize images using this tool. The user can ask to resize
    either a single image or multiple images. Supported *input* image formats are
    JPG and PNG. The supported *output* image format is PNG. The tool will accept
    three command-line parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size = small`, the output image will have *200* pixels of width; for `size
    = medium`, the output file will have *400* pixels of width; and for `size = large`,
    the output will have *800* pixels of width. For example, if the input image is
    a JPG file with a total size of 8 MB, it can be resized to approximately < 500
    KB in size by specifying `size = medium`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode = single` for resizing a single file, or `mode = all` for resizing all
    image files in a specified folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode = single` or `mode = all` is chosen. For `mode = single`, the user specifies
    the value of `srcfolder` as the full path of the image file with its filename.
    For `mode = all`, the user specifies, for the value of `srcfolder`, the full path
    of the folder (the one containing the image files) without any image filenames.
    For example, if `mode = single` and `srcfolder = /user/bob/images/image1.png`
    are used, the tool will resize the single image file of `image1.png`, contained
    in the `/user/bob/images` folder. If `mode = all` and `srcfolder = /user/bob/images`
    are used, the tool will resize *all* the image files contained in the `/user/bob/images`
    source folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our image stats functionality, users will also be able to specify a `srcfolder`
    containing the image files and get back the number of image files in that folder,
    along with the total size of all those image files. For example, if `srcfolder=/user/bob/images`
    is used, the `image stats` option will give a result similar to the following:
    **The folder contains 200 image files with total size 2,234 MB**.'
  prefs: []
  type: TYPE_NORMAL
- en: Non-functional requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are a list of non-functional (technical) requirements for the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool will be packaged and distributed as a binary and it should work on
    three platforms: Linux, Unix, and Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should be able to measure the time taken to resize the images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User inputs for specifying command-line flags must be *case-insensitive* for
    ease of use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool must be able to display meaningful error messages to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core functionality of image resizing must be separate from the **command-line
    interface** (**CLI**). This way, we have the flexibility of reusing the core functionality
    with a desktop graphical interface or as part of a web backend in a web application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project will be organized as a **library** containing the image processing
    functionality and a **binary** that provides the CLI to read and parse user input,
    provide error messages, and display output messages to the user. The binary will
    make use of the library for core image processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create the project skeleton so we can visualize the project structure
    better. Create a new `lib` project using `cargo`. Let''s name the CLI tool as
    `imagecli` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Cargo project structure](img/Figure_4.2_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Cargo project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the project structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `src` folder, create a subfolder called `imagix` (for image magic!)
    to host the library code. Under the `imagix` subfolder, create four files: `mod.rs`,
    which is the entry point into the `imagix` library, `resize.rs` to host the code
    related to image resizing, `stats.rs` to host the code for image file statistics,
    and `error.rs` to contain the custom error type and error handling code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the `src` folder, create a new file called `imagecli.rs`, which will contain
    the code for the CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this subsection, we have seen the feature requirements for the tool and the
    desired project structure. In the next subsection, we will look at the design
    for the tool.
  prefs: []
  type: TYPE_NORMAL
- en: Technical design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will look at the high-level design of the tool, primarily
    focusing on the image processing feature. We will design the specifics of the
    CLI in the *Developing the command-line application and testing* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our project comprises our reusable `imagix` library containing the core functionality
    for image resizing and statistics, and a binary executable, `imagecli`, with a
    CLI. This is depicted in *Figure 4.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – CLI tool with a reusable library](img/Figure_4.3_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – CLI tool with a reusable library
  prefs: []
  type: TYPE_NORMAL
- en: If the library is designed right, it can be reused in the future for other types
    of clients; for example, the application can be provided with a graphical user
    interface (instead of a CLI) as a desktop application, or can even be made accessible
    from a browser-based HTML client app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin the design, let''s try to visualize a few of the key technical
    challenges we have to overcome and solve:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/tmp/` subfolder to store the resized images?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we measure the time taken for image resizing?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Resizing multiple images**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we iterate through the source folder provided by the user to identify
    all the image files and invoke the image resizing function for each entry?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Getting image statistics**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we scan through the user-provided source folder, count only the number
    of image files, and get the aggregate file size of all image files in that folder?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`tmp` subfolder?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding points can be grouped into three broad categories of concerns
    for design purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Image resizing logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path manipulation and directory-iteration logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring time taken for image resizing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image processing is a highly-specialized domain in itself, and it is beyond
    the scope of this book to cover the techniques and algorithms involved. Given
    the complexity and scope of the image processing domain, we will use a third-party
    library that will implement the needed algorithms and provide us with a nice API
    to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we will use the `image-rs/image` open source crate that is
    written in Rust. The crate docs are at the following link: [https://docs.rs/image/](https://docs.rs/image/)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can design the `imagix` library using the `image` crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `image` crate is fully featured and has many image processing functions.
    We will however use only a small subset of features for our project. Let''s recall
    our three key requirements for image processing: the ability to *open an image
    file and load it into memory*, the ability to *resize the image to a desired size*,
    and the ability to *write the resized image from memory into a file* on the disk.
    The following methods in the `image-rs/image` crate address our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image::open()`: This function opens an image at the specified path. It automatically
    detects the format of the image from the image''s file extension. The image data
    is read from the file and converted into a `DynamicImage` type stored in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DynamicImage::thumbnail()`: This function scales an image down to a specified
    size (width and height) and returns a new image while preserving the aspect ratio.
    It uses a fast integer algorithm, which is a sinusoidal transformation technique.
    This is an **in-memory operation**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DynamicImage::write_to()`: This function encodes an image and writes it to
    any object that implements the `std::io::write` trait, which in our case will
    be an output *file handle*. We will use this method to write the resized image
    to a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should be adequate for our image processing requirements in this project.
    For the other two concerns around path manipulation and time measurements, we
    will use the Rust Standard Library, which is described in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Rust Standard Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For developing the image resizing tool, we will be using both external crates
    and the Rust Standard Library. In the previous section, we saw how we plan to
    use the `image` crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the features of the Rust Standard Library that
    we will be using to build our project. There are three key areas where we will
    need the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: The *path manipulation and directory iteration* functionality is needed in order
    to search through a directory, locate the image files, and create a new subfolder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to get tool configuration options from the user. We will evaluate two
    approaches – getting this information through *environment variables* and getting
    it through *command-line parameters*. We will choose one of the options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to *measure the time taken* for the image resizing tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each of these areas in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Path manipulation and directory iteration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For path manipulation, we will use the `std::path` module from the Rust Standard
    Library. For directory iteration, we will use the `std::fs` module.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to manipulate paths?
  prefs: []
  type: TYPE_NORMAL
- en: The source image files for resizing are stored in the *source folder*. The destination
    path for the resized image files is the `tmp` subfolder (within the *source folder*).
    Before writing each resized image file to disk, we have to construct the path
    where the file is to be stored. For example, if the path for the source file is
    `/user/bob/images/image1.jpg`, the destination path for the resized image will
    be `/user/bob/images/tmp/image1.jpg`. We have to construct the destination path
    programmatically, and then call the method on the `image` crate to store the image
    on the destination path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rust Standard Library supports path manipulation functionality through
    two data types: `Path` and `PathBuf`, both part of the `std::path` module. See
    the sidebar for more details on how to construct and manipulate `paths` using
    the standard library.'
  prefs: []
  type: TYPE_NORMAL
- en: The std::path module of the Rust Standard Library
  prefs: []
  type: TYPE_NORMAL
- en: This module provides cross-platform path manipulation functions.
  prefs: []
  type: TYPE_NORMAL
- en: A path points to a filesystem location by following a directory tree. An example
    of a path in Unix systems is `/home/bob/images/`. An example of a path on the
    Windows operating system could be `c:\bob\images\image1.png`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main types in the `std::path` module that are commonly used—`Path`
    and `PathBuf`.
  prefs: []
  type: TYPE_NORMAL
- en: For parsing the path and its components (read operations), `Path` is used. In
    Rust parlance, it is a **path slice** (like a string slice, which is a reference
    to a string).
  prefs: []
  type: TYPE_NORMAL
- en: For modifying existing paths or to construct new paths, `PathBuf` is used. `PathBuf`
    is an **owned**, **mutable path**.
  prefs: []
  type: TYPE_NORMAL
- en: '`Path` is used for read operations and `PathBuf` for read and write operations
    on paths.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to construct a new path from a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '`let path_name = Path::new("/home/alice/foo.txt");`'
  prefs: []
  type: TYPE_NORMAL
- en: In `path_name`, `/home/alice` represents the parent, `foo` is the file stem,
    and `txt` is the file extension. We will be making use of the `file_stem()` and
    `extension()` methods on the `Path` type.
  prefs: []
  type: TYPE_NORMAL
- en: The `pop()` and `push()` methods on the `PathBuf` type are used to truncate
    and append components to a path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `PathBuf` path with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`let mut path_for_editing = PathBuf::from("/home/bob/file1.png")`'
  prefs: []
  type: TYPE_NORMAL
- en: '`path_for_editing.pop()` truncates this path to its parent, that is, `"/home/bob"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, `push()` can be used to append a new component to `PathBuf`. For example,
    continuing from `PathBuf` with the value `"/home/bob"`, `push("tmp")` will append
    `tmp` to `"/home/bob"` path and return `"/home/bob/tmp"`.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the `pop()` and `push()` methods in our project to manipulate
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: Let's next look at how to perform the directory operations needed for our project.
  prefs: []
  type: TYPE_NORMAL
- en: When the user specifies `mode=all`, our requirement is to iterate through all
    the files in the specified source folder and filter the list of image files for
    processing. For iterating over directory paths, we will use the `read_dir()` function
    in the `std::fs` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of how to use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the explanation for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fs:read_dir()` takes a source folder path and returns `std::fs::ReadDir`,
    which is an iterator over entries in the directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use a `for` loop to extract each directory entry (which is wrapped in
    a `Result` type), and print out its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the code we will use to get entries in a directory and do further processing.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from reading a directory for its contents, we also need to check for the
    presence of a `tmp` subfolder under the source folder and create it if it does
    not already exist. We will use the `create_dir()` method from the `std::fs` module
    to create a new subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: We will see more details of the `std::fs` module in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Time measurement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For measuring time, we can use the `std::time` module.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::time` module in the Rust Standard Library has several time-related
    functions including getting the *current system time*, creating a *duration* to
    represent a span of time, and measuring the *time elapsed* between two specific
    time instants. Some examples of using the `time` module are provided in the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the current system time, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how to get the elapsed time from a given point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`Instant::now()` is used to indicate the starting point of the time to be measured.
    The time duration between this point and the point at which `now.elapsed()` is
    called represents the time taken for the operation(s). Here, we are simulating
    a delay using the `sleep()` function from the `std::thread` module.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this subsection, we will learn how to use the Rust Standard Library, along
    with a third-party helper crate, to store the values in environment variables
    and use them in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project with the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[dependencies]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dotenv = "0.15.0"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main.rs`, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we import the `std::env` module and also the `dotenv::dotenv`
    module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following statement loads the environment variables from an `.env` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `for` loop in the previous code block iterates through the environment variables
    in a loop and prints them to the console. `env:vars()` returns an iterator of
    key-value pairs for all environment variables of the current process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test this, let''s create a new`.env` file in the project root and make the
    following entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `srcfolder` value with your own. Run the program with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To access the value of any particular environment variable, the `std::env::var()`
    function can be used, which takes the key of the variable as a parameter. Add
    the following statement to the `main()` function and see the value of the `size`
    variable printed out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have seen how to use *environment variables* to accept user inputs for image
    processing. Let's see how to accept user inputs with *command-line* parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Working with command-line parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this subsection, we will learn to read command-line parameters using the
    `std::env` module of the Rust Standard Library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::env` module supports command-line parameters through `std::env::args()`.
    Create a new Cargo project. Add the following line to the `main()` function in
    `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute the code with `cargo run small all /tmp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The three parameters passed to the program will be printed out to the console.
    To access individual parameters by index, add the following code to `main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program with `cargo run small all /tmp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The individual values for `size`, `mode`, and `source_folder` will be printed
    out as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Of the two approaches we have seen – that is, using *environment variables*
    and *command-line parameters* – the latter is more suitable for accepting inputs
    from end users, while the environment variable approach is more suitable for developers
    configuring the tool.
  prefs: []
  type: TYPE_NORMAL
- en: However, for a user-friendly interface, the bare-bones functionality offered
    by `std::env::args` is inadequate. We will use a third-party crate called **StructOpt**
    to improve the user interaction with the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the deep dive into the Rust Standard Library modules for path
    manipulation, time measurement, and reading environment and command-line parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a summary of the design approaches we have discussed, for the `imagix`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image-rs/image` crate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we create a `/tmp/` subfolder to store the resized images?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will use the `std::fs::create_dir()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`std::fs::read_dir()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we manipulate paths so that the output file is stored in the `tmp` subfolder?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will use the `std::path::Path` and `std::path::PathBuf` types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`std::path::Path` type and the `std::fs::read_dir()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::time::Duration` and `std::time::Instant` modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StructOpt` crate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we conclude this section on addressing project scope and design for
    the `imagix` library. We are now ready to start writing the code for the image
    processing library in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the imagix library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll write the code for the image resizing and image statistics
    functionalities. Let's first look at the code structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module structure of the `imagix` library is summarized in *Figure 4.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Modules of the imagix library](img/Figure_4.4_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Modules of the imagix library
  prefs: []
  type: TYPE_NORMAL
- en: The `imagix` library will consist of two modules, `resize.rs` and `stats.rs`
    respectively. There are two `enums`, `SizeOption` and `Mode`, for representing
    the variants for *size option* and *mode* respectively. The user will specify
    one of the variants of the `SizeOption` `enum` to indicate the desired output
    image size, and one of the variants of the `Mode` `enum` to indicate whether one
    or multiple images need to be resized. There is also `struct Elapsed` for capturing
    elapsed time of the image resizing operation.
  prefs: []
  type: TYPE_NORMAL
- en: The `resize` module has the `process_resize_request()` public function, which
    is the main entry point into the `imagix` library for resizing images.
  prefs: []
  type: TYPE_NORMAL
- en: The `stats` module has a `get_stats()` public function.
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview of the overall code organization of the project is shown in *Figure
    4.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Code organization](img/Figure_4.5_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Code organization
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.5* shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration and dependency entries needed in the `Cargo.toml` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Cargo project's code tree structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of source files of the `imagix` library along with a list of the key
    functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `imagecli.rs` file, which represents the command-line wrapper over the `imagix`
    library, and the code execution entry point in our tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first add the two external crates to `Cargo.toml` in the `imagecli`
    project folder root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we will walk through the code snippets for the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_image_files()`, which demonstrates path navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resize_image()`, which contains the core logic for image resizing using the
    image crate, and for time measurements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_stats()`, which returns the total count and the total size of image files
    in a folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom error handling methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the code is standard Rust (not specific to the topics this chapter
    is focused on) and can be found in the code repository for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through directory entries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this subsection, let's review the code for `get_image_files()`. This is the
    method that retrieves the list of image files contained in a source folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for this method is described here:'
  prefs: []
  type: TYPE_NORMAL
- en: We first retrieve the directory entries in the source folder and collect them
    in a *vector*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then iterate over entries in the vector and filter for only the image files.
    Note that we are only focusing on `PNG` and `JPG` files in this project, but it
    can be extended to other types of image files too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A list of image files is returned from this method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code listing is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/imagix/resize.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the `read_dir()` method to iterate through directory entries and
    collects the results in a `Vector`. The `Vector` is then converted into an iterator,
    and the entries are filtered to return only image files. This gives us the set
    of image files to work with, for resizing. In the next subsection, we will review
    the code to perform the actual resizing of the images.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this subsection, we will review the code for `resize_image()`. This method
    performs the resizing of images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The method accepts a source image filename with the full source folder path,
    resizes it as a `.png` file, and stores the resized file in a `/tmp` subfolder
    under the source folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, the source filename is extracted from the full path. The file extension
    is changed to `.png`. This is because our tool will only support output files
    in `.png` format. As an exercise, you can add support for other image format types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then the destination file path is constructed with the `/tmp` prefix, as the
    resized image will need to be stored in the `tmp` subfolder under the source folder.
    To achieve this, we first need to check whether the `tmp` folder already exists.
    If not, it has to be created. The logic for constructing the path with the `tmp`
    subfolder and for creating the `tmp` subfolder is shown in the previous code listing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to resize the image. For this, the source file is opened, the
    resize function is called with requisite parameters, and the resized image is
    written to the output file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The time taken for image resizing is calculated using the `Instant::now()` and
    `Elapsed::from()` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code listing is shown here. For purposes of explanation, the code listing
    has been split into multiple snippets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code listed here accepts three input parameters – the size, source folder,
    and an entry of type `PathBuf` (which can refer to the full path of an image file).
    The file extension is changed to `.png` as this is the output format supported
    by the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The code snippet here appends the suffix `/tmp` to the file path entry in order
    to create the destination folder path. Note that due to a limitation in the standard
    library, the filename is first constructed as `tmp.png`, which is subsequently
    changed to reflect the final resized image filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The code here opens the image file and loads the image data into memory. The
    `/tmp` subfolder is created under the source folder. Then, the image is resized
    and written to the output file in the destination folder. The time taken for the
    resizing operation is recorded and printed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen the code for resizing images. Next, we will look at the code
    for generating image stats.
  prefs: []
  type: TYPE_NORMAL
- en: Image statistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous subsection, we looked at the code for image resizing. In this
    subsection, we will see the logic for generating image statistics. This method
    will count the number of image files in a specified source folder, and measure
    their total file size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic of the `get_stats()` method that we will use is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_stats()` method takes a source folder as its input parameter and returns
    two values: the number of image files in the folder, and the total aggregate size
    of all image files in the folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a list of image files in the source folder by calling the `get_image_files()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `metadata()` function in the `std::path` module allows us to query a file
    or directory for its metadata information. In our code, as we iterate through
    the directory entries, we aggregate the sizes of all files in one variable, `sum`.
    The `sum` variable is returned from the function along with the count of image
    file entries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code listing is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/imagix/stats.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have covered the code for the image processing functionality. We will now
    cover some details of our custom error handling for the project.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's now take a look at our error handling design.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a part of our project, there may be many failure conditions that we have
    to handle. Some of them are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: The source folder given by the user may be invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specified file may not be present in the source folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our program may not have permission to read and write files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User inputs for size or mode may be incorrect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may be errors during image resizing (for example, a corrupt file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may be other types of internal processing errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define a custom error type to handle all these different types of errors
    in a unified manner, and provide the error as output to the users of our library:'
  prefs: []
  type: TYPE_NORMAL
- en: src/imagix/error.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The names of the errors are mostly self-explanatory. `FormatError` is any error
    encountered while converting or printing values of parameters. The goal of defining
    this custom error type is that the various types of errors that may be encountered
    during processing, such as errors in user input, the inability to read through
    a directory or write to a file, an error in image processing, and so on, are converted
    into our custom error type.
  prefs: []
  type: TYPE_NORMAL
- en: It is not enough to just define a custom error type. We also have to ensure
    that when errors happen in due course of the program's operation, these errors
    are translated into the custom error type. For example, an error in reading an
    image file raises an error defined in the `std::fs` module. This error should
    be caught and transformed into our custom error type. This way, regardless of
    whether there is an error in file operations or error processing, the program
    uniformly propagates the same custom error type for handling by the frontend interface
    to the user (in the case of this project, it is the command line).
  prefs: []
  type: TYPE_NORMAL
- en: For the conversion of various types of errors into `ImagixError`, we will implement
    the `From` trait. We will also implement the `Display` trait for our error type
    so that the errors can be printed out to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Within each of the methods in the project modules, at the failure points, you
    will notice that `ImagixError` is raised and propagated back to the calling function.
    The source code can be found in the source folder for this chapter in the Packt
    code repository.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the error handling subsection of the code.
  prefs: []
  type: TYPE_NORMAL
- en: This also concludes this section on coding the `imagix` library. We have only
    walked through key code snippets as it isn't practical to print out the entire
    code listing inline in the chapter. I would urge the reader to go through the
    entire source code to understand how the various features are translated into
    idiomatic Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will build the command-line application that wraps this
    library and provides the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the command-line application and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we built the library for image resizing. In this section,
    we will review the design and key parts of the code for the main command-line
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with some automated unit tests to test the image resizing functionality
    in `resize.rs`: This way we can confirm that the image resizing library works
    independently of any calling function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two test cases are shown here in the following code—one to resize a single
    image, and the other to resize multiple images. You can replace the source folder
    and filenames in the code with your own:'
  prefs: []
  type: TYPE_NORMAL
- en: src/imagix/resize.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Place the `image1.jpg` and `image2.jpg` files in `/tmp/images` and execute
    the tests with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can see the tests pass successfully. You can also inspect the resized images.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you can add the test cases for the image stats function as well.
  prefs: []
  type: TYPE_NORMAL
- en: We can now conclude that the `imagix` library works as intended. Let's now move
    on to designing the command-line application.
  prefs: []
  type: TYPE_NORMAL
- en: We shall first look at the CLI requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the command-line interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will look at the design of the CLI. By design, we mean
    finalizing the structure of the CLI that the user will use. The CLI should be
    intuitive to use for the end user. The CLI must also accommodate some flexibility
    in its performing of different types of operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `imagecli` CLI will use a command-subcommand model like `git`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CLI command structure is shown in *Figure 4.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Design of CLI commands](img/Figure_4.6_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Design of CLI commands
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of commands with parameters that the user can specify:'
  prefs: []
  type: TYPE_NORMAL
- en: For resizing images, the command is `cargo run –-release resize` with three
    parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For image statistics, the command is `cargo run –-release stats` with one parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For resizing a single image the command is `cargo run --release resize --size
    small --mode single --srcfolder <path-to-image-file/file-name.extn>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For resizing multiple images, we use the `cargo run --release resize --size
    medium --mode all --srcfolder <path-to-folder-containing-images>` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For image statistics, the `cargo run --release stats --srcfolder <path-to-folder-containing-images>`
    command is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `imagecli` `main()` function parses the command-line parameters, handles
    user and processing errors with suitable messages to the user, and invokes the
    respective functions from the `imagix` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a quick recap. To resize images, we need to know the following from
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: The mode (single or multiple files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output size of the image file (small/medium/large)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source folder where the image file (or files) is located
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we designed the CLI for the tool. In the previous sections,
    we built the `imagix` library to resize images. We will now move on to the last
    part of the project, which is to develop the main command-line binary application
    that ties all the pieces together and accepts user inputs from the command-line.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the command-line binary using structopt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we designed the interface for the command-line tool.
    In this section, we will see the code for the `main()` function that accepts user
    inputs from the command line and invokes the `imagix` library. This `main()` function
    will be compiled and built into the command-line binary tool. The user will invoke
    this executable for resizing images and provide the necessary command-line parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function will be located in `src/imagecli.rs`, as we want the command-line
    tool binary name to be `imagecli`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now review the code snippets for the command-line application. The `main()`
    function is located in the `src/imagecli.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the imports section. Note the imports of the `imagix` library
    that we have written, and `structOpt` for command-line argument parsing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now see the definition of the command-line parameters for the tool.
    For this we will use the `structopt` syntax. Refer to documentation at [https://docs.rs/structopt](https://docs.rs/structopt).
    Basically, we have defined an `enum` called `Commandline` and defined two subcommands,
    `Resize` and `Stats`. `Resize` takes three arguments: `size`, `mode` and `srcfolder`
    (the source folder). `Stats` takes one argument: `srcfolder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now review the code for the `main()` function. Here, we basically accept
    the command-line inputs (validated by `StructOpt`) and invoke the suitable methods
    from our `imagix` library. If the user specifies the `Resize` command, the `process_resize_request()`
    method of the `imagix` library is invoked. If the user specifies the `Stats` command,
    the `get_stats()` method of the `imagix` library is invoked. Any errors are handled
    with suitable messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the app with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reason to use the release builds is that there is a considerable time difference
    in resizing images between the debug and release builds (the latter being much
    faster).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then execute and test the following scenarios at the Terminal. Ensure
    to place one or more `.png` or `.jpg` files in the folder that you specify in
    `--srcfolder` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resize a single image**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Resize multiple files**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Generate image stats**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we have built a tool for image resizing that works from a CLI.
    As an exercise, you can experiment by adding additional features, including adding
    support for more image formats, changing the size of the output file, or even
    providing the option to encrypt the generated image file for additional security.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned to write Rust programs that can discover and manipulate
    the system environment, directory structures, and filesystem metadata in a cross-platform
    manner, using the `std::env`, `std::path`, and `std::fs` modules. We looked at
    how to create programs that can use command-line arguments or environment variables
    to accept configuration parameters and user inputs. We saw the use of two third-party
    crates: the `StructOpt` crate to improve the user interface of the tool, and `image-rs/image`
    to do the image resizing.'
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to use the `std:time` module to measure the time taken for
    specific processing tasks. We defined a custom error type to unify error handling
    in the library. In this chapter, we were also introduced to file handling operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a detailed look at doing advanced memory management
    with the standard library.
  prefs: []
  type: TYPE_NORMAL
