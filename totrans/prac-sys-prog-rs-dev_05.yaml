- en: '*Chapter 4*: Managing Environment, Command Line, and Time'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：管理环境、命令行和时间'
- en: In the previous chapter, we looked at how the Rust Standard Library is structured.
    We also wrote a portion of a basic template engine that can generate dynamic HTML
    page components given an HTML template and data. From here onward, we will start
    to deep-dive into specific modules of the standard library grouped by functional
    areas.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Rust 标准库的结构。我们还编写了一个基本模板引擎的部分代码，该引擎可以根据 HTML 模板和数据生成动态的 HTML 页面组件。从现在开始，我们将开始深入研究标准库的特定模块，这些模块按功能区域分组。
- en: In this chapter, we will look at Rust Standard Library modules that pertain
    to working with system environment, command-line, and time-related functions.
    The goal of this chapter is for you to gain more proficiency in working with *command-line
    parameters*, *path manipulation, environment variables*, and *time measurements.*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与处理系统环境、命令行和时间相关函数相关的 Rust 标准库模块。本章的目标是使你能够更熟练地使用 *命令行参数*、*路径操作、环境变量*
    和 *时间测量*。
- en: What is the benefit of learning about these?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些有什么好处？
- en: Working with *command-line arguments* is a required skill for writing any program
    that accepts user inputs from the command line.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *命令行参数* 一起工作是一项编写任何接受命令行用户输入的程序所必需的技能。
- en: Imagine how you would write a tool (such as **find** or **grep**) that deals
    with searching for files and patterns within folders and subfolders. This requires
    knowledge of *path manipulation*, including navigating paths and reading and manipulating
    path entries.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你会如何编写一个工具（例如 **find** 或 **grep**），它能够处理在文件夹和子文件夹中搜索文件和模式。这需要了解 *路径操作*，包括导航路径和读取及操作路径条目。
- en: Learning to use *environment variables* is an essential part of separating the
    code from the configuration, which is a good practice for any kind of program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 学习使用 *环境变量* 是将代码与配置分离的必要部分，这对于任何类型的程序来说都是一种良好的实践。
- en: Learning to work with time is required for programs that deal with timestamps
    of resources and activities. Learning how to do *time measurements* to record
    time intervals between events is needed for benchmarking the time taken for various
    operations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理资源和时间戳的程序来说，学习如何与时间打交道是必要的。学习如何进行 *时间测量* 以记录事件之间的时间间隔，对于评估各种操作所需的时间是必要的。
- en: 'In this chapter, you will learn the following skills:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下技能：
- en: Writing Rust programs that can discover and manipulate the system environment
    and filesystem across Linux, Unix, and Windows platforms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写能够在 Linux、Unix 和 Windows 平台上发现和操作系统环境和文件系统的 Rust 程序
- en: Creating programs that can use command-line arguments to accept configuration
    parameters and user inputs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以使用命令行参数接受配置参数和用户输入的程序
- en: Capturing elapsed time between events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获事件之间的经过时间
- en: These are relevant skills to have for systems programming in Rust. We will learn
    these topics in a practical way by developing a command-line application for image
    processing. Along the way, we will see more details about the `path`, `time`,
    `env`, and `fs` modules of the Rust Standard Library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在 Rust 系统编程中需要的相关技能。我们将通过开发一个用于图像处理的命令行应用程序来以实际的方式学习这些主题。在这个过程中，我们将看到 Rust
    标准库中 `path`、`time`、`env` 和 `fs` 模块的更多细节。
- en: First, let's see what we will be building.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们将要构建的内容。
- en: Imagine that we had a tool for bulk image resizing – tool that would look through
    a filesystem directory on a desktop or server, pull out all the image files (for
    instance, `.png` and `.jpg`), and resize all of them to predefined sizes (for
    example, small, medium, or large).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个批量图像缩放的工具——这个工具会遍历桌面或服务器上的文件系统目录，提取所有图像文件（例如，`.png` 和 `.jpg`），并将它们全部缩放到预定义的大小（例如，小、中或大）。
- en: Think about how helpful such a tool would be for freeing up space on the hard
    disk, or for uploading pictures to show in a mobile or web app. We will be building
    such a tool. Fasten your seat belts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，这样的工具对于释放硬盘空间或上传图片到移动或网页应用中展示会有多有用。我们将构建这样的工具。请系好安全带。
- en: 'We will cover the topics in the following order:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下顺序介绍主题：
- en: Project scope and design overview
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目范围和设计概述
- en: Coding the image resizing library
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写图像缩放库的代码
- en: Developing the command-line application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发命令行应用程序
- en: Technical requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The GitHub repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Project scope and design overview
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will first define what we are going to build and look at
    the technical design. We will then code a Rust library for image processing. Finally,
    we will build a command-line application that accepts user inputs through the
    command line and uses the image resizing library we have built to perform user-specified
    commands.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: What will we build?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will describe the functional requirements, technical
    requirements, and project structure for the tool we are building.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Functional requirements
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will build a command-line tool that performs the following two operations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Image resize**: Resizes one or more images in a source folder to a specified
    size'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image stats**: Provides some statistics on the image files present in the
    source folder'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s name the tool **ImageCLI**. *Figure 4.1* shows the two main features
    of the tool:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Features of ImageCLI tool](img/Figure_4.1_B16405.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Features of ImageCLI tool
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Users will be able to resize images using this tool. The user can ask to resize
    either a single image or multiple images. Supported *input* image formats are
    JPG and PNG. The supported *output* image format is PNG. The tool will accept
    three command-line parameters as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '`size = small`, the output image will have *200* pixels of width; for `size
    = medium`, the output file will have *400* pixels of width; and for `size = large`,
    the output will have *800* pixels of width. For example, if the input image is
    a JPG file with a total size of 8 MB, it can be resized to approximately < 500
    KB in size by specifying `size = medium`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode = single` for resizing a single file, or `mode = all` for resizing all
    image files in a specified folder.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode = single` or `mode = all` is chosen. For `mode = single`, the user specifies
    the value of `srcfolder` as the full path of the image file with its filename.
    For `mode = all`, the user specifies, for the value of `srcfolder`, the full path
    of the folder (the one containing the image files) without any image filenames.
    For example, if `mode = single` and `srcfolder = /user/bob/images/image1.png`
    are used, the tool will resize the single image file of `image1.png`, contained
    in the `/user/bob/images` folder. If `mode = all` and `srcfolder = /user/bob/images`
    are used, the tool will resize *all* the image files contained in the `/user/bob/images`
    source folder.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our image stats functionality, users will also be able to specify a `srcfolder`
    containing the image files and get back the number of image files in that folder,
    along with the total size of all those image files. For example, if `srcfolder=/user/bob/images`
    is used, the `image stats` option will give a result similar to the following:
    **The folder contains 200 image files with total size 2,234 MB**.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Non-functional requirements
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are a list of non-functional (technical) requirements for the
    project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool will be packaged and distributed as a binary and it should work on
    three platforms: Linux, Unix, and Windows.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should be able to measure the time taken to resize the images.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User inputs for specifying command-line flags must be *case-insensitive* for
    ease of use.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool must be able to display meaningful error messages to the user.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core functionality of image resizing must be separate from the **command-line
    interface** (**CLI**). This way, we have the flexibility of reusing the core functionality
    with a desktop graphical interface or as part of a web backend in a web application.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project will be organized as a **library** containing the image processing
    functionality and a **binary** that provides the CLI to read and parse user input,
    provide error messages, and display output messages to the user. The binary will
    make use of the library for core image processing.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create the project skeleton so we can visualize the project structure
    better. Create a new `lib` project using `cargo`. Let''s name the CLI tool as
    `imagecli` using the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the project structure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Cargo project structure](img/Figure_4.2_B16405.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Cargo project structure
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the project structure as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `src` folder, create a subfolder called `imagix` (for image magic!)
    to host the library code. Under the `imagix` subfolder, create four files: `mod.rs`,
    which is the entry point into the `imagix` library, `resize.rs` to host the code
    related to image resizing, `stats.rs` to host the code for image file statistics,
    and `error.rs` to contain the custom error type and error handling code.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the `src` folder, create a new file called `imagecli.rs`, which will contain
    the code for the CLI.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this subsection, we have seen the feature requirements for the tool and the
    desired project structure. In the next subsection, we will look at the design
    for the tool.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Technical design
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will look at the high-level design of the tool, primarily
    focusing on the image processing feature. We will design the specifics of the
    CLI in the *Developing the command-line application and testing* section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Our project comprises our reusable `imagix` library containing the core functionality
    for image resizing and statistics, and a binary executable, `imagecli`, with a
    CLI. This is depicted in *Figure 4.3*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – CLI tool with a reusable library](img/Figure_4.3_B16405.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – CLI tool with a reusable library
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: If the library is designed right, it can be reused in the future for other types
    of clients; for example, the application can be provided with a graphical user
    interface (instead of a CLI) as a desktop application, or can even be made accessible
    from a browser-based HTML client app.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin the design, let''s try to visualize a few of the key technical
    challenges we have to overcome and solve:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`/tmp/` subfolder to store the resized images?'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we measure the time taken for image resizing?
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Resizing multiple images**:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we iterate through the source folder provided by the user to identify
    all the image files and invoke the image resizing function for each entry?
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Getting image statistics**:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we scan through the user-provided source folder, count only the number
    of image files, and get the aggregate file size of all image files in that folder?
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`tmp` subfolder?'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding points can be grouped into three broad categories of concerns
    for design purposes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Image resizing logic
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path manipulation and directory-iteration logic
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring time taken for image resizing
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image processing is a highly-specialized domain in itself, and it is beyond
    the scope of this book to cover the techniques and algorithms involved. Given
    the complexity and scope of the image processing domain, we will use a third-party
    library that will implement the needed algorithms and provide us with a nice API
    to call.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we will use the `image-rs/image` open source crate that is
    written in Rust. The crate docs are at the following link: [https://docs.rs/image/](https://docs.rs/image/)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can design the `imagix` library using the `image` crate.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The `image` crate is fully featured and has many image processing functions.
    We will however use only a small subset of features for our project. Let''s recall
    our three key requirements for image processing: the ability to *open an image
    file and load it into memory*, the ability to *resize the image to a desired size*,
    and the ability to *write the resized image from memory into a file* on the disk.
    The following methods in the `image-rs/image` crate address our needs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '`image::open()`: This function opens an image at the specified path. It automatically
    detects the format of the image from the image''s file extension. The image data
    is read from the file and converted into a `DynamicImage` type stored in memory.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DynamicImage::thumbnail()`: This function scales an image down to a specified
    size (width and height) and returns a new image while preserving the aspect ratio.
    It uses a fast integer algorithm, which is a sinusoidal transformation technique.
    This is an **in-memory operation**.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DynamicImage::write_to()`: This function encodes an image and writes it to
    any object that implements the `std::io::write` trait, which in our case will
    be an output *file handle*. We will use this method to write the resized image
    to a file.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should be adequate for our image processing requirements in this project.
    For the other two concerns around path manipulation and time measurements, we
    will use the Rust Standard Library, which is described in the next subsection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Using the Rust Standard Library
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For developing the image resizing tool, we will be using both external crates
    and the Rust Standard Library. In the previous section, we saw how we plan to
    use the `image` crate.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the features of the Rust Standard Library that
    we will be using to build our project. There are three key areas where we will
    need the standard library:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The *path manipulation and directory iteration* functionality is needed in order
    to search through a directory, locate the image files, and create a new subfolder.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to get tool configuration options from the user. We will evaluate two
    approaches – getting this information through *environment variables* and getting
    it through *command-line parameters*. We will choose one of the options.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to *measure the time taken* for the image resizing tasks.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each of these areas in detail.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Path manipulation and directory iteration
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For path manipulation, we will use the `std::path` module from the Rust Standard
    Library. For directory iteration, we will use the `std::fs` module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to manipulate paths?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The source image files for resizing are stored in the *source folder*. The destination
    path for the resized image files is the `tmp` subfolder (within the *source folder*).
    Before writing each resized image file to disk, we have to construct the path
    where the file is to be stored. For example, if the path for the source file is
    `/user/bob/images/image1.jpg`, the destination path for the resized image will
    be `/user/bob/images/tmp/image1.jpg`. We have to construct the destination path
    programmatically, and then call the method on the `image` crate to store the image
    on the destination path.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rust Standard Library supports path manipulation functionality through
    two data types: `Path` and `PathBuf`, both part of the `std::path` module. See
    the sidebar for more details on how to construct and manipulate `paths` using
    the standard library.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The std::path module of the Rust Standard Library
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: This module provides cross-platform path manipulation functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: A path points to a filesystem location by following a directory tree. An example
    of a path in Unix systems is `/home/bob/images/`. An example of a path on the
    Windows operating system could be `c:\bob\images\image1.png`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: There are two main types in the `std::path` module that are commonly used—`Path`
    and `PathBuf`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: For parsing the path and its components (read operations), `Path` is used. In
    Rust parlance, it is a **path slice** (like a string slice, which is a reference
    to a string).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: For modifying existing paths or to construct new paths, `PathBuf` is used. `PathBuf`
    is an **owned**, **mutable path**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`Path` is used for read operations and `PathBuf` for read and write operations
    on paths.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to construct a new path from a string:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '`let path_name = Path::new("/home/alice/foo.txt");`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In `path_name`, `/home/alice` represents the parent, `foo` is the file stem,
    and `txt` is the file extension. We will be making use of the `file_stem()` and
    `extension()` methods on the `Path` type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The `pop()` and `push()` methods on the `PathBuf` type are used to truncate
    and append components to a path.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `PathBuf` path with the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`let mut path_for_editing = PathBuf::from("/home/bob/file1.png")`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '`path_for_editing.pop()` truncates this path to its parent, that is, `"/home/bob"`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Now, `push()` can be used to append a new component to `PathBuf`. For example,
    continuing from `PathBuf` with the value `"/home/bob"`, `push("tmp")` will append
    `tmp` to `"/home/bob"` path and return `"/home/bob/tmp"`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the `pop()` and `push()` methods in our project to manipulate
    paths.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Let's next look at how to perform the directory operations needed for our project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: When the user specifies `mode=all`, our requirement is to iterate through all
    the files in the specified source folder and filter the list of image files for
    processing. For iterating over directory paths, we will use the `read_dir()` function
    in the `std::fs` module.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of how to use this function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the explanation for the preceding code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`fs:read_dir()` takes a source folder path and returns `std::fs::ReadDir`,
    which is an iterator over entries in the directory.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use a `for` loop to extract each directory entry (which is wrapped in
    a `Result` type), and print out its value.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the code we will use to get entries in a directory and do further processing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Apart from reading a directory for its contents, we also need to check for the
    presence of a `tmp` subfolder under the source folder and create it if it does
    not already exist. We will use the `create_dir()` method from the `std::fs` module
    to create a new subdirectory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: We will see more details of the `std::fs` module in a later chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Time measurement
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For measuring time, we can use the `std::time` module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The `std::time` module in the Rust Standard Library has several time-related
    functions including getting the *current system time*, creating a *duration* to
    represent a span of time, and measuring the *time elapsed* between two specific
    time instants. Some examples of using the `time` module are provided in the following.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the current system time, we can write the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is how to get the elapsed time from a given point in time:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Instant::now()` is used to indicate the starting point of the time to be measured.
    The time duration between this point and the point at which `now.elapsed()` is
    called represents the time taken for the operation(s). Here, we are simulating
    a delay using the `sleep()` function from the `std::thread` module.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Working with environment variables
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this subsection, we will learn how to use the Rust Standard Library, along
    with a third-party helper crate, to store the values in environment variables
    and use them in the program:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project with the following line of code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[dependencies]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dotenv = "0.15.0"
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `main.rs`, add the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we import the `std::env` module and also the `dotenv::dotenv`
    module.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following statement loads the environment variables from an `.env` file:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `for` loop in the previous code block iterates through the environment variables
    in a loop and prints them to the console. `env:vars()` returns an iterator of
    key-value pairs for all environment variables of the current process.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test this, let''s create a new`.env` file in the project root and make the
    following entries:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Replace the `srcfolder` value with your own. Run the program with the following
    command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To access the value of any particular environment variable, the `std::env::var()`
    function can be used, which takes the key of the variable as a parameter. Add
    the following statement to the `main()` function and see the value of the `size`
    variable printed out:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have seen how to use *environment variables* to accept user inputs for image
    processing. Let's see how to accept user inputs with *command-line* parameters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Working with command-line parameters
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this subsection, we will learn to read command-line parameters using the
    `std::env` module of the Rust Standard Library:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::env` module supports command-line parameters through `std::env::args()`.
    Create a new Cargo project. Add the following line to the `main()` function in
    `src/main.rs`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Execute the code with `cargo run small all /tmp`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The three parameters passed to the program will be printed out to the console.
    To access individual parameters by index, add the following code to `main.rs`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the program with `cargo run small all /tmp`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The individual values for `size`, `mode`, and `source_folder` will be printed
    out as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of the two approaches we have seen – that is, using *environment variables*
    and *command-line parameters* – the latter is more suitable for accepting inputs
    from end users, while the environment variable approach is more suitable for developers
    configuring the tool.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: However, for a user-friendly interface, the bare-bones functionality offered
    by `std::env::args` is inadequate. We will use a third-party crate called **StructOpt**
    to improve the user interaction with the CLI.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the deep dive into the Rust Standard Library modules for path
    manipulation, time measurement, and reading environment and command-line parameters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a summary of the design approaches we have discussed, for the `imagix`
    library:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '`image-rs/image` crate.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we create a `/tmp/` subfolder to store the resized images?
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will use the `std::fs::create_dir()` method.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`std::fs::read_dir()` method.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we manipulate paths so that the output file is stored in the `tmp` subfolder?
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will use the `std::path::Path` and `std::path::PathBuf` types.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`std::path::Path` type and the `std::fs::read_dir()` method.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::time::Duration` and `std::time::Instant` modules.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StructOpt` crate.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we conclude this section on addressing project scope and design for
    the `imagix` library. We are now ready to start writing the code for the image
    processing library in the next section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Coding the imagix library
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll write the code for the image resizing and image statistics
    functionalities. Let's first look at the code structure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The module structure of the `imagix` library is summarized in *Figure 4.4*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Modules of the imagix library](img/Figure_4.4_B16405.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Modules of the imagix library
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The `imagix` library will consist of two modules, `resize.rs` and `stats.rs`
    respectively. There are two `enums`, `SizeOption` and `Mode`, for representing
    the variants for *size option* and *mode* respectively. The user will specify
    one of the variants of the `SizeOption` `enum` to indicate the desired output
    image size, and one of the variants of the `Mode` `enum` to indicate whether one
    or multiple images need to be resized. There is also `struct Elapsed` for capturing
    elapsed time of the image resizing operation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The `resize` module has the `process_resize_request()` public function, which
    is the main entry point into the `imagix` library for resizing images.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The `stats` module has a `get_stats()` public function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview of the overall code organization of the project is shown in *Figure
    4.5*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Code organization](img/Figure_4.5_B16405.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Code organization
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.5* shows the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The configuration and dependency entries needed in the `Cargo.toml` file
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Cargo project's code tree structure
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of source files of the `imagix` library along with a list of the key
    functions
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `imagecli.rs` file, which represents the command-line wrapper over the `imagix`
    library, and the code execution entry point in our tool
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first add the two external crates to `Cargo.toml` in the `imagecli`
    project folder root:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this section, we will walk through the code snippets for the following methods:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`get_image_files()`, which demonstrates path navigation'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resize_image()`, which contains the core logic for image resizing using the
    image crate, and for time measurements'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_stats()`, which returns the total count and the total size of image files
    in a folder'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom error handling methods
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the code is standard Rust (not specific to the topics this chapter
    is focused on) and can be found in the code repository for this chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through directory entries
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this subsection, let's review the code for `get_image_files()`. This is the
    method that retrieves the list of image files contained in a source folder.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for this method is described here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: We first retrieve the directory entries in the source folder and collect them
    in a *vector*.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then iterate over entries in the vector and filter for only the image files.
    Note that we are only focusing on `PNG` and `JPG` files in this project, but it
    can be extended to other types of image files too.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A list of image files is returned from this method.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code listing is shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: src/imagix/resize.rs
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code uses the `read_dir()` method to iterate through directory entries and
    collects the results in a `Vector`. The `Vector` is then converted into an iterator,
    and the entries are filtered to return only image files. This gives us the set
    of image files to work with, for resizing. In the next subsection, we will review
    the code to perform the actual resizing of the images.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Resizing images
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this subsection, we will review the code for `resize_image()`. This method
    performs the resizing of images.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for this method is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The method accepts a source image filename with the full source folder path,
    resizes it as a `.png` file, and stores the resized file in a `/tmp` subfolder
    under the source folder.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, the source filename is extracted from the full path. The file extension
    is changed to `.png`. This is because our tool will only support output files
    in `.png` format. As an exercise, you can add support for other image format types.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then the destination file path is constructed with the `/tmp` prefix, as the
    resized image will need to be stored in the `tmp` subfolder under the source folder.
    To achieve this, we first need to check whether the `tmp` folder already exists.
    If not, it has to be created. The logic for constructing the path with the `tmp`
    subfolder and for creating the `tmp` subfolder is shown in the previous code listing.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to resize the image. For this, the source file is opened, the
    resize function is called with requisite parameters, and the resized image is
    written to the output file.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The time taken for image resizing is calculated using the `Instant::now()` and
    `Elapsed::from()` functions.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code listing is shown here. For purposes of explanation, the code listing
    has been split into multiple snippets.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The code listed here accepts three input parameters – the size, source folder,
    and an entry of type `PathBuf` (which can refer to the full path of an image file).
    The file extension is changed to `.png` as this is the output format supported
    by the tool:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code snippet here appends the suffix `/tmp` to the file path entry in order
    to create the destination folder path. Note that due to a limitation in the standard
    library, the filename is first constructed as `tmp.png`, which is subsequently
    changed to reflect the final resized image filename:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code here opens the image file and loads the image data into memory. The
    `/tmp` subfolder is created under the source folder. Then, the image is resized
    and written to the output file in the destination folder. The time taken for the
    resizing operation is recorded and printed out:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have now seen the code for resizing images. Next, we will look at the code
    for generating image stats.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Image statistics
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous subsection, we looked at the code for image resizing. In this
    subsection, we will see the logic for generating image statistics. This method
    will count the number of image files in a specified source folder, and measure
    their total file size.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic of the `get_stats()` method that we will use is described as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_stats()` method takes a source folder as its input parameter and returns
    two values: the number of image files in the folder, and the total aggregate size
    of all image files in the folder.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a list of image files in the source folder by calling the `get_image_files()`
    method.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `metadata()` function in the `std::path` module allows us to query a file
    or directory for its metadata information. In our code, as we iterate through
    the directory entries, we aggregate the sizes of all files in one variable, `sum`.
    The `sum` variable is returned from the function along with the count of image
    file entries.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code listing is provided here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: src/imagix/stats.rs
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have covered the code for the image processing functionality. We will now
    cover some details of our custom error handling for the project.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's now take a look at our error handling design.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'As a part of our project, there may be many failure conditions that we have
    to handle. Some of them are given here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The source folder given by the user may be invalid.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specified file may not be present in the source folder.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our program may not have permission to read and write files.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User inputs for size or mode may be incorrect.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may be errors during image resizing (for example, a corrupt file).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may be other types of internal processing errors.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define a custom error type to handle all these different types of errors
    in a unified manner, and provide the error as output to the users of our library:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: src/imagix/error.rs
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The names of the errors are mostly self-explanatory. `FormatError` is any error
    encountered while converting or printing values of parameters. The goal of defining
    this custom error type is that the various types of errors that may be encountered
    during processing, such as errors in user input, the inability to read through
    a directory or write to a file, an error in image processing, and so on, are converted
    into our custom error type.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: It is not enough to just define a custom error type. We also have to ensure
    that when errors happen in due course of the program's operation, these errors
    are translated into the custom error type. For example, an error in reading an
    image file raises an error defined in the `std::fs` module. This error should
    be caught and transformed into our custom error type. This way, regardless of
    whether there is an error in file operations or error processing, the program
    uniformly propagates the same custom error type for handling by the frontend interface
    to the user (in the case of this project, it is the command line).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: For the conversion of various types of errors into `ImagixError`, we will implement
    the `From` trait. We will also implement the `Display` trait for our error type
    so that the errors can be printed out to the console.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Within each of the methods in the project modules, at the failure points, you
    will notice that `ImagixError` is raised and propagated back to the calling function.
    The source code can be found in the source folder for this chapter in the Packt
    code repository.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the error handling subsection of the code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This also concludes this section on coding the `imagix` library. We have only
    walked through key code snippets as it isn't practical to print out the entire
    code listing inline in the chapter. I would urge the reader to go through the
    entire source code to understand how the various features are translated into
    idiomatic Rust code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will build the command-line application that wraps this
    library and provides the user interface.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Developing the command-line application and testing
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we built the library for image resizing. In this section,
    we will review the design and key parts of the code for the main command-line
    application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with some automated unit tests to test the image resizing functionality
    in `resize.rs`: This way we can confirm that the image resizing library works
    independently of any calling function.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Two test cases are shown here in the following code—one to resize a single
    image, and the other to resize multiple images. You can replace the source folder
    and filenames in the code with your own:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: src/imagix/resize.rs
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Place the `image1.jpg` and `image2.jpg` files in `/tmp/images` and execute
    the tests with the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see the tests pass successfully. You can also inspect the resized images.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you can add the test cases for the image stats function as well.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: We can now conclude that the `imagix` library works as intended. Let's now move
    on to designing the command-line application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: We shall first look at the CLI requirements.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Designing the command-line interface
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will look at the design of the CLI. By design, we mean
    finalizing the structure of the CLI that the user will use. The CLI should be
    intuitive to use for the end user. The CLI must also accommodate some flexibility
    in its performing of different types of operations.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The `imagecli` CLI will use a command-subcommand model like `git`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The CLI command structure is shown in *Figure 4.6*:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Design of CLI commands](img/Figure_4.6_B16405.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Design of CLI commands
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of commands with parameters that the user can specify:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: For resizing images, the command is `cargo run –-release resize` with three
    parameters.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For image statistics, the command is `cargo run –-release stats` with one parameter.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For resizing a single image the command is `cargo run --release resize --size
    small --mode single --srcfolder <path-to-image-file/file-name.extn>`.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For resizing multiple images, we use the `cargo run --release resize --size
    medium --mode all --srcfolder <path-to-folder-containing-images>` command.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For image statistics, the `cargo run --release stats --srcfolder <path-to-folder-containing-images>`
    command is used.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `imagecli` `main()` function parses the command-line parameters, handles
    user and processing errors with suitable messages to the user, and invokes the
    respective functions from the `imagix` library.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a quick recap. To resize images, we need to know the following from
    the user:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The mode (single or multiple files)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output size of the image file (small/medium/large)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source folder where the image file (or files) is located
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we designed the CLI for the tool. In the previous sections,
    we built the `imagix` library to resize images. We will now move on to the last
    part of the project, which is to develop the main command-line binary application
    that ties all the pieces together and accepts user inputs from the command-line.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Coding the command-line binary using structopt
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we designed the interface for the command-line tool.
    In this section, we will see the code for the `main()` function that accepts user
    inputs from the command line and invokes the `imagix` library. This `main()` function
    will be compiled and built into the command-line binary tool. The user will invoke
    this executable for resizing images and provide the necessary command-line parameters.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function will be located in `src/imagecli.rs`, as we want the command-line
    tool binary name to be `imagecli`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now review the code snippets for the command-line application. The `main()`
    function is located in the `src/imagecli.rs` file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the imports section. Note the imports of the `imagix` library
    that we have written, and `structOpt` for command-line argument parsing:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will now see the definition of the command-line parameters for the tool.
    For this we will use the `structopt` syntax. Refer to documentation at [https://docs.rs/structopt](https://docs.rs/structopt).
    Basically, we have defined an `enum` called `Commandline` and defined two subcommands,
    `Resize` and `Stats`. `Resize` takes three arguments: `size`, `mode` and `srcfolder`
    (the source folder). `Stats` takes one argument: `srcfolder`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can now review the code for the `main()` function. Here, we basically accept
    the command-line inputs (validated by `StructOpt`) and invoke the suitable methods
    from our `imagix` library. If the user specifies the `Resize` command, the `process_resize_request()`
    method of the `imagix` library is invoked. If the user specifies the `Stats` command,
    the `get_stats()` method of the `imagix` library is invoked. Any errors are handled
    with suitable messages:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Build the app with the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The reason to use the release builds is that there is a considerable time difference
    in resizing images between the debug and release builds (the latter being much
    faster).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then execute and test the following scenarios at the Terminal. Ensure
    to place one or more `.png` or `.jpg` files in the folder that you specify in
    `--srcfolder` flag:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**Resize a single image**:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Resize multiple files**:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Generate image stats**:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this section, we have built a tool for image resizing that works from a CLI.
    As an exercise, you can experiment by adding additional features, including adding
    support for more image formats, changing the size of the output file, or even
    providing the option to encrypt the generated image file for additional security.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned to write Rust programs that can discover and manipulate
    the system environment, directory structures, and filesystem metadata in a cross-platform
    manner, using the `std::env`, `std::path`, and `std::fs` modules. We looked at
    how to create programs that can use command-line arguments or environment variables
    to accept configuration parameters and user inputs. We saw the use of two third-party
    crates: the `StructOpt` crate to improve the user interface of the tool, and `image-rs/image`
    to do the image resizing.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to use the `std:time` module to measure the time taken for
    specific processing tasks. We defined a custom error type to unify error handling
    in the library. In this chapter, we were also introduced to file handling operations.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a detailed look at doing advanced memory management
    with the standard library.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
