- en: '*Chapter 4*: Building pip Modules in Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing code to solve our problems is useful. However, writing code can become
    repetitive and time-consuming, especially when we are building applications. Applications
    usually require defining the steps that build the application. Packaging our code
    can help us reuse our code and share it with other developers. In this chapter,
    we will package Fibonacci code into a Python `pip` module that can be easily installed
    and has a command-line tool. We will also cover continuous integration processes
    that deploy our packages once a merge has been achieved to our `main` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring setup tools for a Python `pip` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging Python code in a `pip` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to have Python 3 installed. To get the most out of this chapter,
    we will also need to have a GitHub account, as we will be using GitHub to package
    our code, which can be accessed via this link: [https://github.com/maxwellflitton/flitton-fib-py](https://github.com/maxwellflitton/flitton-fib-py).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Git command-line tools are also needed in this chapter. These can be installed
    by following the instructions here: [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git).
    The chapter will also make use of a PyPI account. You will need to have your own
    PyPI account, which can be obtained for free with this link: [https://pypi.org/](https://pypi.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found via this link: [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_four](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_four).'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring setup tools for a Python pip module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setup tools in Python are how the code in our module is packaged and installed.
    They provide a set of commands and parameters for the system that is installing
    the code to process. To explore how this is done, we will package the Fibonacci
    numbers example introduced in the previous chapter. However, these calculations
    will be packaged in a `pip` module. To configure our setup tools, we are going
    to have to carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a GitHub repository for our Python `pip` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define basic parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `README` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a basic module structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's have a look at each of these steps in detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Understandably, a seasoned developer can create a GitHub repository but for
    the sake of completeness, we will offer all the steps needed. If you can already
    create a GitHub repository, move on to the next subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: On the home URL of GitHub when we are logged in, we can create our repository
    by clicking on the **New** button, as shown here:![Figure 4.1 – How to create
    a new repository on GitHub
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.01_B17720.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.1 – How to create a new repository on GitHub
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once this is clicked, we can configure our new repository with the parameters
    shown next:![Figure 4.2 – Parameters for our new GitHub repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.02_B17720.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.2 – Parameters for our new GitHub repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For this example, we have set the GitHub repository to `pip` packaging for
    this chapter will also work the same way for private repositories. We have also
    included a `.gitignore` file and selected it to be Python. This is to stop Python
    caching and for virtual environment files to be tracked by GitHub and uploaded
    when we upload our code to the repository. Now that we have our GitHub repository
    made, going to the repository will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Our GitHub repository home page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.03_B17720.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.3 – Our GitHub repository home page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can see that our description is written in the `README.md` file. It also
    has to be noted that the `README.md` file is rendered. This happens in any directory
    of the repository. We can document what to do and how to use the code throughout
    the repository with a range of `README.md` files if we want.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this is done, we can download our repository with the command shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your URL will be different, as you have a different repository. The only thing
    left is to ensure that our development environment for our repository has a Python
    virtual environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This can be done by navigating to the root directory of the GitHub repository
    and then running the command shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use our virtual environment in the terminal, we can activate it with the
    command shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that our command is prefixed with `(venv)`, meaning that it is active.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the basic parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our environment is fully functional, we are going to define the basic
    parameters when installing our Python `pip` module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is achieved by creating a `setup.py` file in the root of our repository.
    This will get run when another Python system installs our `pip` module. In our
    `setup.py` file, we import our setup tools with the code shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are going to use `setup` to define our parameters, and we are going to use
    `find_packages` to exclude tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have imported our setup tools, we can define our parameters in
    the same file with the code shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are a lot of parameters here. What we have done from the `name` field
    to `url` is essentially define the metadata around our `pip` module. The `classifiers`
    fields are also metadata around our module. The rest of the fields have the following
    effects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Install_requires` field is currently an empty list. This is because our
    module is not requiring any third-party modules right now. We will cover dependencies
    in *Managing dependencies* section.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `packages` field ensures that we exclude our `test` directory when we start
    building our tests for our module. While we will use tests to check our module
    and ensure standards, we do not need to install them when we are using our module
    as a third-party dependency.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Python_requires` field ensures that the system installing our module has
    the correct version of Python installed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests_require` is a list of requirements when tests are running.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have defined our basic setup, we can upload our code with the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What we have done here is add all of the new and changed files to our Git branch
    (which is `main`). We then committed our files with the `adding setup to module`
    message. We then pushed our code to the `main` branch, which means that we uploaded
    our changes onto the Git repository online. This is not the best way to manage
    our code iterations. We will go over different branches and how to manage them
    in the continuous integration section near the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that `long_description` is a Markdown; however, trying
    to fit an entire Markdown into this field would end up dominating the `setup.py`
    file. It would essentially be a long string spanning multiple lines, with a few
    Python lines dispersed into it. We want our `setup.py` file to dictate the logic
    of setting up the module when it is being installed. We also want our long description
    of the module to be rendered by GitHub when we visit the GitHub repository directly
    online. Because of this, we will need to add some extra logic around defining
    our long description in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a README file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our long description is essentially the `README.md` file. If we fuse this with
    our `setup.py`, our `README.md` file will also render if we visit it on PyPI and
    it is uploaded to the PyPI server. This can be done by reading the `README.md`
    file into a string in the `setup.py` file and then plugging that string into our
    `long_description` field with the following code in the `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code after `...` is the same as before. With this, our basic
    module setup is complete. Now, all we need is to do is define a basic module to
    install and use, which is what we will do in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a basic module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining a basic module takes the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We house the actual code that the user will have in our `flitton_fib_py` directory.
    For now, we are just going to have a basic function that prints something out
    so that we can see if our `pip` package works. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this by adding a basic `print` function in the `flitton_fib_py/__init__.py`
    file that has the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once this is done, we can upload the code to the GitHub repository using the
    git commands described in the *Packaging Python code in a pip module* section.
    We should now see all the code of our module in the `main` branch. Considering
    this, we need to navigate to another directory that is not associated with our
    `git` repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then unlink our virtual environment by typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use `pip install`, we point to the URL of the GitHub repository that our
    `pip` module is stored and define which branch it is. We do this by typing the
    following command, all in one line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your GitHub repository will have a different URL and you might have a different
    directory. Running this command will give us a range of printouts, stating that
    it is cloning the repository and installing it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then open up a Python terminal by typing in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have an interactive terminal. We can check to see whether our module
    works by typing in the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the last command is typed, we will get the following printout in the terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There we have it – our Python package works! This works for both private and
    public GitHub repositories. Nothing is stopping us now from packaging private
    Python code to reuse on other private Python projects!
  prefs: []
  type: TYPE_NORMAL
- en: While this is a useful tool to package and install code on other computers with
    minimal setup, we have to be careful. When we are running the `setup.py` file,
    we are running the code as our root user. Therefore, we have to ensure that we
    trust what we are installing. Putting malicious code into the `setup.py` file
    is a vector of attack. We can run direct commands on the computer using the `SubProcess`
    object from the standard Python library. Make sure you trust the author of the
    code that you are installing with `pip install`.
  prefs: []
  type: TYPE_NORMAL
- en: This also highlights how vigilant you have to be when merely just running `pip
    install`. There are developers out there who will slightly change a package. For
    instance, a famous case was the `requests` package. This is a common, well-used
    package; however, for some time, there was an imitation package called `request`.
    They relied on people mistyping `pip install` and downloading the wrong package.
    This is known as **typosquatting**.
  prefs: []
  type: TYPE_NORMAL
- en: We have now packaged our Python code into a module. However, it is not a very
    useful module. This brings us to our next section, where we package our Fibonacci
    sequencing code.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging Python code in a pip module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our GitHub repository configured, we can start building out
    our Fibonacci code for our module. To achieve this, we must carry out the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build our Fibonacci calculation code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a command-line interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test our Fibonacci calculation code with unit tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now discuss each of these steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Building our Fibonacci calculation code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to building our Fibonacci calculation code, we will have two functions
    – one that will calculate a Fibonacci number and another that will take a list
    of numbers and lean on the calculation function to return a list of calculated
    Fibonacci numbers. For this module, we will take a functional programming approach.
    This does not mean that we should have a functional programming approach every
    time we build a `pip` module. We are using functional programming because Fibonacci
    sequence calculations naturally flow well with a functional programming style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is an object-orientated language, and problems that have multiple moving
    parts interrelating naturally flow well with object-orientated approaches. Our
    module structure will take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For this chapter, we will maintain a simple interface so that we can focus
    on the packaging of code in a `pip` module. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can build our Fibonacci number calculator in the `fib_number.py`
    file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, it has to be noted that we are returning `None` when the input number
    is below zero. Technically, we should be throwing an error, but this is in place,
    for now, to demonstrate the effectiveness of a checking tool later on in our *Configuring
    continuous integration* section. As we know from the previous chapter, the preceding
    code will correctly calculate a Fibonacci number based on the input number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have this function, we can depend on this to create a function
    that creates a list of Fibonacci numbers in our `fib_numbers.py` file with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now ready to test our `pip` module again. We must push our code to the
    `main` branch on our repository again, uninstall our `pip` package in another
    virtual environment, and install again using `pip install`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our Python terminal with our new installed package, we can test our `recurring_fibonacci_number`
    function with the following console commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that our Fibonacci function can be imported, and it works,
    calculating the correct Fibonacci numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can test our `calculate_numbers` with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that our `calculate_numbers` function also works. We have a
    fully functioning Fibonacci `pip` module. However, if we want to just calculate
    a Fibonacci number without coding a Python script, we should not have to go into
    a Python terminal. We can remedy this by building a command-line interface in
    the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a command-line interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to build our command line function, our module can take the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To build our interface, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We build the command-line interface in our `fib_numb.py` file with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can see that we get the parameters passed in from the command line
    using the `argparse` module. Once we have obtained the parameters, we will then
    calculate the number and print it out. Now, for us to actually access it via the
    terminal, we have to point to it in the `setup.py` file at the root of the `pip`
    package by adding the following parameter in the `setup` object initialization:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, what we are doing is linking the `fib-number` console command with the
    function that we have just defined. After uninstalling our `pip` module in another
    virtual environment, uploading the changes to the `main` branch on our repository,
    and installing our new module using `pip install`, we will have our new module
    with the command-line tool that we have built.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once it is installed, we just type in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: fib-number -h
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'usage: fib-number [-h] --number NUMBER'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Calculate Fibonacci numbers
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'optional arguments:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -h, --help       show this help message and exit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --number NUMBER  Fibonacci number to be calculated
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, to calculate the Fibonacci number, we use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us the following printout:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we were to provide a string instead of a number for our argument, our program
    would refuse it, throwing an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here we have it, we have a fully working command-line tool! This does not stop
    here. You can take this further. Nothing is stopping you from using `subprocess`
    from the standard library combined with other libraries, such as Docker, to build
    your own DevOps tools. You can automate whole workflows for yourself and the applications
    you make. However, if we are to rely more and more on our `pip` modules to do
    the repetitive heavy lifting, we can get into serious problems if the program
    introduces some bugs we need to know straight away. To do this, we need to start
    building unit tests for our module. These are covered in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Building unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit tests are helpful for us to check and maintain quality control for our
    code. To build our unit tests, our module will have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we are mimicking the structure of the code in our module. This
    is important to keep track of our tests. If the module grows, then we will not
    get lost in our tests. If we need to chop out a directory or move it to another
    module, we can simply delete the appropriate directory or move it. It also has
    to be noted that we have built a Bash script to run our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to writing our tests, it is usually best to code based on the
    chain of dependency. For instance, our files have the dependency chain depicted
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Dependency chain'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.04_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Dependency chain
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering our dependency chain, we should ideally write our tests for the
    `fib_number.py` file first and make sure that our `recurring_fibonacci_number`
    function works before writing tests that rely on the `recurring_fibonacci_number`
    function. Here are the steps to write our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first import what we need to test our code in our `test_fib_number.py` file
    via the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `main` function is to run all tests. We also rely on the `TestCase` class
    by writing our own test class that inherits `TestCase`. This gives our class extra
    class functions to aid us in testing outcomes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can write our own tests for a range of inputs with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, it has to be noted that each one of our functions has the `test_` prefix.
    This flags the function as a test function. This is also the case for the name
    of the file. All test files have the `test_` prefix to flag that the file houses
    tests. In our testing code, we can see that we have merely passed a range of inputs
    into the function that we are testing and asserted that the outcome is what we
    expect. If the assertions do not hold water, then we get an error and a failed
    result. Seeing as we are just testing the same function repeatedly, we can put
    all of the assertions into one test function. This is usually preferred if we
    are testing the whole object. We would essentially have one test function for
    each function that we are testing in the object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that all our tests have been run, we can run the `unittest` `main` function
    if the `test_fib_number.py` file is run directly at the bottom of the `test_fib_number.py`
    file with the code shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have to set our `PYTHONPATH` variable to the directory of `flitton_fib_py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once this is done, we can run our `test_fib_number.py` file and get the console
    printout as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: F in the test dots, and it highlights what test is failing and where it is failing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have built our base test, we can build our tests for the function
    that takes in a list of integers and returns a list of Fibonacci numbers. In our
    `test_fib_numbers.py` file, we import what we need with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we are importing the function that we are testing and
    the same `main` and `TestCase`. However, it has to be noted that we have imported
    a `patch` function. This is because we have already tested our `recurring_fibonacci_number`
    function. The `patch` function enables us to insert a `MagicMock` object in place
    of our `recurring_fibonacci_number` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For our example, it can be argued that we do not need to patch anything. However,
    it is important to get an understanding of patching. `MagicMock` object; we can
    define the return values to anything we want during the test and log all calls
    to the `MagicMock` object.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage here is that we might accidentally call the function we are depending
    on twice for some reason. However, if the function returns the same value twice,
    we will not know anything if we did not patch it. However, with patching, we can
    inspect the calls and throw errors if the behavior is not what we expect. We can
    also test a range of edge cases very quickly by merely changing the return value
    of the patches and rerunning the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this, it is understandable that we can get excited about patching.
    However, there are some downsides. If we do not update the patches'' return values,
    the dependent code does not get the changes, and the testing does not remain accurate.
    This is why it is always sensible to have a mixture of approaches and run a functional
    test that runs the whole process without patching anything. With all this in mind,
    our patched unit test in the `tests/flitton_fib_by/fib_calcs/test_fib_numbers.py`
    file is carried out by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have used the patch as a decorator with a string that
    defines the path to the function that we are patching. We then pass the patched
    function through the test function under the `mock_fib_calc` parameter. We then
    state that we expect the outcome of the function that we are directly testing
    (`calculate_numbers`) to be a list of two return values of the patched function.
    We then pass two integers wrapped in a list into the `calculate_numbers` function
    and assert that this is going to be the same as our expected outcome. Once this
    is done, we assert that the `mock_fib_calc` was only called twice, and we inspect
    each of those calls, asserting that they are the numbers that we passed in, in
    the correct order. This has given us a lot of power to truly inspect our code.
    However, we are not done yet; we also must define the functional test to enable
    us to run our tests with the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'For our module, all our unit tests are done. However, we do not want to go
    through manually running each file to see our tests. There will be times where
    we want to just see all the outcomes of the tests to see if there are any fails.
    To automate this, we can build a Bash script in the `run_tests.sh` file with the
    code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we claim that the file is a Bash script with the first line. The first
    line is a shebang line and tells the computer running it what type of language
    it is. We then get the directory path of where this script is and assign it to
    the `SCRIPTPATH` variable. We then navigate to this directory, move out to the
    root of our module, activate our virtual environment, and then define our `PYTHONPATH`
    variable to be in our module with the Fibonacci number code. Now that everything
    is defined, to run our test we use the `unittest` command-line tool to run all
    the unit tests. Remember, all our tests have the `test_` prefix in their filenames.
    Running this gives us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we have seven tests running and they have all passed.
    We can see that we have started automating the test-running process. This is not
    where we should stop. As we move forward onto packaging and distributing our `pip`
    module, we should investigate automating the processes through continuous integration,
    which is what we explore in the next section. Right now, as it stands, if a user
    has access to our GitHub repository, we can install the code via `pip` and use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Python `pip` package is fully functioning. However, this is not the end.
    We will need to maintain the quality of the code and enable it to be constantly
    upgraded when we push new features to our module and refactor existing code. Continuous
    integration enables us to ensure that the tests pass and that the standard of
    quality is maintained. It also speeds up the deployment process, enabling us to
    push new iterations within a matter of minutes, enabling us to focus on the task
    at hand. It also reduces the risk of making a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, the most mundane, repetitive tasks are the ones that are at the
    highest risk of a mistake occurring. This is just a fact of life. It''s known
    that most car crashes happen within 5 minutes of the driver''s home. This is because
    the drivers pay less attention and their brain switches off, relying on muscle
    memory. Deployment processes are the same. They are repetitive and do not require
    a lot of mental focus. As a result, after several times, we will start to rely
    on muscle memory and forget to check certain things, and make minor blunders when
    deploying our `pip` package. Continuous integration is a must to avoid mistakes
    and saves time in not only deployment but also in not having to correct the errors.
    To set up continuous integration, we are going to have to carry out the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually deploy onto PyPI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manage our dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up type checking for Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up and run tests and type checking with GitHub Actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create automatic versioning for our `pip` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy onto PyPI using GitHub Actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's have a look at each of these steps in detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Manually deploying onto PyPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now move on to our first step of manually deploying our GitHub repository
    onto PyPI. We have installed our `pip` package by directly pointing to the GitHub
    repository. However, if we are allowing everyone to access our module as it''s
    open source, it is easier to upload our package onto PyPI. This will enable others
    to install using a simple command. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to package our `pip` module before we upload it. This can be
    done with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ├── LICENSE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ├── README.md
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ├── dist
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: │   └── flitton_fib_py-0.0.1.tar.gz
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ├── flitton_fib_py
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: . . .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now see that the version is included in the filename. We are now ready
    to upload onto the PyPI server. To do this, we have to install `twine` with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now able to upload the `tar.gz` file with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This uploads all of the packages that we have created. During this process,
    the terminal will ask us for the PyPI username and password. It then uploads the
    package and tells us where we can find out the module on PyPI. If we visit this,
    we should get the view depicted in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.5 – PyPI view of our module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.05_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – PyPI view of our module
  prefs: []
  type: TYPE_NORMAL
- en: We can see that our `README.md` file is being directly rendered in the view
    in *Figure 4.5*. We can now directly install this with the `pip install` command
    depicted in the PyPI view. It must be noted that we now have a dependency. We
    need to manage these dependencies. We will cover this in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to dependencies, we must manage two types. For instance, our
    `twine` dependency helps us upload it onto PyPI. However, this is not needed for
    the `pip` package. Therefore, we need two different lists of dependencies – one
    for development and the other for actual use. We define the dependencies that
    we need for the development with the simple standard command stated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'What the `pip freeze` command gives us is a specific list of requirements that
    our current Python environment needs to install in order to run. `> requirements.txt`
    writes it to the `requirements.txt` file. If you are a new developer starting
    to develop our module, you can install all the requirements needed with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'We can be strict here because nothing is depending on the development requirements
    apart from the direct development of our module. However, when it comes to our
    module, we know that it will be installed into multiple systems with multiple
    requirements. Therefore, we want to allow some flexibility. For instance, if our
    module was going to write our Fibonacci numbers to `yml` and `pickle` files, then
    we will need to use the `pyYAML` and `dill` modules to enable us to write our
    Fibonacci numbers to `yml` and `pickle` files. To do this, we alter our `install_requires`
    parameter in our `setup` initialization in the `setup.py` file with the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'It must be noted that these are not the latest packages. We must drop a few
    versions and allow our dependency to be equal to or above that version. This gives
    our users freedom when using our pip package in their systems. We also must copy
    and paste these requirements into our `requirements.txt` file to ensure that our
    development is consistent with the user experience of our `pip` module. Let''s
    say that we are going to add an optional feature which is to start a small Flask
    server that locally serves an API that calculates Fibonacci numbers. Here, we
    can add an `install_requires` parameter in our `setup` initialization in the `setup.py`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we upload our new code to either PyPI or our personal GitHub repository,
    we will have a different experience when installing our package. If we normally
    install it, we will see that our `pickle` and `yml` requirements automatically
    install if we run the install command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: It will actually install the server requirements. We can have as many requirements
    for the `server` profile as we want, and they will all be installed. Remember,
    our `extras_require` parameter is a dictionary, so we can define as many extra
    requirement profiles as we want. With this, we now have development requirements,
    essential `pip` module requirements, and optional `pip` module requirements. In
    the next step, we are now going to rely on a new development requirement to check
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up type checking for Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point in the book, we have experienced the safety that Rust introduces.
    When types don''t match up, the Rust compiler refuses to compile. However, with
    Python, we do not get this, as Python is an interpreted language. However, we
    can mimic this using the `mypy` module. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can install the `mypy` module with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then type-check by using the `mypy` entry point with the code here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can constrict the return value to just an integer with the `recurring_fibonacci_number`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we raise an error if the input number is below zero. It's
    not going to calculate anyway, so we might as well throw an error informing the
    user that there is an error as opposed to silently producing a `None` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we run our `mypy` check, we get the following console printout:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that all our files were checked and that they have type consistency.
  prefs: []
  type: TYPE_NORMAL
- en: However, we might forget to run this type of checking every time we upload new
    code to the GitHub repository. In the next section, we will define GitHub Actions
    to automate our checking.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and running tests and type-checking with GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitHub Actions run a series of computations that we can define in a `yml` file.
    We generally use GitHub Actions to automate processes that need to run every time.
    Workflow `yml` files are automatically detected by GitHub and run depending on
    what type of tags we give it. We can set up our GitHub Actions by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our tests and type-checking tags, we will define these in the `.github/workflows/run-tests.yml`
    file. In this file, we initially give a name for the workflow, and state that
    it fires when there is a push from one branch to another. This happens when a
    pull request is done as one branch is being pushed to another. This also reruns
    if we push more changes to our branch before merging the pull request. Our definitions
    are inserted at the top of the file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must define our jobs. We also must state that our job is a `shell`
    command. We then define what the operating system is. Once we have done this,
    we define the steps of the job. In our `steps` section, we then define the `uses`,
    which we will state are `actions` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to define the rest of the steps under the `steps` tag. These
    steps usually have a `name` and `run` tag. For us, we will be defining three steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first one is to install the dependencies.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second one is to run all the unit tests.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The third one is to run the type-checking with the code here:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we have to pull a new branch from our `main` branch with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To just trigger a GitHub action with a pull request, we can simply scar our
    code with a comment in any file, such as the one here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can write whatever, as it is just a comment if the code has changed. We
    then add and commit our changes to our **test** branch and push it to the GitHub
    repository. Once this is done, we can trigger a pull request by clicking on the
    **Pull requests** tab and selecting our **test** branch, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Setting up a GitHub pull request'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.06_B17720.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.6 – Setting up a GitHub pull request
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once this is done, we can click on **Create pull request** to view it. Here,
    we will see all the GitHub Actions that get triggered and their status, as shown
    in the following figure:![Figure 4.7 – View of the GitHub Actions status of pull
    requests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.07_B17720.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.7 – View of the GitHub Actions status of pull requests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can see that our tests have failed! If we click on **Details**, we can see
    that everything is working; it is just that we forgot to update our tests. If
    we remember, we changed our code to throw an error if we pass in a negative value
    into the Fibonacci calculation function, as shown next:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.8 – View of the GitHub Actions execution details'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.08_B17720.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.8 – View of the GitHub Actions execution details
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can change the test code to assert that an error is raised by the testing
    code in the `tests/flitton_fib_py/fib_calcs/test_fib_number.py` file with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we assert that a value error is raised because we are
    running code that we expect to raise an error, and that the exception is what
    we expect of it. Pushing this to our GitHub repository will ensure that all the
    tests have passed. We can merge the pull request if we want the code to be merged
    into our `main` branch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have seen from this example that continuous integration is useful. It has
    picked up a change in the code that we might not have noted if we were doing everything
    manually.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that our tests run automatically, we need to automate keeping track of the
    version of our module to avoid making the same mistake we made with not updating
    our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Create automatic versioning for our pip package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To automate the process of updating the version number, we are going to put
    several functions in the `get_latest_version.py` file in the root of our `pip`
    module. Following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import everything we need with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To do this, we can create a function that will get the metadata of our module
    from PyPI and return the version with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is just a simple web request. Once we have done this, we are going to
    want to unpack this string into a tuple of integers with the function defined
    next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that this is a simple split via bullet points. We then convert
    them to integers and pack them into a tuple to be returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have got our version number, we need to increase this by one with
    the function defined next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that if one of the integers is equal or greater than `10`,
    we set it back to `0` and increase the next number by `1`. The only one that does
    not get sent to `0` is the furthest number to the left. This will just keep going
    up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have increased our number by `1`, we will need to pack the integer
    into a string, with the function defined next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have packed this into a string, we will have to write the version to
    a file. This can be done with the function defined next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we ensure that the path is going to be at the root of
    our module. We then delete the version file if it already exists, as it will already
    be out of date.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then write our updated version number to the file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This ensures that if we run the file directly, we will get the updated version
    written to a file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, in our `setup.py` file at the root of our module, we must read the version
    file and define it for our version parameter in the `setup` initialization. For
    that, we first import `pathlib` into our file and read the version file with this
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then set the `version` parameter with the read value with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have our version update process fully automated; we must plug this into
    our GitHub Actions, so we automatically run the update process and push to PyPI
    when merging with our `main` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying onto PyPI using GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable our GitHub actions to push to PyPI, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we store the username and password for our PyPI account in the **Secrets**
    section of our GitHub repository. This can be done by clicking on the **Settings**
    tab and then the **Secrets** tab on the left sidebar, as shown here:![Figure 4.9
    – View of the GitHub Secrets section
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.09_B17720.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.9 – View of the GitHub Secrets section
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the top right of the view in *Figure 4.9* is **New repository secret**.
    If we click this, we will get the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – View of the GitHub secret creation section'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.10_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – View of the GitHub secret creation section
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can create a secret for our PyPI password and another secret for our
    PyPI username.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our secrets defined, we can build our GitHub action in the
    `.github/workflows/publish-package.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to ensure that we publish our package only when we have merged
    a branch with the `main` branch. To do this, we need to ensure that our action
    only executes when there''s a pull request when it''s closed, and the branch being
    pointed out is `main` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, we can define the basic jobs of installing the dependencies
    and updating the package version with `jobs`, defined in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What we have done is fine so far. However, it will run when any pull request
    pointing to `main` is closed. Therefore, we must ensure that the pull request
    has merged before executing the step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the next section, we install the dependencies with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see that our conditional statements are straightforward. We then run
    the `setup.py` file for it to produce our distribution with the following step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have defined all the steps needed to prepare our package, we can
    upload our package using `twine` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we have automated the deployment of our module to PyPI
    using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have managed to build a fully fledged `pip` Python module
    that has continuous integration. We initially set up a GitHub repository and created
    a virtual environment. This is an essential skill for most Python projects, and
    you should be using GitHub repositories and virtual environments even if your
    project is not a `pip` module. You will be able to share your project and work
    with other team members. We then defined our `setup.py` file so our code could
    be installed via `pip`. Even if our GitHub repository is private, people who have
    access to the GitHub repository could freely install our code. This gives us even
    more power when it comes to distributing our code.
  prefs: []
  type: TYPE_NORMAL
- en: When we have an interface defined, our users do not need to know much about
    our code, just how to use the interface. This also enables us to prevent repeated
    code. For instance, if we build a user data model with a database driver, we can
    package it as a `pip` module and use this in multiple web applications. All we
    need to do is change the data model in the `pip` module and make a new release,
    and then all web applications can use the updated version if they wish.
  prefs: []
  type: TYPE_NORMAL
- en: Once our code was packaged, we rebuilt our Fibonacci code in our `pip` module,
    and it worked. We then went further, building entry points that enabled us to
    define our own command-line tools. This makes our code packaging even more powerful,
    as the user doesn't even have to import and code the module; they can just call
    the command-line argument! With this, we can build development tools to speed
    up our development by automating tasks with these entry points. We then built
    basic unit tests to ensure that the quality of our code was maintained. We then
    locked in these good standards with automation pipelines using GitHub Actions.
    We introduced type-checking with `mypy` alongside our unit-testing pipeline. We
    don't have to stop here. For instance, the Python script that we coded that increased
    the version number by one could be built in its own `pip` repository with a command-line
    interface. With this, we could install the module using `pip install` in our GitHub
    Actions and run the commands. Now, with this code packaging, you can build your
    own tools and add them to your belt, reducing the amount of repetition in your
    daily coding as time goes on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we cover what we have done in this chapter in Rust. Considering
    this, we harness the safety and speed of Rust, with the flexibility of `pip` packaging.
    Utilizing this will level up your skills as a Python toolmaker, making you invaluable
    to your team.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How would you perform an installation with `pip install` of our GitHub repository
    on the `test` branch?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can other developers who do not have access to your GitHub repository install
    your `pip` package if you upload it to PyPI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between development dependencies and package dependencies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mypy` ensures the consistency of types when it comes to our Python code. How
    is this different from type-checking in Rust?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we automate boring repetitive tasks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pip install git+https://github.com/maxwellflitton/flitton-fib-py@test  `'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, they can download it despite not having access to your GitHub repository.
    If we think about it, we package our `pip` module in a file and then upload it
    to the PyPI server. Downloading our package from the PyPI server is not connected
    to our GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Development dependencies are specific dependencies defined in the `requirements.txt`
    file. This ensures that developers can work on the `pip` package. Package requirements
    are a little more relaxed and defined in the `setup.py` file. These get installed
    when the user installs our package. Package requirements are to enable the `pip`
    package to be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rust does the type-checking when it is compiling and fails to compile if the
    types are inconsistent. Because of this, we cannot run it. Python, however, is
    an interpreted language. Because of this, we can still run it with the potential
    errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repetitive tasks are easy to automate, so the effort invested is not excessive.
    Also, repetitive tasks have a higher risk of producing errors. Automating these
    tasks reduces the number of errors we could make.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Python Organisation (2021) Packaging code*: [https://packaging.python.org/guides/distributing-packages-using-setuptools/](https://packaging.python.org/guides/distributing-packages-using-setuptools/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GitHub Organisation (2021) GitHub Actions*: [https://docs.github.com/en/actions](https://docs.github.com/en/actions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
