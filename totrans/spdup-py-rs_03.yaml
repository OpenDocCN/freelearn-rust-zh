- en: '*Chapter 4*: Building pip Modules in Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*: 在 Python 中构建 pip 模块'
- en: Writing code to solve our problems is useful. However, writing code can become
    repetitive and time-consuming, especially when we are building applications. Applications
    usually require defining the steps that build the application. Packaging our code
    can help us reuse our code and share it with other developers. In this chapter,
    we will package Fibonacci code into a Python `pip` module that can be easily installed
    and has a command-line tool. We will also cover continuous integration processes
    that deploy our packages once a merge has been achieved to our `main` branch.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码来解决我们的问题是很有用的。然而，编写代码可能会变得重复且耗时，尤其是在我们构建应用程序时。应用程序通常需要定义构建应用程序的步骤。打包我们的代码可以帮助我们重用代码并与其他开发者共享。在本章中，我们将把斐波那契代码打包成一个
    Python `pip` 模块，它可以轻松安装并具有命令行工具。我们还将介绍持续集成过程，一旦合并到 `main` 分支，就会部署我们的包。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Configuring setup tools for a Python `pip` module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Python `pip` 模块配置设置工具
- en: Packaging Python code in a `pip` module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `pip` 模块中打包 Python 代码
- en: Configuring continuous integration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置持续集成
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will need to have Python 3 installed. To get the most out of this chapter,
    we will also need to have a GitHub account, as we will be using GitHub to package
    our code, which can be accessed via this link: [https://github.com/maxwellflitton/flitton-fib-py](https://github.com/maxwellflitton/flitton-fib-py).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装 Python 3。为了充分利用本章内容，我们还需要拥有一个 GitHub 账户，因为我们将会使用 GitHub 来打包我们的代码，可以通过此链接访问：[https://github.com/maxwellflitton/flitton-fib-py](https://github.com/maxwellflitton/flitton-fib-py)。
- en: 'Git command-line tools are also needed in this chapter. These can be installed
    by following the instructions here: [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git).
    The chapter will also make use of a PyPI account. You will need to have your own
    PyPI account, which can be obtained for free with this link: [https://pypi.org/](https://pypi.org/).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还需要 Git 命令行工具。这些工具可以通过以下说明进行安装：[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)。本章还将使用
    PyPI 账户。你需要拥有自己的 PyPI 账户，可以通过此链接免费获得：[https://pypi.org/](https://pypi.org/)。
- en: 'The code for this chapter can be found via this link: [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_four](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_four).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以通过此链接找到：[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_four](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_four)。
- en: Configuring setup tools for a Python pip module
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Python pip 模块配置设置工具
- en: 'Setup tools in Python are how the code in our module is packaged and installed.
    They provide a set of commands and parameters for the system that is installing
    the code to process. To explore how this is done, we will package the Fibonacci
    numbers example introduced in the previous chapter. However, these calculations
    will be packaged in a `pip` module. To configure our setup tools, we are going
    to have to carry out the following steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的设置工具是打包和安装我们模块中的代码的方式。它们为安装代码的系统提供了一套命令和参数，以便处理。为了探索如何实现这一点，我们将打包前一章中介绍的斐波那契数示例。然而，这些计算将被打包在一个
    `pip` 模块中。为了配置我们的设置工具，我们需要执行以下步骤：
- en: Create a GitHub repository for our Python `pip` package.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的 Python `pip` 包创建一个 GitHub 仓库。
- en: Define basic parameters.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义基本参数。
- en: Define a `README` file.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `README` 文件。
- en: Define a basic module structure.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义基本模块结构。
- en: Let's have a look at each of these steps in detail in the following subsections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下节详细查看这些步骤。
- en: Creating a GitHub repository
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 GitHub 仓库
- en: 'Understandably, a seasoned developer can create a GitHub repository but for
    the sake of completeness, we will offer all the steps needed. If you can already
    create a GitHub repository, move on to the next subsection:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，经验丰富的开发者可以创建 GitHub 仓库，但为了完整性，我们将提供所有必要的步骤。如果你已经可以创建 GitHub 仓库，请继续下一节：
- en: On the home URL of GitHub when we are logged in, we can create our repository
    by clicking on the **New** button, as shown here:![Figure 4.1 – How to create
    a new repository on GitHub
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在登录后的 GitHub 主页面上，我们可以通过点击**新建**按钮来创建我们的仓库，如图所示：![图4.1 – 如何在 GitHub 上创建新仓库
- en: '](img/Figure_4.01_B17720.jpg)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.01_B17720.jpg)'
- en: Figure 4.1 – How to create a new repository on GitHub
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.1 – 如何在 GitHub 上创建一个新的仓库
- en: Once this is clicked, we can configure our new repository with the parameters
    shown next:![Figure 4.2 – Parameters for our new GitHub repository
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦点击，我们可以使用下面的参数配置我们的新仓库：![图 4.2 – 我们新 GitHub 仓库的参数
- en: '](img/Figure_4.02_B17720.jpg)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_4.02_B17720.jpg](img/Figure_4.02_B17720.jpg)'
- en: Figure 4.2 – Parameters for our new GitHub repository
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.2 – 我们新 GitHub 仓库的参数
- en: 'For this example, we have set the GitHub repository to `pip` packaging for
    this chapter will also work the same way for private repositories. We have also
    included a `.gitignore` file and selected it to be Python. This is to stop Python
    caching and for virtual environment files to be tracked by GitHub and uploaded
    when we upload our code to the repository. Now that we have our GitHub repository
    made, going to the repository will look like this:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将 GitHub 仓库设置为 `pip` 打包，这一章的私有仓库也将以相同的方式工作。我们还包含了一个 `.gitignore` 文件，并将其选为
    Python。这是为了停止 Python 缓存，并让虚拟环境文件由 GitHub 跟踪，在我们上传代码到仓库时上传。现在我们已经创建了 GitHub 仓库，进入仓库将看起来像这样：
- en: '![Figure 4.3 – Our GitHub repository home page'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.3 – 我们 GitHub 仓库主页'
- en: '](img/Figure_4.03_B17720.jpg)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_4.03_B17720.jpg](img/Figure_4.03_B17720.jpg)'
- en: Figure 4.3 – Our GitHub repository home page
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.3 – 我们 GitHub 仓库主页
- en: We can see that our description is written in the `README.md` file. It also
    has to be noted that the `README.md` file is rendered. This happens in any directory
    of the repository. We can document what to do and how to use the code throughout
    the repository with a range of `README.md` files if we want.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的描述是写在 `README.md` 文件中的。还必须注意的是，`README.md` 文件是可渲染的。这发生在仓库的任何目录中。如果我们想，我们可以通过一系列的
    `README.md` 文件在整个仓库中记录要做什么以及如何使用代码。
- en: 'Once this is done, we can download our repository with the command shown next:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以使用下面的命令下载我们的仓库：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Your URL will be different, as you have a different repository. The only thing
    left is to ensure that our development environment for our repository has a Python
    virtual environment.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的 URL 将不同，因为你有一个不同的仓库。唯一剩下的事情是确保我们的仓库的开发环境有一个 Python 虚拟环境。
- en: 'This can be done by navigating to the root directory of the GitHub repository
    and then running the command shown here:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以通过导航到 GitHub 仓库的根目录，然后运行下面的命令来完成：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use our virtual environment in the terminal, we can activate it with the
    command shown next:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在终端中使用我们的虚拟环境，我们可以使用下面的命令激活它：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see that our command is prefixed with `(venv)`, meaning that it is active.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的命令前面带有 `(venv)` 前缀，这意味着它是激活的。
- en: Defining the basic parameters
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义基本参数
- en: 'Now that our environment is fully functional, we are going to define the basic
    parameters when installing our Python `pip` module:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使环境完全可用，我们将定义在安装 Python `pip` 模块时的基本参数：
- en: 'This is achieved by creating a `setup.py` file in the root of our repository.
    This will get run when another Python system installs our `pip` module. In our
    `setup.py` file, we import our setup tools with the code shown here:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这通过在仓库根目录下创建一个 `setup.py` 文件来实现。当另一个 Python 系统安装我们的 `pip` 模块时，它将被运行。在我们的 `setup.py`
    文件中，我们使用以下代码导入我们的设置工具：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are going to use `setup` to define our parameters, and we are going to use
    `find_packages` to exclude tests.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用 `setup` 来定义我们的参数，并使用 `find_packages` 来排除测试。
- en: 'Now that we have imported our setup tools, we can define our parameters in
    the same file with the code shown here:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导入了设置工具，我们可以使用以下代码在同一个文件中定义我们的参数：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are a lot of parameters here. What we have done from the `name` field
    to `url` is essentially define the metadata around our `pip` module. The `classifiers`
    fields are also metadata around our module. The rest of the fields have the following
    effects:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有很多参数。我们从 `name` 字段到 `url` 所做的是本质上定义了我们 `pip` 模块的元数据。`classifiers` 字段也是我们模块的元数据。其余的字段具有以下效果：
- en: The `Install_requires` field is currently an empty list. This is because our
    module is not requiring any third-party modules right now. We will cover dependencies
    in *Managing dependencies* section.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Install_requires` 字段目前是一个空列表。这是因为我们的模块目前不需要任何第三方模块。我们将在 *管理依赖项* 部分介绍依赖项。'
- en: The `packages` field ensures that we exclude our `test` directory when we start
    building our tests for our module. While we will use tests to check our module
    and ensure standards, we do not need to install them when we are using our module
    as a third-party dependency.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packages`字段确保我们在开始构建模块的测试时排除我们的`test`目录。虽然我们将使用测试来检查我们的模块并确保标准，但当我们使用我们的模块作为第三方依赖项时，我们不需要安装它们。'
- en: The `Python_requires` field ensures that the system installing our module has
    the correct version of Python installed.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Python_requires`字段确保安装我们的模块的系统已安装正确的Python版本。'
- en: '`tests_require` is a list of requirements when tests are running.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests_require`是在运行测试时的一组需求。'
- en: 'Now that we have defined our basic setup, we can upload our code with the following
    commands:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了基本设置，我们可以使用以下命令上传我们的代码：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we have done here is add all of the new and changed files to our Git branch
    (which is `main`). We then committed our files with the `adding setup to module`
    message. We then pushed our code to the `main` branch, which means that we uploaded
    our changes onto the Git repository online. This is not the best way to manage
    our code iterations. We will go over different branches and how to manage them
    in the continuous integration section near the end of this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将所有新更改的文件添加到我们的Git分支（即`main`分支）。然后我们使用`adding setup to module`信息提交我们的文件。然后我们将代码推送到`main`分支，这意味着我们将更改上传到了在线的Git仓库。这不是管理我们的代码迭代的最优方式。我们将在本章末尾的持续集成部分介绍不同的分支以及如何管理它们。
- en: You may have noticed that `long_description` is a Markdown; however, trying
    to fit an entire Markdown into this field would end up dominating the `setup.py`
    file. It would essentially be a long string spanning multiple lines, with a few
    Python lines dispersed into it. We want our `setup.py` file to dictate the logic
    of setting up the module when it is being installed. We also want our long description
    of the module to be rendered by GitHub when we visit the GitHub repository directly
    online. Because of this, we will need to add some extra logic around defining
    our long description in the next section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`long_description`是Markdown格式；然而，试图将整个Markdown放入这个字段会导致`setup.py`文件变得庞大。它将基本上是一个跨越多行的长字符串，其中散布着一些Python代码行。我们希望我们的`setup.py`文件在模块安装时指导设置逻辑。我们还希望模块的详细描述在直接访问GitHub仓库时由GitHub渲染。因此，在下一节中，我们需要在定义我们的详细描述周围添加一些额外的逻辑。
- en: Defining a README file
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个README文件
- en: 'Our long description is essentially the `README.md` file. If we fuse this with
    our `setup.py`, our `README.md` file will also render if we visit it on PyPI and
    it is uploaded to the PyPI server. This can be done by reading the `README.md`
    file into a string in the `setup.py` file and then plugging that string into our
    `long_description` field with the following code in the `setup.py` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的详细描述基本上是`README.md`文件。如果我们将其与`setup.py`合并，当我们在PyPI上访问它并上传到PyPI服务器时，`README.md`文件也会被渲染。这可以通过在`setup.py`文件中将`README.md`文件读取为字符串，然后使用以下代码将该字符串插入到`long_description`字段中来实现：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The rest of the code after `...` is the same as before. With this, our basic
    module setup is complete. Now, all we need is to do is define a basic module to
    install and use, which is what we will do in the next step.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`...`之后的代码与之前相同。有了这个，我们的基本模块设置就完成了。现在，我们只需要定义一个基本的模块来安装和使用，这就是我们在下一步将要做的。'
- en: Defining a basic module
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个基本模块
- en: 'Defining a basic module takes the following structure:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个基本模块采用以下结构：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We house the actual code that the user will have in our `flitton_fib_py` directory.
    For now, we are just going to have a basic function that prints something out
    so that we can see if our `pip` package works. Here are the steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用户将拥有的实际代码放在我们的`flitton_fib_py`目录中。目前，我们只将有一个基本的打印函数，以便我们可以看到我们的`pip`包是否工作。以下是步骤：
- en: 'We do this by adding a basic `print` function in the `flitton_fib_py/__init__.py`
    file that has the following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在`flitton_fib_py/__init__.py`文件中添加一个基本的`print`函数来实现这一点，该函数具有以下代码：
- en: '[PRE22]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once this is done, we can upload the code to the GitHub repository using the
    git commands described in the *Packaging Python code in a pip module* section.
    We should now see all the code of our module in the `main` branch. Considering
    this, we need to navigate to another directory that is not associated with our
    `git` repository.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以使用 *打包 Python 代码到 pip 模块* 部分中描述的 git 命令将代码上传到 GitHub 仓库。现在我们应该在 `main`
    分支中看到我们模块的所有代码。考虑到这一点，我们需要导航到另一个与我们的 `git` 仓库不相关的目录。
- en: 'We then unlink our virtual environment by typing the following command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过输入以下命令解除我们的虚拟环境：
- en: '[PRE23]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To use `pip install`, we point to the URL of the GitHub repository that our
    `pip` module is stored and define which branch it is. We do this by typing the
    following command, all in one line:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `pip install`，我们指向存储我们的 `pip` 模块的 GitHub 仓库的 URL，并定义它是哪个分支。我们通过输入以下命令来完成，所有内容都在一行中：
- en: '[PRE24]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Your GitHub repository will have a different URL and you might have a different
    directory. Running this command will give us a range of printouts, stating that
    it is cloning the repository and installing it.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的 GitHub 仓库将有一个不同的 URL，你可能有不同的目录。运行此命令将给出一系列输出，表明它正在克隆仓库并安装它。
- en: 'We then open up a Python terminal by typing in the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过输入以下命令打开 Python 终端：
- en: '[PRE25]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We now have an interactive terminal. We can check to see whether our module
    works by typing in the following commands:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有一个交互式终端。我们可以通过输入以下命令来检查我们的模块是否工作：
- en: '[PRE26]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the last command is typed, we will get the following printout in the terminal:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦输入最后一个命令，我们将在终端中得到以下输出：
- en: '[PRE27]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There we have it – our Python package works! This works for both private and
    public GitHub repositories. Nothing is stopping us now from packaging private
    Python code to reuse on other private Python projects!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们的 Python 包就成功了！这对私有和公共 GitHub 仓库都适用。现在没有什么能阻止我们将私有 Python 代码打包以在其他私有 Python
    项目中重用！
- en: While this is a useful tool to package and install code on other computers with
    minimal setup, we have to be careful. When we are running the `setup.py` file,
    we are running the code as our root user. Therefore, we have to ensure that we
    trust what we are installing. Putting malicious code into the `setup.py` file
    is a vector of attack. We can run direct commands on the computer using the `SubProcess`
    object from the standard Python library. Make sure you trust the author of the
    code that you are installing with `pip install`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个有用的工具，可以在其他计算机上以最少的设置打包和安装代码，但我们必须小心。当我们运行 `setup.py` 文件时，我们是以我们的 root
    用户身份运行代码。因此，我们必须确保我们信任我们正在安装的内容。将恶意代码放入 `setup.py` 文件是一种攻击向量。我们可以使用标准 Python 库中的
    `SubProcess` 对象在计算机上运行直接命令。确保你信任你用 `pip install` 安装的代码的作者。
- en: This also highlights how vigilant you have to be when merely just running `pip
    install`. There are developers out there who will slightly change a package. For
    instance, a famous case was the `requests` package. This is a common, well-used
    package; however, for some time, there was an imitation package called `request`.
    They relied on people mistyping `pip install` and downloading the wrong package.
    This is known as **typosquatting**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这也突显了在仅仅运行 `pip install` 时，你必须多么警觉。有些开发者会稍微修改一个包。例如，有一个著名的案例是 `requests` 包。这是一个常见且广泛使用的包；然而，在一段时间内，有一个名为
    `request` 的仿冒包。它们依赖于人们误输入 `pip install` 并下载错误的包。这被称为 **打字欺骗**。
- en: We have now packaged our Python code into a module. However, it is not a very
    useful module. This brings us to our next section, where we package our Fibonacci
    sequencing code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将我们的 Python 代码打包成一个模块。然而，它不是一个非常有用的模块。这把我们带到了下一个部分，我们将打包我们的斐波那契序列代码。
- en: Packaging Python code in a pip module
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包 Python 代码到 pip 模块
- en: 'Now that we have our GitHub repository configured, we can start building out
    our Fibonacci code for our module. To achieve this, we must carry out the following
    steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了 GitHub 仓库，我们可以开始构建我们模块的斐波那契代码。为了实现这一点，我们必须执行以下步骤：
- en: Build our Fibonacci calculation code.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建我们的斐波那契计算代码。
- en: Create a command-line interface.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建命令行界面。
- en: Test our Fibonacci calculation code with unit tests.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单元测试测试我们的斐波那契计算代码。
- en: Let's now discuss each of these steps in detail.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在详细讨论这些步骤。
- en: Building our Fibonacci calculation code
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的斐波那契计算代码
- en: When it comes to building our Fibonacci calculation code, we will have two functions
    – one that will calculate a Fibonacci number and another that will take a list
    of numbers and lean on the calculation function to return a list of calculated
    Fibonacci numbers. For this module, we will take a functional programming approach.
    This does not mean that we should have a functional programming approach every
    time we build a `pip` module. We are using functional programming because Fibonacci
    sequence calculations naturally flow well with a functional programming style.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构建我们的斐波那契计算代码时，我们将有两个函数——一个用于计算斐波那契数，另一个将接受一个数字列表并依赖于计算函数来返回计算出的斐波那契数列表。对于这个模块，我们将采用函数式编程方法。这并不意味着我们在构建每个`pip`模块时都应该采用函数式编程方法。我们使用函数式编程是因为斐波那契数列的计算自然地与函数式编程风格相结合。
- en: 'Python is an object-orientated language, and problems that have multiple moving
    parts interrelating naturally flow well with object-orientated approaches. Our
    module structure will take the following form:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种面向对象的语言，具有多个相互关联的移动部分的问题自然地与面向对象的方法相结合。我们的模块结构将采用以下形式：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For this chapter, we will maintain a simple interface so that we can focus
    on the packaging of code in a `pip` module. Here are the steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将保持一个简单的界面，以便我们可以专注于在`pip`模块中打包代码。以下是步骤：
- en: 'First, we can build our Fibonacci number calculator in the `fib_number.py`
    file with the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以在`fib_number.py`文件中使用以下代码构建我们的斐波那契数计算器：
- en: '[PRE37]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, it has to be noted that we are returning `None` when the input number
    is below zero. Technically, we should be throwing an error, but this is in place,
    for now, to demonstrate the effectiveness of a checking tool later on in our *Configuring
    continuous integration* section. As we know from the previous chapter, the preceding
    code will correctly calculate a Fibonacci number based on the input number.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里需要注意的是，当输入的数字小于零时，我们返回`None`。从技术上讲，我们应该抛出一个错误，但现在这样做是为了演示在*配置持续集成*部分中检查工具的有效性。正如我们从前一章所知，前面的代码将根据输入数字正确计算出斐波那契数。
- en: 'Now that we have this function, we can depend on this to create a function
    that creates a list of Fibonacci numbers in our `fib_numbers.py` file with the
    following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这个函数，我们可以依赖它来创建一个函数，该函数可以在我们的`fib_numbers.py`文件中生成斐波那契数列表，以下代码如下：
- en: '[PRE38]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are now ready to test our `pip` module again. We must push our code to the
    `main` branch on our repository again, uninstall our `pip` package in another
    virtual environment, and install again using `pip install`.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在准备好再次测试我们的`pip`模块。我们必须再次将我们的代码推送到存储库的`main`分支，在另一个虚拟环境中卸载我们的`pip`包，并使用`pip
    install`重新安装。
- en: 'In our Python terminal with our new installed package, we can test our `recurring_fibonacci_number`
    function with the following console commands:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们安装了新包的Python终端中，我们可以使用以下控制台命令测试我们的`recurring_fibonacci_number`函数：
- en: '[PRE39]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we can see that our Fibonacci function can be imported, and it works,
    calculating the correct Fibonacci numbers.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的斐波那契函数可以被导入，并且它运行正常，计算出了正确的斐波那契数。
- en: 'We can test our `calculate_numbers` with the following commands:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令测试我们的`calculate_numbers`：
- en: '[PRE40]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we can see that our `calculate_numbers` function also works. We have a
    fully functioning Fibonacci `pip` module. However, if we want to just calculate
    a Fibonacci number without coding a Python script, we should not have to go into
    a Python terminal. We can remedy this by building a command-line interface in
    the next step.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的`calculate_numbers`函数也运行正常。我们有一个完全功能的斐波那契`pip`模块。然而，如果我们只想计算一个斐波那契数而不编写Python脚本，我们就不必进入Python终端。我们可以通过在下一步构建命令行界面来解决这个问题。
- en: Creating a command-line interface
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建命令行界面
- en: 'In order to build our command line function, our module can take the following
    structure:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的命令行函数，我们的模块可以采用以下结构：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To build our interface, we follow these steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的界面，我们遵循以下步骤：
- en: 'We build the command-line interface in our `fib_numb.py` file with the following
    code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`fib_numb.py`文件中使用以下代码构建命令行界面：
- en: '[PRE50]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, we can see that we get the parameters passed in from the command line
    using the `argparse` module. Once we have obtained the parameters, we will then
    calculate the number and print it out. Now, for us to actually access it via the
    terminal, we have to point to it in the `setup.py` file at the root of the `pip`
    package by adding the following parameter in the `setup` object initialization:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们使用`argparse`模块从命令行获取传递的参数。一旦我们获得了参数，我们就会计算这个数字并将其打印出来。现在，为了实际上通过终端访问它，我们必须在`pip`包根目录的`setup.py`文件中指向它，通过在`setup`对象初始化中添加以下参数：
- en: '[PRE51]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, what we are doing is linking the `fib-number` console command with the
    function that we have just defined. After uninstalling our `pip` module in another
    virtual environment, uploading the changes to the `main` branch on our repository,
    and installing our new module using `pip install`, we will have our new module
    with the command-line tool that we have built.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们所做的是将`fib-number`控制台命令与我们刚刚定义的函数相链接。在另一个虚拟环境中卸载我们的`pip`模块，将更改上传到我们仓库的`main`分支，并使用`pip
    install`安装我们的新模块后，我们将拥有我们构建的命令行工具的新模块。
- en: 'Once it is installed, we just type in the following command:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，我们只需输入以下命令：
- en: '[PRE52]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: fib-number -h
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fib-number -h
- en: '[PRE53]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'usage: fib-number [-h] --number NUMBER'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用方法：fib-number [-h] --number NUMBER
- en: Calculate Fibonacci numbers
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算斐波那契数
- en: 'optional arguments:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选参数：
- en: -h, --help       show this help message and exit
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -h, --help       显示此帮助信息并退出
- en: --number NUMBER  Fibonacci number to be calculated
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --number NUMBER  要计算的斐波那契数
- en: '[PRE54]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'So, to calculate the Fibonacci number, we use the following command:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，要计算斐波那契数，我们使用以下命令：
- en: '[PRE55]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This gives us the following printout:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '[PRE56]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If we were to provide a string instead of a number for our argument, our program
    would refuse it, throwing an error.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们为参数提供一个字符串而不是数字，我们的程序将拒绝它，并抛出错误。
- en: Here we have it, we have a fully working command-line tool! This does not stop
    here. You can take this further. Nothing is stopping you from using `subprocess`
    from the standard library combined with other libraries, such as Docker, to build
    your own DevOps tools. You can automate whole workflows for yourself and the applications
    you make. However, if we are to rely more and more on our `pip` modules to do
    the repetitive heavy lifting, we can get into serious problems if the program
    introduces some bugs we need to know straight away. To do this, we need to start
    building unit tests for our module. These are covered in the next subsection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们已经有了，我们有一个完全工作的命令行工具！但这并没有结束。你可以更进一步。没有什么能阻止你使用标准库中的`subprocess`与其他库，如Docker结合，来构建你自己的DevOps工具。你可以自动化你自己的整个工作流程和应用程序。然而，如果我们越来越多地依赖我们的`pip`模块来做重复的繁重工作，如果程序引入了一些我们需要立即知道的错误，我们可能会遇到严重的问题。为了做到这一点，我们需要开始为我们模块构建单元测试。这些将在下一小节中介绍。
- en: Building unit tests
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建单元测试
- en: 'Unit tests are helpful for us to check and maintain quality control for our
    code. To build our unit tests, our module will have the following structure:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试对我们检查和维护代码的质量控制非常有帮助。为了构建我们的单元测试，我们的模块将具有以下结构：
- en: '[PRE57]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We can see that we are mimicking the structure of the code in our module. This
    is important to keep track of our tests. If the module grows, then we will not
    get lost in our tests. If we need to chop out a directory or move it to another
    module, we can simply delete the appropriate directory or move it. It also has
    to be noted that we have built a Bash script to run our tests.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们正在模仿我们模块中的代码结构。这对于跟踪我们的测试非常重要。如果模块增长，我们不会在我们的测试中迷失方向。如果我们需要删除目录或将其移动到另一个模块，我们可以简单地删除适当的目录或移动它。还必须注意的是，我们已经构建了一个Bash脚本来运行我们的测试。
- en: 'When it comes to writing our tests, it is usually best to code based on the
    chain of dependency. For instance, our files have the dependency chain depicted
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到编写我们的测试时，通常最好基于依赖链进行编码。例如，我们的文件具有以下依赖关系链的描述：
- en: '![Figure 4.4 – Dependency chain'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – 依赖关系链'
- en: '](img/Figure_4.04_B17720.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.04 – 依赖关系链](img/Figure_4.04_B17720.jpg)'
- en: Figure 4.4 – Dependency chain
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 依赖关系链
- en: 'Considering our dependency chain, we should ideally write our tests for the
    `fib_number.py` file first and make sure that our `recurring_fibonacci_number`
    function works before writing tests that rely on the `recurring_fibonacci_number`
    function. Here are the steps to write our tests:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的依赖关系链，我们应该首先为`fib_number.py`文件编写测试，并确保我们的`recurring_fibonacci_number`函数在编写依赖于`recurring_fibonacci_number`函数的测试之前正常工作。以下是编写测试的步骤：
- en: 'We first import what we need to test our code in our `test_fib_number.py` file
    via the following code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过以下代码在我们的`test_fib_number.py`文件中导入测试代码所需的模块：
- en: '[PRE72]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `main` function is to run all tests. We also rely on the `TestCase` class
    by writing our own test class that inherits `TestCase`. This gives our class extra
    class functions to aid us in testing outcomes.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`main`函数是用来运行所有测试的。我们还通过编写自己的继承自`TestCase`的测试类来依赖`TestCase`类。这为我们提供了额外的类函数，有助于我们测试结果。'
- en: 'We can write our own tests for a range of inputs with the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码编写一系列输入的测试：
- en: '[PRE73]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, it has to be noted that each one of our functions has the `test_` prefix.
    This flags the function as a test function. This is also the case for the name
    of the file. All test files have the `test_` prefix to flag that the file houses
    tests. In our testing code, we can see that we have merely passed a range of inputs
    into the function that we are testing and asserted that the outcome is what we
    expect. If the assertions do not hold water, then we get an error and a failed
    result. Seeing as we are just testing the same function repeatedly, we can put
    all of the assertions into one test function. This is usually preferred if we
    are testing the whole object. We would essentially have one test function for
    each function that we are testing in the object.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里需要注意的是，我们所有的函数都有一个`test_`前缀。这标志着该函数是一个测试函数。文件名也是这样。所有测试文件都有`test_`前缀，以标记该文件包含测试。在我们的测试代码中，我们可以看到我们只是将一系列输入传递给我们要测试的函数，并断言结果是我们所期望的。如果断言不成立，那么我们会得到一个错误和一个失败的结果。鉴于我们只是在重复测试同一个函数，我们可以将所有的断言放入一个测试函数中。如果我们正在测试整个对象，这通常是首选的。我们实际上会为对象中要测试的每个函数有一个测试函数。
- en: 'Now that all our tests have been run, we can run the `unittest` `main` function
    if the `test_fib_number.py` file is run directly at the bottom of the `test_fib_number.py`
    file with the code shown next:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经运行了所有的测试，如果直接在`test_fib_number.py`文件的底部运行`unittest` `main`函数，我们可以运行以下代码：
- en: '[PRE74]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We now have to set our `PYTHONPATH` variable to the directory of `flitton_fib_py`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须将我们的`PYTHONPATH`变量设置为`flitton_fib_py`目录。
- en: 'Once this is done, we can run our `test_fib_number.py` file and get the console
    printout as shown:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以运行我们的`test_fib_number.py`文件，并得到如图所示的控制台输出：
- en: '[PRE75]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: F in the test dots, and it highlights what test is failing and where it is failing.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试点中的F会高亮显示，并突出显示失败的测试及其失败的位置。
- en: '[PRE76]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now that we have built our base test, we can build our tests for the function
    that takes in a list of integers and returns a list of Fibonacci numbers. In our
    `test_fib_numbers.py` file, we import what we need with the following code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经构建了我们的基本测试，我们可以构建一个函数的测试，该函数接受一个整数列表并返回一个斐波那契数列列表。在我们的`test_fib_numbers.py`文件中，我们使用以下代码导入所需的模块：
- en: '[PRE77]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we can see that we are importing the function that we are testing and
    the same `main` and `TestCase`. However, it has to be noted that we have imported
    a `patch` function. This is because we have already tested our `recurring_fibonacci_number`
    function. The `patch` function enables us to insert a `MagicMock` object in place
    of our `recurring_fibonacci_number` function.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们正在导入我们正在测试的函数以及相同的`main`和`TestCase`。但是，必须注意的是，我们已经导入了`patch`函数。这是因为我们已经测试了我们的`recurring_fibonacci_number`函数。`patch`函数使我们能够将`MagicMock`对象插入到我们的`recurring_fibonacci_number`函数的位置。
- en: For our example, it can be argued that we do not need to patch anything. However,
    it is important to get an understanding of patching. `MagicMock` object; we can
    define the return values to anything we want during the test and log all calls
    to the `MagicMock` object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，可以争论我们不需要修补任何东西。然而，了解修补是很重要的。`MagicMock`对象；我们可以在测试期间将返回值定义为任何我们想要的，并记录对`MagicMock`对象的全部调用。
- en: The advantage here is that we might accidentally call the function we are depending
    on twice for some reason. However, if the function returns the same value twice,
    we will not know anything if we did not patch it. However, with patching, we can
    inspect the calls and throw errors if the behavior is not what we expect. We can
    also test a range of edge cases very quickly by merely changing the return value
    of the patches and rerunning the test.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的优势是，我们可能由于某种原因意外地调用了我们依赖的函数两次。然而，如果函数两次返回相同的值，如果我们没有修复它，我们将一无所知。但是，通过修复，我们可以检查调用并抛出错误，如果行为不是我们所期望的。我们也可以通过仅更改补丁的返回值并重新运行测试，非常快速地测试一系列边缘情况。
- en: 'With all this, it is understandable that we can get excited about patching.
    However, there are some downsides. If we do not update the patches'' return values,
    the dependent code does not get the changes, and the testing does not remain accurate.
    This is why it is always sensible to have a mixture of approaches and run a functional
    test that runs the whole process without patching anything. With all this in mind,
    our patched unit test in the `tests/flitton_fib_by/fib_calcs/test_fib_numbers.py`
    file is carried out by the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些，我们可以理解为什么我们对修补感到兴奋。然而，也有一些缺点。如果我们不更新修补的返回值，依赖的代码不会得到更改，测试也不会保持准确。这就是为什么总是明智地采用多种方法，并运行一个不进行任何修补的功能测试，以运行整个过程。考虑到所有这些，我们的修补单元测试在`tests/flitton_fib_by/fib_calcs/test_fib_numbers.py`文件中是通过以下代码执行的：
- en: '[PRE78]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Here, we can see that we have used the patch as a decorator with a string that
    defines the path to the function that we are patching. We then pass the patched
    function through the test function under the `mock_fib_calc` parameter. We then
    state that we expect the outcome of the function that we are directly testing
    (`calculate_numbers`) to be a list of two return values of the patched function.
    We then pass two integers wrapped in a list into the `calculate_numbers` function
    and assert that this is going to be the same as our expected outcome. Once this
    is done, we assert that the `mock_fib_calc` was only called twice, and we inspect
    each of those calls, asserting that they are the numbers that we passed in, in
    the correct order. This has given us a lot of power to truly inspect our code.
    However, we are not done yet; we also must define the functional test to enable
    us to run our tests with the code here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们使用了一个字符串来定义我们要修补的函数的路径，将补丁作为装饰器使用。然后，我们将修补后的函数通过`mock_fib_calc`参数传递给测试函数。接着，我们声明我们期望直接测试的函数（`calculate_numbers`）的结果是修补函数的两个返回值的列表。然后，我们将两个整数包裹在列表中传递给`calculate_numbers`函数，并断言这将与我们的预期结果相同。一旦完成，我们断言`mock_fib_calc`只被调用了两次，并检查每一个调用，断言它们是我们传递的数字，并且顺序正确。这给了我们很大的权力来真正检查我们的代码。然而，我们还没有完成；我们还需要定义功能测试，以便我们能够运行这里的测试：
- en: '[PRE92]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'For our module, all our unit tests are done. However, we do not want to go
    through manually running each file to see our tests. There will be times where
    we want to just see all the outcomes of the tests to see if there are any fails.
    To automate this, we can build a Bash script in the `run_tests.sh` file with the
    code here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模块，所有的单元测试都已经完成。然而，我们不想手动运行每个文件来查看我们的测试。有时我们只想查看所有测试的结果，看看是否有失败的。为了自动化这个过程，我们可以在`run_tests.sh`文件中构建一个Bash脚本，代码如下：
- en: '[PRE97]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Here, we claim that the file is a Bash script with the first line. The first
    line is a shebang line and tells the computer running it what type of language
    it is. We then get the directory path of where this script is and assign it to
    the `SCRIPTPATH` variable. We then navigate to this directory, move out to the
    root of our module, activate our virtual environment, and then define our `PYTHONPATH`
    variable to be in our module with the Fibonacci number code. Now that everything
    is defined, to run our test we use the `unittest` command-line tool to run all
    the unit tests. Remember, all our tests have the `test_` prefix in their filenames.
    Running this gives us the following printout:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声称这个文件是一个Bash脚本，第一行是。第一行是一个shebang行，告诉运行它的计算机它是什么类型的语言。然后我们获取这个脚本所在的目录路径，并将其分配给`SCRIPTPATH`变量。然后我们导航到这个目录，移动到我们模块的根目录，激活我们的虚拟环境，然后定义我们的`PYTHONPATH`变量，使其包含我们的模块中的斐波那契数代码。现在一切都已经定义好了，为了运行我们的测试，我们使用`unittest`命令行工具来运行所有的单元测试。记住，所有我们的测试文件名都有`test_`前缀。运行这个命令会给出以下输出：
- en: '[PRE104]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Here, we can see that we have seven tests running and they have all passed.
    We can see that we have started automating the test-running process. This is not
    where we should stop. As we move forward onto packaging and distributing our `pip`
    module, we should investigate automating the processes through continuous integration,
    which is what we explore in the next section. Right now, as it stands, if a user
    has access to our GitHub repository, we can install the code via `pip` and use
    it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到有七个测试正在运行，并且它们都通过了。我们可以看到我们已经开始了测试运行的自动化过程。这并不是我们应该停止的地方。当我们继续前进到打包和分发我们的`pip`模块时，我们应该调查通过持续集成来自动化这些过程，这是我们将在下一节中探讨的内容。目前，按照现状，如果一个用户可以访问我们的GitHub仓库，我们可以通过`pip`安装代码并使用它。
- en: Configuring continuous integration
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置持续集成
- en: Our Python `pip` package is fully functioning. However, this is not the end.
    We will need to maintain the quality of the code and enable it to be constantly
    upgraded when we push new features to our module and refactor existing code. Continuous
    integration enables us to ensure that the tests pass and that the standard of
    quality is maintained. It also speeds up the deployment process, enabling us to
    push new iterations within a matter of minutes, enabling us to focus on the task
    at hand. It also reduces the risk of making a mistake.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Python `pip`包完全可用。然而，这并不是终点。我们需要保持代码的质量，并在我们向模块推送新功能和对现有代码进行重构时，使其能够不断升级。持续集成使我们能够确保测试通过，并保持质量标准。它还加快了部署过程，使我们能够在几分钟内推送新迭代，使我们能够专注于手头的任务。它还降低了出错的风险。
- en: 'As we know, the most mundane, repetitive tasks are the ones that are at the
    highest risk of a mistake occurring. This is just a fact of life. It''s known
    that most car crashes happen within 5 minutes of the driver''s home. This is because
    the drivers pay less attention and their brain switches off, relying on muscle
    memory. Deployment processes are the same. They are repetitive and do not require
    a lot of mental focus. As a result, after several times, we will start to rely
    on muscle memory and forget to check certain things, and make minor blunders when
    deploying our `pip` package. Continuous integration is a must to avoid mistakes
    and saves time in not only deployment but also in not having to correct the errors.
    To set up continuous integration, we are going to have to carry out the following
    steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，最平凡、重复的任务是最容易出错的任务。这是生活的一个事实。众所周知，大多数车祸发生在司机离家5分钟内。这是因为司机注意力分散，大脑关闭，依赖肌肉记忆。部署过程也是如此。它们是重复的，不需要太多的精神集中。因此，经过几次之后，我们开始依赖肌肉记忆，忘记检查某些事情，在部署我们的`pip`包时犯下小错误。持续集成是避免错误和节省时间（不仅是在部署中，而且在无需纠正错误中）的必要手段。为了设置持续集成，我们必须执行以下步骤：
- en: Manually deploy onto PyPI.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动部署到PyPI。
- en: Manage our dependencies.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理我们的依赖项。
- en: Set up type checking for Python.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Python的类型检查。
- en: Set up and run tests and type checking with GitHub Actions.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用GitHub Actions设置和运行测试以及类型检查。
- en: Create automatic versioning for our `pip` package.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的`pip`包创建自动版本控制。
- en: Deploy onto PyPI using GitHub Actions.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用GitHub Actions部署到PyPI。
- en: Let's have a look at each of these steps in detail in the following subsections.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下一节详细查看这些步骤。
- en: Manually deploying onto PyPI
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动部署到PyPI
- en: 'We now move on to our first step of manually deploying our GitHub repository
    onto PyPI. We have installed our `pip` package by directly pointing to the GitHub
    repository. However, if we are allowing everyone to access our module as it''s
    open source, it is easier to upload our package onto PyPI. This will enable others
    to install using a simple command. Here are the steps:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在继续到手动将我们的GitHub仓库部署到PyPI的第一步。我们已经通过直接指向GitHub仓库安装了我们的`pip`包。然而，如果我们允许每个人访问我们的模块，因为它开源，那么上传我们的包到PyPI会更简单。这将使其他人能够使用简单的命令进行安装。以下是步骤：
- en: 'First, we need to package our `pip` module before we upload it. This can be
    done with the following command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在我们上传之前，需要打包我们的`pip`模块。这可以通过以下命令完成：
- en: '[PRE108]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: ├── LICENSE
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ├── LICENSE
- en: ├── README.md
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ├── README.md
- en: ├── dist
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ├── dist
- en: │   └── flitton_fib_py-0.0.1.tar.gz
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: │   └── flitton_fib_py-0.0.1.tar.gz
- en: ├── flitton_fib_py
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ├── flitton_fib_py
- en: . . .
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: . . .
- en: '[PRE109]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We can now see that the version is included in the filename. We are now ready
    to upload onto the PyPI server. To do this, we have to install `twine` with the
    following command:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以看到版本号已经包含在文件名中。我们现在已经准备好上传到PyPI服务器。为此，我们必须使用以下命令安装`twine`：
- en: '[PRE110]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We are now able to upload the `tar.gz` file with the following command:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令上传`tar.gz`文件：
- en: '[PRE111]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This uploads all of the packages that we have created. During this process,
    the terminal will ask us for the PyPI username and password. It then uploads the
    package and tells us where we can find out the module on PyPI. If we visit this,
    we should get the view depicted in the following figure:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将上传我们创建的所有包。在这个过程中，终端会要求我们输入PyPI用户名和密码。然后上传包，并告诉我们可以在PyPI上找到模块的位置。如果我们访问这个位置，我们应该会看到以下图中所示视图：
- en: '![Figure 4.5 – PyPI view of our module'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – 我们模块的PyPI视图'
- en: '](img/Figure_4.05_B17720.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.05_B17720.jpg)'
- en: Figure 4.5 – PyPI view of our module
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 我们模块的PyPI视图
- en: We can see that our `README.md` file is being directly rendered in the view
    in *Figure 4.5*. We can now directly install this with the `pip install` command
    depicted in the PyPI view. It must be noted that we now have a dependency. We
    need to manage these dependencies. We will cover this in the next step.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的`README.md`文件正在被直接渲染在*图4.5*的视图中。现在，我们可以直接使用PyPI视图中的`pip install`命令来安装它。必须注意的是，我们现在有一个依赖项。我们需要管理这些依赖项。我们将在下一步中介绍这一点。
- en: Managing dependencies
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: 'When it comes to dependencies, we must manage two types. For instance, our
    `twine` dependency helps us upload it onto PyPI. However, this is not needed for
    the `pip` package. Therefore, we need two different lists of dependencies – one
    for development and the other for actual use. We define the dependencies that
    we need for the development with the simple standard command stated here:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到依赖项时，我们必须管理两种类型。例如，我们的`twine`依赖项帮助我们将其上传到PyPI。然而，这对于`pip`包来说并不是必需的。因此，我们需要两个不同的依赖项列表——一个用于开发，另一个用于实际使用。我们使用这里所述的简单标准命令定义我们需要的开发依赖项：
- en: '[PRE112]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'What the `pip freeze` command gives us is a specific list of requirements that
    our current Python environment needs to install in order to run. `> requirements.txt`
    writes it to the `requirements.txt` file. If you are a new developer starting
    to develop our module, you can install all the requirements needed with the following
    command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip freeze`命令给我们的是一个特定需求列表，我们的当前Python环境需要安装这些需求才能运行。`> requirements.txt`将其写入`requirements.txt`文件。如果你是一个新开发者，刚开始开发我们的模块，你可以使用以下命令安装所有需要的依赖项：'
- en: '[PRE113]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We can be strict here because nothing is depending on the development requirements
    apart from the direct development of our module. However, when it comes to our
    module, we know that it will be installed into multiple systems with multiple
    requirements. Therefore, we want to allow some flexibility. For instance, if our
    module was going to write our Fibonacci numbers to `yml` and `pickle` files, then
    we will need to use the `pyYAML` and `dill` modules to enable us to write our
    Fibonacci numbers to `yml` and `pickle` files. To do this, we alter our `install_requires`
    parameter in our `setup` initialization in the `setup.py` file with the code here:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里很严格，因为除了直接开发我们的模块外，没有任何东西依赖于开发需求。然而，当涉及到我们的模块时，我们知道它将被安装到多个系统上，每个系统都有多个需求。因此，我们希望有一些灵活性。例如，如果我们的模块将要把斐波那契数写入`yml`和`pickle`文件，那么我们将需要使用`pyYAML`和`dill`模块来使我们能够将斐波那契数写入`yml`和`pickle`文件。为此，我们修改`setup.py`文件中`setup`初始化的`install_requires`参数，如下所示：
- en: '[PRE114]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'It must be noted that these are not the latest packages. We must drop a few
    versions and allow our dependency to be equal to or above that version. This gives
    our users freedom when using our pip package in their systems. We also must copy
    and paste these requirements into our `requirements.txt` file to ensure that our
    development is consistent with the user experience of our `pip` module. Let''s
    say that we are going to add an optional feature which is to start a small Flask
    server that locally serves an API that calculates Fibonacci numbers. Here, we
    can add an `install_requires` parameter in our `setup` initialization in the `setup.py`
    file with the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，这些并不是最新的包。我们必须放弃一些版本，并允许我们的依赖项等于或高于该版本。这给我们的用户在使用我们的pip包时提供了自由度。我们还必须将这些需求复制粘贴到我们的`requirements.txt`文件中，以确保我们的开发与我们的`pip`模块的用户体验保持一致。假设我们打算添加一个可选功能，即启动一个小型的Flask服务器，该服务器本地提供计算斐波那契数的API。在这里，我们可以在`setup.py`文件中的`setup`初始化中添加一个`install_requires`参数，如下所示：
- en: '[PRE118]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now, if we upload our new code to either PyPI or our personal GitHub repository,
    we will have a different experience when installing our package. If we normally
    install it, we will see that our `pickle` and `yml` requirements automatically
    install if we run the install command, as shown here:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们把我们的新代码上传到PyPI或我们的个人GitHub仓库，在安装我们的包时，我们会遇到不同的体验。如果我们正常安装它，我们会看到，当我们运行安装命令时，我们的`pickle`和`yml`需求会自动安装，如下所示：
- en: '[PRE121]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: It will actually install the server requirements. We can have as many requirements
    for the `server` profile as we want, and they will all be installed. Remember,
    our `extras_require` parameter is a dictionary, so we can define as many extra
    requirement profiles as we want. With this, we now have development requirements,
    essential `pip` module requirements, and optional `pip` module requirements. In
    the next step, we are now going to rely on a new development requirement to check
    types.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上会安装服务器需求。我们可以为 `server` 配置文件设置任意多的需求，并且它们都会被安装。记住，我们的 `extras_require` 参数是一个字典，因此我们可以定义任意多的额外需求配置文件。有了这个，我们现在有了开发需求、基本
    `pip` 模块需求和可选 `pip` 模块需求。在下一步中，我们现在将依赖于一个新的开发需求来检查类型。
- en: Setting up type checking for Python
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Python 设置类型检查
- en: 'At this point in the book, we have experienced the safety that Rust introduces.
    When types don''t match up, the Rust compiler refuses to compile. However, with
    Python, we do not get this, as Python is an interpreted language. However, we
    can mimic this using the `mypy` module. The steps are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这个阶段，我们已经体验到了 Rust 引入的安全性。当类型不匹配时，Rust 编译器拒绝编译。然而，在 Python 中，我们不会得到这个，因为
    Python 是一种解释型语言。然而，我们可以使用 `mypy` 模块来模拟这一点。步骤如下：
- en: 'First, we can install the `mypy` module with the following command:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以使用以下命令安装 `mypy` 模块：
- en: '[PRE122]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We can then type-check by using the `mypy` entry point with the code here:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `mypy` 入口点使用这里的代码进行类型检查：
- en: '[PRE123]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We can constrict the return value to just an integer with the `recurring_fibonacci_number`
    function:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `recurring_fibonacci_number` 函数将返回值限制为一个整数：
- en: '[PRE124]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Here, we can see that we raise an error if the input number is below zero. It's
    not going to calculate anyway, so we might as well throw an error informing the
    user that there is an error as opposed to silently producing a `None` value.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到如果输入数字小于零，我们会引发一个错误。无论如何它都不会计算，所以我们不妨抛出一个错误，通知用户存在错误，而不是默默地产生一个 `None`
    值。
- en: 'If we run our `mypy` check, we get the following console printout:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们运行 `mypy` 检查，我们会得到以下控制台输出：
- en: '[PRE125]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Here, we can see that all our files were checked and that they have type consistency.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到所有文件都已检查，并且它们具有类型一致性。
- en: However, we might forget to run this type of checking every time we upload new
    code to the GitHub repository. In the next section, we will define GitHub Actions
    to automate our checking.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能会忘记每次上传新代码到 GitHub 仓库时都运行这种检查。在下一节中，我们将定义 GitHub Actions来自动化我们的检查。
- en: Setting up and running tests and type-checking with GitHub Actions
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 设置和运行测试以及类型检查
- en: 'GitHub Actions run a series of computations that we can define in a `yml` file.
    We generally use GitHub Actions to automate processes that need to run every time.
    Workflow `yml` files are automatically detected by GitHub and run depending on
    what type of tags we give it. We can set up our GitHub Actions by following these
    steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 执行一系列我们可以在 `yml` 文件中定义的计算。我们通常使用 GitHub Actions来自动化每次都需要运行的过程。工作流程
    `yml` 文件会被 GitHub 自动检测并运行，具体取决于我们给它提供的标签。我们可以通过以下步骤设置我们的 GitHub Actions：
- en: 'For our tests and type-checking tags, we will define these in the `.github/workflows/run-tests.yml`
    file. In this file, we initially give a name for the workflow, and state that
    it fires when there is a push from one branch to another. This happens when a
    pull request is done as one branch is being pushed to another. This also reruns
    if we push more changes to our branch before merging the pull request. Our definitions
    are inserted at the top of the file with the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的测试和类型检查标签，我们将在 `.github/workflows/run-tests.yml` 文件中定义这些。在这个文件中，我们最初给出工作流程的名称，并声明它在从一个分支推送到另一个分支时触发。这发生在拉取请求完成时，一个分支被推送到另一个分支。如果我们合并拉取请求之前在我们的分支上推送更多更改，它也会重新运行。我们的定义以以下代码插入文件的顶部：
- en: '[PRE126]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Next, we must define our jobs. We also must state that our job is a `shell`
    command. We then define what the operating system is. Once we have done this,
    we define the steps of the job. In our `steps` section, we then define the `uses`,
    which we will state are `actions` with the following code:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义我们的作业。我们还必须声明我们的作业是一个 `shell` 命令。然后我们定义操作系统是什么。一旦我们完成这个，我们就定义作业的步骤。在我们的
    `steps` 部分，我们接着定义 `uses`，我们将声明它们是以下代码中的 `actions`：
- en: '[PRE127]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We are now ready to define the rest of the steps under the `steps` tag. These
    steps usually have a `name` and `run` tag. For us, we will be defining three steps:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备在 `steps` 标签下定义其余步骤。这些步骤通常有一个 `name` 和 `run` 标签。对我们来说，我们将定义三个步骤：
- en: The first one is to install the dependencies.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一项是安装依赖项。
- en: The second one is to run all the unit tests.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二项是运行所有单元测试。
- en: 'The third one is to run the type-checking with the code here:'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步是在这里运行类型检查：
- en: '[PRE128]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'First, we have to pull a new branch from our `main` branch with the following
    command:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须使用以下命令从我们的`main`分支拉取一个新的分支：
- en: '[PRE129]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'To just trigger a GitHub action with a pull request, we can simply scar our
    code with a comment in any file, such as the one here:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要仅通过拉取请求触发GitHub动作，我们可以在任何文件中添加一个注释来简单地标记我们的代码，例如这里：
- en: '[PRE130]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'You can write whatever, as it is just a comment if the code has changed. We
    then add and commit our changes to our **test** branch and push it to the GitHub
    repository. Once this is done, we can trigger a pull request by clicking on the
    **Pull requests** tab and selecting our **test** branch, as shown here:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果代码有变化，你可以写任何内容，因为这只是一个注释。然后我们添加并提交我们的更改到我们的**测试**分支，并将其推送到GitHub仓库。一旦完成，我们可以通过点击**拉取请求**标签并选择我们的**测试**分支来触发一个拉取请求，如图所示：
- en: '![Figure 4.6 – Setting up a GitHub pull request'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.6 – 设置GitHub拉取请求'
- en: '](img/Figure_4.06_B17720.jpg)'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.06_B17720.jpg)'
- en: Figure 4.6 – Setting up a GitHub pull request
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.6 – 设置GitHub拉取请求
- en: Once this is done, we can click on **Create pull request** to view it. Here,
    we will see all the GitHub Actions that get triggered and their status, as shown
    in the following figure:![Figure 4.7 – View of the GitHub Actions status of pull
    requests
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以点击**创建拉取请求**来查看它。在这里，我们将看到所有被触发的GitHub Actions及其状态，如图下所示：![图4.7 – 拉取请求的GitHub
    Actions状态视图
- en: '](img/Figure_4.07_B17720.jpg)'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.07_B17720.jpg)'
- en: Figure 4.7 – View of the GitHub Actions status of pull requests
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.7 – 拉取请求的GitHub Actions状态视图
- en: 'We can see that our tests have failed! If we click on **Details**, we can see
    that everything is working; it is just that we forgot to update our tests. If
    we remember, we changed our code to throw an error if we pass in a negative value
    into the Fibonacci calculation function, as shown next:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到我们的测试失败了！如果我们点击**详情**，我们可以看到一切都在正常工作；只是我们忘记更新我们的测试。如果我们记得，我们更改了我们的代码，在将负值传递给斐波那契计算函数时抛出错误，如下所示：
- en: '![Figure 4.8 – View of the GitHub Actions execution details'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.8 – GitHub Actions执行细节视图'
- en: '](img/Figure_4.08_B17720.jpg)'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.08_B17720.jpg)'
- en: Figure 4.8 – View of the GitHub Actions execution details
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.8 – GitHub Actions执行细节视图
- en: 'We can change the test code to assert that an error is raised by the testing
    code in the `tests/flitton_fib_py/fib_calcs/test_fib_number.py` file with the
    following code:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将测试代码更改为在`tests/flitton_fib_py/fib_calcs/test_fib_number.py`文件中的测试代码断言抛出一个错误，如下所示：
- en: '[PRE131]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Here, we can see that we assert that a value error is raised because we are
    running code that we expect to raise an error, and that the exception is what
    we expect of it. Pushing this to our GitHub repository will ensure that all the
    tests have passed. We can merge the pull request if we want the code to be merged
    into our `main` branch.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们断言抛出一个值错误，因为我们正在运行我们期望会抛出错误的代码，并且异常正是我们所期望的。将此推送到我们的GitHub仓库将确保所有测试都已通过。如果我们想将代码合并到我们的`main`分支，我们可以合并这个拉取请求。
- en: We have seen from this example that continuous integration is useful. It has
    picked up a change in the code that we might not have noted if we were doing everything
    manually.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以看到持续集成是有用的。它捕捉到了我们可能没有注意到的代码更改。
- en: Now that our tests run automatically, we need to automate keeping track of the
    version of our module to avoid making the same mistake we made with not updating
    our tests.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的测试是自动运行的，我们需要自动化跟踪我们模块的版本，以避免犯我们在没有更新测试时犯过的同样的错误。
- en: Create automatic versioning for our pip package
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的pip包创建自动版本控制
- en: 'To automate the process of updating the version number, we are going to put
    several functions in the `get_latest_version.py` file in the root of our `pip`
    module. Following are the steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化更新版本号的过程，我们打算在我们的`pip`模块根目录下的`get_latest_version.py`文件中放置几个函数。以下是步骤：
- en: 'First, we need to import everything we need with the following code:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要使用以下代码导入我们需要的所有内容：
- en: '[PRE132]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'To do this, we can create a function that will get the metadata of our module
    from PyPI and return the version with the following code:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以创建一个函数，该函数将从PyPI获取我们模块的元数据并返回以下代码中的版本：
- en: '[PRE133]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'This is just a simple web request. Once we have done this, we are going to
    want to unpack this string into a tuple of integers with the function defined
    next:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这只是一个简单的网络请求。一旦我们完成这个操作，我们就想使用定义的下一个函数将这个字符串解包成一个整数元组：
- en: '[PRE134]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Here, we can see that this is a simple split via bullet points. We then convert
    them to integers and pack them into a tuple to be returned.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这是一个简单的通过项目符号分割。然后，我们将它们转换为整数并将它们打包成一个元组以返回。
- en: 'Now that we have got our version number, we need to increase this by one with
    the function defined next:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了我们的版本号，我们需要使用定义的下一个函数将这个数字增加 `1`：
- en: '[PRE135]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Here, we can see that if one of the integers is equal or greater than `10`,
    we set it back to `0` and increase the next number by `1`. The only one that does
    not get sent to `0` is the furthest number to the left. This will just keep going
    up.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到如果其中一个整数等于或大于 `10`，我们就将其重置为 `0` 并将下一个数字增加 `1`。唯一不会重置为 `0` 的是最左边的数字。这将不断上升。
- en: 'Now that we have increased our number by `1`, we will need to pack the integer
    into a string, with the function defined next:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将数字增加了 `1`，我们需要使用定义的下一个函数将整数打包成一个字符串：
- en: '[PRE136]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Once we have packed this into a string, we will have to write the version to
    a file. This can be done with the function defined next:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们将这个数字打包成一个字符串，我们就必须将版本写入一个文件。这可以通过定义的下一个函数来完成：
- en: '[PRE137]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Here, we can see that we ensure that the path is going to be at the root of
    our module. We then delete the version file if it already exists, as it will already
    be out of date.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们确保路径将位于我们模块的根目录。然后，如果版本文件已经存在，我们就删除它，因为它已经过时了。
- en: 'We then write our updated version number to the file with the following code:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码将更新的版本号写入文件：
- en: '[PRE138]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This ensures that if we run the file directly, we will get the updated version
    written to a file.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确保了如果我们直接运行文件，我们将得到写入文件的更新版本。
- en: 'Now, in our `setup.py` file at the root of our module, we must read the version
    file and define it for our version parameter in the `setup` initialization. For
    that, we first import `pathlib` into our file and read the version file with this
    code:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的模块根目录的 `setup.py` 文件中，我们必须读取版本文件并将其定义为我们 `setup` 初始化中的版本参数。为此，我们首先将 `pathlib`
    导入到我们的文件中，并使用以下代码读取版本文件：
- en: '[PRE139]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'We then set the `version` parameter with the read value with the following
    code:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码使用读取的值设置 `version` 参数：
- en: '[PRE140]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: We now have our version update process fully automated; we must plug this into
    our GitHub Actions, so we automatically run the update process and push to PyPI
    when merging with our `main` branch.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全自动化了版本更新过程；我们必须将其连接到我们的 GitHub Actions，以便在合并到 `main` 分支时自动运行更新过程并推送到
    PyPI。
- en: Deploying onto PyPI using GitHub Actions
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 部署到 PyPI
- en: 'To enable our GitHub actions to push to PyPI, we need to follow these steps:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 GitHub Actions 能够推送到 PyPI，我们需要遵循以下步骤：
- en: First, we store the username and password for our PyPI account in the **Secrets**
    section of our GitHub repository. This can be done by clicking on the **Settings**
    tab and then the **Secrets** tab on the left sidebar, as shown here:![Figure 4.9
    – View of the GitHub Secrets section
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将我们的 PyPI 账户的用户名和密码存储在我们的 GitHub 仓库的 **Secrets** 部分中。这可以通过点击 **设置** 选项卡，然后点击左侧侧边栏上的
    **Secrets** 选项卡来完成，如图所示：![图 4.9 – GitHub Secrets 部分的视图
- en: '](img/Figure_4.09_B17720.jpg)'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.09_B17720.jpg)'
- en: Figure 4.9 – View of the GitHub Secrets section
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.9 – GitHub Secrets 部分的视图
- en: 'On the top right of the view in *Figure 4.9* is **New repository secret**.
    If we click this, we will get the following screen:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *图 4.9* 视图的右上角是 **新建仓库密钥**。如果我们点击这个，我们会得到以下屏幕：
- en: '![Figure 4.10 – View of the GitHub secret creation section'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – GitHub 密钥创建部分的视图'
- en: '](img/Figure_4.10_B17720.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B17720.jpg)'
- en: Figure 4.10 – View of the GitHub secret creation section
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – GitHub 密钥创建部分的视图
- en: Here, we can create a secret for our PyPI password and another secret for our
    PyPI username.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以为我们的 PyPI 密码创建一个密钥，并为我们的 PyPI 用户名创建另一个密钥。
- en: 'Now that we have our secrets defined, we can build our GitHub action in the
    `.github/workflows/publish-package.yml` file:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的密钥，我们可以在 `.github/workflows/publish-package.yml` 文件中构建我们的 GitHub
    Action：
- en: 'First, we need to ensure that we publish our package only when we have merged
    a branch with the `main` branch. To do this, we need to ensure that our action
    only executes when there''s a pull request when it''s closed, and the branch being
    pointed out is `main` with the following code:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要确保只有在我们将分支与 `main` 分支合并时才发布我们的包。为此，我们需要确保我们的操作只在关闭 pull request 时执行，并且指向的分支是
    `main`，以下代码为证：
- en: '[PRE141]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Once this is done, we can define the basic jobs of installing the dependencies
    and updating the package version with `jobs`, defined in the following code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以使用以下代码中的 `jobs` 定义基本任务，安装依赖项和更新包版本：
- en: '[PRE142]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: What we have done is fine so far. However, it will run when any pull request
    pointing to `main` is closed. Therefore, we must ensure that the pull request
    has merged before executing the step.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们所做的是好的。然而，它将在指向 `main` 的任何 pull request 被关闭时运行。因此，我们必须确保在执行此步骤之前，pull request
    已经合并。
- en: 'For the next section, we install the dependencies with the following code:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一部分，我们使用以下代码安装依赖项：
- en: '[PRE143]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'We can see that our conditional statements are straightforward. We then run
    the `setup.py` file for it to produce our distribution with the following step:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到我们的条件语句非常直接。然后我们运行 `setup.py` 文件，按照以下步骤生成我们的发行版：
- en: '[PRE144]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Now that we have defined all the steps needed to prepare our package, we can
    upload our package using `twine` with the following code:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了准备我们的包所需的所有步骤，我们可以使用以下代码使用 `twine` 上传我们的包：
- en: '[PRE145]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Here, we can see that we have automated the deployment of our module to PyPI
    using GitHub Actions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经使用 GitHub Actions 自动化了我们的模块部署到 PyPI。
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have managed to build a fully fledged `pip` Python module
    that has continuous integration. We initially set up a GitHub repository and created
    a virtual environment. This is an essential skill for most Python projects, and
    you should be using GitHub repositories and virtual environments even if your
    project is not a `pip` module. You will be able to share your project and work
    with other team members. We then defined our `setup.py` file so our code could
    be installed via `pip`. Even if our GitHub repository is private, people who have
    access to the GitHub repository could freely install our code. This gives us even
    more power when it comes to distributing our code.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经成功构建了一个具有持续集成的完整 `pip` Python 模块。我们最初设置了一个 GitHub 仓库并创建了一个虚拟环境。这对于大多数
    Python 项目来说是一个基本技能，即使你的项目不是一个 `pip` 模块，你也应该使用 GitHub 仓库和虚拟环境。你将能够分享你的项目并与团队成员一起工作。然后我们定义了我们的
    `setup.py` 文件，以便我们的代码可以通过 `pip` 安装。即使我们的 GitHub 仓库是私有的，任何有权访问 GitHub 仓库的人都可以自由安装我们的代码。这在我们分发代码时给了我们更多的权力。
- en: When we have an interface defined, our users do not need to know much about
    our code, just how to use the interface. This also enables us to prevent repeated
    code. For instance, if we build a user data model with a database driver, we can
    package it as a `pip` module and use this in multiple web applications. All we
    need to do is change the data model in the `pip` module and make a new release,
    and then all web applications can use the updated version if they wish.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义了一个接口时，我们的用户不需要了解太多关于我们的代码，只需知道如何使用这个接口。这也使我们能够防止代码重复。例如，如果我们使用数据库驱动程序构建一个用户数据模型，我们可以将其打包为一个
    `pip` 模块，并在多个网络应用程序中使用它。我们所需做的只是更改 `pip` 模块中的数据模型，并发布新版本，然后所有网络应用程序都可以在需要时使用更新后的版本。
- en: Once our code was packaged, we rebuilt our Fibonacci code in our `pip` module,
    and it worked. We then went further, building entry points that enabled us to
    define our own command-line tools. This makes our code packaging even more powerful,
    as the user doesn't even have to import and code the module; they can just call
    the command-line argument! With this, we can build development tools to speed
    up our development by automating tasks with these entry points. We then built
    basic unit tests to ensure that the quality of our code was maintained. We then
    locked in these good standards with automation pipelines using GitHub Actions.
    We introduced type-checking with `mypy` alongside our unit-testing pipeline. We
    don't have to stop here. For instance, the Python script that we coded that increased
    the version number by one could be built in its own `pip` repository with a command-line
    interface. With this, we could install the module using `pip install` in our GitHub
    Actions and run the commands. Now, with this code packaging, you can build your
    own tools and add them to your belt, reducing the amount of repetition in your
    daily coding as time goes on.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的代码被打包，我们在`pip`模块中重新构建了我们的斐波那契代码，并且它工作了。然后我们更进一步，构建了入口点，使我们能够定义自己的命令行工具。这使得我们的代码打包更加强大，因为用户甚至不需要导入和编写模块；他们可以直接调用命令行参数！有了这个，我们可以构建开发工具，通过自动化这些入口点来加快我们的开发速度。然后我们构建了基本的单元测试，以确保我们的代码质量得到保持。然后我们使用GitHub
    Actions的自动化管道将这些良好标准锁定。我们在单元测试管道中引入了`mypy`进行类型检查。我们不必就此停止。例如，我们编写的Python脚本，通过增加版本号来提升它，可以构建在自己的`pip`仓库中，并具有命令行界面。有了这个，我们可以在GitHub
    Actions中使用`pip install`来安装模块并运行命令。现在，有了这种代码打包，你可以构建自己的工具并将它们添加到你的工具箱中，随着时间的推移，减少你日常编码中的重复工作。
- en: In the next chapter, we cover what we have done in this chapter in Rust. Considering
    this, we harness the safety and speed of Rust, with the flexibility of `pip` packaging.
    Utilizing this will level up your skills as a Python toolmaker, making you invaluable
    to your team.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍在本章中我们使用Rust做了什么。考虑到这一点，我们利用Rust的安全性和速度，以及`pip`打包的灵活性。利用这一点将提升你作为Python工具制作者的技能，使你对你团队来说无价。
- en: Questions
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How would you perform an installation with `pip install` of our GitHub repository
    on the `test` branch?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会如何在`test`分支上使用`pip install`来安装我们的GitHub仓库？
- en: Can other developers who do not have access to your GitHub repository install
    your `pip` package if you upload it to PyPI?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将`pip`包上传到PyPI，其他没有访问您GitHub仓库的开发者能否安装您的`pip`包？
- en: What is the difference between development dependencies and package dependencies?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发依赖和包依赖之间有什么区别？
- en: '`mypy` ensures the consistency of types when it comes to our Python code. How
    is this different from type-checking in Rust?'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mypy`确保我们的Python代码在类型一致性方面的正确性。这与Rust中的类型检查有何不同？'
- en: Why should we automate boring repetitive tasks?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该自动化无聊的重复性任务？
- en: Answers
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '`pip install git+https://github.com/maxwellflitton/flitton-fib-py@test  `'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pip install git+https://github.com/maxwellflitton/flitton-fib-py@test  `'
- en: Yes, they can download it despite not having access to your GitHub repository.
    If we think about it, we package our `pip` module in a file and then upload it
    to the PyPI server. Downloading our package from the PyPI server is not connected
    to our GitHub repository.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，即使没有访问您的GitHub仓库，他们也可以下载它。如果我们这样考虑，我们把我们`pip`模块打包成一个文件，然后上传到PyPI服务器。从PyPI服务器下载我们的包与我们的GitHub仓库无关。
- en: Development dependencies are specific dependencies defined in the `requirements.txt`
    file. This ensures that developers can work on the `pip` package. Package requirements
    are a little more relaxed and defined in the `setup.py` file. These get installed
    when the user installs our package. Package requirements are to enable the `pip`
    package to be used.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发依赖是在`requirements.txt`文件中定义的特定依赖。这确保了开发者可以工作在`pip`包上。包需求稍微宽松一些，并在`setup.py`文件中定义。这些依赖会在用户安装我们的包时安装。包需求是为了使`pip`包能够被使用。
- en: Rust does the type-checking when it is compiling and fails to compile if the
    types are inconsistent. Because of this, we cannot run it. Python, however, is
    an interpreted language. Because of this, we can still run it with the potential
    errors.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rust在编译时会进行类型检查，如果类型不一致则无法编译。因此，我们无法运行它。然而，Python是一种解释型语言。因此，我们仍然可以运行它，尽管存在潜在的错误。
- en: Repetitive tasks are easy to automate, so the effort invested is not excessive.
    Also, repetitive tasks have a higher risk of producing errors. Automating these
    tasks reduces the number of errors we could make.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复性任务很容易自动化，因此投入的努力不会过多。此外，重复性任务产生错误的风险更高。自动化这些任务可以减少我们可能犯的错误数量。
- en: Further reading
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Python Organisation (2021) Packaging code*: [https://packaging.python.org/guides/distributing-packages-using-setuptools/](https://packaging.python.org/guides/distributing-packages-using-setuptools/)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 组织 (2021) 打包代码*: [https://packaging.python.org/guides/distributing-packages-using-setuptools/](https://packaging.python.org/guides/distributing-packages-using-setuptools/)'
- en: '*GitHub Organisation (2021) GitHub Actions*: [https://docs.github.com/en/actions](https://docs.github.com/en/actions)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GitHub 组织 (2021) GitHub Actions*: [https://docs.github.com/en/actions](https://docs.github.com/en/actions)'
