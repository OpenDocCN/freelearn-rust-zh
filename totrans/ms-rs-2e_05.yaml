- en: Memory Management and Safety
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理和安全
- en: Memory management is a fundamental concept to understand for anyone working
    with a low-level programming language. Low-level languages don't come with automatic
    memory reclamation solutions like a built-in garbage collector, and it's the responsibility
    of the programmer to manage memory that's used by the program. Having knowledge
    of where and how memory gets used in a program enables programmers to build efficient
    and safe software systems. A lot of bugs in low-level software are due to improper
    handling of memory. At times, it's the programmer's mistake. The other times,
    it's the side effect of the programming language used, such as C and C++, which
    are infamous for a lot of memory vulnerability reports in software. Rust offers
    a better, compile-time solution to memory management. It makes it hard to write
    software that leaks memory unless you explicitly intend to! Programmers who have
    done a fair amount of development with Rust eventually come to the realization
    that it discourages bad programming practices and directs the programmer toward
    writing software that uses memory safely and efficiently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何使用底层编程语言的人来说，理解内存管理是一个基本概念。底层语言没有内置的垃圾回收器等自动内存回收解决方案，管理程序使用的内存是程序员的职责。了解程序中内存的使用位置和方式，使程序员能够构建高效且安全的软件系统。许多底层软件中的错误都是由于不正确地处理内存造成的。有时，这是程序员的错误。其他时候，这是所使用的编程语言的副作用，例如C和C++，它们因软件中的许多内存漏洞报告而臭名昭著。Rust为内存管理提供了一个更好的编译时解决方案。除非你明确打算这样做，否则它很难编写会泄漏内存的软件！使用Rust进行了一定程度开发的程序员最终会意识到，它不鼓励不良编程实践，并指导程序员编写使用内存安全且高效的软件。
- en: In this chapter, we go into the nitty-gritty details of how Rust tames the memory
    that's used by resources in a program. We'll give a brief introduction to processes, memory
    allocation, memory management, and what we mean by memory safety. Then, we'll
    go through the memory safety model provided by Rust and understand the concepts
    that enable it to track memory usage at compile time. We'll see how traits are
    used to control where types reside in memory and when they get freed. We'll also
    delve into various smart pointer types that provide abstractions to manage resources
    in the program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解Rust如何驯服程序中资源使用的内存的细节。我们将简要介绍进程、内存分配、内存管理和我们所说的内存安全。然后，我们将了解Rust提供的内存安全模型，并理解使其能够在编译时跟踪内存使用量的概念。我们将看到如何使用特性来控制类型在内存中的位置以及它们何时被释放。我们还将深入研究各种智能指针类型，它们为管理程序中的资源提供了抽象。
- en: 'The topics that are covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Programs and memory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序和内存
- en: Memory allocations and safety
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分配和安全
- en: Memory management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理
- en: Stack and Heap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和堆
- en: Trifecta of safety—Ownership, borrowing, and lifetimes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全三合一——所有权、借用和生命周期
- en: Smart pointer types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能指针类型
- en: Programs and memory
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序和内存
- en: '"If you’re willing to restrict the flexibility of your approach, you can almost
    always do something better."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '"如果你愿意限制你方法的灵活性，你几乎总能做得更好。"'
- en: – *John Carmack*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: – *约翰·卡马克*
- en: As a motivation to understand memory and its management, it's important for
    us to have a general idea of how programs are run by the operating system and
    what mechanisms are in place that allow it to use memory for its requirements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解内存及其管理，我们需要对操作系统如何运行程序以及允许它为需求使用内存的机制有一个大致的了解。
- en: Every program needs memory to run, whether it's your favorite command-line tool
    or a complex stream processing service, and they have vastly different memory
    requirements. In major operating system implementations, a program in execution
    is implemented as a process. A process is a running instance of a program. When
    we execute `./my_program` in a shell in Linux or double-click on `my_program.exe`
    on Windows*,* the OS loads `my_program` as a process in memory and starts executing
    it, along with other processes, giving it a share of CPU and memory. It assigns
    the process with its own virtual address space, which is distinct from the virtual
    address space of other processes and has its own view of memory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序都需要内存来运行，无论是你喜欢的命令行工具还是复杂的流处理服务，它们的内存需求差异很大。在主要的操作系统实现中，正在执行的程序被实现为一个进程。进程是程序的运行实例。当我们Linux中的shell中执行`./my_program`或在Windows上双击`my_program.exe`时，操作系统将`my_program`作为进程加载到内存中并开始执行，与其他进程一起，给它分配CPU和内存的一部分。它为进程分配其自己的虚拟地址空间，这个地址空间与其他进程的虚拟地址空间不同，并且具有自己的内存视图。
- en: During the lifetime of a process, it uses many system resources. First, it needs
    memory to store its own instructions, then it needs space for resources that are
    demanded at runtime during instruction execution, then it needs a way to keep
    track of function calls, any local variables, and the address to return to after
    the last invoked function. Some of these memory requirements can be decided ahead
    at compile time, like storing a primitive type in a variable, while others can
    only be satisfied at runtime, like creating a dynamic data type such as `Vec<String>`.
    Due to the various tiers of memory requirements, and also for security purposes,
    a process's view of memory is divided into regions known as the memory layout.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程的生命周期中，它使用了大量的系统资源。首先，它需要内存来存储自己的指令，然后它需要空间来存储在指令执行期间运行时请求的资源，然后它需要一个方法来跟踪函数调用、任何局部变量以及返回到上一个调用函数的地址。其中一些内存需求可以在编译时提前决定，例如在变量中存储原始类型，而其他一些只能在运行时满足，例如创建动态数据类型如`Vec<String>`。由于内存需求的各个层级，以及出于安全考虑，进程对内存的视图被划分为称为内存布局的区域。
- en: 'Here, we have an approximate representation of the memory layout of a process
    in general:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个进程内存布局的大致表示：
- en: '![](img/3559bb5d-de6f-4448-8dd8-e2e9d4a4e2e7.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3559bb5d-de6f-4448-8dd8-e2e9d4a4e2e7.png)'
- en: 'This layout is divided into various regions based on the kind of data they
    store and the functionality they provide. The major parts we are concerned with
    are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局根据它们存储的数据类型和提供的功能被划分为不同的区域。我们关注的几个主要部分如下：
- en: '**Text segment**: This section contains the actual code to be executed in the
    compiled binary. The text segment is a read-only segment and any user code is
    forbidden to modify it. Doing so can result in a crash of the program.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本段**：这部分包含要执行的实际代码，在编译的二进制文件中。文本段是一个只读段，任何用户代码都禁止修改它。这样做可能会导致程序崩溃。'
- en: '**Data segment**: This is further divided into subsections, that is, the initialized
    data segment and uninitialized data segment, which is historically known as **Block
    Started by Symbol (BSS)**, and holds all global and static values declared in
    the program. Uninitialized values are initialized to zero when they are loaded
    into memory.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据段**：这部分进一步划分为子段，即初始化数据段和未初始化数据段，这在历史上被称为**块起始符号（BSS）**，它包含程序中声明的所有全局和静态值。未初始化的值在加载到内存时被初始化为零。'
- en: '**Stack segment**: This segment is used to hold any local variables and the
    return addresses of functions. All resources whose sizes are known in advance
    and any temporary/intermediary variables that a program creates are implicitly
    stored on the stack.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈段**：这个段用于存储任何局部变量和函数的返回地址。所有大小已知且程序创建的任何临时/中间变量都隐式地存储在栈上。'
- en: '**Heap segment**: This segment is used to store any dynamically allocated data
    whose size is not known up front and can change at runtime depending on the needs
    of the program. This is the ideal allocation place when we want values to outlive
    their declaration within a function.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆段**：这个段用于存储任何在运行时大小未知且可以变化的动态分配的数据。当我们希望值在函数声明之外持续存在时，这是理想的分配位置。'
- en: How do programs use memory?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序如何使用内存？
- en: So, we know that a process has a chunk of memory dedicated for its execution.
    But, how does it access this memory to perform its task? For security purposes
    and fault isolation, a process is not allowed to access the physical memory directly.
    Instead, it uses a virtual memory, which is mapped to the actual physical memory
    by the OS using an in-memory data structure called **pages**, which are maintained
    in **page tables**. The process has to request memory from the OS for its use,
    and what it gets is a virtual address that is internally mapped to a physical
    address in the RAM. For performance reasons, this memory is requested and processed
    in chunks. When virtual memory is accessed by the process, the memory management
    unit does the actual conversion from virtual to physical memory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道一个进程有一个专门用于其执行的内存块。但是，它是如何访问这个内存来执行其任务的呢？出于安全和故障隔离的目的，进程不允许直接访问物理内存。相反，它使用虚拟内存，该内存由操作系统通过一个称为
    **页** 的内存数据结构映射到实际的物理内存，这些 **页** 被维护在 **页表** 中。进程必须从操作系统请求内存以供其使用，它得到的是一个虚拟地址，该地址在内部映射到
    RAM 中的物理地址。出于性能考虑，内存是以块的形式请求和处理的。当进程访问虚拟内存时，内存管理单元执行从虚拟到物理内存的实际转换。
- en: The whole series of steps through which memory is acquired by a process from
    the OS is known as **memory allocation**. A process requests a chunk of memory
    from the OS by using *system calls*, and the OS marks that chunk of memory in
    use by that process. When the process is done using the memory, it has to mark
    the memory as free so other processes can use it. This is called **de-allocation**
    of memory. Major operating system implementations provide abstractions through
    system calls (such as `brk` and `sbrk` in Linux), which are functions that talk directly
    to the OS kernel and can allocate memory requested by the process. But these kernel-level
    functions are very low-level, so they are further abstracted by system libraries
    such as the **glibc** library, which is C's standard library in Linux including
    the implementation of the POSIX APIs, facilitating low-level interactions with
    the OS from the C language.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 进程从操作系统获取内存的整个过程被称为 **内存分配**。进程通过使用 *系统调用* 从操作系统请求一块内存，操作系统标记该内存块为该进程使用。当进程完成对内存的使用后，它必须将内存标记为空闲，以便其他进程可以使用。这被称为内存的
    **释放**。主要的操作系统实现通过系统调用（如 Linux 中的 `brk` 和 `sbrk`）提供抽象，这些是直接与操作系统内核通信的函数，可以分配进程请求的内存。但这些内核级函数非常低级，因此它们被系统库（如
    **glibc** 库）进一步抽象，该库是 Linux 中的 C 语言标准库，包括 POSIX API 的实现，它简化了从 C 语言进行低级操作系统交互。
- en: POSIX is an acronym for Portable Operating System Interface, a term coind by
    Richard Stallman. It is a set of standards that emerged with the need to standardize
    what functionality, a Unix-like operating system should provide, what low level
    APIs they should expose to languages such as C, what command-line utilities they
    should include, and many other aspects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 是 Portable Operating System Interface 的缩写，这是一个由理查德·斯托尔曼提出的术语。它是一组随着标准化
    Unix-like 操作系统应提供哪些功能、它们应向 C 等语言暴露哪些低级 API、它们应包含哪些命令行工具以及许多其他方面的需求而出现的标准。
- en: Glibc also provides a memory allocator API, exposing functions such as `malloc`,
    `calloc`, and `realloc` for allocating memory and the `free` function for de-allocating
    memory. Even though we have a fairly high-level API for allocating/de-allocating
    memory, we still have to manage memory ourselves when using low-level programming
    languages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Glibc 还提供了一组内存分配器 API，暴露了如 `malloc`、`calloc` 和 `realloc` 等用于分配内存的函数，以及 `free`
    函数用于释放内存。尽管我们有一个相当高级的内存分配/释放 API，但在使用低级编程语言时，我们仍然需要自己管理内存。
- en: Memory management and its kinds
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理及其种类
- en: The RAM in your computer is a limited resource and is shared by all running
    programs. It's a necessity that when a program is done executing its instructions,
    it is expected to release any memory used so that the OS can reclaim it and hand
    it to other processes. When we talk about memory management, a prominent aspect
    we care about is the reclamation of used memory and how that happens. The level
    of management required in deallocating used memory is different in different languages.
    Up until the mid-1990s, the majority of programming languages relied on manual
    memory management, which required the programmer to call memory allocator APIs
    such as `malloc` and `free` in code to allocate and deallocate memory, respectively.
    Around 1959, *John McCarthy*, the creator of *Lisp,* invented **Garbage Collectors**
    (**GC**), a form of automatic memory management and Lisp was the first language
    to use one. A GC runs as a daemon thread as part of the running program and analyzes
    the memory that is no longer being referenced by any variable in the program and
    frees it automatically at certain points in time along with program execution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您电脑中的RAM是一种有限的资源，并且被所有正在运行的应用程序共享。当程序完成执行其指令后，它应该释放任何使用的内存，以便操作系统可以回收并分配给其他进程。当我们谈论内存管理时，我们关注的突出方面之一是已使用内存的回收以及它是如何发生的。不同语言在释放已使用内存时所需的管理级别不同。直到1990年代中期，大多数编程语言都依赖于手动内存管理，这要求程序员在代码中调用内存分配器API，如`malloc`和`free`来分别分配和释放内存。大约在1959年，*约翰·麦卡锡*，*Lisp*的创造者，发明了**垃圾回收器**（**GC**），这是一种自动内存管理形式，而Lisp是第一个使用这种技术的语言。GC作为一个守护线程作为运行程序的一部分运行，并分析程序中不再被任何变量引用的内存，并在程序执行的一定时间点自动释放它。
- en: However, low-level languages don't come with a GC as it introduces non-determinism
    and a runtime overhead due to the GC thread running in the background, which in
    some cases pauses the execution of the program. This pause sometimes reaches to
    a milisecond of latency. This might violate the hard time and space constraints
    of system software. Low-level languages put the programmer in control of managing
    memory manually. However, languages such as C++ and Rust take some of this burden
    off from programmers, through type system abstractions like smart pointers, which
    we'll cover later in the chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，低级语言没有内置GC，因为它引入了非确定性以及由于GC线程在后台运行而产生的运行时开销，这有时会暂停程序的执行。这种暂停有时会达到毫秒级的延迟。这可能会违反系统软件的严格时间和空间限制。低级语言将程序员置于手动管理内存的控制之下。然而，像C++和Rust这样的语言通过类型系统抽象，如智能指针，从程序员那里分担了一些负担，我们将在本章后面讨论。
- en: 'Given the difference between languages, we can classify the memory management
    strategies that are used by them into three buckets:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到语言之间的差异，我们可以将这些语言使用的内存管理策略分为三个类别：
- en: '**Manual**: *C* has this form of memory management, where it''s completely
    the programmers responsibility to put `free` calls after the code is done using
    memory. C++ automates this to some extent using smart pointers where the `free`
    call is put in a class''s deconstructor method definition. Rust also has smart
    pointers, which we will cover later in this chapter.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动**：*C*具有这种形式的内存管理，其中程序员完全负责在代码使用内存后调用`free`。C++通过智能指针在一定程度上自动化了这一点，其中`free`调用被放置在类的析构函数方法定义中。Rust也有智能指针，我们将在本章后面讨论。'
- en: '**Automatic**: Languages with this form of memory management include an additional
    runtime thread,that is the Garbage Collector, that runs alongside the program
    as a daemon thread. Most dynamic languages based on a virtual machine such Python,
    Java, C# and Ruby rely on automatic memory management. Automatic memory management
    is one of the reasons that writing code in these languages is easy.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动**：具有这种形式内存管理的语言包括一个额外的运行时线程，即垃圾回收器，它作为守护线程与程序并行运行。大多数基于虚拟机的动态语言，如Python、Java、C#和Ruby，都依赖于自动内存管理。自动内存管理是这些语言编写代码容易的一个原因。'
- en: '**Semi-automatic**: Languages such as Swift fall into this category. They don''t
    have a dedicated GC built in as part of the runtime, but offer a reference counting
    type, which does automatic management of memory at a granular level. Rust also
    provides the reference counting types `Rc<T>` and `Arc<T>`. We''ll get to them
    when we explain about *smart pointers,* later in this chapter.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半自动**：像Swift这样的语言属于这一类别。它们作为运行时的一部分没有内置专门的GC，但提供了一种引用计数类型，可以在细粒度级别自动管理内存。Rust也提供了引用计数类型`Rc<T>`和`Arc<T>`。我们将在本章后面解释*智能指针*时详细介绍它们。'
- en: Approaches to memory allocation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分配方法
- en: At runtime, memory allocations in a process happens either on the *stack* or
    on the *heap*. They are storage locations that are used to store values during
    the execution of the program. In this section, we'll take a look at both of these
    allocation approaches.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，一个进程中的内存分配要么发生在*栈*上，要么发生在*堆*上。它们是程序执行期间用于存储值的存储位置。在本节中，我们将探讨这两种分配方法。
- en: The stack is used for short-lived values whose sizes are known as compile time,
    and is the ideal storage location for function calls and their associated context,
    which needs to go away once the function returns. The heap is for anything that
    needs to live beyond function calls. As mentioned in [Chapter 1](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml),
    *Getting Your Feet Wet*, Rust prefers stack allocation by default. Any value or
    instance of a type that you create and bind to a variable gets stored on the stack
    by default. Storing on the heap is explicit and is done by using smart pointer
    types, which are explained later in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 栈用于存储生命周期短暂的值，其大小在编译时已知，是函数调用及其相关上下文的理想存储位置，一旦函数返回，这些上下文就需要消失。堆用于任何需要在函数调用之外持续存在的对象。如[第1章](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml)“入门指南”中所述，Rust默认偏好栈分配。你创建并绑定到变量的任何值或类型的实例默认存储在栈上。在堆上存储是显式的，并且通过使用智能指针类型来完成，这些类型将在本章后面进行解释。
- en: The stack
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: Any time we call a function or a method, the stack is used for allocating space
    for values that are created within the function. All of the `let` bindings in
    your functions are stored in the stack, either as values themselves or as pointers
    to memory locations on the heap. These values constitute the **stack frame** for
    the active function. A stack frame is a logical block of memory in the stack that
    stores the context of a function call. This context may include function arguments,
    local variables, return addresses, and any saved register's values that need to
    be restored after returning from the function. As more and more functions get
    called, their corresponding stack frames are pushed onto the stack. Once a function
    returns, the stack frame corresponding to the function goes away, along with all
    values declared within that frame.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们调用一个函数或方法时，栈被用来为在函数内部创建的值分配空间。你函数中的所有`let`绑定都存储在栈上，要么作为值本身，要么作为指向堆上内存位置的指针。这些值构成了活动函数的**栈帧**。栈帧是栈中存储函数调用上下文的逻辑内存块。这个上下文可能包括函数参数、局部变量、返回地址以及需要在函数返回后恢复的任何已保存寄存器的值。随着越来越多的函数被调用，它们对应的栈帧被推入栈中。一旦函数返回，与该函数对应的栈帧就会消失，以及在该帧中声明的所有值。
- en: These values are removed in the reverse order of their declaration, following
    the **Last In First Out** (**LIFO**) order.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值按照它们声明的相反顺序被移除，遵循**后进先出**（**LIFO**）的顺序。
- en: 'Allocation on the stack is fast because allocating and deallocating memory
    here requires just one CPU instruction: incrementing/decrementing the stack frame
    pointer. The stack frame pointer (`esp`) is a CPU register that always points
    to the top of the stack. The stack frame pointer keeps on updating as functions
    get called, or when they return. When a function returns, its stack frame is discarded
    by restoring the stack frame pointer to where it was before entering the function.
    Using stacks is a temporary memory allocation strategy, but it is reliable in
    terms of releasing used memory because of its simplicity. However, the same property
    of a stack makes it unsuitable for cases where we need longer living values beyond
    the current stack frame.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈上进行分配很快，因为在这里分配和释放内存只需要一个CPU指令：增加/减少栈帧指针。栈帧指针（`esp`）是一个CPU寄存器，它始终指向栈顶。随着函数的调用或返回，栈帧指针会不断更新。当函数返回时，通过将栈帧指针恢复到进入函数之前的位置，其栈帧被丢弃。使用栈是一种临时内存分配策略，但由于其简单性，它在释放已用内存方面是可靠的。然而，栈的同一属性使其不适合需要超出当前栈帧的持久值的场景。
- en: 'Here''s a piece of code to roughly illustrate how the stack gets updated in
    a program during function calls:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一段代码，大致展示了在程序中函数调用期间栈是如何更新的：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll represent the state of the stack for this program by an empty array
    `[]`. Let''s explore the stack contents by doing a dry run of this program. We''ll
    use `[]` to also represent stack frames within our parent stack. When this program
    is run, the following are the sequence of steps that happens:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个空数组`[]`来表示这个程序的栈状态。让我们通过对这个程序进行一次模拟运行来探索栈的内容。我们还将使用`[]`来表示父栈中的栈帧。当程序运行时，以下步骤将按顺序发生：
- en: When the `main` function is invoked, it creates the stack frame, which holds
    `a`  and `result` (initialized to zero). The stack is now `[[a=12, result=0]]`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`main`函数被调用时，它创建了一个栈帧，其中包含`a`和`result`（初始化为零）。此时栈的内容为`[[a=12, result=0]]`。
- en: Next, the `double_of` function is called and a new stack frame is push onto
    the stack to hold its local values. The stack's contents is now `[[a=12, result=0],
    [b=12, temp_double=2*x, x=0]]`. `temp_double` is a temporary variable that's created
    by the compiler to store the result of `2 * x`, which is then assigned to the `x`
    that's variable declared within the `double_of` function. This `x` is then returned
    to the caller, which is our `main` function.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调用`double_of`函数，并在栈上推入一个新的栈帧以保存其局部值。此时栈的内容为`[[a=12, result=0], [b=12, temp_double=2*x,
    x=0]]`。`temp_double`是一个由编译器创建的临时变量，用于存储`2 * x`的结果，然后将其分配给在`double_of`函数中声明的变量`x`。然后这个`x`被返回给调用者，即我们的`main`函数。
- en: Once `double_of` returns, its stack frame is popped off the stack and the stack
    contents are now `[[a=12, result=24]`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`double_of`函数返回，它的栈帧将从栈中弹出，此时栈的内容变为`[[a=12, result=24]]`。
- en: 'Following that, `main` ends and its stack frame is popped out, leaving the
    stack empty: `[]`.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，`main`函数结束，其栈帧被弹出，栈变为空：`[]`。
- en: There are more details to this, though. We just gave a very high level overview
    of a function call and its interaction with the stack memory. Now, if all we had
    were local values staying valid only for the lifetime of the function call, it
    would be very limiting. While the stack is simple and powerful, to be practical,
    a program also needs longer-living variables, and for that we need the heap.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里还有更多细节。我们只是提供了一个关于函数调用及其与栈内存交互的非常高级的概述。现在，如果我们只有局部值，它们只在函数调用期间有效，这将非常有限。虽然栈简单且强大，但要实用，程序还需要更持久的变量，而这正是堆的作用。
- en: The heap
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: The heap is for the more complicated and dynamic memory allocation requirements.
    A program might allocate on the heap at some point and may release it at some
    other point, and there need not be a strict boundary between these points, as
    is the case with stack memory. In the case of stack allocation, you get deterministic
    allocation and deallocation of values. Also, a value in the heap may live beyond
    the function where it was allocated and it may later get deallocated by some other
    function. In that case, the code fails to call `free`, so it may not get deallocated
    at all, which is the worst case.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 堆用于更复杂和动态的内存分配需求。程序可能在某个时刻在堆上分配内存，也可能在另一个时刻释放它，这些点之间不需要有严格的界限，就像栈内存那样。在栈分配的情况下，你将得到值的确定性的分配和释放。此外，堆中的值可能在其分配的函数之外存活，并且可能稍后被其他函数释放。在这种情况下，代码未能调用`free`，因此它可能根本不会被释放，这是最坏的情况。
- en: Different languages use the heap memory differently. In dynamic languages such
    as Python*,* everything is an object and they are allocated on the heap by default.
    In C, we allocate memory on the heap using manual `malloc` calls, while in C++,
    we allocate using the `new` keyword. To deallocate memory, we need to call free
    in C and delete in C++. In C++, to avoid manual `delete` calls, programmers often
    use smart pointer types such as `unique_ptr` or `shared_ptr`. These smart pointer
    types have deconstructor methods, which get invoked when they go out of scope
    internally, calling `delete`. This paradigm of managing memory is called the RAII
    principle, and was popularized by C++.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言以不同的方式使用堆内存。在动态语言如Python*中，一切都是对象，并且默认情况下它们在堆上分配。在C中，我们使用手动`malloc`调用在堆上分配内存，而在C++中，我们使用`new`关键字进行分配。为了释放内存，我们需要在C中调用`free`，在C++中调用`delete`。为了避免手动`delete`调用，程序员通常使用`unique_ptr`或`shared_ptr`等智能指针类型。这些智能指针类型有析构函数，当它们在内部超出作用域时会被调用，并执行`delete`。这种管理内存的范式称为RAII原则，并由C++普及。
- en: RAII stands for Resource Acquisition Is Initialization; a paradigm suggesting
    that resources must be acquired during initialization of objects and must be released
    when they are deallocated or their destructors are called.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RAII代表资源获取即初始化；一种建议资源必须在对象的初始化期间获取，并在它们被释放或调用析构函数时释放的范式。
- en: Rust also has similar abstractions to how C++ manages heap memory. Here, the
    only way to allocate memory on the heap is through smart pointer types. Smart
    pointer types in Rust implement the `Drop` trait, which specifies how memory used
    by the value should be deallocated, and are semantically similar to deconstructor
    methods in C++. Unless someone writes their own custom smart pointer type, you
    never need to implement `Drop` on their types. More on the `Drop` trait in a separate
    section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Rust也有类似于C++管理堆内存的抽象。在这里，在堆上分配内存的唯一方式是通过智能指针类型。Rust中的智能指针类型实现了`Drop`特质，它指定了值使用的内存应该如何被释放，并且在语义上与C++中的析构函数类似。除非有人编写了自己的自定义智能指针类型，否则您永远不需要在它们的类型上实现`Drop`。关于`Drop`特质的更多内容将在单独的部分中介绍。
- en: To allocate memory on the heap, languages rely on dedicated memory allocators,
    which hide all the low-level details like allocating memory on aligned memory,
    maintaining free chunks of memory to reduce system call overheads, and reducing
    fragmentation while allocating memory and other optimizations. For compiling programs,
    the compiler rustc itself uses the jemalloc allocator, whereas the libraries and
    binaries that are built from Rust use the system allocator. On Linux, it would
    be the glibc memory allocator APIs. Jemalloc is an efficient allocator library
    for use in multithreaded environments and it greatly reduces the build time of
    Rust programs. While jemalloc is used by the compiler, it's not used by any applications
    that are built with Rust because it increases the size of the binary. So, compiled
    binaries and libraries always use the system allocators by default.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在堆上分配内存，语言依赖于专门的内存分配器，这些分配器隐藏了所有底层细节，如在对齐内存上分配内存、维护空闲内存块以减少系统调用开销、以及在分配内存和其他优化时减少碎片化。对于编译程序，编译器rustc本身使用jemalloc分配器，而由Rust构建的库和二进制文件使用系统分配器。在Linux上，将是glibc内存分配器API。jemalloc是一个用于多线程环境的有效分配器库，它大大减少了Rust程序的构建时间。虽然编译器使用了jemalloc，但它不会被用Rust构建的应用程序使用，因为它会增加二进制文件的大小。因此，编译的二进制文件和库默认总是使用系统分配器。
- en: Rust also has a pluggable allocator design, and can use the system allocator
    or any user implemented allocator that implements the `GlobalAlloc` trait from
    the `std::alloc` module. This is often implemented by the `#[global_allocator]`
    attribute, which can be put on any type to declare it as an allocator.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Rust还有一个可插拔的分配器设计，可以使用系统分配器或任何实现了`std::alloc`模块中的`GlobalAlloc`特质的用户实现分配器。这通常通过`#[global_allocator]`属性实现，可以将它放在任何类型上以声明它为一个分配器。
- en: '**Note**: If you have a use case where you want to use the jemalloc crate for
    your programs too, you can use the [https://crates.io/crates/jemallocator](https://crates.io/crates/jemallocator)
    crate.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：如果您有一个用例希望在自己的程序中使用jemalloc crate，您可以使用[https://crates.io/crates/jemallocator](https://crates.io/crates/jemallocator)
    crate。'
- en: 'In Rust, most dynamic types with sizes not known in advance are allocated on
    the heap. This excludes primitive types. For instance, creating a `String` internally
    allocates on the heap:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，大多数大小事先未知的动态类型都在堆上分配。这排除了原始类型。例如，创建`String`内部会在堆上分配：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`String::new` allocates a `Vec<u8>` on the heap and returns a reference to
    it. This reference is bound to the variable `s`, which is allocated on the stack.
    The string in the heap lives for as long as `s` is in scope. When `s` goes out
    of scope, the `Vec<u8>` is deallocated from the heap and its `drop` method is
    called as part of the `Drop` implementation. For rare cases where you need to
    allocate a primitive type on the heap, you can use the `Box<T>` type, which is
    a generic smart pointer type.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`String::new`在堆上分配一个`Vec<u8>`并返回对其的引用。这个引用绑定到变量`s`上，该变量在栈上分配。堆中的字符串在`s`的作用域内存在。当`s`超出作用域时，`Vec<u8>`从堆上解除分配，并且其`drop`方法作为`Drop`实现的一部分被调用。对于需要将原始类型分配到堆上的罕见情况，你可以使用`Box<T>`类型，它是一种泛型智能指针类型。'
- en: In the next section, let's look at the pitfalls when using a language such as
    C that doesn't have all the comforts of automatic memory management.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看使用像C这样的没有自动内存管理舒适性的语言时的陷阱。
- en: Memory management pitfalls
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理陷阱
- en: In languages with a GC, dealing with memory is abstracted away from the programmer.
    You declare and use the variables in your code, and how they get deallocated is
    an implementation detail you don't have to worry about. A low-level system programming
    language such as C/C++, on the other hand, does nothing to hide these details
    from the programmer, and provides nearly no safety. Here, programmers are given
    the responsibility of deallocating memory via manual free calls. Now, if we look
    at the majority of  **Common Vulnerabilities & Exposure** (**CVEs**) in software
    related to memory management, it shows that we humans are not very good at this!
    Programmers can easily create hard-to-debug errors by allocating and deallocating
    values in the wrong order, or may even forget to deallocate used memory, or cast
    pointers illegally. In C, nothing stops you from creating a pointer out of an
    integer and dereferencing it somewhere, only to see the program crash later. Also,
    it's quite easy to create vulnerabilities in C because of the minimal compiler
    checks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有GC（垃圾回收）的语言中，处理内存的问题从程序员那里抽象出来。你在代码中声明和使用变量，它们如何被解除分配是实现的细节，你不必担心。另一方面，像C/C++这样的低级系统编程语言并没有从程序员那里隐藏这些细节，并且提供了几乎没有任何安全性。在这里，程序员被赋予了通过手动释放调用解除内存的责任。现在，如果我们看看与内存管理相关的软件中的大多数**通用漏洞和暴露**（**CVEs**），它表明我们人类在这方面并不擅长！程序员可以通过错误地分配和解除分配值来创建难以调试的错误，甚至可能忘记解除分配已使用的内存，或者非法地取消引用指针。在C中，没有任何东西阻止你从一个整数创建一个指针并在某个地方取消引用它，结果只是程序稍后崩溃。此外，由于编译器的检查最少，很容易在C中创建漏洞。
- en: The most concerning case is freeing heap allocated data. The heap memory is
    to be used with care. Values in the heap can possibly live forever during the
    lifetime of the program if not freed, and may eventually lead to the program being
    killed by the **Out Of Memory** (**OOM**) killer in the kernel. At runtime, a
    bug in the code or mistake from the developer can also cause the program to either
    forget to free the memory, or access a portion of memory that is outside the bounds
    of its memory layout, or dereference a memory address in the protected code segment.
    When this happens, the process receives a trap instruction from the kernel, which
    is what you see as a `segmentation fault` error message, followed by the process
    getting aborted. As such, we must ensure that processes and their interactions
    with memory need to be safe! Either we as programmers need to be critically aware
    of our `malloc` and `free` calls, or use a memory safe language to handle these
    details for us.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人担忧的情况是释放堆分配的数据。堆内存需要谨慎使用。如果未释放，堆中的值在程序的生命周期内可能会永远存在，并最终可能导致内核中的“内存不足”（**OOM**）杀手终止程序。在运行时，代码中的错误或开发者的错误也可能导致程序忘记释放内存，或者访问超出其内存布局范围的内存部分，或者在受保护代码段中取消引用内存地址。当这种情况发生时，进程会从内核接收到陷阱指令，这就是你看到的“段错误”错误消息，随后进程被终止。因此，我们必须确保进程及其与内存的交互需要是安全的！要么我们作为程序员需要对我们自己的`malloc`和`free`调用保持批判性的警觉，要么使用内存安全的语言来为我们处理这些细节。
- en: Memory safety
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存安全
- en: But what do we mean by a program being memory safe? Memory safety is the idea
    that your program never touches a memory location it is not supposed to, and that
    the variables declared in your program cannot point to invalid memory and remain
    valid in all code paths. In other words, safety basically boils down to pointers
    having valid references all of the time in your program, and that the operations
    with pointers do not lead to undefined behavior. Undefined behavior is the state
    of a program where it has entered a situation that has not been accounted for
    in the compiler's because the compiler specification does not clarify what happens
    in that situation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们所说的程序内存安全是什么意思呢？内存安全是这样一个概念：您的程序永远不会触及它不应该触及的内存位置，并且您的程序中声明的变量不能指向无效的内存，并且在所有代码路径中保持有效。换句话说，安全性基本上归结为在您的程序中指针始终具有有效的引用，并且指针操作不会导致未定义行为。未定义行为是程序进入了一种编译器没有考虑到的情况，因为编译器规范没有明确说明这种情况会发生什么。
- en: 'An example of undefined behavior in C is accessing out of bound and uninitialized
    array elements:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: C 中未定义行为的一个例子是访问越界和未初始化的数组元素：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we have an array of 5 elements and we loop and print
    the values in the array. Running this program with `gcc -o main uninitialized_reads.c
    && ./main` gives me the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们有一个包含 5 个元素的数组，并循环打印数组中的值。使用 `gcc -o main uninitialized_reads.c &&
    ./main` 运行此程序会得到以下输出：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On your machine, this could print any value, or might even print an address
    of an instruction, which can be exploited. This is an undefined behavior where
    anything can happen. Your program might crash immediately, which is the best case
    scenario as you get to know it then and there. It may also continue to work, clobbering
    any internal state of the program that might later give faulty outputs from the
    application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上，这可能会打印任何值，甚至可能打印一个指令的地址，这可以被利用。这是一个未定义行为，其中可能发生任何事情。您的程序可能会立即崩溃，这是最好的情况，因为您当时就能知道它。它也可能继续工作，破坏程序可能后来会给出错误输出的任何内部状态。
- en: 'Another example of memory safety violation is the iterator invalidation problem
    in C++:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中内存安全违规的另一个例子是迭代器失效问题：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this C++ code, we create a vector of integers `v` and we are trying to iterate
    using an iterator called  `it` in the `for` loop. The problem with the preceding
    code, is that we have an `it` iterator pointer to `v`, while at the same time
    we iterate and push to `v`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段 C++ 代码中，我们创建了一个整数向量 `v`，并尝试在 `for` 循环中使用一个名为 `it` 的迭代器进行迭代。前述代码的问题在于，我们有一个指向
    `v` 的 `it` 迭代器指针，同时我们在迭代并推入 `v`。
- en: Now, because of the way vectors are implemented, they internally reallocate
    to some other place in memory if their size reaches their capacity. When this
    happens, this would render the `it` pointer pointing to some garbage value, which
    is called the iterator invalidation problem, because the pointer is now pointing
    to invalid memory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于向量的实现方式，当它们的容量达到其容量时，它们会在内存中重新分配到其他位置。当这种情况发生时，这将使 `it` 指针指向某个垃圾值，这被称为迭代器失效问题，因为指针现在指向了无效的内存。
- en: 'Another example of memory unsafety are buffer overflows in C. The following
    is a simple piece of code to demonstrate this idea:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C 中内存不安全的另一个例子是缓冲区溢出。以下是一个简单的代码片段来展示这个概念：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This compiles fine and even runs without errors, but the last assignment went
    over the allocated buffer and might have overwritten other data or instructions
    in the address. Also, specially crafted malicious input values, adapted to the
    architecture and environment, could yield arbitrary code execution. These kind
    of errors have happened in actual code in less obvious ways and has led to vulnerabilities
    affecting businesses worldwide. On recent versions of gcc compilers, this is detected
    as a stack smash attack where gcc halts the program by sending a `SIGABRT` (abort)
    signal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以正常编译，甚至在没有错误的情况下运行，但最后的赋值操作超出了分配的缓冲区，可能覆盖了地址中的其他数据或指令。此外，专门定制的恶意输入值，适应于架构和环境，可能导致任意代码执行。这类错误在实际代码中以不那么明显的方式发生，导致了影响全球企业的漏洞。在最近的
    gcc 编译器版本中，这被检测为堆栈破坏攻击，gcc 通过发送 `SIGABRT`（中止）信号来停止程序。
- en: Memory safety bugs lead to memory leaks, hard crashes in the form of segmentation
    faults, or in the worst case, security vulnerabilities. To create correct and
    safe programs in C, a programmer has to be discrete in correctly placing `free`
    calls when they are done using the memory. Modern C++ safeguards against some
    of the problems associated with manual memory management by providing smart pointer
    types, but this does not completely eliminate them. Languages based on virtual
    machines (Java's JVM being the most prominent example) use garbage collection
    to eliminate whole classes of memory safety issues. While Rust doesn't have a
    built-in GC, it relies on the same RAII built into the language and makes freeing
    used memory automatic for us based on the scope of variables and is much more
    safer than C or C++. It provides us with several fine-grained abstractions that
    you can choose according to your needs and pay only for what you use. To see how
    all of this works in Rust, let's explore the principles that helps Rust provide
    compile-time memory management to programmers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 内存安全漏洞会导致内存泄漏、以段错误形式出现的硬崩溃，或者在最坏的情况下，安全漏洞。为了在C语言中创建正确且安全的程序，程序员必须谨慎地放置`free`调用，以确保在完成内存使用后正确释放内存。现代C++通过提供智能指针类型来防止与手动内存管理相关的一些问题，但这并不能完全消除这些问题。基于虚拟机的语言（Java的JVM是最突出的例子）使用垃圾回收来消除整个类别的内存安全问题。虽然Rust没有内置的GC，但它依赖于语言内建的RAII（Resource
    Acquisition Is Initialization）机制，根据变量的作用域自动释放使用过的内存，这使得它比C或C++更安全。它为我们提供了多种细粒度的抽象，我们可以根据需要选择，并且只为我们使用的部分付费。要了解Rust中这一切是如何工作的，让我们探索帮助Rust在编译时为程序员提供内存管理的原则。
- en: Trifecta of memory safety
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存安全的三角
- en: The concepts that we will explore next are the core tenets of Rust's memory
    safety and its zero cost abstraction principle. They enable Rust to detect memory
    safety violations in a program at compile time, provide automatic freeing of resources
    when their scope ends, and much more. We call these concepts ownership, borrowing,
    and lifetimes. Ownership is kind of like the core principle, while borrowing and
    lifetimes are type system extensions to the language, enforcing and sometimes
    relaxing the ownership principle in different contexts in code to ensure compile-time
    memory management. Let's elaborate on these ideas.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要探讨的概念是Rust内存安全的核心原则及其零成本抽象原则。它们使Rust能够在编译时检测程序中的内存安全违规，在资源作用域结束时自动释放资源，以及更多。我们把这些概念称为所有权、借用和生命周期。所有权有点像核心原则，而借用和生命周期是语言类型系统的扩展，在不同的代码上下文中强制执行和有时放宽所有权原则，以确保编译时内存管理。让我们详细阐述这些想法。
- en: Ownership
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权
- en: The notion of a true owner of a resource in a program differs across languages.
    Here, by resource, we collectively refer to any variable holding a value on the
    heap or the stack, or a variable holding an open file descriptor, a database connection
    socket, a network socket, and similar things. All of them occupy some memory from
    the time they exist until the time they are done being used by the program. An
    important responsibility of being the owner of a resource is to judiciously free
    the memory used by them, as not being able to perform deallocations at proper
    places and times can lead to memory leaks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中资源真正所有者的概念在不同的语言中有所不同。在这里，我们集体指代任何在堆或栈上持有值的变量，或者持有打开的文件描述符、数据库连接套接字、网络套接字等类似事物的变量。从它们存在到程序完成使用，它们都占用一些内存。作为资源所有者的重要责任之一是，要明智地释放它们使用的内存，因为不能在适当的位置和时间执行清理操作可能会导致内存泄漏。
- en: When programming in dynamic languages such as Python, it's fine to have multiple
    owners or aliases to a `list` object where you can add to or remove items from
    the list using one of the many variables pointing to the object. The variables
    don't need to care about freeing the memory used by the object because the GC
    takes care of this and will free the memory once all references to the object
    are gone.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Python等动态语言中编程时，对于`list`对象可以有多个所有者或别名，你可以使用指向该对象的许多变量之一向列表中添加或删除项目。变量不需要关心释放对象使用的内存，因为GC会处理这个问题，一旦所有对对象的引用都消失了，它就会释放内存。
- en: For compiled languages such as C/C++, before smart pointers were a thing, libraries
    had an opinionated take on whether the callee or the caller of an API was responsible
    for deallocating the memory after the code is done with a resource. These opinions
    existed because ownership is not enforced by the compiler in these languages.
    There's still a possibility of goofing up by not using smart pointers in C++.
    It's totally fine in C++ to have more than one variable pointing to a value on
    the heap (though we advise against it), and that is called *aliasing*. The programmer
    runs into all sorts of ill effects with the flexibility of having multiple pointers
    or aliases to a resource, one being the iterator invalidation problem in C++,
    which we explained previously. Specifically, problems arise when there is at least
    one mutable alias to a resource among other immutable aliases in a given scope.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像C/C++这样的编译型语言，在智能指针出现之前，库对API的调用者或被调用者负责在代码完成后释放资源持有不同的观点。这些观点存在是因为在这些语言中，编译器不强制执行所有权。在C++中，仍然有可能因为不使用智能指针而出错。在C++中，有多个变量指向堆上的值是完全正常的（尽管我们建议不要这样做），这被称为*别名*。程序员会遇到各种不良影响，因为拥有多个指向资源的指针或别名的灵活性，其中一个就是C++中的迭代器失效问题，我们之前已经解释过。具体来说，当给定作用域中至少有一个可变别名指向资源，而其他别名是不可变时，就会产生问题。
- en: 'Rust, on the other hand, tries to bring proper semantics regarding the ownership
    of values in a program. The ownership rule of Rust states the following principles:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Rust试图在程序中引入关于值所有权的适当语义。Rust的所有权规则声明以下原则：
- en: When you create a value or a resource using the `let` statement and assign it
    to a variable, the variable becomes the owner of the resource
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用`let`语句创建一个值或资源并将其分配给一个变量时，该变量成为资源的所有者
- en: When the value is reassigned from one variable to another, the ownership of
    the value moves to the other variable and the older variable becomes invalid for
    further use
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当值从一个变量重新分配到另一个变量时，值的所有权转移到另一个变量，而旧的变量将无法进一步使用
- en: The value and the variable are deallocated at the end of their scope
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值和变量在其作用域结束时会被释放
- en: 'The takeaway is that values in Rust have a single owner, that is, the variables
    that created them. The principle is quite simple, but the implications of it are
    what surprises programmers coming from other languages. Consider the following
    code, which demonstrates the ownership principle in its most basic form:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要点在于Rust中的值只有一个所有者，即创建它们的变量。这个原则很简单，但其影响却让来自其他语言的程序员感到惊讶。考虑以下代码，它以最基本的形式展示了所有权原则：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We create two variables, `foo` and `bar`, that points to a `Foo` instance.
    As someone familiar with mainstream imperative languages that allow multiple owners
    to a value, we expect this program to compile just fine. But in Rust, we get the
    following error upon compilation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个变量，`foo`和`bar`，它们指向一个`Foo`实例。对于熟悉主流命令式语言且允许值有多个所有者的程序员来说，我们预期这个程序可以顺利编译。但在Rust中，我们在编译时遇到了以下错误：
- en: '![](img/8bc1cf49-e912-4ef6-b405-b0c62ce4b96c.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8bc1cf49-e912-4ef6-b405-b0c62ce4b96c.png)'
- en: Here, we created a `Foo` instance and assigned it to the `foo` variable. According
    to the ownership rule, `foo` is now the owner of the `Foo` instance. In the next
    line, we then assign `foo` to `bar`. On executing the second line in `main`, 
    `bar` becomes the new owner of the `Foo` instance and the older `foo` is now an
    abandoned variable, which cannot be used anywhere after the move. This is evident
    from the `println!` call on the third line. Rust moves values pointed to by a
    variable by default any time we assign it to some other variable or read from
    the variable. The ownership rule prevents you from having multiple points of access
    for modifying the value, which can lead to use after free situations, even in
    single threaded contexts with languages that permit multiple mutable aliases for
    values. The classic example is the iterator invalidation problem in C++. Now,
    to analyze when a value goes out of scope, the ownership rule also takes into
    account the scope of variables. Let's understand scopes next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `Foo` 实例并将其分配给 `foo` 变量。根据所有权规则，`foo` 现在是 `Foo` 实例的所有者。在下一行，我们将
    `foo` 分配给 `bar`。在 `main` 中的第二行执行时，`bar` 成为 `Foo` 实例的新所有者，而旧的 `foo` 现在是一个废弃的变量，在移动之后任何地方都不能使用。这可以从第三行的
    `println!` 调用中看出。Rust 默认情况下，每次我们将变量分配给其他变量或从变量中读取时，都会移动变量指向的值。所有权规则防止你拥有多个修改值的访问点，这可能导致在允许对值有多个可变别名的单线程上下文中出现使用后释放的情况。一个经典的例子是
    C++ 中的迭代器失效问题。现在，为了分析值何时超出作用域，所有权规则也考虑了变量的作用域。让我们接下来了解作用域。
- en: A brief on scopes
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域简要介绍
- en: Before we go further into ownership, we need to get a brief idea of scopes,
    which might be familiar to you already if you know C, but we'll recap it here
    in the context of Rust, as ownership works in tandem with scopes. So, a scope
    is nothing but an environment where variables and values come into existence.
    Every variable you declare is associated with a scope. Scopes are represented
    in code by braces `{}`. A scope is created whenever you use a *block expression*,
    that is, any expression that starts and ends with braces `{}`. Also, scopes can
    nest within each other and can access items from the parent scope, but not the
    other way around.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步探讨所有权之前，我们需要简要了解作用域，如果你了解 C 语言，这可能会让你感到熟悉，但我们将在这里以 Rust 的上下文回顾它，因为所有权与作用域协同工作。所以，作用域不过是一个变量和值存在的环境。你声明的每个变量都与一个作用域相关联。作用域在代码中由花括号
    `{}` 表示。每当使用 *块表达式* 时，就会创建一个作用域，即任何以花括号 `{}` 开始和结束的表达式。此外，作用域可以嵌套在彼此内部，并且可以访问父作用域中的项目，但不能反过来。
- en: 'Here''s some code that demonstrates multiple scopes and values:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码示例，展示了多个作用域和值：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To help with this explanation, will assume that our scopes are numbered, starting
    from `0`. With this assumption, we have created variables that have the `level_x`
    prefix in their name. Let's run through the preceding code, line by line. As functions
    can create new scopes, the `main` function introduces a root scope level 0 with
    a `level_0_str` defined within it. Inside the level 0 scope, we create a new scope, level
    1*,* with a bare block `{}`, which contains the variable `level_1_number`. Within
    level 1, we create another block expression, which becomes level 2 scope. In level
    2, we declare another variable, `level_2_vector`, to which we push `level_1*_*number`,
    which comes from the parent scope,that is, level 1\. Finally, when the code reaches
    the end of `}`, all of the values get destructed and the respective scopes come
    to an end. Once the scope ends, we cannot use any values defined within them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解释这一点，我们将假设我们的作用域是编号的，从 `0` 开始。基于这个假设，我们创建了具有 `level_x` 前缀的变量名。让我们逐行运行前面的代码。由于函数可以创建新的作用域，`main`
    函数引入了一个根作用域级别 0，其中定义了 `level_0_str`。在级别 0 作用域内部，我们创建了一个新的作用域，即级别 1，它包含一个裸块 `{}`，其中包含变量
    `level_1_number`。在级别 1 内部，我们创建另一个块表达式，这成为级别 2 作用域。在级别 2 中，我们声明另一个变量 `level_2_vector`，我们将
    `level_1_number` 推送到它，这来自父作用域，即级别 1。最后，当代码到达 `}` 的末尾时，所有值都被销毁，相应的作用域也随之结束。一旦作用域结束，我们就不能使用其中定义的任何值。
- en: Scopes are an important property to keep in mind when reasoning about the ownership
    rule. They are also used to reason about borrowing and lifetimes, as we'll see
    later. When a scope ends, any variable that owns a value runs code to deallocate
    the value and itself becomes invalid for use outside the scope. In particular,
    for heap allocated values, a `drop` method is placed right before the end of the scope
    `}`. This is akin to calling the `free` function in C, but here it's implicit
    and saves the programmer from forgetting to deallocate values. The `drop` method
    comes from the `Drop` trait, which is implemented for most heap allocated types
    in Rust and makes automatic freeing of resources a breeze.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在推理所有权规则时，作用域是一个需要记住的重要属性。它们也被用来推理借用和生命周期，正如我们稍后将会看到的。当一个作用域结束时，任何拥有值的变量都会运行代码来释放该值，并且它本身在作用域外使用时也变得无效。特别是对于堆分配的值，在作用域结束的
    `}` 之前放置一个 `drop` 方法。这类似于在 C 中调用 `free` 函数，但在这里它是隐式的，可以节省程序员忘记释放值的麻烦。`drop` 方法来自
    `Drop` 特性，它在 Rust 中为大多数堆分配类型实现，使得自动释放资源变得轻而易举。
- en: 'Having learned about scopes, let''s look at an example similar to the one we
    previously saw in `ownership_basics.rs`, but this time, let''s use a primitive
    value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了作用域的概念后，让我们来看一个与之前在 `ownership_basics.rs` 中看到的例子类似的例子，但这次，我们将使用一个原始值：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Try compiling and running this program. You might be in for a surprise as this
    program compiles and runs just fine. What gives? In the program, the ownership
    of `4623` does not move from `foo` to `bar`, but `bar` gets a separate copy of
    `4623`. It appears that primitive types are treated specially in Rust, where they
    get copied instead of moved. This means that there are different semantics of
    ownership depending on what types we use in Rust, which brings us to the concept
    of move and copy semantics.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编译并运行这个程序。你可能会有惊喜，因为这个程序编译和运行得很好。这是怎么回事？在程序中，`4623` 的所有权并没有从 `foo` 移动到 `bar`，而是
    `bar` 获得了 `4623` 的一个单独的副本。这看起来像是 Rust 中对原始类型进行了特殊处理，它们被复制而不是移动。这意味着在 Rust 中，根据我们使用的类型，所有权的语义是不同的，这引出了移动和复制语义的概念。
- en: Move and copy semantics
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动和复制语义
- en: In Rust, variable bindings have move semantics by default. But what does this
    really mean? To understand that, we need to think about how variables are used
    in a program. We create values or resources and assign them to variables to easily
    refer to them later in our program. These variables are names that point to the
    memory location where the value resides. Now, operations with variables such as
    reading, assignment, addition, passing them to functions, and so on can have different
    semantics or meaning around how the value being pointed to by the variable is
    accessed. In statically typed languages, these semantics are broadly classified
    as move semantics and copy semantics. Let's define both.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，变量绑定默认具有移动语义。但这是什么意思呢？为了理解这一点，我们需要思考变量在程序中的使用方式。我们创建值或资源并将它们分配给变量，以便在程序中稍后轻松引用它们。这些变量是指向值所在内存位置的指针。现在，对变量的操作，如读取、赋值、加法、将它们传递给函数等，可以具有不同的语义或意义，这涉及到变量所指向的值是如何访问的。在静态类型语言中，这些语义被广泛分类为移动语义和复制语义。让我们定义两者。
- en: '**Move semantics**: A value that gets moved to the receiving item when accessed
    through a variable or reassigning to a variable exhibits move semantics. Rust
    has move semantics  by default due to its **affine type system**. A highlighting
    part of affine type systems is that values or resources can only be used once,
    and Rust exhibits this property with the ownership rule.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动语义**：当一个值通过变量访问或重新赋值给变量时被移动到接收项，则该值表现出移动语义。由于 Rust 的 **affine 类型系统**，Rust
    默认具有移动语义。affine 类型系统的一个突出特点是值或资源只能使用一次，Rust 通过所有权规则展示了这一特性。'
- en: '**Copy semantics**: A value that gets copied (as in a bitwise copy) by default
    when assigned or accessed through a variable or passed to/returned from a function
    exhibits copy semantics. This means that the value can be used any number of times
    and each value is completely new.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制语义**：当一个值通过变量赋值或访问时默认进行位复制（例如，在通过变量赋值或访问时），则该值表现出复制语义。这意味着该值可以被使用任意次数，并且每个值都是全新的。'
- en: These semantics are familiar to people from the C++ community. C++ has copy
    semantics by default. Move semantics were added later with the C++11 release.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语义对 C++ 社区的成员来说很熟悉。C++ 默认具有复制语义。移动语义是在 C++11 版本中后来添加的。
- en: 'Move semantics in Rust can be limiting at times. Fortunately, a type''s behavior
    can be changed to follow copy semantics by implementing the `Copy` trait. This
    is implemented by default for primitives and other stack-only data types and is
    the reason why the previous code using primitives works. Consider the following
    snippet that tries to make a type `Copy` explicitly:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的移动语义有时可能会有限制。幸运的是，通过实现`Copy`特性，可以改变类型的行为以遵循复制语义。这默认适用于原始类型和其他栈上数据类型，这就是为什么之前使用原始类型的代码能够正常工作。考虑以下尝试显式使类型`Copy`的代码片段：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On compiling this, we get the following error:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译这个程序时，我们得到以下错误：
- en: '![](img/328db879-eb70-45cd-9a36-380ac8399a6e.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/328db879-eb70-45cd-9a36-380ac8399a6e.png)'
- en: 'Interesting! It appears that `Copy` depends on the `Clone` trait. This is because
    `Copy` is defined in the standard library as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 真是很有趣！看起来`Copy`依赖于`Clone`特性。这是因为`Copy`在标准库中的定义如下：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Clone` is a super trait of `Copy`, and any type implementing `Copy` must also
    implement `Clone`. We can make this example compile by adding the `Clone` trait
    beside `Copy` in the derive annotation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clone`是`Copy`的超特性，任何实现了`Copy`的类型也必须实现`Clone`。我们可以通过在派生注解中添加`Clone`特性来使这个例子编译通过：'
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The program works now. But it's not quite clear of the differences between `Clone`
    and `Copy`. Let's differentiate them next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在运行正常了。但是，关于`Clone`和`Copy`之间的区别还不是非常清楚。让我们接下来区分一下它们。
- en: Duplicating types via traits
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过特性复制类型
- en: The `Copy` and `Clone` traits convey the idea of how types gets duplicated when
    they are used in code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Copy`和`Clone`特性传达了当它们在代码中使用时类型如何被复制的概念。'
- en: Copy
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copy
- en: The `Copy` trait is usually implemented for types that can be completely represented
    on the stack. This is to say that they don't have any part of themselves that
    lives on the heap. If that were the case, `Copy` would be a heavy operation as
    it would also have to go down the heap to copy the values. It directly affects
    how the `=` assignment operator works. If a type implements `Copy`, an assignment
    from one variable to another would copy the data implicitly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Copy`特性通常用于可以在栈上完全表示的类型。也就是说，它们没有任何部分是存在于堆上的。如果是这样的话，`Copy`操作将会很重，因为它还需要遍历堆来复制值。这直接影响了`=`赋值操作符的工作方式。如果一个类型实现了`Copy`，从一个变量到另一个变量的赋值就会隐式地复制数据。'
- en: '`Copy` is an auto trait that is implemented automatically on most stack data
    types such as primitives and immutable references, that is, `&T`.  The way `Copy`
    duplicates types is very similar to how the  `memcpy` function works in C, which
    is used to copy values bitwise. `Copy` for user-defined types is not implemented
    by default as Rust wants to be explicit about copying and the developer has to
    opt in to implement the trait. `Copy` also depends on the `Clone` trait when anyone
    wants to implement `Copy` on their types.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Copy`是一个自动特性，它自动应用于大多数栈数据类型，如原始类型和不可变引用，即`&T`。`Copy`复制类型的方式与C语言中的`memcpy`函数非常相似，后者用于按位复制值。对于用户定义的类型，`Copy`默认不实现，因为Rust希望明确复制，并且开发者必须选择实现该特性。`Copy`在任何人想要在他们的类型上实现`Copy`时也依赖于`Clone`特性。'
- en: Types that don't implement `Copy` are `Vec<T>`, `String`, and mutable references.
    To make copies of these values, we use the more explicit `Clone` trait.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 没有实现`Copy`的类型有`Vec<T>`、`String`和可变引用。为了复制这些值，我们使用更明确的`Clone`特性。
- en: Clone
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clone
- en: 'The `Clone` trait is for explicit duplication and comes with a `clone` method that
    a type can implement to obtain a copy of itself. The `Clone` trait is defined
    like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clone`特性用于显式复制，并附带一个`clone`方法，类型可以通过实现该方法来获得自身的副本。`Clone`特性的定义如下：'
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It has a method called `clone` that takes an immutable reference to the receiver,
    that is, `&self`, and returns a new value of the same type. User defined types
    or any wrapper types that need to provide the ability to duplicate themselves
    should implement the `Clone` trait by implementing the `clone` method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个名为`clone`的方法，该方法接受接收者的不可变引用，即`&self`，并返回相同类型的新值。用户定义的类型或任何需要提供自我复制能力的包装类型都应该通过实现`clone`方法来实现`Clone`特性。
- en: But unlike `Copy` types where assignment implicitly copies the value, to duplicate
    a `Clone` value, we have to explicitly call the `clone` method. The `clone` method
    is a more general duplication mechanism and `Copy` is a special case of it, which
    is always a bitwise copy. Items such as `String` and `Vec` that are heavy to copy,
    only implements  the `Clone` trait. Smart pointer types also implement the `Clone`
    trait where they just copy the pointer and extra metadata such as the reference
    count while pointing to the same heap data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但与`Copy`类型不同，其中赋值隐式复制值，要复制一个`Clone`值，我们必须显式调用`clone`方法。`clone`方法是一种更通用的复制机制，而`Copy`是它的一个特例，它始终是位复制。像`String`和`Vec`这样的重复制项，只实现了`Clone`特质。智能指针类型也实现了`Clone`特质，其中它们只是复制指针和额外的元数据，如引用计数，同时指向相同的堆数据。
- en: This is one of those examples of being able to decide how we want to copy types,
    and the `Clone` trait gives us that flexibility.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们能够决定如何复制类型的一个例子，`Clone`特质给了我们这种灵活性。
- en: 'Here''s a program that demonstrates using `Clone` to duplicate a type:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示使用`Clone`来复制类型的程序：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We added a `Clone` in the derive attribute. With that, we can call `clone` on
    `a`  to get a new copy of it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`derive`属性中添加了一个`Clone`。有了这个，我们就可以在`a`上调用`clone`来获取它的新副本。
- en: Now, you are probably wondering when you should one implement either of these
    types. The following are a few guidelines.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道何时应该实现这两种类型之一。以下是一些指导原则。
- en: 'When to implement `Copy` on a type:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在何时实现`Copy`类型：
- en: 'Small values that can be represented solely in the stack as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 小值可以仅以下列方式表示在堆栈上：
- en: If the type depends only on other types that have `Copy` implemented on them;
    the `Copy` trait is implicitly implemented for it.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型只依赖于其他实现了`Copy`的类型；则对该类型隐式实现了`Copy`特质。
- en: The `Copy` trait implicitly affects how the assignment operator `=` works. The
    decision on whether to make your own externally visible types using the `Copy`
    trait requires some consideration due to how it affects the assignment operator.
    If at an early point of development your type is a `Copy` and you remove it afterwards,
    it affects every point where values of that type are assigned. You can easily
    break an API in that manner.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Copy`特质隐式影响了赋值运算符`=`的工作方式。由于它如何影响赋值运算符，因此决定是否使用`Copy`特质来创建自己的外部可见类型需要一些考虑。如果在开发的早期阶段你的类型是`Copy`，之后你移除了它，这将影响所有该类型值被赋值的地方。你可能会以这种方式轻易地破坏一个API。'
- en: 'When to implement `Clone` on a type:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在何时实现`Clone`类型：
- en: The `Clone` trait merely declares a `clone` method, which needs to be called
    explicitly.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clone`特质仅声明了一个`clone`方法，需要显式调用。'
- en: If your type also contains a value on the heap as part of its representation,
    then opt for implementing `Clone`, which makes it explicit to users that will
    also be cloning the heap data.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的类型还包含作为其表示一部分的堆上的值，那么选择实现`Clone`，这会明确告诉用户还将克隆堆数据。
- en: If you are implementing a smart pointer type such as a reference counting type,
    you should implement `Clone` on your type to only copy the pointers on the stack.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在实现一个如引用计数这样的智能指针类型，你应该在你的类型上实现`Clone`，以仅复制堆栈上的指针。
- en: Now that we know the basics of `Copy` and `Clone`, let's move on to see how
    ownership affects various places in code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`Copy`和`Clone`的基础知识，让我们继续看看所有权如何影响代码的各个地方。
- en: Ownership in action
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动中的所有权
- en: Apart from the `let` binding example, there are other places where you will
    find ownership in effect, and it's important to recognize these and the errors
    the compiler gives us.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`let`绑定示例之外，你还会在其他地方找到所有权的应用，识别这些地方以及编译器给出的错误是非常重要的。
- en: '**Functions:** If you pass parameters to functions, the same ownership rules
    are in effect:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数：** 如果你向函数传递参数，相同的所有权规则同样适用：'
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The compilation fails in a similar way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 编译失败的方式类似：
- en: '![](img/ef35f1ee-f850-4a2a-962e-100f6db2e38b.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef35f1ee-f850-4a2a-962e-100f6db2e38b.png)'
- en: '`String` does not implement the `Copy` trait, so the ownership of the value
    is moved inside the `take_the_s` function. When that function returns, the scope
    of the value comes to an end and `drop` is called on `s`, which frees the heap
    memory used by `s`. Therefore, `s` cannot be used after the function call anymore.
    However, since `String` implements `Clone`, we can make our code work by adding
    a `.clone()` call at the function call site:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`没有实现`Copy`特质，因此值的所有权在`take_the_s`函数内部移动。当该函数返回时，值的范围结束，并在`s`上调用`drop`，从而释放`s`使用的堆内存。因此，在函数调用之后，`s`不能再使用。然而，由于`String`实现了`Clone`，我们可以在函数调用位置添加一个`.clone()`调用，使我们的代码工作：'
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our `take_the_n` works fine as `u8` (a primitive type) implements `Copy`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`take_the_n`在`u8`（一个原始类型）实现`Copy`时工作正常。
- en: 'This is to say that, after passing move types to a function, we cannot use
    that value later. If you want to use the value, we must clone the type and send
    a copy to the function instead. Now, if we only need read access to variable `s`,
    another way we could have made this code work is by passing the string `s` back
    to main. This looks something like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在将移动类型传递给函数后，我们不能再使用该值。如果我们想使用该值，我们必须克隆类型并将副本发送到函数。现在，如果我们只需要读取变量`s`的访问权限，另一种我们可以使此代码工作的方式是将字符串`s`返回到`main`。这看起来像这样：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We added a return type to our `take_the_s` function and return the passed string
    `s` back to the caller. In `main`, we receive it in `s`. With this, the last line
    of code in `main` works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给`take_the_s`函数添加了一个返回类型，并将传递的字符串`s`返回给调用者。在`main`中，我们接收它到`s`。有了这个，`main`中的最后一行代码就可以工作了。
- en: '**Match expressions:** Within a match expression, a move type is also moved
    by default, as shown in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**匹配表达式**：在匹配表达式内部，默认情况下也会移动移动类型，如下述代码所示：'
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we create a `Bag` instance and assign it to `bag`. Next,
    we match on its `food` field and print some text. Later, we print the `bag` with
    `println!`. We get the following error upon compilation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`Bag`实例并将其赋值给`bag`。接下来，我们匹配其`food`字段并打印一些文本。稍后，我们使用`println!`打印`bag`。在编译时，我们得到以下错误：
- en: '![](img/22d4bacb-d7c3-4ece-9f28-d984cd60b3c8.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22d4bacb-d7c3-4ece-9f28-d984cd60b3c8.png)'
- en: As you can clearly read, the error message says that `bag` has already been
    moved and consumed by the `a` variable in the match expression. This invalidates
    the variable `bag` for any further use. We'll see how to make this code work when
    we get to the concept of borrowing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所清晰阅读的，错误信息表明`bag`已经被`match`表达式中的`a`变量移动和消耗。这使`bag`变量无法再用于其他用途。当我们学习到借用概念时，我们将看到如何使此代码工作。
- en: '**Methods:** Within an `impl` block, any method with `self` as the first parameter
    takes ownership of the value on which the method is called. This means that after
    you call the method on the value, you cannot use that value again. This is shown
    in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**：在`impl`块内部，任何以`self`作为第一个参数的方法都获取被调用方法上的值的所有权。这意味着在您对值调用方法后，您不能再使用该值。这在下述代码中显示：'
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Upon compilation, we get the following error:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时，我们得到以下错误：
- en: '![](img/b4710d33-9819-44e6-ac28-44a33bf4842d.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4710d33-9819-44e6-ac28-44a33bf4842d.png)'
- en: '`take_item` is an instance method that takes `self` as the first parameter.
    After its invocation, `it` is moved inside the method and deallocated when the
    function scope ends. We cannot use `it` again later. We''ll make this code work
    when we get to the borrowing concept.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`take_item`是一个实例方法，它以`self`作为第一个参数。在其调用之后，`it`被移动到方法内部，并在函数作用域结束时被释放。我们不能再使用`it`。当我们学习到借用概念时，我们将使此代码工作。'
- en: '**Ownership in closures**: A similar thing happens with closures. Consider
    the following code snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭包中的所有权**：闭包中也会发生类似的事情。考虑以下代码片段：'
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can already guess, the ownership of `Foo` is moved to `b` inside the
    closure by default on assignment, and we can''t access `a` again. We get the following
    output when compiling the preceding code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测的，`Foo`的所有权在闭包内部默认通过赋值移动到`b`，我们不能再访问`a`。编译前面的代码时，我们得到以下输出：
- en: '![](img/a218189e-9151-48ee-a202-b56c3e09496c.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a218189e-9151-48ee-a202-b56c3e09496c.png)'
- en: 'To have a copy of `a`, we can call `a.clone()` inside the closure and assign
    it to `b` or place a move keyword before the closure, like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`a`的一个副本，我们可以在闭包内部调用`a.clone()`并将其赋值给`b`，或者像这样在闭包前放置一个移动关键字：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will make our program compile.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的程序编译成功。
- en: '**Note**: Closures take values differently depending on how a variable is used
    inside the closure.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：闭包根据变量在闭包中的使用方式以不同的方式获取值。'
- en: With these observations, we can already see that the ownership rule can be quite
    restrictive as it allows us to use a type only once. If a function needs only
    read access to a value, then we either need to return the value back again from
    the function or clone it before passing it to the function. The latter might not
    be possible if the type does not implement `Clone`. Cloning the type might seem
    like an easy thing to get around the ownership principle, but it defeats the whole
    point of the zero-cost promise as `Clone`  always duplicates types always, possibly
    making a call to the memory allocator APIs, which is a costly operation involving
    system calls.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些观察，我们可以看出所有权规则可能相当限制性，因为它只允许我们使用一种类型一次。如果一个函数只需要对值进行读取访问，那么我们或者需要从函数中再次返回该值，或者在其传递给函数之前克隆它。如果该类型没有实现
    `Clone`，那么后者可能不可行。克隆类型可能看起来像是一个绕过所有权原则的简单方法，但它违背了零成本承诺的整个目的，因为 `Clone` 总是复制类型，这可能会调用内存分配器API，这是一个涉及系统调用的昂贵操作。
- en: With move semantics and the ownership rule in effect, it soon gets unwieldy
    to write programs in Rust. Fortunately, we have the concept of borrowing and reference
    types that relax the restrictions imposed by the rules but still maintains the
    ownership guarantees at compile time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动语义和所有权规则生效的情况下，很快就会难以在Rust中编写程序。幸运的是，我们有借用和引用类型的概念，这些概念放松了规则强加的限制，但仍然在编译时保持所有权保证。
- en: Borrowing
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用
- en: The concept of borrowing is there to circumvent the restrictions with the ownership
    rule. Under borrowing, you don't take ownership of values, but only lend data
    for as long as you need. This is achieved by borrowing values, that is, taking
    a reference to a value. To borrow a value, we put the  `&` operator before the
    variable `&` is the *address of* operator . We can borrow values in Rust in two
    ways.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 借用的概念是为了绕过所有权规则的限制。在借用下，你不会获取值的所有权，但只需借用数据直到你需要为止。这是通过借用值来实现的，即获取一个值的引用。要借用一个值，我们在变量前放置
    `&` 操作符，即 *地址* 操作符。我们可以在Rust中以两种方式借用值。
- en: '**Immutable borrows**: When we use the `&` operator before a type, we create
    an immutable reference to it. Our previous example from the ownership section
    can be re-written using borrowing:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变借用**：当我们在一个类型前使用 `&` 操作符时，我们创建了一个对该类型的不可变引用。我们可以使用借用重写所有权部分中的先前示例：'
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This time, the program compiles, as the second line inside `main` has changed
    to this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，程序可以编译，因为 `main` 中的第二行已经改为这样：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice the `&` before the variable `foo`. We are borrowing `foo` and assigning
    the borrow to `bar`. `bar` has a type of `&Foo`, which is a reference type. Being
    an immutable reference, we cannot mutate the value inside `Foo` from `bar`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意变量 `foo` 前面的 `&` 符号。我们正在借用 `foo` 并将借用赋给 `bar`。`bar` 的类型是 `&Foo`，这是一个引用类型。作为一个不可变引用，我们不能从
    `bar` 中修改 `Foo` 内部的值。
- en: '**Mutable borrows**: Mutable borrows to a value can be taken using the `&mut`
    operator. With mutable borrows, you can mutate the value. Consider the following
    code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变借用**：可以使用 `&mut` 操作符获取值的可变借用。有了可变借用，你可以修改值。考虑以下代码：'
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we have a `String` instance declared as `a`. We also create a mutable
    reference to it with `b` using `&mut a`. This does not move `a` to `b`,- only
    borrows it mutably. We then push a `''!''` character to the string. Let''s compile
    this program:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个声明为 `a` 的 `String` 实例。我们还使用 `&mut a` 创建了对它的可变引用 `b`。这不会将 `a` 移动到 `b`，而只是以可变方式借用它。然后我们向字符串中推入一个
    `'!'` 字符。让我们编译这个程序：
- en: '![](img/2894603b-b6f4-4527-99ed-c0ca832245ee.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2894603b-b6f4-4527-99ed-c0ca832245ee.png)'
- en: 'We have an error. The compiler says that we cannot borrow `a` mutably. This
    is because mutable borrows require the owning variable itself to be declared with
    the `mut` keyword. This should be obvious, as we can''t mutate something that''s
    behind an immutable binding. Accordingly, we''ll change our declaration of `a`
    to this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个错误。编译器说我们无法以可变方式借用 `a`。这是因为可变借用要求拥有变量的本身也用 `mut` 关键字声明。这应该是显而易见的，因为我们不能修改一个位于不可变绑定后面的东西。因此，我们将
    `a` 的声明改为如下：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This makes the program compile. Here, `a` is a stack variable that points to
    a heap allocated value, and `a_ref` is a mutable reference to the value owned
    by `a`. `a_ref` can mutate the `String` value but it cannot drop the value, as
    it's not the owner. The borrow becomes invalid if `a` is dropped before the line
    that takes a reference.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得程序可以编译。在这里，`a` 是一个指向堆分配值的栈变量，而 `a_ref` 是对 `a` 所拥有的值的可变引用。`a_ref` 可以修改 `String`
    值，但它不能丢弃该值，因为它不是所有者。如果 `a` 在获取引用的行之前被丢弃，则借用将无效。
- en: 'Now, we add a `println!` at the end of the previous program to print the modified
    `a`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compiling this gives us the following error:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88e93618-facf-47bb-88c2-37a23ed6b831.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Rust forbids this, thus borrowing the value immutably as a mutable borrow with
    `a_ref` already is present in the scope. This highlights another important rule
    with borrowing. Once a value is borrowed mutably, we cannot have any other borrows
    of it. Not even an immutable borrow. Having explored borrowing, let's highlight
    the exact borrowing rules in Rust.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing rules
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the ownership rule, we also have borrowing rules that maintain the
    single ownership semantics with references, too. These rules are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: A reference may not live longer than what it referred to. This is obvious, since
    if it did, it would be referring to a garbage value.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there's a mutable reference to a value, no other references, either mutable
    or immutable references, are allowed to the same value in that scope. A mutable
    reference is an exclusive borrow.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no mutable reference to a thing, any number of immutable references
    to the same value are allowed in the scope.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The borrowing rules in Rust are analyzed by a component of the compiler called
    the borrow checker. The Rust community amusingly calls dealing with borrowing
    errors as fighting the borrow checker.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're familiar with the rules, let's see what happens if we go against
    the borrow checker by violating them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing in action
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust's error diagnostics around the borrowing rules are really helpful when
    we go against the borrow checker. In the following few examples, we'll see them
    in various contexts.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**Borrowing in functions**: As you saw previously, moving ownership when making
    function calls does not make much sense if you are only reading the value, and
    is very limiting. You don''t get to use the variable after you call the function.
    Instead of taking parameters by value, we can take them by references. We can
    fix the previous code example that was presented in the ownership section to pass
    the compiler without cloning, like so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, `take_the_s` and `take_the_n` now take mutable references.
    With this, we needed to modify three things in our code. First, the variable binding
    will have to be made mutable:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Second, our function changes to the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Third, the call site would also need to change to this form:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, we can see that everything in Rust is explicit. Mutability is very visible
    in Rust code for obvious reasons, especially when multiple threads come into play.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Borrowing in match**: In match expressions, a value is moved by default in
    the match arms, unless it''s a `Copy` type. The following code, which was presented
    in the previous section on ownership, compiles by borrowing in match arms:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We made a slight change to the preceding code, which might be familiar to you
    from the ownership section. For the second match arm, we prefixed a with `ref`.
    The `ref` keyword is a keyword that can match items by taking a reference to them
    instead of capturing them by value. With this change, our code compiles.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对前面的代码做了一些轻微的修改，这可能与你在所有权部分看到的代码相似。对于第二个匹配分支，我们在 `a` 前加了 `ref` 前缀。`ref` 关键字是一个关键字，它可以通过引用它们而不是按值捕获它们来匹配项。通过这个修改，我们的代码可以编译。
- en: '**Returning a reference from a function**: In the following code example, we
    have a function that tries to return a reference to a value declared within the
    function:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**从函数返回引用**：在下面的代码示例中，有一个尝试从函数内部声明的值返回引用的函数：'
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code fails to pass the borrow checker, and we are met with the following
    error:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码未能通过借用检查器，我们遇到了以下错误：
- en: '![](img/6203aefd-4a8a-47c2-b7b3-3a9e0e5a95a1.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6203aefd-4a8a-47c2-b7b3-3a9e0e5a95a1.png)'
- en: The error message says that we are missing a lifetime specifier. That doesn't
    help much in regards to explaining what is wrong with our code. This is where
    we need to acquaint ourselves with the concept of lifetimes, which we will cover
    in the next section. Before that, let's expound on the kind of functions that
    we can can have based on borrowing rules.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息表明我们缺少生命周期指定符。这并不能很好地解释我们代码中的问题。这就是我们需要熟悉生命周期概念的地方，我们将在下一节中介绍。在此之前，让我们详细说明基于借用规则我们可以有哪些类型的函数。
- en: Method types based on borrowing
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于借用的方法类型
- en: 'The borrowing rules also dictate how inherent methods on types are defined
    and also instance methods from traits. The following are how they receive the
    instance, presented by least restrictive to most restrictive:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 借用规则还规定了如何定义类型上的固有方法和来自特质的实例方法。以下是如何接收实例的说明，从最不限制到最限制：
- en: '`&self` methods: These methods only have immutable access to its members'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&self` 方法：这些方法只能对其成员进行不可变访问'
- en: '`&mut self` methods: These methods borrows the self instance mutably'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&mut self` 方法：这些方法以可变方式借用 self 实例'
- en: '`self` methods: These methods takes ownership of the instance on which it is
    called and the type is not available to be called later'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self` 方法：这些方法在调用时拥有实例的所有权，并且其类型不可用于后续调用'
- en: In the case of user defined types, the same kind of borrowing applies also to
    its field members.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户定义类型的情况下，相同的借用规则也适用于其字段成员。
- en: '**Note**: Unless you''re deliberately writing a method that should move or
    drop `self` at the end, always prefer immutable borrowing methods that is, having `&self`
    as the first parameter.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：除非你故意编写一个应该在结束时移动或丢弃 `self` 的方法，否则始终优先选择不可变借用方法，即，将 `&self` 作为第一个参数。'
- en: Lifetimes
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期
- en: The third piece in Rust's compile time memory safety puzzle is the idea of lifetimes
    and the related syntactic annotation for specifying lifetimes in code. In this
    section, we'll explain lifetimes by stripping them down to the basics.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译时内存安全谜题的第三部分是关于生命周期以及用于在代码中指定生命周期的相关语法标注的概念。在本节中，我们将通过简化基本概念来解释生命周期。
- en: 'When we declare a variable by initializing it with a value, the variable has
    a certain lifetime, beyond which it is invalid to use it. In general programming
    parlance, the lifetime of a variable is the region in code in which the variable
    points to a valid memory. If you have ever programmed in C, you should be acutely
    aware of the case with lifetimes of variables: every time you allocate a variable
    with `malloc`, it should have an owner, and that owner should reliably decide
    when that variable''s life ends and when the memory gets freed. But the worst
    thing is, it''s not enforced by the C compiler; rather, it''s the programmer''s
    responsibility.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过初始化值来声明一个变量时，该变量具有一个生命周期，超出这个生命周期后，使用它就不再有效。在一般编程术语中，变量的生命周期是指代码中变量指向有效内存的区域。如果你曾经用
    C 语言编程，你应该非常清楚变量生命周期的案例：每次使用 `malloc` 分配变量时，它都应该有一个所有者，并且该所有者应该可靠地决定何时结束该变量的生命周期以及何时释放内存。但最糟糕的是，C
    编译器并不强制执行这一点；相反，这是程序员的职责。
- en: For data allocated on the stack, we can easily reason by looking at the code
    and figure out whether a variable is alive or not. For heap allocated values,
    though, this isn't clear. Lifetimes in Rust is a concrete construct and not a
    conceptual idea as in C. They do the same kind of analysis that a programmer does
    manually, that is, by examining the scope of value and any variable that references
    it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: When talking about lifetimes in Rust, you only need to deal with them when you
    have a reference. All references in Rust have an implicit lifetime information
    attached to them. A lifetime defines how long the reference lives in relation
    to the original owner of the value and also the extent of the scope of the reference.
    Most of the time, it is implicit and the compiler figures out the lifetime of
    the variables by looking at the code. But in some cases, the compiler cannot and
    then it needs our help, or better said, it asks you to specify your intent.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have been dealing with references and borrowing quite easily in
    the previous code examples, but let see what happens when we try to compile the
    following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code is very simple. We have a `SomeRef` struct, which stores a reference
    to a generic type, `T`. In `main`, we create an instance of the struct, initializing
    the `part` field with a reference to an `i32`, that is, `&43`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'It gives the following error upon compilation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56b8516a-dd2d-4326-ba68-639034260caa.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: In this case, the compiler asks us to put in something called a lifetime parameter.
    A lifetime parameter is very similar to a generic type parameter. Where a generic
    type `T` denotes any type, lifetime parameters denote the region or the span where
    the reference is valid to be used. It's just there for the compiler to fill in
    with the actual region information later when the code is analyzed by the borrow
    checker.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: A lifetime is purely a compile time construct that helps the compiler to figure
    out the extent to which a reference can be used within a scope, and ensures that
    it follows the borrowing rules. It can keep track of things like the origin of
    references and whether they outlive the borrowed value. Lifetimes in Rust ensure
    that a reference can't outlive the value it points to. Lifetimes are not something
    that you as a developer will use, but it's for the compiler to use and reason
    about validity of references.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime parameters
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For cases where the compiler can''t figure out the lifetime of values by examining
    the code, we need to tell Rust by using some annotations in code. To distinguish
    from identifiers, lifetime annotations are denoted by a quirky symbol of prefixing
    a letter with `''`. So, to make our previous example compile with a parameter,
    we have added a lifetime annotation on our `StructRef`, like so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A lifetime is denoted by a `'`, followed by any sequence of valid identifiers.
    But, by convention, most lifetimes used in the Rust code uses `'a`, `'b `and  `'c`
    as lifetime parameters. If you have multiple lifetimes on a type, you can use
    longer descriptive lifetime names such as `'ctx`, `'reader`, `'writer`, and so
    on. It is declared at the same place and in the same way as generic type parameters.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw examples where the lifetimes acted as a generic parameter for resolving
    valid references later, but there''s a lifetime that has a concrete value. It
    is shown in the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `static` lifetime means that these references are valid for the entire duration
    of the program. All literal strings in Rust have a lifetime of `'static` and they
    go to the data segment of the compiled object code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime elision and the rules
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any time there's a reference in a function or a type definition, there's a lifetime
    involved. Most of the time, you don't need to use explicit lifetime annotation
    is you code as the compiler is smart to infer them for you as a lot of information
    is already available at compile time about references.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, these two function signatures are identical:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the usual case, the compiler has elided the lifetime parameter for  `func_one`
    and we don't need to write it as `func_two`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: But the compiler can elide lifetimes only in restricted places and there are
    rules for elision. Before we talk about these rules, we need to talk about input
    and output lifetimes. These are only discussed when functions that take references
    are involved.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**Input lifetime**: Lifetime annotations on function parameters that are references
    are referred to as input lifetimes.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '**Output lifetimes**: Lifetime annotations on function return values that are
    references are referred to as output lifetimes.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: It's import to note that any output lifetime originates from input lifetimes.
    We cannot have a output lifetime that is independent and distinct from the input
    lifetime. It can only be a lifetime that is smaller than or equal to the output
    lifetime.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the rules that are followed when eliding lifetimes:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: If the input lifetime contains only a single reference, the output lifetime
    is assumed to be the same
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For methods involving `self` and `&mut self`, the input lifetime is inferred
    for the  `&self` parameter
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But sometimes in ambiguous situations, the compiler doesn''t try to assume
    things. Consider the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding code, `RefItem` stores a reference to any type,  `T`. In this
    case, the lifetime of the return value isn''t obvious as there are two input references
    involved. But, sometimes, the compiler is not able to figure out the lifetimes
    of references, and then it needs our help and asks us to specify lifetime parameters.
    Consider the following code, which does not compile:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74eec68d-b419-4a41-9e54-fe1cf6d14ec5.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: The preceding program doesn't compile because Rust is unable to figure out the
    lifetime of the return value and it needs our help here.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there are various places where we have to specify lifetimes when Rust
    cannot figure them out for us:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Function signatures
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs and struct fields
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: impl blocks
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifetimes in user defined types
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a struct definition has fields that are reference to any type, we need to
    explicitly specify how long those references will live. The syntax is similar
    to that of function signatures: we first declare the lifetime names on the struct
    line, and then use them in the fields.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the syntax looks like in its simplest form:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The definition of `Number` lives as long as the reference for `num`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime in impl blocks
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we create `impl` blocks for structs with references, we need to repeat
    the lifetime declarations and definitions again. For instance, if we made an implementation
    for the struct `Foo` we defined previously, the syntax would look like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In most of these cases, this is inferred from the types themselves and then,
    we can omit the signatures with `<'_>` syntax.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Multiple lifetimes
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like generic type parameters, we can specify multiple lifetimes if we
    have more than one reference that has different lifetimes. However, it can quickly
    become hairy when you have to juggle with more than one lifetime in your code.
    Most of the time, we can get away with just one lifetime in our structs or any
    of our functions. But there are cases where we''ll need more than one lifetime
    annotations. For example, say we are building a decoder library that can parse
    binary files according to a schema and a given encoded stream of bytes. We have
    a `Decoder` object, which has a reference to a `Schema` object and a reference
    to a `Reader` type. Our Decoder definition will then look something like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding definition, it is quite possible that we get `Reader` from
    the network while the `Schema` is local, and so their lifetimes in code can be
    different. When we provide implementations for this `Decoder`, we can specify
    relations with it by lifetime subtyping, which we will explain next.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime subtyping
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can specify relation between lifetimes that specifies whether two references
    can be used in the same place. Continuing with our `Decoder` struct example, we
    can specify the lifetimes'' relations with each other in the `impl` block, like
    so:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We specified the relation in the impl block using the where clause as: ''a:
    ''b . This is read as the lifetime `''a` outlives `''b` or in other words `''b`
    should never live longer than `''a`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Specifying lifetime bounds on generic types
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from using traits to constrain the types that can be accepted by a generic
    function, we can also constrain generic type parameters using lifetime annotations.
    For instance, consider we have a logger library where the `Logger` object is defined
    as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, we have a `Logger` struct with its name and a `Level`
    enum. We also have a generic function called `configure_logger` that takes a type
    `T` that is constrained with `Send + 'static`. In main, we create a logger with
    a `'static`, string `"Global"`, and call `configure_logger` passing it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with the `Send` bound, which says that this thread can be sent to threads,
    we also say that the type must live as long as the `''static` lifetime. Let''s
    say we were to use a Logger that references a string of shorter lifetimes, like
    so:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will fail with the following error:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f39f3499-1ef1-4fdc-a1f1-dc3bb4b96ee6.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: The error message clearly say, that the borrowed value must be valid for the
    static lifetime, but we have passed it a string, which has a lifetime called `'a`
    from main, which is a shorter lifetime than `'static`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: With the concept of lifetimes under our belt, let's revisit pointer types in
    Rust.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Pointer types in Rust
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our tale about memory management would be incomplete if we didn't include pointers
    in the discussion, which are the primary way to manipulate memory in any low level
    language. Pointers are simply variables that point to memory locations in the
    process's address space. In Rust, we deal with three kinds of pointers.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: References – safe pointers
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These pointers are already familiar to you from the borrowing section. References
    are like pointers in C, but they are checked for correctness. They can never be
    null and always point to some data owned by any variable. The data they point
    to can either be on the stack or on the heap, or the data segment of the binary.
    They are created using the `&` or the `&mut` operator. These operators, when prefixed
    on a type `T`, create a reference type that is denoted by `&T` for immutable references
    and `&mut T` for mutable references. Let''s recap on these again:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`&T`: It''s an immutable reference to a type `T`. A `&T` pointer is a `Copy`
    type, which simply means you can have many immutable references to a value `T`.
    If you assign this to another variable, you get a copy of the pointer, which points
    to the same data. It is also fine to have a reference to a reference, such as
    `&&T`.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&mut T`: It''s an immutable pointer to a type `T`. Within any scope, you cannot
    have two mutable references to a value `T`, due to the borrowing rule. This means
    that `&mut T` types do not implement the `Copy` trait. They also cannot be sent
    to threads.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw pointers
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These pointers have a quirky type signature of being prefixed with a `*`, which
    also happens to be the dereference operator. They are mostly used in unsafe code.
    One needs an unsafe block to dereference them. There are two kinds of raw pointers
    in Rust:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '`*const T`: An immutable raw pointer to a type `T`. They are also `Copy` types.
    They are similar to `&T`, it''s just that `*const T` can also be null.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*mut T`: A mutable raw pointer to a value `T`, which is non-`Copy`.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an added note, a reference can be cast to a raw pointer, as shown in the
    following code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: However, we can't cast a `&T` to a `*mut T`, as it would violate the borrowing
    rules that allow only one mutable borrow.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: For mutable references, we can cast them to `*mut T` or even `*const T`, which
    is called pointer weakening, as we go from a more capable pointer `&mut T` to
    a less capable `*const T` pointer. For immutable references, we can only cast
    them to `*const T`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: However, dereferencing a raw pointer is an unsafe operation. We'll see how raw
    pointers are useful when we get to [Chapter 10](9e9ce701-5f35-4351-b76b-a5f2bd541059.xhtml),
    *Unsafe Rust and Foreign Function Interfaces*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing raw pointers is highly unsafe and developers need to be careful about
    a lot of details when using them. Uninformed usage may lead to issues such as
    memory leaks, dangling references, and double frees in large code bases in non-obvious
    ways. To alleviate from these issues, we can use smart pointers, which were popularized
    by C++.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Rust also has many kinds of smart pointers. They are called smart because they
    also have extra metadata and code associated with them that gets executed when
    they are created or destroyed. Being able to automatically free the underlying
    resource when a smart pointer goes out of scope is one of the major reasons to
    use smart pointers.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Much of the smartness in smart pointers comes from two traits, called the `Drop`
    trait and the `Deref` trait. Before we explore the available smart pointer types
    in Rust, let's understand these traits in detail.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Drop
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the trait we''ve been referring to quite a few times which does all
    the magic of automatically freeing up the resources that are used when a value
    goes out of scope. The `Drop` trait is akin to what you would call an `object
    destructor` method in other languages. It contains a single method, `drop`, which
    gets called when the object goes out of scope. The method takes in a `&mut self`
    as parameter. Freeing of values with drop is done in **last in, first out**. That
    is, whatever was constructed the last, gets destructed first. The following code
    illustrates this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b426f590-64c0-4736-aaa9-67c54eb60ad7.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
- en: The drop method is an ideal place for you to put any cleanup code for your own
    structs, if needed. It's especially handy for types where the cleanup is less
    clearly deterministic, such as when using reference counted values or garbage
    collectors. When we instantiate any `Drop` implementing value (any heap allocated
    type), the Rust compiler inserts `drop` method calls after every end of scope,
    after compilation. So, we don't need to manually call `drop` on these instances.
    This kind of automatic reclamation based on scope is inspired by the RAII principle
    of C++.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Deref and DerefMut
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To provide similar behavior as normal pointers, that is, to be able to dereference
    the call methods on the underlying type being pointed to, smart pointer types
    often implement the `Deref` trait, which allows us to use the `*` dereferencing
    operator with these types. While `Deref` gives you read-only access, there is
    also `DerefMut`, which can give you a mutable reference to the underlying type.
    Deref has the following type signature:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If defines a single method called `Deref` that takes `self` by reference and
    returns a immutable reference to the underlying type. This combined with the deref
    coercion feature of Rust, reduces a lot of code that you have to write. Deref
    coercion is when a type automatically gets converted from one type of reference
    to some other reference. We'll look at them in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Types of smart pointers
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the smart pointer types from the standard library as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '`Box<T>`: This provides the simplest form of heap allocation. The `Box` type
    owns the value inside it, and can thus be used for holding values inside structs
    or for returning them from functions.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rc<T>`: This is for reference counting. It increments a counter whenever somebody
    takes a new reference, and decrements it when someone releases a reference. When
    the counter hits zero, the value is dropped.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Arc<T>`: This is for atomic reference counting. This is like the previous
    type, but with atomicity to guarantee multithread safety.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cell<T>`: This gives us internal mutability for types that implement the `Copy`
    trait. In other words, we gain the possibility to get multiple mutable references
    to something.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RefCell<T>`: This gives us internal mutability for types, without requiring
    the `Copy` trait. It uses runtime locking for safety.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Box<T>
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The generic type `Box` in the standard library gives us the simplest way to
    allocate values in the heap. It's simply declared as a tuple struct in the standard
    library, and wraps any type given to it and puts it on heap. If you're familiar
    with the concept of boxing and unboxing from other languages, such as Java where
    you have Boxed integers as the *Integer* class, this provides a similar abstraction.
    The ownership semantics with `Box` type depends on the wrapped type. If the underlying
    type is `Copy`, the Box instance becomes copy, otherwise it moves by default.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a heap allocated value of type `T` using a `Box`, we simply call
    the associated `new` method, passing in the value. Creating the `Box` value wrapping
    a type `T` gives back the `Box` instance, which is a pointer on the stack that
    points to `T`, which is allocated on the heap. The following example shows how
    to use B`ox`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In our main function, we created a heap allocated value in boxed_one by calling
    `Box::new(Foo)`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Box` type can be used in the following situations:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be used to create recursive type definitions. For example, here is a
    Node type that represents a node in a singly linked list:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On compiling, we are presented with this error:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dbf582f-cc29-436c-aadf-f6cfbb7eb64b.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: 'We cannot have this definition of the `Node` type because `next` has a type
    that refers to itself. If this definition is allowed, there is no end for the
    compiler to analyze our Node definition as it will keep evaluating it until it
    hits out of memory. This is better illustrated with the following snippet:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This evaluation of the Node definition will keep on continuing until the compiler
    runs out of memory. Also, as every piece of data needs to have a statically known
    size at compile time, this is a non-representable type in Rust. We need to make
    the `next` field something that has a fixed size. We can do this by putting `next`
    behind a pointer because pointers are always fixed size. If you see the error
    message, the compiler,  we''ll use the Box type Our new `Node` definition changes
    like so:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `Box` type is also used when defining recursive types that need to be hidden
    behind a `Sized` indirection. So, an enum consisting of a variant with a reference
    to itself could use the `Box` type to tuck away the variant in the following situations:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: When you need to store types as trait objects
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to store functions in a collection
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference counted smart pointers
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ownership rule allows only one owner to exist at a time in a given scope.
    However, there are cases where you need to share the type with multiple variables.
    For instance, in a GUI library, each of the child widgets needs to have a reference
    to its parent container widget for things like communicating to layout the child
    widget based on resize events from the user. While lifetimes allow you to reference
    the parent node from the child nodes by storing the parent as a `&'a Parent` (say),
    it's often limited by the lifetime `'a` of the value. Once the scope ends, your
    reference is invalid. In such cases, we need more flexible approaches, and that
    calls for using reference counting types. These smart pointer types provide shared
    ownership of values in the program.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Reference counting types enables garbage collection at a granular level. In
    this approach, a smart pointer type allows you to have multiple references to
    the wrapped value. Internally, the smart pointer keeps a count of how many references
    it has given out and are active using a reference counter (hereby refcount), which
    is just an integral value. As variables that reference the wrapped smart pointer
    value go out of scope, the refcount value decrements. Once all of the references
    to the object are gone and the refcount reaches `0`, the value is deallocated.
    This is how reference counted pointers work in general.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust provides us with two kinds of reference counting pointer types:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '`Rc<T>` : This is mainly for use in single threaded environments'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Arc<T>` is meant to be used in multi-threaded environments'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore the single threaded variant here. We'll take a visit to its multi-threaded
    counterparts in [Chapter 8](8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml), *Concurrency*.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Rc<T>
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we interact with an `Rc` type, the following changes happen to it internally:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: When you take a new shared reference to `Rc` by calling `Clone()`, `Rc` increments
    its internal reference count. Rc internally uses the Cell type for its reference
    counts
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the reference goes out of scope, it decrements it
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When all shared references go out of scope, the refcount becomes zero. At this
    point, the last drop call on `Rc` does its deallocation
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using reference counted containers gives us more flexibility in the implementation:
    we can hand out copies of our value as if it were a new copy without having to
    keep exact track of when the references go out of scope. That doesn''t mean that
    we can mutably alias the inner values.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '`Rc<T>` is mostly used via two methods:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The static method `Rc::new` makes a new reference counted container.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `clone` method increments the strong reference count and hands out a new
    `Rc<T>`.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rc` internally keeps two kinds of references: strong (`Rc<T>`) and weak (`Weak<T>`).
    Both keep a count of how many references of each type have been handed out, but
    only when the strong reference count reaches zero so that the values get deallocated.
    The motivation for this is that an implementation of a data structure may need
    to point to the same thing multiple times. For instance, an implementation of
    a tree might have references to both the child nodes and the parent, but incrementing
    the counter for each reference would not be correct and would lead to reference
    cycles. The following diagram illustrates the reference cycle situation:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67567bee-43a2-477a-a975-60f87cc00bc7.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we have two variables, `var1` and `var2`, that reference
    two resources, `Obj1` and `Obj2`. Along with that, `Obj1` also has a reference
    to `Obj2` and `Obj2` has a reference to `Obj1`. Both `Obj1` and `Obj2` have reference
    count of `2` when `var1` and `var2` goes out of scope, the reference count of
    `Obj1` and `Obj2` reaches `1`. They won't get freed because they still refer to
    each other.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The reference cycle can be broken using weak references. As another example,
    a linked list might be implemented in such a way that it maintains links via reference
    counting to both the next item and to the previous. A better way to do this would
    be to use strong references to one direction and weak references to the other.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how that might work. Here''s a minimal implementation of possibly
    the least practical but best learning data structure, the singly linked list:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The linked list is formed of two structs: `LinkedList` provides a reference
    to the first element of the list and the list''s public API, and `Node` contains
    the actual elements. Notice how we''re using `Rc` and cloning the next data pointer
    on every append. Let''s walk through what happens in the append case:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '`LinkedList::new()` gives us a new list. Head is `None`.'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We append `1` to the list. Head is now the node that contains `1` as data,
    and next is the previous head: `None`.'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We append `2` to the list. Head is now the node that contains `2` as data, and
    next is the previous head, the node that contains `1` as data.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The debug output from `println!` confirms this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is a rather functional form of this structure; every append works by just
    adding data at the head, which means that we don't have to play with references
    and actual list references can stay immutable. That changes a bit if we want to
    keep the structure this simple but still have a double-linked list, since then
    we actually have to change the existing structure.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: You can downgrade an `Rc<T>` type into a `Weak<T>` type with the `downgrade`
    method, and similarly a `Weak<T>` type can be turned into `Rc<T>` using the `upgrade`
    method. The downgrade method will always work. In contrast, when calling upgrade
    on a weak reference, the actual value might have been dropped already, in which
    case you get a `None`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add a weak pointer to the previous node:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `append` method grew a bit; we now need to update the previous node of
    the current head before returning the newly created head. This is almost good
    enough, but not quite. The compiler doesn''t let us do invalid operations:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9ae95d0-501b-4926-bd2d-967faa48b547.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
- en: We could make `append` take a mutable reference to `self`, but that would mean
    that we could only append to the list if all the nodes' bindings were mutable,
    forcing the whole structure to be mutable. What we really want is a way to make
    just one small part of the whole structure mutable, and fortunately we can do
    that with a single `RefCell`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `use` for the `RefCell`:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Wrap the previous field in `LinkedListNode` in a `RefCell`:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We change the `append` method to create a new `RefCell` and update the previous
    reference via the `RefCell` mutable borrow:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Whenever we're using `RefCell` borrows, it's a good practice to think carefully
    that we're using it in a safe way, since making mistakes there may lead to runtime
    panics. In this implementation, however, it's easy to see that we have just the
    single `borrow`, and that the closing block immediately discards it.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Apart from shared ownership, we can also get shared mutability at runtime with
    Rust's concept of interior mutability, which are modeled by special wrapper smart
    pointer types.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Interior mutability
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw previously, Rust protects us at compile time from the pointer aliasing
    problem by allowing only a single mutable reference at any given scope. However,
    there are cases where it becomes too restrictive, making code that we know is
    safe not pass the compiler because of the strict borrow checking. For these situations,
    one of the solutions is to move the borrow checking from compile time to runtime,
    which is achieved with *interior mutability*. Before we talk about the types that
    enable interior mutability, we need to understand the concept of interior mutability
    and inherited mutability:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '**Inherited mutability**: This is the default mutability you get when you take
    a `&mut` reference to some struct. This also implies that you can modify any of
    the fields of the struct.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interior mutability**: In this kind of mutability, even if you have a `&SomeStruct`
    reference to some type, you can modify its fields if the fields have the type
    as  `Cell<T>` or `RefCell<T>`.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interior mutability allows for bending the borrowing rules a bit, but it also
    puts the burden on the programmer to ensure that no two mutable borrows are present
    at runtime. These types offload the detection of multiple mutable references from
    compile time to runtime and undergo a panic if two mutable references to a value
    exist. Interior mutability is often used when you want to expose an immutable
    API to users, despite having mutable parts to the API internally. The standard
    library has two generic smart pointer types that provide shared mutability: `Cell`
    and `RefCell`.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Cell<T>
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this program, where we have a requirement to mutate `bag` with two
    mutable references to it:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'But, of course, this does not compile due to the borrow checking rules:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33ba5351-d6a9-4987-866e-a6f114f2995c.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
- en: 'We can make this work by encapsulating the `bag` value inside a `Cell`. Our
    code is updated as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This works as you would expect, and the only added cost is that you have to
    write a bit more. The additional runtime cost is zero, though, and the references
    to the mutable things remain immutable.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Cell<T>` type is a smart pointer type that enables mutability for values,
    even behind an immutable reference. It provides this capability with very minimal
    overhead and has a minimal API:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '`Cell::new` method allows you to create new instances of the `Cell` type by
    passing it any type `T`.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`: The `get` method allows you to copy of the value in the cell. This method
    is only available if the wrapped type `T` is `Copy`.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set`: Allows you to modify the inner value, even behind a immutable reference.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RefCell<T>
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need Cell-like features for non-Copy types, there is the `RefCell` type.
    It uses a read/write pattern similar to how borrowing works, but moves the checks
    to runtime, which is convenient but not zero-cost. RefCell hands out references
    to the value, instead of returning things by value as is the case with the `Cell`
    type. Here's a sample program that
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, we can borrow `bag`, mutably from `hand1` and `hand2` even though
    they are declared as immutable variables. To modify the items in bag, we called
    `borrow_mut` on `hand1` and `hand2`. Later, we borrow it immutably and print the
    contents.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RefCell` type provides us with the following two borrowing methods:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: The `borrow` method takes a new immutable reference
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `borrow_mut` method takes a new mutable reference
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if we try to call both of the methods in the same scope: by changing the
    last line in the preceding code to this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We get to see the following upon running the program:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A runtime panic ! This is because of the same ownership rule of having exclusive
    mutable access. But, for `RefCell` this is checked at runtime instead. For situations
    like this, one has to explicitly use bare blocks to separate the borrows or use
    the drop method to drop the reference.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: The Cell and RefCell types are not thread safe. This simply means
    that Rust won''t allow you to share these types in multiple threads.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Uses of interior mutability
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, the examples on using `Cell` and `RefCell` were simplified,
    and you most probably won't need to use them in that form in real code. Let's
    take a look at some actual benefits that these types would give us.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, the mutability of a binding is not fine-grained;
    a value is either immutable or mutable, and that includes all of its fields if
    it's a struct or an enum. `Cell` and `RefCell` can turn an immutable thing into
    something that's mutable, allowing us to define parts of an immutable struct as
    mutable.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code augments a struct with two integers and a `sum`
    method to cache the answer of the `sum` and return the cached value if it exists:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following is the output of this program:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f41687f3-2ef4-48b0-8059-b0f3b30d1ce3.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust takes a low-level systems programming approach to memory management, promising
    C-like performance, sometimes even better. It does this without requiring a garbage
    collector through its use of ownership, lifetimes, and borrow semantics. We covered
    a whole lot of ground here in a subject that's probably the heaviest to grasp
    for a new Rustacean. That's what people familiar with Rust like to call themselves,
    and you are getting close to becoming one! Getting fluent in this shift of thinking
    of ownership at compile time takes a bit of time, but the investment in learning
    these concepts pays off in the form of reliable software with a small memory footprint.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Our next chapter will concern how fallible situations are handled in Rust. See
    you there!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
