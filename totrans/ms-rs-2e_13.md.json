["```rs\npub trait Service {\n    type ReqBody: Payload;\n    type ResBody: Payload;\n    type Error: Into<Box<dyn StdError + Send + Sync>>;\n    type Future: Future<Item = Response<Self::ResBody>, Error = Self::Error>;\n    fn call(&mut self, req: Request<Self::ReqBody>) -> Self::Future;\n}\n```", "```rs\n# hyperurl/Cargo.toml\n\n[dependencies]\nhyper = \"0.12.17\"\nserde_json = \"1.0.33\"\nfutures = \"0.1.25\"\nlazy_static = \"1.2.0\"\nrust-crypto = \"0.2.36\"\nlog = \"0.4\"\npretty_env_logger = \"0.3\"\n```", "```rs\n// hyperurl/src/main.rs\n\nuse log::{info, error};\nuse std::env;\n\nuse hyper::Server;\nuse hyper::service::service_fn;\n\nuse hyper::rt::{self, Future};\n\nmod shortener;\nmod service;\nuse crate::service::url_service;\n\nfn main() {\n    env::set_var(\"RUST_LOG\",\"hyperurl=info\");\n    pretty_env_logger::init();\n\n    let addr = \"127.0.0.1:3002\".parse().unwrap();\n    let server = Server::bind(&addr)\n        .serve(|| service_fn(url_service))\n        .map_err(|e| error!(\"server error: {}\", e));\n    info!(\"URL shortener listening on http://{}\", addr);\n    rt::run(server);\n}\n```", "```rs\npub fn service_fn<F, R, S>(f: F) -> ServiceFn<F, R> where\n    F: Fn(Request<R>) -> S,\n    S: IntoFuture,\n```", "```rs\n// hyperurl/src/service.rs\n\nuse std::sync::RwLock;\nuse std::collections::HashMap;\nuse std::sync::{Arc};\nuse std::str;\nuse hyper::Request;\nuse hyper::{Body, Response};\nuse hyper::rt::{Future, Stream};\n\nuse lazy_static::lazy_static;\n\nuse crate::shortener::shorten_url;\n\ntype UrlDb = Arc<RwLock<HashMap<String, String>>>;\ntype BoxFut = Box<Future<Item = Response<Body>, Error = hyper::Error> + Send>;\n\nlazy_static! {\n    static ref SHORT_URLS: UrlDb = Arc::new(RwLock::new(HashMap::new()));\n}\n\npub(crate) fn url_service(req: Request<Body>) -> BoxFut {\n    let reply = req.into_body().concat2().map(move |chunk| {\n        let c = chunk.iter().cloned().collect::<Vec<u8>>();\n        let url_to_shorten = str::from_utf8(&c).unwrap();\n        let shortened_url = shorten_url(url_to_shorten);\n        SHORT_URLS.write().unwrap().insert(shortened_url, url_to_shorten.to_string());\n        let a = &*SHORT_URLS.read().unwrap();\n        Response::new(Body::from(format!(\"{:#?}\", a)))\n    });\n\n    Box::new(reply)\n}\n```", "```rs\n// hyperurl/src/shortener.rs\n\nuse crypto::digest::Digest;\nuse crypto::sha2::Sha256;\n\npub(crate) fn shorten_url(url: &str) -> String {\n    let mut sha = Sha256::new();\n    sha.input_str(url);\n    let mut s = sha.result_str();\n    s.truncate(5);\n    format!(\"https://u.rl/{}\", s)\n}\n```", "```rs\n# shorten/Cargo.toml\n\n[dependencies]\nquicli = \"0.4\"\nstructopt = \"0.2\"\nreqwest = \"0.9\"\nserde = \"1\"\n```", "```rs\n// shorten/src/main.rs\n\nuse quicli::prelude::*;\nuse structopt::StructOpt;\n\nconst CONN_ADDR: &str = \"127.0.0.1:3002\";\n\n/// This is a small CLI tool to shorten urls using the hyperurl\n/// url shortening service\n#[derive(Debug, StructOpt)]\nstruct Cli {\n    /// The url to shorten\n    #[structopt(long = \"url\", short = \"u\")]\n    url: String,\n    // Setting logging for this CLI tool\n    #[structopt(flatten)]\n    verbosity: Verbosity,\n}\n\nfn main() -> CliResult {\n    let args = Cli::from_args();\n    println!(\"Shortening: {}\", args.url);\n    let client = reqwest::Client::new();\n    let mut res = client\n        .post(&format!(\"http://{}/shorten\", CONN_ADDR))\n        .body(args.url)\n        .send()?;\n    let a: String = res.text().unwrap();\n    println!(\"http://{}\", a);\n    Ok(())\n}\n```", "```rs\n# linksnap/Cargo.toml\n\n[dependencies]\nactix = \"0.7\"\nactix-web = \"0.7\"\nfutures = \"0.1\"\nenv_logger = \"0.5\"\nbytes = \"0.4\"\nserde = \"1.0.80\"\nserde_json = \"1.0.33\"\nserde_derive = \"1.0.80\"\nurl = \"1.7.2\"\nlog = \"0.4.6\"\nchrono = \"0.4.6\"\n```", "```rs\n// linksnap/src/main.rs\n\nmod links;\nmod route_handlers;\nmod state;\n\nuse std::env;\nuse log::info;\nuse crate::state::State;\nuse crate::route_handlers::{index, links, add_link, rm_link};\nuse actix_web::middleware::Logger;\nuse actix_web::{http, server, App};\n\nfn init_env() {\n    env::set_var(\"RUST_LOG\", \"linksnap=info\");\n    env::set_var(\"RUST_BACKTRACE\", \"1\");\n    env_logger::init();\n    info!(\"Starting http server: 127.0.0.1:8080\");\n}\n\nfn main() {\n    init_env();\n    let system = actix::System::new(\"linksnap\");\n    let state = State::init();\n\n    let web_app = move || {\n        App::with_state(state.clone())\n            .middleware(Logger::default())\n            .route(\"/\", http::Method::GET, index)\n            .route(\"/links\", http::Method::GET, links)\n            .route(\"/add\", http::Method::POST, add_link)\n            .route(\"/rm\", http::Method::DELETE, rm_link)\n    };\n\n    server::new(web_app).bind(\"127.0.0.1:8080\").unwrap().start();\n    let _ = system.run();\n}\n```", "```rs\n// linksnap/src/route_handlers.rs\n\nuse actix_web::{Error, HttpRequest, HttpResponse};\n\nuse crate::state::{AddLink, GetLinks, RmLink};\nuse crate::State;\nuse actix_web::AsyncResponder;\nuse actix_web::FromRequest;\nuse actix_web::HttpMessage;\nuse actix_web::Query;\nuse futures::Future;\n\ntype ResponseFuture = Box<Future<Item = HttpResponse, Error = Error>>;\n\nmacro_rules! server_err {\n    ($msg:expr) => {\n        Err(actix_web::error::ErrorInternalServerError($msg))\n    };\n}\n```", "```rs\nlinksnap/src/route_handlers.rs\n\npub fn index(_req: HttpRequest<State>) -> HttpResponse {\n    HttpResponse::from(\"Welcome to Linksnap API server\")\n}\n```", "```rs\n// linksnap/src/route_handlers.rs\n\npub fn add_link(req: HttpRequest<State>) -> ResponseFuture {\n    req.json()\n        .from_err()\n        .and_then(move |link: AddLink| {\n            let state = req.state().get();\n            state.send(link).from_err().and_then(|e| match e {\n                Ok(_) => Ok(HttpResponse::Ok().finish()),\n                Err(_) => server_err!(\"Failed to add link\"),\n            })\n        })\n        .responder()\n}\n```", "```rs\n{\n    title: \"Title of the link or bookmark\",\n    url: \"The URL of the link\"\n}\n```", "```rs\n// linksnap/src/route_handlers.rs\n\npub fn links(req: HttpRequest<State>) -> ResponseFuture {\n    let state = &req.state().get();\n    state\n        .send(GetLinks)\n        .from_err()\n        .and_then(|res| match res {\n            Ok(res) => Ok(HttpResponse::Ok().body(res)),\n            Err(_) => server_err!(\"Failed to retrieve links\"),\n        })\n        .responder()\n}\n```", "```rs\n// linksnap/src/route_handlers.rs\n\npub fn rm_link(req: HttpRequest<State>) -> ResponseFuture {\n    let params: Query<RmLink> = Query::extract(&req).unwrap();\n    let state = &req.state().get();\n    state\n        .send(RmLink { id: params.id })\n        .from_err()\n        .and_then(|e| match e {\n            Ok(e) => Ok(HttpResponse::Ok().body(format!(\"{}\", e))),\n            Err(_) => server_err!(\"Failed to remove link\"),\n        })\n        .responder()\n}\n```", "```rs\n// linksnap/src/state.rs\n\nuse actix::Actor;\nuse actix::SyncContext;\nuse actix::Message;\nuse actix::Handler;\nuse actix_web::{error, Error};\nuse std::sync::{Arc, Mutex};\nuse crate::links::Links;\nuse actix::Addr;\nuse serde_derive::{Serialize, Deserialize};\nuse actix::SyncArbiter;\n\nconst DB_THREADS: usize = 3;\n\n#[derive(Clone)]\npub struct Db {\n    pub inner: Arc<Mutex<Links>>\n}\n\nimpl Db {\n    pub fn new(s: Arc<Mutex<Links>>) -> Db {\n        Db { inner: s }\n    }\n}\n\nimpl Actor for Db {\n    type Context = SyncContext<Self>;\n}\n\n#[derive(Clone)]\npub struct State {\n    pub inner: Addr<Db>\n}\n\nimpl State {\n    pub fn init() -> Self {\n        let state = Arc::new(Mutex::new(Links::new()));\n        let state = SyncArbiter::start(DB_THREADS, move || Db::new(state.clone()));\n        let state = State {\n            inner: state\n        };\n        state\n    }\n\n    pub fn get(&self) -> &Addr<Db> {\n        &self.inner\n    }\n}\n```", "```rs\n// linksnap/src/state.rs\n\npub struct GetLinks;\n\nimpl Message for GetLinks {\n    type Result = Result<String, Error>;\n}\n\nimpl Handler<GetLinks> for Db {\n    type Result = Result<String, Error>;\n    fn handle(&mut self, _new_link: GetLinks, _: &mut Self::Context) -> Self::Result {\n        Ok(self.inner.lock().unwrap().links())\n    }\n}\n```", "```rs\n// linksnap/src/state.rs\n\npub struct GetLinks;\n\nimpl Message for GetLinks {\n    type Result = Result<String, Error>;\n}\n\nimpl Handler<GetLinks> for Db {\n    type Result = Result<String, Error>;\n    fn handle(&mut self, _new_link: GetLinks, _: &mut Self::Context) -> Self::Result {\n        Ok(self.inner.lock().unwrap().links())\n    }\n}\n```", "```rs\n// linksnap/src/state.rs\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AddLink {\n    pub title: String,\n    pub url: String\n}\n\nimpl Message for AddLink {\n    type Result = Result<(), Error>;\n}\n\nimpl Handler<AddLink> for Db {\n    type Result = Result<(), Error>;\n\n    fn handle(&mut self, new_link: AddLink, _: &mut Self::Context) -> Self::Result {\n        let mut db_ref = self.inner.lock().unwrap();\n        db_ref.add_link(new_link);\n        Ok(())\n    }\n}\n```", "```rs\n// linksnap/src/state.rs\n\n#[derive(Serialize, Deserialize)]\npub struct RmLink {\n    pub id: LinkId,\n}\n\nimpl Message for RmLink {\n    type Result = Result<usize, Error>;\n}\n\nimpl Handler<RmLink> for Db {\n    type Result = Result<usize, Error>;\n    fn handle(&mut self, link: RmLink, _: &mut Self::Context) -> Self::Result {\n        let db_ref = self.get_conn()?;\n        Link::rm_link(link.id, db_ref.deref())\n            .map_err(|_| error::ErrorInternalServerError(\"Failed to remove links\"))\n    }\n}\n\n```", "```rs\ncurl --header \"Content-Type: application/json\" \\\n --request POST \\ \n --data '{\"title\":\"rust blog\",\"url\":\"https://rust-lang.org\"}' \\\n 127.0.0.1:8080/add\n```", "```rs\ncurl 127.0.0.1:8080/links\n```", "```rs\ncurl -X DELETE 127.0.0.1:8080/rm?id=1\n```"]