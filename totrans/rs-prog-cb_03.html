<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing Projects with Cargo</h1>
                </header>
            
            <article>
                
<p><kbd>cargo</kbd> <span class="fontstyle0">is one of the unique selling points of Rust. It makes a developer's life easy by making the creating, developing, packaging, maintaining, testing, and deploying of application code or tools to production considerably more enjoyable. </span><kbd>cargo</kbd><span> </span>is designed to be the single go-to tool for working on any type of Rust project across multiple stages such as the following:</p>
<ul>
<li>Project creation and management</li>
<li>Configuring and executing builds</li>
<li>Dependency installation and maintenance</li>
<li>Testing</li>
<li>Benchmarking</li>
<li>Interfacing with other tools</li>
<li>Packaging and publishing</li>
</ul>
<p>Especially in the domain of systems programming, tools such as <kbd>cargo</kbd> are still rare—which is why many large-scale users developed their own versions. As a young language, Rust draws from the aspects that other tools got right: the <span>versatility and central repository of </span><kbd>npm</kbd> (for Node.js), the <span>ease of use of </span><kbd>pip</kbd> (for Python), and many more. In the end, <kbd>cargo</kbd> provides many great ways to enhance the Rust experience and has been cited as a major influence for developers who want to adopt the language.</p>
<p>In this chapter, we cover recipes that enable developers to utilize all of the features of <kbd>cargo</kbd> to create production-grade Rust projects. These fundamental recipes serve as building blocks for referencing dependencies, adjusting compiler behavior, customizing tools, and many more things that are common in everyday Rust development. </p>
<p class="mce-root"/>
<p><span>In this chapter, we will cover the following</span> recipes<span>:</span></p>
<ul>
<li><span>Organizing large projects with workspaces</span></li>
<li><span>Uploading to</span> <kbd>crates.io</kbd> (<a href="https://crates.io">https://crates.io</a>)</li>
<li><span>Using dependencies and external crates</span></li>
<li><span>Extending <kbd>cargo</kbd> with sub-commands</span></li>
<li><span>Testing your project with <kbd>cargo</kbd></span></li>
<li><span>Continuous integration with <kbd>cargo</kbd></span></li>
<li>Customizing the build</li>
</ul>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Organizing large projects with workspaces</h1>
                </header>
            
            <article>
                
<p class="mce-root">Creating a single project is easy: run <kbd>cargo new my-crate</kbd> and it's done. <kbd>cargo</kbd> creates everything from folder structure to a small source file (or unit test) in a breeze. However, what about larger projects consisting of multiple smaller crates and an executable? Or just a collection of related libraries? The <kbd>cargo</kbd> tool's answer to this is called <strong>workspaces</strong>. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to create your own workspace to manage multiple projects:</p>
<ol>
<li class="mce-root"><span>In a Terminal window (Windows PowerShell or a Terminal on macOS/Linux), change to a directory that will hold the workspace by running these commands: </span></li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ mkdir -p my-workspace</strong><br/><strong>$ cd my-workspace</strong></pre>
<ol start="2">
<li>Use the <kbd>cargo new</kbd> command followed by its name to create a project:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo new a-project</strong><br/>     Created binary (application) `a-project` package</pre>
<ol start="3">
<li>Since we are talking about multiple projects, let's add another library project that we can use:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo new a-lib --lib</strong><br/>     Created library `a-lib` package</pre>
<ol start="4">
<li>Edit <kbd>a-project/src/main.rs</kbd> to contain the following code:</li>
</ol>
<pre style="padding-left: 60px">use a_lib::stringify;<br/>use rand::prelude::*;<br/><br/>fn main() {<br/>    println!("{{ \"values\": {}, \"sensor\": {} }}", stringify(&amp;vec![random::&lt;f64&gt;(); 6]), stringify(&amp;"temperature"));<br/>}</pre>
<ol start="5">
<li>Then, add some code to <kbd>a-lib/src/lib.rs</kbd> that will <kbd>stringify</kbd> (using the <kbd>Debug</kbd> trait) an incoming variable. Obviously, that also needs some tests to show that the function works. Let's add some tests to compare the outputs of number formatting and sequence formatting with <kbd>stringify</kbd>:</li>
</ol>
<pre style="padding-left: 60px">use std::fmt::Debug;<br/><br/>pub fn stringify&lt;T: Debug&gt;(v: &amp;T) -&gt; String {<br/>    format!("{:#?}", v)<br/>}<br/><br/>#[cfg(test)]<br/>mod tests {<br/>    use rand::prelude::*;<br/>    use super::stringify;<br/>    <br/>    #[test]<br/>    fn test_numbers() { <br/>        let a_nr: f64 = random();<br/>        assert_eq!(stringify(&amp;a_nr), format!("{:#?}", a_nr));<br/>        assert_eq!(stringify(&amp;1i32), "1");<br/>        assert_eq!(stringify(&amp;1usize), "1");<br/>        assert_eq!(stringify(&amp;1u32), "1");<br/>        assert_eq!(stringify(&amp;1i64), "1");<br/>    }<br/><br/>    #[test]<br/>    fn test_sequences() {<br/>        assert_eq!(stringify(&amp;vec![0, 1, 2]), "[\n 0,\n 1,\n <br/>        2,\n]");<br/>        assert_eq!(<br/>            stringify(&amp;(1, 2, 3, 4)),<br/>            "(\n 1,\n 2,\n 3,\n 4,\n)"<br/>        );<br/>    }<br/>}</pre>
<p class="mce-root"/>
<ol start="6">
<li>Let's add some configuration to the <kbd>Cargo.toml</kbd> files of each project to reference dependencies:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cat a-project/Cargo.toml</strong> <br/>[package]<br/>name = "a-project"<br/>version = "0.1.0"<br/>authors = ["&lt;git user email address&gt;"]<br/>edition = "2018"<br/><br/>[dependencies]<br/>a-lib = { path = "../a-lib" }<br/>rand = "0.5"<br/><br/>$ cat a-lib/Cargo.toml <br/>[package]<br/>name = "a-lib"<br/>version = "0.1.0"<br/>authors = ["&lt;git user email address&gt;"]<br/>edition = "2018"<br/><br/>[dev-dependencies]<br/>rand = "*"</pre>
<p style="padding-left: 60px"><kbd>a-project</kbd> now makes use of the <kbd>a-lib</kbd> library, but if we are developing these at the same time, the switching back and forth (for example, for testing <kbd>a-lib</kbd> after changes) will soon become cumbersome. This is where workspaces come in.</p>
<ol start="7">
<li>To use <kbd>cargo</kbd> on both projects at the same time, we have to create <kbd>Cargo.toml</kbd> in <kbd>my-workspace</kbd>, the parent directory of <kbd>a-lib</kbd> and <kbd>a-project</kbd>. It only contains two lines: </li>
</ol>
<pre style="padding-left: 60px">[workspace]<br/><br/>members = [ "a-lib", "a-project" ]</pre>
<ol start="8">
<li>With this file in place, <kbd>cargo</kbd> can execute commands on both projects simultaneously and thereby make handling them easier. Let's compile <kbd>cargo test</kbd> and see which tests are run, along with their (test) results:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling a-project v0.1.0 (my-workspace/a-project)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.30s<br/>     Running target/debug/deps/a_lib-bfd9c3226a734f51<br/><br/>running 2 tests<br/>test tests::test_sequences ... ok<br/>test tests::test_numbers ... ok<br/><br/>test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>     Running target/debug/deps/a_project-914dbee1e8606741<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests a-lib<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<ol start="9">
<li>As there is only one project that has tests (<kbd>a-lib</kbd>), it runs those. Let's compile <kbd>cargo run</kbd> to see the output of running the binary executable project:</li>
</ol>
<pre style="padding-left: 60px"><strong>$  cargo run</strong><br/>   Compiling a-project v0.1.0 (my-workspace/a-project)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.41s<br/>     Running `target/debug/a-project`<br/>{ "values": [<br/>    0.6798204591148014,<br/>    0.6798204591148014,<br/>    0.6798204591148014,<br/>    0.6798204591148014,<br/>    0.6798204591148014,<br/>    0.6798204591148014,<br/>], "sensor": "temperature" }</pre>
<div>
<p>Now, let's go behind the scenes to understand the code better.</p>
</div>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a simple binary project (<em>step 2</em> and <em>step 4</em>) together with a library project (<em>step 3</em> and <em>step 5</em>) that depend on each other. We simply specify these dependencies in their <kbd>Cargo.toml</kbd> files in <em>step 6</em> and the workspace we created in <em>step 7</em> helps us to join the projects together. Now, any commands are run on the projects that support them.</p>
<p class="mce-root"/>
<p>By building this project (with<span> </span><kbd>cargo run</kbd>,<span> </span><kbd>cargo test</kbd>, or<span> </span><kbd>cargo build</kbd>), the tool creates a file containing the current dependency tree (called<span> </span><kbd>Cargo.lock</kbd>). As a workspace, the output directory for the binaries (<kbd>target/</kbd>)<span> is also located </span>in the workspace directory instead of the individual projects' directories. <span>Let's check the contents of the directories to see what that looks like and where the compiled output can be found </span>(emphasis has been added to the code):</p>
<pre><strong>$ ls -alh</strong><br/>total 28K<br/>drwxr-xr-x. 5 cm cm 4.0K Apr 11 17:29 ./<br/>drwx------. 63 cm cm 4.0K Apr 10 12:06 ../<br/>drwxr-xr-x. 4 cm cm 4.0K Apr 10 00:42 a-lib/<br/>drwxr-xr-x. 4 cm cm 4.0K Apr 11 17:28 a-project/<br/>-rw-r--r--. 1 cm cm 187 Apr 11 00:05 Cargo.lock<br/>-rw-r--r--. 1 cm cm 48 Apr 11 00:05 Cargo.toml<br/>drwxr-xr-x. 3 cm cm 4.0K Apr 11 17:29 target/<br/><br/><strong>$ ls -alh target/debug/</strong><br/>total 1.7M<br/>drwxr-xr-x. 8 cm cm 4.0K Apr 11 17:31 ./<br/>drwxr-xr-x. 3 cm cm 4.0K Apr 11 17:31 ../<br/><strong>-rwxr-xr-x. 2 cm cm 1.7M Apr 11 17:31 a-project*</strong><br/>-rw-r--r--. 1 cm cm 90 Apr 11 17:31 a-project.d<br/>drwxr-xr-x. 2 cm cm 4.0K Apr 11 17:31 build/<br/>-rw-r--r--. 1 cm cm 0 Apr 11 17:31 .cargo-lock<br/>drwxr-xr-x. 2 cm cm 4.0K Apr 11 17:31 deps/<br/>drwxr-xr-x. 2 cm cm 4.0K Apr 11 17:31 examples/<br/>drwxr-xr-x. 4 cm cm 4.0K Apr 11 17:31 .fingerprint/<br/>drwxr-xr-x. 4 cm cm 4.0K Apr 11 17:31 incremental/<br/>-rw-r--r--. 1 cm cm 89 Apr 11 17:31 liba_lib.d<br/><strong>-rw-r--r--. 2 cm cm 3.9K Apr 11 17:31 liba_lib.rlib</strong><br/>drwxr-xr-x. 2 cm cm 4.0K Apr 11 17:31 native/</pre>
<p>Another aspect of workspaces is its dependency management. <kbd>cargo</kbd> synchronizes the external project dependencies inside the<span> </span><kbd>Cargo.lock</kbd><span> </span>file for every project contained within that workspace. As a result, any external crate will have the same version across every project <span>whenever possible</span>. When we added the<span> </span><kbd>rand</kbd><span> </span>crate as a dependency, it picked the same version for both projects (because of the <kbd>*</kbd> version in<span> </span><kbd>a-lib</kbd>). Here's part of the resulting<span> </span><kbd>Cargo.lock</kbd> file:</p>
<pre># This file is automatically @generated by Cargo.<br/># It is not intended for manual editing.<br/>[[package]]<br/>name = "a-lib"<br/>version = "0.1.0"<br/>dependencies = [<br/> "rand 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)",<br/>]<br/><br/>[[package]]<br/>name = "a-project"<br/>version = "0.1.0"<br/>dependencies = [<br/> "a-lib 0.1.0",<br/> "rand 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)",<br/>]<br/>[...]</pre>
<p><kbd>cargo</kbd> workspaces are a way to handle larger projects by bundling some operations at a higher level while leaving most configurations to the individual crates and applications. The configuration is simple and results in predictable behavior that lets the user build processes around it (for example, collecting all binaries from the workspace's <kbd>target/</kbd> directory).</p>
<p>Another interesting aspect is that <kbd>cargo</kbd> travels upward to find the most parental <kbd>Cargo.toml</kbd> file before executing a command. Therefore, what seems like the running of the tests of a specific project from within its directory results in the running of <em>all</em><strong> </strong>tests of that workspace. Consequently, the commands have to be more specific now, for example, by using <kbd>cargo test -p a-lib</kbd>. </p>
<p class="mce-root"><span>W</span><span>e've successfully learned how to organize large projects with workspaces.</span> <span>Now, let's move on to the next recipe!</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Uploading to crates.io</h1>
                </header>
            
            <article>
                
<p><kbd>crates.io</kbd> (<a href="https://crates.io">https://crates.io</a>)<span> </span>is Rust's public repository for community crates. This links dependencies together, enables discovery, and lets users search for packages. For crate maintainers, it offers usage statistics and a place to host a <kbd>readme</kbd> file. <kbd>cargo</kbd> makes it possible to publish crates quickly and easily, as well as to handle updates. Let's see how.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we are going to publish a crate with minimal functionality. If you already have source code to work on (that is, your own project), feel free to use it. If not, create a new library project using <kbd>cargo new public-crate --lib</kbd> and open it in VS Code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b58444be-9d0c-4649-acaf-818c87121c82.png"/></p>
<p>Go to <a href="https://crates.io">https://crates.io</a> and log in to your account (using <a href="https://github.com">https://github.com</a>). Then, go to the <span class="packt_screen">Account Settings</span> page to create a new token (follow the instructions on the page). Log in on the command line using your own token:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/9708bf28-ce3c-45cf-926c-5883bbb35916.png"/></p>
<p class="mce-root"/>
<p>Let's take a look at the steps we need to perform to upload to <kbd>crates.io</kbd> (<a href="https://crates.io">https://crates.io</a>).</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>With <kbd>cargo</kbd> logged in and ready to go, follow these steps to publish <span>the library to the repository</span>:</p>
<ol>
<li>Open <kbd>src/lib.rs</kbd> and add some code. The crate in our recipe is only going to publish the infamous bubble sort algorithm!</li>
</ol>
<div class="packt_infobox"><span>At the moment, </span><kbd>crates.io</kbd><span> only uses names as identifiers, which means that you can't use the name </span><kbd>bubble-sort</kbd><span> any longer. However, instead of choosing a new name, we ask you not to publish a copy of this crate under a different name but focus your efforts on crates that are useful to the community. </span></div>
<p style="padding-left: 60px">Here is an implementation from the book <em>Hands-On Data Structures and Algorithms with Rust</em> (<a href="https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust">https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust</a>):</p>
<pre style="padding-left: 60px">//! This is a non-optimized implementation of the [bubble sort]<span> </span>algorithm for the book Rust Cookbook by Packt. This implementation also clones the input vector. <br/>//! <br/>//! # Examples<br/>//!```<br/>//!# use bubble_sort::bubble_sort;<br/>//! let v = vec![2, 2, 10, 1, 5, 4, 3]; <br/>//! assert_eq!(bubble_sort(&amp;v), vec![1, 2, 2, 3, 4, 5, 10]);<br/>//!```<br/><br/>///<br/>/// See module level documentation. <br/>/// <br/>pub fn bubble_sort&lt;T: PartialOrd + Clone&gt;(collection: &amp;[T]) -&gt; Vec&lt;T&gt; {<br/>    let mut result: Vec&lt;T&gt; = collection.into();<br/>    for _ in 0..result.len() {<br/>        let mut swaps = 0;<br/>        for i in 1..result.len() {<br/>            if result[i - 1] &gt; result[i] {<br/>                result.swap(i - 1, i);<br/>                swaps += 1;<br/>            }<br/>        }<br/>        if swaps == 0 {<br/>            break;<br/>        }<br/>    }<br/>    result<br/>}</pre>
<p style="padding-left: 60px">This implementation also comes with tests:</p>
<pre style="padding-left: 60px">#[cfg(test)]<br/>mod tests {<br/>    use super::bubble_sort;<br/>     #[test]<br/>    fn test_bubble_sort() {<br/>        assert_eq!(bubble_sort(&amp;vec![9, 8, 7, 6]), vec![6, 7, 8, <br/>         9]);<br/>        assert_eq!(bubble_sort(&amp;vec![9_f32, 8_f32, 7_f32, 6_f32]), <br/>         vec!<br/>        [6_f32, 7_f32, 8_f32, 9_f32]);<br/><br/>        assert_eq!(bubble_sort(&amp;vec!['c','f','a','x']), vec!['a', <br/>         'c', 'f', 'x']);<br/><br/>        assert_eq!(bubble_sort(&amp;vec![6, 8, 7, 9]), vec![6, 7, 8, <br/>         9]);<br/>        assert_eq!(bubble_sort(&amp;vec![2, 1, 1, 1, 1]), vec![1, 1, 1, <br/>         1, 2]);<br/>    }<br/>}</pre>
<ol start="2">
<li>Additionally, <kbd>cargo</kbd> makes it possible to customize the landing page on <kbd>crates.io</kbd> using various fields in <kbd>Cargo.toml</kbd>. The landing page should inform the crate's users about the license (no license means everybody has to get your permission to use the code), where to find more information, and maybe even an example. On top of that, (quite fancy) badges provide information about the crate's build status, test coverage, and so on. Replace the content of <kbd>Cargo.toml</kbd> with the following snippet (and customize it if you want):</li>
</ol>
<pre style="padding-left: 60px">[package]<br/>name = "bubble-sort"<br/>description = "A quick and non-optimized, cloning version of the bubble sort algorithm. Created as a showcase for publishing crates in the Rust Cookbook 2018"<br/>version = "0.1.0"<br/>authors = ["Claus Matzinger &lt;claus.matzinger+kb@gmail.com&gt;"]<br/>edition = "2018"<br/>homepage = "https://blog.x5ff.xyz"<br/>repository = "https://github.com/PacktPublishing/Rust-<br/>              Programming-Cookbook"<br/>license = "MIT"<br/>categories = [<br/>    "Algorithms", <br/>    "Support"<br/>]<br/>keywords = [<br/>    "cookbook",<br/>    "packt",<br/>    "x5ff", <br/>    "bubble",<br/>    "sort",<br/>]<br/>readme = "README.md"<br/>maintenance = { status = "experimental" }</pre>
<ol start="3">
<li class="mce-root">Now t<span>hat all of the metadata is sorted out, let's run</span> <kbd>cargo package</kbd> <span>to see whether the package fulfills the formal criteria:</span></li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ cargo package</strong><br/>error: 2 files in the working directory contain changes that were not yet committed into git:<br/><br/>Cargo.toml<br/>README.md<br/><br/>to proceed despite this, pass the `--allow-dirty` flag</pre>
<ol start="4">
<li>As a friendly reminder, <kbd>cargo</kbd> makes sure that only committed changes are packaged, so the repository and <kbd>crates.io</kbd> are in sync. Commit the changes (read up on Git if you don't know how: <a href="https://git-scm.com">https://git-scm.com</a>) and re-run <kbd>cargo package</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo package</strong><br/>   Packaging bubble-sort v0.1.0 (publish-crate)<br/>   Verifying bubble-sort v0.1.0 (publish-crate)<br/>   Compiling bubble-sort v0.1.0 (publish-<br/>   crate/target/package/bubble-sort-0.1.0)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.68s</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="5">
<li>Now, with an authorized <kbd>cargo</kbd>, let's make our crate public and run <kbd>cargo publish</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong> $ cargo publish</strong><br/>    Updating crates.io index<br/>    Packaging bubble-sort v0.2.0 (Rust-Cookbook/Chapter03/publish-<br/>    crate)<br/>   Verifying bubble-sort v0.2.0 (Rust-Cookbook/Chapter03/publish-<br/>    crate)<br/>   Compiling bubble-sort v0.2.0 (Rust-Cookbook/Chapter03/publish-<br/>   crate/target/package/bubble-sort-0.2.0)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 6.09s<br/>   Uploading bubble-sort v0.2.0 (Rust-Cookbook/Chapter03/publish-<br/>    crate)</pre>
<ol start="6">
<li>Once successful, check out your page at <a href="https://crates.io/crates/bubble-sort">https://crates.io/crates/bubble-sort</a>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/be51839e-e481-488c-b536-9b8fbb9b3e4a.png"/></p>
<p class="mce-root"><span>Now, let's go behind the scenes to understand the code better.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Publishing crates is a great way to get recognized by the Rust community and make whatever you are creating available to a wider audience. For the community to be able to quickly adapt your crate, be sure to use appropriate keywords and categories, as well as examples and tests to make it clear and easy to use, something that we did in <em>step 1</em> and <em>step 2</em>. <kbd>Cargo.toml</kbd> provides many more options than specified previously, so check out the documentation, <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata">https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata</a>,<span> to find out more. </span></p>
<p><span>The most important property in that file is the package name, which uniquely identifies the crate. While there have been incidents on name squatting and selling names, this is generally frowned upon and the community strives to find a solution to that. </span></p>
<p>Once packaged (<em>step 3</em> and <em>step 4</em>), <kbd>cargo</kbd> creates a <kbd>target/package</kbd> <span>directory, </span>which contains everything that will be uploaded to <kbd>crates.io</kbd>. Inside, there is not only the source code but also an additional binary file named <span><kbd>project_name-version.crate</kbd>. If you don't want to upload everything—for example, leaving out videos or large example data—<kbd>Cargo.toml</kbd> allows for exclusion filters as well. By default, everything in the directory is included, but it is good practice to keep the size to a minimum!</span></p>
<div class="packt_tip"><span>Keep your API tokens secret and out of source control. If you are not sure whether a token has been compromised, revoke it!</span></div>
<p>In <em>step 5</em>, we are uploading the new crate. However, <kbd>crates.io</kbd> does not accept just any upload; here are some examples of the errors you might encounter (observe the error messages to fix them):</p>
<pre>error: api errors (status 200 OK): crate version `0.1.0` is already uploaded<br/>error: api errors (status 200 OK): invalid upload request: invalid length 6, expected at most 5 keywords per crate at line 1 column 667<br/>error: 1 files in the working directory contain changes that were not yet committed into git:<br/>error: api errors (status 200 OK): A verified email address is required to publish crates to crates.io. Visit https://crates.io/me to set and verify your email address.</pre>
<p>These are actually great notifications since these barriers help programmers to avoid simple mistakes, reduce spam, and thereby raise quality. If you follow those terms, you'll easily see a version of the step 6 page for your own project. </p>
<p class="mce-root"/>
<p><span>W</span><span>e've successfully learned how to upload to <a href="https://crates.io">https://crates.io</a>. Now, let's move on to the next recipe!</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using dependencies and external crates</h1>
                </header>
            
            <article>
                
<p>Reusing other libraries is a common task in software engineering, which is why easy dependency management was built into <kbd>cargo</kbd> from the start. Third-party dependencies (called <strong>crates</strong>) are stored in a registry called <kbd>crates.io</kbd> (<a href="https://crates.io">https://crates.io</a>), a public platform for users to find and discover crates. Private registries are also available, starting with Rust 1.34. With <kbd>Cargo.toml</kbd> as a central point in this process, let's dive into specifying those dependencies well. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's see how dependency management works in these steps: </p>
<ol>
<li><span>As we are going to print on the command line, let's create a new binary application using </span><kbd>cargo new external-deps</kbd><span> and open it in VS Code.</span></li>
<li>Open the <kbd>Cargo.toml</kbd><span> file to add some dependencies:</span></li>
</ol>
<pre style="padding-left: 60px">[package]<br/>name = "external-deps"<br/>version = "0.1.0"<br/>authors = ["Claus Matzinger &lt;claus.matzinger+kb@gmail.com&gt;"]<br/>edition = "2018"<br/><br/>[dependencies]<br/>regex = { git = "https://github.com/rust-lang/regex" } # bleeding edge libraries<br/><br/># specifying crate features<br/>serde = { version = "1", features = ["derive"] }<br/>serde_json = "*" # pick whatever version<br/><br/><br/>[dev-dependencies]<br/>criterion = "0.2.11"<br/><br/><br/>[[bench]]<br/>name = "cooking_with_rust"<br/>harness = false</pre>
<ol start="3">
<li>With these added, we need to add some code to the <kbd>src/main.rs</kbd> file as well: </li>
</ol>
<pre style="padding-left: 60px">use regex::Regex;<br/>use serde::Serialize;<br/><br/>#[derive(Serialize)]<br/>struct Person {<br/>    pub full_name: String,<br/>    pub call_me: String,<br/>    pub age: usize,<br/>}<br/><br/>fn main() {<br/>    let a_person = Person {<br/>        full_name: "John Smith".to_owned(),<br/>        call_me: "Smithy".to_owned(),<br/>        age: 42,<br/>    };<br/>    let serialized = serde_json::to_string(&amp;a_person).unwrap();<br/>    println!("A serialized Person instance: {}", serialized);<br/><br/>    let re = Regex::new(r"(?x)(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{2})-(?<br/>    P&lt;day&gt;\d{2})").unwrap();<br/>    println!("Some regex parsing:");<br/>    let d = "2019-01-31";<br/>    println!(" Is {} valid? {}", d, re.captures(d).is_some());<br/>    let d = "9999-99-00";<br/>    println!(" Is {} valid? {}", d, re.captures(d).is_some());<br/>    let d = "2019-1-10";<br/>    println!(" Is {} valid? {}", d, re.captures(d).is_some());<br/>}</pre>
<ol start="4">
<li>Then, there is <kbd>dev-dependency</kbd>, which we can use to create benchmarks with the stable Rust compiler. For that, create a new folder on the same level as <kbd>src/</kbd> and add a file, <kbd>cooking_with_rust.rs</kbd>, there. Open it in VS Code and add the following code to run a benchmark:</li>
</ol>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate criterion;<br/><br/>use criterion::black_box;<br/>use criterion::Criterion;<br/><br/>pub fn bubble_sort&lt;T: PartialOrd + Clone&gt;(collection: &amp;[T]) -&gt; Vec&lt;T&gt; {<br/>    let mut result: Vec&lt;T&gt; = collection.into();<br/>    for _ in 0..result.len() {<br/>        let mut swaps = 0;<br/>        for i in 1..result.len() {<br/>            if result[i - 1] &gt; result[i] {<br/>                result.swap(i - 1, i);<br/>                swaps += 1;<br/>            }<br/>        }<br/>        if swaps == 0 {<br/>            break;<br/>        }<br/>    }<br/>    result<br/>}<br/><br/>fn bench_bubble_sort_1k_asc(c: &amp;mut Criterion) {<br/>    c.bench_function("Bubble sort 1k descending numbers", |b| {<br/>        let items: Vec&lt;i32&gt; = (0..1_000).rev().collect();<br/>        b.iter(|| black_box(bubble_sort(&amp;items)))<br/>    });<br/>}<br/><br/>criterion_group!(benches, bench_bubble_sort_1k_asc);<br/>criterion_main!(benches);</pre>
<ol start="5">
<li>Now, let's use these dependencies and see how <kbd>cargo</kbd> integrates them. Let's execute <kbd>cargo run</kbd> first:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling proc-macro2 v0.4.27<br/>   Compiling unicode-xid v0.1.0<br/>   Compiling syn v0.15.30<br/>   Compiling libc v0.2.51<br/>   Compiling memchr v2.2.0<br/>   Compiling ryu v0.2.7<br/>   Compiling serde v1.0.90<br/>   Compiling ucd-util v0.1.3<br/>   Compiling lazy_static v1.3.0<br/>   Compiling regex v1.1.5 (https://github.com/rust-<br/>    lang/regex#9687986d)<br/>   Compiling utf8-ranges v1.0.2<br/>   Compiling itoa v0.4.3<br/>   Compiling regex-syntax v0.6.6 (https://github.com/rust-<br/>    lang/regex#9687986d)<br/>   Compiling thread_local v0.3.6<br/>   Compiling quote v0.6.12<br/>   Compiling aho-corasick v0.7.3<br/>   Compiling serde_derive v1.0.90<br/>   Compiling serde_json v1.0.39<br/>   Compiling external-deps v0.1.0 (Rust-Cookbook<br/>    /Chapter03/external-deps)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 24.56s<br/>     Running `target/debug/external-deps`<br/>A serialized Person instance: {"full_name":"John Smith","call_me":"Smithy","age":42}<br/>Some regex parsing:<br/>  Is 2019-01-31 valid? true<br/>  Is 9999-99-00 valid? true<br/>  Is 2019-1-10 valid? false</pre>
<ol start="6">
<li>It downloaded and compiled various crates (the download part was omitted as it is only done once)—but can you spot what's missing? It's the <kbd>criterion</kbd> crate that was specified as <kbd>dev-dependency</kbd>, and it's only required for development (<kbd>test/bench/..</kbd>) operations. Let's run <kbd>cargo bench</kbd> to see benchmark results of the crate, including some basic trends provided by <kbd>criterion</kbd> (output redacted):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo bench</strong><br/>   Compiling proc-macro2 v0.4.27<br/>   Compiling unicode-xid v0.1.0<br/>   Compiling arrayvec v0.4.10<br/>   [...]<br/>   Compiling tinytemplate v1.0.1<br/>   Compiling external-deps v0.1.0 (Rust-Cookbook<br/>    /Chapter03/external-deps)<br/><strong>   Compiling criterion v0.2.11</strong><br/>    Finished release [optimized] target(s) in 1m 32s<br/>     Running target/release/deps/external_deps-09d742c8de9a2cc7<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>     Running target/release/deps/cooking_with_rust-b879dc4675a42592<br/>Gnuplot not found, disabling plotting<br/>Bubble sort 1k descending numbers <br/>                        time: [921.90 us 924.39 us 927.17 us]<br/>Found 12 outliers among 100 measurements (12.00%)<br/>  6 (6.00%) high mild<br/>  6 (6.00%) high severe<br/><br/>Gnuplot not found, disabling plotting</pre>
<div>
<p>Now, let's go behind the scenes to understand the code better.</p>
</div>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>By specifying the version and name in <kbd>Cargo.toml</kbd>, <kbd>cargo</kbd> can download and compile the required crates and link them into the project as needed. In fact, <kbd>cargo</kbd> maintains a cache for both crates on <kbd>crates.io</kbd> and raw <kbd>git</kbd> dependencies (check the <kbd>~/.cargo</kbd> directory), where it puts recently used crates. This is exactly what we did in the first steps by adding dependencies of mixed origin to the crate.</p>
<p>One of these origins is a  <kbd>git</kbd> repository, but can alternatively take the shape of local paths to directories. Additionally, by passing an object (as seen in the <kbd>regex</kbd> crate in <em>step 1</em>), we can specify features for a crate (as shown in the <kbd>serde</kbd> dependency in <em>step 1</em>) or use an entire section called <kbd>dev-dependencies</kbd> for dependencies that are not shipped in the target output. The result is a dependency tree that is serialized in <kbd>Cargo.lock</kbd>. The use of the <kbd>dev-dependency</kbd> criterion is shown in <em>step 6</em>. The remaining steps show how to use external dependencies and the various versions downloaded and compiled by <kbd>cargo</kbd>. </p>
<p>The version specification in <kbd>Cargo.toml</kbd> is its own mini-language, and it will only upgrade with certain restrictions: </p>
<ul>
<li>A single number specifies the major version (a pattern of <kbd>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</kbd> is mandatory in Rust) but leaves the others open for <kbd>cargo</kbd> to decide (usually the latest version)</li>
<li>More accurate versions leave less room for interpretation</li>
<li><kbd>*</kbd> means any available version, with the latest preferred</li>
</ul>
<p>There are more characters and symbols to put into the version string, yet these will typically suffice. Check out <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html</a> for more examples. The <kbd>cargo upgrade</kbd> <span>command </span>will also check for the latest versions the specification allows and update them accordingly. If you plan to build a crate that is used by others, it's recommended to run <kbd>cargo upgrade</kbd> every once in a while to see it didn't miss any security/patch updates. The Rust project even recommends putting the <kbd>Cargo.lock</kbd> file in source control to avoid unintentionally breaking the crate.</p>
<div class="packt_tip">It is good practice to minimize the number of required crates and to keep them as up to date as possible. Your users will want to do the same.</div>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also...</h1>
                </header>
            
            <article>
                
<p>With 1.34, Rust also allows private repositories. Read more about this on the following blog post: <a href="https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#alternative-cargo-registries">https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#alternative-cargo-registries</a>. <span>W</span><span>e've now successfully learned how to use dependencies and external crates. Now, let's move on to the next recipe!</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Extending cargo with sub-commands</h1>
                </header>
            
            <article>
                
<p>These days, everything is extensible. Whether they are called plugins, extensions, add-ons, or sub-commands—everything is about customizing the (developer) experience. <kbd>cargo</kbd> provides a very easy path to achieve this: by using a binary's name. This allows for quickly extending the <kbd>cargo</kbd> base to include functions that are specific to your own use case or way of working. In this recipe, we are going to build <span>our own extension</span>. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we will stay on the command line and we will use a sample code for a simple binary, so open a Terminal/PowerShell (we are using PowerShell features on Windows) to run the commands in this recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Extending <kbd>cargo</kbd> is surprisingly easy. To do this, perform the following steps:</p>
<ol>
<li>Create a new Rust binary application project with the following command: <kbd>cargo new cargo-hello</kbd>.</li>
<li>Change into the directory with <kbd>cd cargo-hello</kbd> and build it using <kbd>cargo build</kbd>.</li>
<li>Add the <kbd>target<span>/</span>debug</kbd> <span>folder of the current project that is located at your</span> <kbd>PATH</kbd> <span>variable. </span>On Linux and Mac (using bash), it's simply as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>export PATH=$PATH:/path/to/cargo-hello/target/debug</strong></pre>
<p style="padding-left: 60px" class="mce-root"><span>On Windows, you can use</span> PowerShell <span>to achieve the same goal with this code script:</span></p>
<pre style="padding-left: 60px"><strong>$env:Path += ";C:/path/to/cargo-hello/target/debug"</strong></pre>
<ol start="4">
<li>Within the same window, you should now be able to run <kbd>cargo-hello</kbd><span> (<kbd>cargo-hello.exe</kbd> on Windows) from any directory on the computer.</span></li>
<li>Additionally, <kbd>cargo</kbd> <span>can now run <kbd>hello</kbd> as a sub-command. Try running</span> <kbd>cargo hello</kbd> <span>in any directory on the computer. From here, you will see the following output:</span></li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ cargo hello</strong><br/>Hello, world!</pre>
<p class="mce-root"><span>Now let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>cargo</kbd> picks up any executable starting with <kbd>cargo-</kbd> that's available in the <kbd>PATH</kbd> environment variable. Directories listed in there are used to discover command-line executables in *nix systems.</p>
<p>For <kbd>cargo</kbd> to integrate these extensions seamlessly, their names have to meet a few conditions: </p>
<ul>
<li><span>These binaries</span> have to be executable on the current platform</li>
<li>The name starts with <kbd>cargo-</kbd></li>
<li>The containing folder is listed in the <kbd>PATH</kbd> variable</li>
</ul>
<p class="mce-root">On Linux/macOS, these executables can also be shell scripts—something that's very useful for improving the developer workflow. However, these scripts have to look just like a binary and therefore have no file ending. Then, instead of running several commands, such as <kbd>cargo publish</kbd>, <kbd>git tag</kbd>, and <kbd>git push</kbd>, <kbd>cargo shipit</kbd> can significantly improve speed and consistency. </p>
<p class="mce-root">Additionally, any <kbd>cargo</kbd> sub-command can take command-line arguments that are passed after the command, and the working directory is the directory the command is run from by default. With that knowledge, we hope that you can now add to <kbd>cargo</kbd> features!</p>
<p><span>W</span><span>e've successfully learned how to extend cargo with sub-commands. Now, let's move on to the next recipe!</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing your project with cargo</h1>
                </header>
            
            <article>
                
<p>While in a previous recipe we focused on writing tests, this recipe is about <em>running </em>them. Tests are an important part of software engineering since it ensures that we put ourselves in the user's shoes and double-checked to see whether what we created is working. While many other languages require a separate test-runner, <kbd>cargo</kbd> comes with this functionality included!</p>
<p>Let's explore how <kbd>cargo</kbd> helps with this process in this recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To explore <kbd>cargo</kbd> testing capabilities, follow these steps:</p>
<ol>
<li>Create a new project on the command line with <kbd>cargo new test-commands --lib</kbd> and open the resulting folder in VS Code.</li>
<li>Next, replace the content in <kbd>src/lib.rs</kbd> <span>with the following:</span></li>
</ol>
<pre style="padding-left: 60px">#[cfg(test)]<br/>mod tests {<br/><br/>    use std::thread::sleep;<br/>    use std::time::Duration;<br/><br/>    #[test]<br/>    fn it_works() {<br/>        assert_eq!(2 + 2, 4);<br/>    }<br/><br/>    #[test]<br/>    fn wait_10secs() {<br/>        sleep(Duration::from_secs(10));<br/>        println!("Waited for 10 seconds");<br/>        assert_eq!(2 + 2, 4);<br/>    }<br/><br/>    #[test]<br/>    fn wait_5secs() {<br/>        sleep(Duration::from_secs(5));<br/>        println!("Waited for 5 seconds");<br/>        assert_eq!(2 + 2, 4);<br/>    }<br/><br/>        #[test]<br/>    #[ignore]<br/>    fn ignored() {<br/>        assert_eq!(2 + 2, 4);<br/>    }<br/>}</pre>
<ol start="3">
<li>As we did in other recipes, we can execute all tests with the <kbd>cargo test</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling test-commands v0.1.0 (Rust-Cookbook/Chapter03/test-<br/>    commands)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.37s<br/>     Running target/debug/deps/test_commands-06e02dadda81dfcd<br/><br/>running 4 tests<br/>test tests::ignored ... ignored<br/>test tests::it_works ... ok<br/>test tests::wait_5secs ... ok<br/>test tests::wait_10secs ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests test-commands<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<ol start="4">
<li>To iterate quickly, <kbd>cargo</kbd> allows us to carry out a specific test as well by using <kbd>cargo test &lt;test-name&gt;</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test tests::it_works</strong><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.05s<br/>     Running target/debug/deps/test_commands-06e02dadda81dfcd<br/><br/>running 1 test<br/>test tests::it_works ... ok<br/><br/>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 3 filtered out</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li>Another useful way to run tests is without capturing their output. By default, the testing harness won't print anything from inside the tests. Sometimes, it's useful to have some testing output, so let's use <kbd>cargo test -- --nocapture</kbd> to see the output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test -- --nocapture</strong><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.01s<br/>     Running target/debug/deps/test_commands-06e02dadda81dfcd<br/><br/>running 4 tests<br/>test tests::ignored ... ignored<br/>test tests::it_works ... ok<br/>Waited for 5 seconds<br/>test tests::wait_5secs ... ok<br/>Waited for 10 seconds<br/>test tests::wait_10secs ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests test-commands<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<ol start="6">
<li>All tests are run in parallel, which sometimes leads to unexpected results. To adjust this behavior, we can use <kbd>cargo test -- --test-threads &lt;no-of-threads&gt;</kbd> to control the number of threads. Let's compare using four threads and one thread to see the difference. We will use the <kbd>time</kbd> program to show the runtime in seconds (this is optional if you don't have <kbd>time</kbd>). Let's start with four:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ time -f "%e" cargo test -- --test-threads 4</strong><br/>   Compiling test-commands v0.1.0 (/home/cm/workspace/Mine/Rust-<br/>    Cookbook/Chapter03/test-commands)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.35s<br/>     Running target/debug/deps/test_commands-06e02dadda81dfcd<br/><br/>running 4 tests<br/>test tests::ignored ... ignored<br/>test tests::it_works ... ok<br/>test tests::wait_5secs ... ok<br/>test tests::wait_10secs ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests test-commands<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>10.53</pre>
<p style="padding-left: 60px">This is fast, compared to a single thread:</p>
<pre style="padding-left: 60px"><strong>$ time -f "%e" cargo test -- --test-threads 1</strong><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.03s<br/>     Running target/debug/deps/test_commands-06e02dadda81dfcd<br/><br/>running 4 tests<br/>test tests::ignored ... ignored<br/>test tests::it_works ... ok<br/>test tests::wait_10secs ... ok<br/>test tests::wait_5secs ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests test-commands<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>15.17</pre>
<ol start="7">
<li>Lastly, we can also filter multiple tests as well, such as all tests starting with <kbd>wait</kbd>: </li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test wait</strong><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.03s<br/>     Running target/debug/deps/test_commands-06e02dadda81dfcd<br/><br/>running 2 tests<br/>test tests::wait_5secs ... ok<br/>test tests::wait_10secs ... ok</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span>Now, let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Rust's built-in testing library is called <kbd>libtest</kbd> and it is what's invoked by <kbd>cargo</kbd>. Regardless of the type of project created (binary application or library), <kbd>libtest</kbd> runs the associated test and outputs the result. In this recipe, we are examining running the tests of a previously created project—however, these steps obviously work for any project with tests. </p>
<p>In <em>step 2</em>, we created a small library that features four tests, two of which print things to the command line just after waiting for a few seconds (five and ten seconds). This allows us to show threaded test running and that the test harness captures the output by default. </p>
<p>Other than filtering the list of available tests (we do that in <em>step 4</em> and <em>step 7</em>) in the project, <kbd>libtest</kbd> takes command-line arguments to customize the output, logging, threads, and many more things. Find out more by invoking <kbd>cargo test -- --help</kbd>. Note the double dashes (<kbd>--</kbd>), which tell <kbd>cargo</kbd> to pass any following arguments into <kbd>libtest</kbd>.  </p>
<p><span>As the options already indicate: all tests are run in parallel unless stated otherwise, an option that we change in <em>step 6</em> with noticeable results (15 seconds with a single thread versus 10 seconds multi-threaded—just like the longest sleep time). Use this option to debug race conditions or other runtime behavior.</span></p>
<p><span><em>Step 5</em> uses an option to show the standard output, which appears in a different order than how we wrote the test functions. This is the result of concurrent execution, so combining the options to limit the number of threads with the output capture will linearly execute the tests. We conclude the steps by filtering for multiple tests in <em>step 7</em>. </span></p>
<p><span>W</span><span>e've successfully learned how to test our project with <kbd>cargo</kbd>. Now, let's move on to the next recipe!</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Continuous integration with cargo</h1>
                </header>
            
            <article>
                
<p>Automation is an important aspect of today's software engineering. Whether it is infrastructure as code or functions as a service, many things are expected to automatically work as expected. However, the notion of a central testing and deployment infrastructure based on certain rules is much older (called <strong>ALM</strong>—<strong>Application Lifecycle Management</strong>) and with modern tools, it is incredibly easy. <kbd>cargo</kbd> was built to support this stateless infrastructure with reasonable defaults and an easy interface to customize them.</p>
<p>In this recipe, we will take a look at how to build Rust applications using Microsoft's Azure DevOps platform as an example. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>While the Azure DevOps <span>repository </span>(<a href="https://azure.microsoft.com/en-us/services/devops/?nav=min">https://azure.microsoft.com/en-us/services/devops/?nav=min</a>) is accessible for anyone, it is highly recommended to create a Microsoft account and make use of the free tier to reproduce the example. Go to <a href="https://azure.microsoft.com/en-us/services/devops/">https://azure.microsoft.com/en-us/services/devops/</a> and follow the instructions to get started. </p>
<p>To have a ready-made project to work on, we are re-using the <kbd>bubble-sort</kbd> crate from the <em>Uploading to crates.io</em> recipe earlier in this chapter and uploading it to a source code hosting service such as Azure DevOps or GitHub.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">Open a browser window and navigate to <a href="https://dev.azure.com">https://dev.azure.com</a>, sign in, and find the project you created. Then, follow these steps:</p>
<ol>
<li>Azure DevOps is an all-in-one solution for project management, so we are pushing our source code to the available repository. Follow the repository setup guide to do that. </li>
<li>Pipelines are the continuous integration part of Azure DevOps. They orchestrate build agents (machines to run the build on) and provide a visual interface to put together a step-by-step build process. Create a new pipeline from an empty job template:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a59bb95c-6db6-42ee-b3e4-2d2513b95f69.png"/></p>
<ol start="3">
<li>Inside each pipeline, there are several jobs—several steps that run on the same agent, but we only need one. Click on the <span class="packt_screen">+</span> symbol on the right of the predefined <span class="packt_screen">Agent job 1</span> and search for a build task named <kbd>rust</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/33bd03de-388b-418e-ac46-0766828371ea.png"/></p>
<ol start="4">
<li>Since that particular build task is available on the Marketplace (thanks to Sylvain Pontoreau: <a href="https://github.com/spontoreau/rust-azure-devops">https://github.com/spontoreau/rust-azure-devops</a>), we have to add it to our project. </li>
</ol>
<ol start="5">
<li>After <em>purchasing</em> (it's free) the task blueprint, we can add and configure it in our pipeline. It's useful to have a build that runs tests, but CI systems are very flexible and you can get very creative. Your screen should now look like this:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b6da739c-d057-4c0f-8309-6eb649c9192b.png"/></p>
<ol start="6">
<li class="CDPAlignLeft CDPAlign">Use the first task as it is (no configuration needed) since it is only installing the tools using <kbd>rustup</kbd>. The second task simply runs <kbd>cargo test</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ae7d5606-cbb9-4d1b-a3c8-62d1eea983b8.png"/></p>
<ol start="7">
<li>As the last step, queue the build and check its progress. If you followed the recipe, it will result in a successful build and you can start using it to check pull requests, add badges on <kbd>crates.io</kbd>, and much more: </li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/73371632-2ab6-4bf1-b5ee-6b1a60e760e6.png"/></p>
<p class="mce-root"><span>Now, let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Azure DevOps is a fully integrated solution for project management, issue tracking, source code hosting, and building and deploying solutions. Similar offerings are GitHub (also owned by Microsoft), GitLab (<a href="https://about.gitlab.com">https://about.gitlab.com</a>), or Atlassian's Bitbucket (<a href="https://bitbucket.org">https://bitbucket.org</a>). Together with CircleCI (<a href="https://circleci.com">https://circleci.com</a>) or Travis CI (<a href="https://travis-ci.org/">https://travis-ci.org/</a>), these platforms offer powerful tools for teams to make sure that every new deployment reliably meets their goals without large management overhead.</p>
<p>The basic idea is simple: by making the build work on a neutral platform, most of the obvious mistakes (missing dependencies or relying on environment specifics) can easily be avoided while running the same tests that have to run locally. On top of that, running every test might be demanding on large projects, and dedicated infrastructure takes care of that. </p>
<p class="mce-root"/>
<p>Since computers are notoriously picky, the results of running tests are also visible and can be used to prohibit certain actions, such as deploying to production with failing tests. In a way, a continuous integration system holds the developer accountable to their own rules (tests). </p>
<p><kbd>cargo</kbd> support is implicit by being a good citizen in stateless systems. Instead of failing if certain conditions are not met, it tries to mitigate late terminations and requires little configuration to begin with. Its ability to handle dependencies easily and well adds to that and the support for sub-commands makes it a great way to build across platforms.</p>
<p>Here are some ideas of what you can do besides running <kbd>cargo test</kbd>:</p>
<ul>
<li>Run benchmarks</li>
<li>Run integration tests</li>
<li>Format code</li>
<li>Accept PRs only on successful tests</li>
<li>Generate documentation</li>
<li>Do static code analysis</li>
</ul>
<p>Azure DevOps also supports release pipelines, which should be used for tasks such as publishing to <kbd>crates.io</kbd> (or other package repositories), updating the hosted documentation, and more. Read the Azure DevOps documentation (<a href="https://docs.microsoft.com/en-us/azure/devops/?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/?view=azure-devops</a>) on how to do that. For anyone who prefers YAML (<a href="https://yaml.org/">https://yaml.org/</a>) files to configure CI pipelines, Azure DevOps supports these as well. </p>
<p>Thanks to<span> </span>Sylvain Pontoreau's <span>work </span>(<a href="https://twitter.com/bla">https://twitter.com/bla</a>) on creating easy-to-use task templates, we can quickly set build, test, or other pipelines. Doing it manually can be tricky to get right for every platform and maintaining downloads and shell scripts is a hassle for most developers. If you are using his work, he is happy to hear about it as well—for example, on Twitter (<a href="https://twitter.com/spontoreau">https://twitter.com/spontoreau</a>).</p>
<p><span>W</span><span>e've successfully learned how to continuously integrate with <kbd>cargo</kbd>. Now, let's move on to the next recipe!</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Customizing the build</h1>
                </header>
            
            <article>
                
<p><kbd>cargo</kbd> is versatile—something that we have already established in the previous recipes in this chapter. However, we did not touch configuring the tools <kbd>cargo</kbd> uses to compile and run Rust projects. For this, there are multiple ways, as they apply to different domains.</p>
<p>In this recipe, we are going to explore two ways by customizing the build of a new project. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here's how to customize a build:</p>
<ol>
<li><span>Create a new binary project using </span><kbd>cargo new custom-build</kbd><span> and open the project folder using VS Code.</span></li>
<li>Open <kbd>src/main.rs</kbd> <span>and replace the hello world code with the following:</span></li>
</ol>
<pre style="padding-left: 60px">fn main() {<br/>    println!("Overflow! {}", 128u8 + 129u8);<br/>}</pre>
<ol start="3">
<li>The code in our binary is now creating an overflow situation that a compiler can easily catch. However, the default release build has that feature turned off. Run <kbd>cargo run --release</kbd> to see it in action:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run --release</strong><br/> Finished release [optimized] target(s) in 0.02s<br/> Running `target/release/custom-build`<br/>Overflow! 1</pre>
<ol start="4">
<li>If we wanted to change the fact that the compiler verifies overflow errors at compile time in release mode (even though overflows can be <em>useful</em>, for example, in hardware drivers), we have to edit <kbd>Cargo.toml</kbd> and customize the profile for <kbd>release</kbd> (there are others as well, for example, <kbd>dev</kbd> and <kbd>test</kbd>). While we are there we can change a few other options for faster builds (important for larger projects):</li>
</ol>
<pre style="padding-left: 60px"># Let's modify the release build<br/>[profile.release]<br/>opt-level = 2<br/>incremental = true # default is false<br/>overflow-checks = true</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li>When we run <kbd>cargo run --release</kbd> now, the output has changed:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run --release</strong><br/>   Compiling custom-build v0.1.0 (Rust-Cookbook/Chapter03/custom-build)<br/>error: attempt to add with overflow<br/> --&gt; src/main.rs:2:30<br/>  |<br/>2 | println!("Overflow! {}", 128u8 + 129u8);<br/>  | ^^^^^^^^^^^^^<br/>  |<br/>  = note: #[deny(const_err)] on by default<br/><br/>error: aborting due to previous error<br/><br/>error: Could not compile `custom-build`.<br/><br/>To learn more, run the command again with --verbose.</pre>
<ol start="6">
<li>That was easy—but there is more! Create a <kbd>.cargo</kbd> <span>directory </span>at the root of the project and add a <kbd>config</kbd> <span>file </span>inside. Since the file (and directory) is inside the project, that's its scope. However, it's possible to make it valid for a larger number of projects by moving the <kbd>.cargo</kbd> directories up several levels. Be aware that the user's home directory represents <em>global scope</em>, which means the <kbd>cargo</kbd> configuration applies to all of the user's projects. The following settings switch the default build target to WASM output (<a href="https://webassembly.org/">https://webassembly.org/</a>) and rename the build artifact directory <kbd>out</kbd> (the default is <kbd>target</kbd>):</li>
</ol>
<pre style="padding-left: 60px">[build]<br/>target = "wasm32-unknown-unknown" # the new default target<br/>target-dir = "out"                # custom build output directory</pre>
<ol start="7">
<li>Now, let's remove the overflow from <kbd>src/main.rs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">fn main() {<br/>    println!("Overflow! {}", 128 + 129);<br/>}</pre>
<ol start="8">
<li>Compile with <kbd>cargo build</kbd> and <kbd>cargo run</kbd> to see what's happening:</li>
</ol>
<pre style="padding-left: 60px"><strong>$  cargo build</strong><br/>   Compiling custom-build v0.1.0 (Rust-Cookbook/Chapter03/custom-<br/>    build)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.37s<br/><strong>$  cargo run</strong><br/>   Compiling custom-build v0.1.0 (Rust-Cookbook/Chapter03/custom-<br/>    build)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.15s<br/>     Running `out/wasm32-unknown-unknown/debug/custom-build.wasm`<br/>     out/wasm32-unknown-unknown/debug/custom-build.wasm:<br/>      out/wasm32-unknown-unknown/debug/custom-build.wasm: cannot <br/>       execute binary file</pre>
<p><span>Now, let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>There are many aspects of a project that can be configured, most of which are not needed for smaller programs and libraries (unless it's for special architectures). This recipe can only show a few—easy—examples of what's possible, but there is more in the <kbd>cargo</kbd> book about configuration (<a href="https://doc.rust-lang.org/cargo/reference/config.html">https://doc.rust-lang.org/cargo/reference/config.html</a>) and the manifest (<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections">https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections</a>). </p>
<p>In the first steps, <kbd>cargo</kbd> is configured to overlook overflow errors by changing a flag in the <kbd>cargo</kbd> configuration. While it might seem a foolish step at first, it is sometimes necessary to allow overflows for drivers or other low-level electronics to operate. </p>
<p>Many other options customize the developer experience (for example, setting the name and email address for new projects, aliases, and many more) or prove useful in non-standard settings, for example, when creating device drivers, operating systems, or real-time software for specialized hardware. We might use some of these later on in <a href="d229ae85-1922-45fc-ab87-b1de7a533f9b.xhtml" target="_blank">Chapter 9</a>, <em>Systems Programming Made Easy</em>.</p>
<p>However, changing the <kbd>build</kbd> <span>section </span>(as in <kbd>cargo build</kbd>) has grave consequences as it represents the standard output format for the project. It might seem arbitrary to change it to something like WASM, but as a default, it can save many steps for the developer to set up the development environment—or to simply make CI build scripts less verbose. </p>
<p>In any case, <kbd>cargo</kbd> is very flexible and easy to configure, but it's tailored to each project individually. Check out the manifest and documentation to find out how it can make your project (and your life) easier.</p>


            </article>

            
        </section>
    </div></body></html>