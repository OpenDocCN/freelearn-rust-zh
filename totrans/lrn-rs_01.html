<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introducing and Installing Rust</h1>
                
            
            
                
<p class="calibre1">Rust is a fairly new addition to the ever-growing number of programming languages available to developers. If you've never used Rust, but come from pretty much any procedural language (such as C or Pascal) or are used to shell scripting, then you should very quickly feel right at home when using Rust.</p>
<p class="calibre1">Getting to grips with Rust is simple enough, and in this chapter we will cover the following topics:</p>
<ul class="calibre12">
<li class="calibre13">Installing Rust with rustup</li>
<li class="calibre13">Testing the installation</li>
<li class="calibre13">Setting up a project</li>
<li class="calibre13">Looking at the IDEs available</li>
<li class="calibre13">Automation using Cargo</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing Rust</h1>
                
            
            
                
<p class="calibre1">As with most languages, Rust is available for a wide number of platforms. It would be impossible to go through installing the compiler on every variant of every operating system. Fortunately, there's an official method of installing Rust, and even though the details may differ slightly, the process is almost the same on all platforms. Therefore, this book will cover installing Rust using rustup on Fedora 27.</p>
<p class="calibre1"><a href="https://rustup.rs" class="calibre3">https://rustup.rs</a> always contains up-to-date instructions on how to get going on all platforms. On Linux and macOS, it will look something like this:</p>
<div><img class="image-border" src="img/00005.jpeg"/></div>
<p class="calibre1">On Windows, this text is replaced by a link to <kbd class="calibre10">rustup-init.exe</kbd>, which is an executable that installs and sets up rustup on Windows.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing rustup on Linux</h1>
                
            
            
                
<p class="calibre1">Run the suggested command that is shown at <a href="https://rustup.rs/" class="calibre3">https://rustup.rs</a>. Run this command in a Terminal. The script suggests some defaults and asks you to confirm them. This is roughly what it should look like after completing the whole script:</p>
<div><img class="image-border1" src="img/00006.jpeg"/></div>
<p class="calibre1">Note that this script attempts to set up rustup for your user by editing your <kbd class="calibre10">.profile</kbd> and <kbd class="calibre10">.bash_profile</kbd> files. If you are using a custom setup, such as another shell, you may need to add the <kbd class="calibre10">source $HOME/.cargo/env</kbd> command manually.</p>
<p class="calibre1">After finishing this script, you can verify that it worked by logging off and on from your Terminal and verifying that the tools are in your path:</p>
<div><img class="image-border2" src="img/00007.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">gcc prerequisites</h1>
                
            
            
                
<p class="calibre1">To build any software that links against external libraries, you will need a C compiler and development versions of any libraries you may be linking against. To ensure that things work properly, install the compiler using the standard method for your operating system.</p>
<p class="calibre1">In Fedora, this would be done using the <kbd class="calibre10">dnf</kbd> tool:</p>
<pre class="calibre21"><strong class="calibre8">sudo dnf install -y gcc</strong></pre>
<p class="calibre1">If you are unsure whether you have gcc installed, type the following command in a terminal window:</p>
<pre class="calibre21"><strong class="calibre8">gcc -version</strong>  </pre>
<p class="calibre1">If gcc is installed, you'll see something like this:</p>
<div><img class="image-border3" src="img/00008.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Testing your installation</h1>
                
            
            
                
<p class="calibre1">Open a command-prompt window and type this:</p>
<pre class="calibre21"><strong class="calibre8">rustc --version</strong>  </pre>
<p class="calibre1">If everything was installed correctly, you will see something like this:</p>
<div><img class="image-border4" src="img/00009.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Integrated Development Environment</h1>
                
            
            
                
<p class="calibre1">To effectively code Rust, you will need at least some sort of text editor. All popular editors are properly supported, so if your favorite is Vim, Emacs, or any of the others, you will find a high-quality Rust extension there. The website <a href="https://areweideyet.com/" class="calibre3">https://areweideyet.com/</a> should give a current view of how things are.</p>
<p class="calibre1">We will cover the lightweight IDE from Microsoft, <strong class="calibre8">Visual Studio Code</strong>, and its most current Rust extension, called simply <strong class="calibre8">Rust</strong>. This IDE should work fairly well in all the different desktop environments. Installation instructions and packages for several platforms are available at Visual Studio Code's main site, <a href="https://code.visualstudio.com/" class="calibre3">https://code.visualstudio.com</a>.</p>
<ol class="calibre16">
<li value="1" class="calibre13">Open up Visual Studio Code and go to the Command Palette, either by the View menu or by the keyboard shortcut <em class="calibre9">Ctrl</em> + <em class="calibre9">Shift</em> + <em class="calibre9">P</em> (which may differ between platforms). Type in <kbd class="calibre10">install extension</kbd> to look for the proper command, and then select Install Extensions:</li>
</ol>
<div><img class="image-border5" src="img/00010.jpeg"/></div>
<ol start="2" class="calibre16">
<li value="2" class="calibre13">After selecting this, type <kbd class="calibre10">rust</kbd> into the next field to look for the Rust extension. At the time of writing, the most recent one is made by <strong class="calibre8">kalitaalexey</strong>:</li>
</ol>
<div><img class="image-border6" src="img/00011.jpeg"/></div>
<ol start="3" class="calibre16">
<li value="3" class="calibre13">You can install Rust right away by pressing Install; alternatively, click on the list item itself to show information about the extension first. After installing it, reload the editor. The Rust extension is now installed and ready to use!</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Your first Rust project</h1>
                
            
            
                
<p class="calibre1">Your first Rust project is not going to be particularly amazing. If anything, it's going to serve four purposes:</p>
<ul class="calibre12">
<li class="calibre13">Showing the structure of a Rust project</li>
<li class="calibre13">Showing how to create a project by hand</li>
<li class="calibre13">Showing how to create a project using the Rust Cargo script</li>
<li class="calibre13">Compiling and executing the program</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Structure of a Rust project</h1>
                
            
            
                
<p class="calibre1">A Rust project (irrespective of the platform you are developing on) will have the following structure:</p>
<div><img class="image-border7" src="img/00012.jpeg"/></div>
<p class="calibre1">The preceding screenshot shows the structure of the simplest Rust project, and as such can be replicated using the following commands:</p>
<table class="calibre4">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">OS X/Linux</strong></p>
</td>
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Windows (from the command prompt)</strong></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">mkdir firstproject cd firstproject touch Cargo.toml mkdir src cd src touch main.rs</strong></pre></td>
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">md firstproject cd firstproject md src echo $null &gt;&gt; Cargo.toml cd src echo $null &gt;&gt; main.rs</strong></pre></td>
</tr>
</tbody>
</table>
<p>The <kbd class="calibre22">echo $null &gt;&gt; filename</kbd> command creates an empty file without the need to start Notepad; save the file and exit.</p>
<p class="calibre1">The <kbd class="calibre10">Cargo.toml</kbd> file is the Rust equivalent of a <strong class="calibre8">Makefile</strong>. When the <kbd class="calibre10">.toml</kbd> file is created by hand, it should be edited to contain something like this:</p>
<div><img class="image-border8" src="img/00013.jpeg"/></div>
<p class="calibre1">The structure of a Rust project can expand to include documentation as well as the build structure, as follows:</p>
<div><img class="image-border9" src="img/00014.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Automating things</h1>
                
            
            
                
<p class="calibre1">While there is nothing wrong with creating a Rust project by hand, Rust does come with a very handy utility called <strong class="calibre8">Cargo</strong>. Cargo can be used not only to automate the setting up of a project, but also to compile and execute Rust code. Cargo can be used to create the parts required for a library instead of an executable, and can also generate application documentation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a binary package using Cargo</h1>
                
            
            
                
<p class="calibre1">As with any other script, Cargo works (by default) on the current working directory. (For example, while writing this chapter, my working directory for the example code is <kbd class="calibre10">~/Developer/Rust/chapter0</kbd> on the Mac and Linux boxes, and <kbd class="calibre10">J:\Developer\Rust\Chapter0</kbd> on the Windows 10 machine.)</p>
<p class="calibre1">In its simplest form, Cargo can generate the correct file structure like this:</p>
<pre class="calibre21"><strong class="calibre8">cargo new demo_app_name -bin</strong> </pre>
<p class="calibre1">The preceding command tells Cargo to create a new structure called <kbd class="calibre10">demo_app_name</kbd>, and that it is to be a binary. If you remove <kbd class="calibre10">-bin</kbd>, it creates a structure called, which is going to be a library (or more accurately, something other than a binary).</p>
<p class="calibre1">If you don't wish to use the root (say you want to create a library within your binary framework), then instead of <kbd class="calibre10">demo_app_name</kbd>, you append the structure before the name relating to your working directory.</p>
<p class="calibre1">In the small example I gave earlier, if I wanted to create a library within my binary structure, I would use the following:</p>
<pre class="calibre21"><strong class="calibre8">cargo new app_name/mylib</strong>  </pre>
<p class="calibre1">That will create a structure like this:</p>
<div><img class="image-border10" src="img/00015.jpeg"/></div>
<p class="calibre1">The <kbd class="calibre10">Cargo.toml</kbd> file requires no editing (at this stage), as it contains the information we had to enter manually when we created the project by hand.</p>
<p>Cargo has a number of directory separator <em class="calibre23">translators</em>. This means that the preceding example can be used on OS X, Linux, and Windows without an issue; Cargo has converted the <kbd class="calibre22">/</kbd> to <kbd class="calibre22">\</kbd> for Windows.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using Cargo to build and run an application</h1>
                
            
            
                
<p class="calibre1">As we are all able to create directory structures, Cargo is then able to build and execute our source code.</p>
<p class="calibre1">If you look at the source code that comes with this chapter, you will find a directory called <kbd class="calibre10">app_name</kbd>. To build this package using Cargo, type the following from a Terminal (or command on Windows) window:</p>
<pre class="calibre21"><strong class="calibre8">cd app_name </strong>
<strong class="calibre8">cargo build app_name</strong>  </pre>
<p class="calibre1">This will build the source code; finally you will be informed that the compilation has been successful:</p>
<div><img class="image-border6" src="img/00016.jpeg"/></div>
<p class="calibre1">Next, we can use Cargo to execute the binary as follows:</p>
<pre class="calibre21"><strong class="calibre8">cargo run</strong></pre>
<p class="calibre1">If everything has worked, you will see something like the following:</p>
<div><img class="image-border11" src="img/00017.jpeg"/></div>
<p class="calibre1">As with any sort of utility, it's possible to "daisy-chain" the build and execution into one line, as follows:</p>
<pre class="calibre21"><strong class="calibre8">cargo build; cargo run</strong>  </pre>
<p>You may be wondering why the first operation performed was to move into the application structure rather than just type <kbd class="calibre22">cargo build</kbd>. This is because Cargo is looking for the <kbd class="calibre22">Cargo.toml</kbd> file (remember, this acts as a build script).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Cleaning your source tree with Cargo</h1>
                
            
            
                
<p class="calibre1">When the Rust compiler compiles the source files, it generates something known as an object file. The object file takes the source file (which we can read and understand) and compiles this into a form that can be joined with other libraries to create a binary.</p>
<p class="calibre1">This is a good idea, as it cuts down on compilation time; if a source file has not been changed, there is no need to recompile the file, as the object file will be the same.</p>
<p class="calibre1">Sometimes, the object file becomes out of date, or code in another object file causes a panic due to conflicts. In this case, it is not uncommon to "clean" the build. This removes the object files, and the compiler then has to recompile all the source files.</p>
<p class="calibre1">Also, it should always be performed prior to creating a release build.</p>
<p class="calibre1">The standard Unix <kbd class="calibre10">make</kbd> program performs this with the <kbd class="calibre10">clean</kbd> command (<kbd class="calibre10">make clean</kbd>). Cargo performs the clean operation in a way similar to the <kbd class="calibre10">make</kbd> utility in Unix:</p>
<pre class="calibre21"><strong class="calibre8">cargo clean</strong>  </pre>
<p class="calibre1">A comparison of the directories shows what happens when using the preceding Cargo command:</p>
<div><img class="image-border12" src="img/00018.jpeg"/></div>
<p class="calibre1">The entire target directory structure has simply been removed (the preceding screenshot was from a Mac, hence the <kbd class="calibre10">dSYM</kbd> and <kbd class="calibre10">plist</kbd> files. These do not exist on Linux and Windows).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating documentation using Cargo</h1>
                
            
            
                
<p class="calibre1">As with other languages, Rust is able to create documentation based on meta tags with the source files. Take the following example:</p>
<pre class="calibre21">fn main() 
{ 
   print_multiply(4, 5); 
} 
 
/// A simple function example 
/// 
/// # Examples 
/// 
/// ``` 
/// print_multiply(3, 5); 
///  
/// ``` 
 
fn print_multiply(x: i32, y: i32) 
{ 
   println!("x * y = {}", x * y); 
} </pre>
<p class="calibre1">The comments preceded by <kbd class="calibre10">///</kbd> will be converted into documentation.</p>
<p class="calibre1">The documentation can be created in one of two ways: via Cargo or by using the <strong class="calibre8">rustdoc</strong> program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">rustdoc versus Cargo</h1>
                
            
            
                
<p class="calibre1">As with the other operations provided by Cargo, when documentation is created, it acts as a wrapper for rustdoc. The only difference is that with rustdoc you have to specify the directory that the source file sits in. Cargo acts dumb in this case, and creates the documentation for all source files.</p>
<p class="calibre1">In its simplest form, the rustdoc command is used as follows:</p>
<pre class="calibre21"><strong class="calibre8">cargo doc</strong>
<strong class="calibre8">rustdoc src/main.rs</strong>  </pre>
<p class="calibre1">Cargo does have the advantage of creating the doc structure within the <kbd class="calibre10">root</kbd> folder, whereas rustdoc creates the structure within the target (which is removed with <kbd class="calibre10">cargo clean</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using Cargo to help with your unit testing</h1>
                
            
            
                
<p class="calibre1">Hopefully, unit testing is not something you will be unfamiliar with. A unit test is a test that operates on a specific function or method rather than an entire class or namespace. It ensures that the function operates correctly on the data it is presented with.</p>
<p class="calibre1">Unit tests within Rust are very simple to create (two examples are given in the <kbd class="calibre10">assert_unittest</kbd> and <kbd class="calibre10">unittest</kbd> directories). The following has been taken from the <kbd class="calibre10">unittest</kbd> example:</p>
<pre class="calibre21">fn main() { 
    println!("Tests have not been compiled, use rustc --test instead (or cargo test)"); 
} 
 
#[test] 
fn multiply_test() 
{ 
   if 2 * 3 == 5 
   { 
      println!("The multiply worked"); 
   } 
} </pre>
<p class="calibre1">When this is built and executed, you may be surprised by the following result:</p>
<div><img class="image-border6" src="img/00019.jpeg"/></div>
<p>The reason why this unit test has passed despite <em class="calibre23">2 x 3</em> not being <em class="calibre23">5</em> is because the unit test is not testing the result of the operation, but that the operation itself is working. It is very important that this distinction is understood from an early stage to prevent confusion later.</p>
<p class="calibre1">We have hit a limitation of unit testing: if we are not testing the data but the operation, how can we know that the result itself is correct?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Assert yourself!</h1>
                
            
            
                
<p class="calibre1">Unit testing provides the developer with a number of methods called assertion methods:</p>
<pre class="calibre21">#[test] 
fn multiply() 
{ 
   assert_eq!(5, 2 * 3); 
} 
assert_eq!</kbd> (assert equal) macro. The first argument is the answer expected, and the second argument is what is being tested. If <em class="calibre9">2 * 3 = 5</em>, then the assertion is true and passes the unit test.</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Is there anything Cargo can't do?</h1>
                
            
            
                
<p class="calibre1">For a Rust developer, Cargo is an amazing utility. In addition to these common facilities, it also has other commands, which are listed in the table that follows. All commands follow this form:</p>
<pre class="calibre21"><strong class="calibre8">cargo &lt;command&gt; &lt;opts&gt;</strong>  </pre>
<table class="calibre4">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Command</strong></p>
</td>
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">What it does</strong></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">fetch</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command fetches the dependencies of a package from the network. If a lockfile is available, this command will ensure that all of the Git dependencies and/or registry dependencies are downloaded and locally available. The network is never called after a <kbd class="calibre10">cargo fetch</kbd> unless the lockfile changes.</p>
<p class="calibre1">If the lockfile is not available, then this is the equivalent of <kbd class="calibre10">cargo generate-lockfile</kbd>. A lockfile is generated and all the dependencies are also updated.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">generate-lockfile</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command generates the lockfile for a project. The lockfile is typically generated when <kbd class="calibre10">cargo build</kbd> is issued (you will see it as <kbd class="calibre10">Cargo.lockfile</kbd> in the directory structure).</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">git-checkout</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command checks out a Git repository. You will need to use it in the following form:</p>
<pre class="calibre21"><strong class="calibre8">cargo git-checkout -url=URL</strong>        </pre></td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">locate-project</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command locates a package.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">login</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command saves an API token from the registry locally. The call is in the following form:</p>
<pre class="calibre21"><strong class="calibre8">cargo login -host=HOST   token</strong>        </pre></td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">owner</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command manages the owners of a crate on the registry. This allows the ownership of a crate (a crate is a Rust library) to be altered (<kbd class="calibre10">--add LOGIN</kbd> or <kbd class="calibre10">-remove LOGIN</kbd>) as well as adding tokens to the crate.</p>
<p class="calibre1">This command will modify the owners for a package on the specified registry (or the default). Note that the owners of a package can upload new versions, yank old versions, and also modify the set of owners, so be cautious!</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">package</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command assembles the local package into a distributable tarball.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">pkgid</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command prints a fully qualified package specification.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">publish</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command uploads a package to the registry.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">read-manifest</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command reads the manifest file (<kbd class="calibre10">.toml</kbd>).</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">rustc</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command compiles the complete package.</p>
<p class="calibre1">The specified target for the current package will be compiled along with all of its dependencies. The specified options will all be passed to the final compiler invocation, not any of the dependencies. Note that the compiler will still unconditionally receive arguments such as <kbd class="calibre10">-L</kbd>, <kbd class="calibre10">--extern</kbd>, and <kbd class="calibre10">--crate-type</kbd>, and the specified options will simply be added to the compiler invocation.</p>
<p class="calibre1">This command requires that only one target is being compiled. If more than one target is available for the current package, the filters <kbd class="calibre10">--lib</kbd>, <kbd class="calibre10">--bin</kbd>, and so on—must be used to select which target is compiled.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">search</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command searches for packages at <a href="https://crates.io/" class="calibre3">https://crates.io/</a>.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">update</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command updates dependencies as recorded in the local lockfile.</p>
<p class="calibre1">Typical options are:</p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">--package SPEC</kbd> (package to update)</li>
<li class="calibre13"><kbd class="calibre10">--aggressive</kbd> (forcibly update all dependencies of <kbd class="calibre10">&lt;name&gt;</kbd> as well)</li>
<li class="calibre13"><kbd class="calibre10">--precise PRECISE</kbd> (update a single dependency to exactly <kbd class="calibre10">PRECISE</kbd>)</li>
</ul>
<p class="calibre1">This command requires that a <kbd class="calibre10">Cargo.lock</kbd> file already exists as generated by <kbd class="calibre10">cargo build</kbd> or related commands.</p>
<p class="calibre1">If a package spec name (<kbd class="calibre10">SPEC</kbd>) is given, then a conservative update of the lockfile will be performed. This means that only the dependency specified by <kbd class="calibre10">SPEC</kbd> will be updated. Its transitive dependencies will be updated only if <kbd class="calibre10">SPEC</kbd> cannot be updated without updating the dependencies. All other dependencies will remain locked at their currently recorded versions.</p>
<p class="calibre1">If <kbd class="calibre10">PRECISE</kbd> is specified, then <kbd class="calibre10">--aggressive</kbd> must not also be specified. The argument <kbd class="calibre10">PRECISE</kbd> is a string representing a precise revision that the package being updated should be updated to. For example, if the package comes from a Git repository, then <kbd class="calibre10">PRECISE</kbd> would be the exact revision that the repository should be updated to.</p>
<p class="calibre1">If <kbd class="calibre10">SPEC</kbd> is not given, then all the dependencies will be re-resolved and updated.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">verify-project</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command ensures that the project is correctly created.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">version</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command shows the version of Cargo.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<pre class="calibre21"><strong class="calibre8">yank</strong></pre></td>
<td class="calibre7">
<p class="calibre1">This command removes a pushed crate from the index.</p>
<p class="calibre1">The <kbd class="calibre10">yank</kbd> command removes a previously pushed crate version from the server's index. This command does not delete any data, and the crate will still be available for download via the registry's download link.</p>
<p class="calibre1">Note that existing crates locked to a yanked version will still be able to download the yanked version to use it. Cargo will, however, not allow any new crates to be locked to any yanked version.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre1"> </p>
<p class="calibre1">As you can now appreciate, the Cargo utility script is extremely powerful and flexible.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre1">We now have a fully working installation of Rust, and are ready for the get-go. We've explained how to set up a project, both manually and via the Cargo utility, and you should already have an appreciation of how useful Cargo is.</p>
<p class="calibre1">In the next chapter, we'll be looking at the foundation of any language: <strong class="calibre8">variables</strong>.</p>


            

            
        
    </body></html>