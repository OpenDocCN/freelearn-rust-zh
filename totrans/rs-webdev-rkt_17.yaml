- en: '*Chapter 14*: Building a Full Stack Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to build a simple WebAssembly application
    and use Rocket to serve the WebAssembly application. We are going to make WebAssembly
    load the user information from one of the endpoints that we created earlier. After
    learning the information in this chapter, you will be able to write and build
    a WebAssembly application using Rust. You will learn how to serve WebAssembly
    using the Rocket web framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover these main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Cargo workspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a WebAssembly build target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a WebAssembly application using Yew
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving a WebAssembly application using Rocket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter are very simple: the Rust compiler,
    the Cargo command line, and a web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter14](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, almost all applications in the web browser were made using the
    JavaScript language. There were also attempts to use different languages in the
    web browser, such as Java Applet, Adobe Flash, and Silverlight. But, all those
    different attempts were not web standards, and, therefore, the adoption of those
    attempts was not as universal as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a way to use other programming languages in the web browser:
    by using **WebAssembly**. WebAssembly is both a binary executable format and its
    corresponding text format for a stack-based virtual machine. Web browsers that
    support WebAssembly can execute the binary executable format. Any programming
    language that can be compiled into WebAssembly can be executed by web browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, WebAssembly was announced and was first released in March 2017\. All
    major web browser vendors finished the release of browsers with minimum support
    for WebAssembly in September 2017, and then World Wide Web Consortium recommended
    WebAssembly on December 5th, 2019\.
  prefs: []
  type: TYPE_NORMAL
- en: Compiled languages such as C++ or Rust can be compiled into a `.wasm` file,
    and a virtual machine in the browser can then run the WebAssembly file. To run
    interpreted languages, first, the language runtime can be compiled into a `.wasm`
    file, and then, the runtime can run the runtime scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 ‒ Interpreted languages and compiled languages in WebAssembly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.1_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 ‒ Interpreted languages and compiled languages in WebAssembly
  prefs: []
  type: TYPE_NORMAL
- en: The Rust programming language supports WebAssembly, and as we have already learned
    about Rust and created a backend application using Rust and Rocket, we can take
    this opportunity to learn a little about frontend application development using
    Rust. The old web standards and web technologies, such as HTML, CSS, and JavaScript,
    are technologies that changed the course of human history. Learning about new
    web standards, such as WebAssembly, is a good opportunity to be a part of future
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement a page in our application where we will render an empty template.
    The template will load WebAssembly binary from the server. WebAssembly will call
    the user API endpoint that we created earlier. It will then render users using
    a custom component.
  prefs: []
  type: TYPE_NORMAL
- en: For the implementation, we are going to use Yew ([https://yew.rs](https://yew.rs)),
    which is a frontend Rust framework.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Cargo workspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are going to create a new application, it would be nice if we could
    make the code for the `our_application` Rocket application work alongside this
    new application. Cargo has a feature called **Cargo workspaces**. A Cargo workspace
    is a set of different Cargo packages in a single directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up a Cargo workspace to have multiple applications in a single directory
    using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory, for example, `01Wasm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `our_application` directory inside the `01Wasm` directory and create
    a new `Cargo.toml` file inside the `01Wasm` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `Cargo.toml` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Rust application inside `01Wasm` using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, add the new application as a member of the workspace in `01Wasm/Cargo.toml`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try building both applications using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To build or run one of the applications, append `--bin` with the binary package
    name, or `--lib` with the library package name. To run the application, consider
    the location of the directories required for running the Rocket application. For
    example, if there's no logs directory, the application might fail to run. Also,
    if there's no static directory, the application might not be able to find the
    assets file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try building one of the applications by running this command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have set up the Cargo workspace, we can learn how to build the application
    for a different target specifically for WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a WebAssembly build target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust compiler can be set to compile to a different architecture. The architectures
    are also called `x86_64-unknown-linux_gnu` and `x86_64-apple-darwin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Targets can be categorized into three tiers, tier 1, tier 2, and tier 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tier 1** means that the target is guaranteed to work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tier 2** means that the target is guaranteed to build but, sometimes, the
    automated test to build the binary for the targets may not pass. The host tools
    and full standard library for this tier are also supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tier 3** means that the Rust code base supports some features of the targets.
    The build for those targets may or may not exist, and the tooling might not be
    complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that WebAssembly is a binary format for a virtual machine. The Rust
    compiler has targets for the virtual machine specifications, such as `asmjs-unknown-emscripten`,
    `wasm32-unknown-emscripten`, or `wasm32-unknown-unknown`. The community mostly
    supports the tooling around `wasm32-unknown-unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the available target list for the Rust compiler, run the following command
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To add WebAssembly target support for the Rust compiler, run the following
    command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the target, try building `our_application_wasm` by running this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will use `wasm32-unknown-unknown` to build the WebAssembly application in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a WebAssembly application using Yew
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the application, we are going to use Yew (https://yew.rs). On the website,
    it says that Yew is a modern Rust framework for creating multithreaded frontend
    web apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cargo can compile the WebAssembly binary, but the WebAssembly binary itself
    is not usable without other steps. We have to load the WebAssembly binary in the
    web browser''s virtual machine engine. There are proposals such as using a `<script
    type="module"></script>` tag, but unfortunately, those proposals are not standard
    yet. We have to tell JavaScript to load the module using the WebAssembly Web API.
    To make the development easier, we can use `wasm-pack` from the Rust WebAssembly
    working group at https://rustwasm.github.io/. Yew uses an application named `trunk`
    (https://trunkrs.dev) that wraps `wasm-pack` and provides other conveniences.
    Install `trunk` by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the preparation for compiling WebAssembly has been completed, we can
    write the code for the WebAssembly application. Follow these steps to create the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an HTML file named `index.html` inside the `our_application_wasm` directory.
    We will use this HTML file to mimic the template on `our_application`, with small
    differences. We want to add an ID for an HTML tag to be the main tag for the WebAssembly
    application. Let''s name this ID `main_container`. Append the following lines
    to `our_application_wasm/index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `yew` as a dependency to `our_application_wasm`. We also want to access
    the browser DOM, so we need another dependency. Gloo ([https://gloo-rs.web.app/](https://gloo-rs.web.app/))
    provides bindings to the Web API, and we want to use `gloo_utils` as a dependency
    for our WebAssembly application to access the DOM. Add the following dependencies
    to `our_application_wasm/Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the required `use` declarations in `our_application_wasm/src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a minimal component that creates an empty HTML inside `our_application_wasm/src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `gloo_utils` in the `main()` function in `our_application_wasm/src/main.rs`
    to select the `div` tag with the `main_container` ID. Append the following lines
    in the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a Yew application by appending this line to the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use `trunk` to create a small web server and build everything needed
    to build the WebAssembly and related JavaScript to load the WebAssembly and serve
    the HTML. Run this command in the terminal inside the `our_application_wasm` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There should be an output like the following in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Try opening a web browser to `http://127.0.0.1:8080`; you''ll see that it loads
    and runs the Yew WebAssembly application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.2 ‒ Hello WebAssembly!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.2_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 ‒ Hello WebAssembly!
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to get users'' information using an API endpoint that returns
    the JSON that we created earlier in `our_application` from `http://127.0.0.1:8000/api/users`.
    To convert the JSON into Rust types, let''s define similar types to those in `our_application`.
    The types should derive SerDes'' `deserialize`. In `our_application_wasm/Cargo.toml`,
    add the dependencies for the WebAssembly code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in `our_application_wasm/src/main.rs`, add the required `use` declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the types to deserialize the JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One thing that we can do to improve redefining the types is to create a library
    that defines types that can be used by both applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we look at the `User` struct, we can see that the description field is an
    `Option`. Create a convenience function to return an empty `String` if the value
    is `None`, and return the `String` content of `Some` if the value is `Some`. Add
    the following function to `our_application_wasm/src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It''s now time to implement a component that will render `User`. We will name
    the component `UsersList`. Add the following function to `our_application_wasm/src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `html!` macro content looks like the content of `our_application/src/views/users/_user.html.tera`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to load the `User` data from the API endpoint. We can do this by using
    two libraries, `reqwasm` (which provides HTTP request functionality), and `wasm-bindgen-futures`
    (which converts Rust `futures` into JavaScript `promise` and vice versa). Add
    the following dependencies to `our_application_wasm/Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `our_application_wasm/src/main.rs`, add a `const` for our API endpoint.
    Add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the routine to fetch the `User` data. Add the required `use` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, append the following lines inside the `app()` function in `our_application_wasm/src/main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `{}` block under the `users_wrapper` fetching, set the value for
    `next` and `limit`. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the HTML from `Hello WebAssembly!` to show the proper `User` information.
    We want to use the `UsersList` component that we created earlier. Change the `html!`
    macro content into the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the `our_application_wasm` WebAssembly and JavaScript by running this
    command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The command should generate three files in the `dist` directory: `index.html`,
    a WebAssembly file with random name, and a JavaScript file with random name. The
    example of random WebAssembly and JavaScript file are `index-9eb0724334955a2a_bg.wasm`
    and `index-9eb0724334955a2a.js` in the `dist` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have successfully written and built a WebAssembly application.
    In the next section, we are going to learn how to serve a WebAssembly application
    using Rocket.
  prefs: []
  type: TYPE_NORMAL
- en: Serving a WebAssembly application using Rocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to serve the WebAssembly web application using
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To run the WebAssembly file in `our_application`, we have to modify `our_application`
    a little bit. First, copy the WebAssembly and the JavaScript from `our_application_wasm/dist`
    to the `our_application/static` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the template to be able to selectively use WebAssembly in `our_application/src/views/template.html.tera`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new template file named `our_application/src/views/users/wasm.html.tera`.
    Edit the file in order to make sure the HTML file loads the necessary WebAssembly
    and JavaScript file, and run the WebAssembly on the right DOM. Add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new route handling function to load just the generated HTML. Add the
    following function in `our_application/src/routes/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, don''t forget to load the route. Add the new route in `our_application/src/lib.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `our_application` web server by running `cargo run` in the `our_application`
    directory, and then open `http://127.0.0.1:8000/users/wasm` in the web browser.
    If we inspect the web browser developer tools, we can see that the web browser
    runs the JavaScript and WebAssembly, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.3 ‒ Web browser loading and running our_application_wasm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.3_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 ‒ Web browser loading and running our_application_wasm
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly should run properly by modifying the tag with the `main_container`
    tag, then loading the JSON from `http://127.0.0.1:8000/api/users` and rendering
    the HTML in the web browser properly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web technology has evolved to allow web browsers to run a universal binary format
    for a virtual machine. Web browsers can now run a binary generated by the Rust
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have looked at an overview of WebAssembly, and how to prepare
    the Rust compiler to compile to WebAssembly. We also learned how to set up a Cargo
    workspace to have more than one application in a single directory.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how to write a simple frontend application that loads the `User`
    data from the `our_application` API endpoint that we created earlier using Yew
    and other Rust libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we finished with how to serve the generated WebAssembly and JavaScript
    in the `our_application` web server.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is the final chapter, and we're going to see how we can expand
    the Rocket application and find alternatives to it.
  prefs: []
  type: TYPE_NORMAL
