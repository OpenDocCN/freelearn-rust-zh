- en: '*Chapter 9*: Testing, Debugging, and Performance'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*: 测试、调试和性能'
- en: In this book, we've built an entire game using two tools to test our logic –
    that is, a compiler and our eyes. If the game doesn't compile, it's broken, and
    if **Red Hat Boy** (**RHB**) doesn't look right, it's broken – simple enough.
    Fortunately, the compiler provides a lot of tools to make sure we don't make mistakes.
    Let's be honest, though – it's not enough.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用两个工具来测试我们的逻辑——也就是说，编译器和我们的眼睛。如果游戏无法编译，它就是有问题的，如果**红帽男孩**(**RHB**)看起来不对，它也是有问题的——这很简单。幸运的是，编译器提供了很多工具来确保我们不会犯错误。但是，让我们说实话——这还不够。
- en: Developing a game can be a long process, especially if you're a hobbyist. When
    you only have 4 hours to work on it in a given week, they can't all be spent fighting
    the same bug. To ensure our game works, we need to test it, find mistakes, and
    make sure it's not too slow. That's what we're going to be doing here.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个游戏可能是一个漫长的过程，尤其是如果你是一个爱好者。当你在一周内只有4个小时可以用来工作的时候，你不能把所有的时间都花在同一个错误上。为了确保我们的游戏能够正常工作，我们需要对其进行测试，找出错误，并确保它不会太慢。这正是我们在这里要做的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating automated tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自动化测试
- en: Debugging the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试游戏
- en: Measuring performance with the browser
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器测量性能
- en: After completing this chapter, you'll be able to fix the bugs we've written
    so far and make sure they don't happen again.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够修复我们迄今为止编写的错误，并确保它们不再发生。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we'll use the Chrome developer tools to debug the code and
    monitor performance. Other browsers also ship with robust developer tools, but
    for the screenshots and directions in this chapter, we'll be using Chrome.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Chrome开发者工具来调试代码并监控性能。其他浏览器也配备了强大的开发者工具，但为了本章的截图和说明，我们将使用Chrome。
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9)找到。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3NKppLk](https://bit.ly/3NKppLk)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3NKppLk](https://bit.ly/3NKppLk)
- en: Creating automated tests
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自动化测试
- en: 'In an ideal world, every system would have a large amount of testing, both
    automated and manual, that''s done by developers and QA. Some ways to test your
    game is working correctly involve doing the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，每个系统都应该有大量的测试，包括自动和手动测试，由开发人员和QA团队完成。以下是一些测试你的游戏是否正确工作的方法：
- en: Using types to prevent programmer errors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型来防止程序员错误
- en: Playing the game yourself
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自己玩游戏
- en: Performing automated unit tests
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行自动化单元测试
- en: Performing automated integration tests
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行自动化集成测试
- en: So far, we've only used the first two, which is an unfortunately common approach
    in real-world code. This can be suitable for personal or hobby projects but it
    isn't robust enough for production applications, particularly those written by
    a team.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了前两种，这在现实世界的代码中是一个不幸的常见做法。这可能适合个人或爱好项目，但它对于生产应用来说不够健壮，尤其是那些由团队编写的应用。
- en: 'Almost any application can benefit from automated, programmer-written unit
    tests and as a program becomes even larger, it begins to benefit from integration
    tests as well. There''s not a consistent definition of the differences between
    these two types of tests as you tend to know them when you see them, but fortunately,
    we can use the Rust definitions. Rust and Cargo provide two kinds of testing:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何应用程序都可以从自动的、程序员编写的单元测试中受益，随着程序变得越来越大，它也开始从集成测试中受益。这两种测试类型之间的区别并没有一个一致的定义，因为你通常在看到它们时才会知道，但幸运的是，我们可以使用Rust的定义。Rust和Cargo提供了两种测试类型：
- en: Unit tests via `cargo test`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `cargo test` 进行单元测试
- en: Integration tests via `wasm-pack test`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `wasm-pack test` 进行集成测试
- en: Unit tests tend to be programmer-centric. They are written at the method or
    function level, with minimal dependencies. You may have a test for every branch
    of an `if/else` statement, while in the case of a loop, you may have tests for
    when a list has 0, 1, or many entries. These tests are small and fast and should
    run in seconds or less. These are my preferred form of testing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常以程序员为中心。它们在方法或函数级别编写，具有最少的依赖。你可能会有一个针对`if/else`语句每个分支的测试，而在循环的情况下，你可能会有针对列表为0、1或多个条目的测试。这些测试很小、很快，应该在几秒钟或更短的时间内运行。这是我首选的测试形式。
- en: Integration tests tend to look at the app at a higher level. In the case of
    our code, the integration tests automate the browser and will work based on an
    event (such as a mouse click) throughout the program. These tests take longer
    to write, are harder to maintain, and often fail for mysterious reasons. So, why
    write them? Unit tests typically do not test parts of your application or they
    may only do so in small doses. This can lead to a situation where your unit tests
    all pass but the game doesn't work. Most systems will have fewer integration tests
    than unit tests because of their disadvantages, but they will need them for their
    benefits.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常会从更高的层次查看应用程序。在我们的代码中，集成测试会自动化浏览器，并基于事件（如鼠标点击）在整个程序中工作。这些测试编写起来耗时更长，更难维护，并且经常因为神秘的原因而失败。那么，为什么还要编写它们呢？单元测试通常不会测试应用程序的各个部分，或者它们可能只在小范围内这样做。这可能导致一种情况，即单元测试全部通过，但游戏却无法运行。由于集成测试的缺点，大多数系统将比单元测试少，但它们需要它们来获得其好处。
- en: In Rust, unit tests are written side by side with a module and run with `cargo
    test`. In our setup, they will run as part of a Rust executable, running directly
    on the machine. Integration tests are stored in the `tests` directory and only
    have access to things your crate makes public. They run in the browser – potentially
    a headless one – with `wasm-pack test`. Unit tests can test internal methods directly,
    while integration tests must use your crate as a real program would.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，单元测试是与模块并行的，并通过`cargo test`运行。在我们的设置中，它们将作为Rust可执行程序的一部分运行，直接在机器上运行。集成测试存储在`tests`目录中，并且只能访问你的crate公开的事物。它们在浏览器中运行——可能是一个无头浏览器——通过`wasm-pack
    test`。单元测试可以直接测试内部方法，而集成测试必须像真实程序一样使用你的crate。
- en: Tip
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Ham Vocke has a very detailed article on the *Test Pyramid* that describes
    one way to organize all of your tests in a system: [https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 汉姆·沃克（Ham Vocke）有一篇非常详细的关于*测试金字塔*的文章，它描述了一种组织系统中所有测试的方法：[https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html)。
- en: Test-driven development
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: I have a confession to make. I usually write all my code in a test-driven style,
    where you write a test then make it fail for each step in the development process.
    Had we followed that process during the development of this book, we'd likely
    have quite a few tests – perhaps more than 100\. In addition, **test-driven development**
    (**TDD**) exerts a lot of pressure on the design that tends to lead to more loosely
    coupled code. So, why didn't we do this?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个坦白要说。我通常以测试驱动的方式编写所有代码，即先写一个测试，然后在开发过程的每个步骤中让它失败。如果我们在这本书的开发过程中遵循这个过程，我们可能会有一大堆测试——可能超过100个。此外，**测试驱动开发**（**TDD**）对设计施加了很大的压力，这往往会导致更松散耦合的代码。那么，为什么我们没有这样做呢？
- en: Well, TDD has its downsides, with perhaps the largest being we'd generate a
    lot more code in the form of tests. We've already written a *lot* of code in this
    book, so imagine trying to follow along with the tests too – you can see why I
    felt it was best to leave out the kind of testing I normally write. *Test-Driven
    Rust* isn't the title of this book after all. However, just because we didn't
    write tests first doesn't mean we don't want to be sure our code works. That's
    why, in many cases, we used the type system as the first line of defense against
    mistakes, such as using the typestate pattern for state transitions. The type
    system is one of the advantages of using Rust instead of JavaScript for this game.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，TDD有其缺点，其中最大的可能是我们会生成大量的测试代码。我们在这本书中已经写了很多代码，所以想象一下还要跟着测试一起做——你可以看到为什么我觉得最好省略掉我通常写的测试。毕竟，这本书的标题不是《测试驱动的Rust》。然而，仅仅因为我们没有先写测试，并不意味着我们不希望确保我们的代码能正常工作。这就是为什么在许多情况下，我们使用类型系统作为防止错误的第一道防线，例如使用类型状态模式进行状态转换。类型系统是使用Rust而不是JavaScript进行这款游戏的优点之一。
- en: This isn't to say that automated testing cannot provide value for our program.
    The Rust ecosystem places a high value on testing, so much so that a testing framework
    is built into Cargo and is automatically set up for any Rust program. With unit
    tests, we can test algorithms such as collision detection or our famous state
    machines. We can make sure that the game still does what we expect, although we
    can't test whether a game is fun or pretty. For that, you'll have to play the
    game until you hate it, but a game is a lot more fun if the basics work. We can
    use tests, along with types, to ensure the code works as expected so that we can
    turn our focus to whether or not it's fun. To do that, we'll need to set up the
    test runner and then write some tests that run outside of the browser and inside
    the browser.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说自动化测试不能为我们程序提供价值。Rust 生态系统高度重视测试，以至于测试框架被内置到 Cargo 中，并且为任何 Rust 程序自动设置。通过单元测试，我们可以测试诸如碰撞检测或我们著名的状态机等算法。我们可以确保游戏仍然按照我们的预期运行，尽管我们无法测试游戏是否有趣或漂亮。为此，你可能需要一直玩游戏直到你讨厌它，但游戏如果基础功能正常，会更有趣。我们可以使用测试以及类型来确保代码按预期工作，这样我们就可以将注意力转向游戏是否有趣。为此，我们需要设置测试运行器，然后编写一些在浏览器外和浏览器内运行的测试。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you're interested in TDD, Kent Beck's book *Test-Driven Development By Example*
    is still an excellent resource ([https://amzn.to/3o1R663](https://amzn.to/3o1R663)).
    For a web-based approach that uses TypeScript and React, you can take a look at
    an excellent book called *Build Your Own Spreadsheet* at [https://buildyourownspreadsheet.com/](https://buildyourownspreadsheet.com/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 TDD 感兴趣，Kent Beck 的书《通过示例进行测试驱动开发》（[Test-Driven Development By Example](https://amzn.to/3o1R663)）仍然是一个极好的资源。对于使用
    TypeScript 和 React 的基于 Web 的方法，你可以看看一本叫做《自己动手制作电子表格》（[Build Your Own Spreadsheet](https://buildyourownspreadsheet.com/)）的优秀书籍。
- en: Getting started
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'As we mentioned earlier, Rust has built-in capabilities for running tests –
    both unit and integration. Unfortunately, the template we used way back in [*Chapter
    1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015), *Hello WebAssembly*, still
    has an out-of-date setup at the time of writing. If it hasn''t been fixed, running
    `cargo test` at the command prompt will fail to compile, let alone run the tests.
    Fortunately, there are not a lot of mistakes. There''s just some out-of-date `async`
    code for a browser test we won''t be using in the automatically generated tests.
    Those tests are in the `tests` directory in the `app.rs` file. This is traditionally
    where integration tests are put in Cargo projects. We''ll change that setup shortly
    by using unit tests, but first, let''s get this to compile by deleting the incorrect
    `async_test` setup test. In `app.rs`, you can delete that function and the `#[wasm_bindgen_test(async)]`
    macro above it so that your `app.rs` file looks like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Rust 内置了运行测试的能力——既包括单元测试和集成测试。不幸的是，我们很久以前在[*第一章*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015)，“Hello
    WebAssembly”，所使用的模板在撰写本文时仍然存在过时的设置。如果尚未修复，在命令提示符下运行 `cargo test` 将无法编译，更不用说运行测试了。幸运的是，错误并不多。只是有一个过时的
    `async` 代码用于浏览器测试，而我们不会在自动生成的测试中使用。这些测试位于 `tests` 目录下的 `app.rs` 文件中。在 Cargo 项目中，传统上集成测试会放在这里。我们将很快通过使用单元测试来更改这个设置，但首先，让我们通过删除错误的
    `async_test` 设置测试来确保它能编译。在 `app.rs` 中，你可以删除那个函数以及其上的 `#[wasm_bindgen_test(async)]`
    宏，这样你的 `app.rs` 文件看起来就像这样：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: After this book has been published, the template will be fixed and will likely
    compile. I'm going to assume this, regardless of you changing the code, so that
    it matches what is here going forward.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书出版后，模板将被修复，并且很可能会编译。我将假设这一点，无论你如何更改代码，以便它与此处的内容相匹配。
- en: Some of the `use` declarations aren't needed anymore, but they will be short
    so you can leave them in and ignore the warnings. Now, `app.rs` contains two tests
    – one that will run in a JavaScript environment, such as the browser, and one
    that will run as a native Rust test. Both of these are just examples, where `1`
    is still equal to `1`. To run the native Rust tests, you can run `cargo test`,
    as you might be accustomed to. That will run the `rust_test` function, which is
    annotated with the `test` macro. You can run the browser-based tests, which are
    annotated with the `wasm_bindgen_test` macro, via the `wasm-pack test --headless
    --chrome` command. This will run the web tests using the Chrome browser, in a
    headless environment. You can also use `--firefox`, `--safari`, and `--node` if
    you wish, but you must specify what JavaScript environment you'll be running them
    in. Note that `--node` isn't going to work since it doesn't have a browser.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `use` 声明不再需要了，但它们将很短，所以你可以保留它们并忽略警告。现在，`app.rs` 包含了两个测试 - 一个将在 JavaScript
    环境中运行，例如浏览器，另一个将作为原生 Rust 测试运行。这两个都只是示例，其中 `1` 仍然等于 `1`。要运行原生 Rust 测试，你可以运行 `cargo
    test`，就像你可能习惯的那样。这将运行带有 `test` 宏注解的 `rust_test` 函数。你可以通过 `wasm-pack test --headless
    --chrome` 命令运行基于浏览器的测试，这些测试带有 `wasm_bindgen_test` 宏。这将使用 Chrome 浏览器在无头环境中运行网络测试。你也可以使用
    `--firefox`、`--safari` 和 `--node`，如果你愿意，但你必须指定你将在哪个 JavaScript 环境中运行它们。请注意，`--node`
    不会工作，因为它没有浏览器。
- en: We'll start writing tests using the `#[test]` macro, which runs Rust code in
    the native environment, just like writing a standard Rust program. The simplest
    thing to test is a pure function, so let's try that.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始使用 `#[test]` 宏编写测试，这个宏在原生环境中运行 Rust 代码，就像编写一个标准的 Rust 程序一样。要测试的最简单的事情是一个纯函数，所以让我们试试。
- en: Pure functions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: '`#[test]` annotation and run with `cargo test`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[test]` 注解并使用 `cargo test` 运行。'
- en: 'The current setup runs our only Rust test in the `test/app.rs` file, which
    makes it, as far as Cargo is concerned, an integration test. I don''t like that
    and prefer to use the Rust convention of writing unit tests in the file where
    the code is executed. In this first example, we''ll test the `intersects` function
    on `Rect`, which is a pure function that is complicated enough to mess up. We''ll
    add this test to the bottom of `engine.rs` because that''s where `Rect` is defined,
    and we''ll run it with `cargo test`. Let''s add a test to the bottom of the module
    for the `intersect` method on `Rect`, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当前设置在 `test/app.rs` 文件中运行我们唯一的 Rust 测试，这使得在 Cargo 看来，它是一个集成测试。我不喜欢这样，更愿意使用 Rust
    习惯在执行代码的文件中编写单元测试。在这个第一个例子中，我们将测试 `Rect` 上的 `intersects` 函数，这是一个复杂到足以出错的自纯函数。我们将把这个测试添加到
    `engine.rs` 文件的底部，因为 `Rect` 就是在那里定义的，然后我们将使用 `cargo test` 运行它。让我们在这个模块的底部添加一个测试，用于
    `Rect` 上的 `intersect` 方法，如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Much of this is documented in the Rust book at [https://bit.ly/3bNBH3H](https://bit.ly/3bNBH3H),
    but a little review never hurts anyone. We start by using the `#[cfg(test)]` attribute
    macro to tell Cargo not to compile and run this code except when we''re running
    tests. Then, we create a `tests` module using the `mod` keyword to isolate our
    tests from the rest of the code. After that, we import the `engine` code with
    `use super::*`. Then, we write our test by writing a function, `two_rects_that_intersect_on_the_left`,
    which is annotated with the `#[test]` macro so that the test runner can pick it
    up. The rest of this is a pretty standard test. It creates two rectangles, where
    the second overlaps the first, and then makes sure that the `intersects` function
    returns `true`. You can run this test with `cargo test`, where you''ll see the
    following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分内容在 Rust 书籍中有记录，见 [https://bit.ly/3bNBH3H](https://bit.ly/3bNBH3H)，但复习一下永远不会有害。我们首先使用
    `#[cfg(test)]` 属性宏告诉 Cargo 不要编译和运行此代码，除非我们在运行测试。然后，我们使用 `mod` 关键字创建一个 `tests`
    模块，以将我们的测试与代码的其他部分隔离开。之后，我们使用 `use super::*` 导入 `engine` 代码。然后，我们通过编写一个函数 `two_rects_that_intersect_on_the_left`
    并用 `#[test]` 宏注解它来编写我们的测试，这样测试运行器就可以找到它。其余的都是一个相当标准的测试。它创建了两个矩形，第二个矩形与第一个矩形重叠，然后确保
    `intersects` 函数返回 `true`。你可以使用 `cargo test` 运行这个测试，你将看到以下输出：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You'll see two sets of results. The first result references our new test, `two_rects_that_intersect_on_the_left`,
    which will pass. Then, you will see `rust_test` run, which will also pass. The
    `rust_test` test is in `tests\app.rs` and was created with the project skeleton.
    It is run as an integration test because it is in the `tests` directory – this
    is the Cargo standard. The difference between unit tests and integration tests
    is that the integration tests are run as a separate crate and use the production
    code as a separate library. This means they use the code in the same way a user
    of your crate would, but they cannot call internal or private functions. It's
    easier to get complete coverage when you're running unit tests with the caveat
    that they may be less realistic. Our code is not meant to be used as a crate,
    so we won't be using many integration tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到两组结果。第一个结果是关于我们的新测试`two_rects_that_intersect_on_the_left`，它将通过。然后，你会看到`rust_test`运行，它也将通过。`rust_test`测试位于`tests\app.rs`中，它是与项目骨架一起创建的。因为它位于`tests`目录中，所以它作为一个集成测试运行——这是Cargo的标准。单元测试和集成测试之间的区别在于，集成测试作为一个单独的crate运行，并使用生产代码作为单独的库。这意味着它们以与你的crate用户相同的方式使用代码，但它们不能调用内部或私有函数。当你运行单元测试时，更容易获得完整的覆盖率，但有一个前提是它们可能不太现实。我们的代码不是作为crate使用的，所以我们不会使用很多集成测试。
- en: 'Now that we''ve written our first unit test for our code, we can write a lot
    more tests for this `intersects` method, including when the following occurs:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的代码编写了第一个单元测试，我们可以为这个`intersects`方法编写更多测试，包括以下情况发生时：
- en: When the rectangles overlap on the top or bottom
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当矩形在顶部或底部重叠时
- en: When the rectangles overlap on the right
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当矩形在右侧重叠时
- en: When the rectangles *don't* overlap – that is, when the function returns false
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当矩形*不*重叠时——也就是说，当函数返回false时
- en: We should have a test for every branch in the `intersects` function. We leave
    these tests as an exercise for you since repeating them would be redundant. As
    our code base grows, it would be ideal if much of our code could easily be tested
    like this, but unfortunately, for this game, a lot of it interacts with the browser,
    so we will have two different ways to test that. The first way is to replace the
    browser with a stub so that we don't need to run browser-based tests. We'll do
    that in the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在`intersects`函数的每个分支都有一个测试。我们将这些测试留给你作为练习，因为重复它们将是多余的。随着我们的代码库增长，如果大部分代码可以像这样轻松地进行测试，那将是理想的，但不幸的是，对于这个游戏，很多代码都与浏览器交互，因此我们将有两种不同的测试方式。第一种方式是用存根替换浏览器，这样我们就不需要运行基于浏览器的测试。我们将在下一节中这样做。
- en: Hiding the Browser module
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏浏览器模块
- en: Way back in [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063), *Creating
    a Game Loop*, we separated browser functions into a `browser` module. We can use
    this as a **seam** to inject test versions of the browser functions that will
    run as native Rust code and allow us to write tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)“创建游戏循环”中，我们将浏览器功能分离到了一个`browser`模块中。我们可以利用这个**接口**注入测试版本的浏览器功能，使其作为原生Rust代码运行，并允许我们编写测试。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The term **seam** comes from the book *Working Effectively with Legacy Code*,
    by Michael Feathers ([https://amzn.to/3kas1Fa](https://amzn.to/3kas1Fa)). It's
    written in C++ and Java but is still the best book on legacy code you can find.
    A seam is a place where you can insert test behavior to replace real behavior,
    while an **enabling point** is a point in the code that allows that to happen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**接口**来自迈克尔·费瑟斯的书籍《与遗留代码有效协作》（[https://amzn.to/3kas1Fa](https://amzn.to/3kas1Fa)）。这本书是用C++和Java编写的，但仍然是你可以找到的关于遗留代码的最佳书籍。接口是一个可以插入测试行为以替换真实行为的地方，而**启用点**是代码中允许这种情况发生的地方。
- en: 'A seam is somewhere we can alter the behavior of the program without altering
    the code in that place. Look at the following code from the `game` module:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是我们可以在不更改该处代码的情况下改变程序行为的地方。看看`game`模块中的以下代码：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We'd like to test that when the game goes from the `GameOver` state to the `Ready`
    state, the UI is hidden. We can do this with integration tests by checking whether
    the `div` property that contains the UI is empty after this transition. We may
    want to do this, but such tests are frequently a little harder to write and maintain.
    This is especially true as the game grows. Another approach, which we'll use here,
    is to replace the `browser` module with a version of it that doesn't interact
    with the browser. The seam is `hide_ui`, which is a behavior we can replace without
    actually changing the code, while the enabling point is the `use` declaration,
    which is where we brought in the `browser` module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想测试当游戏从 `GameOver` 状态转换为 `Ready` 状态时，UI 是否被隐藏。我们可以通过集成测试来完成这项工作，检查在这次转换之后包含
    UI 的 `div` 属性是否为空。我们可能想这样做，但这样的测试通常编写和维护起来要困难一些。当游戏增长时，这一点尤其正确。另一种方法，我们将在这里使用，是用不与浏览器交互的
    `browser` 模块的版本来替换它。接口是 `hide_ui`，这是一种我们可以替换而不实际更改代码的行为，而启用点是 `use` 声明，这是我们引入
    `browser` 模块的地方。
- en: 'We can enable using a test version of the `browser` module with conditional
    compilation. In the same way that the `#[cfg(test)]` macro only includes the `test`
    module when compiling in test mode, we can import different versions of the `browser`
    module with `cfg` directives, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过条件编译启用使用 `browser` 模块的测试版本。与 `#[cfg(test)]` 宏仅在测试模式下编译时包含 `test` 模块的方式相同，我们可以使用
    `cfg` 指令导入 `browser` 模块的不同版本，如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code can be found at the top of the `game` module, where we were
    previously importing `crate::browser`. Here, we can use the `mod` keyword to bring
    the contents of the `test_browser` module in from the `src/game/test_browser.rs`
    file, but only when we're running a `test` build. Then, we can use `test_browser
    as browser` to make the functions available via `browser::` calls – again, only
    in test builds – in the same way as we call the `browser` production code. Finally,
    we can add the `#[cfg(not(test))]` annotation to `use crate::browser` to prevent
    the real `browser` code from being imported into the test.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以在 `game` 模块的顶部找到，我们之前在这里导入 `crate::browser`。在这里，我们可以使用 `mod` 关键字从 `src/game/test_browser.rs`
    文件中引入 `test_browser` 模块的 内容，但仅在我们运行测试构建时。然后，我们可以使用 `test_browser as browser` 使函数通过
    `browser::` 调用来可用 – 同样，仅在测试构建中 – 就像我们调用生产代码中的 `browser` 一样。最后，我们可以添加 `#[cfg(not(test))]`
    注解到 `use crate::browser` 以防止将真实的 `browser` 代码导入到测试中。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I first saw this technique on Klausi's Weblog at [https://bit.ly/3ENxhWQ](https://bit.ly/3ENxhWQ),
    but it is fairly common in Rust code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次在 Klausi 的博客上看到这项技术，[https://bit.ly/3ENxhWQ](https://bit.ly/3ENxhWQ)，但在
    Rust 代码中相当常见。
- en: 'If you do this and run `cargo test`, you''ll see a lot of errors, such as ``
    cannot find function `fetch_json` in module `browser` ``, because even though
    we''re importing a test module, we haven''t filled it in with any code. In this
    situation, it''s a good idea to follow the compiler errors, which will point out
    that there''s no file yet in `src/game/test_browser.rs`. It will also list the
    functions that are used in the `game` module but aren''t defined in our `test_browser.rs`
    file. To get past this, you can create the `test_browser.rs` file and bring in
    the bare minimum that''s needed to get back to compiling, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做并运行 `cargo test`，你会看到很多错误，例如 `cannot find function `fetch_json` in module
    `browser` ``，因为尽管我们正在导入一个测试模块，但我们还没有用任何代码填充它。在这种情况下，遵循编译器错误是一个好主意，它会指出在 `src/game/test_browser.rs`
    中还没有文件。它还会列出在 `game` 模块中使用但未在 `test_browser.rs` 文件中定义的函数。为了解决这个问题，你可以创建 `test_browser.rs`
    文件，并引入所需的最小内容以重新开始编译，如下所示：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, only four functions are used in `game` that have been defined
    in `browser`, and we''ve filled in just enough to compile. To use this for testing,
    we''re going to need to place simulated implementations with some sort of state
    they keep track of. The other thing you may notice is that `JsValue` and `HtmlElement`
    are both being used in this code since they won''t work when you run Rust native
    tests. They require a browser runtime, so to continue along this path, we''ll
    eventually need to make test versions of `HtmlElement` and `JsValue` or create
    wrapper types for them, potentially in the `engine` module. Let''s leave those
    as is for now, though, and try to write our first test using the standard Rust
    testing framework. We''ll want to test the state machine change I mentioned previously
    by setting up the game in the `GameOver` state and transitioning to the `Running`
    state, then checking that the UI was hidden. The *beginning* of that test looks
    as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`game`模块中只使用了四个在`browser`中定义过的函数，而我们只填入了足够编译的代码。为了进行测试，我们需要放置一些具有某种跟踪状态的模拟实现。您可能还会注意到，由于在运行Rust原生测试时它们无法工作，所以这段代码中同时使用了`JsValue`和`HtmlElement`。它们需要一个浏览器运行时，因此为了继续沿着这条路径前进，我们最终需要为`HtmlElement`和`JsValue`创建测试版本，或者为它们创建包装类型，这可能在`engine`模块中完成。不过，现在我们先保留这些不变，尝试使用标准的Rust测试框架编写我们的第一个测试。我们将通过设置游戏在`GameOver`状态并过渡到`Running`状态来测试我之前提到的状态机变化，然后检查UI是否被隐藏。该测试的*开始部分如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Oh boy – that's a lot of code to test a few lines of Rust, and it's not even
    a complete test yet. It's just setting up the game in the state that we need it
    to be in *before* we transition into a `Ready` state. A lot is being revealed
    about our design, specifically that it's what I may call *naïve'*. It's very hard
    to construct objects, and while the `game`, `engine`, and `browser` modules are
    separate, they are still pretty tightly coupled. It works but it in a fashion
    that only solves the problem in front of us. That's completely acceptable – we
    had specific goals to build a small endless runner and we did it, but this also
    means that if we wanted to start extending our game engine so that it's more flexible,
    we would need to make further changes. I tend to view software design more like
    sculpting than constructing. You start with a big block of code and chip away
    at it until it looks like what you want, rather than a blueprint that you follow
    to get the perfect house.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀——测试这么多的代码只是为了测试几行Rust，而且这甚至不是一个完整的测试。它只是设置游戏到我们需要它处于的状态，*在我们过渡到`Ready`状态之前*。这揭示了关于我们设计的大量信息，特别是它可能是我所说的*天真*。构建对象非常困难，尽管`game`、`engine`和`browser`模块是分开的，但它们仍然相当紧密地耦合在一起。它确实可以工作，但只是在解决我们面前的问题。这是完全可以接受的——我们有一个具体的目标，那就是构建一个小型的无限跑酷游戏，我们做到了，但这同时也意味着，如果我们想要开始扩展我们的游戏引擎，使其更加灵活，我们就需要做出进一步的改变。我倾向于将软件设计看作是雕刻，而不是构建。你从一个大块的代码开始，然后逐渐雕刻，直到它看起来像你想要的样子，而不是遵循蓝图来建造完美的房子。
- en: 'Some of the aspects of our design that this test is revealing are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试揭示了我们设计的一些方面如下：
- en: It's not easy to create new `Walk` structures.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的`Walk`结构并不容易。
- en: The `game` module is far more coupled to `web-sys` and `wasm-bindgen` than we
    thought.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`game`模块与`web-sys`和`wasm-bindgen`的耦合程度远超我们的想象。'
- en: We made the intentional choice not to try and create perfect abstractions early
    in the project. This is one of the reasons we didn't write this code in a test-driven
    style initially. TDD would have strongly pushed in the direction of further abstraction
    and layering, which would have hidden the game code we're trying to learn here.
    As an example, instead of using `HtmlImageElement` or `AudioBuffer`, we may have
    written wrappers or abstractions around those objects (we already have an `Image`
    struct), which is probably better for growing our project in the medium to long
    term but is harder to understand in the short term.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有意选择不在项目早期尝试创建完美的抽象。这也是我们最初没有以测试驱动的方式编写代码的原因之一。TDD会强烈推动进一步抽象和分层，这可能会隐藏我们试图学习的游戏代码。例如，我们可能不会使用`HtmlImageElement`或`AudioBuffer`，而是围绕这些对象编写包装器或抽象（我们已经有了一个`Image`结构体），这在中等或长期内可能更有利于项目的发展，但在短期内可能更难理解。
- en: 'This is a long-winded way of saying that this code is now hard to write isolated
    unit tests for because we didn''t build it with them in mind. If you were able
    to run this test, you would see the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种冗长的说法，意思是由于我们没有考虑到这一点，现在很难为这段代码编写独立的单元测试。如果你能运行这个测试，你会看到以下内容：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It turns out that even though we replaced the production `browser` with `test_browser`,
    we're still trying to call browser code. I have already pointed out `HtmlElement`
    and `JsValue`, but this test also includes `AudioBuffer` and `AudioBufferOptions`.
    As is, this code doesn't compile without more feature flags being enabled and
    changes being made to `engine`. It's just too tightly coupled to the browser still.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，尽管我们用`test_browser`替换了生产中的`browser`，但我们仍在尝试调用浏览器代码。我已经指出了`HtmlElement`和`JsValue`，但这个测试还包括`AudioBuffer`和`AudioBufferOptions`。按照现在的样子，如果没有启用更多功能标志并对`engine`进行更改，这段代码是无法编译的。它仍然与浏览器耦合得太紧密了。
- en: The act of trying to use this code in a test harness demonstrated the power
    of coupling, and it is often useful to take legacy code and get it into a harness
    to identify these dependency problems and break them. Unfortunately, this is a
    time-consuming process that we are not going to continue using in this section,
    although it may appear on my blog at [paytonrules.com](http://paytonrules.com)
    at some point. Instead, we'll test this code via a test that runs in the browser.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在测试框架中使用此代码的行为展示了耦合的力量，通常将遗留代码放入框架中，以识别这些依赖问题并解决它们是非常有用的。不幸的是，这是一个耗时过程，我们不会在本节中继续使用它，尽管它可能会在我的博客[paytonrules.com](http://paytonrules.com)上某个时候出现。相反，我们将通过在浏览器中运行的测试来测试此代码。
- en: Browser tests
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器测试
- en: At the beginning of this chapter, I mentioned that there were **unit tests**
    and **browser tests**. The distinction is that while browser tests may test the
    same behavior as a unit test, they automate the desired behavior in a headless
    browser. This makes the test more realistic, but also slower and more prone to
    breaking for flaky reasons. I prefer my systems to have a large base of unit tests
    and a smaller number of more integrated tests to make sure everything is all wired
    together correctly, but we can't always get what we want.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我提到过有**单元测试**和**浏览器测试**。区别在于，虽然浏览器测试可能与单元测试测试相同的行为，但它们在无头浏览器中自动化了所需的行为。这使得测试更加真实，但同时也更慢，更容易因为不稳定的原因而失败。我更喜欢我的系统有一个大量的单元测试和较少的更集成的测试，以确保一切连接正确无误，但我们并不总能得到我们想要的结果。
- en: 'Instead, we''ll get what we need – verification of the behavior – by skipping
    dependency-breaking techniques for legacy code and writing a test that runs in
    the browser. We''ll remove the code that added the `test_browser` module, as well
    as the `test_browser` file itself. We''ll keep the test we wrote previously and
    make two changes for it to compile, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将通过跳过针对遗留代码的依赖破坏技术，并编写一个在浏览器中运行的测试来获取我们所需的东西——行为的验证。我们将移除添加了`test_browser`模块的代码，以及`test_browser`文件本身。我们将保留之前编写的测试，并对其进行两项更改，如下所示：
- en: Add `AudioBufferOptions` to the list of `web-sys` features in `Cargo.toml`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AudioBufferOptions`添加到`Cargo.toml`中`web-sys`功能列表中。
- en: In the `engine` module, make the `buffer` field on the `Sound` struct public
    so that we can create `Sound` directly in this test.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`engine`模块中，将`Sound`结构体上的`buffer`字段设置为公共的，这样我们就可以在这个测试中直接创建`Sound`。
- en: 'These two changes will get the code compiling, but it won''t make it run in
    the tests yet. For that, we need to make a couple of changes. First, we need to
    change the `#[test]` macro to `#[wasm_bindgen_test]`. Then, we need to add two
    statements to our `test` module, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这两项更改将使代码能够编译，但还不会使其在测试中运行。为此，我们需要进行一些更改。首先，我们需要将`#[test]`宏更改为`#[wasm_bindgen_test]`。然后，我们需要向我们的`test`模块添加两个语句，如下所示：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first line to add is `use wasm_bindgen_test::wasm_bindgen_test` so that
    the macro is present. The second is `wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);`.
    This directive tells the test runner to run in the browser so that the code can
    interact with the DOM, similar to how the application does. This test won''t run
    in `cargo test`, so you''ll need to use the `wasm-pack test --headless –chrome`
    command. This will run the web tests in a headless version of the Chrome browser.
    When you run them, you should see the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要添加的是`use wasm_bindgen_test::wasm_bindgen_test`，以便宏存在。第二是`wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);`。这个指令告诉测试运行器在浏览器中运行，以便代码可以与DOM交互，类似于应用程序的方式。这个测试不会在`cargo
    test`中运行，所以你需要使用`wasm-pack test --headless –chrome`命令。这将使用Chrome浏览器的无头版本运行Web测试。当你运行它们时，你应该看到以下输出：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we have a test that''s running and passing, but the only problem is that
    we don''t have any assertions. We''ve written an "arrange" step but we haven''t
    checked the results. The point of this test was to make sure that the UI was hidden
    when the state transition happened, so we''ll need to update the test to check
    that. We can do this by adding the action and assertion steps, as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个正在运行且通过测试，但唯一的问题是我们没有任何断言。我们已经编写了一个“安排”步骤，但还没有检查结果。这个测试的目的是确保当状态转换发生时UI被隐藏，因此我们需要更新测试来检查这一点。我们可以通过添加动作和断言步骤来实现，如下所示：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we start the test by inserting the `div` property, along with the `ui`
    ID, into the document – after all, that is in `index.html` in the game. Then,
    `browser::draw_ui` draws the UI to the browser, even though the browser is running
    headlessly, so we don''t see it. We continue by creating `WalkTheDogState` in
    the `GameOver` state; on the next line, we have it transition to `Ready` via the
    `state.new_game()` method. Finally, we check that the UI was cleared by finding
    the `div` property and checking its `child_element_count`. If it''s `0`, the code
    is right, and this test will pass. If you run this test, you''ll see that this
    test *does* pass, so you will probably want to comment out the `let next_state:
    WalkTheDogState<Ready> = state.``()` line and run it again just to make sure it
    fails when the transition happens.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们通过将`div`属性和`ui` ID插入到文档中来开始测试——毕竟，这是在游戏的`index.html`中。然后，`browser::draw_ui`将UI绘制到浏览器中，即使浏览器是无头运行的，所以我们看不到。我们继续在`GameOver`状态中创建`WalkTheDogState`；在下一行，我们通过`state.new_game()`方法将其转换为`Ready`状态。最后，我们通过查找`div`属性并检查其`child_element_count`来检查UI是否被清除。如果它是`0`，代码就是正确的，这个测试将会通过。如果你运行这个测试，你会看到这个测试*确实*通过了，所以你可能想要注释掉`let
    next_state: WalkTheDogState<Ready> = state.`这一行，然后再次运行以确保在转换发生时测试失败。'
- en: This is still a very long test but at least it's working. The test can be cleaned
    up by creating some factory methods in the various modules so that structs are
    easier to create. You'll notice that the test is full of `unwrap` calls. This
    is because, in a test, I want things to crash right away if they aren't as expected.
    Unfortunately, browser-based tests with the `wasm_bindgen_test` macro do not let
    you return a `Result` for readability as standard Rust tests do yet. This is another
    reason you should try and make your tests run as native Rust tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一个非常长的测试，但至少它在工作。可以通过在各个模块中创建一些工厂方法来清理测试，这样就可以更容易地创建结构体。你会注意到测试中充满了`unwrap`调用。这是因为，在测试中，我希望如果事情不是预期的，它们立即崩溃。不幸的是，基于浏览器的测试使用`wasm_bindgen_test`宏并不允许你像标准Rust测试那样返回`Result`以提高可读性。这是你应该尝试使你的测试以原生Rust测试方式运行的原因之一。
- en: Async tests
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步测试
- en: One of the biggest challenges of testing web applications, whether they're Wasm
    or traditional JavaScript ones, is code that occurs `async` block or function.
    Imagine calling a function in an `async` test and then immediately trying to verify
    it worked. By definition, you can't, because it's running asynchronously and may
    not have finished yet. Fortunately, `wasm_bindgen_test` handles this rather easily
    by making the test's functions `async` themselves.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Web应用程序的最大挑战之一，无论是Wasm还是传统的JavaScript应用程序，都是在`async`块或函数中发生的代码。想象一下在一个`async`测试中调用一个函数，然后立即尝试验证它是否工作。根据定义，你不能这样做，因为它是异步运行的，可能还没有完成。幸运的是，`wasm_bindgen_test`通过使测试函数本身是`async`的来非常容易地处理这个问题。
- en: 'Let''s look at a simpler example and try to write a test for the `load_json`
    function in the `browser` module:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更简单的例子，并尝试为`browser`模块中的`load_json`函数编写一个测试：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This can be found in the `browser` module. Here, we start with the boilerplate
    to set up a `tests` module, import both `browser` and `wasm_bindgen_test`, and
    configure the test to run in the browser. The test itself is only two lines. Try
    to load a `JSON` file that doesn''t exist and report an error. The key difference
    between this is that the test is `async`, which allows us to use `await` in the
    test and write the assertion without adding any "wait for" logic. This is great,
    but there are a couple of things to keep in mind:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在`browser`模块中找到。在这里，我们首先使用样板代码来设置一个`tests`模块，导入`browser`和`wasm_bindgen_test`，并配置测试在浏览器中运行。测试本身只有两行。尝试加载一个不存在的`JSON`文件并报告错误。这个测试的关键区别在于它是`async`的，这允许我们在测试中使用`await`并在不添加任何“等待”逻辑的情况下编写断言。这很好，但有几件事情需要记住：
- en: If `fetch_json` can hang, this test will hang.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`fetch_json`可能会挂起，这个测试也会挂起。
- en: This test will try to load a file. Ideally, we don't want to do this in a unit
    test.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个测试将尝试加载一个文件。理想情况下，我们不想在单元测试中这样做。
- en: This test will run and pass. We could test all of the `browser` functions this
    way, accepting that the `browser` module's tests will use the filesystem as needed.
    That's probably what I would do if I was handed this system in a professional
    environment. You could work very hard to stub out the actual browser on these
    tests, but to do so would remove its ability to prevent defects. After all, if
    you remove the browser from the `browser` module, then how do you know you got
    the code right?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将会运行并通过。我们可以用这种方式测试所有的`browser`函数，接受`browser`模块的测试将需要使用文件系统。如果我在专业环境中接手这个系统，我可能会这样做。你可以非常努力地模拟这些测试中的实际浏览器，但这样做会消除其防止缺陷的能力。毕竟，如果你从`browser`模块中移除浏览器，你怎么知道代码是正确的？
- en: 'If I was given this code and asked to maintain it, I would likely adopt the
    following strategies:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我被分配了这段代码并要求维护它，我可能会采用以下策略：
- en: Curse the name of the jerk who wrote it without tests (me!).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 咒骂那个没有编写测试就写代码的家伙的名字（就是我！）。
- en: Write tests for code as I need to change it. If it doesn't change, don't bother.
    Go ahead and use browser automation, as we did previously.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要更改代码时编写测试。如果它没有变化，就别麻烦了。继续使用浏览器自动化，就像我们之前做的那样。
- en: Over time, move more code that depends on `wasm-bindgen` and `web-sys` into
    the `browser` module so that `engine` and `game` can stub it out.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移，将更多依赖于`wasm-bindgen`和`web-sys`的代码移入`browser`模块，以便`engine`和`game`可以模拟它。
- en: Write as many tests as possible as Rust-native tests, and then make the browser-based
    unit tests native whenever possible.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能多地编写尽可能多的Rust原生测试，然后尽可能地将基于浏览器的单元测试本地化。
- en: As for integration tests, I doubt I would write any integration tests in the
    Cargo sense. For Cargo libraries, all the integration tests are written in the
    `tests` directory and compiled as a separate package. This is a great idea when
    you're writing a library that's going to be consumed by other people, but we are
    writing an application and aren't providing an API. The integration tests I would
    write would be any tests that use the real browser, but those are integration
    tests in the sense that they are integrated with the web browser, not that they
    run as Rust integration tests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关于集成测试，我怀疑我会在Cargo的意义上编写任何集成测试。对于Cargo库，所有的集成测试都是写在`tests`目录中，并作为一个单独的包编译。当你编写一个将被其他人使用的库时，这是一个很好的主意，但我们正在编写一个应用程序，并没有提供API。我会编写的集成测试是任何使用真实浏览器的测试，但这些测试在意义上是集成在浏览器中的，而不是作为Rust集成测试运行。
- en: However, we can't just rely on adding tests to make sure our code works. Sometimes,
    we just have to debug it. Let's dig into that next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能仅仅依靠添加测试来确保我们的代码工作。有时，我们只是必须调试它。让我们深入探讨这一点。
- en: Debugging the game
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏调试
- en: To debug a traditional program, be it in Java, C#, or C++, we must set breakpoints
    and step through the code. In JavaScript, we can type the word `debugger` to set
    a breakpoint, but although WebAssembly runs in the browser, it isn't JavaScript.
    So, how do we debug it?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试一个传统的程序，无论是Java、C#还是C++，我们必须设置断点并逐步执行代码。在JavaScript中，我们可以输入单词`debugger`来设置断点，但尽管WebAssembly在浏览器中运行，但它不是JavaScript。那么，我们如何调试它？
- en: There's a lot of conflicting information about debugging with WebAssembly. How
    do you debug WebAssembly? Well, according to the official Rust WebAssembly documentation,
    it's simple – you can't!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用WebAssembly进行调试的信息很多，但如何调试WebAssembly呢？根据官方的Rust WebAssembly文档，很简单——你不能！
- en: Unfortunately, the debugging story for WebAssembly is still immature. On most
    Unix systems, DWARF is used to encode the information that a debugger needs to
    provide source-level inspection of a running program. There is an alternative
    format that encodes similar information on Windows. Currently, there is no equivalent
    for WebAssembly. Therefore, debuggers currently provide limited utility, and we
    end up stepping through raw WebAssembly instructions emitted by the compiler,
    rather than the Rust source text we authored.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，WebAssembly的调试故事仍然不成熟。在大多数Unix系统中，DWARF用于编码调试器需要提供源代码级别的程序检查所需的信息。在Windows上有一个替代格式，它以类似的方式编码了相似的信息。目前，WebAssembly还没有等效的格式。因此，当前的调试器提供的功能有限，我们最终只能通过编译器输出的原始WebAssembly指令来逐步执行，而不是我们编写的Rust源代码。
- en: – [https://rustwasm.github.io/docs/book/reference/debugging.html](https://rustwasm.github.io/docs/book/reference/debugging.html)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: – [https://rustwasm.github.io/docs/book/reference/debugging.html](https://rustwasm.github.io/docs/book/reference/debugging.html)
- en: So, there you have it – no debugging, section over. That was easy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是全部内容——没有调试，章节结束。这很简单。
- en: But it's not that simple. Of course, you can debug your application – you just
    can't use your browser's developer tools to step through the Rust code in a debugger.
    The technology isn't there yet. But that doesn't mean we don't debug; it just
    means we'll take more of an old-school approach to debugging.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但事情并非如此简单。当然，你可以调试你的应用程序——你只是不能使用浏览器开发者工具逐步执行调试器中的Rust代码。这项技术还没有准备好。但这并不意味着我们不进行调试；它只是意味着我们将采取更传统的调试方法。
- en: Earlier, I mentioned that when I write code, I typically write a lot of tests.
    I also typically don't use a debugger very often. If we break our code into smaller
    chunks that can be easily exercised by tests, a debugger is rarely required. That
    said, we didn't do that for this project, so we'll need a way to debug existing
    code. We'll start by logging, then getting stack traces, and finally using linters
    to prevent bugs before they happen.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到当我编写代码时，我通常会编写很多测试。我也通常不太常用调试器。如果我们把代码分成小块，这些小块可以很容易地通过测试来执行，那么调试器就很少需要了。话虽如此，我们没有在这个项目中这样做，所以我们需要一种调试现有代码的方法。我们将从记录开始，然后获取堆栈跟踪，最后使用linters来防止在发生之前出现错误。
- en: Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The reality is not as cut and dry as the Rust Wasm site would state. Chrome
    developer tools have added support for the `wasm-bindgen` at the time of writing.
    You can see progress on this issue here: [https://github.com/rustwasm/wasm-bindgen/issues/2389](https://github.com/rustwasm/wasm-bindgen/issues/2389).
    By the time you read this book, the debugging tools may be modernized in Rust
    Wasm, as well as in browsers outside of Chrome, but for the time being, we must
    use more traditional tools such as `println!` and logging.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 事实并非像Rust Wasm网站所陈述的那样简单明了。在撰写本文时，Chrome开发者工具已经添加了对`wasm-bindgen`的支持。你可以在这里看到这个问题的进展：[https://github.com/rustwasm/wasm-bindgen/issues/2389](https://github.com/rustwasm/wasm-bindgen/issues/2389)。到你阅读这本书的时候，Rust
    Wasm以及Chrome以外的浏览器的调试工具可能已经现代化了，但到目前为止，我们必须使用更传统的工具，如`println!`和日志。
- en: Log versus error versus panic
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志、错误与恐慌
- en: 'If you''ve been following along and got confused at some point, then you''ve
    probably used the `log!` macro we wrote in [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*, to see what was going on. If you have been doing that,
    congratulations! You''ve been debugging the same way I did when I wrote the code
    originally. Print line debugging is still standard in many languages and it''s
    pretty much the only form of debugging that''s guaranteed to work anywhere. If
    you haven''t done that, then it looks like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟随并在这个过程中感到困惑，那么你很可能使用了我们在[*第3章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)“创建游戏循环”中编写的`log!`宏来查看发生了什么。如果你一直在这样做，恭喜你！你一直在用与我最初编写代码时相同的方式进行调试。打印行调试在许多语言中仍然是标准做法，并且几乎是唯一保证在任何地方都能工作的调试形式。如果你没有这样做，那么它看起来是这样的：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example, we are logging `KeyState` on every tick through the
    `update` function. This isn''t a great log because it''s going to show an empty
    `KeyState` 60 times a second, but it''s good enough for our purposes. However,
    there''s one flaw in this log: `KeyState` doesn''t implement the `Debug` trait.
    You can add it by adding the `derive(Debug)` annotation to the `KeyState` struct,
    like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过`update`函数在每一刻记录`KeyState`。这不是一个很好的日志，因为它会每秒显示60次空的`KeyState`，但对于我们的目的来说已经足够好了。然而，这个日志有一个缺陷：`KeyState`没有实现`Debug`特质。你可以通过在`KeyState`结构体上添加`derive(Debug)`注解来添加它，如下所示：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you add this, the console will log all your key state changes, which will
    be useful if your keyboard input is broken:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加这个功能时，控制台将记录所有您的键状态变化，这在您的键盘输入损坏时将非常有用：
- en: '![Figure 9.1 – Logging KeyState](img/Figure_9.01_B17151.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 记录 KeyState](img/Figure_9.01_B17151.jpg)'
- en: Figure 9.1 – Logging KeyState
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 记录 KeyState
- en: 'In general, any `pub struct` should `use` `#[derive(Debug)]`, but this isn''t
    the default option since it could make compile times long on large projects. When
    in doubt, go ahead and `use` `#[derive(Debug)]` and log the information. Now,
    maybe `log!` isn''t noticeable enough for you, and you want the text to be bright,
    obvious, and red. For that, you''ll need to use `console.error` in JavaScript
    and write a macro such as the `log` macro, which we already have in the `browser`
    module. This macro looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，任何 `pub struct` 都应该 `use` `#[derive(Debug)]`，但这不是默认选项，因为它可能会使大型项目的编译时间变长。当不确定时，请继续使用
    `#[derive(Debug)]` 并记录信息。现在，可能 `log!` 对您来说不够明显，您希望文本明亮、明显且为红色。为此，您需要使用 JavaScript
    中的 `console.error` 并编写一个类似于 `log` 宏的宏，我们已经在 `browser` 模块中有了这个宏。这个宏看起来是这样的：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is the same as the `log` macro but uses the `error` function on the `console`
    object. There are two advantages to the `error` function. The first is that it''s
    red, while the other is that it also will show you the stack trace. Here''s an
    example of `error` being called when the player is knocked out in Chrome:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `log` 宏相同，但使用 `console` 对象上的 `error` 函数。`error` 函数有两个优点。第一个是它是红色的，另一个优点是它还会显示堆栈跟踪。以下是一个在
    Chrome 中玩家被击倒时调用 `error` 的示例：
- en: '![Figure 9.2 – Error log](img/Figure_9.02_B17151.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 错误日志](img/Figure_9.02_B17151.jpg)'
- en: Figure 9.2 – Error log
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 错误日志
- en: It's not the most readable stack trace in the world, but after seeing a few
    lines of the `console::error_1` function, you can see that this log was called
    from `WalkTheDogState<Walking>::end_game`. This log is really for true errors,
    as opposed to just informational logging, and this stack trace may not show up
    clearly in all browsers. You'll also want to be cautious with leaving this log
    in the production code as you may not want to expose this much information to
    a curious player. We'll want to make sure it's not in the production deployment,
    which we'll create in [*Chapter 10*](B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226),
    *Continuous Deployment*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是世界上最易读的堆栈跟踪，但看过 `console::error_1` 函数的几行后，您可以看到这个日志是从 `WalkTheDogState<Walking>::end_game`
    调用的。这个日志实际上是针对真正的错误，而不是仅仅的信息记录，并且这个堆栈跟踪可能不会在所有浏览器中清晰地显示。您还希望谨慎地保留这个日志在生产代码中，因为您可能不希望向好奇的玩家暴露这么多信息。我们将确保它不在生产部署中，这将在
    [*第 10 章*](B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226) *持续部署* 中创建。
- en: 'Finally, if you want to make sure the program stops when an error occurs, we''ll
    want to go ahead and use the `panic`! macro. Some errors are recoverable but many
    are not, and we don''t want our program to limp along in a broken state. In [*Chapter
    1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015), *Hello WebAssembly*, we included
    the `console-error-panic-hook` crate so that if the program were to panic, we''d
    get a stack trace. Let''s replace calling `error`! with calling `panic`! and see
    the difference:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您想确保程序在发生错误时停止，我们将继续使用 `panic!` 宏。一些错误是可以恢复的，但许多不是，我们不希望我们的程序在损坏的状态下艰难前行。在
    [*第 1 章*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015) *Hello WebAssembly*
    中，我们包含了 `console-error-panic-hook` crate，以便如果程序崩溃，我们会得到一个堆栈跟踪。让我们将调用 `error`!
    替换为调用 `panic`! 并看看区别：
- en: '![Figure 9.3 – Panic log'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 潜意识日志'
- en: '](img/Figure_9.03_B17151.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B17151.jpg)'
- en: Figure 9.3 – Panic log
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 潜意识日志
- en: Here, you can see it looks a little different, but the information is mostly
    the same. There is one thing at the very top where it says `src/game.rs:829`,
    which tells you exactly where `panic` was called. In general, you will probably
    prefer to use `panic` compared to `error` if you need to have the error in your
    production code because that kind of error should be rare and fail fast. The `error`
    function is more useful during debugging, so you'll end up removing those.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到它看起来略有不同，但信息基本上是相同的。在最顶部有一个地方写着 `src/game.rs:829`，这告诉您 `panic` 被调用的确切位置。通常，如果您需要在生产代码中包含错误，您可能会更倾向于使用
    `panic` 而不是 `error`，因为这种错误应该是罕见的，并且应该快速失败。`error` 函数在调试期间更有用，所以您最终会移除那些。
- en: There's another kind of error that we've been ignoring at times, and that's
    the warnings and errors that are given to you by the compiler and linter. We can
    use the Rust ecosystem's tools to detect mistakes before we ever run the program.
    Let's look into that now.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会忽略另一种错误，那就是编译器和代码检查器给出的警告和错误。我们可以在运行程序之前使用 Rust 生态系统中的工具来检测错误。现在让我们来看看这个。
- en: Linting and Clippy
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查和Clippy
- en: 'One of the features that makes the Rust compiler great is that it has a linter
    built into it, in addition to the warnings and errors it already provides. If
    you''re unfamiliar, a linter is a static code analysis tool that typically finds
    style errors and, potentially, logic errors above and beyond what the compiler
    can find. The term comes from the lint you find on clothing, so you can think
    of using a linter like rubbing a lint brush on your code. We''ve been getting
    some warnings from the compiler that we''ve been ignoring for a while now, most
    of which look like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器之所以出色，其中一个特点就是它内置了一个检查器，除了它已经提供的警告和错误之外。如果你不熟悉，检查器是一种静态代码分析工具，它通常会发现样式错误，以及编译器可能无法发现的潜在逻辑错误。这个术语来自衣服上的
    lint，所以你可以把使用检查器想象成在你的代码上刷 lint 刷子。我们已经从编译器那里收到了一些警告，我们已经忽略了一段时间，其中大多数看起来像这样：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These are all cases where an error could occur, but we probably don''t want
    to crash if it does, so panicking or calling `unwrap` isn''t an option. Propagating
    the `Result` type is an option, but I don''t think we want to prevent moving from
    one state to another if there''s a small browser issue. So, instead, we''ll use
    the `error` case to log here. You can see it at `https://bit.ly/3q1936N` in the
    sample source code. Let''s modify the code so that we log any errors:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是可能发生错误的情况，但我们可能不希望它发生时崩溃，所以恐慌或调用 `unwrap` 不是选项。传播 `Result` 类型是一个选项，但我不认为我们想在存在小的浏览器问题时阻止从一个状态移动到另一个状态。因此，我们将使用
    `error` 情况在这里记录。你可以在 `https://bit.ly/3q1936N` 的示例源代码中看到它。让我们修改代码，以便记录任何错误：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we have changed the `browser::hide_ui()` line to `if let Err(err) = browser::hide_ui()`
    and we log if an error occurs. We can see what that error log will look like by
    forcing `hide_ui` to return an error for a moment:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `browser::hide_ui()` 行更改为 `if let Err(err) = browser::hide_ui()` 并在发生错误时进行记录。我们可以通过强制
    `hide_ui` 在一段时间内返回错误来查看错误日志将是什么样子：
- en: '![Figure 9.4 – A fake error'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – 一个假错误'
- en: '](img/Figure_9.04_B17151.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.04_B17151.jpg)'
- en: Figure 9.4 – A fake error
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 一个假错误
- en: The stack trace is cut off in book form, but you can see that we got an error
    log with `Error hiding the browser` and then `This is the error in the hide_ui
    function`, which is the error message I forced into `hide_ui`. The stack trace
    also shows `game::Ready`, which would show you that you were transitioning into
    the `Ready` state if you had infinite room to show the entire message.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍形式中，堆栈跟踪被截断，但你可以看到我们得到了一个错误日志，其中包含 `Error hiding the browser` 和 `This is
    the error in the hide_ui function`，这是我强制放入 `hide_ui` 的错误消息。堆栈跟踪还显示了 `game::Ready`，这会显示如果你有无限的空间来显示整个消息，你将正在过渡到
    `Ready` 状态。
- en: Every single warning that's being generated should be dealt with. Most of the
    warnings are the same kind – that is, `Result` types where the `Err` variant is
    ignored. These can be removed by handling the `Err` case with a log or by calling
    `panic` if the game should truly crash at this time. For the most part, I've used
    the `if let` pattern but if `request_animation_frame` fails, then I just use `unwrap`.
    I don't see how the game could work if that's failing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 应该处理所有生成的警告。大多数警告都是同一种类型，即 `Result` 类型，其中 `Err` 变体被忽略。这些可以通过处理 `Err` 情况并记录或调用
    `panic`（如果游戏确实应该在此时崩溃）来删除。大部分情况下，我使用了 `if let` 模式，但如果 `request_animation_frame`
    失败，我就使用 `unwrap`。我不认为如果那样失败，游戏能工作。
- en: 'There is one more warning we''ve been ignoring that we should address, as shown
    here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还忽略了一个警告，但我们应该解决它，如下所示：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This warning is a little unique because we used this function *for debugging*.
    You may not want to draw rectangles in your game, but it''s essential for debugging
    collision boxes, as we did in [*Chapter 5*](B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114),
    *Collision Detection*, so we''ll want it to be available. To keep it around, let''s
    annotate it with the `allow` keyword, like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告有点独特，因为我们使用了这个函数来*调试*。你可能不想在你的游戏中绘制矩形，但正如我们在 [*第五章*](B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114)
    *碰撞检测* 中所做的那样，调试碰撞框是至关重要的，所以我们会希望它可用。为了保留它，让我们用 `allow` 关键字来注释它，如下所示：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should leave the compilation error-free, but there''s one more tool we
    can use to see whether our code could be improved. If you''ve spent much time
    in the Rust ecosystem, then you''ve probably heard of `Cargo.toml` file but to
    the current system itself. Installation is simple, and you may have done it at
    some point and forgotten about it, but if you haven''t, it''s one shell command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会留下无编译错误的编译结果，但我们还可以使用一个额外的工具来查看我们的代码是否可以改进。如果你在 Rust 生态系统中度过了很多时间，那么你可能已经听说过
    `Cargo.toml` 文件，但针对当前系统本身。安装很简单，你可能已经安装过并忘记了，但如果你还没有，只需要一个 shell 命令：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once you've installed Clippy, you can run `cargo clippy` and see all the other
    ways we wrote bad Rust code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了 Clippy，你可以运行 `cargo clippy` 并看到我们编写坏 Rust 代码的其他所有方式。
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When the code is great, I wrote it and you followed along. When it's bad, we
    did it together. I don't make the rules.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码很棒时，我写了它，而你跟随着。当它很糟糕时，我们一起完成。我不会制定规则。
- en: 'When I run `cargo clippy`, I get `17` warnings, but your number could be different,
    depending on when you run it. I''m not going to go through each one, but let''s
    highlight one error:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行 `cargo clippy` 时，我得到 `17` 个警告，但你的数字可能不同，取决于你何时运行它。我不会逐个解释，但让我们突出一个错误：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `rightmost` function in the `game` module can be made to use one less reference
    and be made more flexible. `help` here is great because it tells me exactly what
    to do to fix it. So, let''s change the `rightmost` function signature so that
    it looks as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`game` 模块中的 `rightmost` 函数可以被修改以使用更少的引用并变得更加灵活。这里的 `help` 非常好，因为它告诉我如何修复它。所以，让我们改变
    `rightmost` 函数签名，使其看起来如下：'
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This doesn't fix any bugs but it does remove a Clippy warning and makes the
    method more flexible.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不能修复任何错误，但它确实移除了一个 Clippy 警告，并使方法更加灵活。
- en: 'It''s very common for Clippy to inform you of better idioms you could be using.
    One Clippy warning I wanted to highlight looks like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Clippy 经常会通知你更好的惯用用法。我想突出一个 Clippy 警告，看起来像这样：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I had this error occur quite a bit in earlier versions of the code. I wasn''t
    aware that the `matches!` macro existed before I ran Clippy, but what it does
    is handle the exact case where you need to check whether an `enum` is a specific
    case you''re looking for. That''s why the code now uses what Clippy suggests,
    which is in `impl` `RedHatBoyStateMachine`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我在代码的早期版本中遇到了这个错误很多次。在运行 Clippy 之前，我不知道存在 `matches!` 宏，但它所做的正是处理你需要检查 `enum`
    是否是特定情况的精确情况。这就是为什么代码现在使用 Clippy 建议的，即在 `impl` `RedHatBoyStateMachine` 中：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Many editors make it very easy to enable Clippy as part of syntax checking so
    that you don't need to run it explicitly. If you can enable it, you should do
    so.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编辑器使它非常容易将 Clippy 作为语法检查的一部分启用，这样你就不需要显式地运行它。如果你能启用它，你应该这样做。
- en: Many of the other errors are about overusing `clone` and using `into` when it
    isn't necessary. I highly recommend going through the code and fixing those, taking
    another moment to understand why they were flagged. In [*Chapter 10*](B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226),
    *Continuous Deployment*, we'll add Clippy to our build process so that we don't
    have to keep putting up with these errors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他错误都是关于过度使用 `clone` 和在不必要的时候使用 `into`。我强烈建议你通读代码并修复这些问题，花点时间理解为什么它们被标记出来。在
    [*第 10 章*](B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226) *持续部署* 中，我们将把 Clippy
    添加到我们的构建过程中，这样我们就不必继续忍受这些错误。
- en: At this point, the code has been tested (a little) and we've handled every compiler
    error and warning we can think of. It's safe to say that the game works, but is
    it fast enough? The next thing to check is its performance. So, let's do that
    now.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码已经经过（一点）测试，我们已经处理了我们能想到的所有编译错误和警告。可以说游戏是可行的，但它足够快吗？接下来要检查的是它的性能。所以，我们现在就来做这件事。
- en: Measuring performance with a browser
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浏览器测量性能
- en: The first step in debugging performance is answering the question, *Do you have
    a performance problem?* Too many developers, especially game developers, worry
    too early about performance and introduce complex code for a performance gain
    that just isn't there.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 调试性能的第一步是回答这个问题，*你是否有性能问题？* 太多的开发者，尤其是游戏开发者，过早地担心性能，并引入了复杂的代码来获得并不存在的性能提升。
- en: 'For example, do you know why so much of this code uses `i16` and `f16`? Well,
    when I was going back to school a few years ago, I took a game optimization class
    in C++, where our final project needed to optimize a particle system. The biggest
    performance gains were to convert 32-bit integers into 16-bit integers. As my
    professor would say, "*We got to the moon on 16-bit!*" So, when I was writing
    this code, I internalized the lesson and made the variables 16-bit unless they
    were being sent to JavaScript, where everything is 32-bit anyway. Well, allow
    me to quote directly from the WebAssembly specification (found at [https://webassembly.github.io/spec/core/syntax/types.html](https://webassembly.github.io/spec/core/syntax/types.html)):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你知道为什么这么多代码使用 `i16` 和 `f16` 吗？好吧，当我几年前回到学校时，我在C++中参加了一门游戏优化课程，我们的最终项目需要优化一个粒子系统。最大的性能提升是将32位整数转换为16位整数。正如我的教授所说，“*我们在16位上登上了月球！*”所以，当我编写这段代码时，我内化了这个教训，并将变量设置为16位，除非它们被发送到JavaScript，在那里一切都是32位的。好吧，让我直接引用WebAssembly规范（可在[https://webassembly.github.io/spec/core/syntax/types.html](https://webassembly.github.io/spec/core/syntax/types.html)找到）：
- en: Number types classify numeric values.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 数字类型用于分类数值。
- en: The *i32* and *i64* types classify 32- and 64-bit integers, respectively. Integers
    are not inherently signed or unsigned; their interpretation is determined by individual
    operations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*i32* 和 *i64* 类型分别用于分类32位和64位整数。整数本身不是有符号或无符号的；它们的解释由单个操作决定。'
- en: The *f32* and *f64* types classify 32- and 64-bit floating-point data, respectively.
    They correspond to the respective binary floating-point representations, also
    known as single and double precision, as defined by the IEEE 754-2019 standard
    (Section 3.3).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*f32* 和 *f64* 类型分别用于分类32位和64位的浮点数据。它们对应于由IEEE 754-2019标准（第3.3节）定义的相应二进制浮点表示，也称为单精度和双精度。'
- en: 'It turns out that WebAssembly doesn''t support a 16-bit numeric value, so all
    of the optimization to `i16` is pointless. It''s not harming anything and it''s
    not worth going back to change it, but it reinforces the first rule of optimization:
    **measure first**. With that in mind, let''s investigate two different ways to
    measure the performance of our game.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，WebAssembly不支持16位数值，所以所有针对 `i16` 的优化都是无意义的。它没有造成任何伤害，也没有必要回去更改它，但它强化了优化的第一条规则：**先测量**。考虑到这一点，让我们调查两种不同的方法来衡量我们游戏的表现。
- en: Frame rate counter
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧率计数器
- en: 'There are two ways our game can perform poorly: by using too much memory and
    slowing the frame rate. The second of those is far more important, especially
    for a small game like this, so we''ll want to start looking at frame rate first.
    If the frame rate consistently lags, our game loop will account for it as best
    it can, but the game will look jittery and respond poorly. So, we need to know
    the current frame rate, and the best way to do that is to draw it on the screen.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏表现不佳有两种方式：使用过多的内存和降低帧率。其中第二种对于像这样小型游戏来说更为重要，因此我们首先需要关注帧率。如果帧率持续落后，我们的游戏循环将尽可能处理它，但游戏看起来会抖动，响应也会不佳。所以，我们需要知道当前的帧率，而最好的方法是在屏幕上显示它。
- en: 'We''ll start by adding a function, `draw_text`, that will draw arbitrary text
    on the screen. This is debug text, so similarly to the `draw_rect` function, we''ll
    need to disable the warning that says the code is unused. Writing text is a function
    of `Renderer` in the `engine` module, as shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个函数 `draw_text`，该函数将在屏幕上绘制任意文本。这是调试文本，所以类似于 `draw_rect` 函数，我们需要禁用显示代码未使用的警告。写文本是
    `engine` 模块中 `Renderer` 的一个功能，如下所示：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've hardcoded the font here because this is for debugging purposes only, so
    it's not worth customizing. Now, we need to add a frame rate calculator to the
    game loop, which is in the `start` method of `GameLoop` in the `engine` module.
    You can refresh your memory on how it works by reviewing [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*. The frame rate can be calculated by taking the difference
    between the last two frames, dividing by 1,000, to get from milliseconds to seconds,
    and calculating its inverse (which is 1 divided by the number). This is simple
    but it will lead to the frame rate fluctuating wildly on screen and won't show
    very useful information. What we can do instead is update the frame rate every
    second so that we can get a fairly stable indicator of performance on screen.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里硬编码了字体，因为这只是用于调试目的，所以不值得定制。现在，我们需要将帧率计算器添加到游戏循环中，这个游戏循环位于`engine`模块的`GameLoop`的`start`方法中。你可以通过回顾[*第3章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)，*创建一个游戏循环*来刷新你对它是如何工作的记忆。帧率可以通过取最后两个帧之间的差值，除以1,000，将毫秒转换为秒，并计算其倒数（即1除以该数值）来计算。这很简单，但它会导致屏幕上的帧率波动得很厉害，并且不会显示非常有用的信息。我们可以做的是每秒更新一次帧率，这样我们就可以在屏幕上得到一个相当稳定的性能指标。
- en: 'Let''s add that code to the `engine` module. We''ll start with a standalone
    function that will calculate the frame rate every second in the `start` method,
    as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这段代码添加到`engine`模块中。我们将从一个独立的函数开始，这个函数将在`start`方法中每秒计算一次帧率，如下所示：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Oh no – it's an `unsafe` function! It's the first one in this book, and probably
    the last. We're using an `unsafe` function here because of the `static mut` variables
    – that is, `FRAMES_COUNTED`, `TOTAL_FRAME_TIME`, and `FRAME_RATE` – which are
    not safe in a multithreaded environment. We know that this function won't be called
    in a multithreaded way, and we also know that if it was called, it would just
    show a weird frame rate value. It's not something I generally recommend, but in
    this case, we don't want to pollute `GameLoop` or the `engine` module with those
    values or put them in thread-safe types. After all, we wouldn't want to have our
    frame rate calculator take too long because of a bunch of `Mutex` lock calls.
    So, we'll accept that this debugging function is `unsafe`, shiver in fear for
    a moment, and move on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不——这是一个`unsafe`函数！这是本书中的第一个，也可能是最后一个。我们在这里使用`unsafe`函数是因为有`static mut`变量——即`FRAMES_COUNTED`、`TOTAL_FRAME_TIME`和`FRAME_RATE`——在多线程环境中并不安全。我们知道这个函数不会以多线程的方式被调用，我们也知道如果它被调用，它只会显示一个奇怪的帧率值。这并不是我一般推荐的做法，但在这个情况下，我们不想让`GameLoop`或`engine`模块被这些值污染，或者将它们放入线程安全的类型中。毕竟，我们不想因为一大堆`Mutex`锁调用而让我们的帧率计算器运行得太慢。所以，我们将接受这个调试函数是`unsafe`的，颤抖一会儿，然后继续。
- en: The function starts by setting up the initial `FRAMES_COUNTED`, `TOTAL_FRAME_TIME`,
    and `FRAME_RATE` values. On each call to `draw_frame_rate`, we update `TOTAL_FRAME_TIME`
    and the number of `FRAMES_COUNTED`. When `TOTAL_FRAME_TIME` has passed `1000`,
    this means that 1 second has elapsed, since `TOTAL_FRAME_TIME` is in milliseconds.
    We can set `FRAME_RATE` to the number of `FRAMES_COUNTED` because that's the literal
    `draw_text` function we just created. This function is going to be called last
    on every frame, which is important because if it isn't, we would draw the game
    right over the top of the frame rate. If we didn't draw the frame rate on every
    frame, we also wouldn't see it except for brief flickers on the screen, which
    is hardly suitable for debugging.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先设置初始的`FRAMES_COUNTED`、`TOTAL_FRAME_TIME`和`FRAME_RATE`值。在每次调用`draw_frame_rate`时，我们更新`TOTAL_FRAME_TIME`和`FRAMES_COUNTED`的数量。当`TOTAL_FRAME_TIME`超过`1000`时，这意味着已经过去了1秒，因为`TOTAL_FRAME_TIME`是以毫秒为单位的。我们可以将`FRAME_RATE`设置为`FRAMES_COUNTED`的数量，因为那正是我们刚刚创建的`draw_text`函数。这个函数将在每一帧上最后被调用，这是很重要的，因为如果不是这样，我们就会在帧率上直接绘制游戏。如果我们不在每一帧上绘制帧率，我们也不会看到它，除了在屏幕上短暂的闪烁，这几乎不适合调试。
- en: 'Now, let''s add the call to `GameLoop`, in the `start` function, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`start`函数中添加对`GameLoop`的调用，如下所示：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `game_loop.accumlated_delta` line has changed slightly, pulling the calculation
    for the length of the frame into a temporary variable, `frame_time`. Then, after
    drawing, we check whether we are in debug/development mode through the check for
    `if cfg!(debug_assertions)`. This will ensure that this doesn''t show up in the
    deployed code. If we are in debug mode, we call `draw_frame_rate` inside an `unsafe`
    block. We send that function `renderer` and `frame_time`, which we just pulled
    into a temporary variable. Adding this code gives us a clear measurement of the
    frame rate on the screen:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`game_loop.accumlated_delta`这一行有轻微的变化，将帧长度的计算拉入一个临时变量`frame_time`。然后，在绘制之后，我们通过检查`if
    cfg!(debug_assertions)`来确定是否处于调试/开发模式。这将确保这不会出现在部署的代码中。如果我们处于调试模式，我们将在`unsafe`块内调用`draw_frame_rate`。我们发送该函数`renderer`和`frame_time`，我们刚刚将其拉入临时变量。添加此代码可以在屏幕上提供清晰的帧率测量：'
- en: '![Figure 9.5 – Showing the frame rate](img/Figure_9.05_B17151.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 显示帧率](img/Figure_9.05_B17151.jpg)'
- en: Figure 9.5 – Showing the frame rate
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 显示帧率
- en: On my machine, the frame rate is a steady `60`, with an occasional blip that
    isn't consistent. That's great unless you're writing a chapter on debugging performance
    issues. Then, you may have a problem.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，帧率稳定在`60`，偶尔会有不稳定的短暂波动。这很好，除非你正在编写关于调试性能问题的章节。那么，你可能会有问题。
- en: 'Fortunately, in early drafts, there was one time when the frame rate dropped,
    and that was when the RHB crashed into a rock. When the `index.html`. In other
    words, we must delete the highlighted code in `index.html`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在早期草稿中，有一次帧率下降，那是在RHB撞到岩石的时候。当`index.html`。换句话说，我们必须删除`index.html`中高亮显示的代码：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you delete the preloaded assets, you should see the see frame rate dip briefly.
    Displaying the frame rate is a great way to make sure that you, as a developer,
    see performance issues right away. If the frame rate dips, then you've got a problem,
    just like we have when we don't preload the assets. Sometimes, we need more than
    just a frame rate counter. So, let's leave the preload code deleted and see the
    performance problem in the browser debugger.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你删除了预加载的资源，你应该会看到帧率短暂下降。显示帧率是确保你作为开发者立即看到性能问题的绝佳方式。如果帧率下降，那么你就遇到了问题，就像我们没有预加载资源时遇到的情况一样。有时，我们需要的不仅仅是帧率计数器。所以，让我们保留预加载代码被删除的状态，并在浏览器调试器中查看性能问题。
- en: Browser debugger
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器调试器
- en: 'Every modern browser has developer tools, but I''ll be using Chrome for this
    section as it''s the one most popular with developers. In general, they all look
    similar to each other. To get performance information, I must start the game and
    open the developer tools in Chrome. Then, I must right-click and click **Inspect**,
    though there are plenty of other ways to open the tools. From there, I must click
    the **Performance** tab and start recording. Then, I must run RHB into a rock
    and stop recording. Since I know I''ve got a specific spot with a performance
    dip, I want to get to it as quickly as possible to hide any noise in the debugger
    from other code. After I do that, I will see a graph, like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个现代浏览器都有开发者工具，但我会在这个部分使用Chrome，因为它是开发者中最受欢迎的。一般来说，它们看起来都很相似。为了获取性能信息，我必须启动游戏并在Chrome中打开开发者工具。然后，我必须右键单击并点击**检查**，尽管有其他很多打开工具的方法。从那里，我必须点击**性能**选项卡并开始录制。然后，我必须将RHB撞到岩石并停止录制。由于我知道我有一个特定的性能下降点，我想尽快到达那里，以隐藏调试器中其他代码的任何噪音。完成这些后，我会看到一个图表，就像这样：
- en: '![Figure 9.6 – The Performance tab](img/Figure_9.06_B17151.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 性能选项卡](img/Figure_9.06_B17151.jpg)'
- en: Figure 9.6 – The Performance tab
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 性能选项卡
- en: 'That''s a lot of noise, but you can see that the graph changes. There''s a
    pink blob on the **Frames** row, which shows that something happened there. I
    can select the section that looks like a hill with my cursor and drag it to zoom
    in on it. Now, I will see the following screen:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多噪音，但你可以看到图表发生了变化。在**帧**行有一个粉红色的块，表明那里发生了某些事情。我可以使用我的光标选择看起来像山一样的部分，并将其拖动以放大。现在，我会看到以下屏幕：
- en: '![Figure 9.7 – Dropped frames](img/Figure_9.07_B17151.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 丢失的帧](img/Figure_9.07_B17151.jpg)'
- en: Figure 9.7 – Dropped frames
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 丢失的帧
- en: Here, you can see that one frame was **115.8 ms**. I opened the **Frames** section
    (see how the gray arrow next to **Frames** points down) to see what was drawn
    on those frames – our poor knocked-out RHB. A frame that's 115.8 ms is way too
    long, and if you hover your mouse over that, it will show you **dropped frames**.
    Beneath the **Frames** section, there's the **Main** section, which shows what
    the application was doing. I've highlighted **Recalculate Style** here, which
    is taking **33.55 ms** according to the **ToolTip** window, which shows up after
    I roll my mouse over it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一帧是**115.8毫秒**。我打开了**帧**部分（看看**帧**旁边的灰色箭头是如何指向下方的），以查看这些帧上绘制了什么——我们可怜的击倒RHB。115.8毫秒的帧太长了，如果你将鼠标悬停在其上，它会显示**丢失的帧**。在**帧**部分下方，是**主**部分，它显示了应用程序正在做什么。我在这里突出显示了**重新计算样式**，根据**工具提示**窗口，它显示为**33.55毫秒**，这个窗口在我将鼠标悬停在其上时出现。
- en: '`index.html` file, which should speed up recalculating the layout. If you do
    that and remeasure your performance, you''ll see something like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`文件，这应该会加快布局的重新计算。如果你这样做并重新测量性能，你会看到类似这样的：'
- en: '![Figure 9.8 – No dropped frames!'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 – 没有丢失帧！'
- en: '](img/Figure_9.08_B17151.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.08_B17151.jpg)'
- en: Figure 9.8 – No dropped frames!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 没有丢失帧！
- en: 'Was this worth worrying about? Possibly – it is noticeable to see the button
    load, but it''s not worth extending this chapter to fix it. You know how to fix
    it, and you know how to find the issue in the **Performance** tab, and that''s
    what''s important for now. Anyway, we have another question to answer: how much
    memory is this game taking up?'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这值得担心吗？可能吧——看到按钮加载是明显的，但扩展这一章来修复它并不值得。你知道如何修复它，也知道如何在**性能**标签页中找到问题，而这正是现在重要的。无论如何，我们还有另一个问题要回答：这款游戏占用了多少内存？
- en: Checking memory
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查内存
- en: When I was writing this game, I would frequently leave it running all day in
    the background, only to have my browser become very unresponsive as it started
    taking up all my computer's memory. I began to suspect that the game had a memory
    leak, so I started investigating. You may think it's impossible to have a memory
    leak in Rust due to its guarantees, and it is harder, but remember that a lot
    of our code talks to JavaScript, where we don't necessarily have the same guarantees.
    Fortunately, we can check this with the same tools we have been using to test
    performance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我编写这个游戏时，我经常让它全天在后台运行，结果我的浏览器开始占用我电脑的所有内存，变得非常不响应。我开始怀疑这个游戏有内存泄漏，所以我开始调查。你可能认为由于Rust的保证，在Rust中不可能有内存泄漏，这确实更难，但记住，我们的大部分代码都与JavaScript通信，我们并不一定有相同的保证。幸运的是，我们可以使用我们用来测试性能的相同工具来检查这一点。
- en: 'Go ahead and clear the performance data by clicking **no sign** in the top-left
    corner. Then, start another recording and play for a little while. This time,
    don''t try to die right away; go ahead and let the game play for a bit. Then,
    stop recording and look at the performance data again, this time ensuring you
    click the **Memory** button. Now, you can a look at the results, which may look
    like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 点击左上角的**无符号**来清除性能数据。然后，开始另一个记录并播放一段时间。这次，不要试图立即死亡；让游戏播放一会儿。然后，停止记录并再次查看性能数据，这次确保你点击**内存**按钮。现在，你可以查看结果，它可能看起来像这样：
- en: '![Figure 9.9 – Memory profiling'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9 – 内存分析'
- en: '](img/Figure_9.09_B17151.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.09_B17151.jpg)'
- en: Figure 9.9 – Memory profiling
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 内存分析
- en: Can you see that blue wave at the bottom of the screen, which shows **HEAP**
    in the bottom right-hand corner? This shows that our memory grows and then is
    periodically reclaimed. This may not be ideal as we'd like memory to be constant,
    but we aren't trying to control things to that degree at this time. Chrome, and
    most browsers, run their garbage collectors in separate threads so that they won't
    affect performance as much as you may think. It would be worth experimenting and
    creating a memory budget in the application and keeping all the allocations in
    that budget, but that's outside the scope of this book. Fortunately, the memory
    is reclaimed and it doesn't look like the game is growing uncontrollably.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到屏幕底部的蓝色波浪吗，它显示了右下角的**堆**？这表明我们的内存增长，然后定期回收。这可能不是我们想要的理想状态，但我们现在并不试图控制到那种程度。Chrome和大多数浏览器都在单独的线程中运行它们的垃圾收集器，这样就不会像你想象的那么影响性能。进行实验并在应用程序中创建一个内存预算，并保持所有分配都在那个预算内，但这超出了本书的范围。幸运的是，内存被回收了，看起来游戏并没有无控制地增长。
- en: After further investigation, it turned out that the problem with my browser
    was caused by my company's bug tracker, which uses far more memory than this little
    game! If you're seeing performance issues, make sure you account for other tabs,
    browser extensions, and anything else that might be slowing down your computer
    outside of the game.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 经过进一步调查，发现我浏览器的问题是由我们公司的缺陷跟踪器引起的，它使用的内存比这个小游戏多得多！如果你遇到性能问题，请确保考虑其他标签页、浏览器扩展程序以及可能减慢你电脑速度的其他任何东西。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a little different than the previous ones because, in many
    ways, our game is complete! But of course, it's not perfect, which is why we spent
    some time looking at ways we can investigate defects and bullet-proof the code
    base.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章与之前的不同，因为从许多方面来看，我们的游戏已经完成了！但当然，它并不完美，这就是为什么我们花了一些时间来研究我们可以如何调查缺陷并使代码库更加健壮。
- en: We dug into automated testing, writing unit tests for our transitions, and writing
    integration tests that run in the browser. We now have logging for any unforeseen
    errors and stack traces if the code crashes, both of which are necessary diagnostics
    for debugging challenging errors. Then, we used the linter and Clippy to clean
    up our code and remove subtle issues that the compiler can't catch. Finally, we
    investigated performance issues in the browser and found that we had none!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入研究了自动化测试，为我们的转换编写了单元测试，并编写了在浏览器中运行的集成测试。我们现在对任何未预见的错误和代码崩溃时的堆栈跟踪都有记录，这两者都是调试困难错误的必要诊断工具。然后，我们使用了代码检查器和Clippy来清理我们的代码，并移除编译器无法捕获的微妙问题。最后，我们调查了浏览器中的性能问题，发现我们没有遇到任何问题！
- en: In the next chapter, we'll get those tests into a CI/CD setup and even deploy
    them to production. What are we waiting for? Let's ship this thing!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把那些测试集成到CI/CD设置中，甚至将它们部署到生产环境中。我们在等什么？让我们把这个东西发布出去！
