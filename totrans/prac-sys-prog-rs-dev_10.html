<html><head></head><body>
		<div id="_idContainer061">
			<h1 id="_idParaDest-127"><em class="italic">Chapter 8</em>: <a id="_idTextAnchor132"/>Working with Processes and Signals</h1>
			<p>Do you know how commands are executed when you type them into a terminal interface on your computer? Are these commands directly executed by the operating system, or is there an intermediate program that handles them? When you run a program from the command line in the foreground, and press <em class="italic">Ctrl</em> + <em class="italic">C</em>, who is listening to this keypress, and how is the program terminated? How can multiple user programs be run at the same time by the operating system? What is the difference between a program and a process? If you are curious, then read on.</p>
			<p>In the previous chapter, we learned how to control and alter the terminal interface that is used to interact with the users in command-line applications.</p>
			<p>In this chapter, we will look at <em class="italic">processes</em>, which are the second most popular abstraction in systems programming after <em class="italic">files</em>. We'll learn what processes are, how they differ from programs, how they are started and terminated, and how the process environment can be controlled. This skill is necessary if you want to write systems programs such as shells, where you want programmatic control over the life cycle of processes. </p>
			<p>We'll also build an elementary shell program as a mini project by using the <em class="italic">Rust Standard Library</em> This will give you a practical understanding of how popular shells such as <em class="italic">Bourne</em>, <em class="italic">Bash</em>, and <em class="italic">zsh</em> work under the hood, and teach you the basics of how you can build your own customized shell environments in Rust.  </p>
			<p>We will cover these topics in the following order:</p>
			<ul>
				<li>Understanding Linux process concepts and syscalls</li>
				<li>Spawning new processes with Rust</li>
				<li>Handling I/O and environment variables for child processes</li>
				<li>Handling panic, errors, and signals</li>
				<li>Writing a basic shell program in Rust (project)</li>
			</ul>
			<p>By the end of this chapter, you will have learned how to programmatically launch new programs as separate processes, how to set and adjust environment variables, how to handle errors, respond to external signals, and exit the process gracefully. You will learn how to talk to the operating system to perform these tasks using the Rust standard library. This gives you, as a system programmer, great control over this important system resource; that is, <em class="italic">processes</em>.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor133"/>Technical requirements</h1>
			<p>Verify that <strong class="source-inline">rustc</strong>, and <strong class="source-inline">cargo</strong> have been installed correctly with the following command: </p>
			<p class="source-code">rustc –version</p>
			<p class="source-code">cargo --version</p>
			<p>The Git repo for the code in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter08">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter08</a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The section on signal handling requires a Unix-like development environment (<em class="italic">Unix</em>,<em class="italic"> Linux</em>, or <em class="italic">macOS</em>), as Microsoft Windows does not directly have the concept of signals. If you work with Windows, download a virtual machine such as Oracle VirtualBox (<a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>) or use a <em class="italic">Docker</em> container to launch a <em class="italic">Unix/Linux</em> image to follow along.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor134"/>Understanding Linux process concepts and syscalls</h1>
			<p>In this section, we'll <a id="_idIndexMarker573"/>cover the fundamentals of process management and <a id="_idIndexMarker574"/>get an appreciation of why it is important for systems programming. We'll look at the process life cycle, including <em class="italic">creating new processes</em>, <em class="italic">setting their environment parameters</em>, <em class="italic">working with their standard input and output</em>, and <em class="italic">terminating the processes</em>.</p>
			<p>This section starts with understanding the differences between a <em class="italic">program</em> and a <em class="italic">process</em>. We'll then go into a few key details about the fundamentals of processes in Linux. Lastly, we'll see an overview of how to manage the process life cycle with Rust using syscalls encapsulated by the Rust standard library.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor135"/>How does a program become a process?</h2>
			<p>A <strong class="bold">process</strong> is a running <strong class="bold">program</strong>. To be <a id="_idIndexMarker575"/>precise, it is an <em class="italic">instance</em> of a running program. You <a id="_idIndexMarker576"/>can have <em class="italic">multiple instances</em> of a single program running at <a id="_idIndexMarker577"/>the same time, such as starting a text editor from multiple terminal windows. Each such instance of a running program is a <em class="italic">process</em>.</p>
			<p>Even though a process is created as a result of running (or executing) a program, the two are <a id="_idIndexMarker578"/>different. A program exists <a id="_idIndexMarker579"/>in two forms – <strong class="bold">source code</strong> and <strong class="bold">machine-executable instructions</strong> (object code <a id="_idIndexMarker580"/>or executables). A compiler (and linker) is typically used to convert the <a id="_idIndexMarker581"/>source code of a program into <em class="italic">machine-executable instructions</em>.</p>
			<p><em class="italic">Machine-executable instructions</em> contain information for the operating system on how to <em class="italic">load a program into memory</em>, <em class="italic">initialize</em> it, and <em class="italic">run</em> it. The instructions include the following:</p>
			<ul>
				<li>An executable format (for example, <strong class="bold">ELF</strong> is a popular executable format in Unix systems).</li>
				<li>The program logic to be executed by the CPU.</li>
				<li>The memory address of the entry point of the program.</li>
				<li>Some data for initializing the program variables and constants.</li>
				<li>Information on the location of shared libraries, functions, and variables.</li>
			</ul>
			<p>When a program is started either from a command line, script, or graphical user interface, the following steps occur:</p>
			<ol>
				<li>The operating system (kernel) allocates virtual memory to the program (which is also <a id="_idIndexMarker582"/>called the <strong class="bold">memory layout</strong> of the program). We saw this in <a href="B16405_05_Final_NM_ePUB.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Memory Management in Rust</em>, on how virtual memory is laid out for a program in terms of <em class="italic">stack</em>, <em class="italic">heap</em>, <em class="italic">text</em>, and <em class="italic">data</em> segments.</li>
				<li>The kernel then loads the program instructions into the <em class="italic">text segment</em> of the virtual memory.</li>
				<li>The kernel initializes the program variables in the <em class="italic">data segment</em>.</li>
				<li>The kernel triggers the CPU to start executing the program instructions.</li>
				<li>The kernel also provides the running program with access to resources it needs, such as files or additional memory.</li>
			</ol>
			<p>The memory layout of a process (running program) was discussed in <a href="B16405_05_Final_NM_ePUB.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Memory Management</em>. It is <a id="_idIndexMarker583"/>reproduced here in <em class="italic">Figure 8.1</em> for reference:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_8.1_B16405.jpg" alt="Figure 8.1 – Program memory layout"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Program memory layout</p>
			<p>We've seen the <em class="italic">memory layout</em> of a program. What is a <em class="italic">process</em>, then?</p>
			<p>As far as the kernel is concerned, a process is an abstraction that consists of the following:</p>
			<ul>
				<li>Virtual memory in which the <a id="_idIndexMarker584"/>program instructions and data are loaded, which is represented in the program memory layout in <em class="italic">Figure 8.1</em>.</li>
				<li>A set of metadata about the running <a id="_idIndexMarker585"/>program such as the <em class="italic">process identifier</em>, <em class="italic">system resources</em> associated with the program (such as a list of open files), <em class="italic">virtual memory tables</em>, and other such information about the program. What is of particular importance is the <em class="italic">process ID</em>, which uniquely identifies an instance of a running program.<p class="callout-heading">Note</p><p class="callout">The kernel <a id="_idIndexMarker586"/>itself is the <strong class="bold">process manager</strong>. It allocates <em class="italic">process IDs</em> to new instances of user programs. When a system is booted up, the kernel creates a special process called <strong class="source-inline">init</strong>, which is assigned a <em class="italic">process ID</em> of <em class="italic">1</em>. The <strong class="source-inline">init</strong> process terminates only when the system is shut down and cannot be killed. All future processes are created either by the <strong class="source-inline">init</strong> process or one of its descendent processes.</p><p class="callout">Thus, a program refers to instructions created by the programmer (in the source or a machine-executable format) and a process is a running instance of a program that uses system resources and is controlled by the kernel. As programmers, if we want to control a running program, we will need to use appropriate <em class="italic">system calls</em> to the kernel. The Rust standard library wraps these system calls into neat APIs for use within Rust programs, as discussed in <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>,<em class="italic"> Introduction to the Rust Standard Library</em>.</p></li>
			</ul>
			<p>We've seen how programs relate to processes. Let's discuss some more details about the <em class="italic">characteristics of processes</em> in the next section.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor136"/>Delving into Linux process fundamentals</h2>
			<p>In <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Introduction to the Rust Standard Library and Key Crates for Systems Programming</em>, we saw <a id="_idIndexMarker587"/>how system calls are the interface between a user program (process) and the kernel (operating system). Using system calls, a user program can manage and control various system resources such as <em class="italic">files</em>, <em class="italic">memory</em>, <em class="italic">devices</em>, and so on.</p>
			<p>In this section, we'll look at how one running program (the parent process) can make system calls to manage the life cycle of another program (the child process). Recall that processes are also treated as system resources in Linux, just like files or memory. Understanding how one process can manage and communicate with another process is the focus of this section.</p>
			<p><em class="italic">Figure 8.2</em> shows the key set of tasks related to process management:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_8.2_B16405.jpg" alt="Figure 8.2 – Working with processes in Rust"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Working with processes in Rust</p>
			<p>Let's go over the <a id="_idIndexMarker588"/>process management tasks shown in the precedi<a id="_idTextAnchor137"/>ng figure. We'll see how process management is done on Linux by a non-Rust user program (for example, C/C++), and how it is different in Rust.</p>
			<h3>Creating a new process</h3>
			<p>While working with Unix/Linux, any user program that needs to create a new process has to request the kernel to do so <a id="_idIndexMarker589"/>using system calls (<em class="italic">syscalls</em>). A program (let's call it the <strong class="bold">parent process</strong>) can create a new process using the <strong class="source-inline">fork()</strong> syscall. The kernel duplicates the parent process and creates a <em class="italic">child process</em> with a unique ID. The child process gets an exact copy of the parent's memory space (the heap, stack, and so on). The child also gets access to the same copy of the program instructions as the parent. </p>
			<p>After creation, a child process can choose to load a different program into its process memory space and execute it. This is accomplished using one of the <strong class="source-inline">exec()</strong> family of <em class="italic">syscalls</em>.</p>
			<p>So, basically, the <em class="italic">syscall</em> in Unix/Linux to <em class="italic">create a new child process</em> is different from that needed to <em class="italic">load a new program</em> into the child process and execute it. However, the Rust standard library simplifies this for us and provides a uniform interface, where both these steps can be combined while creating a new child process. We'll see examples of this in the next section.</p>
			<p>Let's go back to the question at the beginning of the chapter: <em class="italic">What exactly happens when you type something in the command line of a terminal?</em></p>
			<p>When you run a program by typing the program executable name in a command line, two things take place:</p>
			<ol>
				<li value="1">First, a new process is created using the <strong class="source-inline">fork()</strong> system call.</li>
				<li>Then, the image of the new program (that is, the <em class="italic">program executable</em>) is loaded into memory and executed using the <strong class="source-inline">exec()</strong> family of calls.<p class="callout-heading">What happens when you type a command in a terminal?</p><p class="callout">A terminal (as we saw in the previous chapter) provides an interface for the user to interact with the system. But there has to be something that interprets that command and executes it. This is the <strong class="bold">shell program</strong>. You may be familiar with one of <a id="_idIndexMarker590"/>the popular shell <a id="_idIndexMarker591"/>programs such as <em class="italic">Bourne shell</em> or <em class="italic">Bash shell</em> in Unix/Linux, or <em class="italic">PowerShell</em> in Windows. It is these programs that accept the commands from the command line and fork new processes to execute the command. For example, let's take the following command on Unix/Linux, which finds file entries in the current directory structure recursively, searches for <em class="italic">debug</em>, and returns the count of such files:</p><p class="callout"><strong class="source-inline">find * | grep debug | wc -l</strong></p><p class="callout">When this command is typed into a terminal, the shell program spawns three processes to execute this command pipeline. It is this shell command that makes the system call to the kernel to create new processes, load these commands, and execute them in a sequence. The shell then returns the results of the execution and prints it to standard output.</p></li>
			</ol>
			<h3>Checking the status of a child process</h3>
			<p>Once a child process is <a id="_idIndexMarker592"/>spawned by the kernel, it returns a child <em class="italic">process ID</em>. The <strong class="source-inline">wait()</strong> and <strong class="source-inline">waitpid()</strong> syscalls can be used to check whether the child process is running by passing the <em class="italic">child process ID</em> to the call. These are helpful to synchronize the execution of the child process with the parent process. The Rust system library provides calls to wait for the child process to finish and to check its status.</p>
			<h3>Communicating using inter-process communication </h3>
			<p>Processes can <a id="_idIndexMarker593"/>communicate with each other and with the kernel (remember that the kernel is also a process) to coordinate their activities, using mechanisms such as signals, pipes, sockets, message queues, semaphores, and shared memory. In Rust also, two processes can communicate using various means including pipes, processes, and message queues. But one of the <a id="_idIndexMarker594"/>basic forms of <strong class="bold">Inter-Process Communication</strong> (<strong class="bold">IPC</strong>) between parent and child processes involves <em class="italic">stdin/stdout pipes</em>. The parent process can write to standard input and read from the child process's standard output. We'll see an example of this in a later section.</p>
			<h3>Setting environment variables</h3>
			<p>Each process also has its own <a id="_idIndexMarker595"/>set of associated environment variables. The <strong class="source-inline">fork()</strong> and <strong class="source-inline">exec()</strong> syscalls allow the passing and setting of environment variables from the parent to the child process. The values of these environment variables are stored within the virtual memory area of the process. The Rust standard library also allows the parent process to explicitly set or reset the environment variables of the child process.</p>
			<h3>Terminating a process</h3>
			<p>A <a id="_idIndexMarker596"/>process can terminate itself by using the <strong class="source-inline">exit()</strong> syscall, or by being killed by a signal (such as the user pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>) or using the <strong class="source-inline">kill()</strong> syscall. Rust also has an <strong class="source-inline">exit()</strong> call for this purpose. Rust also provides other ways to abort a process, which we will look at in a later section.</p>
			<h3>Handling signals</h3>
			<p>Signals <a id="_idIndexMarker597"/>are used to communicate asynchronous events such as keyboard interrupts to a process. Except for two of the signals, SIGSTOP and SIGKILL, processes can either choose to ignore signals or decide how to respond to them in their own way. Handling signals directly using the Rust standard library is not developer-friendly, so for this, we can use external crates. We'll be using one such crate in a later section.</p>
			<p>In this section, we've seen the differences between a <em class="italic">program</em> and a <em class="italic">process</em>, delved into a few of the characteristics of Linux processes, and got an overview of the kind of things we can do in Rust to interact with processes.</p>
			<p>In the next section, we'll learn first-hand how to spawn, interact, and terminate processes using Rust by writing some code. Note that in the next few sections, only code snippets are provided. In order to execute the code, you will need to create a new cargo project and add the code shown in the <strong class="source-inline">src/main.rs</strong> file with the appropriate module imports.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor138"/>Spawning processes with Rust</h1>
			<p>In the Rust <a id="_idIndexMarker598"/>standard library, <strong class="source-inline">std::process</strong> is the module for working with <a id="_idIndexMarker599"/>processes. In this section, we'll look at how to <em class="italic">spawn new processes</em>, <em class="italic">interact with child processes</em>, and <em class="italic">abort the current process</em> using the Rust standard library. The Rust standard library internally uses the corresponding Unix/Linux <em class="italic">syscalls</em> to invoke the kernel operations for managing processes.</p>
			<p>Let's begin with launching new child processes.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor139"/>Spawning new child processes</h2>
			<p>The <strong class="source-inline">std::process::Command</strong> is used to launch a program at a specified path, or to run a standard shell <a id="_idIndexMarker600"/>command. The configuration parameters for the new process can be constructed using a builder pattern. Let's see a simple example:</p>
			<p class="source-code">use std::process::Command;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    Command::new("ls")</p>
			<p class="source-code">        .spawn()</p>
			<p class="source-code">        .expect("ls command failed to start");</p>
			<p class="source-code">}</p>
			<p>The code shown uses the <strong class="source-inline">Command::new()</strong> method to create a new command for execution, that takes as a parameter the name of the program to be run. The <strong class="source-inline">spawn()</strong> method creates a new child process.</p>
			<p>If you run this program, you will see a listing of files in the current directory.</p>
			<p>This is the simplest way to spin off a standard Unix <em class="italic">shell command</em> or a <em class="italic">user program</em> as a child process using the Rust standard library. </p>
			<p>What if you would like to pass parameters to the shell command? Some example code is shown in the following snippet that passes arguments to the command:</p>
			<p class="source-code">use std::process::Command;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    Command::new("ls")</p>
			<p class="source-code">        .arg("-l")</p>
			<p class="source-code">        .arg("-h")</p>
			<p class="source-code">        .spawn()</p>
			<p class="source-code">        .expect("ls command failed to start");</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">arg()</strong> method can be used to pass one argument to the program. Here we want to run the <strong class="source-inline">ls –lh</strong> command to display files in a long format with readable file sizes. We have to use the <strong class="source-inline">arg()</strong> method twice to pass the two flags.</p>
			<p>Alternatively, the <strong class="source-inline">args()</strong> method can be used as shown here. Note that the <strong class="source-inline">std::process</strong> import and the <strong class="source-inline">main()</strong> function declaration have been removed in future code snippets to avoid repetition, but you must add them before you can run the program:</p>
			<p class="source-code">Command::new("ls")</p>
			<p class="source-code">        .args(&amp;["-l", "-h"]).spawn().unwrap();</p>
			<p>Let's alter the code to list the directory contents for the directory one level above (relative to the current directory).</p>
			<p>The code shows two <a id="_idIndexMarker601"/>parameters for the <strong class="source-inline">ls</strong> command configured through the <strong class="source-inline">args()</strong> method.</p>
			<p>Next, let's set the current directory for the child process to a non-default value:</p>
			<p class="source-code">    Command::new("ls")</p>
			<p class="source-code">        .current_dir("..")</p>
			<p class="source-code">        .args(&amp;["-l", "-h"])</p>
			<p class="source-code">        .spawn()</p>
			<p class="source-code">        .expect("ls command failed to start");</p>
			<p>In the preceding code, we are spawning the process to run the <strong class="source-inline">ls</strong> command in the directory one level above. </p>
			<p>Run the program with the following command:</p>
			<p class="source-code"> cargo run </p>
			<p>You will see the listing of the parent directory displayed.</p>
			<p>We've so far used <strong class="source-inline">spawn()</strong> to create a new child process. This method returns a handle to the child process. </p>
			<p>There is another way to spawn a new process using <strong class="source-inline">output()</strong>. The difference is that <strong class="source-inline">output()</strong> spawns the child process and waits for it to terminate. Let's see an example:</p>
			<p class="source-code">    let output = Command::new("cat").arg("a.txt").output().</p>
			<p class="source-code">        unwrap();</p>
			<p class="source-code">    if !output.status.success() {</p>
			<p class="source-code">        println!("Command executed with failing error code");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    println!("printing: {}", String::from_utf8(output.stdout).</p>
			<p class="source-code">        unwrap());</p>
			<p>We are spawning a new process using the <strong class="source-inline">output()</strong> method to print out the contents of a file named <strong class="source-inline">a.txt</strong>. Let's create this file using the following command:</p>
			<p class="source-code">echo "Hello World" &gt; a.txt</p>
			<p>If you run the program, you will see the contents of the <strong class="source-inline">a.txt</strong> file printed out to the terminal. Note that we <a id="_idIndexMarker602"/>are printing out the contents of the standard output handle of the child process because that's where the output of the <strong class="source-inline">cat</strong> command is directed to by default. We'll learn more details of how to work with child processes' <strong class="source-inline">stdin</strong> and <strong class="source-inline">stdout</strong> later in this chapter.</p>
			<p>We'll now look at how to terminate a process.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor140"/>Terminating processes</h2>
			<p>We've seen how to spawn <a id="_idIndexMarker603"/>new processes. What about terminating them? For this, the Rust standard library provides two methods—<strong class="source-inline">abort()</strong> and <strong class="source-inline">exit()</strong>.</p>
			<p>The usage of the <strong class="source-inline">abort()</strong> method is shown in the following snippet:</p>
			<p class="source-code">use std::process;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    println!("Going to abort process");</p>
			<p class="source-code">    process::abort();</p>
			<p class="source-code">    // This statement will not get executed</p>
			<p class="source-code">    println!("Process aborted");</p>
			<p class="source-code">}</p>
			<p>This code aborts the current process, and the last statement will not get printed.</p>
			<p>There is another <strong class="source-inline">exit()</strong> method similar to <strong class="source-inline">abort()</strong>, but it allows us to specify an exit code that is available to the calling process. </p>
			<p>What is the benefit of processes returning error codes? A child process can fail due to various errors. When the program fails and the child process exits, it would be useful to the calling program or user to know the error code denoting the reason for failure. <strong class="bold">0</strong> indicates a successful exit. Other error codes indicate various conditions such as <em class="italic">data error</em>, <em class="italic">system file error</em>, <em class="italic">I/O error</em>, and so on. The error codes are platform-specific, but most Unix-like platforms use 8-bit error codes, allowing for error values between 0 and 255. Examples of error codes for Unix BSD can be found at <a href="https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html</a>.</p>
			<p>The following is an <a id="_idIndexMarker604"/>example showing the returning of error codes from a process with the <strong class="source-inline">exit()</strong> method:</p>
			<p class="source-code">use std::process;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    println!("Going to exit process with error code 64"); </p>
			<p class="source-code">    process::exit(64);</p>
			<p class="source-code">    // execution never gets here</p>
			<p class="source-code">    println!("Process exited");</p>
			<p class="source-code">}</p>
			<p>Run this program on the command line in your terminal. To know the exit code of the last executed process on Unix-like systems, you can type<strong class="source-inline"> $?</strong> on the command line. Note that this command may vary depending on the platform.</p>
			<p class="callout-heading">abort() versus exit()</p>
			<p class="callout">Note that both <strong class="source-inline">abort()</strong> and <strong class="source-inline">exit()</strong> do not clean up and call any destructors, so if you want to shut down a process in a clean manner, these methods should be called only after all the destructors have been run. However, the operating system will ensure that on termination of a process, all the resources associated with it, such as memory and file descriptors, are automatically made available for re-allocation to other processes.</p>
			<p>In this section, we've <a id="_idIndexMarker605"/>seen how to spawn and terminate processes. Let's next take a look at how to check the status of execution of a child process after it has been spawned. </p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor141"/>Checking the status of a child process' execution</h2>
			<p>As seen earlier, when <a id="_idIndexMarker606"/>we start a new process, we also specify the program or command to be executed within the process. Frequently, we also care about whether this program or command has been executed successfully or not, in order to take suitable actions. </p>
			<p>The Rust standard library provides a <strong class="source-inline">status()</strong> method to let us find out whether a process completed executing successfully. Some example usage is shown in the following snippet:</p>
			<p class="source-code">use std::process::Command;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let status = Command::new("cat")</p>
			<p class="source-code">        .arg("non-existent-file.txt")</p>
			<p class="source-code">        .status()</p>
			<p class="source-code">        .expect("failed to execute cat");</p>
			<p class="source-code"> </p>
			<p class="source-code">    if status.success() {</p>
			<p class="source-code">        println!("Successful operation");</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        println!("Unsuccessful operation");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Run this program and you will see the message <strong class="bold">Unsuccessful operation</strong> printed out to your terminal. Re-run the program with a valid filename and you will see the success message printed.</p>
			<p>This concludes this section. You learned different ways to run commands in a separate child process, how to <a id="_idIndexMarker607"/>terminate them, and how to get the status of their execution.</p>
			<p>In the next section, we'll look at how to set environment variables and work with I/O for child processes.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor142"/>Handling I/O and environment variables</h1>
			<p>In this section, we'll <a id="_idIndexMarker608"/>look at how to handle I/O with child processes, and also learn to set and clear environment variables for the child process. </p>
			<p>Why would <a id="_idIndexMarker609"/>we need this? </p>
			<p>Take the example of a load balancer that is tasked with spawning new workers (Unix processes) in response to incoming requests. Let's assume the new worker process reads configuration parameters from environment variables to perform its tasks. The load balancer process then would need to spawn the worker process and also set its environment variables. Likewise, there may be another situation where the parent process  wants to read a child process's standard output or standard error and route it to a log file. Let's understand how to perform such activities in Rust. We'll start with handling the I/O of the child process.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor143"/>Handling the I/O of child processes</h2>
			<p>Standard input (<strong class="source-inline">stdin</strong>), standard <a id="_idIndexMarker610"/>output (<strong class="source-inline">stdout</strong>), and standard error (<strong class="source-inline">stderr</strong>) are abstractions that allow a process to interact with the surrounding environment.</p>
			<p>For example, when many user processes are running at the same time, and when a user types keystrokes on a terminal, the kernel delivers the keystrokes to the standard input of the right process. Likewise, a Rust program (running as a process in a shell) can print out characters to its standard output, which is in turn read by the shell program and delivered to the terminal screen for the user. Let's learn how to work with standard input and standard output using the Rust standard library.</p>
			<p>The <strong class="source-inline">piped()</strong> method on <strong class="source-inline">std::process::Stdio</strong> allows the child process to communicate with its parent process using a <strong class="source-inline">pipe</strong> (which is an IPC mechanism in Unix-like systems).</p>
			<p>We'll first look at how to communicate with the standard output handle of the child process from the <a id="_idIndexMarker611"/>parent process:</p>
			<p class="source-code">use std::io::prelude::*;</p>
			<p class="source-code">use std::process::{Command, Stdio};</p>
			<p class="source-code"> </p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    // Spawn the `ps` command</p>
			<p class="source-code">    let process = match Command::new("ps").</p>
			<p class="source-code">    stdout(Stdio::piped()).spawn() {</p>
			<p class="source-code">        Err(err) =&gt; panic!("couldn't spawn ps: {}", err),</p>
			<p class="source-code">        Ok(process) =&gt; process,</p>
			<p class="source-code">    };</p>
			<p class="source-code">    let mut ps_output = String::new();</p>
			<p class="source-code">    match process.stdout.unwrap().read_to_string(&amp;mut     </p>
			<p class="source-code">    ps_output) {</p>
			<p class="source-code">        Err(err) =&gt; panic!("couldn't read ps stdout: {}", </p>
			<p class="source-code">            err),</p>
			<p class="source-code">        Ok(_) =&gt; print!("ps output from child process </p>
			<p class="source-code">            is:\n{}", ps_output),</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the preceding code snippet, we first create a new child process to run the <strong class="source-inline">ps</strong> command to show a list of currently running processes. The output is, by default, sent to the child process's <strong class="source-inline">stdout</strong>. </p>
			<p>In order to get access to the child process's <strong class="source-inline">stdout</strong> from the parent process, we create a Unix pipe using the <strong class="source-inline">stdio::piped()</strong> method. The <strong class="source-inline">process</strong> variable is the handle to the child process, and <strong class="source-inline">process.stdout</strong> is the handle to the child process's standard output. The parent process can read from this handle, and print out its contents to its own <strong class="source-inline">stdout</strong> (that is, the parent process's <strong class="source-inline">stdout</strong>). This is how a parent process can read the output of a child process.</p>
			<p>Let's now write some <a id="_idIndexMarker612"/>code to send some bytes from the parent process to the standard input of the child process:</p>
			<p class="source-code">    let process = match Command::new("rev")</p>
			<p class="source-code">        .stdin(Stdio::piped())               &lt;1&gt;</p>
			<p class="source-code">        .stdout(Stdio::piped())              &lt;2&gt;</p>
			<p class="source-code">        .spawn()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Err(err) =&gt; panic!("couldn't spawn rev: {}", err),</p>
			<p class="source-code">        Ok(process) =&gt; process,</p>
			<p class="source-code">    };</p>
			<p class="source-code">    match process.stdin.unwrap().write_all</p>
			<p class="source-code">        ("palindrome".as_bytes()) {</p>
			<p class="source-code">        Err(why) =&gt; panic!("couldn't write to stdin: {}", </p>
			<p class="source-code">            why),</p>
			<p class="source-code">        Ok(_) =&gt; println!("sent text to rev command"),</p>
			<p class="source-code">    }                                      &lt;3&gt;</p>
			<p class="source-code">    let mut child_output = String::new();</p>
			<p class="source-code">    match process.stdout.unwrap().read_to_string(&amp;mut </p>
			<p class="source-code">        child_output) {</p>
			<p class="source-code">        Err(err) =&gt; panic!("couldn't read stdout: {}", err),</p>
			<p class="source-code">        Ok(_) =&gt; print!("Output from child process is:\n{}", </p>
			<p class="source-code">            child_output),</p>
			<p class="source-code">    }                                             &lt;4&gt;</p>
			<p>The descriptions of the numbered annotations in the preceding code are provided here:</p>
			<ol>
				<li value="1">Register a piped connection between the <em class="italic">parent process</em> and <em class="italic">standard input</em> of the child process.</li>
				<li>Register a piped connection between the <em class="italic">parent process</em> and <em class="italic">standard output</em> of the child process.</li>
				<li>Write bytes to the <em class="italic">standard input</em> of the child process.</li>
				<li>Read from the <em class="italic">standard output</em> of the child process and print it to the terminal screen.</li>
			</ol>
			<p>There are a few other methods available on the child process. The <strong class="source-inline">id()</strong> method provides the <em class="italic">process id</em> of the <a id="_idIndexMarker613"/>child process, the <strong class="source-inline">kill()</strong> method kills the child process, the <strong class="source-inline">stderr</strong> method gives a handle to the child process's <em class="italic">standard error</em>, and the <strong class="source-inline">wait()</strong> method makes the parent process to wait until the child process has completely exited.</p>
			<p>We've seen how to handle I/O for child processes. Let's now learn how to work with environment variables.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor144"/>Setting the environment for the child process</h2>
			<p>Let's look at how to <a id="_idIndexMarker614"/>set environment variables for the child process. The following example shows how to set the path environment variable for a child process:</p>
			<p class="source-code">use std::process::Command;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    Command::new("env")</p>
			<p class="source-code">        .env("MY_PATH", "/tmp")</p>
			<p class="source-code">        .spawn()</p>
			<p class="source-code">        .expect("Command failed to execute");</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">env()</strong> method on <strong class="source-inline">std::process::Command</strong> allows the parent process to set the environment variable for the child process being spawned. Run the program and test it with the following command:</p>
			<p class="source-code">cargo run | grep MY_PATH</p>
			<p>You'll see the value of the <strong class="source-inline">MY_PATH</strong> environment variable that was set in the program.</p>
			<p>To set multiple environment variables, the <strong class="source-inline">envs()</strong> command can be used.</p>
			<p>The environment variables for a child <a id="_idIndexMarker615"/>process can be cleared by using the <strong class="source-inline">env_clear()</strong> method, as shown:</p>
			<p class="source-code">    Command::new("env")</p>
			<p class="source-code">        .env_clear()</p>
			<p class="source-code">        .spawn()</p>
			<p class="source-code">        .expect("Command failed to execute");</p>
			<p>Run the program with <strong class="source-inline">cargo run</strong> , and you will see that <em class="italic">nothing</em> is printed out for the <strong class="source-inline">env</strong> command. Re-run the program by commenting out the <strong class="source-inline">.env_clear()</strong> statement, and you will find the <strong class="source-inline">env</strong> values printed to terminal.</p>
			<p>To remove a specific environment variable, the <strong class="source-inline">env_remove()</strong> method can be used.</p>
			<p>With this, we conclude this section. We've seen how to interact with standard input and standard output of a child process and to set/reset the environment variables. In the next section, we'll learn how to handle errors and signals in child processes.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor145"/>Handling panic, errors, and signals</h1>
			<p>Processes can <a id="_idIndexMarker616"/>fail due to various error conditions. These <a id="_idIndexMarker617"/>have to be handled in a controlled manner. There <a id="_idIndexMarker618"/>may also be situations where <a id="_idIndexMarker619"/>we want to terminate a <a id="_idIndexMarker620"/>process in response to external inputs, such <a id="_idIndexMarker621"/>as a user pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>. How we can handle such situations is the focus of this section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In cases when processes exit due to errors, the operating system itself performs some cleanup, such as releasing memory, closing network connections, and releasing any file handles associated with the process. But sometimes, you may want program-driven controls to handle these cases.</p>
			<p>Failures in process execution can broadly be classified into two types – <em class="italic">unrecoverable errors</em> and <em class="italic">recoverable errors</em>. When a process encounters an unrecoverable error, there is sometimes no option but to abort the process. Let's see how to do that.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor146"/>Aborting the current process</h2>
			<p>We saw how to <a id="_idIndexMarker622"/>terminate and exit from a process in the <em class="italic">Spawning processes with Rust</em> section. The <strong class="source-inline">abort()</strong> and <strong class="source-inline">exit()</strong> methods on <strong class="source-inline">process::Command</strong> can be used for this purpose.</p>
			<p>In some cases, we consciously allow a program to fail under some conditions without handling it, mainly in cases of unrecoverable errors. The <strong class="source-inline">std::panic</strong> macro allows us to panic the current thread. What this means is that the program terminates immediately and provides feedback to the caller. But unlike the <strong class="source-inline">exit()</strong> or <strong class="source-inline">abort()</strong> methods, it unwinds the stack of the current thread and calls all destructors. Here is an example of the usage of the <strong class="source-inline">panic!</strong> macro:</p>
			<p class="source-code">use std::process::{Command, Stdio};</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let _child_process = match Command::new("invalid-command")</p>
			<p class="source-code">        .stdin(Stdio::piped())</p>
			<p class="source-code">        .stdout(Stdio::piped())</p>
			<p class="source-code">        .spawn()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Err(err) =&gt; panic!("Unable to spawn child process: </p>
			<p class="source-code">            {}", err),</p>
			<p class="source-code">        Ok(new_process_handle) =&gt; {</p>
			<p class="source-code">            println!("Successfully spawned child process");</p>
			<p class="source-code">            new_process_handle</p>
			<p class="source-code">        }</p>
			<p class="source-code">    };</p>
			<p class="source-code">} </p>
			<p>Run the program with <strong class="source-inline">cargo run</strong> and you will see the error message printed out from the <strong class="source-inline">panic!</strong> macro. There is <a id="_idIndexMarker623"/>also a custom hook that can be registered that will get invoked before the standard cleanup is performed by the <strong class="source-inline">panic</strong> macro. Here is the same example, this time with a custom <strong class="source-inline">panic</strong> hook:</p>
			<p class="source-code">use std::panic;</p>
			<p class="source-code">use std::process::{Stdio,Command};</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code"><strong class="bold">panic::set_hook</strong>(Box::new(|_| {</p>
			<p class="source-code">            println!(" This is an example of custom panic </p>
			<p class="source-code">                hook, which is invoked on thread panic, but </p>
			<p class="source-code">                before the panic run-time is invoked")</p>
			<p class="source-code">        }));       </p>
			<p class="source-code">    let _child_process = match Command::new("invalid-command")</p>
			<p class="source-code">        .stdin(Stdio::piped())</p>
			<p class="source-code">        .stdout(Stdio::piped())</p>
			<p class="source-code">        .spawn()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Err(err) =&gt; panic!("Normal panic message {}", err),</p>
			<p class="source-code">        Ok(new_process_handle) =&gt; new_process_handle,</p>
			<p class="source-code">    };</p>
			<p class="source-code">}</p>
			<p>On running this program, you will see the custom error hook message displayed, as we are providing an invalid command to spawn as a child process.</p>
			<p>Note that <strong class="source-inline">panic!</strong> should be used only for non-recoverable errors. For example, if a child process tries to open a file that does not exist, this can be handled using a recoverable error mechanism such as the <strong class="source-inline">Result enum</strong>. The advantage of using <strong class="source-inline">Result</strong> is that the program <a id="_idIndexMarker624"/>can return to its original state and the failed operation can be retried. If <strong class="source-inline">panic!</strong> is used, the program terminates abruptly, and the original state of the program cannot be recovered. But there are situations where <strong class="source-inline">panic!</strong> may be appropriate such, as when a process runs out of memory in the system.</p>
			<p>Let's next look at another aspect of process control—signal handling.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor147"/>Signal handling</h2>
			<p>In Unix-like <a id="_idIndexMarker625"/>systems, the operating system can send signals to processes. Note that Windows OS does not <a id="_idIndexMarker626"/>have signals. The process can handle the signal in a way it deems fit, or even ignore the signal. There are operating-system defaults for handling various signals. For example, when you issue a kill command on a process from a shell, the <strong class="source-inline">SIGTERM</strong> signal is generated. The program terminates on receipt of this signal by default, and there is no special additional code that needs to be written in Rust to handle that signal. Similarly, a <strong class="source-inline">SIGINT</strong> signal is received when a user presses <em class="italic">Ctrl</em> + <em class="italic">C</em>. But a Rust program can choose to handle these signals in its own way.</p>
			<p>However, handling Unix signals correctly is hard for various reasons. For example, a signal can occur at any time and the thread processing cannot continue until the signal handler completes execution. Also, signals can occur on any thread and synchronization is needed. For this reason, it is better to use third-party crates in Rust for signal handling. Note that even while using external crates, caution should be exercised as the crates do not solve all problems associated with signal handling.</p>
			<p>Let's now see an example of handling signals using the <strong class="source-inline">signal-hook</strong> crate. Add it to dependencies in <strong class="source-inline">Cargo.toml</strong> as shown:</p>
			<p class="source-code">[dependencies]</p>
			<p class="source-code">signal-hook = "0.1.16"</p>
			<p>An example code <a id="_idIndexMarker627"/>snippet is shown as <a id="_idIndexMarker628"/>follows:</p>
			<p class="source-code">use signal_hook::iterator::Signals;</p>
			<p class="source-code">use std::io::Error;</p>
			<p class="source-code">fn main() -&gt; Result&lt;(), Error&gt; {</p>
			<p class="source-code">    let signals = Signals::new(&amp;[signal_hook::SIGTERM, </p>
			<p class="source-code">        signal_hook::SIGINT])?;</p>
			<p class="source-code">    'signal_loop: loop {</p>
			<p class="source-code">        // Pick up signals that arrived since last time</p>
			<p class="source-code">        for signal in signals.pending() {</p>
			<p class="source-code">            match signal {</p>
			<p class="source-code">                signal_hook::SIGINT =&gt; {</p>
			<p class="source-code">                    println!("Received signal SIGINT");</p>
			<p class="source-code">                }</p>
			<p class="source-code">                signal_hook::SIGTERM =&gt; {</p>
			<p class="source-code">                    println!("Received signal SIGTERM");</p>
			<p class="source-code">                    break 'signal_loop;</p>
			<p class="source-code">                }</p>
			<p class="source-code">                _ =&gt; unreachable!(),</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    println!("Terminating program");</p>
			<p class="source-code">    Ok(())</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we listen for two specific signals, <strong class="source-inline">SIGTERM</strong> and <strong class="source-inline">SIGINT,</strong> within the <strong class="source-inline">match</strong> clause. <strong class="source-inline">SIGINT</strong> can be sent to the program by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>. The <strong class="source-inline">SIGTERM</strong>  signal can be generated by using the <strong class="source-inline">kill</strong> command on a <em class="italic">process id</em> from the shell.</p>
			<p>Now, run the program and simulate the two signals. Then, press the <em class="italic">Ctrl</em> + <em class="italic">C</em> key combination, which generates the <strong class="source-inline">SIGINT</strong> signal. You will see that instead of the default behavior (which is to <a id="_idIndexMarker629"/>terminate the program), a statement is <a id="_idIndexMarker630"/>printed out to the terminal.</p>
			<p>To simulate SIGTERM, run a <strong class="source-inline">ps</strong> command on the command line of a Unix shell and retrieve the <em class="italic">process id</em>. Then run a <strong class="source-inline">kill</strong> command with the <em class="italic">process id</em>. You will see that the process terminates, and a statement is printed to the terminal.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are using <strong class="bold">tokio</strong> for asynchronous code, you can <a id="_idIndexMarker631"/>use the <strong class="bold">tokio-support</strong> feature of signal-hook.</p>
			<p>It is important to remember that signal handling is a complex topic, and even with external crates, care must be exercised while writing custom signal-handling code.</p>
			<p>While handling signals or dealing with errors, it is also good practice to log the signal or error using a crate such as <strong class="source-inline">log</strong> for future reference and troubleshooting by system administrators. However, if you'd like a program to read these logs, you can log these messages in JSON format instead of plaintext by using an external crate such as <strong class="source-inline">serde_json</strong>.</p>
			<p>This concludes this subsection on working with <em class="italic">panic</em>, <em class="italic">errors</em>, and <em class="italic">signals</em> in Rust. Let's now write a shell program that demonstrates some of the concepts discussed.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor148"/>Writing a shell program in Rust (project)</h1>
			<p>We learned in the <em class="italic">Delving into Linux process fundamentals</em> section what a shell program is. In this <a id="_idIndexMarker632"/>section, let's build a shell program, adding <a id="_idIndexMarker633"/>features iteratively. </p>
			<p>In the first iteration, we'll write the basic code to read a shell command from the command line and spawn a child process to execute the command. Next, we'll add the ability to pass command arguments to the child process. Lastly, we will personalize the shell by adding support for users to enter commands in a more natural-language-like syntax. We'll also introduce error handling in this last iteration. Let's get started:</p>
			<ol>
				<li value="1">Let's first create a new project:<p class="source-code"><strong class="bold">cargo new myshell &amp;&amp; cd myshell</strong></p></li>
				<li>Create three files: <strong class="source-inline">src/iter1.rs</strong>, <strong class="source-inline">src/iter2.rs</strong>, and <strong class="source-inline">src/iter3.rs</strong>. The code for the three iterations will be placed in these files so that it will be easy to build and test each iteration separately.</li>
				<li>Add the following to <strong class="source-inline">Cargo.toml</strong>:<p class="source-code">[[bin]]</p><p class="source-code">name = "iter1"</p><p class="source-code">path = "src/iter1.rs"</p><p class="source-code">[[bin]]</p><p class="source-code">name = "iter2"</p><p class="source-code">path = "src/iter2.rs"</p><p class="source-code">[[bin]]</p><p class="source-code">name = "iter3"</p><p class="source-code">path = "src/iter3.rs"</p><p>In the preceding code, we specify to the Cargo tool that we want to build separate binaries for the three iterations.</p></li>
			</ol>
			<p>We're now ready to start with the first iteration of the shell program.</p>
			<h3>Iteration 1 – Spawning a child process to execute commands</h3>
			<p>First, let's write a program to <a id="_idIndexMarker634"/>accept commands from the terminal, and then spawn a new child process to execute those user commands. Add a loop construct to continue accepting user commands in a loop until the process is terminated. The code is as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/iter1.rs</p>
			<p class="source-code">use std::io::Write;</p>
			<p class="source-code">use std::io::{stdin, stdout};</p>
			<p class="source-code">use std::process::Command;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    loop {</p>
			<p class="source-code">        print!("$ ");                               &lt;1&gt;</p>
			<p class="source-code">        stdout().flush().unwrap();                  &lt;2&gt;</p>
			<p class="source-code">        let mut user_input = String::new();         &lt;3&gt;</p>
			<p class="source-code">        stdin()</p>
			<p class="source-code">            .read_line(&amp;mut user_input)             &lt;4&gt;</p>
			<p class="source-code">            .expect("Unable to read user input");	</p>
			<p class="source-code">        let command_to_execute = user_input.trim(); &lt;5&gt;</p>
			<p class="source-code">        let mut child = Command::new(command_to_execute) &lt;6&gt;</p>
			<p class="source-code">            .spawn()</p>
			<p class="source-code">            .expect("Unable to execute command");</p>
			<p class="source-code">        child.wait().unwrap();                       &lt;7&gt;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The numbered annotations in the preceding code are described as follows:</p>
			<ol>
				<li value="1">Display the <strong class="source-inline">$</strong> prompt to nudge the user to enter commands.</li>
				<li>Flush the <strong class="source-inline">stdout</strong> handle so that the <strong class="source-inline">$</strong> prompt is immediately displayed on the terminal.</li>
				<li>Create a buffer to hold the command entered by the user.</li>
				<li>Read the user <a id="_idIndexMarker635"/>commands one line at a time.</li>
				<li>Remove the newline character from the buffer (this is added when the user presses the <em class="italic">Enter</em> key to submit the command).</li>
				<li>Create a new child process and pass the user commands to the child process for execution.</li>
				<li>Wait until the child process completes execution before accepting additional user inputs.</li>
				<li>Run the program with the following command:</li>
			</ol>
			<p class="source-code">cargo run –-bin iter1 </p>
			<p>Type any command without arguments such as <strong class="source-inline">ls</strong> or <strong class="source-inline">ps</strong> or <strong class="source-inline">du</strong> on the <strong class="source-inline">$</strong> prompt. You'll see the output of the command execution displayed on the terminal. You can continue to enter more such commands at the next <strong class="source-inline">$</strong> prompt. Press <em class="italic">Ctrl</em> + <em class="italic">C</em> to exit the program.</p>
			<p>We now have the first version of our shell program working, but this program will fail if parameters or flags are entered after the command. For example, typing a command such as <strong class="source-inline">ls</strong> works, but typing <strong class="source-inline">ls –lah</strong> will cause the program to panic and exit. Let's add support for command arguments in the next iteration of our code.</p>
			<h3>Iteration 2 – Adding support for command arguments</h3>
			<p>Let's add support for <a id="_idIndexMarker636"/>command arguments with the <strong class="source-inline">args()</strong> method:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/iter2.rs</p>
			<p class="source-code">// Module imports not shown here</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    loop {</p>
			<p class="source-code">        print!("$ ");</p>
			<p class="source-code">        stdout().flush().unwrap();</p>
			<p class="source-code">        let mut user_input = String::new();</p>
			<p class="source-code">        stdin()</p>
			<p class="source-code">            .read_line(&amp;mut user_input)</p>
			<p class="source-code">            .expect("Unable to read user input");</p>
			<p class="source-code">        let command_to_execute = user_input.trim();</p>
			<p class="source-code">        let command_args: Vec&lt;&amp;str&gt; =      </p>
			<p class="source-code">            command_to_execute.split_whitespace().</p>
			<p class="source-code">            collect(); <strong class="bold">&lt;1&gt;</strong></p>
			<p class="source-code"> </p>
			<p class="source-code">        let mut child = Command::new(command_args[0])            </p>
			<p class="source-code">                                                       <strong class="bold">&lt;2&gt;</strong></p>
			<p class="source-code">            .args(&amp;command_args[1..])   <strong class="bold">&lt;3&gt;</strong></p>
			<p class="source-code">            .spawn()</p>
			<p class="source-code">            .expect("Unable to execute command");</p>
			<p class="source-code">        child.wait().unwrap();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The code shown is essentially the same as the previous snippet, except for the three additional lines added, which are annotated with numbers. The annotations are described as follows:</p>
			<ol>
				<li value="1">Take the user input, split it by whitespace, and store the result in <strong class="source-inline">Vec</strong>.</li>
				<li>The first element of the <strong class="source-inline">Vec</strong> corresponds to the command. Create a child process to execute this command.</li>
				<li>Pass the list of <strong class="source-inline">Vec</strong> elements, starting from the second element, as a list of arguments to the child process.</li>
				<li>Run the program <a id="_idIndexMarker637"/>with the following line:<p class="source-code"><strong class="bold">cargo run -–bin iter2 </strong></p></li>
				<li>Enter a command and pass arguments to it before hitting the <em class="italic">Enter</em> key. For example, you can type one of the following commands: <p class="source-code"><strong class="bold">ls –lah</strong></p><p class="source-code"><strong class="bold">ps -ef</strong></p><p class="source-code"><strong class="bold">cat a.txt </strong></p></li>
			</ol>
			<p>Note that in the last command, <strong class="source-inline">a.txt</strong> is an existing file holding some contents and located in the project root folder.</p>
			<p>You will see the command outputs successfully displayed on the terminal. The shell works so far as we intended. Let's extend it now a little further in the next iteration.</p>
			<h3>Iteration 3 – Supporting natural-language commands</h3>
			<p>Since this is our own shell, let's implement a user-friendly alias for a shell command in this iteration (<em class="italic">why not?</em>). Instead of <a id="_idIndexMarker638"/>typing <strong class="source-inline">ls</strong>, what if a user could type a command in natural language, as follows:</p>
			<p class="source-code">show files</p>
			<p>This is what we'll code next. The following snippet shows the code. Let's look at the module imports first:</p>
			<p class="source-code">use std::io::Write;</p>
			<p class="source-code">use std::io::{stdin, stdout};</p>
			<p class="source-code">use std::io::{Error, ErrorKind};</p>
			<p class="source-code">use std::process::Command;</p>
			<p>Modules from <strong class="source-inline">std::io</strong> are imported for writing to the terminal, reading from the terminal, and for error handling. We already know the purpose of importing the <strong class="source-inline">process</strong> module.</p>
			<p>Let's now look at the <strong class="source-inline">main()</strong> program in parts. We won't cover the code already seen in previous iterations. The complete code for the <strong class="source-inline">main()</strong> function can be found in the GitHub repo in the <strong class="source-inline">src/iter3.rs</strong> file:</p>
			<ol>
				<li value="1">After displaying the <strong class="source-inline">$</strong> prompt, check whether the user has entered any command. If the user presses just the <em class="italic">Enter</em> key at the prompt, ignore and redisplay the <strong class="source-inline">$</strong> prompt. The following code checks whether at least one command has been entered by the user, then processes the user input:<p class="source-code">if command_args.len() &gt; 0 {..}</p></li>
				<li>If the command entered is <strong class="source-inline">show files</strong>, execute the <strong class="source-inline">ls</strong> command in a child process. If the command is <strong class="source-inline">show process</strong>, execute the <strong class="source-inline">ps</strong> command. If <strong class="source-inline">show</strong> is entered without a parameter, or if the <strong class="source-inline">show</strong> command is followed by an invalid word, throw an error:<p class="source-code">            let child = match command_args[0] {</p><p class="source-code">                "show" if command_args.len() &gt; 1 =&gt; match </p><p class="source-code">                    command_args[1] {</p><p class="source-code">                    "files" =&gt; Command::new("ls").</p><p class="source-code">                        args(&amp;command_args[2..]).spawn(),</p><p class="source-code"> </p><p class="source-code">                    "process" =&gt; Command::new("ps").args</p><p class="source-code">                        (&amp;command_args[2..]).spawn(),</p><p class="source-code"> </p><p class="source-code">                    _ =&gt; Err(Error::new(</p><p class="source-code">                        ErrorKind::InvalidInput,</p><p class="source-code">                        "please enter valid command",</p><p class="source-code">                    )),</p><p class="source-code">                },</p><p class="source-code">                "show" if command_args.len() == 1 =&gt; </p><p class="source-code">                    Err(Error::new(</p><p class="source-code">                    ErrorKind::InvalidInput,</p><p class="source-code">                    "please enter valid command",</p><p class="source-code">                )),</p><p class="source-code">                "quit" =&gt; std::process::exit(0),</p><p class="source-code">                _ =&gt; Command::new(command_args[0])</p><p class="source-code">                    .args(&amp;command_args[1..])</p><p class="source-code">                    .spawn(),</p><p class="source-code">            };</p></li>
				<li>Wait for the <a id="_idIndexMarker639"/>child process to complete. If the child process fails to execute successfully, or if the user input is invalid, throw an error:<p class="source-code">            match child {</p><p class="source-code">                Ok(mut child) =&gt; {</p><p class="source-code">                    if child.wait().unwrap().success() {</p><p class="source-code">                    } else {</p><p class="source-code">                        println!("\n{}", "Child process </p><p class="source-code">                            failed")</p><p class="source-code">                    }</p><p class="source-code">                }</p><p class="source-code">                Err(e) =&gt; match e.kind() {</p><p class="source-code">                    ErrorKind::InvalidInput =&gt; eprintln!(                        </p><p class="source-code">                        "Sorry, show command only </p><p class="source-code">                        supports following options: files </p><p class="source-code">                        , process "</p><p class="source-code">                    ),</p><p class="source-code">                    _ =&gt; eprintln!("Please enter a </p><p class="source-code">                        valid command"),</p><p class="source-code">                },</p><p class="source-code">            }</p></li>
				<li>Run the program with <strong class="source-inline">cargo run –-bin iter3</strong> and try the following commands at the <strong class="source-inline">$</strong> prompt to test:<p class="source-code">show files</p><p class="source-code">show process </p><p class="source-code">du</p></li>
			</ol>
			<p>You'll see the commands successfully execute, with a statement printed out indicating success.</p>
			<p>You would have noticed that we've added some error handling in the code. Let's look at what error conditions we've addressed:</p>
			<ul>
				<li>If the user presses <em class="italic">Enter</em> without entering a command</li>
				<li>If the user enters the <strong class="source-inline">show</strong> command without a parameter (either a file or process)</li>
				<li>If the user enters the <strong class="source-inline">show</strong> command with an invalid parameter</li>
				<li>If the user enters a valid Unix command, but one that is not supported by our program (for example, <strong class="source-inline">pipes</strong> or <strong class="source-inline">redirection</strong>)</li>
			</ul>
			<p>Let's try the following invalid inputs:</p>
			<p class="source-code">show memory</p>
			<p class="source-code">show</p>
			<p class="source-code">invalid-command</p>
			<p>You'll see that an <a id="_idIndexMarker640"/>error message is printed to the terminal.</p>
			<p>Try also hitting the <em class="italic">Enter</em> key without command. You will see that this is not processed.</p>
			<p>In error-handling code, note use of <strong class="source-inline">ErrorKind</strong> <strong class="source-inline">enum</strong>, which is a set of pre-defined error types defined in the Rust standard library. The list of predefined error types can be found at <a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html">https://doc.rust-lang.org/std/io/enum.ErrorKind.html</a>.</p>
			<p>Congratulations! You have implemented a basic shell program that can recognize natural-language commands for non-technical users. You've also implemented some error handling so that the program is reasonably robust and doesn't crash on invalid inputs.</p>
			<p>As an exercise, you can do the following to enhance this shell program:</p>
			<ul>
				<li>Add support for pipe-operator-separated command chains such as <strong class="source-inline">ps | grep sys</strong>.</li>
				<li>Add support for redirections such as the <strong class="bold">&gt;</strong> operator to divert the output of a process execution to a file.</li>
				<li>Move the logic of <a id="_idIndexMarker641"/>command-line parsing into a separate tokenizer module.</li>
			</ul>
			<p>In this section, we've written a shell program that has a subset of the features of a real-world shell program such as <strong class="source-inline">zsh</strong> or <strong class="source-inline">bash</strong>. To be clear, a real-world shell program has a lot more complex features, but we have covered the fundamental concepts behind creating a shell program here. Also importantly, we've learned how to handle errors in case of invalid user inputs or if a child process fails. To internalize your learning, it is recommended to write some code for the suggested exercises.</p>
			<p>This concludes the section on writing a shell program in Rust.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor149"/>Summary</h1>
			<p>In this chapter, we reviewed the basics of processes in Unix-like operating systems. We learned how to spawn a child process, interact with its standard input and standard output, and execute a command with its arguments. We also saw how to set and clear environment variables. We looked at the various ways to terminate a process on error conditions, and how to detect and handle external signals. We finally wrote a shell program in Rust that can execute the standard Unix commands, but also accept a couple of commands in a natural-language format. We also handled a set of errors to make the program more robust.</p>
			<p>Continuing on the topic of managing system resources, in the next chapter, we will learn how to manage threads of a process and build concurrent systems programs in Rust.</p>
		</div>
	</body></html>