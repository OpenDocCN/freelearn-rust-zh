<html><head></head><body>
		<div><h1 id="_idParaDest-127"><em class="italic">Chapter 8</em>: <a id="_idTextAnchor132"/>Working with Processes and Signals</h1>
			<p>Do you know how commands are executed when you type them into a terminal interface on your computer? Are these commands directly executed by the operating system, or is there an intermediate program that handles them? When you run a program from the command line in the foreground, and press <em class="italic">Ctrl</em> + <em class="italic">C</em>, who is listening to this keypress, and how is the program terminated? How can multiple user programs be run at the same time by the operating system? What is the difference between a program and a process? If you are curious, then read on.</p>
			<p>In the previous chapter, we learned how to control and alter the terminal interface that is used to interact with the users in command-line applications.</p>
			<p>In this chapter, we will look at <em class="italic">processes</em>, which are the second most popular abstraction in systems programming after <em class="italic">files</em>. We'll learn what processes are, how they differ from programs, how they are started and terminated, and how the process environment can be controlled. This skill is necessary if you want to write systems programs such as shells, where you want programmatic control over the life cycle of processes. </p>
			<p>We'll also build an elementary shell program as a mini project by using the <em class="italic">Rust Standard Library</em> This will give you a practical understanding of how popular shells such as <em class="italic">Bourne</em>, <em class="italic">Bash</em>, and <em class="italic">zsh</em> work under the hood, and teach you the basics of how you can build your own customized shell environments in Rust.  </p>
			<p>We will cover these topics in the following order:</p>
			<ul>
				<li>Understanding Linux process concepts and syscalls</li>
				<li>Spawning new processes with Rust</li>
				<li>Handling I/O and environment variables for child processes</li>
				<li>Handling panic, errors, and signals</li>
				<li>Writing a basic shell program in Rust (project)</li>
			</ul>
			<p>By the end of this chapter, you will have learned how to programmatically launch new programs as separate processes, how to set and adjust environment variables, how to handle errors, respond to external signals, and exit the process gracefully. You will learn how to talk to the operating system to perform these tasks using the Rust standard library. This gives you, as a system programmer, great control over this important system resource; that is, <em class="italic">processes</em>.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor133"/>Technical requirements</h1>
			<p>Verify that <code>rustc</code>, and <code>cargo</code> have been installed correctly with the following command: </p>
			<pre>rustc –version
cargo --version</pre>
			<p>The Git repo for the code in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter08">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter08</a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The section on signal handling requires a Unix-like development environment (<em class="italic">Unix</em>,<em class="italic"> Linux</em>, or <em class="italic">macOS</em>), as Microsoft Windows does not directly have the concept of signals. If you work with Windows, download a virtual machine such as Oracle VirtualBox (<a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>) or use a <em class="italic">Docker</em> container to launch a <em class="italic">Unix/Linux</em> image to follow along.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor134"/>Understanding Linux process concepts and syscalls</h1>
			<p>In this section, we'll <a id="_idIndexMarker573"/>cover the fundamentals of process management and <a id="_idIndexMarker574"/>get an appreciation of why it is important for systems programming. We'll look at the process life cycle, including <em class="italic">creating new processes</em>, <em class="italic">setting their environment parameters</em>, <em class="italic">working with their standard input and output</em>, and <em class="italic">terminating the processes</em>.</p>
			<p>This section starts with understanding the differences between a <em class="italic">program</em> and a <em class="italic">process</em>. We'll then go into a few key details about the fundamentals of processes in Linux. Lastly, we'll see an overview of how to manage the process life cycle with Rust using syscalls encapsulated by the Rust standard library.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor135"/>How does a program become a process?</h2>
			<p>A <strong class="bold">process</strong> is a running <strong class="bold">program</strong>. To be <a id="_idIndexMarker575"/>precise, it is an <em class="italic">instance</em> of a running program. You <a id="_idIndexMarker576"/>can have <em class="italic">multiple instances</em> of a single program running at <a id="_idIndexMarker577"/>the same time, such as starting a text editor from multiple terminal windows. Each such instance of a running program is a <em class="italic">process</em>.</p>
			<p>Even though a process is created as a result of running (or executing) a program, the two are <a id="_idIndexMarker578"/>different. A program exists <a id="_idIndexMarker579"/>in two forms – <strong class="bold">source code</strong> and <strong class="bold">machine-executable instructions</strong> (object code <a id="_idIndexMarker580"/>or executables). A compiler (and linker) is typically used to convert the <a id="_idIndexMarker581"/>source code of a program into <em class="italic">machine-executable instructions</em>.</p>
			<p><em class="italic">Machine-executable instructions</em> contain information for the operating system on how to <em class="italic">load a program into memory</em>, <em class="italic">initialize</em> it, and <em class="italic">run</em> it. The instructions include the following:</p>
			<ul>
				<li>An executable format (for example, <strong class="bold">ELF</strong> is a popular executable format in Unix systems).</li>
				<li>The program logic to be executed by the CPU.</li>
				<li>The memory address of the entry point of the program.</li>
				<li>Some data for initializing the program variables and constants.</li>
				<li>Information on the location of shared libraries, functions, and variables.</li>
			</ul>
			<p>When a program is started either from a command line, script, or graphical user interface, the following steps occur:</p>
			<ol>
				<li>The operating system (kernel) allocates virtual memory to the program (which is also <a id="_idIndexMarker582"/>called the <strong class="bold">memory layout</strong> of the program). We saw this in <a href="B16405_05_Final_NM_ePUB.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Memory Management in Rust</em>, on how virtual memory is laid out for a program in terms of <em class="italic">stack</em>, <em class="italic">heap</em>, <em class="italic">text</em>, and <em class="italic">data</em> segments.</li>
				<li>The kernel then loads the program instructions into the <em class="italic">text segment</em> of the virtual memory.</li>
				<li>The kernel initializes the program variables in the <em class="italic">data segment</em>.</li>
				<li>The kernel triggers the CPU to start executing the program instructions.</li>
				<li>The kernel also provides the running program with access to resources it needs, such as files or additional memory.</li>
			</ol>
			<p>The memory layout of a process (running program) was discussed in <a href="B16405_05_Final_NM_ePUB.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Memory Management</em>. It is <a id="_idIndexMarker583"/>reproduced here in <em class="italic">Figure 8.1</em> for reference:</p>
			<div><div><img src="img/Figure_8.1_B16405.jpg" alt="Figure 8.1 – Program memory layout"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Program memory layout</p>
			<p>We've seen the <em class="italic">memory layout</em> of a program. What is a <em class="italic">process</em>, then?</p>
			<p>As far as the kernel is concerned, a process is an abstraction that consists of the following:</p>
			<ul>
				<li>Virtual memory in which the <a id="_idIndexMarker584"/>program instructions and data are loaded, which is represented in the program memory layout in <em class="italic">Figure 8.1</em>.</li>
				<li>A set of metadata about the running <a id="_idIndexMarker585"/>program such as the <em class="italic">process identifier</em>, <em class="italic">system resources</em> associated with the program (such as a list of open files), <em class="italic">virtual memory tables</em>, and other such information about the program. What is of particular importance is the <em class="italic">process ID</em>, which uniquely identifies an instance of a running program.<p class="callout-heading">Note</p><p class="callout">The kernel <a id="_idIndexMarker586"/>itself is the <code>init</code>, which is assigned a <em class="italic">process ID</em> of <em class="italic">1</em>. The <code>init</code> process terminates only when the system is shut down and cannot be killed. All future processes are created either by the <code>init</code> process or one of its descendent processes.</p><p class="callout">Thus, a program refers to instructions created by the programmer (in the source or a machine-executable format) and a process is a running instance of a program that uses system resources and is controlled by the kernel. As programmers, if we want to control a running program, we will need to use appropriate <em class="italic">system calls</em> to the kernel. The Rust standard library wraps these system calls into neat APIs for use within Rust programs, as discussed in <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>,<em class="italic"> Introduction to the Rust Standard Library</em>.</p></li>
			</ul>
			<p>We've seen how programs relate to processes. Let's discuss some more details about the <em class="italic">characteristics of processes</em> in the next section.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor136"/>Delving into Linux process fundamentals</h2>
			<p>In <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Introduction to the Rust Standard Library and Key Crates for Systems Programming</em>, we saw <a id="_idIndexMarker587"/>how system calls are the interface between a user program (process) and the kernel (operating system). Using system calls, a user program can manage and control various system resources such as <em class="italic">files</em>, <em class="italic">memory</em>, <em class="italic">devices</em>, and so on.</p>
			<p>In this section, we'll look at how one running program (the parent process) can make system calls to manage the life cycle of another program (the child process). Recall that processes are also treated as system resources in Linux, just like files or memory. Understanding how one process can manage and communicate with another process is the focus of this section.</p>
			<p><em class="italic">Figure 8.2</em> shows the key set of tasks related to process management:</p>
			<div><div><img src="img/Figure_8.2_B16405.jpg" alt="Figure 8.2 – Working with processes in Rust"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Working with processes in Rust</p>
			<p>Let's go over the <a id="_idIndexMarker588"/>process management tasks shown in the precedi<a id="_idTextAnchor137"/>ng figure. We'll see how process management is done on Linux by a non-Rust user program (for example, C/C++), and how it is different in Rust.</p>
			<h3>Creating a new process</h3>
			<p>While working with Unix/Linux, any user program that needs to create a new process has to request the kernel to do so <a id="_idIndexMarker589"/>using system calls (<em class="italic">syscalls</em>). A program (let's call it the <code>fork()</code> syscall. The kernel duplicates the parent process and creates a <em class="italic">child process</em> with a unique ID. The child process gets an exact copy of the parent's memory space (the heap, stack, and so on). The child also gets access to the same copy of the program instructions as the parent. </p>
			<p>After creation, a child process can choose to load a different program into its process memory space and execute it. This is accomplished using one of the <code>exec()</code> family of <em class="italic">syscalls</em>.</p>
			<p>So, basically, the <em class="italic">syscall</em> in Unix/Linux to <em class="italic">create a new child process</em> is different from that needed to <em class="italic">load a new program</em> into the child process and execute it. However, the Rust standard library simplifies this for us and provides a uniform interface, where both these steps can be combined while creating a new child process. We'll see examples of this in the next section.</p>
			<p>Let's go back to the question at the beginning of the chapter: <em class="italic">What exactly happens when you type something in the command line of a terminal?</em></p>
			<p>When you run a program by typing the program executable name in a command line, two things take place:</p>
			<ol>
				<li value="1">First, a new process is created using the <code>fork()</code> system call.</li>
				<li>Then, the image of the new program (that is, the <em class="italic">program executable</em>) is loaded into memory and executed using the <code>exec()</code> family of calls.<p class="callout-heading">What happens when you type a command in a terminal?</p><p class="callout">A terminal (as we saw in the previous chapter) provides an interface for the user to interact with the system. But there has to be something that interprets that command and executes it. This is the <code>find * | grep debug | wc -l</code></p><p class="callout">When this command is typed into a terminal, the shell program spawns three processes to execute this command pipeline. It is this shell command that makes the system call to the kernel to create new processes, load these commands, and execute them in a sequence. The shell then returns the results of the execution and prints it to standard output.</p></li>
			</ol>
			<h3>Checking the status of a child process</h3>
			<p>Once a child process is <a id="_idIndexMarker592"/>spawned by the kernel, it returns a child <em class="italic">process ID</em>. The <code>wait()</code> and <code>waitpid()</code> syscalls can be used to check whether the child process is running by passing the <em class="italic">child process ID</em> to the call. These are helpful to synchronize the execution of the child process with the parent process. The Rust system library provides calls to wait for the child process to finish and to check its status.</p>
			<h3>Communicating using inter-process communication </h3>
			<p>Processes can <a id="_idIndexMarker593"/>communicate with each other and with the kernel (remember that the kernel is also a process) to coordinate their activities, using mechanisms such as signals, pipes, sockets, message queues, semaphores, and shared memory. In Rust also, two processes can communicate using various means including pipes, processes, and message queues. But one of the <a id="_idIndexMarker594"/>basic forms of <strong class="bold">Inter-Process Communication</strong> (<strong class="bold">IPC</strong>) between parent and child processes involves <em class="italic">stdin/stdout pipes</em>. The parent process can write to standard input and read from the child process's standard output. We'll see an example of this in a later section.</p>
			<h3>Setting environment variables</h3>
			<p>Each process also has its own <a id="_idIndexMarker595"/>set of associated environment variables. The <code>fork()</code> and <code>exec()</code> syscalls allow the passing and setting of environment variables from the parent to the child process. The values of these environment variables are stored within the virtual memory area of the process. The Rust standard library also allows the parent process to explicitly set or reset the environment variables of the child process.</p>
			<h3>Terminating a process</h3>
			<p>A <a id="_idIndexMarker596"/>process can terminate itself by using the <code>exit()</code> syscall, or by being killed by a signal (such as the user pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>) or using the <code>kill()</code> syscall. Rust also has an <code>exit()</code> call for this purpose. Rust also provides other ways to abort a process, which we will look at in a later section.</p>
			<h3>Handling signals</h3>
			<p>Signals <a id="_idIndexMarker597"/>are used to communicate asynchronous events such as keyboard interrupts to a process. Except for two of the signals, SIGSTOP and SIGKILL, processes can either choose to ignore signals or decide how to respond to them in their own way. Handling signals directly using the Rust standard library is not developer-friendly, so for this, we can use external crates. We'll be using one such crate in a later section.</p>
			<p>In this section, we've seen the differences between a <em class="italic">program</em> and a <em class="italic">process</em>, delved into a few of the characteristics of Linux processes, and got an overview of the kind of things we can do in Rust to interact with processes.</p>
			<p>In the next section, we'll learn first-hand how to spawn, interact, and terminate processes using Rust by writing some code. Note that in the next few sections, only code snippets are provided. In order to execute the code, you will need to create a new cargo project and add the code shown in the <code>src/main.rs</code> file with the appropriate module imports.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor138"/>Spawning processes with Rust</h1>
			<p>In the Rust <a id="_idIndexMarker598"/>standard library, <code>std::process</code> is the module for working with <a id="_idIndexMarker599"/>processes. In this section, we'll look at how to <em class="italic">spawn new processes</em>, <em class="italic">interact with child processes</em>, and <em class="italic">abort the current process</em> using the Rust standard library. The Rust standard library internally uses the corresponding Unix/Linux <em class="italic">syscalls</em> to invoke the kernel operations for managing processes.</p>
			<p>Let's begin with launching new child processes.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor139"/>Spawning new child processes</h2>
			<p>The <code>std::process::Command</code> is used to launch a program at a specified path, or to run a standard shell <a id="_idIndexMarker600"/>command. The configuration parameters for the new process can be constructed using a builder pattern. Let's see a simple example:</p>
			<pre>use std::process::Command;
fn main() {
    Command::new("ls")
        .spawn()
        .expect("ls command failed to start");
}</pre>
			<p>The code shown uses the <code>Command::new()</code> method to create a new command for execution, that takes as a parameter the name of the program to be run. The <code>spawn()</code> method creates a new child process.</p>
			<p>If you run this program, you will see a listing of files in the current directory.</p>
			<p>This is the simplest way to spin off a standard Unix <em class="italic">shell command</em> or a <em class="italic">user program</em> as a child process using the Rust standard library. </p>
			<p>What if you would like to pass parameters to the shell command? Some example code is shown in the following snippet that passes arguments to the command:</p>
			<pre>use std::process::Command;
fn main() {
    Command::new("ls")
        .arg("-l")
        .arg("-h")
        .spawn()
        .expect("ls command failed to start");
}</pre>
			<p>The <code>arg()</code> method can be used to pass one argument to the program. Here we want to run the <code>ls –lh</code> command to display files in a long format with readable file sizes. We have to use the <code>arg()</code> method twice to pass the two flags.</p>
			<p>Alternatively, the <code>args()</code> method can be used as shown here. Note that the <code>std::process</code> import and the <code>main()</code> function declaration have been removed in future code snippets to avoid repetition, but you must add them before you can run the program:</p>
			<pre>Command::new("ls")
        .args(&amp;["-l", "-h"]).spawn().unwrap();</pre>
			<p>Let's alter the code to list the directory contents for the directory one level above (relative to the current directory).</p>
			<p>The code shows two <a id="_idIndexMarker601"/>parameters for the <code>ls</code> command configured through the <code>args()</code> method.</p>
			<p>Next, let's set the current directory for the child process to a non-default value:</p>
			<pre>    Command::new("ls")
        .current_dir("..")
        .args(&amp;["-l", "-h"])
        .spawn()
        .expect("ls command failed to start");</pre>
			<p>In the preceding code, we are spawning the process to run the <code>ls</code> command in the directory one level above. </p>
			<p>Run the program with the following command:</p>
			<pre> cargo run </pre>
			<p>You will see the listing of the parent directory displayed.</p>
			<p>We've so far used <code>spawn()</code> to create a new child process. This method returns a handle to the child process. </p>
			<p>There is another way to spawn a new process using <code>output()</code>. The difference is that <code>output()</code> spawns the child process and waits for it to terminate. Let's see an example:</p>
			<pre>    let output = Command::new("cat").arg("a.txt").output().
        unwrap();
    if !output.status.success() {
        println!("Command executed with failing error code");
    }
    println!("printing: {}", String::from_utf8(output.stdout).
        unwrap());</pre>
			<p>We are spawning a new process using the <code>output()</code> method to print out the contents of a file named <code>a.txt</code>. Let's create this file using the following command:</p>
			<pre>echo "Hello World" &gt; a.txt</pre>
			<p>If you run the program, you will see the contents of the <code>a.txt</code> file printed out to the terminal. Note that we <a id="_idIndexMarker602"/>are printing out the contents of the standard output handle of the child process because that's where the output of the <code>cat</code> command is directed to by default. We'll learn more details of how to work with child processes' <code>stdin</code> and <code>stdout</code> later in this chapter.</p>
			<p>We'll now look at how to terminate a process.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor140"/>Terminating processes</h2>
			<p>We've seen how to spawn <a id="_idIndexMarker603"/>new processes. What about terminating them? For this, the Rust standard library provides two methods—<code>abort()</code> and <code>exit()</code>.</p>
			<p>The usage of the <code>abort()</code> method is shown in the following snippet:</p>
			<pre>use std::process;
fn main() {
    println!("Going to abort process");
    process::abort();
    // This statement will not get executed
    println!("Process aborted");
}</pre>
			<p>This code aborts the current process, and the last statement will not get printed.</p>
			<p>There is another <code>exit()</code> method similar to <code>abort()</code>, but it allows us to specify an exit code that is available to the calling process. </p>
			<p>What is the benefit of processes returning error codes? A child process can fail due to various errors. When the program fails and the child process exits, it would be useful to the calling program or user to know the error code denoting the reason for failure. <strong class="bold">0</strong> indicates a successful exit. Other error codes indicate various conditions such as <em class="italic">data error</em>, <em class="italic">system file error</em>, <em class="italic">I/O error</em>, and so on. The error codes are platform-specific, but most Unix-like platforms use 8-bit error codes, allowing for error values between 0 and 255. Examples of error codes for Unix BSD can be found at <a href="https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html</a>.</p>
			<p>The following is an <a id="_idIndexMarker604"/>example showing the returning of error codes from a process with the <code>exit()</code> method:</p>
			<pre>use std::process;
fn main() {
    println!("Going to exit process with error code 64"); 
    process::exit(64);
    // execution never gets here
    println!("Process exited");
}</pre>
			<p>Run this program on the command line in your terminal. To know the exit code of the last executed process on Unix-like systems, you can type<code> $?</code> on the command line. Note that this command may vary depending on the platform.</p>
			<p class="callout-heading">abort() versus exit()</p>
			<p class="callout">Note that both <code>abort()</code> and <code>exit()</code> do not clean up and call any destructors, so if you want to shut down a process in a clean manner, these methods should be called only after all the destructors have been run. However, the operating system will ensure that on termination of a process, all the resources associated with it, such as memory and file descriptors, are automatically made available for re-allocation to other processes.</p>
			<p>In this section, we've <a id="_idIndexMarker605"/>seen how to spawn and terminate processes. Let's next take a look at how to check the status of execution of a child process after it has been spawned. </p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor141"/>Checking the status of a child process' execution</h2>
			<p>As seen earlier, when <a id="_idIndexMarker606"/>we start a new process, we also specify the program or command to be executed within the process. Frequently, we also care about whether this program or command has been executed successfully or not, in order to take suitable actions. </p>
			<p>The Rust standard library provides a <code>status()</code> method to let us find out whether a process completed executing successfully. Some example usage is shown in the following snippet:</p>
			<pre>use std::process::Command;
fn main() {
    let status = Command::new("cat")
        .arg("non-existent-file.txt")
        .status()
        .expect("failed to execute cat");
 
    if status.success() {
        println!("Successful operation");
    } else {
        println!("Unsuccessful operation");
    }
}</pre>
			<p>Run this program and you will see the message <strong class="bold">Unsuccessful operation</strong> printed out to your terminal. Re-run the program with a valid filename and you will see the success message printed.</p>
			<p>This concludes this section. You learned different ways to run commands in a separate child process, how to <a id="_idIndexMarker607"/>terminate them, and how to get the status of their execution.</p>
			<p>In the next section, we'll look at how to set environment variables and work with I/O for child processes.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor142"/>Handling I/O and environment variables</h1>
			<p>In this section, we'll <a id="_idIndexMarker608"/>look at how to handle I/O with child processes, and also learn to set and clear environment variables for the child process. </p>
			<p>Why would <a id="_idIndexMarker609"/>we need this? </p>
			<p>Take the example of a load balancer that is tasked with spawning new workers (Unix processes) in response to incoming requests. Let's assume the new worker process reads configuration parameters from environment variables to perform its tasks. The load balancer process then would need to spawn the worker process and also set its environment variables. Likewise, there may be another situation where the parent process  wants to read a child process's standard output or standard error and route it to a log file. Let's understand how to perform such activities in Rust. We'll start with handling the I/O of the child process.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor143"/>Handling the I/O of child processes</h2>
			<p>Standard input (<code>stdin</code>), standard <a id="_idIndexMarker610"/>output (<code>stdout</code>), and standard error (<code>stderr</code>) are abstractions that allow a process to interact with the surrounding environment.</p>
			<p>For example, when many user processes are running at the same time, and when a user types keystrokes on a terminal, the kernel delivers the keystrokes to the standard input of the right process. Likewise, a Rust program (running as a process in a shell) can print out characters to its standard output, which is in turn read by the shell program and delivered to the terminal screen for the user. Let's learn how to work with standard input and standard output using the Rust standard library.</p>
			<p>The <code>piped()</code> method on <code>std::process::Stdio</code> allows the child process to communicate with its parent process using a <code>pipe</code> (which is an IPC mechanism in Unix-like systems).</p>
			<p>We'll first look at how to communicate with the standard output handle of the child process from the <a id="_idIndexMarker611"/>parent process:</p>
			<pre>use std::io::prelude::*;
use std::process::{Command, Stdio};
 
fn main() {
    // Spawn the `ps` command
    let process = match Command::new("ps").
    stdout(Stdio::piped()).spawn() {
        Err(err) =&gt; panic!("couldn't spawn ps: {}", err),
        Ok(process) =&gt; process,
    };
    let mut ps_output = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut     
    ps_output) {
        Err(err) =&gt; panic!("couldn't read ps stdout: {}", 
            err),
        Ok(_) =&gt; print!("ps output from child process 
            is:\n{}", ps_output),
    }
}</pre>
			<p>In the preceding code snippet, we first create a new child process to run the <code>ps</code> command to show a list of currently running processes. The output is, by default, sent to the child process's <code>stdout</code>. </p>
			<p>In order to get access to the child process's <code>stdout</code> from the parent process, we create a Unix pipe using the <code>stdio::piped()</code> method. The <code>process</code> variable is the handle to the child process, and <code>process.stdout</code> is the handle to the child process's standard output. The parent process can read from this handle, and print out its contents to its own <code>stdout</code> (that is, the parent process's <code>stdout</code>). This is how a parent process can read the output of a child process.</p>
			<p>Let's now write some <a id="_idIndexMarker612"/>code to send some bytes from the parent process to the standard input of the child process:</p>
			<pre>    let process = match Command::new("rev")
        .stdin(Stdio::piped())               &lt;1&gt;
        .stdout(Stdio::piped())              &lt;2&gt;
        .spawn()
    {
        Err(err) =&gt; panic!("couldn't spawn rev: {}", err),
        Ok(process) =&gt; process,
    };
    match process.stdin.unwrap().write_all
        ("palindrome".as_bytes()) {
        Err(why) =&gt; panic!("couldn't write to stdin: {}", 
            why),
        Ok(_) =&gt; println!("sent text to rev command"),
    }                                      &lt;3&gt;
    let mut child_output = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut 
        child_output) {
        Err(err) =&gt; panic!("couldn't read stdout: {}", err),
        Ok(_) =&gt; print!("Output from child process is:\n{}", 
            child_output),
    }                                             &lt;4&gt;</pre>
			<p>The descriptions of the numbered annotations in the preceding code are provided here:</p>
			<ol>
				<li value="1">Register a piped connection between the <em class="italic">parent process</em> and <em class="italic">standard input</em> of the child process.</li>
				<li>Register a piped connection between the <em class="italic">parent process</em> and <em class="italic">standard output</em> of the child process.</li>
				<li>Write bytes to the <em class="italic">standard input</em> of the child process.</li>
				<li>Read from the <em class="italic">standard output</em> of the child process and print it to the terminal screen.</li>
			</ol>
			<p>There are a few other methods available on the child process. The <code>id()</code> method provides the <em class="italic">process id</em> of the <a id="_idIndexMarker613"/>child process, the <code>kill()</code> method kills the child process, the <code>stderr</code> method gives a handle to the child process's <em class="italic">standard error</em>, and the <code>wait()</code> method makes the parent process to wait until the child process has completely exited.</p>
			<p>We've seen how to handle I/O for child processes. Let's now learn how to work with environment variables.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor144"/>Setting the environment for the child process</h2>
			<p>Let's look at how to <a id="_idIndexMarker614"/>set environment variables for the child process. The following example shows how to set the path environment variable for a child process:</p>
			<pre>use std::process::Command;
fn main() {
    Command::new("env")
        .env("MY_PATH", "/tmp")
        .spawn()
        .expect("Command failed to execute");
}</pre>
			<p>The <code>env()</code> method on <code>std::process::Command</code> allows the parent process to set the environment variable for the child process being spawned. Run the program and test it with the following command:</p>
			<pre>cargo run | grep MY_PATH</pre>
			<p>You'll see the value of the <code>MY_PATH</code> environment variable that was set in the program.</p>
			<p>To set multiple environment variables, the <code>envs()</code> command can be used.</p>
			<p>The environment variables for a child <a id="_idIndexMarker615"/>process can be cleared by using the <code>env_clear()</code> method, as shown:</p>
			<pre>    Command::new("env")
        .env_clear()
        .spawn()
        .expect("Command failed to execute");</pre>
			<p>Run the program with <code>cargo run</code> , and you will see that <em class="italic">nothing</em> is printed out for the <code>env</code> command. Re-run the program by commenting out the <code>.env_clear()</code> statement, and you will find the <code>env</code> values printed to terminal.</p>
			<p>To remove a specific environment variable, the <code>env_remove()</code> method can be used.</p>
			<p>With this, we conclude this section. We've seen how to interact with standard input and standard output of a child process and to set/reset the environment variables. In the next section, we'll learn how to handle errors and signals in child processes.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor145"/>Handling panic, errors, and signals</h1>
			<p>Processes can <a id="_idIndexMarker616"/>fail due to various error conditions. These <a id="_idIndexMarker617"/>have to be handled in a controlled manner. There <a id="_idIndexMarker618"/>may also be situations where <a id="_idIndexMarker619"/>we want to terminate a <a id="_idIndexMarker620"/>process in response to external inputs, such <a id="_idIndexMarker621"/>as a user pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>. How we can handle such situations is the focus of this section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In cases when processes exit due to errors, the operating system itself performs some cleanup, such as releasing memory, closing network connections, and releasing any file handles associated with the process. But sometimes, you may want program-driven controls to handle these cases.</p>
			<p>Failures in process execution can broadly be classified into two types – <em class="italic">unrecoverable errors</em> and <em class="italic">recoverable errors</em>. When a process encounters an unrecoverable error, there is sometimes no option but to abort the process. Let's see how to do that.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor146"/>Aborting the current process</h2>
			<p>We saw how to <a id="_idIndexMarker622"/>terminate and exit from a process in the <em class="italic">Spawning processes with Rust</em> section. The <code>abort()</code> and <code>exit()</code> methods on <code>process::Command</code> can be used for this purpose.</p>
			<p>In some cases, we consciously allow a program to fail under some conditions without handling it, mainly in cases of unrecoverable errors. The <code>std::panic</code> macro allows us to panic the current thread. What this means is that the program terminates immediately and provides feedback to the caller. But unlike the <code>exit()</code> or <code>abort()</code> methods, it unwinds the stack of the current thread and calls all destructors. Here is an example of the usage of the <code>panic!</code> macro:</p>
			<pre>use std::process::{Command, Stdio};
fn main() {
    let _child_process = match Command::new("invalid-command")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
    {
        Err(err) =&gt; panic!("Unable to spawn child process: 
            {}", err),
        Ok(new_process_handle) =&gt; {
            println!("Successfully spawned child process");
            new_process_handle
        }
    };
} </pre>
			<p>Run the program with <code>cargo run</code> and you will see the error message printed out from the <code>panic!</code> macro. There is <a id="_idIndexMarker623"/>also a custom hook that can be registered that will get invoked before the standard cleanup is performed by the <code>panic</code> macro. Here is the same example, this time with a custom <code>panic</code> hook:</p>
			<pre>use std::panic;
use std::process::{Stdio,Command};
fn main() {
<strong class="bold">panic::set_hook</strong>(Box::new(|_| {
            println!(" This is an example of custom panic 
                hook, which is invoked on thread panic, but 
                before the panic run-time is invoked")
        }));       
    let _child_process = match Command::new("invalid-command")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
    {
        Err(err) =&gt; panic!("Normal panic message {}", err),
        Ok(new_process_handle) =&gt; new_process_handle,
    };
}</pre>
			<p>On running this program, you will see the custom error hook message displayed, as we are providing an invalid command to spawn as a child process.</p>
			<p>Note that <code>panic!</code> should be used only for non-recoverable errors. For example, if a child process tries to open a file that does not exist, this can be handled using a recoverable error mechanism such as the <code>Result enum</code>. The advantage of using <code>Result</code> is that the program <a id="_idIndexMarker624"/>can return to its original state and the failed operation can be retried. If <code>panic!</code> is used, the program terminates abruptly, and the original state of the program cannot be recovered. But there are situations where <code>panic!</code> may be appropriate such, as when a process runs out of memory in the system.</p>
			<p>Let's next look at another aspect of process control—signal handling.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor147"/>Signal handling</h2>
			<p>In Unix-like <a id="_idIndexMarker625"/>systems, the operating system can send signals to processes. Note that Windows OS does not <a id="_idIndexMarker626"/>have signals. The process can handle the signal in a way it deems fit, or even ignore the signal. There are operating-system defaults for handling various signals. For example, when you issue a kill command on a process from a shell, the <code>SIGTERM</code> signal is generated. The program terminates on receipt of this signal by default, and there is no special additional code that needs to be written in Rust to handle that signal. Similarly, a <code>SIGINT</code> signal is received when a user presses <em class="italic">Ctrl</em> + <em class="italic">C</em>. But a Rust program can choose to handle these signals in its own way.</p>
			<p>However, handling Unix signals correctly is hard for various reasons. For example, a signal can occur at any time and the thread processing cannot continue until the signal handler completes execution. Also, signals can occur on any thread and synchronization is needed. For this reason, it is better to use third-party crates in Rust for signal handling. Note that even while using external crates, caution should be exercised as the crates do not solve all problems associated with signal handling.</p>
			<p>Let's now see an example of handling signals using the <code>signal-hook</code> crate. Add it to dependencies in <code>Cargo.toml</code> as shown:</p>
			<pre>[dependencies]
signal-hook = "0.1.16"</pre>
			<p>An example code <a id="_idIndexMarker627"/>snippet is shown as <a id="_idIndexMarker628"/>follows:</p>
			<pre>use signal_hook::iterator::Signals;
use std::io::Error;
fn main() -&gt; Result&lt;(), Error&gt; {
    let signals = Signals::new(&amp;[signal_hook::SIGTERM, 
        signal_hook::SIGINT])?;
    'signal_loop: loop {
        // Pick up signals that arrived since last time
        for signal in signals.pending() {
            match signal {
                signal_hook::SIGINT =&gt; {
                    println!("Received signal SIGINT");
                }
                signal_hook::SIGTERM =&gt; {
                    println!("Received signal SIGTERM");
                    break 'signal_loop;
                }
                _ =&gt; unreachable!(),
            }
        }
    }
    println!("Terminating program");
    Ok(())
}</pre>
			<p>In the preceding code, we listen for two specific signals, <code>SIGTERM</code> and <code>SIGINT,</code> within the <code>match</code> clause. <code>SIGINT</code> can be sent to the program by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>. The <code>SIGTERM</code>  signal can be generated by using the <code>kill</code> command on a <em class="italic">process id</em> from the shell.</p>
			<p>Now, run the program and simulate the two signals. Then, press the <em class="italic">Ctrl</em> + <em class="italic">C</em> key combination, which generates the <code>SIGINT</code> signal. You will see that instead of the default behavior (which is to <a id="_idIndexMarker629"/>terminate the program), a statement is <a id="_idIndexMarker630"/>printed out to the terminal.</p>
			<p>To simulate SIGTERM, run a <code>ps</code> command on the command line of a Unix shell and retrieve the <em class="italic">process id</em>. Then run a <code>kill</code> command with the <em class="italic">process id</em>. You will see that the process terminates, and a statement is printed to the terminal.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are using <strong class="bold">tokio</strong> for asynchronous code, you can <a id="_idIndexMarker631"/>use the <strong class="bold">tokio-support</strong> feature of signal-hook.</p>
			<p>It is important to remember that signal handling is a complex topic, and even with external crates, care must be exercised while writing custom signal-handling code.</p>
			<p>While handling signals or dealing with errors, it is also good practice to log the signal or error using a crate such as <code>log</code> for future reference and troubleshooting by system administrators. However, if you'd like a program to read these logs, you can log these messages in JSON format instead of plaintext by using an external crate such as <code>serde_json</code>.</p>
			<p>This concludes this subsection on working with <em class="italic">panic</em>, <em class="italic">errors</em>, and <em class="italic">signals</em> in Rust. Let's now write a shell program that demonstrates some of the concepts discussed.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor148"/>Writing a shell program in Rust (project)</h1>
			<p>We learned in the <em class="italic">Delving into Linux process fundamentals</em> section what a shell program is. In this <a id="_idIndexMarker632"/>section, let's build a shell program, adding <a id="_idIndexMarker633"/>features iteratively. </p>
			<p>In the first iteration, we'll write the basic code to read a shell command from the command line and spawn a child process to execute the command. Next, we'll add the ability to pass command arguments to the child process. Lastly, we will personalize the shell by adding support for users to enter commands in a more natural-language-like syntax. We'll also introduce error handling in this last iteration. Let's get started:</p>
			<ol>
				<li value="1">Let's first create a new project:<pre><strong class="bold">cargo new myshell &amp;&amp; cd myshell</strong></pre></li>
				<li>Create three files: <code>src/iter1.rs</code>, <code>src/iter2.rs</code>, and <code>src/iter3.rs</code>. The code for the three iterations will be placed in these files so that it will be easy to build and test each iteration separately.</li>
				<li>Add the following to <code>Cargo.toml</code>:<pre>[[bin]]
name = "iter1"
path = "src/iter1.rs"
[[bin]]
name = "iter2"
path = "src/iter2.rs"
[[bin]]
name = "iter3"
path = "src/iter3.rs"</pre><p>In the preceding code, we specify to the Cargo tool that we want to build separate binaries for the three iterations.</p></li>
			</ol>
			<p>We're now ready to start with the first iteration of the shell program.</p>
			<h3>Iteration 1 – Spawning a child process to execute commands</h3>
			<p>First, let's write a program to <a id="_idIndexMarker634"/>accept commands from the terminal, and then spawn a new child process to execute those user commands. Add a loop construct to continue accepting user commands in a loop until the process is terminated. The code is as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/iter1.rs</p>
			<pre>use std::io::Write;
use std::io::{stdin, stdout};
use std::process::Command;
fn main() {
    loop {
        print!("$ ");                               &lt;1&gt;
        stdout().flush().unwrap();                  &lt;2&gt;
        let mut user_input = String::new();         &lt;3&gt;
        stdin()
            .read_line(&amp;mut user_input)             &lt;4&gt;
            .expect("Unable to read user input");	
        let command_to_execute = user_input.trim(); &lt;5&gt;
        let mut child = Command::new(command_to_execute) &lt;6&gt;
            .spawn()
            .expect("Unable to execute command");
        child.wait().unwrap();                       &lt;7&gt;
    }
}</pre>
			<p>The numbered annotations in the preceding code are described as follows:</p>
			<ol>
				<li value="1">Display the <code>$</code> prompt to nudge the user to enter commands.</li>
				<li>Flush the <code>stdout</code> handle so that the <code>$</code> prompt is immediately displayed on the terminal.</li>
				<li>Create a buffer to hold the command entered by the user.</li>
				<li>Read the user <a id="_idIndexMarker635"/>commands one line at a time.</li>
				<li>Remove the newline character from the buffer (this is added when the user presses the <em class="italic">Enter</em> key to submit the command).</li>
				<li>Create a new child process and pass the user commands to the child process for execution.</li>
				<li>Wait until the child process completes execution before accepting additional user inputs.</li>
				<li>Run the program with the following command:</li>
			</ol>
			<pre>cargo run –-bin iter1 </pre>
			<p>Type any command without arguments such as <code>ls</code> or <code>ps</code> or <code>du</code> on the <code>$</code> prompt. You'll see the output of the command execution displayed on the terminal. You can continue to enter more such commands at the next <code>$</code> prompt. Press <em class="italic">Ctrl</em> + <em class="italic">C</em> to exit the program.</p>
			<p>We now have the first version of our shell program working, but this program will fail if parameters or flags are entered after the command. For example, typing a command such as <code>ls</code> works, but typing <code>ls –lah</code> will cause the program to panic and exit. Let's add support for command arguments in the next iteration of our code.</p>
			<h3>Iteration 2 – Adding support for command arguments</h3>
			<p>Let's add support for <a id="_idIndexMarker636"/>command arguments with the <code>args()</code> method:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/iter2.rs</p>
			<pre>// Module imports not shown here
fn main() {
    loop {
        print!("$ ");
        stdout().flush().unwrap();
        let mut user_input = String::new();
        stdin()
            .read_line(&amp;mut user_input)
            .expect("Unable to read user input");
        let command_to_execute = user_input.trim();
        let command_args: Vec&lt;&amp;str&gt; =      
            command_to_execute.split_whitespace().
            collect(); <strong class="bold">&lt;1&gt;</strong>
 
        let mut child = Command::new(command_args[0])            
                                                       <strong class="bold">&lt;2&gt;</strong>
            .args(&amp;command_args[1..])   <strong class="bold">&lt;3&gt;</strong>
            .spawn()
            .expect("Unable to execute command");
        child.wait().unwrap();
    }
}</pre>
			<p>The code shown is essentially the same as the previous snippet, except for the three additional lines added, which are annotated with numbers. The annotations are described as follows:</p>
			<ol>
				<li value="1">Take the user input, split it by whitespace, and store the result in <code>Vec</code>.</li>
				<li>The first element of the <code>Vec</code> corresponds to the command. Create a child process to execute this command.</li>
				<li>Pass the list of <code>Vec</code> elements, starting from the second element, as a list of arguments to the child process.</li>
				<li>Run the program <a id="_idIndexMarker637"/>with the following line:<pre><strong class="bold">cargo run -–bin iter2 </strong></pre></li>
				<li>Enter a command and pass arguments to it before hitting the <em class="italic">Enter</em> key. For example, you can type one of the following commands: <pre><strong class="bold">ls –lah</strong>
<strong class="bold">ps -ef</strong>
<strong class="bold">cat a.txt </strong></pre></li>
			</ol>
			<p>Note that in the last command, <code>a.txt</code> is an existing file holding some contents and located in the project root folder.</p>
			<p>You will see the command outputs successfully displayed on the terminal. The shell works so far as we intended. Let's extend it now a little further in the next iteration.</p>
			<h3>Iteration 3 – Supporting natural-language commands</h3>
			<p>Since this is our own shell, let's implement a user-friendly alias for a shell command in this iteration (<em class="italic">why not?</em>). Instead of <a id="_idIndexMarker638"/>typing <code>ls</code>, what if a user could type a command in natural language, as follows:</p>
			<pre>show files</pre>
			<p>This is what we'll code next. The following snippet shows the code. Let's look at the module imports first:</p>
			<pre>use std::io::Write;
use std::io::{stdin, stdout};
use std::io::{Error, ErrorKind};
use std::process::Command;</pre>
			<p>Modules from <code>std::io</code> are imported for writing to the terminal, reading from the terminal, and for error handling. We already know the purpose of importing the <code>process</code> module.</p>
			<p>Let's now look at the <code>main()</code> program in parts. We won't cover the code already seen in previous iterations. The complete code for the <code>main()</code> function can be found in the GitHub repo in the <code>src/iter3.rs</code> file:</p>
			<ol>
				<li value="1">After displaying the <code>$</code> prompt, check whether the user has entered any command. If the user presses just the <em class="italic">Enter</em> key at the prompt, ignore and redisplay the <code>$</code> prompt. The following code checks whether at least one command has been entered by the user, then processes the user input:<pre>if command_args.len() &gt; 0 {..}</pre></li>
				<li>If the command entered is <code>show files</code>, execute the <code>ls</code> command in a child process. If the command is <code>show process</code>, execute the <code>ps</code> command. If <code>show</code> is entered without a parameter, or if the <code>show</code> command is followed by an invalid word, throw an error:<pre>            let child = match command_args[0] {
                "show" if command_args.len() &gt; 1 =&gt; match 
                    command_args[1] {
                    "files" =&gt; Command::new("ls").
                        args(&amp;command_args[2..]).spawn(),
 
                    "process" =&gt; Command::new("ps").args
                        (&amp;command_args[2..]).spawn(),
 
                    _ =&gt; Err(Error::new(
                        ErrorKind::InvalidInput,
                        "please enter valid command",
                    )),
                },
                "show" if command_args.len() == 1 =&gt; 
                    Err(Error::new(
                    ErrorKind::InvalidInput,
                    "please enter valid command",
                )),
                "quit" =&gt; std::process::exit(0),
                _ =&gt; Command::new(command_args[0])
                    .args(&amp;command_args[1..])
                    .spawn(),
            };</pre></li>
				<li>Wait for the <a id="_idIndexMarker639"/>child process to complete. If the child process fails to execute successfully, or if the user input is invalid, throw an error:<pre>            match child {
                Ok(mut child) =&gt; {
                    if child.wait().unwrap().success() {
                    } else {
                        println!("\n{}", "Child process 
                            failed")
                    }
                }
                Err(e) =&gt; match e.kind() {
                    ErrorKind::InvalidInput =&gt; eprintln!(                        
                        "Sorry, show command only 
                        supports following options: files 
                        , process "
                    ),
                    _ =&gt; eprintln!("Please enter a 
                        valid command"),
                },
            }</pre></li>
				<li>Run the program with <code>cargo run –-bin iter3</code> and try the following commands at the <code>$</code> prompt to test:<pre>show files
show process 
du</pre></li>
			</ol>
			<p>You'll see the commands successfully execute, with a statement printed out indicating success.</p>
			<p>You would have noticed that we've added some error handling in the code. Let's look at what error conditions we've addressed:</p>
			<ul>
				<li>If the user presses <em class="italic">Enter</em> without entering a command</li>
				<li>If the user enters the <code>show</code> command without a parameter (either a file or process)</li>
				<li>If the user enters the <code>show</code> command with an invalid parameter</li>
				<li>If the user enters a valid Unix command, but one that is not supported by our program (for example, <code>pipes</code> or <code>redirection</code>)</li>
			</ul>
			<p>Let's try the following invalid inputs:</p>
			<pre>show memory
show
invalid-command</pre>
			<p>You'll see that an <a id="_idIndexMarker640"/>error message is printed to the terminal.</p>
			<p>Try also hitting the <em class="italic">Enter</em> key without command. You will see that this is not processed.</p>
			<p>In error-handling code, note use of <code>ErrorKind</code> <code>enum</code>, which is a set of pre-defined error types defined in the Rust standard library. The list of predefined error types can be found at <a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html">https://doc.rust-lang.org/std/io/enum.ErrorKind.html</a>.</p>
			<p>Congratulations! You have implemented a basic shell program that can recognize natural-language commands for non-technical users. You've also implemented some error handling so that the program is reasonably robust and doesn't crash on invalid inputs.</p>
			<p>As an exercise, you can do the following to enhance this shell program:</p>
			<ul>
				<li>Add support for pipe-operator-separated command chains such as <code>ps | grep sys</code>.</li>
				<li>Add support for redirections such as the <strong class="bold">&gt;</strong> operator to divert the output of a process execution to a file.</li>
				<li>Move the logic of <a id="_idIndexMarker641"/>command-line parsing into a separate tokenizer module.</li>
			</ul>
			<p>In this section, we've written a shell program that has a subset of the features of a real-world shell program such as <code>zsh</code> or <code>bash</code>. To be clear, a real-world shell program has a lot more complex features, but we have covered the fundamental concepts behind creating a shell program here. Also importantly, we've learned how to handle errors in case of invalid user inputs or if a child process fails. To internalize your learning, it is recommended to write some code for the suggested exercises.</p>
			<p>This concludes the section on writing a shell program in Rust.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor149"/>Summary</h1>
			<p>In this chapter, we reviewed the basics of processes in Unix-like operating systems. We learned how to spawn a child process, interact with its standard input and standard output, and execute a command with its arguments. We also saw how to set and clear environment variables. We looked at the various ways to terminate a process on error conditions, and how to detect and handle external signals. We finally wrote a shell program in Rust that can execute the standard Unix commands, but also accept a couple of commands in a natural-language format. We also handled a set of errors to make the program more robust.</p>
			<p>Continuing on the topic of managing system resources, in the next chapter, we will learn how to manage threads of a process and build concurrent systems programs in Rust.</p>
		</div>
	</body></html>