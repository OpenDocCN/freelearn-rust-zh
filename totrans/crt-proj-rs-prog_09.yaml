- en: Creating a Computer Emulator Using Nom
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nom创建计算机模拟器
- en: In the last chapter, we saw how to parse text files—in particular, how to program
    source files in a simple programming language. Text files aren't the only thing
    you could need to parse—several kinds of system software need to parse binary
    files (such as binary executables, multimedia files, and inter-process communication
    messages).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们看到了如何解析文本文件——特别是如何用简单的编程语言编写源文件。文本文件并不是你需要解析的唯一东西——几种类型的系统软件需要解析二进制文件（如二进制可执行文件、多媒体文件和进程间通信消息）。
- en: In this chapter, we will look at how to cope with the need for parsing binary
    files and how the `nom` library can be used to ease this task. First, we will
    look at how to parse and interpret a very simple machine language without using
    an external library, and then how the `nom` library can be used to ease this task.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何应对解析二进制文件的需求以及如何使用`nom`库来简化这项任务。首先，我们将探讨如何在不使用外部库的情况下解析和解释一个非常简单的机器语言，然后我们将探讨如何使用`nom`库来简化这项任务。
- en: 'To do this, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将涵盖以下主题：
- en: Introducing a very simple machine language using only 16-bit words
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一种仅使用16位字的最简单机器语言
- en: Writing a couple of programs in this language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用这种语言编写几个程序
- en: Writing a parser and an interpreter for this language and running it on the
    previously presented programs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为这种语言编写解析器和解释器，并在之前展示的程序上运行它
- en: Defining a byte-addressing machine language derived from the previous one
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个从之前版本派生出的字节寻址机器语言
- en: Explaining the addressing issue (endianness) that emerges when a byte-addressing
    machine language must handle words containing several bytes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释当字节寻址的机器语言必须处理包含多个字节的单词时出现的寻址问题（字节序）
- en: Presenting a version in the new machine language of the previously presented
    machine language program
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以新机器语言的形式展示之前展示的机器语言程序版本
- en: Writing a parser and an interpreter for this language using the `nom` library
    and running it on the machine language program
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nom`库为这种语言编写解析器和解释器，并在机器语言程序上运行它
- en: Writing a translator for the C language that converts the machine language program
    into an equivalent C language program
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个C语言翻译器，将机器语言程序转换为等效的C语言程序
- en: Writing a couple of disassemblers—programs that convert machine language programs
    into assembly language—and applying them to our machine language program
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写几个反汇编器——将机器语言程序转换为汇编语言的程序，并将它们应用于我们的机器语言程序
- en: By the end of this chapter, you will have learned the main concepts of CPU architectures,
    interpretation, and translating machine language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会CPU架构、解释和翻译机器语言的主要概念。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the parts of this chapter referring to the `nom` library, knowledge of the
    preceding chapter is required.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中涉及`nom`库的部分，需要了解前一章的内容。
- en: The complete source code for this chapter is found in the `Chapter09` folder of
    the repository at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码位于[https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers)存储库的`Chapter09`文件夹中。
- en: Project overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, first, the general concepts regarding machine languages will
    be presented. Then, a very simple machine language will be presented. Of course,
    this will be quite unrealistic to use as no real hardware exists to run it. It
    will simply be used to demonstrate how to process it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，首先将介绍有关机器语言的一般概念。然后，将介绍一个非常简单的机器语言。当然，这在使用上相当不切实际，因为没有真实的硬件来运行它。它将仅用于演示如何处理它。
- en: Then, a very simple algorithm will be written in the machine language—a formatter
    of integer numbers. A Rust program to interpret this program will be written without
    using an external library (`word_machine_convert`).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将在机器语言中编写一个非常简单的算法——整数数字的格式化器。将编写一个Rust程序来解释这个程序，而无需使用外部库（`word_machine_convert`）。
- en: Then, a more complex program will be written in this machine language—the famous
    algorithms invented by Eratosthenes to find prime numbers (named the **sieve of
    Eratosthenes**). The previous Rust program will be used to interpret this machine
    language program (`word_machine_sieve`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将用这种机器语言编写一个更复杂的程序——著名的埃拉托斯特尼发明来寻找素数的算法（称为**埃拉托斯特尼筛法**）。之前的Rust程序将用于解释这个机器语言程序（`word_machine_sieve`）。
- en: Afterward, a somewhat more realistic machine language will be defined that is
    capable of addressing single bytes instead of words. The issues raised by this
    machine language will be explained. A new version of the sieve of Eratosthenes will
    be written in this updated machine language and an interpreter will be written
    in Rust to run it. In addition, this Rust program will translate the machine language
    program into C language. This interpreter and compiler will use the `nom` library,
    already introduced in the previous chapter, to generate an intermediate version
    of the program. This intermediate data structure will be both interpreted and
    compiled to the C language (`nom_byte_machine`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将定义一种更接近现实世界的机器语言，它能够处理单个字节而不是字。这种机器语言提出的问题将被解释。将用这种更新的机器语言编写一个新的埃拉托斯特尼筛法版本，并编写一个Rust解释器来运行它。此外，这个Rust程序将把机器语言程序翻译成C语言。这个解释器和编译器将使用在前一章中已介绍过的`nom`库来生成程序的中间版本。这个中间数据结构将被解释和编译成C语言（`nom_byte_machine`）。
- en: Finally, a **disassembler** will be built for this machine language (`nom_disassembler`).
    It will again use the `nom` library and it will show two kinds of disassembling—one
    meant to aid debugging and the other meant to generate source code for an assembler;
    that is, a program that translates symbolic code to machine language.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将为这种机器语言构建一个**反汇编器**（`nom_disassembler`）。它将再次使用`nom`库，并展示两种类型的反汇编——一种旨在帮助调试，另一种旨在为汇编器生成源代码；也就是说，一个将符号代码翻译成机器语言的程序。
- en: Introducing a very simple machine language
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍一个非常简单的机器语言
- en: 'Real machine languages and real computers are way too complex to be covered
    in a single chapter; therefore, we will use a toy machine language that is easier
    to process and understand. In fact, two machine languages will be used:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的机器语言和真实的计算机过于复杂，无法在一个章节中涵盖；因此，我们将使用一种更容易处理和理解的玩具机器语言。实际上，将使用两种机器语言：
- en: The first language that we will use is the simpler one. For simplicity, it addresses 16-bit
    words, instead of memory bytes.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用的第一种语言是更简单的一种。为了简单起见，它处理16位字，而不是内存字节。
- en: The second language presented can address single bytes, as most modern computers
    do.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种语言可以处理单个字节，就像大多数现代计算机一样。
- en: Therefore, any program of the first language that we will use is just a sequence
    of 16-bit words, and any program written in it can only manipulate 16-bit words.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用的第一种语言只是一个16位字的序列，任何用其编写的程序只能操作16位字。
- en: Both machine languages use just one memory segment containing both machine code
    and data. Here, there is no real distinction between code and data; instructions
    can read or write both code and data and data can wrongly be executed as if it
    were instructions. Usually, code, and some data as well (the so-called **constants**),
    is not meant to change, but here, there is no guarantee.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种机器语言都只使用一个包含机器代码和数据的内存段。在这里，代码和数据之间没有真正的区别；指令可以读取或写入代码和数据，数据可能错误地被执行，就像它是指令一样。通常，代码和一些数据（所谓的**常量**）是不打算改变的，但在这里，没有保证。
- en: In most computer architecture, the memory used by any process is composed of
    several portions, named **segments**. The most common memory segments are machine
    code (often named text), static data, heaps, and stacks. Some segments can be
    read-only, while others may be writable. Some segments may have a fixed size and
    others may be resized. Some segments can be shared with other processes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数计算机架构中，任何进程使用的内存由几个部分组成，称为**段**。最常见的内存段是机器代码（通常称为文本）、静态数据、堆栈和堆。一些段可能是只读的，而其他段可能是可写的。一些段可能有固定的大小，而其他段可能可以调整大小。一些段可以与其他进程共享。
- en: 'Let''s look at some reasons why we might need to process machine language software:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为什么我们可能需要处理机器语言软件的一些原因：
- en: Running a binary program for a computer when that computer is not available
    (because it is too costly to buy or because it has not yet been built)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计算机不可用（因为购买成本太高或尚未建造）时运行计算机的二进制程序
- en: Debugging or analyzing a binary program when its source code is not available
    and the computer that must run it is so resource-constrained that no debugger
    can run on it
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有源代码且必须运行的计算机资源受限，以至于无法在其上运行调试器时，调试或分析二进制程序
- en: Disassembling machine code—that is, translating it into assembly code
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆解机器码——即将其翻译成汇编代码
- en: Translating a binary program into another machine language to run it natively in
    a much faster way than by interpreting it
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制程序翻译成另一种机器语言以在更快的速度本地运行，比通过解释它运行要快得多
- en: Translating a binary program into a high-level programming language to change
    it easily and then to recompile it into any machine language
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制程序翻译成高级编程语言以方便修改，然后再将其重新编译成任何机器语言
- en: Writing a program directly in machine code is very error-prone, so no one does
    it. Anyone that needs to write some machine language first writes that code in
    a symbolic language, named **assembly language**, and then translates it into
    machine language. This translation can be done manually or by using a specific
    program, named an **assembler**. Here, we don't have an assembler for our programs,
    so we will translate the assembly code manually. However, before describing our
    machine languages, let's look at some concepts relating to machine language.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 直接用机器码编写程序非常容易出错，所以没有人这样做。任何需要编写一些机器语言的人首先会用一种称为**汇编语言**的符号语言编写代码，然后将其翻译成机器语言。这种翻译可以手动完成或使用一个名为**汇编器**的特定程序完成。在这里，我们没有为我们的程序提供汇编器，所以我们将手动翻译汇编代码。然而，在描述我们的机器语言之前，让我们先看看一些与机器语言相关的概念。
- en: The most important concepts relating to machine language
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与机器语言最相关的最重要的概念
- en: 'In any programming language, you need a way to specify variables and statements.
    In addition, to document your code, you need a way to insert comments into the
    program. The following code is a very simple program in assembly language, containing
    the declaration of some variables, some instructions, and some comments:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，你需要一种方式来指定变量和语句。此外，为了记录代码，你需要一种方式在程序中插入注释。以下是一个非常简单的汇编语言程序，包含一些变量的声明、一些指令和一些注释：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The double backslashes (`//`) begin the comments. The first comment declares
    (for humans) where the `data` section starts. The second comment declares where
    the `code` section starts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 双反斜杠(`//`)开始注释。第一条注释声明（对人类而言）`data`部分开始的位置。第二条注释声明`code`部分开始的位置。
- en: Notice that, apart from comments, some lines are indented and others aren't.
    Actual declarations and instructions must be indented. Lines written in the first
    column are **labels **that mark positions in the program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了注释外，一些行是缩进的，而另一些行则没有。实际的声明和指令必须缩进。第一列的行是**标签**，用于标记程序中的位置。
- en: In the preceding code, there is some data, as shown in the first line. Every
    data item is a word, and so it is declared using the `word` keyword. At position
    `n`, there is a word whose initial value is `17`. At position `m`, there is another
    word whose initial value is `9` and at position `sum`, there is a word whose initial
    value is `0`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有一些数据，如第一行所示。每个数据项都是一个字，因此它使用`word`关键字声明。在位置`n`处有一个初始值为`17`的字。在位置`m`处有一个初始值为`9`的字，在`sum`位置处有一个初始值为`0`的字。
- en: 'Then, there are four instructions, each on a different line. Each instruction
    has two parts:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有四条指令，每条指令都在不同的行上。每条指令有两个部分：
- en: '**Operation Code** (**opcode**): This is a command for the processor.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作码**（**opcode**）：这是给处理器的命令。'
- en: '**Operand**: This is the argument for an opcode command—that is, the data on
    which the command operates.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作数**：这是操作码命令的参数——即命令所操作的数据。'
- en: 'All machine language is designed for specific computer architecture. The computer
    meant to run this program has just two 16-bit CPU registers:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有机器语言都是为特定的计算机架构设计的。运行此程序的计算机只有两个16位CPU寄存器：
- en: One to keep the data word to manipulate, named the **accumulator**
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于保存要操作的数据字，称为**累加器**
- en: One to keep the address of the next instruction to execute, named the **instruction
    pointer** (or **program counter**)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于保存下一个要执行的指令地址，称为**指令指针**（或**程序计数器**）
- en: The first instruction of the program is `load n`. This instruction is equivalent
    to the `accumulator = n;` Rust statement. It copies the current value of the word
    that is at the address labeled with `n` in the accumulator.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一条指令是`load n`。这条指令等同于Rust语句`accumulator = n;`。它将地址为`n`的当前字值复制到累加器中。
- en: The second instruction is `add m`. This is equivalent to the `accumulator +=
    m;` Rust statement. It adds the value of the word that is at the address labeled
    with `m` to the value currently contained in the accumulator and it stores the
    result into the accumulator.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条指令是 `add m`。这相当于 Rust 中的 `accumulator += m;` 语句。它将标签为 `m` 的地址处的字值加到累加器当前包含的值上，并将结果存储到累加器中。
- en: The third instruction is `store sum`. This is equivalent to the `sum = accumulator;` Rust
    statement. It copies the current value of the accumulator into the word that is
    at the address labeled with `sum`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条指令是 `store sum`。这相当于 Rust 中的 `sum = accumulator;` 语句。它将累加器的当前值复制到标签为 `sum`
    的地址处的字。
- en: The last instruction is `terminate 0`. This terminates the execution of the
    program (returning control to the operating system, if there is one) and it returns
    a value of `0` to the process that launched this program (if there is one).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条指令是 `terminate 0`。这终止了程序的执行（如果有的话，返回到操作系统），并返回 `0` 值给启动此程序的进程（如果有的话）。
- en: So, if we follow the effect of the instructions on the data, we find that this
    program starts with the three data words containing `17`, `9`, and `0` and ends
    with them containing `17`, `9`, and `26`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们跟随指令对数据的影响，我们发现这个程序以包含 `17`、`9` 和 `0` 的三个数据字开始，并以它们包含 `17`、`9` 和 `26`
    结束。
- en: However, to run this program, we need to translate it into machine language.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了运行这个程序，我们需要将其翻译成机器语言。
- en: Here, a distinction between the words **program** and **process** is needed.
    A machine language program is the machine code that exists before running it. `t`
    is either stored in a storage device or ROM. Instead, a process is found in the
    RAM area in which the program is loaded and run. This distinction is particularly
    important in multiprocessing systems, where you may have several processes running
    on the same program, but it is also important in systems running one process at
    a time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，需要对 **程序** 和 **进程** 之间的区别进行区分。机器语言程序是在运行之前存在的机器代码。`t` 要么存储在存储设备或 ROM 中。相反，进程是在程序加载并运行的
    RAM 区域中找到的。这种区别在多进程系统中尤为重要，在这种系统中，你可能有多个进程在同一个程序上运行，但在一次只运行一个进程的系统中也很重要。
- en: 'Let''s assume that our machine requires any program to have the following structure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的机器要求任何程序都必须具有以下结构：
- en: '|  Length of the process |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 进程长度 |'
- en: '|  First instruction |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 第一条指令 |'
- en: '|  Second instruction |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 第二条指令 |'
- en: '|  Third instruction |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 第三条指令 |'
- en: '|  ... |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| ... |'
- en: '|  Last instruction |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 最后一条指令 |'
- en: '|  First word of data |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 数据的第一字 |'
- en: '|  Second word of data |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 第二字数据 |'
- en: '|  Third word of data |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 数据的第三字 |'
- en: '|  ... |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| ... |'
- en: This table shows that the first word of the program is meant to be the length
    of the whole process in words. The words after it are meant to be instructions
    in machine language. The words that follow the last instruction of the program
    are meant to be data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表显示程序的第一个字意味着整个进程的字长度。它后面的字意味着机器语言中的指令。程序的最后一条指令后面的字意味着数据。
- en: In the preceding program, we have four instructions, and each of them uses one
    word for the opcode and one for the operand. Therefore, eight words are occupied
    by four instructions. If we add together the initial word containing the length
    of the process and the three words occupied by the three variables (one word per
    variable), we get *1 + 8 + 3 = 12* words. This is the size of the memory space
    used by this program, measured in words. If we set this number as the initial
    word of the program, it means that we need exactly that memory in our process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们有四个指令，每个指令使用一个字作为操作码和一个字作为操作数。因此，四个指令共占用八个字。如果我们把包含进程长度的初始字和三个变量占用的三个字（每个变量一个字）加起来，我们得到
    *1 + 8 + 3 = 12* 个字。这是该程序使用的内存空间的大小，以字为单位。如果我们把这个数字设置为程序的初始字，这意味着我们需要在进程中恰好有那么多内存。
- en: 'If we lay out the instructions and data, we get the following array of words
    for our process:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们布置指令和数据，我们得到以下字数组用于我们的进程：
- en: '| **Position** | **Contents** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **内容** |'
- en: '| `0` | The length of the process |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 进程长度 |'
- en: '| `1` | The opcode of the `load` instruction |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `load` 指令的操作码 |'
- en: '| `2` | The `n` operand |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `n` 操作数 |'
- en: '| `3` | The opcode of the `add` instruction |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `add` 指令的操作码 |'
- en: '| `4` | The `m` operand |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `m` 操作数 |'
- en: '| `5` | The opcode of the `store` instruction |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `store` 指令的操作码 |'
- en: '| `6` | The `sum` operand |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `sum` 操作数 |'
- en: '| `7` | The opcode of the `terminate` instruction |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `7` | `terminate` 指令的操作码 |'
- en: '| `8` | The `0` operand |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `8` | `0` 操作数 |'
- en: '| `9` | Data 17 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `9` | 数据 17 |'
- en: '| `10` | Data 9 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `10` | 数据 9 |'
- en: '| `11` | Data 0 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `11` | 数据 0 |'
- en: The position of any word is its distance from the beginning of the program measured
    in words. Any position is named the **address** of the word, as this number allows
    us to access the word in the process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 任何单词的位置是其从程序开始处的距离，以单词为单位。任何位置都被称为单词的 **地址**，因为这个数字允许我们在过程中访问该单词。
- en: Machine language does not use labels; it only uses addresses. So, to translate
    the assembly code into machine language, we must replace the use of labels with
    memory addresses. The address of the first word is, by definition, `0`. The address
    of the first instruction is `1`. Any instruction is two-words long, and so the
    address of the second instruction is *1 + 2 = 3*. The address after the last instruction—that
    is, the address of the first data word, labeled by `n`—is `9`. The address of
    the second data word, labeled `m`, is `10`. The address of the last data word,
    labeled `sum`, is `11`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 机器语言不使用 **标签**；它只使用 **地址**。因此，为了将汇编代码翻译成机器语言，我们必须用内存地址替换标签的使用。第一个单词的地址，根据定义，是 `0`。第一个指令的地址是
    `1`。任何指令都是两个单词长，因此第二个指令的地址是 *1 + 2 = 3*。最后一个指令之后的地址，即第一个数据单词的地址，标记为 `n`，是 `9`。第二个数据单词的地址，标记为
    `m`，是 `10`。最后一个数据单词的地址，标记为 `sum`，是 `11`。
- en: 'After adding the initial length, moving the instructions before the data, and
    replacing the labels, our program becomes the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加初始长度、将指令移动到数据之前并替换标签之后，我们的程序变成了以下形式：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, we must replace every symbolic code with its corresponding machine language
    opcode, which is a unique number.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将每个符号代码替换为其对应的机器语言操作码，这是一个唯一的数字。
- en: 'Let''s assume the following correspondence between the opcode and symbolic
    instruction code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设操作码和符号指令代码之间的以下对应关系：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `word` keyword does not actually generate instructions. So, our program
    becomes the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`word` 关键字实际上并不生成指令。因此，我们的程序变成了以下形式：'
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Of course, these numbers will be stored as a vector of binary numbers. So,
    in Rust, it will be the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些数字将作为二进制数字的向量存储。所以，在 Rust 中，它将是以下形式：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, we have been able to manually translate an assembly language program into
    a machine language program. However, we used a very small machine language containing
    only four kinds of instructions—that is, only four different opcodes. To carry
    out useful work, some more kinds of instructions are needed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经能够手动将汇编语言程序翻译成机器语言程序。然而，我们使用了一个非常小的机器语言，只包含四种类型的指令——也就是说，只有四种不同的操作码。为了执行有用的工作，需要更多种类的指令。
- en: Extending our machine language
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展我们的机器语言
- en: The machine language that we saw in the preceding section is only capable of making
    additions and it has no input/output capabilities. Such a limited language is
    not very interesting. So, to have a language that can be used to build meaningful
    programs, let's add some kinds of instruction to our machine language.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中看到的机器语言只能进行加法操作，并且没有输入/输出能力。这样的有限语言并不很有趣。因此，为了有一个可以用来构建有意义程序的编程语言，让我们向我们的机器语言添加一些 **种类** 的指令。
- en: 'Our assembly language (and its corresponding machine language) is defined by
    the following table:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的汇编语言（及其对应的机器语言）由以下表格定义：
- en: '| **Opcode** | **Assembly syntax** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **操作码** | **汇编语法** | **描述** |'
- en: '| `0` | `terminate operand` | This terminates the program, returning the operand
    to the caller. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `terminate operand` | 这将终止程序，将操作数返回给调用者。 |'
- en: '| `1` | `set operand` | This copies the operand to the accumulator. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `set operand` | 这会将操作数复制到累加器中。 |'
- en: '| `2` | `load address` | This copies the value at this address to the accumulator.
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `load address` | 这会将此地址的值复制到累加器中。 |'
- en: '| `3` | `store address` | This copies the value of the accumulator to this
    address.  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `store address` | 这会将累加器的值复制到这个地址。  |'
- en: '| `4` | `indirect_load address` | This copies the value whose address is specified
    at this address to the accumulator. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `间接加载地址` | 这会将指定在此地址的地址的值复制到累加器中。 |'
- en: '| `5` | `indirect_store address` | This copies the value of the accumulator
    to the address specified at this address.   |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `间接存储地址` | 这会将累加器的值复制到指定在此地址的地址。   |'
- en: '| `6` | `input length` | This asks the user for console input until the *Enter*
    key is pressed. Then, at most, the `length` characters of the input line are copied
    into consecutive memory words. This sequence of memory words begins at the address
    contained in the accumulator. Each memory word contains exactly one character.
    If the user types less than length characters, the remaining words are set to
    binary zero (`0`). So, in any case, `length` memory words are set by this instruction.
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `输入长度` | 这会要求用户在按下*Enter*键之前从控制台接收输入。然后，最多将输入行的`length`个字符复制到连续的内存字中。这个内存字的序列从累加器中包含的地址开始。每个内存字包含恰好一个字符。如果用户输入的字符少于`length`个，则剩余的字被设置为二进制零（`0`）。因此，无论如何，此指令都会设置`length`个内存字。
    |'
- en: '| `7` | `output length` | This emits to the console the `length` ASCII characters
    whose codes are in consecutive memory words. This sequence of memory words to
    output begins at the address contained in the accumulator. Only 7-bit ASCII characters
    are correctly supported. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `7` | `输出长度` | 将`length`个ASCII字符（其代码在连续的内存字中）输出到控制台。要输出的内存字序列从累加器中包含的地址开始。仅正确支持7位ASCII字符。
    |'
- en: '| `8` | `add address` | This adds the value at this address to the value of
    the accumulator and keeps the result in the accumulator. It uses 16-bit integer
    arithmetic with a wraparound—that is, in the case of integer overflow, the value
    modulo of 65,536 is obtained.  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `8` | `加地址` | 将该地址的值加到累加器的值上，并将结果保留在累加器中。它使用16位整数算术并带有环绕——即在整数溢出的情况下，获得65,536的模值。
    |'
- en: '| `9` | `subtract address` | This subtracts the value at this address from the
    value of the accumulator, using wrap-around arithmetic, and keeps the result in
    the accumulator. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `9` | `减地址` | 使用环绕算术从累加器的值中减去该地址的值，并将结果保留在累加器中。 |'
- en: '| `10` | `multiply address` | This multiplies the value of the accumulator
    by the value at this address, using wrap-around arithmetic, and keeps the result
    in the accumulator. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `10` | `乘地址` | 使用环绕算术将累加器的值乘以该地址的值，并将结果保留在累加器中。 |'
- en: '| `11` | `divide address` | This divides the value of the accumulator by the
    value at this address using integer arithmetic (truncation) and keeps the result
    in the accumulator (quotient). |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `11` | `除地址` | 使用整数算术（截断）将累加器的值除以该地址的值，并将结果（商）保留在累加器中。 |'
- en: '| `12` | `remainder address` | This divides the value of the accumulator by
    the value at this address using integer arithmetic (truncation) and keeps the
    integer remainder in the accumulator.  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `12` | `余数地址` | 这使用整数算术（截断）将累加器的值除以该地址的值，并将整数余数保留在累加器中。 |'
- en: '| `13` | `jump address` | This proceeds to the execution of the instruction
    present at `address`. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `13` | `跳转地址` | 这将继续执行`address`处的指令。 |'
- en: '| `14` | `jump_if_zero address` | This proceeds to the execution of the instruction
    present at `address`, but only if the value of the accumulator is equal to `0`.
    Otherwise, it proceeds to the next instruction. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `14` | `如果累加器为零跳转地址` | 只有当累加器的值等于`0`时，才继续执行`address`处的指令。否则，继续执行下一条指令。 |'
- en: '| `15` | `jump_if_nonzero address` | This proceeds to the execution of the
    instruction present at `address` if the value of the accumulator is not `0`. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `15` | `如果累加器非零跳转地址` | 如果累加器的值不为`0`，则继续执行`address`处的指令。 |'
- en: '| `16` | `jump_if_positive address` | This proceeds to the execution of the
    instruction present at `address` if the value of the accumulator is a positive
    number. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `16` | `如果累加器为正跳转地址` | 如果累加器的值是正数，则继续执行`address`处的指令。 |'
- en: '| `17` | `jump_if_negative address` | This proceeds to the execution of the
    instruction present at `address` if the value of the accumulator is a negative
    number. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `17` | `如果累加器为负跳转地址` | 如果累加器的值是负数，则继续执行`address`处的指令。 |'
- en: '| `18` | `jump_if_nonpositive address` | This proceeds to the execution of
    the instruction present at `address`, but only if the value of the accumulator
    is non-positive—that is, if it is a negative number or it is equal to `0`. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `18` | `如果累加器非正跳转地址` | 只有当累加器的值非正——即它是负数或等于`0`时，才继续执行`address`处的指令。 |'
- en: '| `19` | `jump_if_nonnegative address` | This proceeds to the execution of
    the instruction present at `address` if the value of the accumulator is non-negative—that
    is, if it is a positive number or it is equal to `0`. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `19` | `jump_if_nonnegative address` | 如果累加器的值为非负值——也就是说，如果它是一个正数或者等于 `0`，则执行
    `address` 处的指令。|'
- en: '|  – | `word value` | This reserves a word for data. Its initial content is
    specified by `value`. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  – | `word value` | 这为数据保留一个字。其初始内容由 `value` 指定。|'
- en: '|  –  | `array length` | This reserves an array of `length` words. All these
    words are initialized to `0`. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  –  | `array length` | 这为 `length` 个字保留一个数组。所有这些字都被初始化为 `0`。|'
- en: Notice that the `set` instruction type (opcode `1`) is quite simple; it assigns
    the operand to the accumulator. Almost all the other assignment and arithmetic
    instruction types have one level of indirectness—their operand is the memory address
    of the data that must be operated on. However, the two instructions—`indirect_load`
    (opcode `4`) and `indirect_store` (opcode `5`)—have two levels of indirectness.
    Their operand is the memory address of a word—that is, the memory address of the
    data that must be operated on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `set` 指令类型（操作码 `1`）非常简单；它将操作数赋值给累加器。几乎所有其他赋值和算术指令类型都有一个间接级别——它们的操作数是必须操作的数据的内存地址。然而，有两个指令——`indirect_load`（操作码
    `4`）和 `indirect_store`（操作码 `5`）——有两个间接级别。它们的操作数是一个字的内存地址，即必须操作的数据的内存地址。
- en: Now that we have a powerful enough machine language, we can write a meaningful
    program using it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了足够强大的机器语言，我们可以用它编写一个有意义的程序。
- en: Writing a very simple program
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个非常简单的程序
- en: To show you how to use this language, let's write some code with it. We will
    create a program that, when given a positive integer number in a memory word (in
    binary format), prints it in decimal notation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示如何使用这种语言，让我们用一些代码来写一些程序。我们将创建一个程序，当给定一个存储在内存字中的正整数（二进制格式）时，以十进制表示法打印它。
- en: 'Let''s assume that the number to print is hardcoded as `6710`. When we write
    the algorithm in Rust, it is as shown in the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设要打印的数字硬编码为 `6710`。当我们用 Rust 编写算法时，它如下所示：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, the `n` variable is the unsigned 16-bit number to convert
    and print. The `digits` variable is a buffer that will contain the ASCII values
    of the generated digits. As a 16-bit number can have, at most, five decimal digits,
    an array of five digits is enough. The `pos` variable is the position of the current
    digit in the `digits` array.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`n` 变量是要转换和打印的无符号 16 位数字。`digits` 变量是一个缓冲区，将包含生成的数字的 ASCII 值。由于 16 位数字最多有五个十进制数字，五个数字的数组就足够了。`pos`
    变量是 `digits` 数组中当前数字的位置。
- en: The `number_base` variable is `10` as we are using decimal notation. The `ascii_zero`
    variable contains the ASCII code for the zeroth character (which is `48`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`number_base` 变量是 `10`，因为我们使用十进制表示法。`ascii_zero` 变量包含零字符的 ASCII 码（即 `48`）。'
- en: The first loop computes any ASCII decimal digit by computing the remainder of
    `n` divided by 10 using the `%` operator, and by adding it to `ascii_zero`. Then,
    `n` is divided by the `number_base` variable to remove the least significant decimal
    digit from it. The second loop prints the five generated digits to the console.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环通过使用 `%` 运算符计算 `n` 除以 10 的余数，并将其添加到 `ascii_zero` 来计算任何 ASCII 十进制数字。然后，`n`
    被除以 `number_base` 变量，以从其中移除最低位的十进制数字。第二个循环将生成的五个数字打印到控制台。
- en: The problem with this program is that it needs to use array indexing. Actually, `pos` is
    an index to the `digits` array. Machine language uses addresses, not indices;
    so, to mimic machine language, we must replace the type of `pos` with that of
    raw pointers, whose dereference operation is unsafe in Rust. Instead of counting
    up to five, we set an `end` pointer. When `pos` reaches this pointer, it will
    have finished the array.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的问题在于它需要使用数组索引。实际上，`pos` 是 `digits` 数组的索引。机器语言使用地址，而不是索引；因此，为了模仿机器语言，我们必须将
    `pos` 的类型替换为原始指针的类型，在 Rust 中，原始指针的解引用操作是不安全的。我们不是数到五，而是设置一个 `end` 指针。当 `pos` 达到这个指针时，它将完成数组。
- en: 'So, let''s translate our Rust program into a format that is more similar to
    what can be translated into machine language using raw pointers:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将我们的 Rust 程序翻译成一种更接近使用原始指针转换成机器语言的格式：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding program, the unsafe `offset` method of raw pointers is used.
    When given a raw pointer, it generates another raw pointer by advancing by the
    specified number of positions in memory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，使用了原始指针的不安全`offset`方法。当给定一个原始指针时，它通过在内存中前进指定的位置生成另一个原始指针。
- en: To have a program that is even more similar to a machine language program, we
    should split all the Rust statements into elementary statements that correspond
    to machine instructions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要使程序更类似于机器语言程序，我们应该将所有Rust语句拆分为对应机器指令的基本语句。
- en: However, there is another problem—our accumulator register will sometimes contain
    numbers and other times addresses. Using Rust, this is inconvenient because numbers
    and addresses have different types in Rust. Therefore, here, we will use two variables—`acc` (which
    represents the accumulator when it is used to store a number) and `ptr_acc` (which
    represents the accumulator when it is used to store an address—that is, a memory
    pointer).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个问题——我们的累加器寄存器有时会包含数字，有时会包含地址。在Rust中使用这是不方便的，因为数字和地址在Rust中有不同的类型。因此，在这里，我们将使用两个变量——`acc`（当它用于存储数字时代表累加器）和`ptr_acc`（当它用于存储地址时代表累加器，即内存指针）。
- en: 'Here is the obtained program, which is quite similar to a machine language
    program:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是获得的程序，它与机器语言程序非常相似：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that now, the statements after the empty line, except for the final `for`
    loop, are quite simple. They are only assignments, possibly combined with one
    operation, such as `%=`, `+=`, or `/=`. In addition, there is one `if` statement
    used to break the loop when the `n` variable is `0`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在，除了最后的`for`循环之外，空行之后的语句相当简单。它们只是赋值，可能还结合了一个操作，例如`%=`, `+=`, 或`/=`。此外，还有一个`if`语句用于在`n`变量为`0`时跳出循环。
- en: 'This can be easily translated into our assembly language, as shown:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地翻译成我们的汇编语言，如下所示：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This assembly language program can be manually translated into machine language.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编语言程序可以手动翻译成机器语言。
- en: As there are 5 data words, 1 data array of five words, 16 instructions occupying
    two words each, and the initial word, we have a total of *5 + 1 * 5 + 16 * 2 +
    1 = 43* words. This number will be the value of the first word of our program.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有5个数据字，1个包含5个字的数据数组，16条指令，每条指令占用两个字，以及初始字，我们总共有*5 + 1 * 5 + 16 * 2 + 1 = 43*个字。这个数字将是我们的程序第一个字的值。
- en: 'Then, considering the required layout (the process length, followed by the
    instruction, followed by the data), we can compute the addresses of the jump destinations
    and the addresses of the data, obtaining the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，考虑到所需的布局（过程长度，随后是指令，然后是数据），我们可以计算跳转目标地址和数据地址，得到以下代码：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, notice that the symbolic names of the addresses are commented
    out.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注意地址的符号名称已被注释掉。
- en: 'Then, by replacing the symbolic codes with the opcodes and by removing the
    comments and line addresses, we get the machine language program as a comma-separated
    list of decimal numbers:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过用操作码替换符号代码，并移除注释和行地址，我们得到机器语言程序，作为以逗号分隔的十进制数字列表：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, we start with the following line:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们开始于以下行：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding line becomes the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行变为以下内容：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because the `1:` line address has been removed, the `set` symbolic code has
    been replaced by its opcode (`1`), the `// pos` comment has been removed, and
    two commas have been added to separate the numbers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`1:`行地址已经被移除，所以`set`符号代码被其操作码（`1`）所替换，`// pos`注释被移除，并且添加了两个逗号来分隔数字。
- en: Now, we can build a Rust program that interprets this program. You can find
    it in the `word_machine_convert` project.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建一个Rust程序来解释这个程序。你可以在`word_machine_convert`项目中找到它。
- en: If you execute the `cargo run` command on this project, the program is compiled
    in a short time because it has no dependencies. The execution will simply print `6710` with
    a leading space. The name of this project means to convert a number using a machine
    language that uses word addressing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个项目上执行`cargo run`命令，由于没有依赖项，程序将很快编译。执行将简单地以空格开头打印`6710`。这个项目的名字意味着使用使用字寻址的机器语言来转换数字。
- en: The `main` function of this Rust program just passes the preceding list of numbers
    to the `execute` function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Rust程序的`main`函数只是将前面的数字列表传递给`execute`函数。
- en: 'This function begins with the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数以以下代码开始：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previously mentioned function (`execute`) emulates an extremely simple machine
    language processor that addresses memory as a slice of 16-bit words. This function,
    if it returns, returns the operand of the `terminate` instruction that it may
    execute.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的函数（`execute`）模拟了一个极其简单的机器语言处理器，将内存视为16位字的一个片段。如果这个函数返回，它将返回可能执行的`terminate`指令的操作数。
- en: The `acc` variable represents the accumulator register. The `process` variable
    represents the actual runtime content of memory. Its size, in words, is the number
    specified by the first word of the program. It makes no sense to have a process
    shorter than the program that it runs because some data would be lost.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`acc`变量表示累加器寄存器。`process`变量表示内存的实际运行时内容。其大小，以字为单位，是程序的第一字指定的数字。拥有比运行它的程序更短的过程是没有意义的，因为会丢失一些数据。'
- en: However, it makes sense to have a process larger than the programs that it runs
    because in doing so, it allocates memory that will be used by code with no need
    to declare it in the program. In this way, you can have a program with a few words
    using a memory space of up to 65,536 words, which is 128 **Kibibytes** (**KiB**).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，拥有比运行它的程序更大的过程是有意义的，因为这样做，它分配了将被无声明需求的代码使用的内存。这样，你可以有一个只有几个字的程序，使用高达65,536字的内存空间，这是128 **Kibibytes** (**KiB**)。
- en: The first part of the `process` variable is initialized with the contents of
    `program`, received as an argument of the `execute` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`process`变量的第一部分使用`program`的内容初始化，`program`是`execute`函数的参数。'
- en: The `ip` variable is the instruction pointer, which is initialized to `1`—that
    is, it points to the second word, where there is a first instruction to execute.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip`变量是指令指针，初始化为`1`——也就是说，它指向第二个单词，那里有一个要执行的第一条指令。'
- en: Then, there is the processing loop. Every instruction has exactly one opcode
    and one operand, and so they are loaded into the respective variables. Then, there
    is a debugging statement that is commented out; this can be useful if your program
    does not do what you hoped.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是处理循环。每条指令恰好有一个操作码和一个操作数，因此它们被加载到相应的变量中。然后，有一个被注释掉的调试语句；如果你的程序没有按预期工作，这可能很有用。
- en: After executing any instruction, the instruction that follows it will usually be
    executed, and so the instruction pointer is incremented right away by two words
    to skip the current instruction. The exceptions are the `jump` instructions and `terminate`
    instructions. The `jump` instructions, if their condition is satisfied, will change
    the instruction pointer again and the `terminate` instruction will jump out of
    the processing loop, and out of the `execute` function, too.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 执行任何指令后，通常将执行其后的指令，因此指令指针立即增加两个字以跳过当前指令。例外的是`jump`指令和`terminate`指令。如果`jump`指令的条件得到满足，它将再次更改指令指针，而`terminate`指令将跳出处理循环，甚至跳出`execute`函数。
- en: 'The rest of the function is a large `match` statement, which is needed to process
    the current instruction. Here are its first few lines:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分是一个大的`match`语句，这是处理当前指令所需的。以下是它的前几行：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The behavior of each arm of this kind of a `match` statement is quite simple
    as it is meant to be executed by hardware. For example, if the current instruction
    is `terminate`, the function returns the operand; if it is `set`, the operand
    is assigned to the accumulator; if it is `load`, the memory word whose address
    is the operand is assigned to the accumulator; and so on.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`match`语句的每个分支的行为都非常简单，因为它旨在由硬件执行。例如，如果当前指令是`terminate`，函数返回操作数；如果是`set`，则操作数被分配给累加器；如果是`load`，则将地址为操作数的内存字分配给累加器；等等。
- en: 'Here is a pair of arithmetic instructions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一对算术指令：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In all modern computers, integer numbers are stored in two complementary formats
    and they perform their operations accordingly. This has several advantages:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有现代计算机中，整数数字以两种互补的格式存储，并且它们根据这些格式执行操作。这有几个优点：
- en: A single arithmetic operation can work if the operands are both interpreted
    as signed numbers or unsigned numbers (but not one signed number and the other
    unsigned).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作数都被解释为有符号数或无符号数（但不能是一个有符号数和一个无符号数），则单个算术操作可以工作。
- en: If an addition or subtraction causes an integer to overflow and then another
    operation causes the result to go back into the allowed range, the result is still
    valid.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果加法或减法导致整数溢出，然后另一个操作导致结果回到允许的范围内，结果仍然是有效的。
- en: In high-level languages, such as Rust, arithmetic overflow is usually not allowed
    by default. In Rust, the arithmetic of overflow of basic operators causes panic
    when it shows a message such as `attempt to add with overflow`. To allow two complementary
    arithmetics, the Rust standard library provides the corresponding wrapping method for
    any operator, which is the one usually implemented in machine language. To use
    it, instead of writing `a + b`, you write `a.wrapping_add(b)`; instead of writing `a
    - b`, you write `a.wrapping_sub(b)`, and so on for the other operators.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级语言中，如 Rust，默认情况下通常不允许算术溢出。在 Rust 中，基本运算符的溢出算术会在显示消息“尝试溢出加法”时引发恐慌。为了允许两种互补的算术，Rust
    标准库为任何运算符提供了相应的包装方法，这通常是在机器语言中实现的。要使用它，而不是写 `a + b`，你写 `a.wrapping_add(b)`；而不是写
    `a - b`，你写 `a.wrapping_sub(b)`，以及其他运算符也是如此。
- en: 'The `jump` instructions are a bit different from other instructions, as shown:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`jump` 指令与其他指令略有不同，如下所示：'
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, the `jump_if_nonzero` instruction checks the value of
    the accumulator and sets the instruction pointer to the specified value only if
    this value is not `0`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`jump_if_nonzero` 指令检查累加器的值，并且只有当这个值不是 `0` 时，才将指令指针设置到指定的值。
- en: The `jump_if_positive` instruction checks whether the value of the accumulator
    is positive, interpreting it as a signed number. Without the `as i16` clause,
    the check would always succeed as the `acc` variable is unsigned.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`jump_if_positive` 指令检查累加器的值是否为正，将其解释为有符号数。如果没有 `as i16` 子句，检查将始终成功，因为 `acc`
    变量是无符号的。'
- en: Notice that in Rust, an unsigned number can be converted into a signed one,
    even if the result is negative; for example, the expression `40_000_u16 as i16
    == -25_536_i16` is true.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Rust 中，一个无符号数可以被转换成有符号数，即使结果是负数；例如，表达式 `40_000_u16 as i16 == -25_536_i16`
    是正确的。
- en: The `input` and `output` instructions are unusually complex, and they even interact
    with the operating system. Of course, they are not real-world machine language
    instructions. They were added to this pseudo-machine language just to be able
    to write a complete program with reasonable effort. In practice, in a real-world
    machine language, I/O is performed using a convoluted sequence of instructions
    or by calling an operating system service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`input` 和 `output` 指令非常复杂，它们甚至与操作系统交互。当然，它们不是真实世界的机器语言指令。它们被添加到这种伪机器语言中，只是为了能够以合理的努力编写一个完整的程序。在实践中，在真实世界的机器语言中，输入/输出是通过一系列复杂的指令或通过调用操作系统服务来执行的。'
- en: So, we have seen how to interpret a machine language program. It was quite a
    trivial program, however; so, in the next section, we'll look at a more interesting
    and complex machine language program.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了如何解释机器语言程序。然而，这是一个相当简单的程序；所以，在下一节中，我们将查看一个更有趣且更复杂的机器语言程序。
- en: A more complex program – the sieve of Eratosthenes
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更复杂的程序——埃拉托斯特尼筛法
- en: Now, let's consider a more realistic but challenging problem—implementing an
    algorithm to print all the prime numbers that are less than a number, *N*, where *N* is
    typed in by the user at runtime. This is called the **sieve of Eratosthenes **algorithm.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个更现实但具有挑战性的问题——实现一个算法来打印小于一个数 `N` 的所有素数，其中 `N` 是用户在运行时输入的。这被称为**埃拉托斯特尼筛法**算法。
- en: 'Here is the Rust version of this program:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个程序的 Rust 版本：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, the first 14 lines of the `main` function ask the user
    to type in a number until the typed number is between `2` and `32767`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`main` 函数的前 14 行要求用户输入一个数字，直到输入的数字在 `2` 和 `32767` 之间。
- en: The next group of statements allocates a vector of bytes to store the numbers
    that have been detected as non-primes. Initially, it contains all zeros, meaning
    that every number in the required range could be a prime. Then, all the numbers
    of the range are scanned in increasing order, and for each of them, if it is still
    considered a prime number, all of its multiples are marked as non-primes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一组语句分配一个字节数组来存储被检测为非素数的数字。最初，它包含所有零，这意味着在所需范围内每个数字都可能是一个素数。然后，按顺序扫描范围内的所有数字，对于每个数字，如果它仍然被认为是素数，则将其所有倍数标记为非素数。
- en: The last group of statements again scans all the numbers and prints only those
    that are still marked as prime numbers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的一组语句再次扫描所有数字，并只打印那些仍然标记为素数的数字。
- en: The difficulty of this program is that it needs to allocate memory to be used
    by a vector. Our machine language does not allow memory allocation. We can pre-allocate
    an array with the maximum desired size, say, 400 words.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的难度在于它需要为向量分配内存。我们的机器语言不允许内存分配。我们可以预先分配一个最大所需大小的数组，比如说，400个单词。
- en: To pre-allocate such an array, it is enough to specify that the process size
    is equal to the program size plus 400 words. In doing this, when the process begins
    its execution, it will allocate the required space and it will initialize it to
    be a sequence of zeros.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预先分配这样的数组，只需指定进程大小等于程序大小加400个单词即可。这样做时，当进程开始执行时，它将分配所需的空间，并将其初始化为零的序列。
- en: As you can imagine, the corresponding assembly and machine language program
    is quite complex. It can be found in the `word_machine_sieve` project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，相应的汇编和机器语言程序相当复杂。它可以在`word_machine_sieve`项目中找到。
- en: If you run it and then type in a number that isn't larger than 400, all the
    prime numbers that are smaller than the typed number will be printed to the console.
    The interpreter is identical to the one used in the preceding projects, but there
    is another machine language program in the `main` function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行它并输入一个不超过400的数字，所有小于输入数字的质数将被打印到控制台。解释器与前面项目中使用的解释器相同，但在`main`函数中还有一个机器语言程序。
- en: 'This machine language program is much larger than that of the preceding project,
    and it is explained by comments. The assembly language is equivalent in any instruction
    or data item in a comment. Here is the initial part, containing four instructions:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机器语言程序比前一个项目的要大得多，并且通过注释进行解释。汇编语言在注释中的任何指令或数据项都是等效的。以下是初始部分，包含四个指令：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The process size, `600`, is 400 words, which is larger than the program size
    by 200 words.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 进程大小`600`是400个单词，比程序大小多200个单词。
- en: There are some explanatory comments interleaved, such as those in the second
    and fifth lines.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其中穿插了一些解释性注释，例如第二行和第五行。
- en: The third line is a `set` instruction (opcode 1), with operand `190`. The comment
    explains that this instruction begins at address `1` and corresponds with the `set
    digits` assembly instruction.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行是一个`set`指令（操作码1），操作数为`190`。注释解释说，这个指令从地址`1`开始，与`set digits`汇编指令相对应。
- en: As you can imagine, it is almost impossible to write a machine language program directly without
    passing through its assembly language version, and it is an error-prone choreto
    manually translate an assembly language into machine language. Fortunately, it
    is rather easy to write an assembler program that does this for you. You can do
    this by using the compiling techniques explained in the preceding chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，直接编写机器语言程序而不通过其汇编语言版本几乎是不可能的，手动将汇编语言翻译成机器语言是一项容易出错且繁琐的工作。幸运的是，编写一个为您完成这项工作的汇编器程序相当简单。您可以通过使用前一章中解释的编译技术来完成这项工作。
- en: In the next section, we will look at a more realistic machine language and how
    to use the `nom` parsing library to ease its interpretation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一个更现实的机器语言以及如何使用`nom`解析库来简化其解释。
- en: Defining a byte-addressing machine language
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义字节寻址的机器语言
- en: 'In the preceding section, we saw a different kind of machine language. However,
    this kind of machine language is quite unrealistic for several reasons:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个章节中，我们看到了不同类型的机器语言。然而，这种机器语言由于几个原因而相当不现实：
- en: It addresses memory word by word. This was common in the early days of computer
    technology, until around 1970\. Then, it became more and more common to have processors
    that address single bytes of memory. Today, probably every processor in production
    can address single bytes of memory.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它按字寻址内存。这在计算机技术早期是很常见的，直到大约1970年。然后，拥有可以寻址单个内存字节的处理器的趋势越来越普遍。今天，可能每个正在生产的处理器都可以寻址单个内存字节。
- en: It has instructions of the same length. There has probably never been a machine
    language where all the instructions are of the same length. A very simple instruction,
    such as a **No-Operation** (**NOP**), can stay in a single byte, while there are
    processors that have instructions spanning many bytes.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有相同长度的指令。可能从未有过所有指令长度都相同的机器语言。一个非常简单的指令，例如一个**无操作**（**NOP**），可以占用一个字节，而有些处理器具有跨越多个字节的指令。
- en: Any kind of operation operates on a 16-bit word for real-world processors, for
    any kind of operation—for example, addition. There can be an instruction that
    operates on single bytes, adding an 8-bit byte to another byte, another instruction
    that does the same thing but on 16-bit words, adding a word to another word, another
    instruction for 32-bit double-words, and even instructions that operate on larger
    bit sequences.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于现实世界的处理器，任何类型的操作都在16位字上操作，例如加法。可能有一个指令操作单个字节，将一个8位字节加到另一个字节上，另一个指令执行相同操作但是在16位字上，将一个字加到另一个字上，另一个指令用于32位双字，甚至还有操作更大位序列的指令。
- en: It has just one processor register—the accumulator. Real-world processors have
    much more processor registers.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只有一个处理器寄存器——累加器。现实世界的处理器有更多的处理器寄存器。
- en: It has few operations available. Real-world machine languages have more possible
    operations, such as logical operations, function calls and function return instructions,
    stack manipulation operations, and increment and decrement operators.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供的操作很少。现实世界的机器语言有更多可能的操作，例如逻辑操作、函数调用和函数返回指令、堆栈操作操作以及递增和递减运算符。
- en: 'Here, we will change our machine language to introduce the following missing
    features:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将改变我们的机器语言以引入以下缺失的功能：
- en: Byte addressing
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节寻址
- en: Variable-length instructions
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变长度指令
- en: Instructions to load or store a single byte, in addition to those to load or
    store words
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载或存储单个字节的指令，除了加载或存储字节的指令之外
- en: 'So, we apply the following changes to our byte-addressing machine language:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们对字节寻址的机器语言应用以下更改：
- en: Every address represents the position of a memory byte, not the position of
    a memory word.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个地址代表内存字节的位位置，而不是内存字的位位置。
- en: Every opcode occupies only one byte, instead of the word as was the case in
    the preceding language.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个操作码只占用一个字节，而不是像先前语言那样占用一个字。
- en: While most instruction types still have a one-word operand, three instruction
    types have a 1-byte operand. They are `terminate operand`, `input length`, and `output length`.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然大多数指令类型仍然有一个字操作数，但三种指令类型有一个1字节操作数。它们是`终止操作数`、`输入长度`和`输出长度`。
- en: Four instruction types are added to the language to manipulate a single byte.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言中增加了四种指令类型来操作单个字节。
- en: To understand this new machine language, it is important to realize that every
    16-bit word contains 2 bytes, one containing the eight least significant bits
    of the number and the other containing the eight most significant bits of the
    number. The first byte is named the **low byte** and the other is named the **high
    byte**. When a byte inside a word is manipulated, it is important to know whether
    it is the low byte or the high byte of that word.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这种新的机器语言，重要的是要认识到每个16位字包含2个字节，一个包含数字的8个最低有效位，另一个包含数字的8个最高有效位。第一个字节被称为**低字节**，另一个被称为**高字节**。当操作一个字内的字节时，知道它是该字的低字节还是高字节是很重要的。
- en: 'The new instruction types are defined in the following table:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 新的指令类型定义在以下表中：
- en: '| **Opcode** | **Assembly syntax** | **Description** |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **操作码** | **汇编语法** | **描述** |'
- en: '| `20` | `load_byte address` | This copies the value of the byte at that address to
    the low byte of the accumulator. The high byte of the accumulator is set to `0`.
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `20` | `加载字节地址` | 这会将指定地址的字节值复制到累加器的低字节。累加器的高字节被设置为 `0`。 |'
- en: '| `21` | `store_byte address` | This copies the low byte of the value of the
    accumulator to that address. The high byte of the accumulator is not used. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `21` | `存储字节地址` | 这会将累加器值的低字节复制到该地址。累加器的高字节未使用。 |'
- en: '| `22` | `indirect_load_byte address` | This copies the byte value whose address
    is specified at that address to the low byte of the accumulator. The high byte
    of the accumulator is set to `0`. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `22` | `间接加载字节地址` | 这会将指定地址的字节值复制到累加器的低字节。累加器的高字节被设置为 `0`。 |'
- en: '| `23` | `indirect_store_byte address` | This copies the low byte of the value
    of the accumulator to the address specified at that address. The high byte of
    the accumulator is not used. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `23` | `间接存储字节地址` | 这会将累加器值的低字节复制到指定地址。累加器的高字节未使用。 |'
- en: These four instructions are needed because the `load`, `store`, `indirect_load`,
    and `indirect_store` instruction types still transfer whole words, while we also
    need to read or write a single byte of memory without reading or writing the byte
    next to the specified address.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 需要这四个指令是因为`加载`、`存储`、`间接加载`和`间接存储`指令类型仍然传输整个字，而我们还需要读取或写入指定地址旁边的单个字节而不读取或写入该字节。
- en: As a result of these changes, in the previous machine language, every instruction
    occupied four bytes. However, in this new language, the three instruction types—`terminate`,
    `input`, and `output`—occupy only 2 bytes and all the other instruction types occupy
    3 bytes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些变化，在之前的机器语言中，每个指令占用四个字节。然而，在这种新的语言中，三种指令类型——`终止`、`输入`和`输出`——仅占用2个字节，而所有其他指令类型占用3个字节。
- en: Notice that all the other instruction types remain unchanged and the size of
    the accumulator and the instruction pointer is still 16 bits.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有其他指令类型保持不变，累加器和指令指针的大小仍然是16位。
- en: Having byte-addressing capability, together with words spanning several bytes,
    raises an issue, however. This is the so-called **endianness** issue, described
    in the next section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有了字节寻址能力，并且单词跨越多个字节，但这引发了一个问题。这就是所谓的**字节序**问题，将在下一节中描述。
- en: Coping with the endianness issue
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应对字节序问题
- en: Consider a word in the accumulator with a value of `256`. The low byte of this
    word is `0` and the high byte is `1`. This word will be stored at the `1000` memory
    address. Because this address now refers to a single byte, not to a two-byte word,
    the `store` instruction must also access another memory byte to store a word.
    For every computer system, the other byte that is needed is one with the following
    consecutive address, and so it is at address `1001`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑累加器中的一个值为 `256` 的字。这个字的低字节是 `0`，高字节是 `1`。这个字将被存储在 `1000` 内存地址。因为这个地址现在指的是一个字节，而不是一个双字节字，所以`存储`指令也必须访问另一个内存字节来存储一个字。对于每个计算机系统，所需的另一个字节是具有以下连续地址的字节，因此它在地址
    `1001`。
- en: So, our accumulator will be stored in the 2 bytes with addresses `1000` and
    `1001`. However, the low byte of number `256`, whose value is `0`, could be stored
    at address `1000` or at address `1001`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的累加器将存储在地址 `1000` 和 `1001` 的2个字节中。然而，数值为 `256` 的低字节，其值为 `0`，可能存储在地址 `1000`
    或 `1001`。
- en: 'In the first case, when the low byte is stored at address `1000`, the high
    byte, whose value is `1`, will be stored at address `1001`. Here is the memory
    layout of this case:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，当低字节存储在地址 `1000` 时，其值为 `1` 的高字节将被存储在地址 `1001`。以下是这种情况下的内存布局：
- en: '| **Address** | **Memory content** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **内存内容** |'
- en: '| `1000` | 00000000 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `1000` | 00000000 |'
- en: '| `1001` | 00000001 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `1001` | 00000001 |'
- en: 'In the second case, when the low byte is stored at address `1001`, the high
    byte will be stored at address `1000`. Here is the memory layout of this case:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，当低字节存储在地址 `1001` 时，高字节将被存储在地址 `1000`。以下是这种情况下的内存布局：
- en: '| **Address** | **Memory contents** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **内存内容** |'
- en: '| `1000` | 00000001 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `1000` | 00000001 |'
- en: '| `1001` | 00000000 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `1001` | 00000000 |'
- en: This is just a matter of convention.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个约定问题。
- en: Unfortunately, some important computer vendors chose one convention and some
    other important computer vendors chose the other. Some computer hardware can even
    be programmed to change convention at runtime, and so it is up to the operating
    system to choose the convention.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一些重要的计算机供应商选择了一种约定，而另一些重要的计算机供应商选择了另一种约定。甚至有些计算机硬件可以被编程在运行时更改约定，因此选择约定取决于操作系统。
- en: The convention where the low byte has a lower memory address is named **little-endian**,
    which is shown in the first of the previous two tables. The other convention, where
    the high byte has a lower memory address, is named **big-endian**, and it is shown
    in the second of the preceding two tables. The issue itself is named the **endianness**
    issue.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 低字节具有较低内存地址的约定被称为**小端序**，这在前面两个表中的第一个表中显示。另一种约定，即高字节具有较低内存地址的约定，被称为**大端序**，它在前面两个表中的第二个表中显示。这个问题本身被称为**字节序**问题。
- en: For our machine language, we chose little-endian.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的机器语言，我们选择了小端序。
- en: Now that we have defined the new byte-addressing machine language and we have
    chosen to adopt the little-endian convention for it, we can write an interpreter
    for this machine language.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了新的字节寻址机器语言，并且我们选择了采用小端序约定，我们可以为这种机器语言编写一个解释器。
- en: The nom_byte_machine project
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nom_byte_machine项目
- en: Now that we have a new machine language, we can write some programs using it
    and try to build an interpreter for these programs. In addition, it is possible
    to use the `nom` library, already seen in [Chapter 8](24e48581-b784-455c-bb17-b08a380cdab7.xhtml),
    *Using a Parser Combinator for Interpreting and Compiling*, to ease the building
    of this sort of interpreter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了新的机器语言，我们可以用它编写一些程序，并尝试为这些程序构建一个解释器。此外，可以使用已在[第8章](24e48581-b784-455c-bb17-b08a380cdab7.xhtml)中提到的`nom`库，*使用解析器组合进行解释和编译*，以简化此类解释器的构建。
- en: 'However, before we start coding, let''s consider the possible techniques to execute
    a machine language program. In fact, there are at least three possible ways to
    execute a machine language program without having real hardware:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始编码之前，让我们考虑执行机器语言程序的可能技术。实际上，至少有三种可能的方式在没有真实硬件的情况下执行机器语言程序：
- en: '**Technique 1**: Interpreting it just as the hardware would interpret it. This
    is the technique used in the previous sections to interpret the sieve of Eratosthenes program
    in the `word_machine_sieve` project.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术1**：就像硬件解释它一样解释它。这是在前面章节中用于解释`word_machine_sieve`项目中埃拉托斯特尼筛法程序的技术。'
- en: '**Technique 2**: First, parsing it all and transforming it into a high-level
    data structure, then interpreting this data structure.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术2**：首先，解析整个程序并将其转换成高级数据结构，然后解释这个数据结构。'
- en: '**Technique 3**: Translating it into another programming language, and then
    using an interpreter or a compiler for this programming language.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术3**：将其翻译成另一种编程语言，然后使用该编程语言的解释器或编译器。'
- en: '*Technique 1* is the only one of the three that can obtain the correct result
    for any possible program. The other two techniques only work if the program is
    well formed, following these rules:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*技术1*是三种技术中唯一能够为任何可能的程序获得正确结果的技术。其他两种技术**仅**在程序格式良好，遵循以下规则时才有效：'
- en: It begins with a little-endian word containing the size of the process in bytes.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它以一个包含进程大小的字节的little-endian单词开始。
- en: After the initial word, there is a sequence of valid machine language instructions,
    with no interleaved spaces or data.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始单词之后，是一系列有效的机器语言指令，没有交错的空间或数据。
- en: The `Terminate` instruction occurs once—and only once—as the last instruction
    so that it marks the end of the sequence of instructions. After this, there is
    only data left.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Terminate`指令只出现一次，作为最后一个指令，以标记指令序列的结束。之后，只剩下数据。'
- en: No statement writes on the instructions; only the data can be changed. So, the
    program is not self-modifying; or, said in another way, the program instructions
    are the same as the process instructions.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有语句会在指令上写入；只有数据可以被更改。因此，程序不是自我修改的；或者说，另一种说法是，程序指令与过程指令相同。
- en: The `nom_byte_machine` project implements all three techniques and applies them
    to a well-formed machine language program. This program is a version of the sieve
    algorithm seen in the preceding section, implemented for the byte-addressing machine
    language.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`nom_byte_machine`项目实现了所有三种技术，并将它们应用于一个格式良好的机器语言程序。这个程序是前面章节中看到的筛法算法的版本，为字节寻址的机器语言实现。'
- en: 'First of all, let''s try to build and run the project by typing `cargo run` in
    the `project` folder. The build will take some time because it uses the `nom`
    library. The execution starts by creating the `prog.c` file, containing a C language
    version of the machine language program, and printing the following on the console:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试通过在`project`文件夹中键入`cargo run`来构建和运行项目。构建将花费一些时间，因为它使用了`nom`库。执行开始于创建包含机器语言程序C语言版本的`prog.c`文件，并在控制台上打印以下内容：
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, the program interprets the program using the first technique described
    earlier. This causes it to wait until the user types in a number. You should type
    in a number between `0` and `400` and press *Enter*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，程序使用前面描述的第一种技术解释程序。这导致它等待用户输入一个数字。你应该输入一个介于`0`和`400`之间的数字，然后按*Enter*键。
- en: Some prime numbers will be printed using *Technique 1*, and then the program
    interprets the same program using *Technique 2*, and, therefore, it waits again
    until the user types in a number. You should type in a number again and press
    *Enter*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用*技术1*打印一些素数，然后程序再次使用*技术2*解释相同的程序，因此它再次等待用户输入一个数字。你应该再次输入一个数字并按*Enter*键。
- en: 'For example, if you entered `100` the first time and the second time you entered `40`,
    then the console should display this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你第一次输入 `100`，第二次输入 `40`，那么控制台应该显示以下内容：
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After executing it, the `prog.c` file will exist in the `project` folder. Using
    a Unix-like environment, you can compile it with the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，`prog.c` 文件将存在于 `project` 文件夹中。在类 Unix 环境中，你可以使用以下命令编译它：
- en: '[PRE21]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will create the `prog.exe` file. Then, you can run it with the following command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建 `prog.exe` 文件。然后，你可以使用以下命令运行它：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Of course, this program has the same behavior as the previously interpreted
    program. It first asks for a number, and if, for example, you type in `25`, the
    output is this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个程序与之前解释的程序具有相同的行为。它首先请求一个数字，例如，如果你输入 `25`，输出将是以下内容：
- en: '[PRE23]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As this project is somewhat complex, its source code has been split into several
    source files. They are as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个项目相对复杂，其源代码已被拆分为几个源文件。它们如下：
- en: '`main.rs`: This contains the machine language program and the calls to the
    functions contained in the other source files.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.rs`：这个文件包含机器语言程序和对其他源文件中包含的函数的调用。'
- en: '`instructions.rs`: This contains the definitions of the machine language instructions
    and the `nom` parsers to recognize them.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instructions.rs`：这个文件包含机器语言指令的定义和 `nom` 解析器以识别它们。'
- en: '`emulator.rs`: This is a low-level interpreter of the machine code. Every instruction
    is first parsed and then executed.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emulator.rs`：这是机器码的低级解释器。每条指令首先被解析，然后执行。'
- en: '`parsing_interpreter.rs`: This first parses all the instructions of the machine
    code, constructing a data structure, and then executes this data structure.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parsing_interpreter.rs`：首先解析所有机器码指令，构建一个数据结构，然后执行这个数据结构。'
- en: '`translator.rs`: This translates all the instruction of the machine code into
    C language code and adds some C language lines to create a valid C program.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translator.rs`：这个文件将所有机器码指令翻译成 C 语言代码，并添加一些 C 语言行以创建一个有效的 C 程序。'
- en: Let's look at each of the files in the following sections.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下各节中的每个文件。
- en: Understanding the main.rs source file
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `main.rs` 源文件
- en: 'The `main.rs` file contains the `main` function, which begins with the following
    lines:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.rs` 文件包含 `main` 函数，它以以下行开始：'
- en: '[PRE24]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This machine language program is similar to the one used in the `word_machine_sieve` project.
    While in those programs the numbers represented words (`u16`), now they represent
    bytes (`u8`).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机器语言程序与 `word_machine_sieve` 项目中使用的类似。在这些程序中，数字代表单词 (`u16`)，而现在它们代表字节 (`u8`)。
- en: First, read the comments, except for the descriptive comments that are on their
    own in a line. These comments contain the address of the current instruction or
    data, followed by a colon, followed by an assembly statement.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，阅读注释，除了那些单独占一行的描述性注释。这些注释包含当前指令或数据的地址，后面跟着一个冒号，然后是汇编语句。
- en: The first line represents what starts at address `0`. In this case, this is
    number `699`, which is the required length of the process. As we said in the previous
    section, we adopted the little-endian convention to store words, and so this number
    is stored as the pair of bytes, `187, 2`, which means *2 x 256 + 187*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表示从地址 `0` 开始的内容。在这种情况下，这是数字 `699`，它是进程所需的长度。正如我们在上一节所说，我们采用了小端序约定来存储单词，因此这个数字被存储为字节对，`187,
    2`，这意味着 *2 x 256 + 187*。
- en: The second line is a descriptive comment. The third line represents what starts
    at address `2`, which in little-endian notation is `2, 0`. The content is the `set` instruction,
    with the address of the `digits` label as its operand. The opcode of the `set`
    instruction is `1` and the `digits` label is at address `284`, which in little-endian
    notation is `28, 1`. So, we have, `1, 28, 1` on this line.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是一个描述性注释。第三行表示从地址 `2` 开始的内容，以小端序表示为 `2, 0`。内容是 `set` 指令，其操作数是 `digits` 标签的地址。`set`
    指令的操码是 `1`，`digits` 标签位于地址 `284`，以小端序表示为 `28, 1`。因此，这一行上有 `1, 28, 1`。
- en: The fourth line represents what starts at address `5`, which is an instruction
    that in assembly is `input 5` and in machine code is `6, 5`. The rest of the program
    is similar.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第四行表示从地址 `5` 开始的内容，这是一个汇编中为 `input 5`、机器码中为 `6, 5` 的指令。程序的其他部分类似。
- en: 'The last part of the program is the data section. Here is a snippet of it:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分是数据部分。以下是其中的一段：
- en: '[PRE25]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first line represents an array of 5 bytes, all of them initialized to `0`.
    Its label is `digits` and its address is `284`, which is represented by the `28,
    1` pair.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代表一个5字节的数组，所有这些都被初始化为`0`。它的标签是`digits`，其地址是`284`，由`28, 1`对表示。
- en: The second line represents a word initialized to `0` whose label is `pos` and
    address is the `33, 1` pair, which is 5 bytes after the `digits` address.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行代表一个初始化为`0`的单词，其标签为`pos`，地址是`33, 1`对，这是在`digits`地址之后的5个字节。
- en: The third line represents a word initialized to 10 (represented by the `10,
    0` pair) whose label is `number_base` and whose address is the `35, 1` pair, which
    is two bytes after the `pos` address.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行代表一个初始化为10（由`10, 0`对表示）的单词，其标签为`number_base`，其地址是`35, 1`对，这是在`pos`地址之后的两个字节。
- en: 'The main function ends with the following lines:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数以以下行结束：
- en: '[PRE26]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: From the preceding code, the first statement invokes a function that translates
    the `prog` machine language program into a C language file with the specified
    name.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，第一条语句调用一个函数，该函数将`prog`机器语言程序翻译成具有指定名称的C语言文件。
- en: The second statement interprets the program using the first technique instruction
    by instruction.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个语句逐条指令解释程序。
- en: The last block of statements first invokes the `parse_program` statement, which
    translates the program into a data structure and stores it in the `parsed_program`
    variable, and then the `execute_parsed_program` function is invoked to execute
    this data structure.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段语句首先调用`parse_program`语句，该语句将程序翻译成数据结构并存储在`parsed_program`变量中，然后调用`execute_parsed_program`函数来执行这个数据结构。
- en: The rest of the Rust program implements these functions and we are going to
    use the `nom` library for this purpose.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Rust程序的其余部分实现了这些功能，我们将使用`nom`库来完成这个目的。
- en: Using the Nom library
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Nom库
- en: The code that will implement what is described in this section can be found
    in the `instructions.rs` source file.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 实现本节所描述功能的代码可以在`instructions.rs`源文件中找到。
- en: In the preceding chapters, we saw how to use the `nom` library to parse text,
    which is string slices. Well, `nom` is not limited to text, however; it can also
    be used to parse binary data, which is byte slices. In fact, it was created just
    for that, and the capability to parse strings was added later.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用`nom`库来解析文本，即字符串切片。嗯，`nom`不仅限于文本；它还可以用于解析二进制数据，即字节切片。事实上，它就是为了这个目的而创建的，后来才添加了解析字符串的能力。
- en: Here, we are going to use the binary parsing capability of `nom` to process
    our machine language.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将使用`nom`的二元解析能力来处理我们的机器语言。
- en: Parsing a binary file is no more difficult than parsing a text file. The only
    difference between them is that when parsing a text file, the parsed text is a
    reference to a string slice, with an `&str` type, while when parsing a binary
    file, the parsed text is a reference to a slice of bytes, with an `&[u8]` type.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 解析二进制文件并不比解析文本文件更困难。它们之间的唯一区别在于，当解析文本文件时，解析的文本是字符串切片的引用，具有`&str`类型，而当解析二进制文件时，解析的文本是字节切片的引用，具有`&[u8]`类型。
- en: 'For example, this is the signature of a parser that recognizes an `add` instruction:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是识别`add`指令的解析器的签名：
- en: '[PRE27]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `parse_add` function takes a reference to a slice of bytes as input and,
    of course, its remaining sequence is still a reference to a slice of bytes. We
    want its return value to fully describe the parsed instruction, and so the custom `Instruction`
    type is used.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_add`函数接受一个字节切片的引用作为输入，当然，它的剩余序列仍然是一个字节切片的引用。我们希望它的返回值能够完全描述解析的指令，因此使用了自定义的`Instruction`类型。'
- en: 'This type can be defined in the following way:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型可以按以下方式定义：
- en: '[PRE28]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: From the preceding code snippet, every instruction type is a variant of the
    `Instruction` enum, and these variants have a parameter to store the value of
    the operator. The `Terminate`, `Input`, and `Output` variants have a `u8` parameter,
    while the other instruction types have a `u16` parameter. Notice that the last
    variant is not an instruction; it is `Byte(u8)`, which represents a data byte
    contained in the process.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，每个指令类型都是`Instruction`枚举的一个变体，这些变体有一个参数来存储操作符的值。`Terminate`、`Input`和`Output`变体有一个`u8`参数，而其他指令类型有一个`u16`参数。注意，最后一个变体不是一个指令；它是`Byte(u8)`，表示在过程中包含的数据字节。
- en: Using a Rust enum, it is quite easy to encapsulate the operands of the instructions in
    a variant, even if there are more than one, as is typical of real-world machine
    languages. The operands are always rather small objects, and so it is efficient
    to derive the `Copy` trait for the `Instruction` enum.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the `parse_add` function is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `preceded` parser combinator, already seen in preceding chapters, gets two
    parsers, applies them in sequence, discards the result of the first one, and returns
    the result of the second one.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Its first parser is `tag("\x08")`. In the preceding chapters, we already saw
    the `tag` function used as a parser that can recognize a literal string slice.
    In fact, it can also recognize a literal sequence of bytes, specified as a literal
    string. To specify a byte using a number instead of an ASCII character, a hexadecimal
    escape sequence is appropriate. So, this parser recognizes a byte as having a
    value of `8`, which is the opcode of the `add` instruction.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The second parser processed by `preceded` must recognize a little-endian 2-byte
    operand. So, the `le_u16` parser is used for this. Its name means little-endian
    u16\. There is also a corresponding `be_u16` to recognize a word using the big-endian
    byte order.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The `le_u16` parser just returns a `u16` value. However, we want an `Instruction::Add`
    object to encapsulate this value. So, the `map` function is used to create an
    `Add` object containing the parsed word.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: So, the body of the `parse_add` function first checks whether there are 8 bytes,
    then discards them; then, it reads a pair of bytes to build a 16-bit number according
    to the little-endian byte order, then returns an `Add` object containing this
    word.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: For all the instructions with a word operand, a similar parser can be created.
    However, for the instructions with a byte operand, a different operand parser
    must be used. When parsing a single byte, there is no endianness issue; however,
    for terminological consistency, the `le_u8` parser will be used, even if the `be_u8`
    parser could have been used just as well as it is identical to it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here the parser is used to recognize a `terminate` instruction, with opcode
    `0`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We invoke `parse_add` when we want to recognize an `add` instruction and `parse_terminate` when
    we want to recognize a `terminate` instruction; however, when we want to recognize
    any possible instruction, we must combine all the parsers for all the instructions as
    alternatives using the `alt` parser combinator, already seen in the preceding
    chapters.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'This parser combinator has a limitation, however—it cannot combine more than
    20 parsers. Actually, we have 24 instruction types, and so 24 parsers to combine.
    This issue can easily be overcome by nesting the use of `alt`. Here is the resulting
    function:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: From the preceding code, the `parse_instruction` function uses `alt` to combine
    just two parsers; the first one uses `alt` to combine the parsers for 20 instructions
    and the other one uses `alt` to combine the parsers for the remaining 4 instructions.
    When a byte slice is passed to this function, it returns the only instruction
    that can be parsed from it or an error if no instruction is recognized.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，`parse_instruction` 函数使用 `alt` 来组合恰好两个解析器；第一个解析器使用 `alt` 来组合 20 个指令的解析器，而另一个解析器使用
    `alt` 来组合剩余 4 个指令的解析器。当将字节切片传递给此函数时，它返回可以从其中解析出的唯一指令或错误，如果没有识别到指令。
- en: 'The `Instruction` enum implements the `len` method, which is useful to find
    out the length of the instruction. It is given as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`Instruction` 枚举实现了 `len` 方法，这对于找出指令的长度很有用。它如下所示：'
- en: '[PRE32]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, `Byte` occupies `1` byte, the `Terminate`, `Input`, and
    `Output` instructions occupy `2` bytes, and the other instructions occupy `3`
    bytes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Byte` 占用 `1` 个字节，`Terminate`、`Input` 和 `Output` 指令占用 `2` 个字节，其他指令占用
    `3` 个字节。
- en: The `get_process_size` function is useful for reading the length of the process
    from the first two bytes of the program. Notice that all the parsers (of this
    module) are private, except for `parse_instruction`, so that we can parse machine
    code instructions.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_process_size` 函数用于从程序的第一个字节读取进程的长度。请注意，除了 `parse_instruction` 之外，本模块的所有解析器都是私有的，这样我们就可以解析机器代码指令。'
- en: Now that we have a parser for the instructions, we can build a low-level interpreter
    (that is, an emulator) using it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了指令的解析器，我们可以使用它构建一个低级解释器（即仿真器）。
- en: The emulator.rs source file
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`emulator.rs` 源文件'
- en: 'This emulator is implemented in the `emulator.rs` source file. The entry point
    of the interpreter is the following function:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此仿真器在 `emulator.rs` 源文件中实现。解释器的入口点是以下函数：
- en: '[PRE33]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding function receives a program as an argument and executes it by
    parsing and executing one instruction at a time. If any parse error occurs because
    of a malformed instruction, the function returns that parse error. If no parse
    error occurs, the program goes on until a `Terminate` instruction is encountered.
    Then, the program returns the operand of the `Terminate` instruction.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数接收一个程序作为参数，并通过逐条解析和执行指令来执行它。如果由于指令格式不正确而导致解析错误，则函数返回该解析错误。如果没有发生解析错误，程序将继续执行，直到遇到
    `Terminate` 指令。然后，程序返回 `Terminate` 指令的操作数。
- en: The first statement gets the required size of the process. Then, a `process`
    variable is created as a vector of bytes, with the specified length. The content
    of the program is copied into the first part of the process, then the rest of
    the process is initialized to zeros.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句获取进程所需的大小。然后，创建一个 `process` 变量，它是一个具有指定长度的字节向量。程序的内容被复制到进程的第一部分，然后进程的其余部分初始化为零。
- en: 'Then, at the eighth line of the preceding code, the `registers` variable is
    declared with a `RegisterSet` type, declared as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在前面代码的第八行，声明了 `registers` 变量，其类型为 `RegisterSet`，声明如下：
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this simple machine architecture, there is no big gain in encapsulating the
    instruction pointer and the accumulator in a struct, but with more complex processors
    with many registers, it would be convenient.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的机器架构中，将指令指针和累加器封装在结构体中并没有带来太大的好处，但对于具有许多寄存器的更复杂处理器来说，这将很方便。
- en: 'At last, there is the interpretation loop. It consists of two steps:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是解释循环。它由两个步骤组成：
- en: The call to `parse_instruction` parses the process from the current position
    of the instruction pointer and returns `Instruction`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `parse_instruction` 的调用从指令指针的当前位置解析进程并返回 `Instruction`。
- en: The call to `execute_instruction` executes the instruction generated by the
    preceding step, taking into account the whole process and the register set.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `execute_instruction` 的调用执行了前面步骤生成的指令，考虑到整个进程和寄存器集。
- en: 'The `execute_instruction` function is just a large `match` statement that begins
    with the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute_instruction` 函数只是一个以以下内容开始的大的 `match` 语句：'
- en: '[PRE35]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For each instruction type, the appropriate action is taken. Notice the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种指令类型，都采取适当的操作。注意以下内容：
- en: The `Terminate` instruction causes the function to return `Some`, while for
    any other instruction, `None` is returned. This allows the caller to terminate
    the execution loop.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Terminate` 指令会导致函数返回 `Some`，而对于任何其他指令，返回 `None`。这允许调用者终止执行循环。'
- en: The `Set` instruction sets the accumulator (`r.acc`) to the operand value.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`指令将累加器（`r.acc`）设置为操作数的值。'
- en: The `Load` instruction uses the `get_le_word` function to read a little-endian
    word from the `address` position of `process` and assigns it to the accumulator.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Load`指令使用`get_le_word`函数从`process`的`address`位置读取一个little-endian格式的字，并将其赋值给累加器。'
- en: The `Store` instruction uses the `set_le_word` function to assign a little-endian
    word taken from the accumulator to the `address` position of `process`.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store`指令使用`set_le_word`函数将来自累加器的little-endian格式的字赋值到`process`的`address`位置。'
- en: All the instructions increment the instruction pointer (`r.ip`) by the length
    of the instruction itself.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有指令都会将指令指针（`r.ip`）增加指令本身的长度。
- en: 'Let''s see the auxiliary functions used every time an instruction needs to
    read or to write a word in memory, respectively:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每次指令需要读取或写入内存中的字时使用的辅助函数：
- en: '[PRE36]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, the `get_le_word` function gets a byte at `address` and
    another byte at the next position. The second one is the most significant in little-endian
    notation, and so its value is shifted to the left by 8 bits before adding it to
    the other byte.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`get_le_word`函数从`address`读取一个字节，并从下一个位置读取另一个字节。在little-endian表示法中，第二个字节是最重要的，因此它的值在添加到其他字节之前被左移8位。
- en: '`set_le_word` saves a byte, along with the address position, and another one
    at the next position. The first one is obtained by converting the word into a
    `u8` type, and the second one is obtained by shifting the word to the right by
    8 bits.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_le_word`函数保存一个字节，连同地址位置，以及下一个位置的一个字节。第一个字节是通过将字转换为`u8`类型获得的，第二个字节是通过将字向右移动8位获得的。'
- en: 'Of course, the `jump` instructions are different. For example, look at the
    following code snippet:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`jump`指令是不同的。例如，看看下面的代码片段：
- en: '[PRE37]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Consider the `JumpIfPositive` instruction's operand as a signed number. If this
    value is positive, the instruction pointer is set to the operand. Otherwise, the
    usual increment is performed.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 将`JumpIfPositive`指令的操作数视为一个有符号数。如果这个值是正的，指令指针被设置为操作数。否则，执行常规的增量操作。
- en: 'As another example, let''s see how to indirectly load a byte:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，让我们看看如何间接加载一个字节：
- en: '[PRE38]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using the `get_le_word` function, the 16-bit value at the `address` position is
    read from `process`. This value is an address of a byte, and so the `get_byte`
    function is used to read this byte to assign it to the accumulator.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get_le_word`函数，从`process`的`address`位置读取16位值。这个值是一个字节的地址，因此使用`get_byte`函数读取这个字节并将其赋值给累加器。
- en: So, in this section, we have seen the first execution technique—the one that
    parses and executes one instruction at a time.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们看到了第一种执行技术——逐条解析和执行指令的技术。
- en: The parsing_interpreter.rs source file
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`parsing_interpreter.rs`源文件'
- en: Now, we can look at the other execution technique—the one that first parses
    the whole program and then executes the result of the parsing.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看其他的执行技术——首先解析整个程序，然后执行解析结果。
- en: 'The `parsing_interpreter` module has two entry points:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`parsing_interpreter`模块有两个入口点：'
- en: '`parse_program`'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parse_program`'
- en: '`execute_parsed_program`'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`execute_parsed_program`'
- en: 'The first one calls `get_process_size` once to get the process size from the
    first two bytes, then it parses the program instructions using the following loop:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个步骤是调用一次`get_process_size`函数来从前两个字节中获取进程大小，然后使用以下循环来解析程序指令：
- en: '[PRE39]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the following code, the data structure that we are going to build is the
    `parsed_program` variable. That variable is a vector of instructions or byte data.
    It is initialized by single data bytes with zero value, but then some of these
    bytes are replaced with instructions.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们要构建的数据结构是`parsed_program`变量。这个变量是一个指令或字节数据的向量。它通过初始化为具有零值的单个数据字节来初始化，但随后一些字节被替换为指令。
- en: Starting at position `2`, the program is repeatedly parsed using the `parse_instruction`
    function. This function returns an instruction that is stored in the vector at
    the position corresponding to its position in the program. When the `Terminate`
    instruction is parsed, the loop ends.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 从位置`2`开始，程序会重复使用`parse_instruction`函数进行解析。这个函数返回一个指令，并将其存储在程序位置对应的向量中。当解析到`Terminate`指令时，循环结束。
- en: The `parse_instruction` function is the same as the one we saw in the `instructions`
    module.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_instruction`函数与我们在`instructions`模块中看到的相同。'
- en: 'After this loop, we need to set the data values into the vector. This is done
    by using the following loop:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在此循环之后，我们需要将数据值设置到向量中。这是通过以下循环完成的：
- en: '[PRE40]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This replaces any byte of the vector with another byte whose value is taken
    from the program. The `execute_parsed_program` function has the following body:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用另一个字节替换向量的任何字节，其值来自程序。`execute_parsed_program` 函数具有以下结构：
- en: '[PRE41]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code defines a register set and then calls `execute_parsed_instruction` repeatedly until
    it returns `Some`. This function is very similar to the `execute_instruction`
    functions of the `emulator` module.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个寄存器集，然后反复调用 `execute_parsed_instruction` 直到它返回 `Some`。此函数与 `emulator`
    模块的 `execute_instruction` 函数非常相似。
- en: The main differences are in the use of the `get_parsed_le_word`, `set_parsed_le_word`,
    `get_parsed_byte`, and `set_parsed_byte` functions, instead of `get_le_word`,
    `set_le_word`, `get_byte`, and `set_byte`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于使用 `get_parsed_le_word`、`set_parsed_le_word`、`get_parsed_byte` 和 `set_parsed_byte`
    函数，而不是 `get_le_word`、`set_le_word`、`get_byte` 和 `set_byte`。
- en: These functions, instead of getting or setting the `u8` values in a slice of
    `u8` objects, get or set the `Instruction::Byte` values in a slice of the `Instruction`
    objects. This slice is the parsed program.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数，而不是在 `u8` 对象的切片中获取或设置 `u8` 值，而是在 `Instruction` 对象的切片中获取或设置 `Instruction::Byte`
    值。这个切片是解析后的程序。
- en: We will now move on to the last technique.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向最后一种技术。
- en: The translator.rs source file
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`translator.rs` 源文件'
- en: Now, we can look at the last execution technique—the one that translates the
    program into a C language program so that it can be compiled with any C compiler.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看最后一种执行技术——将程序翻译成 C 语言程序，以便可以使用任何 C 编译器进行编译。
- en: 'The `translator.rs` module has just one entry point:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`translator.rs` 模块只有一个入口点：'
- en: '[PRE42]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This function gets the machine language program to translate the program and
    the path of the file to create and return a result that indicates its success
    or failure.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数获取要翻译的机器语言程序以及要创建的文件路径，并返回一个表示其成功或失败的结果。
- en: 'Its body creates a text file and writes into it using statements such as this
    one:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 其主体创建一个文本文件，并使用如下语句将其写入：
- en: '[PRE43]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It writes a string into the `file` stream. Notice that the `writeln` macro,
    in a similar way to the `println` macro, supports string interpolation through
    pairs of braces:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 它将字符串写入 `file` 流。请注意，与 `println` 宏类似，`writeln` 宏也支持通过成对的大括号进行字符串插值：
- en: '[PRE44]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Therefore, any real brace must be doubled:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何实际的括号都必须成对出现：
- en: '[PRE45]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The translation algorithm is quite simple. First, the declaration of a global
    byte array is emitted:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译算法相当简单。首先，发出全局字节数组的声明：
- en: '[PRE46]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we have the definitions of two utility functions. Their signatures are
    as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有两个实用函数的定义。它们的签名如下：
- en: '[PRE47]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first one reads the two bytes in the `memory` array at two positions—`address`
    and `address + 1`—and, interpreting them as a little-endian 16-bit number, returns
    the number. The second one generates the two bytes that comprise the `operand`
    value and writes them in memory as a little-endian 16-bit number at the `address`
    and `address + 1` positions.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个读取 `memory` 数组中两个位置的两位字节——`address` 和 `address + 1`——并将它们解释为小端 16 位数字，然后返回该数字。第二个生成构成
    `operand` 值的两个字节，并将它们作为小端 16 位数字写入内存的 `address` 和 `address + 1` 位置。
- en: Then, the `main` C function is emitted. It begins by declaring the `acc` variable,
    which will be used as an accumulator register.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，发出 `main` C 函数。它首先声明 `acc` 变量，该变量将用作累加器寄存器。
- en: It may be surprising that there is no need for a variable containing the instruction
    pointer. This means that during the execution of the C program, the current C
    language statement corresponds to the current machine language instruction.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 可能令人惊讶的是，不需要包含指令指针的变量。这意味着在 C 程序执行期间，当前 C 语言语句对应于当前机器语言指令。
- en: The machine language jumps are implemented using the infamous `goto` statement.
    To be able to jump to any instruction, the instructions that are the destination
    of a jump must be preceded by a C language unique label. For simplicity, when
    translating any instruction, a different label is generated, even if most of them
    will never be used by a `goto` statement.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 机器语言跳转是通过臭名昭著的 `goto` 语句实现的。为了能够跳转到任何指令，必须将跳转目标指令之前放置一个 C 语言唯一的标签。为了简单起见，在翻译任何指令时，生成一个不同的标签，即使其中大多数标签将永远不会被
    `goto` 语句使用。
- en: 'As an example, let''s consider the `store pos` assembly language instruction,
    corresponding to the `3, 33, 1` machine language instruction, where `3` is the
    opcode of the `store` instruction and `33, 1` represents `289` in little-endian
    notation. Assume that this instruction starts at position `10` of the program.
    For this instruction, the following C language statement will be generated:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，让我们考虑`store pos`汇编语言指令，对应于`3, 33, 1`机器语言指令，其中`3`是`store`指令的操作码，`33, 1`代表小端表示法中的`289`。假设这个指令从程序的位置`10`开始。对于这个指令，将生成以下C语言语句：
- en: '[PRE48]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, there is the label as a target of a possible `jump` instruction. Labels
    are created, concatenating the position of the instruction to the `addr_` constant.
    Then, there is a function call that copies the value of the `acc` variable to
    the bytes at positions `289` and `230` of the `memory` array in little-endian
    notation.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个标签作为可能的`jump`指令的目标。标签是通过将指令的位置与`addr_`常量连接来创建的。然后，有一个函数调用，它将`acc`变量的值复制到`memory`数组中位置`289`和`230`的字节，使用小端表示法。
- en: To create these statements, a loop is performed that parses an instruction at
    a time using the `parse_instruction` function, and then generates the corresponding
    C language statement using the `translate_instruction_to_c` function.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这些语句，执行了一个循环，每次使用`parse_instruction`函数解析一条指令，然后使用`translate_instruction_to_c`函数生成相应的C语言语句。
- en: 'This function contains a large `match` statement, with a branch for every instruction
    type. For example, the branch that translates the `Store` instructions is as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数包含一个大的`match`语句，为每种指令类型都有一个分支。例如，将`Store`指令翻译的分支如下：
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After the `Terminate` statement has been processed by the loop, the `main` C function
    is closed and the `memory` array, which was only just declared, is now defined
    and initialized using the entire content of the machine language program.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环处理完`Terminate`语句之后，`main` C函数被关闭，而刚刚声明的`memory`数组现在被定义为使用整个机器语言程序的内容进行初始化。
- en: In fact, the machine language instructions could be omitted from this array
    as they are not used by the C language code, but this way is simpler.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，由于C语言代码没有使用机器语言指令，因此可以从这个数组中省略这些指令，但这样做更简单。
- en: So, we have seen how to generate an equivalent C language program from a machine
    language program, assuming it is well formed. This technique could be used to
    generate programs in other programming languages, as long as there is a `goto`
    statement.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了如何从一个机器语言程序生成一个等效的C语言程序，假设它是正确形成的。只要存在`goto`语句，这种技术可以用来生成其他编程语言中的程序。
- en: Now that we have seen several ways to execute machine language programs, we
    can look at another use of a machine language parser.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了执行机器语言程序的好几种方法，我们可以看看机器语言解析器的另一种用途。
- en: The nom_disassembler project
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`nom_disassembler`项目'
- en: We have seen that usually, machine language programs are written in assembly
    language and are then translated into machine language. So, if we want to understand
    or debug a machine language program written by our company, we should look at
    the assembly language program used to generate it.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，通常机器语言程序是用汇编语言编写的，然后翻译成机器语言。所以，如果我们想理解或调试我们公司编写的机器语言程序，我们应该查看用于生成它的汇编语言程序。
- en: 'However, if this program wasn''t written by our company and we don''t have
    its assembly language source code available, it is useful to have a tool that
    tries its best to translate machine language programs into the corresponding assembly
    language programs. This tool, named a disassembler, cannot create an excellent
    assembly language program for the following reasons:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这个程序不是由我们公司编写的，我们没有它的汇编语言源代码可用，那么有一个工具尝试将其尽可能好地翻译成相应的汇编语言程序是有用的。这个工具被称为反汇编器，但由于以下原因，它不能创建一个优秀的汇编语言程序：
- en: No meaningful comments can be inserted into the code.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中不能插入任何有意义的注释。
- en: Data variables have no symbolic name to make sense of them. They are just bytes
    of memory positions where some data is placed, and so they are referenced by their
    address.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据变量没有符号名称来使其有意义。它们只是放置某些数据的位置的内存字节，因此它们通过地址来引用。
- en: The destinations of jumps have no symbolic names to make sense of them. They
    are just memory positions where some instruction begins, and so they are referenced
    by their address.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳转的目标没有符号名称来使其有意义。它们只是某些指令开始的内存位置，因此它们通过地址来引用。
- en: Regarding 16-bit words, sometimes it is useful to see them as single numbers
    and sometimes as pairs of bytes. If you are disassembling a program to apply some
    changes to it and then submit the changed assembly program to an assembler (to
    obtain a changed machine language program), it is better to only generate a single
    number for every 16-bit number (in little-endian notation, for our kind of processor).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 关于16位字，有时将它们视为单个数字是有用的，有时将它们视为字节的成对组合。如果你正在反汇编一个程序以对其进行更改并将其更改后的汇编程序提交给汇编器（以获得更改后的机器语言程序），最好为每个16位数字只生成一个数字（对于我们的处理器类型，以小端序表示）。
- en: Instead, if you are disassembling a program just to understand it deeply, it
    is better to generate both a single number notation and a pair of its bytes for
    every 16-bit number.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你只是为了深入理解程序而反汇编程序，最好为每个16位数字生成一个数字表示法及其字节对的表示。
- en: Typical disassemblers use hexadecimal notation. A 16-bit number is represented
    by four hexadecimal digits, where two digits represent one byte and the other two digits
    represent the other byte.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的反汇编器使用十六进制表示法。一个16位数字由四个十六进制数字表示，其中两个数字代表一个字节，另外两个数字代表另一个字节。
- en: 'Instead, to continue with decimal notation, the `nom_disassembler` project
    generates two outputs from the same machine language program:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，为了继续使用十进制表示法，`nom_disassembler`项目从同一机器语言程序生成两个输出：
- en: A `FOR DEBUG` output, where every 16-bit number is shown both as a single number
    and as a pair of bytes
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`FOR DEBUG`输出，其中每个16位数字都显示为单个数字和字节对
- en: A`FOR ASSEMBLING`output, where every 16-bit number is shown only as a single
    number
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`FOR ASSEMBLING`输出，其中每个16位数字只显示为单个数字
- en: We will now learn how to run the project in the next subsection.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在下一小节学习如何运行项目。
- en: Running the project
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行项目
- en: 'If you type in `cargo run` for this project, you''ll see a long output that
    begins with the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为这个项目输入`cargo run`，你会看到一个以以下内容开始的冗长输出：
- en: '[PRE50]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After a few lines, you''ll find the following:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 几行之后，你会找到以下内容：
- en: '[PRE51]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'At the end, you''ll find the following:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你会找到以下内容：
- en: '[PRE52]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first part of the output is the `FOR DEBUG` disassembly. After showing the
    size of the program and the process, the disassembled instructions begin. The
    first one is a `Set` instruction, whose 16-bit operand is number `284`, which
    is composed of the `28` and `1` bytes in little-endian order. The second instruction
    is `Input`, which has an 8-bit operand.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一部分是`FOR DEBUG`反汇编。在显示程序大小和进程后，开始显示反汇编指令。第一个是`Set`指令，其16位操作数是数字`284`，由`28`和`1`字节按小端序组成。第二个指令是`Input`，它有一个8位操作数。
- en: Any instruction is preceded by the address of the first byte of the instruction.
    So, `Set` is preceded by `2` (it is the third byte of the program), and `Input`
    is preceded by `5` (it is the sixth byte of the program).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 任何指令都由指令的第一个字节的地址 precedes。因此，`Set`由`2` precedes（它是程序的第三个字节），`Input`由`5` precedes（它是程序的第六个字节）。
- en: The program ends with a sequence of bytes. As machine language has no concept
    of word data, the data is just a sequence of bytes.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 程序以一系列字节结束。由于机器语言没有字数据的概念，数据只是字节序列。
- en: 'The second part of the output is the `FOR ASSEMBLING` disassembly. This differs
    from the first kind of disassembling technique by the following aspects:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第二部分是`FOR ASSEMBLING`反汇编。这与第一种反汇编技术有以下不同之处：
- en: There is no program size. Any assembler program can compute the size of the
    corresponding machine language program. There is no need to specify it in the
    source for the assembler.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有程序大小。任何汇编程序都可以计算相应的机器语言程序的大小。在汇编程序的源代码中不需要指定它。
- en: Instructions' symbolic names only contain lowercase letters and they can be
    composed of several words, separated by spaces. In this way, they are easier to
    read and to write. Instead, the `FOR DEBUG` output uses just the names of the
    variants of the instruction enum.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令的符号名称只包含小写字母，并且可以由多个单词组成，单词之间用空格分隔。这样，它们更容易阅读和编写。相反，`FOR DEBUG`输出只使用指令枚举变体的名称。
- en: The operands are a single number.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数是一个数字。
- en: We will now take a look at the source code to help us understand it further.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看源代码以帮助我们进一步理解它。
- en: Examining the source code
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查源代码
- en: 'Now, let''s see how this project obtained this output by examining the source
    code, which is all in the `main.rs` file. This function, after defining the `prog`
    variable as in the preceding project, contains just these statements:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过检查`main.rs`文件中的源代码来查看这个项目是如何获得这种输出的。这个函数在定义了`prog`变量（如前一个项目所示）之后，只包含以下语句：
- en: '[PRE53]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `disassembly_program_for_debug` function produces the first kind of output
    and the `disassembly_program` function produces the second kind of output. Let's
    see what these functions do.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`disassembly_program_for_debug`函数产生第一种输出，而`disassembly_program`函数产生第二种输出。让我们看看这些函数做了什么。'
- en: Generating disassembly code that is useful for debugging
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成对调试有用的反汇编代码
- en: 'The interesting part of the `disassembly_program_for_debug` function is the
    following code snippet:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`disassembly_program_for_debug`函数的有趣部分是以下代码片段：'
- en: '[PRE54]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding code, there is first a loop that parses each instruction using
    the `parse_instruction` function, and then there is a loop that scans each data
    byte. For every parsed instruction, the obtained instruction is printed by `println` and
    its size is added to the current position inside the program, named `offset`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先有一个循环使用`parse_instruction`函数解析每个指令，然后有一个循环扫描每个数据字节。对于每个解析的指令，通过`println`打印获得的指令，并将其大小添加到程序中的当前位置，即`offset`。
- en: This loop ends when the `Terminate` instruction is found. For the data bytes,
    a `Byte` variant is built and it is printed in a similar way. This raises the
    question of how an object of the `Instruction` type can be printed.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环在找到`Terminate`指令时结束。对于数据字节，构建一个`Byte`变体，并以类似的方式打印。这引发了如何打印`Instruction`类型对象的问题。
- en: 'To be printed using the `{:?}` placeholder of `println`, the `Debug` trait
    must be implemented. However, if you print an `Instruction` object such as those
    defined in the preceding chapters, we don''t get the output we want. For example, if
    you execute the `print!("{:?}", Instruction::Set(284))` statement, you will get
    the following output:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`println`的`{:?}`占位符打印，必须实现`Debug`特性。然而，如果你打印一个如前几章中定义的`Instruction`对象，我们不会得到我们想要的输出。例如，如果你执行`print!("{:?}",
    Instruction::Set(284))`语句，你会得到以下输出：
- en: '[PRE55]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But instead, we want the following output:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们希望得到以下输出：
- en: '[PRE56]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To obtain the desired formatting, a new type must be defined in the following
    way:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得期望的格式化，必须以下述方式定义一个新的类型：
- en: '[PRE57]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Word` type encapsulates all the `u16` arguments of the variants of `Instruction` in
    the following way:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`Word`类型以以下方式封装了`Instruction`变体的所有`u16`参数：'
- en: '[PRE58]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Of course, this causes any construction of an `Instruction` object to construct
    a `Word` object inside of it, and every trait implemented by `Instruction` must
    be implemented also by `Word`. The `Copy` and `Clone` traits are implemented using
    default derivations.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会导致任何`Instruction`对象构造时在其内部构造一个`Word`对象，并且`Instruction`实现的每个特性和`Word`也必须实现。`Copy`和`Clone`特性使用默认派生实现。
- en: 'Instead, the `Debug` trait is implemented in the following way:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`Debug`特性以以下方式实现：
- en: '[PRE59]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The body of the `fmt` function writes three numbers—the whole argument (`self.0`),
    its low byte (`self.0 as u8`), and its high byte (`self.0 >> 8`). In this way,
    we get the desired formatting.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt`函数的主体写入三个数字——整个参数（`self.0`）、其低字节（`self.0 as u8`）和其高字节（`self.0 >> 8`）。这样我们就得到了期望的格式化。'
- en: '`Instruction` objects are created by the instruction parsers. So, these parsers
    must be changed, with respect to the project, `nom_byte_machine`. In that project,
    we saw that some parsers accept 16-bit numbers, such as this one:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`Instruction`对象是由指令解析器创建的。因此，根据项目`nom_byte_machine`，这些解析器必须进行更改。在那个项目中，我们看到了一些解析器接受16位数字，例如这个：'
- en: '[PRE60]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For all of these parsers, the use of the `le_u16` parser must be replaced with
    the use of the `le_word` parser, obtaining the following:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些解析器，必须将`le_u16`解析器的使用替换为`le_word`解析器的使用，从而得到以下结果：
- en: '[PRE61]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This parser is defined as follows:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解析器定义如下：
- en: '[PRE62]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It still calls the `le_u16` parser, but then it gets the generated `(input,
    output)` pair and encapsulates the `output` item in a `Word` object, obtaining
    an `(input, Word(output))` pair.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然调用`le_u16`解析器，但随后它获取生成的`(input, output)`对，并将`output`项封装在一个`Word`对象中，从而获得`(input,
    Word(output))`对。
- en: We have seen how to convert a machine language program into a kind of assembly
    code. That disassembled code is useful for debugging purposes, but it is not easy
    to change and reassemble it to generate a new machine language program. In the
    next section, we will look at another kind of disassembly code that is useful
    for assembling it again.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Generating disassembly code that is useful for reassembling
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regarding the other kind of output, `FOR ASSEMBLING`, we must examine the `disassembly_program`
    function, which is quite similar to the corresponding part of the `disassembly_program_for_debug`
    function. The only differences are the following:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: The program size is not emitted.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The format strings of the two `println` statements are `"{:5}: {}"`, instead
    of `"{:5}: {:?}"`.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this kind of format placeholder, the `Display` trait must be implemented
    by the `Instruction` type:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'For any variant, the `write` macro is used to emit the symbolic name of the
    instruction, followed by the formatted value of the byte or word. This formatting also requires
    the implementation of the `Display` trait for the arguments. Bytes are of the `u8` type,
    which already implements the `Display` trait. Instead, for words, the following
    declaration is required:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This simply produces the numeric value encapsulated in a `Word` object. So,
    we have seen how to transform a machine language program into two possible formats
    of disassembled text.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen another kind of disassembling. As an exercise, you should
    write an assembler for this machine language, run it on the code generated by
    this disassembler, and check that the resulting machine code is identical to the
    original one.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first defined an extremely simple toy machine language,
    and then a slightly more complex one to experiment with techniques of machine
    language manipulation.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: The first machine language defined assumes that memory is just a sequence of
    16-bit words and that any instruction is composed of two parts of one word each—an
    opcode and an operand. The second machine language assumes that memory is a sequence
    of bytes and some instructions can manipulate single bytes, while other instructions
    can manipulate whole words.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: This introduced the endianness issue, which concerns how to interpret two consecutive
    bytes as a word. As an example, the sieve of Eratosthenes algorithm was first written
    in Rust and then translated into both machine languages.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: For the first machine language, an interpreter was written without using any
    external library. It was used to first interpret a small number conversion program
    (`word_machine_convert`) and then the more complex sieve algorithm (`word_machine_sieve`).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: For the second machine language, three procedures were written in a single project
    (`nom_byte_machine`). All of these procedures used the `nom` parsing library.
    The first procedure was an instruction-by-instruction interpreter. The second
    procedure first parsed the whole program and then interpreted the parsed program.
    The third procedure translated the program into C language.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: For the second machine language, two kinds of disassemblers were built using
    the `nom` library (`nom_disassembler`)—one disassembler emitted output useful
    for debugging and the other emitted output useful for reassembling it after editing.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: So, after reading this chapter, you should now understand what a machine language
    is, what its corresponding assembly language is, how to translate assembly language
    into machine language and vice versa, how to translate machine language into C
    language, how to interpret machine language, and how to use the `nom` parsing
    library to carry out these tasks.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to create a Linux kernel module.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can a machine language emulator be useful?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the accumulator of a processor?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the instruction pointer of a processor?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it very difficult to write directly in machine language and, therefore,
    better to use an assembler?
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a Rust enum represent a machine language instruction?
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is little-endian notation and what is big-endian notation?
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a `nom` parser that accepts text and one that
    accepts binary data?
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which rules must be respected by a machine language program to be able to parse
    it all or to be able to translate it into another programming language?
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might different kinds of output, or a hexadecimal output format, be preferred
    for a disassembler?
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a single number be printed in different ways?
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
