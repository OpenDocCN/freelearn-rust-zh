- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Data Persistence with PostgreSQL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL 实现数据持久化
- en: By this point in the book, the frontend for our application has been defined,
    and our app is working at face value. However, we know that our app is reading
    and writing from a **JSON** file.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书的这一阶段，我们应用程序的前端已经定义，我们的应用程序在表面上运行良好。然而，我们知道我们的应用程序是从一个 **JSON** 文件中读取和写入的。
- en: In this chapter, we will get rid of our JSON file and introduce a `create`,
    `edit`, and `delete` endpoints interact with the database instead of the JSON
    file.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将放弃我们的 JSON 文件，并引入一个 `create`、`edit` 和 `delete` 端点来与数据库而不是 JSON 文件进行交互。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building our PostgreSQL database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的 PostgreSQL 数据库
- en: Connecting to PostgreSQL with Diesel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Diesel 连接到 PostgreSQL
- en: Connecting our application to PostgreSQL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的应用程序连接到 PostgreSQL
- en: Configuring our application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置我们的应用程序
- en: Managing a database connection pool
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数据库连接池
- en: By the end of this chapter, you will be able to manage an application that performs
    reading, writing, and deleting data in a PostgreSQL database with data models.
    If we make changes to the data models, we will be able to manage them with migrations.
    Once this is done, you will be able to optimize your database connections with
    pools and get the server to reject the HTTP request before it hits the view if
    the database connection cannot be made.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够管理一个应用程序，该应用程序使用数据模型在 PostgreSQL 数据库中执行读取、写入和删除数据。如果我们对数据模型进行更改，我们将能够通过迁移来管理它们。一旦完成这些操作，你将能够使用连接池优化你的数据库连接，并在无法建立数据库连接之前拒绝
    HTTP 请求。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be using **Docker** to define, run a PostgreSQL database,
    and run it. This will enable our app to interact with a database on our local
    machine. Docker can be installed by following the instructions at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 **Docker** 来定义、运行一个 PostgreSQL 数据库，并运行它。这将使我们的应用程序能够与本地机器上的数据库进行交互。可以通过遵循[https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)中的说明来安装
    Docker。
- en: We will also be using `docker-compose` on top of Docker to orchestrate our Docker
    containers. This can be installed by following the instructions at [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在 Docker 之上使用 `docker-compose` 来编排我们的 Docker 容器。可以通过遵循[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)中的说明来安装
    `docker-compose`。
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06)找到。
- en: Building our PostgreSQL database
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的 PostgreSQL 数据库
- en: Up to this point in the book, we have been using a JSON file to store our to-do
    items. This has served us well so far. In fact, there is no reason why we cannot
    use a JSON file throughout the rest of the book to complete the tasks. However,
    if you use a JSON file for production projects, you will come across some downsides.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书的这一阶段，我们一直在使用 JSON 文件来存储我们的待办事项。到目前为止，这已经很好地为我们服务了。事实上，我们没有理由在整个书中使用 JSON
    文件来完成任务。然而，如果你在生产项目中使用 JSON 文件，你将遇到一些缺点。
- en: Why we should use a proper database
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们应该使用合适的数据库
- en: If the reads and writes to our JSON file increase, we can face some concurrency
    issues and data corruption. There is also no checking on the type of data. Therefore,
    another developer can write a function that writes different data to the JSON
    file, and nothing will stand in the way.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对 JSON 文件的读写操作增加，我们可能会遇到一些并发问题和数据损坏。此外，也没有对数据类型进行检查。因此，另一个开发者可以编写一个将不同数据写入
    JSON 文件的功能，而没有任何阻碍。
- en: There is also an issue with migrations. If we want to add a timestamp to the
    to-do items, this will only affect new to-do items that we insert into the JSON
    file. Therefore, some of our to-do items will have a timestamp, and others won’t,
    which will introduce bugs into our app. Our JSON file also has limitations in
    terms of filtering.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移也存在一个问题。如果我们想给待办事项添加时间戳，这将只会影响我们插入到 JSON 文件中的新待办事项。因此，一些待办事项将具有时间戳，而另一些则不会，这将在我们的应用程序中引入错误。我们的
    JSON 文件在过滤方面也存在限制。
- en: Right now, all we do is read the whole data file, alter an item in the whole
    dataset, and write the whole dataset to the **JSON** file. This is not effective
    and will not scale well. It also inhibits us from linking these to-do items to
    another data model-like user. Plus, we can only search right now using the status.
    If we used a SQL database with a user table linked to a to-do item database, we
    would be able to filter to-do items based on the user, status, or title. We can
    even use a combination thereof. When it comes to running our database, we are
    going to use Docker. So why should we use Docker?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只是读取整个数据文件，修改整个数据集中的某个条目，并将整个数据集写入**JSON**文件。这并不有效，并且扩展性不好。它还阻碍了我们将这些待办事项与另一个数据模型（如用户）链接起来。此外，我们目前只能使用状态进行搜索。如果我们使用一个与待办事项数据库链接的用户表的SQL数据库，我们就能根据用户、状态或标题过滤待办事项。我们甚至可以使用它们的组合。当我们运行数据库时，我们将使用Docker。那么，为什么我们应该使用Docker呢？
- en: Why use Docker?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用Docker？
- en: To understand why we would use Docker, we first need to understand what Docker
    is. Docker essentially has containers that work like virtual machines but in a
    more specific and granular way. Docker containers isolate a single application
    and all the application’s dependencies. The application is run inside the Docker
    container. Docker containers can then communicate with each other. Because Docker
    containers share a single common **operating system** (**OS**), they are compartmentalized
    from one another and from the OS at large, meaning that Docker applications  use
    less memory compared to virtual machines. Because of Docker containers, we can
    be more portable with our applications. If the Docker container runs on your machine,
    it will run on another machine that also has Docker. We can also package our applications,
    meaning that extra packages specifically required for our application to run do
    not need to be installed separately, including dependencies on the OS level. As
    a result, Docker gives us great flexibility in web development as we can simulate
    servers and databases on our local machine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么我们会使用Docker，我们首先需要了解Docker是什么。Docker本质上具有像虚拟机一样工作的容器，但方式更加具体和细致。Docker容器隔离单个应用程序及其所有依赖项。应用程序在Docker容器内运行。然后，Docker容器可以相互通信。由于Docker容器共享单个公共**操作系统**（**OS**），它们彼此以及与整个操作系统隔离开来，这意味着Docker应用程序相比虚拟机使用更少的内存。由于Docker容器，我们可以使我们的应用程序更加便携。如果Docker容器在您的机器上运行，它也会在另一个安装了Docker的机器上运行。我们还可以打包我们的应用程序，这意味着不需要单独安装为我们的应用程序运行所必需的额外包，包括操作系统级别的依赖项。因此，Docker在Web开发中为我们提供了极大的灵活性，因为我们可以在本地机器上模拟服务器和数据库。
- en: How to use Docker to run a database
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用Docker运行数据库
- en: 'With all this in mind, it makes sense to go through the extra steps necessary
    to set up and run a SQL database. To do this, we are going to use Docker: a tool
    that helps us create and use containers. Containers themselves are Linux technology
    that package and isolate applications along with their entire runtime environment.
    Containers are technically isolated file systems, but to help visualize what we
    are doing in this chapter, you can think of them as mini lightweight virtual machines.
    These containers are made from images that can be downloaded from **Docker Hub**.
    We can insert our own code into these images before spinning up a container out
    of them, as seen in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，通过额外的步骤来设置和运行一个SQL数据库是有意义的。为此，我们将使用Docker：这是一个帮助我们创建和使用容器的工具。容器本身是Linux技术，它将应用程序及其整个运行时环境打包和隔离。容器在技术上是一个隔离的文件系统，但为了帮助可视化我们在本章中所做的工作，你可以把它们想象成迷你轻量级虚拟机。这些容器是由可以从**Docker
    Hub**下载的镜像构成的。在从这些镜像启动容器之前，我们可以将我们自己的代码插入到这些镜像中，如下面的图所示：
- en: '![Figure 6.1 – Relationship between Docker images and containers](img/Figure_6.1_B18722.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – Docker镜像和容器之间的关系](img/Figure_6.1_B18722.jpg)'
- en: Figure 6.1 – Relationship between Docker images and containers
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – Docker镜像和容器之间的关系
- en: 'With Docker, we can download an image, such as a PostgreSQL database, and run
    it in our development environment. Because of Docker, we can spin up multiple
    databases and apps and then shut them down as and when we need them. First, we
    need to take stock of our containers by running the following command in the terminal:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，我们可以下载一个镜像，例如PostgreSQL数据库，并在我们的开发环境中运行它。由于Docker，我们可以根据需要启动多个数据库和应用程序，然后关闭它们。首先，我们需要通过在终端运行以下命令来盘点我们的容器：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If Docker is a fresh install, we get the following output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Docker是全新安装，我们将得到以下输出：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see, we have no containers. We also need to take stock of our images.
    This can be done by running the following terminal command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们没有容器。我们还需要盘点我们的镜像。这可以通过运行以下终端命令来完成：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command gives the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令给出了以下输出：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, if Docker is a fresh install, then there will be no containers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果Docker是全新安装，那么将没有容器。
- en: 'There are other ways in which we can create a database in Docker. For instance,
    we can create our own `docker-compose` installed. Using `docker-compose` will
    make the database definition straightforward. It will also enable us to add more
    containers and services. To define our PostgreSQL database, we code the following
    `docker-compose.yml` file in the root directory:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过其他方式在Docker中创建数据库。例如，我们可以创建自己的已安装的`docker-compose`。使用`docker-compose`将使数据库定义变得简单。它还将使我们能够添加更多容器和服务。为了定义我们的PostgreSQL数据库，我们在根目录中编写以下`docker-compose.yml`文件：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, at the top of the file, we have defined the version.
    Older versions, such as *2* or *1*, have different styles in which the file is
    laid out. The different versions also support different arguments. At the time
    of writing this book, version *3* is the latest version. The following URL covers
    the changes between each `docker-compose` version: [https://docs.docker.com/compose/compose-file/compose-versioning/](https://docs.docker.com/compose/compose-file/compose-versioning/).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，文件顶部我们定义了版本。较老的版本，如*2*或*1*，在文件布局上具有不同的风格。不同的版本也支持不同的参数。在撰写本书时，版本*3*是最新的版本。以下URL涵盖了每个`docker-compose`版本之间的变化：[https://docs.docker.com/compose/compose-file/compose-versioning/](https://docs.docker.com/compose/compose-file/compose-versioning/).
- en: 'We then define our database service that is nested under the `postgres` tag.
    Tags such as `postgres` and `services` denote dictionaries, and lists are defined
    with `-` for each element. If we were to convert our `docker-compose` file to
    JSON, it would have the following structure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义嵌套在`postgres`标签下的数据库服务。如`postgres`和`services`之类的标签表示字典，列表使用`-`定义每个元素。如果我们把我们的`docker-compose`文件转换为JSON，它将具有以下结构：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we can see that our services are a dictionary of dictionaries
    denoting each service. Thus, we can deduce that we cannot have two tags with the
    same name, as we cannot have two dictionary keys that are the same. The previous
    code also tells us that we can keep stacking on service tags with their own parameters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们的服务是一个字典的字典，表示每个服务。因此，我们可以推断出我们不能有两个具有相同名称的标签，因为我们不能有两个相同的字典键。前面的代码还告诉我们，我们可以继续堆叠具有自己参数的服务标签。
- en: Running a database in Docker
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Docker中运行数据库
- en: With our database service, we have a name, so when we look at our containers,
    we know what each container is doing in relation to the service, such as a server
    or database. In terms of configuring the database and building it, we luckily
    pull the official `postgres` image. This image has everything configured for us,
    and Docker will pull it from the repository. The image is like a blueprint. We
    can spin up multiple containers with their own parameters from that one image
    that we pulled. We then define the restart policy as always. This means that containers’
    restart policies will trigger when the containers exit. We can also define it
    to only restart based on a failure or stopping.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的数据库服务，我们有一个名称，因此当我们查看我们的容器时，我们知道每个容器相对于服务（如服务器或数据库）正在做什么。在配置数据库和构建它方面，我们幸运地拉取了官方的`postgres`镜像。这个镜像为我们配置了一切，Docker会从仓库中拉取它。这个镜像就像一个蓝图。我们可以从这个我们拉取的一个镜像中启动多个具有自己参数的容器。然后我们定义重启策略为总是。这意味着当容器退出时，容器的重启策略将被触发。我们还可以将其定义为仅在失败或停止时重启。
- en: It should be noted that Docker containers have their own ports that are not
    open to the machine. However, we can expose container ports and map the exposed
    port to an internal port inside the Docker container. Considering these features,
    we can define our ports.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，Docker容器有自己的端口，这些端口对机器是关闭的。然而，我们可以公开容器的端口，并将公开的端口映射到Docker容器内部的内部端口。考虑到这些特性，我们可以定义我们的端口。
- en: 'However, in our example, we will keep our definition simple. We will state
    that we accept incoming traffic to the Docker container on port `5432` and route
    it through to the internal port `5432`. We will then define our environment variables,
    which are the username, the name of the database, and the password. While we are
    using generic, easy-to-remember passwords and usernames for this book, it is advised
    that you switch to more secure passwords and usernames if pushing to production.
    We can build a spin up for our system by navigating to the root directory where
    our `docker-compose` file is by running the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的例子中，我们将保持我们的定义简单。我们将声明我们接受端口`5432`上进入Docker容器的流量，并将其路由到内部端口`5432`。然后我们将定义我们的环境变量，包括用户名、数据库名称和密码。虽然我们在这本书中使用的是通用、易于记忆的密码和用户名，但如果要推送到生产环境，建议您切换到更安全的密码和用户名。我们可以通过运行以下命令来构建和启动我们的系统，该命令将我们的`docker-compose`文件所在的根目录：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding command will pull down the `postgres` image from the repository
    and start constructing the database. After a flurry of log messages, the terminal
    should come to rest with the following output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将从存储库中拉取`postgres`镜像并开始构建数据库。在一系列日志消息之后，终端应该显示以下输出：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the date and time will vary. However, what we are told here
    is that our database is ready to accept connections. Yes, it is really that easy.
    Therefore, Docker adoption is unstoppable. Clicking *Ctrl* + *C* will stop our
    `docker-compose`; thus, shutting down our `postgres` container.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，日期和时间会变化。然而，这里告诉我们的是我们的数据库已经准备好接受连接。是的，这真的很简单。因此，Docker的采用是不可避免的。点击*Ctrl*
    + *C*将停止我们的`docker-compose`；从而关闭我们的`postgres`容器。
- en: 'We now list all our containers with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用以下命令列出所有我们的容器：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding command gives us the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令给出了以下输出：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding output, we can see that all the parameters are there. The ports,
    however, are empty because we stopped our service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到所有参数都在那里。然而，端口却是空的，因为我们已经停止了我们的服务。
- en: Exploring routing and ports in Docker
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Docker中的路由和端口
- en: 'If we were to start our service again and list our containers in another terminal,
    port `5432` would be under the `PORTS` tag. We must keep note of the `CONTAINER
    ID` reference to the Docker container as it will be unique and different/random
    for each container. We will need to reference these if we’re accessing logs. When
    we run `docker-compose up`, we essentially use the following structure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次启动我们的服务并在另一个终端中列出我们的容器，端口`5432`将位于`PORTS`标签下。我们必须注意`CONTAINER ID`对Docker容器的引用，因为它是唯一的，对于每个容器都是不同的/随机的。如果我们需要访问日志，我们需要引用这些。当我们运行`docker-compose
    up`时，我们实际上使用以下结构：
- en: "![Figure 6.2 – \uFEFFdocker-compose serving our database](img/Figure_6.2_B18722.jpg)"
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – docker-compose服务我们的数据库](img/Figure_6.2_B18722.jpg)'
- en: Figure 6.2 – docker-compose serving our database
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – docker-compose服务我们的数据库
- en: 'In *Figure 6**.2*, we can see that our `docker-compose` uses a unique project
    name to keep containers and networks in their namespace. It must be noted that
    our containers are running on the localhost. Therefore, if we want to make a call
    to a container managed by `docker-compose`, we will have to make a localhost request.
    However, we must make the call to the port that is open from `docker-compose`,
    and `docker-compose` will route it to the port that is defined in the `docker-compose`.`yml`
    file. For instance, we have two databases with the following `yml` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图6.2*中，我们可以看到我们的`docker-compose`使用一个独特的项目名称来保持容器和网络在其命名空间中。必须注意的是，我们的容器正在本地主机上运行。因此，如果我们想调用由`docker-compose`管理的容器，我们必须发起一个本地主机请求。然而，我们必须调用`docker-compose`开放的端口，`docker-compose`会将它路由到`docker-compose`.`yml`文件中定义的端口。例如，我们有两个数据库，以下是一个`yml`文件：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we can see that both of our databases accept traffic
    into their containers through port `5432`. However, there would be a clash, so
    one of the ports that we open with is port `5433`, which is routed to port `5432`
    in the second database container, which gives us the following layout:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们的两个数据库都通过端口`5432`接受进入其容器的流量。然而，会有冲突，所以我们打开的端口之一是端口`5433`，它被路由到第二个数据库容器的端口`5432`，这给我们以下布局：
- en: '![Figure 6.3 – docker-compose serving multiple databases](img/Figure_6.3_B18722.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – docker-compose服务多个数据库](img/Figure_6.3_B18722.jpg)'
- en: Figure 6.3 – docker-compose serving multiple databases
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – docker-compose服务多个数据库
- en: 'This routing gives us flexibility when running multiple containers. We are
    not going to run multiple databases for our to-do application, so we should delete
    our `postgres_two` service. Once we have deleted our `postgres_two` service, we
    can run `docker-compose` again and then list our containers with the following
    command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种路由在运行多个容器时给我们提供了灵活性。我们不会为我们的待办事项应用运行多个数据库，因此我们应该删除我们的`postgres_two`服务。一旦我们删除了`postgres_two`服务，我们就可以再次运行`docker-compose`，然后使用以下命令列出我们的容器：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding command will now give us the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令现在将给出以下输出：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding output, we can see that our image has been pulled from the
    `postgres` repository. We also have a unique/random ID for the image and a date
    for when that image was created.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到我们的镜像是从`postgres`仓库拉取的。我们还有一个为该镜像生成的唯一/随机ID，以及该镜像创建的日期。
- en: 'Now that we have a basic understanding of how to get our database up and running,
    we can run `docker-compose` in the background with the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了如何让我们的数据库启动并运行，我们可以使用以下命令在后台运行`docker-compose`：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command just tells us which containers have been spun up with
    the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令只是告诉我们哪些容器已经被启动，以下为输出：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can see our status when we list our containers with the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下输出查看我们的状态：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the previous output, the other tags are the same, but we can also see that
    the `STATUS` tag tells us how long the container has been running, and which port
    it is occupying. Although `docker-compose` is running in the background, it does
    not mean we cannot see what is going on. We can access the logs of the container
    anytime by calling the `logs` command and referencing the ID of the container
    using the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，其他标签都是相同的，但我们还可以看到`STATUS`标签告诉我们容器运行了多长时间，以及它占用了哪个端口。尽管`docker-compose`在后台运行，但这并不意味着我们无法看到正在发生的事情。我们可以通过调用`logs`命令并使用以下命令引用容器的ID来随时访问容器的日志：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding command should give the same output as our standard `docker-compose
    up` command. To stop `docker-compose`, we can run the `stop` command, shown as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应该给出与我们的标准`docker-compose up`命令相同的输出。要停止`docker-compose`，我们可以运行`stop`命令，如下所示：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding command will stop our containers in our `docker-compose`. It
    must be noted that this is different from the `down` command, shown as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将停止我们的`docker-compose`中的容器。必须注意的是，这与下面的`down`命令不同：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `down` command will also stop our containers. However, the `down` command
    will delete the container. If our database container is deleted, we will also
    lose all our data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`down`命令也会停止我们的容器。然而，`down`命令会删除容器。如果我们的数据库容器被删除，我们也会丢失所有数据。'
- en: There is a configuration parameter called `volumes` that can prevent the deletion
    of our data when the container is removed; however, this is not essential for
    local development on our computers. In fact, you will be wanting to delete containers
    and images from your laptop regularly. *I did a purge on my laptop once of containers
    and images that I was no longer using, and this freed* *up 23GB!*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`volumes`的配置参数可以在容器删除时防止我们的数据被删除；然而，这对于我们在计算机上的本地开发并不是必需的。实际上，你可能会想要定期从你的笔记本电脑上删除容器和镜像。*我曾在我的笔记本电脑上执行了一次删除不再使用的容器和镜像的操作，这释放了*
    *23GB!*
- en: Docker containers on our local development machines should be treated as temporary.
    While Docker containers are more lightweight than standard virtual machines, they
    are not free. The idea behind Docker running on our local machines is that we
    can simulate what running our application would be like on a server. If it runs
    in Docker on our laptop, we can be certain that it will also run on our server,
    especially if the server is being managed by a production-ready Docker orchestration
    tool such as **Kubernetes**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的本地开发机器上的Docker容器应该被视为临时的。虽然Docker容器比标准虚拟机更轻量级，但它们并不是免费的。Docker在我们本地机器上运行背后的想法是，我们可以模拟在服务器上运行我们的应用程序的情况。如果它在我们的笔记本电脑上的Docker中运行，我们可以确信它也会在我们的服务器上运行，特别是如果服务器是由一个生产就绪的Docker编排工具（如**Kubernetes**）管理的。
- en: Running Docker in the background with Bash scripts
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Bash脚本在后台运行Docker
- en: Docker can also help with consistent testing and development. We will want to
    be able to have the same results every time we run a test. We will also want to
    onboard other developers easily and enable them to tear down and spin up containers
    that will support development quickly and easily. I have personally seen development
    delayed when not supporting easy teardown and spin-up procedures. For instance,
    when working on a complex application, the code that we are adding and testing
    out might scar the database. Reverting back might not be possible, and deleting
    the database and starting again would be a pain, as reconstructing this data might
    take a long time. The developer may not even remember how they constructed the
    data in the first place. There are multiple ways to prevent this from happening
    and we will cover these in [*Chapter 9*](B18722_09.xhtml#_idTextAnchor182), *Testing
    Our Application Endpoints and Components*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还可以帮助进行一致的测试和开发。我们希望每次运行测试时都能得到相同的结果。我们还希望能够轻松地让其他开发者入职，并使他们能够快速、轻松地关闭和启动容器以支持开发。我个人看到，如果不支持简单的关闭和启动程序，开发可能会被推迟。例如，当处理复杂的应用程序时，我们添加并测试的代码可能会损坏数据库。回滚可能不可行，删除数据库并重新开始将是一件痛苦的事情，因为重建这些数据可能需要很长时间。开发者甚至可能不记得最初是如何构建这些数据的。有多种方法可以防止这种情况发生，我们将在[*第9章*](B18722_09.xhtml#_idTextAnchor182)中介绍，*测试我们的应用程序端点和组件*。
- en: 'For now, we will build a script that spins up our database in the background,
    waits until the connection to our database is ready, and then tears down our database.
    This will give us the foundations to build pipelines, tests, and onboarding packages
    to start development. To do this, we will create a directory in the root directory
    of our Rust web application called `scripts`. We can then create a `scripts/wait_for_database.sh`
    file housing the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建一个脚本，在后台启动我们的数据库，等待直到数据库连接就绪，然后关闭我们的数据库。这将为我们构建管道、测试和入职包以开始开发奠定基础。为此，我们将在Rust
    Web应用的根目录中创建一个名为`scripts`的目录。然后我们可以创建一个`scripts/wait_for_database.sh`文件，包含以下代码：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using the preceding code, we move the current working directory of the script
    out of the `scripts` directory and into our root directory. We then start `docker-compose`
    in the background. Next, we loop, pinging port `5432` utilizing the `pq_isready`
    command to wait until our database is ready to accept connections.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们将脚本的当前工作目录从`scripts`目录移动到我们的根目录。然后我们在后台启动`docker-compose`。接下来，我们循环，通过使用`pq_isready`命令ping端口`5432`，等待直到我们的数据库准备好接受连接。
- en: Important note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: 'The `pg_isready` Bash command might not be available on your computer. The
    `pg_isready` command usually comes with the installation of the PostgreSQL client.
    Alternatively, you can use the following Docker command instead of `pg_isready`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`pg_isready` Bash命令可能不在您的计算机上可用。`pg_isready`命令通常与PostgreSQL客户端的安装一起提供。或者，您可以使用以下Docker命令代替`pg_isready`：'
- en: '`until docker run -it postgres --add-host host.docker.internal:host-gateway
    docker.io/postgres:14-alpine -h localhost -U` `username pg_isready`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`until docker run -it postgres --add-host host.docker.internal:host-gateway
    docker.io/postgres:14-alpine -h localhost -U` `username pg_isready`'
- en: What is happening here is that we are using the `postgres` Docker image to run
    our database check to ensure that our database is ready to accept connections.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，我们正在使用`postgres` Docker镜像来运行我们的数据库检查，以确保我们的数据库已准备好接受连接。
- en: 'Once our database is running, we print out to the console that our database
    is running and then tear down our `docker-compose`, destroying the database container.
    Running the command that runs the `wait_for_database.sh` Bash script will give
    the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的数据库启动后，我们在控制台打印出我们的数据库正在运行，然后关闭我们的`docker-compose`，销毁数据库容器。运行执行`wait_for_database.sh`
    Bash脚本的命令将给出以下输出：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From the preceding output, considering that we tell our loop to sleep for 2
    seconds at every iteration of the loop, we can deduce that it took roughly 4 seconds
    for our newly spun-up database to accept connections. Thus, we can say that we
    have achieved basic competency in managing local databases with Docker.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，考虑到我们告诉循环在每次迭代中暂停2秒，我们可以推断出我们的新启动的数据库接受连接大约需要4秒钟。因此，我们可以说我们已经掌握了使用Docker管理本地数据库的基本技能。
- en: In this section, we set up our environment. We also sufficiently understood
    the basics of Docker to build, monitor, shut down, and delete our database with
    just a few simple commands. Now, we can move on to the next section, where we’ll
    interact with our database with Rust and the `diesel` crate.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们设置了我们的环境。我们也充分理解了Docker的基本知识，只需几个简单的命令就能构建、监控、关闭和删除我们的数据库。现在，我们可以继续到下一节，我们将使用Rust和`diesel`
    crate与我们的数据库进行交互。
- en: Connecting to PostgreSQL with Diesel
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Diesel连接到PostgreSQL
- en: 'Now that our database is running, we will build a connection to this database
    in this section. To do this, we will be using the `diesel` crate. The `diesel`
    crate enables us to get our Rust code to connect to databases. We are using the
    `diesel` crate instead of other crates because the `diesel` crate is the most
    established, having a lot of support and documentation. To do this, let us go
    through the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据库正在运行，我们将在本节中构建与该数据库的连接。为此，我们将使用`diesel` crate。`diesel` crate使我们能够使我们的Rust代码连接到数据库。我们使用`diesel`
    crate而不是其他crate，因为`diesel` crate是最成熟的，拥有大量的支持和文档。为此，让我们按照以下步骤进行：
- en: 'First, we will utilize the `diesel` crate. To do this, we can add the following
    dependencies in our `cargo.toml` file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将利用`diesel` crate。为此，我们可以在`cargo.toml`文件中添加以下依赖项：
- en: '[PRE21]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we have included a `postgres` feature in our `diesel`
    crate. The `diesel` crate definition also has the `chrono` and `r2d2` features.
    The `chrono` feature enables our Rust code to utilize datetime structs. The `r2d2`
    feature enables us to perform connection pooling. We will cover connection pooling
    at the end of the chapter. We have also included the `dotenv` crate. This crate
    enables us to define variables in a `.env` file, which will then be passed through
    into our program. We will use this to pass in the database credentials and then
    into processes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`diesel` crate中包含了`postgres`功能。`diesel` crate的定义还包括了`chrono`和`r2d2`功能。`chrono`功能使我们的Rust代码能够利用datetime结构体。`r2d2`功能使我们能够执行连接池。我们将在本章末尾介绍连接池。我们还包含了`dotenv`
    crate。这个crate使我们能够在`.env`文件中定义变量，这些变量随后将被传递到我们的程序中。我们将使用它来传递数据库凭据，然后传递到进程中。
- en: 'We now need to install the `diesel` client to run migrations to the database
    through our terminal as opposed to our app. We can do this with the following
    command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要安装`diesel`客户端，以便通过我们的终端而不是应用程序运行迁移到数据库。我们可以使用以下命令来完成：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now need to define the environment `DATABASE_URL` URL. This will enable
    our client commands to connect to the database with the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要定义环境变量`DATABASE_URL` URL。这将使我们的客户端命令能够使用以下命令连接到数据库：
- en: '[PRE28]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding URL, our username is denoted as username, and our password
    is denoted as password. Our database is running on our own computer, which is
    denoted as `localhost`, and our database is called `to_do`. This creates a `.env`
    file in the root file outputting the following contents:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的URL中，我们的用户名表示为username，密码表示为password。我们的数据库运行在我们的计算机上，表示为`localhost`，我们的数据库名为`to_do`。这将在根目录中创建一个`.env`文件，输出以下内容：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that our variables are defined, we can start to set up our database. We
    need to spin up our database container with `docker-compose` with our `docker-compose
    up` command. We then set up our database with the following command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了变量，我们可以开始设置我们的数据库。我们需要使用`docker-compose up`命令启动我们的数据库容器。然后，我们使用以下命令设置我们的数据库：
- en: '[PRE31]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding command then creates a `migrations` directory in the root with
    the following structure:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令在根目录中创建了一个`migrations`目录，其结构如下：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `up.sql` file is fired when the migration is upgraded, and the `down.sql`
    file is fired when the migration is downgraded.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当迁移升级时，会触发`up.sql`文件，而当迁移降级时，会触发`down.sql`文件。
- en: 'Now, we need to create our migration to create our to-do items. This can be
    done by commanding our client to generate the migration with the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建我们的迁移来创建我们的待办事项。这可以通过命令我们的客户端使用以下命令生成迁移来完成：
- en: '[PRE33]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once this is run, we should get the following printout in the console:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，我们应在控制台获得以下输出：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding command gives us the following file structure in our migrations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令在我们的迁移中给出了以下文件结构：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At face value, it might seem unfortunate that with the `diesel` crate, we will
    have to create our own SQL files. However, this is forcing good practice. While
    it is easier to allow the crate to automatically write the SQL, this couples our
    application with the database. For instance, once I was working on refactoring
    a microservices system. The problem I had was that I was using a Python package
    to manage all my migrations for the database. However, I wanted to change the
    code of the server. You will not be surprised to hear that I was going to switch
    the server from Python to Rust. However, because the migrations were autogenerated
    by the Python library, I had to construct helper Docker containers that, to this
    day, spin up when a new release is done and then perform a copy of the schema
    of the database to the Rust application when it is being built. This is messy.
    This also justified to me why we had to write all our SQL manually when I was
    an R&D software engineer in financial tech.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从字面上看，使用`diesel`包，我们可能觉得不得不创建自己的SQL文件可能是不幸的。然而，这迫使我们养成良好的习惯。虽然允许包自动编写SQL代码更容易，但这会将我们的应用程序与数据库耦合起来。例如，我曾经在重构一个微服务系统时工作。我遇到的问题是，我正在使用一个Python包来管理所有数据库迁移。然而，我想更改服务器的代码。你不会感到惊讶，我将服务器从Python切换到Rust。然而，因为迁移是由Python库自动生成的，我不得不构建辅助Docker容器，这些容器至今仍在每次发布新版本时启动，并在构建过程中将数据库模式复制到Rust应用程序中。这是很混乱的。这也解释了为什么当我作为金融科技研发软件工程师时，我们必须手动编写所有SQL代码的原因。
- en: 'Databases are separate from our applications. Because of this, we should keep
    them isolated, so we do not see the writing of SQL manually as a hindrance. Embrace
    it as you are learning a good skill that will save you headaches in the future.
    We must remember not to force one tool into everything, it has to be the right
    tool for the right job. In our `create to-do items` migrations folder, we define
    our `to_do` table with the following SQL entries in our `up.sql` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库与我们的应用程序是分开的。正因为如此，我们应该将它们隔离，这样我们就不会把手动编写SQL代码看作是一种阻碍。在学习一项将为你未来节省头痛的好技能时，要接受它。我们必须记住不要强迫一个工具适用于所有事情，它必须是适合正确工作的正确工具。在我们的`create
    to-do items`迁移文件夹中，我们在`up.sql`文件中定义我们的`to_do`表，使用以下SQL条目：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding code, we have an `id` of the item that will be unique. We
    then have `title` and `status`. We have also added a `date` field that, by default,
    has the current time the to-do item is inserted into the table. These fields are
    wrapped in a `CREATE TABLE` command. In our `down.sql` file, we need to drop the
    table if we are downgrading the migration with the following SQL command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个唯一的`id`字段，然后是`title`和`status`。我们还添加了一个`date`字段，默认情况下，该字段包含将待办事项插入表中的当前时间。这些字段被包含在一个`CREATE
    TABLE`命令中。在我们的`down.sql`文件中，如果我们正在降级迁移，我们需要使用以下SQL命令来删除表：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that we have written the SQL code for our `up.sql` and `down.sql` files,
    we can describe what our code does with the following diagram:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的`up.sql`和`down.sql`文件编写了SQL代码，我们可以用以下图表来描述我们的代码做了什么：
- en: '![Figure 6.4 – The effect of the up.sql and down.sql scripts](img/Figure_6.4_B18722.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – up.sql和down.sql脚本的效果](img/Figure_6.4_B18722.jpg)'
- en: Figure 6.4 – The effect of the up.sql and down.sql scripts
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – up.sql和down.sql脚本的效果
- en: 'Now that our migration is ready, we can run it with the following terminal
    command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了迁移，我们可以使用以下终端命令来运行它：
- en: '[PRE38]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding command runs the migration creating the `to_do` table. Sometimes,
    we might introduce a different field type in the SQL. To rectify this, we can
    change SQL in our `up.sql` and `down.sql` files and run the following `redo` terminal
    command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将运行迁移，创建`to_do`表。有时，我们可能在SQL中引入不同的字段类型。为了纠正这一点，我们可以在`up.sql`和`down.sql`文件中更改SQL，并运行以下`redo`终端命令：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding command will run the `down.sql` file and then run the `up.sql`
    file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将运行`down.sql`文件，然后运行`up.sql`文件。
- en: 'Next, we can run commands in our database Docker container to inspect that
    our database has the `to_do` table with the right fields that we defined. We can
    do this by running commands directly on our database Docker container. We can
    enter the container under the `username` username, while pointing to the `to_do`
    database using the following terminal command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以在我们的数据库Docker容器中运行命令来检查我们的数据库是否具有我们定义的正确字段的`to_do`表。我们可以通过在数据库Docker容器上直接运行命令来实现这一点。我们可以使用以下终端命令进入容器，使用`username`用户名，同时指向`to_do`数据库：
- en: '[PRE40]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It must be noted that, in the preceding command, my container ID is `5fdeda6cfe43`,
    but your container ID will be different. If you do not input the right container
    ID, you will not be running the right database commands on the right database.
    After running this command, we get a shell interface with the following prompt:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，在前面的命令中，我的容器ID是`5fdeda6cfe43`，但你的容器ID将不同。如果你没有输入正确的容器ID，你将不会在正确的数据库上运行正确的数据库命令。运行此命令后，我们得到一个具有以下提示的shell界面：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After the preceding prompt, when we type in `\c`, we will be connected to the
    database. This will usually be denoted with a statement saying that we are now
    connected to the `to_do` database and as the `username` user. Finally, typing
    `\d` will list the relations, giving the following table in the terminal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的提示之后，当我们输入`\c`时，我们将连接到数据库。这通常会用一条语句表示我们现在已连接到`to_do`数据库并以`username`用户身份连接。最后，输入`\d`将列出关系，在终端中显示以下表：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: From the preceding table, we can see that there is a migrations table to keep
    track of the migration version of the database.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的表中，我们可以看到有一个迁移表来跟踪数据库的迁移版本。
- en: 'We also have our `to_do` table and the sequence for the `to_do` item IDs. To
    inspect the schema, all we need to do is type in `\d+ to_do`, which gives us the
    following schema in the terminal:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有一个`to_do`表格和`to_do`项ID的序列。要检查模式，我们只需要输入`\d+ to_do`，在终端中会得到以下模式：
- en: '[PRE43]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding table, we can see that our schema is exactly how we designed
    it. We get a little more information in the `date` column clarifying that we do
    not get the time the to-do item was created. Seeing as our migrations have worked,
    we should explore how migrations show up in the database in the next step.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，我们可以看到我们的模式与我们设计的完全一致。我们在`date`列中得到了更多一点的信息，明确指出我们没有得到待办事项创建的时间。鉴于我们的迁移已经成功，我们应该在下一步探索迁移如何在数据库中显示。
- en: 'We can inspect our migrations table by running the following SQL command:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下SQL命令来检查我们的迁移表：
- en: '[PRE58]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding command gives us the following table as output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令给出了以下表作为输出：
- en: '[PRE59]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you can see, these migrations can be useful for debugging as sometimes we
    can forget to run a migration after updating a data model. To explore this further,
    we can revert our last migration with the following command outside the Docker
    container:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些迁移对于调试很有用，因为有时我们可能会忘记在更新数据模型后运行迁移。为了进一步探索，我们可以在Docker容器外部使用以下命令回滚我们的最后一个迁移：
- en: '[PRE60]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We then get the following printout informing us that the rollback has been
    performed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到以下打印输出，告知我们已执行回滚操作：
- en: '[PRE61]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now that our migration has been rolled back, our migrations table will look
    like the following printout:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回滚了迁移，我们的迁移表将如下所示：
- en: '[PRE62]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding printout, we can see that our last migration was removed. Therefore,
    we can deduce that the migrations table is not a log. It only keeps track of migrations
    that are currently active. The tracking of the migrations will aid the `diesel`
    client when running a migration to run the right migration.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的打印输出中，我们可以看到我们的最后一个迁移已被移除。因此，我们可以推断迁移表不是一个日志。它只跟踪当前活动的迁移。迁移的跟踪将帮助`diesel`客户端在运行迁移时执行正确的迁移。
- en: In this section, we have used the `diesel` client to connect to our database
    in a Docker container. We then defined the database URL in an environment file.
    Next, we initialized some migrations and created a table in our database. Even
    better, we directly connected with the Docker container, where we could run a
    range of commands to explore our database. Now that our database is fully interactive
    via our client in the terminal, we can start building our `to-do` item database
    models so that our Rust app can interact with our database.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用`diesel`客户端连接到Docker容器中的数据库。然后我们在环境文件中定义了数据库URL。接下来，我们初始化了一些迁移并在数据库中创建了一个表。更好的是，我们直接连接到了Docker容器，在那里我们可以运行一系列命令来探索我们的数据库。现在，我们的数据库通过终端中的客户端完全交互式，我们可以开始构建我们的`to-do`项数据库模型，以便我们的Rust应用程序可以与数据库交互。
- en: Connecting our app to PostgreSQL
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的应用程序连接到PostgreSQL
- en: 'In the preceding section, we managed to connect to the PostgreSQL database
    using the terminal. However, we now need our app to manage the reading and writing
    to the database for our to-do items. In this section, we will connect our application
    to the database running in Docker. To connect, we must build a function that establishes
    a connection and then returns it. It must be stressed that there is a better way
    to manage the database connection and configuration, which we will cover at the
    end of the chapter. For now, we will implement the simplest database connection
    to get our application running. In the `src/database.rs` file, we define the function
    with the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们成功使用终端连接到 PostgreSQL 数据库。然而，我们现在需要我们的应用程序管理待办事项的数据库读写操作。在本节中，我们将我们的应用程序连接到在
    Docker 中运行的数据库。为了连接，我们必须构建一个建立连接并返回它的函数。必须强调的是，管理数据库连接和配置有更好的方法，我们将在本章末尾介绍。现在，我们将实现最简单的数据库连接以使我们的应用程序运行。在
    `src/database.rs` 文件中，我们使用以下代码定义函数：
- en: '[PRE63]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding code, first of all, you might notice the `use diesel::prelude::*;`
    import command. This command imports a range of connection, expression, query,
    serialization, and result structs. Once the required imports are done, we define
    the `connection` function. First of all, we need to ensure that the program will
    not throw an error if we fail to load the environment using the `dotenv().();`
    command.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，你可能注意到 `use diesel::prelude::*;` 导入命令。此命令导入了连接、表达式、查询、序列化和结果结构体的一系列。一旦完成所需的导入，我们定义
    `connection` 函数。首先，我们需要确保程序在无法使用 `dotenv().();` 命令加载环境时不会抛出错误。
- en: Once this is done, we get our database URL from the environment variables and
    establish a connection using a reference to our database URL. We then `unwrap`
    the result, and we might panic displaying the database URL if we do not manage
    to do this, as we want to ensure that we are using the right URL with the right
    parameters. As the connection is the final statement in the function, this is
    what is returned.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们从环境变量中获取数据库 URL 并使用数据库 URL 的引用建立连接。然后我们 `unwrap` 结果，如果我们无法做到这一点，我们可能会恐慌地显示数据库
    URL，因为我们想确保我们使用的是正确的 URL 和正确的参数。由于连接是函数中的最后一个语句，这就是返回的内容。
- en: 'Now that we have our own connection, we need to define the schema. This will
    map the variables of the `to-do` items to the data types. We can define our schema
    in the `src/schema.rs` file with the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了自己的连接，我们需要定义模式。这将把 `to-do` 项的变量映射到数据类型。我们可以在 `src/schema.rs` 文件中使用以下代码定义我们的模式：
- en: '[PRE64]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding code, we are using the `diesel` macro, `table!`, which specifies
    that a table exists. This map is straightforward, and we will use this schema
    in the future to reference columns and the table in database queries and inserts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `diesel` 宏 `table!`，它指定了一个表的存在。这个映射很简单，我们将在未来的数据库查询和插入中引用列和表使用此模式。
- en: 'Now that we have built our database connection and defined a schema, we must
    declare them in our `src/main.rs` file with the following imports:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了数据库连接并定义了模式，我们必须在 `src/main.rs` 文件中声明它们，如下所示：
- en: '[PRE65]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding code, our first import also enables procedural macros. If we
    do not use the `#[macro_use]` tag, then we will not be able to reference our schema
    in our other files. Our schema definition would also would not be able to use
    the table macro. We also import the `dotenv` crate. We keep the modules that we
    created in [*Chapter 5*](B18722_05.xhtml#_idTextAnchor091), *Displaying Content
    in the Browser*. We also define our schema and database modules. After doing this,
    we have all we need to start building our data models.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们的第一个导入还启用了过程宏。如果我们不使用 `#[macro_use]` 标签，那么我们无法在其他文件中引用我们的模式。我们的模式定义也无法使用表宏。我们还导入了
    `dotenv` crate。我们保留了在 [*第 5 章*](B18722_05.xhtml#_idTextAnchor091) 中创建的模块，*在浏览器中显示内容*。我们还定义了我们的模式和数据库模块。完成这些后，我们就需要开始构建我们的数据模型了。
- en: Creating our data models
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的数据模型
- en: 'We will use our data models to define parameters and behavior around the data
    from the database in Rust. They essentially act as a bridge between the database
    and the Rust app, as depicted in the following diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的数据模型在 Rust 中定义数据库数据的参数和行为。它们本质上充当数据库和 Rust 应用程序之间的桥梁，如下面的图所示：
- en: '![Figure 6.5 – The relationship between models, schemas, and databases](img/Figure_6.5_B18722.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 模型、模式和数据库之间的关系](img/Figure_6.5_B18722.jpg)'
- en: Figure 6.5 – The relationship between models, schemas, and databases
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 模型、模式和数据库之间的关系
- en: 'In this section, we will define the data models for to-do items. However, we
    need to enable our app to add more data models if needed. To do this, we carry
    out the following steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义待办事项的数据模型。然而，我们需要使我们的应用程序能够根据需要添加更多数据模型。为此，我们执行以下步骤：
- en: We define a new to-do item data model struct.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个新的待办事项数据模型结构体。
- en: Then, we define a constructor function for the new to-do item structs.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为新的待办事项结构体定义了一个构造函数。
- en: And lastly, we define a to-do item data model struct.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个待办事项数据模型结构体。
- en: 'Before we start writing any code, we define the following file structure in
    the `src` directory as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写任何代码之前，我们在`src`目录中定义了以下文件结构，如下所示：
- en: '[PRE66]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the preceding structure, each data model has a directory in the `models`
    directory. Inside that directory, we have two files that define the model. One
    for a new insert and another for managing the data around the database. The new
    insert data model does not have an ID field.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述结构中，每个数据模型在`models`目录下都有一个目录。在该目录内，我们有两个文件定义了模型。一个用于新的插入，另一个用于管理数据库周围的数据。新的插入数据模型没有ID字段。
- en: 'There is no ID field because the database will assign an ID to the item; we
    do not define it before. However, when we interact with items in the database,
    we will get their ID, and we may want to filter by ID. Therefore, the existing
    data item model houses an ID field. We can define our new item data model in the
    `new_item.rs` file with the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 没有ID字段，因为数据库将为项目分配一个ID；我们不会在之前定义它。然而，当我们与数据库中的项目交互时，我们将得到它们的ID，我们可能想按ID进行筛选。因此，现有的数据项模型包含一个ID字段。我们可以在`new_item.rs`文件中用以下代码定义我们的新项目数据模型：
- en: '[PRE67]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see in the preceding code, we import our table definition because
    we are going to reference it. We then define our new item with `title` and `status`,
    which are to be strings. The `chrono` crate is used to define our `date` field
    as `NaiveDateTime`. We then use a `diesel` macro to define the table to belong
    to this struct at the `"to_do"` table. Do not be fooled by the fact that this
    definition uses quotation marks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们导入我们的表定义，因为我们将要引用它。然后我们使用`title`和`status`定义我们的新项目，它们应该是字符串类型。`chrono`库用于定义我们的`date`字段为`NaiveDateTime`。然后我们使用`diesel`宏定义表属于此结构体的`"to_do"`表。不要被这个定义使用引号的事实所迷惑。
- en: If we do not import our schema, the app will not compile because it will not
    understand the reference. We also add another `diesel` macro stating that we allow
    the data to be inserted into the database with the `Insertable` tag. As covered
    before, we are not going to add any more tags to this macro because we only want
    this struct to insert data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不导入我们的模式，应用程序将无法编译，因为它将无法理解引用。我们还添加了另一个`diesel`宏，声明我们允许使用`Insertable`标签将数据插入数据库。如前所述，我们不会向此宏添加任何更多标签，因为我们只想让这个结构体插入数据。
- en: We have also added a `new` function to enable us to define standard rules around
    creating a new struct. For instance, we are only going to be creating new items
    that are pending. This reduces the risk of a rogue status being created. If we
    want to expand later, the `new` function could accept a `status` input and run
    it through a match statement, throwing an error if the status is not one of the
    statuses that we are willing to accept. We also automatically state that the `date`
    field is the date that we create the item.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`new`函数，使我们能够定义创建新结构的标准规则。例如，我们只将创建待处理状态的新项目。这减少了创建恶意状态的风险。如果我们想以后扩展，`new`函数可以接受一个`status`输入，并通过匹配语句运行它，如果状态不是我们愿意接受的状态之一，则抛出错误。我们还自动声明`date`字段是创建项目的日期。
- en: 'With this in mind, we can define our item data model in the `item.rs` file
    with the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，我们可以在`item.rs`文件中定义我们的项目数据模型，如下所示：
- en: '[PRE68]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As you can see in the preceding code, the only difference between the `NewItem`
    and `Item` struct is that we do not have a constructor function; we have swapped
    the `Insertable` tag for `Queryable` and `Identifiable`, and we have added an
    `id` field to the struct. To make these available to the rest of the application,
    we define them in the `models/item/mod.rs` file with the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`NewItem`和`Item`结构体之间的唯一区别是我们没有构造函数；我们将`Insertable`标签替换为`Queryable`和`Identifiable`，并在结构体中添加了一个`id`字段。为了使这些对应用程序的其余部分可用，我们在`models/item/mod.rs`文件中定义了以下代码：
- en: '[PRE69]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, in the `models/mod.rs` file, we make the `item` module public to other
    modules and the `main.rs` file with the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`models/mod.rs`文件中，我们用以下代码使`item`模块对其他模块和`main.rs`文件公开：
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we define our model’s module in the `main.rs` file with the following
    line of code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`main.rs`文件中用以下行代码定义我们的模型模块：
- en: '[PRE71]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now we can access our data models throughout the app. We have also locked down
    the behavior around reading and writing to the database. Next, we can move on
    to importing these data models and using them in our app.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在整个应用程序中访问我们的数据模型。我们还将读取和写入数据库的行为锁定。接下来，我们可以继续导入这些数据模型并在我们的应用程序中使用它们。
- en: Getting data from the database
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数据库获取数据
- en: When interacting with a database, it can take some time to get used to how we
    do this. Different **object-relational mappers** (**ORMs**) and languages have
    different quirks. While the underlying principles are the same, the syntax for
    these ORMs can vary greatly. Therefore, just clocking hours using an ORM will
    enable you to become more confident and solve more complex problems. We can start
    with the simplest mechanism, getting all the data from a table.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当与数据库交互时，可能需要一些时间来习惯我们这样做的方式。不同的**对象关系映射器**（**ORMs**）和语言有不同的怪癖。虽然基本原理相同，但这些ORM的语法可能会有很大差异。因此，仅仅使用ORM计时并不能使您更有信心，也不能解决更复杂的问题。我们可以从最简单的机制开始，即从表中获取所有数据。
- en: 'To explore this, we can get all the items from the `to_do` table and return
    them at the end of each view. We defined this mechanism in [*Chapter 4*](B18722_04.xhtml#_idTextAnchor073),
    *Processing HTTP Requests*. In terms of our application, you will recall that
    we have a `get_state` function that packages our to-do items for our frontend.
    This `get_state` function is housed in the `ToDoItems` struct in the `src/json_serialization/to_do_items.rs`
    file. Initially, we must import what we need with the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这一点，我们可以从`to_do`表获取所有项目，并在每个视图的末尾返回它们。我们在[*第4章*](B18722_04.xhtml#_idTextAnchor073)，*处理HTTP请求*中定义了这种机制。就我们的应用程序而言，您会记得我们有一个`get_state`函数，它为我们的前端打包待办事项。这个`get_state`函数位于`src/json_serialization/to_do_items.rs`文件中的`ToDoItems`结构体中。最初，我们必须用以下代码导入所需的项：
- en: '[PRE72]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the preceding code, we have imported the `diesel` crate and macros, which
    enable us to build database queries. We then import our `establish_connection`
    function to make connections to the database and then import the schema and database
    model to make the query and handle the data. We can then refactor our `get_state`
    function with the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了`diesel`包和宏，这使我们能够构建数据库查询。然后我们导入`establish_connection`函数以连接到数据库，然后导入模式和数据库模型以进行查询和处理数据。然后我们可以用以下代码重构我们的`get_state`函数：
- en: '[PRE73]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding code, we first establish the connection. Once the database
    connection is established, we then get our table and build a database query off
    it. The first part of the query defines the order. As we can see, our table can
    also pass references to columns which also have their own function.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先建立连接。一旦建立了数据库连接，我们就从我们的表获取并基于它构建一个数据库查询。查询的第一部分定义了顺序。正如我们所见，我们的表也可以传递列的引用，这些列也有它们自己的函数。
- en: We then define what struct will be used to load the data and pass in a reference
    to the connection. Because the macros defined the struct in the load, if we passed
    in the `NewItem` struct into the `load` function, we would get an error because
    the `Queryable` macro is not enabled for that struct.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义将用于加载数据的结构体，并传入连接的引用。因为宏在`load`中定义了结构体，如果我们把`NewItem`结构体传递给`load`函数，我们会得到一个错误，因为`Queryable`宏没有为该结构体启用。
- en: 'It can also be noted that the `load` function has a prefix before the functions
    brackets where the parameters are passed in `load::<Item>(&connection)`. This
    prefix concept was covered in [*Chapter 1*](B18722_01.xhtml#_idTextAnchor015),
    *A Quick Introduction to Rust*,the *Verifying with traits* section, *step 4*,
    but for now, you can use the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以注意到，`load`函数在其函数括号之前有一个前缀，其中参数通过`load::<Item>(&connection)`传递。这个前缀概念在[*第1章*](B18722_01.xhtml#_idTextAnchor015)，*Rust快速入门*，*使用特性行验证*部分，*步骤4*中有所介绍，但到目前为止，您可以使用以下代码：
- en: '[PRE74]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The type that is passed into the prefix `<Item>` defines the type of input accepted.
    This means that when the compiler runs, a separate function for each type passed
    into our `load` function is compiled.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 传递到前缀`<Item>`的类型定义了接受的输入类型。这意味着当编译器运行时，为传递给我们的`load`函数的每个类型编译一个单独的函数。
- en: 'We then directly unwrap the `load` function resulting in a vector of items
    from the database. With the data from the database, we loop through constructing
    our item structs and appending them to our buffer. Once this is done, we construct
    the `ToDoItems` JSON schema from our buffer and return it. Now that we have enacted
    this change, all our views will return data directly from the database. If we
    run this, there will be no items on display. If we try and create any, they will
    not appear. However, although they are not being displayed, what we have done
    is get the data from the database and serialize it in the JSON structure that
    we want. This is the basis of returning data from a database and returning it
    to the requester in a standard way. This is the backbone of APIs built in Rust.
    Because we are no longer relying on reading from a JSON state file when getting
    the items from the database, we can remove the following imports from the `src/json_serialization/to_do_items.rs`
    file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们直接解包 `load` 函数，得到数据库中的项目向量。有了数据库中的数据，我们通过构造项目结构体并将它们追加到我们的缓冲区中来进行循环。一旦完成，我们从缓冲区中构造
    `ToDoItems` JSON 架构并返回它。现在我们已经实施了这一变更，所有我们的视图都将直接从数据库返回数据。如果我们运行这个程序，将不会显示任何项目。如果我们尝试创建任何项目，它们将不会显示。然而，尽管它们没有被显示，我们所做的是从数据库中获取数据，并以我们想要的
    JSON 结构进行序列化。这是从数据库返回数据并以标准方式将其返回给请求者的基础。这是在 Rust 中构建的 API 的骨架。因为我们不再依赖于从 JSON
    状态文件中读取项目时读取，我们可以从 `src/json_serialization/to_do_items.rs` 文件中删除以下导入：
- en: '[PRE75]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We remove the preceding imports because we have not refactored any of the other
    endpoints. Resultantly, the `create` endpoint will fire correctly; however, the
    endpoint is just creating items in the JSON state file that `return_state` no
    longer reads. For us to enable creation again, we must refactor the `create` endpoint
    to insert a new item into the database.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了前面的导入，因为我们没有重构任何其他端点。因此，`create` 端点将正确触发；然而，该端点只是在 JSON 状态文件中创建项目，而 `return_state`
    已经不再读取这些项目。为了再次启用创建功能，我们必须重构 `create` 端点以将新项目插入到数据库中。
- en: Inserting into the database
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入到数据库中
- en: 'In this section, we will build and create a view that creates a to-do item.
    If we remember the rules around our creating of to-do items, we do not want to
    create duplicate to-do items. This can be done with a unique constraint. However,
    for now, it is good to keep things simple. Instead, we will make a database fall
    with a filter based on the title that is passed into the view. We then check,
    and if no results are returned, we will insert a new `to-do` item into the database.
    We do this by refactoring the code in the `views/to_do/create.rs` file. First,
    we reconfigure the imports as seen in the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建并创建一个视图来创建待办事项。如果我们还记得创建待办事项的规则，我们不想创建重复的待办事项。这可以通过唯一约束来实现。然而，目前保持简单是好的。相反，我们将基于传递给视图的标题对数据库执行一个筛选。然后我们进行检查，如果没有返回结果，我们将向数据库中插入一个新的
    `to-do` 事项。我们通过重构 `views/to_do/create.rs` 文件中的代码来完成这项工作。首先，我们重新配置导入，如下面的代码所示：
- en: '[PRE76]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the preceding code, we import the necessary `diesel` imports to make a query
    as described in the previous section. We then import the `actix-web` structs needed
    for the view to process a request and define a result. We then import our database
    structs and functions to interact with the database. Now that we have everything,
    we can start working on our `create` view. Inside our `pub async fn create` function,
    we start by getting two references of the title of the `to-do` item from the request:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了必要的 `diesel` 导入以执行上一节中描述的查询。然后，我们导入了 `actix-web` 结构体，以便视图处理请求并定义结果。接着，我们导入了与数据库交互的数据库结构体和函数。现在我们已经拥有了所有这些，我们可以开始工作在
    `create` 视图上了。在我们的 `pub async fn create` 函数内部，我们首先从请求中获取 `to-do` 项目的标题的两个引用：
- en: '[PRE77]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Once we have extracted the title from the URL in the preceding code, we establish
    a database connection and make a database call to our table using that connection,
    as seen in the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从前面代码中的 URL 中提取了标题，我们就建立数据库连接，并使用该连接对我们的表进行数据库调用，如下面的代码所示：
- en: '[PRE78]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As we can see in the preceding code, the query is pretty much the same as the
    query in the previous section. However, we have a `filter` section that refers
    to our `title` column that must be equal to our `title`. If the item being created
    is truly new, there will be no items created; therefore, the length of the result
    will be zero. Subsequently, if the length is zero, we should create a `NewItem`
    data model and then insert it into the database to return the state at the end
    of the function, as seen in the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，查询基本上与上一节的查询相同。然而，我们有一个`filter`部分，它引用我们的`title`列，必须等于我们的`title`。如果正在创建的项目确实是新的，则不会创建任何项目；因此，结果的长度将为零。随后，如果长度为零，我们应该创建一个`NewItem`数据模型，然后将其插入数据库，以便在函数结束时返回状态，如下面的代码所示：
- en: '[PRE79]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can see that Diesel has an `insert` function, which accepts the table, and references
    to the data model we built. Because we have switched to database storage, we can
    delete the following imports as they are not needed:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Diesel有一个`insert`函数，它接受表和我们对构建的数据模型的引用。因为我们已经切换到数据库存储，所以我们可以删除以下导入，因为它们不再需要：
- en: '[PRE80]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, using our app, we will be able to create to-do items and then see these
    items pop up on the frontend of our application. Therefore, we can see that our
    `create` and `get state` functions are working; they are engaging with our database.
    If you are having trouble, a common mistake is to forget to spin up our `docker-compose`.
    (*Note: Remember to do this, otherwise, the app will not be able to connect to
    the database as it is not running*). However, we cannot edit our to-do items status
    to `DONE`. We will have to edit our data on the database to do this.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用我们的应用，我们将能够创建待办事项，然后看到这些事项在我们的应用前端弹出。因此，我们可以看到我们的`create`和`get state`函数正在工作；它们正在与我们的数据库交互。如果你遇到麻烦，一个常见的错误是忘记启动我们的`docker-compose`。(*注意：请记住做这件事，否则，应用将无法连接到数据库，因为它没有运行*)。然而，我们无法将待办事项的状态编辑为`完成`。我们将不得不在数据库中编辑我们的数据来完成这个操作。
- en: Editing the database
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑数据库
- en: 'When we edit our data, we are going to get the data model from the database
    and then edit the entry with a database call function from Diesel. To engage our
    `edit` function with the database, we can edit our view in the `views/to_do/edit.rs`
    file. We start by refactoring the imports, as you see in the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编辑我们的数据时，我们将从数据库中获取数据模型，然后使用Diesel的数据库调用函数来编辑条目。为了使我们的`edit`函数与数据库交互，我们可以在`views/to_do/edit.rs`文件中编辑我们的视图。我们首先重构导入，如下面的代码所示：
- en: '[PRE81]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As we can see in the preceding code, there is a pattern emerging. The pattern
    is that we import dependencies to handle authentication, a database connection,
    and a schema and then build a function that performs the operation that we want.
    We have covered the imports and the meanings behind them previously. In our `edit`
    view, we must only get one reference to the title this time, which is denoted
    in the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，出现了一个模式。这个模式是，我们导入依赖项来处理身份验证、数据库连接和模式，然后构建一个执行我们想要的操作的函数。我们已经覆盖了导入及其含义。在我们的`edit`视图中，我们这次必须只获取一个对标题的引用，如下面的代码所示：
- en: '[PRE82]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In the preceding code, we can see that we perform a filter on our database
    without loading the data. This means that the `results` variable is an `UpdateStatement`
    struct. We then use this `UpdateStatement` struct to update our item to `DONE`
    in the database. With the fact that we are no longer using the JSON file, we can
    delete the following imports in the `views/to_do/edit.rs` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们可以看到我们在不加载数据的情况下对数据库执行了过滤。这意味着`results`变量是一个`UpdateStatement`结构体。然后我们使用这个`UpdateStatement`结构体来在数据库中更新项目为`完成`。鉴于我们不再使用JSON文件，我们可以在`views/to_do/edit.rs`文件中删除以下导入：
- en: '[PRE83]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the preceding code, we can see that we call the `update` function and fill
    it with the results that we got from the database. We then set the `status` column
    to `Done`, and then `execut`e using the reference to the connection. Now we can
    use this to edit our `to-do` items so they shift to the done list. However, we
    cannot delete them. To do this, we are going to have to refactor our final endpoint
    to completely refactor our app to be connected to a database.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们可以看到我们调用了`update`函数，并用从数据库获取的结果填充它。然后我们将`status`列设置为`完成`，然后使用连接的引用来执行。现在我们可以使用这个来编辑我们的`to-do`事项，使它们移动到完成列表。然而，我们无法删除它们。为了做到这一点，我们将不得不重构我们的最终端点，以完全重构我们的应用以连接到数据库。
- en: Deleting data
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'With deleting data, we will take the same approach that we took in the previous
    section when editing. We will get an item from the database, pass it through the
    Diesel `delete` function, and then return the state. Right now, we should be comfortable
    with this approach, so it is advised that you try and implement it by yourself
    in the `views/to_do/delete.rs` file. The code is given as follows for the imports:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除数据时，我们将采取与上一节编辑时相同的方法。我们将从数据库中获取一个项目，通过 Diesel 的 `delete` 函数传递，然后返回状态。目前，我们应该对这种方法感到舒适，因此建议你在
    `views/to_do/delete.rs` 文件中自己尝试实现它。以下是导入部分的代码：
- en: '[PRE84]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the preceding code, we rely on the Diesel crates and the prelude so we can
    use the Diesel macros. Without `prelude`, we would not be able to use the schema.
    We then import the Actix Web structs that are needed to return data to the client.
    We then import the crates that we have built to manage our to-do item data. For
    the `delete` function, the code is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们依赖于 Diesel 包和预导入，这样我们就可以使用 Diesel 宏。没有 `prelude`，我们就无法使用模式。然后我们导入返回数据给客户端所需的
    Actix Web 结构体。然后导入我们构建来管理待办事项数据的包。对于 `delete` 函数，代码如下：
- en: '[PRE85]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To conduct quality control, let us go through the following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行质量控制，让我们按照以下步骤进行：
- en: Enter `buy canoe` into the text input and click the **Create** button.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本输入框中输入 `buy canoe` 并点击 **创建** 按钮。
- en: Enter `go dragon boat racing` into the text input and click the **Create** button.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本输入框中输入 `go dragon boat racing` 并点击 **创建** 按钮。
- en: 'Click the **edit** button on the **buy canoe** item. After doing this, we should
    have the following output in the frontend:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **buy canoe** 项上的 **编辑** 按钮。完成此操作后，我们应该在前端看到以下输出：
- en: '![Figure 6.6 – Expected output](img/Figure_6.6_B18722.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 预期输出](img/Figure_6.6_B18722.jpg)'
- en: Figure 6.6 – Expected output
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 预期输出
- en: 'In the preceding figure, we have bought our canoe, but we have not gone dragon
    boat racing yet. And here we have it, our app is working seamlessly with our PostgreSQL
    database. We can create, edit, and delete our to-do items. Because of the structure
    that was defined in previous chapters, chopping out the JSON file mechanism for
    the database did not require a lot of work. The request for processing and returning
    of data was already in place. When we run our application now you may have realized
    that we have the following printout when compiling:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们已经购买了我们的独木舟，但还没有参加龙舟比赛。现在，我们的应用程序与我们的 PostgreSQL 数据库无缝工作。我们可以创建、编辑和删除我们的待办事项。由于在之前的章节中定义了结构，移除数据库的
    JSON 文件机制并没有花费太多工作。数据处理和返回请求已经就绪。当我们现在运行应用程序时，你可能已经意识到在编译时会有以下输出：
- en: '[PRE86]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'What is happening, according to the preceding printout, is that we are no longer
    using our `src/state.rs` file or our `src/processes.rs` file. These files are
    no longer being used because our `src/database.rs` file is now managing our storage,
    deletion, and editing of persistent data with a real database. We are also processing
    our data from the database to a struct with our database model structs that have
    implemented the Diesel `Queryable` and `Identifiable` traits. Thus, we can delete
    the `src/state.rs` and `src/database.rs` files as they are no longer needed. We
    also do not need our `src/to_do/traits` module, so this can be removed too. Next,
    we can remove all the references to the traits. Removing the references essentially
    means removing traits from the `src/to_do/mod.rs` file and removing the import
    and implementation of these traits in our structs for the `to_do` module. For
    instance, to remove the traits from the `src/to_do/structs/pending.rs` file, we
    must merely remove the following imports:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的输出，所发生的情况是我们不再使用 `src/state.rs` 文件或 `src/processes.rs` 文件。这些文件不再被使用，因为
    `src/database.rs` 文件现在正在使用真实数据库来管理我们的存储、删除和编辑持久数据。我们还使用实现了 Diesel 的 `Queryable`
    和 `Identifiable` 特性的数据库模型结构体将数据库中的数据处理到结构体中。因此，我们可以删除 `src/state.rs` 和 `src/database.rs`
    文件，因为它们不再需要。我们也不再需要 `src/to_do/traits` 模块，因此也可以将其删除。接下来，我们可以删除所有对特质的引用。删除引用实际上意味着从
    `src/to_do/mod.rs` 文件中删除特质，并从 `to_do` 模块的结构体中删除这些特质的导入和实现。例如，要从 `src/to_do/structs/pending.rs`
    文件中删除特质，我们只需删除以下导入：
- en: '[PRE87]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can then remove the following implementation of these traits:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以删除以下特质的实现：
- en: '[PRE88]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We also must remove the traits in the `src/to_do/structs/done.rs` file. We now
    have an opportunity to appreciate the payoff of our well-structured isolated code.
    We can slot in different methods for persistent storage easily, as we can simply
    remove existing storage methods by deleting a couple of files and the traits directly.
    We then just removed the implementations of the traits. That was it. We did not
    have to dig into functions and alter lines of code. Because our reading functionality
    was in the traits, removing the implementations severed our application completely
    by just removing the implementations of the traits. Structuring code like this
    really pays off in the future. In the past, I have had to pull code out of one
    server into another when refactoring microservices or upgrading or switching a
    method, such as a storage option. Having isolated code makes refactoring a lot
    easier, quicker, and less error-prone.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在`src/to_do/structs/done.rs`文件中移除特性。我们现在有机会欣赏我们结构良好、独立代码的回报。我们可以轻松地插入不同的持久化存储方法，因为我们只需删除几个文件和特性即可简单地移除现有的存储方法。然后我们只是移除了特性的实现。就是这样。我们不必深入函数和修改代码行。因为我们的读取功能在特性中，通过移除特性的实现，我们只需移除特性的实现就能完全切断应用程序。以这种方式结构代码在将来真的很划算。在过去，我不得不从一个服务器中提取代码到另一个服务器中，以重构微服务或升级或切换方法，例如存储选项。拥有独立的代码使重构变得更容易、更快、更不容易出错。
- en: Our application is now fully working with a database. However, we can improve
    the implementation of our database. Before we do this, however, we should refactor
    our configuration code in the next section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在与数据库完全兼容。然而，我们可以改进我们数据库的实现。在我们这样做之前，然而，我们应该在下一节重构我们的配置代码。
- en: Configuring our application
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置我们的应用程序
- en: 'Right now, we are storing our database URL in a `.env` file. This is fine,
    but we can also use `yaml` `config` files. When developing web servers, they will
    be run in different environments. For instance, right now, we are running our
    Rust server on our local machine. However, later we will package the server into
    our own Docker image and deploy it on the cloud. With microservices infrastructure,
    we might use a server that we built in one cluster and slot it into a different
    cluster with different databases to connect to. Because of this, config files
    defining all inward and outward traffic become essential. When we deploy our server,
    we can make a request to file storage, such as AWS S3, to get the right config
    file for the server. It must be noted that environment variables can be preferred
    for deployment as they can be passed into containers. We will cover how to configure
    a web application using environment variables in *Chapter 13*, *Best Practices
    for a Clean Web App Repository*. For now, we will focus on using config files.
    We also need to enable our server to be flexible in terms of what config file
    is being loaded. For instance, we should not have to have a config file in a particular
    directory and with a particular name to be loaded into our server. We should keep
    our config files properly named for the right context to reduce the risk of the
    wrong config file being loaded into the server. Our path to the file can be passed
    when spinning up our server. Because we are using `yaml` files, we need to define
    the `serde_yaml` dependency on our `Cargo.toml` file as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在将数据库URL存储在`.env`文件中。这很好，但我们也可以使用`yaml`配置文件。在开发网络服务器时，它们将在不同的环境中运行。例如，目前，我们正在在我们的本地机器上运行我们的Rust服务器。然而，稍后我们将把服务器打包成我们自己的Docker镜像并在云上部署它。由于微服务基础设施，我们可能会使用在一个集群中构建的服务器，并将其插入到连接到不同数据库的不同集群中。因此，定义所有内外部流量的配置文件变得至关重要。当我们部署我们的服务器时，我们可以向文件存储发出请求，例如AWS
    S3，以获取服务器的正确配置文件。必须注意的是，环境变量可以优先用于部署，因为它们可以被传递到容器中。我们将在第13章“干净Web应用程序仓库的最佳实践”中介绍如何使用环境变量配置Web应用程序。现在，我们将专注于使用配置文件。我们还需要使我们的服务器在加载配置文件方面具有灵活性。例如，我们不应该需要将配置文件放在特定的目录中，并具有特定的名称才能加载到我们的服务器中。我们应该为正确的上下文正确命名我们的配置文件，以降低错误配置文件被加载到服务器中的风险。我们的文件路径可以在启动服务器时传递。因为我们正在使用`yaml`文件，所以我们需要在`Cargo.toml`文件中定义`serde_yaml`依赖项，如下所示：
- en: '[PRE89]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now that we can read `yaml` files, we can build our own configuration module,
    which loads to `yaml` file values into a HashMap. This can be done with one struct;
    therefore, we should put our config module into one file, which is the `src/config.rs`
    file. First, we import what we need with the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以读取`yaml`文件了，我们可以构建自己的配置模块，该模块将`yaml`文件值加载到HashMap中。这可以通过一个结构体来完成；因此，我们应该将配置模块放入一个文件中，即`src/config.rs`文件。首先，我们使用以下代码导入所需的模块：
- en: '[PRE90]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In the preceding code, we use `env` to capture environment variables passed
    into the program, `HashMap` to store the data from the config file, and the `serde_yaml`
    crate to process `yaml` values from the config file. We then define the struct
    that houses our config data with the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`env`来捕获传递给程序的环境变量，使用`HashMap`来存储配置文件中的数据，并使用`serde_yaml`包来处理配置文件中的`yaml`值。然后，我们使用以下代码定义包含我们配置数据的结构体：
- en: '[PRE91]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In the preceding code, we can see that our data key of the value is `String`,
    and the value belonging to those keys are `yaml` values. We then build a constructor
    for our struct that takes the last argument passed into the program, opens the
    file based on the path to the file passed into the program, and loads our `map`
    field with the data from the file with the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们的数据键的值是`String`，而属于这些键的值是`yaml`值。然后我们为我们的结构体构建一个构造函数，它接受传递给程序的最后一个参数，根据传递给程序的文件路径打开文件，并使用以下代码将文件中的数据加载到我们的`map`字段中：
- en: '[PRE92]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now that the `config` struct is defined, we can define our `config` module
    in the `src/main.rs` file with the following line of code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经定义了`config`结构体，我们可以在`src/main.rs`文件中使用以下代码行来定义我们的`config`模块：
- en: '[PRE93]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We must then refactor our `src/database.rs` file to load from a `yaml` `config`
    file. Our refactored imports take the following form:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须重构我们的`src/database.rs`文件，以便从`yaml`配置文件中加载。我们重构的导入形式如下：
- en: '[PRE94]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can see that all references to `env` have been removed, as this is now handled
    in our `config` module. We then load our file, get our `DB_URL` key, and directly
    unwrap the result of getting the variable associated with the `DB_URL` key, converting
    the `yaml` value to a string and directly unwrapping the result from that conversion.
    We directly unwrap the getting and conversion functions because if they fail,
    we will not be able to connect to the database anyway. If we cannot connect, we
    want to know about the error as soon as possible with a clear error message showing
    where this is happening. We can now shift our database URL into our `config.yml`
    file in the root of our Rust application with the following content:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，所有对`env`的引用都已移除，因为现在这已在我们的`config`模块中处理。然后我们加载我们的文件，获取我们的`DB_URL`键，并直接展开与`DB_URL`键关联的变量的结果，将`yaml`值转换为字符串并直接展开转换的结果。我们直接展开获取和转换函数，因为如果它们失败，我们无论如何都无法连接到数据库。如果我们无法连接，我们希望尽快知道错误，并显示一个清晰的错误消息，说明错误发生的位置。现在，我们可以将我们的数据库URL移入Rust应用程序根目录下的`config.yml`文件中，内容如下：
- en: '[PRE95]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, we can run our application with the following command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用以下命令运行我们的应用程序：
- en: '[PRE96]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `config.yml` file is the path to the config file. If you run `docker-compose`
    and the frontend, you will see that the database URL from our config file is being
    loaded and our application is connected to the database. There is one problem
    with this database connection, however. Every time we execute the `establish_connection`
    function, we make a connection to our database. This will work; however, it is
    not optimal. In the next section, we will be more efficient with our database
    connections with database connection pooling.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.yml`文件是配置文件的路径。如果你运行`docker-compose`和前端，你会看到我们的配置文件中的数据库URL正在被加载，并且我们的应用程序已连接到数据库。然而，这个数据库连接有一个问题。每次我们执行`establish_connection`函数时，我们都会与我们的数据库建立连接。这可以工作；然而，这不是最优的。在下一节中，我们将通过数据库连接池来提高数据库连接的效率。'
- en: Building a database connection pool
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建数据库连接池
- en: 'In this section, we will create a database connection pool. A database connection
    pool is a limited number of database connections. When our application needs a
    database connection, it will take the connection from the pool and place it back
    into the pool when the application no longer needs the connection. If there are
    no connections left in the pool, the application will wait until there is a connection
    available, as seen in the following diagram:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个数据库连接池。数据库连接池是一定数量的数据库连接。当我们的应用程序需要数据库连接时，它会从池中取出连接，当应用程序不再需要连接时，它会将连接放回池中。如果池中没有剩余的连接，应用程序将等待直到有可用的连接，如下面的图示所示：
- en: '![Figure 6.7 – Database connection pool with a limit of three connections](img/Figure_6.7_B18722.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 限制为三个连接的数据库连接池](img/Figure_6.7_B18722.jpg)'
- en: Figure 6.7 – Database connection pool with a limit of three connections
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 限制为三个连接的数据库连接池
- en: 'Before we refactor our database connection, we need to install the following
    dependency in our `Cargo.toml` file:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们重构数据库连接之前，我们需要在我们的`Cargo.toml`文件中安装以下依赖项：
- en: '[PRE97]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We then define our imports with the `src/database.rs` file with the following
    code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用以下代码在`src/database.rs`文件中定义我们的导入：
- en: '[PRE98]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: From the imports we have defined in the preceding code, what do you think we
    will do when we write out our new database connection? At this point, it is a
    good time to stop and think about what you can do with these imports.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面代码中定义的导入中，你认为我们在编写新的数据库连接时会做什么？到目前为止，这是一个停下来思考你可以用这些导入做什么的好时机。
- en: 'The first block of imports, if you remember, will be used to establish a database
    connection before the request hits the view. The second block of imports enables
    us to define our database connection pool. The final `Config`  parameter is to
    get the database URL for the connection. Now that our imports are done, we can
    define the connection pool struct with the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，第一个导入块将在请求击中视图之前建立数据库连接。第二个导入块使我们能够定义我们的数据库连接池。最后的`Config`参数是为了获取连接的数据库URL。现在我们的导入已经完成，我们可以使用以下代码定义连接池结构体：
- en: '[PRE99]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In the preceding code, we state that our `PgPool` struct is a connection manager
    that manages connections inside a pool. We then build our connection, which is
    a static reference, with the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明我们的`PgPool`结构体是一个连接管理器，它管理池内的连接。然后我们使用以下代码构建我们的连接，这是一个静态引用：
- en: '[PRE100]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In the preceding code, we get the URL from the config file and construct a
    connection pool that is returned and thus assigned to the `DBCONNECTION` static
    referenced variable. Because this is a static reference, the lifetime of our `DBCONNECTION`
    variable matches the lifetime of the server. We can now refactor our `establish_connection`
    function to take from the database connection pool with the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从配置文件中获取URL并构建一个返回并因此分配给`DBCONNECTION`静态引用变量的连接池。因为这是一个静态引用，所以我们的`DBCONNECTION`变量的生命周期与服务器匹配。现在我们可以重构`establish_connection`函数，使其从数据库连接池中获取连接，以下是一段代码：
- en: '[PRE101]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In the preceding code, we can see that we are returning a `PooledConnection`
    struct. However, we do not want to call the `establish_connection` function every
    time we need it. We also want to reject the HTTP request before it hits the view
    if we cannot make the connection for whatever reason, as we do not want to load
    a view that we cannot process. Just like our `JWToken` struct, we can create a
    struct that creates a database connection and passes that database connection
    into the view. Our struct has one field, which is a pooled connection, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们返回了一个`PooledConnection`结构体。然而，我们不想每次需要时都调用`establish_connection`函数。我们还想在HTTP请求击中视图之前拒绝请求，如果我们无法建立连接，因为我们不想加载无法处理的视图。就像我们的`JWToken`结构体一样，我们可以创建一个结构体来创建数据库连接并将该数据库连接传递到视图中。我们的结构体有一个字段，即一个池连接，如下所示：
- en: '[PRE102]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'With this `DB` struct, we can implement the `FromRequest` trait like we did
    with our `JWToken` struct with the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`DB`结构体，我们可以像处理我们的`JWToken`结构体一样实现`FromRequest`特性，以下是一段代码：
- en: '[PRE103]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Here we do not directly unwrap the getting the database connection. Instead,
    if there is an error when connecting, we return an error with a helpful message.
    If our connection is successful, we then return it. We can implement this in our
    views. To avoid repetitive code, we shall just use the `edit` view, but we should
    apply this approach to all our views. First, we define the following imports:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们并没有直接解包获取数据库连接。相反，如果连接时出现错误，我们返回一个带有有用信息的错误。如果我们的连接成功，我们随后返回它。我们可以在我们的视图中实现这一点。为了避免重复代码，我们只需使用`edit`视图，但我们应该将这种方法应用到所有我们的视图中。首先，我们定义以下导入：
- en: '[PRE104]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In the preceding code, we can see that we have imported the `DB` struct. Our
    `edit` view should now look as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们导入了`DB`结构体。现在，我们的`edit`视图应该如下所示：
- en: '[PRE105]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In the preceding code, we can see that we directly reference the `connection`
    field of our `DB` struct. The fact is that we can simply get a pooled connection
    into our view by passing the `DB` struct into the view like our authentication
    token.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们直接引用了`DB`结构体的`connection`字段。事实上，我们可以通过将`DB`结构体传递到视图中，就像我们的认证令牌一样，简单地获取一个池化连接到我们的视图中。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we constructed a development environment where our app could
    interact with the database using Docker. Once we did this, we explored the listing
    of containers and images to inspect how our system is going. We then created migrations
    using the `diesel` crate. After this, we installed the `diesel` client and defined
    the database URL as an environment variable so that our Rust app and migrations
    could directly connect with the database container.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个开发环境，我们的应用程序可以通过Docker与数据库进行交互。一旦完成这项工作，我们就探索了容器和镜像的列表，以检查我们的系统运行情况。然后，我们使用`diesel`包创建了迁移。之后，我们安装了`diesel`客户端，并将数据库URL定义为环境变量，以便我们的Rust应用程序和迁移可以直接连接到数据库容器。
- en: We then ran migrations and defined the SQL scripts that would fire when the
    migration ran, and in turn, ran them. Once all this was done, we inspected the
    database container again to see whether the migration had, in fact, been executed.
    We then defined the data models in Rust, and refactored our API endpoints, so
    they performed `get`, `edit`, `create`, and `delete` operations on the database
    in order to keep track of the to-do items.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行了迁移，并定义了在迁移运行时将触发的SQL脚本，然后运行了它们。一旦完成所有这些，我们再次检查数据库容器，以查看迁移是否实际上已执行。然后，我们在Rust中定义了数据模型，并重构了我们的API端点，以便它们在数据库上执行`get`、`edit`、`create`和`delete`操作，以跟踪待办事项。
- en: What we have done here is upgraded our database storage system. We are one step
    closer to having a production-ready system as we are no longer relying on a JSON
    file to store our data. You now have the skills to perform database management
    tasks that enable you to manage changes, credentials/access, and schemas. We also
    performed all the basic operations on the database that are needed to run an app
    that creates, gets, updates, and deletes data. These skills are directly transferable
    to any other project you wish to undertake in Rust web projects. We then augmented
    our newly developed database skills by enabling our database connections to be
    limited by a connection pool. Finally, implementing our database connection structs
    was made easy by implementing the `FromRequest` trait so other developers can
    implement our connection just by passing the struct into the view as a parameter.
    The view is also protected if the database connection cannot be made.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是升级了我们的数据库存储系统。我们离拥有一个生产就绪的系统又近了一步，因为我们不再依赖于JSON文件来存储我们的数据。你现在拥有了执行数据库管理任务所需的技能，这些任务使你能够管理更改、凭证/访问和模式。我们还对数据库执行了所有必要的操作，以便运行一个创建、获取、更新和删除数据的应用程序。这些技能可以直接转移到你希望在Rust
    Web项目中进行的任何其他项目中。然后，我们通过使数据库连接受连接池限制来增强我们新开发的数据库技能。最后，通过实现`FromRequest`特质，使实现数据库连接结构体变得简单，这样其他开发者只需通过将结构体传递到视图中作为参数即可实现我们的连接。如果无法建立数据库连接，视图也得到了保护。
- en: In the next chapter, we will build on these skills to build a user authentication
    system so we can create users and check credentials when accessing the app. We
    will use a combination of database, extraction of data from headers, browser storage,
    and routing to ensure that the user must be logged in to access the to-do items.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在此基础上构建用户身份验证系统，以便我们可以在访问应用程序时创建用户和检查凭证。我们将结合使用数据库、从头部提取数据、浏览器存储和路由，以确保用户必须登录才能访问待办事项。
- en: Questions
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the advantages of having a database over a JSON file?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据库而不是JSON文件有哪些优势？
- en: How do you create a migration?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建迁移？
- en: How do we check migrations?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何检查迁移？
- en: If we wanted to create a user data model in Rust with a name and age, what should
    we do?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想在Rust中创建一个具有姓名和年龄的用户数据模型，我们应该怎么做？
- en: What is a connection pool, and why should we use it?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是连接池，为什么我们应该使用它？
- en: Answers
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The database has advantages in terms of multiple reads and writes at the same
    time. The database also checks the data to see whether it is in the right format
    before inserting it and we can do advanced queries with linked tables.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库在同时进行多读和多写方面具有优势。数据库还会在插入之前检查数据，看它是否处于正确的格式，并且我们可以使用关联表进行高级查询。
- en: We install the `diesel` client and define the database URL in the `.env` file.
    We then create migrations using the client and write the desired schema required
    for the migration. We then run the migration.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们安装`diesel`客户端并在`.env`文件中定义数据库URL。然后我们使用客户端创建迁移，并编写所需的模式以供迁移使用。接着我们运行迁移。
- en: We use the container ID of the database to access the container. We then list
    the tables; if the table we desire is there, then this is a sign that the migration
    ran. We can also check the migration table in the database to see when it was
    last run.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用数据库的容器ID来访问容器。然后我们列出表；如果所需的表存在，那么这是一个迁移已运行的迹象。我们还可以检查数据库中的迁移表，以查看它最后一次运行的时间。
- en: We define a `NewUser` struct with the name as a string and age as an integer.
    We then create a `User` struct with the same field and an extra integer field,
    the ID.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个`NewUser`结构体，其中姓名是一个字符串，年龄是一个整数。然后我们创建一个`User`结构体，具有相同的字段和一个额外的整数字段，即ID。
- en: A connection pool pools a limited number of connections that connect to the
    database. Our application then passes these connections to the threads that need
    them. This keeps the number of connections connecting to the database limited
    to avoid the database being overloaded.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接池会收集一定数量的连接，这些连接连接到数据库。然后我们的应用程序将这些连接传递给需要它们的线程。这样可以保持连接到数据库的连接数量有限，以避免数据库过载。
