["```rs\n      assert!(true);\n      assert!(a == b, \"{} was not equal to {}\", a, b);\n```", "```rs\n      let a = 23;\n      let b = 87;\n      assert_eq!(a, b, \"{} and {} are not equal\", a, b);\n```", "```rs\n// first_unit_test.rs\n\n#[test] \nfn basic_test() { \n    assert!(true);\n}\n```", "```rs\nrustc --test first_unit_test.rs\n```", "```rs\n// unit_test/src/lib.rs\n\n// function we want to test\nfn sum(a: i8, b: i8) -> i8 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    fn sum_inputs_outputs() -> Vec<((i8, i8), i8)> {\n        vec![((1, 1), 2), ((0, 0), 0), ((2, -2), 0)]\n    }\n\n    #[test]\n    fn test_sums() {\n        for (input, output) in sum_inputs_outputs() {\n            assert_eq!(crate::sum(input.0, input.1), output);\n        }\n    }\n}\n```", "```rs\n// panic_test.rs\n\n#[test]\n#[should_panic]\nfn this_panics() {\n    assert_eq!(1, 2);\n}\n```", "```rs\n// silly_loop.rs\n\npub fn silly_loop() {\n    for _ in 1..1_000_000_000 {};\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    #[ignore]\n    pub fn test_silly_loop() {\n        ::silly_loop();\n    }\n}\n```", "```rs\n// integration_test/tests/sum.rs\n\nuse integration_test::sum;\n\n#[test]\nfn sum_test() { \n    assert_eq!(sum(6, 8), 14); \n} \n```", "```rs\n. \n├── Cargo.lock \n├── Cargo.toml \n├── src \n│   └── lib.rs \n└── tests \n    └── sum.rs \n```", "```rs\n// integration_test/tests/common.rs\n\npub fn setup() {\n    println!(\"Setting up fixtures\");\n}\n\npub fn teardown() {\n    println!(\"Tearing down\");\n}\n```", "```rs\n// integration_test/tests/sum.rs\n\nuse integration_test::sum;\n\nmod common;\n\nuse common::{setup, teardown};\n\n#[test]\nfn sum_test() { \n    assert_eq!(sum(6, 8), 14); \n}\n\n#[test]\nfn test_with_fixture() {\n    setup();\n    assert_eq!(sum(7, 14), 21);\n    teardown();\n}\n```", "```rs`let a = 23;```", "```rs\n// doctest_demo/src/lib.rs\n\n//! This crate provides functionality for adding things\n//!\n//! # Examples\n//! ```", "```rs\n\n/// Sum two arguments\n///\n/// # Examples\n///\n/// ```", "```rs\npub fn sum(a: i8, b: i8) -> i8 {\n    a + b\n}\n```", "```rs\n// bench_example/src/lib.rs\n\n#![feature(test)]\nextern crate test;\n\nuse test::Bencher;\n\npub fn do_nothing_slowly() {\n    print!(\".\");\n    for _ in 1..10_000_000 {};\n}\n\npub fn do_nothing_fast() {\n}\n\n#[bench]\nfn bench_nothing_slowly(b: &mut Bencher) {\n    b.iter(|| do_nothing_slowly());\n}\n\n#[bench]\nfn bench_nothing_fast(b: &mut Bencher) {\n    b.iter(|| do_nothing_fast());\n}\n```", "```rs\n[dev-dependencies]\ncriterion = \"0.1\"\n\n[[bench]]\nname = \"fibonacci\"\nharness = false\n```", "```rs\n// criterion_demo/src/lib.rs\n\npub fn slow_fibonacci(nth: usize) -> u64 {\n    if nth <= 1 {\n        return nth as u64;   \n    } else {\n        return slow_fibonacci(nth - 1) + slow_fibonacci(nth - 2);\n    }\n}\n\npub fn fast_fibonacci(nth: usize) -> u64 {\n    let mut a = 0;\n    let mut b = 1;\n    let mut c = 0;\n    for _ in 1..nth {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    c\n}\n```", "```rs\n// criterion_demo/benches/fibonacci.rs\n\n#[macro_use]\nextern crate criterion;\nextern crate criterion_demo;\n\nuse criterion_demo::{fast_fibonacci, slow_fibonacci};\nuse criterion::Criterion;\n\nfn fibonacci_benchmark(c: &mut Criterion) {\n    c.bench_function(\"fibonacci 8\", |b| b.iter(|| slow_fibonacci(8)));\n}\n\ncriterion_group!(fib_bench, fibonacci_benchmark);\ncriterion_main!(fib_bench);\n```", "```rs\n//! This is a logic gates simulation crate built to demonstrate writing unit tests and integration tests\n\n// logic_gates/src/lib.rs\n\npub fn and(a: u8, b: u8) -> u8 {\n    unimplemented!()\n}\n\npub fn xor(a: u8, b: u8) -> u8 {\n    unimplemented!()\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{xor, and};\n    #[test]\n    fn test_and() {\n        assert_eq!(1, and(1, 1));\n        assert_eq!(0, and(0, 1));\n        assert_eq!(0, and(1, 0));\n        assert_eq!(0, and(0, 0));\n    }\n\n    #[test]\n    fn test_xor() {\n        assert_eq!(1, xor(1, 0));\n        assert_eq!(0, xor(0, 0));\n        assert_eq!(0, xor(1, 1));\n        assert_eq!(1, xor(0, 1));\n    }\n}\n```", "```rs\n/// Implements a boolean `and` gate taking as input two bits and returns a bit as output\npub fn and(a: u8, b: u8) -> u8 {\n    match (a, b) {\n        (1, 1) => 1,\n        _ => 0\n    }\n}\n\n/// Implements a boolean `xor` gate taking as input two bits and returning a bit as output\npub fn xor(a: u8, b: u8) -> u8 {\n    match (a, b) {\n        (1, 0) | (0, 1) => 1,\n        _ => 0\n    }\n}\n```", "```rs\n// logic_gates/tests/half_adder.rs\n\nuse logic_gates::{and, xor};\n\npub type Sum = u8;\npub type Carry = u8;\n\npub fn half_adder_input_output() -> Vec<((u8, u8), (Sum, Carry))> { \n    vec![\n        ((0, 0), (0, 0)), \n        ((0, 1), (1, 0)), \n        ((1, 0), (1, 0)), \n        ((1, 1), (0, 1)), \n    ] \n}\n\n/// This function implements a half adder using primitive gates\nfn half_adder(a: u8, b: u8) -> (Sum, Carry) {\n    (xor(a, b), and(a, b))\n}\n\n#[test]\nfn one_bit_adder() {\n    for (inn, out) in half_adder_input_output() {\n        let (a, b) = inn;\n        println(\"Testing: {}, {} -> {}\", a, b, out);\n        assert_eq!(half_adder(a, b), out);\n    }\n}\n\n```", "```rs\n#![doc(html_logo_url = \"https://d30y9cdsu7xlg0.cloudfront.net/png/411962-200.png\")]\n```", "```rs\nlanguage: rust \nrust: \n  - stable \n  - beta \n  - nightly \nmatrix: \n  allow_failures: \n  - rust: nightly \n```", "```rs\nlanguage: rust\nrust:\n  - stable\n  - beta\n  - nightly\nmatrix:\n  allow_failures:\n    - rust: nightly\n  fast_finish: true\ncache: cargo\n\nscript:\n  - cargo build --verbose\n  - cargo test --verbose\n```", "```rs\n[![Build Status](https://travis-ci.org/$USERNAME/$REPO_NAME.svg?branch=master)](https://travis-ci.org/creativcoder/logic_gates)\n```"]