<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-101"><em class="italic"><a id="_idTextAnchor101"/>Chapter 8</em>: Serving Static Assets and Templates</h1>
			<p>One of the common functions of a web application is serving static files such as <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) or <strong class="bold">JavaScript</strong> (<strong class="bold">JS</strong>) files. In this chapter, we are going to learn about serving static assets from the Rocket application.</p>
			<p>One common task for a web framework is rendering a template into HTML files. We are going to learn about using the Tera template to render HTML from the Rocket application. </p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Serving static assets</li>
				<li>Introducing the Tera template</li>
				<li>Showcasing users</li>
				<li>Working with forms</li>
				<li>Securing HTML forms from CSRF</li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Technical requirements</h1>
			<p>For this chapter, we have the same technical requirements as the previous chapter. We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database server.</p>
			<p>For the text editor, you can try adding an extension supporting the Tera template. If there is no extension for Tera, try adding an extension for a Jinja2 or Django template and set the file association to include the <strong class="source-inline">*.tera</strong> file.</p>
			<p>We are going to add CSS to our application, and we are going to use stylesheets from <a href="https://minicss.org/">https://minicss.org/</a> since it's small and open source. Feel free to use and modify the example HTML with other stylesheets.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter08">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter08</a>.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Serving static assets</h1>
			<p>Serving static assets (such as HTML files, JS files, or CSS files) is a very common task for a web application. We <a id="_idIndexMarker420"/>can make Rocket serve files as well. Let's create the first function to serve a favicon. Previously you might have noticed that some web browsers requested a favicon file from our server, even though we did not explicitly mention it on our served HTML page. Let's look at the steps:</p>
			<ol>
				<li>In the application root folder, create a folder named <strong class="source-inline">static</strong>. Inside the <strong class="source-inline">static</strong> folder, add a file named <strong class="source-inline">favicon.png</strong>. You can find sample <strong class="source-inline">favicon.png</strong> files on the internet or use the file from the sample source code for this chapter.</li>
				<li>In <strong class="source-inline">src/main.rs</strong>, add a new route:<p class="source-code">routes![</p><p class="source-code">    ...</p><p class="source-code">    routes::favicon,</p><p class="source-code">],</p></li>
				<li>In <strong class="source-inline">src/routes/mod.rs</strong>, add a new route handling function to serve <strong class="source-inline">favicon.png</strong>:<p class="source-code">use rocket::fs::{relative, NamedFile};</p><p class="source-code">use std::path::Path;</p><p class="source-code">...</p><p class="source-code">#[get("/favicon.png")]</p><p class="source-code">pub async fn favicon() -&gt; NamedFile {</p><p class="source-code">    NamedFile::open(Path::new(relative!("static/</p><p class="source-code">    favicon.png")))</p><p class="source-code">        .await</p><p class="source-code">        .ok()</p><p class="source-code">        .unwrap()</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, <strong class="source-inline">relative!</strong> is a macro that generates a crate-relative version of a path. This means that the macro refers to the folder of the source file or the generated binary. For example, we have the source file for this application in <strong class="source-inline">/some/source</strong>, and by saying <strong class="source-inline">relative!("static/favicon.png")</strong>, it means the path is <strong class="source-inline">/some/source/static/favicon.png</strong>.</p>
			<p>Every time we want to serve a particular file, we can create a route handling function, return <strong class="source-inline">NamedFile</strong>, and mount the route to Rocket. But obviously, this approach is not good; we can create a function to return static files dynamically.</p>
			<ol>
				<li value="4">Let's <a id="_idIndexMarker421"/>reuse the <strong class="source-inline">assets</strong> function that we created when we made the application skeleton. Previously, in <a href="B16825_03_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>, <em class="italic">Rocket Requests and Responses</em>, we learned that we can use multiple segments in a route. We can leverage this and serve a file that has the same filename with the request's multiple segments.</li>
			</ol>
			<p>Delete the favicon function that we created earlier and remove the reference to the function from <strong class="source-inline">src/main.rs</strong>. In <strong class="source-inline">src/routes/mod.rs</strong>, modify the <strong class="source-inline">use</strong> declarations:</p>
			<p class="source-code">use rocket::fs::<strong class="bold">{relative</strong>, NamedFile<strong class="bold">}</strong>;</p>
			<p class="source-code"><strong class="bold">use std::path::{Path, PathBuf};</strong></p>
			<ol>
				<li value="5">The application should return an HTTP <strong class="source-inline">404</strong> status code if the application cannot find the requested file. We can easily return <strong class="source-inline">404</strong> status code by wrapping <strong class="source-inline">NamedFile</strong> inside <strong class="source-inline">Option</strong>. If <strong class="source-inline">NamedFile</strong> is <strong class="source-inline">None</strong>, then the response will have <strong class="source-inline">404</strong> status automatically. Modify the <strong class="source-inline">assets</strong> function signature in <strong class="source-inline">src/routes/mod.rs</strong>:<p class="source-code">#[get<strong class="bold">("/&lt;filename..&gt;</strong>")]</p><p class="source-code">pub async fn assets(<strong class="bold">filename: PathBuf</strong>) -&gt; <strong class="bold">Option&lt;NamedFile&gt;</strong> {}</p></li>
				<li>We can then implement the <strong class="source-inline">assets</strong> function:<p class="source-code">let mut filename = Path::new(relative!("static")).join(filename);</p><p class="source-code">NamedFile::open(filename).await.ok()</p></li>
				<li>Unfortunately, Rocket <a id="_idIndexMarker422"/>returns an HTTP <strong class="source-inline">200</strong> status code if filename is a directory, so an attacker can try attacking and mapping the folder structure inside the <strong class="source-inline">static</strong> folder. Let's handle this case by adding these lines:<p class="source-code">let mut filename = Path::new(relative!("static")).join(filename);</p><p class="source-code"><strong class="bold">if filename.is_dir() {</strong></p><p class="source-code"><strong class="bold">    filename.push("index.html");</strong></p><p class="source-code"><strong class="bold">}</strong></p><p class="source-code">NamedFile::open(filename).await.ok()</p></li>
			</ol>
			<p>If an attacker tries to systematically check the path inside the static file, the attacker will be served with an HTTP <strong class="source-inline">404</strong> status code and will not be able to infer the folder structures inside the <strong class="source-inline">static</strong> folder.</p>
			<ol>
				<li value="8">There's another way to serve the static file: by using the built-in <strong class="source-inline">rocket::fs::FileServer</strong> struct. Remove the function to handle static assets in <strong class="source-inline">src/routes/mod.rs</strong>, and append the following lines in <strong class="source-inline">src/main.rs</strong>:<p class="source-code"><strong class="bold">use rocket::fs::relative;</strong></p><p class="source-code"><strong class="bold">use rocket::fs::FileServer;</strong></p><p class="source-code">...</p><p class="source-code">.mount("/assets", <strong class="bold">FileServer::from(</strong></p><p class="source-code"><strong class="bold"> relative!("static"))</strong>)</p></li>
			</ol>
			<p>Even though web frameworks such as Rocket can serve static files, it's more common to serve static files behind web servers such as Apache Web Server or NGINX. In more advanced setups, people also utilize cloud storage, such as Amazon Web Services S3 or Google Cloud Storage, in <a id="_idIndexMarker423"/>conjunction <a id="_idIndexMarker424"/>with a <strong class="bold">Content Delivery Network </strong>(<strong class="bold">CDN</strong>).</p>
			<p>In the next section, we are going to refine the HTML that we created in <a href="B16825_06_ePub.xhtml#_idTextAnchor083"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing User CRUD</em>.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/>Introducing the Tera template</h1>
			<p>In<a id="_idIndexMarker425"/> web applications, there's usually a part that works as a web template system. Web designers and web developers can create web templates, and the web application generates HTML pages from the templates.</p>
			<p>There are different kinds <a id="_idIndexMarker426"/>of web templates: server-side web templates (in which the template is rendered on the server-side), client-side web templates (where client-side applications render the template), or hybrid web<a id="_idIndexMarker427"/> templates.</p>
			<p>There are a couple <a id="_idIndexMarker428"/>of templating engines<a id="_idIndexMarker429"/> in Rust. We can find templating engines for web <a id="_idIndexMarker430"/>development (such as <strong class="bold">Handlebars</strong>, <strong class="bold">Tera</strong>, <strong class="bold">Askama</strong>, or <strong class="bold">Liquid</strong>) at <a href="https://crates.io">https://crates.io</a> or https:/lib.rs.</p>
			<p>The Rocket web framework has built-in support for templating in the form of the <strong class="source-inline">rocket_dyn_templates</strong> crate. Currently, the crate only supports two engines: <strong class="bold">Handlebars</strong> and <strong class="bold">Tera</strong>. In this book, we<a id="_idIndexMarker431"/> are going to use Tera as the template engine to simplify the development, but feel free to try the Handlebars engine as well. </p>
			<p>Tera is a template engine<a id="_idIndexMarker432"/> that is inspired by <strong class="bold">Jinja2</strong> and <strong class="bold">Django</strong> templates. You <a id="_idIndexMarker433"/>can find the documentation for Tera at https://tera.netlify.app/docs/. A <a id="_idIndexMarker434"/>Tera template is a text file with expressions, statements, and comments. The expressions, statements, and comments are replaced with variables and expressions when the template is rendered.</p>
			<p>For example, let's say we have a file named <strong class="source-inline">hello.txt.tera</strong>, with the following content:</p>
			<pre class="source-code">Hello {{ name }}!</pre>
			<p>If our program has a <strong class="source-inline">name</strong> variable with the value <strong class="source-inline">"Robert"</strong>, we can create a <strong class="source-inline">hello.txt</strong> file with the following content:</p>
			<pre class="source-code">Hello Robert!</pre>
			<p>As you can see, we <a id="_idIndexMarker435"/>can easily create HTML pages with Tera templates. In Tera, there are three delimiters we can use:</p>
			<ul>
				<li><strong class="source-inline">{{ }}</strong> for <strong class="bold">expressions</strong></li>
				<li><strong class="source-inline">{% %}</strong> for <strong class="bold">statements</strong></li>
				<li><strong class="source-inline">{# #}</strong> for <strong class="bold">comments</strong></li>
			</ul>
			<p>Suppose we have<a id="_idIndexMarker436"/> a template named <strong class="source-inline">hello.html.tera</strong> with the following content:</p>
			<pre class="source-code">&lt;div&gt;</pre>
			<pre class="source-code">    {# we are setting a variable 'name' with the value </pre>
			<pre class="source-code">    "Robert" #}</pre>
			<pre class="source-code">    {% set name = "Robert" %}</pre>
			<pre class="source-code">    Hello {{ name }}!</pre>
			<pre class="source-code">&lt;/div&gt;</pre>
			<p>We can render that template into a <strong class="source-inline">hello.html</strong> file with the following content:</p>
			<pre class="source-code">&lt;div&gt;</pre>
			<pre class="source-code">    Hello Robert!</pre>
			<pre class="source-code">&lt;/div&gt;</pre>
			<p>Tera also has other capabilities such as embedding other templates in a template, basic data operation, control structures, and functions. Basic data operations include basic mathematic operations, basic comparison functions, and string concatenations. Control structures include <strong class="source-inline">if</strong> branching, <strong class="source-inline">for</strong> loops, and other templates. Functions are defined procedures that return some text to be used in the template.</p>
			<p>We are going to learn more about some of those capabilities by changing the <strong class="source-inline">OurApplication</strong> responses to use the Tera template engine. Let's set up <strong class="source-inline">OurApplication</strong> to use the Tera template engine:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">Cargo.toml</strong> file, add the dependencies. We need the <strong class="source-inline">rocket_dyn_templates</strong> crate and the <strong class="source-inline">serde</strong> crate to serialize instances:<p class="source-code">chrono = <strong class="bold">{version =</strong> "0.4"<strong class="bold">, features = ["serde"]}</strong></p><p class="source-code">rocket_dyn_templates = {path = "../../../rocket/contrib/dyn_templates/", features = ["tera"]}</p><p class="source-code">serde = "1.0.130"</p></li>
				<li>Next, add<a id="_idIndexMarker437"/> a new configuration in <strong class="source-inline">Rocket.toml</strong> to designate a folder in which to place the template files:<p class="source-code">[default]</p><p class="source-code">...</p><p class="source-code">template_dir = "src/views"</p></li>
				<li>In <strong class="source-inline">src/main.rs</strong>, add the following lines to attach the <strong class="source-inline">rocket_dyn_templates::Template</strong> fairing to the application:<p class="source-code">use rocket_dyn_templates::Template;</p><p class="source-code">...</p><p class="source-code">#[launch]</p><p class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</p><p class="source-code">...</p><p class="source-code">rocket::build()</p><p class="source-code">...</p><p class="source-code">    .attach(Template::fairing())</p><p class="source-code">...</p><p class="source-code">}</p></li>
			</ol>
			<p>Adding the <strong class="source-inline">Template</strong> fairing is straightforward. We are going to learn about <strong class="source-inline">Template</strong> in the next section by replacing <strong class="source-inline">RawHtml</strong> with <strong class="source-inline">Template</strong>.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor105"/>Showcasing users</h1>
			<p>We are <a id="_idIndexMarker438"/>going to modify routes for <strong class="source-inline">/users/&lt;uuid&gt;</strong> and <strong class="source-inline">/users/</strong> by taking the following steps:</p>
			<ol>
				<li value="1">The first thing we need to do is to create a template. We already configured the folder for templates in <strong class="source-inline">/src/views</strong>, so create a <strong class="source-inline">views</strong> folder in the <strong class="source-inline">src</strong> folder and then, inside the <strong class="source-inline">views</strong> folder, create a template file named <strong class="source-inline">template.html.tera</strong>. </li>
				<li>We are going to use the file as the base HTML template for all HTML files. Inside <strong class="source-inline">src/views/template.html.tera</strong>, add HTML tags as follows:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">  &lt;meta charset="utf-8" /&gt;</p><p class="source-code">  &lt;title&gt;Our Application User&lt;/title&gt;</p><p class="source-code">  &lt;link href="/assets/mini-default.css" </p><p class="source-code">  rel="stylesheet"&gt;</p><p class="source-code">  &lt;link rel="icon" type="image/png" href="/assets/</p><p class="source-code">  favicon.png"&gt;</p><p class="source-code">  &lt;meta name="viewport" content="width=device-width, </p><p class="source-code">  initial-scale=1"&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">  &lt;div class="container"&gt;&lt;/div&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
			</ol>
			<p>Notice that we included a CSS file in the HTML file. You can download the open source CSS file <a id="_idIndexMarker439"/>from <a href="https://minicss.org/">https://minicss.org/</a> and put it inside the <strong class="source-inline">static</strong> folder. Since we already created a route to serve the static file in <strong class="source-inline">/assets/&lt;filename..&gt;</strong>, we can just use the route directly inside the HTML file.</p>
			<ol>
				<li value="3">For the next <a id="_idIndexMarker440"/>step, we need to include a part where we can put the HTML text we want to render and a part where we can insert <strong class="source-inline">flash</strong> messages. Modify <strong class="source-inline">src/views/template.html.tera</strong> as follows:<p class="source-code">&lt;div class="container"&gt;</p><p class="source-code">  <strong class="bold">{% if flash %}</strong></p><p class="source-code"><strong class="bold">    &lt;div class="toast" onclick="this.remove()"&gt;</strong></p><p class="source-code"><strong class="bold">      {{ flash | safe }}</strong></p><p class="source-code"><strong class="bold">    &lt;/div&gt;</strong></p><p class="source-code"><strong class="bold">  {% endif %}</strong></p><p class="source-code"><strong class="bold">  {% block body %}{% endblock body %}</strong></p><p class="source-code">&lt;/div&gt;</p></li>
			</ol>
			<p>By default, all variables are rendered escaped to avoid an XSS (Cross-Site Scripting) attack. We added the condition if there's a <strong class="source-inline">flash</strong> variable, we put the variable inside the <strong class="source-inline">{{ flash }}</strong> expression. To let the HTML tag render as it is and not escaped, we can use the <strong class="source-inline">| safe</strong> filter.</p>
			<p>Tera has other built-in filters such as <strong class="source-inline">lower</strong>, <strong class="source-inline">upper</strong>, <strong class="source-inline">capitalize</strong>, and many more. For the content, we are using <strong class="source-inline">block</strong> statements. The <strong class="source-inline">block</strong> statements mean we are going to include another template inside the statement. You can also see <strong class="source-inline">block</strong> ends with an <strong class="source-inline">endblock</strong> statement.</p>
			<ol>
				<li value="4">Tera can render any type that implements Serde's <strong class="source-inline">Serializable</strong> trait. Let's modify <strong class="source-inline">User</strong> and related types to implement the <strong class="source-inline">Serializable</strong> trait. In <strong class="source-inline">src/models/user.rs</strong>, modify the file as follows:<p class="source-code"><strong class="bold">use rocket::serde::Serialize;</strong></p><p class="source-code">...</p><p class="source-code">#[derive(Debug, FromRow, FromForm, <strong class="bold">Serialize</strong>)]</p><p class="source-code">pub struct User {</p><p class="source-code">...</p></li>
				<li>Modify <strong class="source-inline">src/models/user_status.rs</strong> as follows:<p class="source-code"><strong class="bold">use rocket::serde::Serialize;</strong></p><p class="source-code">...</p><p class="source-code">#[derive(sqlx::Type, Debug, FromFormField, <strong class="bold">Serialize</strong>)]</p><p class="source-code">#[repr(i32)]</p><p class="source-code">pub enum UserStatus {</p><p class="source-code">...</p></li>
				<li>Also, modify <strong class="source-inline">src/models/our_date_time.rs</strong> as<a id="_idIndexMarker441"/> follows:<p class="source-code"><strong class="bold">use rocket::serde::Serialize;</strong></p><p class="source-code">#[derive(Debug, sqlx::Type, Clone, <strong class="bold">Serialize</strong>)]</p><p class="source-code">#[sqlx(transparent)]</p><p class="source-code">pub struct OurDateTime(pub DateTime&lt;Utc&gt;);</p><p class="source-code">...</p></li>
				<li>For <strong class="source-inline">Pagination</strong>, we can derive <strong class="source-inline">Serialize</strong> as it is, but using a timestamp in an URL does not look good, for example, <strong class="source-inline">/users?pagination.next=</strong><strong class="bold">2021-12-01T13:09:13.060915Z</strong><strong class="source-inline">&amp;pagination.limit=2</strong>. We can make the pagination URL look better by converting <strong class="source-inline">OurDateTime</strong> into <strong class="source-inline">i64</strong> and vice versa. In <strong class="source-inline">src/models/pagination.rs</strong>, append the following lines:<p class="source-code">use rocket::serde::Serialize;</p><p class="source-code">...</p><p class="source-code">#[derive(Serialize)]</p><p class="source-code">pub struct PaginationContext {</p><p class="source-code">    pub next: i64,</p><p class="source-code">    pub limit: usize,</p><p class="source-code">}</p><p class="source-code">impl Pagination {</p><p class="source-code">    pub fn to_context(&amp;self) -&gt; PaginationContext {</p><p class="source-code">        PaginationContext {</p><p class="source-code">            next: self.next.0.timestamp_nanos(),</p><p class="source-code">            limit: self.limit,</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Since we <a id="_idIndexMarker442"/>are not going to use <strong class="source-inline">RawHtml</strong> anymore, remove the <strong class="source-inline">use rocket::response::content::RawHtml;</strong> directive from the <strong class="source-inline">src/routes/mod.rs</strong> file and modify the file as follows:<p class="source-code"><strong class="bold">use rocket_dyn_templates::Template;</strong></p><p class="source-code">...</p><p class="source-code">type HtmlResponse = Result&lt;<strong class="bold">Template</strong>, Status&gt;;</p></li>
				<li>In <strong class="source-inline">src/routes/user.rs</strong>, remove the <strong class="source-inline">use rocket::response::content::RawHtml</strong> directive. We are going to add the <strong class="source-inline">Template</strong> directive to make the response return <strong class="source-inline">Template</strong>, but we also need help from Serde's <strong class="source-inline">Serialize</strong> and <strong class="source-inline">context!</strong> macros to help convert objects into a Tera variable. Append the following lines:<p class="source-code">use rocket::serde::Serialize;</p><p class="source-code">...</p><p class="source-code">use rocket_dyn_templates::{context, Template};</p></li>
				<li>Then, we<a id="_idIndexMarker443"/> can modify the <strong class="source-inline">get_user</strong> function. Inside the <strong class="source-inline">get_user</strong> function in <strong class="source-inline">src/routes/user.rs</strong>, delete everything related to <strong class="source-inline">RawHtml</strong>. Delete all the lines starting from <strong class="source-inline">let mut html_string = String::from(USER_HTML_PREFIX);</strong> to <strong class="source-inline">Ok(RawHtml(html_string))</strong>.</li>
				<li>Then, replace the content of the deleted lines with the following lines:<p class="source-code">#[derive(Serialize)]</p><p class="source-code">struct GetUser {</p><p class="source-code">    user: User,</p><p class="source-code">    flash: Option&lt;String&gt;,</p><p class="source-code">}</p><p class="source-code">let flash_message = flash.map(|fm| String::from(fm.message()));</p><p class="source-code">let context = GetUser {</p><p class="source-code">    user,</p><p class="source-code">    flash: flash_message,</p><p class="source-code">};</p><p class="source-code">Ok(Template::render("users/show", &amp;context))</p></li>
			</ol>
			<p>Remember that the Tera template can use any Rust type that implements the <strong class="source-inline">Serializable</strong> trait. We define the <strong class="source-inline">GetUser</strong> struct that derives the <strong class="source-inline">Serializable</strong> trait. Since the <strong class="source-inline">User</strong> struct already implements <strong class="source-inline">Serializable</strong>, we can use it as a field inside the <strong class="source-inline">GetUser</strong> struct. After creating a new instance of <strong class="source-inline">GetUser</strong>, we then tell the application to render the <strong class="source-inline">"users/show"</strong> template file.</p>
			<ol>
				<li value="12">Since we have told the application that the template name is <strong class="source-inline">"users/show"</strong>, create a new<a id="_idIndexMarker444"/> folder named <strong class="source-inline">users</strong> inside <strong class="source-inline">src/views</strong>. Inside the <strong class="source-inline">src/views/users</strong> folder, create a new file, <strong class="source-inline">src/views/users/show.html.tera</strong>. After that, add these lines inside the file:<p class="source-code">{% extends "template" %}</p><p class="source-code">{% block body %}</p><p class="source-code">  {% include "users/_user" %}</p><p class="source-code">  &lt;a href="/users/edit/{{user.uuid}}" class="</p><p class="source-code">  button"&gt;Edit User&lt;/a&gt;</p><p class="source-code">  &lt;form accept-charset="UTF-8" action="/users/</p><p class="source-code">  delete/{{user.uuid}}" autocomplete="off" </p><p class="source-code">  method="POST" id="deleteUser"</p><p class="source-code">      class="hidden"&gt;&lt;/form&gt;</p><p class="source-code">  &lt;button type="submit" value="Submit" </p><p class="source-code">  form="deleteUser"&gt;Delete&lt;/button&gt;</p><p class="source-code">  &lt;a href="/users" class="button"&gt;User List&lt;/a&gt;</p><p class="source-code">{% endblock body %}</p></li>
			</ol>
			<p>The first statement, <strong class="source-inline">{% extends "template" %}</strong>, means we are extending <strong class="source-inline">src/views/template.html.tera</strong>, which we created earlier. The parent <strong class="source-inline">src/views/template.html.tera</strong> has a statement, <strong class="source-inline">{% block body %}{% endblock body %}</strong>, and we tell the Tera engine to override that block with content from the same block in <strong class="source-inline">src/views/users/show.html.tera</strong>.</p>
			<ol>
				<li value="13">Inside that code, we also see <strong class="source-inline">{% include "users/_user" %}</strong>, so let's create a <strong class="source-inline">src/views/users/_user.html.tera</strong> file and <a id="_idIndexMarker445"/>add the following lines:<p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-3"&gt;&lt;mark&gt;UUID:&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-9"&gt; {{ user.uuid }}&lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-3"&gt;&lt;mark&gt;Username:&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-9"&gt; {{ user.username }}&lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-3"&gt;&lt;mark&gt;Email:&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-9"&gt; {{ user.email }}&lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-3"&gt;&lt;mark&gt;</p><p class="source-code">  Description:&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-9"&gt; {{ user.description }}&lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-3"&gt;&lt;mark&gt;Status:&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-9"&gt; {{ user.status }}&lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-3"&gt;&lt;mark&gt;Created At:&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-9"&gt; {{ user.created_at }}&lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-3"&gt;&lt;mark&gt;Updated At:&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-9"&gt; {{ user.updated_at }}&lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p></li>
			</ol>
			<p>Inside<a id="_idIndexMarker446"/> both files, you will see there are many expressions, such as <strong class="source-inline">{{ user.username }}</strong>. These expressions are using the variable that we defined before: <strong class="source-inline">let context = GetUser { user, flash: flash_message,};</strong>. Then, we tell the application to render the template: <strong class="source-inline">Ok(Template::render("users/show", &amp;context))</strong>. </p>
			<p>You might be wondering why we split <strong class="source-inline">show.html.tera</strong> and <strong class="source-inline">_user.html.tera</strong>. One benefit of using a template system is that we can reuse a template. We want to reuse the same user HTML in the <strong class="source-inline">get_users</strong> function. </p>
			<ol>
				<li value="14">Let's modify the <strong class="source-inline">get_users</strong> function inside the <strong class="source-inline">src/routes/user.rs</strong> files. Delete the lines from <strong class="source-inline">let mut html_string = String::from(USER_HTML_PREFIX);</strong> to <strong class="source-inline">Ok(RawHtml(html_string))</strong>. Replace those lines with the following lines:<p class="source-code">let context = context! {users: users, pagination: new_pagination.map(|pg|pg.to_context())};</p><p class="source-code">Ok(Template::render("users/index", context))</p></li>
				<li>Instead of defining a new struct, such as <strong class="source-inline">GetUser</strong>, we are using the <strong class="source-inline">context!</strong> macro. By using the <strong class="source-inline">context!</strong> macro, we do not need to create a new type to be passed to the template. Now, create a new file named <strong class="source-inline">src/views/users/index.html.tera</strong>, and add the following lines to the file:<p class="source-code">{% extends "template" %}</p><p class="source-code">{% block body %}</p><p class="source-code">  {% for user in users %}</p><p class="source-code">    &lt;div class="container"&gt;</p><p class="source-code">      &lt;div&gt;&lt;mark class="tag"&gt;{{loop.</p><p class="source-code">      index}}&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">      {% include "users/_user" %}</p><p class="source-code">      &lt;a href="/users/{{ user.uuid }}" class="</p><p class="source-code">      button"&gt;See User&lt;/a&gt;</p><p class="source-code">      &lt;a href="/users/edit/{{ user.uuid }}" </p><p class="source-code">      class="button"&gt;Edit User&lt;/a&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  {% endfor %}</p><p class="source-code">  {% if pagination %}</p><p class="source-code">    &lt;a href="/users?pagination.next={{</p><p class="source-code">    pagination.next}}&amp;pagination.limit={{</p><p class="source-code">    pagination.limit}}" class="button"&gt;</p><p class="source-code">      Next</p><p class="source-code">    &lt;/a&gt;</p><p class="source-code">  {% endif %}</p><p class="source-code">  &lt;a href="/users/new" class="button"&gt;New user&lt;/a&gt;</p><p class="source-code">{% endblock %}</p></li>
			</ol>
			<p>We see<a id="_idIndexMarker447"/> two new things here: a <strong class="source-inline">{% for user in users %}...{% endfor %}</strong> statement, which can be used to iterate arrays, and <strong class="source-inline">{{loop.index}}</strong>, to get the current iteration inside the <strong class="source-inline">for</strong> loop.</p>
			<ol>
				<li value="16">We want to change the <strong class="source-inline">new_user</strong> and <strong class="source-inline">edit_user</strong> functions too, but before that, we want to see <strong class="source-inline">get_user</strong> and <strong class="source-inline">get_users</strong> in action. Since we already changed the <strong class="source-inline">HtmlResponse</strong> alias into <strong class="source-inline">Result&lt;Template, Status&gt;</strong>, we need to convert <strong class="source-inline">Ok(RawHtml(html_string))</strong> in <strong class="source-inline">new_user</strong> and <strong class="source-inline">edit_user</strong> to use a template too. Change <strong class="source-inline">Ok(RawHtml(html_string))</strong> in the <strong class="source-inline">new_user</strong> and <strong class="source-inline">edit_user</strong> functions to <strong class="source-inline">Ok(Template::render("users/tmp", context!()))</strong>, and create an empty <strong class="source-inline">src/views/users/tmp.html.tera</strong> file. </li>
				<li>Now, we <a id="_idIndexMarker448"/>can run the application and check the page that we have improved with CSS:</li>
			</ol>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_8.1_B16825.jpg" alt="Figure 8.1 – get_user() rendered&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – get_user() rendered</p>
			<p>We can see that the template is working along with the correct CSS file that the application served. In the next section, we will also modify the form to use the template.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor106"/>Working with forms</h1>
			<p>If we<a id="_idIndexMarker449"/> look at the structure of the form for <strong class="source-inline">new_user</strong> and <strong class="source-inline">edit_user</strong>, we can see that both forms are almost the same, with just a few differences. For example, the forms' <strong class="source-inline">action</strong> endpoints are different, as there are two extra fields for <strong class="source-inline">edit_user</strong>: <strong class="source-inline">_METHOD</strong> and <strong class="source-inline">old_password</strong>. To simplify, we can make one template to be used by both functions. Let's look at the steps:</p>
			<ol>
				<li value="1">Create a template called <strong class="source-inline">src/views/users/form.html.tera</strong>, and insert the following lines:<p class="source-code">{% extends "template" %}</p><p class="source-code">{% block body %}</p><p class="source-code">  &lt;form accept-charset="UTF-8" action="{{ form_url }}" </p><p class="source-code">  autocomplete="off" method="POST"&gt;</p><p class="source-code">    &lt;fieldset&gt;</p><p class="source-code">    &lt;/fieldset&gt;</p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">{% endblock %}</p></li>
				<li>Next, let's <a id="_idIndexMarker450"/>add the title to the form by adding a <strong class="source-inline">legend</strong> tag. Put this inside the <strong class="source-inline">fieldset</strong> tag:<p class="source-code">&lt;legend&gt;{{ legend }}&lt;/legend&gt;</p></li>
				<li>Under the <strong class="source-inline">legend</strong> tag, we can add an extra field if we are editing the user:<p class="source-code">{% if edit %}</p><p class="source-code">  &lt;input type="hidden" name="_METHOD" value="PUT" /&gt;</p><p class="source-code">{% endif %}</p></li>
				<li>Continuing with the field, add the fields for <strong class="source-inline">username</strong> and <strong class="source-inline">email</strong> as follows:<p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-12 col-md-3"&gt;</p><p class="source-code">    &lt;label for="username"&gt;Username:&lt;/label&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-12 col-md"&gt;</p><p class="source-code">    &lt;input name="username" type="text" value="{{ </p><p class="source-code">    user.username }}"/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-12 col-md-3"&gt;</p><p class="source-code">    &lt;label for="email"&gt;Email:&lt;/label&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-12 col-md"&gt;</p><p class="source-code">    &lt;input name="email" type="email" value="{{ </p><p class="source-code">    user.email }}"/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p></li>
				<li>Add a <a id="_idIndexMarker451"/>conditional <strong class="source-inline">old_password</strong> field after the <strong class="source-inline">email</strong> field:<p class="source-code">{% if edit %}</p><p class="source-code">  &lt;div class="row"&gt;</p><p class="source-code">    &lt;div class="col-sm-12 col-md-3"&gt;</p><p class="source-code">      &lt;label for="old_password"&gt;Old password:&lt;/label&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;div class="col-sm-12 col-md"&gt;</p><p class="source-code">      &lt;input name="old_password" type="password" /&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">{% endif %}</p></li>
				<li>Add the rest of the fields:<p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-12 col-md-3"&gt;</p><p class="source-code">    &lt;label for="password"&gt;Password:&lt;/label&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-12 col-md"&gt;</p><p class="source-code">    &lt;input name="password" type="password" /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-12 col-md-3"&gt;</p><p class="source-code">    &lt;label for="password_confirmation"&gt;Password </p><p class="source-code">    Confirmation:&lt;/label&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-12 col-md"&gt;</p><p class="source-code">    &lt;input name="password_confirmation" type=</p><p class="source-code">    "password" /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">  &lt;div class="col-sm-12 col-md-3"&gt;</p><p class="source-code">    &lt;label for="description"&gt;Tell us a little bit more </p><p class="source-code">    about yourself:&lt;/label&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">  &lt;div class="col-sm-12 col-md"&gt;</p><p class="source-code">    &lt;textarea name="description"&gt;{{ user.description </p><p class="source-code">    }}&lt;/textarea&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;button type="submit" value="Submit"&gt;Submit&lt;/button&gt;</p></li>
				<li>Then, change <a id="_idIndexMarker452"/>the labels and fields to show the value (if there is a value):<p class="source-code">&lt;input name="username" type="text" {% if user %}value="{{ user.username }}"{% endif %} /&gt;</p><p class="source-code">...</p><p class="source-code">&lt;input name="email" type="email" {% if user %}value="{{ user.email }}"{% endif %} /&gt;</p><p class="source-code">...</p><p class="source-code">&lt;label for="password"&gt;{% if edit %}New Password:{% else %}Password:{% endif %}&lt;/label&gt;</p><p class="source-code">...</p><p class="source-code">&lt;textarea name="description"&gt;{% if user %}{{ user.description }}{% endif %}&lt;/textarea&gt;</p></li>
				<li>After we have created the form template, we can modify the <strong class="source-inline">new_user</strong> and <strong class="source-inline">edit_user</strong> functions. In <strong class="source-inline">new_user</strong>, remove the lines from <strong class="source-inline">let mut html_string = String::from(USER_HTML_PREFIX);</strong> to <strong class="source-inline">Ok(Template::render("users/tmp", context!()))</strong> to create <strong class="source-inline">RawHtml</strong>.</li>
			</ol>
			<p>In <strong class="source-inline">form.html.tera</strong>, we added these variables: <strong class="source-inline">form_url</strong>, <strong class="source-inline">edit</strong>, and <strong class="source-inline">legend</strong>. We also need to convert <strong class="source-inline">Option&lt;FlashMessage&lt;'_&gt;&gt;</strong> into a <strong class="source-inline">String</strong> since the default implementation of the <strong class="source-inline">Serializable</strong> trait by <strong class="source-inline">FlashMessage</strong> is not human-readable. Add those variables and render the template in the <strong class="source-inline">new_user</strong> function as follows:</p>
			<p class="source-code">let flash_string = flash</p>
			<p class="source-code">    .map(|fl| format!("{}", fl.message()))</p>
			<p class="source-code">    .unwrap_or_else(|| "".to_string());</p>
			<p class="source-code">let context = context! {</p>
			<p class="source-code">    edit: false,</p>
			<p class="source-code">    form_url: "/users",</p>
			<p class="source-code">    legend: "New User",</p>
			<p class="source-code">    flash: flash_string,</p>
			<p class="source-code">};</p>
			<p class="source-code">Ok(Template::render("users/form", context))</p>
			<ol>
				<li value="9">For <strong class="source-inline">edit_user</strong>, we can<a id="_idIndexMarker453"/> create the same variables, but this time, we know the data for <strong class="source-inline">user</strong> so we can include <strong class="source-inline">user</strong> in the context. Delete the lines in the <strong class="source-inline">edit_user</strong> function in <strong class="source-inline">src/routes/user.rs</strong> from <strong class="source-inline">let mut html_string = String::from(USER_HTML_PREFIX);</strong> to <strong class="source-inline">Ok(Template::render("users/tmp", context!()))</strong>.</li>
			</ol>
			<p>Replace those lines with the following code:</p>
			<p class="source-code">let flash_string = flash</p>
			<p class="source-code">    .map(|fl| format!("{}", fl.message()))</p>
			<p class="source-code">    .unwrap_or_else(|| "".to_string());</p>
			<p class="source-code">let context = context! {</p>
			<p class="source-code">    form_url: format!("/users/{}",&amp;user.uuid ),</p>
			<p class="source-code">    edit: true,</p>
			<p class="source-code">    legend: "Edit User",</p>
			<p class="source-code">    flash: flash_string,</p>
			<p class="source-code">    user,</p>
			<p class="source-code">};</p>
			<p class="source-code">Ok(Template::render("users/form", context))</p>
			<ol>
				<li value="10">As the final touch, we can remove the <strong class="source-inline">USER_HTML_PREFIX</strong> and <strong class="source-inline">USER_HTML_SUFFIX</strong> constants from <strong class="source-inline">src/routes/user.rs</strong>. We should also remove the <strong class="source-inline">src/views/users/tmp.html.tera</strong> file since there's no function using that file anymore. And, since we already enclose the flash message inside the <strong class="source-inline">&lt;div&gt;&lt;/div&gt;</strong> tag in the template, we can remove the <strong class="source-inline">div</strong> usage from<a id="_idIndexMarker454"/> flash messages. For example, in <strong class="source-inline">src/routes/user.rs</strong>, we can modify these lines:<p class="source-code">Ok(Flash::success(</p><p class="source-code">    Redirect::to(format!("/users/{}", user.uuid)),</p><p class="source-code">    <strong class="bold">"&lt;div&gt;</strong>Successfully created user<strong class="bold">&lt;/div&gt;</strong>",</p><p class="source-code">))</p></li>
			</ol>
			<p>We can modify them into the following lines:</p>
			<p class="source-code">Ok(Flash::success(</p>
			<p class="source-code">    Redirect::to(format!("/users/{}", user.uuid)),</p>
			<p class="source-code">    "Successfully created user",</p>
			<p class="source-code">))</p>
			<p>One more thing that we can improve for the form is adding a token to secure the application<a id="_idIndexMarker455"/> from <strong class="bold">cross-site request forgery</strong> (<strong class="bold">CSRF</strong>) attacks. We will learn how to secure our form in the next section.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/>Securing HTML forms from CSRF</h1>
			<p>One<a id="_idIndexMarker456"/> of the <a id="_idIndexMarker457"/>most common security attacks is CSRF, where a malicious third party tricks a user into sending a web form with different values than intended. One way to mitigate this attack is by sending a one-time token along with the form content. The web server then checks the token validity to ensure the request comes from the correct web browser.</p>
			<p>We can create such a token in a Rocket application by creating a fairing that will generate a token and check the form value sent back. Let's look at the steps:</p>
			<ol>
				<li value="1">First, we need to add the dependencies for this. We are going to need a <strong class="source-inline">base64</strong> crate to encode and decode binary values into a string. We also need the <strong class="source-inline">secrets</strong> feature from Rocket to store and retrieve private cookies. Private cookies are just like regular cookies, but they are encrypted by the key we configured in the <strong class="source-inline">Rocket.toml</strong> file with <strong class="source-inline">secret_key</strong>.</li>
			</ol>
			<p>For <a id="_idIndexMarker458"/>dependencies, we also need to add <strong class="source-inline">time</strong> as a <a id="_idIndexMarker459"/>dependency. Add the following lines in <strong class="source-inline">Cargo.toml</strong>:</p>
			<p class="source-code"><strong class="bold">base64 = {version = "0.13.0"}</strong></p>
			<p class="source-code">...</p>
			<p class="source-code">rocket = {path = "../../../rocket/core/lib/", features = ["uuid", "json", <strong class="bold">"secrets"</strong>]}</p>
			<p class="source-code">...</p>
			<p class="source-code"><strong class="bold">time = {version = "0.3", features = ["std"]}</strong></p>
			<p>The steps for preventing CSRF are generating a random byte, storing the random byte in a private cookie, hashing the random byte as a string, and rendering the form template along with the token string. When the user sends the token back, we can retrieve the token from the cookie and compare both.</p>
			<ol>
				<li value="2">To make a CSRF fairing, add a new module. In <strong class="source-inline">src/fairings/mod.rs</strong>, add the new module:<p class="source-code">pub mod csrf;</p></li>
				<li>After that, create a file named <strong class="source-inline">src/fairings/csrf.rs</strong> and add the dependencies and constants for the default value for the cookie to store the random bytes:<p class="source-code">use argon2::{</p><p class="source-code">    password_hash::{</p><p class="source-code">        rand_core::{OsRng, RngCore},</p><p class="source-code">        PasswordHash, PasswordHasher, </p><p class="source-code">        PasswordVerifier, SaltString,</p><p class="source-code">    },</p><p class="source-code">    Argon2,</p><p class="source-code">};</p><p class="source-code">use rocket::fairing::{self, Fairing, Info, Kind};</p><p class="source-code">use rocket::http::{Cookie, Status};</p><p class="source-code">use rocket::request::{FromRequest, Outcome, Request};</p><p class="source-code">use rocket::serde::Serialize;</p><p class="source-code">use rocket::{Build, Data, Rocket};</p><p class="source-code">use time::{Duration, OffsetDateTime};</p><p class="source-code">const CSRF_NAME: &amp;str = "csrf_cookie";</p><p class="source-code">const CSRF_LENGTH: usize = 32;</p><p class="source-code">const CSRF_DURATION: Duration = Duration::hours(1);</p></li>
			</ol>
			<p>Then, we <a id="_idIndexMarker460"/>can extend Rocket's <strong class="source-inline">Request</strong> with<a id="_idIndexMarker461"/> a new method to retrieve the CSRF token. Because <strong class="source-inline">Request</strong> is an external crate, we cannot add another method, but we can overcome this by adding a trait and making the external crate type extend this trait. We cannot extend an external crate with an external trait, but extending an external crate with an internal trait is permissible.</p>
			<ol>
				<li value="4">We want to create a method to retrieve CSRF tokens from private cookies. Continue with <strong class="source-inline">src/fairings/csrf.rs</strong> by appending the following lines:<p class="source-code">trait RequestCsrf {</p><p class="source-code">    fn get_csrf_token(&amp;self) -&gt; Option&lt;Vec&lt;u8&gt;&gt;;</p><p class="source-code">}</p><p class="source-code">impl RequestCsrf for Request&lt;'_&gt; {</p><p class="source-code">    fn get_csrf_token(&amp;self) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {</p><p class="source-code">        self.cookies()</p><p class="source-code">            .get_private(CSRF_NAME)</p><p class="source-code">            .and_then(|cookie| base64::</p><p class="source-code">            decode(cookie.value()).ok())</p><p class="source-code">            .and_then(|raw| {</p><p class="source-code">                if raw.len() &gt;= CSRF_LENGTH {</p><p class="source-code">                    Some(raw)</p><p class="source-code">                } else {</p><p class="source-code">                    None</p><p class="source-code">                }</p><p class="source-code">            })</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>After that, we <a id="_idIndexMarker462"/>want to add a fairing that retrieves or <a id="_idIndexMarker463"/>generates, and stores random bytes if the cookie does not exist. Add a new struct to be managed as a fairing:<p class="source-code">#[derive(Debug, Clone)]</p><p class="source-code">pub struct Csrf {}</p><p class="source-code">impl Csrf {</p><p class="source-code">    pub fn new() -&gt; Self {</p><p class="source-code">        Self {}</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">#[rocket::async_trait]</p><p class="source-code">impl Fairing for Csrf {</p><p class="source-code">    fn info(&amp;self) -&gt; Info {</p><p class="source-code">        Info {</p><p class="source-code">            name: "CSRF Fairing",</p><p class="source-code">            kind: Kind::Ignite | Kind::Request,</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    async fn on_ignite(&amp;self, rocket: Rocket&lt;Build&gt;) –</p><p class="source-code">    &gt; fairing::Result {</p><p class="source-code">        Ok(rocket.manage(self.clone()))</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>We want<a id="_idIndexMarker464"/> to retrieve the token first, and if the<a id="_idIndexMarker465"/> token does not exist, generate random bytes and add the bytes to the private token. Inside the <strong class="source-inline">impl Fairing</strong> block, add the <strong class="source-inline">on_request</strong> function:<p class="source-code">async fn on_request(&amp;self, request: &amp;mut Request&lt;'_&gt;, _: &amp;mut Data&lt;'_&gt;) {</p><p class="source-code">    if let Some(_) = request.get_csrf_token() {</p><p class="source-code">        return;</p><p class="source-code">    }</p><p class="source-code">    let mut key = vec![0; CSRF_LENGTH];</p><p class="source-code">    OsRng.fill_bytes(&amp;mut key);</p><p class="source-code">    let encoded = base64::encode(&amp;key[..]);</p><p class="source-code">    let expires = OffsetDateTime::now_utc() + CSRF_</p><p class="source-code">    DURATION;</p><p class="source-code">    let mut csrf_cookie = Cookie::new(</p><p class="source-code">    String::from(CSRF_NAME), encoded);</p><p class="source-code">    csrf_cookie.set_expires(expires);</p><p class="source-code">    request.cookies().add_private(csrf_cookie);</p><p class="source-code">}</p></li>
				<li>We need a<a id="_idIndexMarker466"/> request guard to retrieve the token <a id="_idIndexMarker467"/>string from the request. Append the following lines:<p class="source-code">#[derive(Debug, Serialize)]</p><p class="source-code">pub struct Token(String);</p><p class="source-code">#[rocket::async_trait]</p><p class="source-code">impl&lt;'r&gt; FromRequest&lt;'r&gt; for Token {</p><p class="source-code">    type Error = ();</p><p class="source-code">    async fn from_request(request: &amp;'r Request&lt;'_&gt;) -&gt; </p><p class="source-code">    Outcome&lt;Self, Self::Error&gt; {</p><p class="source-code">        match request.get_csrf_token() {</p><p class="source-code">            None =&gt; Outcome::Failure((Status::</p><p class="source-code">            Forbidden, ())),</p><p class="source-code">            Some(token) =&gt; Outcome::</p><p class="source-code">            Success(Self(base64::encode(token))),</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>We <a id="_idIndexMarker468"/>return an HTTP <strong class="source-inline">403</strong> status code if the token is not found. We also need two more functions: generating a hash and comparing<a id="_idIndexMarker469"/> the token hash with other strings. Since we already use <strong class="source-inline">argon2</strong> for password hashing, we can reuse the <strong class="source-inline">argon2</strong> crate for those functions. Append the following lines:<p class="source-code">impl Token {</p><p class="source-code">    pub fn generate_hash(&amp;self) -&gt; Result&lt;String, </p><p class="source-code">    String&gt; {</p><p class="source-code">        let salt = SaltString::generate(&amp;mut OsRng);</p><p class="source-code">        Argon2::default()</p><p class="source-code">            .hash_password(self.0.as_bytes(), &amp;salt)</p><p class="source-code">            .map(|hp| hp.to_string())</p><p class="source-code">            .map_err(|_| String::from("cannot hash </p><p class="source-code">            authenticity token"))</p><p class="source-code">    }</p><p class="source-code">    pub fn verify(&amp;self, form_authenticity_token: </p><p class="source-code">    &amp;str) -&gt; Result&lt;(), String&gt; {</p><p class="source-code">        let old_password_hash = self.generate_hash()?;</p><p class="source-code">        let parsed_hash = PasswordHash::new(&amp;old_</p><p class="source-code">        password_hash)</p><p class="source-code">            .map_err(|_| String::from("cannot verify </p><p class="source-code">            authenticity token"))?;</p><p class="source-code">        Ok(Argon2::default()</p><p class="source-code">            .verify_password(form_authenticity_</p><p class="source-code">            token.as_bytes(), &amp;parsed_hash)</p><p class="source-code">            .map_err(|_| String::from("cannot verify </p><p class="source-code">            authenticity token"))?)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>After we<a id="_idIndexMarker470"/> set up the <strong class="source-inline">Csrf</strong> fairing, we can use it<a id="_idIndexMarker471"/> in the application. In <strong class="source-inline">src/main.rs</strong>, attach the fairing to the Rocket application:<p class="source-code">use our_application::fairings::{csrf::Csrf, db::DBConnection};</p><p class="source-code">...</p><p class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</p><p class="source-code">...</p><p class="source-code">        .attach(Csrf::new())</p><p class="source-code">...</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">src/models/user.rs</strong>, add a new field to contain the token sent from the form:<p class="source-code">pub struct NewUser&lt;'r&gt; {</p><p class="source-code">...</p><p class="source-code">    pub authenticity_token: &amp;'r str,</p><p class="source-code">}</p><p class="source-code">...</p><p class="source-code">pub struct EditedUser&lt;'r&gt; {</p><p class="source-code">...</p><p class="source-code">    pub authenticity_token: &amp;'r str,</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">src/views/users/form.html.tera</strong>, add <a id="_idIndexMarker472"/>the field to store the token string:<p class="source-code">&lt;form accept-charset="UTF-8" action="{{ form_url }}" autocomplete="off" method="POST"&gt;</p><p class="source-code">  &lt;input type="hidden" name="authenticity_token" </p><p class="source-code">  value="{{ csrf_token }}"/&gt;</p><p class="source-code">...</p></li>
				<li>Finally, we<a id="_idIndexMarker473"/> can modify <strong class="source-inline">src/routes/user.rs</strong>. Add the <strong class="source-inline">Token</strong> dependency:<p class="source-code">use crate::fairings::csrf::Token as CsrfToken;</p></li>
				<li>We can use <strong class="source-inline">CsrfToken</strong> as a request guard, pass the token to the template, and render the template as HTML:<p class="source-code">pub async fn new_user(flash: Option&lt;FlashMessage&lt;'_&gt;&gt;, csrf_token: CsrfToken) -&gt; HtmlResponse {</p><p class="source-code">...</p><p class="source-code">    let context = context! {</p><p class="source-code">        ...</p><p class="source-code">        csrf_token: csrf_token,</p><p class="source-code">    };</p><p class="source-code">    ...</p><p class="source-code">}</p><p class="source-code">...</p><p class="source-code">pub async fn edit_user(</p><p class="source-code">    mut db: Connection&lt;DBConnection&gt;, uuid: &amp;str, </p><p class="source-code">    flash: Option&lt;FlashMessage&lt;'_&gt;&gt;, csrf_token: </p><p class="source-code">    CsrfToken) -&gt; HtmlResponse {</p><p class="source-code">...</p><p class="source-code">    let context = context! {</p><p class="source-code">        ...</p><p class="source-code">        csrf_token: csrf_token,</p><p class="source-code">    };</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Modify <a id="_idIndexMarker474"/>the <strong class="source-inline">create_user</strong> function to verify the<a id="_idIndexMarker475"/> token and return if the hash does not match:<p class="source-code">pub async fn create_user&lt;'r&gt;(</p><p class="source-code">    ...</p><p class="source-code">    csrf_token: CsrfToken,</p><p class="source-code">) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {</p><p class="source-code">    …</p><p class="source-code">    let new_user = user_context.value.as_ref().</p><p class="source-code">    unwrap();</p><p class="source-code">    csrf_token</p><p class="source-code">        .verify(&amp;new_user.authenticity_token)</p><p class="source-code">        .map_err(|_| {</p><p class="source-code">            Flash::error(</p><p class="source-code">                Redirect::to("/users/new"),</p><p class="source-code">                "Something went wrong when creating </p><p class="source-code">                user",</p><p class="source-code">            )</p><p class="source-code">        })?;</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Do the<a id="_idIndexMarker476"/> same <a id="_idIndexMarker477"/>with the <strong class="source-inline">update_user</strong>, <strong class="source-inline">put_user</strong>, and <strong class="source-inline">patch_user</strong> functions as well:<p class="source-code">pub async fn update_user&lt;'r&gt;(</p><p class="source-code">    ...</p><p class="source-code">    csrf_token: CsrfToken,</p><p class="source-code">) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {</p><p class="source-code">    ...</p><p class="source-code">    match user_value.method {</p><p class="source-code">        "PUT" =&gt; put_user(db, uuid, user_context, </p><p class="source-code">        csrf_token).await,</p><p class="source-code">        "PATCH" =&gt; patch_user(db, uuid, user_context, </p><p class="source-code">        csrf_token).await,</p><p class="source-code">        ...</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">...</p><p class="source-code">pub async fn put_user&lt;'r&gt;(</p><p class="source-code">    ...</p><p class="source-code">    csrf_token: CsrfToken,</p><p class="source-code">) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {</p><p class="source-code">    let user_value = user_context.value.as_ref().</p><p class="source-code">    unwrap();</p><p class="source-code">    csrf_token</p><p class="source-code">        .verify(&amp;user_value.authenticity_token)</p><p class="source-code">        .map_err(|_| {</p><p class="source-code">            Flash::error(</p><p class="source-code">                Redirect::to(format!("/users/edit/{}",</p><p class="source-code">                uuid)),</p><p class="source-code">                "Something went wrong when updating </p><p class="source-code">                user",</p><p class="source-code">            )</p><p class="source-code">        })?;</p><p class="source-code">    …</p><p class="source-code">}</p><p class="source-code">…</p><p class="source-code">pub async fn patch_user&lt;'r&gt;(</p><p class="source-code">    ...</p><p class="source-code">    csrf_token: CsrfToken,</p><p class="source-code">) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {</p><p class="source-code">    put_user(db, uuid, user_context, csrf_token).await</p><p class="source-code">}</p></li>
			</ol>
			<p>After <a id="_idIndexMarker478"/>that, try <a id="_idIndexMarker479"/>relaunching the application and sending the form without the token. We should see the application return an HTTP <strong class="source-inline">403</strong> status code. CSRF is one of the most common web attacks, but we have learned how to mitigate the attack by using Rocket features.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Summary</h1>
			<p>In this chapter, we have learned about three things that are common for a web application. The first one is learning how to make the Rocket application serve static files by using either <strong class="source-inline">PathBuf</strong> or the <strong class="source-inline">FileServer</strong> struct.</p>
			<p>Another thing we have learned is how to use <strong class="source-inline">rocket_dyn_templates</strong> to convert a template into a response to the client. We also learned about a template engine, Tera, and the various capabilities of the Tera template engine.</p>
			<p>By utilizing static assets and templates, we can easily create modern web applications. In the next chapter, we are going to learn about user posts: text, picture, and video.</p>
		</div>
	</body></html>