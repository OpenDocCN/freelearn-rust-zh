<html><head></head><body>
		<div><h1 id="_idParaDest-101"><em class="italic"><a id="_idTextAnchor101"/>Chapter 8</em>: Serving Static Assets and Templates</h1>
			<p>One of the common functions of a web application is serving static files such as <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) or <strong class="bold">JavaScript</strong> (<strong class="bold">JS</strong>) files. In this chapter, we are going to learn about serving static assets from the Rocket application.</p>
			<p>One common task for a web framework is rendering a template into HTML files. We are going to learn about using the Tera template to render HTML from the Rocket application. </p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Serving static assets</li>
				<li>Introducing the Tera template</li>
				<li>Showcasing users</li>
				<li>Working with forms</li>
				<li>Securing HTML forms from CSRF</li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Technical requirements</h1>
			<p>For this chapter, we have the same technical requirements as the previous chapter. We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database server.</p>
			<p>For the text editor, you can try adding an extension supporting the Tera template. If there is no extension for Tera, try adding an extension for a Jinja2 or Django template and set the file association to include the <code>*.tera</code> file.</p>
			<p>We are going to add CSS to our application, and we are going to use stylesheets from <a href="https://minicss.org/">https://minicss.org/</a> since it's small and open source. Feel free to use and modify the example HTML with other stylesheets.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter08">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter08</a>.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Serving static assets</h1>
			<p>Serving static assets (such as HTML files, JS files, or CSS files) is a very common task for a web application. We <a id="_idIndexMarker420"/>can make Rocket serve files as well. Let's create the first function to serve a favicon. Previously you might have noticed that some web browsers requested a favicon file from our server, even though we did not explicitly mention it on our served HTML page. Let's look at the steps:</p>
			<ol>
				<li>In the application root folder, create a folder named <code>static</code>. Inside the <code>static</code> folder, add a file named <code>favicon.png</code>. You can find sample <code>favicon.png</code> files on the internet or use the file from the sample source code for this chapter.</li>
				<li>In <code>src/main.rs</code>, add a new route:<pre>routes![
    ...
    routes::favicon,
],</pre></li>
				<li>In <code>src/routes/mod.rs</code>, add a new route handling function to serve <code>favicon.png</code>:<pre>use rocket::fs::{relative, NamedFile};
use std::path::Path;
...
#[get("/favicon.png")]
pub async fn favicon() -&gt; NamedFile {
    NamedFile::open(Path::new(relative!("static/
    favicon.png")))
        .await
        .ok()
        .unwrap()
}</pre></li>
			</ol>
			<p>Here, <code>relative!</code> is a macro that generates a crate-relative version of a path. This means that the macro refers to the folder of the source file or the generated binary. For example, we have the source file for this application in <code>/some/source</code>, and by saying <code>relative!("static/favicon.png")</code>, it means the path is <code>/some/source/static/favicon.png</code>.</p>
			<p>Every time we want to serve a particular file, we can create a route handling function, return <code>NamedFile</code>, and mount the route to Rocket. But obviously, this approach is not good; we can create a function to return static files dynamically.</p>
			<ol>
				<li value="4">Let's <a id="_idIndexMarker421"/>reuse the <code>assets</code> function that we created when we made the application skeleton. Previously, in <a href="B16825_03_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>, <em class="italic">Rocket Requests and Responses</em>, we learned that we can use multiple segments in a route. We can leverage this and serve a file that has the same filename with the request's multiple segments.</li>
			</ol>
			<p>Delete the favicon function that we created earlier and remove the reference to the function from <code>src/main.rs</code>. In <code>src/routes/mod.rs</code>, modify the <code>use</code> declarations:</p>
			<pre>use rocket::fs::<strong class="bold">{relative</strong>, NamedFile<strong class="bold">}</strong>;
<strong class="bold">use std::path::{Path, PathBuf};</strong></pre>
			<ol>
				<li value="5">The application should return an HTTP <code>404</code> status code if the application cannot find the requested file. We can easily return <code>404</code> status code by wrapping <code>NamedFile</code> inside <code>Option</code>. If <code>NamedFile</code> is <code>None</code>, then the response will have <code>404</code> status automatically. Modify the <code>assets</code> function signature in <code>src/routes/mod.rs</code>:<pre>#[get<strong class="bold">("/&lt;filename..&gt;</strong>")]
pub async fn assets(<strong class="bold">filename: PathBuf</strong>) -&gt; <strong class="bold">Option&lt;NamedFile&gt;</strong> {}</pre></li>
				<li>We can then implement the <code>assets</code> function:<pre>let mut filename = Path::new(relative!("static")).join(filename);
NamedFile::open(filename).await.ok()</pre></li>
				<li>Unfortunately, Rocket <a id="_idIndexMarker422"/>returns an HTTP <code>200</code> status code if filename is a directory, so an attacker can try attacking and mapping the folder structure inside the <code>static</code> folder. Let's handle this case by adding these lines:<pre>let mut filename = Path::new(relative!("static")).join(filename);
<strong class="bold">if filename.is_dir() {</strong>
<strong class="bold">    filename.push("index.html");</strong>
<strong class="bold">}</strong>
NamedFile::open(filename).await.ok()</pre></li>
			</ol>
			<p>If an attacker tries to systematically check the path inside the static file, the attacker will be served with an HTTP <code>404</code> status code and will not be able to infer the folder structures inside the <code>static</code> folder.</p>
			<ol>
				<li value="8">There's another way to serve the static file: by using the built-in <code>rocket::fs::FileServer</code> struct. Remove the function to handle static assets in <code>src/routes/mod.rs</code>, and append the following lines in <code>src/main.rs</code>:<pre><strong class="bold">use rocket::fs::relative;</strong>
<strong class="bold">use rocket::fs::FileServer;</strong>
...
.mount("/assets", <strong class="bold">FileServer::from(</strong>
<strong class="bold"> relative!("static"))</strong>)</pre></li>
			</ol>
			<p>Even though web frameworks such as Rocket can serve static files, it's more common to serve static files behind web servers such as Apache Web Server or NGINX. In more advanced setups, people also utilize cloud storage, such as Amazon Web Services S3 or Google Cloud Storage, in <a id="_idIndexMarker423"/>conjunction <a id="_idIndexMarker424"/>with a <strong class="bold">Content Delivery Network </strong>(<strong class="bold">CDN</strong>).</p>
			<p>In the next section, we are going to refine the HTML that we created in <a href="B16825_06_ePub.xhtml#_idTextAnchor083"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing User CRUD</em>.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/>Introducing the Tera template</h1>
			<p>In<a id="_idIndexMarker425"/> web applications, there's usually a part that works as a web template system. Web designers and web developers can create web templates, and the web application generates HTML pages from the templates.</p>
			<p>There are different kinds <a id="_idIndexMarker426"/>of web templates: server-side web templates (in which the template is rendered on the server-side), client-side web templates (where client-side applications render the template), or hybrid web<a id="_idIndexMarker427"/> templates.</p>
			<p>There are a couple <a id="_idIndexMarker428"/>of templating engines<a id="_idIndexMarker429"/> in Rust. We can find templating engines for web <a id="_idIndexMarker430"/>development (such as <strong class="bold">Handlebars</strong>, <strong class="bold">Tera</strong>, <strong class="bold">Askama</strong>, or <strong class="bold">Liquid</strong>) at <a href="https://crates.io">https://crates.io</a> or https:/lib.rs.</p>
			<p>The Rocket web framework has built-in support for templating in the form of the <code>rocket_dyn_templates</code> crate. Currently, the crate only supports two engines: <strong class="bold">Handlebars</strong> and <strong class="bold">Tera</strong>. In this book, we<a id="_idIndexMarker431"/> are going to use Tera as the template engine to simplify the development, but feel free to try the Handlebars engine as well. </p>
			<p>Tera is a template engine<a id="_idIndexMarker432"/> that is inspired by <strong class="bold">Jinja2</strong> and <strong class="bold">Django</strong> templates. You <a id="_idIndexMarker433"/>can find the documentation for Tera at https://tera.netlify.app/docs/. A <a id="_idIndexMarker434"/>Tera template is a text file with expressions, statements, and comments. The expressions, statements, and comments are replaced with variables and expressions when the template is rendered.</p>
			<p>For example, let's say we have a file named <code>hello.txt.tera</code>, with the following content:</p>
			<pre class="source-code">Hello {{ name }}!</pre>
			<p>If our program has a <code>name</code> variable with the value <code>"Robert"</code>, we can create a <code>hello.txt</code> file with the following content:</p>
			<pre class="source-code">Hello Robert!</pre>
			<p>As you can see, we <a id="_idIndexMarker435"/>can easily create HTML pages with Tera templates. In Tera, there are three delimiters we can use:</p>
			<ul>
				<li><code>{{ }}</code> for <strong class="bold">expressions</strong></li>
				<li><code>{% %}</code> for <strong class="bold">statements</strong></li>
				<li><code>{# #}</code> for <strong class="bold">comments</strong></li>
			</ul>
			<p>Suppose we have<a id="_idIndexMarker436"/> a template named <code>hello.html.tera</code> with the following content:</p>
			<pre class="source-code">&lt;div&gt;</pre>
			<pre class="source-code">    {# we are setting a variable 'name' with the value </pre>
			<pre class="source-code">    "Robert" #}</pre>
			<pre class="source-code">    {% set name = "Robert" %}</pre>
			<pre class="source-code">    Hello {{ name }}!</pre>
			<pre class="source-code">&lt;/div&gt;</pre>
			<p>We can render that template into a <code>hello.html</code> file with the following content:</p>
			<pre class="source-code">&lt;div&gt;</pre>
			<pre class="source-code">    Hello Robert!</pre>
			<pre class="source-code">&lt;/div&gt;</pre>
			<p>Tera also has other capabilities such as embedding other templates in a template, basic data operation, control structures, and functions. Basic data operations include basic mathematic operations, basic comparison functions, and string concatenations. Control structures include <code>if</code> branching, <code>for</code> loops, and other templates. Functions are defined procedures that return some text to be used in the template.</p>
			<p>We are going to learn more about some of those capabilities by changing the <code>OurApplication</code> responses to use the Tera template engine. Let's set up <code>OurApplication</code> to use the Tera template engine:</p>
			<ol>
				<li value="1">In the <code>Cargo.toml</code> file, add the dependencies. We need the <code>rocket_dyn_templates</code> crate and the <code>serde</code> crate to serialize instances:<pre>chrono = <strong class="bold">{version =</strong> "0.4"<strong class="bold">, features = ["serde"]}</strong>
rocket_dyn_templates = {path = "../../../rocket/contrib/dyn_templates/", features = ["tera"]}
serde = "1.0.130"</pre></li>
				<li>Next, add<a id="_idIndexMarker437"/> a new configuration in <code>Rocket.toml</code> to designate a folder in which to place the template files:<pre>[default]
...
template_dir = "src/views"</pre></li>
				<li>In <code>src/main.rs</code>, add the following lines to attach the <code>rocket_dyn_templates::Template</code> fairing to the application:<pre>use rocket_dyn_templates::Template;
...
#[launch]
async fn rocket() -&gt; Rocket&lt;Build&gt; {
...
rocket::build()
...
    .attach(Template::fairing())
...
}</pre></li>
			</ol>
			<p>Adding the <code>Template</code> fairing is straightforward. We are going to learn about <code>Template</code> in the next section by replacing <code>RawHtml</code> with <code>Template</code>.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor105"/>Showcasing users</h1>
			<p>We are <a id="_idIndexMarker438"/>going to modify routes for <code>/users/&lt;uuid&gt;</code> and <code>/users/</code> by taking the following steps:</p>
			<ol>
				<li value="1">The first thing we need to do is to create a template. We already configured the folder for templates in <code>/src/views</code>, so create a <code>views</code> folder in the <code>src</code> folder and then, inside the <code>views</code> folder, create a template file named <code>template.html.tera</code>. </li>
				<li>We are going to use the file as the base HTML template for all HTML files. Inside <code>src/views/template.html.tera</code>, add HTML tags as follows:<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8" /&gt;
  &lt;title&gt;Our Application User&lt;/title&gt;
  &lt;link href="/assets/mini-default.css" 
  rel="stylesheet"&gt;
  &lt;link rel="icon" type="image/png" href="/assets/
  favicon.png"&gt;
  &lt;meta name="viewport" content="width=device-width, 
  initial-scale=1"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="container"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li>
			</ol>
			<p>Notice that we included a CSS file in the HTML file. You can download the open source CSS file <a id="_idIndexMarker439"/>from <a href="https://minicss.org/">https://minicss.org/</a> and put it inside the <code>static</code> folder. Since we already created a route to serve the static file in <code>/assets/&lt;filename..&gt;</code>, we can just use the route directly inside the HTML file.</p>
			<ol>
				<li value="3">For the next <a id="_idIndexMarker440"/>step, we need to include a part where we can put the HTML text we want to render and a part where we can insert <code>flash</code> messages. Modify <code>src/views/template.html.tera</code> as follows:<pre>&lt;div class="container"&gt;
  <strong class="bold">{% if flash %}</strong>
<strong class="bold">    &lt;div class="toast" onclick="this.remove()"&gt;</strong>
<strong class="bold">      {{ flash | safe }}</strong>
<strong class="bold">    &lt;/div&gt;</strong>
<strong class="bold">  {% endif %}</strong>
<strong class="bold">  {% block body %}{% endblock body %}</strong>
&lt;/div&gt;</pre></li>
			</ol>
			<p>By default, all variables are rendered escaped to avoid an XSS (Cross-Site Scripting) attack. We added the condition if there's a <code>flash</code> variable, we put the variable inside the <code>{{ flash }}</code> expression. To let the HTML tag render as it is and not escaped, we can use the <code>| safe</code> filter.</p>
			<p>Tera has other built-in filters such as <code>lower</code>, <code>upper</code>, <code>capitalize</code>, and many more. For the content, we are using <code>block</code> statements. The <code>block</code> statements mean we are going to include another template inside the statement. You can also see <code>block</code> ends with an <code>endblock</code> statement.</p>
			<ol>
				<li value="4">Tera can render any type that implements Serde's <code>Serializable</code> trait. Let's modify <code>User</code> and related types to implement the <code>Serializable</code> trait. In <code>src/models/user.rs</code>, modify the file as follows:<pre><strong class="bold">use rocket::serde::Serialize;</strong>
...
#[derive(Debug, FromRow, FromForm, <strong class="bold">Serialize</strong>)]
pub struct User {
...</pre></li>
				<li>Modify <code>src/models/user_status.rs</code> as follows:<pre><strong class="bold">use rocket::serde::Serialize;</strong>
...
#[derive(sqlx::Type, Debug, FromFormField, <strong class="bold">Serialize</strong>)]
#[repr(i32)]
pub enum UserStatus {
...</pre></li>
				<li>Also, modify <code>src/models/our_date_time.rs</code> as<a id="_idIndexMarker441"/> follows:<pre><strong class="bold">use rocket::serde::Serialize;</strong>
#[derive(Debug, sqlx::Type, Clone, <strong class="bold">Serialize</strong>)]
#[sqlx(transparent)]
pub struct OurDateTime(pub DateTime&lt;Utc&gt;);
...</pre></li>
				<li>For <code>Pagination</code>, we can derive <code>Serialize</code> as it is, but using a timestamp in an URL does not look good, for example, <code>/users?pagination.next=</code><code>&amp;pagination.limit=2</code>. We can make the pagination URL look better by converting <code>OurDateTime</code> into <code>i64</code> and vice versa. In <code>src/models/pagination.rs</code>, append the following lines:<pre>use rocket::serde::Serialize;
...
#[derive(Serialize)]
pub struct PaginationContext {
    pub next: i64,
    pub limit: usize,
}
impl Pagination {
    pub fn to_context(&amp;self) -&gt; PaginationContext {
        PaginationContext {
            next: self.next.0.timestamp_nanos(),
            limit: self.limit,
        }
    }
}</pre></li>
				<li>Since we <a id="_idIndexMarker442"/>are not going to use <code>RawHtml</code> anymore, remove the <code>use rocket::response::content::RawHtml;</code> directive from the <code>src/routes/mod.rs</code> file and modify the file as follows:<pre><strong class="bold">use rocket_dyn_templates::Template;</strong>
...
type HtmlResponse = Result&lt;<strong class="bold">Template</strong>, Status&gt;;</pre></li>
				<li>In <code>src/routes/user.rs</code>, remove the <code>use rocket::response::content::RawHtml</code> directive. We are going to add the <code>Template</code> directive to make the response return <code>Template</code>, but we also need help from Serde's <code>Serialize</code> and <code>context!</code> macros to help convert objects into a Tera variable. Append the following lines:<pre>use rocket::serde::Serialize;
...
use rocket_dyn_templates::{context, Template};</pre></li>
				<li>Then, we<a id="_idIndexMarker443"/> can modify the <code>get_user</code> function. Inside the <code>get_user</code> function in <code>src/routes/user.rs</code>, delete everything related to <code>RawHtml</code>. Delete all the lines starting from <code>let mut html_string = String::from(USER_HTML_PREFIX);</code> to <code>Ok(RawHtml(html_string))</code>.</li>
				<li>Then, replace the content of the deleted lines with the following lines:<pre>#[derive(Serialize)]
struct GetUser {
    user: User,
    flash: Option&lt;String&gt;,
}
let flash_message = flash.map(|fm| String::from(fm.message()));
let context = GetUser {
    user,
    flash: flash_message,
};
Ok(Template::render("users/show", &amp;context))</pre></li>
			</ol>
			<p>Remember that the Tera template can use any Rust type that implements the <code>Serializable</code> trait. We define the <code>GetUser</code> struct that derives the <code>Serializable</code> trait. Since the <code>User</code> struct already implements <code>Serializable</code>, we can use it as a field inside the <code>GetUser</code> struct. After creating a new instance of <code>GetUser</code>, we then tell the application to render the <code>"users/show"</code> template file.</p>
			<ol>
				<li value="12">Since we have told the application that the template name is <code>"users/show"</code>, create a new<a id="_idIndexMarker444"/> folder named <code>users</code> inside <code>src/views</code>. Inside the <code>src/views/users</code> folder, create a new file, <code>src/views/users/show.html.tera</code>. After that, add these lines inside the file:<pre>{% extends "template" %}
{% block body %}
  {% include "users/_user" %}
  &lt;a href="/users/edit/{{user.uuid}}" class="
  button"&gt;Edit User&lt;/a&gt;
  &lt;form accept-charset="UTF-8" action="/users/
  delete/{{user.uuid}}" autocomplete="off" 
  method="POST" id="deleteUser"
      class="hidden"&gt;&lt;/form&gt;
  &lt;button type="submit" value="Submit" 
  form="deleteUser"&gt;Delete&lt;/button&gt;
  &lt;a href="/users" class="button"&gt;User List&lt;/a&gt;
{% endblock body %}</pre></li>
			</ol>
			<p>The first statement, <code>{% extends "template" %}</code>, means we are extending <code>src/views/template.html.tera</code>, which we created earlier. The parent <code>src/views/template.html.tera</code> has a statement, <code>{% block body %}{% endblock body %}</code>, and we tell the Tera engine to override that block with content from the same block in <code>src/views/users/show.html.tera</code>.</p>
			<ol>
				<li value="13">Inside that code, we also see <code>{% include "users/_user" %}</code>, so let's create a <code>src/views/users/_user.html.tera</code> file and <a id="_idIndexMarker445"/>add the following lines:<pre>&lt;div class="row"&gt;
  &lt;div class="col-sm-3"&gt;&lt;mark&gt;UUID:&lt;/mark&gt;&lt;/div&gt;
  &lt;div class="col-sm-9"&gt; {{ user.uuid }}&lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-3"&gt;&lt;mark&gt;Username:&lt;/mark&gt;&lt;/div&gt;
  &lt;div class="col-sm-9"&gt; {{ user.username }}&lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-3"&gt;&lt;mark&gt;Email:&lt;/mark&gt;&lt;/div&gt;
  &lt;div class="col-sm-9"&gt; {{ user.email }}&lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-3"&gt;&lt;mark&gt;
  Description:&lt;/mark&gt;&lt;/div&gt;
  &lt;div class="col-sm-9"&gt; {{ user.description }}&lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-3"&gt;&lt;mark&gt;Status:&lt;/mark&gt;&lt;/div&gt;
  &lt;div class="col-sm-9"&gt; {{ user.status }}&lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-3"&gt;&lt;mark&gt;Created At:&lt;/mark&gt;&lt;/div&gt;
  &lt;div class="col-sm-9"&gt; {{ user.created_at }}&lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-3"&gt;&lt;mark&gt;Updated At:&lt;/mark&gt;&lt;/div&gt;
  &lt;div class="col-sm-9"&gt; {{ user.updated_at }}&lt;/div&gt;
&lt;/div&gt;</pre></li>
			</ol>
			<p>Inside<a id="_idIndexMarker446"/> both files, you will see there are many expressions, such as <code>{{ user.username }}</code>. These expressions are using the variable that we defined before: <code>let context = GetUser { user, flash: flash_message,};</code>. Then, we tell the application to render the template: <code>Ok(Template::render("users/show", &amp;context))</code>. </p>
			<p>You might be wondering why we split <code>show.html.tera</code> and <code>_user.html.tera</code>. One benefit of using a template system is that we can reuse a template. We want to reuse the same user HTML in the <code>get_users</code> function. </p>
			<ol>
				<li value="14">Let's modify the <code>get_users</code> function inside the <code>src/routes/user.rs</code> files. Delete the lines from <code>let mut html_string = String::from(USER_HTML_PREFIX);</code> to <code>Ok(RawHtml(html_string))</code>. Replace those lines with the following lines:<pre>let context = context! {users: users, pagination: new_pagination.map(|pg|pg.to_context())};
Ok(Template::render("users/index", context))</pre></li>
				<li>Instead of defining a new struct, such as <code>GetUser</code>, we are using the <code>context!</code> macro. By using the <code>context!</code> macro, we do not need to create a new type to be passed to the template. Now, create a new file named <code>src/views/users/index.html.tera</code>, and add the following lines to the file:<pre>{% extends "template" %}
{% block body %}
  {% for user in users %}
    &lt;div class="container"&gt;
      &lt;div&gt;&lt;mark class="tag"&gt;{{loop.
      index}}&lt;/mark&gt;&lt;/div&gt;
      {% include "users/_user" %}
      &lt;a href="/users/{{ user.uuid }}" class="
      button"&gt;See User&lt;/a&gt;
      &lt;a href="/users/edit/{{ user.uuid }}" 
      class="button"&gt;Edit User&lt;/a&gt;
    &lt;/div&gt;
  {% endfor %}
  {% if pagination %}
    &lt;a href="/users?pagination.next={{
    pagination.next}}&amp;pagination.limit={{
    pagination.limit}}" class="button"&gt;
      Next
    &lt;/a&gt;
  {% endif %}
  &lt;a href="/users/new" class="button"&gt;New user&lt;/a&gt;
{% endblock %}</pre></li>
			</ol>
			<p>We see<a id="_idIndexMarker447"/> two new things here: a <code>{% for user in users %}...{% endfor %}</code> statement, which can be used to iterate arrays, and <code>{{loop.index}}</code>, to get the current iteration inside the <code>for</code> loop.</p>
			<ol>
				<li value="16">We want to change the <code>new_user</code> and <code>edit_user</code> functions too, but before that, we want to see <code>get_user</code> and <code>get_users</code> in action. Since we already changed the <code>HtmlResponse</code> alias into <code>Result&lt;Template, Status&gt;</code>, we need to convert <code>Ok(RawHtml(html_string))</code> in <code>new_user</code> and <code>edit_user</code> to use a template too. Change <code>Ok(RawHtml(html_string))</code> in the <code>new_user</code> and <code>edit_user</code> functions to <code>Ok(Template::render("users/tmp", context!()))</code>, and create an empty <code>src/views/users/tmp.html.tera</code> file. </li>
				<li>Now, we <a id="_idIndexMarker448"/>can run the application and check the page that we have improved with CSS:</li>
			</ol>
			<div><div><img src="img/Figure_8.1_B16825.jpg" alt="Figure 8.1 – get_user() rendered&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – get_user() rendered</p>
			<p>We can see that the template is working along with the correct CSS file that the application served. In the next section, we will also modify the form to use the template.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor106"/>Working with forms</h1>
			<p>If we<a id="_idIndexMarker449"/> look at the structure of the form for <code>new_user</code> and <code>edit_user</code>, we can see that both forms are almost the same, with just a few differences. For example, the forms' <code>action</code> endpoints are different, as there are two extra fields for <code>edit_user</code>: <code>_METHOD</code> and <code>old_password</code>. To simplify, we can make one template to be used by both functions. Let's look at the steps:</p>
			<ol>
				<li value="1">Create a template called <code>src/views/users/form.html.tera</code>, and insert the following lines:<pre>{% extends "template" %}
{% block body %}
  &lt;form accept-charset="UTF-8" action="{{ form_url }}" 
  autocomplete="off" method="POST"&gt;
    &lt;fieldset&gt;
    &lt;/fieldset&gt;
  &lt;/form&gt;
{% endblock %}</pre></li>
				<li>Next, let's <a id="_idIndexMarker450"/>add the title to the form by adding a <code>legend</code> tag. Put this inside the <code>fieldset</code> tag:<pre>&lt;legend&gt;{{ legend }}&lt;/legend&gt;</pre></li>
				<li>Under the <code>legend</code> tag, we can add an extra field if we are editing the user:<pre>{% if edit %}
  &lt;input type="hidden" name="_METHOD" value="PUT" /&gt;
{% endif %}</pre></li>
				<li>Continuing with the field, add the fields for <code>username</code> and <code>email</code> as follows:<pre>&lt;div class="row"&gt;
  &lt;div class="col-sm-12 col-md-3"&gt;
    &lt;label for="username"&gt;Username:&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-12 col-md"&gt;
    &lt;input name="username" type="text" value="{{ 
    user.username }}"/&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-12 col-md-3"&gt;
    &lt;label for="email"&gt;Email:&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-12 col-md"&gt;
    &lt;input name="email" type="email" value="{{ 
    user.email }}"/&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></li>
				<li>Add a <a id="_idIndexMarker451"/>conditional <code>old_password</code> field after the <code>email</code> field:<pre>{% if edit %}
  &lt;div class="row"&gt;
    &lt;div class="col-sm-12 col-md-3"&gt;
      &lt;label for="old_password"&gt;Old password:&lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="col-sm-12 col-md"&gt;
      &lt;input name="old_password" type="password" /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
{% endif %}</pre></li>
				<li>Add the rest of the fields:<pre>&lt;div class="row"&gt;
  &lt;div class="col-sm-12 col-md-3"&gt;
    &lt;label for="password"&gt;Password:&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-12 col-md"&gt;
    &lt;input name="password" type="password" /&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-12 col-md-3"&gt;
    &lt;label for="password_confirmation"&gt;Password 
    Confirmation:&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-12 col-md"&gt;
    &lt;input name="password_confirmation" type=
    "password" /&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-12 col-md-3"&gt;
    &lt;label for="description"&gt;Tell us a little bit more 
    about yourself:&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-12 col-md"&gt;
    &lt;textarea name="description"&gt;{{ user.description 
    }}&lt;/textarea&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;button type="submit" value="Submit"&gt;Submit&lt;/button&gt;</pre></li>
				<li>Then, change <a id="_idIndexMarker452"/>the labels and fields to show the value (if there is a value):<pre>&lt;input name="username" type="text" {% if user %}value="{{ user.username }}"{% endif %} /&gt;
...
&lt;input name="email" type="email" {% if user %}value="{{ user.email }}"{% endif %} /&gt;
...
&lt;label for="password"&gt;{% if edit %}New Password:{% else %}Password:{% endif %}&lt;/label&gt;
...
&lt;textarea name="description"&gt;{% if user %}{{ user.description }}{% endif %}&lt;/textarea&gt;</pre></li>
				<li>After we have created the form template, we can modify the <code>new_user</code> and <code>edit_user</code> functions. In <code>new_user</code>, remove the lines from <code>let mut html_string = String::from(USER_HTML_PREFIX);</code> to <code>Ok(Template::render("users/tmp", context!()))</code> to create <code>RawHtml</code>.</li>
			</ol>
			<p>In <code>form.html.tera</code>, we added these variables: <code>form_url</code>, <code>edit</code>, and <code>legend</code>. We also need to convert <code>Option&lt;FlashMessage&lt;'_&gt;&gt;</code> into a <code>String</code> since the default implementation of the <code>Serializable</code> trait by <code>FlashMessage</code> is not human-readable. Add those variables and render the template in the <code>new_user</code> function as follows:</p>
			<pre>let flash_string = flash
    .map(|fl| format!("{}", fl.message()))
    .unwrap_or_else(|| "".to_string());
let context = context! {
    edit: false,
    form_url: "/users",
    legend: "New User",
    flash: flash_string,
};
Ok(Template::render("users/form", context))</pre>
			<ol>
				<li value="9">For <code>edit_user</code>, we can<a id="_idIndexMarker453"/> create the same variables, but this time, we know the data for <code>user</code> so we can include <code>user</code> in the context. Delete the lines in the <code>edit_user</code> function in <code>src/routes/user.rs</code> from <code>let mut html_string = String::from(USER_HTML_PREFIX);</code> to <code>Ok(Template::render("users/tmp", context!()))</code>.</li>
			</ol>
			<p>Replace those lines with the following code:</p>
			<pre>let flash_string = flash
    .map(|fl| format!("{}", fl.message()))
    .unwrap_or_else(|| "".to_string());
let context = context! {
    form_url: format!("/users/{}",&amp;user.uuid ),
    edit: true,
    legend: "Edit User",
    flash: flash_string,
    user,
};
Ok(Template::render("users/form", context))</pre>
			<ol>
				<li value="10">As the final touch, we can remove the <code>USER_HTML_PREFIX</code> and <code>USER_HTML_SUFFIX</code> constants from <code>src/routes/user.rs</code>. We should also remove the <code>src/views/users/tmp.html.tera</code> file since there's no function using that file anymore. And, since we already enclose the flash message inside the <code>&lt;div&gt;&lt;/div&gt;</code> tag in the template, we can remove the <code>div</code> usage from<a id="_idIndexMarker454"/> flash messages. For example, in <code>src/routes/user.rs</code>, we can modify these lines:<pre>Ok(Flash::success(
    Redirect::to(format!("/users/{}", user.uuid)),
    <strong class="bold">"&lt;div&gt;</strong>Successfully created user<strong class="bold">&lt;/div&gt;</strong>",
))</pre></li>
			</ol>
			<p>We can modify them into the following lines:</p>
			<pre>Ok(Flash::success(
    Redirect::to(format!("/users/{}", user.uuid)),
    "Successfully created user",
))</pre>
			<p>One more thing that we can improve for the form is adding a token to secure the application<a id="_idIndexMarker455"/> from <strong class="bold">cross-site request forgery</strong> (<strong class="bold">CSRF</strong>) attacks. We will learn how to secure our form in the next section.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/>Securing HTML forms from CSRF</h1>
			<p>One<a id="_idIndexMarker456"/> of the <a id="_idIndexMarker457"/>most common security attacks is CSRF, where a malicious third party tricks a user into sending a web form with different values than intended. One way to mitigate this attack is by sending a one-time token along with the form content. The web server then checks the token validity to ensure the request comes from the correct web browser.</p>
			<p>We can create such a token in a Rocket application by creating a fairing that will generate a token and check the form value sent back. Let's look at the steps:</p>
			<ol>
				<li value="1">First, we need to add the dependencies for this. We are going to need a <code>base64</code> crate to encode and decode binary values into a string. We also need the <code>secrets</code> feature from Rocket to store and retrieve private cookies. Private cookies are just like regular cookies, but they are encrypted by the key we configured in the <code>Rocket.toml</code> file with <code>secret_key</code>.</li>
			</ol>
			<p>For <a id="_idIndexMarker458"/>dependencies, we also need to add <code>time</code> as a <a id="_idIndexMarker459"/>dependency. Add the following lines in <code>Cargo.toml</code>:</p>
			<pre><strong class="bold">base64 = {version = "0.13.0"}</strong>
...
rocket = {path = "../../../rocket/core/lib/", features = ["uuid", "json", <strong class="bold">"secrets"</strong>]}
...
<strong class="bold">time = {version = "0.3", features = ["std"]}</strong></pre>
			<p>The steps for preventing CSRF are generating a random byte, storing the random byte in a private cookie, hashing the random byte as a string, and rendering the form template along with the token string. When the user sends the token back, we can retrieve the token from the cookie and compare both.</p>
			<ol>
				<li value="2">To make a CSRF fairing, add a new module. In <code>src/fairings/mod.rs</code>, add the new module:<pre>pub mod csrf;</pre></li>
				<li>After that, create a file named <code>src/fairings/csrf.rs</code> and add the dependencies and constants for the default value for the cookie to store the random bytes:<pre>use argon2::{
    password_hash::{
        rand_core::{OsRng, RngCore},
        PasswordHash, PasswordHasher, 
        PasswordVerifier, SaltString,
    },
    Argon2,
};
use rocket::fairing::{self, Fairing, Info, Kind};
use rocket::http::{Cookie, Status};
use rocket::request::{FromRequest, Outcome, Request};
use rocket::serde::Serialize;
use rocket::{Build, Data, Rocket};
use time::{Duration, OffsetDateTime};
const CSRF_NAME: &amp;str = "csrf_cookie";
const CSRF_LENGTH: usize = 32;
const CSRF_DURATION: Duration = Duration::hours(1);</pre></li>
			</ol>
			<p>Then, we <a id="_idIndexMarker460"/>can extend Rocket's <code>Request</code> with<a id="_idIndexMarker461"/> a new method to retrieve the CSRF token. Because <code>Request</code> is an external crate, we cannot add another method, but we can overcome this by adding a trait and making the external crate type extend this trait. We cannot extend an external crate with an external trait, but extending an external crate with an internal trait is permissible.</p>
			<ol>
				<li value="4">We want to create a method to retrieve CSRF tokens from private cookies. Continue with <code>src/fairings/csrf.rs</code> by appending the following lines:<pre>trait RequestCsrf {
    fn get_csrf_token(&amp;self) -&gt; Option&lt;Vec&lt;u8&gt;&gt;;
}
impl RequestCsrf for Request&lt;'_&gt; {
    fn get_csrf_token(&amp;self) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
        self.cookies()
            .get_private(CSRF_NAME)
            .and_then(|cookie| base64::
            decode(cookie.value()).ok())
            .and_then(|raw| {
                if raw.len() &gt;= CSRF_LENGTH {
                    Some(raw)
                } else {
                    None
                }
            })
    }
}</pre></li>
				<li>After that, we <a id="_idIndexMarker462"/>want to add a fairing that retrieves or <a id="_idIndexMarker463"/>generates, and stores random bytes if the cookie does not exist. Add a new struct to be managed as a fairing:<pre>#[derive(Debug, Clone)]
pub struct Csrf {}
impl Csrf {
    pub fn new() -&gt; Self {
        Self {}
    }
}
#[rocket::async_trait]
impl Fairing for Csrf {
    fn info(&amp;self) -&gt; Info {
        Info {
            name: "CSRF Fairing",
            kind: Kind::Ignite | Kind::Request,
        }
    }
    async fn on_ignite(&amp;self, rocket: Rocket&lt;Build&gt;) –
    &gt; fairing::Result {
        Ok(rocket.manage(self.clone()))
    }
}</pre></li>
				<li>We want<a id="_idIndexMarker464"/> to retrieve the token first, and if the<a id="_idIndexMarker465"/> token does not exist, generate random bytes and add the bytes to the private token. Inside the <code>impl Fairing</code> block, add the <code>on_request</code> function:<pre>async fn on_request(&amp;self, request: &amp;mut Request&lt;'_&gt;, _: &amp;mut Data&lt;'_&gt;) {
    if let Some(_) = request.get_csrf_token() {
        return;
    }
    let mut key = vec![0; CSRF_LENGTH];
    OsRng.fill_bytes(&amp;mut key);
    let encoded = base64::encode(&amp;key[..]);
    let expires = OffsetDateTime::now_utc() + CSRF_
    DURATION;
    let mut csrf_cookie = Cookie::new(
    String::from(CSRF_NAME), encoded);
    csrf_cookie.set_expires(expires);
    request.cookies().add_private(csrf_cookie);
}</pre></li>
				<li>We need a<a id="_idIndexMarker466"/> request guard to retrieve the token <a id="_idIndexMarker467"/>string from the request. Append the following lines:<pre>#[derive(Debug, Serialize)]
pub struct Token(String);
#[rocket::async_trait]
impl&lt;'r&gt; FromRequest&lt;'r&gt; for Token {
    type Error = ();
    async fn from_request(request: &amp;'r Request&lt;'_&gt;) -&gt; 
    Outcome&lt;Self, Self::Error&gt; {
        match request.get_csrf_token() {
            None =&gt; Outcome::Failure((Status::
            Forbidden, ())),
            Some(token) =&gt; Outcome::
            Success(Self(base64::encode(token))),
        }
    }
}</pre></li>
				<li>We <a id="_idIndexMarker468"/>return an HTTP <code>403</code> status code if the token is not found. We also need two more functions: generating a hash and comparing<a id="_idIndexMarker469"/> the token hash with other strings. Since we already use <code>argon2</code> for password hashing, we can reuse the <code>argon2</code> crate for those functions. Append the following lines:<pre>impl Token {
    pub fn generate_hash(&amp;self) -&gt; Result&lt;String, 
    String&gt; {
        let salt = SaltString::generate(&amp;mut OsRng);
        Argon2::default()
            .hash_password(self.0.as_bytes(), &amp;salt)
            .map(|hp| hp.to_string())
            .map_err(|_| String::from("cannot hash 
            authenticity token"))
    }
    pub fn verify(&amp;self, form_authenticity_token: 
    &amp;str) -&gt; Result&lt;(), String&gt; {
        let old_password_hash = self.generate_hash()?;
        let parsed_hash = PasswordHash::new(&amp;old_
        password_hash)
            .map_err(|_| String::from("cannot verify 
            authenticity token"))?;
        Ok(Argon2::default()
            .verify_password(form_authenticity_
            token.as_bytes(), &amp;parsed_hash)
            .map_err(|_| String::from("cannot verify 
            authenticity token"))?)
    }
}</pre></li>
				<li>After we<a id="_idIndexMarker470"/> set up the <code>Csrf</code> fairing, we can use it<a id="_idIndexMarker471"/> in the application. In <code>src/main.rs</code>, attach the fairing to the Rocket application:<pre>use our_application::fairings::{csrf::Csrf, db::DBConnection};
...
async fn rocket() -&gt; Rocket&lt;Build&gt; {
...
        .attach(Csrf::new())
...
}</pre></li>
				<li>In <code>src/models/user.rs</code>, add a new field to contain the token sent from the form:<pre>pub struct NewUser&lt;'r&gt; {
...
    pub authenticity_token: &amp;'r str,
}
...
pub struct EditedUser&lt;'r&gt; {
...
    pub authenticity_token: &amp;'r str,
}</pre></li>
				<li>In <code>src/views/users/form.html.tera</code>, add <a id="_idIndexMarker472"/>the field to store the token string:<pre>&lt;form accept-charset="UTF-8" action="{{ form_url }}" autocomplete="off" method="POST"&gt;
  &lt;input type="hidden" name="authenticity_token" 
  value="{{ csrf_token }}"/&gt;
...</pre></li>
				<li>Finally, we<a id="_idIndexMarker473"/> can modify <code>src/routes/user.rs</code>. Add the <code>Token</code> dependency:<pre>use crate::fairings::csrf::Token as CsrfToken;</pre></li>
				<li>We can use <code>CsrfToken</code> as a request guard, pass the token to the template, and render the template as HTML:<pre>pub async fn new_user(flash: Option&lt;FlashMessage&lt;'_&gt;&gt;, csrf_token: CsrfToken) -&gt; HtmlResponse {
...
    let context = context! {
        ...
        csrf_token: csrf_token,
    };
    ...
}
...
pub async fn edit_user(
    mut db: Connection&lt;DBConnection&gt;, uuid: &amp;str, 
    flash: Option&lt;FlashMessage&lt;'_&gt;&gt;, csrf_token: 
    CsrfToken) -&gt; HtmlResponse {
...
    let context = context! {
        ...
        csrf_token: csrf_token,
    };
    ...
}</pre></li>
				<li>Modify <a id="_idIndexMarker474"/>the <code>create_user</code> function to verify the<a id="_idIndexMarker475"/> token and return if the hash does not match:<pre>pub async fn create_user&lt;'r&gt;(
    ...
    csrf_token: CsrfToken,
) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {
    …
    let new_user = user_context.value.as_ref().
    unwrap();
    csrf_token
        .verify(&amp;new_user.authenticity_token)
        .map_err(|_| {
            Flash::error(
                Redirect::to("/users/new"),
                "Something went wrong when creating 
                user",
            )
        })?;
    ...
}</pre></li>
				<li>Do the<a id="_idIndexMarker476"/> same <a id="_idIndexMarker477"/>with the <code>update_user</code>, <code>put_user</code>, and <code>patch_user</code> functions as well:<pre>pub async fn update_user&lt;'r&gt;(
    ...
    csrf_token: CsrfToken,
) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {
    ...
    match user_value.method {
        "PUT" =&gt; put_user(db, uuid, user_context, 
        csrf_token).await,
        "PATCH" =&gt; patch_user(db, uuid, user_context, 
        csrf_token).await,
        ...
    }
}
...
pub async fn put_user&lt;'r&gt;(
    ...
    csrf_token: CsrfToken,
) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {
    let user_value = user_context.value.as_ref().
    unwrap();
    csrf_token
        .verify(&amp;user_value.authenticity_token)
        .map_err(|_| {
            Flash::error(
                Redirect::to(format!("/users/edit/{}",
                uuid)),
                "Something went wrong when updating 
                user",
            )
        })?;
    …
}
…
pub async fn patch_user&lt;'r&gt;(
    ...
    csrf_token: CsrfToken,
) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {
    put_user(db, uuid, user_context, csrf_token).await
}</pre></li>
			</ol>
			<p>After <a id="_idIndexMarker478"/>that, try <a id="_idIndexMarker479"/>relaunching the application and sending the form without the token. We should see the application return an HTTP <code>403</code> status code. CSRF is one of the most common web attacks, but we have learned how to mitigate the attack by using Rocket features.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Summary</h1>
			<p>In this chapter, we have learned about three things that are common for a web application. The first one is learning how to make the Rocket application serve static files by using either <code>PathBuf</code> or the <code>FileServer</code> struct.</p>
			<p>Another thing we have learned is how to use <code>rocket_dyn_templates</code> to convert a template into a response to the client. We also learned about a template engine, Tera, and the various capabilities of the Tera template engine.</p>
			<p>By utilizing static assets and templates, we can easily create modern web applications. In the next chapter, we are going to learn about user posts: text, picture, and video.</p>
		</div>
	</body></html>