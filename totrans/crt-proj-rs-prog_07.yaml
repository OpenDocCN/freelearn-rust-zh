- en: Creating a Desktop Two-Dimensional Game Using ggez
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding chapter, we saw how to build interactive software based on
    the animation-loop architecture (typically, animated games) for desktops or for
    web browsers from a single set of source codes using the `quicksilver` framework. A
    drawback of this approach is that many input/output functions available on the
    desktop are not available on web browsers, and so a framework for web browsers
    does not necessarily provide as many features to desktop applications that are
    offered on desktop platforms, such as file storage.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, when using the animation-loop architecture, it is quite awkward
    to get discrete input, such as mouse clicks, typed letters, or digits. For this,
    an event-driven architecture is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, another application framework will be introduced—the `ggez`
    framework. This handles both animation-loop and discrete events, but at the time
    of writing, it only supports two-dimensional desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we saw that to compute the position and orientation
    of various graphical objects, some analytical geometry and trigonometry is required.
    For more complex applications, these mathematical computations can become overwhelming.
    To simplify the code, it is useful to encapsulate positions in point objects and
    translations in vector objects, and so in this chapter, we will look at how to
    perform these encapsulations. The `nalgebra` mathematical library helps us to
    do this and will be introduced in this chapter, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding linear algebra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `gg_ski` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `gg_silent_slalom` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `gg_assets_slalom` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `gg_whac` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In particular, you will see the implementation of the same three projects we
    looked at in the previous chapter (`gg_ski`, `gg_silent_slalom`, and `gg_assets_slalom`)
    to demonstrate the animation loop, as well as a Whac-A-Mole game (`gg_whac`) to
    demonstrate the handling of discrete events.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses references to the animation-loop architecture and the slalom
    game implemented in the preceding chapter. The `ggez` framework requires (for
    correctly rendering graphical objects) the OpenGL 3.2 API to be well supported
    by the operating system. Therefore, old operating systems such as Windows XP cannot
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code for this chapter is found in the `Chapter07` folder of
    the repository at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  prefs: []
  type: TYPE_NORMAL
- en: macOS users may struggle to install `coreaudio-sys`. Upgrading the patch version
    of `coreaudio-sys` to `0.2.3` resolves this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will first look at what linear algebra is and why it is
    useful to describe and manipulate the objects drawn in any graphical game. Then,
    we will look at how to use the `nalgebra` library to perform linear algebra operations
    in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will recreate the same projects used in the previous chapter,
    but using the `nalgebra` library and the `ggez` framework instead of the `quicksilver`
    framework. `gg_ski` is a rewrite of `ski`, `gg_silent_slalom` is a rewrite of
    `silent_slalom`, and `gg_assets_slalom` is a rewrite of `assets_slalom`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we will look at the implementation of a completely
    different game with the `gg_whac` project to see how to handle discrete events
    in an architecture that mixes the animation loop with an event-driven architecture.
    This will also show how widgets (such as buttons) can be created and added to
    a window.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding linear algebra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linear algebra is the sector of mathematics regarding systems of first-degree
    equations, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c865534e-7942-46fb-a5cb-2a43c0c5f797.png)'
  prefs: []
  type: TYPE_IMG
- en: This system of equations has a solution to certain values (that is, ![](img/62e199f2-55af-4a4b-93d8-a8d2c310a1e0.png)).
    In addition to being useful for solving systems of equations, the concepts and
    methods of linear algebra are also useful for representing and manipulating geometrical
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, any position on a plane can be represented by two coordinates,
    *x* and *y*, and any position in space can be represented by three coordinates,
    *x*, *y*, and *z*. In addition, any translation of a position on a plane can be
    represented by two coordinates, *Δx* and *Δy*, and any translation of a position
    in space can be represented by three coordinates, *Δx*, *Δy*, and *Δz*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider two positions on a plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '*p[1]*: Its coordinates are *x = 4, y = 7.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*p[2]*: Its coordinates are *x = 10, y = 16.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider two translations on that plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '*t[1]*: Its coordinates are ![](img/b9b71b1b-4a16-47c9-a86d-dd1d42c531cd.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*t[2]*: Its coordinates are ![](img/255887c4-c5f8-4c26-a38c-5169b37fb204.png) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can say that if you translate the *p[1]* position by the *t[1]* translation,
    you get to the *p[2]* position. The computation is done by adding the corresponding
    coordinates: *p[1x] + t[1x] = p[2x]* (or, in numbers, 4 + 6 = 10) and *p[1y] +
    t[1y] = p[2y]* (or, in numbers, 7 + 9 = 16).'
  prefs: []
  type: TYPE_NORMAL
- en: If you apply two translations sequentially to the *p[1]* position—the *t[1]* translation
    and the *t[2]* translation—then you will obtain another position (say, *p[3]*).
    You will also obtain the same result if you first sum the two translations (by
    summing their components memberwise) and then applying the resulting translation
    to *p[1]*.
  prefs: []
  type: TYPE_NORMAL
- en: So, for the *x* coordinate, we have *(p[1x] + t[1x]) + t[2x] = p[1x] + (t[1x]
    + t[2x])* and a similar equation also holds for the *y* coordinate. So, translations
    can be added. You can add a translation to another one by summing their respective
    coordinates, instead, it does not make sense to add one position to another position.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simplify your geometric computations by applying the computations to
    the position and translation entities themselves using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c06b35b1-a5ee-4926-94df-fa46632a036f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In linear algebra, there are two concepts that can be applied to these sorts
    of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vectors**: An algebraic *vector* is a tuple of numbers that can be added
    to another vector, obtaining another vector, which is what is needed to *represent
    translations*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Points**: An algebraic *point* is a tuple of numbers that cannot be added
    to another point, but that can be incremented by a vector, thereby obtaining another
    point, which is what is needed to *represent a**position*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, linear algebraic *N-dimensional vectors* are fit to represent *translations*
    in an *N*-dimensional geometric space, whereas linear algebraic *N-dimensional
    points* are fit to represent *positions* in an *N*-dimensional geometric space.
  prefs: []
  type: TYPE_NORMAL
- en: The `nalgebra` library (pronounced *en-algebra*) is a collection of to many
    algebraic algorithms that provide implementations for these kinds of two-dimensional
    point and vector types, and so it will be used in all of the following projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this library, you can write the following program, which shows which
    operations are allowed and which are forbidden, using vectors and points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first three statements of the `main` function create two two-dimensional
    points and one two-dimensional vector whose coordinates are `f32` numbers. This
    sort of inner numeric type can often be *inferred*, but here it is specified for
    clarity.
  prefs: []
  type: TYPE_NORMAL
- en: The next four statements show that both the `Point2` and `Vector2` types contain
    the `x` and `y` fields, initialized by the arguments of the `new` function. So,
    the `Point2` and `Vector2` types look quite similar, and actually many libraries
    and many developers use just one type to store both positions and translations.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, these types differ for the allowed operations. The following four
    statements show which operations can be carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: Sum a vector to a point (`p1 + v`), obtaining another point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtract two points (`p2 - p1`), obtaining a vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum two vectors or subtract two vectors (`v + v - v`), obtaining a vector in
    both cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply a vector by a number or divide a vector by a number (`(2\. * v) / 2.`),
    obtaining a vector in both cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some operations allowed on vectors that shouldn't be allowed on points
    (because they make no sense for them), which the last two statements show. You
    cannot add two points (`p1 + p2`) and actually, this operation is commented out
    to prevent a compilation error. You shouldn't multiply a point by a number (`2\.
    * p1`), although, for some reason, the `nalgebra` library allows this.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about the `nalgebra` library, you can find its documentation
    at [https://www.nalgebra.org/](https://www.nalgebra.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at a good way to handle geometric coordinates using
    the `nalgebra` library, let's see how to use them in game applications.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the gg_ski project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first three projects in this chapter are just a rewrite of the three projects
    covered in the preceding chapter but are converted so that they use the `ggez`
    framework and the `nalgebra` library instead. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ski` project has become `gg_ski`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `silent_slalom` project has become `gg_silent_slalom`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `assets_slalom` project has become `gg_assets_slalom`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each project''s behavior is very similar to its respective project in [Chapter
    6](72504b4f-2094-4890-9e99-a9251f38c538.xhtml), *Creating a WebAssembly Game Using
    Quicksilver*, and so you can go back to that chapter to see the screenshots accompanying
    each one. For all three projects, `gg_ski`, `gg_silent_slalom`, and `gg_assets_slalom`, the
    `Cargo.toml` file has the following change. Instead of the `quicksilver` dependency,
    there are the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The term `ggez` (pronounced *G. G. easy*) is a slang term used by multiplayer
    online gamers.
  prefs: []
  type: TYPE_NORMAL
- en: The `ggez` framework was admittedly inspired by the **LÖVE game framework**.
    The main difference between them lies in the programming languages. LÖVE is implemented
    in C++ and is programmable in Lua, while `ggez` is both implemented and programmable
    in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's compare the `main.rs` source code of the `ski` project to that of
    the `gg_ski` project.
  prefs: []
  type: TYPE_NORMAL
- en: The main function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the end of the file, there is the `main` function, which prepares the context
    for the game and then runs the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, you can see that, when you use the `ggez` framework, you
    don''t just run the model. First, you should create three objects:'
  prefs: []
  type: TYPE_NORMAL
- en: A context, which, in our case, is a window. It is assigned to the `context`
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An animation loop, which animates that context. It is assigned to the `animation_loop` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model, in our case, is of `Screen` type. It is assigned to the `game` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating these objects, you can call the `run` function with these three
    objects as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: To create the context and the animation loop, a `ContextBuilder` object is first
    created by calling the `ContextBuilder::new` function; then, this builder is modified
    by calling its methods—`window_setup`, `window_mode`, and `add_resource_path`.
    Finally, the call to the `build` method returns both a context and an animation
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, notice the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The call to `new` specifies a name for the app (`"slalom"`) and a name for its
    creator (`"ggez"`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `window_setup` specifies the text in the title bar of the window
    (`"Slalom"`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `window_mode` specifies the desired size of the window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `add_resource_path` specifies the name of the folder that will contain
    the assets loaded at runtime (`"static"`), even if we are not going to use assets in
    this project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the `Screen` model, notice that it is created using the `new` method,
    and so we will have to provide this method; however, we could use any other name
    for this sort of creation method.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns of input handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `quicksilver` and `ggez` adopt an animation loop-based **Model-View-Controller**
    (**MVC**) pattern. This is done by requiring the model to implement a trait that
    has two required methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`update` is the controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draw` is the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both frameworks run an implicit loop that periodically (many times per second)
    calls the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The controller to update the model, using possible input data and the preceding
    values of the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view to update the screen, using the updated values of the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there is a substantial difference in the technique used by these frameworks
    to get input. `quicksilver` is a complete animation loop-oriented framework. The
    controller (or the `update` function) gets input accessing the state of input
    devices—it can check where the mouse is and which mouse buttons and keyboard keys
    are being pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, `ggez` input handling is event-driven because it captures input device
    *transitions*, not input device *states*. There are several kinds of possible
    input device transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: A movement of the mouse (*mouse moves*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A press of a mouse button (*mouse button down*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A release of a pressed mouse button (*mouse button up*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A press of keyboard key (*key down*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A release of a pressed keyboard key (*key up*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `ggez`, for each of these possible input device transitions, the trait declares
    an optional handler routine that can be implemented for the model by the application
    code. These routines are called `mouse_motion_event`, `mouse_button_down_event`,
    `mouse_button_up_event`, `key_down_event`, and `key_up_event`.
  prefs: []
  type: TYPE_NORMAL
- en: If an event happens in an animation-loop time frame, the corresponding handlers
    are invoked just before the `update` function is invoked. In these event handlers,
    the application code should store (in the model) the information gathered from
    the event, such as which key has been pressed or in which position the mouse has
    been moved. Then, the `update` function can process this input data to prepare
    the information needed by the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand these techniques, consider, as an example, the following
    sequence of events or timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: The `update` function is invoked 10 times per second—that is, once every tenth
    of a second—so, frames per second = 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user presses the *A* key at `0.020` seconds and releases it 50 milliseconds
    later at `0.070` seconds, and then they press the *B* key at `0.140` seconds and
    release it 240 milliseconds later at `0.380` seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For `quicksilver`, we have the following timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **At time** | **Input device state** | **Input processing in the update function**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0.0` | No key is pressed. | Nothing. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.1` | No key is pressed. | Nothing. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.2` | The *B* key is pressed. | The *B* key is processed. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.3` | The *B* key is pressed. | The *B* key is processed. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.4` | No key is pressed. | Nothing. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.5` | No key is pressed. | Nothing. |'
  prefs: []
  type: TYPE_TB
- en: 'For `ggez`, we have the following timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **At time** | **Input events** | **Input processing in the** **update function**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0.0` | No input events. | No key info is stored in the model. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.1` | The `key_down_event` function is invoked with the *A* key as an argument.
    It stores the *A* key in the model.The `key_up_event` function is invoked with
    the *A* key as an argument. It does nothing. | The *A* key is read from the model.
    It is processed and reset. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.2` | The `key_down_event` function is invoked with the *B* key as an argument.
    It stores the *B* key in the model. | The *B* key is read from the model. It is
    processed and reset. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.3` | No input events. | No key info is stored in the model. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.4` | The `key_up_event` function is invoked with the *B* key as an argument.
    It does nothing. | No key info is stored in the model. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.5` | No input events. | No key info is stored in the model. |'
  prefs: []
  type: TYPE_TB
- en: Notice that for `quicksilver`, the *A* key has never been pressed, while the
    *B* key has been pressed twice. This can be good for continuous events, such as
    using a joystick, but not for discrete events, such as clicking a command button
    or typing text into a textbox.
  prefs: []
  type: TYPE_NORMAL
- en: However, `quicksilver` has the advantage of capturing all simultaneous events.
    For example, `quicksilver` can easily handle a chord, which is when several keys
    are continually pressed at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, for `ggez`, as long as only one key is pressed in a time frame, all
    key presses are handled the appropriate number of times. This is expected for
    buttons and textboxes; however, chords are not handled correctly. The only key
    combinations handled by `ggez` are those involving the *Shift*, *Ctrl*, and *Alt* special
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: Input handling in the gg_ski project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among the many events that can be captured by a `ggez` application, the `gg_ski`
    game captures only two events—the press of the right or left arrow keys and their
    release. The handling of these events stores the relevant input information in
    the model so that the `update` function can use it. Therefore, the model must
    contain some additional fields, with respect to those contained for the `quicksilver`
    `ski` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we now have a model that contains some fields updated by the event functions,
    to be used by the `update` function, and some other fields updated by the `update`
    function, to be used by the `draw` function. To distinguish these input fields,
    it''s better to encapsulate them in a structure defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `to_turn` field indicates that the user has pressed an arrow key to change
    the direction of the ski. If only the left key is pressed, the direction angle
    should be decremented, and so the value of this field should be `-1.0`. If only
    the right key is pressed, the direction angle should be incremented, and so the
    value of this field should be `1.0`. If the user has not pressed any arrow key,
    the direction should remain unchanged, and so the value of this field should be
    `0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `started` field indicates that the race has started. It is not used in
    this project. An instance of this structure is added to the model using the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The capture of key presses is done through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `keycode` argument specifies which key has been pressed. If the left or
    the right arrow keys have been pressed, the `to_turn` field is set to `-1.0` or
    to `+1.0`, respectively. Any other keys that are pressed are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Capturing the release of the keys is done through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the left or the right arrow keys are released, the `to_turn` field is set
    to `0.0` to stop the change of direction. The release of any other key is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Other differences with quicksilver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Between `quicksilver` and `ggez`, in addition to the described conceptual differences,
    there are some minor differences, which I have covered in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Name of the trait
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The name of the trait to be implemented by the model is `State` for `quicksilver`
    and `EventHandler` for `ggez`. So, for `quicksilver` we had the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But in `ggez`, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The type of context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using both `quicksilver` and `ggez`, you need to implement the `update` method
    and the `draw` method. Both of these methods receive an argument for both frameworks that
    describes the input/output context. This context is the object used to receive
    interactive input (by the `update` method) and to emit graphical output (by the `draw` method).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for `quicksilver` the type of this context argument is `Window`, as
    in the following function signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For `ggez`, it is `Context`. So, now we have the following signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The new method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `State` trait of `quicksilver` requires the implementation of the `new`
    method, used by the framework to create the model instance. The `EventHandler`
    trait of `ggez` has no such method because the model instance is created explicitly
    by application code in the `main` function, as we have seen.
  prefs: []
  type: TYPE_NORMAL
- en: The angle's unit of measurement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While `quicksilver` rotation angles must be specified in degrees, `ggez` rotation
    angles must be specified in radians, and so angular constants and variables are
    specified in these units of measurement. So, now we have the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How to specify the FPS rate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To specify the desired **Frames Per Second** (**FPS**) rate, two parameters
    are specified in the `main` function when using `quicksilver`, whereas `ggez`
    uses another technique. For `ggez`, the `update` function is always invoked 60
    times per second (if possible), but the application code can simulate a different
    rate by writing the following body of the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to ensure that the body of the `while` loop is executed
    with the specified rate, which in this case is `25` frames per second. Let's see
    how this is accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: The required rate specified in our code means that the body should be executed
    once every *1000 / 25 = 40 *milliseconds. When the `update` function is executed,
    if less than 40 milliseconds have elapsed since the preceding execution, the `check_update_time`
    function returns `false`, and so the body of the `while` loop is not executed
    this time. It is likely that even at the next `update` call, not enough time will
    have elapsed, and so the `check_update_time` function will return `false` again.
    In a later execution, when at least 40 milliseconds have elapsed since the last
    time the body was executed, `true` will be returned, and so the body will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: This allows a rate that is lower than 60 FPS. However, there is another feature.
    If a frame, for some reason, takes longer than the allotted time—say, 130 milliseconds—causing
    the animation to stutter, then the `check_update_time` function returns `true`
    several times in a row to make up for the lost time.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you cannot obtain the desired rate if every frame is so slow to take
    too much time. Tough, as long as your frames are processed within the required
    time, this technique ensures that the average frame rate will be the specified
    one.
  prefs: []
  type: TYPE_NORMAL
- en: To say that the actual average rate approximates the desired rate, it is enough
    that the average time taken by a frame is less than the one allotted for a frame.
    Instead, if your frames take, on average, 100 milliseconds, the actual frame rate
    will be 10 FPS.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the ski steering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ski steering is handled differently in the body of the `update` loop. In
    the `ski` project, the `steer` function is only called if an arrow key is kept
    pressed down at that time. Instead, in the `gg_sky` project, the following statement
    is always executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `steer` function is called at any time frame, passing the value set before
    by the input handling methods. If this value is `0`, the ski doesn't steer.
  prefs: []
  type: TYPE_NORMAL
- en: Computation of new position and speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition, the body of the `update` function now contains the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Their purpose is to compute the correct kinematics of the ski. In mechanics,
    to compute a position variation (![](img/f8bdcdfb-b580-4d95-b963-a6c1da93a2fb.png)),
    you have to multiply the current speed (also called **velocity**, *v*) by the
    time elapsed since the previous frame (![](img/2de95eed-7834-4bac-8d45-52416eaf488e.png)).
    This results in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94c8e1ad-c647-489c-b25f-26a56f31c4be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To compute a speed variation (![](img/a5bc6524-13ce-4da6-9434-20778f84594a.png)),
    you have to multiply the current acceleration (*a*) by the time elapsed since
    the preceding frame (![](img/8d645a85-0f7a-4d27-8179-8d85a46c24b6.png)), which results
    in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc23c985-1aaf-4a48-8e24-ddc75239e617.png)'
  prefs: []
  type: TYPE_IMG
- en: So, to compute the position variation and the speed variation, we need the time
    elapsed since the preceding frame. The `ggez` framework provides the `timer::time_since_start`
    function, which returns the duration since the start of the application. We subtract the
    time of the preceding frame from the duration to obtain the time elapsed between
    the two frames. The duration is then converted into seconds. Finally, the current
    time is saved, to be used in the next frame computation.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the background
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The MVC view implemented by the `draw` method draws the white background by
    using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's check how to draw the composite shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing composite shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To draw a composite shape, instead of individually drawing all of its components,
    first create a `Mesh` object, which is a composite shape containing all the component
    shapes, and then draw the `Mesh` object. To create a `Mesh` object, the `MeshBuilder`
    class is used with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now check what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the `new` function creates a `MeshBuilder` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the methods instruct these mesh builders how to create the mesh components. The `rectangle`
    method explains how to create a rectangle, which will be the ski body, and the `polygon` method
    explains how to create a polygon, which will be the ski tip. The features of the
    rectangle are its draw mode (`DrawMode::fill()`), its position and size (`x`,
    `y`, `w`, and `h`), and its color (`1., 0., 1., 1.`). The features of the polygon
    are its draw mode, the list of its vertices, and its color. It has just three
    vertices, so it is a triangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the `build` method creates and returns the specified mesh. Notice that
    the method calls ending with a question mark are fallible and that the colors
    are specified by the quadruple red-green-blue-alpha model, where each number is
    in the range `0` to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To draw a mesh, the following statement is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This `draw` method is not the same as the `draw` method that defines the view
    of the MVC architecture. This is found in the `ggez::graphics` module, while the
    containing method (the view) is part of the `ggez::event::EventHandler` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument of the `graphics::draw` method—`ctx`—is the context on which
    we are drawing. The second argument—`&ski`—is the mesh we are drawing. The third
    argument is a collection of parameters, encapsulated in a `DrawParam` object.
    This type allows us to specify numerous parameters, two of which are specified
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The point to draw the mesh, specified using the `dest` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The angle (in radians) by which the mesh must be rotated, specified using the
    `rotation` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we have now seen how to draw on the screen. However, after calling these
    statements, nothing actually appears on the screen because the statements just
    prepare the output off-screen. To get the output, a finalization statement is
    needed, which is described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Ending the draw method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The view (that is, the `draw` method) should end with the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the typical double-buffering technique used by OpenGL, all the `ggez` drawing
    operations do not output graphics directly on the screen but in a hidden buffer.
    The `present` function quickly swaps the shown screen buffer with the hidden drawn
    buffer, with the effect of immediately displaying the scene and avoiding the flicker
    that could appear otherwise. The last statement tells the operating system to
    stop using the CPU for this process until the next frame must be drawn. By doing
    this, if the processing of a frame is quicker than a time frame, the application
    avoids using 100% of the CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have finished examining the `gg_ski` project. In the next section, we
    will examine how the `gg_silent_slalom` project builds on this project to create
    a slalom game with no sound or text.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the gg_silent_slalom project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine the `gg_silent_slalom` project, which is an
    implementation of the `ggez` framework of the `gg_silent_slalom` game presented
    in the preceding chapter. Here, we will only examine the differences between the
    `gg_ski` project and the `silent_slalom` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in the preceding section, `ggez` handles input as events. In this
    project, two other key events are handled—`Space` and `R`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The spacebar is used to command the start of the race, and so it sets the `started` flag to
    `true`. The *R* key is used to reposition the ski at the beginning of the slope,
    and so it sets the `started` flag to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This flag is then used in the `update` method, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When in `Ready` mode, instead of directly checking the keyboard state, the
    `started` flag is checked. The computation of speed and acceleration takes into
    account the time that has actually elapsed since the preceding frame computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To compute the new forward speed, the acceleration along the slope (`ALONG_ACCELERATION`)
    is projected on the ski direction using the cosine function (`self.direction.cos()`),
    and then the result is multiplied by the elapsed time (`self.period_in_sec`) to
    get the speed increment.
  prefs: []
  type: TYPE_NORMAL
- en: The incremented speed is then multiplied by a factor that is less than `1` to
    take friction into account. This factor is the `DRAG_FACTOR` constant for a time
    of 1 second. To get the decrease factor for the actual time elapsed, the exponential
    function must be used (`powf`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the new horizontal position of the ski tip, the following statement
    is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This multiplies the speed (`self.forward_speed`) by the time elapsed (`self.period_in_sec`)
    to obtain the space increment. This increment is projected on the horizontal direction
    using the sine function (`self.direction.sin()`) to get the horizontal position
    variation.
  prefs: []
  type: TYPE_NORMAL
- en: A similar computation is performed to compute the movement along the slope,
    which is actually the offset of the position of the gates as the ski is always drawn
    at the same *Y* coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw the poles of the gates in the `draw` method, first, two meshes are
    created by using the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, the meshes are created directly without using a `MeshBuilder` object.
    The `new_circle` method requires the context, the fill mode, the center, the radius,
    a tolerance, and the color as parameters. Tolerance is a trade-off between performance
    and graphic quality. The former mesh is used to draw all the poles, except those
    of the finish gate, and the latter mesh is used to draw the poles of the finish
    gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, these meshes are drawn to show all the poles using statements such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, the third argument (with the `DrawParam` type) is specified in a simple
    but somewhat obscure way; it is a tuple containing just one element. This element
    is interpreted as the position where the mesh will be drawn, corresponding to
    the `dest` method call seen in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have now also seen the peculiarities of the `gg_silent_slalom` project.
    In the next section, we will look at the `gg_assets_slalom` project, which adds
    sound and text to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the gg_assets_slalom project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will examine the `gg_assets_slalom` project, which is an
    implementation of the `ggez` framework of the `assets_slalom` game presented in
    the preceding chapter. Here, we will only examine the differences between the
    `gg_silent_slalom` project and the `assets_slalom` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference is found in how the assets are loaded. The assets of these
    projects are of two kinds—fonts and sounds. To encapsulate these assets, instead
    of using objects with the `Asset<Font>` and `Asset<Sound>` types, `ggez` uses
    objects with the `graphics::Font` and `audio::Source` types, respectively. These
    assets are loaded into the constructor of the model. For example, the constructor
    of the `Screen` object contains the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first one loads a file containing a `TrueType` font for the `ctx` context and
    returns an object encapsulating this font. The second one loads (for the `ctx`
    context) a file containing an OGG sound and returns an object encapsulating this
    sound. Both files must be present in the `asset` folder that was specified in
    the `main` function using the `add_resource_path` method, and they must be in
    one of the supported formats.
  prefs: []
  type: TYPE_NORMAL
- en: There is an important difference in how `quicksilver` and `ggez` load their
    assets. `q``uicksilver` loads them asynchronously, creating future objects whose
    access function must ensure that the asset is loaded. On the other hand, `ggez`
    is synchronous; when it loads the assets, it blocks the application until the
    assets are completely loaded. The objects created are not future objects, and
    so they can be used immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Because it uses future objects, `quicksilver` is more sophisticated, but this sophistication
    is probably useless on a desktop application because, provided your application
    has no more than a few megabytes of assets, loading them from local storage is
    quite fast, and so some blocking statements at application startup are not going
    to be inconvenient. Of course, to prevent slowing down animations, the assets
    must be loaded only at application startup, when changing the level of a game,
    or when the game is ending. Once an asset is loaded, it is immediately available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest asset to use is sound. To play a sound, the following function
    is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Its first argument is the `sound` asset and the second argument is the desired
    `volume` level. This function simply sets the volume and then plays the sound
    using the `play_detached` method. This method overlaps the new sound with any
    other sounds that are already playing. There is also a `play` method, which automatically
    stops playing the old sounds before starting the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play a fixed-volume sound, such as one that signals the failure to enter
    a gate, the following statement is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, to make a sound proportional to the speed, the following statement
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The font is quite easy to use, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first statement creates a text shape by calling the `new` function. It
    has a tuple with three fields as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: The string to print (`elapsed_shown_text`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scalable font object to use for this text (`self.font`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The desired size of the generated text (`16.0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second statement draws the created text shape on the `ctx` context. This
    statement specifies a tuple that will be converted to a `DrawParam` value as a
    third parameter. The specified sub-arguments are the destination point (`Point2::new(4.0,
    4.0)`) and the color to use (`graphics::BLACK`).
  prefs: []
  type: TYPE_NORMAL
- en: So, we have now covered the whole game. In the next section, we will look at
    another game, which uses mouse clicks and other kinds of assets—images.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the gg_whac project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine the `gg_whac` project, which is an implementation
    in the `ggez` framework of the famous **Whack-A-Mole **arcade game. First of all,
    let's try to play it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running `cargo run --release` in the `gg_whac` folder, the following
    window will appear, which shows a lawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb92e5c9-1f75-4275-bb78-e3dc6baa4d3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For those of you who aren''t familiar with this game, here are the rules. When
    you click on the Start button, the following things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The Start button disappears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The countdown begins at the top left from 40 seconds to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A nice mole pops up in a random position of the lawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mouse cursor becomes a barred circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you move your mouse cursor over the mole, it becomes a cross and a big mallet
    appears; this mallet can be dragged by the mouse as long as you remain over the
    mole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your window should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b971420a-927d-4040-aedf-18b8cfe6d402.png)'
  prefs: []
  type: TYPE_IMG
- en: If you click the main mouse button when the mouse cursor hovers over the mole,
    the mole disappears and another one appears in another position. In the meantime,
    a counter tells you how many moles you have managed to whack. When the countdown
    reaches 0, you are presented with your score.
  prefs: []
  type: TYPE_NORMAL
- en: The assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the behavior of this application, first, let''s look at the content
    of the `assets` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cry.ogg` is the sound produced by the mole when it pops up out of the lawn.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`click.ogg` is the sound of the mallet when it hits the mole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bump.ogg` is the sound of the mallet when it hits the lawn but misses the
    mole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`two_notes.ogg` is the jingle produced when the game ends because the countdown
    has elapsed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font.ttf` is the font used for all the visible text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mole.png` is the image of the moles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mallet.png` is the image of the mallet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lawn.jpg` is the image used to fill the background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`button.png` is the image used for the Start button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We already saw, in the preceding section, how to load and use sounds and fonts.
    Here, there is a new kind of asset—images. Images are declared by statements such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'They are loaded, at application initialization time, by statements such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'They are displayed by statements such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `lawn_params` argument, with a type of `DrawParam`, can specify a
    position, a scale, a rotation, and even a crop.
  prefs: []
  type: TYPE_NORMAL
- en: The general structure of the application and events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s examine the structure of the source code. Like the preceding projects
    we have seen in this chapter, this project does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines some constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines a model with the `struct Screen` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements the `EventHandler` trait with its required `update` and `draw` methods and
    its optional `mouse_button_down_event` and `mouse_button_up_event` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the `main` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most important field of the model is `mode`, whose type is defined by the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial mode is `Ready`, where the countdown is stopped and the game is
    ready to start. When the game is running, there are the following states:'
  prefs: []
  type: TYPE_NORMAL
- en: No mole appears.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One mole rises from the ground.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One mole rises and waits to be hit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blow of the mallet is about to hit the mole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mole that has been hit lowers into the ground.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, actually, the first state does not exists, because as soon as the game
    starts, a mole pops up, and also, as soon as you hit a mole, another mole pops
    up. The second and third states are represented by `Mode::Raising`. Simply put, when
    the mole reaches its full height, it is not raised.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth and fifth states are represented by `Mode::Lowering`. Simply put,
    the mole lowers simultaneously with the mallet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the input operations, it should be noted that for the `EventHandler`
    trait, no key handling methods are implemented as this game does not use the keyboard.
    Instead, it uses the mouse, and so there is the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first method is invoked when a mouse button is pressed and the second one
    is invoked when a mouse button is released.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument of these methods (`button`) is an enum indicating which button
    has been pressed; `MouseButton::Left` actually represents the main mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth and fifth arguments of these methods (`x` and `y`) are the coordinates
    of the position of the mouse when its button has been pressed. Their unit of measurement
    is pixels and the origin of their coordinate system is the top-left vertex of
    the context, which in our case is the client area of the window.
  prefs: []
  type: TYPE_NORMAL
- en: Only the main mouse button is handled. When it is pressed, the point representing
    the current mouse position is stored in the `mouse_down_at` field of the model,
    and when it is released, it is stored in the `mouse_up_at` field of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'These fields are defined in the model in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Their value is initialized to `None` and is only set to a `Point2` value by
    the preceding code; it is reset to `None` as soon as these events are processed
    by the `update` method. So, each mouse event is only processed once.
  prefs: []
  type: TYPE_NORMAL
- en: Other fields of the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the fields that we have already described, the model has the
    following other fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `start_time` field is used to show the current remaining time during the
    game and to show the Game finished text when the game ends. It is initialized
    to `None`, and then any time the Start button is pressed, the current time is
    stored in it.
  prefs: []
  type: TYPE_NORMAL
- en: The moles do not appear in totally random positions. The lawn is covertly organized
    into three rows and five columns. A mole appears in 1 of these 15 positions, chosen
    at random. The `active_mole_column` and `active_mole_row` fields contain the zero-based
    column and the row of the currently displayed mole.
  prefs: []
  type: TYPE_NORMAL
- en: The `active_mole_position` field contains the fraction of the appearance of
    the current mole. A `0` value means that the mole is totally hidden. A value of
    `1` means that the image of the mole (representing a part of its body) has completely
    appeared. The `n_hit_moles` field counts how many moles have been hit.
  prefs: []
  type: TYPE_NORMAL
- en: The `random_generator` field is a pseudo-random number generator used to generate
    the position of the next mole to show. Finally, `start_button` is a field representing
    the Start button. However, its type is not defined in a library. It is defined
    in this application, as we are going to explain.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Business applications have windows full of small, interactive graphical elements,
    such as buttons and textboxes. These elements are usually named **controls** by
    Microsoft Windows documentation and **widgets** (from window objects) in Unix-like
    environments. Defining widgets using graphics primitives is a rather complex feat,
    so if you want to develop a business application, you should probably use a library
    that defines a set of widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Neither the Rust standard library nor the `ggez` framework defines widgets.
    However, if you need just a few very simple widgets, you can develop them yourself,
    such as the button we will develop for this project. Let's see how this is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, there is a definition of the `Button` type that can be instantiated
    for any button you want to add to your window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Our button is just an image resized as we want with text centered on it. This
    image is the same for all the buttons, and so it should be shared throughout the
    program to save memory. This is why the `base_image` field is a reference-counted
    pointer to an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bounding_box` field indicates the desired position and size of the button.
    The image will be stretched or shrunk to fit this size. The `drawable_text` field
    is a text shape that will be drawn over the image of the button as its caption.
    The `Button` type implements several methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new` to create a new button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contains` to check whether a given point is inside the button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draw` to display itself in the specified context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `new` method has many arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `caption` argument is the text to display inside the button. The `center`
    argument is the desired position of the center of the button. The `font` and `base_image`
    arguments are the font and image to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our button, the following expression is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It specifies `"Start"` as the caption, a width of `600` pixels, and a height
    of `40` pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw the button, first, we check whether the main mouse button is currently
    pressed using this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, it is possible to make the button appear like it is being pressed
    to give visual feedback of the button''s operation. Then, we check whether the
    mouse cursor is inside the button using this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This turns the color of the button caption red when the mouse hovers over the
    button to show the user that the button can be clicked on. So, we have now looked
    at the most interesting parts of this project, which ends our look into the `ggez`
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to build two-dimensional games for the desktop using the `ggez`
    framework. This framework not only allows us to structure the application according
    to the animation-loop architecture and the MVC architectural pattern but also
    to get discrete input events. In addition, we have seen why a linear algebra library
    can be useful for graphical applications.
  prefs: []
  type: TYPE_NORMAL
- en: We created and looked at four apps—`gg_ski`, `gg_silent_slalom`, `gg_assets_slalom`,
    and `gg_whac`.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we learned how to build a graphical desktop app using the `ggez` framework,
    which is structured according to the MVC architecture, and how to implement both
    an animation-loop architecture and an event-driven architecture, possibly in the
    same window. Additionally, we also learned to draw graphical elements on a web
    page using `ggez`, as well as loading and using static resources using `ggez`.
    At the end of the chapter, we encapsulated two-dimensional points and vectors
    in a structure and saw how to manipulate them using the `nalgebra` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will look at a completely different technology: parsing.
    Parsing text files is useful for many purposes, in particular for interpreting
    or compiling a source code program. We will take a look at the `nom` library,
    which makes parsing tasks easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a vector and a point in linear algebra?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the geometrical concepts corresponding to algebraic vectors and points?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can capturing events be useful, even in an animation loop-oriented application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can loading synchronous assets be a good idea in a desktop game?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does `ggez` get input from the keyboard and mouse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the meshes used in the `ggez` framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you build a `ggez` mesh?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you obtain a desired animation frame rate using `ggez`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you draw a mesh in the desired position using `ggez`, with the desired
    scale and rotation values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you play sound using `ggez`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ggez` project can be downloaded from [https://github.com/ggez/ggez](https://github.com/ggez/ggez).
    This repository contains many example projects, including a complete asteroid
    arcade game.
  prefs: []
  type: TYPE_NORMAL
