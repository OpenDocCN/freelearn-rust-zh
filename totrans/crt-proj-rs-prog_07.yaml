- en: Creating a Desktop Two-Dimensional Game Using ggez
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ggez 创建桌面二维游戏
- en: In the preceding chapter, we saw how to build interactive software based on
    the animation-loop architecture (typically, animated games) for desktops or for
    web browsers from a single set of source codes using the `quicksilver` framework. A
    drawback of this approach is that many input/output functions available on the
    desktop are not available on web browsers, and so a framework for web browsers
    does not necessarily provide as many features to desktop applications that are
    offered on desktop platforms, such as file storage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们看到了如何使用 `quicksilver` 框架从单一源代码集构建基于动画循环架构的交互式软件（通常是桌面或网页浏览器中的动画游戏）。这种方法的一个缺点是，许多在桌面上可用的输入/输出函数在网页浏览器中不可用，因此网页浏览器框架不一定提供与桌面平台提供的桌面应用程序一样多的功能，例如文件存储。
- en: In addition, when using the animation-loop architecture, it is quite awkward
    to get discrete input, such as mouse clicks, typed letters, or digits. For this,
    an event-driven architecture is more appropriate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在使用动画循环架构时，获取离散输入（如鼠标点击、键入字母或数字）相当尴尬。为此，事件驱动架构更为合适。
- en: In this chapter, another application framework will be introduced—the `ggez`
    framework. This handles both animation-loop and discrete events, but at the time
    of writing, it only supports two-dimensional desktop applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将介绍另一个应用程序框架——`ggez` 框架。该框架处理动画循环和离散事件，但在编写本书时，它仅支持二维桌面应用程序。
- en: In the previous chapter, we saw that to compute the position and orientation
    of various graphical objects, some analytical geometry and trigonometry is required.
    For more complex applications, these mathematical computations can become overwhelming.
    To simplify the code, it is useful to encapsulate positions in point objects and
    translations in vector objects, and so in this chapter, we will look at how to
    perform these encapsulations. The `nalgebra` mathematical library helps us to
    do this and will be introduced in this chapter, too.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们了解到为了计算各种图形对象的位置和方向，需要一些解析几何和三角学的知识。对于更复杂的应用，这些数学计算可能会变得令人难以承受。为了简化代码，将位置封装在点对象中，将平移封装在向量对象中是有用的，因此在本章中，我们将探讨如何执行这些封装。`nalgebra`
    数学库帮助我们完成这项工作，也将在本章中介绍。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding linear algebra
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线性代数
- en: Implementing the `gg_ski` project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `gg_ski` 项目
- en: Implementing the `gg_silent_slalom` project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `gg_silent_slalom` 项目
- en: Implementing the `gg_assets_slalom` project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `gg_assets_slalom` 项目
- en: Implementing the `gg_whac` project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `gg_whac` 项目
- en: In particular, you will see the implementation of the same three projects we
    looked at in the previous chapter (`gg_ski`, `gg_silent_slalom`, and `gg_assets_slalom`)
    to demonstrate the animation loop, as well as a Whac-A-Mole game (`gg_whac`) to
    demonstrate the handling of discrete events.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，您将看到与上一章中查看的相同三个项目（`gg_ski`、`gg_silent_slalom` 和 `gg_assets_slalom`）的实现，以演示动画循环，以及一个
    Whac-A-Mole 游戏（`gg_whac`）以演示处理离散事件。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter uses references to the animation-loop architecture and the slalom
    game implemented in the preceding chapter. The `ggez` framework requires (for
    correctly rendering graphical objects) the OpenGL 3.2 API to be well supported
    by the operating system. Therefore, old operating systems such as Windows XP cannot
    be used.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了前一章中实现的动画循环架构和回转滑雪游戏的引用。`ggez` 框架要求操作系统良好支持 OpenGL 3.2 API 以正确渲染图形对象。因此，旧操作系统如
    Windows XP 不能使用。
- en: The complete source code for this chapter is found in the `Chapter07` folder of
    the repository at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码位于[https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers)存储库的
    `Chapter07` 文件夹中。
- en: macOS users may struggle to install `coreaudio-sys`. Upgrading the patch version
    of `coreaudio-sys` to `0.2.3` resolves this issue.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 用户可能难以安装 `coreaudio-sys`。将 `coreaudio-sys` 的补丁版本升级到 `0.2.3` 可以解决这个问题。
- en: Project overview
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will first look at what linear algebra is and why it is
    useful to describe and manipulate the objects drawn in any graphical game. Then,
    we will look at how to use the `nalgebra` library to perform linear algebra operations
    in our programs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先探讨线性代数是什么以及为什么它对描述和操作任何图形游戏中的对象是有用的。然后，我们将探讨如何使用 `nalgebra` 库在我们的程序中执行线性代数运算。
- en: After that, we will recreate the same projects used in the previous chapter,
    but using the `nalgebra` library and the `ggez` framework instead of the `quicksilver`
    framework. `gg_ski` is a rewrite of `ski`, `gg_silent_slalom` is a rewrite of
    `silent_slalom`, and `gg_assets_slalom` is a rewrite of `assets_slalom`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将重新创建前一章中使用的相同项目，但使用 `nalgebra` 库和 `ggez` 框架而不是 `quicksilver` 框架。`gg_ski`
    是 `ski` 的重写，`gg_silent_slalom` 是 `silent_slalom` 的重写，而 `gg_assets_slalom` 是 `assets_slalom`
    的重写。
- en: At the end of the chapter, we will look at the implementation of a completely
    different game with the `gg_whac` project to see how to handle discrete events
    in an architecture that mixes the animation loop with an event-driven architecture.
    This will also show how widgets (such as buttons) can be created and added to
    a window.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将通过 `gg_whac` 项目来查看一个完全不同的游戏的实现，以了解如何在将动画循环与事件驱动架构混合的架构中处理离散事件。这还将展示如何创建和将小部件（如按钮）添加到窗口中。
- en: Understanding linear algebra
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解线性代数
- en: 'Linear algebra is the sector of mathematics regarding systems of first-degree
    equations, such as the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数是数学的一个分支，涉及一阶方程组系统，如下所示：
- en: '![](img/c865534e-7942-46fb-a5cb-2a43c0c5f797.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c865534e-7942-46fb-a5cb-2a43c0c5f797.png)'
- en: This system of equations has a solution to certain values (that is, ![](img/62e199f2-55af-4a4b-93d8-a8d2c310a1e0.png)).
    In addition to being useful for solving systems of equations, the concepts and
    methods of linear algebra are also useful for representing and manipulating geometrical
    entities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程组系统对某些值有解（即，![](img/62e199f2-55af-4a4b-93d8-a8d2c310a1e0.png)）。除了在解方程组方面有用外，线性代数的概念和方法对于表示和操作几何实体也是很有用的。
- en: In particular, any position on a plane can be represented by two coordinates,
    *x* and *y*, and any position in space can be represented by three coordinates,
    *x*, *y*, and *z*. In addition, any translation of a position on a plane can be
    represented by two coordinates, *Δx* and *Δy*, and any translation of a position
    in space can be represented by three coordinates, *Δx*, *Δy*, and *Δz*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，平面上任何位置都可以用两个坐标表示，*x* 和 *y*，而空间中任何位置都可以用三个坐标表示，*x*，*y* 和 *z*。此外，平面上位置的任何平移都可以用两个坐标表示，*Δx*
    和 *Δy*，而空间中位置的任何平移都可以用三个坐标表示，*Δx*，*Δy* 和 *Δz*。
- en: 'For example, consider two positions on a plane:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑平面上两个位置：
- en: '*p[1]*: Its coordinates are *x = 4, y = 7.*'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p[1]*: 它的坐标是 *x = 4, y = 7.*'
- en: '*p[2]*: Its coordinates are *x = 10, y = 16.*'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p[2]*: 它的坐标是 *x = 10, y = 16.*'
- en: 'Consider two translations on that plane:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑平面上两个平移：
- en: '*t[1]*: Its coordinates are ![](img/b9b71b1b-4a16-47c9-a86d-dd1d42c531cd.png).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t[1]*: 它的坐标是 ![](img/b9b71b1b-4a16-47c9-a86d-dd1d42c531cd.png).'
- en: '*t[2]*: Its coordinates are ![](img/255887c4-c5f8-4c26-a38c-5169b37fb204.png) .'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t[2]*: 它的坐标是 ![](img/255887c4-c5f8-4c26-a38c-5169b37fb204.png) .'
- en: 'You can say that if you translate the *p[1]* position by the *t[1]* translation,
    you get to the *p[2]* position. The computation is done by adding the corresponding
    coordinates: *p[1x] + t[1x] = p[2x]* (or, in numbers, 4 + 6 = 10) and *p[1y] +
    t[1y] = p[2y]* (or, in numbers, 7 + 9 = 16).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说，如果你通过 *t[1]* 平移将 *p[1]* 位置平移，你会到达 *p[2]* 位置。计算是通过添加相应的坐标来完成的：*p[1x] + t[1x]
    = p[2x]*（或者，用数字来说，4 + 6 = 10）和 *p[1y] + t[1y] = p[2y]*（或者，用数字来说，7 + 9 = 16）。
- en: If you apply two translations sequentially to the *p[1]* position—the *t[1]* translation
    and the *t[2]* translation—then you will obtain another position (say, *p[3]*).
    You will also obtain the same result if you first sum the two translations (by
    summing their components memberwise) and then applying the resulting translation
    to *p[1]*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你依次对 *p[1]* 位置应用两个平移——*t[1]* 平移和 *t[2]* 平移——那么你将获得另一个位置（比如说，*p[3]*）。如果你首先将两个平移（通过逐成员求和它们的分量）相加，然后将结果平移应用到
    *p[1]* 上，你也会得到相同的结果。
- en: So, for the *x* coordinate, we have *(p[1x] + t[1x]) + t[2x] = p[1x] + (t[1x]
    + t[2x])* and a similar equation also holds for the *y* coordinate. So, translations
    can be added. You can add a translation to another one by summing their respective
    coordinates, instead, it does not make sense to add one position to another position.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于 *x* 坐标，我们有 *(p[1x] + t[1x]) + t[2x] = p[1x] + (t[1x] + t[2x])*，对于 *y*
    坐标也有类似的等式。因此，可以添加变换。您可以通过将各自的坐标相加来向另一个变换添加变换，而不是将一个位置添加到另一个位置上。
- en: 'You can simplify your geometric computations by applying the computations to
    the position and translation entities themselves using the following formula:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将计算应用于位置和变换实体本身来简化您的几何计算，使用以下公式：
- en: '![](img/c06b35b1-a5ee-4926-94df-fa46632a036f.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c06b35b1-a5ee-4926-94df-fa46632a036f.png)'
- en: 'In linear algebra, there are two concepts that can be applied to these sorts
    of operations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性代数中，有两个概念可以应用于这类操作：
- en: '**Vectors**: An algebraic *vector* is a tuple of numbers that can be added
    to another vector, obtaining another vector, which is what is needed to *represent
    translations*.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量**：代数*向量*是一组可以添加到另一个向量中的数字，得到另一个向量，这正是表示变换所需的。'
- en: '**Points**: An algebraic *point* is a tuple of numbers that cannot be added
    to another point, but that can be incremented by a vector, thereby obtaining another
    point, which is what is needed to *represent a**position*.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点**：代数*点*是一组不能添加到另一个点中的数字，但可以通过一个向量增加，从而得到另一个点，这正是表示位置所需的。'
- en: Therefore, linear algebraic *N-dimensional vectors* are fit to represent *translations*
    in an *N*-dimensional geometric space, whereas linear algebraic *N-dimensional
    points* are fit to represent *positions* in an *N*-dimensional geometric space.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，线性代数的 *N 维向量* 适合表示 *N 维几何空间中的变换，而线性代数的 *N 维点* 适合表示 *N 维几何空间中的位置*。
- en: The `nalgebra` library (pronounced *en-algebra*) is a collection of to many
    algebraic algorithms that provide implementations for these kinds of two-dimensional
    point and vector types, and so it will be used in all of the following projects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`nalgebra` 库（发音为 *en-algebra*）是一系列代数算法的集合，它为这些类型的二维点和向量类型提供了实现，因此它将在所有以下项目中使用。'
- en: 'Using this library, you can write the following program, which shows which
    operations are allowed and which are forbidden, using vectors and points:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个库，您可以编写以下程序，该程序显示了哪些操作是允许的，哪些是不允许的，使用向量和点：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first three statements of the `main` function create two two-dimensional
    points and one two-dimensional vector whose coordinates are `f32` numbers. This
    sort of inner numeric type can often be *inferred*, but here it is specified for
    clarity.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数的前三个语句创建两个二维点和一个二维向量，其坐标为 `f32` 数字。这种内部数值类型通常可以*推断*出来，但在这里为了清晰起见进行了指定。'
- en: The next four statements show that both the `Point2` and `Vector2` types contain
    the `x` and `y` fields, initialized by the arguments of the `new` function. So,
    the `Point2` and `Vector2` types look quite similar, and actually many libraries
    and many developers use just one type to store both positions and translations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下四个语句显示，`Point2` 和 `Vector2` 类型都包含 `x` 和 `y` 字段，这些字段由 `new` 函数的参数初始化。因此，`Point2`
    和 `Vector2` 类型看起来非常相似，实际上许多库和许多开发者只使用一个类型来存储位置和变换。
- en: 'However, these types differ for the allowed operations. The following four
    statements show which operations can be carried out:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些类型对于允许的操作是不同的。以下四个语句显示了哪些操作可以进行：
- en: Sum a vector to a point (`p1 + v`), obtaining another point.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个向量加到一个点上（`p1 + v`），得到另一个点。
- en: Subtract two points (`p2 - p1`), obtaining a vector.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从两个点中减去一个点（`p2 - p1`），得到一个向量。
- en: Sum two vectors or subtract two vectors (`v + v - v`), obtaining a vector in
    both cases.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个向量相加或相减（`v + v - v`），在两种情况下都得到一个向量。
- en: Multiply a vector by a number or divide a vector by a number (`(2\. * v) / 2.`),
    obtaining a vector in both cases.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个向量乘以一个数字或除以一个数字（`(2\. * v) / 2.`），在两种情况下都得到一个向量。
- en: There are some operations allowed on vectors that shouldn't be allowed on points
    (because they make no sense for them), which the last two statements show. You
    cannot add two points (`p1 + p2`) and actually, this operation is commented out
    to prevent a compilation error. You shouldn't multiply a point by a number (`2\.
    * p1`), although, for some reason, the `nalgebra` library allows this.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在向量上允许执行一些操作，这些操作在点（因为它们对它们没有意义）上是不允许的，最后两个语句展示了这一点。你不能将两个点相加（`p1 + p2`），实际上，这个操作被注释掉以防止编译错误。你不应该将一个点乘以一个数字（`2\.
    * p1`），尽管，出于某种原因，`nalgebra` 库允许这样做。
- en: If you want to learn more about the `nalgebra` library, you can find its documentation
    at [https://www.nalgebra.org/](https://www.nalgebra.org/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 `nalgebra` 库的信息，你可以在 [https://www.nalgebra.org/](https://www.nalgebra.org/)
    找到它的文档。
- en: Now that we have looked at a good way to handle geometric coordinates using
    the `nalgebra` library, let's see how to use them in game applications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了使用 `nalgebra` 库处理几何坐标的好方法，让我们看看如何在游戏应用中使用它们。
- en: Implementing the gg_ski project
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `gg_ski` 项目
- en: 'The first three projects in this chapter are just a rewrite of the three projects
    covered in the preceding chapter but are converted so that they use the `ggez`
    framework and the `nalgebra` library instead. They are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前三个项目只是对上一章中涵盖的三个项目的重写，但它们被转换成使用 `ggez` 框架和 `nalgebra` 库。它们如下所示：
- en: The `ski` project has become `gg_ski`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ski` 项目已更名为 `gg_ski`。'
- en: The `silent_slalom` project has become `gg_silent_slalom`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`silent_slalom` 项目已更名为 `gg_silent_slalom`。'
- en: The `assets_slalom` project has become `gg_assets_slalom`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assets_slalom` 项目已更名为 `gg_assets_slalom`。'
- en: 'Each project''s behavior is very similar to its respective project in [Chapter
    6](72504b4f-2094-4890-9e99-a9251f38c538.xhtml), *Creating a WebAssembly Game Using
    Quicksilver*, and so you can go back to that chapter to see the screenshots accompanying
    each one. For all three projects, `gg_ski`, `gg_silent_slalom`, and `gg_assets_slalom`, the
    `Cargo.toml` file has the following change. Instead of the `quicksilver` dependency,
    there are the following dependencies:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目的行为与其在 [第 6 章](72504b4f-2094-4890-9e99-a9251f38c538.xhtml) 中对应的项目的行为非常相似，即
    *使用 Quicksilver 创建 WebAssembly 游戏*，因此你可以回到那一章查看每个项目的截图。对于所有三个项目，`gg_ski`、`gg_silent_slalom`
    和 `gg_assets_slalom`，`Cargo.toml` 文件有以下更改。不再是 `quicksilver` 依赖项，而是以下依赖项：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The term `ggez` (pronounced *G. G. easy*) is a slang term used by multiplayer
    online gamers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 `ggez`（发音为 *G. G. easy*）是多人在线游戏玩家使用的俚语。
- en: The `ggez` framework was admittedly inspired by the **LÖVE game framework**.
    The main difference between them lies in the programming languages. LÖVE is implemented
    in C++ and is programmable in Lua, while `ggez` is both implemented and programmable
    in Rust.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ggez` 框架不可否认地受到了 **LÖVE 游戏框架** 的启发。它们之间的主要区别在于编程语言。LÖVE 使用 C++ 实现，可以用 Lua
    编程，而 `ggez` 既可以实现也可以用 Rust 编程。'
- en: Now, let's compare the `main.rs` source code of the `ski` project to that of
    the `gg_ski` project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们比较 `ski` 项目和 `gg_ski` 项目的 `main.rs` 源代码。
- en: The main function
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主函数
- en: 'At the end of the file, there is the `main` function, which prepares the context
    for the game and then runs the game:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，有 `main` 函数，它为游戏准备上下文然后运行游戏：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this function, you can see that, when you use the `ggez` framework, you
    don''t just run the model. First, you should create three objects:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，你可以看到，当你使用 `ggez` 框架时，你不仅仅运行模型。首先，你应该创建三个对象：
- en: A context, which, in our case, is a window. It is assigned to the `context`
    variable.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的案例中，这是一个窗口。它被分配给 `context` 变量。
- en: An animation loop, which animates that context. It is assigned to the `animation_loop` variable.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个动画循环，它使该上下文动画化。它被分配给 `animation_loop` 变量。
- en: The model, in our case, is of `Screen` type. It is assigned to the `game` variable.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的案例中，模型是 `Screen` 类型。它被分配给 `game` 变量。
- en: After creating these objects, you can call the `run` function with these three
    objects as arguments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些对象后，你可以使用这三个对象作为参数调用 `run` 函数。
- en: To create the context and the animation loop, a `ContextBuilder` object is first
    created by calling the `ContextBuilder::new` function; then, this builder is modified
    by calling its methods—`window_setup`, `window_mode`, and `add_resource_path`.
    Finally, the call to the `build` method returns both a context and an animation
    loop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建上下文和动画循环，首先通过调用 `ContextBuilder::new` 函数创建一个 `ContextBuilder` 对象；然后，通过调用其方法——`window_setup`、`window_mode`
    和 `add_resource_path` 来修改这个构建器。最后，调用 `build` 方法的调用返回一个上下文和一个动画循环。
- en: 'However, notice the following things:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意以下事项：
- en: The call to `new` specifies a name for the app (`"slalom"`) and a name for its
    creator (`"ggez"`).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`new`的调用指定了应用程序的名称（`"slalom"”）和创建者的名称（`"ggez"`）。
- en: The call to `window_setup` specifies the text in the title bar of the window
    (`"Slalom"`).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`window_setup`的调用指定了窗口标题栏中的文本（`"Slalom"`）。
- en: The call to `window_mode` specifies the desired size of the window.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`window_mode`的调用指定窗口的期望大小。
- en: The call to `add_resource_path` specifies the name of the folder that will contain
    the assets loaded at runtime (`"static"`), even if we are not going to use assets in
    this project.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`add_resource_path`的调用指定了将包含在运行时加载的资源的文件夹名称（`"static"`），即使我们在这个项目中不会使用资源。
- en: Regarding the `Screen` model, notice that it is created using the `new` method,
    and so we will have to provide this method; however, we could use any other name
    for this sort of creation method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Screen`模型，请注意它是使用`new`方法创建的，因此我们将不得不提供此方法；然而，我们可以为这种类型的创建方法使用任何其他名称。
- en: Patterns of input handling
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入处理模式
- en: 'Both `quicksilver` and `ggez` adopt an animation loop-based **Model-View-Controller**
    (**MVC**) pattern. This is done by requiring the model to implement a trait that
    has two required methods:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`quicksilver`和`ggez`都采用基于动画循环的**模型-视图-控制器**（**MVC**）模式。这是通过要求模型实现一个具有两个必需方法的特质来完成的：'
- en: '`update` is the controller.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`是控制器。'
- en: '`draw` is the view.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw`是视图。'
- en: 'Both frameworks run an implicit loop that periodically (many times per second)
    calls the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 两个框架都运行一个隐式循环，该循环周期性地（每秒多次）调用以下操作：
- en: The controller to update the model, using possible input data and the preceding
    values of the model
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器用于更新模型，使用可能的输入数据和模型的先前值
- en: The view to update the screen, using the updated values of the model
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图用于更新屏幕，使用模型的更新值
- en: However, there is a substantial difference in the technique used by these frameworks
    to get input. `quicksilver` is a complete animation loop-oriented framework. The
    controller (or the `update` function) gets input accessing the state of input
    devices—it can check where the mouse is and which mouse buttons and keyboard keys
    are being pressed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些框架在获取输入时使用的技巧有实质性的不同。`quicksilver`是一个完整的面向动画循环的框架。控制器（或`update`函数）通过访问输入设备的状态来获取输入——它可以检查鼠标的位置以及哪些鼠标按钮和键盘键被按下。
- en: 'Instead, `ggez` input handling is event-driven because it captures input device
    *transitions*, not input device *states*. There are several kinds of possible
    input device transitions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`ggez`的输入处理是事件驱动的，因为它捕获输入设备的*转换*，而不是输入设备的*状态*。存在几种可能的输入设备转换：
- en: A movement of the mouse (*mouse moves*)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标的移动（*鼠标移动*）
- en: A press of a mouse button (*mouse button down*)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标按钮的按下（*鼠标按钮按下*）
- en: A release of a pressed mouse button (*mouse button up*)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按压鼠标按钮的释放（*鼠标按钮抬起*）
- en: A press of keyboard key (*key down*)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按键的按下（*按键按下*）
- en: A release of a pressed keyboard key (*key up*)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按压键盘键的释放（*按键抬起*）
- en: In `ggez`, for each of these possible input device transitions, the trait declares
    an optional handler routine that can be implemented for the model by the application
    code. These routines are called `mouse_motion_event`, `mouse_button_down_event`,
    `mouse_button_up_event`, `key_down_event`, and `key_up_event`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ggez`中，对于这些可能的输入设备转换中的每一个，特质声明了一个可选的处理程序例程，该例程可以由应用程序代码为模型实现。这些例程被称为`mouse_motion_event`、`mouse_button_down_event`、`mouse_button_up_event`、`key_down_event`和`key_up_event`。
- en: If an event happens in an animation-loop time frame, the corresponding handlers
    are invoked just before the `update` function is invoked. In these event handlers,
    the application code should store (in the model) the information gathered from
    the event, such as which key has been pressed or in which position the mouse has
    been moved. Then, the `update` function can process this input data to prepare
    the information needed by the view.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在动画循环时间框架内发生事件，则相关处理程序将在`update`函数被调用之前被调用。在这些事件处理程序中，应用程序代码应将（在模型中）从事件中收集的信息存储起来，例如哪个键被按下或鼠标移动到了哪个位置。然后，`update`函数可以处理这些输入数据，为视图准备所需的信息。
- en: 'To better understand these techniques, consider, as an example, the following
    sequence of events or timeline:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些技巧，以以下事件序列或时间线为例：
- en: The `update` function is invoked 10 times per second—that is, once every tenth
    of a second—so, frames per second = 10.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`函数每秒调用10次——也就是说，每十分之一秒调用一次——因此，每秒帧数=10。'
- en: The user presses the *A* key at `0.020` seconds and releases it 50 milliseconds
    later at `0.070` seconds, and then they press the *B* key at `0.140` seconds and
    release it 240 milliseconds later at `0.380` seconds.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在 `0.020` 秒时按下 *A* 键，并在 `0.070` 秒后释放，然后他们在 `0.140` 秒时按下 *B* 键，并在 `0.380` 秒后释放。
- en: 'For `quicksilver`, we have the following timeline:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `quicksilver`，我们有以下的时间线：
- en: '| **At time** | **Input device state** | **Input processing in the update function**
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **在时间点** | **输入设备状态** | **更新函数中的输入处理** |'
- en: '| `0.0` | No key is pressed. | Nothing. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `0.0` | 没有按键被按下。 | 没有操作。 |'
- en: '| `0.1` | No key is pressed. | Nothing. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `0.1` | 没有按键被按下。 | 没有操作。 |'
- en: '| `0.2` | The *B* key is pressed. | The *B* key is processed. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `0.2` | 按下了 *B* 键。 | 处理了 *B* 键。 |'
- en: '| `0.3` | The *B* key is pressed. | The *B* key is processed. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `0.3` | 按下了 *B* 键。 | 处理了 *B* 键。 |'
- en: '| `0.4` | No key is pressed. | Nothing. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `0.4` | 没有按键被按下。 | 没有操作。 |'
- en: '| `0.5` | No key is pressed. | Nothing. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `0.5` | 没有按键被按下。 | 没有操作。 |'
- en: 'For `ggez`, we have the following timeline:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ggez`，我们有以下的时间线：
- en: '| **At time** | **Input events** | **Input processing in the** **update function**
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **在时间点** | **输入事件** | **更新函数中的输入处理** |'
- en: '| `0.0` | No input events. | No key info is stored in the model. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `0.0` | 没有输入事件。 | 模型中没有存储任何按键信息。 |'
- en: '| `0.1` | The `key_down_event` function is invoked with the *A* key as an argument.
    It stores the *A* key in the model.The `key_up_event` function is invoked with
    the *A* key as an argument. It does nothing. | The *A* key is read from the model.
    It is processed and reset. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `0.1` | 使用 *A* 键作为参数调用了 `key_down_event` 函数。它在模型中存储了 *A* 键。使用 *A* 键作为参数调用了
    `key_up_event` 函数。它没有做任何事情。 | 从模型中读取 *A* 键。它被处理并重置。 |'
- en: '| `0.2` | The `key_down_event` function is invoked with the *B* key as an argument.
    It stores the *B* key in the model. | The *B* key is read from the model. It is
    processed and reset. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `0.2` | 使用 *B* 键作为参数调用了 `key_down_event` 函数。它在模型中存储了 *B* 键。 | 从模型中读取 *B*
    键。它被处理并重置。 |'
- en: '| `0.3` | No input events. | No key info is stored in the model. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `0.3` | 没有输入事件。 | 模型中没有存储任何按键信息。 |'
- en: '| `0.4` | The `key_up_event` function is invoked with the *B* key as an argument.
    It does nothing. | No key info is stored in the model. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `0.4` | 使用 *B* 键作为参数调用了 `key_up_event` 函数。它没有做任何事情。 | 模型中没有存储任何按键信息。 |'
- en: '| `0.5` | No input events. | No key info is stored in the model. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `0.5` | 没有输入事件。 | 模型中没有存储任何按键信息。 |'
- en: Notice that for `quicksilver`, the *A* key has never been pressed, while the
    *B* key has been pressed twice. This can be good for continuous events, such as
    using a joystick, but not for discrete events, such as clicking a command button
    or typing text into a textbox.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到对于 `quicksilver`，*A* 键从未被按下，而 *B* 键被按下了两次。这对于连续事件，如使用摇杆，可能是有益的，但不适用于离散事件，如点击命令按钮或向文本框中输入文本。
- en: However, `quicksilver` has the advantage of capturing all simultaneous events.
    For example, `quicksilver` can easily handle a chord, which is when several keys
    are continually pressed at the same time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`quicksilver` 有捕获所有同时发生事件的优点。例如，`quicksilver` 可以轻松处理和弦，即当几个键同时连续按下时。
- en: Instead, for `ggez`, as long as only one key is pressed in a time frame, all
    key presses are handled the appropriate number of times. This is expected for
    buttons and textboxes; however, chords are not handled correctly. The only key
    combinations handled by `ggez` are those involving the *Shift*, *Ctrl*, and *Alt* special
    keys.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，对于 `ggez`，只要在某个时间段内只按下一个键，所有按键都会被适当次数地处理。这对于按钮和文本框来说是预期的；然而，和弦没有被正确处理。`ggez`
    处理的唯一键组合是涉及 *Shift*、*Ctrl* 和 *Alt* 特殊键的组合。
- en: Input handling in the gg_ski project
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gg_ski 项目的输入处理
- en: Among the many events that can be captured by a `ggez` application, the `gg_ski`
    game captures only two events—the press of the right or left arrow keys and their
    release. The handling of these events stores the relevant input information in
    the model so that the `update` function can use it. Therefore, the model must
    contain some additional fields, with respect to those contained for the `quicksilver`
    `ski` project.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ggez` 应用程序可以捕获的许多事件中，`gg_ski` 游戏只捕获了两个事件——右箭头键或左箭头键的按下和释放。处理这些事件会将相关的输入信息存储在模型中，以便
    `update` 函数可以使用它。因此，模型必须包含一些额外的字段，与 `quicksilver` `ski` 项目中包含的字段相比。
- en: 'So, we now have a model that contains some fields updated by the event functions,
    to be used by the `update` function, and some other fields updated by the `update`
    function, to be used by the `draw` function. To distinguish these input fields,
    it''s better to encapsulate them in a structure defined as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个模型，其中包含一些由事件函数更新的字段，供`update`函数使用，以及一些由`update`函数更新的其他字段，供`draw`函数使用。为了区分这些输入字段，最好将它们封装在以下定义的结构中：
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `to_turn` field indicates that the user has pressed an arrow key to change
    the direction of the ski. If only the left key is pressed, the direction angle
    should be decremented, and so the value of this field should be `-1.0`. If only
    the right key is pressed, the direction angle should be incremented, and so the
    value of this field should be `1.0`. If the user has not pressed any arrow key,
    the direction should remain unchanged, and so the value of this field should be
    `0.0`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_turn`字段表示用户按下了箭头键以改变滑雪的方向。如果只按下了左键，方向角度应该递减，因此此字段的值应该是`-1.0`。如果只按下了右键，方向角度应该递增，因此此字段的值应该是`1.0`。如果用户没有按下任何箭头键，方向应该保持不变，因此此字段的值应该是`0.0`。'
- en: 'The `started` field indicates that the race has started. It is not used in
    this project. An instance of this structure is added to the model using the following
    line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`started`字段表示比赛已经开始。在这个项目中没有使用它。使用以下行将此结构的一个实例添加到模型中：'
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The capture of key presses is done through the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 键按下的捕获是通过以下代码完成的：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `keycode` argument specifies which key has been pressed. If the left or
    the right arrow keys have been pressed, the `to_turn` field is set to `-1.0` or
    to `+1.0`, respectively. Any other keys that are pressed are ignored.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`keycode`参数指定了哪个键被按下。如果左键或右键被按下，`to_turn`字段被设置为`-1.0`或`+1.0`，分别。任何其他被按下的键都被忽略。'
- en: 'Capturing the release of the keys is done through the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下代码捕获键的释放：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the left or the right arrow keys are released, the `to_turn` field is set
    to `0.0` to stop the change of direction. The release of any other key is ignored.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左键或右键被释放，`to_turn`字段被设置为`0.0`以停止方向的变化。任何其他键的释放都被忽略。
- en: Other differences with quicksilver
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与quicksilver的其他差异
- en: Between `quicksilver` and `ggez`, in addition to the described conceptual differences,
    there are some minor differences, which I have covered in the following subsections.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quicksilver`和`ggez`之间，除了描述的概念差异之外，还有一些细微的差异，这些差异我在以下小节中进行了说明。
- en: Name of the trait
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特质名称
- en: 'The name of the trait to be implemented by the model is `State` for `quicksilver`
    and `EventHandler` for `ggez`. So, for `quicksilver` we had the following line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 模型需要实现的特质名称对于`quicksilver`是`State`，对于`ggez`是`EventHandler`。因此，对于`quicksilver`，我们有以下行：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But in `ggez`, we have the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但在`ggez`中，我们有以下：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The type of context
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文类型
- en: Using both `quicksilver` and `ggez`, you need to implement the `update` method
    and the `draw` method. Both of these methods receive an argument for both frameworks that
    describes the input/output context. This context is the object used to receive
    interactive input (by the `update` method) and to emit graphical output (by the `draw` method).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quicksilver`和`ggez`，你需要实现`update`方法和`draw`方法。这两个方法都接收一个参数，用于描述两个框架的输入/输出上下文。这个上下文是用于接收交互输入（通过`update`方法）和发出图形输出（通过`draw`方法）的对象。
- en: 'However, for `quicksilver` the type of this context argument is `Window`, as
    in the following function signatures:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于`quicksilver`，此上下文参数的类型是`Window`，如下所示：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For `ggez`, it is `Context`. So, now we have the following signatures:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ggez`，它是`Context`。因此，我们现在有以下签名：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The new method
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新方法
- en: The `State` trait of `quicksilver` requires the implementation of the `new`
    method, used by the framework to create the model instance. The `EventHandler`
    trait of `ggez` has no such method because the model instance is created explicitly
    by application code in the `main` function, as we have seen.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`quicksilver`的`State`特质需要实现`new`方法，这是框架用来创建模型实例的方法。`ggez`的`EventHandler`特质没有这样的方法，因为模型实例是在`main`函数中的应用代码中显式创建的，正如我们所看到的。'
- en: The angle's unit of measurement
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角度测量的单位
- en: 'While `quicksilver` rotation angles must be specified in degrees, `ggez` rotation
    angles must be specified in radians, and so angular constants and variables are
    specified in these units of measurement. So, now we have the following lines:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`quicksilver`旋转角度必须以度为单位指定，而`ggez`旋转角度必须以弧度为单位指定，因此角度常量和变量以这些测量单位指定。因此，我们现在有以下几行：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to specify the FPS rate
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何指定FPS速率
- en: 'To specify the desired **Frames Per Second** (**FPS**) rate, two parameters
    are specified in the `main` function when using `quicksilver`, whereas `ggez`
    uses another technique. For `ggez`, the `update` function is always invoked 60
    times per second (if possible), but the application code can simulate a different
    rate by writing the following body of the `update` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定所需的**每秒帧数**（**FPS**）速率，在`quicksilver`中使用时，`main`函数中指定了两个参数，而`ggez`使用另一种技术。对于`ggez`，`update`函数每秒总是调用60次（如果可能的话），但应用程序代码可以通过编写以下`update`函数的主体来模拟不同的速率：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The purpose of this code is to ensure that the body of the `while` loop is executed
    with the specified rate, which in this case is `25` frames per second. Let's see
    how this is accomplished.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的目的是确保`while`循环的主体以指定的速率执行，在这种情况下是每秒`25`帧。让我们看看这是如何实现的。
- en: The required rate specified in our code means that the body should be executed
    once every *1000 / 25 = 40 *milliseconds. When the `update` function is executed,
    if less than 40 milliseconds have elapsed since the preceding execution, the `check_update_time`
    function returns `false`, and so the body of the `while` loop is not executed
    this time. It is likely that even at the next `update` call, not enough time will
    have elapsed, and so the `check_update_time` function will return `false` again.
    In a later execution, when at least 40 milliseconds have elapsed since the last
    time the body was executed, `true` will be returned, and so the body will be executed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中指定的所需速率意味着主体应该每`1000 / 25 = 40`毫秒执行一次。当`update`函数执行时，如果自上次执行以来少于40毫秒已经过去，`check_update_time`函数将返回`false`，因此这次不会执行`while`循环的主体。很可能在下一个`update`调用时，时间仍然不足以满足要求，因此`check_update_time`函数将再次返回`false`。在随后的执行中，当自上次主体执行以来至少过去了40毫秒时，将返回`true`，因此主体将被执行。
- en: This allows a rate that is lower than 60 FPS. However, there is another feature.
    If a frame, for some reason, takes longer than the allotted time—say, 130 milliseconds—causing
    the animation to stutter, then the `check_update_time` function returns `true`
    several times in a row to make up for the lost time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许速率低于60 FPS。然而，还有一个特性。如果由于某种原因，一帧比分配的时间长——比如说，130毫秒——导致动画卡顿，那么`check_update_time`函数将连续多次返回`true`来弥补失去的时间。
- en: Of course, you cannot obtain the desired rate if every frame is so slow to take
    too much time. Tough, as long as your frames are processed within the required
    time, this technique ensures that the average frame rate will be the specified
    one.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果每一帧都太慢以至于花费太多时间，你将无法获得所需的速率。尽管如此，只要你的帧在所需的时间内处理完毕，这种技术就能确保平均帧率将是指定的速率。
- en: To say that the actual average rate approximates the desired rate, it is enough
    that the average time taken by a frame is less than the one allotted for a frame.
    Instead, if your frames take, on average, 100 milliseconds, the actual frame rate
    will be 10 FPS.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要说实际平均速率接近所需速率，只要一帧的平均时间小于分配给帧的时间就足够了。相反，如果你的帧平均需要100毫秒，实际的帧率将是10 FPS。
- en: Handling the ski steering
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理滑雪转向
- en: 'The ski steering is handled differently in the body of the `update` loop. In
    the `ski` project, the `steer` function is only called if an arrow key is kept
    pressed down at that time. Instead, in the `gg_sky` project, the following statement
    is always executed:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`循环的主体中，滑雪转向的处理方式不同。在`ski`项目中，只有在该时刻按下箭头键时才会调用`steer`函数。相反，在`gg_sky`项目中，以下语句总是被执行：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `steer` function is called at any time frame, passing the value set before
    by the input handling methods. If this value is `0`, the ski doesn't steer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`steer`函数在任何时间帧中都会被调用，传递之前通过输入处理方法设置的值。如果这个值是`0`，滑雪板不会转向。'
- en: Computation of new position and speed
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新位置和速度的计算
- en: 'In addition, the body of the `update` function now contains the following statements:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`update`函数的主体现在包含以下语句：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Their purpose is to compute the correct kinematics of the ski. In mechanics,
    to compute a position variation (![](img/f8bdcdfb-b580-4d95-b963-a6c1da93a2fb.png)),
    you have to multiply the current speed (also called **velocity**, *v*) by the
    time elapsed since the previous frame (![](img/2de95eed-7834-4bac-8d45-52416eaf488e.png)).
    This results in the following equation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的目的是计算滑雪的正确运动学。在力学中，为了计算位置变化（![](img/f8bdcdfb-b580-4d95-b963-a6c1da93a2fb.png)），你必须将当前速度（也称为**速度**，*v*）乘以前一帧以来经过的时间（![](img/2de95eed-7834-4bac-8d45-52416eaf488e.png)）。这导致以下方程：
- en: '![](img/94c8e1ad-c647-489c-b25f-26a56f31c4be.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94c8e1ad-c647-489c-b25f-26a56f31c4be.png)'
- en: 'To compute a speed variation (![](img/a5bc6524-13ce-4da6-9434-20778f84594a.png)),
    you have to multiply the current acceleration (*a*) by the time elapsed since
    the preceding frame (![](img/8d645a85-0f7a-4d27-8179-8d85a46c24b6.png)), which results
    in the following equation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算速度变化（![](img/a5bc6524-13ce-4da6-9434-20778f84594a.png)），你必须将当前加速度（*a*）乘以自前一帧以来经过的时间（![](img/8d645a85-0f7a-4d27-8179-8d85a46c24b6.png)），这导致以下方程：
- en: '![](img/fc23c985-1aaf-4a48-8e24-ddc75239e617.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc23c985-1aaf-4a48-8e24-ddc75239e617.png)'
- en: So, to compute the position variation and the speed variation, we need the time
    elapsed since the preceding frame. The `ggez` framework provides the `timer::time_since_start`
    function, which returns the duration since the start of the application. We subtract the
    time of the preceding frame from the duration to obtain the time elapsed between
    the two frames. The duration is then converted into seconds. Finally, the current
    time is saved, to be used in the next frame computation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了计算位置变化和速度变化，我们需要知道自前一帧以来经过的时间。`ggez` 框架提供了 `timer::time_since_start` 函数，该函数返回自应用程序开始以来的持续时间。我们从前一帧的时间中减去持续时间，以获得两个帧之间的时间差。然后，将持续时间转换为秒。最后，保存当前时间，以便在下一帧的计算中使用。
- en: Drawing the background
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制背景
- en: 'The MVC view implemented by the `draw` method draws the white background by
    using the following statement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `draw` 方法实现的 MVC 视图使用以下语句绘制白色背景：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's check how to draw the composite shapes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何绘制组合形状。
- en: Drawing composite shapes
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制组合形状
- en: 'To draw a composite shape, instead of individually drawing all of its components,
    first create a `Mesh` object, which is a composite shape containing all the component
    shapes, and then draw the `Mesh` object. To create a `Mesh` object, the `MeshBuilder`
    class is used with this code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个组合形状，而不是单独绘制所有组件，首先创建一个 `Mesh` 对象，它是一个包含所有组件形状的组合形状，然后绘制 `Mesh` 对象。要创建
    `Mesh` 对象，使用以下代码使用 `MeshBuilder` 类：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s now check what this code does:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码做了什么：
- en: First, the `new` function creates a `MeshBuilder` object.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`new` 函数创建一个 `MeshBuilder` 对象。
- en: Then, the methods instruct these mesh builders how to create the mesh components. The `rectangle`
    method explains how to create a rectangle, which will be the ski body, and the `polygon` method
    explains how to create a polygon, which will be the ski tip. The features of the
    rectangle are its draw mode (`DrawMode::fill()`), its position and size (`x`,
    `y`, `w`, and `h`), and its color (`1., 0., 1., 1.`). The features of the polygon
    are its draw mode, the list of its vertices, and its color. It has just three
    vertices, so it is a triangle.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，这些方法指导这些网格构建器如何创建网格组件。`rectangle` 方法解释了如何创建一个矩形，它将成为滑雪板体，`polygon` 方法解释了如何创建一个多边形，它将成为滑雪板尖。矩形的特点是其绘制模式（`DrawMode::fill()`）、其位置和大小（`x`、`y`、`w`
    和 `h`）以及其颜色（`1., 0., 1., 1.`）。多边形的特点是其绘制模式、其顶点列表和其颜色。它只有三个顶点，所以它是一个三角形。
- en: Then, the `build` method creates and returns the specified mesh. Notice that
    the method calls ending with a question mark are fallible and that the colors
    are specified by the quadruple red-green-blue-alpha model, where each number is
    in the range `0` to `1`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`build` 方法创建并返回指定的网格。请注意，以问号结尾的方法调用是可能失败的，并且颜色由红绿蓝alpha四元组指定，其中每个数字的范围是 `0`
    到 `1`。
- en: 'To draw a mesh, the following statement is used:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个网格，使用以下语句：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This `draw` method is not the same as the `draw` method that defines the view
    of the MVC architecture. This is found in the `ggez::graphics` module, while the
    containing method (the view) is part of the `ggez::event::EventHandler` trait.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `draw` 方法与定义 MVC 架构视图的 `draw` 方法不同。这可以在 `ggez::graphics` 模块中找到，而包含的方法（视图）是
    `ggez::event::EventHandler` 特性的一个部分。
- en: 'The first argument of the `graphics::draw` method—`ctx`—is the context on which
    we are drawing. The second argument—`&ski`—is the mesh we are drawing. The third
    argument is a collection of parameters, encapsulated in a `DrawParam` object.
    This type allows us to specify numerous parameters, two of which are specified
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`graphics::draw`方法的第一个参数——`ctx`——是我们绘制上下文。第二个参数——`&ski`——是我们绘制的网格。第三个参数是一组参数，封装在`DrawParam`对象中。这种类型允许我们指定许多参数，其中两个如下所述：'
- en: The point to draw the mesh, specified using the `dest` method
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dest`方法指定的绘制网格的点
- en: The angle (in radians) by which the mesh must be rotated, specified using the
    `rotation` method
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格必须旋转的角度（以弧度为单位），使用`rotation`方法指定
- en: So, we have now seen how to draw on the screen. However, after calling these
    statements, nothing actually appears on the screen because the statements just
    prepare the output off-screen. To get the output, a finalization statement is
    needed, which is described in the next section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经看到了如何在屏幕上绘制。然而，在调用这些语句之后，实际上并没有任何东西出现在屏幕上，因为这些语句只是为离屏输出做了准备。要获取输出，需要一个最终化语句，这将在下一节中描述。
- en: Ending the draw method
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结束绘制方法
- en: 'The view (that is, the `draw` method) should end with the following statements:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 视图（即`draw`方法）应以以下语句结束：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the typical double-buffering technique used by OpenGL, all the `ggez` drawing
    operations do not output graphics directly on the screen but in a hidden buffer.
    The `present` function quickly swaps the shown screen buffer with the hidden drawn
    buffer, with the effect of immediately displaying the scene and avoiding the flicker
    that could appear otherwise. The last statement tells the operating system to
    stop using the CPU for this process until the next frame must be drawn. By doing
    this, if the processing of a frame is quicker than a time frame, the application
    avoids using 100% of the CPU cycles.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL使用的典型双缓冲技术中，所有的`ggez`绘图操作不是直接输出到屏幕上，而是在一个隐藏的缓冲区中。`present`函数快速交换显示的屏幕缓冲区与隐藏的绘制缓冲区，从而立即显示场景，避免出现可能出现的闪烁。最后一条语句告诉操作系统停止使用CPU进行此过程，直到必须绘制下一帧。通过这样做，如果帧的处理速度比时间帧快，应用程序可以避免使用100%的CPU周期。
- en: So, we have finished examining the `gg_ski` project. In the next section, we
    will examine how the `gg_silent_slalom` project builds on this project to create
    a slalom game with no sound or text.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了对`gg_ski`项目的考察。在下一节中，我们将考察`gg_silent_slalom`项目是如何在此基础上构建的，以创建一个没有声音或文本的滑雪游戏。
- en: Implementing the gg_silent_slalom project
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`gg_silent_slalom`项目
- en: In this section, we will examine the `gg_silent_slalom` project, which is an
    implementation of the `ggez` framework of the `gg_silent_slalom` game presented
    in the preceding chapter. Here, we will only examine the differences between the
    `gg_ski` project and the `silent_slalom` project.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考察`gg_silent_slalom`项目，这是前一章节中提出的`gg_silent_slalom`游戏的`ggez`框架的实现。在这里，我们只考察`gg_ski`项目和`silent_slalom`项目之间的差异。
- en: 'As we saw in the preceding section, `ggez` handles input as events. In this
    project, two other key events are handled—`Space` and `R`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中看到的，`ggez`将输入作为事件处理。在这个项目中，还处理了两个其他的关键事件——`Space`和`R`：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The spacebar is used to command the start of the race, and so it sets the `started` flag to
    `true`. The *R* key is used to reposition the ski at the beginning of the slope,
    and so it sets the `started` flag to `false`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 空格键用于命令比赛的开始，因此它将`started`标志设置为`true`。*R*键用于将滑雪板重新定位在斜坡的起点，因此它将`started`标志设置为`false`。
- en: 'This flag is then used in the `update` method, as in the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志随后在`update`方法中使用，如下代码所示：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When in `Ready` mode, instead of directly checking the keyboard state, the
    `started` flag is checked. The computation of speed and acceleration takes into
    account the time that has actually elapsed since the preceding frame computation:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当处于`Ready`模式时，不是直接检查键盘状态，而是检查`started`标志。速度和加速度的计算考虑了自前一帧计算以来实际经过的时间：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To compute the new forward speed, the acceleration along the slope (`ALONG_ACCELERATION`)
    is projected on the ski direction using the cosine function (`self.direction.cos()`),
    and then the result is multiplied by the elapsed time (`self.period_in_sec`) to
    get the speed increment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算新的前进速度，沿着斜坡的加速度（`ALONG_ACCELERATION`）通过余弦函数（`self.direction.cos()`）投影到滑雪板方向，然后将结果乘以经过的时间（`self.period_in_sec`）以获得速度增量。
- en: The incremented speed is then multiplied by a factor that is less than `1` to
    take friction into account. This factor is the `DRAG_FACTOR` constant for a time
    of 1 second. To get the decrease factor for the actual time elapsed, the exponential
    function must be used (`powf`).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将增加的速度乘以一个小于`1`的系数，以考虑摩擦。这个系数是1秒钟的`DRAG_FACTOR`常量。为了得到实际经过时间的减少系数，必须使用指数函数（`powf`）。
- en: 'To compute the new horizontal position of the ski tip, the following statement
    is executed:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算滑雪尖头的新水平位置，执行以下语句：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This multiplies the speed (`self.forward_speed`) by the time elapsed (`self.period_in_sec`)
    to obtain the space increment. This increment is projected on the horizontal direction
    using the sine function (`self.direction.sin()`) to get the horizontal position
    variation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将速度（`self.forward_speed`）乘以经过的时间（`self.period_in_sec`），以获得空间增量。这个增量通过正弦函数（`self.direction.sin()`）投影到水平方向，以获得水平位置的变化。
- en: A similar computation is performed to compute the movement along the slope,
    which is actually the offset of the position of the gates as the ski is always drawn
    at the same *Y* coordinate.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算沿斜面的移动，执行类似的计算，这实际上是滑雪板位置偏移，因为滑雪板总是绘制在相同的*Y*坐标上。
- en: 'To draw the poles of the gates in the `draw` method, first, two meshes are
    created by using the following statements:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`方法中绘制标杆，首先，使用以下语句创建两个网格：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the meshes are created directly without using a `MeshBuilder` object.
    The `new_circle` method requires the context, the fill mode, the center, the radius,
    a tolerance, and the color as parameters. Tolerance is a trade-off between performance
    and graphic quality. The former mesh is used to draw all the poles, except those
    of the finish gate, and the latter mesh is used to draw the poles of the finish
    gate.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，网格是直接创建的，没有使用`MeshBuilder`对象。`new_circle`方法需要上下文、填充模式、中心、半径、容差和颜色作为参数。容差是在性能和图形质量之间的权衡。前一个网格用于绘制所有标杆，除了终点标杆，后一个网格用于绘制终点标杆的标杆。
- en: 'Then, these meshes are drawn to show all the poles using statements such as
    the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用如下语句等绘制这些网格，以显示所有标杆：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, the third argument (with the `DrawParam` type) is specified in a simple
    but somewhat obscure way; it is a tuple containing just one element. This element
    is interpreted as the position where the mesh will be drawn, corresponding to
    the `dest` method call seen in the preceding section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第三个参数（具有`DrawParam`类型）以一种简单但有些晦涩的方式指定；它是一个只包含一个元素的元组。这个元素被解释为网格将被绘制的位置，对应于前一个章节中看到的`dest`方法调用。
- en: So, we have now also seen the peculiarities of the `gg_silent_slalom` project.
    In the next section, we will look at the `gg_assets_slalom` project, which adds
    sound and text to our project.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在也已经看到了`gg_silent_slalom`项目的特殊性。在下一节中，我们将查看添加了声音和文本的`gg_assets_slalom`项目。
- en: Implementing the gg_assets_slalom project
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`gg_assets_slalom`项目
- en: In this chapter, we will examine the `gg_assets_slalom` project, which is an
    implementation of the `ggez` framework of the `assets_slalom` game presented in
    the preceding chapter. Here, we will only examine the differences between the
    `gg_silent_slalom` project and the `assets_slalom` project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查`gg_assets_slalom`项目，这是前一章中介绍的`assets_slalom`游戏`ggez`框架的实现。在这里，我们只检查`gg_silent_slalom`项目和`assets_slalom`项目之间的差异。
- en: 'The main difference is found in how the assets are loaded. The assets of these
    projects are of two kinds—fonts and sounds. To encapsulate these assets, instead
    of using objects with the `Asset<Font>` and `Asset<Sound>` types, `ggez` uses
    objects with the `graphics::Font` and `audio::Source` types, respectively. These
    assets are loaded into the constructor of the model. For example, the constructor
    of the `Screen` object contains the following statements:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于资产加载的方式。这些项目的资产分为两种——字体和声音。为了封装这些资产，`ggez`不是使用具有`Asset<Font>`和`Asset<Sound>`类型的对象，而是分别使用具有`graphics::Font`和`audio::Source`类型的对象。这些资产被加载到模型的构造函数中。例如，`Screen`对象的构造函数包含以下语句：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first one loads a file containing a `TrueType` font for the `ctx` context and
    returns an object encapsulating this font. The second one loads (for the `ctx`
    context) a file containing an OGG sound and returns an object encapsulating this
    sound. Both files must be present in the `asset` folder that was specified in
    the `main` function using the `add_resource_path` method, and they must be in
    one of the supported formats.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句加载一个包含`TrueType`字体的文件用于`ctx`上下文，并返回一个封装了这个字体的对象。第二个语句（对于`ctx`上下文）加载一个包含OGG声音的文件，并返回一个封装了这个声音的对象。这两个文件必须存在于`main`函数中通过`add_resource_path`方法指定的`asset`文件夹中，并且它们必须是支持的格式之一。
- en: There is an important difference in how `quicksilver` and `ggez` load their
    assets. `q``uicksilver` loads them asynchronously, creating future objects whose
    access function must ensure that the asset is loaded. On the other hand, `ggez`
    is synchronous; when it loads the assets, it blocks the application until the
    assets are completely loaded. The objects created are not future objects, and
    so they can be used immediately.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`quicksilver`和`ggez`在加载资源方面有一个重要的区别。`quicksilver`异步加载它们，创建需要确保资源已加载的`future`对象。另一方面，`ggez`是同步的；当它加载资源时，它会阻塞应用程序直到资源完全加载。创建的对象不是`future`对象，因此可以立即使用。'
- en: Because it uses future objects, `quicksilver` is more sophisticated, but this sophistication
    is probably useless on a desktop application because, provided your application
    has no more than a few megabytes of assets, loading them from local storage is
    quite fast, and so some blocking statements at application startup are not going
    to be inconvenient. Of course, to prevent slowing down animations, the assets
    must be loaded only at application startup, when changing the level of a game,
    or when the game is ending. Once an asset is loaded, it is immediately available.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它使用`future`对象，`quicksilver`更为复杂，但这种复杂性在桌面应用程序中可能没有太大用处，因为如果你的应用程序的资源不超过几兆字节，从本地存储加载它们相当快，因此应用程序启动时的某些阻塞语句不会造成不便。当然，为了防止动画减速，资源必须在应用程序启动时、更改游戏级别或游戏结束时加载。一旦资源被加载，它就立即可用。
- en: 'The easiest asset to use is sound. To play a sound, the following function
    is defined:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易使用的资源是声音。要播放声音，定义以下函数：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Its first argument is the `sound` asset and the second argument is the desired
    `volume` level. This function simply sets the volume and then plays the sound
    using the `play_detached` method. This method overlaps the new sound with any
    other sounds that are already playing. There is also a `play` method, which automatically
    stops playing the old sounds before starting the new one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 其第一个参数是`sound`资源，第二个参数是期望的`volume`级别。这个函数只是设置音量，然后使用`play_detached`方法播放声音。这个方法将新声音与任何其他正在播放的声音重叠。还有一个`play`方法，它在开始播放新声音之前会自动停止播放旧的声音。
- en: 'To play a fixed-volume sound, such as one that signals the failure to enter
    a gate, the following statement is used:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放固定音量的声音，例如表示无法进入门的声音，可以使用以下语句：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In addition, to make a sound proportional to the speed, the following statement
    is used:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使声音与速度成比例，可以使用以下语句：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The font is quite easy to use, too:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 字体也非常容易使用：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first statement creates a text shape by calling the `new` function. It
    has a tuple with three fields as an argument:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句通过调用`new`函数创建一个文本形状。它有一个包含三个字段的元组作为参数：
- en: The string to print (`elapsed_shown_text`)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要打印的字符串（`elapsed_shown_text`）
- en: The scalable font object to use for this text (`self.font`)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于此文本的可伸缩字体对象（`self.font`）
- en: The desired size of the generated text (`16.0`)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文本的期望大小（`16.0`）
- en: The second statement draws the created text shape on the `ctx` context. This
    statement specifies a tuple that will be converted to a `DrawParam` value as a
    third parameter. The specified sub-arguments are the destination point (`Point2::new(4.0,
    4.0)`) and the color to use (`graphics::BLACK`).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个语句在`ctx`上下文中绘制创建的文本形状。这个语句指定了一个元组，它将被转换为`DrawParam`值的第三个参数。指定的子参数是目标点（`Point2::new(4.0,
    4.0)`）和要使用的颜色（`graphics::BLACK`）。
- en: So, we have now covered the whole game. In the next section, we will look at
    another game, which uses mouse clicks and other kinds of assets—images.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经涵盖了整个游戏。在下一节中，我们将查看另一个游戏，它使用鼠标点击和其他类型的资源——图像。
- en: Implementing the gg_whac project
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现gg_whac项目
- en: In this section, we will examine the `gg_whac` project, which is an implementation
    in the `ggez` framework of the famous **Whack-A-Mole **arcade game. First of all,
    let's try to play it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查`gg_whac`项目，这是在`ggez`框架中实现著名的**打地鼠**街机游戏的一个实现。首先，让我们尝试玩一玩。
- en: 'After running `cargo run --release` in the `gg_whac` folder, the following
    window will appear, which shows a lawn:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gg_whac`文件夹中运行`cargo run --release`后，会出现以下窗口，显示一片草地：
- en: '![](img/eb92e5c9-1f75-4275-bb78-e3dc6baa4d3e.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb92e5c9-1f75-4275-bb78-e3dc6baa4d3e.png)'
- en: 'For those of you who aren''t familiar with this game, here are the rules. When
    you click on the Start button, the following things happen:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉这款游戏的人来说，以下是一些规则。当你点击开始按钮时，以下事情会发生：
- en: The Start button disappears.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始按钮消失。
- en: The countdown begins at the top left from 40 seconds to 0.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 倒计时从左上角的40秒开始，到0结束。
- en: A nice mole pops up in a random position of the lawn.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一只可爱的小鼹鼠随机出现在草地上。
- en: The mouse cursor becomes a barred circle.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鼠标光标变成一个禁止符号。
- en: If you move your mouse cursor over the mole, it becomes a cross and a big mallet
    appears; this mallet can be dragged by the mouse as long as you remain over the
    mole.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将鼠标光标移至鼹鼠身上，它就会变成一个十字形，并出现一个大锤；只要你的鼠标光标保持在鼹鼠上方，你就可以用鼠标拖动这个大锤。
- en: 'Your window should look similar to the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你的窗口应该看起来类似于以下：
- en: '![](img/b971420a-927d-4040-aedf-18b8cfe6d402.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b971420a-927d-4040-aedf-18b8cfe6d402.png)'
- en: If you click the main mouse button when the mouse cursor hovers over the mole,
    the mole disappears and another one appears in another position. In the meantime,
    a counter tells you how many moles you have managed to whack. When the countdown
    reaches 0, you are presented with your score.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击鼠标主按钮，当鼠标光标悬停在鼹鼠上方时，鼹鼠就会消失，并在另一个位置出现另一个鼹鼠。同时，一个计数器会告诉你你成功击打了多少只鼹鼠。当倒计时达到0时，你会看到你的得分。
- en: The assets
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产
- en: 'To understand the behavior of this application, first, let''s look at the content
    of the `assets` folder:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这个应用程序的行为，首先，让我们看看`assets`文件夹的内容：
- en: '`cry.ogg` is the sound produced by the mole when it pops up out of the lawn.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cry.ogg`是鼹鼠从草地上跳出来时产生的声音。'
- en: '`click.ogg` is the sound of the mallet when it hits the mole.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click.ogg`是锤子击中鼹鼠时的声音。'
- en: '`bump.ogg` is the sound of the mallet when it hits the lawn but misses the
    mole.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bump.ogg`是锤子击中草地但未击中鼹鼠时的声音。'
- en: '`two_notes.ogg` is the jingle produced when the game ends because the countdown
    has elapsed.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`two_notes.ogg`是游戏结束时由于倒计时结束而产生的铃声。'
- en: '`font.ttf` is the font used for all the visible text.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font.ttf`是所有可见文本使用的字体。'
- en: '`mole.png` is the image of the moles.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mole.png`是鼹鼠的图片。'
- en: '`mallet.png` is the image of the mallet.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mallet.png`是锤子的图片。'
- en: '`lawn.jpg` is the image used to fill the background.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lawn.jpg`是用于填充背景的图片。'
- en: '`button.png` is the image used for the Start button.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`button.png`是用于开始按钮的图片。'
- en: 'We already saw, in the preceding section, how to load and use sounds and fonts.
    Here, there is a new kind of asset—images. Images are declared by statements such
    as the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面一节中已经看到了如何加载和使用声音和字体。这里，有一种新的资产类型——图片。图片通过以下之类的语句声明：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'They are loaded, at application initialization time, by statements such as
    the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在应用程序初始化时通过以下之类的语句被加载：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'They are displayed by statements such as the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通过以下之类的语句显示：
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the `lawn_params` argument, with a type of `DrawParam`, can specify a
    position, a scale, a rotation, and even a crop.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`lawn_params`参数，其类型为`DrawParam`，可以指定一个位置、一个缩放、一个旋转，甚至一个裁剪。
- en: The general structure of the application and events
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序的一般结构和事件
- en: 'Now, let''s examine the structure of the source code. Like the preceding projects
    we have seen in this chapter, this project does the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查源代码的结构。就像我们在本章前面看到的先前的项目一样，这个项目做了以下几件事：
- en: Defines some constants
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一些常量
- en: Defines a model with the `struct Screen` type
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个`struct Screen`类型的模型
- en: Implements the `EventHandler` trait with its required `update` and `draw` methods and
    its optional `mouse_button_down_event` and `mouse_button_up_event` methods
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了`EventHandler`特质及其所需的`update`和`draw`方法，以及可选的`mouse_button_down_event`和`mouse_button_up_event`方法
- en: Defines the `main` function
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了`main`函数
- en: 'The most important field of the model is `mode`, whose type is defined by the
    following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 模型最重要的字段是`mode`，其类型由以下代码定义：
- en: '[PRE33]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The initial mode is `Ready`, where the countdown is stopped and the game is
    ready to start. When the game is running, there are the following states:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 初始模式是 `Ready`，其中倒计时停止，游戏准备开始。当游戏进行时，有以下状态：
- en: No mole appears.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有鼹鼠出现。
- en: One mole rises from the ground.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一只鼹鼠从地面升起。
- en: One mole rises and waits to be hit.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一只鼹鼠升起并等待被击中。
- en: A blow of the mallet is about to hit the mole.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼓槌即将击中鼹鼠。
- en: The mole that has been hit lowers into the ground.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被击中的鼹鼠会降入地面。
- en: Well, actually, the first state does not exists, because as soon as the game
    starts, a mole pops up, and also, as soon as you hit a mole, another mole pops
    up. The second and third states are represented by `Mode::Raising`. Simply put, when
    the mole reaches its full height, it is not raised.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，实际上，第一个状态不存在，因为游戏开始后，一只鼹鼠就会跳出来，而且，一旦你击中一只鼹鼠，另一只鼹鼠也会跳出来。第二和第三状态由 `Mode::Raising`
    表示。简单来说，当鼹鼠达到其最大高度时，它不会被提升。
- en: The fourth and fifth states are represented by `Mode::Lowering`. Simply put,
    the mole lowers simultaneously with the mallet.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第四和第五状态由 `Mode::Lowering` 表示。简单来说，鼹鼠和鼓槌同时下降。
- en: 'Regarding the input operations, it should be noted that for the `EventHandler`
    trait, no key handling methods are implemented as this game does not use the keyboard.
    Instead, it uses the mouse, and so there is the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 关于输入操作，应注意对于 `EventHandler` 特性，没有实现键处理方法，因为这款游戏不使用键盘。相反，它使用鼠标，因此有如下代码：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first method is invoked when a mouse button is pressed and the second one
    is invoked when a mouse button is released.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标按钮被按下时调用第一个方法，当鼠标按钮被释放时调用第二个方法。
- en: The third argument of these methods (`button`) is an enum indicating which button
    has been pressed; `MouseButton::Left` actually represents the main mouse button.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的第三个参数（`button`）是一个枚举，表示哪个按钮已被按下；`MouseButton::Left` 实际上代表主鼠标按钮。
- en: The fourth and fifth arguments of these methods (`x` and `y`) are the coordinates
    of the position of the mouse when its button has been pressed. Their unit of measurement
    is pixels and the origin of their coordinate system is the top-left vertex of
    the context, which in our case is the client area of the window.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的第四和第五个参数（`x` 和 `y`）是鼠标按钮被按下时鼠标位置的坐标。它们的单位是像素，其坐标系的起点是上下文的最左上角顶点，在我们的案例中是窗口的客户区域。
- en: Only the main mouse button is handled. When it is pressed, the point representing
    the current mouse position is stored in the `mouse_down_at` field of the model,
    and when it is released, it is stored in the `mouse_up_at` field of the model.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 只处理主鼠标按钮。当它被按下时，代表当前鼠标位置的点被存储在模型的 `mouse_down_at` 字段中，当它被释放时，它被存储在模型的 `mouse_up_at`
    字段中。
- en: 'These fields are defined in the model in the following way:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段在模型中以以下方式定义：
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Their value is initialized to `None` and is only set to a `Point2` value by
    the preceding code; it is reset to `None` as soon as these events are processed
    by the `update` method. So, each mouse event is only processed once.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的值初始化为 `None`，并且只有前述代码将其设置为 `Point2` 值；一旦这些事件被 `update` 方法处理，它就会重置为 `None`。因此，每个鼠标事件只处理一次。
- en: Other fields of the model
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型的其他字段
- en: 'In addition to the fields that we have already described, the model has the
    following other fields:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已描述的字段外，模型还有以下其他字段：
- en: '[PRE36]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `start_time` field is used to show the current remaining time during the
    game and to show the Game finished text when the game ends. It is initialized
    to `None`, and then any time the Start button is pressed, the current time is
    stored in it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_time` 字段用于显示游戏中的当前剩余时间，并在游戏结束时显示“游戏结束”文本。它初始化为 `None`，然后每次按下开始按钮时，当前时间都会存储在其中。'
- en: The moles do not appear in totally random positions. The lawn is covertly organized
    into three rows and five columns. A mole appears in 1 of these 15 positions, chosen
    at random. The `active_mole_column` and `active_mole_row` fields contain the zero-based
    column and the row of the currently displayed mole.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 鼹鼠不会出现在完全随机的位置。草坪被秘密地组织成三行五列。一只鼹鼠会出现在这15个位置中的1个，随机选择。`active_mole_column` 和
    `active_mole_row` 字段包含当前显示的鼹鼠的零基于列和行。
- en: The `active_mole_position` field contains the fraction of the appearance of
    the current mole. A `0` value means that the mole is totally hidden. A value of
    `1` means that the image of the mole (representing a part of its body) has completely
    appeared. The `n_hit_moles` field counts how many moles have been hit.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`active_mole_position` 字段包含当前蚂蚁出现的比例。`0` 值表示蚂蚁完全隐藏。`1` 值表示蚂蚁的图像（代表其身体的一部分）已经完全出现。`n_hit_moles`
    字段统计被击中的蚂蚁数量。'
- en: The `random_generator` field is a pseudo-random number generator used to generate
    the position of the next mole to show. Finally, `start_button` is a field representing
    the Start button. However, its type is not defined in a library. It is defined
    in this application, as we are going to explain.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_generator` 字段是一个伪随机数生成器，用于生成下一个要显示的蚂蚁的位置。最后，`start_button` 是表示开始按钮的字段。然而，它的类型在库中没有定义。它在这个应用程序中定义，正如我们将解释的那样。'
- en: Defining a widget
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个小部件
- en: Business applications have windows full of small, interactive graphical elements,
    such as buttons and textboxes. These elements are usually named **controls** by
    Microsoft Windows documentation and **widgets** (from window objects) in Unix-like
    environments. Defining widgets using graphics primitives is a rather complex feat,
    so if you want to develop a business application, you should probably use a library
    that defines a set of widgets.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 商业应用程序有满屏的小型、交互式图形元素，如按钮和文本框。这些元素通常由 Microsoft Windows 文档命名为 **控件**，在类 Unix
    环境中则称为 **小部件**（来自窗口对象）。使用图形原语定义小部件是一项相当复杂的任务，因此如果您想开发商业应用程序，您可能应该使用一个定义了一组小部件的库。
- en: Neither the Rust standard library nor the `ggez` framework defines widgets.
    However, if you need just a few very simple widgets, you can develop them yourself,
    such as the button we will develop for this project. Let's see how this is implemented.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 标准库和 `ggez` 框架都没有定义小部件。然而，如果您只需要一些非常简单的小部件，您可以自己开发它们，例如我们将为这个项目开发按钮。让我们看看这是如何实现的。
- en: 'First of all, there is a definition of the `Button` type that can be instantiated
    for any button you want to add to your window:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个 `Button` 类型的定义，可以实例化以添加到窗口中的任何按钮：
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our button is just an image resized as we want with text centered on it. This
    image is the same for all the buttons, and so it should be shared throughout the
    program to save memory. This is why the `base_image` field is a reference-counted
    pointer to an image.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的按钮只是一个按我们想要的尺寸调整过的图像，上面有居中的文本。这个图像对所有按钮都是相同的，因此应该在程序中共享以节省内存。这就是为什么 `base_image`
    字段是一个指向图像的引用计数指针。
- en: 'The `bounding_box` field indicates the desired position and size of the button.
    The image will be stretched or shrunk to fit this size. The `drawable_text` field
    is a text shape that will be drawn over the image of the button as its caption.
    The `Button` type implements several methods:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`bounding_box` 字段指示按钮的期望位置和大小。图像将被拉伸或缩小以适应此大小。`drawable_text` 字段是一个文本形状，它将在按钮图像上绘制作为其标题。`Button`
    类型实现了几个方法：'
- en: '`new` to create a new button'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `new` 创建一个新的按钮
- en: '`contains` to check whether a given point is inside the button'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `contains` 检查给定点是否在按钮内部
- en: '`draw` to display itself in the specified context'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `draw` 在指定上下文中显示自身
- en: 'The `new` method has many arguments:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 方法有许多参数：'
- en: '[PRE38]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `caption` argument is the text to display inside the button. The `center`
    argument is the desired position of the center of the button. The `font` and `base_image`
    arguments are the font and image to use.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`caption` 参数是显示在按钮内部的文本。`center` 参数是按钮中心的期望位置。`font` 和 `base_image` 参数是使用的字体和图像。'
- en: 'To create our button, the following expression is used:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的按钮，使用以下表达式：
- en: '[PRE39]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It specifies `"Start"` as the caption, a width of `600` pixels, and a height
    of `40` pixels.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 它指定了 `"Start"` 作为标题，宽度为 `600` 像素，高度为 `40` 像素。
- en: 'To draw the button, first, we check whether the main mouse button is currently
    pressed using this expression:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制按钮，首先，我们使用以下表达式检查主鼠标按钮是否当前被按下：
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By doing this, it is possible to make the button appear like it is being pressed
    to give visual feedback of the button''s operation. Then, we check whether the
    mouse cursor is inside the button using this expression:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，可以使按钮看起来像被按下，从而提供按钮操作的视觉反馈。然后，我们使用以下表达式检查鼠标光标是否在按钮内部：
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This turns the color of the button caption red when the mouse hovers over the
    button to show the user that the button can be clicked on. So, we have now looked
    at the most interesting parts of this project, which ends our look into the `ggez`
    framework.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标悬停在按钮上时，这会将按钮标题的颜色变为红色，以向用户显示按钮可以被点击。因此，我们现在已经看到了这个项目的最有趣的部分，这也结束了我们对`ggez`框架的探讨。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen how to build two-dimensional games for the desktop using the `ggez`
    framework. This framework not only allows us to structure the application according
    to the animation-loop architecture and the MVC architectural pattern but also
    to get discrete input events. In addition, we have seen why a linear algebra library
    can be useful for graphical applications.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`ggez`框架在桌面端构建二维游戏。这个框架不仅允许我们根据动画循环架构和MVC架构模式来结构化应用程序，还可以获取离散的输入事件。此外，我们还了解了为什么线性代数库对于图形应用程序来说可能很有用。
- en: We created and looked at four apps—`gg_ski`, `gg_silent_slalom`, `gg_assets_slalom`,
    and `gg_whac`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建并查看了一个应用程序——`gg_ski`、`gg_silent_slalom`、`gg_assets_slalom`和`gg_whac`。
- en: In particular, we learned how to build a graphical desktop app using the `ggez` framework,
    which is structured according to the MVC architecture, and how to implement both
    an animation-loop architecture and an event-driven architecture, possibly in the
    same window. Additionally, we also learned to draw graphical elements on a web
    page using `ggez`, as well as loading and using static resources using `ggez`.
    At the end of the chapter, we encapsulated two-dimensional points and vectors
    in a structure and saw how to manipulate them using the `nalgebra` library.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们学习了如何使用`ggez`框架构建一个图形桌面应用程序，该框架根据MVC架构进行结构化，以及如何实现动画循环架构和事件驱动架构，可能是在同一个窗口中。此外，我们还学习了如何使用`ggez`在网页上绘制图形元素，以及如何使用`ggez`加载和使用静态资源。在章节的结尾，我们将二维点和向量封装在结构中，并看到了如何使用`nalgebra`库来操作它们。
- en: 'In the next chapter, we will look at a completely different technology: parsing.
    Parsing text files is useful for many purposes, in particular for interpreting
    or compiling a source code program. We will take a look at the `nom` library,
    which makes parsing tasks easier.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一个完全不同的技术：解析。解析文本文件对于许多目的都很有用，特别是用于解释或编译源代码程序。我们将查看`nom`库，它使得解析任务变得更容易。
- en: Questions
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a vector and a point in linear algebra?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线性代数中向量和点之间的区别是什么？
- en: What are the geometrical concepts corresponding to algebraic vectors and points?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与代数向量和点相对应的几何概念是什么？
- en: Why can capturing events be useful, even in an animation loop-oriented application?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么即使在面向动画循环的应用程序中，捕获事件也可能很有用？
- en: Why can loading synchronous assets be a good idea in a desktop game?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在桌面游戏中加载同步资源可能是一个好主意？
- en: How does `ggez` get input from the keyboard and mouse?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ggez`是如何从键盘和鼠标获取输入的？'
- en: What are the meshes used in the `ggez` framework?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ggez`框架中使用了哪些网格？'
- en: How can you build a `ggez` mesh?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用`ggez`构建一个`ggez`网格？
- en: How do you obtain a desired animation frame rate using `ggez`?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用`ggez`获得期望的动画帧率？
- en: How do you draw a mesh in the desired position using `ggez`, with the desired
    scale and rotation values?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用`ggez`在期望的位置绘制网格，并使用期望的缩放和旋转值？
- en: How do you play sound using `ggez`?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用`ggez`播放声音？
- en: Further reading
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The `ggez` project can be downloaded from [https://github.com/ggez/ggez](https://github.com/ggez/ggez).
    This repository contains many example projects, including a complete asteroid
    arcade game.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从[https://github.com/ggez/ggez](https://github.com/ggez/ggez)下载`ggez`项目。这个仓库包含许多示例项目，包括一个完整的彗星街机游戏。
