- en: '*Chapter 4*: Managing Animations with State Machines'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：使用状态机管理动画'
- en: In the last chapter, we created a minimal game *engine*, allowing for moving
    our main character around and playing a simple animation, but it's far from full-featured.
    There's no world to navigate, the only animation that plays is running, and **Red
    Hat Boy** (**RHB**) doesn't respond to any physics. At this point, if we wanted
    to retitle our game, it would be called *Red Hat Boy and the Empty Void*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个最小化的游戏*引擎*，允许我们移动主要角色并播放简单的动画，但它远非功能齐全。没有可以导航的世界，唯一播放的动画是跑步，**红帽男孩**（**RHB**）对任何物理都不做出反应。在这个时候，如果我们想重新命名我们的游戏，它将被称为*红帽男孩和空旷的虚空*。
- en: While that might be a fun title, it wouldn't make for a fun game. Ultimately,
    we'll want RHB to chase his dog through a forest with platforms to jump on and
    slide under, and to do that we'll need to make sure he slides, jumps, and runs.
    We'll also need to make sure that he looks, acts, and behaves differently when
    he does those things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能是一个有趣的名字，但它不会让游戏变得有趣。最终，我们希望RHB在森林中追逐他的狗，那里有可以跳跃的平台和可以滑过的障碍，为了做到这一点，我们需要确保他可以滑动、跳跃和跑步。我们还需要确保他在做这些事情时看起来、表现和表现不同。
- en: In this chapter, we're going to introduce a common game development pattern
    to manage all that, the state machine, implemented in `if` statements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一种常见的游戏开发模式来管理所有这些，即状态机，通过`if`语句实现。
- en: 'We''re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Introducing state machines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍状态机
- en: Managing animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理动画
- en: Adding states to walk the dog
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为遛狗添加状态
- en: '`Idle`, `Running`, `Sliding`, and `Jumping` animations'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`空闲`, `运行`, `滑动`, 和 `跳跃` 动画'
- en: By the end of the chapter, you will be able to use state machines to cleanly
    transition between animations while always playing the correct one.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用状态机在动画之间干净地切换，同时始终播放正确的动画。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no new crates or other technical requirements in this chapter. The
    source code for this chapter is available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中没有新的crate或其他技术要求。本章的源代码可在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4)找到。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/35sk3TC](https://bit.ly/35sk3TC)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://bit.ly/35sk3TC](https://bit.ly/35sk3TC)
- en: Introducing state machines
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍状态机
- en: 'Games, web applications, heck, even cryptocurrency miners, have to manage the
    *state* of the system. After all, if the system isn''t doing something right now,
    if it doesn''t have a current state, then it''s not running, is it? The state
    is also fractal. In our game, we have a state of `playing`, and another one of
    `game over`. Once we add menu items, we''ll have even more states. Meanwhile,
    our RHB also has states: he''s running, sliding, jumping, dying, and dead. Let''s
    say unconscious, that''s less dark.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏、Web应用程序，甚至是加密货币矿工，都必须管理系统的*状态*。毕竟，如果系统现在没有做正确的事情，如果没有当前状态，那么它不是在运行，对吗？状态也是分形的。在我们的游戏中，我们有`playing`状态和`game
    over`状态。一旦我们添加菜单项，我们将有更多的状态。同时，我们的RHB也有状态：他在跑步、滑动、跳跃、死亡和死亡。让我们说昏迷，这比黑暗要好一些。
- en: 'The point is our game is doing a lot of things and is maintaining a large game
    state with a lot of mini-states inside it. As the application moves from one state
    to another, the rules of the system change. For example, when RHB is running,
    the *spacebar* might make him jump, but when he''s jumping, hitting the *spacebar*
    doesn''t do anything. The rule is you can''t jump when you''re already jumping.
    One way you can maintain that state is through a large structure with a bunch
    of values or Booleans, such as `jumping = true`, and in a Rust program, you might
    store that in an enumerated type like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是我们的游戏正在做很多事情，并且维护着一个包含许多子状态的大型游戏状态。当应用程序从一个状态移动到另一个状态时，系统的规则会改变。例如，当RHB在跑步时，空格键可能会让他跳跃，但当他正在跳跃时，按下空格键不会做任何事情。规则是你不能在已经跳跃时跳跃。你可以通过一个包含许多值或布尔值的大型结构来维持这种状态，例如`jumping
    = true`，在Rust程序中，你可能像这样将其存储在枚举类型中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This works reasonably well in small programs but for larger programs, there
    are two things that you'll want to manage. The first, which I've already hinted
    at, is that there may be rules about going between states. Maybe you can't go
    right from `Jumping` to `Sliding`, but an `enum` doesn't prevent that. The second
    is that, in addition to the rules being different for each state, frequently things
    happen on the *transitions* between states, things such as playing a sound effect
    or updating a score; for that, you need a state machine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这在小程序中效果相当不错，但对于更大的程序，有两件事你需要管理。第一，我已经暗示过了，可能存在关于状态之间转换的规则。也许你不能直接从 `Jumping`
    转换到 `Sliding`，但 `enum` 无法阻止这一点。第二是，除了每个状态的规则不同之外，经常在状态之间的 *转换* 发生事情，比如播放音效或更新分数；为此，你需要一个状态机。
- en: Defining a state machine
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义状态机
- en: 'Perhaps the most confusing thing about state machines is the naming, as there
    are state machines, finite state machines, the state pattern, and more, all of
    which frequently get used interchangeably by programmers. So, for the sake of
    clarity, let''s define them this way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于状态机，最令人困惑的事情可能是命名，因为存在状态机、有限状态机、状态模式等等，所有这些通常被程序员交替使用。因此，为了清晰起见，让我们这样定义它们：
- en: '**State machines**: A model of the state of a system, represented by a list
    of states and the transitions between them'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态机**：一个系统状态的模型，表示为一系列状态及其之间的转换'
- en: '`trait` object, which you can find here: [https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html](https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html).
    It''s quite good but is not idiomatic Rust, and we won''t be using it.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trait` 对象，您可以在以下链接中找到：[https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html](https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html)。它相当不错，但不是
    Rust 的惯用语法，我们不会使用它。'
- en: 'The state machine both helps us keep a mental model of the system in our heads
    and prevents us from making foolish mistakes in code, such as playing the running
    animation while RHB is jumping. The drawback, of course, is that you need to understand
    state machines, so let''s get that covered. We''ll use RHB as our example. RHB
    can be **Running**, **Idle**, **Jumping**, **Sliding**, **Falling**, or **KnockedOut**.
    We can use a state **transition table** to list those:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机既帮助我们保持对系统在头脑中的心理模型，又防止我们在代码中犯愚蠢的错误，例如当 RHB 跳跃时播放跑步动画。当然，缺点是你需要理解状态机，所以让我们来解决这个问题。我们将使用
    RHB 作为我们的例子。RHB 可以是 **Running**、**Idle**、**Jumping**、**Sliding**、**Falling** 或
    **KnockedOut**。我们可以使用状态 **转换表** 来列出这些：
- en: '![](img/Table_4.1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![表格](img/Table_4.1.jpg)'
- en: The transition table only has three columns for now, which are a start state,
    the event that causes a transition, and the state it transitions to. Events differ
    from transitions in that events are what happens to the system to *cause* a transition,
    but transitions are what happens *during* the state change.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 转换表目前只有三列，分别是起始状态、引起转换的事件以及转换到的状态。事件与转换的不同之处在于，事件是导致系统发生转换的原因，而转换是在状态变化期间发生的事情。
- en: 'It''s a subtle difference, and sometimes it gets used interchangeably because
    the names will frequently be the same. Let''s work through a state transition
    to clarify this. RHB starts in the `Idle` state, where he stands in place with
    an `run`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微妙的不同之处，有时它会被交替使用，因为名称通常会相同。让我们通过一个状态转换来澄清这一点。RHB 从 `Idle` 状态开始，在那里他站立并
    `run`：
- en: '![](img/Table_4.2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![表格](img/Table_4.2.jpg)'
- en: 'When moving to `Running`, we actually do something on the transition. Specifically,
    we start moving to the right; we increase the velocity in `x`. You can name this
    transition in the table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动到 `Running` 状态时，我们在转换过程中实际上做了一些事情。具体来说，我们开始向右移动；在 `x` 方向上增加速度。你可以在表中命名这个转换：
- en: '![](img/Table_4.3.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![表格](img/Table_4.3.jpg)'
- en: While this is correct, often we don't bother naming the transitions and the
    events because they become redundant. While we could continue adding to this table,
    we can also model a state machine with several types of diagrams. I'm partial
    to simple circles and lines, where the circles are the states and the lines are
    the transitions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是正确的，但通常我们不会费心命名转换和事件，因为它们变得冗余。虽然我们可以继续添加到这个表中，但我们也可以用几种类型的图来模拟状态机。我偏爱简单的圆圈和线条，其中圆圈是状态，线条是转换。
- en: '![Figure 4.1 – A state machine diagram'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 状态机图'
- en: '](img/Figure_4.01_B17151.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.01_B17151.jpg)'
- en: Figure 4.1 – A state machine diagram
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 状态机图
- en: This diagram is a fleshed-out version of the previous table, with all of the
    entries completed. It starts at the **Idle** state and transitions to the **Running**
    state via the **Run** event. From there, it can go in several directions. If the
    player *slides*, it can go into the **Sliding** state; if the player *jumps*,
    it can go into the **Jumping** state. Both of those eventually return to the **Running**
    state when sliding or jumping is over. **Running**, **Sliding**, and **Jumping**
    can all transition into the **Falling** state when they crash into something.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表是之前表格的详细版本，所有条目都已填写。它从**Idle**状态开始，通过**Run**事件过渡到**Running**状态。从那里，它可以有几个方向。如果玩家**滑动**，它可以进入**Sliding**状态；如果玩家**跳跃**，它可以进入**Jumping**状态。这两种状态最终都会在滑动或跳跃结束后返回到**Running**状态。**Running**、**Sliding**和**Jumping**都可以在撞到东西时过渡到**Falling**状态。
- en: This does result in a lot of transitions across the middle of the diagram. Finally,
    the **Falling** state transitions into the **KnockedOut** state when **Falling**
    is over, via the **End** event. If you're familiar with this type of diagram,
    you might point out that I could have used a *superstate* to contain **Running**,
    **Jumping**, and **Sliding** and used one event to transition all of those to
    **Falling**. You'd be right, but we won't need to concern ourselves with that
    for our implementation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实导致图表中间有很多转换。最后，当**下落**结束时，**Falling**状态通过**End**事件过渡到**KnockedOut**状态。如果你熟悉这种类型的图表，你可能会指出，我本可以使用**超状态**来包含**Running**、**Jumping**和**Sliding**，并使用一个事件将所有这些转换到**Falling**。你是对的，但我们就不会在我们的实现中关注这一点了。
- en: You might be asking, what's the benefit of all this? Does this really fit the
    *minimal architecture* that we covered in the last chapter? Answering the second
    question first, the answer is, uh…maybe? I find that state machines help me keep
    code together that belongs together, rather than sprinkling `match` statements
    throughout my code base as I might have to when using a simple `enum`. That doesn't
    mean we won't have those `match` statements; they'll just be in one place.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，所有这些有什么好处？这真的符合我们在上一章中提到的**最小架构**吗？首先回答第二个问题，答案是，嗯……也许？我发现状态机帮助我把属于一起的代码放在一起，而不是像使用简单的`enum`时那样在我的代码库中散布`match`语句。这并不意味着我们不会使用那些`match`语句；它们只是会集中在一个地方。
- en: I also find it fits my mental model of how code works well, and it helps prevent
    errors because you simply *can't* perform an action that's invalid because it's
    not available for that given state. Frankly, the state machine exists whether
    or not we model it, and it's cleaner if we can also model it in code rather than
    having it emerge accidentally. So, those are the benefits, and that's why I think
    it fits in our minimal architecture. Now it's time to implement it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我还发现它符合我对代码工作方式的思维模型，并且它有助于防止错误，因为你**根本无法**执行一个无效的操作，因为这个操作在那个特定状态下不可用。坦白说，状态机无论我们是否对其进行建模都存在，如果我们能够在代码中对其进行建模，而不是让它意外出现，那么它会更干净。所以，这些都是好处，这就是为什么我认为它适合我们的最小架构。现在，是时候实现它了。
- en: Implementing with types
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型实现
- en: 'The **Object-Oriented** (**OO**) state pattern is typically implemented as
    a variation on the strategy pattern, where you swap out different objects that
    all implement the same state interface at runtime based on the various transitions.
    The diagram looks something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象**（**OO**）状态模式通常作为策略模式的一种变体来实现，其中在运行时根据各种转换替换实现相同状态接口的不同对象。图表看起来大致如下：'
- en: '![Figure 4.2 – State pattern](img/Figure_4.02_B17151.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 状态模式](img/Figure_4.02_B17151.jpg)'
- en: Figure 4.2 – State pattern
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 状态模式
- en: In the OO version of the pattern, `enum`, which we can use to enumerate the
    states in a clearer fashion than traditional objects. The second is **generic
    types**, which we'll use to model each state as a **typestate**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式的面向对象（OO）版本中，`enum`，我们可以用它以比传统对象更清晰的方式枚举状态。第二个是**泛型类型**，我们将用它来将每个状态建模为**类型状态**。
- en: Important Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The original state machine implementation I wrote was largely based on this
    excellent article by Ana Hobden, a.k.a. Hoverbear, at [https://hoverbear.org/blog/rust-state-machine-pattern/](https://hoverbear.org/blog/rust-state-machine-pattern/).
    While this book no longer uses that pattern, I encourage you to read it for an
    alternative approach.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初编写的原始状态机实现主要基于Ana Hobden（又名Hoverbear）这篇优秀的文章，她在[https://hoverbear.org/blog/rust-state-machine-pattern/](https://hoverbear.org/blog/rust-state-machine-pattern/)上发表了这篇文章。虽然这本书不再使用该模式，但我鼓励你阅读它以获取另一种方法。
- en: The typestate pattern
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型状态模式
- en: '**Typestate** is a fancy name for embedding the state of an object in its type.
    The way it works is that you have a generic structure with one generic parameter
    representing the state. Then, each state will have methods that can return new
    states. So, instead of each state having common methods, as they do, as shown
    in *Figure 4.2*, each state has its own methods that return the new state. The
    states in *Figure 4.2* might look something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型状态**是将对象的状态嵌入其类型中的高级名称。它的工作方式是，你有一个具有一个泛型参数的泛型结构，该参数表示状态。然后，每个状态都将有可以返回新状态的方法。因此，与它们在*图4.2*中所示的情况一样，每个状态都有自己的方法来返回新状态。*图4.2*中的状态可能看起来像这样：'
- en: '![Figure 4.3 – Typestate pattern](img/Figure_4.03_B17151.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 类型状态模式](img/Figure_4.03_B17151.jpg)'
- en: Figure 4.3 – Typestate pattern
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 类型状态模式
- en: In this diagram, `State<GenericStateOne>` has a `next` method, which consumes
    `self` and returns `State<GenericStateTwo>`. Meanwhile, `State<GenericStateTwo>`
    only has an `update` method, which takes a mutably borrowed `self`. The implications
    of this are that the compiler will catch you if you try to call `next` on `State<GenericStateTwo>`.
    In the traditional OO pattern, all states must handle all the same methods because
    they share an interface, so this kind of defense isn't possible. Often, this means
    implementing methods you don't actually care about, and either returning an error
    state or `Self`, and then debugging at runtime.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`State<GenericStateOne>`有一个`next`方法，它消耗`self`并返回`State<GenericStateTwo>`。同时，`State<GenericStateTwo>`只有一个`update`方法，它接受一个可变借用`self`。这意味着如果你尝试在`State<GenericStateTwo>`上调用`next`，编译器会捕获你。在传统的OO模式中，所有状态都必须处理所有相同的方法，因为它们共享一个接口，所以这种防御是不可能的。通常，这意味着实现你实际上不关心的方法，然后返回一个错误状态或`Self`，并在运行时进行调试。
- en: In addition, we can use the `mod` keyword and Rust's rules about privacy to
    make it impossible to create any state in an invalid state. We can make it impossible
    to move from `GenericStateOne` to `GenericStateTwo` without calling `next` by
    keeping the internals of `State` private so you can't just construct it. This
    is called **making illegal states unrepresentable**, and it's a great way to make
    sure you don't make mistakes in your programs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用`mod`关键字和Rust的隐私规则来确保无法创建任何无效状态。我们可以通过保持`State`的内部私有，使其无法直接构造，来确保无法从`GenericStateOne`移动到`GenericStateTwo`而不调用`next`方法。这被称为**使非法状态不可表示**，这是一种确保你不会在程序中犯错的绝佳方法。
- en: Important Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I tracked down the *making illegal states unrepresentable* phrasing to Yaron
    Minsky ([https://blog.janestreet.com/effective-ml-revisited/](https://blog.janestreet.com/effective-ml-revisited/));
    however, it's quite likely the practice and phrasing are older than that.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我追踪到“使非法状态不可表示”的表述是来自Yaron Minsky ([https://blog.janestreet.com/effective-ml-revisited/](https://blog.janestreet.com/effective-ml-revisited/))；然而，这种做法和表述很可能比那还要早。
- en: Typestates are intimidating because they are both a new concept and new jargon,
    so don't worry if you feel a little confused.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类型状态可能会让人感到害怕，因为它们既是一个新概念，也是新术语，所以如果你感到有点困惑，请不要担心。
- en: Tip
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: There's a lot of great information on typestates in Rust. There's an excellent
    talk by Will Crichton from Strange Loop (https://youtu.be/bnnacleqg6k?t=2015),
    as well as blogs at [https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm](https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm)
    and [http://cliffle.com/blog/rust-typestate/](http://cliffle.com/blog/rust-typestate/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中关于类型状态有很多很好的信息。有一个来自Strange Loop的Will Crichton的精彩演讲（https://youtu.be/bnnacleqg6k?t=2015），以及[https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm](https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm)和[http://cliffle.com/blog/rust-typestate/](http://cliffle.com/blog/rust-typestate/)上的博客。
- en: 'If you want to forget all about generics and type theory for a minute, they
    can be summarized as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要暂时忘记所有关于泛型和类型理论的知识，它们可以总结如下：
- en: Each state of the object is represented by a separate struct.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的每个状态都由一个单独的结构体表示。
- en: You can only advance from one state to another by methods on that struct.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能通过该结构体上的方法从一个状态推进到另一个状态。
- en: You can guarantee you can only create valid states using privacy rules.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用隐私规则保证只能创建有效的状态。
- en: The rest are just details.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是细节。
- en: Finally, we're going to need an `enum` to *hold* our typestate. Each state is
    generic, so to continue in our preceding example, any struct that will interact
    with our state machine will need to hold *either* `State<GenericStateOne>` or
    `State<GenericStateTwo>`. In order to do that, we would either need to make the
    containing `struct` generic as well, and then create new versions of the containing
    `struct` every time the state changes, or wrap the generic object in an `enum`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个 `enum` 来 *持有* 我们的类型状态。每个状态都是泛型的，所以继续我们之前的例子，任何将与我们的状态机交互的结构体都需要持有
    *要么* `State<GenericStateOne>` 或 `State<GenericStateTwo>`。为了做到这一点，我们可能需要将包含的结构体也做成泛型的，然后每次状态改变时都创建包含结构体的新版本，或者将泛型对象包裹在一个
    `enum` 中。
- en: We'll use an `enum` because it prevents the generic nature of the typestate
    from propagating throughout the program, allowing the typestate to be an implementation
    detail. We're going to write the kind of state machine that Rust is very good
    at. Let's get to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `enum`，因为它阻止了类型状态的泛型性质在整个程序中传播，使得类型状态成为一个实现细节。我们将编写 Rust 非常擅长的那种状态机。让我们开始吧。
- en: Managing animation
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理动画
- en: We'll create our state machine to manage the different animations. Specifically,
    when RHB isn't moving, he's `Idle`, but when he's moving, he's `Running`. When
    he jumps, he's `Jumping`. You get the idea.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建状态机来管理不同的动画。具体来说，当 RHB 不在移动时，它是 `Idle` 状态，但当它在移动时，它是 `Running` 状态。当他跳跃时，他是
    `Jumping` 状态。你明白这个意思。
- en: Those different RHB states correspond to the different animations managed using
    a state machine. We'll first create the RHB with a state machine and then integrate
    it into our current application. We'll implement this *top-down*, starting with
    a struct that represents RHB and letting the compiler errors drive further development.
    This is sometimes called **Compiler-Driven Development** although it's not a formalized
    approach such as **Test-Driven Development**. It can work extremely well in a
    language with a robust type system and great compiler errors, such as Rust. Let's
    start with how we'll represent RHB.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的 RHB 状态对应于使用状态机管理的不同动画。我们首先创建带有状态机的 RHB，然后将其集成到我们的当前应用程序中。我们将从代表 RHB 的结构体开始，让编译器错误驱动进一步的开发。这有时被称为
    **编译器驱动开发**，尽管它不是一个正式的方法，如 **测试驱动开发**。它可以在具有强大类型系统和优秀编译器错误的语言中工作得非常好，如 Rust。让我们从如何表示
    RHB 开始。
- en: 'The `RedHatBoy` struct will contain the state machine, the sprite sheet, and
    the image because eventually, it will draw itself:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedHatBoy` 结构体将包含状态机、精灵表和图像，因为最终它将自行绘制：'
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: All of this code belongs in the `game` module. That means you can put it in
    the `game.rs` file or if you so choose, put it in a separate file and bring it
    into the `game` module with the `mod` keyword. I'll leave that up to you.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码都属于 `game` 模块。这意味着你可以将它放在 `game.rs` 文件中，或者如果你愿意，可以将其放在一个单独的文件中，并使用 `mod`
    关键字将其引入 `game` 模块。我会把这个决定留给你。
- en: 'Of course, this won''t work because you haven''t created the state machine
    yet. You do have the `Sheet` structure from [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*. Let''s create `RedHatBoyStateMachine`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不会工作，因为你还没有创建状态机。你确实有来自 [*第3章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)
    的 `Sheet` 结构体，*创建游戏循环*。让我们创建 `RedHatBoyStateMachine`：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Seeing the `enum` we discussed earlier, it might still be unclear why we''re
    using it when we''ll be creating all of these typestate structures. `RedHatBoyState`,
    which doesn''t exist yet, is a generic type that contains another type, where
    those types represent the various states. So, why the redundant `enum`? Because
    we want to be able to switch easily between the states without using the heap
    or dynamic dispatch. Let''s imagine we defined the `RedHatBoy` struct in the following
    way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们之前讨论的 `enum`，可能仍然不清楚为什么我们要使用它，因为我们将会创建所有这些类型状态结构。还不存在的 `RedHatBoyState`
    是一个包含另一个类型的泛型类型，其中这些类型代表各种状态。那么，为什么还需要冗余的 `enum`？因为我们希望能够在不使用堆或动态分派的情况下轻松地在状态之间切换。让我们想象我们以以下方式定义了
    `RedHatBoy` 结构体：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now the state is fixed to a state. We could, of course, define things in the
    following way:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在状态被固定到一个状态。当然，我们可以用以下方式定义：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But of course, now `RedHatBoy` has to also be a generic type. You can make this
    work without the `enum` using `Box<dyn State>`, but that's not very ergonomic
    and it would require implementing the same methods on every state, so we'll stick
    with the `enum`. I have to acknowledge that I don't like the stutter in the types
    such as `*Idle*(RedHatBoyState<*Idle*>)`, but we'll see that the `enum` wrapper
    becomes extremely useful as we implement the state machine. Make sure that the
    `enum` is `Copy,Clone` as well, for reasons you'll see shortly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当然，现在`RedHatBoy`也必须是一个泛型类型。你可以使用`Box<dyn State>`而不使用`enum`来使这可行，但这不是很方便，并且需要在每个状态上实现相同的方法，所以我们将坚持使用`enum`。我必须承认我不喜欢类型中的这种重复，比如`*Idle*(RedHatBoyState<*Idle*>)`，但我们会看到，随着状态机的实现，`enum`包装器变得极其有用。确保`enum`也是`Copy,Clone`，原因你很快就会看到。
- en: Important Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you''re interested, *The Rust Programming Language* has a chapter that describes
    how to implement a state pattern in a traditional OO way. Interestingly, they
    eventually abandon it in favor of using an `enum`. You can find that here: [https://bit.ly/3hBsVd4](https://bit.ly/3hBsVd4).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个感兴趣，*《Rust编程语言》*有一章描述了如何以传统的面向对象方式实现状态模式。有趣的是，他们最终放弃了它，转而使用`enum`。你可以在这里找到：[https://bit.ly/3hBsVd4](https://bit.ly/3hBsVd4)。
- en: 'Of course, this code still doesn''t compile, because we haven''t created either
    of those states or the `RedHatBoyState` `x`. This is what I meant by Compiler-Driven
    Development. We can start by creating `RedHatBoyState`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码仍然无法编译，因为我们还没有创建那些状态，也没有创建`RedHatBoyState` `x`。这就是我所说的编译器驱动开发。我们可以从创建`RedHatBoyState`开始：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All the code relating to the individual states will go in its own module, `red_hat_boy_states`,
    so that we can only make public the methods required by the rest of the `game`
    module. This will make it impossible to accidentally create a state without using
    the methods provided, and therefore, impossible to accidentally make an invalid
    transition. The only way to transition from `RedHatBoyState<Idle>` to `RedHatBoyState<Running>`
    is going to be through the methods on `RedHatBoyState<Idle>`. It's important that
    both `RedHatBoyState` and `RedHatBoyContext` are public but their members are
    private, so we can use them as intended.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与单个状态相关的代码都将放入其自己的模块`red_hat_boy_states`中，这样我们就可以只公开`game`模块其余部分所需的方法。这将使得意外创建一个状态而不使用提供的方法变得不可能，因此，不可能意外地执行无效的转换。从`RedHatBoyState<Idle>`转换到`RedHatBoyState<Running>`的唯一方法将通过`RedHatBoyState<Idle>`上的方法来实现。重要的是`RedHatBoyState`和`RedHatBoyContext`都是公开的，但它们的成员是私有的，这样我们就可以按预期使用它们。
- en: 'Inside the new module, `RedHatBoyState` is a simple generic type that contains
    `_state`, which is never read, hence the underscore, and `RedHatBoyContext`. Now,
    `RedHatBoyContext` is a structure with data that''s common to all the states.
    In this case, that''s the frame being rendered, the position, and the velocity.
    We''ll need it so that the state transitions can modify the state of RHB. Putting
    all of this in the `red_hat_boy_states` module means that we haven''t changed
    the compiler error message. We need to import that module into the `game` module
    with `use self::red_hat_boy_states::*;`, which you can add anywhere in the `game`
    module. This gets us partway there, but if we look at the following compiler output,
    we''re still not finished:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在新模块中，`RedHatBoyState`是一个简单的泛型类型，它包含`_state`，这个字段永远不会被读取，因此使用了下划线，以及`RedHatBoyContext`。现在，`RedHatBoyContext`是一个包含所有状态共有数据的结构。在这种情况下，那就是正在渲染的帧、位置和速度。我们需要它以便状态转换可以修改RHB的状态。将所有这些放入`red_hat_boy_states`模块意味着我们没有改变编译器错误信息。我们需要将那个模块导入到`game`模块中，使用`use
    self::red_hat_boy_states::*;`，你可以在`game`模块的任何地方添加它。这让我们前进了一步，但如果我们查看下面的编译器输出，我们还没有完成：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s also a corresponding `enum` variant for `Running(RedHatBoyState<Running>)`.
    Both `Idle` and `Running` don''t exist. We can create both of these easily, with
    empty structures inside the `red_hat_boy_states` module. Note that both of these
    must also be `Clone`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Running(RedHatBoyState<Running>)`也有相应的`enum`变体。`Idle`和`Running`这两个状态都不存在。我们可以在`red_hat_boy_states`模块内部轻松创建这两个状态，注意这两个也必须是`Clone`：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Transitioning between states
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态之间的转换
- en: 'Congratulations! You''ve created two states for RHB. This achieves…nothing.
    There''s a bit missing. For starters, we can''t transition from `Idle` to `Running`,
    and those states don''t actually do anything when they aren''t transitioning.
    Let''s take care of a transition right now. We''ll add a method on `RedHatBoyState<Idle>`
    to go from `Idle` to `Running`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您为RHB创建了两个状态。但这...什么也没做。还有一些东西缺失。首先，我们不能从`Idle`状态转换到`Running`状态，而且当它们不在转换过程中时，这些状态实际上并不做任何事情。让我们现在处理一个转换。我们将在`RedHatBoyState<Idle>`上添加一个方法，从`Idle`状态转换到`Running`状态：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is the transition from `Idle` to `Running`, and the `run` method is where
    the magic happens. This is just a function that takes a `RedHatBoy<Idle>` state
    and converts it to a `RedHatBoy<Running>` state, and for now, doesn't change any
    `RedHatBoyContext` data. You might wonder then, what magic?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从`Idle`状态到`Running`状态的转换，而`run`方法就是魔法发生的地方。这只是一个函数，它接受一个`RedHatBoy<Idle>`状态并将其转换为`RedHatBoy<Running>`状态，目前它不会改变任何`RedHatBoyContext`数据。那么，你可能想知道，这有什么魔法？
- en: This means that to transition from `Idle` to `Running`, you can use `run`, but
    it also means you can't transition from `Running` back into `Idle`, and that makes
    sense because the game doesn't allow that behavior. The function also takes `mut
    self`, so that when it's called, it consumes the current state. This means that
    if you want to somehow keep `Idle` around after transitioning to `Running`, you
    have to clone it, and if you do that, you probably really meant to do it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着要从`Idle`状态转换到`Running`状态，你可以使用`run`，但也意味着你不能从`Running`状态转换回`Idle`状态，这是有道理的，因为游戏不允许这种行为。该函数还接受`mut
    self`，这意味着当它被调用时，它会消耗当前状态。这意味着如果你想在转换到`Running`状态后保留`Idle`状态，你必须克隆它，如果你这样做，你很可能真的想这么做。
- en: You also can't create the `Running` state directly, because its data members
    are private, which means you can't just create that state by mistake. You can't
    create the `Idle` state either, and that's a problem because it's the start state.
    We'll address that in a moment, but first, let's dive into how we'll interact
    with the states through our state machine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不能直接创建`Running`状态，因为它的数据成员是私有的，这意味着你不能不小心创建那个状态。你也不能创建`Idle`状态，这是一个问题，因为它是起始状态。我们稍后会解决这个问题，但首先，让我们深入了解我们将如何通过状态机与状态交互。
- en: Managing the state machine
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理状态机
- en: 'Initially, we might be tempted to implement our state machine by adding methods
    on the `RedHatBoyStateMachine` `enum`, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们可能会倾向于通过在`RedHatBoyStateMachine` `enum`上添加方法来实现我们的状态机，如下所示：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This isn't terrible, but it means that every method on our state machine will
    likely need to match the current variant of the `RedHatBoyStateMachine` `enum`.
    Then, it would return the new variant based on either the transition or `self`
    when the transition isn't currently valid. In other words, while the compiler
    will error if we call `run` on the `Running` state, it won't error if we call
    `run` on `RedHatBoyStateMachine` when the current variant is `Running`. This kind
    of error, where we call `run` by mistake on the wrong state, is exactly what we're
    trying to get away from with our typestates. We'd go to all the trouble of writing
    these typestates only to immediately throw away one of the benefits in every method
    on the `RedHatBoyStateMachine` `enum`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不糟糕，但这意味着我们的状态机上的每个方法都可能需要匹配`RedHatBoyStateMachine` `enum`的当前变体。然后，它将根据转换或`self`返回新的变体，当转换当前无效时。换句话说，虽然如果我们对`Running`状态调用`run`，编译器会报错，但如果我们对当前变体为`Running`的`RedHatBoyStateMachine`调用`run`，编译器不会报错。这种错误，即错误地在不正确的状态上调用`run`，正是我们试图通过类型状态避免的。我们费尽心思编写这些类型状态，只是为了在每个`RedHatBoyStateMachine`
    `enum`的方法上立即放弃其中的一个好处。
- en: 'Unfortunately, we can''t completely get away from that problem, because we
    are using an `enum` to contain our states. There''s no way to implement methods
    on variants of an `enum` as we can with generic structures, and if we''re going
    to wrap the state in an `enum`, we''ll have to match on the variant. What we can
    do is *reduce* the surface area of that kind of error by reducing the number of
    methods that operate in the states. Specifically, instead of calling `run` on
    the `enum`, we''ll create a `transition` function that takes `Event`. That is
    going to look like the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法完全摆脱这个问题，因为我们正在使用`enum`来包含我们的状态。我们无法像使用泛型结构那样在`enum`的变体上实现方法，如果我们打算用`enum`包装状态，我们就必须匹配变体。我们可以做的是通过减少在状态中操作的方法数量来减少这种错误的可能性。具体来说，我们不会在`enum`上调用`run`，而是创建一个接受`Event`的`transition`函数。这看起来像以下代码：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've solved the problem caused by the `enum` with another `enum`! This is very
    *Rusty* of us. In this case, we've created an `enum` named `Event` to represent
    every event that could happen to our machine and replaced the method named `run`
    with a method named `transition`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用另一个`enum`解决了`enum`引起的问题！这非常*Rusty*。在这种情况下，我们创建了一个名为`Event`的`enum`来表示可能发生在我们机器上的每一个事件，并用名为`transition`的方法替换了名为`run`的方法。
- en: So, instead of many small methods for run, jump, and similar, we will have one
    method named `transition` and a bunch of `Event` variants. How does this improve
    things? Because there is only one `match` statement that we have to update when
    we want to add a transition, instead of potentially adding multiple little `match`
    statements. Keep in mind that this function takes `mut` `self`, which means calling
    `transition` will consume `self` and return a new `RedHatBoyStateMachine` just
    as the `run` method does on `RedHatBoyState<Idle>`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会有很多小的方法，如run、jump等，我们将有一个名为`transition`的方法和许多`Event`变体。这如何改进事情？因为当我们想要添加转换时，我们只需要更新一个`match`语句，而不是可能添加多个小的`match`语句。记住，这个函数接受`mut
    self`，这意味着调用`transition`将消耗`self`并返回一个新的`RedHatBoyStateMachine`，就像`run`方法在`RedHatBoyState<Idle>`上做的那样。
- en: Using Into for clean code
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Into编写整洁的代码
- en: We can actually improve the ergonomics of this method using the `From` trait.
    If you're unfamiliar, the `From` trait is a Rust feature that lets us define how
    to convert from one type to another. Implementing the `From` trait on your type
    will also implement the `Into` trait, which will provide an `into` method that
    will make it easy to convert from one type to another.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以使用`From`特质来改进这个方法的易用性。如果你不熟悉，`From`特质是Rust的一个特性，它允许我们定义如何从一个类型转换为另一个类型。在你的类型上实现`From`特质也会实现`Into`特质，这将提供一个`into`方法，使得类型之间的转换变得容易。
- en: 'We know that if we have `RedHatBoyState<Running>`, it will convert into the
    `RedHatBoyStateMachine::Running` variant, and if we write the conversion by implementing
    the `From` trait, we will be able to replace that wrapping with a call to `into`.
    That was a lot of words for a little bit of code, so the following is what the
    implementation of the `From` trait looks like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，如果我们有`RedHatBoyState<Running>`，它将转换为`RedHatBoyStateMachine::Running`变体，如果我们通过实现`From`特质来编写转换，我们将能够用`into`调用替换包装。这虽然说了很多话，但代码却很少，所以以下就是`From`特质的实现样子：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This can be placed right under the implementation of `RedHatBoyStateMachine`.
    It defines how to convert from `RedHatBoy<Running>` to `RedHatBoyStateMachine`,
    and it''s the same small amount of code we wrote in the `transition` method. Because
    we have this now, we can make that method a little more succinct, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以放在`RedHatBoyStateMachine`实现下方。它定义了如何从`RedHatBoy<Running>`转换为`RedHatBoyStateMachine`，并且这与我们在`transition`方法中编写的少量代码相同。因为我们现在有了这个，我们可以使那个方法更加简洁，如下所示：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Replacing calls like `RedHatBoyStateMachine::Idle::Running(state.run)` with
    `into` isn't just prettier and more concise; it also means that if `run` changes
    to return a different state, the `transition` method can stay the same, as long
    as a `From` trait has been written to go from the state to the `RedHatBoyStateMachine`
    `enum`. It's a nice little change that makes our code more flexible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将`RedHatBoyStateMachine::Idle::Running(state.run)`这样的调用替换为`into`不仅更美观、更简洁；它还意味着如果`run`改变为返回不同的状态，只要有一个从状态到`RedHatBoyStateMachine`
    `enum`的`From`特质被编写，`transition`方法就可以保持不变。这是一个使我们的代码更加灵活的小改动。
- en: It's a little odd that the `RedHatBoyStateMachine` `enum` is what we call our
    state machine because we don't normally associate enumerated types with behavior,
    but this method is why we call it a machine. We use `enum` to hold the various
    generic states, and we use the ability to add methods to an `enum` to make it
    a lot more ergonomic to use. The various states know how to transition from one
    state to another, and the machine knows when to do the transitions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有点奇怪的是，我们称之为状态机的`RedHatBoyStateMachine` `enum`是因为我们通常不会将枚举类型与行为相关联，但这个方法就是为什么我们称之为机器。我们使用`enum`来持有各种泛型状态，我们使用向`enum`添加方法的能力来使其使用起来更加方便。各种状态知道如何从一个状态转换到另一个状态，机器知道何时进行转换。
- en: Integrating the state machine
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成状态机
- en: Now that we've built a state machine, albeit one with two states, we need to
    actually use it for something. Recall our current game, let RHB run throughout
    a meaningless void. We're going to want to change it so that RHB starts in the
    left corner and begins running when the user hits the *right arrow key*. In other
    words, they will transition from `Idle` to `Running`. When that happens, we'll
    also want to make sure we're showing the appropriate animation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个状态机，尽管它只有两个状态，但我们实际上需要用它来做些事情。回想一下我们当前的游戏，让 RHB 在一个无意义的虚空中奔跑。我们将想要改变它，使得
    RHB 从左角开始，当用户按下 *右箭头键* 时开始奔跑。换句话说，他们将从一个 `Idle` 状态过渡到 `Running` 状态。当这种情况发生时，我们还想确保显示适当的动画。
- en: 'We''ll start by putting `RedHatBoy` in the `WalkTheDog` game:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从将 `RedHatBoy` 放入 `WalkTheDog` 游戏开始：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'RHB will need to be an `Option` for now because `RedHatBoy` contains a sprite
    sheet. Since the sprite sheet isn''t available until the image is loaded in `initialize`,
    we have to make `rhb` an `Option` type. We''ll want to initialize the machine
    in the `initialize` function, and for that purpose, we''ll want to create a convenient
    `new` method for the `Idle` state:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `RedHatBoy` 包含一个精灵图集，所以现在 `RHB` 必须是一个 `Option` 类型。由于精灵图集直到在 `initialize`
    中加载图像后才可用，我们必须将 `rhb` 设置为 `Option` 类型。我们希望在 `initialize` 函数中初始化机器，为此，我们将为 `Idle`
    状态创建一个方便的 `new` 方法：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because `Idle` is the initial state, it's the only state that will get a `new`
    function, as mentioned earlier. We've also introduced a constant called `FLOOR`
    that marks the bottom of the screen, where RHB will land when he jumps.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Idle` 是初始状态，所以它将是唯一获得 `new` 函数的状态，正如之前提到的。我们还引入了一个名为 `FLOOR` 的常量，它标记了屏幕的底部，当
    RHB 跳跃时，他将落在那里。
- en: 'I''ll show it here as if it''s defined right at the top of the `red_hat_boy_states`
    module. Now, in `Game` `initialize`, we still have a compiler error because we
    haven''t set up `RedHatBoy` in the game. We can do that right after we''ve loaded
    the sprite sheet, and we''ll keep two copies of the sprite sheet around; not because
    we want two copies, but because we''ll delete all the old code when we''ve successfully
    replaced it with the new code. You can see the changes here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里将其展示为好像它定义在 `red_hat_boy_states` 模块的顶部。现在，在 `Game` 的 `initialize` 方法中，我们仍然有一个编译错误，因为我们还没有在游戏中设置
    `RedHatBoy`。我们可以在加载精灵图集之后立即这样做，并且我们会保留两个精灵图集副本；这不是因为我们想要两个副本，而是因为我们将在成功用新代码替换旧代码后删除所有旧代码。你可以在这里看到这些更改：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We had to change a surprising amount of code here, because of Rust''s borrowing
    rules. Our intent is to `clone` `sheet` and `image` and send those into the `RedHatBoy::new`
    method. However, if we do that, we also need to clone `image` and `sheet` when
    setting the fields for `image` and `sheet` on `WalkTheDogStruct`. Why? Because
    the `image: image` line is a move, and can''t be accessed after that. That''s
    the borrow after move error. Instead we clone `image` and sheet and move the cloned
    instances into WalkTheDog. Then when creating the RedHatBoy we clone them again.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '由于 Rust 的借用规则，我们在这里不得不修改大量的代码。我们的意图是 `clone` `sheet` 和 `image`，并将这些传递给 `RedHatBoy::new`
    方法。然而，如果我们这样做，我们还需要在为 `WalkTheDogStruct` 上的 `image` 和 `sheet` 字段设置值时克隆 `image`
    和 `sheet`。为什么？因为 `image: image` 这一行是一个移动操作，之后无法访问。这就是移动后的借用错误。因此，我们克隆 `image`
    和 `sheet`，并将克隆的实例移动到 `WalkTheDog` 中。然后，在创建 `RedHatBoy` 时，我们再次克隆它们。'
- en: The same goes for `sheet`. We also have to explicitly call out the type of `sheet`
    when we assign it in the first place because the compiler can't infer the type
    anymore. Fortunately, this is an intermediate step; we are working past the compiler
    errors and will eventually reduce this code to what we actually need. We can't
    yet because we've replaced one compiler error with two!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `sheet` 也是如此。我们还需要在最初分配 `sheet` 时明确指出 `sheet` 的类型，因为编译器已经无法推断出类型了。幸运的是，这是一个中间步骤；我们正在解决编译错误，并最终将这段代码缩减到我们实际需要的样子。我们目前还不能这样做，因为我们用两个编译错误替换了一个！
- en: Before, the `rhb` field wasn't filled in when we created `WalkTheDog`, so that
    didn't compile. In order to set the `rhb` field to something, we are presuming
    a `RedHatBoy::new` method exists, but it doesn't, so that doesn't compile. We
    are also passing the soon-to-exist constructor clones of `sheet` and `image`.
    The `Sheet` type doesn't support `clone` yet, so that doesn't compile either.
    We'll need to fix both of these compiler errors to move forward.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，当我们创建 `WalkTheDog` 时，`rhb` 字段没有被填充，所以这没有编译通过。为了将 `rhb` 字段设置为一个值，我们假设存在一个
    `RedHatBoy::new` 方法，但实际上它不存在，所以这也没有编译通过。我们还传递了即将存在的构造函数克隆的 `sheet` 和 `image`。由于
    `Sheet` 类型目前不支持 `clone`，这也导致了编译错误。我们需要修复这两个编译错误才能继续前进。
- en: Before we continue, I want to note how we use the `ok_or_else` construct on
    each `clone` call, and then the `?` operator. `RedHatBoy` doesn't need to hold
    `Option<Sheet>` or `Option<HtmlImageElement>`, so its constructor will take `Sheet`
    and `HtmlImageElement`. Calling `ok_or_else` will convert `Option` into `Result`,
    and `?` will return from the `initialize` method with `Error` if the value isn't
    present. This prevents the rest of the code from having to continually validate
    that the `Option` type is present, so the code will be a little bit cleaner. The
    `Option` type is great, but at any time you can replace working with an `Option`
    type with the actual value it's wrapping.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想指出我们如何在每个`clone`调用中使用`ok_or_else`构造，然后是`?`运算符。`RedHatBoy`不需要持有`Option<Sheet>`或`Option<HtmlImageElement>`，所以它的构造函数将接受`Sheet`和`HtmlImageElement`。调用`ok_or_else`将`Option`转换为`Result`，如果值不存在，`?`将返回`initialize`方法中的`Error`。这防止了代码的其余部分需要不断验证`Option`类型的存在，因此代码将更加简洁。`Option`类型很棒，但任何时候你都可以用实际值替换处理`Option`类型。
- en: 'The easiest of the two compiler errors to fix is the fact that `sheet` doesn''t
    implement `clone`. Many in the Rust community derive `Clone` on any public type,
    and while I won''t be following that practice in this book, there''s no reason
    not to add it to `Sheet` and the types it references, as shown here. Remember,
    `Sheet` is in the `engine` module:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 两个编译器错误中，最容易修复的是`sheet`没有实现`clone`。在Rust社区中，很多人在所有公共类型上都派生了`Clone`，虽然在这本书中我不会遵循这种做法，但将`Clone`添加到`Sheet`及其引用的类型中并没有任何理由，如下所示。记住，`Sheet`位于`engine`模块中：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we''re down to one compiler error, `RedHatBoy` doesn''t have a `new` function,
    so let''s create an `impl` block for the `RedHatBoy` struct and define that, as
    shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只剩下一个编译器错误，`RedHatBoy`没有`new`函数，所以让我们为`RedHatBoy`结构体创建一个`impl`块，并定义它，如下所示：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This creates a new `RedHatBoy` with a state machine in the `Idle` state. We've
    also loaded `sprite_sheet` and `image` in the `initialize` function and passed
    them to this constructor. Congratulations! Our code compiles!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个处于`Idle`状态的`RedHatBoy`新实例。我们还在`initialize`函数中加载了`sprite_sheet`和`image`，并将它们传递给这个构造函数。恭喜！我们的代码编译成功了！
- en: Drawing RedHatBoy
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制RedHatBoy
- en: Unfortunately, this still doesn't do much. `RedHatBoy` is never drawn! The interface
    we want is to say `self.rhb.draw()` and see RHB drawing the idle animation. We
    also want to call the `run` function when we push the *right arrow* and see RHB
    run.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这仍然没有做什么。`RedHatBoy`从未被绘制！我们想要的接口是调用`self.rhb.draw()`并看到RHB绘制空闲动画。我们还想在按下*右箭头*时调用`run`函数，看到RHB奔跑。
- en: 'Let''s start by implementing `draw` on `RedHatBoy`. We''ll create a draw function
    that will mimic the draw function in `WalkTheDog` only using the shared `RedHatBoyContext`
    that''s in `RedHatBoyState`. That code is as follows, written as part of the `impl
    RedHatBoy` block:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`RedHatBoy`上实现`draw`开始。我们将创建一个模拟`WalkTheDog`中绘制函数的绘制函数，只使用`RedHatBoyState`中共享的`RedHatBoyContext`。以下代码是作为`impl
    RedHatBoy`块的一部分编写的：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is nearly identical to the code that exists in the `draw` function already
    for our happily running RHB. Instead of always using the `frame_name` function,
    which doesn't exist yet.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与我们的RHB（RedHatBoy）正在运行的`draw`函数中已有的代码完全相同。我们不需要总是使用还不存在的`frame_name`函数。
- en: 'We''re also getting `position` and `frame` off `context()`, another function
    that doesn''t exist yet. Again, we''ll let the compiler guide us to create both
    of these functions; Compiler-Driven Development strikes again! The `RedHatBoyStateMachine`
    `enum` needs to provide a way to return `RedHatBoyContext` and `frame_name`. We
    can add those implementations, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从`context()`获取`position`和`frame`，另一个还不存在的函数。同样，我们将让编译器引导我们创建这两个函数；编译器驱动开发再次发挥作用！`RedHatBoyStateMachine`
    `enum`需要提供一个返回`RedHatBoyContext`和`frame_name`的方法。我们可以添加以下实现：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I admit I don't love either of these methods and did consider creating a trait
    that the various states would implement as an alternative. After some thought,
    I decided this was simpler, and because the Rust compiler will fail if you don't
    match every single `enum` variant, I'm willing to accept these duplicate *case*
    statements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认我不喜欢这两种方法，曾考虑创建一个特质，让各种状态实现作为替代方案。经过一番思考，我决定这更简单，因为如果你不匹配每个`enum`变体，Rust编译器将会失败，所以我愿意接受这些重复的*case*语句。
- en: The `frame_name` and `context` methods both delegate to the currently active
    `state` to get the data that's required. In the case of `frame_name`, this will
    be a method that returns the name of the animation in `rhb.json` for a given state
    as defined on each state. The `context` method is particularly odd because we
    always return the same field for every single state and always will, as that data
    is shared across all the states. That's going to require a generic implementation,
    which we'll write in a moment. An exercise for you would be to simplify these
    functions with a macro, but we won't do that here.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`frame_name` 和 `context` 方法都委托给当前活动的 `state` 来获取所需的数据。在 `frame_name` 的情况下，这将是一个返回给定状态在
    `rhb.json` 中动画名称的方法，正如在每个状态上定义的那样。`context` 方法尤其奇怪，因为我们总是为每个状态返回相同的字段，并且总是这样，因为该数据在所有状态之间共享。这需要一种泛型实现，我们将在稍后编写。一个练习是使用宏简化这些函数，但在这里我们不会这样做。'
- en: Important Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You might have noticed that the line `self.state_machine.context().position.x`
    violates the `self` should only talk to `state_machine` (its friend) but instead,
    it talks to `position` via `context`. This couples `RedHatBoy` to the internal
    structure of `RedHatBoyContext` in a way that could be avoided by adding getters
    for `position_x` and `position_y` on `state machine`, which would delegate to
    `context`, which would, in turn, delegate to `position`. The Law of Demeter is
    a great guideline when setting values, and you should almost always follow it
    for mutable data, but in this case the data is immutable. We can't change the
    context through this getter, and the downsides of violating the Law of Demeter
    are not as relevant. I don't feel it's necessary to create more delegating functions
    just to avoid violating an arbitrary guideline, but if it becomes a problem, we
    can always change it. For more information on this, go to [https://wiki.c2.com/?LawOfDemeter](https://wiki.c2.com/?LawOfDemeter).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这一行 `self.state_machine.context().position.x` 违反了“self”应该只与 `state_machine`（它的朋友）通信，但相反，它通过
    `context` 与 `position` 通信。这种方式将 `RedHatBoy` 与 `RedHatBoyContext` 的内部结构耦合在一起，这可以通过在
    `state machine` 上添加 `position_x` 和 `position_y` 的获取器来避免，这些获取器将委托给 `context`，而
    `context` 又会委托给 `position`。Demeter 法则是设置值时的一个很好的指导原则，你应该几乎总是遵循它来处理可变数据，但在这个案例中，数据是不可变的。我们无法通过这个获取器更改上下文，违反
    Demeter 法则的缺点并不那么相关。我不认为有必要创建更多的委托函数只是为了避免违反一个任意指南，但如果它成为一个问题，我们总是可以更改它。有关此信息的更多信息，请参阅
    [https://wiki.c2.com/?LawOfDemeter](https://wiki.c2.com/?LawOfDemeter)。
- en: 'Following the compiler again, we''ve moved the errors from the `draw` method
    on `RedHatBoy` into `RedHatBoyStateMachine` because none of the states have methods
    for `frame_name` or `context`. Out of these two methods, `frame_name` is more
    straightforward, so we''ll implement it first. It''s a getter of the name of the
    frame in the `rhb.json` file, and it''s different for every state, so we''ll put
    that method on every state, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次遵循编译器，我们将 `RedHatBoy` 上的 `draw` 方法中的错误移动到了 `RedHatBoyStateMachine` 中，因为没有任何状态有
    `frame_name` 或 `context` 方法。在这两个方法中，`frame_name` 更直接，所以我们将首先实现它。它是一个获取 `rhb.json`
    文件中帧名称的获取器，并且对于每个状态都是不同的，所以我们将把这个方法放在每个状态上，如下所示：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've added two constants, `IDLE_FRAME_NAME` and `RUN_FRAME_NAME`, which correspond
    to the names of the frames for the `Idle` and `Run` sections of our sprite sheets,
    respectively. We then created a new method, `frame_name`, on `RedHatBoyState<Idle>`
    as well as an entirely new implementation for `RedHatBoyState<Running>`, which
    also has a `frame_name` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个常量，`IDLE_FRAME_NAME` 和 `RUN_FRAME_NAME`，分别对应于我们的精灵图集 `Idle` 和 `Run` 部分的帧名称。然后我们在
    `RedHatBoyState<Idle>` 上创建了一个新的方法 `frame_name`，以及一个全新的实现 `RedHatBoyState<Running>`，它也包含一个
    `frame_name` 方法。
- en: It's worth thinking about whether we could use a trait object ([https://bit.ly/3JSyoI9](https://bit.ly/3JSyoI9))
    instead of our `enum` for `RedHatBoyStateMachine`, and it probably is possible.
    I've experimented with it and didn't come to a satisfying solution, but I would
    encourage you to give it a shot. You'll learn a lot more from this book if you
    experiment with the code on your own.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 值得考虑的是，我们是否可以使用特质对象（[https://bit.ly/3JSyoI9](https://bit.ly/3JSyoI9)）而不是我们的
    `enum` 来表示 `RedHatBoyStateMachine`，这可能是可行的。我已经尝试过它，但没有找到令人满意的解决方案，但我鼓励你试一试。如果你自己尝试代码，你会从这本书中学到更多。
- en: 'Now that we''ve handled the `frame_name` method, we''ll want to add a `context`
    method. That method is going to do the same thing for every state, return the
    context, and we can write it generically for all of them, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了 `frame_name` 方法，我们想要添加一个 `context` 方法。这个方法将为每个状态做同样的事情，返回上下文，并且我们可以为它们都写一个通用的，就像这里展示的：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is a pretty cool feature of Rust. Since we have a generic struct, we can
    write methods on the generic type, and it will apply to all the types. Finally,
    there is one more compiler error, in the `draw` function where we reference the
    frame or position fields on context. These fields are private, but as long as
    `RedHatBoyContext` is an immutable type, we can each make of those public, as
    follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Rust 的一项相当酷的特性。由于我们有一个泛型结构体，我们可以在泛型类型上写方法，它将适用于所有类型。最后，还有一个编译器错误，在 `draw`
    函数中引用上下文中的帧或位置字段。这些字段是私有的，但只要 `RedHatBoyContext` 是一个不可变类型，我们就可以将它们公开，如下所示：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we need to call that method on `RedHatBoy` in the `WalkTheDog#draw`
    function. You can add that in this, admittedly awkward, one-liner right at the
    end of the `draw` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在 `WalkTheDog#draw` 函数中调用这个方法。你可以在这个，诚然有些尴尬的一行中添加它，就在 `draw` 函数的末尾：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you''ve followed along successfully, you should see the following screen:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经成功跟上了，你应该会看到以下屏幕：
- en: '![Figure 4.4 – RHBs'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – RHBs'
- en: '](img/Figure_4.04_B17151.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – RHBs](img/Figure_4.04_B17151.jpg)'
- en: Figure 4.4 – RHBs
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – RHBs
- en: At the top we have our old, endlessly running RHB, and at the bottom our new
    RHB just standing still. The new version has fewer features; we've gone backward,
    but why? This prepared us for what we're going to do next, moving him around and
    changing animations. Speaking of animations, the `Idle` version of RHB isn't doing
    anything yet, because `frame` never changes. When RHB is idle, he stands while
    breathing slowly, so let's get that started, shall we?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们有我们旧的、永不停歇的 RHB，而在底部，我们的新 RHB 正在静止不动。新版本功能更少；我们退步了，但为什么？这为我们接下来要做的事情做好了准备，就是移动它并改变动画。说到动画，RHB
    的“空闲”版本目前什么都没做，因为“frame”从未改变。当 RHB 处于空闲状态时，它会缓慢呼吸地站立，所以让我们开始吧，好吗？
- en: Updating RHB
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 RHB
- en: 'Our `RedHatBoy` struct is going to have an `update` function, which will, in
    turn, delegate to an `update` function on the state machine. It''s a new method
    because every state is going to need to update, in order to advance the animation.
    We''ll call `update` on `RedHatBoy` from `update` on `WalkTheDog`. That''s a lot
    of updates, but it''s really just delegation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `RedHatBoy` 结构体将有一个 `update` 函数，它将转而委托给状态机上的 `update` 函数。这是一个新方法，因为每个状态都需要更新，以便推进动画。我们将从
    `WalkTheDog` 的 `update` 中调用 `RedHatBoy` 的 `update`。这有很多更新，但实际上只是委托：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `update` function on `WalkTheDog`, we''ve only added one new line, at
    the end of the `update` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WalkTheDog` 的 `update` 函数中，我们只在 `update` 函数的末尾添加了一行新代码：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's funky because of the fact that `rhb` is `Option`, and we'll fix that in
    a little bit. We've added another small function to the `RedHatBoy` `struct` `update`
    that simply updates `state_machine` via the state machine's `update` function.
    This one line, and others like it, are why the state machine needs to be `Copy`.
    If it's not, then because `update` consumes `self` via the parameter of `mut self`,
    you'd have to use something like `Option` to move `self` into `update`, and then
    reset it again. By making everything `Copy`, you get a much more ergonomic `update`
    function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，因为 `rhb` 是 `Option`，我们稍后会修复这个问题。我们向 `RedHatBoy` `struct` 的 `update` 方法添加了另一个小功能，它只是通过状态机的
    `update` 函数更新 `state_machine`。这一行，以及其他类似的行，是为什么状态机需要是 `Copy` 的原因。如果不是，那么因为 `update`
    通过 `mut self` 参数消耗 `self`，你就必须使用类似 `Option` 的东西将 `self` 移入 `update`，然后再重置它。通过使一切成为
    `Copy`，你将获得一个更加方便的 `update` 函数。
- en: Finally, the meat of the behavior is in the `RedHatBoyStateMachine#update` function.
    Here, we match on `self` and update the current frame on a mutable `state` parameter,
    and then return a new `Idle` state with a moved `context` with an updated frame.
    Unfortunately, this code doesn't compile; `context` isn't a public data member
    so you can't assign it. For now, we'll go ahead and make `context` public, but
    this should bother you. Remember that Law of Demeter guideline I mentioned earlier.
    It's one thing to get an immutable data value, another thing entirely to set a
    mutable value. This is the kind of coupling that could cause real problems down
    the line. We're *not* going to fix it right now, so go ahead and make `context`
    public, but we will be keeping a very close eye on this code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，行为的主体在`RedHatBoyStateMachine#update`函数中。在这里，我们匹配`self`并在可变的`state`参数上更新当前帧，然后返回一个新的`Idle`状态，并带有更新后的帧的移动`context`。不幸的是，这段代码无法编译；`context`不是一个公共数据成员，所以你不能分配它。现在，我们将继续使`context`公共，但你应该感到烦恼。记得我之前提到的Demeter法则。获取不可变数据值是一回事，而设置可变值则是另一回事。这种耦合可能会导致未来的真正问题。我们现在**不会**修复它，所以请继续使`context`公共，但我们将非常密切地关注这段代码。
- en: At this point, if you look at `update` for `WalkTheDog` and `update` for `RedHatBoyStateMachine`,
    you'll see similarities. One is updating the running RHB in the upper left corner,
    and one is updating the idle RHB in the lower left. The time has come to begin
    combining these two objects. Let's go ahead and do that.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你查看`WalkTheDog`的`update`和`RedHatBoyStateMachine`的`update`，你会看到相似之处。一个是更新左上角的奔跑RHB，另一个是更新左下角的空闲RHB。现在是时候开始合并这两个对象了。让我们继续这样做。
- en: Adding the Running state
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加奔跑状态
- en: One thing to keep in mind about states is that they exist whether you implement
    a state machine or not. While we haven't implemented anything in `RedHatBoyState<Running>`,
    the `Running` state currently exists in `WalkTheDog`; RHB is running all around
    the void right now! We just need to move the details into our state machine, so
    that we as programmers can actually see the states and what they do as one coherent
    unit. Plus, then we'll stop having a sad and lonely boy who is running in place
    in the left-hand corner of the screen.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 关于状态，有一点需要记住的是，无论你是否实现状态机，它们都存在。虽然我们还没有在`RedHatBoyState<Running>`中实现任何内容，但`Running`状态目前存在于`WalkTheDog`中；RHB现在正四处奔跑在虚空中！我们只需要将细节移动到我们的状态机中，这样我们作为程序员就可以真正看到状态以及它们作为一个连贯单元所做的事情。此外，我们还将停止有一个在屏幕左下角孤独奔跑的悲伤男孩。
- en: 'We can do that quickly by just modifying `update` in `RedHatBoyStateMachine`
    to match the version in `Idle`, with the different frame count for the run animation.
    That''s shown as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改`RedHatBoyStateMachine`中的`update`函数来快速实现这一点，使其与`Idle`中的版本匹配，只是奔跑动画的帧数不同。如下所示：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, the state machine is theoretically capable of drawing the run animation,
    but we haven't written anything to cause that transition. The other thing missing
    is potentially more subtle. The `Running` animation has `23` frames, and the `Idle`
    animation has `29`. If we were to transform from `Idle` to `Running` with the
    frame count at `24`, the game would crash.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，状态机在理论上能够绘制奔跑动画，但我们还没有编写任何代码来触发这种转换。另外缺少的东西可能更加微妙。`Running`动画有`23`帧，而`Idle`动画有`29`帧。如果我们要在`24`帧时从`Idle`转换到`Running`，游戏就会崩溃。
- en: 'Finally, I think we can all agree that the kind of duplication that we have
    here can be improved. The only difference between the two functions is the frame
    count. So, we have a few things to do:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想我们都可以同意，这里存在的这种重复可以改进。这两个函数之间唯一的区别是帧数。所以，我们有一些事情要做：
- en: Refactor the duplicated code.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构重复的代码。
- en: 'The code that updates `context.frame` suffers from a code smell called `update`
    function is operating over and over again on `context`. Why not move that function
    to `RedHatBoyContext`? That''s shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`context.frame`的代码存在一个名为`update`函数在`context`上重复操作的代码异味。为什么不将这个函数移动到`RedHatBoyContext`中呢？如下所示：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`RedHatBoyContext` now has an `update` function that increments the frame,
    looping it back to `0` when the total frame count is reached. Note how it works
    the same way as our transitions, consuming `self`, and returning a new `RedHatBoyContext`,
    although in reality, it''s the same `instance` the entire time. This gives us
    the same kind of *functional* interface that we''re using elsewhere. The total
    frame count changes with each state, so we pass that in as a parameter, using
    constants for clarity.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedHatBoyContext`现在有一个`update`函数，该函数增加帧数，当总帧数达到时循环回`0`。注意它如何以与我们转换相同的方式工作，消耗`self`，并返回一个新的`RedHatBoyContext`，尽管实际上整个时间都是同一个`instance`。这给了我们与我们在其他地方使用的相同类型的*功能性*接口。总帧数随着每个状态的变化而变化，所以我们将其作为参数传递，使用常量以提高清晰度。'
- en: Fix the Law of Demeter violation.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复Demeter法则违反。
- en: 'Looking at the two arms of each `match` statement, they are nearly identical,
    both mutating `context` in the way we didn''t like earlier. Now is a good time
    to address it, which we can do by making the field private on `RedHatBoyState<S>`
    again, and creating new methods on the respective `RedHatBoy` state implementations,
    as shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 看看每个`match`语句的两边，它们几乎是相同的，都在以我们不喜欢的早期方式修改`context`。现在是解决这个问题的好时机，我们可以通过再次将`RedHatBoyState<S>`的字段设为私有，并在各自的`RedHatBoy`状态实现中创建新方法来实现，如下所示：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There! That's better. `context` is no longer inappropriately public, and each
    individual state handles its own updating. The only difference between them is
    the constant they use, and it's fitting to have that bundled with the implementation
    itself. Speaking of which, make sure you move the `RUNNING_FRAMES` and `IDLE_FRAMES`
    constants into the `red_hat_boy_states` module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！这样更好。`context`不再是不恰当的公共的，每个单独的状态都处理自己的更新。它们之间的唯一区别是它们使用的常量，将它们与实现本身捆绑在一起是很合适的。说到这里，确保将`RUNNING_FRAMES`和`IDLE_FRAMES`常量移动到`red_hat_boy_states`模块中。
- en: 'We''ll need to modify the `update` method on `RedHatBoyStateMachine` to call
    this new method on each of the states:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`RedHatBoyStateMachine`上的`update`方法，以便在每个状态上调用这个新方法：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each of the arms in update now updates the state, and then returns the state.
    There's some duplication here that's a little suspicious; we'll take another look
    at that shortly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`中，每个臂现在都会更新状态，然后返回状态。这里有一些可疑的重复；我们稍后会再次查看。
- en: Move RHB on every `update`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次`update`时移动RHB。
- en: 'If RHB is going to run in the running state, it needs to respect the velocity.
    In other words, update animates the frame, but it doesn''t move, so let''s add
    that to the `RedHatBoyContext` `update` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果RHB要在运行状态下运行，它需要尊重速度。换句话说，更新动画化帧，但不移动，所以让我们将其添加到`RedHatBoyContext`的`update`方法中：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Of course, RHB won't move yet because we aren't changing the velocity. That
    will come soon.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，RHB现在不会移动，因为我们没有改变速度。这很快就会到来。
- en: Ensure that the frame count resets to `0` when transitioning between states.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在状态之间转换时帧计数重置为`0`。
- en: There are two categories of changes on the game object that can happen in our
    state machine. There are changes that happen when the state doesn't change. That's
    what `update` is and right now those are written in `RedHatBoyStateMachine`. There
    are also changes that happen on a transition, and those happen in the transition
    functions that are defined as methods of the type classes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的状态机中，游戏对象可能发生两种类型的更改。有一种是在状态没有变化时发生的更改。这就是`update`所做的工作，目前这些都是在`RedHatBoyStateMachine`中编写的。还有在转换时发生的更改，这些是在定义为类型类方法的转换函数中发生的。
- en: 'We already transitioned from `Idle` to `Running` via the `run` method, and
    we can make sure to reset the frame rate on the transition. That''s a small change
    you can see here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过`run`方法从`Idle`状态转换到`Running`状态，并且我们可以在转换时确保重置帧率。这是一个你可以在这里看到的小改动：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`RedHatBoyContext` has grown a function called `reset_frame`, which resets
    its frame count to `0` and returns itself. By returning itself, we can chain calls
    together, which will come in handy shortly. The `run` method has also evolved
    to call `reset_frame()` on `RedHatBoyContext` and use that new version of `context`
    in the new `RedHatBoyState` struct.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedHatBoyContext`增加了一个名为`reset_frame`的函数，该函数将它的帧计数重置为`0`并返回自身。通过返回自身，我们可以将调用链在一起，这很快就会派上用场。`run`方法也演变为在`RedHatBoyContext`上调用`reset_frame()`并使用新的`context`版本在新的`RedHatBoyState`结构体中。'
- en: Start Running on transition.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在转换时开始运行。
- en: 'Now that we have prevented crashes by restarting animations on transitions,
    let''s start running forward on a transition. This is going to be very short:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过在转换时重新启动动画来防止崩溃，让我们开始在转换时向前跑步。这将非常短：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We've sprouted another method on `RedHatBoyContext` called `run_right`, which
    simply adds forward speed to the velocity. Meanwhile, we've chained a call (see!)
    to `run_right` in the transition. Don't forget to add the `RUNNING_SPEED` constant
    to the module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`RedHatBoyContext`上又增加了一个名为`run_right`的方法，它只是简单地将前进速度添加到速度中。同时，我们在转换中链式调用了`run_right`（看！）方法。别忘了将`RUNNING_SPEED`常量添加到模块中。
- en: Start Running on the *right* arrow.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*右*箭头上开始跑步。
- en: 'Finally, we actually need to call this event when the `ArrowRight` button is
    pressed. At this point, we can follow along with where we''re doing this in the
    `WalkTheDog` implementation:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实际上需要在按下`ArrowRight`按钮时调用这个事件。在这个时候，我们可以跟随在`WalkTheDog`实现中我们正在做这件事的地方：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will now start our RHB running, so much so that he'll run right off the
    screen!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将现在开始我们的RHB跑步，以至于他会直接跑出屏幕！
- en: '![Figure 4.5 – This could be a problem](img/Figure_4.05_B17151.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 这可能是个问题](img/Figure_4.05_B17151.jpg)'
- en: Figure 4.5 – This could be a problem
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 这可能是个问题
- en: 'At this point, we could re-establish *moonwalking*, to bring RHB back on screen,
    but that doesn''t really serve the purpose of the game. You can either create
    an event that resets horizontal velocity every update, just like the current code
    does, or you could track when a key goes up to remove some velocity. The second
    one feels better but will cause us to write a few events and possibly a transition
    from `Running` to `Idle`. No, we''ll go to a third approach: ignore it and hit
    refresh! We don''t need to move backward in our actual game, nor stop, so we won''t.
    Let''s not spend any more time writing code, that we''ll just delete anyway. Speaking
    of that.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以重新建立*月球漫步*，将RHB带回屏幕上，但这并不真正服务于游戏的目的。你可以创建一个事件，每次更新时重置水平速度，就像当前代码所做的那样，或者你可以跟踪当按键抬起时移除一些速度。第二个感觉更好，但将迫使我们编写一些事件，并可能从`Running`状态转换到`Idle`状态。不，我们将采取第三种方法：忽略它并刷新！在我们的实际游戏中，我们不需要向后移动，也不需要停止，所以我们不会这样做。让我们不要花更多的时间编写代码，我们最终会删除它。说到这一点。
- en: Delete the original code.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除原始代码。
- en: 'Now that the new and improved RHB is moving, it''s time to get rid of all the
    references in `WalkTheDog` to the sheet, the element, the frame…basically anything
    that isn''t the `RedHatBoy` `struct`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在新的改进版RHB正在移动，是时候移除`WalkTheDog`中对工作表、元素、框架等的所有引用，基本上是任何不是`RedHatBoy` `struct`的东西：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Rather than boring you with endless deletes, I'll simply say you can delete
    all the fields that aren't `rhb` and follow the compiler errors to delete the
    rest of the code. When you're done, `WalkTheDog` becomes very short, as it should
    be. As for the arrow keys, you only need to worry about the `ArrowRight` key,
    and moving to the right.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是用无休止的删除来让你感到无聊，我简单地说你可以删除所有不是`rhb`的字段，并跟随编译器错误来删除其余的代码。当你完成时，`WalkTheDog`会变得非常短，就像它应该的那样。至于箭头键，你只需要担心`ArrowRight`键，以及向右移动。
- en: Tip
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As I said, we won't be restoring moving backward, up, or down here, but you
    could certainly consider restoring the walking backward functionality by extending
    the state machine. Doing so will help you internalize the lesson here and save
    you the trouble of refreshing all the time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，我们不会在这里恢复向上、向下或向后的移动，但你当然可以考虑通过扩展状态机来恢复向后行走的功能。这样做将帮助你内化这里的教训，并节省你不断刷新的麻烦。
- en: So, now RHB can run across the screen, but that's not much fun. Let's add sliding.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在RHB可以在屏幕上跑步，但这并不有趣。让我们添加滑动。
- en: Transitioning to sliding
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换到滑动
- en: 'Transitioning from running to sliding will involve adding a new state for sliding,
    so that we see the sliding action, but also checking for when a slide is complete
    and transitioning back into the running state. This will mean sliding will have
    its own variation on the `update` function. We can start by adding sliding on
    the *down* arrow and treating it all just like running. We''ll go through this
    quickly because most of it is familiar. Let''s start by adding sliding on the
    *down* arrow in the `update` method of `WalkTheDog`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从跑步到滑动的转换将涉及添加一个新的滑动状态，这样我们就能看到滑动动作，同时检查滑动何时完成并转换回跑步状态。这意味着滑动将在`update`函数上有自己的变体。我们可以从在*下*箭头上添加滑动开始，将其处理得就像跑步一样。我们将快速完成这个过程，因为大部分都是熟悉的。让我们首先在`WalkTheDog`的`update`方法中添加滑动：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It''s time to follow the compiler. RedHatBoy doesn''t have a `slide` method,
    so let''s add that, as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候跟随编译器了。RedHatBoy 没有滑动方法，所以让我们添加它，如下所示：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Transitioning via `Event::Slide` doesn''t exist. There''s no `Event::Slide`
    at all, so let''s add those next:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Event::Slide` 事件进行转换不存在。根本就没有 `Event::Slide`，所以让我们添加这些：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's nothing new in the preceding code block. When RHB is `Running`, it can
    transition to `Sliding` via the `Event::Slide` event and the `slide` method, which
    doesn't exist on the `RedHatBoyState<Running>` typestate. This is all very similar
    to how we went from `Idle` to `Running`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码块中没有新内容。当 RHB 是 `Running` 状态时，它可以通过 `Event::Slide` 事件和 `slide` 方法转换到 `Sliding`
    状态，而 `slide` 方法在 `RedHatBoyState<Running>` 类型状态上不存在。这与其他从 `Idle` 到 `Running` 的转换非常相似。
- en: 'To continue with the compiler, we need to add a `slide` method to the `RedHatBoyState<Running>`
    typestate, as in the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续编译器，我们需要向 `RedHatBoyState<Running>` 类型状态添加一个 `slide` 方法，如下所示：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `slide` method on `RedHatBoyState<Running>` converts the state into `RedHatBoyState<Sliding>`,
    only calling `reset_frame` on `context` to make sure the sliding animation starts
    playing at frame `0`. We also call `into` on the `slide` method, which needs to
    convert `RedHatBoyState<Sliding>` into a `RedHatBoyStateMachine` variant. That
    means we need to create the variant and create a `From` implementation for it,
    as shown here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedHatBoyState<Running>` 上的 `slide` 方法将状态转换为 `RedHatBoyState<Sliding>`，仅在
    `context` 上调用 `reset_frame` 确保滑动动画从帧 `0` 开始播放。我们还在 `slide` 方法上调用 `into`，这意味着我们需要为
    `RedHatBoyState<Sliding>` 创建一个变体，并为其创建一个 `From` 实现，如下所示：'
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At this point, you''ll see errors on the `frame_name`, `context`, and `update`
    methods of `RedHatBoyStateMachine` because their corresponding `match` calls don''t
    have cases for the new `Sliding` variant. We can fix that by adding cases to those
    `match` statements, which will mimic the other cases:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你会在 `RedHatBoyStateMachine` 的 `frame_name`、`context` 和 `update` 方法的错误上看到错误，因为它们对应的
    `match` 调用没有为新的 `Sliding` 变体添加情况。我们可以通过向这些 `match` 语句添加情况来修复这个问题，这将模仿其他情况：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once again, we''ve replaced one compiler error with another. There is no `Sliding`
    state, and it doesn''t have the methods we assumed it would. We can fix that by
    filling it in, adding some constants for good measure:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们用另一个编译器错误替换了一个。没有 `Sliding` 状态，它也没有我们假设它应有的方法。我们可以通过填充它，添加一些常数来修复这个问题：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you look through this code, you''ll see it''s very similar to our already
    existing running code. If you followed along, you''ll see RHB start skidding across
    the floor until he goes past the right edge of the screen:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这段代码，你会发现它与我们的现有运行代码非常相似。如果你一直跟着做，你会看到 RHB 开始在地面上滑动，直到他滑过屏幕的右边缘：
- en: '![Figure 4.6 – Safe'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 安全'
- en: '](img/Figure_4.06_B17151.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 安全](img/Figure_4.06_B17151.jpg)'
- en: Figure 4.6 – Safe
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 安全
- en: 'Stopping RHB from sliding is a little different than what we''ve done before.
    What we need to do is identify when the slide animation is complete, then transition
    right back into running without any user input. We''ll start by checking whether
    the animation is done in the `update` method of the `enum`, which represents our
    machine, and then create a new transition from sliding back into running. We can
    do that by modifying the `RedHatBoyStateMachine` `update` method to check after
    updating in the sliding branch, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止 RHB 滑动与之前我们所做的方法略有不同。我们需要做的是确定滑动动画何时完成，然后立即过渡回运行状态，无需任何用户输入。我们将从检查代表我们的机器的
    `enum` 的 `update` 方法中动画是否完成开始，然后从滑动状态创建一个新的过渡。我们可以通过修改 `RedHatBoyStateMachine`
    的 `update` 方法，在滑动分支更新后进行检查，如下所示：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This doesn't compile yet, because stand isn't defined yet and because `SLIDING_FRAMES`
    is in the `red_hat_boy_states` module. You might think that we can make `SLIDING_FRAMES`
    public and define a `stand` method, or we could move `SLIDING_FRAMES` into the
    `game` module. These will both work but I think it's time to look a little more
    holistically at our `update` method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不能编译，因为 `stand` 还未定义，并且因为 `SLIDING_FRAMES` 在 `red_hat_boy_states` 模块中。你可能认为我们可以将
    `SLIDING_FRAMES` 公开并定义一个 `stand` 方法，或者我们可以将 `SLIDING_FRAMES` 移动到 `game` 模块。这两种方法都可以工作，但我认为现在是时候更全面地查看我们的
    `update` 方法了。
- en: 'Every arm of the `match` statement updates the current state and then returns
    a new state. In the case of `Running` and `Idle`, it was always the same state,
    but in the case of `Sliding`, sometimes it''s the `Running` state. It turns out
    `update` is a transition, just one that sometimes transitions to the state it
    started from. In a state diagram, it looks like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`语句的每一臂都会更新当前状态，然后返回一个新的状态。在`Running`和`Idle`的情况下，总是相同的状态，但在`Sliding`的情况下，有时会是`Running`状态。结果是`update`是一个转换，只是有时会转换回起始状态。在状态图中，它看起来像这样：'
- en: '![Figure 4.7 – Sliding to Running](img/Figure_4.07_B17151.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 从滑动到运行](img/Figure_4.07_B17151.jpg)'
- en: Figure 4.7 – Sliding to Running
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 从滑动到运行
- en: If we wanted to be strict about it, we could say that `Updating` state when
    it gets an **Update** event, then it can transition back to **Sliding** or **Running**.
    This is a case where the state exists, at least conceptually, but we don't actually
    have to create it in our code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对此要严格一些，我们可以说，当`Updating`状态接收到**Update**事件时，它可以转换回**Sliding**或**Running**。这是一个状态至少在概念上存在，但我们实际上不必在我们的代码中创建它。
- en: '`update` on the `Sliding` state is really best modeled as a transition because
    it''s a method that ultimately returns a state. Come to think of it, that''s exactly
    what the other arms in the `update` method are too! Yes, they don''t ever transition
    to another state, but each branch calls `update` and then returns a state. So,
    before we add `Sliding` to the `update` method, let''s refactor to make `update`
    a transition for both of the other states.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sliding`状态上的`update`实际上最好建模为一个转换，因为它是一个最终返回状态的函数。想到这一点，这正是`update`方法中的其他臂所做的事情！是的，它们永远不会转换到另一个状态，但每个分支都会调用`update`然后返回一个状态。所以，在我们将`Sliding`添加到`update`方法之前，让我们重构以使`update`对其他两个状态都是转换。'
- en: 'Since we''re using Compiler-Driven Development, we''ll change the `update`
    method to work as if `update` is already a transition:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用编译器驱动开发，我们将更改`update`方法，使其看起来像`update`已经是一个转换：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With these changes, we''ve turned `Update` into `Event` and added two more
    arms to `match` in the `transition` method. Both of those arms work the same way
    as the other transitions: they call a method on the typestate and then convert
    the state into the `RedHatBoyStateMachine enum` with the `From` trait. The compiler
    error you get now might be a little strange; it looks like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们将`Update`转换为`Event`，并在`transition`方法中为`match`添加了两个额外的臂。这两个臂的工作方式与其他转换相同：它们在类型状态上调用一个方法，然后将状态转换为带有`From`特质的`RedHatBoyStateMachine`枚举。你现在得到的编译器错误可能有点奇怪；它看起来像这样：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You may have expected that the error would say something about the `update`
    method not returning anything, but remember all Rust functions return something;
    they just return `Unit` when they don''t return anything else. So, this error
    is telling you there''s no way to convert from the `()`, or `Unit`, to a value
    of the `RedHatBoyStateMachine` type. That''s not what we want to fix; we want
    to make both of the `update` calls on the states return new states. Those changes
    are next:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能预计错误会提到`update`方法没有返回任何内容，但请记住，所有Rust函数都会返回一些内容；它们只是在没有返回其他内容时返回`Unit`。所以这个错误在告诉你没有方法可以从`()`或`Unit`转换为`RedHatBoyStateMachine`类型的值。这不是我们想要修复的；我们想要使两个状态上的`update`调用都返回新状态。那些更改是下一个：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The changes are small but important. The `update` method for `RedHatBoyState<Idle>`
    and `RedHatBoyState<Running>` both return `Self` now, because even though the
    state doesn't change, these are still typestate methods that return a new state.
    They also take `mut self` now instead of `&mut self`. You can't return `self`
    if you mutably borrow it, so this method stopped compiling. More importantly,
    this means these methods don't make unnecessary copies. They take ownership of
    `self` when called, and then return it. So, if you're worried about an optimization
    problem because of extra copies, you don't have to be.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改很小但很重要。`RedHatBoyState<Idle>`和`RedHatBoyState<Running>`的`update`方法现在都返回`Self`，因为即使状态没有改变，这些仍然是返回新状态的类型状态方法。它们现在也接受`mut
    self`而不是`&mut self`。如果你可变借用它，就不能返回`self`，所以这个方法停止编译。更重要的是，这意味着这些方法不会进行不必要的复制。它们在调用时获取`self`的所有权，然后返回它。所以，如果你担心由于额外的复制而导致的优化问题，你不必担心。
- en: 'Now, we''re down to one compiler error, which we''ve seen before:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只剩下一个编译器错误，我们之前已经见过：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We didn''t implement a conversion from the `Idle` state back to the `RedHatBoyStateMachine
    enum`. That''s similar to the other ones we wrote, implementing `From<RedHatBoyState<Idle>>`,
    as shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有实现从 `Idle` 状态转换回 `RedHatBoyStateMachine enum` 的转换。这与其他我们编写的类似，实现了 `From<RedHatBoyState<Idle>>`，如下所示：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Remember that these implementations of the `From` trait are not in the `red_hat_boy_states`
    module. The `red_hat_boy_states` module knows about the individual states but
    does not know about `RedHatBoyStateMachine`. That's not its job.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些 `From` 特质的实现并不在 `red_hat_boy_states` 模块中。`red_hat_boy_states` 模块了解各个状态，但不知道
    `RedHatBoyStateMachine`。这不是它的职责。
- en: Now that we've refactored the code, our little RHB doesn't slide anymore. Instead,
    he kind of sits down because the `Sliding` state doesn't handle the `Update` event.
    Let's fix that now.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重构了代码，我们的小 RHB 不再滑动。相反，他有点坐下来，因为 `Sliding` 状态没有处理 `Update` 事件。现在让我们修复这个问题。
- en: Transitioning to sliding and back again
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在滑动和返回之间转换
- en: Part of the reason we used the typestate pattern for our individual states is
    so that we get compiler errors when we make a mistake. For instance, if we call
    `run` when we are in the `Running` state, it won't even compile because there
    is no such method. There is one place this doesn't hold, the `transition` method
    on the `RedHatBoyStateMachine` `enum`. If you call `transition` with a `RedHatBoyStateMachine`
    variant and an `Event` variant pair that don't have a match, it returns `Self`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类型状态模式为我们的各个状态的一部分原因是为了在出错时得到编译器错误。例如，如果我们处于 `Running` 状态时调用 `run`，它甚至无法编译，因为没有这样的方法。有一个地方这个规则不适用，那就是
    `RedHatBoyStateMachine` `enum` 上的 `transition` 方法。如果你用一个 `RedHatBoyStateMachine`
    变体和一个没有匹配的 `Event` 变体对调用 `transition`，它将返回 `Self`。
- en: That's why our RHB is sitting down. He transitions to `Sliding` and then stops
    updating, staying in the same state forever. We'll fix that by adding the match
    for the `Update` event and then, you guessed it, follow the compiler to implement
    the sliding animation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，我们的 RHB 才会坐着。他过渡到 `Sliding` 状态，然后停止更新，永远停留在同一个状态。我们将通过添加对 `Update`
    事件的匹配来解决这个问题，然后，正如你所猜到的，跟随编译器来实现滑动动画。
- en: 'This starts by adding the match to the transition method, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从添加到转换方法开始的，如下所示：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This match is just like the others; we match on `Sliding` and `Update` and
    call `update`. Just like before, we''ll get an error:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个匹配就像其他匹配一样；我们在 `Sliding` 和 `Update` 上进行匹配并调用 `update`。就像之前一样，我们会得到一个错误：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Sliding` state still has an update method that doesn't return a state.
    That's not going to work with our current setup, but it's not as simple as making
    the `update` method return `Self`, as on the other two states.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sliding` 状态仍然有一个更新方法，该方法不会返回一个状态。这在我们当前的设置中是不可行的，但并不像在其他两个状态中那样简单，只需让 `update`
    方法返回 `Self`。'
- en: 'Remember, there are two possible states that can come from the `update` method
    on `Sliding`: `Sliding` and `Running`. How is that going to work with our current
    setup? What we''ll need to do is have `update` return an `SlidingEndState` `enum`
    that can be either `Sliding` or `Running`, and then we''ll implement a `From`
    trait that will convert that into the appropriate variant of `RedHatBoyStateMachine`.
    That''s odd to explain, so let''s see it in action. We can modify the `update`
    method on `RedHatBoyState<Sliding>` to work like the one we proposed at the beginning
    of this section:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，从 `Sliding` 状态的 `update` 方法可以返回两种可能的状态：`Sliding` 和 `Running`。这如何与我们的当前设置相匹配？我们需要做的是让
    `update` 返回一个 `SlidingEndState` `enum`，它可以要么是 `Sliding`，要么是 `Running`，然后我们将实现一个
    `From` 特质，将这个转换成 `RedHatBoyStateMachine` 的适当变体。这很难解释，所以让我们看看它是如何工作的。我们可以修改 `RedHatBoyState<Sliding>`
    上的 `update` 方法，使其像本节开头所提出的：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''ve taken the code that we originally considered putting in the `RedHatBoyStateMachine`
    `update` method and moved it into the `update` method of `RedHatBoyState<Sliding>`.
    This makes sense conceptually; the state should know how it behaves. On every
    update, we update `context`, and then check whether the animation is complete,
    with `if self.context.frame >= SLIDING_FRAMES`. If the animation is complete,
    we return one variant of this new `enum` that doesn''t exist yet: `SlidingState`.
    The `SlidingState` variant can either be `Complete` or `Sliding`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将原本考虑放入 `RedHatBoyStateMachine` 的 `update` 方法中的代码移动到了 `RedHatBoyState<Sliding>`
    的 `update` 方法中。从概念上讲，这是有道理的；状态应该知道自己的行为。在每次更新时，我们更新 `context`，然后检查动画是否完成，使用 `if
    self.context.frame >= SLIDING_FRAMES`。如果动画完成，我们将返回这个新 `enum` 的一个变体，而这个变体目前还不存在：`SlidingState`。`SlidingState`
    变体可以是 `Complete` 或 `Sliding`。
- en: Important Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It's definitely a little strange that the `update` method doesn't return another
    state here, and probably means we aren't using a *pure* typestate method. An alternative
    might have been to return the next `Event` from `update` and send that back into
    a call to the `transition` method on `RedHatBoyStateMachine`. That implementation
    ends up looking very strange because states are returning `Events` that are only
    used by `RedHatBoyStateMachine` and are otherwise unreferenced in the `red_hat_boy_states`
    module. Regardless of whether the strange return value of `update` makes you uncomfortable,
    I would encourage you to try other approaches. Maybe yours is better than mine!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 确实有点奇怪，这里的`update`方法没有返回另一个状态，可能意味着我们并没有使用一个*纯*状态类型方法。一个替代方案可能是从`update`返回下一个`Event`，并将其发送回`RedHatBoyStateMachine`上的`transition`方法的调用。这种实现最终看起来非常奇怪，因为状态返回的`Events`只被`RedHatBoyStateMachine`使用，在`red_hat_boy_states`模块中其他地方没有引用。不管`update`返回的奇怪值让你有多不舒服，我都鼓励你尝试其他方法。也许你的方法比我的更好！
- en: 'Following the compiler yet again, we have two obvious problems: there is no
    `stand` method and there is no `SlidingEndState` `enum`. We can handle both of
    these right here, next to the code we just wrote, as shown:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 再次跟随编译器，我们有两个明显的问题：没有`stand`方法，也没有`SlidingEndState` `enum`。我们可以在我们刚刚编写的代码旁边处理这两个问题，如下所示：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The only side effect of the transition to `Running` is that we call `reset_frame`
    again on `context`. Remember this has to be done on every transition, otherwise,
    the program can try to animate the new state with `frame`, which isn't valid and
    will crash. So, we'll reset the frame back to `0` on every transition.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 转换到`Running`的唯一副作用是我们再次在`context`上调用`reset_frame`。记住，这必须在每次转换时都做，否则程序可能会尝试用`frame`来动画化新状态，这是无效的，会导致崩溃。所以，我们将在每次转换时将帧重置回`0`。
- en: 'This leaves us with a compiler error to fix once again. This time, it''s the
    following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这又让我们遇到了一个需要修复的编译器错误。这次，它是这样的：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Pay close attention to that source trait. It''s not coming from one of the
    states but from the intermediate `SlidingEndState`. We''ll solve it the same way
    as before, with a `From` trait, but we''ll need to use a `match` statement to
    pull it out of the `enum`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细注意那个源特质。它不是来自任何一个状态，而是来自中间的`SlidingEndState`。我们将像之前一样解决这个问题，使用`From`特质，但我们需要使用`match`语句从`enum`中提取它：
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we match on `end_state` to get the actual `State` out of `enum`, and then
    call `into` on that state again to get to `RedHatBoyStateMachine`. A little boilerplate,
    but it makes it easier to do the conversion.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过`end_state`进行匹配，从`enum`中获取实际的`State`，然后再次调用该状态的`into`方法以到达`RedHatBoyStateMachine`。虽然有点模板化，但这样做使得转换更容易。
- en: 'And now we have it! Run the game now and you''ll see RHB take a short slide
    and pop back up again to the running state. Now that we''ve added three animations,
    it''s time to deal with these ugly lines in the `WalkTheDog` implementation: `self.rhb.as_mut().unwrap().slide()`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了它！现在运行游戏，你会看到RHB短暂地滑行然后又弹回到跑步状态。现在我们已经添加了三个动画，是时候处理`WalkTheDog`实现中的这些丑陋的线条了：`self.rhb.as_mut().unwrap().slide()`。
- en: We treat `rhb` as an `Option` type, not because it's ever really going to be
    `None`, but because we don't have it yet before the `WalkTheDog` `struct` is initialized.
    After `WalkTheDog` is initialized, `rhb` can never be `None` again because the
    state of the system has changed. Fortunately, we now have a tool for dealing with
    that, the good old state machine!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`rhb`视为`Option`类型，并不是因为它真的会变成`None`，而是因为我们还没有在`WalkTheDog``struct`初始化之前拥有它。一旦`WalkTheDog`初始化，`rhb`就再也不会是`None`了，因为系统的状态已经改变。幸运的是，我们现在有一个工具来处理这个问题，那就是我们熟悉的状态机！
- en: Every little thing I think I see
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我看到的每一件小事
- en: '`WalkTheDog` can be in two states, `Loading` or `Loaded`, after it''s initialized.
    Fortunately, we accounted for this when we wrote our `GameLoop`. Remember that
    `GameLoop` returns `Result<Game>` from `initialize`; we''re just currently always
    returning `Ok(WalkTheDog)`. What if we made `WalkTheDog` an `enum` and returned
    a different state of our game instead? That would mean `WalkTheDog` would be a
    state machine, with two states, and `initialize` would become the transition!
    That''s exactly what we''re going to do. Modify `WalkTheDog` so it is no longer
    a `struct` but an `enum`, as shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`WalkTheDog`可以处于两种状态，`Loading`或`Loaded`，在初始化之后。幸运的是，我们在编写我们的`GameLoop`时已经考虑到了这一点。记住`GameLoop`从`initialize`返回`Result<Game>`；我们目前总是返回`Ok(WalkTheDog)`。如果我们让`WalkTheDog`成为一个枚举并返回我们游戏的不同状态会怎样？这意味着`WalkTheDog`将是一个状态机，有两个状态，而`initialize`将成为转换！这正是我们要做的。将`WalkTheDog`修改为不再是`struct`而是枚举，如下所示：'
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is great; now everything is broken! Whoops! We''ll need to adjust the
    `WalkTheDog` implementation to account for the two variants. First, we''ll change
    the `initialize` function on `WalkTheDog`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了；现在一切都坏了！哎呀！我们需要调整`WalkTheDog`的实现来考虑两种变体。首先，我们将更改`WalkTheDog`上的`initialize`函数：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Remember in [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*, where we made this function return `Game`? This was why!
    In order to ensure `initialize` is only called once, `initialize` has to match
    `self` on its variants, and if we call `initialize` twice, we''ll return an error
    via `anyhow!`. Otherwise, everything inside the `Loading` branch is the same as
    before, except we return `WalkTheDog::Loaded` instead of `WalkTheDog`. This does
    cause a compiler warning, which will become an error in future versions of Rust
    because `RedHatBoy` isn''t public but is exposed in a public type. To get rid
    of that warning, you''ll need to make `RedHatBoy` public, and that''s fine; go
    ahead and do that. We also need to change the `new` constructor to reflect the
    new type, as shown here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[*第3章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)中，*创建游戏循环*，我们让这个函数返回`Game`？这就是原因！为了确保`initialize`只调用一次，`initialize`必须在它的变体上匹配`self`，如果我们调用`initialize`两次，我们将通过`anyhow!`返回一个错误。否则，`Loading`分支内部的所有内容都与之前相同，只是我们返回`WalkTheDog::Loaded`而不是`WalkTheDog`。这确实会导致编译器警告，在Rust的未来版本中这将成为一个错误，因为`RedHatBoy`不是公开的，但它被公开类型暴露。为了消除这个警告，你需要将`RedHatBoy`公开，这是可以的；继续这样做。我们还需要更改`new`构造函数，以反映新的类型，如下所示：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `WalkTheDog` `enum` starts in `Loading`, nothing fancy there. The `update`
    and `draw` functions now both need to reflect the changing states; you can see
    those changes here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`WalkTheDog`枚举在初始化后开始于`Loading`，这里没有什么特别之处。现在`update`和`draw`函数都需要反映变化的状态；你可以在这里看到这些变化：'
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You could argue this isn't really a change on the `Option` type, as we still
    need to check the state of `Game` each time we operate on `rhb`, and that's true,
    but I think this more clearly reveals the intent of the system. It also has the
    benefit of getting rid of the `as_ref`, `as_mut` code, which is often confusing.
    Now that we've cleaned up that code, let's add one more animation to RHB. Let's
    see this boy jump!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以争论这并不是对`Option`类型的真正改变，因为我们每次操作`rhb`时仍然需要检查`Game`的状态，这是真的，但我认为这更清楚地揭示了系统的意图。这也带来了好处，可以消除`as_ref`、`as_mut`代码，这些代码通常很令人困惑。现在我们已经清理了那段代码，让我们给RHB添加一个额外的动画。让我们看看这个男孩跳起来吧！
- en: Transitioning to jumping
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换到跳跃
- en: 'Going through each and every change yet again for the jump is redundant. Instead,
    I can recommend you make the following change:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 再次逐个检查跳跃的每个变化是多余的。相反，我可以推荐你进行以下更改：
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You should be able to follow the compiler errors all the way through, creating
    a transition from `Running` to `Jumping`. You can also look up the constant values
    you need directly out of `rhb.json`. The number of frames is the number of images
    in `Jump` in the animation multiplied by `3`, and subtracting `1`, and the name
    of the animation is `Jump`. Make sure you handle the `update` event in the transition
    method for `Jumping`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够跟踪编译器错误，从`rhb.json`中直接查找所需的常量值。帧数是动画中`Jump`中的图像数量乘以`3`，然后减去`1`，动画的名称是`Jump`。确保你在`Jumping`的转换方法中处理`update`事件。
- en: 'Do all that and you see RHB skidding across the ground, doing a kind of dance:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 做完所有这些，你会看到RHB在地面上打滑，做一种舞蹈般的动作：
- en: '![Figure 4.8 – That''s...not jumping](img/Figure_4.08_B17151.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 那不是跳跃](img/Figure_4.08_B17151.jpg)'
- en: Figure 4.8 – That's...not jumping
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 那不是跳跃
- en: Tip
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you get stuck, the answers to this are available at [https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/).
    However, I strongly recommend trying to do this without checking first. Look at
    what we did for the first three transitions and try to understand what we did.
    Even if you get stuck, the time spent practicing is valuable here.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你卡住了，这些答案可以在[https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/)找到。然而，我强烈建议在查看答案之前先尝试解决这个问题。看看我们为前三个过渡做了什么，并尝试理解我们做了什么。即使你卡住了，这里练习所花费的时间也是宝贵的。
- en: If you've correctly implemented the code for transitioning to the jumping state,
    our RHB will play his jumping animation, forever, while skidding across the ground.
    We've seen this before with the slide state, so it's time to figure out what's
    different about jumping. Of course, we know exactly what's different about jumping
    – you go up! Well, at least a little.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经正确实现了代码以过渡到跳跃状态，我们的RHB将永远播放他的跳跃动画，同时在地面滑行。我们之前在滑行状态中见过这种情况，所以现在是时候弄清楚跳跃有什么不同了。当然，我们知道跳跃有什么不同——你会向上跳！嗯，至少有一点。
- en: 'There are three things we need to do. First, we give RHB vertical velocity
    when he jumps; second, we need to add gravity so that RHB will actually come down
    when he jumps. And finally, we need to transition running when we land, using
    our ever-durable state machine:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做三件事。首先，当RHB跳跃时，我们给他赋予垂直速度；其次，我们需要添加重力，这样RHB在跳跃时才会真正落下。最后，我们着陆时需要过渡到奔跑状态，使用我们永远耐用的状态机：
- en: Going up on `Jump`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Jump`上向上跳。
- en: 'Take a moment and think, where does this belong? Should it go in the `update`
    function, the `jump` event, or maybe in the `enum` implementation? No, this is
    a transition change because it happens on `jump`, and it belongs in the `jump`
    method on the `Running` type class. You should already have a transition from
    running to jumping, so let''s update that function to add vertical velocity:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 休息一下，思考一下，这应该放在哪里？应该放在`update`函数中，还是`jump`事件中，或者可能在`enum`实现中？不，这是一个过渡变化，因为它发生在`jump`事件上，它属于`Running`类型类的`jump`方法。你应该已经有了从奔跑到跳跃的过渡，所以让我们更新这个函数以添加垂直速度：
- en: '[PRE59]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Remember in our 2D coordinate system, `y` is `0` at the top, so we need a negative
    velocity to go up. It also resets the frame so that the jump animation starts
    at frame `0`. The implementation in `RedHatBoyContext` is using the same pattern
    of accepting `mut self` and returning a new `RedHatBoyContext`. Now, if you let
    the app refresh, RHB will take off like Superman!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 记住在我们二维坐标系中，`y`在顶部是`0`，所以我们需要一个负速度才能向上跳。它还会重置帧，使跳跃动画从帧`0`开始。`RedHatBoyContext`中的实现使用了接受`mut
    self`并返回一个新的`RedHatBoyContext`的相同模式。现在，如果你让应用刷新，RHB将像超人一样起飞！
- en: Adding gravity.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加重力。
- en: 'In order to have a natural jump, we''ll apply gravity on every update. We''ll
    do this *regardless of state* because later, we''ll need to have RHB fall off
    of platforms and cliffs, and we don''t want to have to constantly pick and choose
    when we''re applying gravity. This will go in the `update` function of `RedHatBoyContext`,
    right at the top:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使跳跃更自然，我们将在每次更新时应用重力。我们将*无论状态如何*都这样做，因为稍后我们需要让RHB从平台和悬崖上掉下来，我们不想每次都要不断选择何时应用重力。这将在`RedHatBoyContext`的`update`函数中实现，就在顶部：
- en: '[PRE60]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you refresh the page right now, you'll get a blink-and-you'll-miss-it problem,
    and you'll probably be greeted with a blank screen. The screen isn't really blank;
    RHB just fell right through the ground!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在刷新页面，你会遇到一个一闪而过的问题，你可能会看到一个空白的屏幕。屏幕其实并不空白；RHB直接穿过了地面！
- en: '![Figure 4.9 – Tell my family I love them](img/Figure_4.09_B17151.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 告诉我的家人我爱他们](img/Figure_4.09_B17151.jpg)'
- en: Figure 4.9 – Tell my family I love them
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 告诉我的家人我爱他们
- en: We'll need to address this with our first case of **collision resolution**.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用我们的第一个案例来处理**碰撞解决**。
- en: Landing on the ground.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着陆地面。
- en: 'This is a bit of a spoiler for the next chapter, but collision detection happens
    in two steps. The first is detection, finding places where things collide, and
    the second is resolution, where you do something about the collision. Since there
    isn''t anything to collide with in RHB''s empty void, we can just do a simple
    check in the same `update` function to see whether his new position is past the
    floor and update the position back to the floor. Keep in mind, you do this *after*
    you update to a new position:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对下一章的一点点剧透，但碰撞检测分为两个步骤。第一步是检测，找到物体碰撞的地方，第二步是解决，处理碰撞。由于RHB的空旷空间中没有东西可以碰撞，我们可以在同一个`update`函数中简单地检查他的新位置是否超过了地板，并将位置更新回地板。记住，你是在更新到新位置之后做这个操作的：
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This may feel redundant, but we can't know gravity pulled RHB past the ground
    without actually calculating where he ends up, and we don't draw the in-between
    state, so the performance cost is minimal. This change prevents RHB from falling
    through the ground and causes a nice jumping arc, but he keeps performing the
    jumping animation for eternity. We need to change the state from `Jumping` back
    to `Running`, and we need to make that decision in `RedHatBoyStateMachine` because
    it's a conditional state change based on a condition just like the one that transitioned
    from `Sliding` to `Running`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉有些多余，但我们无法知道重力是否将RHB拉过了地面，除非我们实际计算他最终的位置，而且我们没有绘制中间状态，所以性能成本最小。这个更改防止了RHB穿过地面，并产生了一个漂亮的跳跃弧线，但他会一直执行跳跃动画。我们需要将状态从`Jumping`变回`Running`，并且我们需要在`RedHatBoyStateMachine`中做出这个决定，因为它是一个基于条件的状态改变，就像从`Sliding`过渡到`Running`的那个一样。
- en: 'That''s a change to the state machine, much like the one we did for `Sliding`,
    as seen here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是状态机的更改，就像我们为`Sliding`所做的更改一样，如下所示：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'So, if the position is on the floor, we need to transition to `Running` via
    the `stand` method, only we can''t! We never wrote a transition from `Sliding`
    to `Running`, just the other way around. We also never wrote a `JumpingEndState`
    enum, or a way to convert out of it via `From`. So, right now, you should see
    several compiler errors about all of that, the first being the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果位置在地板上，我们需要通过`stand`方法过渡到`Running`状态，但我们不能！我们从未编写过从`Sliding`到`Running`的转换，只有相反的转换。我们也从未编写过`JumpingEndState`枚举，或者通过`From`转换出去的方法。所以，现在你应该会看到关于所有这些的几个编译器错误，第一个如下所示：
- en: '[PRE63]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There''s the compiler error, but there''s no `land` method. So, go write it.
    *I''m serious: go write it yourself. I''m not going to reproduce it here*. You
    can go ahead and follow along with the previous methods we wrote and implement
    them. You can do it; I believe in you. When you do, you''ll have a clean animation
    from `Idle` to `Running`, then `Jumping`, and back to `Running` again. Then, you''ll
    wander off the screen because we don''t have a full scene yet, but we''re getting
    there!'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有编译器错误，但没有`land`方法。所以，去写它。*我是认真的：自己去写。我不会在这里重现它*。你可以继续跟随我们之前编写的代码和方法来实现它们。你可以做到的；我相信你。当你这样做的时候，你将会有一个从`Idle`到`Running`，然后到`Jumping`，再回到`Running`的干净动画。然后，你会离开屏幕，因为我们还没有一个完整的场景，但我们正在朝着这个目标前进！
- en: Important Note
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you get stumped, you can always check the source code for this chapter in
    the repository at [https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到难题，你总是可以检查在[https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/)仓库中该章节的源代码。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered one topic, but one of the most important topics in game
    development. State machines are everywhere in games, which we saw when we implemented
    a small one to manage the `Loaded` and `Loading` states of the `WalkTheDog` `enum`
    itself. They are a particularly nice way to implement animation states that must
    correspond with what the player is doing, and Rust has great ways to implement
    this pattern. We used two: the simple one for `WalkTheDog`, and the much more
    complex `RedHatBoyStateMachine` that uses the typestate pattern. The typestate
    pattern is a commonly used pattern in Rust, both inside and outside of game development,
    so you can expect to see it in many Rust projects.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了一个主题，但它是游戏开发中最重要的话题之一。状态机在游戏中无处不在，我们在实现一个小的状态机来管理`WalkTheDog` `enum`的`Loaded`和`Loading`状态时已经看到了这一点。它们是实现必须与玩家行为相对应的动画状态的一种特别好的方式，而Rust有很好的方法来实现这种模式。我们使用了两种：简单的用于`WalkTheDog`，以及更复杂的`RedHatBoyStateMachine`，它使用了类型状态模式。类型状态模式是Rust中常用的一种模式，无论是在游戏开发内部还是外部，你都可以期待在许多Rust项目中看到它。
- en: We also used the compiler to drive development, over and over again. It's an
    incredibly useful technique, where you can start with what you want the code to
    look like and use the compiler's error messages to help you fill in the rest of
    the implementation. The code becomes like a paint by numbers picture, where you
    use higher-level code to draw the lines and the compiler error messages tell you
    how to fill them in. Rust has very good compiler error messages, getting better
    with every release, and it will pay huge dividends for you to pay close attention
    to them.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还多次使用编译器来驱动开发。这是一种极其有用的技术，你可以从你希望代码看起来像什么开始，并使用编译器的错误信息来帮助你完成其余的实现。代码就像是一个数字画，你使用高级代码来画线，编译器的错误信息告诉你如何填充它们。Rust有非常好的编译器错误信息，并且随着每个版本的发布而变得越来越好，密切关注它们将为你带来巨大的回报。
- en: Now that our RHB can run and jump, how about he runs and jumps on something?
    We'll put him in a scene and have him jump on it in the next chapter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让RHB能够跑和跳了，那么他跑和跳在什么东西上呢？我们将在下一章把他放入一个场景，并让他跳到上面。
