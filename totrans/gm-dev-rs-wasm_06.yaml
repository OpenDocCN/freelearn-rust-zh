- en: '*Chapter 4*: Managing Animations with State Machines'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：使用状态机管理动画'
- en: In the last chapter, we created a minimal game *engine*, allowing for moving
    our main character around and playing a simple animation, but it's far from full-featured.
    There's no world to navigate, the only animation that plays is running, and **Red
    Hat Boy** (**RHB**) doesn't respond to any physics. At this point, if we wanted
    to retitle our game, it would be called *Red Hat Boy and the Empty Void*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个最小化的游戏*引擎*，允许我们移动主要角色并播放简单的动画，但它远非功能齐全。没有可以导航的世界，唯一播放的动画是跑步，**红帽男孩**（**RHB**）对任何物理都不做出反应。在这个时候，如果我们想重新命名我们的游戏，它将被称为*红帽男孩和空旷的虚空*。
- en: While that might be a fun title, it wouldn't make for a fun game. Ultimately,
    we'll want RHB to chase his dog through a forest with platforms to jump on and
    slide under, and to do that we'll need to make sure he slides, jumps, and runs.
    We'll also need to make sure that he looks, acts, and behaves differently when
    he does those things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能是一个有趣的名字，但它不会让游戏变得有趣。最终，我们希望RHB在森林中追逐他的狗，那里有可以跳跃的平台和可以滑过的障碍，为了做到这一点，我们需要确保他可以滑动、跳跃和跑步。我们还需要确保他在做这些事情时看起来、表现和表现不同。
- en: In this chapter, we're going to introduce a common game development pattern
    to manage all that, the state machine, implemented in `if` statements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一种常见的游戏开发模式来管理所有这些，即状态机，通过`if`语句实现。
- en: 'We''re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Introducing state machines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍状态机
- en: Managing animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理动画
- en: Adding states to walk the dog
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为遛狗添加状态
- en: '`Idle`, `Running`, `Sliding`, and `Jumping` animations'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`空闲`, `运行`, `滑动`, 和 `跳跃` 动画'
- en: By the end of the chapter, you will be able to use state machines to cleanly
    transition between animations while always playing the correct one.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用状态机在动画之间干净地切换，同时始终播放正确的动画。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no new crates or other technical requirements in this chapter. The
    source code for this chapter is available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中没有新的crate或其他技术要求。本章的源代码可在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4)找到。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/35sk3TC](https://bit.ly/35sk3TC)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://bit.ly/35sk3TC](https://bit.ly/35sk3TC)
- en: Introducing state machines
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍状态机
- en: 'Games, web applications, heck, even cryptocurrency miners, have to manage the
    *state* of the system. After all, if the system isn''t doing something right now,
    if it doesn''t have a current state, then it''s not running, is it? The state
    is also fractal. In our game, we have a state of `playing`, and another one of
    `game over`. Once we add menu items, we''ll have even more states. Meanwhile,
    our RHB also has states: he''s running, sliding, jumping, dying, and dead. Let''s
    say unconscious, that''s less dark.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏、Web应用程序，甚至是加密货币矿工，都必须管理系统的*状态*。毕竟，如果系统现在没有做正确的事情，如果没有当前状态，那么它不是在运行，对吗？状态也是分形的。在我们的游戏中，我们有`playing`状态和`game
    over`状态。一旦我们添加菜单项，我们将有更多的状态。同时，我们的RHB也有状态：他在跑步、滑动、跳跃、死亡和死亡。让我们说昏迷，这比黑暗要好一些。
- en: 'The point is our game is doing a lot of things and is maintaining a large game
    state with a lot of mini-states inside it. As the application moves from one state
    to another, the rules of the system change. For example, when RHB is running,
    the *spacebar* might make him jump, but when he''s jumping, hitting the *spacebar*
    doesn''t do anything. The rule is you can''t jump when you''re already jumping.
    One way you can maintain that state is through a large structure with a bunch
    of values or Booleans, such as `jumping = true`, and in a Rust program, you might
    store that in an enumerated type like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是我们的游戏正在做很多事情，并且维护着一个包含许多子状态的大型游戏状态。当应用程序从一个状态移动到另一个状态时，系统的规则会改变。例如，当RHB在跑步时，空格键可能会让他跳跃，但当他正在跳跃时，按下空格键不会做任何事情。规则是你不能在已经跳跃时跳跃。你可以通过一个包含许多值或布尔值的大型结构来维持这种状态，例如`jumping
    = true`，在Rust程序中，你可能像这样将其存储在枚举类型中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This works reasonably well in small programs but for larger programs, there
    are two things that you'll want to manage. The first, which I've already hinted
    at, is that there may be rules about going between states. Maybe you can't go
    right from `Jumping` to `Sliding`, but an `enum` doesn't prevent that. The second
    is that, in addition to the rules being different for each state, frequently things
    happen on the *transitions* between states, things such as playing a sound effect
    or updating a score; for that, you need a state machine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这在小程序中效果相当不错，但对于更大的程序，有两件事你需要管理。第一，我已经暗示过了，可能存在关于状态之间转换的规则。也许你不能直接从 `Jumping`
    转换到 `Sliding`，但 `enum` 无法阻止这一点。第二是，除了每个状态的规则不同之外，经常在状态之间的 *转换* 发生事情，比如播放音效或更新分数；为此，你需要一个状态机。
- en: Defining a state machine
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义状态机
- en: 'Perhaps the most confusing thing about state machines is the naming, as there
    are state machines, finite state machines, the state pattern, and more, all of
    which frequently get used interchangeably by programmers. So, for the sake of
    clarity, let''s define them this way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于状态机，最令人困惑的事情可能是命名，因为存在状态机、有限状态机、状态模式等等，所有这些通常被程序员交替使用。因此，为了清晰起见，让我们这样定义它们：
- en: '**State machines**: A model of the state of a system, represented by a list
    of states and the transitions between them'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态机**：一个系统状态的模型，表示为一系列状态及其之间的转换'
- en: '`trait` object, which you can find here: [https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html](https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html).
    It''s quite good but is not idiomatic Rust, and we won''t be using it.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trait` 对象，您可以在以下链接中找到：[https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html](https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html)。它相当不错，但不是
    Rust 的惯用语法，我们不会使用它。'
- en: 'The state machine both helps us keep a mental model of the system in our heads
    and prevents us from making foolish mistakes in code, such as playing the running
    animation while RHB is jumping. The drawback, of course, is that you need to understand
    state machines, so let''s get that covered. We''ll use RHB as our example. RHB
    can be **Running**, **Idle**, **Jumping**, **Sliding**, **Falling**, or **KnockedOut**.
    We can use a state **transition table** to list those:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机既帮助我们保持对系统在头脑中的心理模型，又防止我们在代码中犯愚蠢的错误，例如当 RHB 跳跃时播放跑步动画。当然，缺点是你需要理解状态机，所以让我们来解决这个问题。我们将使用
    RHB 作为我们的例子。RHB 可以是 **Running**、**Idle**、**Jumping**、**Sliding**、**Falling** 或
    **KnockedOut**。我们可以使用状态 **转换表** 来列出这些：
- en: '![](img/Table_4.1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![表格](img/Table_4.1.jpg)'
- en: The transition table only has three columns for now, which are a start state,
    the event that causes a transition, and the state it transitions to. Events differ
    from transitions in that events are what happens to the system to *cause* a transition,
    but transitions are what happens *during* the state change.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 转换表目前只有三列，分别是起始状态、引起转换的事件以及转换到的状态。事件与转换的不同之处在于，事件是导致系统发生转换的原因，而转换是在状态变化期间发生的事情。
- en: 'It''s a subtle difference, and sometimes it gets used interchangeably because
    the names will frequently be the same. Let''s work through a state transition
    to clarify this. RHB starts in the `Idle` state, where he stands in place with
    an `run`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微妙的不同之处，有时它会被交替使用，因为名称通常会相同。让我们通过一个状态转换来澄清这一点。RHB 从 `Idle` 状态开始，在那里他站立并
    `run`：
- en: '![](img/Table_4.2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![表格](img/Table_4.2.jpg)'
- en: 'When moving to `Running`, we actually do something on the transition. Specifically,
    we start moving to the right; we increase the velocity in `x`. You can name this
    transition in the table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动到 `Running` 状态时，我们在转换过程中实际上做了一些事情。具体来说，我们开始向右移动；在 `x` 方向上增加速度。你可以在表中命名这个转换：
- en: '![](img/Table_4.3.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![表格](img/Table_4.3.jpg)'
- en: While this is correct, often we don't bother naming the transitions and the
    events because they become redundant. While we could continue adding to this table,
    we can also model a state machine with several types of diagrams. I'm partial
    to simple circles and lines, where the circles are the states and the lines are
    the transitions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是正确的，但通常我们不会费心命名转换和事件，因为它们变得冗余。虽然我们可以继续添加到这个表中，但我们也可以用几种类型的图来模拟状态机。我偏爱简单的圆圈和线条，其中圆圈是状态，线条是转换。
- en: '![Figure 4.1 – A state machine diagram'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 状态机图'
- en: '](img/Figure_4.01_B17151.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.01_B17151.jpg)'
- en: Figure 4.1 – A state machine diagram
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 状态机图
- en: This diagram is a fleshed-out version of the previous table, with all of the
    entries completed. It starts at the **Idle** state and transitions to the **Running**
    state via the **Run** event. From there, it can go in several directions. If the
    player *slides*, it can go into the **Sliding** state; if the player *jumps*,
    it can go into the **Jumping** state. Both of those eventually return to the **Running**
    state when sliding or jumping is over. **Running**, **Sliding**, and **Jumping**
    can all transition into the **Falling** state when they crash into something.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表是之前表格的详细版本，所有条目都已填写。它从**Idle**状态开始，通过**Run**事件过渡到**Running**状态。从那里，它可以有几个方向。如果玩家**滑动**，它可以进入**Sliding**状态；如果玩家**跳跃**，它可以进入**Jumping**状态。这两种状态最终都会在滑动或跳跃结束后返回到**Running**状态。**Running**、**Sliding**和**Jumping**都可以在撞到东西时过渡到**Falling**状态。
- en: This does result in a lot of transitions across the middle of the diagram. Finally,
    the **Falling** state transitions into the **KnockedOut** state when **Falling**
    is over, via the **End** event. If you're familiar with this type of diagram,
    you might point out that I could have used a *superstate* to contain **Running**,
    **Jumping**, and **Sliding** and used one event to transition all of those to
    **Falling**. You'd be right, but we won't need to concern ourselves with that
    for our implementation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实导致图表中间有很多转换。最后，当**下落**结束时，**Falling**状态通过**End**事件过渡到**KnockedOut**状态。如果你熟悉这种类型的图表，你可能会指出，我本可以使用**超状态**来包含**Running**、**Jumping**和**Sliding**，并使用一个事件将所有这些转换到**Falling**。你是对的，但我们就不会在我们的实现中关注这一点了。
- en: You might be asking, what's the benefit of all this? Does this really fit the
    *minimal architecture* that we covered in the last chapter? Answering the second
    question first, the answer is, uh…maybe? I find that state machines help me keep
    code together that belongs together, rather than sprinkling `match` statements
    throughout my code base as I might have to when using a simple `enum`. That doesn't
    mean we won't have those `match` statements; they'll just be in one place.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，所有这些有什么好处？这真的符合我们在上一章中提到的**最小架构**吗？首先回答第二个问题，答案是，嗯……也许？我发现状态机帮助我把属于一起的代码放在一起，而不是像使用简单的`enum`时那样在我的代码库中散布`match`语句。这并不意味着我们不会使用那些`match`语句；它们只是会集中在一个地方。
- en: I also find it fits my mental model of how code works well, and it helps prevent
    errors because you simply *can't* perform an action that's invalid because it's
    not available for that given state. Frankly, the state machine exists whether
    or not we model it, and it's cleaner if we can also model it in code rather than
    having it emerge accidentally. So, those are the benefits, and that's why I think
    it fits in our minimal architecture. Now it's time to implement it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我还发现它符合我对代码工作方式的思维模型，并且它有助于防止错误，因为你**根本无法**执行一个无效的操作，因为这个操作在那个特定状态下不可用。坦白说，状态机无论我们是否对其进行建模都存在，如果我们能够在代码中对其进行建模，而不是让它意外出现，那么它会更干净。所以，这些都是好处，这就是为什么我认为它适合我们的最小架构。现在，是时候实现它了。
- en: Implementing with types
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型实现
- en: 'The **Object-Oriented** (**OO**) state pattern is typically implemented as
    a variation on the strategy pattern, where you swap out different objects that
    all implement the same state interface at runtime based on the various transitions.
    The diagram looks something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象**（**OO**）状态模式通常作为策略模式的一种变体来实现，其中在运行时根据各种转换替换实现相同状态接口的不同对象。图表看起来大致如下：'
- en: '![Figure 4.2 – State pattern](img/Figure_4.02_B17151.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 状态模式](img/Figure_4.02_B17151.jpg)'
- en: Figure 4.2 – State pattern
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 状态模式
- en: In the OO version of the pattern, `enum`, which we can use to enumerate the
    states in a clearer fashion than traditional objects. The second is **generic
    types**, which we'll use to model each state as a **typestate**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式的面向对象（OO）版本中，`enum`，我们可以用它以比传统对象更清晰的方式枚举状态。第二个是**泛型类型**，我们将用它来将每个状态建模为**类型状态**。
- en: Important Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The original state machine implementation I wrote was largely based on this
    excellent article by Ana Hobden, a.k.a. Hoverbear, at [https://hoverbear.org/blog/rust-state-machine-pattern/](https://hoverbear.org/blog/rust-state-machine-pattern/).
    While this book no longer uses that pattern, I encourage you to read it for an
    alternative approach.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初编写的原始状态机实现主要基于Ana Hobden（又名Hoverbear）这篇优秀的文章，她在[https://hoverbear.org/blog/rust-state-machine-pattern/](https://hoverbear.org/blog/rust-state-machine-pattern/)上发表了这篇文章。虽然这本书不再使用该模式，但我鼓励你阅读它以获取另一种方法。
- en: The typestate pattern
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型状态模式
- en: '**Typestate** is a fancy name for embedding the state of an object in its type.
    The way it works is that you have a generic structure with one generic parameter
    representing the state. Then, each state will have methods that can return new
    states. So, instead of each state having common methods, as they do, as shown
    in *Figure 4.2*, each state has its own methods that return the new state. The
    states in *Figure 4.2* might look something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型状态**是将对象的状态嵌入其类型中的高级名称。它的工作方式是，你有一个具有一个泛型参数的泛型结构，该参数表示状态。然后，每个状态都将有可以返回新状态的方法。因此，与它们在*图4.2*中所示的情况一样，每个状态都有自己的方法来返回新状态。*图4.2*中的状态可能看起来像这样：'
- en: '![Figure 4.3 – Typestate pattern](img/Figure_4.03_B17151.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 类型状态模式](img/Figure_4.03_B17151.jpg)'
- en: Figure 4.3 – Typestate pattern
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 类型状态模式
- en: In this diagram, `State<GenericStateOne>` has a `next` method, which consumes
    `self` and returns `State<GenericStateTwo>`. Meanwhile, `State<GenericStateTwo>`
    only has an `update` method, which takes a mutably borrowed `self`. The implications
    of this are that the compiler will catch you if you try to call `next` on `State<GenericStateTwo>`.
    In the traditional OO pattern, all states must handle all the same methods because
    they share an interface, so this kind of defense isn't possible. Often, this means
    implementing methods you don't actually care about, and either returning an error
    state or `Self`, and then debugging at runtime.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`State<GenericStateOne>`有一个`next`方法，它消耗`self`并返回`State<GenericStateTwo>`。同时，`State<GenericStateTwo>`只有一个`update`方法，它接受一个可变借用`self`。这意味着如果你尝试在`State<GenericStateTwo>`上调用`next`，编译器会捕获你。在传统的OO模式中，所有状态都必须处理所有相同的方法，因为它们共享一个接口，所以这种防御是不可能的。通常，这意味着实现你实际上不关心的方法，然后返回一个错误状态或`Self`，并在运行时进行调试。
- en: In addition, we can use the `mod` keyword and Rust's rules about privacy to
    make it impossible to create any state in an invalid state. We can make it impossible
    to move from `GenericStateOne` to `GenericStateTwo` without calling `next` by
    keeping the internals of `State` private so you can't just construct it. This
    is called **making illegal states unrepresentable**, and it's a great way to make
    sure you don't make mistakes in your programs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用`mod`关键字和Rust的隐私规则来确保无法创建任何无效状态。我们可以通过保持`State`的内部私有，使其无法直接构造，来确保无法从`GenericStateOne`移动到`GenericStateTwo`而不调用`next`方法。这被称为**使非法状态不可表示**，这是一种确保你不会在程序中犯错的绝佳方法。
- en: Important Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I tracked down the *making illegal states unrepresentable* phrasing to Yaron
    Minsky ([https://blog.janestreet.com/effective-ml-revisited/](https://blog.janestreet.com/effective-ml-revisited/));
    however, it's quite likely the practice and phrasing are older than that.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我追踪到“使非法状态不可表示”的表述是来自Yaron Minsky ([https://blog.janestreet.com/effective-ml-revisited/](https://blog.janestreet.com/effective-ml-revisited/))；然而，这种做法和表述很可能比那还要早。
- en: Typestates are intimidating because they are both a new concept and new jargon,
    so don't worry if you feel a little confused.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类型状态可能会让人感到害怕，因为它们既是一个新概念，也是新术语，所以如果你感到有点困惑，请不要担心。
- en: Tip
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: There's a lot of great information on typestates in Rust. There's an excellent
    talk by Will Crichton from Strange Loop (https://youtu.be/bnnacleqg6k?t=2015),
    as well as blogs at [https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm](https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm)
    and [http://cliffle.com/blog/rust-typestate/](http://cliffle.com/blog/rust-typestate/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中关于类型状态有很多很好的信息。有一个来自Strange Loop的Will Crichton的精彩演讲（https://youtu.be/bnnacleqg6k?t=2015），以及[https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm](https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm)和[http://cliffle.com/blog/rust-typestate/](http://cliffle.com/blog/rust-typestate/)上的博客。
- en: 'If you want to forget all about generics and type theory for a minute, they
    can be summarized as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要暂时忘记所有关于泛型和类型理论的知识，它们可以总结如下：
- en: Each state of the object is represented by a separate struct.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的每个状态都由一个单独的结构体表示。
- en: You can only advance from one state to another by methods on that struct.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能通过该结构体上的方法从一个状态推进到另一个状态。
- en: You can guarantee you can only create valid states using privacy rules.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用隐私规则保证只能创建有效的状态。
- en: The rest are just details.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是细节。
- en: Finally, we're going to need an `enum` to *hold* our typestate. Each state is
    generic, so to continue in our preceding example, any struct that will interact
    with our state machine will need to hold *either* `State<GenericStateOne>` or
    `State<GenericStateTwo>`. In order to do that, we would either need to make the
    containing `struct` generic as well, and then create new versions of the containing
    `struct` every time the state changes, or wrap the generic object in an `enum`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个 `enum` 来 *持有* 我们的类型状态。每个状态都是泛型的，所以继续我们之前的例子，任何将与我们的状态机交互的结构体都需要持有
    *要么* `State<GenericStateOne>` 或 `State<GenericStateTwo>`。为了做到这一点，我们可能需要将包含的结构体也做成泛型的，然后每次状态改变时都创建包含结构体的新版本，或者将泛型对象包裹在一个
    `enum` 中。
- en: We'll use an `enum` because it prevents the generic nature of the typestate
    from propagating throughout the program, allowing the typestate to be an implementation
    detail. We're going to write the kind of state machine that Rust is very good
    at. Let's get to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `enum`，因为它阻止了类型状态的泛型性质在整个程序中传播，使得类型状态成为一个实现细节。我们将编写 Rust 非常擅长的那种状态机。让我们开始吧。
- en: Managing animation
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理动画
- en: We'll create our state machine to manage the different animations. Specifically,
    when RHB isn't moving, he's `Idle`, but when he's moving, he's `Running`. When
    he jumps, he's `Jumping`. You get the idea.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建状态机来管理不同的动画。具体来说，当 RHB 不在移动时，它是 `Idle` 状态，但当它在移动时，它是 `Running` 状态。当他跳跃时，他是
    `Jumping` 状态。你明白这个意思。
- en: Those different RHB states correspond to the different animations managed using
    a state machine. We'll first create the RHB with a state machine and then integrate
    it into our current application. We'll implement this *top-down*, starting with
    a struct that represents RHB and letting the compiler errors drive further development.
    This is sometimes called **Compiler-Driven Development** although it's not a formalized
    approach such as **Test-Driven Development**. It can work extremely well in a
    language with a robust type system and great compiler errors, such as Rust. Let's
    start with how we'll represent RHB.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的 RHB 状态对应于使用状态机管理的不同动画。我们首先创建带有状态机的 RHB，然后将其集成到我们的当前应用程序中。我们将从代表 RHB 的结构体开始，让编译器错误驱动进一步的开发。这有时被称为
    **编译器驱动开发**，尽管它不是一个正式的方法，如 **测试驱动开发**。它可以在具有强大类型系统和优秀编译器错误的语言中工作得非常好，如 Rust。让我们从如何表示
    RHB 开始。
- en: 'The `RedHatBoy` struct will contain the state machine, the sprite sheet, and
    the image because eventually, it will draw itself:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedHatBoy` 结构体将包含状态机、精灵表和图像，因为最终它将自行绘制：'
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: All of this code belongs in the `game` module. That means you can put it in
    the `game.rs` file or if you so choose, put it in a separate file and bring it
    into the `game` module with the `mod` keyword. I'll leave that up to you.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码都属于 `game` 模块。这意味着你可以将它放在 `game.rs` 文件中，或者如果你愿意，可以将其放在一个单独的文件中，并使用 `mod`
    关键字将其引入 `game` 模块。我会把这个决定留给你。
- en: 'Of course, this won''t work because you haven''t created the state machine
    yet. You do have the `Sheet` structure from [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*. Let''s create `RedHatBoyStateMachine`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不会工作，因为你还没有创建状态机。你确实有来自 [*第3章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)
    的 `Sheet` 结构体，*创建游戏循环*。让我们创建 `RedHatBoyStateMachine`：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Seeing the `enum` we discussed earlier, it might still be unclear why we''re
    using it when we''ll be creating all of these typestate structures. `RedHatBoyState`,
    which doesn''t exist yet, is a generic type that contains another type, where
    those types represent the various states. So, why the redundant `enum`? Because
    we want to be able to switch easily between the states without using the heap
    or dynamic dispatch. Let''s imagine we defined the `RedHatBoy` struct in the following
    way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们之前讨论的 `enum`，可能仍然不清楚为什么我们要使用它，因为我们将会创建所有这些类型状态结构。还不存在的 `RedHatBoyState`
    是一个包含另一个类型的泛型类型，其中这些类型代表各种状态。那么，为什么还需要冗余的 `enum`？因为我们希望能够在不使用堆或动态分派的情况下轻松地在状态之间切换。让我们想象我们以以下方式定义了
    `RedHatBoy` 结构体：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now the state is fixed to a state. We could, of course, define things in the
    following way:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在状态被固定到一个状态。当然，我们可以用以下方式定义：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But of course, now `RedHatBoy` has to also be a generic type. You can make this
    work without the `enum` using `Box<dyn State>`, but that's not very ergonomic
    and it would require implementing the same methods on every state, so we'll stick
    with the `enum`. I have to acknowledge that I don't like the stutter in the types
    such as `*Idle*(RedHatBoyState<*Idle*>)`, but we'll see that the `enum` wrapper
    becomes extremely useful as we implement the state machine. Make sure that the
    `enum` is `Copy,Clone` as well, for reasons you'll see shortly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当然，现在`RedHatBoy`也必须是一个泛型类型。你可以使用`Box<dyn State>`而不使用`enum`来使这可行，但这不是很方便，并且需要在每个状态上实现相同的方法，所以我们将坚持使用`enum`。我必须承认我不喜欢类型中的这种重复，比如`*Idle*(RedHatBoyState<*Idle*>)`，但我们会看到，随着状态机的实现，`enum`包装器变得极其有用。确保`enum`也是`Copy,Clone`，原因你很快就会看到。
- en: Important Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you''re interested, *The Rust Programming Language* has a chapter that describes
    how to implement a state pattern in a traditional OO way. Interestingly, they
    eventually abandon it in favor of using an `enum`. You can find that here: [https://bit.ly/3hBsVd4](https://bit.ly/3hBsVd4).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个感兴趣，*《Rust编程语言》*有一章描述了如何以传统的面向对象方式实现状态模式。有趣的是，他们最终放弃了它，转而使用`enum`。你可以在这里找到：[https://bit.ly/3hBsVd4](https://bit.ly/3hBsVd4)。
- en: 'Of course, this code still doesn''t compile, because we haven''t created either
    of those states or the `RedHatBoyState` `x`. This is what I meant by Compiler-Driven
    Development. We can start by creating `RedHatBoyState`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码仍然无法编译，因为我们还没有创建那些状态，也没有创建`RedHatBoyState` `x`。这就是我所说的编译器驱动开发。我们可以从创建`RedHatBoyState`开始：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All the code relating to the individual states will go in its own module, `red_hat_boy_states`,
    so that we can only make public the methods required by the rest of the `game`
    module. This will make it impossible to accidentally create a state without using
    the methods provided, and therefore, impossible to accidentally make an invalid
    transition. The only way to transition from `RedHatBoyState<Idle>` to `RedHatBoyState<Running>`
    is going to be through the methods on `RedHatBoyState<Idle>`. It's important that
    both `RedHatBoyState` and `RedHatBoyContext` are public but their members are
    private, so we can use them as intended.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与单个状态相关的代码都将放入其自己的模块`red_hat_boy_states`中，这样我们就可以只公开`game`模块其余部分所需的方法。这将使得意外创建一个状态而不使用提供的方法变得不可能，因此，不可能意外地执行无效的转换。从`RedHatBoyState<Idle>`转换到`RedHatBoyState<Running>`的唯一方法将通过`RedHatBoyState<Idle>`上的方法来实现。重要的是`RedHatBoyState`和`RedHatBoyContext`都是公开的，但它们的成员是私有的，这样我们就可以按预期使用它们。
- en: 'Inside the new module, `RedHatBoyState` is a simple generic type that contains
    `_state`, which is never read, hence the underscore, and `RedHatBoyContext`. Now,
    `RedHatBoyContext` is a structure with data that''s common to all the states.
    In this case, that''s the frame being rendered, the position, and the velocity.
    We''ll need it so that the state transitions can modify the state of RHB. Putting
    all of this in the `red_hat_boy_states` module means that we haven''t changed
    the compiler error message. We need to import that module into the `game` module
    with `use self::red_hat_boy_states::*;`, which you can add anywhere in the `game`
    module. This gets us partway there, but if we look at the following compiler output,
    we''re still not finished:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在新模块中，`RedHatBoyState`是一个简单的泛型类型，它包含`_state`，这个字段永远不会被读取，因此使用了下划线，以及`RedHatBoyContext`。现在，`RedHatBoyContext`是一个包含所有状态共有数据的结构。在这种情况下，那就是正在渲染的帧、位置和速度。我们需要它以便状态转换可以修改RHB的状态。将所有这些放入`red_hat_boy_states`模块意味着我们没有改变编译器错误信息。我们需要将那个模块导入到`game`模块中，使用`use
    self::red_hat_boy_states::*;`，你可以在`game`模块的任何地方添加它。这让我们前进了一步，但如果我们查看下面的编译器输出，我们还没有完成：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s also a corresponding `enum` variant for `Running(RedHatBoyState<Running>)`.
    Both `Idle` and `Running` don''t exist. We can create both of these easily, with
    empty structures inside the `red_hat_boy_states` module. Note that both of these
    must also be `Clone`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Running(RedHatBoyState<Running>)`也有相应的`enum`变体。`Idle`和`Running`这两个状态都不存在。我们可以在`red_hat_boy_states`模块内部轻松创建这两个状态，注意这两个也必须是`Clone`：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Transitioning between states
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态之间的转换
- en: 'Congratulations! You''ve created two states for RHB. This achieves…nothing.
    There''s a bit missing. For starters, we can''t transition from `Idle` to `Running`,
    and those states don''t actually do anything when they aren''t transitioning.
    Let''s take care of a transition right now. We''ll add a method on `RedHatBoyState<Idle>`
    to go from `Idle` to `Running`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您为RHB创建了两个状态。但这...什么也没做。还有一些东西缺失。首先，我们不能从`Idle`状态转换到`Running`状态，而且当它们不在转换过程中时，这些状态实际上并不做任何事情。让我们现在处理一个转换。我们将在`RedHatBoyState<Idle>`上添加一个方法，从`Idle`状态转换到`Running`状态：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is the transition from `Idle` to `Running`, and the `run` method is where
    the magic happens. This is just a function that takes a `RedHatBoy<Idle>` state
    and converts it to a `RedHatBoy<Running>` state, and for now, doesn't change any
    `RedHatBoyContext` data. You might wonder then, what magic?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从`Idle`状态到`Running`状态的转换，而`run`方法就是魔法发生的地方。这只是一个函数，它接受一个`RedHatBoy<Idle>`状态并将其转换为`RedHatBoy<Running>`状态，目前它不会改变任何`RedHatBoyContext`数据。那么，你可能想知道，这有什么魔法？
- en: This means that to transition from `Idle` to `Running`, you can use `run`, but
    it also means you can't transition from `Running` back into `Idle`, and that makes
    sense because the game doesn't allow that behavior. The function also takes `mut
    self`, so that when it's called, it consumes the current state. This means that
    if you want to somehow keep `Idle` around after transitioning to `Running`, you
    have to clone it, and if you do that, you probably really meant to do it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着要从`Idle`状态转换到`Running`状态，你可以使用`run`，但也意味着你不能从`Running`状态转换回`Idle`状态，这是有道理的，因为游戏不允许这种行为。该函数还接受`mut
    self`，这意味着当它被调用时，它会消耗当前状态。这意味着如果你想在转换到`Running`状态后保留`Idle`状态，你必须克隆它，如果你这样做，你很可能真的想这么做。
- en: You also can't create the `Running` state directly, because its data members
    are private, which means you can't just create that state by mistake. You can't
    create the `Idle` state either, and that's a problem because it's the start state.
    We'll address that in a moment, but first, let's dive into how we'll interact
    with the states through our state machine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不能直接创建`Running`状态，因为它的数据成员是私有的，这意味着你不能不小心创建那个状态。你也不能创建`Idle`状态，这是一个问题，因为它是起始状态。我们稍后会解决这个问题，但首先，让我们深入了解我们将如何通过状态机与状态交互。
- en: Managing the state machine
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理状态机
- en: 'Initially, we might be tempted to implement our state machine by adding methods
    on the `RedHatBoyStateMachine` `enum`, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们可能会倾向于通过在`RedHatBoyStateMachine` `enum`上添加方法来实现我们的状态机，如下所示：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This isn't terrible, but it means that every method on our state machine will
    likely need to match the current variant of the `RedHatBoyStateMachine` `enum`.
    Then, it would return the new variant based on either the transition or `self`
    when the transition isn't currently valid. In other words, while the compiler
    will error if we call `run` on the `Running` state, it won't error if we call
    `run` on `RedHatBoyStateMachine` when the current variant is `Running`. This kind
    of error, where we call `run` by mistake on the wrong state, is exactly what we're
    trying to get away from with our typestates. We'd go to all the trouble of writing
    these typestates only to immediately throw away one of the benefits in every method
    on the `RedHatBoyStateMachine` `enum`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不糟糕，但这意味着我们的状态机上的每个方法都可能需要匹配`RedHatBoyStateMachine` `enum`的当前变体。然后，它将根据转换或`self`返回新的变体，当转换当前无效时。换句话说，虽然如果我们对`Running`状态调用`run`，编译器会报错，但如果我们对当前变体为`Running`的`RedHatBoyStateMachine`调用`run`，编译器不会报错。这种错误，即错误地在不正确的状态上调用`run`，正是我们试图通过类型状态避免的。我们费尽心思编写这些类型状态，只是为了在每个`RedHatBoyStateMachine`
    `enum`的方法上立即放弃其中的一个好处。
- en: 'Unfortunately, we can''t completely get away from that problem, because we
    are using an `enum` to contain our states. There''s no way to implement methods
    on variants of an `enum` as we can with generic structures, and if we''re going
    to wrap the state in an `enum`, we''ll have to match on the variant. What we can
    do is *reduce* the surface area of that kind of error by reducing the number of
    methods that operate in the states. Specifically, instead of calling `run` on
    the `enum`, we''ll create a `transition` function that takes `Event`. That is
    going to look like the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法完全摆脱这个问题，因为我们正在使用`enum`来包含我们的状态。我们无法像使用泛型结构那样在`enum`的变体上实现方法，如果我们打算用`enum`包装状态，我们就必须匹配变体。我们可以做的是通过减少在状态中操作的方法数量来减少这种错误的可能性。具体来说，我们不会在`enum`上调用`run`，而是创建一个接受`Event`的`transition`函数。这看起来像以下代码：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've solved the problem caused by the `enum` with another `enum`! This is very
    *Rusty* of us. In this case, we've created an `enum` named `Event` to represent
    every event that could happen to our machine and replaced the method named `run`
    with a method named `transition`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用另一个`enum`解决了`enum`引起的问题！这非常*Rusty*。在这种情况下，我们创建了一个名为`Event`的`enum`来表示可能发生在我们机器上的每一个事件，并用名为`transition`的方法替换了名为`run`的方法。
- en: So, instead of many small methods for run, jump, and similar, we will have one
    method named `transition` and a bunch of `Event` variants. How does this improve
    things? Because there is only one `match` statement that we have to update when
    we want to add a transition, instead of potentially adding multiple little `match`
    statements. Keep in mind that this function takes `mut` `self`, which means calling
    `transition` will consume `self` and return a new `RedHatBoyStateMachine` just
    as the `run` method does on `RedHatBoyState<Idle>`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会有很多小的方法，如run、jump等，我们将有一个名为`transition`的方法和许多`Event`变体。这如何改进事情？因为当我们想要添加转换时，我们只需要更新一个`match`语句，而不是可能添加多个小的`match`语句。记住，这个函数接受`mut
    self`，这意味着调用`transition`将消耗`self`并返回一个新的`RedHatBoyStateMachine`，就像`run`方法在`RedHatBoyState<Idle>`上做的那样。
- en: Using Into for clean code
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Into编写整洁的代码
- en: We can actually improve the ergonomics of this method using the `From` trait.
    If you're unfamiliar, the `From` trait is a Rust feature that lets us define how
    to convert from one type to another. Implementing the `From` trait on your type
    will also implement the `Into` trait, which will provide an `into` method that
    will make it easy to convert from one type to another.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以使用`From`特质来改进这个方法的易用性。如果你不熟悉，`From`特质是Rust的一个特性，它允许我们定义如何从一个类型转换为另一个类型。在你的类型上实现`From`特质也会实现`Into`特质，这将提供一个`into`方法，使得类型之间的转换变得容易。
- en: 'We know that if we have `RedHatBoyState<Running>`, it will convert into the
    `RedHatBoyStateMachine::Running` variant, and if we write the conversion by implementing
    the `From` trait, we will be able to replace that wrapping with a call to `into`.
    That was a lot of words for a little bit of code, so the following is what the
    implementation of the `From` trait looks like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，如果我们有`RedHatBoyState<Running>`，它将转换为`RedHatBoyStateMachine::Running`变体，如果我们通过实现`From`特质来编写转换，我们将能够用`into`调用替换包装。这虽然说了很多话，但代码却很少，所以以下就是`From`特质的实现样子：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This can be placed right under the implementation of `RedHatBoyStateMachine`.
    It defines how to convert from `RedHatBoy<Running>` to `RedHatBoyStateMachine`,
    and it''s the same small amount of code we wrote in the `transition` method. Because
    we have this now, we can make that method a little more succinct, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以放在`RedHatBoyStateMachine`实现下方。它定义了如何从`RedHatBoy<Running>`转换为`RedHatBoyStateMachine`，并且这与我们在`transition`方法中编写的少量代码相同。因为我们现在有了这个，我们可以使那个方法更加简洁，如下所示：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Replacing calls like `RedHatBoyStateMachine::Idle::Running(state.run)` with
    `into` isn't just prettier and more concise; it also means that if `run` changes
    to return a different state, the `transition` method can stay the same, as long
    as a `From` trait has been written to go from the state to the `RedHatBoyStateMachine`
    `enum`. It's a nice little change that makes our code more flexible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将`RedHatBoyStateMachine::Idle::Running(state.run)`这样的调用替换为`into`不仅更美观、更简洁；它还意味着如果`run`改变为返回不同的状态，只要有一个从状态到`RedHatBoyStateMachine`
    `enum`的`From`特质被编写，`transition`方法就可以保持不变。这是一个使我们的代码更加灵活的小改动。
- en: It's a little odd that the `RedHatBoyStateMachine` `enum` is what we call our
    state machine because we don't normally associate enumerated types with behavior,
    but this method is why we call it a machine. We use `enum` to hold the various
    generic states, and we use the ability to add methods to an `enum` to make it
    a lot more ergonomic to use. The various states know how to transition from one
    state to another, and the machine knows when to do the transitions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有点奇怪的是，我们称之为状态机的`RedHatBoyStateMachine` `enum`是因为我们通常不会将枚举类型与行为相关联，但这个方法就是为什么我们称之为机器。我们使用`enum`来持有各种泛型状态，我们使用向`enum`添加方法的能力来使其使用起来更加方便。各种状态知道如何从一个状态转换到另一个状态，机器知道何时进行转换。
- en: Integrating the state machine
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成状态机
- en: Now that we've built a state machine, albeit one with two states, we need to
    actually use it for something. Recall our current game, let RHB run throughout
    a meaningless void. We're going to want to change it so that RHB starts in the
    left corner and begins running when the user hits the *right arrow key*. In other
    words, they will transition from `Idle` to `Running`. When that happens, we'll
    also want to make sure we're showing the appropriate animation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by putting `RedHatBoy` in the `WalkTheDog` game:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'RHB will need to be an `Option` for now because `RedHatBoy` contains a sprite
    sheet. Since the sprite sheet isn''t available until the image is loaded in `initialize`,
    we have to make `rhb` an `Option` type. We''ll want to initialize the machine
    in the `initialize` function, and for that purpose, we''ll want to create a convenient
    `new` method for the `Idle` state:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because `Idle` is the initial state, it's the only state that will get a `new`
    function, as mentioned earlier. We've also introduced a constant called `FLOOR`
    that marks the bottom of the screen, where RHB will land when he jumps.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll show it here as if it''s defined right at the top of the `red_hat_boy_states`
    module. Now, in `Game` `initialize`, we still have a compiler error because we
    haven''t set up `RedHatBoy` in the game. We can do that right after we''ve loaded
    the sprite sheet, and we''ll keep two copies of the sprite sheet around; not because
    we want two copies, but because we''ll delete all the old code when we''ve successfully
    replaced it with the new code. You can see the changes here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We had to change a surprising amount of code here, because of Rust''s borrowing
    rules. Our intent is to `clone` `sheet` and `image` and send those into the `RedHatBoy::new`
    method. However, if we do that, we also need to clone `image` and `sheet` when
    setting the fields for `image` and `sheet` on `WalkTheDogStruct`. Why? Because
    the `image: image` line is a move, and can''t be accessed after that. That''s
    the borrow after move error. Instead we clone `image` and sheet and move the cloned
    instances into WalkTheDog. Then when creating the RedHatBoy we clone them again.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for `sheet`. We also have to explicitly call out the type of `sheet`
    when we assign it in the first place because the compiler can't infer the type
    anymore. Fortunately, this is an intermediate step; we are working past the compiler
    errors and will eventually reduce this code to what we actually need. We can't
    yet because we've replaced one compiler error with two!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Before, the `rhb` field wasn't filled in when we created `WalkTheDog`, so that
    didn't compile. In order to set the `rhb` field to something, we are presuming
    a `RedHatBoy::new` method exists, but it doesn't, so that doesn't compile. We
    are also passing the soon-to-exist constructor clones of `sheet` and `image`.
    The `Sheet` type doesn't support `clone` yet, so that doesn't compile either.
    We'll need to fix both of these compiler errors to move forward.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, I want to note how we use the `ok_or_else` construct on
    each `clone` call, and then the `?` operator. `RedHatBoy` doesn't need to hold
    `Option<Sheet>` or `Option<HtmlImageElement>`, so its constructor will take `Sheet`
    and `HtmlImageElement`. Calling `ok_or_else` will convert `Option` into `Result`,
    and `?` will return from the `initialize` method with `Error` if the value isn't
    present. This prevents the rest of the code from having to continually validate
    that the `Option` type is present, so the code will be a little bit cleaner. The
    `Option` type is great, but at any time you can replace working with an `Option`
    type with the actual value it's wrapping.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest of the two compiler errors to fix is the fact that `sheet` doesn''t
    implement `clone`. Many in the Rust community derive `Clone` on any public type,
    and while I won''t be following that practice in this book, there''s no reason
    not to add it to `Sheet` and the types it references, as shown here. Remember,
    `Sheet` is in the `engine` module:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we''re down to one compiler error, `RedHatBoy` doesn''t have a `new` function,
    so let''s create an `impl` block for the `RedHatBoy` struct and define that, as
    shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This creates a new `RedHatBoy` with a state machine in the `Idle` state. We've
    also loaded `sprite_sheet` and `image` in the `initialize` function and passed
    them to this constructor. Congratulations! Our code compiles!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Drawing RedHatBoy
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, this still doesn't do much. `RedHatBoy` is never drawn! The interface
    we want is to say `self.rhb.draw()` and see RHB drawing the idle animation. We
    also want to call the `run` function when we push the *right arrow* and see RHB
    run.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing `draw` on `RedHatBoy`. We''ll create a draw function
    that will mimic the draw function in `WalkTheDog` only using the shared `RedHatBoyContext`
    that''s in `RedHatBoyState`. That code is as follows, written as part of the `impl
    RedHatBoy` block:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is nearly identical to the code that exists in the `draw` function already
    for our happily running RHB. Instead of always using the `frame_name` function,
    which doesn't exist yet.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also getting `position` and `frame` off `context()`, another function
    that doesn''t exist yet. Again, we''ll let the compiler guide us to create both
    of these functions; Compiler-Driven Development strikes again! The `RedHatBoyStateMachine`
    `enum` needs to provide a way to return `RedHatBoyContext` and `frame_name`. We
    can add those implementations, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I admit I don't love either of these methods and did consider creating a trait
    that the various states would implement as an alternative. After some thought,
    I decided this was simpler, and because the Rust compiler will fail if you don't
    match every single `enum` variant, I'm willing to accept these duplicate *case*
    statements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The `frame_name` and `context` methods both delegate to the currently active
    `state` to get the data that's required. In the case of `frame_name`, this will
    be a method that returns the name of the animation in `rhb.json` for a given state
    as defined on each state. The `context` method is particularly odd because we
    always return the same field for every single state and always will, as that data
    is shared across all the states. That's going to require a generic implementation,
    which we'll write in a moment. An exercise for you would be to simplify these
    functions with a macro, but we won't do that here.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the line `self.state_machine.context().position.x`
    violates the `self` should only talk to `state_machine` (its friend) but instead,
    it talks to `position` via `context`. This couples `RedHatBoy` to the internal
    structure of `RedHatBoyContext` in a way that could be avoided by adding getters
    for `position_x` and `position_y` on `state machine`, which would delegate to
    `context`, which would, in turn, delegate to `position`. The Law of Demeter is
    a great guideline when setting values, and you should almost always follow it
    for mutable data, but in this case the data is immutable. We can't change the
    context through this getter, and the downsides of violating the Law of Demeter
    are not as relevant. I don't feel it's necessary to create more delegating functions
    just to avoid violating an arbitrary guideline, but if it becomes a problem, we
    can always change it. For more information on this, go to [https://wiki.c2.com/?LawOfDemeter](https://wiki.c2.com/?LawOfDemeter).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the compiler again, we''ve moved the errors from the `draw` method
    on `RedHatBoy` into `RedHatBoyStateMachine` because none of the states have methods
    for `frame_name` or `context`. Out of these two methods, `frame_name` is more
    straightforward, so we''ll implement it first. It''s a getter of the name of the
    frame in the `rhb.json` file, and it''s different for every state, so we''ll put
    that method on every state, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've added two constants, `IDLE_FRAME_NAME` and `RUN_FRAME_NAME`, which correspond
    to the names of the frames for the `Idle` and `Run` sections of our sprite sheets,
    respectively. We then created a new method, `frame_name`, on `RedHatBoyState<Idle>`
    as well as an entirely new implementation for `RedHatBoyState<Running>`, which
    also has a `frame_name` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: It's worth thinking about whether we could use a trait object ([https://bit.ly/3JSyoI9](https://bit.ly/3JSyoI9))
    instead of our `enum` for `RedHatBoyStateMachine`, and it probably is possible.
    I've experimented with it and didn't come to a satisfying solution, but I would
    encourage you to give it a shot. You'll learn a lot more from this book if you
    experiment with the code on your own.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve handled the `frame_name` method, we''ll want to add a `context`
    method. That method is going to do the same thing for every state, return the
    context, and we can write it generically for all of them, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is a pretty cool feature of Rust. Since we have a generic struct, we can
    write methods on the generic type, and it will apply to all the types. Finally,
    there is one more compiler error, in the `draw` function where we reference the
    frame or position fields on context. These fields are private, but as long as
    `RedHatBoyContext` is an immutable type, we can each make of those public, as
    follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we need to call that method on `RedHatBoy` in the `WalkTheDog#draw`
    function. You can add that in this, admittedly awkward, one-liner right at the
    end of the `draw` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you''ve followed along successfully, you should see the following screen:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – RHBs'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.04_B17151.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – RHBs
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: At the top we have our old, endlessly running RHB, and at the bottom our new
    RHB just standing still. The new version has fewer features; we've gone backward,
    but why? This prepared us for what we're going to do next, moving him around and
    changing animations. Speaking of animations, the `Idle` version of RHB isn't doing
    anything yet, because `frame` never changes. When RHB is idle, he stands while
    breathing slowly, so let's get that started, shall we?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Updating RHB
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `RedHatBoy` struct is going to have an `update` function, which will, in
    turn, delegate to an `update` function on the state machine. It''s a new method
    because every state is going to need to update, in order to advance the animation.
    We''ll call `update` on `RedHatBoy` from `update` on `WalkTheDog`. That''s a lot
    of updates, but it''s really just delegation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `update` function on `WalkTheDog`, we''ve only added one new line, at
    the end of the `update` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's funky because of the fact that `rhb` is `Option`, and we'll fix that in
    a little bit. We've added another small function to the `RedHatBoy` `struct` `update`
    that simply updates `state_machine` via the state machine's `update` function.
    This one line, and others like it, are why the state machine needs to be `Copy`.
    If it's not, then because `update` consumes `self` via the parameter of `mut self`,
    you'd have to use something like `Option` to move `self` into `update`, and then
    reset it again. By making everything `Copy`, you get a much more ergonomic `update`
    function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the meat of the behavior is in the `RedHatBoyStateMachine#update` function.
    Here, we match on `self` and update the current frame on a mutable `state` parameter,
    and then return a new `Idle` state with a moved `context` with an updated frame.
    Unfortunately, this code doesn't compile; `context` isn't a public data member
    so you can't assign it. For now, we'll go ahead and make `context` public, but
    this should bother you. Remember that Law of Demeter guideline I mentioned earlier.
    It's one thing to get an immutable data value, another thing entirely to set a
    mutable value. This is the kind of coupling that could cause real problems down
    the line. We're *not* going to fix it right now, so go ahead and make `context`
    public, but we will be keeping a very close eye on this code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you look at `update` for `WalkTheDog` and `update` for `RedHatBoyStateMachine`,
    you'll see similarities. One is updating the running RHB in the upper left corner,
    and one is updating the idle RHB in the lower left. The time has come to begin
    combining these two objects. Let's go ahead and do that.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Running state
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing to keep in mind about states is that they exist whether you implement
    a state machine or not. While we haven't implemented anything in `RedHatBoyState<Running>`,
    the `Running` state currently exists in `WalkTheDog`; RHB is running all around
    the void right now! We just need to move the details into our state machine, so
    that we as programmers can actually see the states and what they do as one coherent
    unit. Plus, then we'll stop having a sad and lonely boy who is running in place
    in the left-hand corner of the screen.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that quickly by just modifying `update` in `RedHatBoyStateMachine`
    to match the version in `Idle`, with the different frame count for the run animation.
    That''s shown as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, the state machine is theoretically capable of drawing the run animation,
    but we haven't written anything to cause that transition. The other thing missing
    is potentially more subtle. The `Running` animation has `23` frames, and the `Idle`
    animation has `29`. If we were to transform from `Idle` to `Running` with the
    frame count at `24`, the game would crash.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I think we can all agree that the kind of duplication that we have
    here can be improved. The only difference between the two functions is the frame
    count. So, we have a few things to do:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Refactor the duplicated code.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code that updates `context.frame` suffers from a code smell called `update`
    function is operating over and over again on `context`. Why not move that function
    to `RedHatBoyContext`? That''s shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`RedHatBoyContext` now has an `update` function that increments the frame,
    looping it back to `0` when the total frame count is reached. Note how it works
    the same way as our transitions, consuming `self`, and returning a new `RedHatBoyContext`,
    although in reality, it''s the same `instance` the entire time. This gives us
    the same kind of *functional* interface that we''re using elsewhere. The total
    frame count changes with each state, so we pass that in as a parameter, using
    constants for clarity.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Fix the Law of Demeter violation.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Looking at the two arms of each `match` statement, they are nearly identical,
    both mutating `context` in the way we didn''t like earlier. Now is a good time
    to address it, which we can do by making the field private on `RedHatBoyState<S>`
    again, and creating new methods on the respective `RedHatBoy` state implementations,
    as shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There! That's better. `context` is no longer inappropriately public, and each
    individual state handles its own updating. The only difference between them is
    the constant they use, and it's fitting to have that bundled with the implementation
    itself. Speaking of which, make sure you move the `RUNNING_FRAMES` and `IDLE_FRAMES`
    constants into the `red_hat_boy_states` module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to modify the `update` method on `RedHatBoyStateMachine` to call
    this new method on each of the states:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each of the arms in update now updates the state, and then returns the state.
    There's some duplication here that's a little suspicious; we'll take another look
    at that shortly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Move RHB on every `update`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If RHB is going to run in the running state, it needs to respect the velocity.
    In other words, update animates the frame, but it doesn''t move, so let''s add
    that to the `RedHatBoyContext` `update` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Of course, RHB won't move yet because we aren't changing the velocity. That
    will come soon.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the frame count resets to `0` when transitioning between states.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two categories of changes on the game object that can happen in our
    state machine. There are changes that happen when the state doesn't change. That's
    what `update` is and right now those are written in `RedHatBoyStateMachine`. There
    are also changes that happen on a transition, and those happen in the transition
    functions that are defined as methods of the type classes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'We already transitioned from `Idle` to `Running` via the `run` method, and
    we can make sure to reset the frame rate on the transition. That''s a small change
    you can see here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`RedHatBoyContext` has grown a function called `reset_frame`, which resets
    its frame count to `0` and returns itself. By returning itself, we can chain calls
    together, which will come in handy shortly. The `run` method has also evolved
    to call `reset_frame()` on `RedHatBoyContext` and use that new version of `context`
    in the new `RedHatBoyState` struct.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Start Running on transition.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have prevented crashes by restarting animations on transitions,
    let''s start running forward on a transition. This is going to be very short:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We've sprouted another method on `RedHatBoyContext` called `run_right`, which
    simply adds forward speed to the velocity. Meanwhile, we've chained a call (see!)
    to `run_right` in the transition. Don't forget to add the `RUNNING_SPEED` constant
    to the module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Start Running on the *right* arrow.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we actually need to call this event when the `ArrowRight` button is
    pressed. At this point, we can follow along with where we''re doing this in the
    `WalkTheDog` implementation:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will now start our RHB running, so much so that he'll run right off the
    screen!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – This could be a problem](img/Figure_4.05_B17151.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – This could be a problem
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we could re-establish *moonwalking*, to bring RHB back on screen,
    but that doesn''t really serve the purpose of the game. You can either create
    an event that resets horizontal velocity every update, just like the current code
    does, or you could track when a key goes up to remove some velocity. The second
    one feels better but will cause us to write a few events and possibly a transition
    from `Running` to `Idle`. No, we''ll go to a third approach: ignore it and hit
    refresh! We don''t need to move backward in our actual game, nor stop, so we won''t.
    Let''s not spend any more time writing code, that we''ll just delete anyway. Speaking
    of that.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Delete the original code.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the new and improved RHB is moving, it''s time to get rid of all the
    references in `WalkTheDog` to the sheet, the element, the frame…basically anything
    that isn''t the `RedHatBoy` `struct`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Rather than boring you with endless deletes, I'll simply say you can delete
    all the fields that aren't `rhb` and follow the compiler errors to delete the
    rest of the code. When you're done, `WalkTheDog` becomes very short, as it should
    be. As for the arrow keys, you only need to worry about the `ArrowRight` key,
    and moving to the right.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: As I said, we won't be restoring moving backward, up, or down here, but you
    could certainly consider restoring the walking backward functionality by extending
    the state machine. Doing so will help you internalize the lesson here and save
    you the trouble of refreshing all the time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: So, now RHB can run across the screen, but that's not much fun. Let's add sliding.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to sliding
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Transitioning from running to sliding will involve adding a new state for sliding,
    so that we see the sliding action, but also checking for when a slide is complete
    and transitioning back into the running state. This will mean sliding will have
    its own variation on the `update` function. We can start by adding sliding on
    the *down* arrow and treating it all just like running. We''ll go through this
    quickly because most of it is familiar. Let''s start by adding sliding on the
    *down* arrow in the `update` method of `WalkTheDog`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It''s time to follow the compiler. RedHatBoy doesn''t have a `slide` method,
    so let''s add that, as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Transitioning via `Event::Slide` doesn''t exist. There''s no `Event::Slide`
    at all, so let''s add those next:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's nothing new in the preceding code block. When RHB is `Running`, it can
    transition to `Sliding` via the `Event::Slide` event and the `slide` method, which
    doesn't exist on the `RedHatBoyState<Running>` typestate. This is all very similar
    to how we went from `Idle` to `Running`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue with the compiler, we need to add a `slide` method to the `RedHatBoyState<Running>`
    typestate, as in the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `slide` method on `RedHatBoyState<Running>` converts the state into `RedHatBoyState<Sliding>`,
    only calling `reset_frame` on `context` to make sure the sliding animation starts
    playing at frame `0`. We also call `into` on the `slide` method, which needs to
    convert `RedHatBoyState<Sliding>` into a `RedHatBoyStateMachine` variant. That
    means we need to create the variant and create a `From` implementation for it,
    as shown here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At this point, you''ll see errors on the `frame_name`, `context`, and `update`
    methods of `RedHatBoyStateMachine` because their corresponding `match` calls don''t
    have cases for the new `Sliding` variant. We can fix that by adding cases to those
    `match` statements, which will mimic the other cases:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once again, we''ve replaced one compiler error with another. There is no `Sliding`
    state, and it doesn''t have the methods we assumed it would. We can fix that by
    filling it in, adding some constants for good measure:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you look through this code, you''ll see it''s very similar to our already
    existing running code. If you followed along, you''ll see RHB start skidding across
    the floor until he goes past the right edge of the screen:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Safe'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.06_B17151.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Safe
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Stopping RHB from sliding is a little different than what we''ve done before.
    What we need to do is identify when the slide animation is complete, then transition
    right back into running without any user input. We''ll start by checking whether
    the animation is done in the `update` method of the `enum`, which represents our
    machine, and then create a new transition from sliding back into running. We can
    do that by modifying the `RedHatBoyStateMachine` `update` method to check after
    updating in the sliding branch, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This doesn't compile yet, because stand isn't defined yet and because `SLIDING_FRAMES`
    is in the `red_hat_boy_states` module. You might think that we can make `SLIDING_FRAMES`
    public and define a `stand` method, or we could move `SLIDING_FRAMES` into the
    `game` module. These will both work but I think it's time to look a little more
    holistically at our `update` method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Every arm of the `match` statement updates the current state and then returns
    a new state. In the case of `Running` and `Idle`, it was always the same state,
    but in the case of `Sliding`, sometimes it''s the `Running` state. It turns out
    `update` is a transition, just one that sometimes transitions to the state it
    started from. In a state diagram, it looks like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Sliding to Running](img/Figure_4.07_B17151.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Sliding to Running
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to be strict about it, we could say that `Updating` state when
    it gets an **Update** event, then it can transition back to **Sliding** or **Running**.
    This is a case where the state exists, at least conceptually, but we don't actually
    have to create it in our code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`update` on the `Sliding` state is really best modeled as a transition because
    it''s a method that ultimately returns a state. Come to think of it, that''s exactly
    what the other arms in the `update` method are too! Yes, they don''t ever transition
    to another state, but each branch calls `update` and then returns a state. So,
    before we add `Sliding` to the `update` method, let''s refactor to make `update`
    a transition for both of the other states.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re using Compiler-Driven Development, we''ll change the `update`
    method to work as if `update` is already a transition:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With these changes, we''ve turned `Update` into `Event` and added two more
    arms to `match` in the `transition` method. Both of those arms work the same way
    as the other transitions: they call a method on the typestate and then convert
    the state into the `RedHatBoyStateMachine enum` with the `From` trait. The compiler
    error you get now might be a little strange; it looks like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You may have expected that the error would say something about the `update`
    method not returning anything, but remember all Rust functions return something;
    they just return `Unit` when they don''t return anything else. So, this error
    is telling you there''s no way to convert from the `()`, or `Unit`, to a value
    of the `RedHatBoyStateMachine` type. That''s not what we want to fix; we want
    to make both of the `update` calls on the states return new states. Those changes
    are next:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The changes are small but important. The `update` method for `RedHatBoyState<Idle>`
    and `RedHatBoyState<Running>` both return `Self` now, because even though the
    state doesn't change, these are still typestate methods that return a new state.
    They also take `mut self` now instead of `&mut self`. You can't return `self`
    if you mutably borrow it, so this method stopped compiling. More importantly,
    this means these methods don't make unnecessary copies. They take ownership of
    `self` when called, and then return it. So, if you're worried about an optimization
    problem because of extra copies, you don't have to be.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''re down to one compiler error, which we''ve seen before:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We didn''t implement a conversion from the `Idle` state back to the `RedHatBoyStateMachine
    enum`. That''s similar to the other ones we wrote, implementing `From<RedHatBoyState<Idle>>`,
    as shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Remember that these implementations of the `From` trait are not in the `red_hat_boy_states`
    module. The `red_hat_boy_states` module knows about the individual states but
    does not know about `RedHatBoyStateMachine`. That's not its job.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've refactored the code, our little RHB doesn't slide anymore. Instead,
    he kind of sits down because the `Sliding` state doesn't handle the `Update` event.
    Let's fix that now.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to sliding and back again
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part of the reason we used the typestate pattern for our individual states is
    so that we get compiler errors when we make a mistake. For instance, if we call
    `run` when we are in the `Running` state, it won't even compile because there
    is no such method. There is one place this doesn't hold, the `transition` method
    on the `RedHatBoyStateMachine` `enum`. If you call `transition` with a `RedHatBoyStateMachine`
    variant and an `Event` variant pair that don't have a match, it returns `Self`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: That's why our RHB is sitting down. He transitions to `Sliding` and then stops
    updating, staying in the same state forever. We'll fix that by adding the match
    for the `Update` event and then, you guessed it, follow the compiler to implement
    the sliding animation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'This starts by adding the match to the transition method, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This match is just like the others; we match on `Sliding` and `Update` and
    call `update`. Just like before, we''ll get an error:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Sliding` state still has an update method that doesn't return a state.
    That's not going to work with our current setup, but it's not as simple as making
    the `update` method return `Self`, as on the other two states.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, there are two possible states that can come from the `update` method
    on `Sliding`: `Sliding` and `Running`. How is that going to work with our current
    setup? What we''ll need to do is have `update` return an `SlidingEndState` `enum`
    that can be either `Sliding` or `Running`, and then we''ll implement a `From`
    trait that will convert that into the appropriate variant of `RedHatBoyStateMachine`.
    That''s odd to explain, so let''s see it in action. We can modify the `update`
    method on `RedHatBoyState<Sliding>` to work like the one we proposed at the beginning
    of this section:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''ve taken the code that we originally considered putting in the `RedHatBoyStateMachine`
    `update` method and moved it into the `update` method of `RedHatBoyState<Sliding>`.
    This makes sense conceptually; the state should know how it behaves. On every
    update, we update `context`, and then check whether the animation is complete,
    with `if self.context.frame >= SLIDING_FRAMES`. If the animation is complete,
    we return one variant of this new `enum` that doesn''t exist yet: `SlidingState`.
    The `SlidingState` variant can either be `Complete` or `Sliding`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: It's definitely a little strange that the `update` method doesn't return another
    state here, and probably means we aren't using a *pure* typestate method. An alternative
    might have been to return the next `Event` from `update` and send that back into
    a call to the `transition` method on `RedHatBoyStateMachine`. That implementation
    ends up looking very strange because states are returning `Events` that are only
    used by `RedHatBoyStateMachine` and are otherwise unreferenced in the `red_hat_boy_states`
    module. Regardless of whether the strange return value of `update` makes you uncomfortable,
    I would encourage you to try other approaches. Maybe yours is better than mine!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the compiler yet again, we have two obvious problems: there is no
    `stand` method and there is no `SlidingEndState` `enum`. We can handle both of
    these right here, next to the code we just wrote, as shown:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The only side effect of the transition to `Running` is that we call `reset_frame`
    again on `context`. Remember this has to be done on every transition, otherwise,
    the program can try to animate the new state with `frame`, which isn't valid and
    will crash. So, we'll reset the frame back to `0` on every transition.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves us with a compiler error to fix once again. This time, it''s the
    following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Pay close attention to that source trait. It''s not coming from one of the
    states but from the intermediate `SlidingEndState`. We''ll solve it the same way
    as before, with a `From` trait, but we''ll need to use a `match` statement to
    pull it out of the `enum`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we match on `end_state` to get the actual `State` out of `enum`, and then
    call `into` on that state again to get to `RedHatBoyStateMachine`. A little boilerplate,
    but it makes it easier to do the conversion.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we have it! Run the game now and you''ll see RHB take a short slide
    and pop back up again to the running state. Now that we''ve added three animations,
    it''s time to deal with these ugly lines in the `WalkTheDog` implementation: `self.rhb.as_mut().unwrap().slide()`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: We treat `rhb` as an `Option` type, not because it's ever really going to be
    `None`, but because we don't have it yet before the `WalkTheDog` `struct` is initialized.
    After `WalkTheDog` is initialized, `rhb` can never be `None` again because the
    state of the system has changed. Fortunately, we now have a tool for dealing with
    that, the good old state machine!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Every little thing I think I see
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`WalkTheDog` can be in two states, `Loading` or `Loaded`, after it''s initialized.
    Fortunately, we accounted for this when we wrote our `GameLoop`. Remember that
    `GameLoop` returns `Result<Game>` from `initialize`; we''re just currently always
    returning `Ok(WalkTheDog)`. What if we made `WalkTheDog` an `enum` and returned
    a different state of our game instead? That would mean `WalkTheDog` would be a
    state machine, with two states, and `initialize` would become the transition!
    That''s exactly what we''re going to do. Modify `WalkTheDog` so it is no longer
    a `struct` but an `enum`, as shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is great; now everything is broken! Whoops! We''ll need to adjust the
    `WalkTheDog` implementation to account for the two variants. First, we''ll change
    the `initialize` function on `WalkTheDog`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Remember in [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*, where we made this function return `Game`? This was why!
    In order to ensure `initialize` is only called once, `initialize` has to match
    `self` on its variants, and if we call `initialize` twice, we''ll return an error
    via `anyhow!`. Otherwise, everything inside the `Loading` branch is the same as
    before, except we return `WalkTheDog::Loaded` instead of `WalkTheDog`. This does
    cause a compiler warning, which will become an error in future versions of Rust
    because `RedHatBoy` isn''t public but is exposed in a public type. To get rid
    of that warning, you''ll need to make `RedHatBoy` public, and that''s fine; go
    ahead and do that. We also need to change the `new` constructor to reflect the
    new type, as shown here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `WalkTheDog` `enum` starts in `Loading`, nothing fancy there. The `update`
    and `draw` functions now both need to reflect the changing states; you can see
    those changes here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You could argue this isn't really a change on the `Option` type, as we still
    need to check the state of `Game` each time we operate on `rhb`, and that's true,
    but I think this more clearly reveals the intent of the system. It also has the
    benefit of getting rid of the `as_ref`, `as_mut` code, which is often confusing.
    Now that we've cleaned up that code, let's add one more animation to RHB. Let's
    see this boy jump!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to jumping
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going through each and every change yet again for the jump is redundant. Instead,
    I can recommend you make the following change:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You should be able to follow the compiler errors all the way through, creating
    a transition from `Running` to `Jumping`. You can also look up the constant values
    you need directly out of `rhb.json`. The number of frames is the number of images
    in `Jump` in the animation multiplied by `3`, and subtracting `1`, and the name
    of the animation is `Jump`. Make sure you handle the `update` event in the transition
    method for `Jumping`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Do all that and you see RHB skidding across the ground, doing a kind of dance:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – That''s...not jumping](img/Figure_4.08_B17151.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – That's...not jumping
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: If you get stuck, the answers to this are available at [https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/).
    However, I strongly recommend trying to do this without checking first. Look at
    what we did for the first three transitions and try to understand what we did.
    Even if you get stuck, the time spent practicing is valuable here.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: If you've correctly implemented the code for transitioning to the jumping state,
    our RHB will play his jumping animation, forever, while skidding across the ground.
    We've seen this before with the slide state, so it's time to figure out what's
    different about jumping. Of course, we know exactly what's different about jumping
    – you go up! Well, at least a little.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three things we need to do. First, we give RHB vertical velocity
    when he jumps; second, we need to add gravity so that RHB will actually come down
    when he jumps. And finally, we need to transition running when we land, using
    our ever-durable state machine:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Going up on `Jump`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a moment and think, where does this belong? Should it go in the `update`
    function, the `jump` event, or maybe in the `enum` implementation? No, this is
    a transition change because it happens on `jump`, and it belongs in the `jump`
    method on the `Running` type class. You should already have a transition from
    running to jumping, so let''s update that function to add vertical velocity:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Remember in our 2D coordinate system, `y` is `0` at the top, so we need a negative
    velocity to go up. It also resets the frame so that the jump animation starts
    at frame `0`. The implementation in `RedHatBoyContext` is using the same pattern
    of accepting `mut self` and returning a new `RedHatBoyContext`. Now, if you let
    the app refresh, RHB will take off like Superman!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Adding gravity.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to have a natural jump, we''ll apply gravity on every update. We''ll
    do this *regardless of state* because later, we''ll need to have RHB fall off
    of platforms and cliffs, and we don''t want to have to constantly pick and choose
    when we''re applying gravity. This will go in the `update` function of `RedHatBoyContext`,
    right at the top:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you refresh the page right now, you'll get a blink-and-you'll-miss-it problem,
    and you'll probably be greeted with a blank screen. The screen isn't really blank;
    RHB just fell right through the ground!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Tell my family I love them](img/Figure_4.09_B17151.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Tell my family I love them
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to address this with our first case of **collision resolution**.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Landing on the ground.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a bit of a spoiler for the next chapter, but collision detection happens
    in two steps. The first is detection, finding places where things collide, and
    the second is resolution, where you do something about the collision. Since there
    isn''t anything to collide with in RHB''s empty void, we can just do a simple
    check in the same `update` function to see whether his new position is past the
    floor and update the position back to the floor. Keep in mind, you do this *after*
    you update to a new position:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This may feel redundant, but we can't know gravity pulled RHB past the ground
    without actually calculating where he ends up, and we don't draw the in-between
    state, so the performance cost is minimal. This change prevents RHB from falling
    through the ground and causes a nice jumping arc, but he keeps performing the
    jumping animation for eternity. We need to change the state from `Jumping` back
    to `Running`, and we need to make that decision in `RedHatBoyStateMachine` because
    it's a conditional state change based on a condition just like the one that transitioned
    from `Sliding` to `Running`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a change to the state machine, much like the one we did for `Sliding`,
    as seen here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'So, if the position is on the floor, we need to transition to `Running` via
    the `stand` method, only we can''t! We never wrote a transition from `Sliding`
    to `Running`, just the other way around. We also never wrote a `JumpingEndState`
    enum, or a way to convert out of it via `From`. So, right now, you should see
    several compiler errors about all of that, the first being the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There''s the compiler error, but there''s no `land` method. So, go write it.
    *I''m serious: go write it yourself. I''m not going to reproduce it here*. You
    can go ahead and follow along with the previous methods we wrote and implement
    them. You can do it; I believe in you. When you do, you''ll have a clean animation
    from `Idle` to `Running`, then `Jumping`, and back to `Running` again. Then, you''ll
    wander off the screen because we don''t have a full scene yet, but we''re getting
    there!'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: If you get stumped, you can always check the source code for this chapter in
    the repository at [https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered one topic, but one of the most important topics in game
    development. State machines are everywhere in games, which we saw when we implemented
    a small one to manage the `Loaded` and `Loading` states of the `WalkTheDog` `enum`
    itself. They are a particularly nice way to implement animation states that must
    correspond with what the player is doing, and Rust has great ways to implement
    this pattern. We used two: the simple one for `WalkTheDog`, and the much more
    complex `RedHatBoyStateMachine` that uses the typestate pattern. The typestate
    pattern is a commonly used pattern in Rust, both inside and outside of game development,
    so you can expect to see it in many Rust projects.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: We also used the compiler to drive development, over and over again. It's an
    incredibly useful technique, where you can start with what you want the code to
    look like and use the compiler's error messages to help you fill in the rest of
    the implementation. The code becomes like a paint by numbers picture, where you
    use higher-level code to draw the lines and the compiler error messages tell you
    how to fill them in. Rust has very good compiler error messages, getting better
    with every release, and it will pay huge dividends for you to pay close attention
    to them.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Now that our RHB can run and jump, how about he runs and jumps on something?
    We'll put him in a scene and have him jump on it in the next chapter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
