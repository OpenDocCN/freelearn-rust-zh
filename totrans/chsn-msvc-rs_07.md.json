["```rs\ndocker run -it --rm --name test-pg -p 5432:5432 postgres\n```", "```rs\ncreating subdirectories ... ok\nselecting default max_connections ... 100\nselecting default shared_buffers ... 128MB\nselecting dynamic shared memory implementation ... posix\ncreating configuration files ... ok\nrunning bootstrap script ... ok\nperforming post-bootstrap initialization ... ok\nsyncing data to disk ... ok\n........\n```", "```rs\npsql --host localhost --port 5432 --username postgres\n```", "```rs\ndocker stop test-pg\n```", "```rs\ncargo new --bin users\n```", "```rs\ncargo add clap postgres\n```", "```rs\ncargo install cargo-edit\n```", "```rs\nextern crate clap;\nextern crate postgres;\n\nuse clap::{\n    crate_authors, crate_description, crate_name, crate_version,\n    App, AppSettings, Arg, SubCommand,\n};\nuse postgres::{Connection, Error, TlsMode};\n```", "```rs\nlet conn = Connection::connect(\"postgres://postgres@localhost:5432\", TlsMode::None).unwrap();\n```", "```rs\nfn create_table(conn: &Connection) -> Result<(), Error> {\n    conn.execute(\"CREATE TABLE users (\n                    id SERIAL PRIMARY KEY,\n                    name VARCHAR NOT NULL,\n                    email VARCHAR NOT NULL\n                  )\", &[])\n        .map(drop)\n}\n```", "```rs\nfn create_user(conn: &Connection, name: &str, email: &str) -> Result<(), Error> {\n    conn.execute(\"INSERT INTO users (name, email) VALUES ($1, $2)\",\n                 &[&name, &email])\n        .map(drop)\n}\n```", "```rs\nfn list_users(conn: &Connection) -> Result<Vec<(String, String)>, Error> {\n    let res = conn.query(\"SELECT name, email FROM users\", &[])?.into_iter()\n        .map(|row| (row.get(0), row.get(1)))\n        .collect();\n    Ok(res)\n}\n```", "```rs\nconst CMD_CREATE: &str = \"create\";\nconst CMD_ADD: &str = \"add\";\nconst CMD_LIST: &str = \"list\";\n```", "```rs\nfn main() -> Result<(), Error> {\n\n    let matches = App::new(crate_name!())\n        .version(crate_version!())\n        .author(crate_authors!())\n        .about(crate_description!())\n        .setting(AppSettings::SubcommandRequired)\n        .arg(\n            Arg::with_name(\"database\")\n            .short(\"d\")\n            .long(\"db\")\n            .value_name(\"ADDR\")\n            .help(\"Sets an address of db connection\")\n            .takes_value(true),\n            )\n        .subcommand(SubCommand::with_name(CMD_CREATE).about(\"create users table\"))\n        .subcommand(SubCommand::with_name(CMD_ADD).about(\"add user to the table\")\n                    .arg(Arg::with_name(\"NAME\")\n                         .help(\"Sets the name of a user\")\n                         .required(true)\n                         .index(1))\n                    .arg(Arg::with_name(\"EMAIL\")\n                         .help(\"Sets the email of a user\")\n                         .required(true)\n                         .index(2)))\n        .subcommand(SubCommand::with_name(CMD_LIST).about(\"print list of users\"))\n        .get_matches();\n    // Add connection here\n}\n```", "```rs\nlet addr = matches.value_of(\"database\")\n    .unwrap_or(\"postgres://postgres@localhost:5432\");\nlet conn = Connection::connect(addr, TlsMode::None)?;\n```", "```rs\nmatch matches.subcommand() {\n    (CMD_CREATE, _) => {\n        create_table(&conn)?;\n    }\n    (CMD_ADD, Some(matches)) => {\n        let name = matches.value_of(\"NAME\").unwrap();\n        let email = matches.value_of(\"EMAIL\").unwrap();\n        create_user(&conn, name, email)?;\n    }\n    (CMD_LIST, _) => {\n        let list = list_users(&conn)?;\n        for (name, email) in list {\n            println!(\"Name: {:20}    Email: {:20}\", name, email);\n        }\n    }\n    _ => {\n        matches.usage(); // but unreachable\n    }\n}\nOk(())\n```", "```rs\ncargo run -- --helpYou will see the next output:\nUSAGE:\n users [OPTIONS] <SUBCOMMAND>\nFLAGS:\n -h, --help       Prints help information\n -V, --version    Prints version information\nOPTIONS:\n -d, --db <ADDR>    Sets an address of db connection\nSUBCOMMANDS:\n add       add user to the table\n create    create users table\n help      Prints this message or the help of the given subcommand(s)\n list      print list of users\n```", "```rs\ncargo run -- create\n```", "```rs\nError: Error(Db(DbError { severity: \"ERROR\", parsed_severity: Some(Error), code: SqlState(\"42P07\"), message: \"relation \\\"users\\\" already exists\", detail: None, hint: None, position: None, where_: None, schema: None, table: None, column: None, datatype: None, constraint: None, file: Some(\"heap.c\"), line: Some(1084), routine: Some(\"heap_create_with_catalog\") }))\n```", "```rs\npostgres=# \\dt\n List of relations\n Schema | Name  | Type  |  Owner \n--------+-------+-------+----------\n public | users | table | postgres\n(1 row)\n```", "```rs\ncargo run -- add user-1 user-1@example.com\ncargo run -- add user-2 user-2@example.com\ncargo run -- add user-3 user-3@example.com\n```", "```rs\ncargo run -- list\nName: user-1   Email: user-1@example.com \nName: user-2   Email: user-2@example.com \nName: user-3   Email: user-3@example.com  \n```", "```rs\n[dependencies]\nclap = \"2.32\"\ncsv = \"1.0\"\nfailure = \"0.1\"\npostgres = \"0.15\"\nr2d2 = \"0.8\"\nr2d2_postgres = \"0.14\"\nrayon = \"1.0\"\nserde = \"1.0\"\nserde_derive = \"1.0\"\n```", "```rs\n#[derive(Deserialize, Debug)]\nstruct User {\n name: String,\n email: String,\n}\n```", "```rs\nfn create_user(conn: &Connection, user: &User) -> Result<(), Error> {\n    conn.execute(\"INSERT INTO users (name, email) VALUES ($1, $2)\",\n                 &[&user.name, &user.email])\n        .map(drop)\n}\n\nfn list_users(conn: &Connection) -> Result<Vec<User>, Error> {\n    let res = conn.query(\"SELECT name, email FROM users\", &[])?.into_iter()\n        .map(|row| {\n            User {\n                name: row.get(0),\n                email: row.get(1),\n            }\n        })\n        .collect();\n    Ok(res)\n}\n```", "```rs\nconst CMD_IMPORT: &str = \"import\";\n```", "```rs\n.subcommand(SubCommand::with_name(CMD_IMPORT).about(\"import users from csv\"))\n```", "```rs\n(CMD_ADD, Some(matches)) => {\n    let name = matches.value_of(\"NAME\").unwrap().to_owned();\n    let email = matches.value_of(\"EMAIL\").unwrap().to_owned();\n    let user = User { name, email };\n    create_user(&conn, &user)?;\n}\n```", "```rs\n(CMD_LIST, _) => {\n    let list = list_users(&conn)?;\n    for user in list {\n        println!(\"Name: {:20}    Email: {:20}\", user.name, user.email);\n    }\n}\n```", "```rs\n(CMD_IMPORT, _) => {\n    let mut rdr = csv::Reader::from_reader(io::stdin());\n    let mut users = Vec::new();\n    for user in rdr.deserialize() {\n        users.push(user?);\n    }\n    // Put parallel statements execution here\n}\n```", "```rs\nusers.par_iter()\n    .map(|user| -> Result<(), failure::Error> {\n        let conn = pool.get()?;\n        create_user(&conn, &user)?;\n        Ok(())\n    })\n    .for_each(drop);\n```", "```rs\ndocker run -it --rm --name test-mysql -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=test -p 3306:3306 mysql\n```", "```rs\nmysql -h 127.0.0.1 -P 3306 -u root -p test\n```", "```rs\ndocker stop test-mysql\n```", "```rs\nmysql = \"14.1\"\nr2d2_mysql = \"9.0\"\n```", "```rs\nuse mysql::{Conn, Error, Opts, OptsBuilder};\nuse r2d2_mysql::MysqlConnectionManager;\n```", "```rs\nfn create_table(conn: &mut Conn) -> Result<(), Error> {\n    conn.query(\"CREATE TABLE users (\n                    id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n                    name VARCHAR(50) NOT NULL,\n                    email VARCHAR(50) NOT NULL\n                  )\")\n        .map(drop)\n}\n```", "```rs\nfn create_user(conn: &mut Conn, user: &User) -> Result<(), Error> {\n     conn.prep_exec(\"INSERT INTO users (name, email) VALUES (?, ?)\",\n                  (&user.name, &user.email))\n         .map(drop)\n }\n```", "```rs\nfn list_users(conn: &mut Conn) -> Result<Vec<User>, Error> {\n    conn.query(\"SELECT name, email FROM users\")?\n        .into_iter()\n        .try_fold(Vec::new(), |mut vec, row| {\n            let row = row?;\n            let user = User {\n                name: row.get_opt(0).unwrap()?,\n                email: row.get_opt(1).unwrap()?,\n            };\n            vec.push(user);\n            Ok(vec)\n        })\n}\n```", "```rs\nlet addr = matches.value_of(\"database\")\n    .unwrap_or(\"mysql://root:password@localhost:3306/test\");\nlet opts = Opts::from_url(addr)?;\nlet builder = OptsBuilder::from_opts(opts);\nlet manager = MysqlConnectionManager::new(builder);\nlet pool = r2d2::Pool::new(manager)?;\nlet mut conn = pool.get()?;\n```", "```rs\n(CMD_CRATE, _) => {\n    create_table(&mut conn)?;\n}\n```", "```rs\nname,email\nuser01,user01@example.com\nuser02,user02@example.com\nuser03,user03@example.com\n```", "```rs\ncargo run -- import < users.csv\n```", "```rs\nmysql> SELECT * FROM users;\n+----+--------+--------------------+\n| id | name   | email              |\n+----+--------+--------------------+\n|  1 | user01 | user01@example.com |\n|  2 | user03 | user03@example.com |\n|  3 | user08 | user08@example.com |\n|  4 | user06 | user06@example.com |\n|  5 | user02 | user02@example.com |\n|  6 | user07 | user07@example.com |\n|  7 | user04 | user04@example.com |\n|  8 | user09 | user09@example.com |\n|  9 | user10 | user10@example.com |\n| 10 | user05 | user05@example.com |\n+----+--------+--------------------+\n10 rows in set (0.00 sec)\n```", "```rs\ndocker run -it --rm --name test-redis -p 6379:6379 redis\n```", "```rs\ntelnet 127.0.0.1 6379\nTrying 127.0.0.1...\nConnected to 127.0.0.1.\nEscape character is '^]'.\nSET session-1 \"Rust\"\n+OK\nGET session-1\n$4\nRust\n^]\n```", "```rs\ndocker stop test-redis\n```", "```rs\n[dependencies]\nclap = \"2.32\"\nfailure = \"0.1\"\nr2d2 = \"0.8\"\nr2d2_redis = \"0.8\"\nredis = \"0.9\"\n```", "```rs\nuse clap::{\n    crate_authors, crate_description, crate_name, crate_version,\n    App, AppSettings, Arg, SubCommand,\n};\nuse redis::{Commands, Connection, RedisError};\nuse r2d2_redis::RedisConnectionManager;\nuse std::collections::HashMap;\n```", "```rs\nconst SESSIONS: &str = \"sessions\";\nconst CMD_ADD: &str = \"add\";\nconst CMD_REMOVE: &str = \"remove\";\nconst CMD_LIST: &str = \"list\";\n```", "```rs\nfn add_session(conn: &Connection, token: &str, uid: &str) -> Result<(), RedisError> {\n    conn.hset(SESSIONS, token, uid)\n}\n```", "```rs\nfn remove_session(conn: &Connection, token: &str) -> Result<(), RedisError> {\n    conn.hdel(SESSIONS, token)\n}\n```", "```rs\nfn list_sessions(conn: &Connection) -> Result<HashMap<String, String>, RedisError> {\n     conn.hgetall(SESSIONS)\n}\n```", "```rs\nlet matches = App::new(crate_name!())\n    .version(crate_version!())\n    .author(crate_authors!())\n    .about(crate_description!())\n    .setting(AppSettings::SubcommandRequired)\n    .arg(\n        Arg::with_name(\"database\")\n        .short(\"d\")\n        .long(\"db\")\n        .value_name(\"ADDR\")\n        .help(\"Sets an address of db connection\")\n        .takes_value(true),\n        )\n    .subcommand(SubCommand::with_name(CMD_ADD).about(\"add a session\")\n                .arg(Arg::with_name(\"TOKEN\")\n                     .help(\"Sets the token of a user\")\n                     .required(true)\n                     .index(1))\n                .arg(Arg::with_name(\"UID\")\n                     .help(\"Sets the uid of a user\")\n                     .required(true)\n                     .index(2)))\n    .subcommand(SubCommand::with_name(CMD_REMOVE).about(\"remove a session\")\n                .arg(Arg::with_name(\"TOKEN\")\n                     .help(\"Sets the token of a user\")\n                     .required(true)\n                     .index(1)))\n    .subcommand(SubCommand::with_name(CMD_LIST).about(\"print list of sessions\"))\n    .get_matches();\n```", "```rs\nlet addr = matches.value_of(\"database\")\n    .unwrap_or(\"redis://127.0.0.1/\");\nlet manager = RedisConnectionManager::new(addr)?;\nlet pool = r2d2::Pool::builder().build(manager)?;\nlet conn = pool.get()?;\n```", "```rs\nmatch matches.subcommand() {\n    (CMD_ADD, Some(matches)) => {\n        let token = matches.value_of(\"TOKEN\").unwrap();\n        let uid = matches.value_of(\"UID\").unwrap();\n        add_session(&conn, token, uid)?;\n    }\n    (CMD_REMOVE, Some(matches)) => {\n        let token = matches.value_of(\"TOKEN\").unwrap();\n        remove_session(&conn, token)?;\n    }\n    (CMD_LIST, _) => {\n        println!(\"LIST\");\n        let sessions = list_sessions(&conn)?;\n        for (token, uid) in sessions {\n            println!(\"Token: {:20}   Uid: {:20}\", token, uid);\n        }\n    }\n    _ => { matches.usage(); }\n}\n```", "```rs\ncargo run -- add 7vQ2MhnRcyYeTptp a73bbfe3-df6a-4dea-93a8-cb4ea3998a53\ncargo run -- add pTySt8FI7TIqId4N 0f3688be-0efc-4744-829c-be5d177e0e1c\ncargo run -- add zJx3mBRpJ9WTkwGU f985a744-6648-4d0a-af5c-0b71aecdbcba\n```", "```rs\ncargo run -- list\n```", "```rs\nLIST\nToken: pTySt8FI7TIqId4N       Uid: 0f3688be-0efc-4744-829c-be5d177e0e1c\nToken: zJx3mBRpJ9WTkwGU       Uid: f985a744-6648-4d0a-af5c-0b71aecdbcba\nToken: 7vQ2MhnRcyYeTptp       Uid: a73bbfe3-df6a-4dea-93a8-cb4ea3998a53\n```", "```rs\ndocker run -it --rm --name test-mongo -p 27017:27017 mongo\n```", "```rs\nmongo 127.0.0.1:27017/admin\n```", "```rs\ndocker stop test-mongo\n```", "```rs\n[dependencies]\nbson = \"0.13\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\nclap = \"2.32\"\nfailure = \"0.1\"\nmongodb = \"0.3\"\nr2d2 = \"0.8\"\nr2d2-mongodb = \"0.1\"\nserde = \"1.0\"\nserde_derive = \"1.0\"\nurl = \"1.7\"\n```", "```rs\nuse chrono::offset::Utc;\nuse clap::{\n    crate_authors, crate_description, crate_name, crate_version,\n    App, AppSettings, Arg, SubCommand,\n};\nuse mongodb::Error;\nuse mongodb::db::{Database, ThreadedDatabase};\nuse r2d2::Pool;\nuse r2d2_mongodb::{ConnectionOptionsBuilder, MongodbConnectionManager};\nuse url::Url;\n```", "```rs\nconst CMD_ADD: &str = \"add\";\nconst CMD_LIST: &str = \"list\";\n```", "```rs\n#[derive(Deserialize, Debug)]\nstruct Activity {\n    user_id: String,\n    activity: String,\n    datetime: String,\n}\n```", "```rs\nfn add_activity(conn: &Database, activity: Activity) -> Result<(), Error> {\n    let doc = doc! {\n        \"user_id\": activity.user_id,\n        \"activity\": activity.activity,\n        \"datetime\": activity.datetime,\n    };\n    let coll = conn.collection(\"activities\");\n    coll.insert_one(doc, None).map(drop)\n}\n```", "```rs\nfn list_activities(conn: &Database) -> Result<Vec<Activity>, Error> {\n    conn.collection(\"activities\").find(None, None)?\n        .try_fold(Vec::new(), |mut vec, doc| {\n            let doc = doc?;\n            let activity: Activity = bson::from_bson(bson::Bson::Document(doc))?;\n            vec.push(activity);\n            Ok(vec)\n        })\n}\n```", "```rs\nlet matches = App::new(crate_name!())\n    .version(crate_version!())\n    .author(crate_authors!())\n    .about(crate_description!())\n    .setting(AppSettings::SubcommandRequired)\n    .arg(\n        Arg::with_name(\"database\")\n        .short(\"d\")\n        .long(\"db\")\n        .value_name(\"ADDR\")\n        .help(\"Sets an address of db connection\")\n        .takes_value(true),\n        )\n    .subcommand(SubCommand::with_name(CMD_ADD).about(\"add user to the table\")\n                .arg(Arg::with_name(\"USER_ID\")\n                     .help(\"Sets the id of a user\")\n                     .required(true)\n                     .index(1))\n                .arg(Arg::with_name(\"ACTIVITY\")\n                     .help(\"Sets the activity of a user\")\n                     .required(true)\n                     .index(2)))\n    .subcommand(SubCommand::with_name(CMD_LIST).about(\"print activities list of users\"))\n    .get_matches();\n```", "```rs\nlet addr = matches.value_of(\"database\")\n    .unwrap_or(\"mongodb://localhost:27017/admin\");\nlet url = Url::parse(addr)?;\n```", "```rs\nlet opts = ConnectionOptionsBuilder::new()\n    .with_host(url.host_str().unwrap_or(\"localhost\"))\n    .with_port(url.port().unwrap_or(27017))\n    .with_db(&url.path()[1..])\n    .build();\n\nlet manager = MongodbConnectionManager::new(opts);\n\nlet pool = Pool::builder()\n    .max_size(4)\n    .build(manager)?;\n\nlet conn = pool.get()?;\n```", "```rs\nmatch matches.subcommand() {\n    (CMD_ADD, Some(matches)) => {\n        let user_id = matches.value_of(\"USER_ID\").unwrap().to_owned();\n        let activity = matches.value_of(\"ACTIVITY\").unwrap().to_owned();\n        let activity = Activity {\n            user_id,\n            activity,\n            datetime: Utc::now().to_string(),\n        };\n        add_activity(&conn, activity)?;\n    }\n    (CMD_LIST, _) => {\n        let list = list_activities(&conn)?;\n        for item in list {\n            println!(\"User: {:20}    Activity: {:20}    DateTime: {:20}\",\n                     item.user_id, item.activity, item.datetime);\n        }\n    }\n    _ => { matches.usage(); }\n}\n```", "```rs\ncargo run -- add 43fb507d-4cee-431a-a7eb-af31a1eeed02 \"Logged In\"\ncargo run -- add 43fb507d-4cee-431a-a7eb-af31a1eeed02 \"Added contact information\"\ncargo run -- add 43fb507d-4cee-431a-a7eb-af31a1eeed02 \"E-mail confirmed\"\n```", "```rs\ncargo run -- list\n```", "```rs\nUser: 43fb507d-4cee-431a-a7eb-af31a1eeed02   DateTime: 2018-11-30 14:19:26.245957656 UTC    Activity: Logged In\nUser: 43fb507d-4cee-431a-a7eb-af31a1eeed02   DateTime: 2018-11-30 14:19:42.249548906 UTC   Activity: Added contact information\nUser: 43fb507d-4cee-431a-a7eb-af31a1eeed02   DateTime: 2018-11-30 14:19:59.035373758 UTC   Activity: E-mail confirmed\n```", "```rs\nmongo admin\n> db.activities.find()\n{ \"_id\" : ObjectId(\"5c0146ee6531339934e7090c\"), \"user_id\" : \"43fb507d-4cee-431a-a7eb-af31a1eeed02\", \"activity\" : \"Logged In\", \"datetime\" : \"2018-11-30 14:19:26.245957656 UTC\" }\n{ \"_id\" : ObjectId(\"5c0146fe653133b8345ed772\"), \"user_id\" : \"43fb507d-4cee-431a-a7eb-af31a1eeed02\", \"activity\" : \"Added contact information\", \"datetime\" : \"2018-11-30 14:19:42.249548906 UTC\" }\n{ \"_id\" : ObjectId(\"5c01470f653133cf34391c1f\"), \"user_id\" : \"43fb507d-4cee-431a-a7eb-af31a1eeed02\", \"activity\" : \"E-mail confirmed\", \"datetime\" : \"2018-11-30 14:19:59.035373758 UTC\" }\n```", "```rs\ndocker run -it --rm --name test-dynamodb -p 8000:8000 amazon/dynamodb-local\n```", "```rs\npip install awscli --upgrade --user\n```", "```rs\naws configure\nAWS Access Key ID [None]: <your-access-key>\nAWS Secret Access Key [None]: <your-secret-key>\nDefault region name [None]: us-east-1\nDefault output format [None]: json\n```", "```rs\naws dynamodb create-table --cli-input-json file://table.json --endpoint-url http://localhost:8000 --region custom\n```", "```rs\n{\n    \"TableName\" : \"Locations\",\n    \"KeySchema\": [\n        {\n            \"AttributeName\": \"Uid\",\n            \"KeyType\": \"HASH\"\n        },\n        {\n            \"AttributeName\": \"TimeStamp\",\n            \"KeyType\": \"RANGE\"\n        }\n    ],\n    \"AttributeDefinitions\": [\n        {\n            \"AttributeName\": \"Uid\",\n            \"AttributeType\": \"S\"\n        },\n        {\n            \"AttributeName\": \"TimeStamp\",\n            \"AttributeType\": \"S\"\n        }\n    ],\n    \"ProvisionedThroughput\": {\n        \"ReadCapacityUnits\": 1,\n        \"WriteCapacityUnits\": 1\n    }\n}\n```", "```rs\naws dynamodb list-tables --endpoint-url http://localhost:8000 --region custom\n```", "```rs\n{\n    \"TableNames\": [\n        \"Locations\"\n    ]\n}\n```", "```rs\nchrono = \"0.4\"\n\nclap = \"2.32\"\n\nfailure = \"0.1\"\n\nrusoto_core = \"0.36.0\"\n\nrusoto_dynamodb = \"0.36.0\"\n```", "```rs\nuse chrono::Utc;\n\nuse clap::{App, AppSettings, Arg, SubCommand,\n    crate_authors, crate_description, crate_name, crate_version};\n\nuse failure::{Error, format_err};\n\nuse rusoto_core::Region;\n\nuse rusoto_dynamodb::{AttributeValue, DynamoDb, DynamoDbClient,\n    QueryInput, UpdateItemInput};\n\nuse std::collections::HashMap;\n```", "```rs\n#[derive(Debug)]\nstruct Location {\n    user_id: String,\n    timestamp: String,\n    longitude: String,\n    latitude: String,\n}\n```", "```rs\nimpl Location {\n    fn from_map(map: HashMap<String, AttributeValue>) -> Result<Location, Error> {\n        let user_id = map\n            .get(\"Uid\")\n            .ok_or_else(|| format_err!(\"No Uid in record\"))\n            .and_then(attr_to_string)?;\n        let timestamp = map\n            .get(\"TimeStamp\")\n            .ok_or_else(|| format_err!(\"No TimeStamp in record\"))\n            .and_then(attr_to_string)?;\n        let latitude = map\n            .get(\"Latitude\")\n            .ok_or_else(|| format_err!(\"No Latitude in record\"))\n            .and_then(attr_to_string)?;\n        let longitude = map\n            .get(\"Longitude\")\n            .ok_or_else(|| format_err!(\"No Longitude in record\"))\n            .and_then(attr_to_string)?;\n        let location = Location { user_id, timestamp, longitude, latitude };\n        Ok(location)\n    }\n}\n```", "```rs\nfn attr_to_string(attr: &AttributeValue) -> Result<String, Error> {\n    if let Some(value) = &attr.s {\n        Ok(value.to_owned())\n    } else {\n        Err(format_err!(\"no string value\"))\n    }\n}\n```", "```rs\nfn add_location(conn: &DynamoDbClient, location: Location) -> Result<(), Error> {\n    let mut key: HashMap<String, AttributeValue> = HashMap::new();\n    key.insert(\"Uid\".into(), s_attr(location.user_id));\n    key.insert(\"TimeStamp\".into(), s_attr(location.timestamp));\n    let expression = format!(\"SET Latitude = :y, Longitude = :x\");\n    let mut values = HashMap::new();\n    values.insert(\":y\".into(), s_attr(location.latitude));\n    values.insert(\":x\".into(), s_attr(location.longitude));\n    let update = UpdateItemInput {\n        table_name: \"Locations\".into(),\n        key,\n        update_expression: Some(expression),\n        expression_attribute_values: Some(values),\n        ..Default::default()\n    };\n    conn.update_item(update)\n        .sync()\n        .map(drop)\n        .map_err(Error::from)\n}\n```", "```rs\nfn s_attr(s: String) -> AttributeValue {\n    AttributeValue {\n        s: Some(s),\n        ..Default::default()\n    }\n}\n```", "```rs\nfn list_locations(conn: &DynamoDbClient, user_id: String) -> Result<Vec<Location>, Error> {\n    let expression = format!(\"Uid = :uid\");\n    let mut values = HashMap::new();\n    values.insert(\":uid\".into(), s_attr(user_id));\n    let query = QueryInput {\n        table_name: \"Locations\".into(),\n        key_condition_expression: Some(expression),\n        expression_attribute_values: Some(values),\n        ..Default::default()\n    };\n    let items = conn.query(query).sync()?\n        .items\n        .ok_or_else(|| format_err!(\"No Items\"))?;\n    let mut locations = Vec::new();\n    for item in items {\n        let location = Location::from_map(item)?;\n        locations.push(location);\n    }\n    Ok(locations)\n}\n```", "```rs\n.arg(\n   Arg::with_name(\"region\")\n   .long(\"region\")\n   .value_name(\"REGION\")\n   .help(\"Sets a region\")\n   .takes_value(true),\n   )\n.arg(\n   Arg::with_name(\"endpoint\")\n   .long(\"endpoint-url\")\n   .value_name(\"URL\")\n   .help(\"Sets an endpoint url\")\n   .takes_value(true),\n   )\n```", "```rs\n.subcommand(SubCommand::with_name(CMD_ADD).about(\"add geo record to the table\")\n           .arg(Arg::with_name(\"USER_ID\")\n                .help(\"Sets the id of a user\")\n                .required(true)\n                .index(1))\n           .arg(Arg::with_name(\"LATITUDE\")\n                .help(\"Sets a latitudelongitude of location\")\n                .required(true)\n                .index(2))\n           .arg(Arg::with_name(\"LONGITUDE\")\n                .help(\"Sets a longitude of location\")\n                .required(true)\n                .index(3)))\n```", "```rs\n.subcommand(SubCommand::with_name(CMD_LIST).about(\"print all records for the user\")\n           .arg(Arg::with_name(\"USER_ID\")\n                .help(\"User if to filter records\")\n                .required(true)\n                .index(1)))\n```", "```rs\nlet region = matches.value_of(\"endpoint\").map(|endpoint| {\n     Region::Custom {\n         name: \"custom\".into(),\n         endpoint: endpoint.into(),\n     }\n }).ok_or_else(|| format_err!(\"Region not set\"))\n .or_else(|_| {\n     matches.value_of(\"region\")\n         .unwrap_or(\"us-east-1\")\n         .parse()\n })?;\n```", "```rs\nlet client = DynamoDbClient::new(region);\n```", "```rs\n(CMD_ADD, Some(matches)) => {\n     let user_id = matches.value_of(\"USER_ID\").unwrap().to_owned();\n     let timestamp = Utc::now().to_string();\n     let latitude = matches.value_of(\"LATITUDE\").unwrap().to_owned();\n     let longitude = matches.value_of(\"LONGITUDE\").unwrap().to_owned();\n     let location = Location { user_id, timestamp, latitude, longitude };\n     add_location(&client, location)?;\n }\n```", "```rs\n(CMD_LIST, Some(matches)) => {\n     let user_id = matches.value_of(\"USER_ID\").unwrap().to_owned();\n     let locations = list_locations(&client, user_id)?;\n     for location in locations {\n         println!(\"{:?}\", location);\n     }\n }\n```", "```rs\ncargo run -- --endpoint-url http://localhost:8000 add 651B4984-1252-4ECE-90E7-0C8B58541E7C 52.73169 41.44326\ncargo run -- --endpoint-url http://localhost:8000 add 651B4984-1252-4ECE-90E7-0C8B58541E7C 52.73213 41.44443\ncargo run -- --endpoint-url http://localhost:8000 add 651B4984-1252-4ECE-90E7-0C8B58541E7C 52.73124 41.44435\ncargo run -- --endpoint-url http://localhost:8000 add 7E3E27D0-D002-43C4-A0DF-415B2F5FF94D 35.652832 139.839478\n```", "```rs\ncargo run -- --endpoint-url http://localhost:8000 list 651B4984-1252-4ECE-90E7-0C8B58541E7C\n```", "```rs\nLocation { user_id: \"651B4984-1252-4ECE-90E7-0C8B58541E7C\", timestamp: \"2019-01-04 19:58:26.278518362 UTC\", latitude: \"52.73169\", longitude: \"41.44326\" }\nLocation { user_id: \"651B4984-1252-4ECE-90E7-0C8B58541E7C\", timestamp: \"2019-01-04 19:58:42.559125438 UTC\", latitude: \"52.73213\", longitude: \"41.44443\" }\nLocation { user_id: \"651B4984-1252-4ECE-90E7-0C8B58541E7C\", timestamp: \"2019-01-04 19:58:55.730794942 UTC\", latitude: \"52.73124\", longitude: \"41.44435\" }\n```"]