["```rs\n$ cargo new --bin serde-basic\n```", "```rs\n[package]\nname = \"serde-basic\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nserde = \"1.0\"\nserde_derive = \"1.0\"\nserde_json = \"1.0\"\nserde_yaml = \"0.7.1\"\n```", "```rs\n// chapter4/serde-basic/src/main.rs\n\n#[macro_use]\nextern crate serde_derive;\n\nextern crate serde;\nextern crate serde_json;\nextern crate serde_yaml;\n\n// We will serialize and deserialize instances of\n// this struct\n#[derive(Serialize, Deserialize, Debug)]\nstruct ServerConfig {\n    workers: u64,\n    ignore: bool,\n    auth_server: Option<String>\n}\n\nfn main() {\n    let config = ServerConfig {\n                workers: 100, \n                ignore: false, \n                auth_server: Some(\"auth.server.io\".to_string())\n            };\n    {\n        println!(\"To and from YAML\");\n        let serialized = serde_yaml::to_string(&config).unwrap();\n        println!(\"{}\", serialized);\n        let deserialized: ServerConfig =\n        serde_yaml::from_str(&serialized).unwrap();\n        println!(\"{:?}\", deserialized);\n    }\n    println!(\"\\n\\n\");\n    {\n        println!(\"To and from JSON\");\n        let serialized = serde_json::to_string(&config).unwrap();\n        println!(\"{}\", serialized);\n        let deserialized: ServerConfig =\n        serde_json::from_str(&serialized).unwrap();\n        println!(\"{:?}\", deserialized);\n    }\n}\n```", "```rs\n$ cargo run\n   Compiling serde-basic v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/chapter4/serde-basic)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.88 secs\n     Running `target/debug/serde-basic`\nTo and from YAML\n---\nworkers: 100\nignore: false\nauth_server: auth.server.io\nServerConfig { workers: 100, ignore: false, auth_server: Some(\"auth.server.io\") }\n\nTo and from JSON\n{\"workers\":100,\"ignore\":false,\"auth_server\":\"auth.server.io\"}\nServerConfig { workers: 100, ignore: false, auth_server: Some(\"auth.server.io\") }\n```", "```rs\n$ cargo new --bin serde-server\n```", "```rs\n$ cat Cargo.toml\n[package]\nname = \"serde-server\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nserde = \"1.0\"\nserde_derive = \"1.0\"\nserde_json = \"1.0\"\n```", "```rs\n// chapter4/serde-server/src/main.rs\n\n#[macro_use]\nextern crate serde_derive;\n\nextern crate serde;\nextern crate serde_json;\n\nuse std::net::{TcpListener, TcpStream};\nuse std::io::{stdin, BufRead, BufReader, Error, Write};\nuse std::{env, str, thread};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point3D {\n    x: u32,\n    y: u32,\n    z: u32,\n}\n\n// Like previous examples of vanilla TCP servers, this function handles\n// a single client.\nfn handle_client(stream: TcpStream) -> Result<(), Error> {\n    println!(\"Incoming connection from: {}\", stream.peer_addr()?);\n    let mut data = Vec::new();\n    let mut stream = BufReader::new(stream);\n\n    loop {\n        data.clear();\n\n        let bytes_read = stream.read_until(b'\\n', &mut data)?;\n        if bytes_read == 0 {\n            return Ok(());\n        }\n        let input: Point3D = serde_json::from_slice(&data)?;\n        let value = input.x.pow(2) + input.y.pow(2) + input.z.pow(2);\n\n        write!(stream.get_mut(), \"{}\", f64::from(value).sqrt())?;\n        write!(stream.get_mut(), \"{}\", \"\\n\")?;\n    }\n}\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Please provide --client or --server as argument\");\n        std::process::exit(1);\n    }\n    // The server case\n    if args[1] == \"--server\" {\n        let listener = TcpListener::bind(\"0.0.0.0:8888\").expect(\"Could\n        not bind\");\n        for stream in listener.incoming() {\n            match stream {\n                Err(e) => eprintln!(\"failed: {}\", e),\n                Ok(stream) => {\n                    thread::spawn(move || {\n                        handle_client(stream).unwrap_or_else(|error|\n                        eprintln!(\"{:?}\", error));\n                    });\n                }\n            }\n        }\n    }\n    // Client case begins here\n    else if args[1] == \"--client\" {\n        let mut stream = TcpStream::connect(\"127.0.0.1:8888\").expect(\"Could not connect to server\");\n        println!(\"Please provide a 3D point as three comma separated\n        integers\");\n        loop {\n            let mut input = String::new();\n            let mut buffer: Vec<u8> = Vec::new();\n            stdin()\n                .read_line(&mut input)\n                .expect(\"Failed to read from stdin\");\n            let parts: Vec<&str> = input\n                                    .trim_matches('\\n')\n                                    .split(',')\n                                    .collect();\n            let point = Point3D {\n                x: parts[0].parse().unwrap(),\n                y: parts[1].parse().unwrap(),\n                z: parts[2].parse().unwrap(),\n            };\n            stream\n                .write_all(serde_json::to_string(&point).unwrap().as_bytes())\n                .expect(\"Failed to write to server\");\n            stream.write_all(b\"\\n\").expect(\"Failed to write to\n            server\");\n\n            let mut reader = BufReader::new(&stream);\n            reader\n                .read_until(b'\\n', &mut buffer)\n                .expect(\"Could not read into buffer\");\n            let input = str::from_utf8(&buffer).expect(\"Could not write\n            buffer as string\");\n            if input == \"\" {\n                eprintln!(\"Empty response from server\");\n            }\n            print!(\"Response from server {}\", input);\n        }\n    }\n}\n```", "```rs\nserver$ cargo run -- --server\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/serde-server --server`\nIncoming connection from: 127.0.0.1:49630\n```", "```rs\nclient$ cargo run -- --client\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/serde-server --client`\nPlease provide a 3D point as three comma separated integers\n1,2,3\nResponse from server 3.7416573867739413\n3,4,5\nResponse from server 7.0710678118654755\n4,5,6\nResponse from server 8.774964387392123\n```", "```rs\n$ cargo new --bin serde-custom\n```", "```rs\n[package]\nname = \"serde-custom\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nserde = \"1.0\"\nserde_derive = \"1.0\"\nserde_json = \"1.0\"\nserde_test = \"1.0\"\n```", "```rs\n// chapter4/serde-custom/src/main.rs\n\n// We will implement custom serialization and deserialization\n// for this struct\n#[derive(Debug, PartialEq)]\nstruct KubeConfig {\n    port: u8,\n    healthz_port: u8,\n    max_pods: u8,\n}\n```", "```rs\npub trait Serialize {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n        where S: Serializer;\n}\n```", "```rs\n// chapter4/serde-custom/src/main.rs\n\n// Implementing Serialize for our custom struct defines\n// how instances of that struct should be serialized.\n// In essence, serialization of an object is equal to\n// sum of the serializations of it's components\nimpl Serialize for KubeConfig {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n        where S: Serializer\n    {\n        let mut state = serializer.serialize_struct(\"KubeConfig\", 3)?;\n        state.serialize_field(\"port\", &self.port)?;\n        state.serialize_field(\"healthz_port\", &self.healthz_port)?;\n        state.serialize_field(\"max_pods\", &self.max_pods)?;\n        state.end()\n    }\n}\n```", "```rs\npub trait Deserialize<'de>: Sized {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where D: Deserializer<'de>;\n}\n```", "```rs\npub trait Visitor<'de>: Sized {\n    type Value;\n    fn expecting(&self, formatter: &mut Formatter) -> Result;\n    fn visit_bool<E>(self, v: bool) -> Result<Self::Value,\n     E>\n    where\n        E: Error,\n    { }\n    ...\n}\n```", "```rs\n// chapter4/serde-custom/src/main.rs\n\n// Implementing Deserialize for our struct defines how\n// an instance of the struct should be created from an\n// input stream of bytes\nimpl<'de> Deserialize<'de> for KubeConfig {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where D: Deserializer<'de>\n    {\n        enum Field { Port, HealthzPort, MaxPods };\n\n        impl<'de> Deserialize<'de> for Field {\n            fn deserialize<D>(deserializer: D) ->\n            Result<Field,\n            D::Error>\n                where D: Deserializer<'de>\n            {\n                struct FieldVisitor;\n\n                impl<'de> Visitor<'de> for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter)\n                    -> fmt::Result {\n                        formatter.write_str(\"`port` or `healthz_port`\n                        or `max_pods`\")\n                    }\n\n                    fn visit_str<E>(self, value: &str) ->\n                    Result<Field,\n                    E>\n                        where E: de::Error\n                    {\n                        match value {\n                            \"port\" => Ok(Field::Port),\n                            \"healthz_port\" =>\n                            Ok(Field::HealthzPort),\n                            \"max_pods\" => Ok(Field::MaxPods),\n                            _ => Err(de::Error::unknown_field(value, \n                            FIELDS)),\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n}\n```", "```rs\n// chapter4/serde-custom/src/main.rs\n\nimpl<'de> Deserialize<'de> for KubeConfig {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where D: Deserializer<'de>\n    {\n        struct KubeConfigVisitor;\n\n        impl<'de> Visitor<'de> for KubeConfigVisitor {\n            type Value = KubeConfig;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> \n            fmt::Result {\n                formatter.write_str(\"struct KubeConfig\")\n            }\n\n            fn visit_map<V>(self, mut map: V) ->\n            Result<KubeConfig, \n            V::Error>\n                where V: MapAccess<'de>\n            {\n                let mut port = None;\n                let mut hport = None;\n                let mut max = None;\n                while let Some(key) = map.next_key()? {\n                    match key {\n                        Field::Port => {\n                            if port.is_some() {\n                                return \n                            Err(de::Error::duplicate_field(\"port\"));\n                            }\n                            port = Some(map.next_value()?);\n                        }\n                        Field::HealthzPort => {\n                            if hport.is_some() {\n                                return\n                            Err(de::Error::duplicate_field\n                            (\"healthz_port\"));\n                            }\n                            hport = Some(map.next_value()?);\n                        }\n                        Field::MaxPods => {\n                            if max.is_some() {\n                                return \n                                Err(de::Error::duplicate_field\n                                (\"max_pods\"));\n                            }\n                            max = Some(map.next_value()?);\n                        }\n                    }\n                }\n                let port = port.ok_or_else(||\n                de::Error::missing_field(\"port\"))?;\n                let hport = hport.ok_or_else(||\n                de::Error::missing_field(\"healthz_port\"))?;\n                let max = max.ok_or_else(||\n                de::Error::missing_field(\"max_pods\"))?;\n                Ok(KubeConfig {port: port, healthz_port: hport,\n                max_pods: max})\n            }\n        }\n\n        const FIELDS: &'static [&'static str] = &[\"port\",\n        \"healthz_port\", \"max_pods\"];\n        deserializer.deserialize_struct(\"KubeConfig\", FIELDS,\n        KubeConfigVisitor)\n    }\n}\n```", "```rs\n// chapter4/serde-custom/src/main.rs\n\n#[test]\nfn test_ser_de() {\n    let c = KubeConfig { port: 10, healthz_port: 11, max_pods: 12};\n\n    assert_de_tokens(&c, &[\n        Token::Struct { name: \"KubeConfig\", len: 3 },\n        Token::Str(\"port\"),\n        Token::U8(10),\n        Token::Str(\"healthz_port\"),\n        Token::U8(11),\n        Token::Str(\"max_pods\"),\n        Token::U8(12),\n        Token::StructEnd,\n    ]);\n}\n```", "```rs\n// chapter4/serde-custom/src/main.rs\n\nfn main() {\n    let c = KubeConfig { port: 10, healthz_port: 11, max_pods: 12};\n    let serialized = serde_json::to_string(&c).unwrap();\n    println!(\"{:?}\", serialized);\n}\n```", "```rs\n$ cargo test\n   Compiling serde-custom v0.1.0 (file:///serde-custom)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.61 secs\n     Running target/debug/deps/serde_custom-81ee5105cf257563\n\nrunning 1 test\ntest test_ser_de ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n$ cargo run\n   Compiling serde-custom v0.1.0 (file:///serde-custom)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.54 secs\n     Running `target/debug/serde-custom`\n    \"{\\\"port\\\":10,\\\"healthz_port\\\":11,\\\"max_pods\\\":12}\"\n```", "```rs\n$ cargo new --bin nom-http\n```", "```rs\n$ cat Cargo.toml\n[package]\nname = \"nom-http\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies.nom]\nversion = \"3.2.1\"\nfeatures = [\"verbose-errors\", \"nightly\"]\n```", "```rs\n// chapter4/nom-http/src/main.rs\n\n#[macro_use]\nextern crate nom;\n\nuse std::str;\nuse nom::{ErrorKind, IResult};\n\n#[derive(Debug)]\nenum Method {\n    GET,\n    POST,\n}\n\n#[derive(Debug)]\nstruct Request {\n    method: Method,\n    url: String,\n    version: String,\n}\n\n// A parser that parses method out of a HTT request\nnamed!(parse_method<&[u8], Method>,\n       return_error!(ErrorKind::Custom(12), alt!(map!(tag!(\"GET\"), |_| Method::GET) | map!(tag!(\"POST\"), |_| Method::POST))));\n\n// A parser that parses the request part\nnamed!(parse_request<&[u8], Request>, ws!(do_parse!(\n    method: parse_method >>\n    url: map_res!(take_until!(\" \"), str::from_utf8) >>\n    tag!(\"HTTP/\") >>\n    version: map_res!(take_until!(\"\\r\"), str::from_utf8) >>\n    (Request { method: method, url: url.into(), version: version.into() })\n)));\n\n// Driver function for running the overall parser\nfn run_parser(input: &str) {\n    match parse_request(input.as_bytes()) {\n      IResult::Done(rest, value) => println!(\"Rest: {:?} Value: {:?}\",\n      rest, value),\n      IResult::Error(err) => println!(\"{:?}\", err),\n      IResult::Incomplete(needed) => println!(\"{:?}\", needed)\n    }\n}\n\nfn main() {\n    let get = \"GET /home/ HTTP/1.1\\r\\n\";\n    run_parser(get);\n    let post = \"POST /update/ HTTP/1.1\\r\\n\";\n    run_parser(post);\n    let wrong = \"WRONG /wrong/ HTTP/1.1\\r\\n\";\n    run_parser(wrong);\n}\n```", "```rs\n$ cargo run\n   Compiling nom-http v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/ch4/nom-http)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.60 secs\n     Running `target/debug/nom-http`\nRest: [] Value: Request { method: GET, url: \"/home/\", version: \"1.1\" }\nRest: [] Value: Request { method: POST, url: \"/update/\", version: \"1.1\" }\nNodePosition(Custom(128), [87, 82, 79, 78, 71, 32, 47, 119, 114, 111, 110, 103, 47, 32, 72, 84, 84, 80, 47, 49, 46, 49, 13, 10], [Position(Alt, [87, 82, 79, 78, 71, 32, 47, 119, 114, 111, 110, 103, 47, 32, 72, 84, 84, 80, 47, 49, 46, 49, 13, 10])])\n```", "```rs\n$ cargo new --bin pom-string\n```", "```rs\n[package]\nname = \"pom-string\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\npom = \"1.1.0\"\n```", "```rs\n// chapter4/pom-string/src/main.rs\n\nextern crate pom;\n\nuse pom::DataInput;\nuse pom::parser::{sym, one_of, seq};\nuse pom::parser::*;\n\nuse std::str;\n\n// Represents one or more occurrence of an empty whitespace\nfn space() -> Parser<'static, u8, ()> {\n    one_of(b\" \\t\\r\\n\").repeat(0..).discard()\n}\n\n// Represents a string in all lower case\nfn string() -> Parser<'static, u8, String> {\n    one_of(b\"abcdefghijklmnopqrstuvwxyz\").repeat(0..).convert(String::from_utf8)\n}\n\nfn main() {\n    let get = b\"GET /home/ HTTP/1.1\\r\\n\";\n    let mut input = DataInput::new(get);\n    let parser = (seq(b\"GET\") | seq(b\"POST\")) * space() * sym(b'/') *\n    string() * sym(b'/') * space() * seq(b\"HTTP/1.1\");\n    let output = parser.parse(&mut input);\n    println!(\"{:?}\", str::from_utf8(&output.unwrap()));\n}\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/pom-string`\nOk(\"HTTP/1.1\")\n```", "```rs\n$ cargo new --bin nom-ipv6\n```", "```rs\n// chapter4/nom-ipv6/src/main.rs\n\n#[macro_use]\nextern crate nom;\n\nuse std::net::Ipv6Addr;\n\nuse nom::IResult;\n\n// Struct representing an IPv6 header\n#[derive(Debug, PartialEq, Eq)]\npub struct IPv6Header {\n    version: u8,\n    traffic_class: u8,\n    flow_label: u32,\n    payload_length: u16,\n    next_header: u8,\n    hop_limit: u8,\n    source_addr: Ipv6Addr,\n    dest_addr: Ipv6Addr,\n}\n\n// Converts a given slice of [u8] to an array of 16 u8 given by\n// [u8; 16]\nfn slice_to_array(input: &[u8]) -> [u8; 16] {\n    let mut array = [0u8; 16];\n    for (&x, p) in input.iter().zip(array.iter_mut()) {\n        *p = x;\n    }\n    array\n}\n\n// Converts a reference to a slice [u8] to an instance of\n// std::net::Ipv6Addr\nfn to_ipv6_address(i: &[u8]) -> Ipv6Addr {\n    let arr = slice_to_array(i);\n    Ipv6Addr::from(arr)\n}\n\n// Parsers for each individual section of the header\nnamed!(parse_version<&[u8], u8>, bits!(take_bits!(u8, 4)));\nnamed!(parse_traffic_class<&[u8], u8>, bits!(take_bits!(u8, 8)));\nnamed!(parse_flow_label<&[u8], u32>, bits!(take_bits!(u32, 20)));\nnamed!(parse_payload_length<&[u8], u16>, bits!(take_bits!(u16, 16)));\nnamed!(parse_next_header<&[u8], u8>, bits!(take_bits!(u8, 8)));\nnamed!(parse_hop_limit<&[u8], u8>, bits!(take_bits!(u8, 8)));\nnamed!(parse_address<&[u8], Ipv6Addr>, map!(take!(16), to_ipv6_address));\n\n// The primary parser\nnamed!(ipparse<&[u8], IPv6Header>,\n       do_parse!(\n            ver: parse_version >>\n            cls: parse_traffic_class >>\n            lbl: parse_flow_label >>\n            len: parse_payload_length >>\n            hdr: parse_next_header >>\n            lim: parse_hop_limit >>\n            src: parse_address >>\n            dst: parse_address >>\n              (IPv6Header {\n                  version: ver,\n                  traffic_class: cls,\n                  flow_label: lbl,\n                  payload_length: len,\n                  next_header: hdr,\n                  hop_limit: lim,\n                  source_addr: src,\n                  dest_addr : dst\n              })\n));\n\n// Wrapper for the parser\npub fn parse_ipv6_header(i: &[u8]) -> IResult<&[u8], IPv6Header> {\n    ipparse(i)\n}\n\nfn main() {\n    const EMPTY_SLICE: &'static [u8] = &[];\n    let bytes = [0x60,\n                 0x00,\n                 0x08, 0x19,\n                 0x80, 0x00, 0x14, 0x06,\n                 0x40,\n                 0x2a, 0x02, 0x0c, 0x7d, 0x2e, 0x5d, 0x5d, 0x00,\n                 0x24, 0xec, 0x4d, 0xd1, 0xc8, 0xdf, 0xbe, 0x75,\n                 0x2a, 0x00, 0x14, 0x50, 0x40, 0x0c, 0x0c, 0x0b,\n                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd\n                 ];\n\n    let expected = IPv6Header {\n        version: 6,\n        traffic_class: 0,\n        flow_label: 33176,\n        payload_length: 20,\n        next_header: 6,\n        hop_limit: 64,\n        source_addr:\n        \"2a02:c7d:2e5d:5d00:24ec:4dd1:c8df:be75\".parse().unwrap(),\n        dest_addr: \"2a00:1450:400c:c0b::bd\".parse().unwrap(),\n    };\n    assert_eq!(ipparse(&bytes), IResult::Done(EMPTY_SLICE, expected));\n}\n```"]