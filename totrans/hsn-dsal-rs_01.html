<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Hello Rust!</h1>
                </header>
            
            <article>
                
<p class="mce-root">First, thank you for picking up a copy of this book! Many of you will only have talked about the topic of algorithms and data structures back in university. In fact, regardless of whether this is your first endeavor in programming or not, we worked hard to make this book a great learning experience. Our primary focus will be the unique influence of Rust on algorithm and data structure design, so we would like to start with a recap of important fundamentals.</p>
<p class="mce-root">Starting off with the Rust 2018 edition changes, we will cover how borrowing and ownership, mutability, and concurrency influence how and where data can be held, and what algorithms can be executed. In this chapter, you can look forward to learning about the following:</p>
<ul>
<li>A quick refresh on Rust and what awaits in the 2018 edition (Rust 1.31)</li>
<li>The latest and greatest about borrowing and ownership</li>
<li>How we can leverage concurrency and mutability properly</li>
<li>References (not pointers!) to where Rust lives<span><br/></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rust in 2018</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>How old is Rust? It started off in 2006 as a side project of Graydon Hoare, an engineer at Mozilla, and was later (in 2009) adopted by the company. Fast forward to less than a decade later to May 15, 2015, and the Rust team announced a stable version 1.0!</span></p>
<p class="mce-root"><span>During its journey, there have been many features that have been added and removed again (for example, a garbage collector, classes, and interfaces) to help it become the fast and safe language that it is today.</span></p>
<p class="mce-root">Before getting deeper into borrowing and ownership, mutability, concurrency, safety, and so on in Rust, we would like to recap some major concepts in Rust and why they change architectural patterns significantly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The 2018 edition</h1>
                </header>
            
            <article>
                
<p>Rust in the 2015 edition is essentially the 1.0 version with a few non-breaking additions. Between 2015 and 2018, however, features and <span><strong>Requests for Comments </strong></span>(<strong>RFCs</strong>), Rust's way of changing core features with the community, accumulated, and worries about backward compatibility arose.</p>
<p>With the goal of keeping this compatibility, editions were introduced and, with the first additional edition, many major changes made it into the language:</p>
<ul>
<li>Changes to the module path system</li>
<li><kbd>dyn Trait</kbd> and <kbd>impl Trait</kbd> syntax</li>
<li><kbd>async</kbd>/<kbd>await</kbd> syntax</li>
<li>Simplifications to the lifetime syntax</li>
</ul>
<p>With these additions, Rust will introduce asynchronous programming into its syntax (<kbd>async</kbd>/<kbd>await</kbd> keywords) and improve the language's usability. This book uses the Rust 2018, released on December 6, 2018 (<a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html">https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html</a>) edition by default, so all the following snippets will already include these new language features!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Rust language</h1>
                </header>
            
            <article>
                
<p>Many of the established programming languages today are multi-paradigm languages, but still remain focused on the principles of object orientation. This means that they have classes, methods, interfaces, inheritance, and so on, <span>none of which can be found in Rust, giving it a steep learning curve for many established developers.</span></p>
<div class="packt_infobox">More experienced readers will miss many aspects of what makes Rust an excellent language, such as static versus dynamic method invocation, memory layouts, and so on. I recognize the importance of those things, yet for brevity and focus chose to leave it to you to explore these things further. Check the <em>Further reading</em> section for resources.</div>
<p>As a multi-paradigm language, Rust has many functional concepts and paradigms that guide it, but they make traditional object-oriented patterns more difficult to apply. Other than organizing code without classes and interfaces, there are various methods to handle errors, change the code itself, or even work with raw pointers.</p>
<p>In the following sections, we want to explore a few concepts that make Rust unique and have a major influence on the way we develop algorithms and data structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Objects and behavior</h1>
                </header>
            
            <article>
                
<p>Organizing code in Rust is a bit different from regular object-oriented languages such as C#. There, an object is supposed to change its own state, interfaces are simple contract definitions, and specialization is often modeled using class inheritance:</p>
<pre>class Door {<br/>    private bool is_open = false;<br/><br/>    public void Open() {<br/>        this.is_open = true;<br/>    }<br/>}</pre>
<p>With Rust, this pattern would require constant mutability of any <kbd>Door</kbd> instance (thereby requiring explicit locking for thread safety), and without inheritance <kbd>GlassDoor</kbd> would have to duplicate code, making it harder to maintain.</p>
<p>Instead, it's recommended to create traits to implement (shared) behavior. Traits have a lot in common with abstract classes in traditional languages (such as default implementations of methods/functions), yet any <kbd>struct</kbd> in Rust can (and should) implement several of those traits:</p>
<pre>struct Door {<br/>    is_open: bool<br/>}<br/><br/>impl Door {<br/>    fn new(is_open: bool) -&gt; Door {<br/>        Door { is_open: is_open }<br/>    }<br/>}<br/><br/>trait Openable {<br/>    fn open(&amp;mut self);<br/>}<br/><br/>impl Openable for Door {<br/>    fn open(&amp;mut self) {<br/>        self.is_open = true;<br/>    }<br/>}<br/><br/>#[cfg(test)]<br/>mod tests {<br/>    use super::*;<br/><br/>    #[test]<br/>    fn open_door() {<br/>        let mut door = Door::new(false);<br/>        door.open();<br/>        assert!(door.is_open);<br/>    }<br/>}</pre>
<p>This pattern is very common in the standard library, and often third-party libraries will even add behavior to existing types by implementing traits in their code (also known as extension traits).</p>
<p>Other than a typical class, where data fields and methods are in a single construct, Rust emphasizes the separation between those by declaring a <kbd>struct</kbd> for data and an <kbd>impl</kbd> part for the methods/functions. Traits name and encapsulate behaviors so they can easily be imported, shared, and reused.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Going wrong</h1>
                </header>
            
            <article>
                
<p>Other than classes, Rust comes without another well-known companion: <kbd>null</kbd>. In the absence of pointers and with a very different memory management model, there is no typical <kbd>null</kbd> pointer/reference.</p>
<p>Instead, the language works with <kbd>Option</kbd> and <kbd>Result</kbd> types that let developers model success or failure. In fact, there is no exception system either, so any failed execution of a function should be indicated in the return type. Only in rare cases when immediate termination is required does the language provide a macro for panicking: <kbd>panic!()</kbd>.</p>
<p><kbd>Option&lt;T&gt;</kbd> and <kbd>Result&lt;T, E&gt;</kbd> both encapsulate one (<kbd>Option&lt;T&gt;</kbd>) or two (<kbd>Result&lt;T, E&gt;</kbd>) values that can be returned to communicate an error or whether something was found or not. For example, a <kbd>find()</kbd> <span>function</span> <span>could return</span> <kbd>Option&lt;T&gt;</kbd><span>, whereas something like</span> <kbd>read_file()</kbd> <span>would typically have a</span> <kbd>Result&lt;T, E&gt;</kbd> <span>return type to communicate the content or errors:</span></p>
<pre>fn find(needle: u16, haystack: Vec&lt;u16&gt;) -&gt; Option&lt;usize&gt; {<br/>    // find the needle in the haystack<br/>}<br/><br/>fn read_file(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {<br/>    // open the path as a file and read it<br/>}</pre>
<p>Handling those return values is often done with <kbd>match</kbd> or <kbd>if let</kbd> clauses in order to handle the cases of success or failure:</p>
<pre>match find(2, vec![1,3,4,5]) {<br/>    Some(_) =&gt; println!("Found!"),<br/>    None =&gt; println!("Not found :(")<br/>}<br/><br/>// another way<br/>if let Some(result) = find(2, vec![1,2,3,4]) {<br/>    println!("Found!")<br/>}<br/><br/>// similarly for results!<br/>match read_file("/tmp/not/a/file") {<br/>    Ok(content) =&gt; println!(content),<br/>    Err(error) =&gt; println!("Oh no!")<br/>}</pre>
<p>This is due to <kbd>Option&lt;T&gt;</kbd> and <kbd>Result&lt;T, E&gt;</kbd> both being enumerations that have generic type parameters; they can assume any type in their variants. Matching on their variants provides access to their inner values and types to allow a branch of the code to be executed and handle the case accordingly. Not only does this eliminate the need for constructs such as try/catch with multiple—sometimes cast—exception arms, it makes failure part of the normal workflow that needs to be taken care of.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Macros</h1>
                </header>
            
            <article>
                
<p>Another aspect of Rust is the ability to do metaprogramming—basically programming programming—using macros! Macros are expanded in Rust code before compilation, which gives them more power than a regular function. The generated code can, for instance, create functions on the fly or implement traits for a structure.</p>
<p>These pieces of code make everyday life a lot easier by reducing the need to create and then initialize vectors, deriving the ability to clone a structure, or simply printing stuff to the command line.</p>
<p>This is a simplified example for the declarative <kbd>vec![]</kbd> macro provided in the <em>Rust Book</em> (second edition, Appendix D):</p>
<pre><span class="hljs-meta">#[macro_export]</span><span> <br/></span><span class="hljs-built_in">macro_rules!</span><span> vec {<br/>     ( $( $x:expr ),* ) =&gt; {<br/>         {             <br/>            </span><span class="hljs-keyword">let</span><span> </span><span class="hljs-keyword">mut</span><span> temp_vec = </span><span class="hljs-built_in">Vec</span><span>::new();              <br/>             $( temp_vec.push($x); )*      <br/>            temp_vec<br/>         }     <br/>    }; <br/>}</span></pre>
<p>Declarative macros work on patterns and run code if that pattern matches; the previous example matches <em>0 - n</em> expressions (for example, a number, or a function that returns a number) and inserts <kbd>temp_vec.push(...)</kbd> <em>n</em> times, iterating over the provided expressions as a parameter.</p>
<p>The second type, procedural macros, operate differently and are often used to provide a default trait implementation. In many code bases, the <kbd>#[derive(Clone, Debug)]</kbd> statement can be found on top of structures to implement the <kbd>Clone</kbd> and <kbd>Debug</kbd> traits automatically.</p>
<p>Later in this chapter, we are going to use a structure, <kbd>FileName</kbd>, to illustrate reference counting, but for printing it to the command line using the debug literal <kbd>"{:?}"</kbd>, we need to derive <kbd>Debug</kbd>, which recursively prints all members to the command line:</p>
<div>
<pre><span>#[derive(Debug)]<br/></span><span>struct</span><span> </span><span>FileName</span><span> {<br/></span><span>    name: Rc</span><span>&lt;</span><span>String</span><span>&gt;</span><span>,<br/></span><span>    ext: Rc</span><span>&lt;</span><span>String</span><span>&gt;<br/></span><span>}</span></pre></div>
<p>The Rust standard library provides several macros already, and by creating custom macros, you can minimize the boilerplate code you have to write.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unsafe</h1>
                </header>
            
            <article>
                
<p>Rust's code is "safe" because the compiler checks and enforces certain behavior when it comes to memory access and management. However, sometimes these rules have to be forgone, making the code unsafe. <kbd>unsafe</kbd> is a keyword in Rust and declares a section of code that can do most of the things the C programming language would let you do. For example, it lets the user do the following (from the <em>Rust Book</em>, chapter 19.1):</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an <kbd>unsafe</kbd> function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an <kbd>unsafe</kbd> trait</li>
</ul>
<p>These four abilities can be used for things such as very low-level device access, language interoperability (the compiler can't know what native libraries do with their memory), and so on. In most cases, and certainly in this book, <kbd>unsafe</kbd> is not required. In fact, the Rustonomicon (<a href="https://doc.rust-lang.org/nomicon/what-unsafe-does.html">https://doc.rust-lang.org/nomicon/what-unsafe-does.html</a>) defines a list of issues the language is trying to prevent from happening by providing the safe part:</p>
<ul>
<li>Dereferencing null, dangling, or unaligned pointers.</li>
<li>Reading uninitialized memory.</li>
<li>Breaking the pointer aliasing rules.</li>
<li>Producing invalid primitive values:
<ul>
<li>Dangling/null references</li>
<li>Null <kbd>fn</kbd> pointers</li>
<li>A bool that isn't 0 or 1</li>
<li>An undefined <kbd>enum</kbd> discriminant</li>
<li>A char outside the ranges [<kbd>0x0</kbd>, <kbd>0xD7FF</kbd>] and [<kbd>0xE000</kbd>, <kbd>0x10FFFF</kbd>]</li>
<li>A non-UTF8 string</li>
</ul>
</li>
<li>Unwinding into another language.</li>
<li>Causing a data race.</li>
</ul>
<p>The fact that these potential issues are prevented in safe Rust certainly makes the life of a developer easier, especially when designing algorithms or data structures. As a consequence, this book will always work with safe Rust.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Borrowing and ownership</h1>
                </header>
            
            <article>
                
<p><span>Rust is famous for its memory management model, which replaces runtime garbage collection with compile-time checks for memory safety. The reason why Rust can work without a garbage collector and still free the programmer from error-prone memory management is simple (but not easy): borrowing and ownership.</span></p>
<p><span>While the particulars are quite complex, the high-level view is that the compiler inserts any "provide <em>x</em> amounts of memory" and "remove <em>x</em> amounts of memory" (somewhat like <kbd>malloc()</kbd> and <kbd>free()</kbd> for C programmers) statements for the developer. Yet how can it do that?</span></p>
<div class="packt_tip">The rules of ownership are as follows:<br/>
<ul>
<li>The owner of a value is a variable</li>
<li>At any time, only a single owner is allowed</li>
<li>The value is lost once the owner goes out of scope</li>
</ul>
</div>
<p>This is where Rust's declarative syntax comes into play. By declaring a variable, the compiler knows—at compile time—that a certain amount of memory needs to be reserved. The lifetime is clearly defined too, from the beginning to end of a block or function, or as long as the <kbd>struct</kbd> instance lives. If the size of this variable is known at compile time, the compiler can provide exactly the necessary amount of memory to the function for the time required. To illustrate, let's consider this snippet, where two variables are allocated and removed in a deterministic order:</p>
<pre>fn my_func() {<br/>    // the compiler allocates memory for x <br/>    let x = LargeObject::new(); <br/>    x.do_some_computation();<br/>    // allocate memory for y<br/>    let y = call_another_func();<br/>    if y &gt; 10 {<br/>        do_more_things();<br/>    }<br/>} // deallocate (drop) x, y</pre>
<p><span>Is this not what every other compiler does? The answer is yes—and no. At compile time, the "provide <em>x</em> amounts of memory" part is fairly simple; the tricky part is keeping track of how much is still in use when references can be passed around freely. If, during the course of a function, a particular local reference becomes invalid, a static code analysis will tell the compiler about the lifetime of the value behind the reference. However, what if a thread changes that value at an unknown time during the function's execution?</span></p>
<p class="mce-root">At compile time, this is impossible to know, which is why many languages do these checks at runtime using a garbage collector. Rust forgoes this, with two primary strategies:</p>
<ul>
<li>Every variable is owned by exactly one scope at any time</li>
<li>Therefore, the developer is forced to pass ownership as required</li>
</ul>
<p class="mce-root">Especially when working with scopes, the nature of stack variables comes in handy. <span>There are two areas of memory, stack and heap, and, s</span>imilar to other languages, the developer uses types to decide whether to allocate heap (<kbd>Box</kbd>, <kbd>Rc</kbd>, and so on) or stack memory.</p>
<p>Stack memory is usually short-lived and smaller, and operates in a first-in, last-out manner. Consequently, a variable's size has to be known before it is put on the stack:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/04d4f181-3289-4b0a-97ed-7942ad366875.png" style="width:34.75em;height:23.83em;"/></p>
<p>Heap memory is different; it's a large portion of the memory, which makes it easy to allocate more whenever needed. There is no ordering, and memory is accessed by using an addresses. Since the pointer to an address on the heap has a known size at compile time, it fits nicely on the stack:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f30496bb-f144-45a9-befa-4e66a0f8b4cf.png" style="width:35.25em;height:19.75em;"/></p>
<p>Stack variables are typically passed by value in other languages, which means that the entire value is copied and placed into the stack frame of the function. Rust does the same, but it also invalidates further use of that variable in the—now parent—scope. Ownership moves into the new scope and can only be transferred back as a return value. When trying to compile this snippet, the compiler will complain:</p>
<pre>fn my_function() {<br/>    let x = 10;<br/>    do_something(x); // ownership is moved here<br/>    let y = x;       // x is now invalid!<br/>}</pre>
<p>Borrowing is similar but, instead of copying the entire value, a reference to the original value is moved into the new scope. Just like in real life, the value continues to be owned by the original scope; scopes with a reference are just allowed to use it as it was provided. Of course, this comes with drawbacks for mutability, and some functions will require ownership for technical and semantic reasons, but it also has advantages such as a smaller memory footprint.</p>
<div class="packt_tip">These are the rules of borrowing:<br/>
<ul>
<li>Owners can have immutable or mutable references, but not both</li>
<li>There can be multiple immutable references, but only one mutable reference</li>
<li>References cannot be invalid</li>
</ul>
</div>
<p>By changing the previous snippet to borrow the variable to <kbd>do_something()</kbd> (assuming this is allowed, of course), the compiler will be happy:</p>
<pre>fn my_function() {<br/>    let x = 10;<br/>    do_something(&amp;x); // pass a reference to x<br/>    let y = x;        // x is still valid!<br/>}</pre>
<p>Borrowed variables rely heavily on lifetimes. The most basic lifetime is the scope it was created in. However, if a reference should go into a struct field, how can the compiler know that the underlying value has not been invalidated? The answer is explicit lifetimes!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exceptional lifetimes</h1>
                </header>
            
            <article>
                
<p>Some lifetimes are different and Rust denominates them with a <kbd>'</kbd>. While this could be the predefined <kbd>'static</kbd>, it's equally possible to create your own, something that is often required when working with structures.</p>
<p>This makes sense when thinking about the underlying memory structure: if an input parameter is passed into the function and returned at the end, its lifetime surpasses the function's. While the function owns this part of the memory during its lifetime, it cannot borrow a variable for longer than it actually exists. So, this snippet cannot work:</p>
<div>
<pre>fn another_function(mut passing_through: MyStruct) -&gt; MyStruct {<br/>    let x = vec![1, 2, 3];<br/><br/>    // passing_through cannot hold a reference <br/>    // to a shorter lived x!<br/>    // the compiler will complain.<br/>    passing_through.x = &amp;x;<br/><br/>    return passing_through;<br/>} // x's life ends here</pre></div>
<p>The reason is that the <kbd>passing_through</kbd> <span>variable</span> <span>outlives</span> <kbd>x</kbd><span>. There are several solutions to this</span> problem<span>:</span></p>
<ul>
<li>Change the type definition of <kbd>MyStruct</kbd> to require ownership. This way, the structure now owns the variable and it will live as long as the structure:</li>
</ul>
<pre style="padding-left: 60px">fn another_function(mut passing_through: MyStruct) -&gt; MyStruct {<br/>    let x = vec![1, 2, 3];<br/><br/>    // passing_through owns x and it will be<br/>    // dropped together with passing_through.<br/>    passing_through.<span>x = x;</span> <br/><br/>    return passing_through;<br/>}</pre>
<ul>
<li>Clone <kbd>x</kbd> to pass ownership into <kbd>passing_through</kbd>:</li>
</ul>
<pre style="padding-left: 60px">fn another_function(mut passing_through: MyStruct) -&gt; MyStruct {<br/>    let x = vec![1, 2, 3];<br/>    let y = &amp;x;<br/><br/>    // passing_through owns a deep copy of x'value that is be<br/>    // dropped together with passing_through.<br/>    passing_through.<span>x = y.clone();</span> <br/><br/>    return passing_through;<br/>}</pre>
<ul>
<li>In this case, <kbd>vec![]</kbd> is statically defined, so it could make sense to add it as a function parameter. This is not only more allocation-efficient, but also can enforce an appropriate lifetime:</li>
</ul>
<pre style="padding-left: 60px">fn another_function&lt;'a&gt;(mut passing_through: MyStruct&lt;'a&gt;, x: &amp;'a Vec&lt;u32&gt;) -&gt; MyStruct&lt;'a&gt; {<br/><br/>    // The compiler knows and expects a lifetime that is <br/>    // at least as long as the struct's <br/>    // of any reference passed in as x. <br/>    passing_through.<span>x = x;</span> <br/><br/>    return passing_through;<br/>}</pre>
<p>Lifetimes cause a lot of strange errors for many Rust users, and in the 2018 edition there is one less to worry about. With the introduction of non-lexical lifetimes, the borrow checker got a lot smarter and it is now able to check—up to a certain degree—semantically whether the variable was used. <span>Recall from the rules of borrowing that, if a mutable reference is created, no immutable references can exist.</span></p>
<p>This code did not compile before Rust 1.31:</p>
<pre><span>fn main() {     <br/>    let mut a = 42;     <br/>    let b = &amp;a; // borrow a     <br/>    let c = &amp;mut a; // borrow a again, mutably         <br/>    // ... but don't ever use b<br/>}</span></pre>
<p>Now it will compile since the compiler does not just check the beginning and ending of a scope, but also if the reference was used at all.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple owners</h1>
                </header>
            
            <article>
                
<p>As powerful as single ownership is, it does not work for every use case. Large objects or shared objects that other instances need to own are examples where <span><span>immutable</span></span> ownership makes life easier. Consider a function that requires an owned object to be passed in:</p>
<div>
<pre><span>#[derive(Debug)]<br/>struct FileName {<br/>    name: String,<br/>    ext: String <br/>}<br/><br/></span><span>fn</span><span> no_</span><span>ref_counter</span><span>() {<br/></span><span>    let</span><span> name </span><span>=</span><span> </span><span>String</span><span>::</span><span>from</span><span>(</span><span>"main"</span><span>);<br/>    let ext = String::from("rs");<br/><br/>    </span><span>for</span><span> _ </span><span>in</span><span> </span><span>0</span><span>..</span><span>3</span><span> {<br/>        println!("{;?}", </span><span>FileName {<br/>                    name: name, <br/>                    ext: ext <br/>        });</span><span><br/>    </span><span>}<br/></span><span>}</span></pre></div>
<p>When trying to compile <kbd>no_ref_counter()</kbd>, the compiler creates a scope for each iteration of the loop and owns any value that is used within it. This works exactly once, since afterward, the variable has been moved and is inaccessible for subsequent iterations.</p>
<p>Consequently, these values (in this case, <kbd>name</kbd> and <kbd>ext</kbd>) are gone and compilation will yield two errors, one for each "second" move of a string:</p>
<pre><strong>error[E0382]: use of moved value: `name`</strong><br/><strong> --&gt; src/main.rs:63:33</strong><br/><strong> |</strong><br/><strong>63 | let _ = FileName { name: name, ext: ext };</strong><br/><strong> |                            ^^^^ value moved here in previous iteration of loop</strong><br/><strong> |</strong><br/><strong> = note: move occurs because `name` has type `std::string::String`, which does not implement the `Copy` trait</strong><br/><br/><strong>error[E0382]: use of moved value: `ext`</strong><br/><strong> --&gt; src/main.rs:63:44</strong><br/><strong> |</strong><br/><strong>63 | let _ = FileName { name: name, ext: ext };</strong><br/><strong> |                                       ^^^ value moved here in previous iteration of loop</strong><br/><strong> |</strong><br/><strong> = note: move occurs because `ext` has type `std::string::String`, which does not implement the `Copy` trait</strong></pre>
<p>One solution is to clone the object in every iteration, but that causes a lot of slow memory allocations. For this, the Rust standard library provides a solution: reference counting.</p>
<p>A reference counter (<kbd>std::rc::Rc&lt;T&gt;</kbd>) encapsulates a variable of type <kbd>T</kbd> allocated on the heap and returns an <strong>immutable</strong> reference when created. This reference can be cloned with low overhead (it's only a reference count that is incremented) but never transformed into a mutable reference. Regardless, it acts just like owned data, passing through function calls and property lookups.</p>
<p>While this requires a change to the variable types, a call to <kbd>clone()</kbd> is now far cheaper than cloning the data directly:</p>
<pre><span>use std::rc::Rc;<br/><br/>#[derive(Debug)]<br/>struct FileName {<br/>    name: Rc&lt;String&gt;,<br/>    ext: Rc&lt;String&gt; <br/>}<br/><br/></span><span>fn</span><span> </span><span>ref_counter</span><span>() {<br/></span><span>    let</span><span> name </span><span>=</span><span> Rc::new(</span><span>String</span><span>::</span><span>from</span><span>(</span><span>"main"</span><span>));<br/>    let ext = Rc::new(String::from("rs")));<br/><br/>    </span><span>for</span><span> _ </span><span>in</span><span> </span><span>0</span><span>..</span><span>3</span><span> {<br/>        println!("{;?}", </span><span>FileName {<br/>                    name: name.clone(), <br/>                    ext: ext.clone() <br/>        });</span><span><br/>    </span><span>}<br/></span><span>}</span></pre>
<p>Running this snippet prints the debug version of the <kbd>FileName</kbd> object three times:</p>
<pre><strong>FileName { name: "main", ext: "rs" }</strong><br/><strong>FileName { name: "main", ext: "rs" }</strong><br/><strong>FileName { name: "main", ext: "rs" }</strong></pre>
<p>This approach works great for single-threaded and immutable scenarios, but will refuse to compile multithreaded code. The solution to this will be discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concurrency and mutability</h1>
                </header>
            
            <article>
                
<p>Rust's approach to managing memory is a powerful concept. In fact, it is powerful enough to also facilitate concurrency and parallel execution. However, first things first: how do threads work in the Rust standard library?</p>
<div class="packt_infobox">Concurrency and parallelism are two different modes of execution. While concurrency means that parts of a program run independently of each other, parallelism refers to these parts executing at the same time. For simplicity, we will refer to both concepts as concurrency.</div>
<p><span>Due to its low-level nature, Rust provides an API to the operating system's threading capabilities (for example, POSIX on Linux/Unix systems). If no variables are passed into the scope, their usage is very straightforward:</span></p>
<pre><span class="hljs-keyword">use</span><span> std::thread; <br/><br/></span><span class="hljs-function"><span class="hljs-keyword">fn</span> threading</span><span>() { <br/>    // The to pipes (||) is the space where parameters go,<br/>    // akin to a function signature's parameters, without<br/>    // the need to always declare types explicitly. <br/>    // This way, variables can move from the outer into the inner scope<br/></span><span>    </span><span class="hljs-keyword">let</span><span> handle = thread::spawn(|| { <br/>        </span><span class="hljs-built_in">println!</span><span>(</span><span class="hljs-string">"Hello from a thread"</span><span>);<br/>    }); <br/>    handle.join().unwrap(); <br/>}</span></pre>
<p>However, when passing data back and forth, more work has to be done to hold up Rust's safety guarantees, especially when mutability comes into play. Before getting into that, it is important to recap immutability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Immutable variables</h1>
                </header>
            
            <article>
                
<p>Rust—like many functional languages—embraces immutable variables. They are the default, and changing mutability requires explicit declaration with <kbd>mut</kbd>, which tells the compiler what the variable is going to be used for (reading or writing).</p>
<p>Functional programming languages are known for facilitating the ability to work concurrently, thanks to immutability guarantees; reading data does not produce side effects! Requiring explicit mutability gives the compiler a chance to check where and if mutability is required, and therefore whether a data race may occur.</p>
<p>This results in compile-time warnings and errors instead of crashes and strange race conditions at runtime, something that many production users appreciate. In short, it's easier to think through your code if mutability is a (rare) option instead of the norm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shadowing</h1>
                </header>
            
            <article>
                
<p>Instead of changing variable properties, it's often more readable to overwrite a variable with a different value (for example, a changed copy of the original). This technique is called <strong>shadowing</strong>.</p>
<p>Typically, this is used to reuse a variable name, even though the actual value has changed, to work in the current situation. This snippet sanitizes <kbd>String</kbd> and, by using the same name throughout the function, it's always clear that it's the input parameter that is changed:</p>
<pre>fn sanitize(s: String) -&gt; String {<br/>    let s = s.trim();<br/>    let s = s.replace(" ", "_");<br/>    s<br/>} </pre>
<p>While this is akin to changing the value of a variable, shadowing does not replace mutability, especially when it's less costly to actually change properties of that variable; Rust has a specific design pattern for that!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interior mutability</h1>
                </header>
            
            <article>
                
<p>Can a variable be immutable and mutable at the same time? Of course. Boxed variables (<kbd>Box</kbd>, <kbd>Rc</kbd>, and so on) are an immutable reference to the heap and they contain the actual value.</p>
<p>For these kinds of containers, there is no reason why the inner variable cannot be changed—a task that can be done safely in Rust using <kbd>RefCell</kbd>. <kbd>RefCell</kbd> maintains single ownership of a value but allows mutable borrowing <strong>checked at runtime.</strong> Instead of compiler errors, violating the rules of borrowing will lead to a runtime <kbd>panic!</kbd>, crashing the program.</p>
<p>This entire concept is called <strong>interior mutability</strong> and is often used in combination with <kbd>Rc</kbd> in order to provide a value to multiple owners with mutability at will. Clearly, to provide a great user experience, it is strongly recommended to make sure the borrowing rules can't be violated in other ways.</p>
<p>Wrapping a <kbd>RefCell</kbd> in an <kbd>Rc</kbd> acts as the gatekeeper for having multiple owners, including a way to change the contents. This is actually similar to more traditional programming languages such as Java or C#, where typically references are moved between method calls, pointing to the object's instance on the heap memory.</p>
<p>This pattern is very important for implementing complex programs and data structures, since ownership of a specific variable is not always clear. For example, later in the book we will examine doubly linked lists, which famously have a pointer to the preceding and succeeding node. Which node <em>should</em> have ownership of which pointer? Interior mutability allows us to say both. Consider the node declaration we will <span>use</span> <span>later:</span></p>
<pre>use std::cell::RefCell;<br/>use std::rc::Rc;<br/><br/>#[derive(Clone)]<br/>struct Node {<br/>    value: String,<br/>    next: Link,<br/>    prev: Link,<br/>}<br/><br/>type Link = Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;;</pre>
<p><span><span>With this list declaration</span></span>, we can see the pattern in this simpler version of the <kbd>append</kbd> function:</p>
<pre>pub fn append(&amp;mut self, value: String) {<br/>    let new = Rc::new(RefCell::new(Node::new(value)));<br/>    match self.tail.take() {<br/>        Some(old) =&gt; {<br/>            old.borrow_mut().next = Some(new.clone());<br/>            new.borrow_mut().prev = Some(old);<br/>        }<br/>        None =&gt; self.head = Some(new.clone()),<br/>    };<br/>}</pre>
<p>This code adds a new node at the front (head) of the list, which contains all data in the form of nodes stored on the heap. In order to add a node at the head of the list, the references have to be set properly, so the previous and next pointers actually refer to the same nodes instead of copies. A more detailed exploration is going to be covered in <a href="1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml">Chapter 3</a>, <em>Lists, Lists, and More Lists</em>. For now, the important part is setting the variables using <kbd>borrow_mut()</kbd>. This mutable reference only lives as long as the assignment takes, thereby ruling out creating a too-large scope and violating the borrowing rules.</p>
<p>By using the <kbd>RefCell</kbd> function's <kbd>borrow_mut()</kbd>, it will check for and enforce borrowing rules and panic in the case of a violation. Later on, we will also talk about the <kbd>Mutex</kbd> type, which is essentially a multithreaded version of these cells.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Moving data</h1>
                </header>
            
            <article>
                
<p>The introductory snippet showed code that spawns a thread but did not pass any data into the scope. Just like any other scope, it requires either ownership of a value or at least a borrowed reference in order to work with that data. In this case, passing ownership is what we want, something that is called <strong>moving data</strong> into the scope.</p>
<p>If we change the snippet from the introduction to include a simple variable to print from within the thread, compilation is going to fail:</p>
<pre><span class="hljs-keyword">use</span><span> std::thread; <br/><br/></span><span class="hljs-function"><span class="hljs-keyword">fn</span> threading</span><span>() { <br/>    let x = 10;<br/></span><span>    </span><span class="hljs-keyword">let</span><span> handle = thread::spawn(|| { <br/>        </span><span class="hljs-built_in">println!</span><span>(</span><span class="hljs-string">"Hello from a thread, the number is {}", x</span><span>);<br/>    }); <br/>    handle.join().unwrap(); <br/>}</span></pre>
<p>The reason for this is simple: the compiler cannot determine the lifetimes of each of the scopes (will <kbd>x</kbd> still be there when the thread needs it?), so it refuses to compile the code:</p>
<pre><span><strong>Compiling ch1 v0.1.0 (file:///code/ch1) </strong><br/><strong>error[E0373]: closure may outlive the current function, but it borrows `x`, which is owned by the current function </strong><br/><strong> --&gt; src/main.rs:5:32 </strong><br/><strong>  | </strong><br/><strong>5 |     let handle = thread::spawn(|| {  </strong><br/><strong>  |                                ^^ may outlive borrowed value `x` </strong><br/><strong>6 |         println!("Hello from a thread, the number is {}", x); </strong><br/><strong>  |                                                           - `x` is borrowed here </strong><br/><strong>help: to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword </strong><br/><strong>  | </strong><br/><strong>5 |     let handle = thread::spawn(move || { </strong><br/><strong>  |                                ^^^^^^^</strong></span></pre>
<p>As the compiler messages indicate, adding the <kbd>move</kbd> keyword will solve the issue! This keyword lets a thread pass ownership to a different thread; it "moves" the memory area:</p>
<div>
<pre>fn threading() { <br/>    let x = 10;<br/>    let handle = thread::spawn(move || {<br/>        println!("Hello from a thread, the number is {}", x);<br/>    }); <br/>    handle.join().unwrap(); <br/>} </pre></div>
<p>When running this snippet, the output is as follows:</p>
<pre><span><strong>Hello from a thread, the number is 10</strong></span></pre>
<p>However, for passing multiple messages into a thread or implementing <em>an actor model</em>, the Rust standard library offers channels. Channels are single-consumer, multi-producer queues that let the caller send messages from multiple threads.</p>
<p>This snippet will spawn 10 threads and have each send a number into the channel, where it will be collected into a vector after the senders have finished executing:</p>
<div>
<pre>use std::sync::mpsc::{channel, Sender, Receiver};<br/><br/>fn channels() {<br/>    const N: i32 = 10;<br/>    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = channel();<br/>    let handles = (0..N).map(|i| {<br/>        let _tx = tx.clone();<br/>        thread::spawn(move || { <br/>            // don't use the result<br/>            let _ = _tx.send(i).unwrap(); <br/>        })<br/>    });<br/>    // close all threads<br/>    for h in handles {<br/>        h.join().unwrap();<br/>    }<br/>    // receive N times<br/>    let numbers: Vec&lt;i32&gt; = (0..N).map(|_|<br/>            rx.recv().unwrap()<br/>        ).collect();<br/>    <br/>    println!("{:?}", numbers);<br/>}</pre></div>
<p>As expected, the output is as follows:</p>
<pre><span><strong>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</strong></span></pre>
<p>With these tools, a multithreaded application can move data between threads without the need for manual locking or the dangers of inadvertently creating side effects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sharing data</h1>
                </header>
            
            <article>
                
<p>Other than sending data into threads <span>one way</span>, many programs operate on a shared state where multiple execution streams have to access and change one or more shared variables. Typically, this warrants a <strong>mutex</strong> (short for <strong>mutual exclusion</strong>), so that any time something is accessed within this locked mutex, it is guaranteed to be a single thread.</p>
<p>This is an old concept and implemented in the Rust standard library. How does that facilitate accessing a variable? Wrapping a variable into a <kbd>Mutex</kbd> type will provide for the locking mechanism, thereby making it accessible from multiple concurrent writers. However, they don't have ownership of that memory area yet.</p>
<p>In order to provide that ownership across threads—similar to what <kbd>Rc</kbd> does within a single thread—Rust provides the concept of an <kbd>Arc</kbd>, an atomic reference counter. Using this <kbd>Mutex</kbd> on top, it's the thread-safe equivalent of an <kbd>Rc</kbd> wrapping a <kbd>RefCell</kbd>, a reference counter that wraps a mutable container. To provide an example, this works nicely:</p>
<pre class="mce-root">use std::thread;<br/>use std::sync::{Mutex, Arc};<br/><br/>fn shared_state() {<br/>    let v = Arc::new(Mutex::new(vec![]));<br/>    let handles = (0..10).map(|i| {<br/>        let numbers = Arc::clone(&amp;v);<br/>        thread::spawn(move || {<br/>            let mut vector = numbers<br/>                .lock()<br/>                .unwrap();<br/>            (*vector).push(i);<br/>        })<br/>    });<br/><br/>    for handle in handles {<br/>        handle.join().unwrap();<br/>    }<br/>    println!("{:?}", *v.lock().unwrap());<br/>}</pre>
<p>When running this example, the output is this:</p>
<pre><strong>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</strong><span> </span></pre>
<p>While the preferred way of doing concurrent programming is still to use immutable variables as often as possible, safe Rust provides the tools for working with shared data without side effects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Send and Sync</h1>
                </header>
            
            <article>
                
<p>These marker traits are fundamental to Rust's multithreading policies. They have distinct purposes:</p>
<ul>
<li><kbd>Send</kbd>: A data type is safe to send (move) from one thread to the other</li>
<li><kbd>Sync</kbd>: The data type can be shared across threads without manual locks or mutex areas</li>
</ul>
<p>These marker traits are implemented in all basic types of the standard library and can be inherited for custom types (if all properties of a type are <kbd>Sync</kbd>, then the type itself is <kbd>Sync</kbd> too).</p>
<p>Implementing <kbd>Sync</kbd> or <kbd>Send</kbd> is unsafe because there is no way for the compiler to know if you are right and the code can be shared/sent between threads, which is why it's very unusual to do this.</p>
<p>In case your program requires this depth of Rust programming, be sure to read up on this topic in the <em>Rust Book</em>, chapter 16 (<a href="https://doc.rust-lang.org/1.31.0/book/ch16-04-extensible-concurrency-sync-and-send.html">https://doc.rust-lang.org/1.31.0/book/ch16-04-extensible-concurrency-sync-and-send.html</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deeper into Rust</h1>
                </header>
            
            <article>
                
<p>Another one of Rust's strong points is its thriving community. Many users actively participate in their local community (by going to or organizing meetups) or online via working groups, the IRC/Discord channel, or the official forum. The most important online resources are as follows:</p>
<ul>
<li>The main website with pointers to various resources: <a href="https://www.rust-lang.org">https://www.rust-lang.org</a></li>
<li>The Rust user forum: <a href="https://users.rust-lang.org">https://users.rust-lang.org</a></li>
<li>The official Twitter account: <a href="https://twitter.com/rustlang">https://twitter.com/rustlang</a></li>
<li>A collection of IRC channels at <a href="https://wiki.mozilla.org/Rust">https://wiki.mozilla.org/Rust</a></li>
<li>Rust's official blog: <a href="https://blog.rust-lang.org">https://blog.rust-lang.org</a></li>
<li>The Rust Book: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></li>
</ul>
<p>Other than that, users have created additional content, such as podcasts, blogs, and various tools and libraries. The most impressive user contributions, however, can be found in the core language!</p>
<p>Rust's official GitHub repository at <a href="https://github.com/rust-lang">https://github.com/rust-lang</a> holds the source code for many of the resources (for example, the website, blog, book, and documentation), and contributions are very welcome.</p>
<p>Mozilla has an impressive record of creating and fostering open source communities, and Rust is no different. As active members of these communities, we encourage everyone to take part and help make Rust the most enjoyable and useful language around!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Requests for Comments (RFCs)</h1>
                </header>
            
            <article>
                
<p>Due to the open source nature of Rust, there are some governance rules in place to maintain stable and flexible interfaces, yet encourage change and discussion as the language evolves.</p>
<p>For something as sensitive as a programming language and its standard library, a more rigid process than the regular pull request approval is required to have deeper discussions. Imagine the impact of changing a single keyword and how many projects would stop working immediately!</p>
<p>This is where RFCs come in. They provide a way for all stakeholders to contribute to the discussion with an equal chance to comment. A typical workflow for integrating change in open source projects uses the fork and pull method where the contributor creates a <strong>pull request</strong> (<strong>PR</strong>) to propose changes (<a href="https://help.github.com/articles/about-pull-requests/">https://help.github.com/articles/about-pull-requests/</a>). Unlike in the RFC process, this gets hard to manage in larger code bases and only starts the discussion <em>after</em> a solution has been proposed, narrowing the focus considerably.</p>
<p>A repository of active and past RFCs can be found here: <a href="https://github.com/rust-lang/rfcs">https://github.com/rust-lang/rfcs</a>.<a href="https://github.com/rust-lang/rfcs"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Rust is a multi-paradigm language with exceptional concepts: the language emphasizes data and behavior separation with structures and traits, uses macros for metaprogramming, and leverages explicit ownership of memory to determine variable lifetimes. Knowing these lifetimes removes the need for runtime garbage collection and, at the same time, greatly facilitates concurrency by allowing mutable borrowing only in certain circumstances.</p>
<p>Consequently, threads and other asynchronous processes can change variables only when they have mutable ownership of them, something that is mostly enforced at compile time, but can also be done at runtime! Therefore, safe Rust is effectively free of data races.</p>
<p>Another strong point of the Rust ecosystem is its diverse and welcoming community. Sponsored by Mozilla, development is guided by RFCs, events are organized and centrally advertised, and learning resources are available online. Another way to be a part of the ecosystem is to contribute packages to <kbd>crates.io</kbd> (<a href="https://crates.io/">https://crates.io/</a>), Rust's public package repository. Read the next chapter to find out more about <kbd>cargo</kbd>, Rust's universal tool to build and package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ul>
<li>What are traits and how are they different from interfaces?</li>
<li>Why doesn't Rust have a garbage collector?</li>
<li>Name three examples of how lifetimes are created in Rust (explicitly and implicitly)!</li>
<li>Why is immutability for variables important?</li>
<li>What does the Sync marker trait do?</li>
<li>Where can you go to participate in the Rust community?</li>
<li>Why are RFCs preferred over PRs?</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Refer to the following books for more information:</p>
<ul>
<li><em>Hands-On Concurrency with Rust</em> by Brian L. Troutwine (Packt)</li>
<li><em>Functional Programming in Rust</em> by Andrew Johnson (Packt)</li>
</ul>


            </article>

            
        </section>
    </body></html>