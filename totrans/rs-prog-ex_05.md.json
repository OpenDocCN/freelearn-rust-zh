["```rs\nsudo apt-get install libgtk-3-dev\n```", "```rs\nbrew install gtk+3 gnome-icon-theme\n```", "```rs\npacman -S mingw-w64-x86_64-gtk3\n```", "```rs\ncargo new rusic --bin\n```", "```rs\ngio = \"^0.3.0\"\ngtk = \"^0.3.0\"\n```", "```rs\nextern crate gio;\nextern crate gtk;\n\nuse std::env;\n\nuse gio::{ApplicationExt, ApplicationExtManual, ApplicationFlags};\nuse gtk::{\n    Application,\n    ApplicationWindow,\n    WidgetExt,\n    GtkWindowExt,\n};\n\nfn main() {\n    let application = Application::new(\"com.github.rust-by-\n     example\", ApplicationFlags::empty())\n        .expect(\"Application initialization failed\");\n    application.connect_startup(|application| {\n        let window = ApplicationWindow::new(&application);\n        window.set_title(\"Rusic\");\n        window.show();\n    });\n    application.connect_activate(|_| {});\n    application.run(&env::args().collect::<Vec<_>>());\n}\n```", "```rs\nextern crate gio;\nextern crate gtk;\n```", "```rs\nuse std::env;\n\nuse gio::{ApplicationExt, ApplicationExtManual, ApplicationFlags};\nuse gtk::{\n    Application,\n    ApplicationWindow,\n    WidgetExt,\n    GtkWindowExt,\n};\n```", "```rs\nfn main() {\n    let application = Application::new(\"com.github.rust-by-\n     example\", \n     ApplicationFlags::empty())\n        .expect(\"Application initialization failed\");\n```", "```rs\n    application.connect_startup(|application| {\n        let window = ApplicationWindow::new(&application);\n        window.set_title(\"Rusic\");\n        window.show();\n    });\n    application.connect_activate(|_| {});\n```", "```rs\n|application| {\n    let window = ApplicationWindow::new(&application);\n    window.set_title(\"Rusic\");\n    window.show();\n}\n```", "```rs\nfn startup_handler(application: &Application) {\n    let window = ApplicationWindow::new(&application);\n    window.set_title(\"Rusic\");\n    window.show();\n}\n\n// In the main function:\n\n    application.connect_startup(startup_handler);\n```", "```rs\n    application.run(&env::args().collect::<Vec<_>>());\n}\n```", "```rs\nwindow.connect_delete_event(|_, _| {\n    Inhibit(true)\n});\n```", "```rs\nwindow.connect_delete_event(|_, _| {\n    Inhibit(false)\n});\n```", "```rs\nuse gtk::{\n    ContainerExt,\n    SeparatorToolItem,\n    Toolbar,\n    ToolButton,\n};\n```", "```rs\nconst PLAY_STOCK: &str = \"gtk-media-play\";\n```", "```rs\nfn main() {\n    // Same code to initialize gtk, create the window.\n    application.connect_startup(|application| {\n        // â€¦\n\n        let toolbar = Toolbar::new();\n        window.add(&toolbar);\n```", "```rs\n    let open_button = ToolButton::new_from_stock(\"gtk-open\");\n    toolbar.add(&open_button);\n```", "```rs\n        window.show_all();\n    });\n```", "```rs\n    toolbar.add(&SeparatorToolItem::new());\n\n    let previous_button = ToolButton::new_from_stock(\"gtk-media-previous\");\n    toolbar.add(&previous_button);\n\n    let play_button = ToolButton::new_from_stock(PLAY_STOCK);\n    toolbar.add(&play_button);\n\n    let stop_button = ToolButton::new_from_stock(\"gtk-media-stop\");\n    toolbar.add(&stop_button);\n\n    let next_button = ToolButton::new_from_stock(\"gtk-media-next\");\n    toolbar.add(&next_button);\n\n    toolbar.add(&SeparatorToolItem::new());\n\n    let remove_button = ToolButton::new_from_stock(\"gtk-remove\");\n    toolbar.add(&remove_button);\n\n    toolbar.add(&SeparatorToolItem::new());\n\n    let quit_button = ToolButton::new_from_stock(\"gtk-quit\");\n    toolbar.add(&quit_button);\n```", "```rs\nuse gtk::{\n    ContainerExt,\n    SeparatorToolItem,\n    Toolbar,\n    ToolButton,\n};\n\nconst PLAY_STOCK: &str = \"gtk-media-play\";\n```", "```rs\npub struct MusicToolbar {\n    open_button: ToolButton,\n    next_button: ToolButton,\n    play_button: ToolButton,\n    previous_button: ToolButton,\n    quit_button: ToolButton,\n    remove_button: ToolButton,\n    stop_button: ToolButton,\n    toolbar: Toolbar,\n}\n```", "```rs\nimpl MusicToolbar {\n    pub fn new() -> Self {\n        let toolbar = Toolbar::new();\n\n        let open_button = ToolButton::new_from_stock(\"gtk-open\");\n        toolbar.add(&open_button);\n\n        // ...\n\n        let quit_button = ToolButton::new_from_stock(\"gtk-quit\");\n        toolbar.add(&quit_button);\n\n        MusicToolbar {\n            open_button,\n            next_button,\n            play_button,\n            previous_button,\n            quit_button,\n            remove_button,\n            stop_button,\n            toolbar\n        }\n    }\n}\n```", "```rs\n    pub fn toolbar(&self) -> &Toolbar {\n        &self.toolbar\n    }\n```", "```rs\nuse toolbar::MusicToolbar;\n```", "```rs\nstruct App {\n    toolbar: MusicToolbar,\n    window: ApplicationWindow,\n}\n```", "```rs\nimpl App {\n    fn new(application: Application) -> Self {\n        let window = ApplicationWindow::new(&application);\n        window.set_title(\"Rusic\");\n\n        let toolbar = MusicToolbar::new();\n        window.add(toolbar.toolbar());\n\n        window.show_all();\n\n        let app = App {\n            toolbar,\n            window,\n        };\n\n        app.connect_events();\n\n        app\n    }\n}\n```", "```rs\n    fn connect_events(&self) {\n    }\n```", "```rs\nuse gtk::{\n    ToolButtonExt,\n    WidgetExt,\n};\n\nuse App;\n```", "```rs\nimpl App {\n    pub fn connect_toolbar_events(&self) {\n        let window = self.window.clone();\n        self.toolbar.quit_button.connect_clicked(move |_| {\n            window.destroy();\n        });\n    }\n}\n```", "```rs\n    let play_button = self.toolbar.play_button.clone();\n    self.toolbar.play_button.connect_clicked(move |_| {\n        if play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {\n            play_button.set_stock_id(PAUSE_STOCK);\n        } else {\n            play_button.set_stock_id(PLAY_STOCK);\n       }\n    });\n```", "```rs\nconst PAUSE_STOCK: &str = \"gtk-media-pause\";\n```", "```rs\nself.toolbar.play_button.connect_clicked(|_| {\n    if self.toolbar.play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {\n        self.toolbar.play_button.set_stock_id(PAUSE_STOCK);\n    } else {\n        self.toolbar.play_button.set_stock_id(PLAY_STOCK);\n    }\n});\n```", "```rs\nerror[E0477]: the type `[closure@src/toolbar.rs:79:50: 85:10 self:&&App]` does not fulfill the required lifetime\n  --> src/toolbar.rs:79:34\n   |\n79 |         self.toolbar.play_button.connect_clicked(|_| {\n   |                                  ^^^^^^^^^^^^^^^\n   |\n   = note: type must satisfy the static lifetime\n\nerror[E0495]: cannot infer an appropriate lifetime for capture of `self` by closure due to conflicting requirements\n  --> src/toolbar.rs:79:50\n   |\n79 |           self.toolbar.play_button.connect_clicked(|_| {\n   |  __________________________________________________^\n80 | |             if self.toolbar.play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {\n81 | |                 self.toolbar.play_button.set_stock_id(PAUSE_STOCK);\n82 | |             } else {\n83 | |                 self.toolbar.play_button.set_stock_id(PLAY_STOCK);\n84 | |             }\n85 | |         });\n   | |_________^\n```", "```rs\nfn connect_clicked<F: Fn(&Self) + 'static>(&self, f: F) -> u64\n```", "```rs\nfn get_element_inc(elements: &[i32], index: usize) -> &i32 {\n    let element = elements[index] + 1;\n    &element\n}\n```", "```rs\nerror[E0597]: `element` does not live long enough\n --> src/main.rs:3:6\n  |\n3 |     &element\n  |      ^^^^^^^ does not live long enough\n4 | }\n  | - borrowed value only lives until here\n```", "```rs\nfn get_element_inc<'a>(elements: &'a [i32], index: usize) -> &'a i32 {\n    let element = elements[index] + 1;\n    &element\n}\n```", "```rs\nfn get_element<'a>(elements: &'a [i32], index: usize) -> &'a i32 {\n    &elements[index]\n}\n```", "```rs\nfn get_element<'a>(elements: &'a [i32], index: usize) -> &'a i32 {\n    &42\n}\n```", "```rs\nfn connect_clicked<F: Fn(&Self) + 'static>(&self, f: F) -> u64\n```", "```rs\nlet play_button = self.toolbar.play_button.clone();\n```", "```rs\nlet play_button = self.toolbar.play_button.clone();\nself.toolbar.play_button.connect_clicked(|_| {\n    if play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {\n        play_button.set_stock_id(PAUSE_STOCK);\n    } else {\n        play_button.set_stock_id(PLAY_STOCK);\n    }\n});\n```", "```rs\nerror[E0373]: closure may outlive the current function, but it borrows `play_button`, which is owned by the current function\n  --> src/toolbar.rs:80:50\n   |\n80 |         self.toolbar.play_button.connect_clicked(|_| {\n   |                                                  ^^^ may outlive borrowed value `play_button`\n81 |             if play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {\n   |                ----------- `play_button` is borrowed here\n   |\nhelp: to force the closure to take ownership of `play_button` (and any other referenced variables), use the `move` keyword\n   |\n80 |         self.toolbar.play_button.connect_clicked(move |_| {\n   |                                                  ^^^^^^^^\n```", "```rs\nlet mut vec = vec![\"string\".to_string()];\nif !vec.is_empty() {\n    let element = vec.remove(0);\n    // element is deallocated at the end of this scope.\n}\n```", "```rs\nself.toolbar.play_button.connect_clicked(move |_| {\n    if play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {\n        play_button.set_stock_id(PAUSE_STOCK);\n    } else {\n        play_button.set_stock_id(PLAY_STOCK);\n    }\n});\n```", "```rs\napp.connect_events();\napp.connect_toolbar_events();\n```", "```rs\nwindow.add(toolbar.toolbar());\n```", "```rs\nuse gtk::{\n    Adjustment,\n    Image,\n    ImageExt,\n    Scale,\n    ScaleExt,\n};\nuse gtk::Orientation::{Horizontal, Vertical};\n```", "```rs\nlet vbox = gtk::Box::new(Vertical, 0);\nwindow.add(&vbox);\n```", "```rs\nlet toolbar = MusicToolbar::new();\nvbox.add(toolbar.toolbar());\n\nlet cover = Image::new();\ncover.set_from_file(\"cover.jpg\");\nvbox.add(&cover);\n```", "```rs\nlet adjustment = Adjustment::new(0.0, 0.0, 10.0, 0.0, 0.0, 0.0);\nlet scale = Scale::new(Horizontal, &adjustment);\nscale.set_draw_value(false);\nvbox.add(&scale);\n```", "```rs\nstruct App {\n    adjustment: Adjustment,\n    cover: Image,\n    toolbar: MusicToolbar,\n    window: ApplicationWindow,\n}\n```", "```rs\nimpl App {\n    fn new(application: Application) -> Self {\n        // ...\n\n        window.show_all();\n\n        let app = App {\n            adjustment,\n            cover,\n            toolbar,\n            window,\n        };\n\n        app.connect_events();\n        app.connect_toolbar_events();\n\n        app\n    }\n}\n```", "```rs\nextern crate gdk_pixbuf;\nextern crate id3;\n```", "```rs\ngdk-pixbuf = \"^0.3.0\"\nid3 = \"^0.2.0\"\n```", "```rs\nmod playlist;\n```", "```rs\nuse std::path::Path;\n\nuse gdk_pixbuf::{InterpType, Pixbuf, PixbufLoader};\nuse gtk::{\n    CellLayoutExt,\n    CellRendererPixbuf,\n    CellRendererText,\n    ListStore,\n    ListStoreExt,\n    ListStoreExtManual,\n    StaticType,\n    ToValue,\n    TreeIter,\n    TreeModelExt,\n    TreeSelectionExt,\n    TreeView,\n    TreeViewColumn,\n    TreeViewColumnExt,\n    TreeViewExt,\n    Type,\n    WidgetExt,\n};\nuse id3::Tag;\n```", "```rs\nconst THUMBNAIL_COLUMN: u32 = 0;\nconst TITLE_COLUMN: u32 = 1;\nconst ARTIST_COLUMN: u32 = 2;\nconst ALBUM_COLUMN: u32 = 3;\nconst GENRE_COLUMN: u32 = 4;\nconst YEAR_COLUMN: u32 = 5;\nconst TRACK_COLUMN: u32 = 6;\nconst PATH_COLUMN: u32 = 7;\nconst PIXBUF_COLUMN: u32 = 8;\n\nconst IMAGE_SIZE: i32 = 256;\nconst THUMBNAIL_SIZE: i32 = 64;\n```", "```rs\npub struct Playlist {\n    model: ListStore,\n    treeview: TreeView,\n}\n```", "```rs\nimpl Playlist {\n    pub fn new() -> Self {\n        let model = ListStore::new(&[\n            Pixbuf::static_type(),\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Pixbuf::static_type(),\n        ]);\n        let treeview = TreeView::new_with_model(&model);\n        treeview.set_hexpand(true);\n        treeview.set_vexpand(true);\n\n        Self::create_columns(&treeview);\n\n        Playlist {\n            model,\n            treeview,\n        }\n    }\n}\n```", "```rs\n    fn create_columns(treeview: &TreeView) {\n        Self::add_pixbuf_column(treeview, THUMBNAIL_COLUMN as i32, \n         Visible);\n        Self::add_text_column(treeview, \"Title\", TITLE_COLUMN as i32);\n        Self::add_text_column(treeview, \"Artist\", ARTIST_COLUMN as i32);\n        Self::add_text_column(treeview, \"Album\", ALBUM_COLUMN as i32);\n        Self::add_text_column(treeview, \"Genre\", GENRE_COLUMN as i32);\n        Self::add_text_column(treeview, \"Year\", YEAR_COLUMN as i32);\n        Self::add_text_column(treeview, \"Track\", TRACK_COLUMN as i32);\n        Self::add_pixbuf_column(treeview, PIXBUF_COLUMN as i32, Invisible);\n    }\n```", "```rs\nuse self::Visibility::*;\n\n#[derive(PartialEq)]\nenum Visibility {\n    Invisible,\n    Visible,\n}\n```", "```rs\n    fn add_text_column(treeview: &TreeView, title: &str, column: i32) {\n        let view_column = TreeViewColumn::new();\n        view_column.set_title(title);\n        let cell = CellRendererText::new();\n        view_column.set_expand(true);\n        view_column.pack_start(&cell, true);\n        view_column.add_attribute(&cell, \"text\", column);\n        treeview.append_column(&view_column);\n    }\n```", "```rs\nview_column.add_attribute(&cell, \"text\", column);\n```", "```rs\n    fn add_pixbuf_column(treeview: &TreeView, column: i32, visibility:\n    Visibility) {\n        let view_column = TreeViewColumn::new();\n        if visibility == Visible {\n            let cell = CellRendererPixbuf::new();\n            view_column.pack_start(&cell, true);\n            view_column.add_attribute(&cell, \"pixbuf\", column);\n        }\n        treeview.append_column(&view_column);\n    }\n```", "```rs\n    pub fn view(&self) -> &TreeView {\n        &self.treeview\n    }\n```", "```rs\nlet playlist = Playlist::new();\nvbox.add(playlist.view());\n```", "```rs\nstruct App {\n    adjustment: Adjustment,\n    cover: Image,\n    playlist: Playlist,\n    toolbar: MusicToolbar,\n    window: Window,\n}\n```", "```rs\nlet app = App {\n    adjustment,\n    cover,\n    playlist,\n    toolbar,\n    window,\n};\n```", "```rs\ncover.set_from_file(\"cover.jpg\");\n```", "```rs\ngtk-sys = \"^0.5.0\"\n```", "```rs\nextern crate gtk_sys;\n```", "```rs\nstruct App {\n    adjustment: Adjustment,\n    cover: Image,\n    playlist: Rc<Playlist>,\n    toolbar: MusicToolbar,\n    window: Window,\n}\n```", "```rs\nuse std::rc::Rc;\n```", "```rs\nlet playlist = Rc::new(Playlist::new());\n```", "```rs\nvbox.add(playlist.view());\n```", "```rs\nconst INTERP_HYPER: InterpType = 3;\n\n    fn set_pixbuf(&self, row: &TreeIter, tag: &Tag) {\n        if let Some(picture) = tag.pictures().next() {\n            let pixbuf_loader = PixbufLoader::new();\n            pixbuf_loader.set_size(IMAGE_SIZE, IMAGE_SIZE);\n            pixbuf_loader.loader_write(&picture.data).unwrap();\n            if let Some(pixbuf) = pixbuf_loader.get_pixbuf() {\n                let thumbnail = pixbuf.scale_simple(THUMBNAIL_SIZE, \n                THUMBNAIL_SIZE, INTERP_HYPER).unwrap();\n                self.model.set_value(row, THUMBNAIL_COLUMN,\n                 &thumbnail.to_value());\n                self.model.set_value(row, PIXBUF_COLUMN, \n                 &pixbuf.to_value());\n            }\n            pixbuf_loader.close().unwrap();\n        }\n    }\n```", "```rs\n    pub fn add(&self, path: &Path) {\n        let filename =  \n         path.file_stem().unwrap_or_default().to_str().unwrap_or_default();\n\n        let row = self.model.append();\n\n        if let Ok(tag) = Tag::read_from_path(path) {\n            let title = tag.title().unwrap_or(filename);\n            let artist = tag.artist().unwrap_or(\"(no artist)\");\n            let album = tag.album().unwrap_or(\"(no album)\");\n            let genre = tag.genre().unwrap_or(\"(no genre)\");\n            let year = tag.year().map(|year| \n            year.to_string()).unwrap_or(\"(no  \n            year)\".to_string());\n            let track = tag.track().map(|track| \n            track.to_string()).unwrap_or(\"??\".to_string());\n            let total_tracks = tag.total_tracks().map(|total_tracks|  \n            total_tracks.to_string()).unwrap_or(\"??\".to_string());\n            let track_value = format!(\"{} / {}\", track, total_tracks);\n```", "```rs\n            self.set_pixbuf(&row, &tag);\n\n            self.model.set_value(&row, TITLE_COLUMN, &title.to_value());\n            self.model.set_value(&row, ARTIST_COLUMN, &artist.to_value());\n            self.model.set_value(&row, ALBUM_COLUMN, &album.to_value());\n            self.model.set_value(&row, GENRE_COLUMN, &genre.to_value());\n            self.model.set_value(&row, YEAR_COLUMN, &year.to_value());\n            self.model.set_value(&row, TRACK_COLUMN, \n             &track_value.to_value());\n        }\n        else {\n            self.model.set_value(&row, TITLE_COLUMN, &filename.to_value());\n        }\n\n        let path = path.to_str().unwrap_or_default();\n        self.model.set_value(&row, PATH_COLUMN, &path.to_value());\n    }\n```", "```rs\nuse std::path::PathBuf;\n\nuse gtk::{FileChooserAction, FileChooserDialog, FileFilter};\n\nfn show_open_dialog(parent: &ApplicationWindow) -> Option<PathBuf> {\n    let mut file = None;\n    let dialog = FileChooserDialog::new(Some(\"Select an MP3 audio\n     file\"), \n    Some(parent), FileChooserAction::Open);\n    let filter = FileFilter::new();\n    filter.add_mime_type(\"audio/mp3\");\n    filter.set_name(\"MP3 audio file\");\n    dialog.add_filter(&filter);\n    dialog.add_button(\"Cancel\", RESPONSE_CANCEL);\n    dialog.add_button(\"Accept\", RESPONSE_ACCEPT);\n    let result = dialog.run();\n    if result == RESPONSE_ACCEPT {\n        file = dialog.get_filename();\n    }\n    dialog.destroy();\n    file\n}\n```", "```rs\nuse gtk_sys::{GTK_RESPONSE_ACCEPT, GTK_RESPONSE_CANCEL};\n\nconst RESPONSE_ACCEPT: i32 = GTK_RESPONSE_ACCEPT as i32;\nconst RESPONSE_CANCEL: i32 = GTK_RESPONSE_CANCEL as i32;\n```", "```rs\n        let parent = self.window.clone();\n        let playlist = self.playlist.clone();\n        self.toolbar.open_button.connect_clicked(move |_| {\n            let file = show_open_dialog(&parent);\n            if let Some(file) = file {\n                playlist.add(&file);\n            }\n        });\n```", "```rs\n    pub fn remove_selection(&self) {\n        let selection = self.treeview.get_selection();\n        if let Some((_, iter)) = selection.get_selected() {\n            self.model.remove(&iter);\n        }\n    }\n```", "```rs\n     let playlist = self.playlist.clone();\n     self.toolbar.remove_button.connect_clicked(move |_| {\n       playlist.remove_selection();\n     });\n```", "```rs\n    pub fn pixbuf(&self) -> Option<Pixbuf> {\n        let selection = self.treeview.get_selection();\n        if let Some((_, iter)) = selection.get_selected() {\n            let value = self.model.get_value(&iter, PIXBUF_COLUMN as i32);\n            return value.get::<Pixbuf>();\n        }\n        None\n    }\n```", "```rs\nuse gtk::Image;\n\nuse playlist::Playlist;\n\nfn set_cover(cover: &Image, playlist: &Playlist) {\n    cover.set_from_pixbuf(playlist.pixbuf().as_ref());\n    cover.show();\n}\n```", "```rs\n        let playlist = self.playlist.clone();\n        let cover = self.cover.clone();\n        self.toolbar.play_button.connect_clicked(move |_| {\n            if play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {\n                play_button.set_stock_id(PAUSE_STOCK);\n                set_cover(&cover, &playlist);\n            } else {\n                play_button.set_stock_id(PLAY_STOCK);\n            }\n        });\n```"]