<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Web Development with Rust</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Web Development with Rust</h1>
                </header>
            
            <article>
                
<p>We will be covering the following recipes in this chapter:</p>
<ul>
<li>Setting up a web server</li>
<li>Creating endpoints</li>
<li>Handling JSONRequests</li>
<li>Building a custom error handler</li>
<li>Hosting templates</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Rust has many packages available that allow the developer to spin up a web server with it, and Rust is an ideal choice for a web project where memory, safety, and speed are of a great significance.</p>
<p>In this chapter, we will be playing with the nickel crate in Rust, which is a web application framework in Rust and provides all the fundamental units required for building a web application in Rust. The fundamental units include setting up a web server, handling web requests, and more. We will focus on the different macros and types that the nickel crate provides us for creating a web application in Rust.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up a web server</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn the steps through which you can install the nickel crate into your Rust project and learn the commands with which you can start a web server where you can host your web application.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following nickel crate before we can go ahead and spawn a web server. Follow the given steps to download and set up the <kbd>nickel</kbd> crate for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust project using the Cargo tool and enter the newly created project:</li>
</ol>
<pre><strong>      cargo new --bin nickel-demo &amp;&amp; cd nickel-demo</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/ab489f1f-34ef-4269-9c2a-d0e6c3d4657f.png"/></div>
<ol start="3">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification shown in the following screenshot. Here, we are using the nickel crate, which is entered in the dependencies field:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="108" width="400" class="image-border" src="images/a8a98c8a-d53f-41b9-b313-f0be3b1d330c.png"/></div>
<ol start="4">
<li>Install the crate in your project with the following command:</li>
</ol>
<pre><strong>      cargo build</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img height="535" width="520" class="image-border" src="images/80c06119-f80b-43bb-af96-84cdde0a6187.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Starting a simple hello world nickel web app<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 20 April 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Import the installed <kbd>nickel</kbd> crate by using the <kbd>extern</kbd> keyword:</li>
</ol>
<pre>        #[macro_use] extern crate nickel;<br/><br/>        use nickel::Nickel;
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function in which we declare the <kbd>server</kbd> instance:</li>
</ol>
<pre>        fn main() {<br/>          let mut server = Nickel::new();<br/><br/>          server.utilize(router! {<br/>          get "**" =&gt; |_req, _res| {<br/>          "Hello world!"<br/>          }<br/>          });<br/><br/>        server.listen("127.0.0.1:6767");<br/>        }
</pre>
<ol start="5">
<li>Save the file and start the server with the following command from the root directory of the project:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p style="padding-left: 60px">We will get the following output on the successful execution of our code in the terminal:</p>
<div class="CDPAlignCenter CDPAlign"><img height="64" width="421" class="image-border" src="images/22e108f7-f971-4c33-9ac1-1b809a67e391.png"/></div>
<p style="padding-left: 60px" class="mce-root CDPAlignLeft CDPAlign">Open your favorite browser and redirect to <kbd>http://127.0.0.1:6767/</kbd> to get the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><br/>
<img height="96" width="253" class="image-border" src="images/ec0e4839-7bc6-473e-9182-8b10ccbde998.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a Rust project named <kbd>nickel-demo</kbd>, which helps us spawn a web server using the <kbd>nickel</kbd> web application crate.</p>
<p>Starting at the top, we referenced the external <kbd>nickel</kbd> crate using the <kbd>extern</kbd> keyword and loaded all its macros with <kbd>#[macro_use]</kbd>. The <kbd>nickel</kbd> crate is the application object and surface that holds all public APIs; it's a struct, which implements all the fundamental methods for performing all the web application tasks. In the <kbd>main</kbd> function, we first assign <kbd>server</kbd> instances to a mutable variable and create a new <kbd>nickel</kbd> application object with <kbd>Nickel::new()</kbd>, which creates an instance of nickel with default error handling.</p>
<p>Next, we set up our endpoint routing for which we use the <kbd>router!</kbd> macro, which listens at <kbd>"**"</kbd> and provides a simple message <kbd>"Hello world!"</kbd>, when a <kbd>get</kbd> request is demanded by the end user. The <kbd>get</kbd> method of the nickel crate or the server instance registers a handler to be used for a specific <kbd>get</kbd> request. Handlers are assigned to paths and paths are allowed to contain variables and wildcards; we have <kbd>"**"</kbd> in our case for handlers, which is a wild card entry and basically returns the same response for the get request of any endpoint. A handler added through this API will be attached to the default router. Double pipe characters represent a closure in Rust; this is the place where our <kbd>request</kbd> and <kbd>response</kbd> parameters go, which are <kbd>_req</kbd> and <kbd>_res</kbd> in our application. Fundamentally, there are structs that contain the request and response data.</p>
<p>Using the <kbd>server.utilize</kbd> method, we add the endpoint to the server instance and register the handler, which will be invoked among other handlers before each request. The <kbd>server.listen</kbd> method listens to the API requests on <kbd>127.0.0.1:6767</kbd>, where it binds and listens for connections on the given host and port.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating endpoints</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn the steps through which you can install the nickel crate into your Rust project. You will also learn the commands with which we can create custom endpoints in our web application, which would display different messages on being accessed by an end user of the application.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following nickel crate before we can go ahead and spawn a web server. Follow the given steps to download and set up the <kbd>nickel</kbd> crate for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust project using the Cargo tool and enter the newly created project:</li>
</ol>
<pre><strong>      cargo new --bin nickel-routing &amp;&amp; cd nickel-routing</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/5520e964-1bc2-49b0-bf98-a1d9801a8b53.png"/></div>
<ol start="3">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification shown in the following screenshot. Here, we are using the nickel crate, which is entered in the dependencies field:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="86" width="380" class="image-border" src="images/bcaf2dd9-4f06-4b90-bbea-1ac1f3535f04.png"/></div>
<ol start="4">
<li>Install the crate in your project with the following command:</li>
</ol>
<pre><strong>      cargo build</strong>
</pre>
<p style="padding-left: 60px">This command will install all the dependencies of the <kbd>nickel</kbd> crate in your Rust project.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Routing using nickel<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 20 April 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Import the installed <kbd>nickel</kbd> crate by using the <kbd>extern</kbd> keyword:</li>
</ol>
<pre>        #[macro_use] extern crate nickel;<br/><br/>        use nickel::{Nickel, HttpRouter};
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function in which we declare the <kbd>server</kbd> instance:</li>
</ol>
<pre>        fn main() {<br/>        let mut server = Nickel::new();<br/><br/>        server.get("/bar", middleware!("This is the /bar<br/>        handler"));<br/>        server.get("/user/:userid", middleware! { |request|<br/>        format!("This is user: {:?}", request.param("userid"))<br/>        });<br/>        server.get("/a/*/d", middleware!("matches /a/b/d but<br/>        not /a/b/c/d"));<br/>        server.get("/a/**/d", middleware!("This matches /a/b/d<br/>        and also /a/b/c/d"));<br/><br/>        server.listen("127.0.0.1:6767");<br/>        }
</pre>
<ol start="5">
<li>Save the file and start the server with the following command from the root directory of the project:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p style="padding-left: 60px">We will get the following output on the successful execution of our code in the terminal:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/b85dfb27-66b6-46a9-af96-89e658562809.png"/></div>
<p style="padding-left: 60px">Open your favorite browser and redirect to the following endpoints:</p>
<ul>
<li>Enter the URL, <kbd>http://127.0.0.1:6767/bar</kbd>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="107" width="217" class="image-border" src="images/b0ae273b-4816-4265-80a7-64bfc59bb08b.png"/></div>
<ul>
<li>Enter the URL, <kbd>http://127.0.0.1:6767/user/viki</kbd>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="95" width="220" class="image-border" src="images/a5bdc4bd-33ee-4f01-bfac-9814db93b7c3.png"/></div>
<ul>
<li>Enter the URL, <kbd>http://127.0.0.1:6767/a/b/d/d</kbd>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="88" width="291" class="image-border" src="images/c8c4e97f-acaa-4b6d-830c-d621829585e0.png"/></div>
<ul>
<li>Enter the URL, <kbd>http://127.0.0.1:6767/a/b/c/d</kbd>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="99" width="250" class="image-border" src="images/fde183f3-5d96-4d54-aff9-b862a8cab52e.png"/></div>
<ul>
<li>Enter the URL, <kbd>http://127.0.0.1:6767/a/b/d</kbd>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="122" width="251" class="image-border" src="images/3be22968-c278-4e56-8dae-2b3e112ef5c8.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a Rust project named <kbd>nickel-routing</kbd>, which helps us to create multiple endpoints in our web application, and each endpoint displays different custom messages.</p>
<p><span>Starting at the top, we referenced the external</span> <kbd>nickel</kbd> <span>crate using the</span> <kbd>extern</kbd> <span>keyword and loading all of its macros with</span> <kbd>#[macro_use]</kbd><span>. We use</span> <kbd>nickel</kbd> <span>as the application object and surface, which holds all the public APIs. It's a struct that implements all the fundamental methods for performing all the web application tasks, and <kbd>HttpRouter</kbd> is a public trait provided by the <kbd>nickle</kbd> crate, which has the signature of various REST API calls.</span></p>
<p><span>In the</span> <kbd>main</kbd> <span>function, we first assign</span> <kbd>server</kbd> <span>instances to a mutable variable and create a new</span> <kbd>nickel</kbd> <span>application object with</span> <kbd>Nickel::new()</kbd>, <span>which creates an instance of nickel with default error handling.</span></p>
<p>The <kbd>server.get</kbd> method registers a handler to be used for a specific <kbd>get</kbd> request. Handlers are assigned to paths and paths are allowed to contain variables and wildcards. A handler added through this API will be attached to the default router. The <kbd>middleware!</kbd> macro reduces the amount of boilerplate code needed for each route.</p>
<p>We create the following routes in this recipe:</p>
<ul>
<li><kbd>/bar</kbd>: On hitting this endpoint, we get the message, <span class="packt_screen">This is the /bar handler</span>.</li>
<li><kbd>/user/:userid</kbd>: <span>On hitting this endpoint, we get the message, <span class="packt_screen">This is user: {:?}</span></span>. <span>Here, the argument is replaced with the data (<kbd>:userid</kbd>) passed in the <kbd>get</kbd> request with the <kbd>request.param("userid")</kbd> command, where <kbd>param</kbd> is a method of the <kbd>request</kbd> struct.</span></li>
<li><kbd>/a/*/d</kbd>: <span>On hitting this endpoint, we get the message,</span> <span class="packt_screen">matches /a/b/d but not /a/b/c/d</span>. <span>The asterisk here allows only one intermediate path.</span></li>
<li><kbd>/a/**/d</kbd>: <span>On hitting this endpoint, we get a message: <span class="packt_screen">This matches /a/b/d and also /a/b/c/d</span></span>. <span>The asterisk here allows only two intermediate paths.</span></li>
</ul>
<div class="packt_infobox">Routes can be as simple as <kbd>/foo</kbd>, use parameters, wildcards, and even double wildcards.</div>
<p><span>The</span> <kbd>server.listen</kbd> <span>method listens to the API requests on</span> <kbd>127.0.0.1:6767</kbd> <span>where it binds and listens for connections on the given host and port.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Handling JSONRequests</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn the steps through which we can install the <kbd>nickel</kbd> crate into your Rust project and learn the commands with which we can accept a <kbd>POST</kbd> request to an endpoint from the end user.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following <kbd>nickel</kbd> crate before we can go ahead and spawn a web server. Follow the given steps to download and set up the <kbd>nickel</kbd> and <kbd>rustc_serialize</kbd> crates for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust project using the Cargo tool and enter the newly created project:</li>
</ol>
<pre><strong>      cargo new nickel-jsonhandling --bin &amp;&amp; cd nickel-    jsonhandling</strong>
</pre>
<p style="padding-left: 60px" class="mce-root">Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/35670fb1-ccec-4082-9a84-d6e8e6a57428.png"/></div>
<ol start="3">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification shown in the following screenshot. Here, we are using the nickel and <kbd>rustc-serialize</kbd> crates, which are entered in the dependencies field:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="118" width="407" class="image-border" src="images/be5f1bf6-479e-4c00-8ddf-5fcb4484224b.png"/></div>
<ol start="4">
<li>Install the crate in your project using the following command:</li>
</ol>
<pre><strong>      cargo build</strong>
</pre>
<p style="padding-left: 60px">This command will install all the dependencies of the <kbd>nickel</kbd> and <kbd>rustc-serialize</kbd> crate in your Rust project.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Json handling in nickel<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 20 April 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Import the installed <kbd>nickel</kbd> and <kbd>rustc_serialize</kbd> crates by using the <kbd>extern</kbd> keyword:</li>
</ol>
<pre>        extern crate rustc_serialize;<br/>        #[macro_use] extern crate nickel;<br/><br/>        use nickel::{Nickel, HttpRouter, JsonBody};
</pre>
<ol start="4">
<li>Define a custom <kbd>Struct</kbd> type named <kbd>Person</kbd>:</li>
</ol>
<pre>        #[derive(RustcDecodable, RustcEncodable)]<br/>        struct Person {<br/>          firstname: String,<br/>          lastname: String,<br/>        }
</pre>
<ol start="5">
<li>Define the <kbd>main</kbd> function, where we declare the <kbd>server</kbd> instance:</li>
</ol>
<pre>        fn main() {<br/>          let mut server = Nickel::new();<br/><br/>          server.post("/a/post/request", middleware! {<br/>          |request,<br/>          response|<br/>          let person = request.json_as::&lt;Person&gt;().unwrap();<br/>          format!("Hello {} {}", person.firstname,<br/>          person.lastname)});<br/><br/>          server.listen("127.0.0.1:6767");<br/>        }
</pre>
<ol start="6">
<li>Save the file and start the server with the following command from the root directory of the project:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p style="padding-left: 60px">We will get the following output on the successful execution of our code in the terminal:</p>
<div class="CDPAlignCenter CDPAlign"><img height="75" width="629" class="image-border" src="images/8ba3af65-6ef8-4c96-a2eb-81c1be6103f1.png"/></div>
<p style="padding-left: 60px">Open your terminal and enter the following command to hit the endpoint with <kbd>curl</kbd>:</p>
<pre>        curl -H "Content-Type: application/json" -X POST -d<br/>        '{"firstname":"Vigneshwer","lastname":"Dhinakaran"}'<br/>        http://127.0.0.1:6767/a/post/request
</pre>
<p style="padding-left: 60px" class="mce-root">On successfully hitting the endpoint with the <kbd>curl</kbd> command, we will get the following response (highlighted) in the output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><br/>
<img class="image-border" src="images/87d48b7e-0306-4b81-9d9e-afaa360f7b18.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a Rust project named <kbd>nickel-jsonhandling</kbd>, which helps us get data from the end user and perform a certain set of actions based on the input. The <kbd>nickel</kbd> crate makes it easy to map JSON data right onto your struct. We use the <kbd>rustc-serialize</kbd> dependency for this project in order to handle JSON encoding and decoding.</p>
<p><span>Starting at the top, we referenced the external</span> <kbd>nickel</kbd> <span>crate using the</span> <kbd>extern</kbd> <span>keyword and loaded all of its macros with</span> <kbd>#[macro_use]</kbd><span>. We use</span> <kbd>nickel</kbd> <span>as the application object and surface, which holds all the public APIs; it's basically a struct that implements all the fundamental methods for performing the web application tasks. The <kbd>HttpRouter</kbd> is a public trait provided by the <kbd>nickle</kbd> crate, which has the signature of various REST API calls. <kbd>JsonBody</kbd> is a public trait provided by the <kbd>nickle</kbd> crate, which has the signature of the <kbd>json_as</kbd> method, which takes a decodable type provided by the</span> <span><kbd>rustc-serialize</kbd> crate.</span> We create a custom struct type named <kbd>Person</kbd>, which has two string fields: <kbd>firstname</kbd> and <kbd>lastname</kbd>. The JSON body that is posted from the end user is converted to the <kbd>Person</kbd> type so that we can use it our application. To be able to encode a piece of data, it must implement the <kbd>rustc_serialize::Encodable</kbd> trait. To be able to decode a piece of data, it must implement the <kbd>rustc_serialize::Decodable</kbd> trait. The Rust compiler provides an annotation to automatically generate the code for these traits: <kbd>#[derive(RustcDecodable, RustcEncodable)]</kbd>.</p>
<p><span>In the</span> <kbd>main</kbd> <span>function, we first assign</span> <kbd>server</kbd> <span>instances to a mutable variable and create a new</span> <kbd>nickel</kbd> <span>application object with</span> <kbd>Nickel::new()</kbd>, <span>which creates an instance of <kbd>nickel</kbd> with default error handling.</span></p>
<p>The <kbd>server.post</kbd> method registers a handler to be used for a specific <kbd>POST</kbd> request. Handlers are assigned to paths and paths are allowed to contain variables and wildcards. A handler added through this API will be attached to the default router. The <kbd>middleware!</kbd> macro reduces the amount of boilerplate code needed for each route. We create a variable, <kbd>person</kbd>, which is assigned to <kbd>request.json_as::&lt;Person&gt;().unwrap()</kbd>, where <kbd>request</kbd> is a parameter containing the information from the end user and the <kbd>unwrap</kbd> method is one of the several ways that Rust provides for assigning a value. We provide a simple message, <kbd>"Hello {} {}", person.firstname, person.lastname"</kbd>, in the <kbd>format!</kbd> macro to be displayed when the <kbd>/a/post/request</kbd> endpoint is accessed, where <kbd>person</kbd> is a variable of the <kbd>Person</kbd> type.</p>
<p>To hit the endpoint, we use the <kbd>curl</kbd> command, where <kbd>-H</kbd> stands for the header type, which is<kbd>"Content-Type: application/json"</kbd>, and we give a <kbd>POST</kbd> request (<kbd>-X</kbd>) at <kbd>http://127.0.0.1:6767/a/post/request</kbd> with the following data (<kbd>-d</kbd>): <kbd>'{"firstname":"Vigneshwer","lastname":"Dhinakaran"}'</kbd>.</p>
<p><span>The</span> <kbd>server.listen</kbd> <span>method listens to the API requests on</span> <kbd>127.0.0.1:6767</kbd> <span>where it binds and listens for connections on the given host and port.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building custom error handlers</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn the steps through which you can install the nickel crate into your Rust project. You will also learn the commands to create your custom error handler, which, for example, can help you create a custom <kbd>404</kbd> page.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following <kbd>nickel</kbd> crate before we can go ahead and spawn a web server. Follow the given steps to download and setup a <kbd>nickel</kbd> crate for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust project using the Cargo tool and enter the newly created project:</li>
</ol>
<pre><strong>      cargo new nickel-errorhandling --bin &amp;&amp; cd nickel-errorhandling</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/d34b64b0-f53d-4d1d-9782-96bc5146b361.png"/></div>
<ol start="3">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification shown in the following screenshot. Here, we are using the <kbd>nickel</kbd> crate, which is entered in the dependencies field:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/46940cf2-7b45-436b-8b61-92bb888644c4.png"/></div>
<ol start="4">
<li>Install the crate in your project with the following command:</li>
</ol>
<pre><strong>      cargo build</strong>
</pre>
<p style="padding-left: 60px">This command will install all the dependencies of the <kbd>nickle</kbd> crate in your Rust project.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Custom error handling in nickel<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 20 April 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Import the installed <kbd>nickel</kbd> crate by using the <kbd>extern</kbd> keyword:</li>
</ol>
<pre>        #[macro_use] extern crate nickel;<br/><br/>        use std::io::Write;<br/>        use nickel::status::StatusCode::NotFound;<br/>        use nickel::{Nickel, NickelError, Action, Continue,<br/>        Halt, Request};
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function in which we declare the <kbd>server</kbd> instance:</li>
</ol>
<pre>        fn main() {<br/>          let mut server = Nickel::new();<br/><br/>          //this is how to overwrite the default error handler<br/>          to<br/>          handle 404 cases with a custom view<br/>          fn custom_404&lt;'a&gt;(err: &amp;mut NickelError, _req: &amp;mut<br/>          Request) -&gt; Action {<br/>            if let Some(ref mut res) = err.stream {<br/>              if res.status() == NotFound {<br/>                let _ = res.write_all(b"&lt;h1&gt;Page Does not exist<br/>                :<br/>                (&lt;/h1&gt;");<br/>                return Halt(())<br/>              }<br/>            }<br/><br/>            Continue(())<br/>            }<br/><br/>          let custom_handler: fn(&amp;mut NickelError, &amp;mut<br/>          Request)<br/>          -&gt; Action = custom_404;<br/><br/>          server.handle_error(custom_handler);<br/><br/>          server.listen("127.0.0.1:6767");<br/><br/>        }
</pre>
<ol start="5">
<li>Save the file and start the server with the following command from the root directory of the project:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p style="padding-left: 60px">We will get the following output on the successful execution of our code in the terminal:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/7347614f-956d-48ce-bda1-5ac413ddaa86.png"/></div>
<p style="padding-left: 60px" class="mce-root CDPAlignLeft CDPAlign">Open your favorite browser and redirect to <kbd>127.0.0.1:6767/viki</kbd> to get the following output:</p>
<div style="padding-left: 60px" class="mce-root CDPAlignCenter CDPAlign"><br/>
<img height="105" width="313" class="image-border" src="images/03544319-dcb3-4337-ba2f-96d5c11bcdc1.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a Rust project named <kbd>nickel-errorhandling</kbd>, which helps us spawn the web server using the <kbd>nickel</kbd> web application crate. By default, <kbd>nickel</kbd> catches all the errors with its default ErrorHandler and tries to take reasonable actions.</p>
<p><span>Starting at the top, we referenced the external</span> <kbd>nickel</kbd> <span>crate using the</span> <kbd>extern</kbd> <span>keyword and loaded all of its macros with</span> <kbd>#[macro_use]</kbd><span>.</span></p>
<p><span>We used the following units from the <kbd>nickel</kbd> crate:</span></p>
<ul>
<li>The <kbd>nickel</kbd> crate <span>is the application object and surface, which holds all the public APIs. It's a struct that implements all the fundamental methods for performing all the web application tasks.</span></li>
<li><kbd>NickelError</kbd> is a basic error type for <kbd>HTTP</kbd> errors as well as user-defined errors.</li>
<li><kbd>Action</kbd> is an <kbd>enum</kbd> data type provided by the <kbd>nickel</kbd> crate, where <kbd>Continue</kbd> and <kbd>Halt</kbd> are variants of the <kbd>Action</kbd> type.</li>
<li><kbd>Request</kbd> is a container for all the request data.</li>
</ul>
<p>We used <kbd>nickel::status::StatusCode::NotFound</kbd>; here, the status is a public module of the <kbd>nickel</kbd> crate, which defines the <kbd>StatusCode</kbd> <kbd>enum</kbd> type containing the different HTTP status codes. <kbd>NotFound</kbd> is one of them and <kbd>std::io::Write</kbd>, which is a trait that defines the <kbd>write_all</kbd> method, writes all the data in the entire buffer.</p>
<p><span>In the</span> <kbd>main</kbd> <span>function, we first assign</span> <kbd>server</kbd> <span>instances to a mutable variable and create a new</span> <kbd>nickel</kbd> <span>application object with</span> <kbd>Nickel::new()</kbd>, <span>which creates an instance of <kbd>nickel</kbd> with default error handling.</span></p>
<p>We create a custom error handler named <kbd>custom_handler</kbd>, which is invoked in the case of <kbd>NotFound</kbd> or <kbd>404</kbd> status code. We call the function, <kbd>custom_404</kbd>, which takes in two parameters, <kbd>NickelError</kbd> and <kbd>Request</kbd>, and returns an <kbd>Action</kbd> type. The <kbd><span>custom_404</span></kbd> is a way to overwrite the default error handler to handle <kbd>404</kbd> cases with a custom view.</p>
<p>The <kbd>custom_404</kbd> assigns the arguments <kbd>&amp;mut NickelError</kbd> and <kbd>&amp;mut Request</kbd> to <kbd>err</kbd> and <kbd>_req</kbd>, respectively. In the function, we assign <kbd>err.stream</kbd>, where <kbd>stream</kbd> is a field of the <kbd>NickelError</kbd> type to <kbd>Some(ref mut res)</kbd>, and check whether it is true; else we return <kbd>Continue(())</kbd>. If true, we know that there has been an error when the end user tried to access the endpoint, and the next step is to check whether the status code <kbd>res.status()</kbd> is <kbd>NotFound</kbd>. In such a case, we write the custom <kbd>404</kbd> page with the <kbd>res.write_all</kbd> method and return <kbd>Halt(())</kbd>.</p>
<p>The <kbd>server.handle_error</kbd> registers an error handler, which will be invoked among other error handlers as soon as any regular handler returns an error; the other error handler in our case is <kbd>custom_handler</kbd>.</p>
<p><span>The</span> <kbd>server.listen</kbd> <span>method listens to the API requests on</span> <kbd>127.0.0.1:6767</kbd> <span>where it binds and listens for connections on the given host and port.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Hosting templates</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn the steps through which you can install the <kbd>nickel</kbd> crate into your Rust project and learn the commands with which we can host a custom template when the end user hits an endpoint.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following <kbd>nickel</kbd> crate before we can go ahead and spawn a web server. Follow the given steps to download and set up the <kbd>nickel</kbd> crate for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust project using the Cargo tool and enter the newly created project:</li>
</ol>
<pre><strong>      cargo new nickel-template --bin &amp;&amp; cd nickel-template</strong>
</pre>
<p style="padding-left: 60px">Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/4578440a-4d03-44b0-89b3-188e1a70342a.png"/></div>
<ol start="3">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification shown in the following screenshot. Here, we are using the <kbd>nickel</kbd> crate, which is entered in the dependencies field:<br/>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/a75776da-da81-4853-bedc-20f3c389c696.png"/></div>
</li>
<li>Install the crate in your project with the following command:</li>
</ol>
<pre><strong>      cargo build</strong>
</pre>
<p style="padding-left: 60px">This command will install all the dependencies of the <kbd>nickle</kbd> crate in your Rust project.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Templating in nickel<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 20 April 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Import the installed <kbd>nickel</kbd> crate by using the <kbd>extern</kbd> keyword:</li>
</ol>
<pre>        #[macro_use] extern crate nickel;<br/><br/>        use std::collections::HashMap;<br/>        use nickel::{Nickel, HttpRouter};
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function where we declare the <kbd>server</kbd> instance:</li>
</ol>
<pre>        fn main() {<br/>          let mut server = Nickel::new();<br/><br/>          server.get("/", middleware! { |_, response|<br/>          let mut data = HashMap::new();<br/>          data.insert("name", "viki");<br/>          return<br/>          response.render("examples/assets/template.tpl",<br/>          &amp;data);<br/>          });<br/><br/>          server.listen("127.0.0.1:6767");<br/>        }
</pre>
<ol start="5">
<li>Create the <kbd>examples/assets</kbd> directory and the <kbd>template.tpl</kbd> file using the the following commands:</li>
</ol>
<pre><strong>        mkdir -p examples/assets<br/>        cd ./examples/assets<br/>        touch template.tpl</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/7a98653a-d3e4-47dc-aaa9-8d776ea694ff.png"/></div>
<ol start="6">
<li>Open the file <kbd>template.tpl</kbd> in a text editor and enter the following code:</li>
</ol>
<pre>        &lt;html&gt;<br/>        &lt;body&gt;<br/>        &lt;h1&gt;<br/>        Hello {{ name }}!<br/>        &lt;/h1&gt;<br/>        &lt;/body&gt;<br/>        &lt;/html&gt;
</pre>
<ol start="7">
<li>Save the file and start the server with the following command from the root directory of the project:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p style="padding-left: 60px">We will get the following output on the successful execution of our code in the terminal:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/90d49d32-0574-413a-a8c1-9efe852ab4d9.png"/></div>
<p style="padding-left: 60px" class="mce-root CDPAlignLeft CDPAlign">Open your favorite browser and redirect to <kbd>127.0.0.1:6767</kbd> to get the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><br/>
<img height="147" width="237" class="image-border" src="images/32968ef2-1fc5-48d4-a75b-0870f9f40f93.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a Rust project named <kbd>nickel-template</kbd>, which loads a custom HTML template with dynamic data fields when the end user tries to access a particular endpoint.</p>
<p><span>Starting at the top, we referenced the external</span> <kbd>nickel</kbd> <span>crate using the</span> <kbd>extern</kbd> <span>keyword and loaded all of its macros with</span> <kbd>#[macro_use]</kbd><span>. We used</span> <kbd>nickel</kbd> <span>as the application object and surface, which holds all the public APIs; it's a struct that implements all the fundamental methods for performing all the web application tasks. We also used <kbd>HttpRouter</kbd>, which is a public trait provided by the <kbd>nickle</kbd> crate and has the signature of various REST API calls, and the <kbd>Hashmap</kbd> type from</span> <kbd>std::collections</kbd><span>.</span></p>
<div class="packt_infobox">HashMaps store values by key. <kbd>HashMap</kbd> keys can be Booleans, integers, Strings, and vectors. HashMaps are growable but HashMaps can also shrink themselves when they have excess space.</div>
<p><span>In the</span> <kbd>main</kbd> <span>function, we first assign</span> <kbd>server</kbd> <span>instances to a mutable variable and create a new</span> <kbd>nickel</kbd> <span>application object with</span> <kbd>Nickel::new()</kbd>, <span>which creates an instance of <kbd>nickel</kbd> with default error handling.</span></p>
<p><span>The</span> <kbd>server.get</kbd> <span>method registers a handler to be used for a specific</span> <kbd>get</kbd> <span>request. Handlers are assigned to paths and paths are allowed to contain variables and wildcards. A handler added through this API will be attached to the default router. The</span> <kbd>middleware!</kbd> <span>macro reduces the amount of boilerplate code needed for each route. The path here is <kbd>"/"</kbd>, where the response contains the data that needs to be returned to the end user.</span> We host the template created in <kbd>examples/asset s/template.tpl</kbd> and provide the input for the <kbd>name</kbd> field in the arguments for <kbd>response.render</kbd>, which is returned as output to the end user. We create a mutable variable named <kbd>data</kbd>, which is of the <kbd>HashMap</kbd> type. We also insert a key named <kbd>name</kbd> and assign it a value, <kbd>"viki"</kbd> using <kbd>data.insert</kbd>.</p>
<p><span>The</span> <kbd>server.listen</kbd> <span>method listens to the API requests on</span> <kbd>127.0.0.1:6767</kbd> <span>where it binds and listens for connections on the given host and port.</span></p>


            </article>

            
        </section>
    </div>
</body>
</html>