<html><head></head><body>
        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Adding All Game Mechanisms</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In the previous chapters, <a href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>, <a href="part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 2</a>,  <em class="calibre21">Starting with SDL</em>, and <a href="part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 3</a>, <em class="calibre21">Events and Basic Game Mechanisms</em>, we wrote all the mechanisms that we needed. The only missing parts are the UI rendering and the font management. In short, the easy parts So in this chapter, we'll add the drawing of the game and some fonts handling as well.</p>
<p class="calibre3">Let's go!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Getting started with game mechanisms</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's start with the UI rendering first and then add the font management in order to display the game information in real time.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Rendering UI</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">With the current code base, very few changes are required in order to be able to have a fully working Tetris.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Rendering initialization</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">For now, the <span><kbd class="calibre14">main</kbd></span> function is very small. First, let's add the following lines at the top of the function:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> sdl_context = sdl2::init().expect(<span>"SDL initialization <br class="calibre6"/>      failed"</span>);
<span>    let</span> video_subsystem = sdl_context.video().expect(<span>"Couldn't get<br class="calibre6"/>       SDL video subsystem"</span>);
<span>    let</span> width = <span>600</span>;
<span>    let</span> height = <span>800</span>;</pre></div>
<p class="calibre3">No need for explanations, we've already explained everything in the previous chapters, so let's continue.</p>
<p class="calibre3">Just after the following lines:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> sdl_context = sdl2::init().expect(<span>"SDL initialization<br class="calibre6"/>      failed"</span>);
<span>    let</span> <span>mut</span> tetris = Tetris::new();
<span>    let</span> <span>mut</span> timer = SystemTime::now();

<span>    let</span> <span>mut</span> event_pump = sdl_context.event_pump().expect(<span>"Failed to<br class="calibre6"/>      get SDL event pump"</span>);

<span>    let</span> grid_x = (width - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>) <span>as</span> <span>i32</span> / <span>2</span>;
<span>    let</span> grid_y = (height - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>) <span>as</span> <span>i32</span> / <span>2</span>;</pre></div>
<p class="calibre3">Let's add the following ones:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> window = video_subsystem.window(<span>"Tetris"</span>, width, height)
        .position_centered() <span>// to put it in the middle of the screen</span>
        .build() <span>// to create the window</span>
        .expect(<span>"Failed to create window"</span>);

<span>    let</span> <span>mut</span> canvas = window.into_canvas()
        .target_texture()
        .present_vsync() <span>// To enable v-sync.</span>
        .build()
        .expect(<span>"Couldn't get window's canvas"</span>);

<span>    let</span> texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();

<span>    let</span> grid = create_texture_rect(&amp;<span>mut</span> canvas,
        &amp;texture_creator,
        <span>0</span>, <span>0</span>, <span>0</span>,
        TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>,
        TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>).expect(<span>"Failed to create<br class="calibre6"/>           a texture"</span>);

<span>    let</span> border = create_texture_rect(&amp;<span>mut</span> canvas,
        &amp;texture_creator,
        <span>255</span>, <span>255</span>, <span>255</span>,
        TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span> + <span>20</span>,
        TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span> + <span>20</span>).expect(<span>"Failed to create <br class="calibre6"/>          a texture"</span>);

<span>    macro_rules!</span> texture <span>{</span>
      ($r:expr, $g:expr, $b:expr) =&gt; (
        create_texture_rect(&amp;<span>mut</span> canvas,
          &amp;texture_creator,
          $r, $g, $b,
          TETRIS_HEIGHT <span>as</span> <span>u32</span>,
          TETRIS_HEIGHT <span>as</span> <span>u32</span>).unwrap()
      )
<span>    }</span>

<span>    let</span> textures = <span>[</span><span>texture!</span>(<span>255</span>, <span>69</span>, <span>69</span>), <span>texture!</span>(<span>255</span>, <span>220</span>, <span>69</span>), <br class="calibre6"/><span>        texture!</span>(<span>237</span>, <span>150</span>, <span>37</span>),<span>texture!</span>(<span>171</span>, <span>99</span>, <span>237</span>), <span>texture!</span>(<span>77</span>, <span>149</span>, <br class="calibre6"/><span>        239</span>), <span>texture!</span>(<span>39</span>, <span>218</span>, <span>225</span>), <span>texture!</span>(<span>45</span>, <span>216</span>, <span>47</span>)<span>]</span>;</pre></div>
<p class="calibre3">There's even a macro in the middle, so yes, a few explanations are required!</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> window = video_subsystem.window(<span>"Tetris"</span>, width, height)
       .position_centered()
       .build()
       .expect(<span>"Failed to create window"</span>);

<span>    let</span> <span>mut</span> canvas = window.into_canvas()
       .target_texture()
       .present_vsync()
       .build()
       .expect(<span>"Couldn't get window's canvas"</span>);

<span>    let</span> texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();</pre></div>
<p class="calibre3">We've already seen all this, so we'll just go very quickly through each:</p>
<ol class="calibre16">
<li value="1" class="calibre11">We create the window.</li>
<li value="2" class="calibre11">We initialize the area where we'll draw.</li>
<li value="3" class="calibre11">We initialize the texture engine.</li>
</ol>
<p class="calibre3">The two next calls are more interesting and are the start of the actual UI rendering:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> grid = create_texture_rect(&amp;<span>mut</span> canvas,
       &amp;texture_creator,
       <span>0</span>, <span>0</span>, <span>0</span>,
       TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>,
       TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>).expect(<span>"Failed to create a texture"</span>);

<span>    let</span> border = create_texture_rect(&amp;<span>mut</span> canvas,
       &amp;texture_creator,
       <span>255</span>, <span>255</span>, <span>255</span>,
       TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span> + <span>20</span>,
       TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span> + <span>20</span>).expect(<span>"Failed to create a texture"</span>);</pre></div>
<p class="calibre3">They both call a function defined in <a target="_blank" href="part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 2</a>, <em class="calibre21">Starting with SDL</em>. <span><kbd class="calibre14">grid</kbd></span> is where we'll draw the tetriminoes and border to represent the borders of the game area. The first one is black, whereas the other one is <span>white</span>. The following is a screenshot of what they'll look like:</p>
<div class="mce-root"><img src="../images/00024.jpeg" class="calibre54"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 4.1</em></div>
</div>
<p class="calibre3">So now let's write down the code to load more easily:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    macro_rules!</span> texture <span>{</span>
      ($r:expr, $g:expr, $b:expr) =&gt; (
        create_texture_rect(&amp;<span>mut</span> canvas,
           &amp;texture_creator,
           $r, $g, $b,
           TETRIS_HEIGHT <span>as</span> <span>u32</span>,
           TETRIS_HEIGHT <span>as</span> <span>u32</span>).unwrap()
      )
<span>    }</span></pre></div>
<p class="calibre3">We already introduced macros in <a target="_blank" href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>, so we will assume you'll understand pretty easily what this one is doing. (It calls the <span><kbd class="calibre14">create_texture_rect</kbd></span> function with <span><kbd class="calibre14">$r</kbd></span>, <span><kbd class="calibre14">$g</kbd></span>, and <span><kbd class="calibre14">$b</kbd></span> being the color we want the texture to be.)</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> textures = <span>[</span><span>texture!</span>(<span>255</span>, <span>69</span>, <span>69</span>), <span>texture!</span>(<span>255</span>, <span>220</span>, <span>69</span>), <br class="calibre6"/><span>         texture!</span>(<span>237</span>, <span>150</span>, <span>37</span>), <span>texture!</span>(<span>171</span>, <span>99</span>, <span>237</span>), <span>texture!</span>(<span>77</span>, <span>149</span>,<br class="calibre6"/>          <span>239</span>), <span>texture!</span>(<span>39</span>, <span>218</span>, <span>225</span>), <span>texture!</span>(<span>45</span>, <span>216</span>, <span>47</span>)<span>]</span>;</pre></div>
<p class="calibre3">In here, we create the textures for our tetriminoes blocks. So seven textures for seven types of tetrimino blocks.</p>
<p class="calibre3">We initialized everything we needed for the rendering. So now, let's render!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Rendering</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Still in the <kbd class="calibre14">main</kbd> function, but this time we're going into the main loop (no wordplay!). Just after the <span><kbd class="calibre14">is_time_over</kbd></span> if condition, let's add:</p>
<div class="title-page-name">
<pre class="calibre23">    canvas.set_draw_color(Color::RGB(<span>255</span>, <span>0</span>, <span>0</span>));
    canvas.clear();
    canvas.copy(&amp;border,
        <span>None</span>,
        Rect::new((width - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>) <span>as</span> <span>i32</span> / <span>2</span> - <span>10</span>,
        (height - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>) <span>as</span> <span>i32</span> / <span>2</span> - <span>10</span>,
        TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span> + <span>20</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span> + <span>20</span>))
        .expect(<span>"Couldn't copy texture into window"</span>);
         canvas.copy(&amp;grid,
         <span>None</span>,
         Rect::new((width - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>) <span>as</span> <span>i32</span> / <span>2</span>,
         (height - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>) <span>as</span> <span>i32</span> / <span>2</span>,
         TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>))
         .expect(<span>"Couldn't copy texture into window"</span>);</pre></div>
<p class="calibre3">If we want to change the background depending on the player's actual level, we can just change the first line. No sweat.</p>
<p class="calibre3">About the following formulas:</p>
<div class="title-page-name">
<pre class="calibre23">    Rect::new((width - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>) <span>as</span> <span>i32</span> / <span>2</span> - <span>10</span>,
       (height - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>) <span>as</span> <span>i32</span> / <span>2</span> - <span>10</span>,
       TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span> + <span>20</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span> + <span>20</span>)</pre></div>
<p class="calibre3">I think a small explanation might come in handy here. As you certainly remember, <span><kbd class="calibre14">Rect::new</kbd></span> takes the four following arguments:</p>
<ul class="calibre10">
<li class="calibre11"><em class="calibre21">x</em> position</li>
<li class="calibre11"><em class="calibre21">y</em> position</li>
<li class="calibre11">width</li>
<li class="calibre11">height</li>
</ul>
<p class="calibre3">For the first two, we center our game map. For example, for the <em class="calibre21">x</em> position, we need to first compute how much width it'll take (so a width of <kbd class="calibre14">10</kbd> tetriminoes):</p>
<pre class="calibre23">    TETRIS_HEIGHT as u32 * 10</pre>
<p class="calibre3">Then we subtract this from the total width:</p>
<pre class="calibre23">    width - TETRIS_HEIGHT as u32 * 10</pre>
<p class="calibre3">What remains is what isn't the game map. So if we use it as <em class="calibre21">x</em> position, the game map will be fully on the left. Not pretty. Luckily, centering is quite easy, we just have to divide this result by 2, which is shown as follows:</p>
<pre class="calibre23">    (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2</pre>
<p class="calibre3">And here we go! Now, about the subtraction of 10; it's because of the borders. It has a width of <kbd class="calibre14">10</kbd>, so we need to subtract it as well to be <em class="calibre21">really</em> centered:</p>
<pre class="calibre23">    (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2 - 10</pre>
<p class="calibre3">Not very complicated, but it can be hard to read the first time. The same goes for the height, so we won't make the same explanations twice. Time to speak about the width and height computation! I think that you already got it from the previous explanations, but just in case:</p>
<pre class="calibre23">    TETRIS_HEIGHT as u32 * 10</pre>
<p class="calibre3">A <kbd class="calibre14">Tetris</kbd> has a width of ten blocks. Therefore, our game map must have the same as well.</p>
<pre class="calibre23">    TETRIS_HEIGHT as u32 * 10 + 20</pre>
<p class="calibre3">We've now added the width of the total borders as well (since there is a border on each side and a border has a width of 10 pixels, <span><kbd class="calibre14">10 * 2 = 20</kbd></span>).</p>
<p class="calibre3">The same goes for the height.</p>
<p class="calibre3">Once you get how these formulas work, you'll get how all the others are working as well.</p>
<p class="calibre3">Since we've drawn the game environment, it's time to draw the tetriminoes. First, let's draw the current one! In order to do this, we need to update the <span><kbd class="calibre14">for</kbd></span> loop inside the <span><kbd class="calibre14">handle_events</kbd></span> condition:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    if</span> !handle_events(&amp;<span>mut</span> tetris, &amp;<span>mut</span> quit, &amp;<span>mut</span> timer, &amp;<span>mut<br class="calibre6"/></span>      event_pump) <span>{</span>
      <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
        <span>for</span> (line_nb, line) <span>in</span> piece.states<span>[</span>piece.current_state<br class="calibre6"/>           <span>as</span> <span>usize</span><span>]</span>.iter().enumerate() <span>{</span>
          <span>for</span> (case_nb, case) <span>in</span> line.iter().enumerate() <span>{</span>
            <span>if</span> *case == <span>0</span> <span>{</span>
              <span>continue</span>
            <span>}</span>
            <span>// The new part is here:</span>
              canvas.copy(&amp;textures<span>[</span>*case <span>as</span> <span>usize</span> - <span>1</span><span>]</span>,
                <span>None</span>,
                Rect::new(grid_x + (piece.x + case_nb <span>as</span> <span>isize</span>) <span>as</span> <br class="calibre6"/><span>                  i32</span> * TETRIS_HEIGHT <span>as</span> <span>i32</span>, grid_y + (piece.y + <br class="calibre6"/>                  line_nb) <span>as</span> <span>i32</span> * TETRIS_HEIGHT <span>as</span> <span>i32</span>, TETRIS_HEIGHT<br class="calibre6"/>                  <span>as</span> <span>u32</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span>))
                  .expect(<span>"Couldn't copy texture into window"</span>);
          <span>}</span>
        <span>}</span>
      <span>}</span>
<span>    }</span></pre></div>
<p class="calibre3">For each block of the current tetrimino, we paste a texture corresponding to its ID. From the explanations of the preceding formulas, we can suppose it's not necessary to go back on those <em class="calibre21">new</em> ones.</p>
<p class="calibre3">With this, only the last part is remaining; drawing all the other tetriminoes blocks:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    for</span> (line_nb, line) <span>in</span> tetris.game_map.iter().enumerate() <span>{</span>
      <span>for</span> (case_nb, case) <span>in</span> line.iter().enumerate() <span>{</span>
        <span>if</span> *case == <span>0</span> <span>{</span>
            <span>continue</span>
        <span>}</span>
        canvas.copy(&amp;textures<span>[</span>*case <span>as</span> <span>usize</span> - <span>1</span><span>]</span>,
          <span>None</span>, Rect::new(grid_x + case_nb <span>as</span> <span>i32</span> * TETRIS_HEIGHT<br class="calibre6"/>          <span>as</span> <span>i32</span>, grid_y + line_nb <span>as</span> <span>i32</span> * TETRIS_HEIGHT <span>as</span> <span>i32</span>,
          TETRIS_HEIGHT <span>as</span> <span>u32</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span>))
          .expect(<span>"Couldn't copy texture into window"</span>);
      <span>}</span>
<span>    }</span>
    canvas.present();</pre></div>
<p class="calibre3">In this code, we iterate over a block of each line of the game map and paste the corresponding texture, if the game map's <em class="calibre21">occupied</em>.</p>
<p class="calibre3">Once done, we apply all the changes to the display, with:</p>
<div class="title-page-name">
<pre class="calibre23">    canvas.present();</pre></div>
<p class="calibre3">With this, our <kbd class="calibre14">Tetris</kbd> is now complete! You can now play by launching the command:</p>
<pre class="calibre23"><strong class="calibre5">cargo run --release</strong></pre>
<p class="calibre3">The <span><kbd class="calibre14">--release</kbd></span> is for starting the program in non-debug mode.</p>
<p class="calibre3">The full code of the <span><kbd class="calibre14">main</kbd></span> function is now the following:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    fn</span> main() <span>{</span>
      <span>let</span> sdl_context = sdl2::init().expect(<span>"SDL initialization failed"</span>);
      <span>let</span> video_subsystem = sdl_context.video().expect(<span>"Couldn't get <br class="calibre6"/>          SDL video subsystem"</span>);
      <span>let</span> width = <span>600</span>;
      <span>let</span> height = <span>800</span>;
<span>      let</span> <span>mut</span> timer = SystemTime::now();
<span>      let</span> <span>mut</span> event_pump = sdl_context.event_pump().expect(<span>"Failed to get<br class="calibre6"/>          SDL event pump"</span>);

      <span>let</span> grid_x = (width - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>) <span>as</span> <span>i32</span> / <span>2</span>;
      <span>let</span> grid_y = (height - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>) <span>as</span> <span>i32</span> / <span>2</span>;
<span>      let</span> <span>mut</span> tetris = Tetris::new();

      <span>let</span> window = video_subsystem.window(<span>"Tetris"</span>, width, height)
                                .position_centered()
                                .build()
                                .expect(<span>"Failed to create window"</span>);

      <span>let</span> <span>mut</span> canvas = window.into_canvas()
                           .target_texture()
                           .present_vsync()
                           .build()
                           .expect(<span>"Couldn't get window's canvas"</span>);

      <span>let</span> texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();

      <span>let</span> grid = create_texture_rect(&amp;<span>mut</span> canvas,
               &amp;texture_creator,
               <span>0</span>, <span>0</span>, <span>0</span>,
               TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>,
               TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>).expect(<span>"Failed to create<br class="calibre6"/>                 a texture"</span>);

      <span>let</span> border = create_texture_rect(&amp;<span>mut</span> canvas,
               &amp;texture_creator,
               <span>255</span>, <span>255</span>, <span>255</span>,
               TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span> + <span>20</span>,
               TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span> + <span>20</span>).expect(<span>"Failed to create<br class="calibre6"/>                 a texture"</span>);

      <span>macro_rules!</span> texture <span>{</span>
        ($r:expr, $g:expr, $b:expr) =&gt; (
            create_texture_rect(&amp;<span>mut</span> canvas,
                                &amp;texture_creator,
                                $r, $g, $b,
                                TETRIS_HEIGHT <span>as</span> <span>u32</span>,
                                TETRIS_HEIGHT <span>as</span> <span>u32</span>).unwrap()
        )
      <span>}</span>

      <span>let</span> textures = <span>[</span><span>texture!</span>(<span>255</span>, <span>69</span>, <span>69</span>), <span>texture!</span>(<span>255</span>, <span>220</span>, <span>69</span>),<br class="calibre6"/>         <span>texture!</span>(<span>237</span>, <span>150</span>, <span>37</span>), <span>texture!</span>(<span>171</span>, <span>99</span>, <span>237</span>), <br class="calibre6"/><span>         texture!</span>(<span>77</span>, <span>149</span>, <span>239</span>), <span>texture!</span>(<span>39</span>, <span>218</span>, <span>225</span>),
         <span>texture!</span>(<span>45</span>, <span>216</span>, <span>47</span>)<span>]</span>;

      <span>loop</span> <span>{</span>
        <span>if</span> is_time_over(&amp;tetris, &amp;timer) <span>{</span>
          <span>let</span> <span>mut</span> make_permanent = <span>false</span>;
          <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
            <span>let</span> x = piece.x;
            <span>let</span> y = piece.y + <span>1</span>;
            make_permanent = !piece.change_position(&amp;tetris.game_map,<br class="calibre6"/>               x, y);
          <span>}</span>
          <span>if</span> make_permanent <span>{</span>
            tetris.make_permanent();
          <span>}</span>
          timer = SystemTime::now();
        <span>}</span>

        canvas.set_draw_color(Color::RGB(<span>255</span>, <span>0</span>, <span>0</span>));
        canvas.clear();

        canvas.copy(&amp;border,
           <span>None</span>,
           Rect::new((width - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>) <span>as</span> <span>i32</span> / <span>2</span> - <span>10</span>,
           (height - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>) <span>as</span> <span>i32</span> / <span>2</span> - <span>10</span>,
           TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span> + <span>20</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span> + <span>20</span>))
           .expect(<span>"Couldn't copy texture into window"</span>);
        canvas.copy(&amp;grid,
           <span>None</span>,
           Rect::new((width - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>) <span>as</span> <span>i32</span> / <span>2</span>,
           (height - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>) <span>as</span> <span>i32</span> / <span>2</span>,
           TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>))
           .expect(<span>"Couldn't copy texture into window"</span>);


        <span>if</span> tetris.current_piece.is_none() <span>{</span>
            <span>let</span> current_piece = tetris.create_new_tetrimino();
            <span>if</span> !current_piece.test_current_position(&amp;tetris.game_map) <span>{</span>
                print_game_information(&amp;tetris);
                <span>break</span>
            <span>}</span>
            tetris.current_piece = <span>Some</span>(current_piece);
        <span>}</span>
        <span>let</span> <span>mut</span> quit = <span>false</span>;
        <span>if</span> !handle_events(&amp;<span>mut</span> tetris, &amp;<span>mut</span> quit, &amp;<span>mut</span> timer,<br class="calibre6"/>           &amp;<span>mut</span> event_pump) <span>{</span>
         <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
           <span>for</span> (line_nb, line) <span>in</span> piece.states<span>[</span>piece.current_state <br class="calibre6"/><span>               as</span> <span>usize</span><span>]</span>.iter().enumerate() <span>{</span>
             <span>for</span> (case_nb, case) <span>in</span> line.iter().enumerate() <span>{</span>
               <span>if</span> *case == <span>0</span> <span>{</span>
                 <span>continue</span>
               <span>}</span>
               canvas.copy(&amp;textures<span>[</span>*case <span>as</span> <span>usize</span> - <span>1</span><span>]</span>,
                  <span>None</span>,
                  Rect::new(grid_x + (piece.x + case_nb <span>as</span> <span>isize</span>) <br class="calibre6"/><span>                    as</span> <span>i32</span> * TETRIS_HEIGHT <span>as</span> <span>i32</span>,
                  grid_y + (piece.y + line_nb) <span>as</span> <span>i32</span> * TETRIS_HEIGHT <br class="calibre6"/><span>                    as</span> <span>i32</span>,
                    TETRIS_HEIGHT <span>as</span> <span>u32</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span>))
                  .expect(<span>"Couldn't copy texture into window"</span>);
             <span>}</span>
           <span>}</span>
         <span>}</span>
        <span>}</span>
        <span>if</span> quit <span>{</span>
          print_game_information(&amp;tetris);
            <span>break</span>
        <span>}</span>

        <span>for</span> (line_nb, line) <span>in</span> tetris.game_map.iter().enumerate() <span>{</span>
          <span>for</span> (case_nb, case) <span>in</span> line.iter().enumerate() <span>{</span>
             <span>if</span> *case == <span>0</span> <span>{</span>
                <span>continue</span>
             <span>}</span>
             canvas.copy(&amp;textures<span>[</span>*case <span>as</span> <span>usize</span> - <span>1</span><span>]</span>,
                <span>None</span>,
                Rect::new(grid_x + case_nb <span>as</span> <span>i32</span> * TETRIS_HEIGHT <span>as</span> <span>i32</span>,
                grid_y + line_nb <span>as</span> <span>i32</span> * TETRIS_HEIGHT <span>as</span> <span>i32</span>,
                TETRIS_HEIGHT <span>as</span> <span>u32</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span>))
                .expect(<span>"Couldn't copy texture into window"</span>);
          <span>}</span>
        <span>}</span>
        canvas.present();

        sleep(Duration::new(<span>0</span>, <span>1_000_000_000u32</span> / <span>60</span>));
      <span>}</span>
<span>    }</span></pre></div>
<p class="calibre3">And here is an example of the current output of this code:</p>
<div class="mce-root"><img src="../images/00025.jpeg" class="calibre55"/></div>
<div class="mce-root1"><em class="calibre21">Figure 4.2</em></div>
<p class="calibre3">It's now working, but what about displaying the game information, such as the current score, level, or the number of lines sent?</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Playing with fonts</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">To display these pieces of information, we'll need to use fonts. No additional external dependencies are required, however, we'll need to use a feature, so we need to update our <span><kbd class="calibre14">Cargo.toml</kbd></span>:</p>
<pre class="calibre23">    [features]
    default = ["sdl2/ttf"]</pre>
<p class="calibre3">By default, the <span><kbd class="calibre14">sdl2</kbd></span> crate doesn't provide the <kbd class="calibre14">ttf</kbd> module, you need to enable it by adding the <span><kbd class="calibre14">ttf</kbd></span> feature to the compilation process. That's what we did by saying to <span><kbd class="calibre14">cargo</kbd></span>: <em class="calibre21">by default, I want the <kbd class="calibre14">ttf</kbd> feature of the <kbd class="calibre14">sdl2</kbd> crate enabled</em>. You can try with and without it to see the difference, after adding this new context initialization:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> ttf_context = sdl2::ttf::init().expect(<span>"SDL TTF initialization<br class="calibre6"/>        failed"</span>);</pre></div>
<div class="packt_infobox">If you get a missing library compilation error, it means you didn't install the corresponding library. To fix this issue, you need to install it through your favorite package manager.</div>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Install on OS X</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Run the following command:</p>
<pre class="calibre23"><strong class="calibre5">brew install sdl2_ttf</strong></pre>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Install on Linux</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Run the following command (depending on your package manager, of course):</p>
<pre class="calibre23"><strong class="calibre5">sudo apt-get install libsdl2-ttf-dev</strong></pre>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Other system/package manager</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">You can download the library at <a href="https://www.libsdl.org/projects/SDL_ttf/" class="calibre13">https://www.libsdl.org/projects/SDL_ttf/.</a></p>
<p class="calibre3">Follow the instructions and install it on your system, then just run the projects. If no errors appear, then it means you installed it correctly.</p>
<p class="calibre3">Time to start the real thing!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Loading font</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Before going any further, we actually need a font. I chose <strong class="calibre5">Lucida console</strong>, but pick the one you prefer, it doesn't really matter. Once downloaded, put it in the <span><kbd class="calibre14">assets</kbd></span> folder as well. Now, time to actually load the font:</p>
<div class="title-page-name">
<pre class="calibre23"><span>     let</span> font = ttf_context.load_font(<span>"assets/lucida.ttf"</span>, <span>128</span>).expect(<span>"<br class="calibre6"/>       Couldn't load the font"</span>);</pre></div>
<p class="calibre3">Note that if you want to apply a style to your font (such as bold, italic, strikethrough, or underline), that's the object on which you need to apply it. Here is an example:</p>
<div class="title-page-name">
<pre class="calibre23">    font.set_style(sdl2::ttf::STYLE_BOLD);</pre></div>
<p class="calibre3">Now, two steps are remaining to be able to actually display text:</p>
<ol class="calibre16">
<li value="1" class="calibre11">Render the text.</li>
<li value="2" class="calibre11">Create a texture from it.</li>
</ol>
<p class="calibre3">Let's write a function in order to do so:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    fn</span> create_texture_from_text&lt;<span>'a</span>&gt;(texture_creator: &amp;<span>'a</span> <br class="calibre6"/>       TextureCreator&lt;WindowContext&gt;,
       font: &amp;sdl2::ttf::Font,
       text: &amp;<span>str</span>,
       r: <span>u8</span>, g: <span>u8</span>, b: <span>u8</span>,
       ) -&gt; <span>Option</span>&lt;Texture&lt;<span>'a</span>&gt;&gt; <span>{</span>
         <span>if</span> <span>let</span> <span>Ok</span>(surface) = font.render(text)
           .blended(Color::RGB(r, g, b)) <span>{</span>
          texture_creator.create_texture_from_surface(&amp;surface).ok()
         <span>}</span> <span>else</span> <span>{</span>
               <span>None</span>
           <span>}</span>
<span>       }</span></pre></div>
<p class="calibre3">Looks a lot like <span><kbd class="calibre14">create_texture_rect</kbd></span>, right?</p>
<p class="calibre3">Why not test it? Let's call the function and paste the texture onto the screen to see:</p>
<div class="title-page-name">
<pre class="calibre23"><span>     let</span> rendered_text = create_texture_from_text(&amp;texture_creator,<br class="calibre6"/>        &amp;font, <span>"test"</span>, <span>255</span>, <span>255</span>, <span>255</span>).expect(<span>"Cannot render text"</span>);
     canvas.copy(&amp;rendered_text, <span>None</span>, <span>Some</span>(Rect::new(width <span>as</span> <span>i32</span> - <br class="calibre6"/><span>        40</span>, <span>0</span>, <span>40</span>, <span>30</span>)))
    .expect(<span>"Couldn't copy t</span><span>ext"</span>);</pre></div>
<p class="calibre3">And it looks like this:</p>
<div class="mce-root"><img src="../images/00026.jpeg" class="calibre56"/></div>
<div class="mce-root1"><em class="calibre21">Figure 4.3</em></div>
<p class="calibre3">For the texture rectangle, I use the following rule: one character is a block of 10 x 30 pixels. So in this example, since <kbd class="calibre14">test</kbd> has 4 letters, we need a block of 40 x 30 pixels. Let's write a function to make this easier:</p>
<div class="title-page-name">
<pre class="calibre23"><span>     fn</span> get_rect_from_text(text: &amp;<span>str</span>, x: <span>i32</span>, y: <span>i32</span>) -&gt; <span>Option</span>&lt;Rect&gt; <span>{</span>
        <span>Some</span>(Rect::new(x, y, text.len() <span>as</span> <span>u32</span> * <span>20</span>, <span>30</span>))
<span>     }</span></pre></div>
<p class="calibre3">Ok, so now is the time to render the game information and write a new function to do it:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    fn</span> display_game_information&lt;<span>'a</span>&gt;(tetris: &amp;Tetris,
       canvas: &amp;<span>mut</span> Canvas&lt;Window&gt;,
       texture_creator: &amp;<span>'a</span> TextureCreator&lt;WindowContext&gt;,
       font: &amp;sdl2::ttf::Font,
       start_x_point: <span>i32</span>) <span>{</span>
     <span>let</span> score_text = <span>format!</span>(<span>"Score: {}"</span>, tetris.score);
     <span>let</span> lines_sent_text = <span>format!</span>(<span>"Lines sent: {}"</span>, tetris.nb_lines);
     <span>let</span> level_text = <span>format!</span>(<span>"Level: {}"</span>, tetris.current_level);

     <span>let</span> score = create_texture_from_text(&amp;texture_creator, &amp;font,
        &amp;score_text, <span>255</span>, <span>255</span>, <span>255</span>)
        .expect(<span>"Cannot render text"</span>);
     <span>let</span> lines_sent = create_texture_from_text(&amp;texture_creator, &amp;font,
        &amp;lines_sent_text, <span>255</span>, <span>255</span>, <span>255</span>)
        .expect(<span>"Cannot render text"</span>);
     <span>let</span> level = create_texture_from_text(&amp;texture_creator, &amp;font,
        &amp;level_text, <span>255</span>, <span>255</span>, <span>255</span>)
        .expect(<span>"Cannot render text"</span>);
     
     canvas.copy(&amp;score, <span>None</span>, get_rect_from_text(&amp;score_text, <br class="calibre6"/>       start_x_point, <span>90</span>))
          .expect(<span>"Couldn't copy text"</span>);
    canvas.copy(&amp;lines_sent, <span>None</span>, get_rect_from_text(&amp;score_text,<br class="calibre6"/>       start_x_point, <span>125</span>))
          .expect(<span>"Couldn't copy text"</span>);
    canvas.copy(&amp;level, <span>None</span>, get_rect_from_text(&amp;score_text, <br class="calibre6"/>       start_x_point, <span>160</span>))
          .expect(<span>"Couldn't copy text"</span>);
<span>    }</span></pre></div>
<p class="calibre3">And then we call it, as follows:</p>
<div class="title-page-name">
<pre class="calibre23">    display_game_information(&amp;tetris, &amp;<span>mut</span> canvas, &amp;texture_creator, &amp;font,
       width <span>as</span> <span>i32</span> - grid_x - <span>1</span><span>0</span>);</pre></div>
<p class="calibre3">And now it looks like this:</p>
<div class="mce-root"><img src="../images/00027.jpeg" class="calibre57"/></div>
<div class="mce-root1"><em class="calibre21">Figure 4.4</em></div>
<p class="calibre3">Wonderful, we have the game information in real time! Isn't it awesome? What? It's ugly and overlaps the game? Let's move the game then! Instead of centering it, we'll give it a fixed <kbd class="calibre14">x</kbd> position (which will make our formula way simpler).</p>
<p class="calibre3">First, let's update our <span><kbd class="calibre14">grid_x</kbd></span> variable:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> grid_x = <span>20</span>;</pre></div>
<p class="calibre3">Then, let's update so <span><kbd class="calibre14">canvas.copy</kbd></span> calls:</p>
<div class="title-page-name">
<pre class="calibre23">     canvas.copy(&amp;border,
            <span>None</span>,
            Rect::new(<span>10</span>,
                      (height - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>) <span>as</span> <span>i32</span> / <span>2</span> - <span>10</span>,
                      TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span> + <span>20</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span> + <span>20</span>))
      .expect(<span>"Couldn't copy texture into window"</span>);
     canvas.copy(&amp;grid,
       <span>None</span>,
       Rect::new(<span>20</span>,
       (height - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>) <span>as</span> <span>i32</span> / <span>2</span>,
        TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>, TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>))
      .expect(<span>"Couldn't copy texture into window"</span>);</pre></div>
<p class="calibre3">And that's it. You now have a nice Tetris playing:</p>
<div class="mce-root"><img src="../images/00028.jpeg" class="calibre58"/></div>
<div class="mce-root1"><em class="calibre21"><em class="calibre21">Figure 4.5</em></em></div>
<p class="calibre3">We could improve the display a bit by adding a border around the text, or even display a preview of the next piece, or even add a <em class="calibre21">ghost</em>, but I think that, from this point, you can add them easily.</p>
<p class="calibre3">That's it for this Tetris, have fun while playing with the <span><kbd class="calibre14">sdl2</kbd></span>!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We now have a fully working Tetris. In the last three chapters, we saw how to use the <kbd class="calibre14">sdl2</kbd> crate, how to add dependencies to Rust projects, how to handle I/O (with files), and how modules were working.</p>
<p class="calibre3">Even if we stop here for this Tetris project, you can <span>continue this project </span>(and it'd be even a good idea to improve yourself in <kbd class="calibre14">sdl2</kbd>!).  A few ideas of missing things you could add:</p>
<ul class="calibre10">
<li class="calibre11">Change the background depending on the current level</li>
<li class="calibre11">Asking the players, once the game is over, if they want to start a new game</li>
<li class="calibre11">Adding the next tetrimino preview</li>
<li class="calibre11">Adding a ghost (to see where the tetrimino will fall)</li>
<li class="calibre11"><span>And so much more. Just have fun while adding new features!</span></li>
</ul>
<p class="calibre3">As you can see, a lot of things are possible. Have fun!</p>
<p class="calibre3"/>


            </article>

            
        </section>
    </body></html>