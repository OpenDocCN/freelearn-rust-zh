<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding All Game Mechanisms</h1>
                
            
            
                
<p class="calibre3">In the previous chapters, <a href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>, <a href="part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 2</a>,  <em class="calibre21">Starting with SDL</em>, and <a href="part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 3</a>, <em class="calibre21">Events and Basic Game Mechanisms</em>, we wrote all the mechanisms that we needed. The only missing parts are the UI rendering and the font management. In short, the easy parts So in this chapter, we'll add the drawing of the game and some fonts handling as well.</p>
<p class="calibre3">Let's go!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting started with game mechanisms</h1>
                
            
            
                
<p class="calibre3">Let's start with the UI rendering first and then add the font management in order to display the game information in real time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rendering UI</h1>
                
            
            
                
<p class="calibre3">With the current code base, very few changes are required in order to be able to have a fully working Tetris.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rendering initialization</h1>
                
            
            
                
<p class="calibre3">For now, the <kbd class="calibre14">main</kbd> function is very small. First, let's add the following lines at the top of the function:</p>
<div><pre class="calibre23">    let sdl_context = sdl2::init().expect("SDL initialization <br class="calibre6"/>      failed");
    let video_subsystem = sdl_context.video().expect("Couldn't get<br class="calibre6"/>       SDL video subsystem");
    let width = 600;
    let height = 800;</pre></div>
<p class="calibre3">No need for explanations, we've already explained everything in the previous chapters, so let's continue.</p>
<p class="calibre3">Just after the following lines:</p>
<div><pre class="calibre23">    let sdl_context = sdl2::init().expect("SDL initialization<br class="calibre6"/>      failed");
    let mut tetris = Tetris::new();
    let mut timer = SystemTime::now();

    let mut event_pump = sdl_context.event_pump().expect("Failed to<br class="calibre6"/>      get SDL event pump");

    let grid_x = (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2;
    let grid_y = (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2;</pre></div>
<p class="calibre3">Let's add the following ones:</p>
<div><pre class="calibre23">    let window = video_subsystem.window("Tetris", width, height)
        .position_centered() // to put it in the middle of the screen
        .build() // to create the window
        .expect("Failed to create window");

    let mut canvas = window.into_canvas()
        .target_texture()
        .present_vsync() // To enable v-sync.
        .build()
        .expect("Couldn't get window's canvas");

    let texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();

    let grid = create_texture_rect(&amp;mut canvas,
        &amp;texture_creator,
        0, 0, 0,
        TETRIS_HEIGHT as u32 * 10,
        TETRIS_HEIGHT as u32 * 16).expect("Failed to create<br class="calibre6"/>           a texture");

    let border = create_texture_rect(&amp;mut canvas,
        &amp;texture_creator,
        255, 255, 255,
        TETRIS_HEIGHT as u32 * 10 + 20,
        TETRIS_HEIGHT as u32 * 16 + 20).expect("Failed to create <br class="calibre6"/>          a texture");

    macro_rules! texture {
      ($r:expr, $g:expr, $b:expr) =&gt; (
        create_texture_rect(&amp;mut canvas,
          &amp;texture_creator,
          $r, $g, $b,
          TETRIS_HEIGHT as u32,
          TETRIS_HEIGHT as u32).unwrap()
      )
    }

    let textures = [texture!(255, 69, 69), texture!(255, 220, 69), <br class="calibre6"/>        texture!(237, 150, 37),texture!(171, 99, 237), texture!(77, 149, <br class="calibre6"/>        239), texture!(39, 218, 225), texture!(45, 216, 47)];</pre></div>
<p class="calibre3">There's even a macro in the middle, so yes, a few explanations are required!</p>
<div><pre class="calibre23">    let window = video_subsystem.window("Tetris", width, height)
       .position_centered()
       .build()
       .expect("Failed to create window");

    let mut canvas = window.into_canvas()
       .target_texture()
       .present_vsync()
       .build()
       .expect("Couldn't get window's canvas");

    let texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();</pre></div>
<p class="calibre3">We've already seen all this, so we'll just go very quickly through each:</p>
<ol class="calibre16">
<li value="1" class="calibre11">We create the window.</li>
<li value="2" class="calibre11">We initialize the area where we'll draw.</li>
<li value="3" class="calibre11">We initialize the texture engine.</li>
</ol>
<p class="calibre3">The two next calls are more interesting and are the start of the actual UI rendering:</p>
<div><pre class="calibre23">    let grid = create_texture_rect(&amp;mut canvas,
       &amp;texture_creator,
       0, 0, 0,
       TETRIS_HEIGHT as u32 * 10,
       TETRIS_HEIGHT as u32 * 16).expect("Failed to create a texture");

    let border = create_texture_rect(&amp;mut canvas,
       &amp;texture_creator,
       255, 255, 255,
       TETRIS_HEIGHT as u32 * 10 + 20,
       TETRIS_HEIGHT as u32 * 16 + 20).expect("Failed to create a texture");</pre></div>
<p class="calibre3">They both call a function defined in <a target="_blank" href="part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 2</a>, <em class="calibre21">Starting with SDL</em>. <kbd class="calibre14">grid</kbd> is where we'll draw the tetriminoes and border to represent the borders of the game area. The first one is black, whereas the other one is white. The following is a screenshot of what they'll look like:</p>
<div><img src="img/00024.jpeg" class="calibre54"/></div>
<div><div><em class="calibre21">Figure 4.1</em></div>
</div>
<p class="calibre3">So now let's write down the code to load more easily:</p>
<div><pre class="calibre23">    macro_rules! texture {
      ($r:expr, $g:expr, $b:expr) =&gt; (
        create_texture_rect(&amp;mut canvas,
           &amp;texture_creator,
           $r, $g, $b,
           TETRIS_HEIGHT as u32,
           TETRIS_HEIGHT as u32).unwrap()
      )
    }</pre></div>
<p class="calibre3">We already introduced macros in <a target="_blank" href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>, so we will assume you'll understand pretty easily what this one is doing. (It calls the <kbd class="calibre14">create_texture_rect</kbd> function with <kbd class="calibre14">$r</kbd>, <kbd class="calibre14">$g</kbd>, and <kbd class="calibre14">$b</kbd> being the color we want the texture to be.)</p>
<div><pre class="calibre23">    let textures = [texture!(255, 69, 69), texture!(255, 220, 69), <br class="calibre6"/>         texture!(237, 150, 37), texture!(171, 99, 237), texture!(77, 149,<br class="calibre6"/>          239), texture!(39, 218, 225), texture!(45, 216, 47)];</pre></div>
<p class="calibre3">In here, we create the textures for our tetriminoes blocks. So seven textures for seven types of tetrimino blocks.</p>
<p class="calibre3">We initialized everything we needed for the rendering. So now, let's render!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rendering</h1>
                
            
            
                
<p class="calibre3">Still in the <kbd class="calibre14">main</kbd> function, but this time we're going into the main loop (no wordplay!). Just after the <kbd class="calibre14">is_time_over</kbd> if condition, let's add:</p>
<div><pre class="calibre23">    canvas.set_draw_color(Color::RGB(255, 0, 0));
    canvas.clear();
    canvas.copy(&amp;border,
        None,
        Rect::new((width - TETRIS_HEIGHT as u32 * 10) as i32 / 2 - 10,
        (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2 - 10,
        TETRIS_HEIGHT as u32 * 10 + 20, TETRIS_HEIGHT as u32 * 16 + 20))
        .expect("Couldn't copy texture into window");
         canvas.copy(&amp;grid,
         None,
         Rect::new((width - TETRIS_HEIGHT as u32 * 10) as i32 / 2,
         (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2,
         TETRIS_HEIGHT as u32 * 10, TETRIS_HEIGHT as u32 * 16))
         .expect("Couldn't copy texture into window");</pre></div>
<p class="calibre3">If we want to change the background depending on the player's actual level, we can just change the first line. No sweat.</p>
<p class="calibre3">About the following formulas:</p>
<div><pre class="calibre23">    Rect::new((width - TETRIS_HEIGHT as u32 * 10) as i32 / 2 - 10,
       (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2 - 10,
       TETRIS_HEIGHT as u32 * 10 + 20, TETRIS_HEIGHT as u32 * 16 + 20)</pre></div>
<p class="calibre3">I think a small explanation might come in handy here. As you certainly remember, <kbd class="calibre14">Rect::new</kbd> takes the four following arguments:</p>
<ul class="calibre10">
<li class="calibre11"><em class="calibre21">x</em> position</li>
<li class="calibre11"><em class="calibre21">y</em> position</li>
<li class="calibre11">width</li>
<li class="calibre11">height</li>
</ul>
<p class="calibre3">For the first two, we center our game map. For example, for the <em class="calibre21">x</em> position, we need to first compute how much width it'll take (so a width of <kbd class="calibre14">10</kbd> tetriminoes):</p>
<pre class="calibre23">    TETRIS_HEIGHT as u32 * 10</pre>
<p class="calibre3">Then we subtract this from the total width:</p>
<pre class="calibre23">    width - TETRIS_HEIGHT as u32 * 10</pre>
<p class="calibre3">What remains is what isn't the game map. So if we use it as <em class="calibre21">x</em> position, the game map will be fully on the left. Not pretty. Luckily, centering is quite easy, we just have to divide this result by 2, which is shown as follows:</p>
<pre class="calibre23">    (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2</pre>
<p class="calibre3">And here we go! Now, about the subtraction of 10; it's because of the borders. It has a width of <kbd class="calibre14">10</kbd>, so we need to subtract it as well to be <em class="calibre21">really</em> centered:</p>
<pre class="calibre23">    (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2 - 10</pre>
<p class="calibre3">Not very complicated, but it can be hard to read the first time. The same goes for the height, so we won't make the same explanations twice. Time to speak about the width and height computation! I think that you already got it from the previous explanations, but just in case:</p>
<pre class="calibre23">    TETRIS_HEIGHT as u32 * 10</pre>
<p class="calibre3">A <kbd class="calibre14">Tetris</kbd> has a width of ten blocks. Therefore, our game map must have the same as well.</p>
<pre class="calibre23">    TETRIS_HEIGHT as u32 * 10 + 20</pre>
<p class="calibre3">We've now added the width of the total borders as well (since there is a border on each side and a border has a width of 10 pixels, <kbd class="calibre14">10 * 2 = 20</kbd>).</p>
<p class="calibre3">The same goes for the height.</p>
<p class="calibre3">Once you get how these formulas work, you'll get how all the others are working as well.</p>
<p class="calibre3">Since we've drawn the game environment, it's time to draw the tetriminoes. First, let's draw the current one! In order to do this, we need to update the <kbd class="calibre14">for</kbd> loop inside the <kbd class="calibre14">handle_events</kbd> condition:</p>
<div><pre class="calibre23">    if !handle_events(&amp;mut tetris, &amp;mut quit, &amp;mut timer, &amp;mut<br class="calibre6"/>      event_pump) {
      if let Some(ref mut piece) = tetris.current_piece {
        for (line_nb, line) in piece.states[piece.current_state<br class="calibre6"/>           as usize].iter().enumerate() {
          for (case_nb, case) in line.iter().enumerate() {
            if *case == 0 {
              continue
            }
            // The new part is here:
              canvas.copy(&amp;textures[*case as usize - 1],
                None,
                Rect::new(grid_x + (piece.x + case_nb as isize) as <br class="calibre6"/>                  i32 * TETRIS_HEIGHT as i32, grid_y + (piece.y + <br class="calibre6"/>                  line_nb) as i32 * TETRIS_HEIGHT as i32, TETRIS_HEIGHT<br class="calibre6"/>                  as u32, TETRIS_HEIGHT as u32))
                  .expect("Couldn't copy texture into window");
          }
        }
      }
    }</pre></div>
<p class="calibre3">For each block of the current tetrimino, we paste a texture corresponding to its ID. From the explanations of the preceding formulas, we can suppose it's not necessary to go back on those <em class="calibre21">new</em> ones.</p>
<p class="calibre3">With this, only the last part is remaining; drawing all the other tetriminoes blocks:</p>
<div><pre class="calibre23">    for (line_nb, line) in tetris.game_map.iter().enumerate() {
      for (case_nb, case) in line.iter().enumerate() {
        if *case == 0 {
            continue
        }
        canvas.copy(&amp;textures[*case as usize - 1],
          None, Rect::new(grid_x + case_nb as i32 * TETRIS_HEIGHT<br class="calibre6"/>          as i32, grid_y + line_nb as i32 * TETRIS_HEIGHT as i32,
          TETRIS_HEIGHT as u32, TETRIS_HEIGHT as u32))
          .expect("Couldn't copy texture into window");
      }
    }
    canvas.present();</pre></div>
<p class="calibre3">In this code, we iterate over a block of each line of the game map and paste the corresponding texture, if the game map's <em class="calibre21">occupied</em>.</p>
<p class="calibre3">Once done, we apply all the changes to the display, with:</p>
<div><pre class="calibre23">    canvas.present();</pre></div>
<p class="calibre3">With this, our <kbd class="calibre14">Tetris</kbd> is now complete! You can now play by launching the command:</p>
<pre class="calibre23"><strong class="calibre5">cargo run --release</strong></pre>
<p class="calibre3">The <kbd class="calibre14">--release</kbd> is for starting the program in non-debug mode.</p>
<p class="calibre3">The full code of the <kbd class="calibre14">main</kbd> function is now the following:</p>
<div><pre class="calibre23">    fn main() {
      let sdl_context = sdl2::init().expect("SDL initialization failed");
      let video_subsystem = sdl_context.video().expect("Couldn't get <br class="calibre6"/>          SDL video subsystem");
      let width = 600;
      let height = 800;
      let mut timer = SystemTime::now();
      let mut event_pump = sdl_context.event_pump().expect("Failed to get<br class="calibre6"/>          SDL event pump");

      let grid_x = (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2;
      let grid_y = (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2;
      let mut tetris = Tetris::new();

      let window = video_subsystem.window("Tetris", width, height)
                                .position_centered()
                                .build()
                                .expect("Failed to create window");

      let mut canvas = window.into_canvas()
                           .target_texture()
                           .present_vsync()
                           .build()
                           .expect("Couldn't get window's canvas");

      let texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();

      let grid = create_texture_rect(&amp;mut canvas,
               &amp;texture_creator,
               0, 0, 0,
               TETRIS_HEIGHT as u32 * 10,
               TETRIS_HEIGHT as u32 * 16).expect("Failed to create<br class="calibre6"/>                 a texture");

      let border = create_texture_rect(&amp;mut canvas,
               &amp;texture_creator,
               255, 255, 255,
               TETRIS_HEIGHT as u32 * 10 + 20,
               TETRIS_HEIGHT as u32 * 16 + 20).expect("Failed to create<br class="calibre6"/>                 a texture");

      macro_rules! texture {
        ($r:expr, $g:expr, $b:expr) =&gt; (
            create_texture_rect(&amp;mut canvas,
                                &amp;texture_creator,
                                $r, $g, $b,
                                TETRIS_HEIGHT as u32,
                                TETRIS_HEIGHT as u32).unwrap()
        )
      }

      let textures = [texture!(255, 69, 69), texture!(255, 220, 69),<br class="calibre6"/>         texture!(237, 150, 37), texture!(171, 99, 237), <br class="calibre6"/>         texture!(77, 149, 239), texture!(39, 218, 225),
         texture!(45, 216, 47)];

      loop {
        if is_time_over(&amp;tetris, &amp;timer) {
          let mut make_permanent = false;
          if let Some(ref mut piece) = tetris.current_piece {
            let x = piece.x;
            let y = piece.y + 1;
            make_permanent = !piece.change_position(&amp;tetris.game_map,<br class="calibre6"/>               x, y);
          }
          if make_permanent {
            tetris.make_permanent();
          }
          timer = SystemTime::now();
        }

        canvas.set_draw_color(Color::RGB(255, 0, 0));
        canvas.clear();

        canvas.copy(&amp;border,
           None,
           Rect::new((width - TETRIS_HEIGHT as u32 * 10) as i32 / 2 - 10,
           (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2 - 10,
           TETRIS_HEIGHT as u32 * 10 + 20, TETRIS_HEIGHT as u32 * 16 + 20))
           .expect("Couldn't copy texture into window");
        canvas.copy(&amp;grid,
           None,
           Rect::new((width - TETRIS_HEIGHT as u32 * 10) as i32 / 2,
           (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2,
           TETRIS_HEIGHT as u32 * 10, TETRIS_HEIGHT as u32 * 16))
           .expect("Couldn't copy texture into window");


        if tetris.current_piece.is_none() {
            let current_piece = tetris.create_new_tetrimino();
            if !current_piece.test_current_position(&amp;tetris.game_map) {
                print_game_information(&amp;tetris);
                break
            }
            tetris.current_piece = Some(current_piece);
        }
        let mut quit = false;
        if !handle_events(&amp;mut tetris, &amp;mut quit, &amp;mut timer,<br class="calibre6"/>           &amp;mut event_pump) {
         if let Some(ref mut piece) = tetris.current_piece {
           for (line_nb, line) in piece.states[piece.current_state <br class="calibre6"/>               as usize].iter().enumerate() {
             for (case_nb, case) in line.iter().enumerate() {
               if *case == 0 {
                 continue
               }
               canvas.copy(&amp;textures[*case as usize - 1],
                  None,
                  Rect::new(grid_x + (piece.x + case_nb as isize) <br class="calibre6"/>                    as i32 * TETRIS_HEIGHT as i32,
                  grid_y + (piece.y + line_nb) as i32 * TETRIS_HEIGHT <br class="calibre6"/>                    as i32,
                    TETRIS_HEIGHT as u32, TETRIS_HEIGHT as u32))
                  .expect("Couldn't copy texture into window");
             }
           }
         }
        }
        if quit {
          print_game_information(&amp;tetris);
            break
        }

        for (line_nb, line) in tetris.game_map.iter().enumerate() {
          for (case_nb, case) in line.iter().enumerate() {
             if *case == 0 {
                continue
             }
             canvas.copy(&amp;textures[*case as usize - 1],
                None,
                Rect::new(grid_x + case_nb as i32 * TETRIS_HEIGHT as i32,
                grid_y + line_nb as i32 * TETRIS_HEIGHT as i32,
                TETRIS_HEIGHT as u32, TETRIS_HEIGHT as u32))
                .expect("Couldn't copy texture into window");
          }
        }
        canvas.present();

        sleep(Duration::new(0, 1_000_000_000u32 / 60));
      }
    }</pre></div>
<p class="calibre3">And here is an example of the current output of this code:</p>
<div><img src="img/00025.jpeg" class="calibre55"/></div>
<div><em class="calibre21">Figure 4.2</em></div>
<p class="calibre3">It's now working, but what about displaying the game information, such as the current score, level, or the number of lines sent?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Playing with fonts</h1>
                
            
            
                
<p class="calibre3">To display these pieces of information, we'll need to use fonts. No additional external dependencies are required, however, we'll need to use a feature, so we need to update our <kbd class="calibre14">Cargo.toml</kbd>:</p>
<pre class="calibre23">    [features]
    default = ["sdl2/ttf"]</pre>
<p class="calibre3">By default, the <kbd class="calibre14">sdl2</kbd> crate doesn't provide the <kbd class="calibre14">ttf</kbd> module, you need to enable it by adding the <kbd class="calibre14">ttf</kbd> feature to the compilation process. That's what we did by saying to <kbd class="calibre14">cargo</kbd>: <em class="calibre21">by default, I want the <kbd class="calibre14">ttf</kbd> feature of the <kbd class="calibre14">sdl2</kbd> crate enabled</em>. You can try with and without it to see the difference, after adding this new context initialization:</p>
<div><pre class="calibre23">    let ttf_context = sdl2::ttf::init().expect("SDL TTF initialization<br class="calibre6"/>        failed");</pre></div>
<p>If you get a missing library compilation error, it means you didn't install the corresponding library. To fix this issue, you need to install it through your favorite package manager.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Install on OS X</h1>
                
            
            
                
<p class="calibre3">Run the following command:</p>
<pre class="calibre23"><strong class="calibre5">brew install sdl2_ttf</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Install on Linux</h1>
                
            
            
                
<p class="calibre3">Run the following command (depending on your package manager, of course):</p>
<pre class="calibre23"><strong class="calibre5">sudo apt-get install libsdl2-ttf-dev</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Other system/package manager</h1>
                
            
            
                
<p class="calibre3">You can download the library at <a href="https://www.libsdl.org/projects/SDL_ttf/" class="calibre13">https://www.libsdl.org/projects/SDL_ttf/.</a></p>
<p class="calibre3">Follow the instructions and install it on your system, then just run the projects. If no errors appear, then it means you installed it correctly.</p>
<p class="calibre3">Time to start the real thing!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Loading font</h1>
                
            
            
                
<p class="calibre3">Before going any further, we actually need a font. I chose <strong class="calibre5">Lucida console</strong>, but pick the one you prefer, it doesn't really matter. Once downloaded, put it in the <kbd class="calibre14">assets</kbd> folder as well. Now, time to actually load the font:</p>
<div><pre class="calibre23">     let font = ttf_context.load_font("assets/lucida.ttf", 128).expect("<br class="calibre6"/>       Couldn't load the font");</pre></div>
<p class="calibre3">Note that if you want to apply a style to your font (such as bold, italic, strikethrough, or underline), that's the object on which you need to apply it. Here is an example:</p>
<div><pre class="calibre23">    font.set_style(sdl2::ttf::STYLE_BOLD);</pre></div>
<p class="calibre3">Now, two steps are remaining to be able to actually display text:</p>
<ol class="calibre16">
<li value="1" class="calibre11">Render the text.</li>
<li value="2" class="calibre11">Create a texture from it.</li>
</ol>
<p class="calibre3">Let's write a function in order to do so:</p>
<div><pre class="calibre23">    fn create_texture_from_text&lt;'a&gt;(texture_creator: &amp;'a <br class="calibre6"/>       TextureCreator&lt;WindowContext&gt;,
       font: &amp;sdl2::ttf::Font,
       text: &amp;str,
       r: u8, g: u8, b: u8,
       ) -&gt; Option&lt;Texture&lt;'a&gt;&gt; {
         if let Ok(surface) = font.render(text)
           .blended(Color::RGB(r, g, b)) {
          texture_creator.create_texture_from_surface(&amp;surface).ok()
         } else {
               None
           }
       }</pre></div>
<p class="calibre3">Looks a lot like <kbd class="calibre14">create_texture_rect</kbd>, right?</p>
<p class="calibre3">Why not test it? Let's call the function and paste the texture onto the screen to see:</p>
<div><pre class="calibre23">     let rendered_text = create_texture_from_text(&amp;texture_creator,<br class="calibre6"/>        &amp;font, "test", 255, 255, 255).expect("Cannot render text");
     canvas.copy(&amp;rendered_text, None, Some(Rect::new(width as i32 - <br class="calibre6"/>        40, 0, 40, 30)))
    .expect("Couldn't copy text");</pre></div>
<p class="calibre3">And it looks like this:</p>
<div><img src="img/00026.jpeg" class="calibre56"/></div>
<div><em class="calibre21">Figure 4.3</em></div>
<p class="calibre3">For the texture rectangle, I use the following rule: one character is a block of 10 x 30 pixels. So in this example, since <kbd class="calibre14">test</kbd> has 4 letters, we need a block of 40 x 30 pixels. Let's write a function to make this easier:</p>
<div><pre class="calibre23">     fn get_rect_from_text(text: &amp;str, x: i32, y: i32) -&gt; Option&lt;Rect&gt; {
        Some(Rect::new(x, y, text.len() as u32 * 20, 30))
     }</pre></div>
<p class="calibre3">Ok, so now is the time to render the game information and write a new function to do it:</p>
<div><pre class="calibre23">    fn display_game_information&lt;'a&gt;(tetris: &amp;Tetris,
       canvas: &amp;mut Canvas&lt;Window&gt;,
       texture_creator: &amp;'a TextureCreator&lt;WindowContext&gt;,
       font: &amp;sdl2::ttf::Font,
       start_x_point: i32) {
     let score_text = format!("Score: {}", tetris.score);
     let lines_sent_text = format!("Lines sent: {}", tetris.nb_lines);
     let level_text = format!("Level: {}", tetris.current_level);

     let score = create_texture_from_text(&amp;texture_creator, &amp;font,
        &amp;score_text, 255, 255, 255)
        .expect("Cannot render text");
     let lines_sent = create_texture_from_text(&amp;texture_creator, &amp;font,
        &amp;lines_sent_text, 255, 255, 255)
        .expect("Cannot render text");
     let level = create_texture_from_text(&amp;texture_creator, &amp;font,
        &amp;level_text, 255, 255, 255)
        .expect("Cannot render text");
     
     canvas.copy(&amp;score, None, get_rect_from_text(&amp;score_text, <br class="calibre6"/>       start_x_point, 90))
          .expect("Couldn't copy text");
    canvas.copy(&amp;lines_sent, None, get_rect_from_text(&amp;score_text,<br class="calibre6"/>       start_x_point, 125))
          .expect("Couldn't copy text");
    canvas.copy(&amp;level, None, get_rect_from_text(&amp;score_text, <br class="calibre6"/>       start_x_point, 160))
          .expect("Couldn't copy text");
    }</pre></div>
<p class="calibre3">And then we call it, as follows:</p>
<div><pre class="calibre23">    display_game_information(&amp;tetris, &amp;mut canvas, &amp;texture_creator, &amp;font,
       width as i32 - grid_x - 10);</pre></div>
<p class="calibre3">And now it looks like this:</p>
<div><img src="img/00027.jpeg" class="calibre57"/></div>
<div><em class="calibre21">Figure 4.4</em></div>
<p class="calibre3">Wonderful, we have the game information in real time! Isn't it awesome? What? It's ugly and overlaps the game? Let's move the game then! Instead of centering it, we'll give it a fixed <kbd class="calibre14">x</kbd> position (which will make our formula way simpler).</p>
<p class="calibre3">First, let's update our <kbd class="calibre14">grid_x</kbd> variable:</p>
<div><pre class="calibre23">    let grid_x = 20;</pre></div>
<p class="calibre3">Then, let's update so <kbd class="calibre14">canvas.copy</kbd> calls:</p>
<div><pre class="calibre23">     canvas.copy(&amp;border,
            None,
            Rect::new(10,
                      (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2 - 10,
                      TETRIS_HEIGHT as u32 * 10 + 20, TETRIS_HEIGHT as u32 * 16 + 20))
      .expect("Couldn't copy texture into window");
     canvas.copy(&amp;grid,
       None,
       Rect::new(20,
       (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2,
        TETRIS_HEIGHT as u32 * 10, TETRIS_HEIGHT as u32 * 16))
      .expect("Couldn't copy texture into window");</pre></div>
<p class="calibre3">And that's it. You now have a nice Tetris playing:</p>
<div><img src="img/00028.jpeg" class="calibre58"/></div>
<div><em class="calibre21"><em class="calibre21">Figure 4.5</em></em></div>
<p class="calibre3">We could improve the display a bit by adding a border around the text, or even display a preview of the next piece, or even add a <em class="calibre21">ghost</em>, but I think that, from this point, you can add them easily.</p>
<p class="calibre3">That's it for this Tetris, have fun while playing with the <kbd class="calibre14">sdl2</kbd>!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre3">We now have a fully working Tetris. In the last three chapters, we saw how to use the <kbd class="calibre14">sdl2</kbd> crate, how to add dependencies to Rust projects, how to handle I/O (with files), and how modules were working.</p>
<p class="calibre3">Even if we stop here for this Tetris project, you can continue this project (and it'd be even a good idea to improve yourself in <kbd class="calibre14">sdl2</kbd>!).  A few ideas of missing things you could add:</p>
<ul class="calibre10">
<li class="calibre11">Change the background depending on the current level</li>
<li class="calibre11">Asking the players, once the game is over, if they want to start a new game</li>
<li class="calibre11">Adding the next tetrimino preview</li>
<li class="calibre11">Adding a ghost (to see where the tetrimino will fall)</li>
<li class="calibre11">And so much more. Just have fun while adding new features!</li>
</ul>
<p class="calibre3">As you can see, a lot of things are possible. Have fun!</p>
<p class="calibre3"/>


            

            
        
    </body></html>