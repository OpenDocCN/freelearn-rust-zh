- en: Testing and Debugging Rust Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices, like any other application, can have bugs. You can make a mistake
    when writing new code, or by adding extra features to an application. In this
    chapter, we will explore the available tools to test and debug your microservices.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating unit and integration tests for an application. We
    will also examine the testing capabilities of the `actix` crate.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we will study debugging with the LLDB Debugger, and also examine
    logging as a debugging technique, since not every bug can be caught with a traditional
    debugger. Furthermore, if you use a product in production, you can't attach a
    debugger to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the testing examples of this chapter, you need some extra software besides
    Rust compiler (which, of course, you'll need too). You will need to install Docker
    and Docker Compose to bootstrap the application from [Chapter 15](http://Packing%20Servers%20to%20Containers), *Packing
    Servers to Containers*. We will use this application to run integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to install the Postman tool, which we will use to test APIs
    manually, along with the LLDB debugger, which we'll learn how to use for debugging
    microservices. Also, Jaeger will need to be installed, but you can also use the
    all-in-one image running in Docker for this. Finally, we will use the OpenTracing
    API for distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples of this chapter are provided with sources on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter13.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter13)'
  prefs: []
  type: TYPE_NORMAL
- en: Testing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust is an almost perfect tool for creating reliable applications. The compiler
    is so strict and never misses any potential memory access error or data race,
    but still there are many ways to make a mistake in the code. In other words, Rust
    helps you a lot, but it is not omnipotent.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices can also have bugs, so you have to be armed to handle all possible
    bugs. The first line of defense is unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing involves using HTTP clients to send an isolated request to a server
    or a request handler. In a unit test, you should check only one function. It's
    necessary to cover the majority of the code that helps to keep the same behavior
    of a function that can be reimplemented or improved with tests.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you can write a test before writing any piece of code. It's called **Test-Driven
    Development** (**TDD**), but this approach is suitable for projects that have
    a good specification, because if you haven't decided on the solution, you will
    have to rewrite tests multiple times. In other words, TDD is not suitable for
    projects in which bugs are not critical, but where high-speed development is required.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests for traditional crates is simple, but for microservices,
    you have a lot of issues with emulating the environment in which a microservice
    will work in production. To emulate an environment, you can use mocking services
    that create HTTP servers with predefined responses for specified requests. Do
    you remember, in [Chapter 11,](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml) *Involving
    Concurrency with Actors and Actix Crate*, when we created a routing microservice
    that we can't test, because we have to run a lot of microservices manually? In
    this section, we will create a unit test for that very routing microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `mock` server that emulates responses for requests to three
    paths to a routing microservice: `/signin`, `/signup`, and `/comments`. There
    is the `mockito` crate that provides a server for emulating HTTP responses. We
    will use the example from [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml),
    *Involving Concurrency with Actors and the Actix Crate*. Copy it and add these
    extra dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We need the `mockito` crate to start a server with mocks, and the `reqwest`
    crate to make HTTP requests to our Actix server instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `tests` module with the `#[cfg(test)]` attribute that will be compiled
    for testing only, and import the following types that we will use for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We use types of router microservices to prepare requests; namely, `Comment`,
    `UserForm`, and `UserId`. Also, we added the `LinksMap` struct to configure URLs
    to mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this struct to `State` and use it with handlers to get the URLs of microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also, we imported the `lazy_static!` macro that we need to initialize a `Mutex`,
    which we will use to check that the Actix Server started once. Rust also has the
    `Once` type, which can also be used, but we need to wait a certain interval before
    letting the services perform requests, and the `is_completed` method of `Once`
    type is unstable. To create mocks, we will use the `mock` function of the `mockito`
    crate and a `Mock` type that represents a handler of a specific request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function to add mocks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `add_mock` function expects an HTTP method and path to emulated resource.
    Also, it takes a value returned as a response in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the `mock` function to create a `Mock` instance and tune it with the
    following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`with_status` sets the status code of a response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with_header` sets a specific value for a header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with_body` sets the body of a response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we call the `crate` method, which tries to start a `mock` server and
    attach our created `Mock` to it. Now, we can start a router microservice instance
    and prepare all the necessary mocks to emulate other microservices that the router
    expects.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a server for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start a server instance in a separate thread, because Rust runs tests
    in multiple threads, and we won''t create a server instance with a unique port
    for every test run to show how you can use a shared instance, because integration
    tests often need to reuse the same application instance. Create a shared flag
    that we will use to detect routers that have already started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use this `Mutex` to create a function to start a server. Look
    at the following `setup` function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function locks a `Mutex` to get the value of the flag. If it equals
    `false`, we spawn a new thread with a server instance and mocks, and wait 5 seconds
    before we set the flag to `true` and release the `Mutex`.
  prefs: []
  type: TYPE_NORMAL
- en: In the spawned thread, we get a URL or `mock` server. It automatically starts
    that server if it wasn't started already. After this, we use the `add_mock` method
    to add all mocks to emulate other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The `mockito` crate requires you to have added all the mocks in the same thread
    in which the `mock` server started.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we keep all crated mocks in local variables. If any of them are dropped,
    then that mocking handler will be lost. You can also use the `std::mem::forget`
    method to ensure that the mock will be never dropped, but it's more accurate to
    leave the local variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will employ `LinksMap` using the URL of the `mock` server and paths, both
    of which are concatenated with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we called the `start` function, which is actually a modified `main`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The difference between this and the `main` function of the router microservice
    of [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *Involving Concurrency
    with Actors and Actix Crate*, is that it expects the `LinksMap` value to add it
    to `State`. Now, we can create methods to perform testing requests to a server
    that resends them to mocks.
  prefs: []
  type: TYPE_NORMAL
- en: Making requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make `GET` requests, we will use the `test_get` function, which creates
    a `Client` of the `reqwest` crate, sets a path, executes a `send` request, and
    deserializes the response from JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with the `reqwest` crate, you may ask why we get text values,
    since `Client` has the `json` method that deserializes JSON? If we do that, we
    can't see the original value if we have deserialization issues, but using the
    original text of a response, we can log it for investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate URLs, we use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This adds the address of a server to which we bind it, but for large projects,
    it's better to use dynamic addresses, especially if you want to use a fresh server
    instance in every test.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `POST` requests, we will use similar method, but we won''t deserialize
    the result because we don''t need it and will check the status of a response only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have all the necessary functions to implement unit tests for every handler.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the utilities we''ve created so far in this chapter, the unit tests look
    pretty compact. To test the handler of the `/signup` path that expects `UserForm`,
    we will add a `test_signup_with_client` function with the `#[test]` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we run the `cargo test` command, this function will be called and the `test_post`
    call, in turn, will bootstrap a server with a `mock` server as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test a handler of the `/signin` path, we will use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This test uses the same input values with a `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch a list of comments, it''s enough to call the `test_get` function with the
    `/comments` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can start these tests to check the router microservice that forwards
    requests to a `mock` server.
  prefs: []
  type: TYPE_NORMAL
- en: Running our tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the unit test, run Cargo''s `test` command in the folder of this project.
    It will start three tests and you will see, in the Terminal, the output of the
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the tests have passed, but let''s check what happens if we change something
    in the implementation. Let''s remove a `Mock` for the `/signin` path. The test
    will print that one test has failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the `tests::test_signin_with_client` test failed, because it can't
    get a response from the `/signin` request. Unit testing will help you ensure the
    behavior of a handler won't be changed, even if you rewrite the implementation
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: We covered a microservice with a unit test using predefined methods to simplify
    bootstrapping a server and to send HTTP requests to it. If you want to test complex
    interaction with an application, you should implement integration tests, which
    we will cover now.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing can't guarantee that the whole application works, because it tests
    only a small piece of implementation. By contrast, integration tests are more
    complex and they help to ensure your whole application works properly. We combined
    some microservices that we created for this book into one application. Let's create
    integration tests to check the application.
  prefs: []
  type: TYPE_NORMAL
- en: Starting an application instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we write the first line of a testing code, we have to start an application
    with Docker. It''s complex and you will learn how to make it in [Chapter 15](80b8c3ec-d291-40df-a7a7-b9e9f0a64a99.xhtml), *Packing
    Servers to Containers*, but for now, open the code samples folder of that chapter
    and start a project from the Docker Compose script. However, you will also have
    to prepare an image for building microservices. Enter these two commands into
    a Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The project already contains a special Compose file, `docker-compose.test.yml`,
    that opens the ports of the containers to make it possible to connect to them
    from our local Rust application.
  prefs: []
  type: TYPE_NORMAL
- en: It takes time to start, but when the application has started, you will see the log
    in a Terminal window. Then, we can write some integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be surprised, but for integration testing, we don''t need a lot of
    dependencies, because we will use an HTTP client and the `serde` family of crates
    to serialize requests and deserialize responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Also, we need the `uuid` crate to generate unique values, and the `cookie` crate
    to support cookies in our HTTP requests, because integration tests have to keep
    the session to make a sequence of meaningful requests.
  prefs: []
  type: TYPE_NORMAL
- en: Utils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like we did for unit tests, we''ll add some utility function to avoid creating
    HTTP clients for every test. We will use predefined methods to health-check and
    to send `POST` and `GET` requests to microservices included in the application.
    Create a `utils.rs` file and import the necessary types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use a `Client` instance from the `reqwest` crate, just as we did for
    the unit test, but we''ll need to import extra types: `Method` to set different
    HTTP methods exactly; `RedirectPolicy` to control redirects, since the router
    microservice will redirect us to other pages; and `Client`, which will perform
    those redirects, but we want to turn off this behavior. `StatusCode` is used to
    check returned HTTP status codes.'
  prefs: []
  type: TYPE_NORMAL
- en: We imported the `COOKIE` and `SET_COOKIE` headers to set the values of those
    headers for requests, and get their values from the responses. But the values
    of those headers are formal and we need to parse them. To simplify this, we will
    use the `Cookie` and `CookieJar` types of the cookie crate, since the `reqwest`
    crate doesn't support cookies now.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we use the `rand` crate and the imported `Alphanumeric` distribution from
    it to generate unique logins for testing, because we will interact with a working
    application and simply can't restart it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application contains four microservices with the following addresses, all
    of which are available from the Docker containers of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared addresses as constant, so that we have a single place to update
    them if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need a function to generate random strings that consist of alphanumeric
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses a random number generator that's initialized for the
    current thread, and an iterator that generates random values, to take 7 characters
    and join them into `String` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since integration tests work with live systems, we need a function to sleep
    the current thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function is a short alias for the `thread::sleep` call.
  prefs: []
  type: TYPE_NORMAL
- en: But it's not all about utilities—we also need a universal client to send requests
    to all working microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The integration testing client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following struct to your `utils.rs` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It has three fields—an HTTP `Client`; a base `url`, which is used to construct
    full URLs with added paths; and a `CookieJar` instance to keep cookie values between
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of this struct takes a URL and builds a `Client` instance with
    redirects disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add shortcuts to create instances of `WebApi` for the specific microservice
    of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will check that every microservice is alive. To do this, we need a method
    for `WebApi` that sends `GET` requests to a specified path and checks the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Every microservice of our application has a special path to get the name of
    microservice, which we will use for health-checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send requests to microservices, we will use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It's a useful function that sends a request in JSON format and receives a response
    in JSON format, which it deserializes into the necessary native struct. The implementation
    of this method is not crazy. It expects a HTTP method, path, and values that will
    be used as form parameters in a request.
  prefs: []
  type: TYPE_NORMAL
- en: We use a textual response to print values if the microservice returns an HTTP
    status other than `OK`. If a response is successful, we will deserialize the body
    from JSON format to the necessary output type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the whole application won''t return internal service information to us,
    we need a method that creates a request and checks the status code of a response,
    but also stores cookies to have a chance to sign up and sign in to our application.
    Create the `check_status` method for the `WebApi` struct implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation also uses values to make a request with a form,
    but it also prepares cookies and sends them with the `Cookie`  header after the
    function expects a response from a server. If a response contains a `SetCookie`
    header, we use it to update our `CookieJar`. With such simple manipulations, we
    take a method that can keep the connection session.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start implementing tests, we need to add some types that we need
    to interact with microservices. Create a `types.rs` source file with types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a `UserId` struct that will be used to parse raw responses from the
    `users` microservices (yes, we will also test it directly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add a `Comment` struct that we will use to post new comments to our content
    microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can write tests for every microservice separately, and after that, create
    a test for complex interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start the `users` microservice test coverage. Create a `users.rs` file
    and import the created modules into it with the necessary types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At first, we have to check that the microservice is alive. Add the `users_healthcheck`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It creates an instance of the `WebApi` struct using the `users` method that
    already configures it for interaction with the users microservice. We use the
    `healthcheck` method to check the root path of a service that has to return the
    `"Users Microservice"` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main purpose of the `users` microservice is a new users'' registration,
    and the authorization of registered users. Create a `check_signup_and_signin`
    function that will generate a new user, register it by sending a request to the `/signup`
    path, and then try to log in using the `/signin` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We created a new `WebApi` instance that has targeted to our `users` microservice.
    The values of the `username` and `password` are generated by the `rand_str` function
    call of the `utils` module that we created earlier. After this, we prepare parameters
    to emulate sending an HTML form to a server with a `POST` request. The first request
    registers a new user; the second request tries to authorize it with the same form
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Since the users microservice is used internally by the router microservice,
    it returns a raw `UserId` struct. We will parse it, but won't use it, because
    we have already checked that the microservice works, as it won't return users'
    IDs for bad credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next microservice we need to test is a content microservice that allows
    users to post comments. Create a `content.rs` file and import the `types` and
    `utils` modules with the necessary types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We also will check that the service is available in the `content_healthcheck`
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This service is necessary for users to be able to add a new comment, and is
    loose-coupled (it doesn''t need to check that the user exists, because it is protected
    from non-existent users by router microservices). We will generate a new ID of
    the user and send a request to post a new comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We prepared a form to create a new comment and sent a `POST` request to the
    `/new_comment` path. After that, we take a list of comments and check that there
    is a comment with generated text in a list. This means that the comment was added
    and that the content microservice works properly.
  prefs: []
  type: TYPE_NORMAL
- en: Mailer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application also has a mailer microservice that sends notifications to
    users. It needs the `utils` module for testing only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the preceding code into a new `mailer.rs` file and add a `healthcheck`
    to test that a microservice instance is alive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The Mailer microservice also doesn''t need to know users to notify them. It
    only requires an email address and some content. This microservice will send confirmation
    codes to a user, so let''s simulate this behavior in our `send_mail` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We created a `WebApi` instance with the `mailer` function call to target a client
    to the Mailer microservice. After that, we generated a new email and code, and
    put them into a form. The microservice returns a Boolean value, indicating that
    the email was sent. We use it with the `asser!` macro to check that it worked
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered all of the microservices of the application with tests, and
    now we can add a full integration test that checks a complex interaction with
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `router.rs` file and add the following modules and types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the router microservice also serves static files by the root path that
    we used for the other microservice, to check that they are alive, we will use
    a special `/healthcheck` path that returns the name of that microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete test is implemented in the `check_router_full` test. Look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It creates a new `WebApi` instance that's targeted at the router microservice.
    After this, it creates random credentials for a user and calls the router's method
    in `/api` scope. But in this case, we use the `check_status` method, because the
    router microservice creates and keeps session IDs internally and returns cookies
    to identify us.
  prefs: []
  type: TYPE_NORMAL
- en: We sent requests to `/api/signup` and `/api/signin` to register a user account
    and to authorize it. After this, we called the `/api/new_comment` method of the
    application API to post a new comment by user of the current session. Finally,
    we check in the open `/api/comments` endpoint that our comment exits.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the basic functionality of applications with this integration test,
    but for large applications, you can also check records in databases, cached values,
    and uploaded files to ensure that the application works as you expected. If your
    microservice works incorrectly and you can't find a reason, you can try to debug
    it with the instruments that we will learn about in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your program does go wrong, you need debugging tools to fix that, which
    we will explore in this section. Debugging not only means interactive debugging
    using a debugger—a special tool that helps you to execute program step by step—you
    can also use logging to trace all activities of the code. To understand the cause
    of the error, you can use the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**curl**: a command-line tool that we already used to send HTTP requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postman:** a GUI tool for testing REST APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mitmproxy: ** a proxy to trace all requests passing through it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LLDB:** a traditional command-line debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VS Code:** an editor with good LLDB integration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore all of them.
  prefs: []
  type: TYPE_NORMAL
- en: curl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most commonly used tool to perform HTTP requests is `curl`. It''s a command-line
    tool with a boatload of parameters. Some of the most useful ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--request <METHOD>` (or `-X`) sets the HTTP method to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--header "Header: Value"` (or -`H`) sets an extra header to the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--data <data>` (of `-d`) sets a body to a request, and uses `@filename` as
    a data value to attach the contents of a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--form "field=value"` (or `-F`) sets a field of a form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cookie <file>` (or `-b`) sets a file with cookies to send'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cookie-jar <file>` (or `-c`) sets a file with cookies to store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if you want to send a request with a JSON file, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, to send a form, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you want to keep cookies between calls, use the same file to read and write
    cookie values with the following code: `-b session.file -c session.file`.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer to use GUI tools, you can consider using Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Postman is a popular extension for browsers that is also available as a desktop
    application. You can get it from here: [https://www.getpostman.com/](https://www.getpostman.com/).
    The coolest features of Postman include that you can group requests and use configurable
    variables in requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s send a sign-in request to our application that we started
    with Docker Compose. Install Postman and create a new workspace called **Rust
    Microservices***.* Enter the URL of an application, set the method to `POST`,
    and add the body as `x-www-form-unlencoded`, with two parameters, `email` and
    `password` (the user has to have been created with */signup* before). Click the Send
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55cab771-6424-4a77-a030-58fee59d9829.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the microservices returned a response with cookies, which contain
    an `auth-example` named value.
  prefs: []
  type: TYPE_NORMAL
- en: But what about if we want to use a browser to perform all activities, but explore
    sent request and responses later? We can start a tracing proxy. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: mitmproxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'mitmproxy is a good proxy that logs all request and responses, and can work
    as a transparent proxy, as a SOCKS5 proxy, or as a reverse proxy. This tool is
    useful when you want to interact with the running application with a browser,
    but want to record all request and responses of the interaction session. You can
    get this tool from here: [https://mitmproxy.org/](https://mitmproxy.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install a proxy and start it by forwarding it to the server''s ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you may already know by talking parameters, we used reverse-proxy mode. It
    used the `7777` port to provide access to the mitmproxy UI and port `7780` to
    connect to our application through proxy. In other words, the proxy redirects
    all requests from port `7780` to port `7000` of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `127.0.0.1:7777` in a browser, and `127.0.0.1:7780` in a separate tab,
    and try to interact with the application. The mitmproxy web app will show you
    a flow of request and the responses the browser made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39e16a9a-812e-4c0b-8623-d15309aa7c43.png)'
  prefs: []
  type: TYPE_IMG
- en: Like with Postman, we also can explore the headers of the `/signin` response,
    and see the cookie header with the `auth-example` value set.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you might see incorrect behavior in your application, but can't find
    a bug in the code. For these cases, you may consider trying debuggers.
  prefs: []
  type: TYPE_NORMAL
- en: LLDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust has good support for two debuggers—GDB and LLDB. We will try the second
    here. LLDB is a modern command-line debugger. It's a part of the LLVM project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to look inside our working router microservice. Move to the directory
    with the microservice and compile it with the `cargo build` command. However,
    you have to be sure you don''t set the `--release` flag, because it removes all
    debugging information. If you don''t use cargo and want to add debugging information
    directly using `rustc`, add the `-g -C debuginfo=2` arguments to keep debugging
    symbols in the output file. After the building is finished, use a command to start
    a debugger with scripts to support the Rust programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is already installed if you used the `rustup` installation tool
    to install Rust. You will have also installed LLDB debugger on your machine. When
    the debugger starts, it will print something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It will prompt for your input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set a breakpoint to the `comments` handler. You can do that with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It will print that your breakpoint was set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start the microservice with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It will inform you that the process has launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try to open the `http://localhost:8080/comments` URL in a browser,
    then the debugger will interrupt the execution of the handler in the breakpoint
    you set, and the debugger will show you the position of the line of code where
    it has interrupted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can explore the running microservices. For example, you
    can get to know which alive threads exists with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It will show you the main thread and arbiter threads of actix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: To see the variables that are available for the current context, you can use the
    `frame variable` command. To move execution to the next line of code, use the
    `next` command. To continue execution, use the `continue` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using this tool, you can go through buggy handlers step by step and find the
    reason for the problem. Many developers prefer GUI debuggers and we'll also try
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Code is a convenient editor for developers with a lot of extensions,
    including for the Rust language and the LLDB debugger support. Let's try to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you have to download and install Visual Studio Code from here: [https://code.visualstudio.com/](https://code.visualstudio.com/).
    After this, you need to install two extensions—`rust-lang.rust` and `vadimcn.vscode-lldb`.
    The first adds Rust support while the second integrates VS Code with LLDB.'
  prefs: []
  type: TYPE_NORMAL
- en: The integration with Rust is based on the **Rust Language Server** (**RLS**)
    project that, which provides information about Rust code for IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Open the router microservice project with *File > Add Folder To A Workspace...*
    and choose the folder with a project. When it's open, set a breakpoint—set a cursor
    to the desired line and choose *Debug > Toggle Breakpoint* command. Now, we can
    start debugging with the *Debug | Start Debugging* command. On the first run,
    it takes some time to prepare LLDB, but when debugger starts, it prints some information
    to the *Output* tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a browser and try to open the `http://localhost:8080/comments` URL that
    activates the breakpoint of our `comments` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/757b550d-b32b-46d2-be75-9ff8c5a62197.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the bar at the top to move the execution pointer to the next line. With
    a GUI debugger, you can explore variables and the call stack. It's simple and
    useful. But not every case can be fixed with debugger, because there's types of
    bugs (called **Heisenbugs**) that disappear at the moment of debugging or studying
    them. The only thing that can help with that is logging.
  prefs: []
  type: TYPE_NORMAL
- en: Structural logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I believe the logging is the silver bullet of debugging, because it works everywhere—on
    tests, on production servers, in cloud infrastructure. Also, you don't have to
    reproduce the activity that produces bugs – you can take the logs of a working
    application and read them to detect problems. Sometimes, you will have bugs that
    you can't reproduce, and logs can help to fix them.
  prefs: []
  type: TYPE_NORMAL
- en: We already studied the basics of logging in [Chapter 3,](751f86d9-59ce-4966-beb8-cd743b521373.xhtml) *Logging
    and Configuring Microservices*. We used the simple `env_logger` and `log` crates,
    but for large applications, it may not be enough, because you will need to collect
    all logs for analyzing, and it's simpler to parse logs from a formal format like
    JSON. There are structural logging crates for this case. Let's explore a tiny
    example of using structural logging with the `slog` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will crate a tiny application that writes logs to a file and to a console.
    Create a new crate and add the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We need `slog` as the main logging crate for the application. The `slog-async`
    crate helps to move log processing to a separate thread. `slog-json` provides
    a logger that writes records in JSON format. `slog-term` provides formats to write
    messages to a Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will import the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: From the main `slog` crate, we will use the `crit`, `debug`, and `error` macros,
    which are an alternative to the logging macro of the `log` crate. `Drain` is the
    main trait that provides logging functionality. Ultimately, we must create a `Drain`
    instance to log something. `Duplicate` is a kind of `Drain` that duplicates records
    to two `Drain` instances. `Level` and `LevelFilter` allow us to filter records
    by desired level.
  prefs: []
  type: TYPE_NORMAL
- en: From the `slog-async` crate, we will use the `Async` type, which is a `Drain`
    that moves records processing to a separate thread. `PlainDecorator`, which is
    imported from the `slog-term` crate, prints logs without any coloring. Also, we
    imported the `CompactFormat` type, which is a `Drain` that writes records in a
    short format.From the `slog-json` crate, we imported the `Json` form of `Drain`
    that writes logs in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the `Drain` trait has a default implementation for `Mutex`
    values that contains a value that has already implemented the `Drain` trait. It
    allows us to wrap any `Drain` with a `Mutex` to make it safe for use in multiple
    threads. The `OpenOptions` type is imported to open a file for writing and truncate
    the contents of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the `main` function with sample logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This function opens a file and creates two `Drain` instances. The first is a `Json`
    wrapped with a `Mutex`, because `Json` is not a thread-safe type. We also wrap
    it with `LevelFilter` to filter messages at a level lower than `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we used `PlainDecorator` to write logs to the `stderr` stream. It
    implements the `Decorator` trait, which can be used as a stream for creating `Drain`
    instances. We wrap it with `CompactFormat` and now we have two `Drain` instances
    that we will combine.
  prefs: []
  type: TYPE_NORMAL
- en: We use `Duplicate` to duplicate records to the two created `Drain` instances,
    but we also wrap it with `Async` to move logs that are processing to a separate
    thread. Now, we can create a `Logger` instance and fill it with basic information
    about the application.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `root` method to create the root logger. This method can also get
    a map of values, which will be added to records. We used the `o!` macro to create
    a map. After this, we added calls of different macros to show you how to use a
    structural logger.
  prefs: []
  type: TYPE_NORMAL
- en: Any logging macro expects some arguments—a reference to a `Logger` instance,
    a message, optional parameters to fill a message, or a key-value map with extra
    parameters that can be extracted later from logs for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The demo application is ready and we can start to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Build this application with `cargo build`, or with the following command, if
    you want to play with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `cargo-watch` tool, but ignore log files, because these will be
    created when the application is run. After the application has started, you will
    the following records in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, no records with the `Debug` level were filtered in the Terminal
    output. As you may remember, we duplicated logging into two `Drain` instances.
    The first writes errors to the `app.log` file, and if you open this file, you
    can see the filtered records that don''t contain records with a `Debug` level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: There are only records with the level above or equal to `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](751f86d9-59ce-4966-beb8-cd743b521373.xhtml), *Logging and Configuring
    Microservice,* in the example with the `env_logger` crate, we used environment
    variables to configure a logger. `slog` also provides this feature with the `slog_envlogger`
    crate.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is an awesome tool that's used to trace every action of a single microservice,
    but if your application consists of multiple microservices, it can be hard to
    understand why some error happened, because it is affected by multiple factors.
    To find and repair this hardest type of bug, there is distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed tracing helps to collect information about related parts of an application
    as a **distributed acyclic graph** (**DAG**). You can use collected information
    to analyze a path of any activity in a distributed application.
  prefs: []
  type: TYPE_NORMAL
- en: There is an open standard—OpenTracing, which is supported by multiple products,
    including Jaeger. The most minimal unit of tracing is called a **span**. Spans
    can have relationships with other spans to construct a report with tracing paths.
    In this section, we'll write a tiny application that will send some spans to a
    Jaeger instance.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Jaeger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need a working Jaeger instance that you can start as a Docker container
    from the official Docker image that contains all of the parts of the application
    in one. It''s even called **jaegertracing/all-in-one**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Open all the necessary ports, and access the web UI of Jaeger at [http://localhost:16686](http://localhost:16686).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can write an application to interact with this instance.
  prefs: []
  type: TYPE_NORMAL
- en: Generating spans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use two crates to make a test example—`rustracing` and `rustracing_jaeger`.
    Create a new crate and add it to the `[dependencies]` section of `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following dependencies to the `main.rs` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`AppSampler` implements the `Sampler` trait that is used to decide whether
    every new trace will be sampled or not. Consider samplers as filters of loggers,
    but smart ones that can limit the amount of traces per second or use other conditions.
    `Tag` is used to set extra data for spans. `Tracer` is the main object that''s
    used for creating spans. The `JaegerCompactReporter` type is used to group spans
    and send them to the Jaeger instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we need a function to sleep the current thread for milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can add the `main` function, and add the first part of the example
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we did a major part of the tracing routine. First, we created
    two `Tracer` instances that will pass all values by `AllSampler`. After this,
    we used `spawn` to create a new thread and created a loop that generated spans.
    You have to remember that the `rustracing` crate uses a `Drop` trait implementation
    to send a span value to a `Reciever` that was also created with the `Tracer::new`
    method call, and we have to drop values (we used the scoping rules of Rust to
    do dropping automatically).
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `Tracer` instance stored in the `tracer1` variable to create a
    span with the `span` method call. It expects a name for the span and created a `StartSpanOptions`
    struct that can be used to configure a future `Span` value. For configuring, we
    can use the `child_of` method to set a parent, or the `follows_from` method to
    set a reference to the previous `Span`. Also, we can set extra information with the
    `tag` method call and provide a key-value pair called `Tag`, just as we did in
    structural logging before. After configuring, we have to call the `start` method
    of the `StartSpanOptions` instance to create a `Span` instance with a set span
    starting time. Using scopes and tracer, we emulated two parts of an application:
    the first that processes a request, and the second that performs a database query
    and generates a response, where the first is a parent of the latter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to use `SpanReciever` instances to collect all dropped `Span`
    values. (They''ve actually been sent to `Reciever`.) Also, we create two `JaegerCompactReporter`
    instances with names and add spans to reports using the `report` method call in
    the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can compile and run this tracing example.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start this example, you can use the `cargo run` command. When the example
    starts, it will continuously produce spans and send them to the running Jaeger
    instance. You will need to wait for a short interval and interrupt the application,
    otherwise it will generate too many spans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the web UI of Jaeger in a browser. Choose `router` in the Service field,
    and click the Find Traces button to find the corresponding spans. You will see
    recent traces, and if you click on one of them, you will see the details of the
    tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec2371cb-427a-44ac-bb8c-8cb950ef4d0f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, distributed tracing registered activities of our application,
    and we can use it as a tool for logging the distributed activities of microservices
    that are included in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed a lot of topics on testing and debugging microservices.
    First, we considered unit and integration tests, and also saw some examples of
    using these in Rust. After this, we explored tools that help us with debugging
    microservices, including curl and Postman, to send requests manually; mitmproxy
    to trace all incoming requests and outgoing responses of a microservice; LLDB
    to explore the running code of a microservice; and Visual Studio Code as a GUI
    frontend for the LLDB Debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we discussed two techniques that used for the largest applications,
    where you can''t simply debug: structural logging and distributed tracing using
    OpenTracing API.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about some techniques with which you can optimize
    Rust microservices.
  prefs: []
  type: TYPE_NORMAL
