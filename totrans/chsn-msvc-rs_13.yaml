- en: Testing and Debugging Rust Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和调试Rust微服务
- en: Microservices, like any other application, can have bugs. You can make a mistake
    when writing new code, or by adding extra features to an application. In this
    chapter, we will explore the available tools to test and debug your microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务，就像任何其他应用程序一样，都可能存在错误。你可能在编写新代码时犯错，或者通过向应用程序添加额外功能来犯错。在本章中，我们将探讨可用于测试和调试你的微服务的可用工具。
- en: We will start by creating unit and integration tests for an application. We
    will also examine the testing capabilities of the `actix` crate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为应用程序创建单元和集成测试。我们还将检查`actix`包的测试能力。
- en: After this, we will study debugging with the LLDB Debugger, and also examine
    logging as a debugging technique, since not every bug can be caught with a traditional
    debugger. Furthermore, if you use a product in production, you can't attach a
    debugger to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将学习使用LLDB调试器进行调试，并检查日志作为调试技术，因为并非每个错误都能用传统的调试器捕获。此外，如果你在生产中使用产品，你不能将其附加到调试器上。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Testing microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务测试
- en: Debugging microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务调试
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the testing examples of this chapter, you need some extra software besides
    Rust compiler (which, of course, you'll need too). You will need to install Docker
    and Docker Compose to bootstrap the application from [Chapter 15](http://Packing%20Servers%20to%20Containers), *Packing
    Servers to Containers*. We will use this application to run integration tests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的测试示例，你除了需要Rust编译器（当然，你也需要）之外，还需要一些额外的软件。你需要安装Docker和Docker Compose来从[第15章](http://Packing%20Servers%20to%20Containers)，“将服务器打包到容器中”启动应用程序。我们将使用这个应用程序来运行集成测试。
- en: You will also need to install the Postman tool, which we will use to test APIs
    manually, along with the LLDB debugger, which we'll learn how to use for debugging
    microservices. Also, Jaeger will need to be installed, but you can also use the
    all-in-one image running in Docker for this. Finally, we will use the OpenTracing
    API for distributed tracing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装Postman工具，我们将使用它手动测试API，以及LLDB调试器，我们将学习如何使用它来调试微服务。此外，还需要安装Jaeger，但你可以使用在Docker中运行的单一镜像来完成这项工作。最后，我们将使用OpenTracing
    API进行分布式跟踪。
- en: 'The examples of this chapter are provided with sources on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter13.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter13)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter13)
- en: Testing microservices
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务测试
- en: Rust is an almost perfect tool for creating reliable applications. The compiler
    is so strict and never misses any potential memory access error or data race,
    but still there are many ways to make a mistake in the code. In other words, Rust
    helps you a lot, but it is not omnipotent.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust是创建可靠应用程序的几乎完美的工具。编译器非常严格，永远不会错过任何潜在的内存访问错误或数据竞争，但仍然有许多方法可以在代码中犯错。换句话说，Rust在很大程度上帮助你，但它并非万能。
- en: Unit testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Microservices can also have bugs, so you have to be armed to handle all possible
    bugs. The first line of defense is unit testing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务也可能存在错误，因此你必须准备好处理所有可能的错误。第一道防线是单元测试。
- en: Unit testing involves using HTTP clients to send an isolated request to a server
    or a request handler. In a unit test, you should check only one function. It's
    necessary to cover the majority of the code that helps to keep the same behavior
    of a function that can be reimplemented or improved with tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试涉及使用HTTP客户端向服务器或请求处理器发送隔离的请求。在单元测试中，你应该只检查一个函数。覆盖大多数有助于保持函数相同行为的代码，该函数可以通过测试重新实现或改进，这是必要的。
- en: Also, you can write a test before writing any piece of code. It's called **Test-Driven
    Development** (**TDD**), but this approach is suitable for projects that have
    a good specification, because if you haven't decided on the solution, you will
    have to rewrite tests multiple times. In other words, TDD is not suitable for
    projects in which bugs are not critical, but where high-speed development is required.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以在编写任何代码之前编写一个测试。这被称为**测试驱动开发**（**TDD**），但这种方法适合具有良好规格的项目，因为如果你还没有决定解决方案，你可能需要多次重写测试。换句话说，TDD不适合错误不是关键，但需要高速开发的项目。
- en: Writing unit tests for traditional crates is simple, but for microservices,
    you have a lot of issues with emulating the environment in which a microservice
    will work in production. To emulate an environment, you can use mocking services
    that create HTTP servers with predefined responses for specified requests. Do
    you remember, in [Chapter 11,](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml) *Involving
    Concurrency with Actors and Actix Crate*, when we created a routing microservice
    that we can't test, because we have to run a lot of microservices manually? In
    this section, we will create a unit test for that very routing microservice.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为传统crate编写单元测试很简单，但对于微服务，你会有很多问题，因为需要在生产环境中模拟微服务的工作环境。为了模拟环境，你可以使用创建具有预定义响应的HTTP服务器的模拟服务。你还记得在[第11章](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml)中，*使用Actix
    Crate和Actors进行并发*时，我们创建了一个无法测试的路由微服务吗？因为我们必须手动运行很多微服务？在本节中，我们将为该路由微服务创建一个单元测试。
- en: Mocking
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: 'Let''s create a `mock` server that emulates responses for requests to three
    paths to a routing microservice: `/signin`, `/signup`, and `/comments`. There
    is the `mockito` crate that provides a server for emulating HTTP responses. We
    will use the example from [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml),
    *Involving Concurrency with Actors and the Actix Crate*. Copy it and add these
    extra dependencies:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个模拟服务器，模拟对路由微服务的三个路径的请求响应：`/signin`、`/signup`和`/comments`。有一个名为`mockito`的crate提供了模拟HTTP响应的服务器。我们将使用[第11章](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml)中的示例，*使用Actix
    Crate和Actors进行并发*。复制它并添加以下额外的依赖项：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need the `mockito` crate to start a server with mocks, and the `reqwest`
    crate to make HTTP requests to our Actix server instance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`mockito` crate来启动带有模拟的服务器，以及`reqwest` crate来向我们的Actix服务器实例发送HTTP请求。
- en: 'Create a `tests` module with the `#[cfg(test)]` attribute that will be compiled
    for testing only, and import the following types that we will use for testing:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有`#[cfg(test)]`属性的`tests`模块，它只编译用于测试，并导入以下我们将用于测试的类型：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We use types of router microservices to prepare requests; namely, `Comment`,
    `UserForm`, and `UserId`. Also, we added the `LinksMap` struct to configure URLs
    to mocks:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用路由微服务的类型来准备请求；即，`Comment`、`UserForm`和`UserId`。此外，我们还添加了`LinksMap`结构体来配置URL到模拟：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add this struct to `State` and use it with handlers to get the URLs of microservices:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将此结构体添加到`State`中，并使用处理程序获取微服务的URL：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Also, we imported the `lazy_static!` macro that we need to initialize a `Mutex`,
    which we will use to check that the Actix Server started once. Rust also has the
    `Once` type, which can also be used, but we need to wait a certain interval before
    letting the services perform requests, and the `is_completed` method of `Once`
    type is unstable. To create mocks, we will use the `mock` function of the `mockito`
    crate and a `Mock` type that represents a handler of a specific request.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还导入了`lazy_static!`宏，它用于初始化一个`Mutex`，我们将使用它来检查Actix服务器是否已启动一次。Rust还有一个`Once`类型，也可以使用，但我们需要等待一定的时间间隔，然后让服务执行请求，而`Once`类型的`is_completed`方法是不稳定的。为了创建模拟，我们将使用`mockito`
    crate的`mock`函数和一个表示特定请求处理器的`Mock`类型。
- en: 'Create a function to add mocks, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个添加模拟的函数，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `add_mock` function expects an HTTP method and path to emulated resource.
    Also, it takes a value returned as a response in JSON format.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_mock`函数期望一个HTTP方法和要模拟的资源路径。它还接受以JSON格式返回的响应值。'
- en: 'We call the `mock` function to create a `Mock` instance and tune it with the
    following methods:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`mock`函数来创建一个`Mock`实例，并使用以下方法对其进行调整：
- en: '`with_status` sets the status code of a response'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with_status`设置响应的状态码'
- en: '`with_header` sets a specific value for a header'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with_header`设置特定头部的值'
- en: '`with_body` sets the body of a response'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with_body`设置响应体'
- en: Finally, we call the `crate` method, which tries to start a `mock` server and
    attach our created `Mock` to it. Now, we can start a router microservice instance
    and prepare all the necessary mocks to emulate other microservices that the router
    expects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`crate`方法，它尝试启动一个模拟服务器并将我们创建的`Mock`附加到它。现在，我们可以启动一个路由微服务实例并准备所有必要的模拟来模拟路由器期望的其他微服务。
- en: Starting a server for testing
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动测试服务器
- en: 'We will start a server instance in a separate thread, because Rust runs tests
    in multiple threads, and we won''t create a server instance with a unique port
    for every test run to show how you can use a shared instance, because integration
    tests often need to reuse the same application instance. Create a shared flag
    that we will use to detect routers that have already started:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个单独的线程中启动服务器实例，因为Rust在多个线程中运行测试，并且我们不会为每次测试运行创建具有唯一端口的服务器实例来展示如何使用共享实例，因为集成测试通常需要重用相同的应用程序实例。创建一个共享标志，我们将使用它来检测已经启动的路由器：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we will use this `Mutex` to create a function to start a server. Look
    at the following `setup` function implementation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个`Mutex`来创建一个启动服务器的函数。看看下面的`setup`函数实现：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding function locks a `Mutex` to get the value of the flag. If it equals
    `false`, we spawn a new thread with a server instance and mocks, and wait 5 seconds
    before we set the flag to `true` and release the `Mutex`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能会锁定一个`Mutex`以获取标志的值。如果它等于`false`，我们将启动一个新的线程，并带有服务器实例和模拟，然后在将标志设置为`true`并释放`Mutex`之前等待5秒钟。
- en: In the spawned thread, we get a URL or `mock` server. It automatically starts
    that server if it wasn't started already. After this, we use the `add_mock` method
    to add all mocks to emulate other microservices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动的线程中，我们获取一个URL或`mock`服务器。如果它还没有启动，它将自动启动该服务器。之后，我们使用`add_mock`方法将所有模拟添加到模拟其他微服务。
- en: The `mockito` crate requires you to have added all the mocks in the same thread
    in which the `mock` server started.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockito` crate要求你在`mock`服务器启动的同一个线程中添加所有模拟。'
- en: Also, we keep all crated mocks in local variables. If any of them are dropped,
    then that mocking handler will be lost. You can also use the `std::mem::forget`
    method to ensure that the mock will be never dropped, but it's more accurate to
    leave the local variable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将所有创建的模拟都保存在局部变量中。如果其中任何一个被丢弃，那么那个模拟处理程序就会丢失。你也可以使用`std::mem::forget`方法来确保模拟永远不会被丢弃，但更准确的做法是保留局部变量。
- en: 'We will employ `LinksMap` using the URL of the `mock` server and paths, both
    of which are concatenated with the following function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`LinksMap`，通过`mock`服务器的URL和路径，这两个都通过以下函数连接：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we called the `start` function, which is actually a modified `main`
    function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用了`start`函数，这实际上是一个修改过的`main`函数：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The difference between this and the `main` function of the router microservice
    of [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *Involving Concurrency
    with Actors and Actix Crate*, is that it expects the `LinksMap` value to add it
    to `State`. Now, we can create methods to perform testing requests to a server
    that resends them to mocks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这与第11章[涉及并发与Actix Crate](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml)中路由器微服务的`main`函数的区别在于，它期望将`LinksMap`值添加到`State`中。现在，我们可以创建方法来对重定向到模拟的服务器进行测试请求。
- en: Making requests
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送请求
- en: 'To make `GET` requests, we will use the `test_get` function, which creates
    a `Client` of the `reqwest` crate, sets a path, executes a `send` request, and
    deserializes the response from JSON:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送`GET`请求，我们将使用`test_get`函数，该函数创建一个`reqwest` crate的`Client`，设置一个路径，执行一个`send`请求，并将响应从JSON反序列化：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you are familiar with the `reqwest` crate, you may ask why we get text values,
    since `Client` has the `json` method that deserializes JSON? If we do that, we
    can't see the original value if we have deserialization issues, but using the
    original text of a response, we can log it for investigation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉`reqwest` crate，你可能想知道为什么我们得到文本值，因为`Client`有`json`方法可以反序列化JSON？如果我们这样做，在反序列化问题时我们无法看到原始值，但使用响应的原始文本，我们可以将其记录下来以供调查。
- en: 'To generate URLs, we use the following function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成URL，我们使用以下函数：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This adds the address of a server to which we bind it, but for large projects,
    it's better to use dynamic addresses, especially if you want to use a fresh server
    instance in every test.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了我们将要绑定到的服务器地址，但对于大型项目，最好使用动态地址，特别是如果你想在每次测试中使用一个新的服务器实例。
- en: 'For `POST` requests, we will use similar method, but we won''t deserialize
    the result because we don''t need it and will check the status of a response only:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`POST`请求，我们将使用类似的方法，但我们不会反序列化结果，因为我们不需要它，并且只会检查响应的状态：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have all the necessary functions to implement unit tests for every handler.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了所有必要的函数来实现每个处理器的单元测试。
- en: Implementing tests
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现测试
- en: 'With the utilities we''ve created so far in this chapter, the unit tests look
    pretty compact. To test the handler of the `/signup` path that expects `UserForm`,
    we will add a `test_signup_with_client` function with the `#[test]` attribute:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在这个章节中创建的实用工具使得单元测试看起来相当紧凑。为了测试期望 `UserForm` 的 `/signup` 路径的处理程序，我们将添加一个带有
    `#[test]` 属性的 `test_signup_with_client` 函数：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we run the `cargo test` command, this function will be called and the `test_post`
    call, in turn, will bootstrap a server with a `mock` server as well.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `cargo test` 命令时，这个函数将被调用，而 `test_post` 调用，反过来，将启动一个带有 `mock` 服务器的服务器。
- en: 'To test a handler of the `/signin` path, we will use the following function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `/signin` 路径的处理程序，我们将使用以下函数：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This test uses the same input values with a `POST` request.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用与 `POST` 请求相同的输入值。
- en: 'To fetch a list of comments, it''s enough to call the `test_get` function with the
    `/comments` path:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取评论列表，只需调用带有 `/comments` 路径的 `test_get` 函数：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we can start these tests to check the router microservice that forwards
    requests to a `mock` server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动这些测试来检查将请求转发到 `mock` 服务器的路由微服务。
- en: Running our tests
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的测试
- en: 'To run the unit test, run Cargo''s `test` command in the folder of this project.
    It will start three tests and you will see, in the Terminal, the output of the
    command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行单元测试，请在本项目文件夹中运行 Cargo 的 `test` 命令。它将启动三个测试，您将在终端中看到命令的输出：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All of the tests have passed, but let''s check what happens if we change something
    in the implementation. Let''s remove a `Mock` for the `/signin` path. The test
    will print that one test has failed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都通过了，但让我们检查一下如果我们更改实现中的某些内容会发生什么。让我们移除 `/signin` 路径的 `Mock`。测试将打印出一个测试失败的信息：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As expected, the `tests::test_signin_with_client` test failed, because it can't
    get a response from the `/signin` request. Unit testing will help you ensure the
    behavior of a handler won't be changed, even if you rewrite the implementation
    from scratch.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`tests::test_signin_with_client` 测试失败了，因为它无法从 `/signin` 请求中获取响应。单元测试可以帮助您确保处理器的行为不会改变，即使您从头开始重写实现。
- en: We covered a microservice with a unit test using predefined methods to simplify
    bootstrapping a server and to send HTTP requests to it. If you want to test complex
    interaction with an application, you should implement integration tests, which
    we will cover now.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用预定义的方法对微服务进行了单元测试，以简化服务器的启动并向其发送 HTTP 请求。如果您想测试与应用程序的复杂交互，您应该实现集成测试，我们现在将介绍。
- en: Integration testing
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Unit testing can't guarantee that the whole application works, because it tests
    only a small piece of implementation. By contrast, integration tests are more
    complex and they help to ensure your whole application works properly. We combined
    some microservices that we created for this book into one application. Let's create
    integration tests to check the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不能保证整个应用程序正常工作，因为它只测试了实现的一小部分。相比之下，集成测试更复杂，并且有助于确保您的整个应用程序正常工作。我们将这本书中创建的一些微服务组合成一个应用程序。让我们创建集成测试来检查应用程序。
- en: Starting an application instance
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动应用程序实例
- en: 'Before we write the first line of a testing code, we have to start an application
    with Docker. It''s complex and you will learn how to make it in [Chapter 15](80b8c3ec-d291-40df-a7a7-b9e9f0a64a99.xhtml), *Packing
    Servers to Containers*, but for now, open the code samples folder of that chapter
    and start a project from the Docker Compose script. However, you will also have
    to prepare an image for building microservices. Enter these two commands into
    a Terminal:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写测试代码的第一行之前，我们必须使用 Docker 启动一个应用程序。这很复杂，您将在第 15 章 [80b8c3ec-d291-40df-a7a7-b9e9f0a64a99.xhtml]
    “将服务器打包到容器中” 中学习如何操作，但到目前为止，请打开该章节的代码示例文件夹，并从 Docker Compose 脚本中启动一个项目。然而，您还必须准备一个用于构建微服务的镜像。在终端中输入以下两个命令：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The project already contains a special Compose file, `docker-compose.test.yml`,
    that opens the ports of the containers to make it possible to connect to them
    from our local Rust application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 项目已经包含一个特殊的 Compose 文件，`docker-compose.test.yml`，它打开容器的端口，以便我们可以从本地的 Rust 应用程序连接到它们。
- en: It takes time to start, but when the application has started, you will see the log
    in a Terminal window. Then, we can write some integration tests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要一些时间来启动，但应用程序启动后，您将在终端窗口中看到日志。然后，我们可以编写一些集成测试。
- en: Dependencies
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'You might be surprised, but for integration testing, we don''t need a lot of
    dependencies, because we will use an HTTP client and the `serde` family of crates
    to serialize requests and deserialize responses:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会感到惊讶，但在集成测试中，我们不需要很多依赖项，因为我们将会使用HTTP客户端和`serde`系列crate来序列化请求和反序列化响应：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, we need the `uuid` crate to generate unique values, and the `cookie` crate
    to support cookies in our HTTP requests, because integration tests have to keep
    the session to make a sequence of meaningful requests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要`uuid`crate来生成唯一值，以及`cookie`crate来支持我们的HTTP请求中的cookies，因为集成测试必须保持会话以发出一系列有意义的请求。
- en: Utils
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: 'Like we did for unit tests, we''ll add some utility function to avoid creating
    HTTP clients for every test. We will use predefined methods to health-check and
    to send `POST` and `GET` requests to microservices included in the application.
    Create a `utils.rs` file and import the necessary types:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对单元测试所做的那样，我们将添加一些实用函数以避免为每个测试创建HTTP客户端。我们将使用预定义的方法来执行健康检查，并发送`POST`和`GET`请求到应用程序中包含的微服务。创建一个`utils.rs`文件并导入必要的类型：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will use a `Client` instance from the `reqwest` crate, just as we did for
    the unit test, but we''ll need to import extra types: `Method` to set different
    HTTP methods exactly; `RedirectPolicy` to control redirects, since the router
    microservice will redirect us to other pages; and `Client`, which will perform
    those redirects, but we want to turn off this behavior. `StatusCode` is used to
    check returned HTTP status codes.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`reqwest`crate中的`Client`实例，就像我们在单元测试中所做的那样，但我们需要导入额外的类型：`Method`用于精确设置不同的HTTP方法；`RedirectPolicy`用于控制重定向，因为路由微服务会重定向我们到其他页面；以及`Client`，它将执行这些重定向，但我们希望关闭这种行为。`StatusCode`用于检查返回的HTTP状态码。
- en: We imported the `COOKIE` and `SET_COOKIE` headers to set the values of those
    headers for requests, and get their values from the responses. But the values
    of those headers are formal and we need to parse them. To simplify this, we will
    use the `Cookie` and `CookieJar` types of the cookie crate, since the `reqwest`
    crate doesn't support cookies now.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`COOKIE`和`SET_COOKIE`头，用于设置这些头的值以供请求使用，并从响应中获取它们的值。但这些头的值是正式的，我们需要解析它们。为了简化这一点，我们将使用cookie
    crate中的`Cookie`和`CookieJar`类型，因为`reqwest`crate目前不支持cookies。
- en: Also, we use the `rand` crate and the imported `Alphanumeric` distribution from
    it to generate unique logins for testing, because we will interact with a working
    application and simply can't restart it now.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用`rand`crate和从中导入的`Alphanumeric`分布来生成唯一的测试登录名，因为我们将与一个工作应用程序交互，现在根本无法重新启动它。
- en: 'Our application contains four microservices with the following addresses, all
    of which are available from the Docker containers of our application:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序包含四个微服务，以下地址，所有这些地址都可以从我们的应用程序的Docker容器中访问：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We declared addresses as constant, so that we have a single place to update
    them if necessary:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将地址声明为常量，这样我们就有了一个单独的地方来更新它们（如果需要的话）：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Also, we need a function to generate random strings that consist of alphanumeric
    characters:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要一个函数来生成由字母数字字符组成的随机字符串：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code uses a random number generator that's initialized for the
    current thread, and an iterator that generates random values, to take 7 characters
    and join them into `String` values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用一个为当前线程初始化的随机数生成器和一个生成随机值的迭代器，取7个字符并将它们连接成`String`值。
- en: 'Since integration tests work with live systems, we need a function to sleep
    the current thread:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集成测试与实时系统一起工作，我们需要一个函数来暂停当前线程：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function is a short alias for the `thread::sleep` call.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是`thread::sleep`调用的简短别名。
- en: But it's not all about utilities—we also need a universal client to send requests
    to all working microservices.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不仅仅是关于工具——我们还需要一个通用客户端来向所有工作的微服务发送请求。
- en: The integration testing client
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试客户端
- en: 'Add the following struct to your `utils.rs` source file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下结构体添加到您的`utils.rs`源文件中：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It has three fields—an HTTP `Client`; a base `url`, which is used to construct
    full URLs with added paths; and a `CookieJar` instance to keep cookie values between
    requests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它有三个字段——一个HTTP `Client`；一个基础`url`，用于使用附加的路径构建完整的URL；以及一个`CookieJar`实例，用于在请求之间保持cookie值。
- en: 'The constructor of this struct takes a URL and builds a `Client` instance with
    redirects disabled:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体的构造函数接受一个URL并构建一个禁用重定向的`Client`实例：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can add shortcuts to create instances of `WebApi` for the specific microservice
    of our application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为应用程序的特定微服务创建`WebApi`实例的快捷方式：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will check that every microservice is alive. To do this, we need a method
    for `WebApi` that sends `GET` requests to a specified path and checks the response:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查每个微服务是否存活。为此，我们需要一个`WebApi`的方法，该方法向指定的路径发送`GET`请求并检查响应：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Every microservice of our application has a special path to get the name of
    microservice, which we will use for health-checking.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的每个微服务都有一个特殊的路径来获取微服务的名称，我们将使用它来进行健康检查。
- en: 'To send requests to microservices, we will use the following function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要向微服务发送请求，我们将使用以下函数：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It's a useful function that sends a request in JSON format and receives a response
    in JSON format, which it deserializes into the necessary native struct. The implementation
    of this method is not crazy. It expects a HTTP method, path, and values that will
    be used as form parameters in a request.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的函数，它以JSON格式发送请求并接收JSON格式的响应，然后将其反序列化为必要的本地结构。这个方法的实现并不疯狂。它期望一个HTTP方法、路径以及将用作请求表单参数的值。
- en: We use a textual response to print values if the microservice returns an HTTP
    status other than `OK`. If a response is successful, we will deserialize the body
    from JSON format to the necessary output type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果微服务返回的不是`OK`的HTTP状态，我们使用文本响应来打印值。如果响应成功，我们将从JSON格式反序列化主体到必要的输出类型。
- en: 'Since the whole application won''t return internal service information to us,
    we need a method that creates a request and checks the status code of a response,
    but also stores cookies to have a chance to sign up and sign in to our application.
    Create the `check_status` method for the `WebApi` struct implementation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个应用程序不会返回内部服务信息给我们，我们需要一个创建请求并检查响应状态码的方法，同时存储cookie以便有机会在我们的应用程序中注册和登录。为`WebApi`结构实现创建`check_status`方法：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding implementation also uses values to make a request with a form,
    but it also prepares cookies and sends them with the `Cookie`  header after the
    function expects a response from a server. If a response contains a `SetCookie`
    header, we use it to update our `CookieJar`. With such simple manipulations, we
    take a method that can keep the connection session.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现还使用值以表单的形式发送请求，但它还准备cookie并在函数期望从服务器收到响应后，通过`Cookie`头将它们发送出去。如果响应包含`SetCookie`头，我们使用它来更新我们的`CookieJar`。通过这样的简单操作，我们使一个可以保持连接会话的方法。
- en: Types
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'Before we start implementing tests, we need to add some types that we need
    to interact with microservices. Create a `types.rs` source file with types:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现测试之前，我们需要添加一些我们需要与微服务交互的类型。创建一个`types.rs`源文件并定义类型：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, add a `UserId` struct that will be used to parse raw responses from the
    `users` microservices (yes, we will also test it directly):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个`UserId`结构体，它将被用来解析来自`users`微服务的原始响应（是的，我们也将直接测试它）：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also, add a `Comment` struct that we will use to post new comments to our content
    microservice:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加一个`Comment`结构体，我们将使用它来向我们的内容微服务发布新的评论：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we can write tests for every microservice separately, and after that, create
    a test for complex interaction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为每个微服务单独编写测试，然后创建一个测试复杂交互的测试。
- en: Users
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户
- en: 'We will start the `users` microservice test coverage. Create a `users.rs` file
    and import the created modules into it with the necessary types:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始`users`微服务的测试覆盖率。创建一个`users.rs`文件并将创建的模块导入其中，使用必要的类型：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At first, we have to check that the microservice is alive. Add the `users_healthcheck`
    method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须检查微服务是否存活。添加`users_healthcheck`方法：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It creates an instance of the `WebApi` struct using the `users` method that
    already configures it for interaction with the users microservice. We use the
    `healthcheck` method to check the root path of a service that has to return the
    `"Users Microservice"` string.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`users`方法创建`WebApi`结构体的实例，该方法已经配置好了与用户微服务的交互。我们使用`healthcheck`方法检查必须返回`"Users
    Microservice"`字符串的服务根路径。
- en: 'The main purpose of the `users` microservice is a new users'' registration,
    and the authorization of registered users. Create a `check_signup_and_signin`
    function that will generate a new user, register it by sending a request to the `/signup`
    path, and then try to log in using the `/signin` path:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`users`微服务的主要目的是新用户的注册以及已注册用户的授权。创建一个`check_signup_and_signin`函数，该函数将生成一个新用户，通过向`/signup`路径发送请求来注册它，然后尝试使用`/signin`路径进行登录：'
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We created a new `WebApi` instance that has targeted to our `users` microservice.
    The values of the `username` and `password` are generated by the `rand_str` function
    call of the `utils` module that we created earlier. After this, we prepare parameters
    to emulate sending an HTML form to a server with a `POST` request. The first request
    registers a new user; the second request tries to authorize it with the same form
    parameters.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`WebApi`实例，该实例针对我们的`users`微服务。`username`和`password`的值是由我们之前创建的`utils`模块中的`rand_str`函数调用生成的。之后，我们准备参数来模拟向服务器发送带有`POST`请求的HTML表单。第一个请求注册了一个新用户；第二个请求尝试使用相同的表单参数进行授权。
- en: Since the users microservice is used internally by the router microservice,
    it returns a raw `UserId` struct. We will parse it, but won't use it, because
    we have already checked that the microservice works, as it won't return users'
    IDs for bad credentials.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户微服务被路由器微服务内部使用，它返回一个原始的`UserId`结构体。我们将解析它，但不会使用它，因为我们已经检查了微服务是否正常工作，因为它不会为无效凭据返回用户的ID。
- en: Content
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容
- en: 'The next microservice we need to test is a content microservice that allows
    users to post comments. Create a `content.rs` file and import the `types` and
    `utils` modules with the necessary types:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要测试的下一个微服务是一个允许用户发布评论的内容微服务。创建一个`content.rs`文件，并使用必要的类型导入`types`和`utils`模块：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also will check that the service is available in the `content_healthcheck`
    test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`content_healthcheck`测试中检查该服务是否可用：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This service is necessary for users to be able to add a new comment, and is
    loose-coupled (it doesn''t need to check that the user exists, because it is protected
    from non-existent users by router microservices). We will generate a new ID of
    the user and send a request to post a new comment:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务对于用户能够添加新评论是必要的，并且是松散耦合的（它不需要检查用户是否存在，因为它由路由器微服务保护，免受不存在用户的干扰）。我们将生成一个新的用户ID并发送一个请求来发布一条新评论：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We prepared a form to create a new comment and sent a `POST` request to the
    `/new_comment` path. After that, we take a list of comments and check that there
    is a comment with generated text in a list. This means that the comment was added
    and that the content microservice works properly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备了一个创建新评论的表单，并向`/new_comment`路径发送了一个`POST`请求。之后，我们取出一组评论并检查列表中是否存在一个包含生成文本的评论。这意味着评论已被添加，并且内容微服务运行正常。
- en: Mailer
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮件发送器
- en: 'Our application also has a mailer microservice that sends notifications to
    users. It needs the `utils` module for testing only:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序还有一个邮件发送器微服务，该服务向用户发送通知。它只需要`utils`模块进行测试：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Put the preceding code into a new `mailer.rs` file and add a `healthcheck`
    to test that a microservice instance is alive:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码放入一个新的`mailer.rs`文件，并添加一个`healthcheck`来测试微服务实例是否存活：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The Mailer microservice also doesn''t need to know users to notify them. It
    only requires an email address and some content. This microservice will send confirmation
    codes to a user, so let''s simulate this behavior in our `send_mail` test:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件发送器微服务也不需要知道用户来通知他们。它只需要一个电子邮件地址和一些内容。这个微服务将向用户发送确认码，所以让我们在我们的`send_mail`测试中模拟这种行为：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We created a `WebApi` instance with the `mailer` function call to target a client
    to the Mailer microservice. After that, we generated a new email and code, and
    put them into a form. The microservice returns a Boolean value, indicating that
    the email was sent. We use it with the `asser!` macro to check that it worked
    correctly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`mailer`函数调用创建了一个`WebApi`实例，以将客户端指向邮件发送器微服务。之后，我们生成了一个新的电子邮件和代码，并将它们放入一个表单中。微服务返回一个布尔值，表示电子邮件已发送。我们使用`asser!`宏来检查它是否正确工作。
- en: We have covered all of the microservices of the application with tests, and
    now we can add a full integration test that checks a complex interaction with
    the application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用测试覆盖了应用程序的所有微服务，现在我们可以添加一个完整的集成测试，以检查与应用程序的复杂交互。
- en: Router
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器
- en: 'Create a `router.rs` file and add the following modules and types:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`router.rs`文件并添加以下模块和类型：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since the router microservice also serves static files by the root path that
    we used for the other microservice, to check that they are alive, we will use
    a special `/healthcheck` path that returns the name of that microservice:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由器微服务也通过我们用于其他微服务的根路径提供静态文件，为了检查它们是否存活，我们将使用一个特殊的`/healthcheck`路径，该路径返回该微服务的名称：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The complete test is implemented in the `check_router_full` test. Look at the
    following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的测试是在`check_router_full`测试中实现的。查看以下代码：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It creates a new `WebApi` instance that's targeted at the router microservice.
    After this, it creates random credentials for a user and calls the router's method
    in `/api` scope. But in this case, we use the `check_status` method, because the
    router microservice creates and keeps session IDs internally and returns cookies
    to identify us.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个针对路由微服务的 `WebApi` 实例。之后，它为用户创建随机凭据并在 `/api` 范围内调用路由的方法。但在这个案例中，我们使用 `check_status`
    方法，因为路由微服务内部创建并保持会话 ID，并返回 cookie 来识别我们。
- en: We sent requests to `/api/signup` and `/api/signin` to register a user account
    and to authorize it. After this, we called the `/api/new_comment` method of the
    application API to post a new comment by user of the current session. Finally,
    we check in the open `/api/comments` endpoint that our comment exits.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `/api/signup` 和 `/api/signin` 发送请求以注册用户账户并对其进行授权。之后，我们调用应用程序 API 的 `/api/new_comment`
    方法，通过当前会话的用户发布一条新评论。最后，我们在公开的 `/api/comments` 端点检查我们的评论是否存在。
- en: We covered the basic functionality of applications with this integration test,
    but for large applications, you can also check records in databases, cached values,
    and uploaded files to ensure that the application works as you expected. If your
    microservice works incorrectly and you can't find a reason, you can try to debug
    it with the instruments that we will learn about in the next section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个集成测试覆盖了应用程序的基本功能，但对于大型应用程序，你也可以检查数据库中的记录、缓存的值和上传的文件，以确保应用程序按预期工作。如果你的微服务工作不正确，并且你找不到原因，你可以尝试使用我们在下一节中将要学习的工具来调试它。
- en: Debugging microservices
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试微服务
- en: 'If your program does go wrong, you need debugging tools to fix that, which
    we will explore in this section. Debugging not only means interactive debugging
    using a debugger—a special tool that helps you to execute program step by step—you
    can also use logging to trace all activities of the code. To understand the cause
    of the error, you can use the following tools:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序出现错误，你需要调试工具来修复它，我们将在本节中探讨。调试不仅意味着使用调试器进行交互式调试——这是一个特殊的工具，可以帮助你逐步执行程序——你还可以使用日志来跟踪代码的所有活动。为了了解错误的起因，你可以使用以下工具：
- en: '**curl**: a command-line tool that we already used to send HTTP requests'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**curl**：一个我们已使用的用于发送 HTTP 请求的命令行工具'
- en: '**Postman:** a GUI tool for testing REST APIs'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Postman**：一个用于测试 REST API 的图形界面工具'
- en: '**mitmproxy: ** a proxy to trace all requests passing through it'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mitmproxy**：一个用于跟踪通过它的所有请求的代理'
- en: '**LLDB:** a traditional command-line debugger'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LLDB**：一个传统的命令行调试器'
- en: '**VS Code:** an editor with good LLDB integration'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VS Code**：一个具有良好 LLDB 集成的编辑器'
- en: Let's explore all of them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索所有这些。
- en: curl
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: curl
- en: 'The most commonly used tool to perform HTTP requests is `curl`. It''s a command-line
    tool with a boatload of parameters. Some of the most useful ones are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 HTTP 请求最常用的工具是 `curl`。它是一个具有大量参数的命令行工具。其中一些最有用的如下：
- en: '`--request <METHOD>` (or `-X`) sets the HTTP method to use'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--request <METHOD>`（或 `-X`）设置要使用的 HTTP 方法'
- en: '`--header "Header: Value"` (or -`H`) sets an extra header to the request'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--header "Header: Value"`（或 -`H`）为请求设置一个额外的头信息'
- en: '`--data <data>` (of `-d`) sets a body to a request, and uses `@filename` as
    a data value to attach the contents of a file'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--data <data>`（或 `-d`）设置请求的主体，并使用 `@filename` 作为数据值来附加文件内容'
- en: '`--form "field=value"` (or `-F`) sets a field of a form'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--form "field=value"`（或 `-F`）设置表单的一个字段'
- en: '`--cookie <file>` (or `-b`) sets a file with cookies to send'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cookie <file>`（或 `-b`）设置一个包含 cookie 的文件以发送'
- en: '`--cookie-jar <file>` (or `-c`) sets a file with cookies to store'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cookie-jar <file>`（或 `-c`）设置一个包含 cookie 的文件以存储'
- en: 'For example, if you want to send a request with a JSON file, use the following
    command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想发送一个带有 JSON 文件的请求，请使用以下命令：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Or, to send a form, use the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要发送表单，请使用以下命令：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you want to keep cookies between calls, use the same file to read and write
    cookie values with the following code: `-b session.file -c session.file`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在调用之间保持 cookie，请使用以下代码使用相同的文件读取和写入 cookie 值：`-b session.file -c session.file`。
- en: If you prefer to use GUI tools, you can consider using Postman.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用图形界面工具，你可以考虑使用 Postman。
- en: Postman
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Postman
- en: 'Postman is a popular extension for browsers that is also available as a desktop
    application. You can get it from here: [https://www.getpostman.com/](https://www.getpostman.com/).
    The coolest features of Postman include that you can group requests and use configurable
    variables in requests.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是一个流行的浏览器扩展，它也作为桌面应用程序提供。你可以从这里获取它：[https://www.getpostman.com/](https://www.getpostman.com/)。Postman
    最酷的功能之一是你可以分组请求并在请求中使用可配置的变量。
- en: 'For example, let''s send a sign-in request to our application that we started
    with Docker Compose. Install Postman and create a new workspace called **Rust
    Microservices***.* Enter the URL of an application, set the method to `POST`,
    and add the body as `x-www-form-unlencoded`, with two parameters, `email` and
    `password` (the user has to have been created with */signup* before). Click the Send
    button:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向使用 Docker Compose 启动的应用程序发送一个登录请求。安装 Postman 并创建一个名为 **Rust Microservices**
    的新工作区。输入应用程序的 URL，将方法设置为 `POST`，并将正文设置为 `x-www-form-unlencoded`，包含两个参数，`email`
    和 `password`（用户必须在使用 */signup* 之前创建）。点击发送按钮：
- en: '![](img/55cab771-6424-4a77-a030-58fee59d9829.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55cab771-6424-4a77-a030-58fee59d9829.png)'
- en: As you can see, the microservices returned a response with cookies, which contain
    an `auth-example` named value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，微服务返回了一个包含名为 `auth-example` 的值的 cookie 的响应。
- en: But what about if we want to use a browser to perform all activities, but explore
    sent request and responses later? We can start a tracing proxy. Let's do it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想使用浏览器执行所有活动，但之后探索发送的请求和响应怎么办？我们可以启动一个跟踪代理。让我们试试。
- en: mitmproxy
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mitmproxy
- en: 'mitmproxy is a good proxy that logs all request and responses, and can work
    as a transparent proxy, as a SOCKS5 proxy, or as a reverse proxy. This tool is
    useful when you want to interact with the running application with a browser,
    but want to record all request and responses of the interaction session. You can
    get this tool from here: [https://mitmproxy.org/](https://mitmproxy.org/).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: mitmproxy 是一个优秀的代理工具，它可以记录所有请求和响应，并且可以作为透明代理、SOCKS5 代理或反向代理工作。当你想通过浏览器与运行中的应用程序交互，但又想记录交互会话的所有请求和响应时，这个工具非常有用。你可以从这里获取这个工具：[https://mitmproxy.org/](https://mitmproxy.org/).
- en: 'Install a proxy and start it by forwarding it to the server''s ports:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 安装一个代理并通过转发到服务器的端口启动它：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you may already know by talking parameters, we used reverse-proxy mode. It
    used the `7777` port to provide access to the mitmproxy UI and port `7780` to
    connect to our application through proxy. In other words, the proxy redirects
    all requests from port `7780` to port `7000` of our application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经通过谈论参数所知，我们使用了反向代理模式。它使用 `7777` 端口提供对 mitmproxy UI 的访问，并使用端口 `7780` 通过代理连接到我们的应用程序。换句话说，代理将所有来自端口
    `7780` 的请求重定向到我们应用程序的 `7000` 端口。
- en: 'Open `127.0.0.1:7777` in a browser, and `127.0.0.1:7780` in a separate tab,
    and try to interact with the application. The mitmproxy web app will show you
    a flow of request and the responses the browser made:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `127.0.0.1:7777`，并在单独的标签页中打开 `127.0.0.1:7780`，然后尝试与应用程序交互。mitmproxy
    网页应用将显示浏览器发出的请求流和响应：
- en: '![](img/39e16a9a-812e-4c0b-8623-d15309aa7c43.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39e16a9a-812e-4c0b-8623-d15309aa7c43.png)'
- en: Like with Postman, we also can explore the headers of the `/signin` response,
    and see the cookie header with the `auth-example` value set.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Postman 一样，我们也可以探索 `/signin` 响应的头部，并查看设置了 `auth-example` 值的 cookie 头部。
- en: Sometimes, you might see incorrect behavior in your application, but can't find
    a bug in the code. For these cases, you may consider trying debuggers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能会在应用程序中看到不正确的行为，但找不到代码中的错误。对于这些情况，您可能需要考虑尝试调试器。
- en: LLDB
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLDB
- en: Rust has good support for two debuggers—GDB and LLDB. We will try the second
    here. LLDB is a modern command-line debugger. It's a part of the LLVM project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 对两个调试器——GDB 和 LLDB——有很好的支持。我们在这里尝试第二个。LLDB 是一个现代的命令行调试器。它是 LLVM 项目的组成部分。
- en: 'Let''s try to look inside our working router microservice. Move to the directory
    with the microservice and compile it with the `cargo build` command. However,
    you have to be sure you don''t set the `--release` flag, because it removes all
    debugging information. If you don''t use cargo and want to add debugging information
    directly using `rustc`, add the `-g -C debuginfo=2` arguments to keep debugging
    symbols in the output file. After the building is finished, use a command to start
    a debugger with scripts to support the Rust programming language:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试查看我们正在工作的路由微服务内部。移动到微服务的目录，并使用 `cargo build` 命令编译它。然而，你必须确保你没有设置 `--release`
    标志，因为它会删除所有调试信息。如果你不使用 cargo，并想直接使用 `rustc` 添加调试信息，请添加 `-g -C debuginfo=2` 参数以保留输出文件中的调试符号。构建完成后，使用命令启动一个支持
    Rust 编程语言的调试器：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This command is already installed if you used the `rustup` installation tool
    to install Rust. You will have also installed LLDB debugger on your machine. When
    the debugger starts, it will print something like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用了 `rustup` 安装工具安装 Rust，则此命令已经安装。您还将安装 LLDB 调试器到您的机器上。当调试器启动时，它将打印类似以下内容：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It will prompt for your input.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它将提示您输入。
- en: 'Let''s set a breakpoint to the `comments` handler. You can do that with the
    following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置 `comments` 处理器的断点。您可以使用以下命令完成：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It will print that your breakpoint was set:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印出您已设置断点的信息：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can start the microservice with this command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用此命令启动微服务：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It will inform you that the process has launched:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 它会通知您进程已启动：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, if you try to open the `http://localhost:8080/comments` URL in a browser,
    then the debugger will interrupt the execution of the handler in the breakpoint
    you set, and the debugger will show you the position of the line of code where
    it has interrupted:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在浏览器中尝试打开 `http://localhost:8080/comments` URL，那么调试器将中断您设置的断点处的处理器执行，调试器将显示它中断的代码行位置：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At this point, you can explore the running microservices. For example, you
    can get to know which alive threads exists with the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以探索正在运行的微服务。例如，您可以使用以下命令了解哪些活动线程存在：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It will show you the main thread and arbiter threads of actix:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 它会显示 actix 的主线程和仲裁线程：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To see the variables that are available for the current context, you can use the
    `frame variable` command. To move execution to the next line of code, use the
    `next` command. To continue execution, use the `continue` command.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前上下文中可用的变量，您可以使用 `frame variable` 命令。要将执行移动到下一行代码，使用 `next` 命令。要继续执行，使用
    `continue` 命令。
- en: Using this tool, you can go through buggy handlers step by step and find the
    reason for the problem. Many developers prefer GUI debuggers and we'll also try
    one.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个工具，您可以逐步通过有问题的处理器并找到问题的原因。许多开发者更喜欢 GUI 调试器，我们也会尝试一个。
- en: Visual Studio Code
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Visual Studio Code is a convenient editor for developers with a lot of extensions,
    including for the Rust language and the LLDB debugger support. Let's try to use
    it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 是一个方便的开发者编辑器，拥有许多扩展，包括对 Rust 语言和 LLDB 调试器的支持。让我们尝试使用它。
- en: 'First, you have to download and install Visual Studio Code from here: [https://code.visualstudio.com/](https://code.visualstudio.com/).
    After this, you need to install two extensions—`rust-lang.rust` and `vadimcn.vscode-lldb`.
    The first adds Rust support while the second integrates VS Code with LLDB.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须从这里下载并安装 Visual Studio Code：[https://code.visualstudio.com/](https://code.visualstudio.com/)。之后，您需要安装两个扩展——`rust-lang.rust`
    和 `vadimcn.vscode-lldb`。第一个扩展添加 Rust 支持，而第二个将 VS Code 与 LLDB 集成。
- en: The integration with Rust is based on the **Rust Language Server** (**RLS**)
    project that, which provides information about Rust code for IDEs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Rust 的集成基于 **Rust 语言服务器**（**RLS**）项目，该项目为 IDE 提供有关 Rust 代码的信息。
- en: Open the router microservice project with *File > Add Folder To A Workspace...*
    and choose the folder with a project. When it's open, set a breakpoint—set a cursor
    to the desired line and choose *Debug > Toggle Breakpoint* command. Now, we can
    start debugging with the *Debug | Start Debugging* command. On the first run,
    it takes some time to prepare LLDB, but when debugger starts, it prints some information
    to the *Output* tab.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *文件 > 将文件夹添加到工作区...* 打开路由微服务项目，并选择包含项目的文件夹。当它打开时，设置一个断点——将光标移动到所需的行并选择 *调试
    > 切换断点* 命令。现在，我们可以使用 *调试 | 开始调试* 命令开始调试。在第一次运行时，需要一些时间来准备 LLDB，但调试器启动时，会在 *输出*
    选项卡中打印一些信息。
- en: 'Open a browser and try to open the `http://localhost:8080/comments` URL that
    activates the breakpoint of our `comments` handler:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并尝试打开激活我们 `comments` 处理器断点的 `http://localhost:8080/comments` URL：
- en: '![](img/757b550d-b32b-46d2-be75-9ff8c5a62197.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/757b550d-b32b-46d2-be75-9ff8c5a62197.png)'
- en: Use the bar at the top to move the execution pointer to the next line. With
    a GUI debugger, you can explore variables and the call stack. It's simple and
    useful. But not every case can be fixed with debugger, because there's types of
    bugs (called **Heisenbugs**) that disappear at the moment of debugging or studying
    them. The only thing that can help with that is logging.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用顶部的栏移动执行指针到下一行。使用 GUI 调试器，您可以探索变量和调用栈。它简单且实用。但并非所有情况都可以通过调试器修复，因为存在一些类型的错误（称为
    **海森堡错误**），在调试或研究它们时会消失。唯一能帮助这种情况的是日志。
- en: Structural logging
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化日志
- en: I believe the logging is the silver bullet of debugging, because it works everywhere—on
    tests, on production servers, in cloud infrastructure. Also, you don't have to
    reproduce the activity that produces bugs – you can take the logs of a working
    application and read them to detect problems. Sometimes, you will have bugs that
    you can't reproduce, and logs can help to fix them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为日志是调试的银弹，因为它无处不在——在测试中、在生产服务器上、在云基础设施中。此外，您不必重现产生错误的操作——您可以直接读取工作应用程序的日志来检测问题。有时，您会遇到无法重现的错误，日志可以帮助修复它们。
- en: We already studied the basics of logging in [Chapter 3,](751f86d9-59ce-4966-beb8-cd743b521373.xhtml) *Logging
    and Configuring Microservices*. We used the simple `env_logger` and `log` crates,
    but for large applications, it may not be enough, because you will need to collect
    all logs for analyzing, and it's simpler to parse logs from a formal format like
    JSON. There are structural logging crates for this case. Let's explore a tiny
    example of using structural logging with the `slog` crate.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第3章，](751f86d9-59ce-4966-beb8-cd743b521373.xhtml) *日志和配置微服务*中学习了日志的基本知识。我们使用了简单的
    `env_logger` 和 `log` crate，但对于大型应用程序来说，可能还不够，因为您需要收集所有日志进行分析，并且从像 JSON 这样的正式格式解析日志更简单。为此存在结构化日志
    crate。让我们通过 `slog` crate 探索使用结构化日志的一个微小示例。
- en: Example
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'We will crate a tiny application that writes logs to a file and to a console.
    Create a new crate and add the following dependencies:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个微小的应用程序，该程序将日志写入文件和控制台。创建一个新的crate并添加以下依赖项：
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We need `slog` as the main logging crate for the application. The `slog-async`
    crate helps to move log processing to a separate thread. `slog-json` provides
    a logger that writes records in JSON format. `slog-term` provides formats to write
    messages to a Terminal.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `slog` 作为应用程序的主要日志 crate。`slog-async` crate 有助于将日志处理移动到单独的线程。`slog-json`
    提供了一个以 JSON 格式写入记录的日志记录器。`slog-term` 提供了将消息写入终端的格式。
- en: 'We will import the following types:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入以下类型：
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: From the main `slog` crate, we will use the `crit`, `debug`, and `error` macros,
    which are an alternative to the logging macro of the `log` crate. `Drain` is the
    main trait that provides logging functionality. Ultimately, we must create a `Drain`
    instance to log something. `Duplicate` is a kind of `Drain` that duplicates records
    to two `Drain` instances. `Level` and `LevelFilter` allow us to filter records
    by desired level.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从主 `slog` crate 中，我们将使用 `crit`、`debug` 和 `error` 宏，这些宏是 `log` crate 中日志宏的替代品。`Drain`
    是提供日志功能的主要 trait。最终，我们必须创建一个 `Drain` 实例来记录某些内容。`Duplicate` 是一种将记录复制到两个 `Drain`
    实例的 `Drain`。`Level` 和 `LevelFilter` 允许我们根据所需的级别过滤记录。
- en: From the `slog-async` crate, we will use the `Async` type, which is a `Drain`
    that moves records processing to a separate thread. `PlainDecorator`, which is
    imported from the `slog-term` crate, prints logs without any coloring. Also, we
    imported the `CompactFormat` type, which is a `Drain` that writes records in a
    short format.From the `slog-json` crate, we imported the `Json` form of `Drain`
    that writes logs in JSON format.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `slog-async` crate 中，我们将使用 `Async` 类型，它是一个将记录处理移动到单独线程的 `Drain`。从 `slog-term`
    crate 导入的 `PlainDecorator` 打印日志而不进行任何着色。我们还导入了 `CompactFormat` 类型，它是一个将记录以短格式写入的
    `Drain`。从 `slog-json` crate 中，我们导入了 `Json` 格式的 `Drain`，它以 JSON 格式写入日志。
- en: Please note that the `Drain` trait has a default implementation for `Mutex`
    values that contains a value that has already implemented the `Drain` trait. It
    allows us to wrap any `Drain` with a `Mutex` to make it safe for use in multiple
    threads. The `OpenOptions` type is imported to open a file for writing and truncate
    the contents of it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Drain` trait 为包含已实现 `Drain` trait 的值的 `Mutex` 类型的值提供了一个默认实现。这允许我们将任何 `Drain`
    包装在 `Mutex` 中，使其在多线程中使用时更安全。`OpenOptions` 类型被导入以打开一个文件进行写入并截断其内容。
- en: 'Now, we can add the `main` function with sample logging:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加带有示例日志的 `main` 函数：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This function opens a file and creates two `Drain` instances. The first is a `Json`
    wrapped with a `Mutex`, because `Json` is not a thread-safe type. We also wrap
    it with `LevelFilter` to filter messages at a level lower than `Error`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数打开一个文件并创建两个 `Drain` 实例。第一个是一个用 `Mutex` 包装的 `Json`，因为 `Json` 不是一个线程安全的类型。我们还用
    `LevelFilter` 包装它，以过滤低于 `Error` 级别的消息。
- en: After this, we used `PlainDecorator` to write logs to the `stderr` stream. It
    implements the `Decorator` trait, which can be used as a stream for creating `Drain`
    instances. We wrap it with `CompactFormat` and now we have two `Drain` instances
    that we will combine.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`PlainDecorator`将日志写入`stderr`流。它实现了`Decorator`特质，这可以用作创建`Drain`实例的流。我们用`CompactFormat`包装它，现在我们有两个`Drain`实例，我们将它们组合起来。
- en: We use `Duplicate` to duplicate records to the two created `Drain` instances,
    but we also wrap it with `Async` to move logs that are processing to a separate
    thread. Now, we can create a `Logger` instance and fill it with basic information
    about the application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Duplicate`将记录复制到两个创建的`Drain`实例，但我们还用`Async`包装它，以便将正在处理的日志移动到单独的线程。现在，我们可以创建一个`Logger`实例并填充它关于应用程序的基本信息。
- en: We use the `root` method to create the root logger. This method can also get
    a map of values, which will be added to records. We used the `o!` macro to create
    a map. After this, we added calls of different macros to show you how to use a
    structural logger.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`root`方法创建根日志记录器。此方法还可以获取一个值映射，这些值将被添加到记录中。我们使用了`o!`宏来创建一个映射。之后，我们添加了不同宏的调用，以展示如何使用结构化日志记录器。
- en: Any logging macro expects some arguments—a reference to a `Logger` instance,
    a message, optional parameters to fill a message, or a key-value map with extra
    parameters that can be extracted later from logs for analysis.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 任何日志宏都期望一些参数——一个指向`Logger`实例的引用、一条消息、可选的参数来填充消息，或者一个键值映射，其中包含可以稍后从日志中提取的额外参数。
- en: The demo application is ready and we can start to test it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 演示应用程序已经准备好了，我们可以开始测试它。
- en: Building and testing
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和测试
- en: 'Build this application with `cargo build`, or with the following command, if
    you want to play with the code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cargo build`构建此应用程序，或者如果你想玩代码，可以使用以下命令：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We use the `cargo-watch` tool, but ignore log files, because these will be
    created when the application is run. After the application has started, you will
    the following records in the Terminal:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`cargo-watch`工具，但忽略日志文件，因为这些将在应用程序运行时创建。应用程序启动后，你将在终端看到以下记录：
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As you can see, no records with the `Debug` level were filtered in the Terminal
    output. As you may remember, we duplicated logging into two `Drain` instances.
    The first writes errors to the `app.log` file, and if you open this file, you
    can see the filtered records that don''t contain records with a `Debug` level:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在终端输出中没有过滤掉任何带有`Debug`级别的记录。正如你可能记得的，我们将日志复制到两个`Drain`实例。第一个将错误写入`app.log`文件，如果你打开这个文件，你可以看到不包含带有`Debug`级别的记录的过滤记录：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There are only records with the level above or equal to `Error`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有级别高于或等于`Error`的记录。
- en: In [Chapter 3](751f86d9-59ce-4966-beb8-cd743b521373.xhtml), *Logging and Configuring
    Microservice,* in the example with the `env_logger` crate, we used environment
    variables to configure a logger. `slog` also provides this feature with the `slog_envlogger`
    crate.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](751f86d9-59ce-4966-beb8-cd743b521373.xhtml)，“日志和配置微服务”，在`env_logger`
    crate的示例中，我们使用了环境变量来配置日志记录器。`slog`也通过`slog_envlogger` crate提供了这个功能。
- en: Logging is an awesome tool that's used to trace every action of a single microservice,
    but if your application consists of multiple microservices, it can be hard to
    understand why some error happened, because it is affected by multiple factors.
    To find and repair this hardest type of bug, there is distributed tracing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是一个强大的工具，用于追踪单个微服务的每一个动作，但如果你的应用程序由多个微服务组成，理解某些错误发生的原因可能很困难，因为它是受多个因素影响的。为了找到并修复这种最困难的类型的问题，存在分布式追踪。
- en: Distributed tracing
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式追踪
- en: Distributed tracing helps to collect information about related parts of an application
    as a **distributed acyclic graph** (**DAG**). You can use collected information
    to analyze a path of any activity in a distributed application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式追踪有助于收集关于应用程序相关部分的**分布式无环图**（DAG）信息。你可以使用收集到的信息来分析分布式应用程序中任何活动的路径。
- en: There is an open standard—OpenTracing, which is supported by multiple products,
    including Jaeger. The most minimal unit of tracing is called a **span**. Spans
    can have relationships with other spans to construct a report with tracing paths.
    In this section, we'll write a tiny application that will send some spans to a
    Jaeger instance.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个开放标准——OpenTracing，它被多个产品支持，包括Jaeger。追踪的最小单元被称为**span**。Spans可以与其他span建立关系，以构建带有追踪路径的报告。在本节中，我们将编写一个小应用程序，将一些span发送到Jaeger实例。
- en: Starting Jaeger
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动Jaeger
- en: 'First, we need a working Jaeger instance that you can start as a Docker container
    from the official Docker image that contains all of the parts of the application
    in one. It''s even called **jaegertracing/all-in-one**:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Open all the necessary ports, and access the web UI of Jaeger at [http://localhost:16686](http://localhost:16686).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can write an application to interact with this instance.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Generating spans
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use two crates to make a test example—`rustracing` and `rustracing_jaeger`.
    Create a new crate and add it to the `[dependencies]` section of `Cargo.toml`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add the following dependencies to the `main.rs` source file:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`AppSampler` implements the `Sampler` trait that is used to decide whether
    every new trace will be sampled or not. Consider samplers as filters of loggers,
    but smart ones that can limit the amount of traces per second or use other conditions.
    `Tag` is used to set extra data for spans. `Tracer` is the main object that''s
    used for creating spans. The `JaegerCompactReporter` type is used to group spans
    and send them to the Jaeger instance.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we need a function to sleep the current thread for milliseconds:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, you can add the `main` function, and add the first part of the example
    to it:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this code, we did a major part of the tracing routine. First, we created
    two `Tracer` instances that will pass all values by `AllSampler`. After this,
    we used `spawn` to create a new thread and created a loop that generated spans.
    You have to remember that the `rustracing` crate uses a `Drop` trait implementation
    to send a span value to a `Reciever` that was also created with the `Tracer::new`
    method call, and we have to drop values (we used the scoping rules of Rust to
    do dropping automatically).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `Tracer` instance stored in the `tracer1` variable to create a
    span with the `span` method call. It expects a name for the span and created a `StartSpanOptions`
    struct that can be used to configure a future `Span` value. For configuring, we
    can use the `child_of` method to set a parent, or the `follows_from` method to
    set a reference to the previous `Span`. Also, we can set extra information with the
    `tag` method call and provide a key-value pair called `Tag`, just as we did in
    structural logging before. After configuring, we have to call the `start` method
    of the `StartSpanOptions` instance to create a `Span` instance with a set span
    starting time. Using scopes and tracer, we emulated two parts of an application:
    the first that processes a request, and the second that performs a database query
    and generates a response, where the first is a parent of the latter.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to use `SpanReciever` instances to collect all dropped `Span`
    values. (They''ve actually been sent to `Reciever`.) Also, we create two `JaegerCompactReporter`
    instances with names and add spans to reports using the `report` method call in
    the loop:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now, we can compile and run this tracing example.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start this example, you can use the `cargo run` command. When the example
    starts, it will continuously produce spans and send them to the running Jaeger
    instance. You will need to wait for a short interval and interrupt the application,
    otherwise it will generate too many spans.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个示例，你可以使用 `cargo run` 命令。当示例启动时，它将连续产生跨度并将它们发送到正在运行的 Jaeger 实例。你需要等待一小段时间并中断应用程序，否则它将生成过多的跨度。
- en: 'Open the web UI of Jaeger in a browser. Choose `router` in the Service field,
    and click the Find Traces button to find the corresponding spans. You will see
    recent traces, and if you click on one of them, you will see the details of the
    tracing:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 Jaeger 的 Web UI。在服务字段中选择 `router`，然后点击查找跟踪按钮以查找相应的跨度。你会看到最近的跟踪，如果你点击其中一个，你将看到跟踪的详细信息：
- en: '![](img/ec2371cb-427a-44ac-bb8c-8cb950ef4d0f.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec2371cb-427a-44ac-bb8c-8cb950ef4d0f.png)'
- en: As you can see, distributed tracing registered activities of our application,
    and we can use it as a tool for logging the distributed activities of microservices
    that are included in our application.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，分布式跟踪记录了我们应用程序的活动，我们可以将其用作日志记录我们应用程序中包含的微服务分布式活动的工具。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed a lot of topics on testing and debugging microservices.
    First, we considered unit and integration tests, and also saw some examples of
    using these in Rust. After this, we explored tools that help us with debugging
    microservices, including curl and Postman, to send requests manually; mitmproxy
    to trace all incoming requests and outgoing responses of a microservice; LLDB
    to explore the running code of a microservice; and Visual Studio Code as a GUI
    frontend for the LLDB Debugger.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多关于测试和调试微服务的话题。首先，我们考虑了单元测试和集成测试，并看到了一些在 Rust 中使用这些测试的例子。之后，我们探讨了帮助我们调试微服务的工具，包括
    curl 和 Postman，用于手动发送请求；mitmproxy 用于跟踪微服务的所有传入请求和传出响应；LLDB 用于探索微服务的运行代码；以及 Visual
    Studio Code 作为 LLDB 调试器的 GUI 前端。
- en: 'Lastly, we discussed two techniques that used for the largest applications,
    where you can''t simply debug: structural logging and distributed tracing using
    OpenTracing API.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了两种用于最大应用程序的技术，在这些应用程序中，你不能简单地调试：结构化日志和使用 OpenTracing API 的分布式跟踪。
- en: In the next chapter, you'll learn about some techniques with which you can optimize
    Rust microservices.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解一些可以用来优化 Rust 微服务的技巧。
