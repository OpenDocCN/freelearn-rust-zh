- en: DevOps of Rust Microservices - Continuous Integration and Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the widely used practices of **continuous integration**
    (**CI**) and **continuous delivery** (**CD**). When a microservice is being developed,
    you have to be sure that every feature is tested and works and think about how
    to deliver an application to your servers or deploy it to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll study how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use tools to check the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build the code automatically using CI tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deploy the compiled code to servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the Rust compiler, and you have to install at least version
    1.31\. Also, you need the `rustup` tool to add extra components, such as `rustfmt` and `clippy`.
    If you don''t have it, you can find it here: [https://rustup.rs/](https://rustup.rs/)'
  prefs: []
  type: TYPE_NORMAL
- en: Also in this chapter, we will try to bootstrap a CI system that will build and
    test a microservice. Since manual installation of these kinds of tools is long
    and complex, we will use Docker with Docker Compose to start and prepare the building
    environment faster. But in any case, you need a browser to be able to connect
    to the management console UI of the TeamCity tool to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter16.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter16)'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration and continuous delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the modern world, speed is a decisive factor of success for applications
    and products. The competition has become fierce and every company has to release
    new features as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: For microservice developers, this means we need a continuous process for building
    and delivering new versions of our products to be timely and competitive. In terms
    of software, this means you need to automate this process—maybe a special product
    or a set of scripts. Fortunately, this class of products already exists; called
    CI tools.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI is the process of merging all incoming features and patches into a single,
    well-tested application. It is important to note that this should happen several
    times a day—you will get a freshly *baked* version, like from a conveyor belt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, many products are offered to provide you a tool to test, build, and
    deploy your product unclear. In most cases, CI products work as a server that
    uses remote build agents to build code pulled from a repository. This process
    is approximately depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39e23daf-c25f-42a5-8262-d124dc94f259.png)'
  prefs: []
  type: TYPE_IMG
- en: The CI server is responsible for getting updates from a source code management
    server (such as Git) to pull a fresh version of the code and start building on
    using agents that are already connected and registered on the server. Some software
    can use Docker as a runtime for the necessary build agents. In this case, you
    don't even need to run agents manually. But this is not suitable for every part
    of an application, because some parts need to be built in an environment that
    can't be started as a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices that have been compiled and tested successfully can be moved to
    a deployment process that also can be automated using CD.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application is built and is ready for deployment, the process of deployment
    automation is called CD. Often, this functionality is provided by CI products
    by using special plugins called configuration management and deployment tools,
    such as Ansible, Chef, Puppet, and Salt.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, microservices were delivered as an archive with files such as **Web
    ARchives** (**WAR**), in Java, as packages installed directly on a server''s operating
    system, and as binaries. Nowadays, companies prefer to deliver containers, instead
    of these other formats. The advantages of containers are undeniable: they''re
    compact and safe, they use shared registries, and you don''t need to prepare environments
    again and again. A Docker image already contains what you need, and if your microservices
    can work without collisions with other instances of the same microservice, you
    can consider delivering your product not only as a container deployed to a remote
    server, but also using an orchestration tool that automatically scales your application
    depending on your customers'' needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Container orchestration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With automated building and delivery processes, you can still deploy a microservice
    into an unscalable environment. This means you lose the important benefit of fast-scaling
    your application. Developers of one huge internet hiring service told me a funny
    story about the peak load they experience—the greatest activity on their servers
    falls on Monday morning. That's the time when every worker visits the office after
    the weekend and decides, *that's finished*. The reality of application maintenance
    is that you can't predict peaks of activity for your services, so you should be
    able to run more instances of your microservices quickly.
  prefs: []
  type: TYPE_NORMAL
- en: There are some products that can orchestrate containers, and one of the most
    popular is Kubernetes. The only thing you have to do is to upload containers to
    a registry. Kubernetes can route requests and run extra instances of microservices
    that can't process all incoming requests. However, you still need to provide hardware
    resources to it and write loosely coupled microservices so that you can run as
    many as you want.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, to automate the delivery process of your application, you have
    to start with a CI system and improve it. Let's look at the tools that we can
    use to write CI scripts for Rust projects.
  prefs: []
  type: TYPE_NORMAL
- en: Rust tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of quality control of microservices is checking that the code
    does not contain explicit blunders. The compiler checks the cases with mutability,
    references, ownership, and lifetimes, and also prints warnings if you have unused
    code, but there are more complex cases that require a special tool to detect.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we cover the following tools commonly used in CI agents to
    prepare a code for merging. Let's explore all of them, starting with code formatting
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: Rustfmt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rustfmt is a tool that helps you to fit your code to style guidelines. It doesn''t
    mean you have to use one common style: the tool provides multiple configuration
    parameters that you can use to set a preferred style.'
  prefs: []
  type: TYPE_NORMAL
- en: This tool is mature, but it wasn't included in the Rust distribution until version
    1.31\. Since edition 2018 was released, the rustfmt tool has been available and
    is recommended for use in your projects; however, Rust doesn't force your code
    to have a standard format. Let's install it and try to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you use the `rustup` tool, then to install `rustfmt`, you need to add the
    corresponding component using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to install the latest version, you can do it directly from the
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The installation from source code requires compilation time and can be unstable,
    but you will have the latest features.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since `rustfmt` was added as a command, using it is as simple as calling a
    special command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command fixes all sources to default style guidelines. But it works quietly
    and we have to look at the differences between files to see the changes.
  prefs: []
  type: TYPE_NORMAL
- en: The tool patches files from your project, and you have to commit all the changes
    before you attempt to fix the code styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we will use this tool to check the code styles with CI, and stop building
    if the code was formatted incorrectly. To check the code and also to see potential
    changes, you have to pass the `--check` argument to `rustfmt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used an extra `--` parameter, because without it, we pass
    arguments to a tool that calls `rustfmt`, but to send arguments directly to `rustfmt`
    we have to add this extra pair of dashes. The checking has a `0` code if sources
    don''t contain issues, and a non-zero code if errors are present, printing a potential
    diff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what we need to use in CI to interrupt the building, and to
    see the reason for the interruption in order to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can change the behavior of `rustfmt` with a configuration to set your preferred
    styles. Add the `rustfmt.toml` configuration file to your project. The defaults
    of the current version can be described with the following configuration file
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Most parameters have descriptive names, but if you want to read a description
    of the parameters, you can pass the `--help=config` argument to `rustfmt` to see
    the details. You can create a `rustfmt.toml` file and set parameters that are
    different from the default values.
  prefs: []
  type: TYPE_NORMAL
- en: Often, code style checking is the first step of a CI script, because it's the fastest
    check and is best done before a long compilation process. There is also another
    code check that we should do before compilation—lint checking.
  prefs: []
  type: TYPE_NORMAL
- en: Clippy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the problems with the format of your code, you may also face
    more serious problems that can be fixed with another kind of tool—linters. A linter
    is a program that finds bad practices of writing code that can affect the future
    performance if the problem can be solved more simply. Rust has a good linter called
    `clippy`, included as a component since version 1.31, when it became a part of
    edition 2018\. It's a good tool to use when building scripts to prevent a flood
    of bad coding practices. Let's install it and try to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can install `clippy` in two ways, as we did with the `rustfmt` tool: by
    adding the component using the `rustup` command or by installing the latest version
    from the GitHub repository of the project. To add it as a prebuilt component,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You also can install the latest version directly from the repository of the
    project using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: But remember, this version is potentially unstable, and the lints it contains
    might be changed in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use `clippy`, it''s enough to start it as the subcommand of `cargo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This sub-command starts checking the code and will inform you about possible
    improvements. For example, imagine that you have a struct like this in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `clippy` will inform you that `Box` is unnecessary, since `Vec` is already
    placed in a memory heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: But if you really want to box a vector, you can disable this warning for this
    line of code by adding the `#[allow(clippy::box_vec)]` attribute to the field
    or the struct, and the warning for this field will be suppressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example is a warning that means the code will be compiled successfully
    and the building won''t be interrupted by `clippy`. In CI scripts, `clippy` has
    to interrupt execution if it gets a warning from the code, because we should merge
    code that doesn''t contain any warnings, as well as ambiguous code. To let `clippy`
    fail when there''s warning, we can set the extra argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `clippy` denies all warnings. But there is still a loophole if your crate
    contains non-default features: `clippy` won''t check all of them. To do a full
    check, you can use the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it will take more time, but all potential problems known to `clippy` will
    be checked.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `clippy` tool can be very annoying. To tighten or loosen checks, you can
    configure the tool using the `clippy.toml` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we activate all lints with the `-W clippy::pedantic` argument,
    we can get a warning like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This happened because `clippy` thinks there is the name of a variable that
    we forget to include in ticks. To avoid this behavior, we can add an extra word to the
    `clippy.toml` configuration to ignore markdown comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now the tool won't interpret `MyCompany` as the name of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Recommended code attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you saw, it''s possible to allow or deny some warnings for lints, but there
    are some attributes that can be used to make your code cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of stricter requirements for a code. The compiler deny unused
    code of missing docs, will require `loop` instead of `while true` and check all
    published types have to be reachable. Also, we completely deny using variable
    names in markdown docs without ticks. You can add whatever requirements you need
    to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the preceding requirements force us to use `dyn Trait` for trait objects,
    instead of a bare `Trait` name. This may come in handy if you use the 2015 edition
    but want to prepare the project for Edition 2018, but it's better to use the latest
    edition where possible, and there is a tool that can help you to move to the freshest
    edition of Rust—`rustfix`.
  prefs: []
  type: TYPE_NORMAL
- en: Rustfix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have thought, if Rust can find a problem in a code and suggest a solution,
    why hasn't it applied the changes immediately? This is a reasonable idea, and
    it may be possible in the future, but now this feature in active development with
    the `rustfix` tool.
  prefs: []
  type: TYPE_NORMAL
- en: This project aims to provide a tool that can fix all compiler warnings, and
    today you can try to use it to move your project from Edition 2015 to Edition
    2018\. We don't need this tool in CI processes directly, but it can help to satisfy
    CI checks more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install `rustfix`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After installation, you can use the `cargo fix` subcommand with the necessary
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider moving the project from Edition 2015 to Edition 2018\. Which
    arguments do you have to set to do this transformation of your code? First, you
    can prepare your code for transformation with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will make your code compatible with both editions, but if you
    want to use idioms of an edition, you have to set the edition version to be used
    in the `edition` field of the `[package]` section of the `Cargo.toml` file, and
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After running this, your code will potentially be compatible with the selected
    edition. You can also do more with `rustfix`, but some issues can be fixed if
    you use an IDE, but this topic is out of the scope of this book; and let's explore
    other cargo commands.
  prefs: []
  type: TYPE_NORMAL
- en: Cargo test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be perfectly honest, the most important tool for checking in CI is the testing
    tool. We already learned about writing tests in [Chapter 13](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml), *Testing
    and Debugging Rust Microservices*, but in this section we explore some useful
    arguments for the `cargo test` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some useful arguments for CI:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--no-run`: Compiles, but doesn''t run tests, which is useful for checking
    the compilation of tests for different targets, without wasting time for extra
    running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--all-targets`: Runs tests for all targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--all-features`: Runs tests with all features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--examples`: Tests all examples'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--jobs <N>`: Runs tests in multiple jobs, which is useful if the test uses
    one database instance only and you want to run tests sequentially to avoid a situation
    where one test affects the results of another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we are ready to bootstrap a CI tool and configure it for building a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: CI and CD tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss systems for CI, and bootstrap a CI server instance
    with a build agent using Docker Compose. But first, let's look at some popular
    CI products and their delivery capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: TravisCI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TravisCI is the most popular CI service for open source projects, because it
    provides a free plan for such projects and is integrated well with GitHub. To
    use it, all you have to do is add the `.travis.yml` file to the root of repository
    of your project. It supports Rust out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'With TravisCI, you can build your projects in either Linux or macOS environments.
    Let''s write a simple example of a `.travis.yml` file. The first part of this
    file is a building matrix declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We chose the Rust language with caching for cargo to speed up building updates.
    Also, we declared a matrix of environments. TravisCI automatically prepared the Rust
    environment for us with four variants: `linux` with a `stable` compiler, `linux`
    with a `nightly` compiler, and a pair of `stable` and `nightly` compiler versions
    for `osx`. For microservices, you often need `linux` builds only. Also, we specified
    targets, but you can use `musl` instead of `gnu`, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code installs extra packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can add environment variables that you can use in building and test
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you have to add a script that will be used as the CI script. You can
    put the `script` section with a command directly into `.travis.yml` as items to
    that section, or add a `jobs` section that can contain concurrent jobs to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `jobs` section can also contain an install subsection to provide a list
    of commands to install extra dependencies for a job.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can put this .`travis.yml` file into the root of the repository of your
    project to allow Travis CI to check the pull requests of your project. But remember
    that you have to pay for private repositories with the TravisCI service, while
    GitHub allows you to have private repositories for free. You can test your Rust
    application for Linux and macOS, but there is another service that provides another
    set of operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: AppVeyor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AppVeyor is a CI service for Linux and Windows. It''s also free for open source
    projects and provides good integration with GitHub. To start using this service,
    you have to add an `appveyor.yml` file to your project. Let''s look at the example
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration looks similar to the configuration for TravisCI. We also
    created a matrix of builds and will use MSVC and GNU toolchains for stable and
    nightly compiler versions. After this, we use these values to install the required
    tools using `rustup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also installed the `rustfmt` and `clippy` tools after the `PATH` environment
    variable was updated. Finally, we can build the projects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We set the `build` field to `false` to prevent the building agent from starting the
    MSBuild tool, which is not necessary for Rust crates.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a popular CI system created originally for and with Java. Jenkins is
    an open source product and has no limits on usage. These are both reasons why
    some growing companies choose this product, and you might too, if you want to
    customize the build process and want to control costs for CI.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins offers you two approaches for building applications.The first is running
    a plain script and the second is using pipeline, the feature that allows you to
    include a CI script in the root of the repository, like we did with TravisCI and
    AppVeyor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the `pipeline` configuration that has to be stored in
    a `Jenkinsfile` configuration file in the root of your project if you want to
    pull this script with a repository automatically and update it using SCM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `pipeline` configuration means that Jenkins requires Docker to
    build the attached `Dockerfile` and to run all commands for all stages. This feature
    utilizes Docker containers instead of agents, but you can also connect traditional
    building agents to a CI server.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstration of continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a demonstration, we will use TeamCity CI, developed by JetBrains.
    This product is similar to Jenkins in some features, but it's simpler to bootstrap
    and deploy for our demonstration. We will bootstrap our own CI environment and
    configure our own building tasks for it. TeamCity has a free plan that's enough
    for building small and medium projects. We will also use a Gogs Git server to
    have a private SCM server for our building needs. Let's start.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an empty `docker-compose.yml` file and add a `services` section to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The SCM server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To the `services` section, add the SCM server Gogs first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We'll use an official Docker image. We set a persistent volume to keep all created
    repositories between starts. Also, we forwarded two ports—SSH (from local port `10022`
    to port `22` in the container) and HTTP (from local port `10080` to port `3000`
    in the container). To upload data with the Git client, we will use the local port,
    but to use the server from TeamCity, we have to use the port of the container.
  prefs: []
  type: TYPE_NORMAL
- en: The CI server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next service we need is a CI server. We will use the official image of
    TeamCity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The container requires two persistent volumes for data and logs. We also forward
    port `8111` of the container to the same local port to connect to the UI with
    a browser.
  prefs: []
  type: TYPE_NORMAL
- en: The CI agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the TeamCity server for builds, we need at least one agent. It works
    as a sibling container in Docker, and we also declare it as a service, but provide the
    `SERVER_URL` environment variable targeted to the CI server we created before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There is the official image for an agent, but we don't use it directly here,
    because we need to add the Rust compiler and extra tools, which is why we build
    our own image for this service. Also, we need to provide a persistent volume to
    it to keep the configuration of the running agent that will be connected to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Agents don't need to open ports, because they are non-interactive and don't
    have any UI. Often, agents are also called slaves.
  prefs: []
  type: TYPE_NORMAL
- en: The image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The image for the agent service created from the official image of minimal
    agent for TeamCity is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we installed the Rust compiler and added `rustfmt` and `clippy`
    as components with `rustup`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Gogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s configure the SCM server and push a tiny microservice to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start up Docker Compose from our CI services bundle with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When all services are started, open `http://localhost:10080` in a browser to
    configure the Gogs server. You will see the following configuration form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ccf28dc3-b980-4084-9849-843466357026.png)'
  prefs: []
  type: TYPE_IMG
- en: Set SQLite3 in the Database Type field (because we won't spend time configuring
    an external database), leave the default values in the other fields, and hit the Install
    Gogs button. It will redirect you to port `3000`, but recall that, it's available
    inside Docker only and you have to open the previous URL again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the Register link and register a new account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0429244c-da63-424f-9552-4dc6886b47da.png)'
  prefs: []
  type: TYPE_IMG
- en: I set `developer` as the username and `secret` as the password. We need these
    credentials to both upload our code to a created repository and to pull it with
    CI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new private repository with the **+** sing button and call it `microservice`.
    Now you can upload the code to this repository using `http://localhost:3000/developer/microservice.git`.
    If you use the code of this chapter from the repository of the book, you can use the
    microservice crate in that folder, but you have to initialize it and add the remote
    server with these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It's a trivial command, but one to remember if you forget something.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the username and password we set before, and you have got an empty repository
    in SCM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8161f652-1a7b-41c5-bfb4-4a0028f8e5fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we can configure CI to get this code for building.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring TeamCity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, open the `http://localhost:8111` URL, where we bind the CI server in
    a browser and pass the first steps of configuring the TeamCity instance. Set a
    DataDirectory the same as we attached as a persistent volume (default value):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d85f4f1a-f522-4a23-a128-3c704e1813e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the Proceed button, and in the next step, create a database of the HSQLDB
    type. There are options for other external databases, and it''s better to use
    them for production, but for testing it''s enough to keep all data in the `data`
    directory of TeamCity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/598cdc1d-cbdc-48a7-9add-518bf6a1cf90.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create an administrator account that you will use to access the TeamCity UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/067319fe-d838-4473-9927-81e333c478a0.png)'
  prefs: []
  type: TYPE_IMG
- en: I used the `admin` value for username and the `secret` value for the password
    fields. Now it takes time to initialize and start, but after the initialization
    process is finished, we can add external agents.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have an agent in a sibling container, it already tried to connect
    to a server, but we have to authorize it because if an agent is authorized it
    can steal the source code of the microservices. Click the Authorize button in the
    Unauthorized tab of the Agents page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7301472-221c-4f91-b135-a6b543466afe.png)'
  prefs: []
  type: TYPE_IMG
- en: When the agent is authorized, you can see it in the Connected tab and can control
    it. You can also add more sibling workers to the Docker Compose configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have connected agents and can create a project that will build our microservice.
    Click the Create Project button on the Projects page and fill in the form with
    the parameters of the repository that we want to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7a643b6-3c32-43c2-a712-6b226c9ff5d1.png)'
  prefs: []
  type: TYPE_IMG
- en: We set the repository URL to `http://git-server:3000/developer/microservice.git`,
    because the CI server instance works inside a virtual network and can connect
    to other services by the names and original ports exposed by Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click the Proceed button, you can specify the name of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11d445ab-73ce-4ec0-9540-13117c933b42.png)'
  prefs: []
  type: TYPE_IMG
- en: Click Proceed again, and you have an empty project that we can configure with
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Building steps for Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the project''s page, click the link to configure build steps manually and
    add a new build step to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a64eb3f-638d-416c-871d-9d88c1ec88c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first step, called `Format Check`, is a Command Line that runs Custom script
    with a single command: `cargo fmt -- --check`. This command will check the style
    of the code with the `rustfmt` tool. Add the next build step, called Build (you
    can use your own name), with the `cargo build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9f27cdc-db76-4420-a843-960daf262e9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you click the Build Steps menu item, you will see the steps we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecd0add2-e44f-4bd5-bc87-53ae654a18ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you can start this building process by clicking the Run button, as shown
    in the preceding screenshot. It will immediately start building with the agent
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Building with CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you enter into the first building task that appears, you will see the building
    is in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97ce1689-c841-4d8a-a5fe-bf1b16fc96a9.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the first step is finished successfully and the `cargo build`
    command is in progress. When it is complete, the status of this building task
    will be changed to success. It works!
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, projects by default create a trigger to run the build process when you
    push new changes to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be6c5d33-f9cd-47b1-a376-f6b8b7040ca7.png)'
  prefs: []
  type: TYPE_IMG
- en: I pushed one extra commit to a repository and the building process started.
    As you can see in the preceding screenshot, an estimated time for building has
    appeared. According to the previous build, it's estimated at 15 minutes, but actually
    it takes only 40 seconds, because agents keep a building cache.
  prefs: []
  type: TYPE_NORMAL
- en: As an experiment, you can add more steps that test and check the code with `clippy`,
    and also add steps to upload the binary to servers.
  prefs: []
  type: TYPE_NORMAL
- en: You can also configure Jenkins to work in a similar way, but it takes a little
    more time to configure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got acquainted with CI of Rust microservices. If you haven't
    used Rust to create local programs before, this may seem like a new topic to you.
    First, we discussed the purposes of CI and CD. Also, we looked at the benefits
    of container orchestration tools.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we learned about some tools for checking the quality of the code—`rustfmt`,
    `clippy`, and `rustfix`. Then we figured out how to configure them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we studied examples of using some popular CI services and servers—TravisCI,
    AppVeyor, and Jenkins. Then, we bootstrapped an example with TeamCity CI and its
    agent, and used a private Git server to push our Rust project to be built with
    CI. Lastly, we configured the building process of a microservice and checked it
    with UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we have a look at serverless applications: what is it,
    and how to write them using Rust. Amazon Web Services offers AWS Lambda product
    for hosting serverless applications and had started to support Rust officially.'
  prefs: []
  type: TYPE_NORMAL
