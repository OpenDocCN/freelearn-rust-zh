- en: DevOps of Rust Microservices - Continuous Integration and Delivery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust微服务的DevOps - 持续集成和交付
- en: This chapter covers the widely used practices of **continuous integration**
    (**CI**) and **continuous delivery** (**CD**). When a microservice is being developed,
    you have to be sure that every feature is tested and works and think about how
    to deliver an application to your servers or deploy it to the cloud.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了广泛使用的持续集成（**CI**）和持续交付（**CD**）实践。当一个微服务正在开发时，您必须确保每个功能都经过测试并且能够正常工作，并考虑如何将应用程序部署到您的服务器或云中。
- en: 'In this chapter, we''ll study how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下内容：
- en: How to use tools to check the code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用工具检查代码
- en: How to build the code automatically using CI tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用CI工具自动构建代码
- en: How to deploy the compiled code to servers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将编译后的代码部署到服务器
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the Rust compiler, and you have to install at least version
    1.31\. Also, you need the `rustup` tool to add extra components, such as `rustfmt` and `clippy`.
    If you don''t have it, you can find it here: [https://rustup.rs/](https://rustup.rs/)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要Rust编译器，并且您必须安装至少版本1.31。此外，您还需要`rustup`工具来添加额外的组件，例如`rustfmt`和`clippy`。如果您还没有它，您可以在以下链接找到：[https://rustup.rs/](https://rustup.rs/)
- en: Also in this chapter, we will try to bootstrap a CI system that will build and
    test a microservice. Since manual installation of these kinds of tools is long
    and complex, we will use Docker with Docker Compose to start and prepare the building
    environment faster. But in any case, you need a browser to be able to connect
    to the management console UI of the TeamCity tool to configure it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试启动一个CI系统，该系统将构建和测试一个微服务。由于手动安装这类工具既耗时又复杂，我们将使用Docker和Docker Compose来更快地启动和准备构建环境。但无论如何，您需要一个浏览器来连接到TeamCity工具的管理控制台UI并进行配置。
- en: 'The examples for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter16.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter16)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter16.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter16)
- en: Continuous integration and continuous delivery
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和持续交付
- en: In the modern world, speed is a decisive factor of success for applications
    and products. The competition has become fierce and every company has to release
    new features as fast as possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代世界，速度是应用程序和产品成功的关键因素。竞争已经变得激烈，每个公司都必须尽可能快地发布新功能。
- en: For microservice developers, this means we need a continuous process for building
    and delivering new versions of our products to be timely and competitive. In terms
    of software, this means you need to automate this process—maybe a special product
    or a set of scripts. Fortunately, this class of products already exists; called
    CI tools.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务开发者来说，这意味着我们需要一个持续的过程来及时且具有竞争力地构建和交付我们产品的版本。从软件的角度来看，这意味着您需要自动化这个过程——可能是一个特殊的产品或一系列脚本。幸运的是，这类产品已经存在；被称为CI工具。
- en: Continuous integration
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: CI is the process of merging all incoming features and patches into a single,
    well-tested application. It is important to note that this should happen several
    times a day—you will get a freshly *baked* version, like from a conveyor belt.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（CI）是将所有传入的功能和补丁合并到单个经过充分测试的应用程序的过程。重要的是要注意，这应该每天发生几次——您将获得一个新鲜出炉的版本，就像从传送带上下来的一样。
- en: 'Nowadays, many products are offered to provide you a tool to test, build, and
    deploy your product unclear. In most cases, CI products work as a server that
    uses remote build agents to build code pulled from a repository. This process
    is approximately depicted in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多产品提供给您一个测试、构建和部署产品的工具，但它们并不明确。在大多数情况下，CI产品作为一个服务器，使用远程构建代理从存储库中提取代码进行构建。这个过程在以下图中大致描述：
- en: '![](img/39e23daf-c25f-42a5-8262-d124dc94f259.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39e23daf-c25f-42a5-8262-d124dc94f259.png)'
- en: The CI server is responsible for getting updates from a source code management
    server (such as Git) to pull a fresh version of the code and start building on
    using agents that are already connected and registered on the server. Some software
    can use Docker as a runtime for the necessary build agents. In this case, you
    don't even need to run agents manually. But this is not suitable for every part
    of an application, because some parts need to be built in an environment that
    can't be started as a Docker container.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CI服务器负责从源代码管理服务器（如Git）获取更新，拉取代码的新版本，并使用已经连接并注册在服务器上的代理开始构建。一些软件可以使用Docker作为必要构建代理的运行时。在这种情况下，你甚至不需要手动运行代理。但这并不适合应用程序的每个部分，因为某些部分需要在不能作为Docker容器启动的环境中构建。
- en: Microservices that have been compiled and tested successfully can be moved to
    a deployment process that also can be automated using CD.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和测试成功的微服务可以被移动到也可以使用CD自动化的部署流程中。
- en: Continuous delivery
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付
- en: When an application is built and is ready for deployment, the process of deployment
    automation is called CD. Often, this functionality is provided by CI products
    by using special plugins called configuration management and deployment tools,
    such as Ansible, Chef, Puppet, and Salt.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序构建完成并准备部署时，自动化部署的过程被称为CD。通常，这种功能是通过CI产品提供的，使用称为配置管理和部署工具的特殊插件，如Ansible、Chef、Puppet和Salt。
- en: 'In the past, microservices were delivered as an archive with files such as **Web
    ARchives** (**WAR**), in Java, as packages installed directly on a server''s operating
    system, and as binaries. Nowadays, companies prefer to deliver containers, instead
    of these other formats. The advantages of containers are undeniable: they''re
    compact and safe, they use shared registries, and you don''t need to prepare environments
    again and again. A Docker image already contains what you need, and if your microservices
    can work without collisions with other instances of the same microservice, you
    can consider delivering your product not only as a container deployed to a remote
    server, but also using an orchestration tool that automatically scales your application
    depending on your customers'' needs.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，微服务是以包含如**Web ARchives**（**WAR**）等文件的存档形式交付的，在Java中，它们作为直接安装在服务器操作系统上的包，以及作为二进制文件。如今，公司更倾向于交付容器，而不是这些其他格式。容器的好处是无可否认的：它们紧凑且安全，使用共享注册表，而且你不需要一次又一次地准备环境。Docker镜像已经包含了你需要的内容，如果你的微服务可以在不与其他相同微服务的实例冲突的情况下工作，你可以考虑将你的产品不仅作为部署到远程服务器的容器，还可以使用一个自动根据客户需求扩展应用程序的编排工具。
- en: Container orchestration
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器编排
- en: With automated building and delivery processes, you can still deploy a microservice
    into an unscalable environment. This means you lose the important benefit of fast-scaling
    your application. Developers of one huge internet hiring service told me a funny
    story about the peak load they experience—the greatest activity on their servers
    falls on Monday morning. That's the time when every worker visits the office after
    the weekend and decides, *that's finished*. The reality of application maintenance
    is that you can't predict peaks of activity for your services, so you should be
    able to run more instances of your microservices quickly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动化的构建和交付流程，你仍然可以将一个微服务部署到一个无法扩展的环境中。这意味着你失去了快速扩展应用程序的重要好处。一个大型互联网招聘服务的开发者告诉我一个有趣的故事，关于他们经历的峰值负载——他们服务器上最大的活动发生在周一早晨。那是在周末后每个员工访问办公室并决定“这结束了”的时候。应用程序维护的现实是，你无法预测服务的活动峰值，因此你应该能够快速运行更多微服务的实例。
- en: There are some products that can orchestrate containers, and one of the most
    popular is Kubernetes. The only thing you have to do is to upload containers to
    a registry. Kubernetes can route requests and run extra instances of microservices
    that can't process all incoming requests. However, you still need to provide hardware
    resources to it and write loosely coupled microservices so that you can run as
    many as you want.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些产品可以编排容器，其中最受欢迎的是Kubernetes。你唯一需要做的就是将容器上传到注册表。Kubernetes可以路由请求并运行无法处理所有传入请求的额外微服务实例。然而，你仍然需要为其提供硬件资源，并编写松散耦合的微服务，这样你就可以运行尽可能多的实例。
- en: In any case, to automate the delivery process of your application, you have
    to start with a CI system and improve it. Let's look at the tools that we can
    use to write CI scripts for Rust projects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，为了自动化应用程序的交付流程，你必须从持续集成系统开始，并不断改进它。让我们看看我们可以用来为Rust项目编写CI脚本的工具。
- en: Rust tools
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust工具
- en: The first line of quality control of microservices is checking that the code
    does not contain explicit blunders. The compiler checks the cases with mutability,
    references, ownership, and lifetimes, and also prints warnings if you have unused
    code, but there are more complex cases that require a special tool to detect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务质量控制的第一步是检查代码中不包含明显的错误。编译器会检查可变性、引用、所有权和生命周期的情况，如果你有未使用的代码，它还会打印警告，但还有一些更复杂的情况需要特殊工具来检测。
- en: In this section, we cover the following tools commonly used in CI agents to
    prepare a code for merging. Let's explore all of them, starting with code formatting
    styles.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在持续集成（CI）代理中常用的以下工具，用于准备合并前的代码。让我们一一探索，从代码格式化风格开始。
- en: Rustfmt
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rustfmt
- en: 'Rustfmt is a tool that helps you to fit your code to style guidelines. It doesn''t
    mean you have to use one common style: the tool provides multiple configuration
    parameters that you can use to set a preferred style.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Rustfmt是一个帮助你使代码符合风格指南的工具。这并不意味着你必须使用一种通用的风格：该工具提供了多个配置参数，你可以使用它们来设置首选的样式。
- en: This tool is mature, but it wasn't included in the Rust distribution until version
    1.31\. Since edition 2018 was released, the rustfmt tool has been available and
    is recommended for use in your projects; however, Rust doesn't force your code
    to have a standard format. Let's install it and try to use it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具已经成熟，但直到版本1.31之前，它都没有包含在Rust发行版中。自2018版发布以来，rustfmt工具已经可用，并建议在项目中使用；然而，Rust不会强制你的代码具有标准格式。让我们安装它并尝试使用它。
- en: Installation
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'If you use the `rustup` tool, then to install `rustfmt`, you need to add the
    corresponding component using the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`rustup`工具，那么要安装`rustfmt`，你需要使用以下命令添加相应的组件：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want to install the latest version, you can do it directly from the
    repository:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要安装最新版本，你可以直接从仓库中安装：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The installation from source code requires compilation time and can be unstable,
    but you will have the latest features.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码安装需要编译时间，可能不稳定，但你将拥有最新的功能。
- en: Usage
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用
- en: 'Since `rustfmt` was added as a command, using it is as simple as calling a
    special command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`rustfmt`被添加为一个命令，使用它就像调用一个特殊命令一样简单：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command fixes all sources to default style guidelines. But it works quietly
    and we have to look at the differences between files to see the changes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将所有源代码修复为默认风格指南。但它会静默运行，我们必须查看文件之间的差异来查看更改。
- en: The tool patches files from your project, and you have to commit all the changes
    before you attempt to fix the code styles.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具会修补你的项目中的文件，在你尝试修复代码风格之前，你必须提交所有更改。
- en: 'But we will use this tool to check the code styles with CI, and stop building
    if the code was formatted incorrectly. To check the code and also to see potential
    changes, you have to pass the `--check` argument to `rustfmt`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将使用这个工具通过CI检查代码风格，如果代码格式不正确，则停止构建。为了检查代码并查看潜在的变化，你必须将`--check`参数传递给`rustfmt`：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, we used an extra `--` parameter, because without it, we pass
    arguments to a tool that calls `rustfmt`, but to send arguments directly to `rustfmt`
    we have to add this extra pair of dashes. The checking has a `0` code if sources
    don''t contain issues, and a non-zero code if errors are present, printing a potential
    diff:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用了额外的`--`参数，因为没有它，我们会将参数传递给调用`rustfmt`的工具，但为了直接将参数发送到`rustfmt`，我们必须添加这个额外的破折号对。如果没有问题，检查将返回`0`代码，如果有错误，则返回非零代码，并打印出潜在的差异：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is exactly what we need to use in CI to interrupt the building, and to
    see the reason for the interruption in order to fix it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在CI中需要用来中断构建，并查看中断原因以便修复的工具。
- en: Configuration
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: 'You can change the behavior of `rustfmt` with a configuration to set your preferred
    styles. Add the `rustfmt.toml` configuration file to your project. The defaults
    of the current version can be described with the following configuration file
    contents:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过配置来更改`rustfmt`的行为，以设置你首选的样式。将`rustfmt.toml`配置文件添加到你的项目中。当前版本的默认值可以用以下配置文件内容描述：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Most parameters have descriptive names, but if you want to read a description
    of the parameters, you can pass the `--help=config` argument to `rustfmt` to see
    the details. You can create a `rustfmt.toml` file and set parameters that are
    different from the default values.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数参数都有描述性的名称，但如果你想阅读参数的描述，你可以通过向`rustfmt`传递`--help=config`参数来查看详细信息。你可以创建一个`rustfmt.toml`文件，并设置与默认值不同的参数。
- en: Often, code style checking is the first step of a CI script, because it's the fastest
    check and is best done before a long compilation process. There is also another
    code check that we should do before compilation—lint checking.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，代码风格检查是CI脚本的第一步，因为它是最快的检查，最好在长时间编译过程之前完成。还有一个我们在编译之前应该做的代码检查——lint检查。
- en: Clippy
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clippy
- en: In addition to the problems with the format of your code, you may also face
    more serious problems that can be fixed with another kind of tool—linters. A linter
    is a program that finds bad practices of writing code that can affect the future
    performance if the problem can be solved more simply. Rust has a good linter called
    `clippy`, included as a component since version 1.31, when it became a part of
    edition 2018\. It's a good tool to use when building scripts to prevent a flood
    of bad coding practices. Let's install it and try to use it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你代码格式的问题外，你还可能遇到更严重的问题，这些问题可以通过另一种工具——linters来解决。linters是一种程序，它可以找到可能影响未来性能的代码编写不良习惯，如果问题可以更简单地解决。Rust有一个很好的linters叫做`clippy`，自1.31版本以来作为组件包含在内，当时它成为了2018版的一部分。它是在构建脚本时防止大量不良编码实践的好工具。让我们安装它并尝试使用它。
- en: Installation
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'You can install `clippy` in two ways, as we did with the `rustfmt` tool: by
    adding the component using the `rustup` command or by installing the latest version
    from the GitHub repository of the project. To add it as a prebuilt component,
    use the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式安装`clippy`，就像我们安装`rustfmt`工具一样：使用`rustup`命令添加组件或从项目的GitHub仓库安装最新版本。要将其添加为预构建组件，请使用以下命令：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You also can install the latest version directly from the repository of the
    project using this command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下命令直接从项目的仓库中安装最新版本：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But remember, this version is potentially unstable, and the lints it contains
    might be changed in the future.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，这个版本可能是不稳定的，它包含的lints可能在将来发生变化。
- en: Usage
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用
- en: 'To use `clippy`, it''s enough to start it as the subcommand of `cargo`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`clippy`，只需将其作为`cargo`的子命令启动即可：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This sub-command starts checking the code and will inform you about possible
    improvements. For example, imagine that you have a struct like this in your code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此子命令开始检查代码，并将通知你可能的改进。例如，假设你的代码中有一个这样的结构体：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, `clippy` will inform you that `Box` is unnecessary, since `Vec` is already
    placed in a memory heap:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`clippy`会通知你`Box`是不必要的，因为`Vec`已经放置在内存堆中：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But if you really want to box a vector, you can disable this warning for this
    line of code by adding the `#[allow(clippy::box_vec)]` attribute to the field
    or the struct, and the warning for this field will be suppressed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你真的想对向量进行装箱，你可以通过在字段或结构体上添加`#[allow(clippy::box_vec)]`属性来禁用此行代码的警告，并且此字段的警告将被抑制。
- en: 'The preceding example is a warning that means the code will be compiled successfully
    and the building won''t be interrupted by `clippy`. In CI scripts, `clippy` has
    to interrupt execution if it gets a warning from the code, because we should merge
    code that doesn''t contain any warnings, as well as ambiguous code. To let `clippy`
    fail when there''s warning, we can set the extra argument:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个警告，意味着代码将成功编译，构建不会被`clippy`中断。在CI脚本中，如果`clippy`从代码中获得警告，它必须中断执行，因为我们应该合并不包含任何警告以及模糊代码的代码。为了使`clippy`在出现警告时失败，我们可以设置额外的参数：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, `clippy` denies all warnings. But there is still a loophole if your crate
    contains non-default features: `clippy` won''t check all of them. To do a full
    check, you can use the following arguments:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`clippy`否认所有警告。但如果你的crate包含非默认功能：`clippy`不会检查所有这些。要进行完整检查，可以使用以下参数：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, it will take more time, but all potential problems known to `clippy` will
    be checked.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会花费更多时间，但`clippy`知道的所有潜在问题都将被检查。
- en: Configuration
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: The `clippy` tool can be very annoying. To tighten or loosen checks, you can
    configure the tool using the `clippy.toml` configuration file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`clippy`工具可能会非常烦人。为了收紧或放宽检查，你可以使用`clippy.toml`配置文件来配置工具。'
- en: 'For example, if we activate all lints with the `-W clippy::pedantic` argument,
    we can get a warning like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用 `-W clippy::pedantic` 参数激活所有 lint，我们可以得到如下警告：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This happened because `clippy` thinks there is the name of a variable that
    we forget to include in ticks. To avoid this behavior, we can add an extra word to the
    `clippy.toml` configuration to ignore markdown comments:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `clippy` 认为存在一个我们忘记包含在引号中的变量名称。为了避免这种行为，我们可以在 `clippy.toml` 配置文件中添加一个额外的单词来忽略
    Markdown 注释：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now the tool won't interpret `MyCompany` as the name of a variable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在工具不会将 `MyCompany` 解释为变量的名称。
- en: Recommended code attributes
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐的代码属性
- en: 'As you saw, it''s possible to allow or deny some warnings for lints, but there
    are some attributes that can be used to make your code cleaner:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，允许或拒绝某些警告对于 lint 是可能的，但有一些属性可以用来自动化你的代码：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is an example of stricter requirements for a code. The compiler deny unused
    code of missing docs, will require `loop` instead of `while true` and check all
    published types have to be reachable. Also, we completely deny using variable
    names in markdown docs without ticks. You can add whatever requirements you need
    to your project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码更严格要求的示例。编译器拒绝未使用代码和缺少文档，将要求使用 `loop` 而不是 `while true`，并检查所有已发布类型都必须可达。我们还完全拒绝在
    Markdown 文档中使用不带引号的变量名称。你可以将所需的要求添加到你的项目中。
- en: Also, the preceding requirements force us to use `dyn Trait` for trait objects,
    instead of a bare `Trait` name. This may come in handy if you use the 2015 edition
    but want to prepare the project for Edition 2018, but it's better to use the latest
    edition where possible, and there is a tool that can help you to move to the freshest
    edition of Rust—`rustfix`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，前面的要求迫使我们使用 `dyn Trait` 来表示 trait 对象，而不是裸露的 `Trait` 名称。如果你使用 2015 版本但想为 Edition
    2018 准备项目，这可能很有用，但最好尽可能使用最新版本，并且有一个工具可以帮助你迁移到 Rust 的最新版本——`rustfix`。
- en: Rustfix
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rustfix
- en: You may have thought, if Rust can find a problem in a code and suggest a solution,
    why hasn't it applied the changes immediately? This is a reasonable idea, and
    it may be possible in the future, but now this feature in active development with
    the `rustfix` tool.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想过，如果 Rust 可以在代码中找到问题并提出解决方案，为什么没有立即应用这些更改？这是一个合理的想法，未来可能实现，但现在这个功能正在通过 `rustfix`
    工具积极开发中。
- en: This project aims to provide a tool that can fix all compiler warnings, and
    today you can try to use it to move your project from Edition 2015 to Edition
    2018\. We don't need this tool in CI processes directly, but it can help to satisfy
    CI checks more quickly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目旨在提供一个可以修复所有编译器警告的工具，今天你可以尝试使用它将你的项目从 Edition 2015 转换到 Edition 2018。我们不需要在
    CI 流程中直接使用这个工具，但它可以帮助更快地满足 CI 检查。
- en: Installation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'To install `rustfix`, use the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `rustfix`，请使用以下命令：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After installation, you can use the `cargo fix` subcommand with the necessary
    parameters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，你可以使用带有必要参数的 `cargo fix` 子命令。
- en: Usage
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'Let''s consider moving the project from Edition 2015 to Edition 2018\. Which
    arguments do you have to set to do this transformation of your code? First, you
    can prepare your code for transformation with this command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑将项目从 Edition 2015 转换到 Edition 2018。你需要设置哪些参数来完成这个代码转换？首先，你可以使用以下命令来准备你的代码以进行转换：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This command will make your code compatible with both editions, but if you
    want to use idioms of an edition, you have to set the edition version to be used
    in the `edition` field of the `[package]` section of the `Cargo.toml` file, and
    run the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使你的代码与两个版本兼容，但如果你想使用某个版本的惯用用法，你必须将版本设置为在 `Cargo.toml` 文件的 `[package]` 部分的
    `edition` 字段中使用的版本，并运行以下命令：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After running this, your code will potentially be compatible with the selected
    edition. You can also do more with `rustfix`, but some issues can be fixed if
    you use an IDE, but this topic is out of the scope of this book; and let's explore
    other cargo commands.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你的代码可能与所选版本兼容。你还可以使用 `rustfix` 做更多的事情，但如果你使用 IDE，一些问题可以得到修复；但这个主题超出了本书的范围；让我们探索其他
    cargo 命令。
- en: Cargo test
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargo 测试
- en: To be perfectly honest, the most important tool for checking in CI is the testing
    tool. We already learned about writing tests in [Chapter 13](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml), *Testing
    and Debugging Rust Microservices*, but in this section we explore some useful
    arguments for the `cargo test` command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完全坦白地说，CI 中最重要的工具是测试工具。我们已经在 [第 13 章](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml)
    中学习了如何编写测试，*测试和调试 Rust 微服务*，但在本节中，我们将探讨 `cargo test` 命令的一些有用参数。
- en: 'There are some useful arguments for CI:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: CI 有一些有用的参数：
- en: '`--no-run`: Compiles, but doesn''t run tests, which is useful for checking
    the compilation of tests for different targets, without wasting time for extra
    running'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-run`：编译但不运行测试，这对于检查不同目标的测试编译很有用，无需浪费额外运行的时间'
- en: '`--all-targets`: Runs tests for all targets'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--all-targets`：为所有目标运行测试'
- en: '`--all-features`: Runs tests with all features'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--all-features`：使用所有功能运行测试'
- en: '`--examples`: Tests all examples'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--examples`：测试所有示例'
- en: '`--jobs <N>`: Runs tests in multiple jobs, which is useful if the test uses
    one database instance only and you want to run tests sequentially to avoid a situation
    where one test affects the results of another'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--jobs <N>`：在多个作业中运行测试，如果测试只使用一个数据库实例，并且你想要顺序运行测试以避免一个测试影响另一个测试的结果，这很有用'
- en: Now we are ready to bootstrap a CI tool and configure it for building a microservice.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好启动 CI 工具并为其构建微服务进行配置。
- en: CI and CD tools
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI 和 CD 工具
- en: In this section, we will discuss systems for CI, and bootstrap a CI server instance
    with a build agent using Docker Compose. But first, let's look at some popular
    CI products and their delivery capabilities.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论 CI 系统，并使用 Docker Compose 启动一个 CI 服务器实例，并使用构建代理。但首先，让我们看看一些流行的 CI
    产品及其交付能力。
- en: TravisCI
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TravisCI
- en: TravisCI is the most popular CI service for open source projects, because it
    provides a free plan for such projects and is integrated well with GitHub. To
    use it, all you have to do is add the `.travis.yml` file to the root of repository
    of your project. It supports Rust out of the box.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: TravisCI 是开源项目最受欢迎的持续集成服务，因为它为这些项目提供免费计划，并且与 GitHub 集成良好。要使用它，你只需将 `.travis.yml`
    文件添加到你的项目仓库的根目录。它默认支持 Rust。
- en: 'With TravisCI, you can build your projects in either Linux or macOS environments.
    Let''s write a simple example of a `.travis.yml` file. The first part of this
    file is a building matrix declaration:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TravisCI，你可以在 Linux 或 macOS 环境中构建你的项目。让我们写一个简单的 `.travis.yml` 文件示例。该文件的第一部分是构建矩阵声明：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We chose the Rust language with caching for cargo to speed up building updates.
    Also, we declared a matrix of environments. TravisCI automatically prepared the Rust
    environment for us with four variants: `linux` with a `stable` compiler, `linux`
    with a `nightly` compiler, and a pair of `stable` and `nightly` compiler versions
    for `osx`. For microservices, you often need `linux` builds only. Also, we specified
    targets, but you can use `musl` instead of `gnu`, for example.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了带有缓存的 Rust 语言，以加快构建更新的速度。此外，我们还声明了一个环境矩阵。TravisCI 自动为我们准备了 Rust 环境，有四种变体：带有
    `stable` 编译器的 `linux`，带有 `nightly` 编译器的 `linux`，以及 `osx` 上的 `stable` 和 `nightly`
    编译器版本的一对。对于微服务，你通常只需要 `linux` 构建。此外，我们还指定了目标，但你可以使用 `musl` 而不是 `gnu`，例如。
- en: 'The following code installs extra packages:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码安装额外的包：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, you can add environment variables that you can use in building and test
    running:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以添加在构建和测试运行中使用的环境变量：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, you have to add a script that will be used as the CI script. You can
    put the `script` section with a command directly into `.travis.yml` as items to
    that section, or add a `jobs` section that can contain concurrent jobs to run:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须添加一个用作 CI 脚本的脚本。你可以直接将 `script` 部分中的命令作为该部分的项放入 `.travis.yml`，或者添加一个 `jobs`
    部分以包含可以并行运行的作业：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `jobs` section can also contain an install subsection to provide a list
    of commands to install extra dependencies for a job.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`jobs` 部分也可以包含一个安装子部分，以提供为作业安装额外依赖项的命令列表。'
- en: Now you can put this .`travis.yml` file into the root of the repository of your
    project to allow Travis CI to check the pull requests of your project. But remember
    that you have to pay for private repositories with the TravisCI service, while
    GitHub allows you to have private repositories for free. You can test your Rust
    application for Linux and macOS, but there is another service that provides another
    set of operating systems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将这个`.travis.yml`文件放入你项目仓库的根目录，以便允许Travis CI检查你的项目的pull请求。但请记住，你必须为TravisCI服务付费以使用私有仓库，而GitHub允许你免费拥有私有仓库。你可以测试你的Rust应用程序在Linux和macOS上，但还有一个提供另一组操作系统的服务。
- en: AppVeyor
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AppVeyor
- en: 'AppVeyor is a CI service for Linux and Windows. It''s also free for open source
    projects and provides good integration with GitHub. To start using this service,
    you have to add an `appveyor.yml` file to your project. Let''s look at the example
    configuration:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: AppVeyor是一个适用于Linux和Windows的CI服务。对于开源项目，它也是免费的，并且与GitHub有良好的集成。要开始使用这项服务，你必须在你的项目中添加一个`appveyor.yml`文件。让我们看看示例配置：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The configuration looks similar to the configuration for TravisCI. We also
    created a matrix of builds and will use MSVC and GNU toolchains for stable and
    nightly compiler versions. After this, we use these values to install the required
    tools using `rustup`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 配置看起来与TravisCI的配置类似。我们还创建了一个构建矩阵，并将使用MSVC和GNU工具链为稳定和夜间编译器版本。在此之后，我们使用这些值通过`rustup`安装所需的工具：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also installed the `rustfmt` and `clippy` tools after the `PATH` environment
    variable was updated. Finally, we can build the projects as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新了`PATH`环境变量之后，我们也安装了`rustfmt`和`clippy`工具。最后，我们可以按照以下方式构建项目：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We set the `build` field to `false` to prevent the building agent from starting the
    MSBuild tool, which is not necessary for Rust crates.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`build`字段设置为`false`，以防止构建代理启动MSBuild工具，这对于Rust crate来说是不必要的。
- en: Jenkins
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins
- en: This is a popular CI system created originally for and with Java. Jenkins is
    an open source product and has no limits on usage. These are both reasons why
    some growing companies choose this product, and you might too, if you want to
    customize the build process and want to control costs for CI.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最初为Java创建并设计的流行CI系统。Jenkins是一个开源产品，对使用没有限制。这两个原因都是一些成长中的公司选择这个产品的原因，如果你想要定制构建过程并希望控制CI的成本，你也可能会选择这个产品。
- en: Jenkins offers you two approaches for building applications.The first is running
    a plain script and the second is using pipeline, the feature that allows you to
    include a CI script in the root of the repository, like we did with TravisCI and
    AppVeyor.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins为你提供了两种构建应用程序的方法。第一种是运行一个普通的脚本，第二种是使用流水线（pipeline），这是一个允许你在仓库根目录中包含CI脚本的特性，就像我们在TravisCI和AppVeyor中做的那样。
- en: 'Here is an example of the `pipeline` configuration that has to be stored in
    a `Jenkinsfile` configuration file in the root of your project if you want to
    pull this script with a repository automatically and update it using SCM:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自动从仓库中拉取此脚本并将其使用SCM更新，那么必须将以下`pipeline`配置存储在你项目根目录的`Jenkinsfile`配置文件中：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding `pipeline` configuration means that Jenkins requires Docker to
    build the attached `Dockerfile` and to run all commands for all stages. This feature
    utilizes Docker containers instead of agents, but you can also connect traditional
    building agents to a CI server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`pipeline`配置意味着Jenkins需要Docker来构建附加的`Dockerfile`，并运行所有阶段的全部命令。这个特性利用Docker容器而不是代理，但你也可以将传统的构建代理连接到CI服务器。
- en: Demonstration of continuous integration
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成的演示
- en: To create a demonstration, we will use TeamCity CI, developed by JetBrains.
    This product is similar to Jenkins in some features, but it's simpler to bootstrap
    and deploy for our demonstration. We will bootstrap our own CI environment and
    configure our own building tasks for it. TeamCity has a free plan that's enough
    for building small and medium projects. We will also use a Gogs Git server to
    have a private SCM server for our building needs. Let's start.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个演示，我们将使用由JetBrains开发的TeamCity CI。这个产品在某些特性上与Jenkins相似，但对我们演示来说，它更容易启动和部署。我们将启动自己的CI环境，并为其配置自己的构建任务。TeamCity有一个免费计划，足以构建小型和中型项目。我们还将使用Gogs
    Git服务器来满足我们的构建需求。让我们开始吧。
- en: Docker Compose
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: 'Create an empty `docker-compose.yml` file and add a `services` section to it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空的`docker-compose.yml`文件，并向其中添加一个`services`部分：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The SCM server
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SCM服务器
- en: 'To the `services` section, add the SCM server Gogs first:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`services`部分，首先添加SCM服务器Gogs：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We'll use an official Docker image. We set a persistent volume to keep all created
    repositories between starts. Also, we forwarded two ports—SSH (from local port `10022`
    to port `22` in the container) and HTTP (from local port `10080` to port `3000`
    in the container). To upload data with the Git client, we will use the local port,
    but to use the server from TeamCity, we have to use the port of the container.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用官方的Docker镜像。我们设置了一个持久卷来保持所有创建的仓库在启动之间的状态。此外，我们还转发了两个端口——SSH（从本地端口`10022`到容器中的端口`22`）和HTTP（从本地端口`10080`到容器中的端口`3000`）。要使用Git客户端上传数据，我们将使用本地端口，但要从TeamCity服务器使用，我们必须使用容器的端口。
- en: The CI server
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI服务器
- en: 'The next service we need is a CI server. We will use the official image of
    TeamCity:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一个服务是一个持续集成（CI）服务器。我们将使用TeamCity的官方镜像：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The container requires two persistent volumes for data and logs. We also forward
    port `8111` of the container to the same local port to connect to the UI with
    a browser.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 容器需要两个持久卷来存储数据和日志。我们还转发容器的`8111`端口到相同的本地端口，以便通过浏览器连接到用户界面。
- en: The CI agent
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI代理
- en: 'To use the TeamCity server for builds, we need at least one agent. It works
    as a sibling container in Docker, and we also declare it as a service, but provide the
    `SERVER_URL` environment variable targeted to the CI server we created before:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用TeamCity服务器进行构建，我们需要至少一个代理。它在Docker中作为一个兄弟容器工作，我们还将它声明为一个服务，但提供指向我们之前创建的CI服务器的`SERVER_URL`环境变量：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There is the official image for an agent, but we don't use it directly here,
    because we need to add the Rust compiler and extra tools, which is why we build
    our own image for this service. Also, we need to provide a persistent volume to
    it to keep the configuration of the running agent that will be connected to the
    server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个官方的代理镜像，但我们在这里没有直接使用它，因为我们需要添加Rust编译器和额外的工具，这就是为什么我们为这个服务构建了自己的镜像。此外，我们还需要为它提供一个持久卷来保持将要连接到服务器的运行代理的配置。
- en: Agents don't need to open ports, because they are non-interactive and don't
    have any UI. Often, agents are also called slaves.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代理不需要打开端口，因为它们是非交互式的，并且没有任何用户界面。通常，代理也被称为奴隶。
- en: The image
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像
- en: 'The image for the agent service created from the official image of minimal
    agent for TeamCity is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从TeamCity最小代理的官方镜像创建的代理服务镜像如下：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, we installed the Rust compiler and added `rustfmt` and `clippy`
    as components with `rustup`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们安装了Rust编译器，并使用`rustup`添加了`rustfmt`和`clippy`作为组件。
- en: Configuring Gogs
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Gogs
- en: 'Let''s configure the SCM server and push a tiny microservice to it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置源代码管理（SCM）服务器并将一个小型微服务推送到它：
- en: 'Start up Docker Compose from our CI services bundle with this command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从我们的CI服务包启动Docker Compose：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When all services are started, open `http://localhost:10080` in a browser to
    configure the Gogs server. You will see the following configuration form:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有服务启动后，在浏览器中打开`http://localhost:10080`来配置Gogs服务器。您将看到以下配置表单：
- en: '![](img/ccf28dc3-b980-4084-9849-843466357026.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ccf28dc3-b980-4084-9849-843466357026.png)'
- en: Set SQLite3 in the Database Type field (because we won't spend time configuring
    an external database), leave the default values in the other fields, and hit the Install
    Gogs button. It will redirect you to port `3000`, but recall that, it's available
    inside Docker only and you have to open the previous URL again.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库类型字段中设置SQLite3（因为我们不会花时间配置外部数据库），在其他字段中保留默认值，然后点击安装Gogs按钮。它将重定向到端口`3000`，但请记住，它仅在Docker内部可用，您必须再次打开之前的URL。
- en: 'Click the Register link and register a new account:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击注册链接并注册一个新账户：
- en: '![](img/0429244c-da63-424f-9552-4dc6886b47da.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0429244c-da63-424f-9552-4dc6886b47da.png)'
- en: I set `developer` as the username and `secret` as the password. We need these
    credentials to both upload our code to a created repository and to pull it with
    CI.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了`developer`作为用户名，`secret`作为密码。我们需要这些凭证来上传我们的代码到创建的仓库，以及使用CI拉取代码。
- en: 'Create a new private repository with the **+** sing button and call it `microservice`.
    Now you can upload the code to this repository using `http://localhost:3000/developer/microservice.git`.
    If you use the code of this chapter from the repository of the book, you can use the
    microservice crate in that folder, but you have to initialize it and add the remote
    server with these commands:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+**按钮创建一个新的私有仓库，并将其命名为`microservice`。现在您可以使用`http://localhost:3000/developer/microservice.git`将代码上传到这个仓库。如果您使用本书仓库中的本章代码，您可以使用该文件夹中的microservice
    crate，但您必须初始化它并使用以下命令添加远程服务器：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It's a trivial command, but one to remember if you forget something.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一条简单的命令，但如果你忘记了，就需要记住。
- en: 'Enter the username and password we set before, and you have got an empty repository
    in SCM:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入我们之前设置的用户名和密码，你将获得一个空的源代码管理（SCM）仓库：
- en: '![](img/8161f652-1a7b-41c5-bfb4-4a0028f8e5fd.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8161f652-1a7b-41c5-bfb4-4a0028f8e5fd.png)'
- en: Now we can configure CI to get this code for building.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以配置 CI 以获取构建所需的代码。
- en: Configuring TeamCity
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 TeamCity
- en: 'First, open the `http://localhost:8111` URL, where we bind the CI server in
    a browser and pass the first steps of configuring the TeamCity instance. Set a
    DataDirectory the same as we attached as a persistent volume (default value):'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 `http://localhost:8111` URL，在那里我们在浏览器中绑定 CI 服务器并传递配置 TeamCity 实例的第一步。设置数据目录与作为持久卷附加的相同（默认值）：
- en: '![](img/d85f4f1a-f522-4a23-a128-3c704e1813e4.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d85f4f1a-f522-4a23-a128-3c704e1813e4.png)'
- en: 'Click the Proceed button, and in the next step, create a database of the HSQLDB
    type. There are options for other external databases, and it''s better to use
    them for production, but for testing it''s enough to keep all data in the `data`
    directory of TeamCity:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“继续”按钮，在下一步中，创建一个 HSQLDB 类型的数据库。还有其他外部数据库的选项，对于生产环境来说，使用它们会更好，但对于测试来说，将所有数据保留在
    TeamCity 的 `data` 目录中就足够了：
- en: '![](img/598cdc1d-cbdc-48a7-9add-518bf6a1cf90.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/598cdc1d-cbdc-48a7-9add-518bf6a1cf90.png)'
- en: 'Create an administrator account that you will use to access the TeamCity UI:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个管理员账户，你将使用它来访问 TeamCity 用户界面：
- en: '![](img/067319fe-d838-4473-9927-81e333c478a0.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/067319fe-d838-4473-9927-81e333c478a0.png)'
- en: I used the `admin` value for username and the `secret` value for the password
    fields. Now it takes time to initialize and start, but after the initialization
    process is finished, we can add external agents.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我为用户名使用了 `admin` 值，为密码字段使用了 `secret` 值。现在初始化和启动需要一些时间，但初始化过程完成后，我们可以添加外部代理。
- en: Authorizing agents
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权代理
- en: 'Since we have an agent in a sibling container, it already tried to connect
    to a server, but we have to authorize it because if an agent is authorized it
    can steal the source code of the microservices. Click the Authorize button in the
    Unauthorized tab of the Agents page:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个在兄弟容器中的代理，它已经尝试连接到服务器，但我们必须授权它，因为如果代理被授权，它可以窃取微服务的源代码。在“代理”页面的“未授权”选项卡中点击“授权”按钮：
- en: '![](img/a7301472-221c-4f91-b135-a6b543466afe.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7301472-221c-4f91-b135-a6b543466afe.png)'
- en: When the agent is authorized, you can see it in the Connected tab and can control
    it. You can also add more sibling workers to the Docker Compose configuration.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理被授权后，你可以在“已连接”选项卡中看到它，并可以控制它。你还可以在 Docker Compose 配置中添加更多的兄弟工作节点。
- en: Creating a project
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Now we have connected agents and can create a project that will build our microservice.
    Click the Create Project button on the Projects page and fill in the form with
    the parameters of the repository that we want to build:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接了代理，可以创建一个构建我们的微服务的项目。在“项目”页面点击“创建项目”按钮，并填写我们想要构建的仓库参数：
- en: '![](img/f7a643b6-3c32-43c2-a712-6b226c9ff5d1.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7a643b6-3c32-43c2-a712-6b226c9ff5d1.png)'
- en: We set the repository URL to `http://git-server:3000/developer/microservice.git`,
    because the CI server instance works inside a virtual network and can connect
    to other services by the names and original ports exposed by Docker images.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仓库 URL 设置为 `http://git-server:3000/developer/microservice.git`，因为 CI 服务器实例在虚拟网络内部运行，可以通过
    Docker 镜像暴露的名称和原始端口连接到其他服务。
- en: 'When you click the Proceed button, you can specify the name of the project:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击“继续”按钮时，你可以指定项目的名称：
- en: '![](img/11d445ab-73ce-4ec0-9540-13117c933b42.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11d445ab-73ce-4ec0-9540-13117c933b42.png)'
- en: Click Proceed again, and you have an empty project that we can configure with
    steps.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 再次点击“继续”，你将得到一个空的项目，我们可以通过步骤来配置它。
- en: Building steps for Rust
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 的构建步骤
- en: 'On the project''s page, click the link to configure build steps manually and
    add a new build step to our project:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的页面上，点击配置构建步骤的链接并添加一个新的构建步骤到我们的项目中：
- en: '![](img/9a64eb3f-638d-416c-871d-9d88c1ec88c5.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a64eb3f-638d-416c-871d-9d88c1ec88c5.png)'
- en: 'The first step, called `Format Check`, is a Command Line that runs Custom script
    with a single command: `cargo fmt -- --check`. This command will check the style
    of the code with the `rustfmt` tool. Add the next build step, called Build (you
    can use your own name), with the `cargo build` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，称为“格式检查”，是一个运行自定义脚本的命令行，使用单个命令：`cargo fmt -- --check`。这个命令将使用 `rustfmt`
    工具检查代码的风格。添加下一个构建步骤，称为“构建”（你可以使用自己的名称），使用 `cargo build` 命令：
- en: '![](img/e9f27cdc-db76-4420-a843-960daf262e9a.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9f27cdc-db76-4420-a843-960daf262e9a.png)'
- en: 'Now, if you click the Build Steps menu item, you will see the steps we created:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你点击构建步骤菜单项，你会看到我们创建的步骤：
- en: '![](img/ecd0add2-e44f-4bd5-bc87-53ae654a18ac.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecd0add2-e44f-4bd5-bc87-53ae654a18ac.png)'
- en: Now you can start this building process by clicking the Run button, as shown
    in the preceding screenshot. It will immediately start building with the agent
    container.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过点击运行按钮开始这个构建过程，如前面的截图所示。它将立即与代理容器开始构建。
- en: Building with CI
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CI 构建
- en: 'If you enter into the first building task that appears, you will see the building
    is in progress:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入第一个出现的构建任务，你会看到构建正在进行中：
- en: '![](img/97ce1689-c841-4d8a-a5fe-bf1b16fc96a9.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97ce1689-c841-4d8a-a5fe-bf1b16fc96a9.png)'
- en: As you can see, the first step is finished successfully and the `cargo build`
    command is in progress. When it is complete, the status of this building task
    will be changed to success. It works!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一步已经成功完成，`cargo build` 命令正在进行中。当它完成时，这个构建任务的状态将变为成功。它工作了！
- en: 'Also, projects by default create a trigger to run the build process when you
    push new changes to the repository:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，项目默认创建一个触发器，当你向仓库推送新更改时，它会运行构建过程：
- en: '![](img/be6c5d33-f9cd-47b1-a376-f6b8b7040ca7.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be6c5d33-f9cd-47b1-a376-f6b8b7040ca7.png)'
- en: I pushed one extra commit to a repository and the building process started.
    As you can see in the preceding screenshot, an estimated time for building has
    appeared. According to the previous build, it's estimated at 15 minutes, but actually
    it takes only 40 seconds, because agents keep a building cache.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我向一个仓库推送了一个额外的提交，构建过程随即开始。正如你在前面的截图中所见，出现了构建的预估时间。根据之前的构建，预估需要 15 分钟，但实际上只需要
    40 秒，因为代理保持了构建缓存。
- en: As an experiment, you can add more steps that test and check the code with `clippy`,
    and also add steps to upload the binary to servers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实验，你可以添加更多步骤来使用 `clippy` 测试和检查代码，还可以添加步骤将二进制文件上传到服务器。
- en: You can also configure Jenkins to work in a similar way, but it takes a little
    more time to configure.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以配置 Jenkins 以类似的方式工作，但配置需要更多时间。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got acquainted with CI of Rust microservices. If you haven't
    used Rust to create local programs before, this may seem like a new topic to you.
    First, we discussed the purposes of CI and CD. Also, we looked at the benefits
    of container orchestration tools.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 Rust 微服务的 CI（持续集成）。如果你之前没有使用 Rust 创建过本地程序，这可能对你来说是一个新话题。首先，我们讨论了
    CI 和 CD 的目的。此外，我们还探讨了容器编排工具的好处。
- en: After this, we learned about some tools for checking the quality of the code—`rustfmt`,
    `clippy`, and `rustfix`. Then we figured out how to configure them.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了检查代码质量的一些工具——`rustfmt`、`clippy` 和 `rustfix`。然后我们了解了如何配置它们。
- en: Next, we studied examples of using some popular CI services and servers—TravisCI,
    AppVeyor, and Jenkins. Then, we bootstrapped an example with TeamCity CI and its
    agent, and used a private Git server to push our Rust project to be built with
    CI. Lastly, we configured the building process of a microservice and checked it
    with UI.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了使用一些流行的 CI 服务和服务器——TravisCI、AppVeyor 和 Jenkins 的示例。然后，我们使用 TeamCity
    CI 和其代理启动了一个示例，并使用私有 Git 服务器将我们的 Rust 项目推送到 CI 进行构建。最后，我们配置了微服务的构建过程，并通过 UI 进行了检查。
- en: 'In the next chapter, we have a look at serverless applications: what is it,
    and how to write them using Rust. Amazon Web Services offers AWS Lambda product
    for hosting serverless applications and had started to support Rust officially.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨无服务器应用程序：它是怎么回事，以及如何使用 Rust 编写它们。亚马逊网络服务提供了 AWS Lambda 产品来托管无服务器应用程序，并开始正式支持
    Rust。
