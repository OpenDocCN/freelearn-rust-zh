<html><head></head><body>
		<div><h1 id="_idParaDest-148" class="chapter-number"><a id="_idTextAnchor149"/>7</h1>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Managing User Sessions</h1>
			<p>At this point, our app is manipulating data in a proper database through the clicking of buttons on the view. However, anyone who comes across our app can also edit the data. While our app is not the type of app that would require a lot of security, it is an important concept to understand and practice in general web development.</p>
			<p>In this chapter, we will build a system that creates users. This system will also manage user sessions by requiring the user to log in before they can alter any to-do items through the frontend app.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating user data models with relationships with other tables with unique constraints of certain fields via database migrations</li>
				<li>Authenticating our users</li>
				<li>Managing user sessions</li>
				<li>Cleaning up authentication requirements</li>
				<li>Configuring expiration of auth tokens</li>
				<li>Adding authentication into our frontend</li>
			</ul>
			<p>After reading this chapter, you will be able to understand the basics of authenticating users on a web server. You will also be able to implement this authentication on the server side of our Rust application and store credentials in our React application in the frontend. The understanding of the concepts and practices covered in this chapter will also enable you to incorporate authentication in phone applications using React Native, and on a Rust server and desktop applications by wrapping our React application in <strong class="bold">Electron</strong>.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor151"/>Technical requirements</h1>
			<p>In this chapter, we build on the code built in the previous chapter. This can be found at the following URL: <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06/building_a_database_connection_pool">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06/building_a_database_connection_pool</a>.</p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter07">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter07</a>.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor152"/>Creating our user model</h1>
			<p>Since we are managing user sessions in our app, we will need to store information about our users to <a id="_idIndexMarker693"/>check their credentials, before we allow our to-do items to be created, deleted, and edited. We will store our user data in a <strong class="bold">PostgreSQL</strong> database. While <a id="_idIndexMarker694"/>this is not essential, we will also link users in the database to to-do items. This will give us an understanding of how to alter an existing table and create links between tables. To create our user model, we are going to have to do the following:</p>
			<ol>
				<li>Create a <code>User</code> data model.</li>
				<li>Create a <code>NewUser</code> data model.</li>
				<li>Alter the to-do item data model so that we can link it to a user model.</li>
				<li>Update the schema file with the new table and altered fields.</li>
				<li>Create and run migration scripts on the database.</li>
			</ol>
			<p>In the following sections, we’ll look at the preceding steps in detail.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Creating a User data module</h2>
			<p>Before <a id="_idIndexMarker695"/>we start, we will need to update the dependencies <a id="_idIndexMarker696"/>in the <code>Cargo.toml</code> file with the following dependencies:</p>
			<pre class="source-code">
[dependencies]
. . .
bcrypt = "0.13.0"
uuid = {version = "1.0.0", features = ["serde", "v4"]}</pre>
			<p>We will be using the <code>bcrypt</code> crate to hash and check passwords and the <code>uuid</code> crate to generate unique IDs for our user data models. As we covered in <a href="B18722_06.xhtml#_idTextAnchor127"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Persistence with PostgreSQL</em>, we will need to create two different structs for our user data model.</p>
			<p>The new user will not have an <code>id</code> field because it does not exist in the database yet. This ID is created by the database when the new user is inserted into the table. We then have another struct that has all the same fields with the <code>id</code> field we added, since we might need <a id="_idIndexMarker697"/>to use this ID when we’re interacting with existing <a id="_idIndexMarker698"/>users in the database. ID numbers can be useful for referencing other tables. They are short and we know that they are unique. We will be using a user ID to link the user to the to-do items. These data models can be housed in the following file structure in the <code>src/models.rs</code> directory:</p>
			<pre class="console">
└── user
    ├── mod.rs
    ├── new_user.rs
    └── user.rs</pre>
			<p>We will define the data model in our <code>new_user.rs</code> file. First, we must define the imports, as shown here:</p>
			<pre class="source-code">
use uuid::Uuid;
use diesel::Insertable;
use bcrypt::{DEFAULT_COST, hash};
use crate::schema::users;</pre>
			<p>It must be noted that we have not defined the users in the schema yet. We will get around to this after we have finished with all the data models. We will not be able to compile our code until we have defined our <code>users</code> schema. We will also import a unique ID crate because we are going to be creating a unique ID when we create a new user, and the <code>Insertable</code> trait from the <code>diesel</code> crate because we are going to be inserting the new user into our database. We then use the <code>hash</code> function from the <code>bcrypt</code> crate to hash the new password that we define for our new user. We can also see that we import the <code>DEFAULT_COST</code> constant from the <code>bcrypt</code> crate. The <code>DEFAULT_COST</code> is merely a constant that we will pass into the <code>hash</code> function. We will explore why <a id="_idIndexMarker699"/>this is the case in the next section when we cover <a id="_idIndexMarker700"/>hashing passwords. Now that we have defined our user data model module and imported what we need, we can move on to the next section to create the <code>NewUser</code> struct.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Creating a NewUser data model</h2>
			<p>We can <a id="_idIndexMarker701"/>define <a id="_idIndexMarker702"/>our data model with the following code:</p>
			<pre class="source-code">
#[derive(Insertable, Clone)]
#[table_name="users"]
pub struct NewUser {
    pub username: String,
    pub email: String,
    pub password: String,
    pub unique_id: String,
}</pre>
			<p>Here, we can see that we allowed our data model to be insertable. However, we are not allowing it to be queried. We want to ensure that when a user is retrieved from the database, their ID is present. We could move on to defining the general data model for users, but this is not secure. We need to ensure that our passwords are protected by hashing them. If you remember from <a href="B18722_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>, <em class="italic">Designing Your Web Application in Rust</em>, we utilized traits to allow certain to-do structs to perform actions. Some structs could create, while others could delete based on the traits that they implemented. We are locking down the functionality of our <code>NewUser</code> struct here by just implementing the <code>Insertable</code> trait. However, we will enable querying by implementing other traits for the <code>User</code> struct, as shown in the following figure:</p>
			<div><div><img src="img/Figure_7.1_B18722.jpg" alt="Figure 7.1 – Locking down data model structs with traits"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Locking down data model structs with traits</p>
			<p>Now that we have created the struct that inserts new users into the database, we can explore how to store our users’ passwords in the database.</p>
			<p>You may have wondered why you cannot recover forgotten passwords; you can only reset them. This is because the password is <em class="italic">hashed</em>. Hashing passwords is a common practice when it comes to storing them. This is where we use an algorithm to obfuscate a password so that it cannot be read. Once this is done, it cannot be reversed.</p>
			<p>The hashed <a id="_idIndexMarker703"/>password is then stored in a database. To check <a id="_idIndexMarker704"/>the password, the input password is hashed and compared to the hashed password in the database. This allows us to see whether the input hashed password matches the hashed password stored in the database. This has a couple of advantages. First, it prevents employees who have access to your data from knowing your password. If there is a data leak, it also prevents the leaked data from directly exposing your password to whoever had the data.</p>
			<p>Considering a lot of people use the same password for multiple things (even though they should not), you can only imagine the damage that may be caused to people using your app if you are not hashing passwords and there’s a data breach. However, hashing gets more complicated than this. There is a <a id="_idIndexMarker705"/>concept called <em class="italic">salting</em> that ensures that when you hash the same password, it does not result in the same hash. It does this by adding an extra bit of data to the password before it is hashed. This is also where the <code>DEFAULT_COST</code> constant that we pass into the <code>hash</code> function comes in. Let’s say we got hold of the data in the database and we want to write code that will guess the passwords we have in the data. If we have enough computing power, we could effectively guess the password. Therefore, we can pass in a cost parameter. As we increase the cost parameter, the amount of work in either CPU time or memory increases exponentially. Increasing the cost factor by one will increase the number of operations needed to compute the hash by 10,000 or even more.</p>
			<p>Explaining password security in more detail is beyond the scope of this book. However, it must be stressed that password hashing is always a must when storing passwords. Luckily, there is a range of modules in all major languages that enable you to hash and check passwords with just a few lines of code. Rust is no different here.</p>
			<p>To ensure <a id="_idIndexMarker706"/>that we can insert our new users into the <a id="_idIndexMarker707"/>database with hashed passwords, follow these steps:</p>
			<ol>
				<li value="1">First, we will have to ensure that the input password is hashed in our <code>NewUser</code> constructor, which is defined as follows:<pre class="source-code">
impl NewUser {</pre><pre class="source-code">
    pub fn new(username: String,</pre><pre class="source-code">
        email: String, password: String) -&gt; NewUser {</pre><pre class="source-code">
        let hashed_password: String = hash(</pre><pre class="source-code">
                password.as_str(), DEFAULT_COST</pre><pre class="source-code">
            ).unwrap();</pre><pre class="source-code">
        let uuid = Uuid::new_v4().to_string();</pre><pre class="source-code">
        return NewUser {</pre><pre class="source-code">
            username,</pre><pre class="source-code">
            email,</pre><pre class="source-code">
            password: hashed_password,</pre><pre class="source-code">
            unique_id: uuid</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Here, we used the <code>hash</code> function from the <code>bcrypt</code> crate to hash our password, where we also passed in the <code>DEFAULT_COST</code> constant. We also created a unique ID using the <code>Uuid</code> crate and then constructed a new instance of the <code>NewUser</code> struct with those attributes. In our app, there is no real need for a unique ID. However, these can come in handy if you are communicating between multiple servers and databases.</p>
			<ol>
				<li value="2">Now that <a id="_idIndexMarker708"/>we have defined our <code>NewUser</code> data model, we can define our general user data model in the <code>user.rs</code> file with <a id="_idIndexMarker709"/>the following code. First, we must define the following imports:<pre class="source-code">
extern crate bcrypt;</pre><pre class="source-code">
use diesel::{Queryable, Identifiable};</pre><pre class="source-code">
use bcrypt::verify;</pre><pre class="source-code">
use crate::schema::users;</pre></li>
			</ol>
			<p>Here, we can see that we are using the <code>verify</code> function and that we are also allowing the general user data model struct to be queryable and identifiable.</p>
			<ol>
				<li value="3">With the imports defined in the previous step, we can build our <code>User</code> struct. Remember, this is a struct that is going to be loaded from our database when we make database queries. Before you read further, this is a good time to try and build the <code>User</code> struct yourself, as it uses the same table as the <code>NewUser</code> struct but has an <code>id</code> field and is queried instead of inserted. Once you have built your <code>User</code> struct, it should look like the following code:<pre class="source-code">
#[derive(Queryable, Clone, Identifiable)]</pre><pre class="source-code">
#[table_name="users"]</pre><pre class="source-code">
pub struct User {</pre><pre class="source-code">
    pub id: i32,</pre><pre class="source-code">
    pub username: String,</pre><pre class="source-code">
    pub email: String,</pre><pre class="source-code">
    pub password: String,</pre><pre class="source-code">
    pub unique_id: String</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We can see that we just added the <code>id</code> field and derived the <code>Queryable</code> trait instead of the <code>Insertable</code> trait.</p>
			<ol>
				<li value="4">Now that our <code>User</code> struct has been defined, we can build a function that verifies <a id="_idIndexMarker710"/>whether an input password matches <a id="_idIndexMarker711"/>the password belonging to the user with the following code:<pre class="source-code">
impl User {</pre><pre class="source-code">
    pub fn verify(&amp;self, password: String) -&gt; bool {</pre><pre class="source-code">
    verify(password.as_str(),</pre><pre class="source-code">
    &amp;self.password).unwrap()</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
				<li>Now that our models have been defined, we must remember to register them in the <code>models/user/mod.rs</code> file with the following code:<pre class="source-code">
pub mod new_user;</pre><pre class="source-code">
pub mod user;</pre></li>
				<li>Furthermore, we can make these modules accessible to the app by adding the following line to the <code>models/mod.rs</code> file:<pre class="source-code">
pub mod item;</pre><pre class="source-code">
pub mod user;</pre></li>
			</ol>
			<p>With that, our data <a id="_idIndexMarker712"/>models for the users <a id="_idIndexMarker713"/>have been defined. However, we still need to link them to our to-do items.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor155"/>Altering the to-do item data model</h2>
			<p>To link data models to our to-do items, we must alter our to-do data models. There are multiple <a id="_idIndexMarker714"/>ways in which we can do this. For instance, we can add a <code>user_id</code> field to the item table that is just the <code>unique_id</code> field of <a id="_idIndexMarker715"/>the user table. When we are creating a new item, we then pass the unique ID of the user into the item constructor. This is easy to implement; however, it does have risks. Merely passing the unique ID of the user into the item does not enforce that the ID of the user is valid and in the database. There is nothing stopping us from inserting an ID of a deleted user into the item constructor and thus inserting an orphaned item into the database. This will then be hard to extract later, as we have no reference to the user ID that the orphaned item is associated with. We can also create a new table that references the user’s ID with the item ID, as shown in the following figure:</p>
			<div><div><img src="img/Figure_7.2_B18722.jpg" alt="Figure 7.2 – A separate database table for logging item associations with users"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – A separate database table for logging item associations with users</p>
			<p>The advantage of this is that it is easy to decouple the users from the items by merely dropping the table. However, it also does not have valid user ID enforcement or item ID enforcement when creating a new entry. We will also have to make two queries, one to the association table and then another to the item table to get the items from the user. As the previous two methods of attaching a user ID column to the items table or creating a bridge table holding an item ID and user unique ID are easy to implement, we will not explore them; you should be able to implement them yourself at this point. In the context <a id="_idIndexMarker716"/>of the to-do application, the previous two methods would be subpar, as they offer us no benefits yet introduce the risk of <a id="_idIndexMarker717"/>errors when inserting data into our database. This does not mean that the two previous methods should never be used. The data needs for each project are different. In our project, we will create a foreign key to link our users to items, as shown in the following figure:</p>
			<div><div><img src="img/Figure_7.3_B18722.jpg" alt="Figure 7.3 – Foreign key association between our user and items"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Foreign key association between our user and items</p>
			<p>This does not allow us to access the items associated with a user with one database call, but we are only allowed to insert items that have a reference to a legitimate user ID in the database. Foreign keys can also trigger cascade events where, if we delete a user, this will automatically delete all existing items associated with the user to prevent orphan items from being created. We create a foreign key by declaring the link to the table with a macro. In <code>models/item/item.rs</code>, we can achieve this by initially having the following imports:</p>
			<pre class="source-code">
use crate::schema::to_do;
use chrono::NaiveDateTime;
use super::super::user::user::User;</pre>
			<p>We can <a id="_idIndexMarker718"/>see that we must import the <code>User</code> struct, as we will be referencing it in the <code>belongs_to</code> macro to claim that our <code>Item</code> struct belongs to the <code>User</code> struct, as shown in the following code:</p>
			<pre class="source-code">
#[derive(Queryable, Identifiable, Associations)]
#[belongs_to(User)]
#[table_name="to_do"]
pub struct Item {
    pub id: i32,
    pub title: String,
    pub status: String,
    pub date: NaiveDateTime,
    pub user_id: i32,
}</pre>
			<p>Here, we can see that we imported the user data model struct, defined it with a <code>belongs_to</code> macro, and added a <code>user_id</code> field to link the struct. Note that the <code>belongs_to</code> macro will not be callable if we do not include the <code>Associations</code> macro.</p>
			<p>One last <a id="_idIndexMarker719"/>thing we need to do is add the <code>user_id</code> field to the fields and constructor in the <code>models/item/new_item.rs</code> file. We need to do this so that we can link the new to-do item to the user creating the item. This can be achieved by using the following code:</p>
			<pre class="source-code">
use crate::schema::to_do;
use chrono::{NaiveDateTime, Utc};
#[derive(Insertable)]
#[table_name="to_do"]
pub struct NewItem {
    pub title: String,
    pub status: String,
    pub date: NaiveDateTime,
    pub user_id: i32,
}
impl NewItem {
    pub fn new(title: String, user_id: i32) -&gt; NewItem {
        let now = Utc::now().naive_local();
        NewItem{
            title, status: String::from("PENDING"),
            date: now,
            user_id
        }
    }
}</pre>
			<p>So, taking <a id="_idIndexMarker720"/>stock of what we have done, all our <a id="_idIndexMarker721"/>data model structs have been altered, and we are able to use them as and when we need them in the app when interacting with the database. However, we have not updated our database, and we have not updated the bridge connecting the app to the database. We will do this next.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Updating the schema file</h2>
			<p>To make sure that the mapping from the data model struct to the database is up to date, we must <a id="_idIndexMarker722"/>update our schema with these changes. This means <a id="_idIndexMarker723"/>that we must alter the existing schema for the to-do item table and add a user schema to the <code>src/schema.rs</code> file. This is denoted by the following code:</p>
			<pre class="source-code">
table! {
    to_do (id) {
        id -&gt; Int4,
        title -&gt; Varchar,
        status -&gt; Varchar,
        date -&gt; Timestamp,
        user_id -&gt; Int4,
    }
}
table! {
    users (id) {
        id -&gt; Int4,
        username -&gt; Varchar,
        email -&gt; Varchar,
        password -&gt; Varchar,
        unique_id -&gt; Varchar,
    }
}</pre>
			<p>It must be noted that our fields in the schema file are defined in the same order as the Rust data models. This is important because, if we do not do this, the fields will be mismatched when we’re connecting to the database. We might also realize that our schema is merely just defining the fields and their type; it is not covering the relationship between the to-do table and the user table.</p>
			<p>We do <a id="_idIndexMarker724"/>not have to worry about this because when <a id="_idIndexMarker725"/>we create and run our own migrations, this schema file will be updated with the relationship. This leads us to create our own migrations to complete this schema file.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/>Creating and running migration scripts on the database</h2>
			<p>Running <a id="_idIndexMarker726"/>migrations has a similar process to what <a id="_idIndexMarker727"/>we covered in <a href="B18722_06.xhtml#_idTextAnchor127"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Persistence with PostgreSQL</em>, which <a id="_idIndexMarker728"/>covered <a id="_idIndexMarker729"/>how to install the Diesel client and connect to the database. First, we must run our database with the <code>docker-compose</code> command:</p>
			<pre class="console">
docker-compose up</pre>
			<p>We will need this running in the background when we run the migration. We can then create the migration scripts by running the following command:</p>
			<pre class="console">
diesel migration generate create_users</pre>
			<p>This creates a directory in the migrations, which includes <code>create_users</code> in the username of the directory. Inside this directory, we have two blank <em class="italic">SQL</em> files. Here, we will manually write our own SQL scripts for the migrations. Initially, you might find this unnecessary, as there are libraries in other languages that automatically generate these migrations, but there are some advantages to doing this.</p>
			<p>irst, it keeps our hand in SQL, which is another handy tool. This enables us to think about solutions that utilize SQL in the day-to-day problems that we are trying to solve. It also gives us more fine-grained control of how migrations flow. For instance, in the migration that we are going to create, we are going to have to create the user table and then a base user so that when we alter the column in the <code>to_do</code> table, we can fill it with the ID of the placeholder user row. We carry this out in our <code>up.sql</code> file with the following table definition:</p>
			<pre class="source-code">
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR NOT NULL UNIQUE,
    email VARCHAR NOT NULL UNIQUE,
    password VARCHAR NOT NULL,
    unique_id VARCHAR NOT NULL
);</pre>
			<p>This is straightforward. Note that the <code>email</code> and <code>username</code> fields are unique. This is because we do not want users with duplicate usernames and emails. It’s good to put the constraint in at this level for several reasons. For instance, we could protect against this by doing a database call of the username and email and refusing to insert a new user if there is duplication.</p>
			<p>However, there may be an error in the code, or someone might alter our code in the future. A new <a id="_idIndexMarker730"/>feature might be introduced <a id="_idIndexMarker731"/>that doesn’t have this check, such as <a id="_idIndexMarker732"/>an edit feature. There might <a id="_idIndexMarker733"/>be a migration that alters rows or inserts new users. It is usually best practice, if you are writing your own SQL, to ensure that you use the <code>;</code> symbol to indicate that the operation has finished.</p>
			<p>This SQL command is fired, and then the next command is fired afterward. Our next command in the <code>up.sql</code> file inserts a placeholder user row with the following command:</p>
			<pre class="source-code">
 INSERT INTO users (username, email, password, unique_id)
VALUES ('placeholder', 'placeholder email',
'placeholder password', 'placeholder unique id');</pre>
			<p>Now that we have created our user, we then alter our <code>to_do</code> table. We can do this with the following command, in the same file under the previous command we just wrote:</p>
			<pre class="source-code">
ALTER TABLE to_do ADD user_id integer default 1
CONSTRAINT user_id REFERENCES users NOT NULL;</pre>
			<p>With that, our <code>up.sql</code> migration has been defined. Now, we must define our <code>down.sql</code> migration. With the down migration, we basically must reverse what we did in the up migrations. This means dropping the <code>user_id</code> column in the <code>to_do</code> table and then dropping the user table entirely. This can be done with the following SQL code in the <code>down.sql</code> file:</p>
			<pre class="source-code">
ALTER TABLE to_do DROP COLUMN user_id;
DROP TABLE users</pre>
			<p>We must keep in mind that Docker must be running for the migration to influence the database. Once this migration is run, we can see that the following code has been added to the <code>src/schema.rs</code> file:</p>
			<pre class="source-code">
joinable!(to_do -&gt; users (user_id));
allow_tables_to_appear_in_same_query!(
    to_do,
    users,
);</pre>
			<p>This enables <a id="_idIndexMarker734"/>our Rust data models <a id="_idIndexMarker735"/>to make queries concerning <a id="_idIndexMarker736"/>the relationship between users and <a id="_idIndexMarker737"/>to-do items. With this migration finished, we can run our app again. However, before we do that, there is just one slight alteration that we have to make in the <code>src/views/to_do/create.rs</code> file, where the constructor of the new item in the <code>create</code> view function adds the default user ID with the following line of code:</p>
			<pre class="source-code">
let new_post = NewItem::new(title, 1);</pre>
			<p>Running our app now will result in the same behavior we described in <a href="B18722_06.xhtml#_idTextAnchor127"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Persistence with PostgreSQL</em>, in that our app is running with the migrations that we have made. However, we also need to see whether our constructor for the new user works as we hash the password and generate the unique ID.</p>
			<p>To do this, we need to build a create user endpoint. For this, we must define the schema, and then a view that inserts that new user into the database. We can create our schema in the <code>src/json_serialization/new_user.rs</code> file with the following code:</p>
			<pre class="source-code">
use serde::Deserialize;
#[derive(Deserialize)]
pub struct NewUserSchema {
    pub name: String,
    pub email: String,
    pub password: String
}</pre>
			<p>After this, we <a id="_idIndexMarker738"/>can declare the new <a id="_idIndexMarker739"/>user schema in our <code>src/json_serialization/mod.rs</code> file with <code>pub mod new_user;</code>. Once our schema <a id="_idIndexMarker740"/>has been defined, we can create our <a id="_idIndexMarker741"/>own user view module with the following file structure:</p>
			<pre class="source-code">
views
...
└── users
    ├── create.rs
    └── mod.rs</pre>
			<p>In our <code>users/create.rs</code> file, we need to build a create view function. First, import the following crates:</p>
			<pre class="source-code">
use crate::diesel;
use diesel::prelude::*;
use actix_web::{web, HttpResponse, Responder};
use actix_web::HttpResponseBuilder;
use crate::database::DB;
use crate::json_serialization::new_user::NewUserSchema;
use crate::models::user::new_user::NewUser;
use crate::schema::users;</pre>
			<p>Since <a id="_idIndexMarker742"/>we have been building our views <a id="_idIndexMarker743"/>multiple times now, none of these <a id="_idIndexMarker744"/>imports should be surprising. We import <a id="_idIndexMarker745"/>the <code>diesel</code> macros and crate to enable us to make calls to the database. We then import the <code>actix_web</code> traits and structs to enable data to flow in and out of the view. We then import our schemas and structs to structure the data that we are receiving and processing. Now that we’ve imported the correct crates, we must define the <code>create</code> view function with the following code:</p>
			<pre class="source-code">
pub async fn create(new_user: web::Json&lt;NewUserSchema&gt;,
                    db: DB) -&gt; impl Responder {
    . . .
}</pre>
			<p>Here, we can see that we accept JSON data that is loaded into the <code>NewUserSchema</code> struct. We also establish a database connection from the connection pool with the <code>DB</code> struct. Inside our <code>create</code> view function, we extract the data that we need from the <code>NewUserSchema</code> struct to create a <code>NewUser</code> struct with the following code:</p>
			<pre class="source-code">
let new_user = NewUser::new(
    new_user.name.clone(),
    new_user.email.clone(),
    new_user.password.clone()
);</pre>
			<p>We must clone the fields to be passed into the <code>NewUser</code> constructor because strings do not implement the <code>Copy</code> trait, meaning we must do this manually. We then create our <code>insert</code> command for the database and execute it with the following code:</p>
			<pre class="source-code">
let insert_result = diesel::insert_into(users::table)
                            .values(&amp;new_user)
                            .execute(&amp;db.connection);</pre>
			<p>This returns a <code>Result</code> struct. However, we do not unwrap it directly. There could be a conflict. For instance, we could be trying to insert a new user with a username or email that is already in the database. However, we do not want this to just error out. This is an edge case <a id="_idIndexMarker746"/>that we will expect as we <a id="_idIndexMarker747"/>have implemented the unique <a id="_idIndexMarker748"/>username and email constraint ourselves. If there <a id="_idIndexMarker749"/>was a legitimate error that happens when the view is being executed, we need to know about it. Therefore, we must give response codes to the edge cases. Therefore, we match the result of the insert and return the appropriate response code with the following code:</p>
			<pre class="source-code">
match insert_result {
    Ok(_) =&gt; HttpResponse::Created(),
    Err(_) =&gt; HttpResponse::Conflict()
}</pre>
			<p>Here, we have established a database connection, extracted the fields from the JSON body, created a new <code>NewUser</code> struct, and then inserted it into the database. There is a slight difference here compared to the other views. In the return response, we are having to <em class="italic">await</em> and then <em class="italic">unwrap</em> it. This is because we are not returning a JSON body. Therefore, <code>HttpResponse::Ok()</code> is merely a builder struct.</p>
			<p>Now that we have built our create view, we need to define our view factory in the <code>views/users/mod.rs</code> file, like so:</p>
			<pre class="source-code">
mod create;
use actix_web::web::{ServiceConfig, post, scope};
pub fn user_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
        scope("v1/user")
        .route("create", post().to(create::create))
    );
}</pre>
			<p>Again, since <a id="_idIndexMarker750"/>we have been building views regularly, none <a id="_idIndexMarker751"/>of this should come as a surprise <a id="_idIndexMarker752"/>to you. If it does, it is recommended <a id="_idIndexMarker753"/>that you read the <em class="italic">Managing views using the Actix Web framework</em> section in <a href="B18722_03.xhtml#_idTextAnchor059"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling HTTP Requests</em>, for clarity. Now, our main views factory in the <code>views/mod.rs</code> file should look like the following:</p>
			<pre class="source-code">
mod auth;
mod to_do;
mod app;
mod users;
use auth::auth_views_factory;
use to_do::to_do_views_factory;
use app::app_views_factory;
use users::user_views_factory;
use actix_web::web::ServiceConfig;
pub fn views_factory(app: &amp;mut ServiceConfig) {
    auth_views_factory(app);
    to_do_views_factory(app);
    app_views_factory(app);
    user_views_factory(app);
}</pre>
			<p>Now that <a id="_idIndexMarker754"/>we have registered our <a id="_idIndexMarker755"/>user view, we can run our app and <a id="_idIndexMarker756"/>create our user with the following <a id="_idIndexMarker757"/>Postman call:</p>
			<div><div><img src="img/Figure_7.4_B18722.jpg" alt="Figure 7.4 – Postman call to our create user endpoint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Postman call to our create user endpoint</p>
			<p>With this, we should get a <code>201</code> created response. If we call the exact same call again, we should get a <code>409</code> conflict. With this, we should expect that our new user has been created. With the steps covered in the <em class="italic">Connecting to PostgreSQL with Diesel</em> section in <a href="B18722_06.xhtml#_idTextAnchor127"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Persistence with PostgreSQL</em>, we can inspect the database in our Docker container, which gives us the following printout:</p>
			<pre class="console">
 id |    name     |       email
----+-------------+-------------------
  1 | placeholder | placeholder email
  2 | maxwell     | test@gmail.com
                           password
-------------------------------------------------------------
 placeholder password
 $2b$12$jlfLwu4AHjrvTpZrB311Y.W0JulQ71WVy2g771xl50e5nS1UfqwQ.
              unique_id
--------------------------------------
 placeholder unique id
 543b7aa8-e563-43e0-8f62-55211960a604</pre>
			<p>Here, we can see the initial user that was created in our migration. However, we can also see <a id="_idIndexMarker758"/>the user we created via our view. Here, we have <a id="_idIndexMarker759"/>a hashed password and a unique ID. From <a id="_idIndexMarker760"/>this, we can see that <a id="_idIndexMarker761"/>we should never directly create our user; we should only create a user through the constructor function belonging to the <code>NewUser</code> struct.</p>
			<p>In the context of our app, we do not really need a unique ID. However, in wider situations where multiple servers and databases are used, a unique ID can become useful. We also must note that our conflict response on the second one was correct; the third replica create user call, did not insert a replica user into the database.</p>
			<p>With this, our app is running as normal, since there is now a user table with user models linked to the to-do items. Thus, we can create other data tables with relationships and structure <a id="_idIndexMarker762"/>migrations so that they <a id="_idIndexMarker763"/>can be seamlessly upgraded <a id="_idIndexMarker764"/>and downgraded. We have also covered <a id="_idIndexMarker765"/>how to verify and create passwords. However, we have not actually written any code that checks whether the user is passing the right credentials. In the next section, we will work on authenticating users and rejecting requests that do not contain the right credentials.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor158"/>Authenticating our users</h1>
			<p>When it comes to authenticating our users, we have built a struct that extracts a message <a id="_idIndexMarker766"/>from the header of the HTTP request. We are now at the stage where we can make real use of this extraction by storing data about the user in the header. Right now, there is nothing stopping us from storing the username, ID, and password in the header of each HTTP request so that we can authenticate each one. However, this is a terrible practice. If someone intercepts the request or gets hold of the data stored in the browser to facilitate this, then the account is compromised and the hacker can do whatever they want. Instead, we are going to obfuscate the data, as shown in the following figure:</p>
			<div><div><img src="img/Figure_7.5_B18722.jpg" alt="Figure 7.5 – Steps for authenticating requests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Steps for authenticating requests</p>
			<p>In <em class="italic">Figure 7</em><em class="italic">.5</em>, we can see that we use a secret key to serialize the structured data that we have on the user into a token that is in bytes. We then give the token to the user to store in the browser. When the user wants to make an authorized request, the user must send <a id="_idIndexMarker767"/>the token in the header of the request. Our server then uses the secret key to deserialize the token back into structured data about the user. The algorithms used to do this process are standard hashing algorithms that are available to anyone. Therefore, we have a secret key that we define to keep the tokens out in the wild safe. For our application to carry out the processes laid out in <em class="italic">Figure 7</em><em class="italic">.5</em>, we are going to have to rewrite most of our <code>src/jwt.rs</code> file, including the <code>JwToken</code> struct. Before we start, we need to update our <code>Cargo.toml</code> dependencies with the following code:</p>
			<pre class="source-code">
[dependencies]
. . .
chrono = {version = "0.4.19", features = ["serde"]}
. . .
jsonwebtoken = "8.1.0"</pre>
			<p>We can see that we have added the <code>serde</code> features to the <code>chrono</code> crate and added the <code>jsonwebtoken</code> crate. To rebuild the <code>JwToken</code> struct, we need to import the following in the <code>src/jwt.rs</code> file:</p>
			<pre class="source-code">
use actix_web::dev::Payload;
use actix_web::{Error, FromRequest, HttpRequest};
use actix_web::error::ErrorUnauthorized;
use futures::future::{Ready, ok, err};
use serde::{Deserialize, Serialize};
use jsonwebtoken::{encode, decode, Algorithm, Header,
                   EncodingKey, DecodingKey, Validation};
use chrono::{DateTime, Utc};
use chrono::serde::ts_seconds;
use crate::config::Config;</pre>
			<p>We can see <a id="_idIndexMarker768"/>that we import <code>actix_web</code> traits and structs to enable the processing of the requests and responses. We then import <code>futures</code> to enable us to handle the interception of the HTTP request before it hits the views. We then import <code>serde</code> and <code>jsonwebtoken</code> to enable the serialization and deserialization of data to and from the token. We then import the <code>chrono</code> crate because we want to log when these tokens are minted. We also need to have the key for the serialization, and we get this from the config file, which is why we import the <code>Config</code> struct. Now that we have imported all the traits and structs that we need, we can write our token struct with the following code:</p>
			<pre class="source-code">
#[derive(Debug, Serialize, Deserialize)]
pub struct JwToken {
    pub user_id: i32,
    #[serde(with = "ts_seconds")]
    pub minted: DateTime&lt;Utc&gt;
}</pre>
			<p>Here, we can see that we have the ID of the user, and we also have the date-time of when the token was created. We also decorate our <code>minted</code> field with a <code>serde</code> macro to state how <a id="_idIndexMarker769"/>we are going to serialize the <code>datetime</code> field. Now that we have the data that we need for the token, we can move on to defining the serialization functions with the following code:</p>
			<pre class="source-code">
impl JwToken {
    pub fn get_key() -&gt; String {
        . . .
    }
    pub fn encode(self) -&gt; String {
        . . .
    }
    pub fn new(user_id: i32) -&gt; Self {
        . . .
    }
    pub fn from_token(token: String) -&gt; Option&lt;Self&gt; {
        . . .
    }
}</pre>
			<p>We can explain what each one of the preceding functions does with the following bullet points:</p>
			<ul>
				<li><code>get_key</code>: Gets the secret key for the serialization and deserialization from the <code>config.yml</code> file.</li>
				<li><code>encode</code>: Encodes the data from the <code>JwToken</code> struct as a token</li>
				<li><code>new</code>: Creates a new <code>JwToken</code> struct</li>
				<li><code>from_token</code>: Creates a <code>JwToken</code> struct from a token. If there is a failure in the deserialization it returns a <code>None</code> as there can be failures in deserialization.</li>
			</ul>
			<p>Once we have <a id="_idIndexMarker770"/>built the preceding functions, our <code>JwToken</code> struct will be able to handle tokens as and when we see fit. We flesh out the <code>get_key</code> function with the following code:</p>
			<pre class="source-code">
pub fn get_key() -&gt; String {
    let config = Config::new();
    let key_str = config.map.get("SECRET_KEY")
                            .unwrap().as_str()
                            .unwrap();
    return key_str.to_owned()
}</pre>
			<p>Here, we can see that we load the key from the config file. Therefore, we need to add the key to the <code>config.yml</code> file, resulting in our file looking like this:</p>
			<pre class="source-code">
DB_URL: postgres://username:password@localhost:5433/to_do
SECRET_KEY: secret</pre>
			<p>If our server is in production, we should have a better secret key. However, for local development, this will work fine. Now that we are extracting the key from the config file, we can define our <code>encode</code> function with the following code:</p>
			<pre class="source-code">
pub fn encode(self) -&gt; String {
    let key = EncodingKey::
              from_secret(JwToken::get_key().as_ref());
    let token = encode(&amp;Header::default(), &amp;self,
                       &amp;key).unwrap();
    return token
}</pre>
			<p>Here, we can see <a id="_idIndexMarker771"/>that we have defined an encoding key using the secret key from the config file. We then use this key to encode the data from the <code>JwToken</code> struct into a token and return it. Now that we can encode our <code>JwToken</code> struct, we will need to create new <code>JwToken</code> structs when we need them, which can be achieved by the following <code>new</code> function:</p>
			<pre class="source-code">
pub fn new(user_id: i32) -&gt; Self {
    let timestamp = Utc::now();
    return JwToken { user_id, minted: timestamp};
}</pre>
			<p>With the constructor, we know when our <code>JwToken</code> is minted. This can help us manage our user sessions if we want. For instance, if the token’s age exceeds a threshold that we deem appropriate, we can force another login.</p>
			<p>Now, all we have is the <code>from_token</code> function, where we extract the data from a token using the following code:</p>
			<pre class="source-code">
pub fn from_token(token: String) -&gt; Option&lt;Self&gt; {
    let key = DecodingKey::from_secret(
                JwToken::get_key().as_ref()
              );
    let token_result = decode::&lt;JwToken&gt;(
                        &amp;token, &amp;key,
                        &amp;Validation::new(Algorithm::HS256)
                        );
    match token_result {
        Ok(data) =&gt; {
            Some(data.claims)
        },
        Err(_) =&gt; {
            return None
        }
    }
}</pre>
			<p>Here, we define <a id="_idIndexMarker772"/>a decoding key and then use it to decode the token. We then return <code>JwToken</code> using <code>data.claims</code>. Now, our <code>JwToken</code> struct can be created, encoded into a token, and extracted from a token. Now, all we need to do is extract it from the header of an HTTP request before the view is loaded, using the following outline:</p>
			<pre class="source-code">
impl FromRequest for JwToken {
    type Error = Error;
    type Future = Ready&lt;Result&lt;JwToken, Error&gt;&gt;;
    fn from_request(req: &amp;HttpRequest,
                    _: &amp;mut Payload) -&gt; Self::Future {
        . . .
    }
}</pre>
			<p>We have implemented the <code>FromRequest</code> trait multiple times now for the database connection <a id="_idIndexMarker773"/>and the previous implementation for the <code>JwToken</code> struct. Inside the <code>from_request</code> function, we extract the token from the header with the following code:</p>
			<pre class="source-code">
match req.headers().get("token") {
    Some(data) =&gt; {
        . . .
    },
    None =&gt; {
        let error = ErrorUnauthorized(
                    "token not in header under key 'token'"
                    );
        return err(error)
    }
}</pre>
			<p>If the token is not in the header, we directly return <code>ErrorUnauthorized</code>, avoiding the call to the view completely. If we manage to extract the token from the header, we can process it with the following code:</p>
			<pre class="source-code">
Some(data) =&gt; {
    let raw_token = data.to_str()
                        .unwrap()
                        .to_string();
    let token_result = JwToken::from_token(
                                raw_token
                            );
    match token_result {
        Some(token) =&gt; {
            return ok(token)
        },
        None =&gt; {
            let error = ErrorUnauthorized(
                            "token can't be decoded"
                        );
            return err(error)
        }
    }
},</pre>
			<p>Here, we convert <a id="_idIndexMarker774"/>the raw token extracted from the header to a string. We then deserialize the token and load it into the <code>JwToken</code> struct. However, if this fails due to a fake token being supplied, we return an <code>ErrorUnauthorized</code> error. Our authentication is now fully working; however, we will not be able to do anything because we do not have a valid token, as shown in the following figure:</p>
			<div><div><img src="img/Figure_7.6_B18722.jpg" alt="Figure 7.6 – Authentication blocking requests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Authentication blocking requests</p>
			<p>In the <a id="_idIndexMarker775"/>next section, we will build login API endpoints to enable us to interact with our protected endpoints.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor159"/>Managing user sessions</h1>
			<p>For our users, we are going to have to enable them to log in. This means that we must create an <a id="_idIndexMarker776"/>endpoint to check their credentials and then generate a JWT to be returned to the user in the frontend, via the header in the response. Our first step is to define a login schema in the <code>src/json_serialization/login.rs</code> file with the following code:</p>
			<pre class="source-code">
use serde::Deserialize;
#[derive(Deserialize)]
pub struct Login {
    pub username: String,
    pub password: String
}</pre>
			<p>We have to remember to register it in the <code>src/json_serialization/mod.rs</code> file with the <code>pub mod login;</code> line of code. Once we have done this, we can build our login endpoint. We can do this by editing the <code>src/views/auth/login.rs</code> file we created in the <em class="italic">Managing views using the Actix Web framework</em> section in <a href="B18722_03.xhtml#_idTextAnchor059"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling HTTP Requests</em>, which declares our basic login view. This just returns a string.</p>
			<p>Now, we can start <a id="_idIndexMarker777"/>refactoring this view by defining the required imports, as shown in the following code:</p>
			<pre class="source-code">
use crate::diesel;
use diesel::prelude::*;
use actix_web::{web, HttpResponse, Responder};
use crate::database::DB;
use crate::models::user::user::User;
use crate::json_serialization::login::Login;
use crate::schema::users;
use crate::jwt::JwToken;</pre>
			<p>At this stage, we can glance at the imports and get a feel for what we are going to do. We are going to extract the username and password from the body. We are then going to connect to the database to check the user and password, and then use the <code>JwToken</code> struct to create the token that will be passed back to the user. We can initially lay out the outline of the view with the following code in the same file:</p>
			<pre class="source-code">
. . .
Use std::collections::HashMap;
pub async fn login(credentials: web::Json&lt;Login&gt;,
                   db: DB) -&gt; impl HttpResponse {
    . . .
}</pre>
			<p>Here, we can see that we accept the login credentials from the body of the incoming request and prepare a database connection from the connection pool for the view. We can then extract <a id="_idIndexMarker778"/>the details we need from the request body and make a database call with the following code:</p>
			<pre class="source-code">
let password = credentials.password.clone();
let users = users::table
    .filter(users::columns::username.eq(
        credentials.username.clone())
    ).load::&lt;User&gt;(&amp;db.connection).unwrap();</pre>
			<p>Now, we must check to see whether we got what we expected from the database call with the following code:</p>
			<pre class="source-code">
if users.len() == 0 {
    return HttpResponse::NotFound().await.unwrap()
} else if users.len() &gt; 1 {
    return HttpResponse::Conflict().await.unwrap()
}</pre>
			<p>Here, we have done some early returns. If there are no users, then we return a <code>not found</code> response code. This is something we will expect from time to time. However, if there is more than one user with that username, we need to return a different code.</p>
			<p>Due to the unique constraints shown, something is very wrong. A migration script in the future might undo these unique constraints, or the user query might be altered by accident. If this happens, we need to know that this has happened right away, since corrupted data that goes against our constraints can cause our application to behave in unexpected ways that can be hard to troubleshoot.</p>
			<p>Now that we have checked that the right number of users have been retrieved, we can get the one and only user at index zero with confidence and check whether their password is passable, as follows:</p>
			<pre class="source-code">
match users[0].verify(password) {
    true =&gt; {
        let token = JwToken::new(users[0].id);
        let raw_token = token.encode();
        let mut body = HashMap::new();
      body.insert("token", raw_token);
        HttpResponse::Ok().json(body)
    },
    false =&gt; HttpResponse::Unauthorized()
}</pre>
			<p>Here, we can see that we used the <code>verify</code> function. If the password is a match, we then generate <a id="_idIndexMarker779"/>a token using the ID and return it to the user in the body. If the password is not correct, we return an unauthorized code instead.</p>
			<p>In terms of our logout, we are going to take a far more lightweight approach. All we must do in our logout view is run two lines of JavaScript code. One is to remove the user token from the local storage and then revert the user to the main view. HTML can just host JavaScript that gets run as soon as you open it. Therefore, we can achieve this by putting the following code in the <code>src/views/auth/logout.rs</code> file:</p>
			<pre class="source-code">
use actix_web::HttpResponse;
pub async fn logout() -&gt; HttpResponse {
    HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body("&lt;html&gt;\
                &lt;script&gt;\
                    localStorage.removeItem('user-token'); \
                    window.location.replace(
                        document.location.origin);\
                &lt;/script&gt;\
              &lt;/html&gt;")
}</pre>
			<p>Since this <a id="_idIndexMarker780"/>view is already registered, we can run the app and make the call with Postman:</p>
			<div><div><img src="img/Figure_7.7_B18722.jpg" alt="Figure 7.7 – Logging into our application using the login endpoint with Postman"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Logging into our application using the login endpoint with Postman</p>
			<p>Altering the username will give us a <code>404-response</code> code, whereas altering the password will give us a <code>401-response</code> code. If we have the correct username and password, we will get a <code>200-response</code> code and there will be a <em class="italic">token</em> in the response of <a id="_idIndexMarker781"/>the header, as shown in <em class="italic">Figure 7</em><em class="italic">.7</em>. However, if we want to use our <em class="italic">token</em> in the response header, we will get a <code>token can't be decoded</code> message. In the next section, we are going to clean up our authentication requirements.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/>Cleaning up authentication requirements</h1>
			<p>In this section, we are going to clean up our Rust server in terms of authentication before we <a id="_idIndexMarker782"/>start configuring our frontend to handle these authentication processes. To keep the flow of the chapter engaging, we have not regularly carried out “housekeeping.” Now, we are going to update our <code>to_do</code> views. We can start by updating the <code>create</code> view with authentication requirements. To do so, the function signature of our <code>create</code> view in the <code>src/views/to_do/create.rs</code> file should look like the following:</p>
			<pre class="source-code">
. . .
use crate::jwt::JwToken;
use crate::database::DB
pub async fn create(token: JwToken,
                    req: HttpRequest, db: DB) -&gt; HttpResponse {
    . . .</pre>
			<p>We also must update the user ID when creating a new item with the ID from the token, using the following code:</p>
			<pre class="source-code">
if items.len() == 0 {
    let new_post = NewItem::new(title, token.user_id);
    let _ = diesel::
            insert_into(to_do::table).values(&amp;new_post)
        .execute(&amp;db.connection);
}
Return HttpResponse::Ok().json(
    ToDoItems::get_state(token.user_id)
)</pre>
			<p>With our <code>delete</code> view, we must ensure that we are deleting a to-do item that belongs to the user making the request. If we do not add a filter using the user ID, the deletion of the to-do <a id="_idIndexMarker783"/>item will be random. This filter can be added in our <code>src/views/to_do/delete.rs</code> file with the following code:</p>
			<pre class="source-code">
. . .
Use crate::database::DB;
. . .
pub async fn delete(to_do_item: web::Json&lt;ToDoItem&gt;,
                    token: JwToken, db: DB) -&gt; HttpResponse {
    let items = to_do::table
        .filter(to_do::columns::title.eq(
                    &amp;to_do_item.title.as_str())
                )
        .filter(to_do::columns::user_id.eq(&amp;token.user_id))
        .order(to_do::columns::id.asc())
        .load::&lt;Item&gt;(&amp;db.connection)
        .unwrap();
    let _ = diesel::delete(&amp;items[0]).execute(&amp;db.connection);
    return HttpResponse::Ok().json(ToDoItems::get_state(
        token.user_id
    ))
}</pre>
			<p>We can see that the <code>filter</code> functions can merely be chained when making a database query. Considering what we have done with our <code>delete</code> view, how do you think we will upgrade <a id="_idIndexMarker784"/>our authentication requirements for our <code>edit</code> in the <code>src/views/to_do/edit.rs</code> file? At this stage, I encourage you to try and update the <code>edit</code> view yourself, as the approach is like our <code>delete</code> view upgrade. Once you have done this, your <code>edit</code> view should look like the following code:</p>
			<pre class="source-code">
pub async fn edit(to_do_item: web::Json&lt;ToDoItem&gt;,
                  token: JwToken, db: DB) -&gt; HttpResponse {
    let results = to_do::table.filter(to_do::columns::title
                              .eq(&amp;to_do_item.title))
                              .filter(to_do::columns::user_
                                      id
                              .eq(&amp;token.user_id));
    let _ = diesel::update(results)
        .set(to_do::columns::status.eq("DONE"))
        .execute(&amp;db.connection);
    return HttpResponse::Ok().json(ToDoItems::get_state(
                                   token.user_id
    ))
}</pre>
			<p>Now that we have updated our specific views, we can now move on to the <code>get</code> view, which also has the <code>get_state</code> function that is applied to all other views. Our <code>get</code> view in the <code>src/views/to_do/get.rs</code> file now takes the following form:</p>
			<pre class="source-code">
use actix_web::Responder;
use crate::json_serialization::to_do_items::ToDoItems;
use crate::jwt::JwToken;
pub async fn get(token: JwToken) -&gt; impl Responder {
    ToDoItems::get_state(token.user_id)
}</pre>
			<p>Now, everything in the preceding code should not be a surprise. We can see that we pass the <a id="_idIndexMarker785"/>user ID into the <code>ToDoItems::get_state</code> function. You must remember to fill in the user ID everywhere the <code>ToDoItems::get_state</code> function is implemented, which is all the to-do views. We can then redefine our <code>ToDoItems::get_state</code> function in the <code>src/json_serialization/to_do_items.rs</code> file with the following code:</p>
			<pre class="source-code">
. . .
use crate::database::DBCONNECTION;
. . .
impl ToDoItems {
    . . .
    pub fn get_state(user_id: i32) -&gt; ToDoItems {
        let connection = DBCONNECTION.db_connection.get()
                         .unwrap();
        let items = to_do::table
                    .filter(to_do::columns::user_id.eq
                           (&amp;user_id))
                    .order(to_do::columns::id.asc())
                    .load::&lt;Item&gt;(&amp;connection)
                    .unwrap();
        let mut array_buffer = Vec::
                               with_capacity(items.len());
        for item in items {
            let status = TaskStatus::from_string(
            &amp;item.status.as_str().to_string());
            let item = to_do_factory(&amp;item.title, status);
            array_buffer.push(item);
        }
        return ToDoItems::new(array_buffer)
    }
}</pre>
			<p>Here, we can see that we have updated the database connection and the filter for the user ID. We have now updated our code to accommodate different users. There is one more change <a id="_idIndexMarker786"/>that we must make. Because we will be writing frontend code in our React application, we will try and keep the React coding as simple as possible, as React development is a book itself. To avoid over-complicating the frontend development of header extraction and <code>GET</code> posts using Axios, we will add a <code>Post</code> method to our login and return the token using the body. This is another good opportunity to try and solve this yourself, as we have covered all the concepts needed to pull this off.</p>
			<p>If you have attempted to solve this problem yourself, it should look like the following. First, we define a response struct in the <code>src/json_serialization/login_response.rs</code> file with the following code:</p>
			<pre class="source-code">
use serde::Serialize;
#[derive(Serialize)]
pub struct LoginResponse {
    pub token: String
}</pre>
			<p>We remember <a id="_idIndexMarker787"/>to declare the preceding struct by putting in <code>pub mod login_response</code> in the <code>src/json_serialization/mod.rs</code> file. We now go to our <code>src/views/auth/login.rs</code> and have the following <code>return</code> statement in the <code>login</code> function:</p>
			<pre class="source-code">
match users[0].clone().verify(credentials.password.clone()) {
    true =&gt; {
        let user_id = users[0].clone().id;
        let token = JwToken::new(user_id);
        let raw_token = token.encode();
        let response = LoginResponse{token:
                                     raw_token.clone()};
        let body = serde_json::
                   to_string(&amp;response).unwrap();
        HttpResponse::Ok().append_header(("token",
                           raw_token)).json(&amp;body)
    },
    false =&gt; HttpResponse::Unauthorized().finish()
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">You may have noticed that we made a slight change to our unauthorized to the following:</p>
			<p class="callout"><strong class="bold">HttpResponse::Unauthorized().finish()</strong></p>
			<p class="callout">This is because we have switched our <code>return</code> type for the view function to an <code>HttpResponse</code> struct giving us the following function signature:</p>
			<p class="callout"><strong class="bold">(credentials: web::Json&lt;Login&gt;, db: DB) -&gt; </strong><strong class="bold">HttpResponse</strong></p>
			<p class="callout">We had to make the switch because adding the <code>json</code> function to our response turns our response from <code>HttpResponseBuilder</code> to <code>HttpResponse</code>. Once the <code>json</code> function has been called, <code>HttpResponseBuilder</code> cannot be used. Going back to the unauthored response builder, we can deduce that the <code>finish</code> function converts <code>HttpResponseBuilder</code> to <code>HttpResponse</code>. We can also convert our <code>HttpResponseBuilder</code> to <code>HttpResponse</code> by using <code>await</code>, as shown in the following code:</p>
			<p class="callout"><strong class="bold">HttpResponse::Unauthorized().await.unwrap()</strong></p>
			<p>Here, we can <a id="_idIndexMarker788"/>see that we return the token in the header and the body. This will give us flexibility and ease when writing the frontend code. However, it must be stressed that this is not the best practice. We are implementing the approach of passing the token back into the body and header to keep the frontend development section simple. We can then enable the <code>POST</code> method for our login view in our <code>src/views/auth/mod.rs</code> file with the following code:</p>
			<pre class="source-code">
mod login;
mod logout;
use actix_web::web::{ServiceConfig, get, post, scope};
pub fn auth_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
            scope("v1/auth")
            .route("login", get().to(login::login))
            .route("login", post().to(login::login))
            .route("logout", get().to(logout::logout))
    );
}</pre>
			<p>We can see that we have merely stacked a <code>get</code> function onto the same <code>login</code> view. Now, <code>POST</code> and <code>GET</code> are available for our login view. We can now move into the next section where <a id="_idIndexMarker789"/>we configure our authentication tokens so they can expire. We want our tokens to expire to increase our security. If a token is compromised and a bad actor gets hold of a token, they will be able to do whatever they want for as long as they want without ever having to log in. However, if our tokens expire, then the bad actor only has a limited time window before the token expires.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor161"/>Configuring expiration of auth tokens</h1>
			<p>If we try and perform an API call on our now protected endpoints with a valid token obtained <a id="_idIndexMarker790"/>from logging in with the token in the header, we will get an unauthorized error. If we insert some <code>print</code> statements, we will get the following error when failing to decode the token:</p>
			<pre class="console">
missing required claim: exp</pre>
			<p>This implies that there is no field called <code>exp</code> in our <code>JwToken</code> struct. If we reference the <code>jsonwebtoken</code> documentation at <a href="https://docs.rs/jsonwebtoken/latest/jsonwebtoken/fn.encode.html">https://docs.rs/jsonwebtoken/latest/jsonwebtoken/fn.encode.html</a>, we can see that the <code>encode</code> instructions never mention <code>exp</code>:</p>
			<pre class="source-code">
use serde::{Deserialize, Serialize};
use jsonwebtoken::{encode, Algorithm, Header, EncodingKey};
#[derive(Debug, Serialize, Deserialize)]
struct Claims {
   sub: String,
   company: String
}
let my_claims = Claims {
    sub: "b@b.com".to_owned(),
    company: "ACME".to_owned()
};
// my_claims is a struct that implements Serialize
// This will create a JWT using HS256 as algorithm
let token = encode(&amp;Header::default(), &amp;my_claims,
&amp;EncodingKey::from_secret("secret".as_ref())).unwrap();</pre>
			<p>Here, we can see that there is no mention of claims. However, what is happening is that when we <a id="_idIndexMarker791"/>try and deserialize our token, the <code>decode</code> function in the <code>jsonwebtoken</code> crate is automatically looking for the <code>exp</code> field to work out when the token is supposed to be expired. We are exploring this because the official documentation and slightly confusing error message could leave you wasting hours trying to figure out what is going on. With this in mind, we must go back to our <code>src/jwt.rs</code> file for some more rewriting, but this is the last time, I promise, and it is not an entire rewrite. First, we ensure that the following is imported alongside what is already in the <code>src/jwt.rs</code> file:</p>
			<pre class="source-code">
. . .
use jsonwebtoken::{encode, decode, Header,
                   EncodingKey, DecodingKey,
                   Validation};
use chrono::Utc;
. . .</pre>
			<p>We can then make sure our <code>JwToken</code> struct is written with the <code>exp</code> field with the following code:</p>
			<pre class="source-code">
#[derive(Debug, Serialize, Deserialize)]
pub struct JwToken {
    pub user_id: i32,
    pub exp: usize,
}</pre>
			<p>We now must rewrite the <code>new</code> constructor method for our <code>JwToken</code> struct. In the <code>new</code> function, we will have to define at what time the newly minted <code>JwToken</code> struct has expired. This must vary; as a developer, you might want to tweak the time taken to timeout. Remember <a id="_idIndexMarker792"/>that we must recompile every time we change the Rust code; therefore, it makes sense to have the timeout period defined in the config file. With the variance of timeout considered, our <code>new</code> function takes the following form:</p>
			<pre class="source-code">
pub fn new(user_id: i32) -&gt; Self {
    let config = Config::new();
    let minutes = config.map.get("EXPIRE_MINUTES")
                            .unwrap().as_i64().unwrap();
    let expiration = Utc::now()
    .checked_add_signed(chrono::Duration::minutes(minutes))
                            .expect("valid timestamp")
                            .timestamp();
    return JwToken { user_id, exp: expiration as usize };
}</pre>
			<p>We can see that we define the number of minutes. We then convert our expiration as <code>usize</code> and then build our <code>JwToken</code> struct. Now that we have this, we need to be more specific with the type of error that we return, as it could be an error in the decoding <a id="_idIndexMarker793"/>of the token, or the token could be expired. We handle the different types of errors when decoding the token with the following code:</p>
			<pre class="source-code">
pub fn from_token(token: String) -&gt; Result&lt;Self, String&gt; {
    let key = DecodingKey::
              from_secret(JwToken::get_key().as_ref());
    let token_result = decode::&lt;JwToken&gt;(&amp;token.as_str(),
                              &amp;key,&amp;Validation::default());
    match token_result {
        Ok(data) =&gt; {
            return Ok(data.claims)
        },
        Err(error) =&gt; {
            let message = format!("{}", error);
            return Err(message)
        }
    }
}</pre>
			<p>Here, we can see that we have switched from returning <code>Option</code> to <code>Result</code>. We have switched to <code>Result</code> because we are returning the message that can be digested and processed in our <code>from_request</code> function in the <code>FromRequest</code> trait implementation. The rest of the code in the <code>from_request</code> function is the same. Where we make the change is checking the message if there is an error and returning a different message to the frontend with the following code:</p>
			<pre class="source-code">
fn from_request(req: &amp;HttpRequest,
                _: &amp;mut Payload) -&gt; Self::Future {
    match req.headers().get("token") {
        Some(data) =&gt; {
            let raw_token = data.to_str()
                                .unwrap()
                                .to_string();
            let token_result = JwToken::
                        from_token(raw_token);
            match token_result {
                Ok(token) =&gt; {
                    return ok(token)
                },
                Err(message) =&gt; {
                    if message == "ExpiredSignature"
                                  .to_owned() {
                        return err(
                        ErrorUnauthorized("token expired"))
                    }
                    return err(
                    ErrorUnauthorized("token can't be decoded"))
                }
            }
        },
        None =&gt; {
            return err(
            ErrorUnauthorized(
            "token not in header under key 'token'"))
        }
    }
}</pre>
			<p>With the nuanced error message, our frontend code can handle and adapt, as we can be more specific on how we handle the errors in the frontend. Being more specific in the frontend <a id="_idIndexMarker794"/>can aid the user, prompting them where they went wrong. However, when it comes to authentication, make sure you do not give too much away because this can also aid bad actors trying to obtain unauthorized access. We now have our login and logout endpoints running; we also have token authorization on the views that we need. However, this is not very useful if we want a standard user to interact with our application, as they are unlikely to use Postman. Therefore, we are going to have to incorporate our login/logout endpoints in the frontend in the next section.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor162"/>Adding authentication into our frontend</h1>
			<p>We incorporate <a id="_idIndexMarker795"/>our login functionality. We must start off by building the login form in the <code>src/components/LoginForm.js</code> file. First, we import the following:</p>
			<pre class="source-code">
import React, {Component} from 'react';
import axios from 'axios';
import '../css/LoginForm.css';</pre>
			<p>The code for the imported CSS is provided in the <em class="italic">Appendix</em> of this chapter. We will not go through it here, as it is a lot of repetitive code. You can also download the CSS code from the GitHub repo. With these imports, we can build the framework for our login form with the following code:</p>
			<pre class="source-code">
class LoginForm extends Component {
    state = {
        username: "",
        password: "",
    }
    submitLogin = (e) =&gt; {
        . . .
    }
    handlePasswordChange = (e) =&gt; {
        this.setState({password: e.target.value})
    }
    handleUsernameChange = (e) =&gt; {
        this.setState({username: e.target.value})
    }
    render() {
        . . .
    }
}
export default LoginForm;</pre>
			<p>Here, we can <a id="_idIndexMarker796"/>see that we keep track of <code>username</code> and <code>password</code> that is constantly updating the state. Remember, when the state is updated, we execute the <code>render</code> function. This is powerful, as we can change whatever we want. For instance, if the length of <code>username</code> exceeds a certain length, we can change the color of the components or remove the button. We will not be making drastic changes ourselves, as this is out of the scope of this book. Now that we have defined our framework, we can state what our <code>render</code> function returns with the following code:</p>
			<pre class="source-code">
&lt;form className="login" onSubmit={this.submitLogin}&gt;
    &lt;h1 className="login-title"&gt;Login&lt;/h1&gt;
    &lt;input type="text" className="login-input"
    placeholder="Username"
    autoFocus onChange={this.handleUsernameChange}
           value={this.state.username} /&gt;
    &lt;input type="password" className="login-input"
    placeholder="Password"
    onChange={this.handlePasswordChange}
           value={this.state.password} /&gt;
    &lt;input type="submit" value="Lets Go"
    className="login-button" /&gt;
&lt;/form&gt;</pre>
			<p>Here, we can <a id="_idIndexMarker797"/>see that we have the <code>username</code> and <code>password</code> fields in the form that execute the <code>handleUsernameChange</code> and <code>handlePasswordChange</code> functions when there is a change. When we input <code>username</code> and <code>password</code>, we need to submit these fields to the backend via the <code>submitLogin</code> function, which we can define here:</p>
			<pre class="source-code">
submitLogin = (e) =&gt; {
    e.preventDefault();
    axios.post("http://localhost:8000/v1/auth/login",
        {"username": this.state.username,
         "password": this.state.password},
        {headers: {"Access-Control-Allow-Origin": "*"}}
        )
        .then(response =&gt; {
            this.setState({username: "", password: ""});
            this.props.handleLogin(response.data["token"]);
        })
        .catch(error =&gt; {
            alert(error);
            this.setState({password: "", firstName: ""});
        });
}</pre>
			<p>Here, we can see that we pass the response of the login API call to a function that we passed through <a id="_idIndexMarker798"/>using props. We will have to define this in the <code>src/app.js</code> file. If there is an error, we print this out in an alert to tell us what happened. Either way, we empty the <code>username</code> and <code>password</code> fields.</p>
			<p>Now that we have defined our login form, we will need to show it when we need the user to log in. Once the user has logged in, we need to hide the login form. Before we can do this, we need to import our login form to the <code>src/app.js</code> file with the following code:</p>
			<pre class="source-code">
import LoginForm from "./components/LoginForm";</pre>
			<p>We now need to keep track of the login status. To do this, our <code>App</code> class’s state needs to take the following form:</p>
			<pre class="source-code">
state = {
  "pending_items": [],
  "done_items": [],
  "pending_items_count": 0,
  "done_items_count": 0,
  "login_status": false,
}</pre>
			<p>We are keeping track of our items, but if <code>login_status</code> is <code>false</code>, we can show the login form. Once the user has logged in, we can set <code>login_status</code> to <code>true</code>, and as a result, we can hide the login form. Now that we are logging the login status, we can update the <code>App</code> class’s <code>getItems</code> function:</p>
			<pre class="source-code">
getItems() {
  axios.get("http://127.0.0.1:8000/v1/item/get",
  {headers: {"token": localStorage.getItem("user-token")}})
  .then(response =&gt; {
      let pending_items = response.data["pending_items"]
      let done_items = response.data["done_items"]
      this.setState({
        "pending_items":
         this.processItemValues(pending_items),
        "done_items": this.processItemValues(done_items),
        "pending_items_count":
         response.data["pending_item_count"],
        "done_items_count":
         response.data["done_item_count"]
        })
  }).catch(error =&gt; {
      if (error.response.status === 401) {
        this.logout();
      }
  });
}</pre>
			<p>We can see <a id="_idIndexMarker799"/>that we get the token and put it in the header. If there is an error with unauthorized code, we execute the <code>logout</code> function of the <code>App</code> class. Our <code>logout</code> function takes the form defined here:</p>
			<pre class="source-code">
logout() {
  localStorage.removeItem("token");
  this.setState({"login_status": false});
}</pre>
			<p>We can see that we remove the token from the local storage and set our <code>login_status</code> to <code>false</code>. This <code>logout</code> function also needs to be executed if there is an error when trying to edit a to-do item, as we must remember that our token can expire so it <a id="_idIndexMarker800"/>can happen anywhere, and we must prompt another login. This means we must pass the <code>logout</code> function into the <code>ToDoItem</code> component with the following code:</p>
			<pre class="source-code">
processItemValues(items) {
  let itemList = [];
  items.forEach((item, _)=&gt;{
      itemList.push(
          &lt;ToDoItem key={item.title + item.status}
                    title={item.title}
                    status={item.status}
                    passBackResponse={this.handleReturnedState}
                    logout={this.logout}/&gt;
      )
  })
  return itemList
}</pre>
			<p>Once we have passed our <code>logout</code> function into the <code>ToDoItem</code> component, we can update the API call to edit a to-do item in the <code>src/components/ToDoItem.js</code> file with the following code:</p>
			<pre class="source-code">
sendRequest = () =&gt; {
    axios.post("http://127.0.0.1:8000/v1/item/" +
                this.state.button,
        {
            "title": this.state.title,
            "status": this.inverseStatus(this.state.status)
        },
    {headers: {"token": localStorage.getItem(
         "user-token")}})
        .then(response =&gt; {
            this.props.passBackResponse(response);
        }).catch(error =&gt; {
            if (error.response.status === 401) {
                this.props.logout();
            }
    });
}</pre>
			<p>Here, we can <a id="_idIndexMarker801"/>see that we pass the token from local storage to the API call via the header. We then execute the <code>logout</code> function passed in via the props if we get an unauthorized status.</p>
			<p>We now move back to the <code>src/app.js</code> file to wrap up the functionality of our application. Remember that our application needs to load data when we first access it. When our application initially loads, we must consider the token in the local storage with the following code:</p>
			<pre class="source-code">
componentDidMount() {
  let token = localStorage.getItem("user-token");
  if (token !== null) {
      this.setState({login_status: true});
      this.getItems();
  }
}</pre>
			<p>Now our application will only get the items from the backend when there is a token. We must only handle the login before we wrap up our application with the <code>render</code> function. You have seen how we are handling our token with local storage. At this point, you should <a id="_idIndexMarker802"/>be able to build the <code>handleLogin</code> function for the <code>App</code> class yourself. If you have attempted coding your own function, it should look like the following code:</p>
			<pre class="source-code">
handleLogin = (token) =&gt; {
  localStorage.setItem("user-token", token);
  this.setState({"login_status": true});
  this.getItems();
}</pre>
			<p>We are now at the stage of defining the <code>render</code> function for the <code>App</code> class. If our login status is <code>true</code>, we can show everything our application has to offer with the following code:</p>
			<pre class="source-code">
if (this.state.login_status === true) {
    return (
        &lt;div className="App"&gt;
            &lt;div className="mainContainer"&gt;
                &lt;div className="header"&gt;
                    &lt;p&gt;complete tasks:
                       {this.state.done_items_count}&lt;/p&gt;
                    &lt;p&gt;pending tasks:
                       {this.state.pending_items_count}&lt;/p&gt;
                &lt;/div&gt;
                &lt;h1&gt;Pending Items&lt;/h1&gt;
                {this.state.pending_items}
                &lt;h1&gt;Done Items&lt;/h1&gt;
                {this.state.done_items}
                &lt;CreateToDoItem
                 passBackResponse={this.handleReturnedState}/&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
}</pre>
			<p>There is <a id="_idIndexMarker803"/>not too much new here. However, if our login status is not <code>true</code>, we can then just display the login form with the following code:</p>
			<pre class="source-code">
else {
    return (
        &lt;div className="App"&gt;
            &lt;div className="mainContainer"&gt;
                &lt;LoginForm handleLogin={this.handleLogin}
                /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
}</pre>
			<p>As we can see, we have passed the <code>handleLogin</code> function into the <code>LoginForm</code> component. With this, we are ready to run the application. Our first view looks like the following:</p>
			<div><div><img src="img/Figure_7.8_B18722.jpg" alt="Figure 7.8 – Login and thus the loading view of our application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Login and thus the loading view of our application</p>
			<p>Once we <a id="_idIndexMarker804"/>enter the correct credentials, we will be able to access the application and interact with the to-do items. Our application is essentially working!</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor163"/>Summary</h1>
			<p>In this chapter, we built user data model structs and tied them to the to-do item data models in our migrations. We then got to dive a little deeper into our migrations by firing multiple steps in the SQL file to ensure our migration runs smoothly. We also explored how to add unique constraints to certain fields.</p>
			<p>Once our data models were defined in the database, we hashed some passwords before storing them in our database with the stored user. We then created a JWT struct to enable our users to store their JWT in their browsers so that they can submit them when making an API call. We then explored how to redirect the URL in JavaScript and the HTML storage so that the frontend can work out whether the user even has credentials, before it entertains the notion of sending API calls to the items.</p>
			<p>What we have done here is alter the database with migration so that our app can manage data models that handle more complexity. We then utilized frontend storage to enable our user to pass credentials. This is directly applicable to any other Rust web project you will embark on. Most web apps require some sort of authentication.</p>
			<p>In the next chapter, we will explore <strong class="bold">REST API</strong> practices, where we will standardize interfaces, caching, and logging.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor164"/>Questions</h1>
			<ol>
				<li value="1">What are the advantages of defining unique constraints in SQL as opposed to server-side code?</li>
				<li>What is the main advantage of a user having a JWT over storing a password?</li>
				<li>How does a user store a JWT on the frontend?</li>
				<li>How could a JWT be useful in the view once we have verified that it is passable?</li>
				<li>What is the minimal approach to altering data in the frontend and redirecting it to another view when a user hits an endpoint?</li>
				<li>Why is it useful to have a range of different response codes when logging in as a user, as opposed to just denoting that login is successful or unsuccessful?</li>
			</ol>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Answers</h1>
			<ol>
				<li value="1">Adding unique constraints directly on a database ensures that this standard is enforced, no matter whether data manipulation is done via migration or a server request. This also protects us from corrupting data if a new feature is added at another endpoint that forgets to enforce this standard, or if the code is altered in later alterations of the endpoints.</li>
				<li>If an attacker manages to obtain a JWT, it does not mean that they have direct access to the user’s password. Also, if the tokens get refreshed, then the access the attacker has to items has a limited timeframe.</li>
				<li>The JWT can be stored in local HTML storage or cookies.</li>
				<li>We can store multiple data points in the token when hashing it. Therefore, we can encrypt the user ID. With this, we can extract the user ID for operations related to the to-do item’s creation, deletion, or edit.</li>
				<li>We return an <code>HttpResponse</code> struct with HTML/text body that contains a string housing a couple of HTML tags. In between these tags are a couple of script tags. In between the script tags, we can have each of our JavaScript commands split by ;. We can then directly alter the HTML storage and window location.</li>
				<li>There could be a range of reasons why data gets corrupted on a database, including alterations in the migrations. However, there could be an error that is not the fault of the user – for instance, a duplicate username for two different users. This is an error where our unique constraints have been violated. We need to know this has happened so that we can correct it.</li>
			</ol>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor166"/>Further reading</h1>
			<p>JWT standard: <a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/>Appendix</h1>
			<p>The CSS used for the login form:</p>
			<pre class="source-code">
body {
    background: #2d343d;
}
.login {
    margin: 20px auto;
    width: 300px;
    padding: 30px 25px;
    background: white;
    border: 1px solid #c4c4c4;
    border-radius: 25px;
}
h1.login-title {
    margin: -28px -25px 25px;
    padding: 15px 25px;
    line-height: 30px;
    font-size: 25px;
    font-weight: 300;
    color: #ADADAD;
    text-align:center;
    background: #f7f7f7;
    border-radius: 25px 25px 0px 0px;
}
.login-input {
    width: 285px;
    height: 50px;
    margin-bottom: 25px;
    padding-left:10px;
    font-size: 15px;
    background: #fff;
    border: 1px solid #ccc;
    border-radius: 4px;
}
.login-input:focus {
    border-color:#6e8095;
    outline: none;
}
.login-button {
    width: 100%;
    height: 50px;
    padding: 0;
    font-size: 20px;
    color: #fff;
    text-align: center;
    background: #f0776c;
    border: 0;
    border-radius: 5px;
    cursor: pointer;
    outline:0;
}
.login-lost
{
    text-align:center;
    margin-bottom:0px;
}
.login-lost a
{
    color:#666;
    text-decoration:none;
    font-size:13px;
}
.loggedInTitle {
    font-family: "Helvetica Neue";
    color: white;
}</pre>
		</div>
	</body></html>