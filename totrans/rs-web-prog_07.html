<html><head></head><body>
		<div id="_idContainer082">
			<h1 id="_idParaDest-148" class="chapter-number"><a id="_idTextAnchor149"/>7</h1>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Managing User Sessions</h1>
			<p>At this point, our app is manipulating data in a proper database through the clicking of buttons on the view. However, anyone who comes across our app can also edit the data. While our app is not the type of app that would require a lot of security, it is an important concept to understand and practice in general <span class="No-Break">web development.</span></p>
			<p>In this chapter, we will build a system that creates users. This system will also manage user sessions by requiring the user to log in before they can alter any to-do items through the <span class="No-Break">frontend app.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Creating user data models with relationships with other tables with unique constraints of certain fields via <span class="No-Break">database migrations</span></li>
				<li>Authenticating <span class="No-Break">our users</span></li>
				<li>Managing <span class="No-Break">user sessions</span></li>
				<li>Cleaning up <span class="No-Break">authentication requirements</span></li>
				<li>Configuring expiration of <span class="No-Break">auth tokens</span></li>
				<li>Adding authentication into <span class="No-Break">our frontend</span></li>
			</ul>
			<p>After reading this chapter, you will be able to understand the basics of authenticating users on a web server. You will also be able to implement this authentication on the server side of our Rust application and store credentials in our React application in the frontend. The understanding of the concepts and practices covered in this chapter will also enable you to incorporate authentication in phone applications using React Native, and on a Rust server and desktop applications by wrapping our React application <span class="No-Break">in </span><span class="No-Break"><strong class="bold">Electron</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor151"/>Technical requirements</h1>
			<p>In this chapter, we build on the code built in the previous chapter. This can be found at the following <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06/building_a_database_connection_pool"><span class="No-Break">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06/building_a_database_connection_pool</span></a><span class="No-Break">.</span></p>
			<p>The code for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter07"><span class="No-Break">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter07</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor152"/>Creating our user model</h1>
			<p>Since we are managing user sessions in our app, we will need to store information about our users to <a id="_idIndexMarker693"/>check their credentials, before we allow our to-do items to be created, deleted, and edited. We will store our user data in a <strong class="bold">PostgreSQL</strong> database. While <a id="_idIndexMarker694"/>this is not essential, we will also link users in the database to to-do items. This will give us an understanding of how to alter an existing table and create links between tables. To create our user model, we are going to have to do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Create a <strong class="source-inline">User</strong> <span class="No-Break">data model.</span></li>
				<li>Create a <strong class="source-inline">NewUser</strong> <span class="No-Break">data model.</span></li>
				<li>Alter the to-do item data model so that we can link it to a <span class="No-Break">user model.</span></li>
				<li>Update the schema file with the new table and <span class="No-Break">altered fields.</span></li>
				<li>Create and run migration scripts on <span class="No-Break">the database.</span></li>
			</ol>
			<p>In the following sections, we’ll look at the preceding steps <span class="No-Break">in detail.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Creating a User data module</h2>
			<p>Before <a id="_idIndexMarker695"/>we start, we will need to update the dependencies <a id="_idIndexMarker696"/>in the <strong class="source-inline">Cargo.toml</strong> file with the <span class="No-Break">following dependencies:</span></p>
			<pre class="source-code">
[dependencies]
. . .
bcrypt = "0.13.0"
uuid = {version = "1.0.0", features = ["serde", "v4"]}</pre>
			<p>We will be using the <strong class="source-inline">bcrypt</strong> crate to hash and check passwords and the <strong class="source-inline">uuid</strong> crate to generate unique IDs for our user data models. As we covered in <a href="B18722_06.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Data Persistence with PostgreSQL</em>, we will need to create two different structs for our user <span class="No-Break">data model.</span></p>
			<p>The new user will not have an <strong class="source-inline">id</strong> field because it does not exist in the database yet. This ID is created by the database when the new user is inserted into the table. We then have another struct that has all the same fields with the <strong class="source-inline">id</strong> field we added, since we might need <a id="_idIndexMarker697"/>to use this ID when we’re interacting with existing <a id="_idIndexMarker698"/>users in the database. ID numbers can be useful for referencing other tables. They are short and we know that they are unique. We will be using a user ID to link the user to the to-do items. These data models can be housed in the following file structure in the <span class="No-Break"><strong class="source-inline">src/models.rs</strong></span><span class="No-Break"> directory:</span></p>
			<pre class="console">
└── user
    ├── mod.rs
    ├── new_user.rs
    └── user.rs</pre>
			<p>We will define the data model in our <strong class="source-inline">new_user.rs</strong> file. First, we must define the imports, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
use uuid::Uuid;
use diesel::Insertable;
use bcrypt::{DEFAULT_COST, hash};
use crate::schema::users;</pre>
			<p>It must be noted that we have not defined the users in the schema yet. We will get around to this after we have finished with all the data models. We will not be able to compile our code until we have defined our <strong class="source-inline">users</strong> schema. We will also import a unique ID crate because we are going to be creating a unique ID when we create a new user, and the <strong class="source-inline">Insertable</strong> trait from the <strong class="source-inline">diesel</strong> crate because we are going to be inserting the new user into our database. We then use the <strong class="source-inline">hash</strong> function from the <strong class="source-inline">bcrypt</strong> crate to hash the new password that we define for our new user. We can also see that we import the <strong class="source-inline">DEFAULT_COST</strong> constant from the <strong class="source-inline">bcrypt</strong> crate. The <strong class="source-inline">DEFAULT_COST</strong> is merely a constant that we will pass into the <strong class="source-inline">hash</strong> function. We will explore why <a id="_idIndexMarker699"/>this is the case in the next section when we cover <a id="_idIndexMarker700"/>hashing passwords. Now that we have defined our user data model module and imported what we need, we can move on to the next section to create the <span class="No-Break"><strong class="source-inline">NewUser</strong></span><span class="No-Break"> struct.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Creating a NewUser data model</h2>
			<p>We can <a id="_idIndexMarker701"/>define <a id="_idIndexMarker702"/>our data model with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[derive(Insertable, Clone)]
#[table_name="users"]
pub struct NewUser {
    pub username: String,
    pub email: String,
    pub password: String,
    pub unique_id: String,
}</pre>
			<p>Here, we can see that we allowed our data model to be insertable. However, we are not allowing it to be queried. We want to ensure that when a user is retrieved from the database, their ID is present. We could move on to defining the general data model for users, but this is not secure. We need to ensure that our passwords are protected by hashing them. If you remember from <a href="B18722_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Designing Your Web Application in Rust</em>, we utilized traits to allow certain to-do structs to perform actions. Some structs could create, while others could delete based on the traits that they implemented. We are locking down the functionality of our <strong class="source-inline">NewUser</strong> struct here by just implementing the <strong class="source-inline">Insertable</strong> trait. However, we will enable querying by implementing other traits for the <strong class="source-inline">User</strong> struct, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_7.1_B18722.jpg" alt="Figure 7.1 – Locking down data model structs with traits"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Locking down data model structs with traits</p>
			<p>Now that we have created the struct that inserts new users into the database, we can explore how to store our users’ passwords in <span class="No-Break">the database.</span></p>
			<p>You may have wondered why you cannot recover forgotten passwords; you can only reset them. This is because the password is <em class="italic">hashed</em>. Hashing passwords is a common practice when it comes to storing them. This is where we use an algorithm to obfuscate a password so that it cannot be read. Once this is done, it cannot <span class="No-Break">be reversed.</span></p>
			<p>The hashed <a id="_idIndexMarker703"/>password is then stored in a database. To check <a id="_idIndexMarker704"/>the password, the input password is hashed and compared to the hashed password in the database. This allows us to see whether the input hashed password matches the hashed password stored in the database. This has a couple of advantages. First, it prevents employees who have access to your data from knowing your password. If there is a data leak, it also prevents the leaked data from directly exposing your password to whoever had <span class="No-Break">the data.</span></p>
			<p>Considering a lot of people use the same password for multiple things (even though they should not), you can only imagine the damage that may be caused to people using your app if you are not hashing passwords and there’s a data breach. However, hashing gets more complicated than this. There is a <a id="_idIndexMarker705"/>concept called <em class="italic">salting</em> that ensures that when you hash the same password, it does not result in the same hash. It does this by adding an extra bit of data to the password before it is hashed. This is also where the <strong class="source-inline">DEFAULT_COST</strong> constant that we pass into the <strong class="source-inline">hash</strong> function comes in. Let’s say we got hold of the data in the database and we want to write code that will guess the passwords we have in the data. If we have enough computing power, we could effectively guess the password. Therefore, we can pass in a cost parameter. As we increase the cost parameter, the amount of work in either CPU time or memory increases exponentially. Increasing the cost factor by one will increase the number of operations needed to compute the hash by 10,000 or <span class="No-Break">even more.</span></p>
			<p>Explaining password security in more detail is beyond the scope of this book. However, it must be stressed that password hashing is always a must when storing passwords. Luckily, there is a range of modules in all major languages that enable you to hash and check passwords with just a few lines of code. Rust is no <span class="No-Break">different here.</span></p>
			<p>To ensure <a id="_idIndexMarker706"/>that we can insert our new users into the <a id="_idIndexMarker707"/>database with hashed passwords, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li value="1">First, we will have to ensure that the input password is hashed in our <strong class="source-inline">NewUser</strong> constructor, which is defined <span class="No-Break">as follows:</span><pre class="source-code">
impl NewUser {</pre><pre class="source-code">
    pub fn new(username: String,</pre><pre class="source-code">
        email: String, password: String) -&gt; NewUser {</pre><pre class="source-code">
        let hashed_password: String = hash(</pre><pre class="source-code">
                password.as_str(), DEFAULT_COST</pre><pre class="source-code">
            ).unwrap();</pre><pre class="source-code">
        let uuid = Uuid::new_v4().to_string();</pre><pre class="source-code">
        return NewUser {</pre><pre class="source-code">
            username,</pre><pre class="source-code">
            email,</pre><pre class="source-code">
            password: hashed_password,</pre><pre class="source-code">
            unique_id: uuid</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Here, we used the <strong class="source-inline">hash</strong> function from the <strong class="source-inline">bcrypt</strong> crate to hash our password, where we also passed in the <strong class="source-inline">DEFAULT_COST</strong> constant. We also created a unique ID using the <strong class="source-inline">Uuid</strong> crate and then constructed a new instance of the <strong class="source-inline">NewUser</strong> struct with those attributes. In our app, there is no real need for a unique ID. However, these can come in handy if you are communicating between multiple servers <span class="No-Break">and databases.</span></p>
			<ol>
				<li value="2">Now that <a id="_idIndexMarker708"/>we have defined our <strong class="source-inline">NewUser</strong> data model, we can define our general user data model in the <strong class="source-inline">user.rs</strong> file with <a id="_idIndexMarker709"/>the following code. First, we must define the <span class="No-Break">following imports:</span><pre class="source-code">
extern crate bcrypt;</pre><pre class="source-code">
use diesel::{Queryable, Identifiable};</pre><pre class="source-code">
use bcrypt::verify;</pre><pre class="source-code">
use crate::schema::users;</pre></li>
			</ol>
			<p>Here, we can see that we are using the <strong class="source-inline">verify</strong> function and that we are also allowing the general user data model struct to be queryable <span class="No-Break">and identifiable.</span></p>
			<ol>
				<li value="3">With the imports defined in the previous step, we can build our <strong class="source-inline">User</strong> struct. Remember, this is a struct that is going to be loaded from our database when we make database queries. Before you read further, this is a good time to try and build the <strong class="source-inline">User</strong> struct yourself, as it uses the same table as the <strong class="source-inline">NewUser</strong> struct but has an <strong class="source-inline">id</strong> field and is queried instead of inserted. Once you have built your <strong class="source-inline">User</strong> struct, it should look like the <span class="No-Break">following code:</span><pre class="source-code">
#[derive(Queryable, Clone, Identifiable)]</pre><pre class="source-code">
#[table_name="users"]</pre><pre class="source-code">
pub struct User {</pre><pre class="source-code">
    pub id: i32,</pre><pre class="source-code">
    pub username: String,</pre><pre class="source-code">
    pub email: String,</pre><pre class="source-code">
    pub password: String,</pre><pre class="source-code">
    pub unique_id: String</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We can see that we just added the <strong class="source-inline">id</strong> field and derived the <strong class="source-inline">Queryable</strong> trait instead of the <span class="No-Break"><strong class="source-inline">Insertable</strong></span><span class="No-Break"> trait.</span></p>
			<ol>
				<li value="4">Now that our <strong class="source-inline">User</strong> struct has been defined, we can build a function that verifies <a id="_idIndexMarker710"/>whether an input password matches <a id="_idIndexMarker711"/>the password belonging to the user with the <span class="No-Break">following code:</span><pre class="source-code">
impl User {</pre><pre class="source-code">
    pub fn verify(&amp;self, password: String) -&gt; bool {</pre><pre class="source-code">
    verify(password.as_str(),</pre><pre class="source-code">
    &amp;self.password).unwrap()</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
				<li>Now that our models have been defined, we must remember to register them in the <strong class="source-inline">models/user/mod.rs</strong> file with the <span class="No-Break">following code:</span><pre class="source-code">
pub mod new_user;</pre><pre class="source-code">
pub mod user;</pre></li>
				<li>Furthermore, we can make these modules accessible to the app by adding the following line to the <span class="No-Break"><strong class="source-inline">models/mod.rs</strong></span><span class="No-Break"> file:</span><pre class="source-code">
pub mod item;</pre><pre class="source-code">
pub mod user;</pre></li>
			</ol>
			<p>With that, our data <a id="_idIndexMarker712"/>models for the users <a id="_idIndexMarker713"/>have been defined. However, we still need to link them to our <span class="No-Break">to-do items.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor155"/>Altering the to-do item data model</h2>
			<p>To link data models to our to-do items, we must alter our to-do data models. There are multiple <a id="_idIndexMarker714"/>ways in which we can do this. For instance, we can add a <strong class="source-inline">user_id</strong> field to the item table that is just the <strong class="source-inline">unique_id</strong> field of <a id="_idIndexMarker715"/>the user table. When we are creating a new item, we then pass the unique ID of the user into the item constructor. This is easy to implement; however, it does have risks. Merely passing the unique ID of the user into the item does not enforce that the ID of the user is valid and in the database. There is nothing stopping us from inserting an ID of a deleted user into the item constructor and thus inserting an orphaned item into the database. This will then be hard to extract later, as we have no reference to the user ID that the orphaned item is associated with. We can also create a new table that references the user’s ID with the item ID, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_7.2_B18722.jpg" alt="Figure 7.2 – A separate database table for logging item associations with users"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – A separate database table for logging item associations with users</p>
			<p>The advantage of this is that it is easy to decouple the users from the items by merely dropping the table. However, it also does not have valid user ID enforcement or item ID enforcement when creating a new entry. We will also have to make two queries, one to the association table and then another to the item table to get the items from the user. As the previous two methods of attaching a user ID column to the items table or creating a bridge table holding an item ID and user unique ID are easy to implement, we will not explore them; you should be able to implement them yourself at this point. In the context <a id="_idIndexMarker716"/>of the to-do application, the previous two methods would be subpar, as they offer us no benefits yet introduce the risk of <a id="_idIndexMarker717"/>errors when inserting data into our database. This does not mean that the two previous methods should never be used. The data needs for each project are different. In our project, we will create a foreign key to link our users to items, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_7.3_B18722.jpg" alt="Figure 7.3 – Foreign key association between our user and items"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Foreign key association between our user and items</p>
			<p>This does not allow us to access the items associated with a user with one database call, but we are only allowed to insert items that have a reference to a legitimate user ID in the database. Foreign keys can also trigger cascade events where, if we delete a user, this will automatically delete all existing items associated with the user to prevent orphan items from being created. We create a foreign key by declaring the link to the table with a macro. In <strong class="source-inline">models/item/item.rs</strong>, we can achieve this by initially having the <span class="No-Break">following imports:</span></p>
			<pre class="source-code">
use crate::schema::to_do;
use chrono::NaiveDateTime;
use super::super::user::user::User;</pre>
			<p>We can <a id="_idIndexMarker718"/>see that we must import the <strong class="source-inline">User</strong> struct, as we will be referencing it in the <strong class="source-inline">belongs_to</strong> macro to claim that our <strong class="source-inline">Item</strong> struct belongs to the <strong class="source-inline">User</strong> struct, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[derive(Queryable, Identifiable, Associations)]
#[belongs_to(User)]
#[table_name="to_do"]
pub struct Item {
    pub id: i32,
    pub title: String,
    pub status: String,
    pub date: NaiveDateTime,
    pub user_id: i32,
}</pre>
			<p>Here, we can see that we imported the user data model struct, defined it with a <strong class="source-inline">belongs_to</strong> macro, and added a <strong class="source-inline">user_id</strong> field to link the struct. Note that the <strong class="source-inline">belongs_to</strong> macro will not be callable if we do not include the <span class="No-Break"><strong class="source-inline">Associations</strong></span><span class="No-Break"> macro.</span></p>
			<p>One last <a id="_idIndexMarker719"/>thing we need to do is add the <strong class="source-inline">user_id</strong> field to the fields and constructor in the <strong class="source-inline">models/item/new_item.rs</strong> file. We need to do this so that we can link the new to-do item to the user creating the item. This can be achieved by using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use crate::schema::to_do;
use chrono::{NaiveDateTime, Utc};
#[derive(Insertable)]
#[table_name="to_do"]
pub struct NewItem {
    pub title: String,
    pub status: String,
    pub date: NaiveDateTime,
    pub user_id: i32,
}
impl NewItem {
    pub fn new(title: String, user_id: i32) -&gt; NewItem {
        let now = Utc::now().naive_local();
        NewItem{
            title, status: String::from("PENDING"),
            date: now,
            user_id
        }
    }
}</pre>
			<p>So, taking <a id="_idIndexMarker720"/>stock of what we have done, all our <a id="_idIndexMarker721"/>data model structs have been altered, and we are able to use them as and when we need them in the app when interacting with the database. However, we have not updated our database, and we have not updated the bridge connecting the app to the database. We will do <span class="No-Break">this next.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Updating the schema file</h2>
			<p>To make sure that the mapping from the data model struct to the database is up to date, we must <a id="_idIndexMarker722"/>update our schema with these changes. This means <a id="_idIndexMarker723"/>that we must alter the existing schema for the to-do item table and add a user schema to the <strong class="source-inline">src/schema.rs</strong> file. This is denoted by the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
table! {
    to_do (id) {
        id -&gt; Int4,
        title -&gt; Varchar,
        status -&gt; Varchar,
        date -&gt; Timestamp,
        user_id -&gt; Int4,
    }
}
table! {
    users (id) {
        id -&gt; Int4,
        username -&gt; Varchar,
        email -&gt; Varchar,
        password -&gt; Varchar,
        unique_id -&gt; Varchar,
    }
}</pre>
			<p>It must be noted that our fields in the schema file are defined in the same order as the Rust data models. This is important because, if we do not do this, the fields will be mismatched when we’re connecting to the database. We might also realize that our schema is merely just defining the fields and their type; it is not covering the relationship between the to-do table and the <span class="No-Break">user table.</span></p>
			<p>We do <a id="_idIndexMarker724"/>not have to worry about this because when <a id="_idIndexMarker725"/>we create and run our own migrations, this schema file will be updated with the relationship. This leads us to create our own migrations to complete this <span class="No-Break">schema file.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/>Creating and running migration scripts on the database</h2>
			<p>Running <a id="_idIndexMarker726"/>migrations has a similar process to what <a id="_idIndexMarker727"/>we covered in <a href="B18722_06.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Data Persistence with PostgreSQL</em>, which <a id="_idIndexMarker728"/>covered <a id="_idIndexMarker729"/>how to install the Diesel client and connect to the database. First, we must run our database with the <span class="No-Break"><strong class="source-inline">docker-compose</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
docker-compose up</pre>
			<p>We will need this running in the background when we run the migration. We can then create the migration scripts by running the <span class="No-Break">following command:</span></p>
			<pre class="console">
diesel migration generate create_users</pre>
			<p>This creates a directory in the migrations, which includes <strong class="source-inline">create_users</strong> in the username of the directory. Inside this directory, we have two blank <em class="italic">SQL</em> files. Here, we will manually write our own SQL scripts for the migrations. Initially, you might find this unnecessary, as there are libraries in other languages that automatically generate these migrations, but there are some advantages to <span class="No-Break">doing this.</span></p>
			<p>irst, it keeps our hand in SQL, which is another handy tool. This enables us to think about solutions that utilize SQL in the day-to-day problems that we are trying to solve. It also gives us more fine-grained control of how migrations flow. For instance, in the migration that we are going to create, we are going to have to create the user table and then a base user so that when we alter the column in the <strong class="source-inline">to_do</strong> table, we can fill it with the ID of the placeholder user row. We carry this out in our <strong class="source-inline">up.sql</strong> file with the following <span class="No-Break">table definition:</span></p>
			<pre class="source-code">
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR NOT NULL UNIQUE,
    email VARCHAR NOT NULL UNIQUE,
    password VARCHAR NOT NULL,
    unique_id VARCHAR NOT NULL
);</pre>
			<p>This is straightforward. Note that the <strong class="source-inline">email</strong> and <strong class="source-inline">username</strong> fields are unique. This is because we do not want users with duplicate usernames and emails. It’s good to put the constraint in at this level for several reasons. For instance, we could protect against this by doing a database call of the username and email and refusing to insert a new user if there <span class="No-Break">is duplication.</span></p>
			<p>However, there may be an error in the code, or someone might alter our code in the future. A new <a id="_idIndexMarker730"/>feature might be introduced <a id="_idIndexMarker731"/>that doesn’t have this check, such as <a id="_idIndexMarker732"/>an edit feature. There might <a id="_idIndexMarker733"/>be a migration that alters rows or inserts new users. It is usually best practice, if you are writing your own SQL, to ensure that you use the <strong class="source-inline">;</strong> symbol to indicate that the operation <span class="No-Break">has finished.</span></p>
			<p>This SQL command is fired, and then the next command is fired afterward. Our next command in the <strong class="source-inline">up.sql</strong> file inserts a placeholder user row with the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
 INSERT INTO users (username, email, password, unique_id)
VALUES ('placeholder', 'placeholder email',
'placeholder password', 'placeholder unique id');</pre>
			<p>Now that we have created our user, we then alter our <strong class="source-inline">to_do</strong> table. We can do this with the following command, in the same file under the previous command we <span class="No-Break">just wrote:</span></p>
			<pre class="source-code">
ALTER TABLE to_do ADD user_id integer default 1
CONSTRAINT user_id REFERENCES users NOT NULL;</pre>
			<p>With that, our <strong class="source-inline">up.sql</strong> migration has been defined. Now, we must define our <strong class="source-inline">down.sql</strong> migration. With the down migration, we basically must reverse what we did in the up migrations. This means dropping the <strong class="source-inline">user_id</strong> column in the <strong class="source-inline">to_do</strong> table and then dropping the user table entirely. This can be done with the following SQL code in the <span class="No-Break"><strong class="source-inline">down.sql</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
ALTER TABLE to_do DROP COLUMN user_id;
DROP TABLE users</pre>
			<p>We must keep in mind that Docker must be running for the migration to influence the database. Once this migration is run, we can see that the following code has been added to the <span class="No-Break"><strong class="source-inline">src/schema.rs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
joinable!(to_do -&gt; users (user_id));
allow_tables_to_appear_in_same_query!(
    to_do,
    users,
);</pre>
			<p>This enables <a id="_idIndexMarker734"/>our Rust data models <a id="_idIndexMarker735"/>to make queries concerning <a id="_idIndexMarker736"/>the relationship between users and <a id="_idIndexMarker737"/>to-do items. With this migration finished, we can run our app again. However, before we do that, there is just one slight alteration that we have to make in the <strong class="source-inline">src/views/to_do/create.rs</strong> file, where the constructor of the new item in the <strong class="source-inline">create</strong> view function adds the default user ID with the following line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
let new_post = NewItem::new(title, 1);</pre>
			<p>Running our app now will result in the same behavior we described in <a href="B18722_06.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Data Persistence with PostgreSQL</em>, in that our app is running with the migrations that we have made. However, we also need to see whether our constructor for the new user works as we hash the password and generate the <span class="No-Break">unique ID.</span></p>
			<p>To do this, we need to build a create user endpoint. For this, we must define the schema, and then a view that inserts that new user into the database. We can create our schema in the <strong class="source-inline">src/json_serialization/new_user.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use serde::Deserialize;
#[derive(Deserialize)]
pub struct NewUserSchema {
    pub name: String,
    pub email: String,
    pub password: String
}</pre>
			<p>After this, we <a id="_idIndexMarker738"/>can declare the new <a id="_idIndexMarker739"/>user schema in our <strong class="source-inline">src/json_serialization/mod.rs</strong> file with <strong class="source-inline">pub mod new_user;</strong>. Once our schema <a id="_idIndexMarker740"/>has been defined, we can create our <a id="_idIndexMarker741"/>own user view module with the following <span class="No-Break">file structure:</span></p>
			<pre class="source-code">
views
...
└── users
    ├── create.rs
    └── mod.rs</pre>
			<p>In our <strong class="source-inline">users/create.rs</strong> file, we need to build a create view function. First, import the <span class="No-Break">following crates:</span></p>
			<pre class="source-code">
use crate::diesel;
use diesel::prelude::*;
use actix_web::{web, HttpResponse, Responder};
use actix_web::HttpResponseBuilder;
use crate::database::DB;
use crate::json_serialization::new_user::NewUserSchema;
use crate::models::user::new_user::NewUser;
use crate::schema::users;</pre>
			<p>Since <a id="_idIndexMarker742"/>we have been building our views <a id="_idIndexMarker743"/>multiple times now, none of these <a id="_idIndexMarker744"/>imports should be surprising. We import <a id="_idIndexMarker745"/>the <strong class="source-inline">diesel</strong> macros and crate to enable us to make calls to the database. We then import the <strong class="source-inline">actix_web</strong> traits and structs to enable data to flow in and out of the view. We then import our schemas and structs to structure the data that we are receiving and processing. Now that we’ve imported the correct crates, we must define the <strong class="source-inline">create</strong> view function with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub async fn create(new_user: web::Json&lt;NewUserSchema&gt;,
                    db: DB) -&gt; impl Responder {
    . . .
}</pre>
			<p>Here, we can see that we accept JSON data that is loaded into the <strong class="source-inline">NewUserSchema</strong> struct. We also establish a database connection from the connection pool with the <strong class="source-inline">DB</strong> struct. Inside our <strong class="source-inline">create</strong> view function, we extract the data that we need from the <strong class="source-inline">NewUserSchema</strong> struct to create a <strong class="source-inline">NewUser</strong> struct with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let new_user = NewUser::new(
    new_user.name.clone(),
    new_user.email.clone(),
    new_user.password.clone()
);</pre>
			<p>We must clone the fields to be passed into the <strong class="source-inline">NewUser</strong> constructor because strings do not implement the <strong class="source-inline">Copy</strong> trait, meaning we must do this manually. We then create our <strong class="source-inline">insert</strong> command for the database and execute it with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let insert_result = diesel::insert_into(users::table)
                            .values(&amp;new_user)
                            .execute(&amp;db.connection);</pre>
			<p>This returns a <strong class="source-inline">Result</strong> struct. However, we do not unwrap it directly. There could be a conflict. For instance, we could be trying to insert a new user with a username or email that is already in the database. However, we do not want this to just error out. This is an edge case <a id="_idIndexMarker746"/>that we will expect as we <a id="_idIndexMarker747"/>have implemented the unique <a id="_idIndexMarker748"/>username and email constraint ourselves. If there <a id="_idIndexMarker749"/>was a legitimate error that happens when the view is being executed, we need to know about it. Therefore, we must give response codes to the edge cases. Therefore, we match the result of the insert and return the appropriate response code with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
match insert_result {
    Ok(_) =&gt; HttpResponse::Created(),
    Err(_) =&gt; HttpResponse::Conflict()
}</pre>
			<p>Here, we have established a database connection, extracted the fields from the JSON body, created a new <strong class="source-inline">NewUser</strong> struct, and then inserted it into the database. There is a slight difference here compared to the other views. In the return response, we are having to <em class="italic">await</em> and then <em class="italic">unwrap</em> it. This is because we are not returning a JSON body. Therefore, <strong class="source-inline">HttpResponse::Ok()</strong> is merely a <span class="No-Break">builder struct.</span></p>
			<p>Now that we have built our create view, we need to define our view factory in the <strong class="source-inline">views/users/mod.rs</strong> file, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
mod create;
use actix_web::web::{ServiceConfig, post, scope};
pub fn user_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
        scope("v1/user")
        .route("create", post().to(create::create))
    );
}</pre>
			<p>Again, since <a id="_idIndexMarker750"/>we have been building views regularly, none <a id="_idIndexMarker751"/>of this should come as a surprise <a id="_idIndexMarker752"/>to you. If it does, it is recommended <a id="_idIndexMarker753"/>that you read the <em class="italic">Managing views using the Actix Web framework</em> section in <a href="B18722_03.xhtml#_idTextAnchor059"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Handling HTTP Requests</em>, for clarity. Now, our main views factory in the <strong class="source-inline">views/mod.rs</strong> file should look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
mod auth;
mod to_do;
mod app;
mod users;
use auth::auth_views_factory;
use to_do::to_do_views_factory;
use app::app_views_factory;
use users::user_views_factory;
use actix_web::web::ServiceConfig;
pub fn views_factory(app: &amp;mut ServiceConfig) {
    auth_views_factory(app);
    to_do_views_factory(app);
    app_views_factory(app);
    user_views_factory(app);
}</pre>
			<p>Now that <a id="_idIndexMarker754"/>we have registered our <a id="_idIndexMarker755"/>user view, we can run our app and <a id="_idIndexMarker756"/>create our user with the following <a id="_idIndexMarker757"/><span class="No-Break">Postman call:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_7.4_B18722.jpg" alt="Figure 7.4 – Postman call to our create user endpoint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Postman call to our create user endpoint</p>
			<p>With this, we should get a <strong class="source-inline">201</strong> created response. If we call the exact same call again, we should get a <strong class="source-inline">409</strong> conflict. With this, we should expect that our new user has been created. With the steps covered in the <em class="italic">Connecting to PostgreSQL with Diesel</em> section in <a href="B18722_06.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Data Persistence with PostgreSQL</em>, we can inspect the database in our Docker container, which gives us the <span class="No-Break">following printout:</span></p>
			<pre class="console">
 id |    name     |       email
----+-------------+-------------------
  1 | placeholder | placeholder email
  2 | maxwell     | test@gmail.com
                           password
-------------------------------------------------------------
 placeholder password
 $2b$12$jlfLwu4AHjrvTpZrB311Y.W0JulQ71WVy2g771xl50e5nS1UfqwQ.
              unique_id
--------------------------------------
 placeholder unique id
 543b7aa8-e563-43e0-8f62-55211960a604</pre>
			<p>Here, we can see the initial user that was created in our migration. However, we can also see <a id="_idIndexMarker758"/>the user we created via our view. Here, we have <a id="_idIndexMarker759"/>a hashed password and a unique ID. From <a id="_idIndexMarker760"/>this, we can see that <a id="_idIndexMarker761"/>we should never directly create our user; we should only create a user through the constructor function belonging to the <span class="No-Break"><strong class="source-inline">NewUser</strong></span><span class="No-Break"> struct.</span></p>
			<p>In the context of our app, we do not really need a unique ID. However, in wider situations where multiple servers and databases are used, a unique ID can become useful. We also must note that our conflict response on the second one was correct; the third replica create user call, did not insert a replica user into <span class="No-Break">the database.</span></p>
			<p>With this, our app is running as normal, since there is now a user table with user models linked to the to-do items. Thus, we can create other data tables with relationships and structure <a id="_idIndexMarker762"/>migrations so that they <a id="_idIndexMarker763"/>can be seamlessly upgraded <a id="_idIndexMarker764"/>and downgraded. We have also covered <a id="_idIndexMarker765"/>how to verify and create passwords. However, we have not actually written any code that checks whether the user is passing the right credentials. In the next section, we will work on authenticating users and rejecting requests that do not contain the <span class="No-Break">right credentials.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor158"/>Authenticating our users</h1>
			<p>When it comes to authenticating our users, we have built a struct that extracts a message <a id="_idIndexMarker766"/>from the header of the HTTP request. We are now at the stage where we can make real use of this extraction by storing data about the user in the header. Right now, there is nothing stopping us from storing the username, ID, and password in the header of each HTTP request so that we can authenticate each one. However, this is a terrible practice. If someone intercepts the request or gets hold of the data stored in the browser to facilitate this, then the account is compromised and the hacker can do whatever they want. Instead, we are going to obfuscate the data, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_7.5_B18722.jpg" alt="Figure 7.5 – Steps for authenticating requests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Steps for authenticating requests</p>
			<p>In <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.5</em>, we can see that we use a secret key to serialize the structured data that we have on the user into a token that is in bytes. We then give the token to the user to store in the browser. When the user wants to make an authorized request, the user must send <a id="_idIndexMarker767"/>the token in the header of the request. Our server then uses the secret key to deserialize the token back into structured data about the user. The algorithms used to do this process are standard hashing algorithms that are available to anyone. Therefore, we have a secret key that we define to keep the tokens out in the wild safe. For our application to carry out the processes laid out in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.5</em>, we are going to have to rewrite most of our <strong class="source-inline">src/jwt.rs</strong> file, including the <strong class="source-inline">JwToken</strong> struct. Before we start, we need to update our <strong class="source-inline">Cargo.toml</strong> dependencies with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
[dependencies]
. . .
chrono = {version = "0.4.19", features = ["serde"]}
. . .
jsonwebtoken = "8.1.0"</pre>
			<p>We can see that we have added the <strong class="source-inline">serde</strong> features to the <strong class="source-inline">chrono</strong> crate and added the <strong class="source-inline">jsonwebtoken</strong> crate. To rebuild the <strong class="source-inline">JwToken</strong> struct, we need to import the following in the <span class="No-Break"><strong class="source-inline">src/jwt.rs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
use actix_web::dev::Payload;
use actix_web::{Error, FromRequest, HttpRequest};
use actix_web::error::ErrorUnauthorized;
use futures::future::{Ready, ok, err};
use serde::{Deserialize, Serialize};
use jsonwebtoken::{encode, decode, Algorithm, Header,
                   EncodingKey, DecodingKey, Validation};
use chrono::{DateTime, Utc};
use chrono::serde::ts_seconds;
use crate::config::Config;</pre>
			<p>We can see <a id="_idIndexMarker768"/>that we import <strong class="source-inline">actix_web</strong> traits and structs to enable the processing of the requests and responses. We then import <strong class="source-inline">futures</strong> to enable us to handle the interception of the HTTP request before it hits the views. We then import <strong class="source-inline">serde</strong> and <strong class="source-inline">jsonwebtoken</strong> to enable the serialization and deserialization of data to and from the token. We then import the <strong class="source-inline">chrono</strong> crate because we want to log when these tokens are minted. We also need to have the key for the serialization, and we get this from the config file, which is why we import the <strong class="source-inline">Config</strong> struct. Now that we have imported all the traits and structs that we need, we can write our token struct with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[derive(Debug, Serialize, Deserialize)]
pub struct JwToken {
    pub user_id: i32,
    #[serde(with = "ts_seconds")]
    pub minted: DateTime&lt;Utc&gt;
}</pre>
			<p>Here, we can see that we have the ID of the user, and we also have the date-time of when the token was created. We also decorate our <strong class="source-inline">minted</strong> field with a <strong class="source-inline">serde</strong> macro to state how <a id="_idIndexMarker769"/>we are going to serialize the <strong class="source-inline">datetime</strong> field. Now that we have the data that we need for the token, we can move on to defining the serialization functions with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
impl JwToken {
    pub fn get_key() -&gt; String {
        . . .
    }
    pub fn encode(self) -&gt; String {
        . . .
    }
    pub fn new(user_id: i32) -&gt; Self {
        . . .
    }
    pub fn from_token(token: String) -&gt; Option&lt;Self&gt; {
        . . .
    }
}</pre>
			<p>We can explain what each one of the preceding functions does with the following <span class="No-Break">bullet points:</span></p>
			<ul>
				<li><strong class="source-inline">get_key</strong>: Gets the secret key for the serialization and deserialization from the <span class="No-Break"><strong class="source-inline">config.yml</strong></span><span class="No-Break"> file.</span></li>
				<li><strong class="source-inline">encode</strong>: Encodes the data from the <strong class="source-inline">JwToken</strong> struct as <span class="No-Break">a token</span></li>
				<li><strong class="source-inline">new</strong>: Creates a new <span class="No-Break"><strong class="source-inline">JwToken</strong></span><span class="No-Break"> struct</span></li>
				<li><strong class="source-inline">from_token</strong>: Creates a <strong class="source-inline">JwToken</strong> struct from a token. If there is a failure in the deserialization it returns a <strong class="source-inline">None</strong> as there can be failures <span class="No-Break">in deserialization.</span></li>
			</ul>
			<p>Once we have <a id="_idIndexMarker770"/>built the preceding functions, our <strong class="source-inline">JwToken</strong> struct will be able to handle tokens as and when we see fit. We flesh out the <strong class="source-inline">get_key</strong> function with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub fn get_key() -&gt; String {
    let config = Config::new();
    let key_str = config.map.get("SECRET_KEY")
                            .unwrap().as_str()
                            .unwrap();
    return key_str.to_owned()
}</pre>
			<p>Here, we can see that we load the key from the config file. Therefore, we need to add the key to the <strong class="source-inline">config.yml</strong> file, resulting in our file looking <span class="No-Break">like this:</span></p>
			<pre class="source-code">
DB_URL: postgres://username:password@localhost:5433/to_do
SECRET_KEY: secret</pre>
			<p>If our server is in production, we should have a better secret key. However, for local development, this will work fine. Now that we are extracting the key from the config file, we can define our <strong class="source-inline">encode</strong> function with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub fn encode(self) -&gt; String {
    let key = EncodingKey::
              from_secret(JwToken::get_key().as_ref());
    let token = encode(&amp;Header::default(), &amp;self,
                       &amp;key).unwrap();
    return token
}</pre>
			<p>Here, we can see <a id="_idIndexMarker771"/>that we have defined an encoding key using the secret key from the config file. We then use this key to encode the data from the <strong class="source-inline">JwToken</strong> struct into a token and return it. Now that we can encode our <strong class="source-inline">JwToken</strong> struct, we will need to create new <strong class="source-inline">JwToken</strong> structs when we need them, which can be achieved by the following <span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
pub fn new(user_id: i32) -&gt; Self {
    let timestamp = Utc::now();
    return JwToken { user_id, minted: timestamp};
}</pre>
			<p>With the constructor, we know when our <strong class="source-inline">JwToken</strong> is minted. This can help us manage our user sessions if we want. For instance, if the token’s age exceeds a threshold that we deem appropriate, we can force <span class="No-Break">another login.</span></p>
			<p>Now, all we have is the <strong class="source-inline">from_token</strong> function, where we extract the data from a token using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub fn from_token(token: String) -&gt; Option&lt;Self&gt; {
    let key = DecodingKey::from_secret(
                JwToken::get_key().as_ref()
              );
    let token_result = decode::&lt;JwToken&gt;(
                        &amp;token, &amp;key,
                        &amp;Validation::new(Algorithm::HS256)
                        );
    match token_result {
        Ok(data) =&gt; {
            Some(data.claims)
        },
        Err(_) =&gt; {
            return None
        }
    }
}</pre>
			<p>Here, we define <a id="_idIndexMarker772"/>a decoding key and then use it to decode the token. We then return <strong class="source-inline">JwToken</strong> using <strong class="source-inline">data.claims</strong>. Now, our <strong class="source-inline">JwToken</strong> struct can be created, encoded into a token, and extracted from a token. Now, all we need to do is extract it from the header of an HTTP request before the view is loaded, using the <span class="No-Break">following outline:</span></p>
			<pre class="source-code">
impl FromRequest for JwToken {
    type Error = Error;
    type Future = Ready&lt;Result&lt;JwToken, Error&gt;&gt;;
    fn from_request(req: &amp;HttpRequest,
                    _: &amp;mut Payload) -&gt; Self::Future {
        . . .
    }
}</pre>
			<p>We have implemented the <strong class="source-inline">FromRequest</strong> trait multiple times now for the database connection <a id="_idIndexMarker773"/>and the previous implementation for the <strong class="source-inline">JwToken</strong> struct. Inside the <strong class="source-inline">from_request</strong> function, we extract the token from the header with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
match req.headers().get("token") {
    Some(data) =&gt; {
        . . .
    },
    None =&gt; {
        let error = ErrorUnauthorized(
                    "token not in header under key 'token'"
                    );
        return err(error)
    }
}</pre>
			<p>If the token is not in the header, we directly return <strong class="source-inline">ErrorUnauthorized</strong>, avoiding the call to the view completely. If we manage to extract the token from the header, we can process it with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
Some(data) =&gt; {
    let raw_token = data.to_str()
                        .unwrap()
                        .to_string();
    let token_result = JwToken::from_token(
                                raw_token
                            );
    match token_result {
        Some(token) =&gt; {
            return ok(token)
        },
        None =&gt; {
            let error = ErrorUnauthorized(
                            "token can't be decoded"
                        );
            return err(error)
        }
    }
},</pre>
			<p>Here, we convert <a id="_idIndexMarker774"/>the raw token extracted from the header to a string. We then deserialize the token and load it into the <strong class="source-inline">JwToken</strong> struct. However, if this fails due to a fake token being supplied, we return an <strong class="source-inline">ErrorUnauthorized</strong> error. Our authentication is now fully working; however, we will not be able to do anything because we do not have a valid token, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_7.6_B18722.jpg" alt="Figure 7.6 – Authentication blocking requests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Authentication blocking requests</p>
			<p>In the <a id="_idIndexMarker775"/>next section, we will build login API endpoints to enable us to interact with our <span class="No-Break">protected endpoints.</span></p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor159"/>Managing user sessions</h1>
			<p>For our users, we are going to have to enable them to log in. This means that we must create an <a id="_idIndexMarker776"/>endpoint to check their credentials and then generate a JWT to be returned to the user in the frontend, via the header in the response. Our first step is to define a login schema in the <strong class="source-inline">src/json_serialization/login.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use serde::Deserialize;
#[derive(Deserialize)]
pub struct Login {
    pub username: String,
    pub password: String
}</pre>
			<p>We have to remember to register it in the <strong class="source-inline">src/json_serialization/mod.rs</strong> file with the <strong class="source-inline">pub mod login;</strong> line of code. Once we have done this, we can build our login endpoint. We can do this by editing the <strong class="source-inline">src/views/auth/login.rs</strong> file we created in the <em class="italic">Managing views using the Actix Web framework</em> section in <a href="B18722_03.xhtml#_idTextAnchor059"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Handling HTTP Requests</em>, which declares our basic login view. This just returns <span class="No-Break">a string.</span></p>
			<p>Now, we can start <a id="_idIndexMarker777"/>refactoring this view by defining the required imports, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use crate::diesel;
use diesel::prelude::*;
use actix_web::{web, HttpResponse, Responder};
use crate::database::DB;
use crate::models::user::user::User;
use crate::json_serialization::login::Login;
use crate::schema::users;
use crate::jwt::JwToken;</pre>
			<p>At this stage, we can glance at the imports and get a feel for what we are going to do. We are going to extract the username and password from the body. We are then going to connect to the database to check the user and password, and then use the <strong class="source-inline">JwToken</strong> struct to create the token that will be passed back to the user. We can initially lay out the outline of the view with the following code in the <span class="No-Break">same file:</span></p>
			<pre class="source-code">
. . .
Use std::collections::HashMap;
pub async fn login(credentials: web::Json&lt;Login&gt;,
                   db: DB) -&gt; impl HttpResponse {
    . . .
}</pre>
			<p>Here, we can see that we accept the login credentials from the body of the incoming request and prepare a database connection from the connection pool for the view. We can then extract <a id="_idIndexMarker778"/>the details we need from the request body and make a database call with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let password = credentials.password.clone();
let users = users::table
    .filter(users::columns::username.eq(
        credentials.username.clone())
    ).load::&lt;User&gt;(&amp;db.connection).unwrap();</pre>
			<p>Now, we must check to see whether we got what we expected from the database call with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
if users.len() == 0 {
    return HttpResponse::NotFound().await.unwrap()
} else if users.len() &gt; 1 {
    return HttpResponse::Conflict().await.unwrap()
}</pre>
			<p>Here, we have done some early returns. If there are no users, then we return a <strong class="source-inline">not found</strong> response code. This is something we will expect from time to time. However, if there is more than one user with that username, we need to return a <span class="No-Break">different code.</span></p>
			<p>Due to the unique constraints shown, something is very wrong. A migration script in the future might undo these unique constraints, or the user query might be altered by accident. If this happens, we need to know that this has happened right away, since corrupted data that goes against our constraints can cause our application to behave in unexpected ways that can be hard <span class="No-Break">to troubleshoot.</span></p>
			<p>Now that we have checked that the right number of users have been retrieved, we can get the one and only user at index zero with confidence and check whether their password is passable, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
match users[0].verify(password) {
    true =&gt; {
        let token = JwToken::new(users[0].id);
        let raw_token = token.encode();
        let mut body = HashMap::new();
      body.insert("token", raw_token);
        HttpResponse::Ok().json(body)
    },
    false =&gt; HttpResponse::Unauthorized()
}</pre>
			<p>Here, we can see that we used the <strong class="source-inline">verify</strong> function. If the password is a match, we then generate <a id="_idIndexMarker779"/>a token using the ID and return it to the user in the body. If the password is not correct, we return an unauthorized <span class="No-Break">code instead.</span></p>
			<p>In terms of our logout, we are going to take a far more lightweight approach. All we must do in our logout view is run two lines of JavaScript code. One is to remove the user token from the local storage and then revert the user to the main view. HTML can just host JavaScript that gets run as soon as you open it. Therefore, we can achieve this by putting the following code in the <span class="No-Break"><strong class="source-inline">src/views/auth/logout.rs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
use actix_web::HttpResponse;
pub async fn logout() -&gt; HttpResponse {
    HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body("&lt;html&gt;\
                &lt;script&gt;\
                    localStorage.removeItem('user-token'); \
                    window.location.replace(
                        document.location.origin);\
                &lt;/script&gt;\
              &lt;/html&gt;")
}</pre>
			<p>Since this <a id="_idIndexMarker780"/>view is already registered, we can run the app and make the call <span class="No-Break">with Postman:</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_7.7_B18722.jpg" alt="Figure 7.7 – Logging into our application using the login endpoint with Postman"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Logging into our application using the login endpoint with Postman</p>
			<p>Altering the username will give us a <strong class="source-inline">404-response</strong> code, whereas altering the password will give us a <strong class="source-inline">401-response</strong> code. If we have the correct username and password, we will get a <strong class="source-inline">200-response</strong> code and there will be a <em class="italic">token</em> in the response of <a id="_idIndexMarker781"/>the header, as shown in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.7</em>. However, if we want to use our <em class="italic">token</em> in the response header, we will get a <strong class="source-inline">token can't be decoded</strong> message. In the next section, we are going to clean up our <span class="No-Break">authentication requirements.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/>Cleaning up authentication requirements</h1>
			<p>In this section, we are going to clean up our Rust server in terms of authentication before we <a id="_idIndexMarker782"/>start configuring our frontend to handle these authentication processes. To keep the flow of the chapter engaging, we have not regularly carried out “housekeeping.” Now, we are going to update our <strong class="source-inline">to_do</strong> views. We can start by updating the <strong class="source-inline">create</strong> view with authentication requirements. To do so, the function signature of our <strong class="source-inline">create</strong> view in the <strong class="source-inline">src/views/to_do/create.rs</strong> file should look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
. . .
use crate::jwt::JwToken;
use crate::database::DB
pub async fn create(token: JwToken,
                    req: HttpRequest, db: DB) -&gt; HttpResponse {
    . . .</pre>
			<p>We also must update the user ID when creating a new item with the ID from the token, using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
if items.len() == 0 {
    let new_post = NewItem::new(title, token.user_id);
    let _ = diesel::
            insert_into(to_do::table).values(&amp;new_post)
        .execute(&amp;db.connection);
}
Return HttpResponse::Ok().json(
    ToDoItems::get_state(token.user_id)
)</pre>
			<p>With our <strong class="source-inline">delete</strong> view, we must ensure that we are deleting a to-do item that belongs to the user making the request. If we do not add a filter using the user ID, the deletion of the to-do <a id="_idIndexMarker783"/>item will be random. This filter can be added in our <strong class="source-inline">src/views/to_do/delete.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
. . .
Use crate::database::DB;
. . .
pub async fn delete(to_do_item: web::Json&lt;ToDoItem&gt;,
                    token: JwToken, db: DB) -&gt; HttpResponse {
    let items = to_do::table
        .filter(to_do::columns::title.eq(
                    &amp;to_do_item.title.as_str())
                )
        .filter(to_do::columns::user_id.eq(&amp;token.user_id))
        .order(to_do::columns::id.asc())
        .load::&lt;Item&gt;(&amp;db.connection)
        .unwrap();
    let _ = diesel::delete(&amp;items[0]).execute(&amp;db.connection);
    return HttpResponse::Ok().json(ToDoItems::get_state(
        token.user_id
    ))
}</pre>
			<p>We can see that the <strong class="source-inline">filter</strong> functions can merely be chained when making a database query. Considering what we have done with our <strong class="source-inline">delete</strong> view, how do you think we will upgrade <a id="_idIndexMarker784"/>our authentication requirements for our <strong class="source-inline">edit</strong> in the <strong class="source-inline">src/views/to_do/edit.rs</strong> file? At this stage, I encourage you to try and update the <strong class="source-inline">edit</strong> view yourself, as the approach is like our <strong class="source-inline">delete</strong> view upgrade. Once you have done this, your <strong class="source-inline">edit</strong> view should look like the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub async fn edit(to_do_item: web::Json&lt;ToDoItem&gt;,
                  token: JwToken, db: DB) -&gt; HttpResponse {
    let results = to_do::table.filter(to_do::columns::title
                              .eq(&amp;to_do_item.title))
                              .filter(to_do::columns::user_
                                      id
                              .eq(&amp;token.user_id));
    let _ = diesel::update(results)
        .set(to_do::columns::status.eq("DONE"))
        .execute(&amp;db.connection);
    return HttpResponse::Ok().json(ToDoItems::get_state(
                                   token.user_id
    ))
}</pre>
			<p>Now that we have updated our specific views, we can now move on to the <strong class="source-inline">get</strong> view, which also has the <strong class="source-inline">get_state</strong> function that is applied to all other views. Our <strong class="source-inline">get</strong> view in the <strong class="source-inline">src/views/to_do/get.rs</strong> file now takes the <span class="No-Break">following form:</span></p>
			<pre class="source-code">
use actix_web::Responder;
use crate::json_serialization::to_do_items::ToDoItems;
use crate::jwt::JwToken;
pub async fn get(token: JwToken) -&gt; impl Responder {
    ToDoItems::get_state(token.user_id)
}</pre>
			<p>Now, everything in the preceding code should not be a surprise. We can see that we pass the <a id="_idIndexMarker785"/>user ID into the <strong class="source-inline">ToDoItems::get_state</strong> function. You must remember to fill in the user ID everywhere the <strong class="source-inline">ToDoItems::get_state</strong> function is implemented, which is all the to-do views. We can then redefine our <strong class="source-inline">ToDoItems::get_state</strong> function in the <strong class="source-inline">src/json_serialization/to_do_items.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
. . .
use crate::database::DBCONNECTION;
. . .
impl ToDoItems {
    . . .
    pub fn get_state(user_id: i32) -&gt; ToDoItems {
        let connection = DBCONNECTION.db_connection.get()
                         .unwrap();
        let items = to_do::table
                    .filter(to_do::columns::user_id.eq
                           (&amp;user_id))
                    .order(to_do::columns::id.asc())
                    .load::&lt;Item&gt;(&amp;connection)
                    .unwrap();
        let mut array_buffer = Vec::
                               with_capacity(items.len());
        for item in items {
            let status = TaskStatus::from_string(
            &amp;item.status.as_str().to_string());
            let item = to_do_factory(&amp;item.title, status);
            array_buffer.push(item);
        }
        return ToDoItems::new(array_buffer)
    }
}</pre>
			<p>Here, we can see that we have updated the database connection and the filter for the user ID. We have now updated our code to accommodate different users. There is one more change <a id="_idIndexMarker786"/>that we must make. Because we will be writing frontend code in our React application, we will try and keep the React coding as simple as possible, as React development is a book itself. To avoid over-complicating the frontend development of header extraction and <strong class="source-inline">GET</strong> posts using Axios, we will add a <strong class="source-inline">Post</strong> method to our login and return the token using the body. This is another good opportunity to try and solve this yourself, as we have covered all the concepts needed to pull <span class="No-Break">this off.</span></p>
			<p>If you have attempted to solve this problem yourself, it should look like the following. First, we define a response struct in the <strong class="source-inline">src/json_serialization/login_response.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use serde::Serialize;
#[derive(Serialize)]
pub struct LoginResponse {
    pub token: String
}</pre>
			<p>We remember <a id="_idIndexMarker787"/>to declare the preceding struct by putting in <strong class="source-inline">pub mod login_response</strong> in the <strong class="source-inline">src/json_serialization/mod.rs</strong> file. We now go to our <strong class="source-inline">src/views/auth/login.rs</strong> and have the following <strong class="source-inline">return</strong> statement in the <span class="No-Break"><strong class="source-inline">login</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
match users[0].clone().verify(credentials.password.clone()) {
    true =&gt; {
        let user_id = users[0].clone().id;
        let token = JwToken::new(user_id);
        let raw_token = token.encode();
        let response = LoginResponse{token:
                                     raw_token.clone()};
        let body = serde_json::
                   to_string(&amp;response).unwrap();
        HttpResponse::Ok().append_header(("token",
                           raw_token)).json(&amp;body)
    },
    false =&gt; HttpResponse::Unauthorized().finish()
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">You may have noticed that we made a slight change to our unauthorized to <span class="No-Break">the following:</span></p>
			<p class="callout"><span class="No-Break"><strong class="bold">HttpResponse::Unauthorized().finish()</strong></span></p>
			<p class="callout">This is because we have switched our <strong class="source-inline">return</strong> type for the view function to an <strong class="source-inline">HttpResponse</strong> struct giving us the following <span class="No-Break">function signature:</span></p>
			<p class="callout"><strong class="bold">(credentials: web::Json&lt;Login&gt;, db: DB) -&gt; </strong><span class="No-Break"><strong class="bold">HttpResponse</strong></span></p>
			<p class="callout">We had to make the switch because adding the <strong class="source-inline">json</strong> function to our response turns our response from <strong class="source-inline">HttpResponseBuilder</strong> to <strong class="source-inline">HttpResponse</strong>. Once the <strong class="source-inline">json</strong> function has been called, <strong class="source-inline">HttpResponseBuilder</strong> cannot be used. Going back to the unauthored response builder, we can deduce that the <strong class="source-inline">finish</strong> function converts <strong class="source-inline">HttpResponseBuilder</strong> to <strong class="source-inline">HttpResponse</strong>. We can also convert our <strong class="source-inline">HttpResponseBuilder</strong> to <strong class="source-inline">HttpResponse</strong> by using <strong class="source-inline">await</strong>, as shown in the <span class="No-Break">following code:</span></p>
			<p class="callout"><span class="No-Break"><strong class="bold">HttpResponse::Unauthorized().await.unwrap()</strong></span></p>
			<p>Here, we can <a id="_idIndexMarker788"/>see that we return the token in the header and the body. This will give us flexibility and ease when writing the frontend code. However, it must be stressed that this is not the best practice. We are implementing the approach of passing the token back into the body and header to keep the frontend development section simple. We can then enable the <strong class="source-inline">POST</strong> method for our login view in our <strong class="source-inline">src/views/auth/mod.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
mod login;
mod logout;
use actix_web::web::{ServiceConfig, get, post, scope};
pub fn auth_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
            scope("v1/auth")
            .route("login", get().to(login::login))
            .route("login", post().to(login::login))
            .route("logout", get().to(logout::logout))
    );
}</pre>
			<p>We can see that we have merely stacked a <strong class="source-inline">get</strong> function onto the same <strong class="source-inline">login</strong> view. Now, <strong class="source-inline">POST</strong> and <strong class="source-inline">GET</strong> are available for our login view. We can now move into the next section where <a id="_idIndexMarker789"/>we configure our authentication tokens so they can expire. We want our tokens to expire to increase our security. If a token is compromised and a bad actor gets hold of a token, they will be able to do whatever they want for as long as they want without ever having to log in. However, if our tokens expire, then the bad actor only has a limited time window before the <span class="No-Break">token expires.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor161"/>Configuring expiration of auth tokens</h1>
			<p>If we try and perform an API call on our now protected endpoints with a valid token obtained <a id="_idIndexMarker790"/>from logging in with the token in the header, we will get an unauthorized error. If we insert some <strong class="source-inline">print</strong> statements, we will get the following error when failing to decode <span class="No-Break">the token:</span></p>
			<pre class="console">
missing required claim: exp</pre>
			<p>This implies that there is no field called <strong class="source-inline">exp</strong> in our <strong class="source-inline">JwToken</strong> struct. If we reference the <strong class="source-inline">jsonwebtoken</strong> documentation at <a href="https://docs.rs/jsonwebtoken/latest/jsonwebtoken/fn.encode.html">https://docs.rs/jsonwebtoken/latest/jsonwebtoken/fn.encode.html</a>, we can see that the <strong class="source-inline">encode</strong> instructions never <span class="No-Break">mention </span><span class="No-Break"><strong class="source-inline">exp</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
use serde::{Deserialize, Serialize};
use jsonwebtoken::{encode, Algorithm, Header, EncodingKey};
#[derive(Debug, Serialize, Deserialize)]
struct Claims {
   sub: String,
   company: String
}
let my_claims = Claims {
    sub: "b@b.com".to_owned(),
    company: "ACME".to_owned()
};
// my_claims is a struct that implements Serialize
// This will create a JWT using HS256 as algorithm
let token = encode(&amp;Header::default(), &amp;my_claims,
&amp;EncodingKey::from_secret("secret".as_ref())).unwrap();</pre>
			<p>Here, we can see that there is no mention of claims. However, what is happening is that when we <a id="_idIndexMarker791"/>try and deserialize our token, the <strong class="source-inline">decode</strong> function in the <strong class="source-inline">jsonwebtoken</strong> crate is automatically looking for the <strong class="source-inline">exp</strong> field to work out when the token is supposed to be expired. We are exploring this because the official documentation and slightly confusing error message could leave you wasting hours trying to figure out what is going on. With this in mind, we must go back to our <strong class="source-inline">src/jwt.rs</strong> file for some more rewriting, but this is the last time, I promise, and it is not an entire rewrite. First, we ensure that the following is imported alongside what is already in the <span class="No-Break"><strong class="source-inline">src/jwt.rs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
. . .
use jsonwebtoken::{encode, decode, Header,
                   EncodingKey, DecodingKey,
                   Validation};
use chrono::Utc;
. . .</pre>
			<p>We can then make sure our <strong class="source-inline">JwToken</strong> struct is written with the <strong class="source-inline">exp</strong> field with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[derive(Debug, Serialize, Deserialize)]
pub struct JwToken {
    pub user_id: i32,
    pub exp: usize,
}</pre>
			<p>We now must rewrite the <strong class="source-inline">new</strong> constructor method for our <strong class="source-inline">JwToken</strong> struct. In the <strong class="source-inline">new</strong> function, we will have to define at what time the newly minted <strong class="source-inline">JwToken</strong> struct has expired. This must vary; as a developer, you might want to tweak the time taken to timeout. Remember <a id="_idIndexMarker792"/>that we must recompile every time we change the Rust code; therefore, it makes sense to have the timeout period defined in the config file. With the variance of timeout considered, our <strong class="source-inline">new</strong> function takes the <span class="No-Break">following form:</span></p>
			<pre class="source-code">
pub fn new(user_id: i32) -&gt; Self {
    let config = Config::new();
    let minutes = config.map.get("EXPIRE_MINUTES")
                            .unwrap().as_i64().unwrap();
    let expiration = Utc::now()
    .checked_add_signed(chrono::Duration::minutes(minutes))
                            .expect("valid timestamp")
                            .timestamp();
    return JwToken { user_id, exp: expiration as usize };
}</pre>
			<p>We can see that we define the number of minutes. We then convert our expiration as <strong class="source-inline">usize</strong> and then build our <strong class="source-inline">JwToken</strong> struct. Now that we have this, we need to be more specific with the type of error that we return, as it could be an error in the decoding <a id="_idIndexMarker793"/>of the token, or the token could be expired. We handle the different types of errors when decoding the token with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub fn from_token(token: String) -&gt; Result&lt;Self, String&gt; {
    let key = DecodingKey::
              from_secret(JwToken::get_key().as_ref());
    let token_result = decode::&lt;JwToken&gt;(&amp;token.as_str(),
                              &amp;key,&amp;Validation::default());
    match token_result {
        Ok(data) =&gt; {
            return Ok(data.claims)
        },
        Err(error) =&gt; {
            let message = format!("{}", error);
            return Err(message)
        }
    }
}</pre>
			<p>Here, we can see that we have switched from returning <strong class="source-inline">Option</strong> to <strong class="source-inline">Result</strong>. We have switched to <strong class="source-inline">Result</strong> because we are returning the message that can be digested and processed in our <strong class="source-inline">from_request</strong> function in the <strong class="source-inline">FromRequest</strong> trait implementation. The rest of the code in the <strong class="source-inline">from_request</strong> function is the same. Where we make the change is checking the message if there is an error and returning a different message to the frontend with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
fn from_request(req: &amp;HttpRequest,
                _: &amp;mut Payload) -&gt; Self::Future {
    match req.headers().get("token") {
        Some(data) =&gt; {
            let raw_token = data.to_str()
                                .unwrap()
                                .to_string();
            let token_result = JwToken::
                        from_token(raw_token);
            match token_result {
                Ok(token) =&gt; {
                    return ok(token)
                },
                Err(message) =&gt; {
                    if message == "ExpiredSignature"
                                  .to_owned() {
                        return err(
                        ErrorUnauthorized("token expired"))
                    }
                    return err(
                    ErrorUnauthorized("token can't be decoded"))
                }
            }
        },
        None =&gt; {
            return err(
            ErrorUnauthorized(
            "token not in header under key 'token'"))
        }
    }
}</pre>
			<p>With the nuanced error message, our frontend code can handle and adapt, as we can be more specific on how we handle the errors in the frontend. Being more specific in the frontend <a id="_idIndexMarker794"/>can aid the user, prompting them where they went wrong. However, when it comes to authentication, make sure you do not give too much away because this can also aid bad actors trying to obtain unauthorized access. We now have our login and logout endpoints running; we also have token authorization on the views that we need. However, this is not very useful if we want a standard user to interact with our application, as they are unlikely to use Postman. Therefore, we are going to have to incorporate our login/logout endpoints in the frontend in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor162"/>Adding authentication into our frontend</h1>
			<p>We incorporate <a id="_idIndexMarker795"/>our login functionality. We must start off by building the login form in the <strong class="source-inline">src/components/LoginForm.js</strong> file. First, we import <span class="No-Break">the following:</span></p>
			<pre class="source-code">
import React, {Component} from 'react';
import axios from 'axios';
import '../css/LoginForm.css';</pre>
			<p>The code for the imported CSS is provided in the <em class="italic">Appendix</em> of this chapter. We will not go through it here, as it is a lot of repetitive code. You can also download the CSS code from the GitHub repo. With these imports, we can build the framework for our login form with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
class LoginForm extends Component {
    state = {
        username: "",
        password: "",
    }
    submitLogin = (e) =&gt; {
        . . .
    }
    handlePasswordChange = (e) =&gt; {
        this.setState({password: e.target.value})
    }
    handleUsernameChange = (e) =&gt; {
        this.setState({username: e.target.value})
    }
    render() {
        . . .
    }
}
export default LoginForm;</pre>
			<p>Here, we can <a id="_idIndexMarker796"/>see that we keep track of <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> that is constantly updating the state. Remember, when the state is updated, we execute the <strong class="source-inline">render</strong> function. This is powerful, as we can change whatever we want. For instance, if the length of <strong class="source-inline">username</strong> exceeds a certain length, we can change the color of the components or remove the button. We will not be making drastic changes ourselves, as this is out of the scope of this book. Now that we have defined our framework, we can state what our <strong class="source-inline">render</strong> function returns with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
&lt;form className="login" onSubmit={this.submitLogin}&gt;
    &lt;h1 className="login-title"&gt;Login&lt;/h1&gt;
    &lt;input type="text" className="login-input"
    placeholder="Username"
    autoFocus onChange={this.handleUsernameChange}
           value={this.state.username} /&gt;
    &lt;input type="password" className="login-input"
    placeholder="Password"
    onChange={this.handlePasswordChange}
           value={this.state.password} /&gt;
    &lt;input type="submit" value="Lets Go"
    className="login-button" /&gt;
&lt;/form&gt;</pre>
			<p>Here, we can <a id="_idIndexMarker797"/>see that we have the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> fields in the form that execute the <strong class="source-inline">handleUsernameChange</strong> and <strong class="source-inline">handlePasswordChange</strong> functions when there is a change. When we input <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong>, we need to submit these fields to the backend via the <strong class="source-inline">submitLogin</strong> function, which we can <span class="No-Break">define here:</span></p>
			<pre class="source-code">
submitLogin = (e) =&gt; {
    e.preventDefault();
    axios.post("http://localhost:8000/v1/auth/login",
        {"username": this.state.username,
         "password": this.state.password},
        {headers: {"Access-Control-Allow-Origin": "*"}}
        )
        .then(response =&gt; {
            this.setState({username: "", password: ""});
            this.props.handleLogin(response.data["token"]);
        })
        .catch(error =&gt; {
            alert(error);
            this.setState({password: "", firstName: ""});
        });
}</pre>
			<p>Here, we can see that we pass the response of the login API call to a function that we passed through <a id="_idIndexMarker798"/>using props. We will have to define this in the <strong class="source-inline">src/app.js</strong> file. If there is an error, we print this out in an alert to tell us what happened. Either way, we empty the <strong class="source-inline">username</strong> and <span class="No-Break"><strong class="source-inline">password</strong></span><span class="No-Break"> fields.</span></p>
			<p>Now that we have defined our login form, we will need to show it when we need the user to log in. Once the user has logged in, we need to hide the login form. Before we can do this, we need to import our login form to the <strong class="source-inline">src/app.js</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import LoginForm from "./components/LoginForm";</pre>
			<p>We now need to keep track of the login status. To do this, our <strong class="source-inline">App</strong> class’s state needs to take the <span class="No-Break">following form:</span></p>
			<pre class="source-code">
state = {
  "pending_items": [],
  "done_items": [],
  "pending_items_count": 0,
  "done_items_count": 0,
  "login_status": false,
}</pre>
			<p>We are keeping track of our items, but if <strong class="source-inline">login_status</strong> is <strong class="source-inline">false</strong>, we can show the login form. Once the user has logged in, we can set <strong class="source-inline">login_status</strong> to <strong class="source-inline">true</strong>, and as a result, we can hide the login form. Now that we are logging the login status, we can update the <strong class="source-inline">App</strong> class’s <span class="No-Break"><strong class="source-inline">getItems</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
getItems() {
  axios.get("http://127.0.0.1:8000/v1/item/get",
  {headers: {"token": localStorage.getItem("user-token")}})
  .then(response =&gt; {
      let pending_items = response.data["pending_items"]
      let done_items = response.data["done_items"]
      this.setState({
        "pending_items":
         this.processItemValues(pending_items),
        "done_items": this.processItemValues(done_items),
        "pending_items_count":
         response.data["pending_item_count"],
        "done_items_count":
         response.data["done_item_count"]
        })
  }).catch(error =&gt; {
      if (error.response.status === 401) {
        this.logout();
      }
  });
}</pre>
			<p>We can see <a id="_idIndexMarker799"/>that we get the token and put it in the header. If there is an error with unauthorized code, we execute the <strong class="source-inline">logout</strong> function of the <strong class="source-inline">App</strong> class. Our <strong class="source-inline">logout</strong> function takes the form <span class="No-Break">defined here:</span></p>
			<pre class="source-code">
logout() {
  localStorage.removeItem("token");
  this.setState({"login_status": false});
}</pre>
			<p>We can see that we remove the token from the local storage and set our <strong class="source-inline">login_status</strong> to <strong class="source-inline">false</strong>. This <strong class="source-inline">logout</strong> function also needs to be executed if there is an error when trying to edit a to-do item, as we must remember that our token can expire so it <a id="_idIndexMarker800"/>can happen anywhere, and we must prompt another login. This means we must pass the <strong class="source-inline">logout</strong> function into the <strong class="source-inline">ToDoItem</strong> component with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
processItemValues(items) {
  let itemList = [];
  items.forEach((item, _)=&gt;{
      itemList.push(
          &lt;ToDoItem key={item.title + item.status}
                    title={item.title}
                    status={item.status}
                    passBackResponse={this.handleReturnedState}
                    logout={this.logout}/&gt;
      )
  })
  return itemList
}</pre>
			<p>Once we have passed our <strong class="source-inline">logout</strong> function into the <strong class="source-inline">ToDoItem</strong> component, we can update the API call to edit a to-do item in the <strong class="source-inline">src/components/ToDoItem.js</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
sendRequest = () =&gt; {
    axios.post("http://127.0.0.1:8000/v1/item/" +
                this.state.button,
        {
            "title": this.state.title,
            "status": this.inverseStatus(this.state.status)
        },
    {headers: {"token": localStorage.getItem(
         "user-token")}})
        .then(response =&gt; {
            this.props.passBackResponse(response);
        }).catch(error =&gt; {
            if (error.response.status === 401) {
                this.props.logout();
            }
    });
}</pre>
			<p>Here, we can <a id="_idIndexMarker801"/>see that we pass the token from local storage to the API call via the header. We then execute the <strong class="source-inline">logout</strong> function passed in via the props if we get an <span class="No-Break">unauthorized status.</span></p>
			<p>We now move back to the <strong class="source-inline">src/app.js</strong> file to wrap up the functionality of our application. Remember that our application needs to load data when we first access it. When our application initially loads, we must consider the token in the local storage with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
componentDidMount() {
  let token = localStorage.getItem("user-token");
  if (token !== null) {
      this.setState({login_status: true});
      this.getItems();
  }
}</pre>
			<p>Now our application will only get the items from the backend when there is a token. We must only handle the login before we wrap up our application with the <strong class="source-inline">render</strong> function. You have seen how we are handling our token with local storage. At this point, you should <a id="_idIndexMarker802"/>be able to build the <strong class="source-inline">handleLogin</strong> function for the <strong class="source-inline">App</strong> class yourself. If you have attempted coding your own function, it should look like the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
handleLogin = (token) =&gt; {
  localStorage.setItem("user-token", token);
  this.setState({"login_status": true});
  this.getItems();
}</pre>
			<p>We are now at the stage of defining the <strong class="source-inline">render</strong> function for the <strong class="source-inline">App</strong> class. If our login status is <strong class="source-inline">true</strong>, we can show everything our application has to offer with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
if (this.state.login_status === true) {
    return (
        &lt;div className="App"&gt;
            &lt;div className="mainContainer"&gt;
                &lt;div className="header"&gt;
                    &lt;p&gt;complete tasks:
                       {this.state.done_items_count}&lt;/p&gt;
                    &lt;p&gt;pending tasks:
                       {this.state.pending_items_count}&lt;/p&gt;
                &lt;/div&gt;
                &lt;h1&gt;Pending Items&lt;/h1&gt;
                {this.state.pending_items}
                &lt;h1&gt;Done Items&lt;/h1&gt;
                {this.state.done_items}
                &lt;CreateToDoItem
                 passBackResponse={this.handleReturnedState}/&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
}</pre>
			<p>There is <a id="_idIndexMarker803"/>not too much new here. However, if our login status is not <strong class="source-inline">true</strong>, we can then just display the login form with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
else {
    return (
        &lt;div className="App"&gt;
            &lt;div className="mainContainer"&gt;
                &lt;LoginForm handleLogin={this.handleLogin}
                /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
}</pre>
			<p>As we can see, we have passed the <strong class="source-inline">handleLogin</strong> function into the <strong class="source-inline">LoginForm</strong> component. With this, we are ready to run the application. Our first view looks like <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_7.8_B18722.jpg" alt="Figure 7.8 – Login and thus the loading view of our application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Login and thus the loading view of our application</p>
			<p>Once we <a id="_idIndexMarker804"/>enter the correct credentials, we will be able to access the application and interact with the to-do items. Our application is <span class="No-Break">essentially working!</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor163"/>Summary</h1>
			<p>In this chapter, we built user data model structs and tied them to the to-do item data models in our migrations. We then got to dive a little deeper into our migrations by firing multiple steps in the SQL file to ensure our migration runs smoothly. We also explored how to add unique constraints to <span class="No-Break">certain fields.</span></p>
			<p>Once our data models were defined in the database, we hashed some passwords before storing them in our database with the stored user. We then created a JWT struct to enable our users to store their JWT in their browsers so that they can submit them when making an API call. We then explored how to redirect the URL in JavaScript and the HTML storage so that the frontend can work out whether the user even has credentials, before it entertains the notion of sending API calls to <span class="No-Break">the items.</span></p>
			<p>What we have done here is alter the database with migration so that our app can manage data models that handle more complexity. We then utilized frontend storage to enable our user to pass credentials. This is directly applicable to any other Rust web project you will embark on. Most web apps require some sort <span class="No-Break">of authentication.</span></p>
			<p>In the next chapter, we will explore <strong class="bold">REST API</strong> practices, where we will standardize interfaces, caching, <span class="No-Break">and logging.</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor164"/>Questions</h1>
			<ol>
				<li value="1">What are the advantages of defining unique constraints in SQL as opposed to <span class="No-Break">server-side code?</span></li>
				<li>What is the main advantage of a user having a JWT over storing <span class="No-Break">a password?</span></li>
				<li>How does a user store a JWT on <span class="No-Break">the frontend?</span></li>
				<li>How could a JWT be useful in the view once we have verified that it <span class="No-Break">is passable?</span></li>
				<li>What is the minimal approach to altering data in the frontend and redirecting it to another view when a user hits <span class="No-Break">an endpoint?</span></li>
				<li>Why is it useful to have a range of different response codes when logging in as a user, as opposed to just denoting that login is successful <span class="No-Break">or unsuccessful?</span></li>
			</ol>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Answers</h1>
			<ol>
				<li value="1">Adding unique constraints directly on a database ensures that this standard is enforced, no matter whether data manipulation is done via migration or a server request. This also protects us from corrupting data if a new feature is added at another endpoint that forgets to enforce this standard, or if the code is altered in later alterations of <span class="No-Break">the endpoints.</span></li>
				<li>If an attacker manages to obtain a JWT, it does not mean that they have direct access to the user’s password. Also, if the tokens get refreshed, then the access the attacker has to items has a <span class="No-Break">limited timeframe.</span></li>
				<li>The JWT can be stored in local HTML storage <span class="No-Break">or cookies.</span></li>
				<li>We can store multiple data points in the token when hashing it. Therefore, we can encrypt the user ID. With this, we can extract the user ID for operations related to the to-do item’s creation, deletion, <span class="No-Break">or edit.</span></li>
				<li>We return an <strong class="source-inline">HttpResponse</strong> struct with HTML/text body that contains a string housing a couple of HTML tags. In between these tags are a couple of script tags. In between the script tags, we can have each of our JavaScript commands split by ;. We can then directly alter the HTML storage and <span class="No-Break">window location.</span></li>
				<li>There could be a range of reasons why data gets corrupted on a database, including alterations in the migrations. However, there could be an error that is not the fault of the user – for instance, a duplicate username for two different users. This is an error where our unique constraints have been violated. We need to know this has happened so that we can <span class="No-Break">correct it.</span></li>
			</ol>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor166"/>Further reading</h1>
			<p>JWT <span class="No-Break">standard: </span><a href="https://tools.ietf.org/html/rfc7519"><span class="No-Break">https://tools.ietf.org/html/rfc7519</span></a></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/>Appendix</h1>
			<p>The CSS used for the <span class="No-Break">login form:</span></p>
			<pre class="source-code">
body {
    background: #2d343d;
}
.login {
    margin: 20px auto;
    width: 300px;
    padding: 30px 25px;
    background: white;
    border: 1px solid #c4c4c4;
    border-radius: 25px;
}
h1.login-title {
    margin: -28px -25px 25px;
    padding: 15px 25px;
    line-height: 30px;
    font-size: 25px;
    font-weight: 300;
    color: #ADADAD;
    text-align:center;
    background: #f7f7f7;
    border-radius: 25px 25px 0px 0px;
}
.login-input {
    width: 285px;
    height: 50px;
    margin-bottom: 25px;
    padding-left:10px;
    font-size: 15px;
    background: #fff;
    border: 1px solid #ccc;
    border-radius: 4px;
}
.login-input:focus {
    border-color:#6e8095;
    outline: none;
}
.login-button {
    width: 100%;
    height: 50px;
    padding: 0;
    font-size: 20px;
    color: #fff;
    text-align: center;
    background: #f0776c;
    border: 0;
    border-radius: 5px;
    cursor: pointer;
    outline:0;
}
.login-lost
{
    text-align:center;
    margin-bottom:0px;
}
.login-lost a
{
    color:#666;
    text-decoration:none;
    font-size:13px;
}
.loggedInTitle {
    font-family: "Helvetica Neue";
    color: white;
}</pre>
		</div>
	</body></html>