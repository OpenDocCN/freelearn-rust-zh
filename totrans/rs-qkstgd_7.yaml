- en: Generic Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: Sometimes, the details of a data type just don't matter. Our code would work
    just as well no matter what the data type is, as long as it's *something*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，数据类型的细节并不重要。无论数据类型是什么，只要它是 *某种*，我们的代码都会正常工作。
- en: We've seen examples of this sort of situation many times already, such as with
    `Result`, `Option`, `Rc`, and so on. All of them, and many more, can work with
    a wide range of different data types, because they have one or more *generic type
    parameter*s.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次看到这类情况的例子，比如 `Result`、`Option`、`Rc` 等等。所有这些，以及更多，都可以与广泛的不同的数据类型一起工作，因为它们有一个或多个
    *泛型类型参数*。
- en: 'In this chapter, we''re going to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Learn what generic type parameters are
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习泛型类型参数是什么
- en: Learn how to apply generic type parameters to data types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何将泛型类型参数应用于数据类型
- en: Learn how to apply generic type parameters to functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何将泛型类型参数应用于函数
- en: Learn how generic types and trait objects differ
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习泛型类型和特例对象如何不同
- en: Create a complete and useful binary tree data structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个完整且有用的二叉树数据结构
- en: Types with generic type parameters
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有泛型类型参数的类型
- en: 'When a data type has generic type parameters, it''s not, strictly speaking,
    actually a data type at all. It is a whole family of data types. Let''s look at
    `Option` for a moment. `Option` is defined as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数据类型具有泛型类型参数时，它严格来说根本不是一个数据类型。它是一系列数据类型。让我们暂时看看 `Option`。`Option` 定义如下：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This means that it has one generic type parameter with the name `T`. If we
    try to use `Option` without specifying a type for that generic type parameter,
    Rust will report an error:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它有一个名为 `T` 的泛型类型参数。如果我们尝试在不指定泛型类型参数类型的情况下使用 `Option`，Rust 将报告错误：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It produces this error:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生了这个错误：
- en: '![](img/a77720ef-620f-4f6e-b393-75459d3f3a27.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a77720ef-620f-4f6e-b393-75459d3f3a27.png)'
- en: What that's telling us, in essence, is that `Option` isn't a usable data type.
    However, `Option<u32>` is, as is `Option<String>`, `Option<Result<f64, String>>`,
    and so on. Moreover, `Option<u32>` and `Option<String>` are not the same type,
    and Rust won't pretend that they are. They're two different data types that have
    the same shape, as it were.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上在告诉我们，`Option` 不是一个可用的数据类型。然而，`Option<u32>` 是，`Option<String>` 也是，`Option<Result<f64,
    String>>>` 等等。此外，`Option<u32>` 和 `Option<String>` 不是同一类型，Rust 也不会假装它们是。它们是两种具有相同形状的不同数据类型。
- en: When we write `Option<String>`, we're telling Rust that it should make a data
    type by substituting `String` for the `T` in the definition of `Option`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写 `Option<String>` 时，我们是在告诉 Rust 使用 `String` 替换定义中的 `T` 来创建一个数据类型。
- en: Limiting what types can be used for type parameters
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制可用于类型参数的类型
- en: Sometimes, we need our type to have generic type parameters, but we don't want
    them to be *totally* generic. For example, we might need the type that's substituted
    for the parameter to be able to be moved between threads, or to support transformation
    into `String`, or any number of other things. Fortunately, Rust provides a way
    for us to do that.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要我们的类型具有泛型类型参数，但我们不希望它们是 *完全* 泛型的。例如，我们可能需要替换参数的类型能够在不同线程之间移动，或者支持转换为
    `String`，或者任何其他事情。幸运的是，Rust 提供了一种方法让我们能够做到这一点。
- en: We limit the domain of a generic type parameter by requiring it to have one
    or more traits. This is called a trait bound. Let's look at a basic binary tree
    data structure as an example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过要求泛型类型参数具有一个或多个特质来限制泛型类型参数的范围。这被称为特例约束。让我们以一个基本的二叉树数据结构为例。
- en: 'A binary tree is made up of nodes. Each node has a key, an associated value,
    and two sub-trees: one for nodes with keys that are less than the current node''s
    key, and one for nodes with keys that are greater. Finding a node with a particular
    key in the tree is just a matter of comparing it to the root node''s key, then
    if it isn''t the same, picking either the lesser or greater tree, and doing the
    same thing there, and so on.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树由节点组成。每个节点都有一个键，一个相关的值，以及两个子树：一个用于键小于当前节点键的节点，另一个用于键大于当前节点键的节点。在树中查找具有特定键的节点只是将其与根节点键进行比较，然后如果它不是相同的，就选择较小的或较大的树，并在那里做同样的事情，依此类推。
- en: 'Here are a pair of structures that represent a binary tree, with generic type
    parameters for the key and value types, and a trait bound on the key type to make
    sure it actually supports the comparisons we need for a binary tree key:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一对表示二叉树的结构，具有用于键和值类型的泛型类型参数，以及对键类型的特例约束，以确保它实际上支持我们为二叉树键所需的比较：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the second structure, which gives us a way to store an empty tree:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第二个结构，它为我们提供了存储空树的方法：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need the second structure so that a tree containing no data can be represented.
    On both of these structures, we''ve placed the names of the generic type parameters
    between `<` and `>` after the structure name, but then we included a `where` clause
    that says that `K: PartialOrd + PartialEq`. That means that any data type that
    is substituted for `K` *must* implement both the `PartialOrd` trait and the `PartialEq`
    trait. If we try to use a data type that does not implement both traits, the compiler
    will reject it.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要第二个结构，以便可以表示不包含数据的树。在这两个结构中，我们在结构名称之后放置了通配类型参数的名称，并在其之间放置了 `<` 和 `>`，然后包含了一个
    `where` 子句，说明 `K: PartialOrd + PartialEq`。这意味着任何替换 `K` 的数据类型都必须实现 `PartialOrd`
    特性和 `PartialEq` 特性。如果我们尝试使用不实现这两个特性的数据类型，编译器将拒绝它。'
- en: We'll examine the specific meanings of `PartialOrd` and `PartialEq` in [Chapter
    8](a10c4fb7-f282-4769-9b35-5ab56a619eea.xhtml), *Important Standard Traits*. Roughly,
    they mean that the concepts of *greater* and *lesser* apply to the key.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 8 章 [重要标准特性](a10c4fb7-f282-4769-9b35-5ab56a619eea.xhtml)中检查 `PartialOrd`
    和 `PartialEq` 的具体含义，*重要标准特性*。大致来说，它们意味着 *大于* 和 *小于* 的概念适用于键。
- en: We've also specified that `lesser` and `greater` in `TreeNode` and `root` in
    `Tree` are variables with the `Option<Box<TreeNode<K, V>>>` data type . That means
    that they are optional (they can contain a meaningful value, or `None`), and if
    they contain a meaningful value, it is stored on the heap, and that value stored
    on the heap is a `TreeNode` with `K` as the data type of its key, and `V` as the
    data type of its value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了 `TreeNode` 中的 `lesser` 和 `greater` 以及 `Tree` 中的 `root` 是具有 `Option<Box<TreeNode<K,
    V>>>` 数据类型的变量。这意味着它们是可选的（它们可以包含一个有意义的值，或者 `None`），如果它们包含一个有意义的值，则该值存储在堆上，并且存储在堆上的值是一个
    `TreeNode`，其键的数据类型为 `K`，值的数据类型为 `V`。
- en: Implementing functionality for types with generic type parameters
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现具有泛型类型参数的类型的功能
- en: If we want to have functions that are part of a type with generic type parameters,
    we need to have an implementation block, the same as if the type didn't have those
    parameters, but we need to parameterize the implementation block, too.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要有属于具有泛型类型参数的类型的功能的函数，我们需要有一个实现块，就像类型没有这些参数一样，但我们还需要参数化实现块。
- en: 'Here is the beginning of our implementation block for the `TreeNode` type:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `TreeNode` 类型的实现块的开始：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, `TreeNode<K, V>` is the data type we''re implementing functionality for.
    It''s the `impl<K, V>` part that tells the compiler that `K` and `V` are generic
    type parameters, and it''s `K: PartialOrd + PartialEq` that tells it the trait
    bounds for those parameters. It does not just use the same generic type parameters
    and trait bounds that were specified for the data type, because implementation
    blocks are allowed to differ from the data type; for example, there''s an implementation
    block for `Box<Any>` that provides the `downcast` function for a boxed `Any`,
    which is not a part of `Box` under other circumstances. If the implementation
    block''s trait bounds match what is actually being using for type parameters,
    the functions in the block are available. If they do not, the functions are not
    available.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，`TreeNode<K, V>` 是我们正在实现功能的类型。`impl<K, V>` 部分告诉编译器 `K` 和 `V` 是泛型类型参数，而 `K:
    PartialOrd + PartialEq` 告诉它这些参数的特性行界。它并不只是使用为数据类型指定的相同泛型类型参数和特性行界，因为实现块可以与数据类型不同；例如，有一个为
    `Box<Any>` 提供了 `downcast` 函数的实现块，这在其他情况下不是 `Box` 的一部分。如果实现块的特性行界与实际使用的类型参数匹配，则块中的函数是可用的。如果不匹配，则函数不可用。'
- en: 'Inside the implementation block, we can use `K` and `V` as the names of data
    types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现块内部，我们可以使用 `K` 和 `V` 作为数据类型的名称：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we have the code to associate a key with a value inside our binary tree.
    It starts off with a pretty standard function definition, except that we're using
    `K` and `V` to specify the data types of the `key` and `value` parameters. We
    mutably borrow `self` because setting a contained value is a mutation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有将一个键与二叉树中的值关联起来的代码。它从一个相当标准的函数定义开始，除了我们使用 `K` 和 `V` 来指定 `key` 和 `value`
    参数的数据类型。我们以可变借用 `self` 的方式，因为设置包含的值是一种变异。
- en: Inside the function, we first compare the current node's key to the key we're
    looking for, and if they're the same, we just assign the value to the current
    node.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们首先比较当前节点的键与我们正在寻找的键，如果它们相同，我们就将值赋给当前节点。
- en: Next, we check whether the key we're looking for is less than or greater than
    the current node's key, and use that to select which branch of the tree to travel
    down. Either way, we use a `match` expression to figure out whether there actually
    is a branch on that side, and if there's not, we create one containing the specified
    key and value. If there *is* a branch on that side, we call that node's `set`
    function, which does the same thing all over again except with a different `self`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查我们正在寻找的键是否小于或大于当前节点的键，并使用这一点来选择要下行的树的哪个分支。无论哪种方式，我们都使用`match`表达式来确定该侧是否确实有一个分支，如果没有，我们就创建一个包含指定键和值的分支。如果那一侧确实有一个分支，我们就调用该节点的`set`函数，它再次执行相同的事情，只是这次使用不同的`self`。
- en: Using generic types as function return values
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将泛型类型用作函数返回值
- en: Within an implementation block that has generic type parameters, we can use
    those parameter names as part of function return values, too.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有泛型类型参数的实现块中，我们也可以将这些参数名称用作函数返回值的一部分。
- en: 'Here is an example function that uses generic type parameter names in its `return`
    data type:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用泛型类型参数名称在其`return`数据类型中的示例函数：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function looks up a key in the binary tree, and returns an immutable borrow
    of the associated value, or an error message if the key is not present in the
    tree.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在二叉树中查找键，并返回关联值的不可变借用，如果键不在树中，则返回错误信息。
- en: It's structured very similarly to the `set` function we saw before, but since
    we're not changing anything or asking for a mutable borrow, `self` can be a plain
    old immutable borrow as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它的结构与之前看到的`set`函数非常相似，但由于我们没有任何更改或请求可变借用，`self`也可以是一个普通的不可变借用。
- en: Compiler errors involving generic type parameters
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涉及泛型类型参数的编译器错误
- en: 'Our tree structure requires that the data type used for the key has to have
    the `PartialOrd` and `PartialEq` traits. The `&str` type happens to have those
    traits, so we can use an `&str` for the key:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们树结构的要求是用于键的数据类型必须具有`PartialOrd`和`PartialEq`特质。`&str`类型恰好具有这些特质，因此我们可以使用`&str`作为键：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we've created a `Tree<&'static str, f32>`, or a tree that maps static
    strings to 32-bit floating point numbers. If we compile and run a complete program
    containing that snippet, everything works beautifully.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个`Tree<&'static str, f32>`，或者是一个将静态字符串映射到32位浮点数的树。如果我们编译并运行包含此片段的完整程序，一切都会完美运行。
- en: 'This data type, on the other hand, does not have the `PartialOrd` trait:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，此数据类型不具有`PartialOrd`特质：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we substitute `NotOrdered` for `&''static str` as the key type for the tree,
    we suddenly get seven different compiler errors, which probably fill up the entire
    screen. Most of them look something like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`NotOrdered`替换为`&'static str`作为树的键类型，我们突然得到七个不同的编译器错误，这可能会填满整个屏幕。其中大多数看起来像这样：
- en: '![](img/768756f1-0bcc-4222-97bf-d6c3b062fe3a.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/768756f1-0bcc-4222-97bf-d6c3b062fe3a.png)'
- en: This is telling us that the function was defined inside an implementation block
    that requires `PartialOrd` and `PartialEq`. Since our `NotOrdered` data type doesn't
    have those traits, the function we're trying to call doesn't exist, and the compiler
    is telling us that.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们该函数是在一个需要`PartialOrd`和`PartialEq`的实现块中定义的。由于我们的`NotOrdered`数据类型没有这些特质，我们试图调用的函数不存在，编译器正在告诉我们这一点。
- en: 'Up at the top of the list of errors, and possibly scrolled right off the screen,
    is a different error message:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误列表的顶部，可能已经滚动到屏幕之外，是不同的错误信息：
- en: '![](img/93b1ad4d-62d5-43b6-a7f8-9e2ec03707b5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93b1ad4d-62d5-43b6-a7f8-9e2ec03707b5.png)'
- en: This error message is somewhat more helpful than the other one, but it stems
    from the same cause. Our `Tree` data type requires a key type whose values can
    be compared to other values of the same type, and `NotOrdered` just doesn't provide
    that.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误信息比其他错误信息更有帮助，但它源于同一原因。我们的`Tree`数据类型需要一个键类型，其值可以与其他相同类型的值进行比较，而`NotOrdered`根本不提供这一点。
- en: Generic types on functions outside of implementation blocks
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现块之外的函数上的泛型类型
- en: 'It''s possible to use generic type parameters for functions even when they''re
    not part of an implementation block. That looks like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们不是实现块的一部分，也可以为函数使用泛型类型参数。这看起来像这样：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function has a generic type parameter, `T`, which can be any data type
    that has the `Display` trait. That means that, if this function is defined, we
    can do things like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有一个泛型类型参数`T`，可以是任何具有`Display`特质的任何数据类型。这意味着，如果此函数被定义，我们可以做这样的事情：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each of those lines calls a different `print_generic` function, specialized
    for the data type of the parameter. The compiler generates code for each version
    of `print_generic` that we use, each one accepting a different data type for its
    parameter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都调用一个不同的`print_generic`函数，针对参数的数据类型进行了特殊化。编译器为每个我们使用的`print_generic`版本生成代码，每个版本接受不同数据类型的参数。
- en: Of course, `print_generic` doesn't do anything that the plain `println!` macro
    doesn't, but it serves to demonstrate the ways of generic type parameters for
    standalone functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`print_generic`并没有做`println!`宏没有做的事情，但它用来展示独立函数的泛型类型参数的用法。
- en: Alternative ways to write trait bounds
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写特性界限的替代方法
- en: So far, we've been writing trait bounds as a `where` clause, but there are two
    alternative ways of writing them. The `where` clause is nice because it's somewhat
    out of the way, allowing us to write even complex trait bounds without interfering
    with reading the rest of the function or data type declaration.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将特性界限写作`where`子句，但有两种不同的方式来编写它们。`where`子句的好处是它位于一边，允许我们编写甚至复杂的特性界限而不会干扰到阅读函数或数据类型声明。
- en: 'The first alternative is to put the trait bounds alongside the generic type
    parameter names, like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种替代方法是将特性界限放在泛型类型参数名称旁边，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For a standalone function, that technique looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个独立函数，这种技术看起来是这样的：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This can be good for data types or functions that only have simple trait bounds,
    but we can see that even with just two required traits, the `TreeNode` implementation
    block is getting a little hard to read. The trait bound kind of breaks up the
    flow and makes us go looking for the data type's name when we want to find it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于只有简单特性界限的数据类型或函数来说可能很好，但我们可以看到，即使只有两个必需的特性，`TreeNode`实现块也变得有点难以阅读。特性界限有点打断了流程，当我们想要找到数据类型名称时，它会让我们去寻找。
- en: 'There''s another way of specifying trait bounds that only works for functions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种指定特性界限的方法，但这只适用于函数：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What we're saying here is that the `value` parameter can be any data type that
    has the `Display` trait. As with any other function with generic type parameters,
    the compiler will generate a different version of the function for each data type
    that is actually used for `value`. However, using this syntax, we didn't give
    the generic type parameter a name, so we can't refer to it elsewhere in the function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里说的是`value`参数可以是任何具有`Display`特性的数据类型。与任何其他具有泛型类型参数的函数一样，编译器将为用于`value`的每个实际数据类型生成函数的不同版本。然而，使用这种语法，我们没有为泛型类型参数命名，因此我们无法在函数的其他地方引用它。
- en: Within the body of the function, that's not usually much of a problem, because
    we can usually skip specifying data types inside the function body and just rely
    on the compiler to figure it out.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内部，这通常不是什么大问题，因为我们通常可以跳过在函数体内指定数据类型，而只依赖编译器来推断它。
- en: 'We can also use a similar syntax to specify the return type of our function,
    which is handy because if we don''t have a name for one or more of the parameter
    types, it can be hard to write the return type:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用类似的语法来指定函数的返回类型，这很方便，因为如果我们没有为一个或多个参数类型命名，编写返回类型可能会很困难：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This doesn't mean that the function could return any data type as long as it
    implements `Display` (the correct way to do that would be to return a trait object,
    such as `Box<dyn Display>`), but all we care about is that the return type *does*
    implement `Display`, and we want the compiler to figure out the details of the
    return type beyond that.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着只要实现了`Display`（正确的方式是返回一个特性对象，例如`Box<dyn Display>`），函数就可以返回任何数据类型，但我们所关心的是返回类型*确实*实现了`Display`，并且我们希望编译器推断出返回类型的细节。
- en: 'To make that clear, here is a function that tries to return two different data
    types, both of which implement `Display`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一点更清晰，这里有一个尝试返回两种不同数据类型的函数，这两种数据类型都实现了`Display`特性：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the error message that Rust gives when we try to compile it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Rust在尝试编译它时给出的错误信息：
- en: '![](img/c31e0023-4785-49fe-8e4f-ffbc2a9c14d2.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c31e0023-4785-49fe-8e4f-ffbc2a9c14d2.png)'
- en: When it finds the `return 52`, Rust checks that `52` implements `Display` (it
    does) and decides that the actual return type of the function is some form of
    integer. Then, it finds the second `return` and decides that something is wrong,
    because even though `"Oh no"` also implements `Display`, it's definitely not an
    integer. Returning an `impl Display` or similar doesn't mean returning anything
    that implements `Display`; it means figuring out the specific type we're returning,
    as long as it implements `Display`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当它找到 `return 52` 时，Rust 会检查 `52` 是否实现了 `Display` 特质（它实现了）并决定函数的实际返回类型是某种整数形式。然后，它找到第二个
    `return` 并决定有问题，因为尽管 `"Oh no"` 也实现了 `Display` 特质，但它肯定不是整数。返回 `impl Display` 或类似的类型并不意味着返回任何实现了
    `Display` 的类型；这意味着确定我们返回的具体类型，只要它实现了 `Display`。
- en: Generic types versus trait objects
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型与特质对象
- en: 'We can use trait objects in a very similar way to generic type parameters.
    From one point of view, these two functions do the same thing:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用特质对象以非常类似的方式使用泛型类型参数。从一个角度来看，这两个函数做的是同一件事：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This might seem like it does the same thing as the previous code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来与之前的代码做的是同一件事：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first has a generic type parameter with a trait bound, the second accepts
    a trait object, which means both of them can work with many different data types,
    as long as the type in question has the `Display` trait.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个有一个带有特质边界的泛型类型参数，第二个接受一个特质对象，这意味着它们都可以与许多不同的数据类型一起工作，只要相关类型具有 `Display` 特质。
- en: Underneath, though, they're very different. The generic function is used to
    generate a version of the function that is specialized for each data type that
    is passed to it, while the compiler is running. That means that when we call the
    function while the program is running,the computer doesn't have to spend any time
    at all considering the differences between various data types. It just calls the
    function the compiler told it to use, which is the version specialized for the
    data type that's actually being used. This is faster, but all the various versions
    of generic functions make the program a little larger.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在底层，它们非常不同。泛型函数用于生成一个针对传递给它的每个数据类型在编译器运行时专门化的函数版本。这意味着当我们调用函数时，程序正在运行，计算机不需要花费任何时间考虑各种数据类型之间的差异。它只是调用编译器告诉它使用的函数，即针对实际使用的数据类型专门化的版本。这更快，但所有各种泛型函数版本会使程序稍微大一些。
- en: This process of turning a generic type-based pattern for a function into multiple
    actual functions specialized for specific types is called *monomorphization*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将基于泛型类型的函数模式转换为针对特定类型的多达多个实际函数的过程称为 *单态化*。
- en: The function that accepts a trait object as its parameter, on the other hand,
    has only one version, but the computer has to deal with the differences between
    the various data types that have the `Display` trait while it's running. This
    is slower, but requires a little less memory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，接受特质对象作为其参数的函数只有一个版本，但计算机在运行时必须处理具有 `Display` 特质的各个数据类型之间的差异。这较慢，但需要的内存略少。
- en: As a rule of thumb, opt to use generic type parameters when you can. We do things
    at runtime when they can't be done at compile time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，当你能使用泛型类型参数时，选择使用它们。当它们不能在编译时完成时，我们在运行时做事情。
- en: Higher-order functions and trait bounds that represent functions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数和代表函数的特质边界
- en: 'A higher-order function is a function that takes another function, or a closure,
    as a parameter. In Rust, there are three somewhat unusual traits that allow us
    to specify a function or closure as a parameter''s trait bound: `Fn`, `FnOnce`,
    and `FnMut`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是一种接受另一个函数或闭包作为参数的函数。在 Rust 中，有三个相对不寻常的特质允许我们指定一个函数或闭包作为参数的特质边界：`Fn`、`FnOnce`
    和 `FnMut`。
- en: 'The differences between these traits are defined by what kind of variable access
    they permit:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特质之间的区别由它们允许的变量访问类型定义：
- en: '`FnOnce` is the most widely applicable of these traits, because it has the
    fewest requirements on what types can implement it. An `FnOnce` only guarantees
    that it is safe to call it once. A function that consumes `self` is an example
    of a natural `FnOnce`, because having consumed `self`, it no longer has a `self`
    to be called on in future. Functions and closures that are safe to be called more
    than once still implement `FnOnce`, because calling them exactly once isn''t an
    error. That means that a variable that is constrained to be an `FnOnce` can accept
    any sort of function or closure.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FnOnce` 是这些特质中最广泛应用的，因为它对可以实现它的类型的要求最少。`FnOnce` 只保证可以安全地调用它一次。消耗 `self` 的函数是一个自然的
    `FnOnce` 的例子，因为消耗了 `self`，它就不再有 `self` 可以在未来被调用。可以安全多次调用的函数和闭包仍然实现 `FnOnce`，因为精确地调用它们一次不是错误。这意味着一个被限制为
    `FnOnce` 的变量可以接受任何类型的函数或闭包。'
- en: '`FnMut` is the next most widely applicable trait. An `FnMut` guarantees that
    it is safe to call it more than once, but it doesn''t promise not to change variable
    values elsewhere in the code via mutable borrows. A function that uses `&mut self`
    is an example of a natural `FnMut`, because it might change one or more of the
    variables contained in its `self`. Functions and closures that can''t or don''t
    actually change any outside variables still implement `FnMut`, because using them
    in a place where mutating is allowed isn''t an error.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FnMut` 是应用最广泛的特质。`FnMut` 保证可以多次调用它是安全的，但它不保证不会通过可变借用在代码的其他地方改变变量值。使用 `&mut
    self` 的函数是一个自然的 `FnMut` 的例子，因为它可能会改变其 `self` 中包含的一个或多个变量。不能或实际上没有改变任何外部变量的函数和闭包仍然实现
    `FnMut`，因为在允许变动的位置使用它们不是错误。'
- en: '`Fn` is the least applicable, since it guarantees that it can be called multiple
    times and it will not change any outside variables. Anything that is `Fn` can
    safely be used where an `FnMut` or `FnOnce` was expected, but the reverse is not
    true.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn` 是应用最少的，因为它保证可以多次调用，并且不会改变任何外部变量。任何是 `Fn` 的东西都可以安全地用于期望 `FnMut` 或 `FnOnce`
    的地方，但反过来则不成立。'
- en: That means that when we're the receiver, we should prefer to accept `FnOnce`
    if possible, or `FnMut` as a second choice, and `Fn` as the last choice when we
    truly need all of those guarantees, so as to give the people who are sending the
    data value to us the maximum flexibility in what they choose to send.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们是接收者时，如果可能的话，我们应该优先接受 `FnOnce`，其次是 `FnMut`，最后是 `Fn`，当我们真正需要所有这些保证时，这样就可以给发送数据值给我们的人提供最大的灵活性，让他们可以选择发送什么。
- en: 'Here is a very simple higher-order function, which uses a trait bound to specify
    what kind of function can be assigned to the `f` parameter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非常简单的更高阶函数，它使用特质界限来指定可以分配给 `f` 参数的函数类型：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, that looks a little odd. `FnOnce(u32) -> u32` is the complete name of the
    trait that we're requiring data types for `f` to implement. The special syntax
    that allows us to specify the parameter and return types for `Fn`, `FnMut`, and `FnOnce` is
    unique to those traits; we can't do similar things anywhere else.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这看起来有点奇怪。`FnOnce(u32) -> u32` 是我们要求 `f` 实现的数据类型的特质的完整名称。允许我们为 `Fn`、`FnMut`
    和 `FnOnce` 指定参数和返回类型的特殊语法是这些特质的独特之处；我们无法在其他地方做类似的事情。
- en: 'Just to be clear, that function definition could have also been written as
    follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，该函数定义也可以写成如下形式：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We could also have written the same thing as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样写同样的内容：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All of the preceding code means the same thing: the function''s `f` parameter
    needs to implement the `FnOnce` trait, and accept a single `u32` parameter, and
    return a `u32`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前面代码都意味着相同的意思：函数的 `f` 参数需要实现 `FnOnce` 特质，并接受一个 `u32` 参数，并返回一个 `u32`。
- en: 'Here''s a bit of code that calls our `higher_order` function and passes it
    a closure to be used as the value of `f`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一段调用我们的 `higher_order` 函数并传递一个闭包作为 `f` 的值的代码：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This closure has one parameter named `x`, defined between the `|` and `|` symbols,
    but it also accesses the `y` variable that was defined on the first line. In addition,
    it changes the value of that variable, meaning it requires mutable access. Thus,
    this closure implements `FnOnce` and `FnMut`, but not `Fn`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个闭包有一个名为 `x` 的参数，定义在 `|` 和 `|` 符号之间，但它也访问了第一行定义的 `y` 变量。此外，它改变了该变量的值，这意味着它需要可变访问。因此，这个闭包实现了
    `FnOnce` 和 `FnMut`，但没有实现 `Fn`。
- en: 'If we change `higher_order` to require the `Fn` trait and try compiling this
    code, we get a compiler error, as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `higher_order` 改为需要 `Fn` 特性并尝试编译此代码，我们将得到编译器错误，如下面的截图所示：
- en: '![](img/7382d144-1317-405d-a1c7-606515ac039e.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7382d144-1317-405d-a1c7-606515ac039e.png)'
- en: This error is not particularly illuminating. What it means is that we told `higher_order`
    to require an `Fn`, and then we passed it a closure that therefore *must* be an
    `Fn`, but we tried to perform a mutating operation inside of the closure, where
    we don't have a mutable `borrow` because Rust is sure that the closure must have
    the `Fn` trait, so it reports an error about trying a mutating operation on a
    non-mutable variable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误并不特别具有启发性。它的意思是，我们告诉 `higher_order` 需要一个 `Fn`，然后我们传递给它一个闭包，因此它必须是 `Fn`，但我们试图在闭包内部执行一个修改操作，在那里我们没有可变的借用，因为
    Rust 确定闭包必须具有 `Fn` 特性，所以它报告了一个关于尝试在不可变变量上执行修改操作的错误。
- en: All we need to do to fix this is change the trait bound on the `higher_order`
    function's `f` parameter back to `FnOnce` (or `FnMut`) so that the closure is
    allowed to perform the `push` operation on `y`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，我们只需要将 `higher_order` 函数的 `f` 参数的特征约束改回 `FnOnce`（或 `FnMut`），这样闭包就可以在
    `y` 上执行 `push` 操作。
- en: 'Once we restore `f` to have the proper trait bound, what does this code actually
    do?:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将 `f` 恢复到具有适当的特征约束，这段代码实际上做了什么？：
- en: Creates a mutable variable `y` containing a `String`
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 `String` 的可变变量 `y`
- en: Constructs a closure that captures a mutable borrow of the `y` variable, and
    accepts an `x` parameter
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个捕获 `y` 变量的可变借用的闭包，并接受一个 `x` 参数
- en: Passes that closure to `higher_order` as the value of the `f` parameter
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个闭包传递给 `higher_order` 作为 `f` 参数的值
- en: '`higher_order` then calls `f` (which is our closure), passing it `5` as the
    value of its `x` parameter'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`higher_order` 然后调用 `f`（即我们的闭包），并将 `5` 作为其 `x` 参数的值传递'
- en: 'Within the closure, the following occurs:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在闭包内部，发生以下情况：
- en: The character `'X'` is appended to the string stored in `y`
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符 `'X'` 被追加到存储在 `y` 中的字符串
- en: The new value of `y` is printed
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 `y` 的新值
- en: The value of `x` is returned, and becomes the result of the `f(5)` expression
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 `x` 的值，并成为 `f(5)` 表达式的结果
- en: '`higher_order` returns'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`higher_order` 返回'
- en: The current value of the `y` variable is printed
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 `y` 变量的当前值
- en: Notice that the code inside the closure does not run until the closure is called,
    but it has access to the variables that were defined in the scope where it was
    created.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，闭包内部的代码只有在闭包被调用时才会运行，但它可以访问在创建它的作用域中定义的变量。
- en: Both of the printouts of `y` print the string `yX`, because they are both referring
    to the same actual variable, whether directly or via a mutable borrow.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `y` 的打印输出都打印了字符串 `yX`，因为它们都引用了同一个实际变量，无论是直接引用还是通过可变借用。
- en: Complete implementation of a binary tree with generic type parameters
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整实现了具有泛型类型参数的二叉树
- en: 'We''ve finally progressed far enough in our journey through Rust that we can
    produce something truly useful. Our binary tree could still be improved in any
    number of ways, but it does what it was designed to do: it allows us to easily
    store and retrieve any number of key/value pairs.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于在我们对 Rust 的探索中取得了足够的进步，可以产生一些真正有用的东西。我们的二叉树仍然可以通过多种方式改进，但它确实做到了它被设计要做的事情：它允许我们轻松地存储和检索任意数量的键/值对。
- en: We made no effort to ensure that the binary tree remains balanced, meaning that
    the left and right branches of each node are approximately the same height, because
    that wouldn't have added anything to our discussion of generic types. If we had,
    this data structure would also be guaranteed to be efficient. Balanced binary
    trees are close to being as good as you can get when it comes to arbitrary key/value
    data structures.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有努力确保二叉树保持平衡，这意味着每个节点的左右分支的高度大致相同，因为那不会增加我们对泛型类型讨论的内容。如果我们这样做，这个数据结构也将保证是高效的。平衡二叉树在任意键/值数据结构方面几乎是最优的。
- en: 'So, here we have a complete, useful data structure. First we have the actual
    structure that stores the tree node data:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们有一个完整、有用的数据结构。首先，我们有实际的结构，它存储树节点数据：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we have the implementation block to define the functionality of the `TreeNode`
    type, starting with the `set` function, which associates a key with a value:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个实现块来定义 `TreeNode` 类型的功能，从 `set` 函数开始，它将一个键与一个值关联：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `get_ref` and `get_mut` functions are structured very similarly to the
    `set` function, because all three of them use the same mechanism to search the
    tree for a node with the correct key:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_ref`和`get_mut`函数的结构与`set`函数非常相似，因为这三个函数都使用相同的机制在树中搜索具有正确键的节点：'
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next comes the definition of our `Tree` data type, which provides the public
    interface to our data structure, and allows us to have an empty tree:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是定义我们的`Tree`数据类型，它为我们提供了数据结构的公共接口，并允许我们有一个空树：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And now the implementation block for `Tree`, with the public functions that
    provide us with a way to interact with `TreeNodes`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`Tree`的实现块，其中包含提供我们与`TreeNodes`交互方式的公共函数：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we have a main function to actually use our tree, so we can see it
    in action:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个主函数来实际使用我们的树，这样我们就可以看到它的实际应用：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have done the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们做了以下工作：
- en: Looked at generic type parameters for data types and for functions
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究了数据类型和函数的泛型类型参数
- en: Learned how to limit generic type parameters so that we can be sure the concrete
    types chosen implement the proper traits
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了如何限制泛型类型参数，以确保所选的具体类型实现了适当的特性
- en: Seen various compiler errors relating to generic types, and what they mean
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看到了与泛型类型相关的各种编译器错误以及它们的意义
- en: Learned how to use trait bounds and the `Fn`, `FnMut`, and `FnOnce` traits to
    create higher-order functions
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了如何使用特性界限和`Fn`、`FnMut`以及`FnOnce`特性来创建高阶函数
- en: Learned about the differences and similarities between using generic types and
    using trait objects
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解使用泛型类型和使用特性对象之间的差异和相似之处
- en: Taken our knowledge from this chapter and previous chapters and built a binary
    tree data structure
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本章和前几章的知识中汲取知识，构建了一个二叉树数据结构
- en: In the next chapter, we're going to conclude our Rust journey by looking at
    many more traits, learning what they mean and how to implement them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过查看更多特性来结束我们的Rust之旅，了解它们的意义以及如何实现它们。
