- en: Generic Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the details of a data type just don't matter. Our code would work
    just as well no matter what the data type is, as long as it's *something*.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen examples of this sort of situation many times already, such as with
    `Result`, `Option`, `Rc`, and so on. All of them, and many more, can work with
    a wide range of different data types, because they have one or more *generic type
    parameter*s.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn what generic type parameters are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to apply generic type parameters to data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to apply generic type parameters to functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how generic types and trait objects differ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a complete and useful binary tree data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types with generic type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a data type has generic type parameters, it''s not, strictly speaking,
    actually a data type at all. It is a whole family of data types. Let''s look at
    `Option` for a moment. `Option` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that it has one generic type parameter with the name `T`. If we
    try to use `Option` without specifying a type for that generic type parameter,
    Rust will report an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a77720ef-620f-4f6e-b393-75459d3f3a27.png)'
  prefs: []
  type: TYPE_IMG
- en: What that's telling us, in essence, is that `Option` isn't a usable data type.
    However, `Option<u32>` is, as is `Option<String>`, `Option<Result<f64, String>>`,
    and so on. Moreover, `Option<u32>` and `Option<String>` are not the same type,
    and Rust won't pretend that they are. They're two different data types that have
    the same shape, as it were.
  prefs: []
  type: TYPE_NORMAL
- en: When we write `Option<String>`, we're telling Rust that it should make a data
    type by substituting `String` for the `T` in the definition of `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting what types can be used for type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need our type to have generic type parameters, but we don't want
    them to be *totally* generic. For example, we might need the type that's substituted
    for the parameter to be able to be moved between threads, or to support transformation
    into `String`, or any number of other things. Fortunately, Rust provides a way
    for us to do that.
  prefs: []
  type: TYPE_NORMAL
- en: We limit the domain of a generic type parameter by requiring it to have one
    or more traits. This is called a trait bound. Let's look at a basic binary tree
    data structure as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'A binary tree is made up of nodes. Each node has a key, an associated value,
    and two sub-trees: one for nodes with keys that are less than the current node''s
    key, and one for nodes with keys that are greater. Finding a node with a particular
    key in the tree is just a matter of comparing it to the root node''s key, then
    if it isn''t the same, picking either the lesser or greater tree, and doing the
    same thing there, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a pair of structures that represent a binary tree, with generic type
    parameters for the key and value types, and a trait bound on the key type to make
    sure it actually supports the comparisons we need for a binary tree key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the second structure, which gives us a way to store an empty tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We need the second structure so that a tree containing no data can be represented.
    On both of these structures, we''ve placed the names of the generic type parameters
    between `<` and `>` after the structure name, but then we included a `where` clause
    that says that `K: PartialOrd + PartialEq`. That means that any data type that
    is substituted for `K` *must* implement both the `PartialOrd` trait and the `PartialEq`
    trait. If we try to use a data type that does not implement both traits, the compiler
    will reject it.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll examine the specific meanings of `PartialOrd` and `PartialEq` in [Chapter
    8](a10c4fb7-f282-4769-9b35-5ab56a619eea.xhtml), *Important Standard Traits*. Roughly,
    they mean that the concepts of *greater* and *lesser* apply to the key.
  prefs: []
  type: TYPE_NORMAL
- en: We've also specified that `lesser` and `greater` in `TreeNode` and `root` in
    `Tree` are variables with the `Option<Box<TreeNode<K, V>>>` data type . That means
    that they are optional (they can contain a meaningful value, or `None`), and if
    they contain a meaningful value, it is stored on the heap, and that value stored
    on the heap is a `TreeNode` with `K` as the data type of its key, and `V` as the
    data type of its value.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing functionality for types with generic type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to have functions that are part of a type with generic type parameters,
    we need to have an implementation block, the same as if the type didn't have those
    parameters, but we need to parameterize the implementation block, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the beginning of our implementation block for the `TreeNode` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `TreeNode<K, V>` is the data type we''re implementing functionality for.
    It''s the `impl<K, V>` part that tells the compiler that `K` and `V` are generic
    type parameters, and it''s `K: PartialOrd + PartialEq` that tells it the trait
    bounds for those parameters. It does not just use the same generic type parameters
    and trait bounds that were specified for the data type, because implementation
    blocks are allowed to differ from the data type; for example, there''s an implementation
    block for `Box<Any>` that provides the `downcast` function for a boxed `Any`,
    which is not a part of `Box` under other circumstances. If the implementation
    block''s trait bounds match what is actually being using for type parameters,
    the functions in the block are available. If they do not, the functions are not
    available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the implementation block, we can use `K` and `V` as the names of data
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we have the code to associate a key with a value inside our binary tree.
    It starts off with a pretty standard function definition, except that we're using
    `K` and `V` to specify the data types of the `key` and `value` parameters. We
    mutably borrow `self` because setting a contained value is a mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function, we first compare the current node's key to the key we're
    looking for, and if they're the same, we just assign the value to the current
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the key we're looking for is less than or greater than
    the current node's key, and use that to select which branch of the tree to travel
    down. Either way, we use a `match` expression to figure out whether there actually
    is a branch on that side, and if there's not, we create one containing the specified
    key and value. If there *is* a branch on that side, we call that node's `set`
    function, which does the same thing all over again except with a different `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Using generic types as function return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within an implementation block that has generic type parameters, we can use
    those parameter names as part of function return values, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example function that uses generic type parameter names in its `return`
    data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function looks up a key in the binary tree, and returns an immutable borrow
    of the associated value, or an error message if the key is not present in the
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: It's structured very similarly to the `set` function we saw before, but since
    we're not changing anything or asking for a mutable borrow, `self` can be a plain
    old immutable borrow as well.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler errors involving generic type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our tree structure requires that the data type used for the key has to have
    the `PartialOrd` and `PartialEq` traits. The `&str` type happens to have those
    traits, so we can use an `&str` for the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created a `Tree<&'static str, f32>`, or a tree that maps static
    strings to 32-bit floating point numbers. If we compile and run a complete program
    containing that snippet, everything works beautifully.
  prefs: []
  type: TYPE_NORMAL
- en: 'This data type, on the other hand, does not have the `PartialOrd` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we substitute `NotOrdered` for `&''static str` as the key type for the tree,
    we suddenly get seven different compiler errors, which probably fill up the entire
    screen. Most of them look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/768756f1-0bcc-4222-97bf-d6c3b062fe3a.png)'
  prefs: []
  type: TYPE_IMG
- en: This is telling us that the function was defined inside an implementation block
    that requires `PartialOrd` and `PartialEq`. Since our `NotOrdered` data type doesn't
    have those traits, the function we're trying to call doesn't exist, and the compiler
    is telling us that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up at the top of the list of errors, and possibly scrolled right off the screen,
    is a different error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93b1ad4d-62d5-43b6-a7f8-9e2ec03707b5.png)'
  prefs: []
  type: TYPE_IMG
- en: This error message is somewhat more helpful than the other one, but it stems
    from the same cause. Our `Tree` data type requires a key type whose values can
    be compared to other values of the same type, and `NotOrdered` just doesn't provide
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Generic types on functions outside of implementation blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s possible to use generic type parameters for functions even when they''re
    not part of an implementation block. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has a generic type parameter, `T`, which can be any data type
    that has the `Display` trait. That means that, if this function is defined, we
    can do things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each of those lines calls a different `print_generic` function, specialized
    for the data type of the parameter. The compiler generates code for each version
    of `print_generic` that we use, each one accepting a different data type for its
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, `print_generic` doesn't do anything that the plain `println!` macro
    doesn't, but it serves to demonstrate the ways of generic type parameters for
    standalone functions.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative ways to write trait bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been writing trait bounds as a `where` clause, but there are two
    alternative ways of writing them. The `where` clause is nice because it's somewhat
    out of the way, allowing us to write even complex trait bounds without interfering
    with reading the rest of the function or data type declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first alternative is to put the trait bounds alongside the generic type
    parameter names, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For a standalone function, that technique looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This can be good for data types or functions that only have simple trait bounds,
    but we can see that even with just two required traits, the `TreeNode` implementation
    block is getting a little hard to read. The trait bound kind of breaks up the
    flow and makes us go looking for the data type's name when we want to find it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another way of specifying trait bounds that only works for functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What we're saying here is that the `value` parameter can be any data type that
    has the `Display` trait. As with any other function with generic type parameters,
    the compiler will generate a different version of the function for each data type
    that is actually used for `value`. However, using this syntax, we didn't give
    the generic type parameter a name, so we can't refer to it elsewhere in the function.
  prefs: []
  type: TYPE_NORMAL
- en: Within the body of the function, that's not usually much of a problem, because
    we can usually skip specifying data types inside the function body and just rely
    on the compiler to figure it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use a similar syntax to specify the return type of our function,
    which is handy because if we don''t have a name for one or more of the parameter
    types, it can be hard to write the return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't mean that the function could return any data type as long as it
    implements `Display` (the correct way to do that would be to return a trait object,
    such as `Box<dyn Display>`), but all we care about is that the return type *does*
    implement `Display`, and we want the compiler to figure out the details of the
    return type beyond that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make that clear, here is a function that tries to return two different data
    types, both of which implement `Display`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the error message that Rust gives when we try to compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c31e0023-4785-49fe-8e4f-ffbc2a9c14d2.png)'
  prefs: []
  type: TYPE_IMG
- en: When it finds the `return 52`, Rust checks that `52` implements `Display` (it
    does) and decides that the actual return type of the function is some form of
    integer. Then, it finds the second `return` and decides that something is wrong,
    because even though `"Oh no"` also implements `Display`, it's definitely not an
    integer. Returning an `impl Display` or similar doesn't mean returning anything
    that implements `Display`; it means figuring out the specific type we're returning,
    as long as it implements `Display`.
  prefs: []
  type: TYPE_NORMAL
- en: Generic types versus trait objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use trait objects in a very similar way to generic type parameters.
    From one point of view, these two functions do the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This might seem like it does the same thing as the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first has a generic type parameter with a trait bound, the second accepts
    a trait object, which means both of them can work with many different data types,
    as long as the type in question has the `Display` trait.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath, though, they're very different. The generic function is used to
    generate a version of the function that is specialized for each data type that
    is passed to it, while the compiler is running. That means that when we call the
    function while the program is running,the computer doesn't have to spend any time
    at all considering the differences between various data types. It just calls the
    function the compiler told it to use, which is the version specialized for the
    data type that's actually being used. This is faster, but all the various versions
    of generic functions make the program a little larger.
  prefs: []
  type: TYPE_NORMAL
- en: This process of turning a generic type-based pattern for a function into multiple
    actual functions specialized for specific types is called *monomorphization*.
  prefs: []
  type: TYPE_NORMAL
- en: The function that accepts a trait object as its parameter, on the other hand,
    has only one version, but the computer has to deal with the differences between
    the various data types that have the `Display` trait while it's running. This
    is slower, but requires a little less memory.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, opt to use generic type parameters when you can. We do things
    at runtime when they can't be done at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions and trait bounds that represent functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A higher-order function is a function that takes another function, or a closure,
    as a parameter. In Rust, there are three somewhat unusual traits that allow us
    to specify a function or closure as a parameter''s trait bound: `Fn`, `FnOnce`,
    and `FnMut`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences between these traits are defined by what kind of variable access
    they permit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FnOnce` is the most widely applicable of these traits, because it has the
    fewest requirements on what types can implement it. An `FnOnce` only guarantees
    that it is safe to call it once. A function that consumes `self` is an example
    of a natural `FnOnce`, because having consumed `self`, it no longer has a `self`
    to be called on in future. Functions and closures that are safe to be called more
    than once still implement `FnOnce`, because calling them exactly once isn''t an
    error. That means that a variable that is constrained to be an `FnOnce` can accept
    any sort of function or closure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FnMut` is the next most widely applicable trait. An `FnMut` guarantees that
    it is safe to call it more than once, but it doesn''t promise not to change variable
    values elsewhere in the code via mutable borrows. A function that uses `&mut self`
    is an example of a natural `FnMut`, because it might change one or more of the
    variables contained in its `self`. Functions and closures that can''t or don''t
    actually change any outside variables still implement `FnMut`, because using them
    in a place where mutating is allowed isn''t an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fn` is the least applicable, since it guarantees that it can be called multiple
    times and it will not change any outside variables. Anything that is `Fn` can
    safely be used where an `FnMut` or `FnOnce` was expected, but the reverse is not
    true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That means that when we're the receiver, we should prefer to accept `FnOnce`
    if possible, or `FnMut` as a second choice, and `Fn` as the last choice when we
    truly need all of those guarantees, so as to give the people who are sending the
    data value to us the maximum flexibility in what they choose to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a very simple higher-order function, which uses a trait bound to specify
    what kind of function can be assigned to the `f` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, that looks a little odd. `FnOnce(u32) -> u32` is the complete name of the
    trait that we're requiring data types for `f` to implement. The special syntax
    that allows us to specify the parameter and return types for `Fn`, `FnMut`, and `FnOnce` is
    unique to those traits; we can't do similar things anywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to be clear, that function definition could have also been written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also have written the same thing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the preceding code means the same thing: the function''s `f` parameter
    needs to implement the `FnOnce` trait, and accept a single `u32` parameter, and
    return a `u32`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a bit of code that calls our `higher_order` function and passes it
    a closure to be used as the value of `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This closure has one parameter named `x`, defined between the `|` and `|` symbols,
    but it also accesses the `y` variable that was defined on the first line. In addition,
    it changes the value of that variable, meaning it requires mutable access. Thus,
    this closure implements `FnOnce` and `FnMut`, but not `Fn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change `higher_order` to require the `Fn` trait and try compiling this
    code, we get a compiler error, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7382d144-1317-405d-a1c7-606515ac039e.png)'
  prefs: []
  type: TYPE_IMG
- en: This error is not particularly illuminating. What it means is that we told `higher_order`
    to require an `Fn`, and then we passed it a closure that therefore *must* be an
    `Fn`, but we tried to perform a mutating operation inside of the closure, where
    we don't have a mutable `borrow` because Rust is sure that the closure must have
    the `Fn` trait, so it reports an error about trying a mutating operation on a
    non-mutable variable.
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do to fix this is change the trait bound on the `higher_order`
    function's `f` parameter back to `FnOnce` (or `FnMut`) so that the closure is
    allowed to perform the `push` operation on `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we restore `f` to have the proper trait bound, what does this code actually
    do?:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a mutable variable `y` containing a `String`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructs a closure that captures a mutable borrow of the `y` variable, and
    accepts an `x` parameter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Passes that closure to `higher_order` as the value of the `f` parameter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`higher_order` then calls `f` (which is our closure), passing it `5` as the
    value of its `x` parameter'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the closure, the following occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The character `'X'` is appended to the string stored in `y`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The new value of `y` is printed
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of `x` is returned, and becomes the result of the `f(5)` expression
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`higher_order` returns'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current value of the `y` variable is printed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the code inside the closure does not run until the closure is called,
    but it has access to the variables that were defined in the scope where it was
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Both of the printouts of `y` print the string `yX`, because they are both referring
    to the same actual variable, whether directly or via a mutable borrow.
  prefs: []
  type: TYPE_NORMAL
- en: Complete implementation of a binary tree with generic type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve finally progressed far enough in our journey through Rust that we can
    produce something truly useful. Our binary tree could still be improved in any
    number of ways, but it does what it was designed to do: it allows us to easily
    store and retrieve any number of key/value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: We made no effort to ensure that the binary tree remains balanced, meaning that
    the left and right branches of each node are approximately the same height, because
    that wouldn't have added anything to our discussion of generic types. If we had,
    this data structure would also be guaranteed to be efficient. Balanced binary
    trees are close to being as good as you can get when it comes to arbitrary key/value
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here we have a complete, useful data structure. First we have the actual
    structure that stores the tree node data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the implementation block to define the functionality of the `TreeNode`
    type, starting with the `set` function, which associates a key with a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_ref` and `get_mut` functions are structured very similarly to the
    `set` function, because all three of them use the same mechanism to search the
    tree for a node with the correct key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next comes the definition of our `Tree` data type, which provides the public
    interface to our data structure, and allows us to have an empty tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the implementation block for `Tree`, with the public functions that
    provide us with a way to interact with `TreeNodes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have a main function to actually use our tree, so we can see it
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Looked at generic type parameters for data types and for functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to limit generic type parameters so that we can be sure the concrete
    types chosen implement the proper traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seen various compiler errors relating to generic types, and what they mean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to use trait bounds and the `Fn`, `FnMut`, and `FnOnce` traits to
    create higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned about the differences and similarities between using generic types and
    using trait objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taken our knowledge from this chapter and previous chapters and built a binary
    tree data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we're going to conclude our Rust journey by looking at
    many more traits, learning what they mean and how to implement them.
  prefs: []
  type: TYPE_NORMAL
