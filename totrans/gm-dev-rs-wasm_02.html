<html><head></head><body>
		<div><h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Hello WebAssembly</h1>
			<p>Let's cut to the chase – if you're holding this book, you probably already know you love Rust, and you<a id="_idIndexMarker000"/> think <strong class="bold">WebAssembly</strong> is a great way to deploy your Rust programs to the web. Good news – you're right! Rust and WebAssembly are a match made in programmer heaven, and while WebAssembly is still in its early days, game development is an ideal candidate for WebAssembly. I am excited to be guiding you through building a game for the web in Stack Overflow's "most-loved" language, Rust.</p>
			<p>This chapter is all about equipping yourself with the tools for the game development journey. In this chapter, we'll cover the following topics: </p>
			<ul>
				<li>What is WebAssembly?</li>
				<li>Creating a Rust and WebAssembly project skeleton</li>
				<li>Translating JavaScript code into Rust code</li>
				<li>Drawing to the screen with HTML5 Canvas<a id="_idTextAnchor016"/></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>To follow along with the project skeleton, you'll need to install <code>rustup</code> to install the Rust toolchains. This can be found at <a href="https://rustup.rs/">https://rustup.rs/</a>. While you can install Rust and its various toolchains without using the <code>rustup</code> tool, it's not trivial, and I won't be documenting it here. You'll also need an editor for writing Rust code, and while you can use virtually any editor with rust-analyzer, if you're new to writing Rust, I'd recommend Visual Studio Code and the Rust extension found at <a href="https://bit.ly/3tAUyH2">https://bit.ly/3tAUyH2</a>. It's easy to set up and works right out of the box.</p>
			<p>Finally, you'll need a web browser, and in this chapter, you'll need some familiarity with the terminal and <strong class="bold">Node.js</strong>. If you get stumped, the code for this chapter is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1</a>. The final code for the entire book is in the main branch at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly</a>.<a id="_idTextAnchor018"/></p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3qMV44E">https://bit.ly/3qMV44E</a></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>What is WebAssembly?</h1>
			<p>You picked up <a id="_idIndexMarker001"/>this book (thanks!) so in all likelihood, you have some idea of what WebAssembly<a id="_idIndexMarker002"/> is, but just in case, let's grab a definition from <a href="https://WebAssembly.org">https://WebAssembly.org</a>:</p>
			<p class="author-quote">"WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications."</p>
			<p>In other words, <strong class="bold">Wasm</strong> is a binary format that we can compile other languages to so that we can run them in the browser. This is different than transpiling or source-to-source compiling, where languages such as TypeScript are converted into JavaScript for running in JavaScript environments. Those languages are still ultimately running JavaScript, whereas Wasm is bytecode. This makes it a smaller download and parsing and compiling steps are removed when running it, which can lead to significant performance improvements. But let's be honest – you're not using Rust and Wasm for the performance improvements, which aren't guaranteed anyway. You're using it because you like Rust.</p>
			<p>And that's okay!</p>
			<p>Rust has a great type system, excellent developer tooling, and a fantastic community. While WebAssembly was originally created with C and C++ in mind, Rust is a fantastic language for WebAssembly for all the reasons you love Rust and more. Now, for most of the web's existence, writing applications to run in a browser meant writing JavaScript, and over the years, JavaScript has evolved into a suitably modern language for that purpose. I'm not here to tell you that if you like JavaScript you should stop, but if you love Rust, you should absolutely start compiling to Wasm and running apps in the browser.</p>
			<p class="callout-heading">Important Note </p>
			<p class="callout">This book is focused on making web-based games with Rust and Wasm, but you can absolutely run Wasm apps in server-side environments such as Node.js. If you're interested in that, you can check out the book <em class="italic">Learn WebAssembly</em> by Mike Rourke, which can be found at <a href="https://bit.ly/2N89prp">https://bit.ly/2N89prp</a>, or the official <code>wasm-bindgen</code> guide at <a href="https://bit.ly/39WC63G">https://bit.ly/39WC63G</a>.</p>
			<p class="callout-heading">Important Note </p>
			<p class="callout">This book assumes some familiarity with Rust, although you do not need to be an expert. If at any time you're confused by a Rust concept, I highly encourage you to stop and check <em class="italic">"the book"</em>, <em class="italic">The Rust Programming Language</em>, available for free at <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>. </p>
			<p>So, now that I've <a id="_idIndexMarker003"/>convinced you to do what you were already going to do anyway, let's go over some of the tools you'll need to write a game for the web in Rust:</p>
			<ul>
				<li><code>rustup</code>: Most likely <a id="_idIndexMarker004"/>you're already using <code>rustup</code> if you're <a id="_idIndexMarker005"/>writing Rust code. If you're not, you should, as it's the standard way to install Rust. It allows for easy installations of toolchains, Rust compilers, and even launches the Rust documentation. You'll need it to install <a id="_idIndexMarker006"/>the <strong class="bold">Wasm toolchain</strong>, and you can install it from the previous link. The code in this book has been tested on Rust version 1.57.0.</li>
				<li><strong class="bold">Node.js</strong>: I know – I promised<a id="_idIndexMarker007"/> you that we'd be writing in Rust! We<a id="_idIndexMarker008"/> will, but this is still a web application and you'll be using Node.js to run the application. I recommend installing the current long-term support version (<strong class="bold">16.13.0</strong> at the time of writing). Older versions of Node.js may not work with the package creation tools as expected. If you're using Ubuntu Linux, be especially cautious when using the Debian distribution, which installs a very old version at this time. When in doubt, use tools for managing multiple <a id="_idIndexMarker009"/>versions, such as the <strong class="bold">Node Version Manager</strong> (<strong class="bold">nvm</strong>) tool for Linux/Mac or the corresponding nvm-windows tool for Windows, to ensure that you're using the long-term release version. I use the asdf tool (<a href="https://asdf-vm.com/">https://asdf-vm.com/</a>) for managing multiple versions myself, although I don't usually recommend it to people that haven't used a version management tool before. </li>
				<li><strong class="bold">webpack</strong>: We'll use <a id="_idIndexMarker010"/>webpack <a id="_idIndexMarker011"/>to bundle our application for release and run a development server. Most of the time, you won't have to worry about it, but it's there.<p class="callout-heading">Important Note</p><p class="callout">The current template uses webpack 4. Make sure to check that when looking up documentation.</p></li>
				<li><code>wasm-pack</code>: This is a Rust tool for building Rust-generated WebAssembly code. Like webpack, most of the time you won't know it's there, as it's managed by webpack, and your<a id="_idIndexMarker012"/> Rust application will largely be managed by Rust build tools.</li>
				<li><code>wasm-bindgen</code>: This is one of the crates you'll need to get to know to write Rust-generated WebAssembly code. One limitation of WebAssembly is that you cannot access <a id="_idIndexMarker013"/>the <code>wasm-bindgen</code> does is create those bindings and the boilerplate needed to call JavaScript functions from your Rust code, as well as provide tools to create bindings in the other direction so that JavaScript code can call back into the Rust code. We'll cover the details of how <code>wasm-bindgen</code> works as we go through the book, but to avoid getting bogged down in details right now, you can just think of it as a library to call JavaScript from your Rust code.</li>
				<li><code>web-sys</code>: This is a crate made up of many pre-generated bindings, using <code>wasm-bindgen</code>, for the web. We'll use <code>web-sys</code> to call browser APIs such as the canvas and <code>requestAnimationFrame</code>. This book assumes at least a passing familiarity with web development but doesn't require expertise in this area, and in fact, one of the advantages of game development in Rust is that we can just treat the browser as a platform library that we call functions on. The <code>web-sys</code> crate means we don't have to create all those bindings ourselves.</li>
				<li><code>Canvas</code>: HTML Canvas is a <code>&lt;canvas&gt;</code> browser element, such as headers or paragraphs, only it allows you to draw directly to it. This is how we can make a video game! There are many ways to draw to the canvas, including <code>WebGL</code> and <code>WebGPU</code>, but we're going to use the built-in Canvas API for most of this project. While this isn't the absolute fastest way of making a game, it's fast enough for learning purposes and avoids adding more technologies to our stack.</li>
			</ul>
			<p>Finally, while googling <code>web-sys</code>, <code>web-bindgen</code>, or other Rust packages for WebAssembly, you are likely to come across references to <code>cargo-web</code> and <code>stdweb</code>. While both of <a id="_idIndexMarker014"/>those projects were important to the development of Rust as a WebAssembly source, neither has been updated since 2019 and can be safely ignored. Now that we know the tools we'll be using, let's start building our first<a id="_idTextAnchor020"/> Rust project.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor021"/>A Rust project skeleton</h1>
			<p class="callout-heading">Important Note </p>
			<p class="callout">These directions <a id="_idIndexMarker015"/>are based on the status of <code>rust-webpack-template</code> at the time of writing. It's likely to have changed at the time of reading this, so pay close attention to the changes we are making. If they don't make sense, check the documents for <code>wasm-pack</code> and use your best judgment.</p>
			<p>At this point, I'm going to assume you've installed <code>rustup</code> and Node.js. If you haven't, go ahead and follow the instructions for your platform to install them, and then follow these steps:</p>
			<ol>
				<li><strong class="bold">Initialize the project</strong></li>
			</ol>
			<p>Let's start by creating a project skeleton for your application, which will be the Rust webpack Template from the Rust Wasm group. It's found on GitHub at <a href="https://github.com/rustwasm/rust-webpack-template">https://github.com/rustwasm/rust-webpack-template</a>, but you don't want to download<a id="_idIndexMarker016"/> it. Instead, use <code>npm init</code> to create it, like this:</p>
			<pre>mkdir walk-the-dog
cd walk-the-dog
npm init rust-webpack</pre>
			<p>You should see something like this:</p>
			<pre>npx: installed 17 in 1.941s
 🦀 Rust + 🕸 WebAssembly + Webpack = ❤
Installed dependencies ✅</pre>
			<p>Congratulations! You have created your project.</p>
			<ol>
				<li value="2"><strong class="bold">Install dependencies</strong></li>
			</ol>
			<p>You can install the dependencies with <code>npm</code>:</p>
			<pre>npm install</pre>
			<p class="callout-heading">Important Note </p>
			<p class="callout">If you prefer to use <code>yarn</code>, you can, with the exception of the <code>npm init</code> command. I'll be using <code>npm</code> for this book.</p>
			<ol>
				<li value="3"><strong class="bold">Run the server</strong></li>
			</ol>
			<p>After the installation completes, you can now run a development server with <code>npm run start</code>. You may see an error, like this:</p>
			<pre>ℹ  Installing wasm-pack
Error: Rust compilation.
at ChildProcess.&lt;anonymous&gt; (/walk-the-dog/node_modules/@wasm-tool/wasm-pack-plugin/plugin.js:221:16)
at ChildProcess.emit (events.js:315:20)
at maybeClose (internal/child_process.js:1048:16)
at Socket.&lt;anonymous&gt; (internal/child_process.js:439:11)
at Socket.emit (events.js:315:20)
at Pipe.&lt;anonymous&gt; (net.js:673:12)</pre>
			<p>If that happens, you'll need to install <code>wasm-pack</code> manually.</p>
			<ol>
				<li value="4"><strong class="bold">Install wasm-pack</strong></li>
			</ol>
			<p>On Linux and <a id="_idIndexMarker017"/>macOS systems <code>wasm-pack</code> is installed with a simple cURL script:</p>
			<pre>curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh</pre>
			<p>Windows users have a separate installer that can be found at <a href="https://rustwasm.github.io">https://rustwasm.github.io</a>.  </p>
			<ol>
				<li value="5"><strong class="bold">Run the server – take two</strong></li>
			</ol>
			<p>Now that <code>wasm-pack</code> is installed, webpack can use it, and you should be able to run the app:</p>
			<pre>npm run start</pre>
			<p>When you see <code>｢</code><code>wdm</code><code>｣</code><code>: Compiled successfully.</code> , you can browse your app at <code>http://localhost:8080</code>. Okay, yes, it's a blank page, but if you open the developer tools console, you should see the following:</p>
			<div><div><img alt="Figure 1.1 – Hello WebAssembly!" src="img/Figure_1.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Hello WebAssembly!</p>
			<p>You've got the application running in the browser, but the Rust ecosystem updates faster <a id="_idIndexMarker018"/>than the template you used can keep up.</p>
			<ol>
				<li value="6"><strong class="bold">Update the Rust edition</strong></li>
			</ol>
			<p>The latest Rust edition, with the most recent Rust idioms and conventions, is 2021. This is changed in the generated <code>Cargo.toml</code> file in the <code>package</code> section, as shown here:</p>
			<pre># You must change these to your own details.
[package]
name = "rust-webpack-template"
description = "Walk the Dog - the game for the Rust Games with WebAssembly book"
version = "0.1.0"
authors = ["Eric Smith &lt;paytonrules@gmail.com&gt;"]
categories = ["wasm"]
readme = "README.md"
<strong class="bold">edition = "2021"</strong></pre>
			<p>It is only the <code>edition</code> field that is changed here.</p>
			<ol>
				<li value="7"><strong class="bold">Update the dependencies</strong></li>
			</ol>
			<p>The dependencies in the generated <code>Cargo.toml</code> file are not going to be the latest and greatest unless you happened to pull the template down the moment it was updated. Since neither of us is that lucky, you're going to want to open up that file and modify the dependencies to the following. Please note that the ellipses are<a id="_idIndexMarker019"/> just there to mark a gap in the file and are not meant to be typed in:</p>
			<pre>wasm-bindgen = "0.2.78"
...
[dependencies.web-sys]
version = "0.3.55"
...
[dev-dependencies]
wasm-bindgen-test = "0.3.28"
futures = "0.3.18"
js-sys = "0.3.55"
wasm-bindgen-futures = "0.4.28"</pre>
			<p>Those are the versions I used while writing this book. If you're feeling adventurous, you can go to <a href="http://crates.io">http://crates.io</a> and find the most recent version of each dependency, which is what I would do, but I am a glutton for punishment. You're probably smarter than me and will use the versions specified here so that the sample code works.</p>
			<ol>
				<li value="8"><strong class="bold">Update console_error_panic_hook</strong></li>
			</ol>
			<p><code>console_error_panic_hook</code> is a very useful crate during the development of a WebAssembly application. It takes panics in Rust code and forwards them to the console so that you can debug them. The current template attempts to hide it behind a feature flag, but unfortunately, there's a bug and it doesn't work. Remember to double-check your generated code; if it doesn't look like what I've reproduced here, the bug may have been fixed, but in the meantime, delete the following code (still in <code>Cargo.toml</code>).</p>
			<pre>[target."cfg(debug_assertions)".dependencies]
console_error_panic_hook = "0.1.5"</pre>
			<p>Then add<a id="_idIndexMarker020"/> the to the [dependencies] section, under wasm-bindgen is a good spot:</p>
			<pre>console_error_panic_hook = "0.1.7"</pre>
			<p>Later, we'll make this a conditional dependency so that you don't deploy it during release builds, but for now, this is enough progress. Who wants to continue messing with <code>config</code> files anyway? I want to draw stuff to the screen!</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">While this application uses an <code>npm init</code> template to create itself, you can use its output to create a <code>cargo generate</code> template so that you don't have to redo these changes every time you create an application, simply by creating a <code>git</code> repository. Of course, if you do that, you'll fall behind changes to the <code>rust-webpack</code> template, so it's a trade-off. If you're curious about using <code>cargo generate</code> to create your own templates, you can find more information here: <a href="https://bit.ly/3hCFWTs">https://bit.ly/3hCFWTs</a>.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor023"/>Drawing to the canvas</h1>
			<p>To write our<a id="_idIndexMarker021"/> game in Rust, we're going to need to draw to the screen, and for that, we'll use the HTML Canvas element using the 2D context. What the canvas provides is an API for drawing directly to the screen, without knowledge of WebGL or using an external tool. It's not the fastest technology in the world but it's perfectly suitable for our small game. Let's start converting our Rust app from <em class="italic">"Hello World"</em> to an <a id="_idIndexMarker022"/>application that draws a <strong class="bold">Sierpiński triangle</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The Sierpiński triangle is a fractal image that is created by drawing a triangle, then subdividing that triangle into four triangles, and then subdividing those triangles into four triangles, and so on. It sounds complicated but, as with many fractals, is created from only a few lines of math:</p>
			<ol>
				<li value="1"><strong class="bold">Add the canvas</strong></li>
			</ol>
			<p>Canvas is an HTML element that lets us draw to it freely, making it an ideal candidate for games. Indeed, at the time of writing, Adobe Flash is officially dead, and if you see a game on the internet, be it 2D or 3D, it's running in a <code>canvas</code> element. Canvas can use WebGL or WebGPU for games, and WebAssembly will work quite well with those technologies, but they are out of the scope of this book. We'll be using the built-in Canvas 2D API and its 2D context. This means you won't have to learn a shading language, and we'll be able to get images <a id="_idIndexMarker023"/>on the screen very quickly. It also means that if you need <a id="_idIndexMarker024"/>to, you can find excellent documentation on the <strong class="bold">Mozilla Developer Network</strong> (<strong class="bold">MDN</strong>) Web Docs website: <a href="https://mzl.la/3tX5qPC">https://mzl.la/3tX5qPC</a>. </p>
			<p>To draw to the canvas, we'll need to add it to the web page. Open up <code>static/index.html</code> and add underneath <code>&lt;body&gt; tag &lt;canvas id="canvas" tabindex="0" height="600" width="600"&gt;Your browser does not support the canvas.&lt;/canvas&gt;</code>. The width and height are pretty arbitrary but seem appropriate for now. The "<code>Your browser does not support the canvas.</code>" message will show up on browsers that don't support HTML Canvas, but there aren't many of those anymore.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Make sure you don't delete the <code>&lt;script&gt;</code> tag. That's running the JavaScript and WebAssembly you're building in this project!</p>
			<ol>
				<li value="2"><strong class="bold">Clean up errors</strong></li>
			</ol>
			<p>Finally, we get to write some Rust code! Well, we get to delete some Rust code anyway. In the <code>src/lib.rs</code> file, you'll see a function named <code>main_js()</code> with the following code:</p>
			<pre>// This provides better error messages in debug mode.
// It's disabled in release mode so it doesn't bloat 
   up the file size.
    #[cfg(debug_assertions)]
    console_error_panic_hook::set_once();</pre>
			<p>You can go<a id="_idIndexMarker025"/> ahead and remove the comments and the <code>[cfg(debug_annotations)]</code> annotation. For the time being, we'll leave that running in our build and will remove it when preparing for production with a feature flag.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you're seeing an error in your editor that says the <code>console::log_1(&amp;JsValue::from_str("Hello world!"))</code> code is missing an unsafe block, don't worry – that error is wrong. Unfortunately, it's a bug in rust-analyzer that's been addressed in this issue: <a href="https://bit.ly/3BbQ39m">https://bit.ly/3BbQ39m</a>. You'll see this error with anything that uses procedural macros under the hood. If you're using an editor that supports experimental settings, you may be able to fix the problem; check the <code>rust-analyzer.experimental.procAttrMacros</code> setting. When in doubt, check the output from <code>npm run start</code>, as that is the more accurate source for compiler errors.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you diverge from this book and decide to deploy, go to <a href="B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226"><em class="italic">Chapter 10</em></a>, <em class="italic">Continuous Deployment</em>, and learn how to hide that feature behind a feature flag in release mode, so you don't deploy code you don't need into production.</p>
			<p>Removing that code will remove the <code>warning: Found 'debug_assertions' in 'target.'cfg(...)'.dependencies'.</code> message on startup of the app. At this point, you may have noticed that I'm not telling you to restart the server after changes, and that's because <code>npm start</code> runs the <code>webpack-dev-server</code>, which automatically detects changes and then rebuilds and refreshes the app. Unless <a id="_idIndexMarker026"/>you're changing the webpack config, you sho<a id="_idTextAnchor024"/>uldn't have to restart.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor025"/>The current code</h2>
			<p>Up to now, I've been<a id="_idIndexMarker027"/> telling you what to do, and you've been blindly doing it because you're following along like a good reader. That's very diligent of you, if a little trusting, and it's time to take a look at the current source and see just what we have in our WebAssembly library. First, let's start <a id="_idTextAnchor026"/>with the <code>use</code> directives.</p>
			<pre>use wasm_bindgen::prelude::*;
use web_sys::console;</pre>
			<p>The first<a id="_idIndexMarker028"/> import <a id="_idIndexMarker029"/>is the <code>prelude</code> for <code>wasm_bindgen</code>. This brings in the macros you'll see shortly, and a couple of types that are pretty necessary for writing Rust for the web. Fortunately, it's not a lot, and shouldn't pollute the namespace too much.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">"<code>*</code>' syntax and import everything from a given module. If the module has a lot of exported names, you have now those same names in your project, and they aren't obvious when you're coding. If, for instance, <code>wasm_bindgen::prelude</code> had a function named <code>add</code> in it and you also had a function named <code>add</code> in your namespace, they would collide. You can work around this by using explicit namespaces when you call the functions, but then why use <code>*</code> in the first place? By convention, many Rust packages have a module named <code>prelude</code>, which can be imported via <code>*</code> for ease of use; other modules should be imported with their full name.</p>
			<p>The other import is <code>web_sys::console</code>, which brings in the <code>console</code> namespace from <code>web_sys</code>, which in turn mimics the <code>console</code> namespace in JavaScript. This is a good time to talk a little more in detail about what these two modules do. I've said it before but it probably bears repeating – <code>wasm_bindgen</code> provides the capability to bind JavaScript functions so you can call them in WebAssembly and to expose your WebAssembly functions to JavaScript. There's that language again, the one we're trying to avoid by writing <a id="_idIndexMarker031"/>Rust, but it can't be avoided because we're working in a browser.</p>
			<p>In fact, one of the limitations of WebAssembly is that it cannot manipulate the DOM, which is a fancy way of saying that it can't change the web page. What it can do is call functions in JavaScript, which in turn do that work. In addition, JavaScript knows nothing about your WebAssembly types, so any data that is passed to a JavaScript object is marshaled into shared memory and then pulled back out by JavaScript so that it can turn it into something it understands. This is a LOT of code to write over and over again, and that is what the <code>wasm-bindgen</code> crate does for you. Later, we'll use it to bind our own custom bindings to third-party JavaScript code, but what about all the functions already built into the browser, such as <code>console.log</code>? That's where <code>web-sys</code> comes in. It uses <code>wasm-bindgen</code> to bind to all the functions in the browser environment so that you don't have to manually specify them. Think of it as a helper crate that says, <em class="italic">"Yeah, I know you'll need all these functions so I created them for you."</em></p>
			<p>So, to sum up, <code>wasm-bindgen</code> gives you the capability to communicate between WebAssembly and JavaScript, and <code>web-sys</code> contains a large number of pre-created bindings. If you're particularly interested in how the calls between WebAssembly and JavaScript <a id="_idIndexMarker032"/>work, check out this article by Lin Clark, which explains it in great detail, and with pictures: <a href="https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/">https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/</a>.</p>
			<h3>The wee allocator</h3>
			<p>After the<a id="_idIndexMarker033"/> use<a id="_idIndexMarker034"/> statements you'll see a comment block referring to the `wee_alloc` feature, which is a WebAssembly allocator that uses much less memory than the default Rust allocator. We're not using it, and it was disabled in the <code>Cargo.toml</code> file, so you can delete it from both <a id="_idTextAnchor028"/>the source code and <code>Cargo.toml</code>.</p>
			<h3>The main</h3>
			<p>Finally, we get<a id="_idIndexMarker035"/> to the <a id="_idIndexMarker036"/>main part of our program:</p>
			<pre>#[wasm_bindgen(start)]
pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {</pre>
			<p>The <code>wasm_bindgen(start)</code> annotation exports <code>main_js</code> so that it can be called by JavaScript, and the <code>start</code> parameter identifies it as the starting point of the program. If you're curious, you can take a look at <code>pkg/index_bg.wasm.d.ts</code> to see what was generated by it. You'll also want to take note of the return value, <code>Result</code>, where the error type can be <code>JsValue</code>, which represents an object owned by JavaScript and not Rust.</p>
			<p>At this point, you may start to wonder how you'll keep track of what's JavaScript and what's Rust, and I'd advise you to not worry too much about it right now. There's a lot of jargon popping up and there's no way you'll keep it all in your head; just let it swim around in there and when it comes up again, I'll explain it again. <code>JsValue</code> is just a representative JavaScript object in your Rust code.</p>
			<p>Finally, let's look at the contents:</p>
			<pre>console_error_panic_hook::set_once();
// Your code goes here!
console::log_1(&amp;JsValue::from_str("Hello world!"));
Ok(())</pre>
			<p>The first line sets the panic hook, which just means that any panics will be redirected to the web browser's console. You'll need it for debugging, and it's best to keep it at the beginning of the program. Our one line, our <em class="italic">Hello World</em>, is <code>console::log_1(&amp;JsValue::from_str("Hello world!"));</code>. That calls the JavaScript <code>console.log</code> function, but it's using the version that's <code>log_1</code> because the JavaScript version takes varying parameters. This is something that's going to come up again and again when using <code>web-sys</code>, which is that JavaScript supports <code>varargs</code> and Rust doesn't. So instead, many variations are created in the <code>web-sys</code> module to match the alternatives. If a JavaScript function you expect doesn't exist, then take a look at the Rust documents for <code>web-sys</code> (<a href="https://bit.ly/2NlRmOI">https://bit.ly/2NlRmOI</a>) and see whether there are versions that are similar but built to account for multiple parameters.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">A series of macros for several of the more commonly used functions (such as <code>log</code>) could solve this problem, but that's an exercise for the reader.</p>
			<p>Finally, the<a id="_idIndexMarker037"/> function<a id="_idIndexMarker038"/> returns <code>Ok(())</code>, as is typical of Rust programs. Now that we've seen the generated code<a id="_idTextAnchor029"/>, let's break it down with our own.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor030"/>Drawing a triangle</h2>
			<p>We've spent a lot <a id="_idIndexMarker039"/>of time digging into the code we currently have, and it's a lot to just write <em class="italic">"Hello World"</em> to the console. Why don't we have some fun and actually draw to the canvas?</p>
			<p>What we're going to do is mimic the following JavaScript code in Rust:</p>
			<pre>canvas = window.document.getElementById("canvas")
context = canvas.getContext("2d")
context.moveTo(300, 0)
context.beginPath()
context.lineTo(0, 600)
context.lineTo(600, 600)
context.lineTo(300, 0)
context.closePath()
context.stroke()
context.fill()</pre>
			<p>This code grabs the canvas element we put in <code>index.html</code>, grabs its 2D context, and then draws a<a id="_idIndexMarker040"/> black triangle. One way to draw a shape on the context is to draw a line path, then stroke, and, in this case, fill it. You can actually see this in the browser using the web developer tools built into most browsers. This screenshot is from Firefox:</p>
			<div><div><img alt="Figure 1.2 – A simple canvas triangle" src="img/Figure_1.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – A simple canvas triangle</p>
			<p>Let's do the same thing in our Rust program. You'll see that it's a little…different. Start with the quick addition of a <code>use</code> statement at the top:</p>
			<pre>use wasm_bindgen::JsCast;</pre>
			<p>Then, replace<a id="_idIndexMarker041"/> the existing <code>main_js</code> function with the following:</p>
			<pre>console_error_panic_hook::set_once();
let window = web_sys::window().unwrap();
let document = window.document().unwrap();
let canvas = document
    .get_element_by_id("canvas")
    .unwrap()
    .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()
    .unwrap();
let context = canvas
    .get_context("2d")
    .unwrap()
    .unwrap()
    .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()
    .unwrap();
context.move_to(300.0, 0.0); // top of triangle
context.begin_path();
context.line_to(0.0, 600.0); // bottom left of triangle
context.line_to(600.0, 600.0); // bottom right of triangle
context.line_to(300.0, 0.0); // back to top of triangle
context.close_path();
context.stroke();
context.fill();
Ok(())</pre>
			<p>There are a few differences that stand out, but at a glance, you may just feel like Rust code is a lot <em class="italic">noisier</em> than JavaScript code, and that's true. You might be inclined to say that it's less elegant or isn't as clean, but I'd say that's in the eye of the beholder. JavaScript is a dynamically typed language and it shows. It ignores <code>undefined</code> and <code>null</code>, and can just crash if any of the values are not present. It uses duck typing to call all the functions on the context, which means that if the function is present, it simply calls it; otherwise, it throws exceptions.</p>
			<p>Rust code takes a very different approach, one that favors explicitness and safety but at the cost of the code having extra noise. In Rust, you have to be more explicit when calling methods on structs, hence the casting, and you have to acknowledge <code>null</code> or failed <code>Result</code> types, hence all the unwraps. I've spent years using dynamic languages, including JavaScript, and I like them a lot. I certainly liked them a lot better than writing in C++, which I find overly verbose without really granting some of the safety advantages, but I think that with some tweaks, we can make Rust code nearly as elegant as JavaScript without glossing over exceptions and results.</p>
			<p>My rant <a id="_idIndexMarker042"/>aside, if you're still running the program, you'll notice one minor detail – the Rust code doesn't compile! This leads me to the first thing we'll need to cover when translating JavaScript code to Rust code.</p>
			<h3>web-sys and feature flags</h3>
			<p>The <code>web-sys</code> crate<a id="_idIndexMarker043"/> makes <a id="_idIndexMarker044"/>heavy use <a id="_idIndexMarker045"/>of feature<a id="_idIndexMarker046"/> flags to keep its size down. This means that every time you want to use a function and it doesn't exist, you'll need to check which feature flag it's tied to, which is in its documentation, and add it to <code>Cargo.toml</code>. Fortunately, this is well documented and easy enough to do; we don't even need to restart the server!</p>
			<p>Looking at our errors, we should see the following:</p>
			<pre>error[E0425]: cannot find function 'window' in crate 'web_sys'
--&gt; src/lib.rs:18:27
|
18 | let window = web_sys::window().unwrap();
|                           ^^^^^^ not found in 'web_sys'</pre>
			<p>There are a few more errors of the same kind, but what you see here is that <code>window</code> is not in the <code>web_sys</code> module. Now, if you check the documentation for the <code>window</code> function in <code>web-sys</code> at <a href="https://bit.ly/3ak3sAR">https://bit.ly/3ak3sAR</a>, you'll see that, yes, it does exist, but there is the <code>This API requires the following crate features to be activated: Window </code>message.</p>
			<p>Open the <code>cargo.toml</code> file and look for <code>dependencies.web-sys</code>. You'll see that it has a <code>features</code> entry with just <code>["console"]</code> in it; go ahead and add <code>"Window"</code>,<code> "Document"</code>, <code>"HtmlCanvasElement"</code>, <code>"CanvasRenderingContext2d"</code>, and <code>"Element"</code> to that list. To be clear, you don't need all those feature flags for just the <code>window</code> function; that's all of the functions we're using.</p>
			<p>You'll notice <a id="_idIndexMarker047"/>the<a id="_idIndexMarker048"/> project <a id="_idIndexMarker049"/>will <a id="_idIndexMarker050"/>rebuild automatically and should build successfully. If you look in the browser, you'll see your own black triangle! Let's extend it and learn a bit more about how we did it.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When a function you expect to exist on <code>web-sys</code> doesn't, go and check the feature flags in the documents.</p>
			<h3>DOM interaction</h3>
			<p>You'll <a id="_idIndexMarker051"/>notice<a id="_idIndexMarker052"/> that the method for drawing the triangle after you get the context looks essentially the same as the method in JavaScript – draw a line path, stroke, and fill it. The code at the top that interacted with the DOM looks…different. Let's break down what's going on here:</p>
			<ul>
				<li>Unwrapping option</li>
			</ul>
			<p>Getting the <code>Window</code> is just a function in the <code>web-sys</code> crate, one you enabled when you added the <code>Window</code> feature to <code>Cargo.toml</code>. However, you'll notice it's got <code>unwrap</code> at the end:</p>
			<pre>let window = web_sys::window().unwrap();</pre>
			<p>In JavaScript, <code>window</code> can be <code>null</code> or <code>undefined</code>, at least theoretically, and in Rust, this gets translated into <code>Option&lt;Window&gt;</code>. You can see that <code>unwrap</code> is applied to the result of <code>window()</code>, <code>document()</code>, and <code>get_element_by_id()</code> because all of them return <code>Option&lt;T&gt;</code>.</p>
			<ul>
				<li><code>dyn_into</code></li>
			</ul>
			<p>What the heck is <code>dyn_into</code>? Well, this oddity accounts for the difference between the way JavaScript does typing and the way Rust does. When we retrieve the canvas with <code>get_element_by_id</code>, it returns <code>Option&lt;Element&gt;</code>, and <code>Element</code> does not have any functions relating to the canvas. In JavaScript, you can use dynamic typing to assume the element has the <code>get_context</code> method, and if you're wrong, the program will throw an exception. This<a id="_idIndexMarker053"/> is anathema to Rust; indeed, this is <a id="_idIndexMarker054"/>a case where one developer's convenience is another developer's potential bug in hiding, so in order to use <code>Element</code>, we have to call the <code>dyn_into</code> function to cast it into <code>HtmlCanvasElement</code>. This method was brought into scope with the `use wasm_bindgen::JsCast` declaration.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Note that <code>HtmlCanvasElement</code>, <code>Document</code>, and <code>Element</code> were all also feature flags you had to add in <code>web-sys</code>.</p>
			<ul>
				<li>Two unwraps?</li>
			</ul>
			<p>After calling <code>get_context("2d")</code>, we actually call <code>unwrap</code> twice; that's not a typo. What's going on is that <code>get_context</code> returns a <code>Result&lt;Option&lt;Object&gt;&gt;</code>, so we unwrap it twice. This is another case where the game can't recover if this fails, so <code>unwrap</code> is okay, but I wouldn't complain if <a id="_idIndexMarker055"/>you replaced those with <code>ex<a id="_idTextAnchor031"/>pect</code> so that <a id="_idIndexMarker056"/>you can give a clearer error message. </p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor032"/>A Sierpiński triangle</h2>
			<p>Now let's have<a id="_idIndexMarker057"/> some real fun, and draw a Sierpiński triangle a few levels deep. If you're up for a challenge, you can try and write the code yourself before following along with the solution presented here. The way the algorithm works is to draw the first triangle (the one you are already drawing) and then draw another three triangles, where the first triangle has the same top point but its other two points are at the halfway point on each side of the original triangle. Then, draw a second triangle on the lower left, with its top at the halfway point of the left side, its lower-right point at the halfway point of the bottom of the original triangle, and its lower-left point at the lower-left point of the original triangle. Finally, you create a third triangle in the lower-right corner of the original triangle. This leaves a "hole" in the middle shaped like an upside-down triangle. This is much easier to visualize than it is to explain, so how about a picture?</p>
			<div><div><img alt="Figure 1.3 – A one-level Sierpiński triangle" src="img/Figure_1.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – A one-level Sierpiński triangle</p>
			<p>Each of the <a id="_idIndexMarker058"/>numbered triangles was one that was drawn. The upside-down blue triangle is what's left of the original triangle because we didn't draw over it.</p>
			<p>So that's one triangle subdivided into four. Now, the algorithm works recursively, taking each triangle and subdividing again. So, two levels deep, it looks like this:</p>
			<div><div><img alt="Figure 1.4 – A two-level Sierpiński triangle&#13;&#10;" src="img/Figure_1.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – A two-level Sierpiński triangle</p>
			<p>Note that it <em class="italic">doesn't </em>subdivide<a id="_idIndexMarker059"/> the upside-down triangle in the center, just the three purple ones that you created. Indeed, all the triangles with their points down are just "happy accidents" that make the shape look cool. You now know enough at this point to draw your own Sierpiński triangle, with one catch – you should remove the <code>fill</code> statement on context. Otherwise, all the triangles will be filled black and you<a id="_idIndexMarker060"/> <a id="_idTextAnchor033"/>won't be able to see them. Go ahead and give it a try.</p>
			<h3>Drawing the Sierpiński triangle</h3>
			<p>So, did you give <a id="_idIndexMarker061"/>it a try? No, I wouldn't either; I guess we have a lot in common. To get started with creating a Sierpiński triangle, let's replace the hardcoded triangle with a triangle function. Here's the first pass at <code>draw_triangle</code>:</p>
			<pre>fn draw_triangle(context: &amp;web_sys::CanvasRenderingContext2d,     points: [(f64, f64); 3]) {
        let [top, left, right] = points;
        context.move_to(top.0, top.1);
        context.begin_path();
        context.line_to(left.0, left.1);
        context.line_to(right.0, right.1);
        context.line_to(top.0, top.1);
        context.close_path();
        context.stroke();
}</pre>
			<p>There are a couple of small changes from the hard-coded version that we started with. The function takes a reference to the context and a list of three points. Points themselves are represented by tuples. We've also gotten rid of the <code>fill</code> function, so we only have an empty triangle. Replace the inline <code>draw_triangle</code> with the function call, which should look like this:</p>
			<pre>let context = canvas
    .get_context("2d")
    .unwrap()
    .unwrap()
    .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()
    .unwrap();
draw_triangle(&amp;context, [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)]);</pre>
			<p>Now that you're drawing one empty triangle, you're ready to start drawing the recursive triangles. Rather than starting with recursion, let's draw the first subdivision by drawing three more <a id="_idIndexMarker062"/>triangles. The first will have the same top point and two side points:</p>
			<pre>draw_triangle(&amp;context, [(300.0, 0.0), (150.00, 300.0), (450.0, 300.0)]);</pre>
			<p>Note that the third tuple has an x halfway between <code>300.0</code> and <code>600.0</code>, not between <code>0</code> and <code>600.0</code>, because the top point of the triangle is halfway between the other two points. Also note that y gets larger as you go down, which is upside-down compared to many 3D systems. Now, let's add the lower-left and lower-right triangles:</p>
			<pre>draw_triangle(&amp;context, [(150.0, 300.0), (0.0, 600.0), (300.0, 600.0)]);
draw_triangle(&amp;context, [(450.0, 300.0), (300.0, 600.0), (600.0, 600.0)]);</pre>
			<p>Your triangles should look like this:</p>
			<div><div><img alt="Figure 1.5 – Your triangles" src="img/Figure_1.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Your triangles</p>
			<p>You will start<a id="_idIndexMarker063"/> to see a pattern at this point, and we can begin to turn our hardcoded triangles into an algorithm. We'll create a function called <code>sierpinski</code> that takes the context, the triangle dimensions, and a depth function so that we only draw as many triangles as we want, instead of drawing them to infinity and crashing the browser. Then, we'll move those functions we called into that function:</p>
			<pre>fn sierpinski(context: &amp;web_sys::CanvasRenderingContext2d, points: [(f64, f64); 3], depth: u8) {
    draw_triangle(&amp;context, [(300.0, 0.0), (0.0, 600.0), 
     (600.0, 600.0)]);
    draw_triangle(&amp;context, [(300.0, 0.0), (150.00, 300.0), 
     (450.0, 300.0)]);
    draw_triangle(&amp;context, [(150.0, 300.0), (0.0, 600.0), 
     (300.0, 600.0)]);
    draw_triangle(&amp;context, [(450.0, 300.0), (300.0, 
     600.0), (600.0, 600.0)]);
}</pre>
			<p>This function <a id="_idIndexMarker064"/>currently ignores everything except the context, but you can replace those four <code>draw_triangle</code> calls from <code>main_js</code> and replace them with a call to <code>sierpinski</code>:</p>
			<pre>sierpinski(&amp;context, [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)], 2);</pre>
			<p>It's important that you only send a depth of <code>2</code> for now so that the image will continue to look the same as we progress. Think of this call as a proto-unit test, guaranteeing our behavior doesn't change while we refactor. Now, in <code>sierpinski</code>, take the first triangle and have it use the passed-in points:</p>
			<pre>fn sierpinski(context: &amp;web_sys::CanvasRenderingContext2d, points: [(f64, f64); 3], depth: u8) {
    draw_triangle(&amp;context, points);
    ...</pre>
			<p>Then, after drawing the triangle, reduce the depth by one and see if it is still greater than <code>0</code>. Then, draw the rest of the triangles:</p>
			<pre>...
let depth = depth - 1;
if depth &gt; 0 {
    draw_triangle(&amp;context, [(300.0, 0.0), (150.00, 300.0), 
     (450.0, 300.0)]);
    draw_triangle(&amp;context, [(150.0, 300.0), (0.0, 600.0), 
     (300.0, 600.0)]);
    draw_triangle(&amp;context, [(450.0, 300.0), (300.0, 
     600.0), (600.0, 600.0)]);
}</pre>
			<p>Now, to complete the<a id="_idIndexMarker065"/> recursion, you can replace all those <code>draw_triangle</code> calls with calls into <code>sierpinski</code>:</p>
			<pre>if depth &gt; 0 {
    sierpinski(
        &amp;context,
        [(300.0, 0.0), (150.00, 300.0), (450.0, 300.0)],
        depth,
    );
    sierpinski(
        &amp;context,
        [(150.0, 300.0), (0.0, 600.0), (300.0, 600.0)],
        depth,
    );
    sierpinski(
        &amp;context,
        [(450.0, 300.0), (300.0, 600.0), (600.0, 600.0)],
        depth,
    );
    }</pre>
			<p>So far so good – you should still see a triangle subdivided into four triangles. Finally, we can actually calculate the midpoints of each line on the original triangle and use those to create the recursive <a id="_idIndexMarker066"/>triangles, instead of hardcoding them:</p>
			<pre>let [top, left, right] = points;
if depth &gt; 0 {
    let left_middle = ((top.0 + left.0) / 2.0, (top.1 + 
     left.1) / 2.0);
    let right_middle = ((top.0 + right.0) / 2.0, (top.1 + 
     right.1) / 2.0);
    let bottom_middle = (top.0, right.1);
    sierpinski(&amp;context, [top, left_middle, right_middle], 
     depth);
    sierpinski(&amp;context, [left_middle, left, 
     bottom_middle], depth);
    sierpinski(&amp;context, [right_middle, bottom_middle, 
     right], depth);
}</pre>
			<p>Calculating the midpoint of a line segment is done by taking the <em class="italic">x</em> and <em class="italic">y</em> coordinates of each end, adding those together, and then dividing them by two. While the preceding code works, let's make it clearer by writing a new function, as shown here:</p>
			<pre>fn midpoint(point_1: (f64, f64), point_2: (f64, f64)) -&gt; (f64, f64) {
    ((point_1.0 + point_2.0) / 2.0, (point_1.1 + point_2.1) 
    / 2.0)
}</pre>
			<p>Now, we can use<a id="_idIndexMarker067"/> that in the preceding function, for clarity:</p>
			<pre>if depth &gt; 0 {
    let left_middle = midpoint(top, left);
    let right_middle = midpoint(top, right);
    let bottom_middle = midpoint(left, right);
    sierpinski(&amp;context, [top, left_middle, right_middle], 
     depth);
    sierpinski(&amp;context, [left_middle, left, 
     bottom_middle], depth);
    sierpinski(&amp;context, [right_middle, bottom_middle, 
     right], depth);
}</pre>
			<p>If you've been following along, you should make sure you're still showing a triangle with four inside to ensure you haven't made any mistakes. Now for the big reveal – go ahead and change the depth to <code>5</code> in the original <code>Sierpinski</code> call:</p>
			<pre>sierpinski(&amp;context, [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)], 5);</pre>
			<p>You should see a recursive drawing of triangles, like this:</p>
			<div><div><img alt="Figure 1.6 – A recursive drawing of triangles&#13;&#10;" src="img/Figure_1.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – A recursive drawing of triangles</p>
			<p>Looking good! But what about those colors we saw in<a id="_idTextAnchor034"/> the original diagrams? They make it much <a id="_idIndexMarker068"/>more interesting.</p>
			<h3>When libraries aren't compatible</h3>
			<p>The earlier<a id="_idIndexMarker069"/> examples of this image had the triangles filled in with a different random color at each recursive layer. So, the first triangle was one color, three and four were another, the next nine another, and so on. It makes for a more interesting image <em class="italic">and</em> it provides a good example of what to do when a library isn't completely WebAssembly-compatible.</p>
			<p>To create a random color, we'll need a random number generator, and that is not part of the standard library but instead found in a crate. You can add that crate by changing the <code>Cargo.toml</code> file to include it as a dependency:</p>
			<pre>console_error_panic_hook = "0.1.7"
rand = "0.8.4"</pre>
			<p>When you do this, you'll get a compiler error that looks like the following (although your message may differ slightly):</p>
			<pre>error: target is not supported, for more information see: https://docs.rs/getrandom/#unsupported-targets
   --&gt; /usr/local/cargo/registry/src/github.com-
   1ecc6299db9ec823/getrandom-0.2.2/src/lib.rs:213:9
    |
213 | /         compile_error!("target is not supported, for more information see: \
214 | |                         https://docs.rs/getrandom/#unsupported-targets");</pre>
			<p>This is a case where a transitive dependency, in this case <code>getrandom</code>, does not compile on the WebAssembly target. In this case, it's an extremely helpful error message, and if you follow the link, you'll get the solution in the documentation. Specifically, you need to enable <code>js</code> in the feature flags for <code>getrandom</code>. Go back to your <code>Cargo.toml</code> file and add the following:</p>
			<pre>getrandom = { version = "0.2.3", features = ["js"] }</pre>
			<p>This adds the <code>getrandom</code> dependency with the <code>js</code> feature enabled, and your code will begin compiling again. The lesson to take away from this is that not every Rust crate will compile on the WebAssembly target, and when that happens, you'll need to check the documents.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When a crate <a id="_idIndexMarker070"/>won't compile <em class="italic">slowly</em>, read the error message and follow the instructions. It's very easy to skim right over the re<a id="_idTextAnchor035"/>ason the build is breaking, especially when you're frustrated.</p>
			<h3>Random colors</h3>
			<p>Now that we've <a id="_idIndexMarker071"/>got the random create building with our project, let's change the color of the triangles as we draw them to a random color. To do that, we'll set <code>fillStyle</code> with a color before we draw the triangle, and we'll add a <code>fill</code> command. This is, generally, how the <code>Context2D</code> API works. You set up the state of the context and then execute commands with that state set. It takes a little getting used to but you'll get the hang of it. Let's add <code>color</code> as a parameter of the three <code>u8</code> tuples to <code>draw_triangle</code>:</p>
			<pre>fn draw_triangle(
    context: &amp;web_sys::CanvasRenderingContext2d,
    points: [(f64, f64); 3],
    color: (u8, u8, u8),
) {</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Colors are represented here as three components, red, green, and blue, where each value can go from <code>0</code> to <code>255</code>. We're using tuples in this chapter because we can make progress quickly, but if it's starting to bother you, you're welcome to make proper <code>struct</code>s.</p>
			<p>Now that <code>draw_triangle</code> needs a color, our application doesn't compile. Let's move to the <code>sierpinski</code> function and pass a color to it as well. We're going to send the color to the <code>sierpinski</code> function, instead of generating it there, so that we can get one color at every level. The first generation will be one solid color, then the second will all be one color, and <a id="_idIndexMarker072"/>then the third a third color, and so on. So let's add that:</p>
			<pre>fn sierpinski(
    context: &amp;web_sys::CanvasRenderingContext2d,
    points: [(f64, f64); 3],
    color: (u8, u8, u8),
    depth: u8,
) {
    draw_triangle(&amp;context, points, color);
    let depth = depth - 1;
    let [top, left, right] = points;
    if depth &gt; 0 {
        let left_middle = midpoint(top, left);
        let right_middle = midpoint(top, right);
        let bottom_middle = midpoint(left, right);
        sierpinski(&amp;context, [top, left_middle, 
         right_middle], <strong class="bold">color</strong>, depth);
        sierpinski(&amp;context, [left_middle, left, 
         bottom_middle], <strong class="bold">color</strong>, depth);
        sierpinski(&amp;context, [right_middle, bottom_middle, 
         right], <strong class="bold">color</strong>, depth);
    }
}</pre>
			<p>I put <code>color</code> as the third parameter and not the fourth because I think it looks better that way. Remember to pass color to the other calls. Finally, so that we can compile, we'll send a color to the initial <code>sierpinski</code> call:</p>
			<pre>sierpinski(
    &amp;context,
    [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)],
    (0, 255, 0),
    5,
);</pre>
			<p>Since this is an RGB color, <code>(0, 255, 0)</code> represents green. Now, we've made our code compile, but it doesn't do anything, so let's work back downward from the original call and into <a id="_idIndexMarker073"/>the <code>sierpinski</code> function again. Instead of just passing the color through, let's create a new tuple that has a random number for each component. You'll need to add <code>use rand::prelude::*;</code> to the use declarations at the top. Then, add the following code to the <code>sierpinski</code> function, after the <code>if depth &gt; 0</code> check:</p>
			<pre>let mut rng = thread_rng();
let next_color = (
    rng.gen_range(0..255),
    rng.gen_range(0..255),
    rng.gen_range(0..255),
);
...
sierpinski(
    &amp;context,
    top, left_middle, right_middle],
    next_color,
    depth,
);
sierpinski(
    &amp;context,
    [left_middle, left, bottom_middle],
    next_color,
    depth,
);
sierpinski(
    &amp;context,
    [right_middle, bottom_middle, right],
    next_color,
    depth,
);</pre>
			<p>Inside the<a id="_idIndexMarker074"/> depth check, we randomly generate <code>next_color</code> and then pass it along to all the recursive <code>sierpinski</code> calls. But of course, our output <em class="italic">still</em> doesn't look any different. We never changed <code>draw_triangle</code> to change the color! This is going to be a little weird because the <code>context.fillStyle</code> property takes <code>DOMString</code> in JavaScript, so we'll need to do a conversion. At the top of <code>draw_triangle</code>, add two lines:</p>
			<pre>let color_str = format!("rgb({}, {}, {})", color.0, color.1, color.2);
context.set_fill_style(&amp;wasm_bindgen::JsValue::from_str(&amp;color_str));</pre>
			<p>On line one, we convert our tuple of three unsigned integers to a string reading <code>"rgb(255, 0, 255)"</code>, which is what the <code>fillStyle</code> property expects. On the second line, we use <code>set_fill_style</code> to set it, doing that funky conversion. There are two things that you need to understand with this function. The first is that, generally, JavaScript properties are just public and you set them, but <code>web-sys</code> generates <code>getter</code> and <code>setter</code> functions. The second is that these generated functions frequently take <code>JsValue</code> objects, which represent an object owned by JavaScript. Fortunately, <code>wasm_bindgen</code> has factory functions for these, so we can create them <a id="_idIndexMarker075"/>easily and use the compiler as our guide.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Whenever you translate from JavaScript code to Rust, make sure that you check the documentation of the corresponding functions to see what types are needed. Passing a string to JavaScript isn't always as simple as you might think.</p>
			<p>Finally, we actually need to fill the triangles to see those colors, so after <code>context.stroke()</code>, you need to restore that <code>context.fill()</code> method you deleted earlier, and ta-da!</p>
			<div><div><img alt="Figure 1.7 – Filled triangles" src="img/Figure_1.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Filled triangl<a id="_idTextAnchor036"/>es</p>
			<p>You've <a id="_idIndexMarker076"/>done it, and you're ready to start creating a real game.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor037"/>Summary</h1>
			<p>In this chapter, we've done a <em class="italic">lot</em>. We've written our first WebAssembly app using Rust, moving from <em class="italic">"Hello World"</em> to drawing in the browser with HTML Canvas. You've added crates, run a development server, and interacted with the DOM. You've learned a lot about interacting with the browser, including the following:</p>
			<ul>
				<li>Creating the main entry point with <code>#[wasm_bindgen(start)]</code></li>
				<li>Translating JavaScript code to Rust code</li>
				<li>Dealing with crates that compile to JavaScript</li>
			</ul>
			<p>You've also been introduced to HTML Canvas. Frankly, it's been a bit of a whirlwind, so don't worry if some information flew over your head, as we'll cover many of these topics again – including in the next chapter, where we'll start drawing sprites.</p>
		</div>
	</body></html>