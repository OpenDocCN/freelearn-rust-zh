<html><head></head><body>
		<div id="_idContainer013">
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Hello WebAssembly</h1>
			<p>Let's cut to the chase – if you're holding this book, you probably already know you love Rust, and you<a id="_idIndexMarker000"/> think <strong class="bold">WebAssembly</strong> is a great way to deploy your Rust programs to the web. Good news – you're right! Rust and WebAssembly are a match made in programmer heaven, and while WebAssembly is still in its early days, game development is an ideal candidate for WebAssembly. I am excited to be guiding you through building a game for the web in Stack Overflow's "most-loved" language, Rust.</p>
			<p>This chapter is all about equipping yourself with the tools for the game development journey. In this chapter, we'll cover the following topics: </p>
			<ul>
				<li>What is WebAssembly?</li>
				<li>Creating a Rust and WebAssembly project skeleton</li>
				<li>Translating JavaScript code into Rust code</li>
				<li>Drawing to the screen with HTML5 Canvas<a id="_idTextAnchor016"/></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>To follow along with the project skeleton, you'll need to install <strong class="source-inline">rustup</strong> to install the Rust toolchains. This can be found at <a href="https://rustup.rs/">https://rustup.rs/</a>. While you can install Rust and its various toolchains without using the <strong class="source-inline">rustup</strong> tool, it's not trivial, and I won't be documenting it here. You'll also need an editor for writing Rust code, and while you can use virtually any editor with rust-analyzer, if you're new to writing Rust, I'd recommend Visual Studio Code and the Rust extension found at <a href="https://bit.ly/3tAUyH2">https://bit.ly/3tAUyH2</a>. It's easy to set up and works right out of the box.</p>
			<p>Finally, you'll need a web browser, and in this chapter, you'll need some familiarity with the terminal and <strong class="bold">Node.js</strong>. If you get stumped, the code for this chapter is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1</a>. The final code for the entire book is in the main branch at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly</a>.<a id="_idTextAnchor018"/></p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3qMV44E">https://bit.ly/3qMV44E</a></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>What is WebAssembly?</h1>
			<p>You picked up <a id="_idIndexMarker001"/>this book (thanks!) so in all likelihood, you have some idea of what WebAssembly<a id="_idIndexMarker002"/> is, but just in case, let's grab a definition from <a href="https://WebAssembly.org">https://WebAssembly.org</a>:</p>
			<p class="author-quote">"WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications."</p>
			<p>In other words, <strong class="bold">Wasm</strong> is a binary format that we can compile other languages to so that we can run them in the browser. This is different than transpiling or source-to-source compiling, where languages such as TypeScript are converted into JavaScript for running in JavaScript environments. Those languages are still ultimately running JavaScript, whereas Wasm is bytecode. This makes it a smaller download and parsing and compiling steps are removed when running it, which can lead to significant performance improvements. But let's be honest – you're not using Rust and Wasm for the performance improvements, which aren't guaranteed anyway. You're using it because you like Rust.</p>
			<p>And that's okay!</p>
			<p>Rust has a great type system, excellent developer tooling, and a fantastic community. While WebAssembly was originally created with C and C++ in mind, Rust is a fantastic language for WebAssembly for all the reasons you love Rust and more. Now, for most of the web's existence, writing applications to run in a browser meant writing JavaScript, and over the years, JavaScript has evolved into a suitably modern language for that purpose. I'm not here to tell you that if you like JavaScript you should stop, but if you love Rust, you should absolutely start compiling to Wasm and running apps in the browser.</p>
			<p class="callout-heading">Important Note </p>
			<p class="callout">This book is focused on making web-based games with Rust and Wasm, but you can absolutely run Wasm apps in server-side environments such as Node.js. If you're interested in that, you can check out the book <em class="italic">Learn WebAssembly</em> by Mike Rourke, which can be found at <a href="https://bit.ly/2N89prp">https://bit.ly/2N89prp</a>, or the official <strong class="source-inline">wasm-bindgen</strong> guide at <a href="https://bit.ly/39WC63G">https://bit.ly/39WC63G</a>.</p>
			<p class="callout-heading">Important Note </p>
			<p class="callout">This book assumes some familiarity with Rust, although you do not need to be an expert. If at any time you're confused by a Rust concept, I highly encourage you to stop and check <em class="italic">"the book"</em>, <em class="italic">The Rust Programming Language</em>, available for free at <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>. </p>
			<p>So, now that I've <a id="_idIndexMarker003"/>convinced you to do what you were already going to do anyway, let's go over some of the tools you'll need to write a game for the web in Rust:</p>
			<ul>
				<li><strong class="source-inline">rustup</strong>: Most likely <a id="_idIndexMarker004"/>you're already using <strong class="source-inline">rustup</strong> if you're <a id="_idIndexMarker005"/>writing Rust code. If you're not, you should, as it's the standard way to install Rust. It allows for easy installations of toolchains, Rust compilers, and even launches the Rust documentation. You'll need it to install <a id="_idIndexMarker006"/>the <strong class="bold">Wasm toolchain</strong>, and you can install it from the previous link. The code in this book has been tested on Rust version 1.57.0.</li>
				<li><strong class="bold">Node.js</strong>: I know – I promised<a id="_idIndexMarker007"/> you that we'd be writing in Rust! We<a id="_idIndexMarker008"/> will, but this is still a web application and you'll be using Node.js to run the application. I recommend installing the current long-term support version (<strong class="bold">16.13.0</strong> at the time of writing). Older versions of Node.js may not work with the package creation tools as expected. If you're using Ubuntu Linux, be especially cautious when using the Debian distribution, which installs a very old version at this time. When in doubt, use tools for managing multiple <a id="_idIndexMarker009"/>versions, such as the <strong class="bold">Node Version Manager</strong> (<strong class="bold">nvm</strong>) tool for Linux/Mac or the corresponding nvm-windows tool for Windows, to ensure that you're using the long-term release version. I use the asdf tool (<a href="https://asdf-vm.com/">https://asdf-vm.com/</a>) for managing multiple versions myself, although I don't usually recommend it to people that haven't used a version management tool before. </li>
				<li><strong class="bold">webpack</strong>: We'll use <a id="_idIndexMarker010"/>webpack <a id="_idIndexMarker011"/>to bundle our application for release and run a development server. Most of the time, you won't have to worry about it, but it's there.<p class="callout-heading">Important Note</p><p class="callout">The current template uses webpack 4. Make sure to check that when looking up documentation.</p></li>
				<li><strong class="source-inline">wasm-pack</strong>: This is a Rust tool for building Rust-generated WebAssembly code. Like webpack, most of the time you won't know it's there, as it's managed by webpack, and your<a id="_idIndexMarker012"/> Rust application will largely be managed by Rust build tools.</li>
				<li><strong class="source-inline">wasm-bindgen</strong>: This is one of the crates you'll need to get to know to write Rust-generated WebAssembly code. One limitation of WebAssembly is that you cannot access <a id="_idIndexMarker013"/>the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) that represents a web page directly. Instead, WebAssembly programs need to call JavaScript functions to do that, requiring bindings and serializing data back and forth. What <strong class="source-inline">wasm-bindgen</strong> does is create those bindings and the boilerplate needed to call JavaScript functions from your Rust code, as well as provide tools to create bindings in the other direction so that JavaScript code can call back into the Rust code. We'll cover the details of how <strong class="source-inline">wasm-bindgen</strong> works as we go through the book, but to avoid getting bogged down in details right now, you can just think of it as a library to call JavaScript from your Rust code.</li>
				<li><strong class="source-inline">web-sys</strong>: This is a crate made up of many pre-generated bindings, using <strong class="source-inline">wasm-bindgen</strong>, for the web. We'll use <strong class="source-inline">web-sys</strong> to call browser APIs such as the canvas and <strong class="source-inline">requestAnimationFrame</strong>. This book assumes at least a passing familiarity with web development but doesn't require expertise in this area, and in fact, one of the advantages of game development in Rust is that we can just treat the browser as a platform library that we call functions on. The <strong class="source-inline">web-sys</strong> crate means we don't have to create all those bindings ourselves.</li>
				<li><strong class="source-inline">Canvas</strong>: HTML Canvas is a <strong class="source-inline">&lt;canvas&gt;</strong> browser element, such as headers or paragraphs, only it allows you to draw directly to it. This is how we can make a video game! There are many ways to draw to the canvas, including <strong class="source-inline">WebGL</strong> and <strong class="source-inline">WebGPU</strong>, but we're going to use the built-in Canvas API for most of this project. While this isn't the absolute fastest way of making a game, it's fast enough for learning purposes and avoids adding more technologies to our stack.</li>
			</ul>
			<p>Finally, while googling <strong class="source-inline">web-sys</strong>, <strong class="source-inline">web-bindgen</strong>, or other Rust packages for WebAssembly, you are likely to come across references to <strong class="source-inline">cargo-web</strong> and <strong class="source-inline">stdweb</strong>. While both of <a id="_idIndexMarker014"/>those projects were important to the development of Rust as a WebAssembly source, neither has been updated since 2019 and can be safely ignored. Now that we know the tools we'll be using, let's start building our first<a id="_idTextAnchor020"/> Rust project.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor021"/>A Rust project skeleton</h1>
			<p class="callout-heading">Important Note </p>
			<p class="callout">These directions <a id="_idIndexMarker015"/>are based on the status of <strong class="source-inline">rust-webpack-template</strong> at the time of writing. It's likely to have changed at the time of reading this, so pay close attention to the changes we are making. If they don't make sense, check the documents for <strong class="source-inline">wasm-pack</strong> and use your best judgment.</p>
			<p>At this point, I'm going to assume you've installed <strong class="source-inline">rustup</strong> and Node.js. If you haven't, go ahead and follow the instructions for your platform to install them, and then follow these steps:</p>
			<ol>
				<li><strong class="bold">Initialize the project</strong></li>
			</ol>
			<p>Let's start by creating a project skeleton for your application, which will be the Rust webpack Template from the Rust Wasm group. It's found on GitHub at <a href="https://github.com/rustwasm/rust-webpack-template">https://github.com/rustwasm/rust-webpack-template</a>, but you don't want to download<a id="_idIndexMarker016"/> it. Instead, use <strong class="source-inline">npm init</strong> to create it, like this:</p>
			<p class="source-code">mkdir walk-the-dog</p>
			<p class="source-code">cd walk-the-dog</p>
			<p class="source-code">npm init rust-webpack</p>
			<p>You should see something like this:</p>
			<p class="source-code">npx: installed 17 in 1.941s</p>
			<p class="source-code"> 🦀 Rust + 🕸 WebAssembly + Webpack = ❤</p>
			<p class="source-code">Installed dependencies ✅</p>
			<p>Congratulations! You have created your project.</p>
			<ol>
				<li value="2"><strong class="bold">Install dependencies</strong></li>
			</ol>
			<p>You can install the dependencies with <strong class="source-inline">npm</strong>:</p>
			<p class="source-code">npm install</p>
			<p class="callout-heading">Important Note </p>
			<p class="callout">If you prefer to use <strong class="source-inline">yarn</strong>, you can, with the exception of the <strong class="source-inline">npm init</strong> command. I'll be using <strong class="source-inline">npm</strong> for this book.</p>
			<ol>
				<li value="3"><strong class="bold">Run the server</strong></li>
			</ol>
			<p>After the installation completes, you can now run a development server with <strong class="source-inline">npm run start</strong>. You may see an error, like this:</p>
			<p class="source-code">ℹ  Installing wasm-pack</p>
			<p class="source-code">Error: Rust compilation.</p>
			<p class="source-code">at ChildProcess.&lt;anonymous&gt; (/walk-the-dog/node_modules/@wasm-tool/wasm-pack-plugin/plugin.js:221:16)</p>
			<p class="source-code">at ChildProcess.emit (events.js:315:20)</p>
			<p class="source-code">at maybeClose (internal/child_process.js:1048:16)</p>
			<p class="source-code">at Socket.&lt;anonymous&gt; (internal/child_process.js:439:11)</p>
			<p class="source-code">at Socket.emit (events.js:315:20)</p>
			<p class="source-code">at Pipe.&lt;anonymous&gt; (net.js:673:12)</p>
			<p>If that happens, you'll need to install <strong class="source-inline">wasm-pack</strong> manually.</p>
			<ol>
				<li value="4"><strong class="bold">Install wasm-pack</strong></li>
			</ol>
			<p>On Linux and <a id="_idIndexMarker017"/>macOS systems <strong class="source-inline">wasm-pack</strong> is installed with a simple cURL script:</p>
			<p class="source-code">curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh</p>
			<p>Windows users have a separate installer that can be found at <a href="https://rustwasm.github.io">https://rustwasm.github.io</a>.  </p>
			<ol>
				<li value="5"><strong class="bold">Run the server – take two</strong></li>
			</ol>
			<p>Now that <strong class="source-inline">wasm-pack</strong> is installed, webpack can use it, and you should be able to run the app:</p>
			<p class="source-code">npm run start</p>
			<p>When you see <strong class="source-inline">｢</strong><strong class="source-inline">wdm</strong><strong class="source-inline">｣</strong><strong class="source-inline">: Compiled successfully.</strong> , you can browse your app at <strong class="source-inline">http://localhost:8080</strong>. Okay, yes, it's a blank page, but if you open the developer tools console, you should see the following:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer006">
					<img alt="Figure 1.1 – Hello WebAssembly!" src="image/Figure_1.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Hello WebAssembly!</p>
			<p>You've got the application running in the browser, but the Rust ecosystem updates faster <a id="_idIndexMarker018"/>than the template you used can keep up.</p>
			<ol>
				<li value="6"><strong class="bold">Update the Rust edition</strong></li>
			</ol>
			<p>The latest Rust edition, with the most recent Rust idioms and conventions, is 2021. This is changed in the generated <strong class="source-inline">Cargo.toml</strong> file in the <strong class="source-inline">package</strong> section, as shown here:</p>
			<p class="source-code"># You must change these to your own details.</p>
			<p class="source-code">[package]</p>
			<p class="source-code">name = "rust-webpack-template"</p>
			<p class="source-code">description = "Walk the Dog - the game for the Rust Games with WebAssembly book"</p>
			<p class="source-code">version = "0.1.0"</p>
			<p class="source-code">authors = ["Eric Smith &lt;paytonrules@gmail.com&gt;"]</p>
			<p class="source-code">categories = ["wasm"]</p>
			<p class="source-code">readme = "README.md"</p>
			<p class="source-code"><strong class="bold">edition = "2021"</strong></p>
			<p>It is only the <strong class="source-inline">edition</strong> field that is changed here.</p>
			<ol>
				<li value="7"><strong class="bold">Update the dependencies</strong></li>
			</ol>
			<p>The dependencies in the generated <strong class="source-inline">Cargo.toml</strong> file are not going to be the latest and greatest unless you happened to pull the template down the moment it was updated. Since neither of us is that lucky, you're going to want to open up that file and modify the dependencies to the following. Please note that the ellipses are<a id="_idIndexMarker019"/> just there to mark a gap in the file and are not meant to be typed in:</p>
			<p class="source-code">wasm-bindgen = "0.2.78"</p>
			<p class="source-code">...</p>
			<p class="source-code">[dependencies.web-sys]</p>
			<p class="source-code">version = "0.3.55"</p>
			<p class="source-code">...</p>
			<p class="source-code">[dev-dependencies]</p>
			<p class="source-code">wasm-bindgen-test = "0.3.28"</p>
			<p class="source-code">futures = "0.3.18"</p>
			<p class="source-code">js-sys = "0.3.55"</p>
			<p class="source-code">wasm-bindgen-futures = "0.4.28"</p>
			<p>Those are the versions I used while writing this book. If you're feeling adventurous, you can go to <a href="http://crates.io">http://crates.io</a> and find the most recent version of each dependency, which is what I would do, but I am a glutton for punishment. You're probably smarter than me and will use the versions specified here so that the sample code works.</p>
			<ol>
				<li value="8"><strong class="bold">Update console_error_panic_hook</strong></li>
			</ol>
			<p><strong class="source-inline">console_error_panic_hook</strong> is a very useful crate during the development of a WebAssembly application. It takes panics in Rust code and forwards them to the console so that you can debug them. The current template attempts to hide it behind a feature flag, but unfortunately, there's a bug and it doesn't work. Remember to double-check your generated code; if it doesn't look like what I've reproduced here, the bug may have been fixed, but in the meantime, delete the following code (still in <strong class="source-inline">Cargo.toml</strong>).</p>
			<p class="source-code">[target."cfg(debug_assertions)".dependencies]</p>
			<p class="source-code">console_error_panic_hook = "0.1.5"</p>
			<p>Then add<a id="_idIndexMarker020"/> the to the [dependencies] section, under wasm-bindgen is a good spot:</p>
			<p class="source-code">console_error_panic_hook = "0.1.7"</p>
			<p>Later, we'll make this a conditional dependency so that you don't deploy it during release builds, but for now, this is enough progress. Who wants to continue messing with <strong class="source-inline">config</strong> files anyway? I want to draw stuff to the screen!</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">While this application uses an <strong class="source-inline">npm init</strong> template to create itself, you can use its output to create a <strong class="source-inline">cargo generate</strong> template so that you don't have to redo these changes every time you create an application, simply by creating a <strong class="source-inline">git</strong> repository. Of course, if you do that, you'll fall behind changes to the <strong class="source-inline">rust-webpack</strong> template, so it's a trade-off. If you're curious about using <strong class="source-inline">cargo generate</strong> to create your own templates, you can find more information here: <a href="https://bit.ly/3hCFWTs">https:<span id="_idTextAnchor022"/>//bit.ly/3hCFWTs</a>.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor023"/>Drawing to the canvas</h1>
			<p>To write our<a id="_idIndexMarker021"/> game in Rust, we're going to need to draw to the screen, and for that, we'll use the HTML Canvas element using the 2D context. What the canvas provides is an API for drawing directly to the screen, without knowledge of WebGL or using an external tool. It's not the fastest technology in the world but it's perfectly suitable for our small game. Let's start converting our Rust app from <em class="italic">"Hello World"</em> to an <a id="_idIndexMarker022"/>application that draws a <strong class="bold">Sierpiński triangle</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The Sierpiński triangle is a fractal image that is created by drawing a triangle, then subdividing that triangle into four triangles, and then subdividing those triangles into four triangles, and so on. It sounds complicated but, as with many fractals, is created from only a few lines of math:</p>
			<ol>
				<li value="1"><strong class="bold">Add the canvas</strong></li>
			</ol>
			<p>Canvas is an HTML element that lets us draw to it freely, making it an ideal candidate for games. Indeed, at the time of writing, Adobe Flash is officially dead, and if you see a game on the internet, be it 2D or 3D, it's running in a <strong class="source-inline">canvas</strong> element. Canvas can use WebGL or WebGPU for games, and WebAssembly will work quite well with those technologies, but they are out of the scope of this book. We'll be using the built-in Canvas 2D API and its 2D context. This means you won't have to learn a shading language, and we'll be able to get images <a id="_idIndexMarker023"/>on the screen very quickly. It also means that if you need <a id="_idIndexMarker024"/>to, you can find excellent documentation on the <strong class="bold">Mozilla Developer Network</strong> (<strong class="bold">MDN</strong>) Web Docs website: <a href="https://mzl.la/3tX5qPC">https://mzl.la/3tX5qPC</a>. </p>
			<p>To draw to the canvas, we'll need to add it to the web page. Open up <strong class="source-inline">static/index.html</strong> and add underneath <strong class="source-inline">&lt;body&gt; tag &lt;canvas id="canvas" tabindex="0" height="600" width="600"&gt;Your browser does not support the canvas.&lt;/canvas&gt;</strong>. The width and height are pretty arbitrary but seem appropriate for now. The "<strong class="source-inline">Your browser does not support the canvas.</strong>" message will show up on browsers that don't support HTML Canvas, but there aren't many of those anymore.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Make sure you don't delete the <strong class="source-inline">&lt;script&gt;</strong> tag. That's running the JavaScript and WebAssembly you're building in this project!</p>
			<ol>
				<li value="2"><strong class="bold">Clean up errors</strong></li>
			</ol>
			<p>Finally, we get to write some Rust code! Well, we get to delete some Rust code anyway. In the <strong class="source-inline">src/lib.rs</strong> file, you'll see a function named <strong class="source-inline">main_js()</strong> with the following code:</p>
			<p class="source-code">// This provides better error messages in debug mode.</p>
			<p class="source-code">// It's disabled in release mode so it doesn't bloat </p>
			<p class="source-code">   up the file size.</p>
			<p class="source-code">    #[cfg(debug_assertions)]</p>
			<p class="source-code">    console_error_panic_hook::set_once();</p>
			<p>You can go<a id="_idIndexMarker025"/> ahead and remove the comments and the <strong class="source-inline">[cfg(debug_annotations)]</strong> annotation. For the time being, we'll leave that running in our build and will remove it when preparing for production with a feature flag.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you're seeing an error in your editor that says the <strong class="source-inline">console::log_1(&amp;JsValue::from_str("Hello world!"))</strong> code is missing an unsafe block, don't worry – that error is wrong. Unfortunately, it's a bug in rust-analyzer that's been addressed in this issue: <a href="https://bit.ly/3BbQ39m">https://bit.ly/3BbQ39m</a>. You'll see this error with anything that uses procedural macros under the hood. If you're using an editor that supports experimental settings, you may be able to fix the problem; check the <strong class="source-inline">rust-analyzer.experimental.procAttrMacros</strong> setting. When in doubt, check the output from <strong class="source-inline">npm run start</strong>, as that is the more accurate source for compiler errors.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you diverge from this book and decide to deploy, go to <a href="B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226"><em class="italic">Chapter 10</em></a>, <em class="italic">Continuous Deployment</em>, and learn how to hide that feature behind a feature flag in release mode, so you don't deploy code you don't need into production.</p>
			<p>Removing that code will remove the <strong class="source-inline">warning: Found 'debug_assertions' in 'target.'cfg(...)'.dependencies'.</strong> message on startup of the app. At this point, you may have noticed that I'm not telling you to restart the server after changes, and that's because <strong class="source-inline">npm start</strong> runs the <strong class="source-inline">webpack-dev-server</strong>, which automatically detects changes and then rebuilds and refreshes the app. Unless <a id="_idIndexMarker026"/>you're changing the webpack config, you sho<a id="_idTextAnchor024"/>uldn't have to restart.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor025"/>The current code</h2>
			<p>Up to now, I've been<a id="_idIndexMarker027"/> telling you what to do, and you've been blindly doing it because you're following along like a good reader. That's very diligent of you, if a little trusting, and it's time to take a look at the current source and see just what we have in our WebAssembly library. First, let's start <a id="_idTextAnchor026"/>with the <strong class="source-inline">use</strong> directives.</p>
			<p class="source-code">use wasm_bindgen::prelude::*;</p>
			<p class="source-code">use web_sys::console;</p>
			<p>The first<a id="_idIndexMarker028"/> import <a id="_idIndexMarker029"/>is the <strong class="source-inline">prelude</strong> for <strong class="source-inline">wasm_bindgen</strong>. This brings in the macros you'll see shortly, and a couple of types that are pretty necessary for writing Rust for the web. Fortunately, it's not a lot, and shouldn't pollute the namespace too much.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">"<strong class="bold">Pollute the namespace</strong>" refers to<a id="_idIndexMarker030"/> what can happen when you use the '<strong class="source-inline">*</strong>' syntax and import everything from a given module. If the module has a lot of exported names, you have now those same names in your project, and they aren't obvious when you're coding. If, for instance, <strong class="source-inline">wasm_bindgen::prelude</strong> had a function named <strong class="source-inline">add</strong> in it and you also had a function named <strong class="source-inline">add</strong> in your namespace, they would collide. You can work around this by using explicit namespaces when you call the functions, but then why use <strong class="source-inline">*</strong> in the first place? By convention, many Rust packages have a module named <strong class="source-inline">prelude</strong>, which can be imported via <strong class="source-inline">*</strong> for ease of use; other modules should be imported with their full name.</p>
			<p>The other import is <strong class="source-inline">web_sys::console</strong>, which brings in the <strong class="source-inline">console</strong> namespace from <strong class="source-inline">web_sys</strong>, which in turn mimics the <strong class="source-inline">console</strong> namespace in JavaScript. This is a good time to talk a little more in detail about what these two modules do. I've said it before but it probably bears repeating – <strong class="source-inline">wasm_bindgen</strong> provides the capability to bind JavaScript functions so you can call them in WebAssembly and to expose your WebAssembly functions to JavaScript. There's that language again, the one we're trying to avoid by writing <a id="_idIndexMarker031"/>Rust, but it can't be avoided because we're working in a browser.</p>
			<p>In fact, one of the limitations of WebAssembly is that it cannot manipulate the DOM, which is a fancy way of saying that it can't change the web page. What it can do is call functions in JavaScript, which in turn do that work. In addition, JavaScript knows nothing about your WebAssembly types, so any data that is passed to a JavaScript object is marshaled into shared memory and then pulled back out by JavaScript so that it can turn it into something it understands. This is a LOT of code to write over and over again, and that is what the <strong class="source-inline">wasm-bindgen</strong> crate does for you. Later, we'll use it to bind our own custom bindings to third-party JavaScript code, but what about all the functions already built into the browser, such as <strong class="source-inline">console.log</strong>? That's where <strong class="source-inline">web-sys</strong> comes in. It uses <strong class="source-inline">wasm-bindgen</strong> to bind to all the functions in the browser environment so that you don't have to manually specify them. Think of it as a helper crate that says, <em class="italic">"Yeah, I know you'll need all these functions so I created them for you."</em></p>
			<p>So, to sum up, <strong class="source-inline">wasm-bindgen</strong> gives you the capability to communicate between WebAssembly and JavaScript, and <strong class="source-inline">web-sys</strong> contains a large number of pre-created bindings. If you're particularly interested in how the calls between WebAssembly and JavaScript <a id="_idIndexMarker032"/>work, check out this article by Lin Clark, which explains it in great detail, and with pictures: <a href="https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/">https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-ar<span id="_idTextAnchor027"/>e-finally-fast-%F0%9F%8E%89/</a>.</p>
			<h3>The wee allocator</h3>
			<p>After the<a id="_idIndexMarker033"/> use<a id="_idIndexMarker034"/> statements you'll see a comment block referring to the `wee_alloc` feature, which is a WebAssembly allocator that uses much less memory than the default Rust allocator. We're not using it, and it was disabled in the <strong class="source-inline">Cargo.toml</strong> file, so you can delete it from both <a id="_idTextAnchor028"/>the source code and <strong class="source-inline">Cargo.toml</strong>.</p>
			<h3>The main</h3>
			<p>Finally, we get<a id="_idIndexMarker035"/> to the <a id="_idIndexMarker036"/>main part of our program:</p>
			<p class="source-code">#[wasm_bindgen(start)]</p>
			<p class="source-code">pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {</p>
			<p>The <strong class="source-inline">wasm_bindgen(start)</strong> annotation exports <strong class="source-inline">main_js</strong> so that it can be called by JavaScript, and the <strong class="source-inline">start</strong> parameter identifies it as the starting point of the program. If you're curious, you can take a look at <strong class="source-inline">pkg/index_bg.wasm.d.ts</strong> to see what was generated by it. You'll also want to take note of the return value, <strong class="source-inline">Result</strong>, where the error type can be <strong class="source-inline">JsValue</strong>, which represents an object owned by JavaScript and not Rust.</p>
			<p>At this point, you may start to wonder how you'll keep track of what's JavaScript and what's Rust, and I'd advise you to not worry too much about it right now. There's a lot of jargon popping up and there's no way you'll keep it all in your head; just let it swim around in there and when it comes up again, I'll explain it again. <strong class="source-inline">JsValue</strong> is just a representative JavaScript object in your Rust code.</p>
			<p>Finally, let's look at the contents:</p>
			<p class="source-code">console_error_panic_hook::set_once();</p>
			<p class="source-code">// Your code goes here!</p>
			<p class="source-code">console::log_1(&amp;JsValue::from_str("Hello world!"));</p>
			<p class="source-code">Ok(())</p>
			<p>The first line sets the panic hook, which just means that any panics will be redirected to the web browser's console. You'll need it for debugging, and it's best to keep it at the beginning of the program. Our one line, our <em class="italic">Hello World</em>, is <strong class="source-inline">console::log_1(&amp;JsValue::from_str("Hello world!"));</strong>. That calls the JavaScript <strong class="source-inline">console.log</strong> function, but it's using the version that's <strong class="source-inline">log_1</strong> because the JavaScript version takes varying parameters. This is something that's going to come up again and again when using <strong class="source-inline">web-sys</strong>, which is that JavaScript supports <strong class="source-inline">varargs</strong> and Rust doesn't. So instead, many variations are created in the <strong class="source-inline">web-sys</strong> module to match the alternatives. If a JavaScript function you expect doesn't exist, then take a look at the Rust documents for <strong class="source-inline">web-sys</strong> (<a href="https://bit.ly/2NlRmOI">https://bit.ly/2NlRmOI</a>) and see whether there are versions that are similar but built to account for multiple parameters.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">A series of macros for several of the more commonly used functions (such as <strong class="source-inline">log</strong>) could solve this problem, but that's an exercise for the reader.</p>
			<p>Finally, the<a id="_idIndexMarker037"/> function<a id="_idIndexMarker038"/> returns <strong class="source-inline">Ok(())</strong>, as is typical of Rust programs. Now that we've seen the generated code<a id="_idTextAnchor029"/>, let's break it down with our own.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor030"/>Drawing a triangle</h2>
			<p>We've spent a lot <a id="_idIndexMarker039"/>of time digging into the code we currently have, and it's a lot to just write <em class="italic">"Hello World"</em> to the console. Why don't we have some fun and actually draw to the canvas?</p>
			<p>What we're going to do is mimic the following JavaScript code in Rust:</p>
			<p class="source-code">canvas = window.document.getElementById("canvas")</p>
			<p class="source-code">context = canvas.getContext("2d")</p>
			<p class="source-code">context.moveTo(300, 0)</p>
			<p class="source-code">context.beginPath()</p>
			<p class="source-code">context.lineTo(0, 600)</p>
			<p class="source-code">context.lineTo(600, 600)</p>
			<p class="source-code">context.lineTo(300, 0)</p>
			<p class="source-code">context.closePath()</p>
			<p class="source-code">context.stroke()</p>
			<p class="source-code">context.fill()</p>
			<p>This code grabs the canvas element we put in <strong class="source-inline">index.html</strong>, grabs its 2D context, and then draws a<a id="_idIndexMarker040"/> black triangle. One way to draw a shape on the context is to draw a line path, then stroke, and, in this case, fill it. You can actually see this in the browser using the web developer tools built into most browsers. This screenshot is from Firefox:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer007">
					<img alt="Figure 1.2 – A simple canvas triangle" src="image/Figure_1.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – A simple canvas triangle</p>
			<p>Let's do the same thing in our Rust program. You'll see that it's a little…different. Start with the quick addition of a <strong class="source-inline">use</strong> statement at the top:</p>
			<p class="source-code">use wasm_bindgen::JsCast;</p>
			<p>Then, replace<a id="_idIndexMarker041"/> the existing <strong class="source-inline">main_js</strong> function with the following:</p>
			<p class="source-code">console_error_panic_hook::set_once();</p>
			<p class="source-code">let window = web_sys::window().unwrap();</p>
			<p class="source-code">let document = window.document().unwrap();</p>
			<p class="source-code">let canvas = document</p>
			<p class="source-code">    .get_element_by_id("canvas")</p>
			<p class="source-code">    .unwrap()</p>
			<p class="source-code">    .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()</p>
			<p class="source-code">    .unwrap();</p>
			<p class="source-code">let context = canvas</p>
			<p class="source-code">    .get_context("2d")</p>
			<p class="source-code">    .unwrap()</p>
			<p class="source-code">    .unwrap()</p>
			<p class="source-code">    .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()</p>
			<p class="source-code">    .unwrap();</p>
			<p class="source-code">context.move_to(300.0, 0.0); // top of triangle</p>
			<p class="source-code">context.begin_path();</p>
			<p class="source-code">context.line_to(0.0, 600.0); // bottom left of triangle</p>
			<p class="source-code">context.line_to(600.0, 600.0); // bottom right of triangle</p>
			<p class="source-code">context.line_to(300.0, 0.0); // back to top of triangle</p>
			<p class="source-code">context.close_path();</p>
			<p class="source-code">context.stroke();</p>
			<p class="source-code">context.fill();</p>
			<p class="source-code">Ok(())</p>
			<p>There are a few differences that stand out, but at a glance, you may just feel like Rust code is a lot <em class="italic">noisier</em> than JavaScript code, and that's true. You might be inclined to say that it's less elegant or isn't as clean, but I'd say that's in the eye of the beholder. JavaScript is a dynamically typed language and it shows. It ignores <strong class="source-inline">undefined</strong> and <strong class="source-inline">null</strong>, and can just crash if any of the values are not present. It uses duck typing to call all the functions on the context, which means that if the function is present, it simply calls it; otherwise, it throws exceptions.</p>
			<p>Rust code takes a very different approach, one that favors explicitness and safety but at the cost of the code having extra noise. In Rust, you have to be more explicit when calling methods on structs, hence the casting, and you have to acknowledge <strong class="source-inline">null</strong> or failed <strong class="source-inline">Result</strong> types, hence all the unwraps. I've spent years using dynamic languages, including JavaScript, and I like them a lot. I certainly liked them a lot better than writing in C++, which I find overly verbose without really granting some of the safety advantages, but I think that with some tweaks, we can make Rust code nearly as elegant as JavaScript without glossing over exceptions and results.</p>
			<p>My rant <a id="_idIndexMarker042"/>aside, if you're still running the program, you'll notice one minor detail – the Rust code doesn't compile! This leads me to the first thing we'll need to cover when translating JavaScript code to Rust code.</p>
			<h3>web-sys and feature flags</h3>
			<p>The <strong class="source-inline">web-sys</strong> crate<a id="_idIndexMarker043"/> makes <a id="_idIndexMarker044"/>heavy use <a id="_idIndexMarker045"/>of feature<a id="_idIndexMarker046"/> flags to keep its size down. This means that every time you want to use a function and it doesn't exist, you'll need to check which feature flag it's tied to, which is in its documentation, and add it to <strong class="source-inline">Cargo.toml</strong>. Fortunately, this is well documented and easy enough to do; we don't even need to restart the server!</p>
			<p>Looking at our errors, we should see the following:</p>
			<p class="source-code">error[E0425]: cannot find function 'window' in crate 'web_sys'</p>
			<p class="source-code">--&gt; src/lib.rs:18:27</p>
			<p class="source-code">|</p>
			<p class="source-code">18 | let window = web_sys::window().unwrap();</p>
			<p class="source-code">|                           ^^^^^^ not found in 'web_sys'</p>
			<p>There are a few more errors of the same kind, but what you see here is that <strong class="source-inline">window</strong> is not in the <strong class="source-inline">web_sys</strong> module. Now, if you check the documentation for the <strong class="source-inline">window</strong> function in <strong class="source-inline">web-sys</strong> at <a href="https://bit.ly/3ak3sAR">https://bit.ly/3ak3sAR</a>, you'll see that, yes, it does exist, but there is the <strong class="source-inline">This API requires the following crate features to be activated: Window </strong>message.</p>
			<p>Open the <strong class="source-inline">cargo.toml</strong> file and look for <strong class="source-inline">dependencies.web-sys</strong>. You'll see that it has a <strong class="source-inline">features</strong> entry with just <strong class="source-inline">["console"]</strong> in it; go ahead and add <strong class="source-inline">"Window"</strong>,<strong class="source-inline"> "Document"</strong>, <strong class="source-inline">"HtmlCanvasElement"</strong>, <strong class="source-inline">"CanvasRenderingContext2d"</strong>, and <strong class="source-inline">"Element"</strong> to that list. To be clear, you don't need all those feature flags for just the <strong class="source-inline">window</strong> function; that's all of the functions we're using.</p>
			<p>You'll notice <a id="_idIndexMarker047"/>the<a id="_idIndexMarker048"/> project <a id="_idIndexMarker049"/>will <a id="_idIndexMarker050"/>rebuild automatically and should build successfully. If you look in the browser, you'll see your own black triangle! Let's extend it and learn a bit more about how we did it.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When a function you expect to exist on <strong class="source-inline">web-sys</strong> doesn't, go and check the feature flags in the documents.</p>
			<h3>DOM interaction</h3>
			<p>You'll <a id="_idIndexMarker051"/>notice<a id="_idIndexMarker052"/> that the method for drawing the triangle after you get the context looks essentially the same as the method in JavaScript – draw a line path, stroke, and fill it. The code at the top that interacted with the DOM looks…different. Let's break down what's going on here:</p>
			<ul>
				<li>Unwrapping option</li>
			</ul>
			<p>Getting the <strong class="source-inline">Window</strong> is just a function in the <strong class="source-inline">web-sys</strong> crate, one you enabled when you added the <strong class="source-inline">Window</strong> feature to <strong class="source-inline">Cargo.toml</strong>. However, you'll notice it's got <strong class="source-inline">unwrap</strong> at the end:</p>
			<p class="source-code">let window = web_sys::window().unwrap();</p>
			<p>In JavaScript, <strong class="source-inline">window</strong> can be <strong class="source-inline">null</strong> or <strong class="source-inline">undefined</strong>, at least theoretically, and in Rust, this gets translated into <strong class="source-inline">Option&lt;Window&gt;</strong>. You can see that <strong class="source-inline">unwrap</strong> is applied to the result of <strong class="source-inline">window()</strong>, <strong class="source-inline">document()</strong>, and <strong class="source-inline">get_element_by_id()</strong> because all of them return <strong class="source-inline">Option&lt;T&gt;</strong>.</p>
			<ul>
				<li><strong class="source-inline">dyn_into</strong></li>
			</ul>
			<p>What the heck is <strong class="source-inline">dyn_into</strong>? Well, this oddity accounts for the difference between the way JavaScript does typing and the way Rust does. When we retrieve the canvas with <strong class="source-inline">get_element_by_id</strong>, it returns <strong class="source-inline">Option&lt;Element&gt;</strong>, and <strong class="source-inline">Element</strong> does not have any functions relating to the canvas. In JavaScript, you can use dynamic typing to assume the element has the <strong class="source-inline">get_context</strong> method, and if you're wrong, the program will throw an exception. This<a id="_idIndexMarker053"/> is anathema to Rust; indeed, this is <a id="_idIndexMarker054"/>a case where one developer's convenience is another developer's potential bug in hiding, so in order to use <strong class="source-inline">Element</strong>, we have to call the <strong class="source-inline">dyn_into</strong> function to cast it into <strong class="source-inline">HtmlCanvasElement</strong>. This method was brought into scope with the `use wasm_bindgen::JsCast` declaration.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Note that <strong class="source-inline">HtmlCanvasElement</strong>, <strong class="source-inline">Document</strong>, and <strong class="source-inline">Element</strong> were all also feature flags you had to add in <strong class="source-inline">web-sys</strong>.</p>
			<ul>
				<li>Two unwraps?</li>
			</ul>
			<p>After calling <strong class="source-inline">get_context("2d")</strong>, we actually call <strong class="source-inline">unwrap</strong> twice; that's not a typo. What's going on is that <strong class="source-inline">get_context</strong> returns a <strong class="source-inline">Result&lt;Option&lt;Object&gt;&gt;</strong>, so we unwrap it twice. This is another case where the game can't recover if this fails, so <strong class="source-inline">unwrap</strong> is okay, but I wouldn't complain if <a id="_idIndexMarker055"/>you replaced those with <strong class="source-inline">ex<a id="_idTextAnchor031"/>pect</strong> so that <a id="_idIndexMarker056"/>you can give a clearer error message. </p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor032"/>A Sierpiński triangle</h2>
			<p>Now let's have<a id="_idIndexMarker057"/> some real fun, and draw a Sierpiński triangle a few levels deep. If you're up for a challenge, you can try and write the code yourself before following along with the solution presented here. The way the algorithm works is to draw the first triangle (the one you are already drawing) and then draw another three triangles, where the first triangle has the same top point but its other two points are at the halfway point on each side of the original triangle. Then, draw a second triangle on the lower left, with its top at the halfway point of the left side, its lower-right point at the halfway point of the bottom of the original triangle, and its lower-left point at the lower-left point of the original triangle. Finally, you create a third triangle in the lower-right corner of the original triangle. This leaves a "hole" in the middle shaped like an upside-down triangle. This is much easier to visualize than it is to explain, so how about a picture?</p>
			<div>
				<div class="IMG---Figure" id="_idContainer008">
					<img alt="Figure 1.3 – A one-level Sierpiński triangle" src="image/Figure_1.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – A one-level Sierpiński triangle</p>
			<p>Each of the <a id="_idIndexMarker058"/>numbered triangles was one that was drawn. The upside-down blue triangle is what's left of the original triangle because we didn't draw over it.</p>
			<p>So that's one triangle subdivided into four. Now, the algorithm works recursively, taking each triangle and subdividing again. So, two levels deep, it looks like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer009">
					<img alt="Figure 1.4 – A two-level Sierpiński triangle&#13;&#10;" src="image/Figure_1.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – A two-level Sierpiński triangle</p>
			<p>Note that it <em class="italic">doesn't </em>subdivide<a id="_idIndexMarker059"/> the upside-down triangle in the center, just the three purple ones that you created. Indeed, all the triangles with their points down are just "happy accidents" that make the shape look cool. You now know enough at this point to draw your own Sierpiński triangle, with one catch – you should remove the <strong class="source-inline">fill</strong> statement on context. Otherwise, all the triangles will be filled black and you<a id="_idIndexMarker060"/> <a id="_idTextAnchor033"/>won't be able to see them. Go ahead and give it a try.</p>
			<h3>Drawing the Sierpiński triangle</h3>
			<p>So, did you give <a id="_idIndexMarker061"/>it a try? No, I wouldn't either; I guess we have a lot in common. To get started with creating a Sierpiński triangle, let's replace the hardcoded triangle with a triangle function. Here's the first pass at <strong class="source-inline">draw_triangle</strong>:</p>
			<p class="source-code">fn draw_triangle(context: &amp;web_sys::CanvasRenderingContext2d,     points: [(f64, f64); 3]) {</p>
			<p class="source-code">        let [top, left, right] = points;</p>
			<p class="source-code">        context.move_to(top.0, top.1);</p>
			<p class="source-code">        context.begin_path();</p>
			<p class="source-code">        context.line_to(left.0, left.1);</p>
			<p class="source-code">        context.line_to(right.0, right.1);</p>
			<p class="source-code">        context.line_to(top.0, top.1);</p>
			<p class="source-code">        context.close_path();</p>
			<p class="source-code">        context.stroke();</p>
			<p class="source-code">}</p>
			<p>There are a couple of small changes from the hard-coded version that we started with. The function takes a reference to the context and a list of three points. Points themselves are represented by tuples. We've also gotten rid of the <strong class="source-inline">fill</strong> function, so we only have an empty triangle. Replace the inline <strong class="source-inline">draw_triangle</strong> with the function call, which should look like this:</p>
			<p class="source-code">let context = canvas</p>
			<p class="source-code">    .get_context("2d")</p>
			<p class="source-code">    .unwrap()</p>
			<p class="source-code">    .unwrap()</p>
			<p class="source-code">    .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()</p>
			<p class="source-code">    .unwrap();</p>
			<p class="source-code">draw_triangle(&amp;context, [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)]);</p>
			<p>Now that you're drawing one empty triangle, you're ready to start drawing the recursive triangles. Rather than starting with recursion, let's draw the first subdivision by drawing three more <a id="_idIndexMarker062"/>triangles. The first will have the same top point and two side points:</p>
			<p class="source-code">draw_triangle(&amp;context, [(300.0, 0.0), (150.00, 300.0), (450.0, 300.0)]);</p>
			<p>Note that the third tuple has an x halfway between <strong class="source-inline">300.0</strong> and <strong class="source-inline">600.0</strong>, not between <strong class="source-inline">0</strong> and <strong class="source-inline">600.0</strong>, because the top point of the triangle is halfway between the other two points. Also note that y gets larger as you go down, which is upside-down compared to many 3D systems. Now, let's add the lower-left and lower-right triangles:</p>
			<p class="source-code">draw_triangle(&amp;context, [(150.0, 300.0), (0.0, 600.0), (300.0, 600.0)]);</p>
			<p class="source-code">draw_triangle(&amp;context, [(450.0, 300.0), (300.0, 600.0), (600.0, 600.0)]);</p>
			<p>Your triangles should look like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer010">
					<img alt="Figure 1.5 – Your triangles" src="image/Figure_1.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Your triangles</p>
			<p>You will start<a id="_idIndexMarker063"/> to see a pattern at this point, and we can begin to turn our hardcoded triangles into an algorithm. We'll create a function called <strong class="source-inline">sierpinski</strong> that takes the context, the triangle dimensions, and a depth function so that we only draw as many triangles as we want, instead of drawing them to infinity and crashing the browser. Then, we'll move those functions we called into that function:</p>
			<p class="source-code">fn sierpinski(context: &amp;web_sys::CanvasRenderingContext2d, points: [(f64, f64); 3], depth: u8) {</p>
			<p class="source-code">    draw_triangle(&amp;context, [(300.0, 0.0), (0.0, 600.0), </p>
			<p class="source-code">     (600.0, 600.0)]);</p>
			<p class="source-code">    draw_triangle(&amp;context, [(300.0, 0.0), (150.00, 300.0), </p>
			<p class="source-code">     (450.0, 300.0)]);</p>
			<p class="source-code">    draw_triangle(&amp;context, [(150.0, 300.0), (0.0, 600.0), </p>
			<p class="source-code">     (300.0, 600.0)]);</p>
			<p class="source-code">    draw_triangle(&amp;context, [(450.0, 300.0), (300.0, </p>
			<p class="source-code">     600.0), (600.0, 600.0)]);</p>
			<p class="source-code">}</p>
			<p>This function <a id="_idIndexMarker064"/>currently ignores everything except the context, but you can replace those four <strong class="source-inline">draw_triangle</strong> calls from <strong class="source-inline">main_js</strong> and replace them with a call to <strong class="source-inline">sierpinski</strong>:</p>
			<p class="source-code">sierpinski(&amp;context, [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)], 2);</p>
			<p>It's important that you only send a depth of <strong class="source-inline">2</strong> for now so that the image will continue to look the same as we progress. Think of this call as a proto-unit test, guaranteeing our behavior doesn't change while we refactor. Now, in <strong class="source-inline">sierpinski</strong>, take the first triangle and have it use the passed-in points:</p>
			<p class="source-code">fn sierpinski(context: &amp;web_sys::CanvasRenderingContext2d, points: [(f64, f64); 3], depth: u8) {</p>
			<p class="source-code">    draw_triangle(&amp;context, points);</p>
			<p class="source-code">    ...</p>
			<p>Then, after drawing the triangle, reduce the depth by one and see if it is still greater than <strong class="source-inline">0</strong>. Then, draw the rest of the triangles:</p>
			<p class="source-code">...</p>
			<p class="source-code">let depth = depth - 1;</p>
			<p class="source-code">if depth &gt; 0 {</p>
			<p class="source-code">    draw_triangle(&amp;context, [(300.0, 0.0), (150.00, 300.0), </p>
			<p class="source-code">     (450.0, 300.0)]);</p>
			<p class="source-code">    draw_triangle(&amp;context, [(150.0, 300.0), (0.0, 600.0), </p>
			<p class="source-code">     (300.0, 600.0)]);</p>
			<p class="source-code">    draw_triangle(&amp;context, [(450.0, 300.0), (300.0, </p>
			<p class="source-code">     600.0), (600.0, 600.0)]);</p>
			<p class="source-code">}</p>
			<p>Now, to complete the<a id="_idIndexMarker065"/> recursion, you can replace all those <strong class="source-inline">draw_triangle</strong> calls with calls into <strong class="source-inline">sierpinski</strong>:</p>
			<p class="source-code">if depth &gt; 0 {</p>
			<p class="source-code">    sierpinski(</p>
			<p class="source-code">        &amp;context,</p>
			<p class="source-code">        [(300.0, 0.0), (150.00, 300.0), (450.0, 300.0)],</p>
			<p class="source-code">        depth,</p>
			<p class="source-code">    );</p>
			<p class="source-code">    sierpinski(</p>
			<p class="source-code">        &amp;context,</p>
			<p class="source-code">        [(150.0, 300.0), (0.0, 600.0), (300.0, 600.0)],</p>
			<p class="source-code">        depth,</p>
			<p class="source-code">    );</p>
			<p class="source-code">    sierpinski(</p>
			<p class="source-code">        &amp;context,</p>
			<p class="source-code">        [(450.0, 300.0), (300.0, 600.0), (600.0, 600.0)],</p>
			<p class="source-code">        depth,</p>
			<p class="source-code">    );</p>
			<p class="source-code">    }</p>
			<p>So far so good – you should still see a triangle subdivided into four triangles. Finally, we can actually calculate the midpoints of each line on the original triangle and use those to create the recursive <a id="_idIndexMarker066"/>triangles, instead of hardcoding them:</p>
			<p class="source-code">let [top, left, right] = points;</p>
			<p class="source-code">if depth &gt; 0 {</p>
			<p class="source-code">    let left_middle = ((top.0 + left.0) / 2.0, (top.1 + </p>
			<p class="source-code">     left.1) / 2.0);</p>
			<p class="source-code">    let right_middle = ((top.0 + right.0) / 2.0, (top.1 + </p>
			<p class="source-code">     right.1) / 2.0);</p>
			<p class="source-code">    let bottom_middle = (top.0, right.1);</p>
			<p class="source-code">    sierpinski(&amp;context, [top, left_middle, right_middle], </p>
			<p class="source-code">     depth);</p>
			<p class="source-code">    sierpinski(&amp;context, [left_middle, left, </p>
			<p class="source-code">     bottom_middle], depth);</p>
			<p class="source-code">    sierpinski(&amp;context, [right_middle, bottom_middle, </p>
			<p class="source-code">     right], depth);</p>
			<p class="source-code">}</p>
			<p>Calculating the midpoint of a line segment is done by taking the <em class="italic">x</em> and <em class="italic">y</em> coordinates of each end, adding those together, and then dividing them by two. While the preceding code works, let's make it clearer by writing a new function, as shown here:</p>
			<p class="source-code">fn midpoint(point_1: (f64, f64), point_2: (f64, f64)) -&gt; (f64, f64) {</p>
			<p class="source-code">    ((point_1.0 + point_2.0) / 2.0, (point_1.1 + point_2.1) </p>
			<p class="source-code">    / 2.0)</p>
			<p class="source-code">}</p>
			<p>Now, we can use<a id="_idIndexMarker067"/> that in the preceding function, for clarity:</p>
			<p class="source-code">if depth &gt; 0 {</p>
			<p class="source-code">    let left_middle = midpoint(top, left);</p>
			<p class="source-code">    let right_middle = midpoint(top, right);</p>
			<p class="source-code">    let bottom_middle = midpoint(left, right);</p>
			<p class="source-code">    sierpinski(&amp;context, [top, left_middle, right_middle], </p>
			<p class="source-code">     depth);</p>
			<p class="source-code">    sierpinski(&amp;context, [left_middle, left, </p>
			<p class="source-code">     bottom_middle], depth);</p>
			<p class="source-code">    sierpinski(&amp;context, [right_middle, bottom_middle, </p>
			<p class="source-code">     right], depth);</p>
			<p class="source-code">}</p>
			<p>If you've been following along, you should make sure you're still showing a triangle with four inside to ensure you haven't made any mistakes. Now for the big reveal – go ahead and change the depth to <strong class="source-inline">5</strong> in the original <strong class="source-inline">Sierpinski</strong> call:</p>
			<p class="source-code">sierpinski(&amp;context, [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)], 5);</p>
			<p>You should see a recursive drawing of triangles, like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer011">
					<img alt="Figure 1.6 – A recursive drawing of triangles&#13;&#10;" src="image/Figure_1.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – A recursive drawing of triangles</p>
			<p>Looking good! But what about those colors we saw in<a id="_idTextAnchor034"/> the original diagrams? They make it much <a id="_idIndexMarker068"/>more interesting.</p>
			<h3>When libraries aren't compatible</h3>
			<p>The earlier<a id="_idIndexMarker069"/> examples of this image had the triangles filled in with a different random color at each recursive layer. So, the first triangle was one color, three and four were another, the next nine another, and so on. It makes for a more interesting image <em class="italic">and</em> it provides a good example of what to do when a library isn't completely WebAssembly-compatible.</p>
			<p>To create a random color, we'll need a random number generator, and that is not part of the standard library but instead found in a crate. You can add that crate by changing the <strong class="source-inline">Cargo.toml</strong> file to include it as a dependency:</p>
			<p class="source-code">console_error_panic_hook = "0.1.7"</p>
			<p class="source-code">rand = "0.8.4"</p>
			<p>When you do this, you'll get a compiler error that looks like the following (although your message may differ slightly):</p>
			<p class="source-code">error: target is not supported, for more information see: https://docs.rs/getrandom/#unsupported-targets</p>
			<p class="source-code">   --&gt; /usr/local/cargo/registry/src/github.com-</p>
			<p class="source-code">   1ecc6299db9ec823/getrandom-0.2.2/src/lib.rs:213:9</p>
			<p class="source-code">    |</p>
			<p class="source-code">213 | /         compile_error!("target is not supported, for more information see: \</p>
			<p class="source-code">214 | |                         https://docs.rs/getrandom/#unsupported-targets");</p>
			<p>This is a case where a transitive dependency, in this case <strong class="source-inline">getrandom</strong>, does not compile on the WebAssembly target. In this case, it's an extremely helpful error message, and if you follow the link, you'll get the solution in the documentation. Specifically, you need to enable <strong class="source-inline">js</strong> in the feature flags for <strong class="source-inline">getrandom</strong>. Go back to your <strong class="source-inline">Cargo.toml</strong> file and add the following:</p>
			<p class="source-code">getrandom = { version = "0.2.3", features = ["js"] }</p>
			<p>This adds the <strong class="source-inline">getrandom</strong> dependency with the <strong class="source-inline">js</strong> feature enabled, and your code will begin compiling again. The lesson to take away from this is that not every Rust crate will compile on the WebAssembly target, and when that happens, you'll need to check the documents.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When a crate <a id="_idIndexMarker070"/>won't compile <em class="italic">slowly</em>, read the error message and follow the instructions. It's very easy to skim right over the re<a id="_idTextAnchor035"/>ason the build is breaking, especially when you're frustrated.</p>
			<h3>Random colors</h3>
			<p>Now that we've <a id="_idIndexMarker071"/>got the random create building with our project, let's change the color of the triangles as we draw them to a random color. To do that, we'll set <strong class="source-inline">fillStyle</strong> with a color before we draw the triangle, and we'll add a <strong class="source-inline">fill</strong> command. This is, generally, how the <strong class="source-inline">Context2D</strong> API works. You set up the state of the context and then execute commands with that state set. It takes a little getting used to but you'll get the hang of it. Let's add <strong class="source-inline">color</strong> as a parameter of the three <strong class="source-inline">u8</strong> tuples to <strong class="source-inline">draw_triangle</strong>:</p>
			<p class="source-code">fn draw_triangle(</p>
			<p class="source-code">    context: &amp;web_sys::CanvasRenderingContext2d,</p>
			<p class="source-code">    points: [(f64, f64); 3],</p>
			<p class="source-code">    color: (u8, u8, u8),</p>
			<p class="source-code">) {</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Colors are represented here as three components, red, green, and blue, where each value can go from <strong class="source-inline">0</strong> to <strong class="source-inline">255</strong>. We're using tuples in this chapter because we can make progress quickly, but if it's starting to bother you, you're welcome to make proper <strong class="source-inline">struct</strong>s.</p>
			<p>Now that <strong class="source-inline">draw_triangle</strong> needs a color, our application doesn't compile. Let's move to the <strong class="source-inline">sierpinski</strong> function and pass a color to it as well. We're going to send the color to the <strong class="source-inline">sierpinski</strong> function, instead of generating it there, so that we can get one color at every level. The first generation will be one solid color, then the second will all be one color, and <a id="_idIndexMarker072"/>then the third a third color, and so on. So let's add that:</p>
			<p class="source-code">fn sierpinski(</p>
			<p class="source-code">    context: &amp;web_sys::CanvasRenderingContext2d,</p>
			<p class="source-code">    points: [(f64, f64); 3],</p>
			<p class="source-code">    color: (u8, u8, u8),</p>
			<p class="source-code">    depth: u8,</p>
			<p class="source-code">) {</p>
			<p class="source-code">    draw_triangle(&amp;context, points, color);</p>
			<p class="source-code">    let depth = depth - 1;</p>
			<p class="source-code">    let [top, left, right] = points;</p>
			<p class="source-code">    if depth &gt; 0 {</p>
			<p class="source-code">        let left_middle = midpoint(top, left);</p>
			<p class="source-code">        let right_middle = midpoint(top, right);</p>
			<p class="source-code">        let bottom_middle = midpoint(left, right);</p>
			<p class="source-code">        sierpinski(&amp;context, [top, left_middle, </p>
			<p class="source-code">         right_middle], <strong class="bold">color</strong>, depth);</p>
			<p class="source-code">        sierpinski(&amp;context, [left_middle, left, </p>
			<p class="source-code">         bottom_middle], <strong class="bold">color</strong>, depth);</p>
			<p class="source-code">        sierpinski(&amp;context, [right_middle, bottom_middle, </p>
			<p class="source-code">         right], <strong class="bold">color</strong>, depth);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>I put <strong class="source-inline">color</strong> as the third parameter and not the fourth because I think it looks better that way. Remember to pass color to the other calls. Finally, so that we can compile, we'll send a color to the initial <strong class="source-inline">sierpinski</strong> call:</p>
			<p class="source-code">sierpinski(</p>
			<p class="source-code">    &amp;context,</p>
			<p class="source-code">    [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)],</p>
			<p class="source-code">    (0, 255, 0),</p>
			<p class="source-code">    5,</p>
			<p class="source-code">);</p>
			<p>Since this is an RGB color, <strong class="source-inline">(0, 255, 0)</strong> represents green. Now, we've made our code compile, but it doesn't do anything, so let's work back downward from the original call and into <a id="_idIndexMarker073"/>the <strong class="source-inline">sierpinski</strong> function again. Instead of just passing the color through, let's create a new tuple that has a random number for each component. You'll need to add <strong class="source-inline">use rand::prelude::*;</strong> to the use declarations at the top. Then, add the following code to the <strong class="source-inline">sierpinski</strong> function, after the <strong class="source-inline">if depth &gt; 0</strong> check:</p>
			<p class="source-code">let mut rng = thread_rng();</p>
			<p class="source-code">let next_color = (</p>
			<p class="source-code">    rng.gen_range(0..255),</p>
			<p class="source-code">    rng.gen_range(0..255),</p>
			<p class="source-code">    rng.gen_range(0..255),</p>
			<p class="source-code">);</p>
			<p class="source-code">...</p>
			<p class="source-code">sierpinski(</p>
			<p class="source-code">    &amp;context,</p>
			<p class="source-code">    top, left_middle, right_middle],</p>
			<p class="source-code">    next_color,</p>
			<p class="source-code">    depth,</p>
			<p class="source-code">);</p>
			<p class="source-code">sierpinski(</p>
			<p class="source-code">    &amp;context,</p>
			<p class="source-code">    [left_middle, left, bottom_middle],</p>
			<p class="source-code">    next_color,</p>
			<p class="source-code">    depth,</p>
			<p class="source-code">);</p>
			<p class="source-code">sierpinski(</p>
			<p class="source-code">    &amp;context,</p>
			<p class="source-code">    [right_middle, bottom_middle, right],</p>
			<p class="source-code">    next_color,</p>
			<p class="source-code">    depth,</p>
			<p class="source-code">);</p>
			<p>Inside the<a id="_idIndexMarker074"/> depth check, we randomly generate <strong class="source-inline">next_color</strong> and then pass it along to all the recursive <strong class="source-inline">sierpinski</strong> calls. But of course, our output <em class="italic">still</em> doesn't look any different. We never changed <strong class="source-inline">draw_triangle</strong> to change the color! This is going to be a little weird because the <strong class="source-inline">context.fillStyle</strong> property takes <strong class="source-inline">DOMString</strong> in JavaScript, so we'll need to do a conversion. At the top of <strong class="source-inline">draw_triangle</strong>, add two lines:</p>
			<p class="source-code">let color_str = format!("rgb({}, {}, {})", color.0, color.1, color.2);</p>
			<p class="source-code">context.set_fill_style(&amp;wasm_bindgen::JsValue::from_str(&amp;color_str));</p>
			<p>On line one, we convert our tuple of three unsigned integers to a string reading <strong class="source-inline">"rgb(255, 0, 255)"</strong>, which is what the <strong class="source-inline">fillStyle</strong> property expects. On the second line, we use <strong class="source-inline">set_fill_style</strong> to set it, doing that funky conversion. There are two things that you need to understand with this function. The first is that, generally, JavaScript properties are just public and you set them, but <strong class="source-inline">web-sys</strong> generates <strong class="source-inline">getter</strong> and <strong class="source-inline">setter</strong> functions. The second is that these generated functions frequently take <strong class="source-inline">JsValue</strong> objects, which represent an object owned by JavaScript. Fortunately, <strong class="source-inline">wasm_bindgen</strong> has factory functions for these, so we can create them <a id="_idIndexMarker075"/>easily and use the compiler as our guide.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Whenever you translate from JavaScript code to Rust, make sure that you check the documentation of the corresponding functions to see what types are needed. Passing a string to JavaScript isn't always as simple as you might think.</p>
			<p>Finally, we actually need to fill the triangles to see those colors, so after <strong class="source-inline">context.stroke()</strong>, you need to restore that <strong class="source-inline">context.fill()</strong> method you deleted earlier, and ta-da!</p>
			<div>
				<div class="IMG---Figure" id="_idContainer012">
					<img alt="Figure 1.7 – Filled triangles" src="image/Figure_1.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Filled triangl<a id="_idTextAnchor036"/>es</p>
			<p>You've <a id="_idIndexMarker076"/>done it, and you're ready to start creating a real game.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor037"/>Summary</h1>
			<p>In this chapter, we've done a <em class="italic">lot</em>. We've written our first WebAssembly app using Rust, moving from <em class="italic">"Hello World"</em> to drawing in the browser with HTML Canvas. You've added crates, run a development server, and interacted with the DOM. You've learned a lot about interacting with the browser, including the following:</p>
			<ul>
				<li>Creating the main entry point with <strong class="source-inline">#[wasm_bindgen(start)]</strong></li>
				<li>Translating JavaScript code to Rust code</li>
				<li>Dealing with crates that compile to JavaScript</li>
			</ul>
			<p>You've also been introduced to HTML Canvas. Frankly, it's been a bit of a whirlwind, so don't worry if some information flew over your head, as we'll cover many of these topics again – including in the next chapter, where we'll start drawing sprites.</p>
		</div>
	</body></html>