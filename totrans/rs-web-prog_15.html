<html><head></head><body>
		<div id="_idContainer190">
			<h1 id="_idParaDest-290" class="chapter-number"><a id="_idTextAnchor291"/>15</h1>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor292"/>Accepting TCP Traffic with Tokio</h1>
			<p>In the previous chapter, we managed to get actors running in different threads to send messages to each other. While it is exciting to code the building blocks for async programming, we left that chapter with a not-very-practical application. In this chapter, we will be creating a server with Tokio that listens to <strong class="bold">TCP</strong> traffic on a port. If messages are sent, our TCP server will process the incoming data, perform operations through a series of actors and threads, and then return the updated data to <span class="No-Break">the client.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><span class="No-Break">Exploring TCP</span></li>
				<li><span class="No-Break">Accepting TCP</span></li>
				<li><span class="No-Break">Processing bytes</span></li>
				<li>Passing TCP to <span class="No-Break">an actor</span></li>
				<li>Keeping track of orders <span class="No-Break">with actors</span></li>
				<li>Chaining communication <span class="No-Break">between actors</span></li>
				<li>Responding <span class="No-Break">with TCP</span></li>
				<li>Sending different commands via <span class="No-Break">the client</span></li>
			</ul>
			<p>By the end of this chapter, you will understand how to use TCP and how to package and unpack data sent via TCP with bytes. With this knowledge, you will be able to create a server using Tokio to listen to incoming messages, process those messages, and then perform units of computation based on the incoming message through a series of threads <span class="No-Break">and actors.</span></p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor293"/>Technical requirements</h1>
			<p>In this chapter, we will be building on the code from <a href="B18722_14.xhtml#_idTextAnchor279"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">Exploring the Tokio Framework</em>. This can be found at the following <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter14/working_with_actors"><span class="No-Break">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter14/working_with_actors</span></a><span class="No-Break">.</span></p>
			<p>The code for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter15"><span class="No-Break">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter15</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor294"/>Exploring TCP</h1>
			<p><strong class="bold">TCP</strong> stands for <strong class="bold">transmission control protocol</strong>. TCP is one of the most widely used transfer protocols on the internet. TCP is essentially a protocol that transports bytes over a socket from one program or <a id="_idIndexMarker1317"/>computer to another<a id="_idIndexMarker1318"/> using an <strong class="bold">internet protocol</strong> (<strong class="bold">IP</strong>). TCP is used for the world wide web, email, remote administration, and file transfer. The <strong class="bold">transport layer security/secure sockets layer</strong> (<strong class="bold">TLS/SSL</strong>) protocols are built on top of TCP. This means that HTTP and <a id="_idIndexMarker1319"/>HTTPS are built on top <span class="No-Break">of TCP.</span></p>
			<p>TCP is a connection-oriented protocol. This is where a connection between the client and server is established before any data is transferred. This is achieved by a <span class="No-Break">three-way handshake:</span></p>
			<ol>
				<li><strong class="bold">SYN</strong>: Initially, the client sends a SYN to the server. The SYN is a message with a random number to ensure<a id="_idIndexMarker1320"/> that the same client is communicating with <span class="No-Break">the server.</span></li>
				<li><strong class="bold">SYN-ACK</strong>: The server then<a id="_idIndexMarker1321"/> responds to the client with the initial sequence number and an additional random number known as <span class="No-Break">the ACK.</span></li>
				<li><strong class="bold">ACK</strong>: Finally, the client <a id="_idIndexMarker1322"/>returns the ACK to the server to establish that the connection has <span class="No-Break">been acknowledged.</span></li>
			</ol>
			<p><em class="italic">Steps 1</em> and <em class="italic">2</em> establish and acknowledge the sequence number from the client and the server. <em class="italic">Steps 2</em> and <em class="italic">3</em> establish and acknowledge the sequence number from the server to <span class="No-Break">the client:</span></p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/Figure_15.1_B18722.jpg" alt="Figure 15.1 – A TCP handshake"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – A TCP handshake</p>
			<p>In this chapter, we will be converting the actor model we built in the previous chapter so that it accepts TCP traffic from outside of our program as commands. First, we need to get our program to <a id="_idIndexMarker1323"/>accept <span class="No-Break">TCP connections.</span></p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor295"/>Accepting TCP</h1>
			<p>Before we write any TCP<a id="_idIndexMarker1324"/> code, we must acknowledge that our code is at risk of becoming bloated due to all the code being in one file. To prevent the <strong class="source-inline">src/main.rs</strong> file from becoming bloated, we must copy all the code apart from the main function from the <strong class="source-inline">src/main.rs</strong> file into a file called <strong class="source-inline">src/actors.rs</strong>. Now, we can wipe our <strong class="source-inline">src/main.rs</strong> file completely and fill it with the <span class="No-Break">following outline:</span></p>
			<pre class="source-code">
use tokio::net::TcpListener;
use std::{thread, time};
#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:8080".to_string();
    let mut socket = TcpListener::bind(&amp;addr).await.unwrap();
    println!("Listening on: {}", addr);
    while let Ok((mut stream, peer)) =
        socket.accept().await {
        println!("Incoming connection from: {}",
                  peer.to_string());
        tokio::spawn(async move {
            . . .
        });
    }
}</pre>
			<p>Here, we imported a TCP listener to listen to incoming traffic. We also imported structs that enable us to perform a sleep function from the <strong class="source-inline">Tokio</strong> crate and define our <strong class="source-inline">main</strong> runtime function. In our <strong class="source-inline">main</strong> function, we define our address and bind it to a TCP listener. We directly <a id="_idIndexMarker1325"/>unwrap this because if we fail to bind the address, there is no point in continuing with the program. You could handle the outcome of binding the address by increasing the port number by 1 until you find an open port number, but for this example, we should keep our implementation of the server simple. Then, we have a <strong class="source-inline">while</strong> loop that continues to accept new connections throughout the lifetime of the program, which can be infinite if the program is not interrupted or there is no problem with the socket. Once we get a connection, we spawn a new thread and process the <span class="No-Break">incoming message.</span></p>
			<p>For now, for our incoming message, we will merely sleep for 5 seconds, as seen in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
tokio::spawn(async move {
    println!("thread starting {} starting",
               peer.to_string());
    let five_seconds = time::Duration::from_secs(5);
    let begin = time::Instant::now();
    tokio::time::sleep(five_seconds);
    let end = begin.elapsed();
    println!("thread {} finishing {}", peer.to_string(),
              end.as_secs_f32());
});</pre>
			<p>Here, we print when the thread is starting and finish printing the time duration at the end. The duration should be more than the delay. We also make the thread sleep. The printout statements and sleep functionality will enable us to trace what is happening when we send multiple messages from <span class="No-Break">different programs.</span></p>
			<p>Now that we have<a id="_idIndexMarker1326"/> defined our program, which accepts TCP traffic, we can create a new Rust cargo project in a different directory for the client, which will send messages to the server. In this new project, the <strong class="source-inline">Cargo.toml</strong> file will contain the same dependencies as those in the TCP server. Inside the <strong class="source-inline">main.rs</strong> file, we have the following <span class="No-Break">simple program:</span></p>
			<pre class="source-code">
use tokio::net::TcpStream;
use tokio::io::AsyncWriteExt;
use std::error::Error;
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut stream =
        TcpStream::connect("127.0.0.1:8080").await?;
    println!("stream starting");
    stream.write_all(b"hello world").await?;
    println!("stream finished");
    Ok(())
}</pre>
			<p>This program merely makes a connection with the TCP server and then writes <strong class="source-inline">hello world</strong> in bytes to the TCP <a id="_idIndexMarker1327"/>stream. Once the bytes have been written, we finish. Now, we can test our server. First, we need to run our server, which will give us the <span class="No-Break">following printout:</span></p>
			<pre class="console">
Listening on: 127.0.0.1:8080</pre>
			<p>The terminal should now be hanging, which means we can run our client in a different terminal three times in a row as quickly as possible to get three requests in before the first thread stops sleeping. This will allow us to see the effect the sleeping threads have on our application. Our client printout should look <span class="No-Break">as follows:</span></p>
			<pre class="console">
    Finished dev [unoptimized + debuginfo] target(s) in
    0.87s
     Running `target/debug/simulation_client`
stream starting
stream finished
    Finished dev [unoptimized + debuginfo] target(s) in
    0.02s
     Running `target/debug/simulation_client`
stream starting
stream finished
    Finished dev [unoptimized + debuginfo] target(s) in
    0.01s
     Running `target/debug/simulation_client`
stream starting
stream finished</pre>
			<p>If we wait for 7 seconds, we <a id="_idIndexMarker1328"/>can inspect our server terminal, which should have the <span class="No-Break">following printout:</span></p>
			<pre class="console">
Incoming connection from: 127.0.0.1:57716
thread starting 127.0.0.1:57716 starting
Incoming connection from: 127.0.0.1:57717
thread starting 127.0.0.1:57717 starting
Incoming connection from: 127.0.0.1:57718
thread starting 127.0.0.1:57718 starting
thread 127.0.0.1:57716 finishing
thread 127.0.0.1:57717 finishing
thread 127.0.0.1:57718 finishing</pre>
			<p>Here, we can see that each process has a port on the local host. As expected with spawning threads to handle the incoming messages, the messages were handled in an async manner. We could handle many more connections <span class="No-Break">if needed.</span></p>
			<p>Now that we have managed to accept bytes through TCP, we will process these bytes in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor296"/>Processing bytes</h1>
			<p>Why do we send bytes through the TCP channel as opposed to the string itself? We send bytes because they have a <a id="_idIndexMarker1329"/>standardized way of being encoded and decoded. For instance, in this chapter, we are creating a client that is written in Rust. However, the client might be written in JavaScript or Python. Primitive data structures such as string characters can be encoded into bytes and then decoded when received by the TCP server. Because of the UTF-8 standard, we can use these strings anywhere. Our data could be saved in a file by one text editor and loaded by another text editor because they are both using the <span class="No-Break">same encoding.</span></p>
			<p>If we keep exploring the concept of bytes, we will conclude that the only data that a computer can store is bytes. MP3, WAV, JPEG, PNG, and so on are all examples of encoding. If you save any file, you will encode the data into bytes. If we load any file, we will be decoding the data from bytes. Now, let us decode our byte string that was sent <span class="No-Break">over TCP.</span></p>
			<p>In our <strong class="source-inline">main.rs</strong> file in the TCP server project, we first need to import <span class="No-Break">the following:</span></p>
			<pre class="source-code">
use tokio::io::{BufReader, AsyncBufReadExt, AsyncWriteExt};</pre>
			<p>The <strong class="source-inline">BufReader</strong> struct essentially adds a buffer to any reader, which improves the speed of small frequent reads from the same file or socket. While this greatly helps us as we are expecting multiple small <a id="_idIndexMarker1330"/>messages to be sent down the same TCP socket, it will not give us any speed improvement if we are trying to read a large stream of data in one go from a file or socket. The other two import traits must be imported to enable the <strong class="source-inline">BufReader</strong> struct to read <span class="No-Break">or write.</span></p>
			<p>Now, we must wipe all code in our thread spawn section of the code to start again as we will be doing a range of different processes. First, inside our thread spawn code, we must print out that we are starting the thread by splitting our stream into a reader and writer, and then creating our buffer reader from the reader and an empty vector to store the processed <span class="No-Break">incoming data:</span></p>
			<pre class="source-code">
println!("thread starting {} starting", peer.to_string());
let (reader, mut writer) = stream.split();
let mut buf_reader = BufReader::new(reader);
let mut buf = vec![];</pre>
			<p>Now that we have everything ready for reading, we can continuously read one line at a time, telling the reader to stop reading once it hits the EOF condition, <strong class="source-inline">'b\n'</strong>, from <span class="No-Break">our stream:</span></p>
			<pre class="source-code">
loop {
    match buf_reader.read_until(b'\n', &amp;mut buf).await {
        Ok(n) =&gt; {
            . . .
        },
        Err(e) =&gt; println!("Error receiving message: {}", e)
    }
}</pre>
			<p>We can see that if there is an error, we will print it out. However, the rest of the code that we are concerned with when it comes to processing bytes is in our <strong class="source-inline">Ok</strong> <span class="No-Break">code block.</span></p>
			<p>Inside our <strong class="source-inline">Ok</strong> code block, we initially need to check to<a id="_idIndexMarker1331"/> see if the stream has closed by checking if zero bytes <span class="No-Break">are received:</span></p>
			<pre class="source-code">
if n == 0 {
    println!("EOF received");
    break;
}</pre>
			<p><strong class="source-inline">EOF</strong> stands for <em class="italic">end-of-file</em>. EOF is the standard way of declaring that we have come to the end of the file or that the data stream has finished. Once we get past the preceding code block, we know that we have some bytes to process. We must convert our incoming bytes into a string using the <span class="No-Break">UTF-8 encoding:</span></p>
			<pre class="source-code">
let buf_string = String::from_utf8_lossy(&amp;buf);</pre>
			<p>The lossy reference in the preceding code is where nonstandard characters are replaced with a placeholder, so nonstandard characters are lost in translation. This is not going to be an issue for us as we are sending over standard characters. With our string data, we are going to separate values in a message with a <strong class="source-inline">;</strong> delimiter. We will split our string into a vector of strings, replacing all new lines with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let data: Vec&lt;String&gt; = buf_string.split(";")
                                  .map(|x| x.to_string()
                                  .replace("\n", ""))
                                  .collect();</pre>
			<p>Now, we can print out the processed message and then clear the buffer so that the line that we are processing does not get caught up in the next <span class="No-Break">processing step:</span></p>
			<pre class="source-code">
println!(
    "Received message: {:?}",
    data
);
buf.clear();</pre>
			<p>We are now at the end of the loop. Right outside the loop, we must print out that the thread is finished with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
println!("thread {} finishing", peer.to_string());</pre>
			<p>With that, we have finished our server for now as we can process bytes. Now, we can go to the <strong class="source-inline">main.rs</strong>  file in our client project and write the following <span class="No-Break">byte string:</span></p>
			<pre class="source-code">
println!("stream starting");
stream.write_all(b"one;two\nthree;four").await?;
println!("stream finished");</pre>
			<p>What outcome do you <a id="_idIndexMarker1332"/>think we will get from this byte string? If we look at the byte string, we will see that there is a new line, so we are sending two messages in one packet over the TCP connection. Each message has two values due to the <strong class="source-inline">;</strong> delimiter. When we spin up our server and run the client, we will get the <span class="No-Break">following printout:</span></p>
			<pre class="console">
Incoming connection from: 127.0.0.1:59172
thread starting 127.0.0.1:59172 starting
Received message: ["one", "two"]
Received message: ["three", "four"]
EOF received
thread 127.0.0.1:59172 finishing</pre>
			<p>We can see that our server processed two messages in the same thread before we closed the thread. With this, we can see that we have a lot of flexibility with TCP sockets. We are now ready to route TCP traffic to <span class="No-Break">our actors.</span></p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor297"/>Passing TCP to an actor</h1>
			<p>When it comes to routing TCP <a id="_idIndexMarker1333"/>data to actors, we need to import our actors and channels into the <strong class="source-inline">main.rs</strong> file in our <a id="_idIndexMarker1334"/>server project with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
. . .
use tokio::sync::mpsc;
mod actors;
use actors::{OrderBookActor, BuyOrder, Message};
. . .</pre>
			<p>Now, we have to construct our <em class="italic">order book</em> actor and run it. However, as you may recall, we merely ran the <em class="italic">order book</em> actor at the end of the Tokio runtime. However, if we apply this strategy here, we will block the loop from executing, so we can listen to incoming traffic. If we run the <em class="italic">order book</em> actor after the loop, the <em class="italic">order book</em> actor will never run as the loop runs indefinitely in a <strong class="source-inline">while</strong> loop and thus blocks the execution of any code following it. In our case, there is a further complication. This complication is that the actor run function enters a <strong class="source-inline">while</strong> loop, which further explains the need to put this entire code in a separate spawned Tokio task. Because of this, we must spawn a thread before <span class="No-Break">the loop:</span></p>
			<pre class="source-code">
#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:8080".to_string();
    let mut socket =
        TcpListener::bind(&amp;addr).await.unwrap();
    println!("Listening on: {}", addr);
    let (tx, rx) = mpsc::channel::&lt;Message&gt;(1);
    tokio::spawn(async move {
        let order_book_actor = OrderBookActor::new(rx,
                                                   20.0);
        order_book_actor.run().await;
    });
    println!("order book running now");
    while let Ok((mut stream, peer)) =
        socket.accept().await {
        println!("Incoming connection from: {}",
                  peer.to_string());
        let tx_one = tx.clone();
        . . .</pre>
			<p>Note that we directly <a id="_idIndexMarker1335"/>move the <strong class="source-inline">tx</strong> receiver into the Tokio task without cloning it because <strong class="source-inline">OrderBookActor</strong> is the only actor taking full exclusive ownership of the receiver. Here, we can see that the TCP listener is the same. Then, we create the <strong class="source-inline">mpsc</strong> channel, which we use to create and run our <em class="italic">order book</em> actor in the first thread that we spawn. Then, we enter the <strong class="source-inline">while</strong> loop to listen for TCP traffic. Note that the clone of the sender of the mpsc channel for the <em class="italic">order book</em> actor is cloned <a id="_idIndexMarker1336"/>straight away. This is because we are going to have to clone it again in the reading loop on every <span class="No-Break">next iteration.</span></p>
			<p>Inside the <strong class="source-inline">Ok</strong> block in our loop, we process our byte string, create the new <em class="italic">buy order</em> actor, and then send the message to the <em class="italic">order </em><span class="No-Break"><em class="italic">book</em></span><span class="No-Break"> actor:</span></p>
			<pre class="source-code">
. . .
let data: Vec&lt;String&gt; = buf_string.split(";")
    .map(|x| x.to_string().replace("\n", "")).collect();
let amount = data[0].parse::&lt;f32&gt;().unwrap();
let order_actor = BuyOrder::new(amount, data[1].clone(),
                                tx_one.clone());
println!("{}: {}", order_actor.ticker, order_actor.amount);
order_actor.send().await;
buf.clear();</pre>
			<p>And this should be it. We can see that the actors that we defined in a standard Tokio runtime without listening to<a id="_idIndexMarker1337"/> traffic can be plugged into our TCP network application. There is only one thing left to do, and that is to update the message being sent in the client <strong class="source-inline">main.rs</strong> file with the <a id="_idIndexMarker1338"/><span class="No-Break">following content:</span></p>
			<pre class="source-code">
. . .
println!("stream starting");
stream.write_all(b"8.0;BYND;\n9.0;PLTR").await?;
println!("stream finished");
. . .</pre>
			<p>Here, we are sending two buy orders (<strong class="source-inline">BYND</strong> and <strong class="source-inline">PLTR</strong>). If we run our server and then run our client, we will get the following printout for <span class="No-Break">the server:</span></p>
			<pre class="console">
Listening on: 127.0.0.1:8080
order book running now
actor is running
Incoming connection from: 127.0.0.1:59769
thread starting 127.0.0.1:59769 starting
BYND: 8
processing purchase, total invested: 8
here is the outcome: 1
PLTR: 9
processing purchase, total invested: 17
here is the outcome: 1
EOF received
thread 127.0.0.1:59769 finishing</pre>
			<p>With this printout, we can see that we run our <em class="italic">order book</em> actor and listen to TCP traffic before we process incoming <a id="_idIndexMarker1339"/>traffic. Then, we accept our packet, process the data, and send our data into the actor system. Overall, our<a id="_idIndexMarker1340"/> application flow takes the <span class="No-Break">following form:</span></p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/Figure_15.2_B18722.jpg" alt="Figure 15.2 – Our TCP application flow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – Our TCP application flow</p>
			<p>With this, we now have a network application that accepts TCP traffic and passes the processed data from the incoming bytes to our actor system. We create <em class="italic">buy order</em> actors on the fly when we accept a new message via TCP, while our <em class="italic">order book</em> actor continues to run throughout the lifetime of our program. If we were to add another order book or a different<a id="_idIndexMarker1341"/> type of actor, we could simply spin off another thread where we construct and run the actor. There is no limit to this, so our system <span class="No-Break">can scale.</span></p>
			<p>Right now, our client does <a id="_idIndexMarker1342"/>not know what happened. Therefore, our server must reply to our client about what happened. However, before we can do this, we must keep track of our stock orders so that we can return the state of our orders when we <span class="No-Break">need them.</span></p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor298"/>Keeping track of orders with actors</h1>
			<p>When it comes to keeping track of our orders, we could simply add a HashMap to our order book and add a couple of other messages that can be sent to the <em class="italic">order book</em> actor. This is one approach. We <a id="_idIndexMarker1343"/>are getting into territory where there are no clear correct approaches, and people within the community debate on the best approaches to solve problems. In this chapter, we will get used to creating actors and managing multiple actors in Tokio by creating two new actors. One actor will merely keep track of our stock purchases, while the other actor will send messages to the order tracker to get the state of <span class="No-Break">our orders.</span></p>
			<p>First, we need to create a separate file in <strong class="source-inline">src/order_tracker.rs</strong>. In this file, we initially need to import what we need to handle the collection of stocks and the channels that enable the connections between <span class="No-Break">the actors:</span></p>
			<pre class="source-code">
use tokio::sync::{mpsc, oneshot};
use std::collections::HashMap;</pre>
			<p>Then, we need to create the message struct for the messages sent to our <span class="No-Break">tracker actor:</span></p>
			<pre class="source-code">
#[derive(Debug, Clone)]
pub enum Order {
    BUY(String, f32),
    GET
}
pub struct TrackerMessage {
    pub command: Order,
    pub respond_to: oneshot::Sender&lt;String&gt;
}</pre>
			<p>Here, we need to pass in a command. This command is needed because the tracker actor can perform multiple actions, such as <strong class="source-inline">BUY</strong> and <strong class="source-inline">GET</strong>. If the command is just a <strong class="source-inline">GET</strong>, then we do not need anything else, which is why the rest of the fields <span class="No-Break">are optional.</span></p>
			<p>With this message defined, we<a id="_idIndexMarker1344"/> can build the most basic actor, which merely sends a <strong class="source-inline">get</strong> message to the tracker actor and returns the state of <span class="No-Break">our orders:</span></p>
			<pre class="source-code">
pub struct GetTrackerActor {
    pub sender: mpsc::Sender&lt;TrackerMessage&gt;
}</pre>
			<p>Here, we can see that no state is held by <strong class="source-inline">GetTrackerActor</strong>. We could just make this whole actor a function in another actor. However, as stated, we want to get comfortable with managing multiple actors in an async system in this chapter. To enable our <strong class="source-inline">GetTrackerActor</strong> to get data, we must create a <strong class="source-inline">send</strong> function that will send a <strong class="source-inline">GET</strong> command to the tracker actor and return the state of the tracker actor as <span class="No-Break">a string:</span></p>
			<pre class="source-code">
impl GetTrackerActor {
    pub async fn send(self) -&gt; String {
        println!("GET function firing");
        let (send, recv) = oneshot::channel();
        let message = TrackerMessage {
            command: Order::GET,
            respond_to: send
        };
        let _ = self.sender.send(message).await;
        match recv.await {
            Err(e) =&gt; panic!("{}", e),
            Ok(outcome) =&gt;  return outcome
        }
    }
}</pre>
			<p>This method should be familiar to you now. We created a one-shot channel so that the tracker actor could send a message back to the <strong class="source-inline">GetTrackerActor</strong> actor. Then, we sent the <strong class="source-inline">GET</strong> message and waited for a response. You may have also noticed that we are printing out that the <strong class="source-inline">send</strong> function is firing. We will be peppering the code with print statements<a id="_idIndexMarker1345"/> throughout so that we can track how the <strong class="source-inline">async</strong> code runs in the printout and in <span class="No-Break">what order.</span></p>
			<p>We are now at the stage where to need to create our <em class="italic">order tracker</em> actor. We need a HashMap and a channel to receive messages, which we can create with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub struct TrackerActor {
    pub receiver: mpsc::Receiver&lt;TrackerMessage&gt;,
    pub db: HashMap&lt;String, f32&gt;
}</pre>
			<p>This actor is more complex as we need the actor to run to receive messages, handle the messages, and send the state of the order, which takes the <span class="No-Break">following outline:</span></p>
			<pre class="source-code">
impl TrackerActor {
    pub fn new(receiver: mpsc::Receiver&lt;TrackerMessage&gt;) -&gt;
        Self {
        . . .
    }
    fn send_state(&amp;self, respond_to: oneshot::
                  Sender&lt;String&gt;) {
        . . .
    }
    fn handle_message(&amp;mut self, message: TrackerMessage) {
        . . .
    }
    pub async fn run(mut self) {
        . . .
    }
}</pre>
			<p>If you wish to test your handle on actors, now is a good time to try and implement the <span class="No-Break">preceding functions.</span></p>
			<p>If you have attempted these functions, they should be implemented similarly to what’s shown in the following <a id="_idIndexMarker1346"/>code, which we are going to cover here. First, our constructor takes the <span class="No-Break">following form:</span></p>
			<pre class="source-code">
pub fn new(receiver: mpsc::Receiver&lt;TrackerMessage&gt;) -&gt;
    Self {
    TrackerActor {
        receiver,
        db: HashMap::new(),
    }
}</pre>
			<p>This constructor should not be a surprise for anyone. We need a HashMap with a string as a key to denote the ticker and a float for the number of stocks we own for that ticker. We also accept a channel receiver to <span class="No-Break">receive messages.</span></p>
			<p>The next process we need to define is how to package our data into a string so that we can send it over TCP. We can do this with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
fn send_state(&amp;self, respond_to: oneshot::Sender&lt;String&gt;) {
    let mut buffer = Vec::new();
    for key in self.db.keys() {
        let amount = self.db.get(key).unwrap();
        buffer.push(format!("{}:{ };", &amp;key, amount));
    }
    buffer.push("\n".to_string());
    println!("sending state: {}", buffer.join(""));
    respond_to.send(buffer.join(""));
}</pre>
			<p>Here, we create a vector that holds our data. Then, we loop through our HashMap, which is logging our stock<a id="_idIndexMarker1347"/> holdings. We can see that we separate the ticker from the amount with a <strong class="source-inline">:</strong>, and then we separate the individual stock tickers with counts with a <strong class="source-inline">;</strong>. At this point, our response should be something like <strong class="source-inline">"BYND:8;PLTR:9;\n"</strong>, which means that we have 8 of BYND and 9 of PLTR. Once we have stored the entire state in a vector of strings, we join the vector into one string and then send that string over <span class="No-Break">a channel.</span></p>
			<p>We now have everything we need to handle an incoming message, which can be handled with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
fn handle_message(&amp;mut self, message: TrackerMessage) {
    match message.command {
        Order::GET =&gt; {
            println!("getting state");
            self.send_state(message.respond_to);
        },
        Order::BUY(ticker, amount) =&gt; {
            match self.db.get(&amp;ticker) {
                Some(ticker_amount) =&gt; {
                    self.db.insert(ticker, ticker_amount +
                                   amount);
                },
                None =&gt; {
                    self.db.insert(ticker, amount);
                }
            }
            println!("db: {:?}", self.db);
        }
    }
}</pre>
			<p>Here, we match the command being passed via the incoming message. If a <strong class="source-inline">GET</strong> command is passed, we merely return the state with the address to respond to extracted from the incoming message. If a <strong class="source-inline">BUY</strong> command is passed, we extract the parameters for the purchase order from the message and try and get the ticker from the HashMap. If the ticker is not<a id="_idIndexMarker1348"/> present, we create a new entry. If the ticker is present, we merely increase the count of the ticker that we <span class="No-Break">have bought.</span></p>
			<p>We have now handled our messages and state. There is only one thing left to do and that is to run the actor; this can be achieved with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub async fn run(mut self) {
    println!("tracker actor is running");
    while let Some(msg) = self.receiver.recv().await {
        self.handle_message(msg);
    }
}</pre>
			<p>With this, our tracker actor is fully working, so it is time to stand back and look at our system and how we envision it to work, as shown in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/Figure_15.3_B18722.jpg" alt="Figure 15.3 – Interactions between actors"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – Interactions between actors</p>
			<p>Here, we can see that there must be an interaction between the <em class="italic">order book</em> actor and the <em class="italic">tracker actor</em> when a buy order<a id="_idIndexMarker1349"/> is executed. Therefore, we need to refactor our <em class="italic">order book</em> actor to enable chained communication between <span class="No-Break">multiple actors.</span></p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor299"/>Chaining communication between actors</h1>
			<p>As we can see in <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.2</em>, our <em class="italic">order book</em> actor is running and accepting orders. The <em class="italic">order book</em> actor then sends a message to the <em class="italic">tracker</em> actor, updating the state once the <strong class="source-inline">BUY</strong> order is processed. This means that our actor needs to manage two channels. To handle two <a id="_idIndexMarker1350"/>channels, inside the <strong class="source-inline">src/actors.rs</strong> file, we need to import the tracker message with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use tokio::sync::{mpsc, oneshot, mpsc::Sender};
use crate::order_tracker::TrackerMessage;</pre>
			<p>Now, we must hold two channels, resulting in our <strong class="source-inline">OrderBookActor</strong> struct having the <span class="No-Break">following fields:</span></p>
			<pre class="source-code">
pub struct OrderBookActor {
    pub receiver: mpsc::Receiver&lt;Message&gt;,
    pub sender: mpsc::Sender&lt;TrackerMessage&gt;,
    pub total_invested: f32,
    pub investment_cap: f32
}</pre>
			<p>Here, the fields are essentially the same, but we are holding onto a sender that sends messages to the tracker. We<a id="_idIndexMarker1351"/> can see how helpful different messages are. We know exactly where the message is destined to be. With this extra field, we need to slightly change the constructor for <strong class="source-inline">OrderBookActor</strong> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub fn new(receiver: mpsc::Receiver&lt;Message&gt;,
           sender: mpsc::Sender&lt;TrackerMessage&gt;,
           investment_cap: f32) -&gt; Self {
    OrderBookActor {
        receiver, sender,
        total_invested: 0.0,
        investment_cap
    }
}</pre>
			<p>There is only one other behavior that we must add. Remember that we process our incoming messages in the <strong class="source-inline">handle_message</strong> function. Here, we must send a <strong class="source-inline">TrackerMessage</strong> to the tracker actor with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
async fn handle_message(&amp;mut self, message: Message) {
    if message.amount + self.total_invested &gt;=
        self.investment_cap {
        println!("rejecting purchase, total invested: {}",
                  self.total_invested);
        let _ = message.respond_to.send(0);
    }
    else {
        self.total_invested += message.amount;
        println!("processing purchase, total invested: {}",
                  self.total_invested);
        let _ = message.respond_to.send(1);
        let (send, _) = oneshot::channel();
        let tracker_message = TrackerMessage{
            command: "BUY".to_string(),
            ticker: Some(message.ticker),
            amount: Some(message.amount),
            respond_to: send
        };
        let _ = self.sender.send(tracker_message).await;
    }
}</pre>
			<p>As we can see, the logic for deciding whether a buy order is going to be processed is the same, but if the buy order is <a id="_idIndexMarker1352"/>processed, we merely construct a <strong class="source-inline">TrackerMessage</strong> and send it to the <span class="No-Break"><em class="italic">tracker</em></span><span class="No-Break"> actor.</span></p>
			<p>Now that our actors have been built and refactored, our actor system will behave as shown in <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.2</em>. We can now implement our new actor system so that we can respond to the TCP traffic <span class="No-Break">with TCP.</span></p>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor300"/>Responding with TCP</h1>
			<p>When it comes to responding to TCP, we<a id="_idIndexMarker1353"/> must implement our actor system in the <strong class="source-inline">src/main.rs</strong> file. First, we need to import our new actors with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
. . .
use order_tracker::{TrackerActor, GetTrackerActor,
                    TrackerMessage};</pre>
			<p>Now, we must construct our extra channel in the <strong class="source-inline">main</strong> function with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let addr = "127.0.0.1:8080".to_string();
let socket = TcpListener::bind(&amp;addr).await.unwrap();
println!("Listening on: {}", addr);
let (tx, rx) = mpsc::channel::&lt;Message&gt;(1);
let (tracker_tx, tracker_rx) =
    mpsc::channel::&lt;TrackerMessage&gt;(1);
let tracker_tx_one = tracker_tx.clone();</pre>
			<p>Here, we have a <strong class="source-inline">tracker</strong> channel. With the <strong class="source-inline">tracker</strong> and <strong class="source-inline">main</strong> channels, we can spin up two different threads with the <em class="italic">tracker</em> actor and <em class="italic">order book</em> actor with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
tokio::spawn( async {
    TrackerActor::new(tracker_rx).run();
});
tokio::spawn(async move {
    let order_book_actor = OrderBookActor::new(
        rx, tracker_tx_one.clone(), 20.0);
    order_book_actor.run().await;
});</pre>
			<p>With this, we now have two of our actors running, awaiting incoming messages. Now, we must manage our incoming TCP traffic and spin up different actors, depending on the command passed in. As a design choice, we are going to have the first string passed in via TCP to be the<a id="_idIndexMarker1354"/> command that our <span class="No-Break">application has:</span></p>
			<pre class="source-code">
let buf_string = String::from_utf8_lossy(&amp;buf);
let data: Vec&lt;String&gt; = buf_string.split(";")
    .map(|x| x.to_string().replace("\n", "")).collect();
println!("here is the data {:?}", data);
let command = data[0].clone();</pre>
			<p>Then, we must match our command with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
match command.as_str() {
    "BUY" =&gt; {
        . . .
    },
    "GET" =&gt; {
        . . .
    },
    _ =&gt; {
        panic!("{} command not supported", command);
    }
}
buf.clear();</pre>
			<p>For our buy order, we still simply spin up the <em class="italic">buy order</em> actor and send it to the <em class="italic">order </em><span class="No-Break"><em class="italic">book</em></span><span class="No-Break"> actor:</span></p>
			<pre class="source-code">
println!("buy order command processed");
let amount = data[1].parse::&lt;f32&gt;().unwrap();
let order_actor = BuyOrder::new(amount, data[2].clone(),
                                tx_one.clone());
println!("{}: {}", order_actor.ticker, order_actor.amount);
order_actor.send().await;</pre>
			<p>The main change here is how we<a id="_idIndexMarker1355"/> manage the incoming data, and this is because we have introduced the <strong class="source-inline">command</strong> parameter. For the <strong class="source-inline">get</strong> command, we create <strong class="source-inline">GetTrackerActor</strong>, which sends a message to the tracker actor. Then, we write the state that we got from the <em class="italic">tracker</em> actor with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
println!("get order command processed");
let get_actor =
    GetTrackerActor{sender: tracker_tx_two.clone()};
let state = get_actor.send().await;
println!("sending back: {:?}", state);
writer.write_all(state.as_bytes()).await.unwrap();</pre>
			<p>With this, our server can now accept different commands and track all the buy orders that we <span class="No-Break">have made.</span></p>
			<p>Even though our server is now fully functional, our client will not work. This is because we have not updated our client with the commands. In the next section, we will update our client, which can send multiple <span class="No-Break">different commands.</span></p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor301"/>Sending different commands via the client</h1>
			<p>Our client is simple, and it is going to stay simple. First, we must ensure our read and write traits are imported as<a id="_idIndexMarker1356"/> this time, we will be reading a response. Our imports in the <strong class="source-inline">src/main.rs</strong> file should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
use tokio::net::TcpStream;
use tokio::io::{BufReader, AsyncBufReadExt, AsyncWriteExt};
use std::error::Error;</pre>
			<p>Then, we must write a series of messages to our connection and then read until we get a <span class="No-Break">new line:</span></p>
			<pre class="source-code">
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut stream =
        TcpStream::connect("127.0.0.1:8080").await?;
    let (reader, mut writer) = stream.split();
    println!("stream starting");
    writer.write_all(b"BUY;8.0;BYND;\nBUY;9.0;PLTR\n
                     BUY;9.0;PLTR\nGET\n").await?;
    println!("sent data");
    let mut buf_reader = BufReader::new(reader);
    let mut buf = vec![];
    println!("reading data");
    let _ = buf_reader.read_until(b'\n',
                                  &amp;mut buf).await.unwrap();
    let state_string = String::from_utf8_lossy(&amp;buf);
    println!("{}", state_string);
    Ok(())
}</pre>
			<p>With this, we are done. All we must do now is run the server and then run the client. The client has the <span class="No-Break">following printout:</span></p>
			<pre class="console">
stream starting
sent data
reading data
PLTR:9;BYND:8;</pre>
			<p>Here, we get the state of our stock orders after sending our orders. Even though this state is in a single string, we <a id="_idIndexMarker1357"/>have delimiters so that we can split our data up into something useful. Once our client has run, our server will have the <span class="No-Break">following printout:</span></p>
			<pre class="console">
Incoming connection from: 127.0.0.1:61494
thread starting 127.0.0.1:61494 starting
here is the data ["BUY", "8.0", "BYND", ""]
buy order command processed
BYND: 8
processing purchase, total invested: 8
db: {"BYND": 8.0}
here is the outcome: 1
here is the data ["BUY", "9.0", "PLTR"]
buy order command processed
PLTR: 9
processing purchase, total invested: 17
db: {"PLTR": 9.0, "BYND": 8.0}
here is the outcome: 1
here is the data ["BUY", "9.0", "PLTR"]
buy order command processed
PLTR: 9
rejecting purchase, total invested: 17
here is the outcome: 0
here is the data ["GET"]
get order command processed
GET function firing
getting state
sending state: PLTR:9;BYND:8;
sending back: "PLTR:9;BYND:8;\n"
EOF received
thread 127.0.0.1:61494 finishing</pre>
			<p>This is a long printout, but we can see how our order message got converted into a vector. We can also see how<a id="_idIndexMarker1358"/> the state of our tracker changes over time, and at the end, we can see how our <strong class="source-inline">get</strong> command is processed with the <em class="italic">get state</em> actor and <span class="No-Break"><em class="italic">tracker</em></span><span class="No-Break"> actor.</span></p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor302"/>Summary</h1>
			<p>In this chapter, we managed to bring our Tokio async program to the next level by accepting incoming TCP traffic. Then, we processed our TCP traffic, which was packaged in bytes, essentially creating a protocol for processing buy orders for stocks. We must note that we have a lot of flexibility with this approach. We managed to stuff multiple buy orders and then a <strong class="source-inline">get</strong> command into one message. We can become creative with our message structure as there is little constraint in how to package our message and unpack it in the server if the protocols are consistent between the server and <span class="No-Break">the client.</span></p>
			<p>Then, we added more threads and actors to our system to handle multiple commands passed into our server. We finished up this chapter by updating our client and returning the state of our orders. The result is a highly async-safe network application that accepts messages via TCP. This network application is not just for running on our local computers. We can wrap this TCP Tokio network application in Docker and deploy it on a server. You now have the tools to build lower-level network applications to aid your web applications. Considering that our distroless Rust servers are roughly 50 MB in size, these network applications will be an inexpensive aid to whatever problems you are trying <span class="No-Break">to solve.</span></p>
			<p>While having a protocol is useful and gives us more freedom, we will take our protocol processing of TCP traffic to the next level in the next chapter with framing, enabling us to have even more control over how we process and package our messages as they’re being sent <span class="No-Break">via TCP.</span></p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor303"/>Further reading</h1>
			<p>Tokio TCP <span class="No-Break">documentation: </span><a href="https://docs.rs/tokio/latest/tokio/net/struct.TcpStream.html"><span class="No-Break">https://docs.rs/tokio/latest/tokio/net/struct.TcpStream.html</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor304"/>Questions</h1>
			<ol>
				<li value="1">How do we create an actor that accepts messages and sends messages to <span class="No-Break">other actors?</span></li>
				<li>Why do we need to spin our long-running actors up in their <span class="No-Break">own threads?</span></li>
				<li>How can we have multiple actors processing the same type <span class="No-Break">of job?</span></li>
			</ol>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor305"/>Answers</h1>
			<ol>
				<li value="1">We create an actor that has a minimum of two fields. These two fields hold the sender for the channel of the actor we are sending messages to and the receiver of the channel we are receiving messages from. Then, we need a <strong class="source-inline">run</strong> function to enable our actor to run awaiting <span class="No-Break">incoming messages.</span></li>
				<li>If we do not create a thread to run our long-running actors, our main runtime will be blocked by this actor running. If only one actor is running after the server is listening, this is OK; however, if there are multiple actors or a loop that is accepting TCP traffic, then we have a problem as the system will essentially be gridlocked and our actor system will <span class="No-Break">not work.</span></li>
				<li>We can build an actor that essentially acts like a router. It can keep track of incoming messages and alternate sending messages to multiple different actors who do the same type of job. However, do not do this if multiple actors rely on the <span class="No-Break">internal state.</span></li>
			</ol>
		</div>
	</body></html>