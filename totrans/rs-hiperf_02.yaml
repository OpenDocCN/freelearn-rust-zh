- en: Extra Performance Enhancements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的性能提升
- en: Once your application avoids common performance bottlenecks, it's time to move
    to more complex performance improvements. Rust has many options that allow you
    to improve the performance of your code by using lesser-known APIs. This will
    give you parity with C/C++ and, in some scenarios, it can even improve the speed
    of most of the fastest C/C++ scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用程序避免了常见的性能瓶颈，就是时候转向更复杂的功能提升了。Rust 有许多选项，允许你通过使用不太为人所知的 API 来提高你代码的性能。这将使你的性能与
    C/C++ 相当，在某些场景中，它甚至可以提高大多数最快的 C/C++ 脚本的运行速度。
- en: 'In this chapter, we will be looking into the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Compile-time checks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时检查
- en: Compile-time state machines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时状态机
- en: Extra performance enhancements, such as using closures for avoiding runtime
    evaluation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的性能提升，例如使用闭包来避免运行时评估
- en: Unstable sorting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不稳定的排序
- en: Map hashing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射哈希
- en: Standard library collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库集合
- en: Compile-time checks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时检查
- en: Rust has an amazing type system. It's so powerful that it is Turing-complete
    by itself. This means that you can write very complex programs just by using Rust's
    type system. This can help your code a lot, since the type system gets evaluated
    at compile time, making your runtime much faster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有一个惊人的类型系统。它如此强大，以至于它本身就是一个图灵完备的。这意味着你只需使用 Rust 的类型系统就可以编写非常复杂的程序。这可以极大地帮助你的代码，因为类型系统在编译时进行评估，这使得你的运行时速度更快。
- en: 'Starting from the basics, what do we mean by *the type system*? Well, it means
    all those traits, structures, generics, and enums you can use to make your code
    very specialized at runtime. An interesting thing to know is the following: if
    you create a generic function that gets used with two different types, Rust will
    compile two specific functions, one for each type.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础知识开始，我们所说的*类型系统*是什么意思？嗯，这意味着所有那些特质、结构、泛型和枚举，你可以在运行时使用它们来使你的代码非常专业化。一个有趣的事实是：如果你创建了一个泛型函数，它使用了两种不同的类型，Rust
    将编译两个特定的函数，每个类型一个。
- en: 'This might seem like code duplication but, in reality, it is usually faster
    to have a specific function for the given type than to try to generalize a function
    over multiple ones. This also allows for the creation of specialized methods that
    will take into account the data they are using. Let''s see this with an example.
    Suppose we have two structures and we want them to output a message with some
    of their information:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是代码重复，但事实上，对于给定的类型，拥有一个特定的函数通常比尝试泛化多个函数要快。这也允许创建专门的方法，这些方法将考虑它们使用的数据。让我们用一个例子来看看。假设我们有两个结构，我们希望它们输出一些信息：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We create a trait that we will implement for them that will return something
    that can be displayed in the console:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个特质，我们将为它们实现它，它将返回可以在控制台显示的内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And we implement it for our structures. Note that I have decided to return
    a reference to the data string in the case of the `StringData` structure. This
    simplifies the logic but adds some lifetimes and some extra referencing to the
    variable. This is because the reference must be valid while `StringData` is valid.
    If not, it might try to print non-existent data, and Rust prevents us from doing
    that:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的结构实现了它。请注意，我决定在`StringData`结构的情况下返回数据字符串的引用。这简化了逻辑，但增加了一些生命周期和一些额外的引用到变量。这是因为引用必须在`StringData`有效时有效。如果不是，它可能会尝试打印不存在的数据，而
    Rust 阻止我们这样做：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, one of them returns a string and the other returns an integer,
    so it would be very difficult to create a function that allows both of them to
    work, especially in a strongly-typed language. But since Rust will create two
    completely different functions for them, each using their own code, this can be
    solved thanks to generics:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，其中一个返回一个字符串，另一个返回一个整数，因此创建一个允许它们都工作的函数将非常困难，尤其是在强类型语言中。但是，由于 Rust 为它们创建了两个完全不同的函数，每个函数都使用自己的代码，这可以通过泛型来解决：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, the `println!` macro will call to the specific methods of the
    `i32` and `&str` structures. We then simply create a small `main()` function to
    test everything, and you should see how it can print both structures perfectly:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`println!` 宏将调用 `i32` 和 `&str` 结构的特定方法。然后我们简单地创建一个小的 `main()` 函数来测试一切，你应该能看到它如何完美地打印出这两个结构：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You might be tempted to think that this is similar to what languages such as
    Java do with their interfaces, and, functionally, it is. But talking about performance,
    our topic in this book, they are very different. Here, the generated machine code
    will effectively be different between both calls. One clear symptom is that the
    `print()` method gets ownership of the value it receives, so the caller must pass
    this in the registers of the CPU. Both structures are fundamentally different
    though. One is bigger than the other (containing the string pointer, the length,
    and capacity), so the way the call is done must be different.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，这与Java等语言使用接口的方式相似，在功能上确实如此。但谈到性能，我们这本书的主题，它们非常不同。在这里，生成的机器代码在两次调用之间将会有所不同。一个明显的症状是`print()`方法获得了它接收的值的所有权，因此调用者必须将其传递到CPU的寄存器中。尽管这两种结构在本质上都是不同的。一个比另一个大（包含字符串指针、长度和容量），因此调用方式必须不同。
- en: So, great, Rust does not use the same structure for traits as Java does for
    interfaces. But why should you care? Well, there are a number of reasons, but
    there is one that will probably show you what this accomplishes. Let's create
    a state machine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，太好了，Rust不使用与Java接口相同的结构。但你为什么要关心这个呢？好吧，有多个原因，但有一个可能会让你了解这是如何完成的。让我们创建一个状态机。
- en: Sequential state machines
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序状态机
- en: Let's first think about how to implement this in a C/C++ environment. You will
    probably have a global state and then a `while` loop that would change the state
    after each iteration. There are, of course, many ways of implementing a state
    machine but, in C, all of them require either metaprogramming or a runtime evaluation
    of the global state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先思考如何在C/C++环境中实现它。你可能会有一个全局状态，然后是一个`while`循环，每次迭代后都会改变状态。当然，实现状态机有许多方法，但在C语言中，所有这些方法都需要元编程或对全局状态的运行时评估。
- en: 'In Rust, we have a Turing-complete type system, so why not try and use it to
    create that state machine? Let''s start by defining some traits that will have
    the power of creating the state machine. We first define a `StateMachine` trait,
    that will have the functionality of moving from one state to another state:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们有一个图灵完备的类型系统，为什么不尝试用它来创建状态机呢？让我们首先定义一些将具有创建状态机能力的特质。我们首先定义一个`StateMachine`特质，它将具有从一个状态移动到另一个状态的功能：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, I already added a new type, `MainLogic`. This will be a trait
    representing a structure that can perform a logic in a state. The `StateMachine`
    trait itself is pretty simple. It only contains a type that will be the next state
    and an `execute()` function that consumes itself so that nobody can execute the
    same state twice without going to the next state (the next state could be itself
    again). It simply returns a new state machine. Here we have the `MainLogic` trait:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我已经添加了一个新的类型，`MainLogic`。这将是一个代表可以在状态中执行逻辑的结构特质的类型。`StateMachine`特质本身很简单。它只包含一个类型，它将是下一个状态，以及一个`execute()`函数，它消耗自身，这样就没有人可以在不进入下一个状态的情况下执行同一个状态两次（下一个状态又可以是它自己）。它简单地返回一个新的状态机。这里我们有`MainLogic`特质：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It''s just a function to execute the logic of the state. The main functionality
    of this state machine, that will enable it to go from one state to the next, always
    doing the proper logic, is defined in the default implementation of the `MainLogic`
    trait:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个执行状态逻辑的函数。这个状态机的主体功能，将使其能够从一个状态移动到下一个状态，始终执行正确的逻辑，是在`MainLogic`特质的默认实现中定义的：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will implement the `MainLogic` trait for any state implementing the `StateMachine`
    trait. It will simply execute the state and then call the main logic of the next
    state. If this new state is also a `StateMachine`, it will get executed and then
    the next state will be executed. This pattern is especially useful if you want
    to sequentially execute different states. The last state will be the one implementing
    `MainLogic` but not `StateMachine`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为任何实现`StateMachine`特质的状态实现`MainLogic`特质。它将简单地执行状态，然后调用下一个状态的主逻辑。如果这个新状态也是`StateMachine`，它将被执行，然后执行下一个状态。这种模式在你想顺序执行不同的状态时特别有用。最后一个状态将是实现`MainLogic`但不是`StateMachine`的状态：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The compiler will make sure at compile time that you properly go from the first
    state to the second one, and it will force you to do so. But, more importantly,
    this will be compiled into very efficient code, as efficient as doing the sequential
    calls one by one, but with all the safety Rust gives you. In fact, as you can
    see, both `FirstState` and `Laststate` have no attributes. That is because they
    have no size. They will not occupy space in memory at runtime.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将确保你在编译时正确地从第一个状态转换到第二个状态，并强制你这样做。但更重要的是，这将编译成非常高效的代码，效率与逐个执行顺序调用一样高，但提供了Rust所提供的所有安全性。事实上，正如你所见，`FirstState`和`Laststate`都没有属性。这是因为它们没有大小。它们在运行时不会占用内存空间。
- en: This is the simplest state machine though. It will only allow you to advance
    from one state to the next. It's helpful if that's what you want, since it will
    make sure your flow gets checked at compile time, but it will not perform complex
    patterns. If you loop over a previous state, you will endlessly continue looping.
    This will also be useful when each state has a defined next state and when no
    other possibility comes from that state.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的状态机。它只会允许你从一个状态前进到下一个状态。如果你想要这样做，这很有帮助，因为它将确保你的流程在编译时得到检查，但它不会执行复杂的模式。如果你在一个先前状态上循环，你将无限循环。这也会在每个状态都有一个定义的下一个状态，并且没有其他可能性从这个状态产生时很有用。
- en: Complex state machines
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂的状态机
- en: A more complex state machine, that allows you to move from one to another in
    your code while still using the type system to check for proper usage, can be
    done. Let's start by defining the state machine. We want a machine that represents
    the way a robot works in a car-building facility. Let's say its job is to install
    two doors in a car. It will first wait for the next car to come, take the door,
    put it in place, put the bolts in place, do the same for the second door, and
    then wait for the next car.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的状态机，允许你在代码中从一个状态移动到另一个状态，同时仍然使用类型系统来检查正确的使用，是可以实现的。让我们首先定义状态机。我们希望一个机器能够代表机器人在汽车制造设施中的工作方式。假设它的任务是安装两扇车门。它将首先等待下一辆车到来，取下车门，将其放置到位，安装螺栓，对第二扇车门做同样的操作，然后等待下一辆车。
- en: 'We will first define some functions that will use sensors and that we will
    simulate:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一些将使用传感器并模拟的函数：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Of course, the real software would need to take many things into account. It
    should check that the environment is safe, the way it moves the door to the car
    should be optimal, and so on, but this simplification will do for now. We now
    define some states:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，真正的软件需要考虑许多因素。它应该检查环境是否安全，移动车门到汽车的方式应该是最优的，等等，但现在的简化已经足够了。我们现在定义一些状态：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And we then define the machine itself:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义机器本身：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This machine will hold an internal state that can have some information attached
    to it (it can be any kind of structure) or it can have a zero-sized structure,
    and thus have a size of zero bytes. We will then implement our first transition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机器将持有内部状态，可以附加一些信息（可以是任何类型的结构）或者可以有一个零大小的结构，因此具有零字节的大小。然后我们将实现我们的第一个转换：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will simply check every 1 second whether the car is in the proper place.
    Once it is, it will return the next state, the `TakingDoor` state. The function
    signature makes sure that you cannot return the incorrect state, even if you do
    a really complex logic inside the `from()` function. Moreover, at compile time,
    this `DoorMachine` will have zero byte size, as we saw, so it will not consume
    RAM regardless of how complex our state transitions are. Of course, the code for
    the `from()` functions will be in RAM, but the necessary checks for proper transitioning
    will all be done at compile time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地每秒检查一次汽车是否在正确的位置。一旦它在正确的位置，它将返回下一个状态，即`TakingDoor`状态。函数签名确保你无法返回错误的状态，即使你在`from()`函数内部执行非常复杂的逻辑。此外，在编译时，这个`DoorMachine`将具有零字节大小，正如我们所见，因此它不会消耗RAM，无论我们的状态转换多么复杂。当然，`from()`函数的代码将存储在RAM中，但必要的检查都会在编译时完成。
- en: 'We will then implement the next transition:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将实现下一个转换：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And finally, a similar thing can be done for the last state:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于最后一个状态，也可以做类似的事情：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The machine can start in any given state, and moving it from one to another
    will be as simple as writing the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 机器可以从任何给定的状态开始，从一个状态移动到另一个状态将像编写以下内容一样简单：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You might be thinking, *why don't I simply write two functions and execute them
    sequentially?* The answer is not straightforward, but it's easy to explain. This
    makes you avoid many issues at compile time. For example, if each state has only
    one possible next state, you can use a generic `into()` function without needing
    to know the current state, and it will simply work.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“我为什么不简单地写两个函数并按顺序执行它们？”答案并不直接，但很容易解释。这让你在编译时避免了许多问题。例如，如果每个状态只有一个可能的下一个状态，你可以使用一个通用的`into()`函数，而无需知道当前状态，它将简单地工作。
- en: 'In a more complex environment, you might find yourself doing the following
    pattern:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更复杂的环境中，你可能会发现自己做以下模式：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, if you look at it properly, we are no longer in the first state!
    What will happen if the machine tries to change the state again, thinking it's
    still in the first state? Well, here is where Rust comes handy. The `into()` function
    takes ownership of the binding, so this will simply not compile. Rust will complain
    that the `beginning_state` no longer exists since it has been already converted
    to `next_state`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你正确地看待它，我们就不再处于第一个状态了！如果机器试图再次改变状态，认为它仍然处于第一个状态，会发生什么？嗯，这正是Rust发挥作用的地方。`into()`函数获取绑定所有权，所以这根本无法编译。Rust会抱怨`beginning_state`不再存在，因为它已经被转换成了`next_state`。
- en: Real-life type system check example
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实的类型系统检查示例
- en: 'There is an example I love when talking about compile-time checks and high-performance
    computing: Philipp Oppermann wrote a type-safe paging system for a kernel with
    only two traits. Let''s first understand the problem and then try the solution.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论编译时检查和高性能计算时，有一个例子我非常喜欢：Philipp Oppermann为内核编写了一个只有两个特质的类型安全分页系统。让我们首先理解这个问题，然后尝试解决方案。
- en: When a program uses the memory on a computer, it must separate virtual memory
    from physical memory. This is because each program running in the OS will think
    that the whole address space is theirs. This means that in a 64-bit machine, each
    program will think it has 16 **exbibytes** (**EiB**) of memory, 2^(64) bytes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序在计算机上使用内存时，它必须将虚拟内存与物理内存分开。这是因为运行在操作系统中的每个程序都会认为整个地址空间是它们的。这意味着在一个64位机器上，每个程序都会认为它有16
    **exbibytes**（**EiB**）的内存，即2^(64)字节。
- en: That is, of course, not the case for any computer in the world, so what the
    kernel does is to move memory out of RAM to the HDD/SSD, and put in RAM the required
    memory. For this to work properly, memory has to be managed in chunks, since it
    doesn't make sense to move in and out individual memory addresses. These are called
    pages, and they are usually 4 KiB in size for x86_64 processors (the case for
    most laptops and desktop computers).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是世界上任何计算机的情况，所以内核所做的就是将内存从RAM移动到HDD/SSD，并将所需的内存放入RAM。为了正确工作，内存必须以块的形式进行管理，因为移动单个内存地址是没有意义的。这些被称为页面，对于x86_64处理器（大多数笔记本电脑和台式计算机的情况）来说，它们通常大小为4
    KiB。
- en: 'For the paging to be easily manageable, a paging hierarchy gets created. Every
    512 pages get added to an index called a P1 table, and every 512 P1 tables get
    added to a P2 table. That goes on recursively until all pages have been assigned,
    which will be 4 levels. That is what it''s called: 4-level paging.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使分页易于管理，创建了一个分页层次结构。每512页被添加到一个称为P1表的索引中，每512个P1表被添加到一个P2表中。这个过程递归进行，直到所有页面都被分配，这将达到4级。这就是它被称为4级分页的原因。
- en: The idea is that a kernel should be able to ask a table for one of its pages,
    and if it's a P4 table, it should be able to ask for a P3, then for a P2, then
    for a P1, and finally load the page referenced by that P1\. This address gets
    passed in a 64-bit registry, so all the data is there. The problem is that it
    could be easy to end up with tons of code duplication for each table type, or
    we could end up with a solution that works for all pages but that has to check
    the current page at runtime if it wants to return the next table (if it's a P4-P2
    table) or the actual page (if it's a P1 table).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，内核应该能够向一个表请求其页面之一，如果它是一个P4表，它应该能够请求一个P3，然后是P2，然后是P1，最后加载由P1引用的页面。这个地址通过一个64位寄存器传递，所以所有数据都在那里。问题是，对于每种表类型，可能会很容易出现大量的代码重复，或者我们可能会得到一个适用于所有页面的解决方案，但为了返回下一个表（如果它是P4-P2表）或实际页面（如果它是P1表），它必须在运行时检查当前页面。
- en: The first case is really error-prone, and difficult to maintain, while the second
    one not only continues being error-prone, but it even requires checks at runtime,
    making it slower. Rust can do better.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况确实容易出错，难以维护，而第二种情况不仅继续容易出错，甚至需要在运行时进行检查，使其变慢。Rust可以做得更好。
- en: 'The solution is to define a trait that all pages have, let''s call it `PageTable`,
    and a trait that only higher-order tables have (tables that cannot directly return
    a page but that they need to return another page table). Let''s call it `HighTable`.
    Since all `HighTable` types are also `PageTable`, one trait will inherit from
    the other:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是定义一个所有页面都有的特质，让我们称它为`PageTable`，以及一个只有高阶表有的特质（不能直接返回页面但需要返回另一个页面表的表）。让我们称它为`HighTable`。由于所有`HighTable`类型也都是`PageTable`，一个特质将继承另一个特质：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This creates four enumerations representing page table levels. The reason for
    using enumerations instead of structures is that empty enumerations cannot be
    instantiated, which will avoid some typos. Then we write the `HighTable` trait:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了代表页面表级别的四个枚举。使用枚举而不是结构体的原因是空枚举不能实例化，这样可以避免一些错误。然后我们编写`HighTable`特质：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we add an associated type to each enumeration to represent the
    next level of paging. But, of course, in the case of the last level, it will not
    have another page table below.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们为每个枚举添加了一个关联类型来表示分页的下一级。但是，当然，在最后一级的情况下，它下面不会有另一个页面表。
- en: This allows you to define functions associated to `HighTable` that will not
    be accessible to a P1 table and so on. And it lets you create a `Page` type that
    will contain the contents of a `Page` (a byte array, more or less) that is generic
    over what level it is.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你定义与`HighTable`关联的函数，这些函数将无法被P1表等访问。它还让你创建一个`Page`类型，该类型将包含`Page`的内容（大致是一个字节数组），它是通用的，适用于任何级别。
- en: Rust will ensure that you cannot try to get the next table of a P1 table at
    compile time, and at runtime, these enumerations will disappear, as they are zero-sized.
    The logic will be safe, though, and checked at compile time with no overhead.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Rust将确保你无法在编译时尝试获取P1表的下一个表，而在运行时，这些枚举将消失，因为它们是零大小的。逻辑将是安全的，并且将在编译时进行检查，没有开销。
- en: Extra performance tips
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的性能技巧
- en: Compile-time checks are not the only place where you can benefit from a performance
    enhancement at no cost. While in [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml), *Common
    Performance Pitfalls*, we saw the common errors people write in Rust, we left
    the most advanced tips and tricks for this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时检查并不是唯一可以免费获得性能提升的地方。在[第1章](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml)，“常见性能陷阱”中，我们看到了人们在Rust中编写的常见错误，但我们把最先进的技巧和窍门留给了这一章。
- en: Using closures to avoid runtime evaluation
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用闭包来避免运行时评估
- en: 'Sometimes, it might seem natural to write code that does not perform as fast
    as expected. Many times, this is due to Rust doing some extra computations at
    runtime. An example of an unnecessary computation that someone could write is
    the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，编写代码可能看起来很自然，但它的性能并不如预期。很多时候，这是由于Rust在运行时进行一些额外的计算。某人可能会编写以下不必要的计算示例：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I have intentionally made this example simply because a real example usually
    takes really long code. The idea behind it is valid though. When you have an `Option`
    or a `Result`, you have some very useful functions to allow you get the value
    inside or a default. There is this specific function, the `unwrap_or()` function,
    that allows you specify the default value. Of course, you can pass anything you
    want to that function, but if you require a complex calculation to calculate the
    default value (and it's not a constant), the code will perform poorly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意使这个例子简单，因为真实示例通常需要非常长的代码。尽管如此，其背后的思想是有效的。当你有一个`Option`或`Result`时，你有一些非常有用的函数来允许你获取其内部的值或默认值。有一个特定的函数，即`unwrap_or()`函数，它允许你指定默认值。当然，你可以向该函数传递任何你想要的东西，但如果你需要进行复杂的计算来计算默认值（并且它不是一个常量），代码的性能将会很差。
- en: 'This happens because when calling the `unwrap_or()` function, the value you
    pass must be calculated beforehand. This does not make much sense if most of the
    time the value will exist and the computation is not required. A better option
    is to use `unwrap_or_else()`. This function accepts a closure that will only be
    executed if the `Option`/`Result` is `None`/`Err` respectively. In this concrete
    case, since `some_complex_function()` does not have any arguments, you can directly
    use that as the closure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在调用`unwrap_or()`函数时，你必须事先计算出你传递的值。如果大部分时间值都存在且不需要计算，这就没有太多意义。更好的选择是使用`unwrap_or_else()`。这个函数接受一个闭包，该闭包只有在`Option`/`Result`为`None`/`Err`时才会执行。在这个具体案例中，由于`some_complex_function()`没有参数，你可以直接将其作为闭包使用：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But if the function requires arguments, you will need to build the closure
    yourself:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果函数需要参数，你需要自己构建闭包：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This way, you can use a very complicated function, as complicated as you'd like,
    and you will avoid calling it if there is something inside the `Option` type.
    You will also reduce the cyclomatic complexity of the function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以使用一个非常复杂的函数，复杂程度由你决定，如果函数内部有`Option`类型的内容，你将避免调用它。同时，你也会降低函数的圈复杂度。
- en: Unstable sorting
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不稳定排序
- en: 'There is also an interesting place where some gains can be made. Usually, when
    you want to sort a vector, for example, stable sorting is used. This means that
    if two elements have the same ordering, the original ordering will be preserved.
    Let''s see it with an example. Suppose we have a list of fruits we want to order
    alphabetically, taking into account only their first letter:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个有趣的地方可以取得一些收益。通常，当你想要对一个向量进行排序时，例如，会使用稳定的排序。这意味着如果两个元素具有相同的排序，原始的顺序将被保留。让我们用一个例子来看看。假设我们有一个水果列表，我们想要按字母顺序对其进行排序，只考虑它们的第一个字母：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will print exactly the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出以下内容：
- en: '![](img/2f922eee-3536-4d96-845c-da8a7b362b97.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f922eee-3536-4d96-845c-da8a7b362b97.png)'
- en: And in that order. Even though `Peach` and `Pear` should be before `Pome` if
    we did the sorting by the whole word, since we only take the first character into
    account, the ordering is correct. The final order depends on the one at the beginning.
    If I changed the first list and put `Pome` after `Peach`, the final order would
    have `Pome` after `Peach`. This is called **stable ordering**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 并且按照这个顺序。即使按照整个单词排序时，`Peach`和`Pear`应该在`Pome`之前，但由于我们只考虑第一个字符，排序是正确的。最终的顺序取决于开始的顺序。如果我改变了第一个列表，将`Pome`放在`Peach`之后，最终的顺序将是`Pome`在`Peach`之后。这被称为**稳定的排序**。
- en: On the other hand, unstable ordering doesn't try to preserve previous ordering.
    So, `Pome`, `Peach`, and `Pear` could end up in any order between them. This is
    consistent with the condition of being ordered by the first letter, but without
    preserving the original order.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不稳定的排序并不试图保留之前的顺序。因此，`Pome`、`Peach`和`Pear`之间的顺序可以是任意的。这与按第一个字母排序的条件一致，但不会保留原始顺序。
- en: This unstable sorting is actually faster than the stable sorting, and if you
    don't care about respecting the initial ordering, you can save valuable time doing
    the sorting operation, one of the most time-consuming operations. A simple example
    is ordering a list of results alphabetically. In the case of a mismatch, you usually
    don't care how they were ordered in the database, so it doesn't matter if one
    comes after the other or the other way around.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不稳定排序实际上比稳定排序更快，如果你不介意尊重初始顺序，你可以在排序操作中节省宝贵的时间，排序操作是最耗时的操作之一。一个简单的例子是按字母顺序对结果列表进行排序。在出现不匹配的情况下，你通常不关心它们在数据库中的排序方式，所以一个在前一个在后或者反过来都没有关系。
- en: 'To use unstable sorting, you will need to call `sort_unstable()` or `sort_unstable_by()`,
    depending on whether you want to use the default comparison of each `PartialOrd`
    element or use your own classifier, if you want a custom one or if the elements
    in the vector are not `PartialOrd`. Consider the following example using unstable
    sorting:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用不稳定的排序，你需要调用`sort_unstable()`或`sort_unstable_by()`，这取决于你是否想使用每个`PartialOrd`元素的默认比较，或者使用你自己的分类器，如果你需要一个自定义的分类器，或者向量的元素不是`PartialOrd`。考虑以下使用不稳定排序的示例：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A possible output for this would be the following, impossible with stable sorting:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况下的可能输出如下，这在稳定的排序中是不可能的：
- en: '![](img/2f922eee-3536-4d96-845c-da8a7b362b97.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f922eee-3536-4d96-845c-da8a7b362b97.png)'
- en: So, summarizing, if you really need to maintain the ordering of the input, use
    stable sorting; if not, use unstable sorting, since you will make your program
    much faster.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，如果你真的需要保持输入的顺序，使用稳定的排序；如果不，使用不稳定的排序，因为这将使你的程序运行得更快。
- en: Map hashing
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射哈希
- en: Rust also has another development option that allows you to make the hashing
    of the maps faster. This comes from the idea that when storing information in
    a `HashMap`, for example, the key gets hashed or a faster lookup. This is great,
    since it allows using arbitrary long and complex keys, but adds overhead when
    retrieving a value or inserting a new value, since the hash must be calculated.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Rust还有一个开发选项，允许你使映射的哈希更快。这来自于这样一个想法：当在`HashMap`中存储信息时，例如，键被哈希或进行快速查找。这很好，因为它允许使用任意长和复杂的键，但在检索值或插入新值时增加了开销，因为必须计算哈希。
- en: Rust allows you to change the hashing method for a `HashMap`, and even create
    your own. Of course, usually, the best thing is to use the default hashing algorithm,
    since it has been thoroughly tested and avoids collisions (different keys having
    the same hash and overwriting one another). The default hasher for Rust is a very
    efficient hasher, but if you need performance and you are working with a really
    small `HashMap` or even a somehow predictable `HashMap`, it could make sense to
    use your own function or even a faster function included in Rust.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Rust允许你更改`HashMap`的哈希方法，甚至可以创建自己的。当然，通常最好的做法是使用默认的哈希算法，因为它已经过彻底测试，避免了冲突（不同的键具有相同的哈希值并相互覆盖）。Rust的默认哈希器是一个非常高效的哈希器，但如果你需要性能，并且你正在处理一个非常小的`HashMap`或某种可预测的`HashMap`，使用你自己的函数或甚至Rust中包含的更快函数是有意义的。
- en: But beware—it's very risky to use one of these functions in an environment where
    a user can provide (or manipulate) keys. They could generate a collision and modify
    the value of a key they should not have access to. They could even create a denial
    of service attack using it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意——在一个用户可以提供（或操作）键的环境中，使用这些函数是非常危险的。他们可能会生成冲突并修改他们不应访问的键的值。他们甚至可以使用它来创建拒绝服务攻击。
- en: 'Using a different hashing is as simple as using the `with_hasher()` function
    when creating the `HashMap`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的哈希方法就像在创建`HashMap`时使用`with_hasher()`函数一样简单：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Currently, only `RandomState` is available in the standard library; the rest
    have been deprecated. But you can create your own by implementing the `Hasher`
    trait:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，标准库中仅提供`RandomState`；其余的都已弃用。但你可以通过实现`Hasher`特性来创建自己的：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This creates the `MyHasher` structure, which contains a count that can be initialized
    as you wish. The `hash` function is really simple; it just adds all the bytes
    of the key and returns a `u64` with the sum result. Generating a collision here
    is pretty easy: you just need to make your bytes sum the same. So `[45, 23]` will
    have the same hash as `[23, 45]`. But it works as an example of a hasher. The
    `BuildHasher` trait is also required, and it only needs to return an instance
    of a `Hasher`. I derived the `Clone` trait and just cloned it.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了`MyHasher`结构，其中包含一个可以按你的意愿初始化的计数器。`hash`函数实际上非常简单；它只是将键的所有字节相加，并返回一个包含求和结果的`u64`。在这里生成冲突很容易：你只需要让你的字节求和相同。所以`[45,
    23]`将具有与`[23, 45]`相同的哈希值。但它作为一个哈希器的例子。还需要`BuildHasher`特性，它只需要返回一个`Hasher`的实例。我派生了`Clone`特性，并简单地克隆了它。
- en: 'This can be easily used, as we saw before:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易使用，就像我们之前看到的那样：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will probably be faster than the default hasher, but it will also be much,
    much less secure. So be careful about what hash function you use.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能比默认的哈希器更快，但安全性也会低得多。所以请小心选择你使用的哈希函数。
- en: Perfect hash functions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完美哈希函数
- en: 'If the map is known at compile time, and it does not change during the runtime,
    there is a very, very fast system that can improve by orders of magnitude the
    use of maps. It''s called **perfect hash functions**, and that''s the key to them:
    they perform the minimum required computation for a hash to know whether it''s
    stored in the hash map. This is because it maps one, and only one, integer for
    each element. And it has no collisions. Of course, this requires a constant, known
    hash map at compilation time.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编译时已知映射，并且在运行时不会改变，那么有一个非常、非常快的系统可以按数量级提高映射的使用效率。它被称为**完美哈希函数**，这是它们的关键：它们执行最小的计算来确定一个哈希值是否存储在哈希表中。这是因为它将一个，且仅有一个整数映射到每个元素。并且没有冲突。当然，这需要在编译时有一个已知的常量哈希表。
- en: To use them, you will need the `phf` crate. With this crate, you will be able
    to define a hash map at compile time in the `build.rs` file at the same level
    as the `Cargo.toml` file and use it with no more overhead than a comparison in
    your code. Let's see how to configure it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它们，你需要 `phf` 包。使用这个包，你可以在 `build.rs` 文件中定义一个哈希表，该文件与 `Cargo.toml` 文件位于同一级别，并且使用它时，代码中的开销不会比比较操作更大。让我们看看如何配置它。
- en: 'First, you will need to add the `phf_codegen` crate as a development dependency.
    For that, you will need to add a `build-dependencies` section to your `Cargo.toml`,
    with the same syntax as the `dependencies` section. Then, you will need to create
    a `build.rs` file and, inside, you will need something like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将 `phf_codegen` 包添加为开发依赖项。为此，你需要在 `Cargo.toml` 中添加一个 `build-dependencies`
    部分，其语法与 `dependencies` 部分相同。然后，你需要创建一个 `build.rs` 文件，并在其中需要如下内容：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's check what is happening here. The `build.rs` script is run before the
    compilation starts (if it's present). We have a map that is an array of key/value
    tuples. It then creates a code generation map and adds entries one by one to the
    map. This has to be done in a loop, since the compiler stack could overflow due
    to deep recursion.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这里发生了什么。`build.rs` 脚本在编译开始之前运行（如果存在）。我们有一个键/值元组的数组映射。然后它创建一个代码生成映射，并逐个将条目添加到映射中。这必须在一个循环中完成，因为编译器栈可能会因为深度递归而溢出。
- en: 'It will write into a file, called `phf.rs`, starting with a line adding a static
    variable, and then writing the whole map into the file, ending it with a new line.
    This means that once the compilation starts, a new file named `phf.rs` will exist
    that we can use from our code. How? You will need to directly include the file
    in your code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它将写入一个名为 `phf.rs` 的文件，首先添加一个静态变量，然后写入整个映射到文件中，并以新行结束。这意味着一旦开始编译，就会存在一个名为 `phf.rs`
    的新文件，我们可以从我们的代码中使用它。如何？你需要直接在代码中包含这个文件：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will print the value associated to `key1`, in this case, `value1`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印与 `key1` 关联的值，在这种情况下，是 `value1`。
- en: Note that when creating the map in the `build.rs` file, the values are written
    directly, so if you want to put a string, you need to add the quotation marks
    and escape them. This enables you to add enumeration variants, for example, or
    to write code directly for values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `build.rs` 文件中创建映射时，值是直接写入的，所以如果你想放一个字符串，你需要添加引号并转义它们。这使你能够添加枚举变体，或者为值直接编写代码。
- en: Once you have learned how to use compile-time hash maps, you should understand
    the different kinds of collections the standard library allows you to use, since
    it will be crucial to the speed and memory footprint of your application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你学会了如何使用编译时哈希表，你应该了解标准库允许你使用的不同类型的集合，因为这对你的应用程序的速度和内存占用至关重要。
- en: Standard library collections
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库集合
- en: Rust's standard library has eight different collection types in the `std::collections`
    module. They are divided into sequences, maps, sets, and a binary heap that does
    not fit in any group. The most well known ones are arguably `HashMap` and `Vec`,
    but each of them has a use case, and you should know about them to use the proper
    one in each moment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的标准库在 `std::collections` 模块中有八种不同的集合类型。它们被分为序列、映射、集合和一个不适合任何组的二叉堆。最著名的是
    `HashMap` 和 `Vec`，但每个都有其用例，你应该了解它们，以便在每个时刻使用正确的类型。
- en: The official standard library documentation is really good, so you should check
    it thoroughly. In any case, though, I will introduce the types so that you can
    familiarize yourself with them. Let's start with sequences.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的标准库文档非常好，所以你应该彻底检查它。无论如何，我将会介绍这些类型，以便你能够熟悉它们。让我们从序列开始。
- en: Sequences
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: The most-used dynamic sequence in Rust and in most languages is the vector,
    represented in Rust as `Vec`. You can add elements to the back of a vector with
    the `push()` method, and get the last element back with the `pop()` method. You
    can also iterate through the vector and, by default, it will go from front to
    back, but you can also reverse the iterator to go from back to front. In general,
    a vector in Rust can be compared to a stack, since it's primarily a LIFO structure.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 以及大多数语言中，最常用的动态序列是向量，在 Rust 中表示为 `Vec`。你可以使用 `push()` 方法向向量的末尾添加元素，并使用
    `pop()` 方法获取最后一个元素。你也可以遍历向量，默认情况下它将从前往后遍历，但你也可以反转迭代器从后往前遍历。一般来说，Rust 中的向量可以比作栈，因为它主要是一个后进先出（LIFO）结构。
- en: Vectors are really useful when you want to add new elements to a list, and when
    you are fine with working with indexes in slices to get the elements. Remember
    that vectors can be referenced as slices, and can be indexed with ranges. An interesting
    thing is that you can convert a vector into a boxed slice, that is similar to
    an array, but allocated in heap instead of a stack. You only have to call the
    `into_boxed_slice()` method. This is useful when you have finished growing the
    vector and want it to occupy less RAM. A vector has a capacity, a length, and
    a pointer to the elements, while a boxed slice will only have the pointer and
    the length, avoiding some extra memory usage.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 向量在你想向列表中添加新元素，并且你愿意使用索引在切片中获取元素时非常有用。记住，向量可以作为切片引用，并且可以使用范围进行索引。有趣的是，你可以将向量转换为boxed
    slice，这类似于数组，但分配在堆上而不是栈上。你只需要调用`into_boxed_slice()`方法。这在向量增长完成后，你想让它占用更少的RAM时很有用。向量有一个容量、一个长度和一个指向元素的指针，而boxed
    slice将只包含指针和长度，从而避免一些额外的内存使用。
- en: Another useful sequence is the `VecDeque` sequence. This structure is a FIFO
    queue, where you can append elements to the back of the queue using the `push_back()`
    method, and pop elements from the front by using `pop_front()`. This can be used
    as a buffer since it can be consumed from the front while you continue adding
    elements to the back. Of course, to use it as a buffer crossing thread boundaries,
    you will need to lock it with a `Mutex`, for example. Iterations in these queues
    go from front to back, the same way as in vectors. It's implemented with a growable
    ring buffer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的序列是`VecDeque`序列。这个结构是一个FIFO队列，你可以使用`push_back()`方法将元素追加到队列的末尾，并使用`pop_front()`从前面弹出元素。这可以用作缓冲区，因为它可以在你继续向队列末尾添加元素的同时从前端消耗。当然，为了在跨线程边界使用它作为缓冲区，你需要使用`Mutex`等锁。这些队列的迭代从前面到后面，与向量中的迭代方式相同。它是通过可增长的环形缓冲区实现的。
- en: Finally, the `LinkedList` is another sequential list where its peculiarity is
    that instead of having a chunk of elements in the memory, each element gets linked
    to the one before and the one after so that there is no need for an index. It's
    easy to iterate, and easy to remove any element in the list without leaving gaps
    or having to reorder the memory, but in general, it's not very memory-friendly
    and requires more CPU consumption.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`LinkedList`是另一种顺序列表，其特点是它不像在内存中有一个元素块，每个元素都链接到它前面的一个和后面的一个，因此不需要索引。迭代很容易，删除列表中的任何元素也很容易，无需留下空隙或重新排序内存，但通常它不是非常节省内存，并且需要更多的CPU消耗。
- en: You will, most of the time, prefer a `Vec` or a `VecDeque`. `LinkedLists` are
    usually only a good option when many inserts and removes have to be done in the
    middle of the sequence, since in that case, `Vecs` and `VecDeques` will have to
    reorder themselves, which takes a lot of time. But if you will usually only change
    the structure of the list from the back, a `Vec` is the best option; if you will
    also change it from the front, a `VecDeque`. Remember that in both you can read
    any element easily by indexing, it's just that it's more time-consuming to remove
    or add them in the middle of the list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你大多数时候会倾向于使用`Vec`或`VecDeque`。`LinkedLists`通常只有在需要在序列中间进行许多插入和删除操作时才是一个好的选择，因为在这种情况下，`Vecs`和`VecDeques`将不得不重新排序，这需要很多时间。但如果你通常只会从后端更改列表的结构，`Vec`是最好的选择；如果你也会从前端更改它，那么`VecDeque`。记住，在这两种情况下，你可以通过索引轻松读取任何元素，只是从中部删除或添加它们会更耗时。
- en: Maps
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'There are two kinds of maps: `HashMap` and `BTreeMap`. The main difference
    between them is how they order themselves in memory. They have similar methods
    to insert and retrieve elements, but their performance changes a lot depending
    on the operation.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的映射：`HashMap`和`BTreeMap`。它们之间的主要区别在于它们在内存中的排序方式。它们有类似的方法来插入和检索元素，但性能会根据操作有很大变化。
- en: '`HashMap` creates an index, where for every key a hash points to the element.
    That way, you do not need to check the whole key for every new `insert`/`delete`/`get`
    operation. You simply hash it and search it in the index. If it exists, it can
    be retrieved, modified, or deleted; if it doesn''t, it can be inserted. It is
    pretty fast to insert new elements. It''s as simple as adding it to the index.
    Retrieving it is also pretty much the same: just get the value if the hashed index
    exists; all operations are done in `O(1)`. You cannot append one `HashMap` to
    another, though, because their hashing algorithms will be different, or at least
    be in different states.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 创建一个索引，其中每个键通过哈希值指向相应的元素。这样，你就不需要为每个新的 `insert`/`delete`/`get` 操作检查整个键。你只需对它进行哈希，然后在索引中搜索。如果存在，可以检索、修改或删除；如果不存在，可以插入。插入新元素非常快，只需将其添加到索引中即可。检索也大致相同：如果哈希索引存在，则获取其值；所有操作都在
    `O(1)` 时间内完成。不过，你不能将一个 `HashMap` 添加到另一个中，因为它们的哈希算法将不同，或者至少处于不同的状态。'
- en: '`BTreeMap`, on the other hand, does not create indexes. It maintains an ordered
    list of elements and, that way, when you want to insert or get a new element,
    it does a binary search. Check whether the key is bigger than the key in the middle
    of the list. If it is, divide the second half of the list into two and try it
    again with the element of the middle of the second half; if it''s not, do the
    same with the first half.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`BTreeMap` 不创建索引。它维护一个有序的元素列表，因此当你想要插入或获取一个新元素时，它会进行二分搜索。检查键是否大于列表中间的键。如果是，将列表的后半部分分成两部分，并再次使用后半部分的中间元素尝试；如果不是，对前半部分做同样的操作。
- en: That way, you don't have to compare each element with all elements in the map,
    and you can quickly retrieve them. Adding new elements is a similarly costly algorithm,
    and all operations can be done in `O(log n)`. You can also append another `BTreeSet`
    to this one, and the elements will be reordered for the search to be as fast as
    possible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你不必将每个元素与映射中的所有元素进行比较，并且可以快速检索它们。添加新元素的操作成本也类似，所有操作都可以在 `O(log n)` 时间内完成。你还可以将另一个
    `BTreeSet` 添加到这个集合中，并且元素将被重新排序，以便搜索尽可能快。
- en: Sets
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'Both `HashMap` and `BTreeMap` have their set counterparts, called `HashSet`
    and `BTreeSet`. Both are implemented with the same idea in mind: sometimes you
    don''t need a key/value store, but just an element store, where you can retrieve
    the list of the elements by iterating through them, or where you can check whether
    an element is inside just by comparing it to the ones inside.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 和 `BTreeMap` 都有它们的集合对应物，分别称为 `HashSet` 和 `BTreeSet`。两者都是基于相同的思想实现的：有时你不需要键/值存储，只需要一个元素存储，你可以通过迭代来检索元素列表，或者通过比较来检查元素是否在内部。'
- en: Their approach is the same as with the case of their map counterparts, and you
    can think of them as their counterpart maps but with a null value, where only
    keys are the ones doing the job.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的实现方式与它们的映射对应物相同，你可以将它们视为它们的映射对应物，但带有空值，其中只有键在执行工作。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use compile-time checks to your advantage.
    You learned how Rust's type system can help you create complex and safe behaviour
    without runtime overhead. You learned how to create state machines and how to
    make your code less error-prone.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何利用编译时检查的优势。你学习了 Rust 的类型系统如何帮助你创建复杂且安全的操作，而无需运行时开销。你学习了如何创建状态机以及如何使你的代码更不容易出错。
- en: You also learned about some extra performance enhancements that complement those
    of [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml), *Common Performance
    Pitfalls*. You learned about unstable sorting and map hashing, including perfect
    hash functions created at compile time, and how to create compile-time hash maps
    that will have no runtime overhead.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解了一些额外的性能增强，这些增强补充了 [第 1 章](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml) 中提到的内容，*常见的性能陷阱*。你学习了不稳定的排序和映射哈希，包括编译时创建的完美哈希函数，以及如何创建没有运行时开销的编译时哈希映射。
- en: Finally, you learned about the collections in the standard library, how they
    are classified, and which type of collection you should use depending on the situation.
    You learned about sequences, maps, and sets, and how they can be adapted for your
    code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你了解了标准库中的集合，它们的分类以及根据情况选择哪种类型的集合。你了解了序列、映射和集合，以及它们如何适应你的代码。
- en: In [Chapter 3](71d38dd3-1f0b-408e-b454-3d342b413f7c.xhtml), *Memory Management
    in Rust*, we will talk about memory management in Rust. Even if, in Rust, you
    do not need to manually allocate and de-allocate memory, there are still plenty
    of things you can do to improve your memory footprint.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](71d38dd3-1f0b-408e-b454-3d342b413f7c.xhtml)，*Rust中的内存管理*，我们将讨论Rust中的内存管理。即使，在Rust中，你不需要手动分配和释放内存，仍然有许多事情你可以做来优化你的内存占用。
