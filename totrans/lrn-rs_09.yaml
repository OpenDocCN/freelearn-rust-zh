- en: Introducing Generics, Impl, and Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key benefits of any modern language is the ability to be able to
    use a type which can be anything. Not only does this reduce the amount of code
    required, but it allows for greater flexibility in code creation. Rust not only
    allows for generic types and functions, but introduces traits; these can be considered
    as a logical extension of generics, as they tell the compiler the functionality
    the type must provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generics in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Impl and traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trait objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those coming from the likes of C++ and C#, generics will be nothing new
    to you. It is typically represented as `T`. It is used in the same way as a standard
    type. As `T` doesn't actually have a type, it's known a **polymorphic parameter**.
  prefs: []
  type: TYPE_NORMAL
- en: There's a simple rule regarding generic types.
  prefs: []
  type: TYPE_NORMAL
- en: The types have to match—if we define `T` as being `f64` and attempt to assign
    a `String` to it, the compiler will fail to build that code.
  prefs: []
  type: TYPE_NORMAL
- en: While `T` is also (probably) the most commonly used letter for a generic type,
    in reality you can have any letter, or even words.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is perfectly acceptable code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Y` and `N` do not need to be the same type either; therefore, `Y` could be
    a `String` and `N` a `bool`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, the following shows how the generic type works. `Option` is provided
    as part of the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Generics also provide another useful facility: they allow for the production
    of generic functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generic functions—the functions that you can throw anything at! A standard
    function may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The example code for this section can be found in `09/multiply_generic_return_t`.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter being passed in is an `i32` and is called `x`. If we attempt to
    pass in a float, bool, string, or any other type that is not an `i32`, the compiler
    will fail the build as the types don't match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic function looks very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In style, this is very similar to how a generic method is written in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be extended to take multiple parameters with the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with multiple types and parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use a generic as a return type. Recall that a standard function
    returns a value like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic return would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will only work for simplesome types; you cannot multiply string types,
    though you can concatenate them—this means you add one string to another. The
    problem though is we cannot do this... yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we attempt to build this, an error is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's see if we can break this down a bit to see why we're getting the error.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that both `a` and `b` are of type `T`, but what is the *real* type of
    `a`?
  prefs: []
  type: TYPE_NORMAL
- en: Here, `a` needs to be any type that implements `std::ops::Mul`—that is, the
    `*` operator. Moreover, the output of this function needs to be explicitly filled
    in also.
  prefs: []
  type: TYPE_NORMAL
- en: When you see something akin to `std::ops::Mul`, it is just saying we're going
    to use the equivalent of `namespace std.ops` (if we are using C#). It's just the
    library in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s alter the type to tell the compiler that `T` needs to implement `Mul`
    and that we are going yield a result of type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'All `<T: Mul<Output = T>>` means is that we''re going to use `Mul` and that
    the output is going to be of type `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we can build and the code works fine, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Pretty handy! By the way, there''s another way to declare this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Whichever is neater is up to the programmer, so you may see and use both styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is: What happens if we do something like send in a string? Thankfully,
    in this form, the compiler throws an error and won''t allow the code to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A generic problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An aspect of generics is the determination of what `T` is and therefore how
    we can handle it. In C#, we can use `System.Reflection` and use the `GetType`
    method to find the type or use `typeof` when comparing types.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this part can be found in `09/generic_typeof`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, we use `std::any:Any`. This is a type to emulate dynamic typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just by looking at this output, you may be thinking: *What on earth are those
    numbers? I expected something like f32*.'
  prefs: []
  type: TYPE_NORMAL
- en: The associated code for this part can be found in `09/generic_typeof_print`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re seeing here is the *ID* for the type rather than the type. To actually
    show the variable type, we have do something slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, this code will only build on the nightly branch. Chances
    are that by the time you read this book, it will be in the stable branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the preceding code is run on the Rust Playground website, the following
    results are obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While most of the code we have seen many times, we have not yet come across
    `unsafe` and the shebang (`#!`) in the code.
  prefs: []
  type: TYPE_NORMAL
- en: The unsafe directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen many times so far the lengths to which the Rust compiler will go
    to ensure the code you have written will not only compile, but is also not going
    to do something stupid (such as exceed the bounds of an array, use the wrong type,
    or plain use a variable that has not been given a value first).
  prefs: []
  type: TYPE_NORMAL
- en: This is known as *safe* code. That's not to say that all safe code is good code—you
    can still end up with memory leaks, integer overflows, or threading deadlocks
    which you don't want, but aren't actually defined as unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, `unsafe` surrounding code means exactly that—you're telling the compiler
    that you know what you're writing is to be ignored by the inbuilt protection.
  prefs: []
  type: TYPE_NORMAL
- en: Using `unsafe` should only be done with care. We will come across `unsafe` later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole #!'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those used to Linux shell scripting, you will have certainly seen `#!`—in
    Rust, the `#` is a declaration with the name in `[]` an attribute. They can be
    written as either `#[attr]` or `#![attr]`.
  prefs: []
  type: TYPE_NORMAL
- en: However, the meaning of `#[attr]` and `#![attr]` is different. `#[attr]` only
    applies directly to what comes after it. The `#!` changes what the attribute is
    applied to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen this back in Chapter 2, *Variables and Variable Types*, when we
    discussed writing tests. We would have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This `do_check` function will only be run when we're running the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Traits and Impl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very powerful feature of Rust that is commonly seen when dealing with generics
    is that it is possible to tell the compiler that a particular type will provide
    certain functionality. This is provided by a special feature known as a `trait`.
  prefs: []
  type: TYPE_NORMAL
- en: However, to appreciate traits, we first have to look at the `impl` keyword (short
    for implement).
  prefs: []
  type: TYPE_NORMAL
- en: Impl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `impl` keyword works in a very similar way to a function. The structure
    of an implementation needs to considered as being closer to a static class (in
    C#) or as a function within a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be more for a non-generic type. For generics, the preceding code
    becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `<T>` is required to tell the compiler that the `impl` is for
    a generic. `reference_name` is the name used to access the `impl` function. It
    can be anything you wish.
  prefs: []
  type: TYPE_NORMAL
- en: An example of `impl` can be found in `09/impl_example`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build and run the `impl_example` code, you will get a result like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The code creates two implementations for two functions that provide a defined
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The `impl_example` is a very simple example. An `impl` can be as complex as
    required.
  prefs: []
  type: TYPE_NORMAL
- en: The impl lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in Chapter 8, *The Rust Application Lifetime*, we can use a lifetime
    with an `impl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`''a` is denoted directly after both the `impl` and `MyFunction`. For the `impl`,
    it''s to say we''re using it, while after `MyFunction`, it''s to say we''re using
    it within `MyFunction`.'
  prefs: []
  type: TYPE_NORMAL
- en: And back to traits we go...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to think of a trait is that it creates a signature to the
    implementation. If you''re used to C (or C++), then you will have seen this in
    code akin to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The compiler accepts this code is correct as there is a signature in the `.h`
    file that says somewhere there is a compiled function that provides the implementation
    of this call. When the compiler comes to link everything together, the code that
    was promised by the signature is found and `myFunction` does whatever it's supposed
    to do and returns the `int`.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, this would be supplied via an `interface`.
  prefs: []
  type: TYPE_NORMAL
- en: With Rust, we have something very similar.
  prefs: []
  type: TYPE_NORMAL
- en: The `trait` supplies the signature, the `impl` supplies the implementation,
    and the code calls the `impl`.
  prefs: []
  type: TYPE_NORMAL
- en: Now this may seem somewhat like overkill. Why would you create a stub when the
    implementation is typically in the same source file? The answer is we can use
    traits in a Rust library known as a **crate**. The trait tells the compiler that
    somewhere the code is implemented and it will be linked at the last stage of the
    build.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at crates in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A simple crate example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will create a trait that will contain the signature for
    two functions: `calc_perimeter` and `calc_area`. To start with, we construct a
    `struct`. In this case, we will have two `struct`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create a trait for each. The general format for a trait looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we would have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We now need to create an implementation for both of these traits. The `impl`,
    though, will not look quite the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before, we had the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we have to give the name of the struct it relates to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If the `impl` defines the trait and the trait is just a stub, why do we need
    to say which struct it is for?
  prefs: []
  type: TYPE_NORMAL
- en: This is a fair question.
  prefs: []
  type: TYPE_NORMAL
- en: Without the trait, an `impl` operates in a similar way to a function. We supply
    the parameters to the `impl` via `&self`. When we have a trait, the `impl` has
    to say what `&self` refers to.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this can be found in `09/non_generic_trait`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `impl` for the first trait will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the function can access `side_one` and `side_two` from the `Perimeter
    struct`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second `impl` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the calls to the implementations. Unlike previous examples, both of
    the structures have to be initialized and then the implementation call given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the code has been compiled, the expected answer is as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Traits and generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we look at the code, we have two structures that effectively do the same
    thing, with the only difference being the types for the parameters aren''t the
    same. We can alter the member names for the structures without an issue to make
    life simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This would become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The calculation cannot be altered as they are totally different, but will need
    the parameter names to be altered. The other aspect to alter will be the name
    for the functions. Let's create a version of the code that only uses part of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have the generic version of the `struct`, we next need to create the
    trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have to use `<T>` as the `trait` has to take a generic.
  prefs: []
  type: TYPE_NORMAL
- en: The construction for the implementation can be achieved in one of two ways.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section can be found in `09/generic_traits_simple`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the impl for specific types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is by far the simplest way of creating the code. We define the types that
    `Shape` can take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Writing the code like this ensures that we cannot pass anything into the implementations
    that don't make any sense (for example, types that cannot have `+` or `*` applied
    to them).
  prefs: []
  type: TYPE_NORMAL
- en: Using where
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're used to programming using generics in C#, this should be familiar
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust contains an implementation of `where`, so we are able to define what `where`
    is. This means that, as we had in an earlier example for this chapter, the construct
    `<T: Mul<Output = T>>` can be used in a modified way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This does, though, give rise to a number of other issues. Two simple ones are
    that we multiply by `2`—however, that value isn't clear if it's `2u8` or `2i32`.
    We also try to add values together, but as with multiplying `T` together, there
    is no guarantee you can add by `T`.
  prefs: []
  type: TYPE_NORMAL
- en: Making it work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final step is to add a `main` function. We can use the same function as
    was in the non-generic trait example but with the oval removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When compiled, this gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we have created the second implementation, extending the `main` function
    to include the second calculation should be trivial.
  prefs: []
  type: TYPE_NORMAL
- en: See `09/generic_trait_full` for the code files of this part.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to implement the `f32` calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is compiled, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Something you may have noticed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we compare the two different implementations of the code (generic and non-generic),
    the main difference is that we have reduced the amount of code we need as the
    two structs were the same in all but the name. We have also simplified the code
    so that we have a single call to calc and allow the compiler to decide which one
    we need based on the type passed in.
  prefs: []
  type: TYPE_NORMAL
- en: Generics - a small aside
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code reduction and simplification is always a good thing (well, mostly at least!).
    However, with generics, there is always a trade-off and it's not always apparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This returns a value of type `T` by multiplying two variables (of type `T`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is: You can send a number of types into that function - how will
    the compiler know what to do if it doesn''t know what type `T` is? The only safe
    way is to create a version of `my_multiply` for each possible type. Fortunately,
    the compiler does this automatically for you in a process called monomorphization.'
  prefs: []
  type: TYPE_NORMAL
- en: So what does happen?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To give all of these generated functions unique names, compilers that work with
    generics use a process called **name mangling** (or *name munging*). This creates
    a unique name for each internally created function that takes generic parameters.
  prefs: []
  type: TYPE_NORMAL
- en: For which one to use, during linking, the linker analyzes the code *signatures* required.
    If the linker sees a signature requiring `f32` for `T`, that munged name object
    code is included in the final object list. Once the linker has finished with the
    analysis, the unused objects (those not on the final list) are stripped out. The
    final binary therefore only contains the required code and not every variation
    of the types possible.
  prefs: []
  type: TYPE_NORMAL
- en: While different compilers treat generics differently, the process for compilation,
    name munging, and then final stripping is common among them all!
  prefs: []
  type: TYPE_NORMAL
- en: Back to the where version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `where` version of the code is more complex than the non-where version.
  prefs: []
  type: TYPE_NORMAL
- en: The source for this version can be found in `09/generic_trait_where`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We have seen `std::ops::Mul` before in the generic multiplication example. If
    we need to include multiple items from `std::ops` (or indeed any library), they
    are held in curly braces; `{}`. Here, we include `Add` and `Mul`.
  prefs: []
  type: TYPE_NORMAL
- en: Up until this point, we have not seen the `extern crate` directive. For now,
    it is enough to know that this will include an external library. Crates are covered
    in Chapter 9, *Generics and Traits*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `FromPrimitive` from the `num` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `struct` and `trait` are the same as before. The implementation, though,
    is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important lines in this code: `where T:Copy + FromPrimitive +
    Add<Output = T> + Mul<Output = T>` and `let two = T::from_u8(2).expect("Unable
    to create a value of 2");`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are saying that we want to copy the type, we'll be using `FromPrimitive`
    to cast a primitive to `T`, and both the `Add` and `Mul` outputs will be of type
    `T`. Rust concatenates the parameters that a `where` uses using `+`.
  prefs: []
  type: TYPE_NORMAL
- en: The `let two` line creates a variable that takes an unsigned 8-bit value and
    casts that to `T`. If it fails, the error is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: We have to use `Add<Output = T>` to ensure we can add the types together.
  prefs: []
  type: TYPE_NORMAL
- en: Try to compile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you use the standard `cargo run`, you will be met with an error that the
    compiler is `unable to find extern crate num`. This is down to cargo not knowing
    where the dependencies are held. At the first time of grabbing an external reference,
    Rust will update the list of available crates (the registry) and then download
    the ones required. To do this, the `Cargo.toml` file needs to be edited and the
    following code inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this has been saved and the `cargo run` executed, you will see output
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Trait bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A trait can also have a bound placed upon it. In effect, a bound is a rule that
    the trait has to abide by and is added to the declaring type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The source for this part is in `09/trait_bound_gen_struct`.
  prefs: []
  type: TYPE_NORMAL
- en: In the code example, the `impl` has a `PartialEq` bound placed upon the generic
    type. Our `struct` contains four parameters within it and so we only want to test
    for partial equality within that `struct`. If we didn't have the `PartialEq` on
    the declared type parameter, the compilation would fail as we're not testing everything
    within that `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the code is compiled, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Can we reduce the amount of code further?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yes. It is possible to completely omit the requirement to create an implementation
    of a trait if that trait contains a default method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`test_code` is just the stub which requires an implementation. The `self_test_code`
    function doesn''t need an implementation as it has a default method already.'
  prefs: []
  type: TYPE_NORMAL
- en: Can the default method be overridden?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section is in `09/override_default_method`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the code off by defining a `trait`. This has a default method
    for `is_not_done`. We will still need to implement `is_done` though, which we
    do for the `UseFirstTime` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We next want to override the default method for `is_not_done`. Again, we create
    an empty `struct` and write both the implementations for `is_done` and `is_not_done`.
    When we call `is_not_done` from the second `struct`, the `println!` from the second
    `struct` is shown and not the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When compiled, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Rounding off traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This has been a large topic, but we have two more aspects to consider for traits:
    inheritance and deriving. One that should be familiar if you''re used to any form
    of object-oriented programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is very similar to inheritance within C++ and C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Code for this part is in `09/inheritance`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that implements `OneTwo` must also implement `One` (the same as when
    we overrode the default method, we still had to define `is_done`), therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we omitted the `impl One` block, we would get a compilation error complaining
    that `impl OneTwo` requires `impl One` to exist.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust provides a handy attribute that allows you to access a number of commonly
    used traits without having to implement them yourself time and again. They are
    called using `#[derive(Trait_Name)]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traits available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Clone`: This creates a clone of the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Copy`: This creates a copy of the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Debug`: This provides debugging code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Default`: This gives a useful default value for a type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Eq`: `Equality`, this is similar to `PartialEq` except for all parameters
    within a struct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hash`: This is a hashable type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ord`: `Order`, these are the types that form a total order on all types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PartialEq`: `Partial Equality`, this only tests on a subset of the struct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PartialOrd`: `Partial Order`, values that can compared to create a sort order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trait objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, when we call a function in Rust, we will have a line in the code
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have a `struct` in the code which has an `impl` attached to it, we
    will have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: These are both fine.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, back in the `generic_trait_full` example, we had `Calc` defined
    and `T` could be either an `f32` or `i32`. We also talked about how the application
    knew what to include in the final binary. This is known as **static dispatch**
    (which Rust prefers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust uses a system called a **dispatch**, of which there are two types: static
    (favored by Rust) and dynamic. Dynamic dispatch relies on something called a **trait
    object**.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a sample test setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test code is very simple. We have a trait with a function that returns
    a `String`. We then have a couple of implementations and a parameter bound function
    that will display the result from the implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The code for this part can be found in `09/trait_object_static`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When compiled and executed, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the previous explanation, we know that the compiler will generate the various
    types that `T` can be.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see dynamic dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic dispatch uses trait objects. A trait object can store a value of any
    type that implements the `trait`. The actual type of the value is only known at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section can be found in `09/dynamic_dispatch`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some code to explain how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we had for `display_code` the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We no longer have the `T` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the static version, `display_code` was called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For the dynamic version, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The trait object has been obtained from the pointer (`&DynamicObject`) which
    implemented the trait by using the cast (`&test_one as &DynamicObject`). It is
    also acceptable to use `display_code(&test_one)`. This is known as coercion: `&test_one`
    has been used as an argument to a function that takes `&DynamicObject`.'
  prefs: []
  type: TYPE_NORMAL
- en: The only issue with dynamic dispatch is that it can be slower, as each time
    the code is run, the runtime *forgets* the type of the pointer and has to create
    a new implementation for the different type.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your object safe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can''t use all traits to create a trait object. Take the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will not compile as `Clone` is not object-safe as `Clone` contains `Self:
    Sized`, which a trait cannot have.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the trait doesn''t require `Self: Sized` and all of the methods are object-safe,
    it is an object-safe trait. For a method to be object-safe, it must require `Self:
    Sized`. If the method doesn''t require `Self: Sized`, it can still be object-safe
    if the method doesn''t require any parameters and doesn''t use `Self`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traits and generics are a key feature for development and Rust is feature-rich
    for these. We have seen how to create implementations, how to use generics, how
    to ensure that the types can be bound, and the power of traits. Hopefully, you
    should be appreciating now the sheer power that generics provide to the developer
    in terms of flexibility. Generics also allow for reducing the amount of code we
    (as developers) have to write by essentially removing the need to worry too much
    about what the generic represents.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at extending our Rust applications by
    the use of external libraries, known as crates.
  prefs: []
  type: TYPE_NORMAL
