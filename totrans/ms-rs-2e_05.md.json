["```rs\n// stack_basics.rs\n\nfn double_of(b: i32) -> i32 {\n    let x = 2 * b;\n    x\n}\n\nfn main() {\n    let a = 12;\n    let result = double_of(a);\n}\n```", "```rs\nlet s = String::new(\"foo\");\n```", "```rs\n// uninitialized_reads.c\n\n#include <stdio.h>\nint main() { \n    int values[5]; \n    for (int i = 0; i < 5; i++) \n        printf(\"%d \", values[i]); \n}\n```", "```rs\n4195840 0 4195488 0 609963056\n```", "```rs\n// iterator_invalidation.cpp\n\n#include <iostream>\n#include <vector>\n\nint main() {   \n    std::vector <int> v{1, 5, 10, 15, 20}; \n    for (auto it=v.begin();it!=v.end();it++) \n        if ((*it) == 5) \n            v.push_back(-1); \n\n    for (auto it=v.begin();it!=v.end();it++) \n        std::cout << (*it) << \" \"; \n\n    return 0;     \n}\n```", "```rs\n// buffer_overflow.c\n\nint main() { \n     char buf[3]; \n     buf[0] = 'a'; \n     buf[1] = 'b'; \n     buf[2] = 'c'; \n     buf[3] = 'd'; \n}\n```", "```rs\n// ownership_basics.rs\n\n#[derive(Debug)]\nstruct Foo(u32);\n\nfn main() {\n    let foo = Foo(2048);\n    let bar = foo;\n    println!(\"Foo is {:?}\", foo);\n    println!(\"Bar is {:?}\", bar);\n}\n```", "```rs\n// scopes.rs\n\nfn main() { \n    let level_0_str = String::from(\"foo\"); \n    {  \n        let level_1_number = 9; \n        { \n            let mut level_2_vector = vec![1, 2, 3];\n            level_2_vector.push(level_1_number);    // can access\n        } // level_2_vector goes out of scope here \n\n        level_2_vector.push(4);    // no longer exists\n    } // level_1_number goes out of scope here\n} // level_0_str goes out of scope here\n```", "```rs\n// ownership_primitives.rs\n\nfn main() {\n    let foo = 4623;\n    let bar = foo;\n    println!(\"{:?} {:?}\", foo, bar); \n}\n```", "```rs\n// making_copy_types.rs\n\n#[derive(Copy, Debug)]\nstruct Dummy;\n\nfn main() {\n    let a = Dummy;\n    let b = a;\n    println!(\"{}\", a);\n    println!(\"{}\", b);\n}\n```", "```rs\npub trait Copy: Clone { }\n```", "```rs\n// making_copy_types_fixed.rs\n\n#[derive(Copy, Clone, Debug)]\nstruct Dummy;\n\nfn main() {\n    let a = Dummy;\n    let b = a;\n    println!(\"{}\", a);\n    println!(\"{}\", b);\n}\n```", "```rs\npub trait Clone {\n    fn clone(&self) -> Self;\n}\n```", "```rs\n// explicit_copy.rs\n\n#[derive(Clone, Debug)]\nstruct Dummy {\n    items: u32\n}\n\nfn main() {\n    let a = Dummy { items: 54 };\n    let b = a.clone();\n    println!(\"a: {:?}, b: {:?}\", a, b);\n}\n```", "```rs\n// ownership_functions.rs\n\nfn take_the_n(n: u8) { }\n\nfn take_the_s(s: String) { }\n\nfn main() { \n    let n = 5; \n    let s = String::from(\"string\"); \n\n    take_the_n(n); \n    take_the_s(s); \n\n    println!(\"n is {}\", n); \n    println!(\"s is {}\", s); \n} \n```", "```rs\ntake_the_s(s.clone());\n```", "```rs\n// ownership_functions_back.rs\n\nfn take_the_n(n: u8) { }\n\nfn take_the_s(s: String) -> String {\n    println!(\"inside function {}\", s);\n    s\n}\n\nfn main() { \n    let n = 5; \n    let s = String::from(\"string\"); \n\n    take_the_n(n); \n    let s = take_the_s(s); \n\n    println!(\"n is {}\", n); \n    println!(\"s is {}\", s); \n} \n```", "```rs\n// ownership_match.rs\n\n#[derive(Debug)]\nenum Food {\n    Cake,\n    Pizza,\n    Salad\n}\n\n#[derive(Debug)]\nstruct Bag {\n    food: Food\n}\n\nfn main() {\n    let bag = Bag { food: Food::Cake };\n    match bag.food {\n        Food::Cake => println!(\"I got cake\"),\n        a => println!(\"I got {:?}\", a)\n    }\n\n    println!(\"{:?}\", bag);\n}\n```", "```rs\n// ownership_methods.rs\n\nstruct Item(u32);\n\nimpl Item {\n    fn new() -> Self {\n        Item(1024)\n    }\n\n    fn take_item(self) {\n        // does nothing\n    } \n}\n\nfn main() {\n    let it = Item::new();\n    it.take_item();\n    println!(\"{}\", it.0);\n}\n```", "```rs\n// ownership_closures.rs\n\n#[derive(Debug)]\nstruct Foo;\n\nfn main() {\n    let a = Foo;\n\n    let closure = || {\n        let b = a;    \n    };\n\n    println!(\"{:?}\", a);\n}\n```", "```rs\n    let closure = move || {\n        let b = a;    \n    };\n```", "```rs\n// borrowing_basics.rs\n\n#[derive(Debug)]\nstruct Foo(u32);\n\nfn main() {\n    let foo = Foo;\n    let bar = &foo;\n    println!(\"Foo is {:?}\", foo);\n    println!(\"Bar is {:?}\", bar);\n}\n```", "```rs\n    let bar = &foo;\n```", "```rs\n// mutable_borrow.rs\n\nfn main() {\n    let a = String::from(\"Owned string\");\n    let a_ref = &mut a;\n    a_ref.push('!');\n}\n```", "```rs\nlet mut a = String::from(\"Owned string\");\n```", "```rs\n// exclusive_borrow.rs\n\nfn main() {\n    let mut a = String::from(\"Owned string\");\n    let a_ref = &mut a;\n    a_ref.push('!');\n    println!(\"{}\", a);\n}\n```", "```rs\n// borrowing_functions.rs\n\nfn take_the_n(n: &mut u8) {\n    *n += 2;\n}\n\nfn take_the_s(s: &mut String) {\n    s.push_str(\"ing\");\n}\n\nfn main() {\n    let mut n = 5;\n    let mut s = String::from(\"Borrow\");\n\n    take_the_n(&mut n);\n    take_the_s(&mut s);\n\n    println!(\"n changed to {}\", n);\n    println!(\"s changed to {}\", s);\n}\n```", "```rs\nlet mut s = String::from(\"Borrow\"); \n```", "```rs\nfn take_the_s(n: &mut String) { \n    s.push_str(\"ing\"); \n} \n```", "```rs\n    take_the_s(&mut s); \n```", "```rs\n// borrowing_match.rs\n\n#[derive(Debug)]\nenum Food {\n    Cake,\n    Pizza,\n    Salad\n}\n\n#[derive(Debug)]\nstruct Bag {\n    food: Food\n}\n\nfn main() {\n    let bag = Bag { food: Food::Cake };\n    match bag.food {\n        Food::Cake => println!(\"I got cake\"),\n        ref a => println!(\"I got {:?}\", a)\n    }\n\n    println!(\"{:?}\", bag);\n}\n```", "```rs\n// return_func_ref.rs\n\nfn get_a_borrowed_value() -> &u8 { \n    let x = 1; \n    &x \n}\n\nfn main() {\n    let value = get_a_borrowed_value(); \n}\n```", "```rs\n// lifetime_basics.rs\n\nstruct SomeRef<T> {\n    part: &T\n}\n\nfn main() {\n    let a = SomeRef { part: &43 };\n}\n```", "```rs\n// using_lifetimes.rs\n\nstruct SomeRef<'a, T> {\n    part: &'a T\n}\n\nfn main() {\n    let _a = SomeRef { part: &43 };\n}\n```", "```rs\n// static_lifetime.rs\n\nfn main() {\n    let _a: &'static str = \"I live forever\";\n}\n```", "```rs\nfn func_one(x: &u8) → &u8 { .. }\n\nfn func_two<'a>(x: &'a u8) → &'a u8 { .. }\n```", "```rs\n// explicit_lifetimes.rs\n\nfn foo(a: &str, b: &str) -> &str {\n    b\n}\n\nfn main() {\n    let a = \"Hello\";\n    let b = \"World\";\n    let c = foo(a, b);\n}\n```", "```rs\n//  lifetime_struct.rs\n\nstruct Number<'a> { \n    num: &'a u8 \n}\n\nfn main() {\n    let _n = Number {num: &545}; \n}\n```", "```rs\n// lifetime_impls.rs\n\n#[derive(Debug)]\nstruct Number<'a> { \n    num: &'a u8 \n}\n\nimpl<'a> Number<'a> { \n    fn get_num(&self) -> &'a u8 { \n        self.num \n    }  \n    fn set_num(&mut self, new_number: &'a u8) { \n        self.num = new_number \n    }\n}\n\nfn main() {\n    let a = 10;\n    let mut num = Number { num: &a };\n    num.set_num(&23);\n    println!(\"{:?}\", num.get_num());\n}\n```", "```rs\n// multiple_lifetimes.rs\n\nstruct Decoder<'a, 'b, S, R> {\n    schema: &'a S,\n    reader: &'b R\n}\n\nfn main() {}\n```", "```rs\n// lifetime_subtyping.rs\n\nstruct Decoder<'a, 'b, S, R> {\n    schema: &'a S,\n    reader: &'b R\n}\n\nimpl<'a, 'b, S, R> Decoder<'a, 'b, S, R>\nwhere 'a: 'b {\n\n}\n\nfn main() {\n    let a: Vec<u8> = vec![];\n    let b: Vec<u8> = vec![];\n    let decoder = Decoder {schema: &a, reader: &b};\n}\n```", "```rs\n// lifetime_bounds.rs\n\nenum Level {\n    Error\n}\n\nstruct Logger<'a>(&'a str, Level);\n\nfn configure_logger<T>(_t: T) where T: Send + 'static {\n    // configure the logger here\n}\n\nfn main() {\n    let name = \"Global\";\n    let log1 = Logger(name, Level::Error);\n    configure_logger(log1);\n}\n```", "```rs\n// lifetime_bounds_short.rs\n\nenum Level {\n    Error\n}\n\nstruct Logger<'a>(&'a str, Level);\n\nfn configure_logger<T>(_t: T) where T: Send + 'static {\n    // configure the logger here\n}\n\nfn main() {\n    let other = String::from(\"Local\");\n    let log2 = Logger(&other, Level::Error);\n    configure_logger(&log2);\n}\n```", "```rs\nlet a = &56;\nlet a_raw_ptr = a as *const u32;\n// or\nlet b = &mut 5634.3;\nlet b_mut_ptr = b as *mut T;\n```", "```rs\n// drop.rs\n\nstruct Character {\n    name: String,\n}\n\nimpl Drop for Character {\n    fn drop(&mut self) {\n        println!(\"{} went away\", self.name)\n    }\n}\n\nfn main() {\n    let steve = Character {\n        name: \"Steve\".into(),\n    };\n    let john = Character {\n        name: \"John\".into(),\n    };\n}\n```", "```rs\npub trait Deref {\n    type Target: ?Sized;\n    fn deref(&self) -> &Self::Target;\n}\n```", "```rs\n// box_basics.rs\n\nfn box_ref<T>(b: T) -> Box<T> {\n    let a = b;\n    Box::new(a)\n}\n\nstruct Foo;\n\nfn main() {\n    let boxed_one = Box::new(Foo);\n    let unboxed_one = *boxed_one;\n    box_ref(unboxed_one);\n}\n```", "```rs\n// recursive_type.rs\n\nstruct Node {\n    data: u32,\n    next: Option<Node>\n}\n\nfn main() {\n    let a = Node { data: 33, next: None };\n}\n```", "```rs\nstruct Node {\n    data: u32,\n    next: Some(Node {\n              data: u32,\n              next: Node {\n                        data: u32,\n                        next: ...\n                    }\n          })\n}\n```", "```rs\nstruct Node {\n    data: u32,\n    next: Option<Box<Node>>\n}\n```", "```rs\n// linked_list.rs\n\nuse std::rc::Rc; \n\n#[derive(Debug)] \nstruct LinkedList<T> { \n    head: Option<Rc<Node<T>>> \n} \n\n#[derive(Debug)] \nstruct Node<T> { \n    next: Option<Rc<Node<T>>>, \n    data: T \n} \n\nimpl<T> LinkedList<T> { \n    fn new() -> Self { \n        LinkedList { head: None } \n    } \n\n    fn append(&self, data: T) -> Self { \n        LinkedList { \n            head: Some(Rc::new(Node { \n                data: data, \n                next: self.head.clone() \n            })) \n        } \n    } \n} \n\nfn main() { \n    let list_of_nums = LinkedList::new().append(1).append(2); \n    println!(\"nums: {:?}\", list_of_nums); \n\n    let list_of_strs = LinkedList::new().append(\"foo\").append(\"bar\"); \n    println!(\"strs: {:?}\", list_of_strs); \n}\n```", "```rs\nnums: LinkedList { head: Some(Node { next: Some(Node { next: None, data: 1 }), data: 2 }) }\nstrs: LinkedList { head: Some(Node { next: Some(Node { next: None, data: \"foo\" }), data: \"bar\" }) }\n```", "```rs\n// rc_weak.rs\n\nuse std::rc::Rc; \nuse std::rc::Weak; \n\n#[derive(Debug)] \nstruct LinkedList<T> { \n    head: Option<Rc<LinkedListNode<T>>> \n} \n\n#[derive(Debug)] \nstruct LinkedListNode<T> { \n    next: Option<Rc<LinkedListNode<T>>>, \n    prev: Option<Weak<LinkedListNode<T>>>, \n    data: T \n} \n\nimpl<T> LinkedList<T> { \n    fn new() -> Self { \n        LinkedList { head: None } \n    } \n\n    fn append(&mut self, data: T) -> Self { \n        let new_node = Rc::new(LinkedListNode { \n            data: data, \n            next: self.head.clone(), \n            prev: None \n        }); \n\n        match self.head.clone() { \n            Some(node) => { \n                node.prev = Some(Rc::downgrade(&new_node)); \n            }, \n            None => { \n            } \n        } \n\n        LinkedList { \n            head: Some(new_node) \n        } \n    } \n} \n\nfn main() { \n    let list_of_nums = LinkedList::new().append(1).append(2).append(3); \n    println!(\"nums: {:?}\", list_of_nums); \n}\n```", "```rs\n        use std::cell::RefCell; \n```", "```rs\n        // rc_3.rs\n        #[derive(Debug)] \n        struct LinkedListNode<T> { \n            next: Option<Rc<LinkedListNode<T>>>, \n            prev: RefCell<Option<Weak<LinkedListNode<T>>>>, \n            data: T \n        }\n```", "```rs\n    // rc_3.rs\n\n    fn append(&mut self, data: T) -> Self { \n        let new_node = Rc::new(LinkedListNode { \n            data: data, \n            next: self.head.Clone(), \n            prev: RefCell::new(None) \n        }); \n\n        match self.head.Clone() { \n            Some(node) => { \n                let mut prev = node.prev.borrow_mut(); \n                *prev = Some(Rc::downgrade(&new_node)); \n            }, \n            None => { \n            } \n        } \n\n        LinkedList { \n            head: Some(new_node) \n        } \n    } \n} \n```", "```rs\n// without_cell.rs\n\nuse std::cell::Cell; \n\n#[derive(Debug)]\nstruct Bag { \n    item: Box<u32>\n} \n\nfn main() { \n    let mut bag = Cell::new(Bag { item: Box::new(1) }); \n    let hand1 = &mut bag;\n    let hand2 = &mut bag;\n    *hand1 = Cell::new(Bag {item: Box::new(2)});\n    *hand2 = Cell::new(Bag {item: Box::new(2)});\n}\n```", "```rs\n// cell.rs\n\nuse std::cell::Cell; \n\n#[derive(Debug)]\nstruct Bag { \n    item: Box<u32>\n} \n\nfn main() { \n    let bag = Cell::new(Bag { item: Box::new(1) }); \n    let hand1 = &bag;\n    let hand2 = &bag;\n    hand1.set(Bag { item: Box::new(2)}); \n    hand2.set(Bag { item: Box::new(3)});\n}\n```", "```rs\n// refcell_basics.rs\n\nuse std::cell::RefCell; \n\n#[derive(Debug)]\nstruct Bag { \n    item: Box<u32>\n} \n\nfn main() { \n    let bag = RefCell::new(Bag { item: Box::new(1) }); \n    let hand1 = &bag;\n    let hand2 = &bag;\n    *hand1.borrow_mut() = Bag { item: Box::new(2)}; \n    *hand2.borrow_mut() = Bag { item: Box::new(3)};\n    let borrowed = hand1.borrow();\n    println!(\"{:?}\", borrowed);\n}\n```", "```rs\nprintln!(\"{:?} {:?}\", hand1.borrow(), hand1.borrow_mut());\n```", "```rs\nthread 'main' panicked at 'already borrowed: BorrowMutError', src/libcore/result.rs:1009:5\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n```", "```rs\n// cell_cache.rs\n\nuse std::cell::Cell; \n\nstruct Point { \n    x: u8, \n    y: u8, \n    cached_sum: Cell<Option<u8>> \n} \n\nimpl Point { \n    fn sum(&self) -> u8 { \n        match self.cached_sum.get() { \n            Some(sum) => { \n                println!(\"Got from cache: {}\", sum); \n                sum \n            }, \n            None => { \n                let new_sum = self.x + self.y; \n                self.cached_sum.set(Some(new_sum)); \n                println!(\"Set cache: {}\", new_sum); \n                new_sum \n            } \n        } \n    } \n} \n\nfn main() { \n    let p = Point { x: 8, y: 9, cached_sum: Cell::new(None) }; \n    println!(\"Summed result: {}\", p.sum()); \n    println!(\"Summed result: {}\", p.sum()); \n}\n\n```"]