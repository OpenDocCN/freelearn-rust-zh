["```rs\nnumber_of_rooms: i32 \n```", "```rs\nis_upstairs: bool \nnumber_of_doors: i32 \nnumber_of_windows: i32 \nwindow_type: String \nhas_curtains: bool // true = yes \nwood_or_carpet: bool // true = carpet \ncarpet_color: String \nroom_name: String \nhas_wardrobe: bool // true = yes \nroom_width: f32 \nroom_height: f32 \n```", "```rs\nstruct MyStruct \n{ \n    foo: i32, \n    bar: f32, \n} \n```", "```rs\nstruct Room \n{  \n    is_upstairs: bool, \n    number_of_doors: i32, \n    number_of_windows: i32, \n    window_type: String, \n    has_curtains: bool, \n    wood_or_carpet: bool, \n    carpet_color: String, \n    room_name: String, \n    has_wardrobe: bool, \n    room_width: f32, \n    room_height: f32, \n} \n```", "```rs\nstruct House \n{ \n    room:... um... \n} \n```", "```rs\nstruct House \n{ \n     room: Room, \n} \n```", "```rs\nstruct House \n{ \n     rooms: Vec<Room> \n} \n```", "```rs\nstruct Area \n{ \n    width: f32, \n    length: f32, \n} \n\nstruct Window \n{ \n    window_area: Area, \n    window_type: String, \n    has_blinds: bool, \n    curtain_color: String, \n    has_lock: bool, \n    top_open: bool, \n    single_window: bool, \n} \n```", "```rs\nstruct Room \n{  \n    is_upstairs: bool, \n    number_of_doors: i32, \n    window: Vec<Window> ,\n    wood_or_carpet: bool, \n    carpet_color: String, \n    room_name: String, \n    has_wardrobe: bool, \n    room_area: Area, \n} \n```", "```rs\nlet mut room = Room { is_upstairs: true, \n number_of_doors: 1, wood_or_carpet: true, carpet_color: \"Red\", \n room_name: \"Bedroom 1\", has_wardrobe: true };\n```", "```rs\nprintln!(\"Bedroom {} has {} door\", room.room_name, \n room.number_of_door);\n```", "```rs\nroom_area: Area {width: 2.3f32, length: 4.3f32} \n```", "```rs\nprintln!(\"The room width is {}m by {}m\", room.room_area.width, room.room_area.length); \n```", "```rs\nwindow: vec![  \n        Window { \n            window_area: Area {width: 1.3f32, length: 1.4f32}, \n            window_type: \"Main\".to_owned(), \n            has_blinds: true, \n            curtain_color: \"Blue\".to_owned(), \n            has_lock: false, \n            top_open: true, \n            single_window: true, \n        }, \n        Window { \n            window_area: Area {width: 0.9f32, length: 1.1f32}, \n            window_type: \"Small\".to_owned(), \n            has_blinds: true, \n            curtain_color: \"Blue\".to_owned(), \n            has_lock: false, \n            top_open: true, \n            single_window: true, \n        } \n```", "```rs\nprintln!(\"The room width is {}m by {}m\", room.room_area.width, room.room_area.length);  \nlet ref window_two = room.window[1]; \nprintln!(\"Window 2 is {}m by {}m and has {} curtains\", window_two.window_area.width, window_two.window_area.length,  window_two.curtain_color); \n```", "```rs\ninclude!(\"structs.rs\"); \n```", "```rs\nmod structs; \nuse structs::*; \n```", "```rs\n// readwrite.rs \npub struct RWData \n{ \n    pub X: i32, \n    Y: i32 \n} \n\nstatic mut rwdata: RWData = RWData {X: 0, Y: 0}; \n\npub fn store_y(val: i32) \n{ \n    unsafe { rwdata.Y = val; }\n} \n\npub fn new_y() -> i32 \n{ \n    unsafe { rwdata.Y * 6 }\n} \n\n// main.rs \nmod readwrite; \nuse readwrite::*; \n\nfn main() { \n\n        store_y(6); \n        println!(\"Y is now {}\", new_y()); \n\n} \n```", "```rs\nstruct someStruct; \nlet x = someStruct; \n```", "```rs\nlet tup = (3, \"foo\"); \nlet tup: (i32, &str) = (3, \"foo\"); \n\n```", "```rs\nlet mut change = (1.1f32, 1); \nlet into = (3.14f32, 6); \nchange = into; \n```", "```rs\nlet mut change = (1.1f32, 1); \nlet into = (1, 3.14f32); \n```", "```rs\nlet test = 1i32; \n```", "```rs\nlet test = (1, 4f32); \n```", "```rs\nlet t = someArray[3]; \n```", "```rs\nlet t = test.1 \n```", "```rs\nlet (one, two, three) = (1, 2, 3); \n```", "```rs\nlet (one, two, three) = (1, 2, 3); \nprintln!(\"One = {}\", one); // outputs One = 1 \n```", "```rs\nstruct Test \n{ \n     drink: bool, \n     number: i32, \n     price: f32 \n} \n```", "```rs\nlet Test: (bool, i32, f32) = (false, 4, 1.55); \n```", "```rs\nstruct TestOne (f32, i8, &str); \nstruct TestTwo (f32, i8, &str); \n```", "```rs\nlet i = TestOne.1; \n```", "```rs\nstruct MyPi(f32);  \nfn main()  \n{ \n    let my_pi = MyPi(22f32 / 7f32); \n    let MyPi(pi) = my_pi;  \n    println!(\"pi = {}\", pi); \n} \n```", "```rs\nenum myEnum {start = 4, next, nextone, lastone=999};  \n```", "```rs\nenum MyEnum \n{ \n     TupleType(f32, i8, &str), \n     StructType { varone: i32, vartwo: f64 }, \n     NewTypeTuple(i32), \n     SomeVarName \n} \n```", "```rs\nenum MyFirstEnum \n{ \n    TupleType(f32, i8, String), \n    StuctType {varone: i32, vartwo: f64}, \n    NewTypeTuple(i32), \n    SomeVarName \n} \n\nenum MySecondEnum \n{ \n    TupleType(f32, i8, String), \n    StuctType {varone: i32, vartwo: f64}, \n    NewTypeTuple(i32), \n} \n\nfn main()  \n{ \n    let mut text1 = \"\".to_owned(); // text1: String \n    let mut text2 = \"\".to_owned(); // text2: String \n    let mut num1 = 0f32; \n\n    let value = MyFirstEnum::TupleType(3.14, 1, \"Hello\".to_owned()); \n    let value2 = MySecondEnum::TupleType(6.28, 0, \"World\".to_owned()); \n\n    if let MyFirstEnum::TupleType(f,i,s)  = value \n    { \n        text1 = s; \n        num1 = f; \n    } \n\n    if let MySecondEnum::TupleType(f,i,s) = value2 \n    { \n        text2 = s; \n    } \n\n    println!(\"{} {} from the {} man\", text1, text2, num1) \n} \n```", "```rs\nlet value = MyFirstEnum::TupleType(3.14, 1, \"Hello\".to_owned()); \n```", "```rs\nfn my_test(x: i32) -> String \n{ \n    if x == 1 \n    {   \n        return \"one\".to_owned(); \n    } \n    else if x == 2 \n    { \n        return \"two\".to_owned(); \n    } \n    else if x == 3 \n    { \n        return \"three\".to_owned(); \n    } \n    return \"not found\".to_owned(); \n} \n```", "```rs\nfn my_test(x: i32) -> String \n{ \n    let mut t = \"\".to_owned(); \n    match x \n    { \n        1 => t = \"one\".to_owned(), \n        2 => t = \"two\".to_owned(), \n        3 => t = \"three\".to_owned(), \n        _ => t = \"not found\".to_owned() \n    } \n    return t; \n} \n```", "```rs\nvar t = SomeCondition == 3 ? \"three\" : (SomeCondition == 4 ? \n \"four\" : \"not three or four\");\n```", "```rs\nlet mut t = \"\".to_string(); \nmatch x \n{ \n```", "```rs\nlet t = match x \n{ \n    ... \n}; \nreturn t; \n```", "```rs\nreturn match x \n{ \n    ... \n}; \n\n```", "```rs\nfn my_test(x: i32) -> String { \n    match x { \n        1 => \"one\".to_owned(), \n        2 => \"two\".to_owned(), \n        3 => \"three\".to_owned(), \n        _ => \"not found\".to_owned() \n    } \n}\n```", "```rs\nenum MyFirstEnum \n{ \n    TupleType(f32, i8, String), \n    StructType {varone: i32, vartwo: f64}, \n    NewTypeTuple(i32), \n    SomeVarName \n} \nfn tuple_type(v: f32, c: i8, st: String) {//code} \nfn struct_type(v1: i32, v2: f64) {//code} \nfn new_type_tuple(n: i32) {//code} \nfn process_varname() {//code}  \n\nfn match_enum_code(e: MyFirstEnum) \n{ \nmatch e { \n   MyFirstEnum::SomeVarName => process_varname(), \n   MyFirstEnum::TupleType(f,i,s) => tuple_type(f,i,s), \n   MyFirstEnum::StructType(v1,v2) => struct_type(v1,v2), \n   MyFirstEnum::NewTypeTuple(i) => new_type_tuple(i) \n}; \n} \n```", "```rs\nfn match_enum_code(e:MyFirstEnum) \n{ \nmatch e { \n   MyFirstEnum::SomeVarName => process_varname(), \n   MyFirstEnum::TupleType(f,i,s) => tuple_type(f,i,s), \n   MyFirstEnum::StructType(v1,v2) => struct_type(v1,v2), \n   _ => return  // breaks out of the match \n}; \n} \n```", "```rs\nstruct Test  \n{ \n    answer: i32, \n    real_answer: i32, \n    score: i32,\n} \n```", "```rs\nfn match_test(t: Test) \n{ \n    match t \n    { \n        Test {answer: Question::MyAnswer, real_answer: \n         Question::RealAnswer, ..} => {...} \n    } \n} \n```", "```rs\nfn match_test(t:Test) \n{ \n    match t \n    { \n        Test {answer: Question::MyAmswer, real_answer: \n         Question::RealAnswer, score:_} => {...} \n    } \n} \n```", "```rs\nswitch(foo) \n{ \n    case 1: \n    case 2: printf(\"1 and 2\\n\"); \n            break; \n    case 3: printf(\"3\\n\"); \n            break; \n} \n```", "```rs\nmatch foo  \n{ \n    1 | 2 => println!(\"1 and 2\"), \n    3 => println!(\"3\"), \n    _ => println!(\"anything else\") \n} \n```", "```rs\nmatch foo \n{ \n    1 ... 10 => println!(\"Value between 1 and 10\"), \n    _ => println!(\"Value not between 1 and 10\") \n} \n```", "```rs\nmatch char_foo \n{ \n    'A' ... 'M' => println!(\"A - M\"), \n    'N' ... 'Y' => println!(\"N - Y\"), \n    'Z' => println!(\"Z\"), \n    _ => println!(\"something else\") \n} \n```", "```rs\nmatch test \n{ \n    e @ 1 ... 10 => println!(\"the value is {}\", e), \n    _ => println!(\"nothing doing\") \n} \n```", "```rs\nmatch test \n{ \n    t @ 1 ... 5 | t @ 10 ... 15 => println!(\"our value for t = {}\", t), \n    _ => println!(\"dunno!\") \n} \n```", "```rs\n\nfn testcode(t: u8) \n{ \n    match t \n    { \n        1 | 2 if t != 1 => println!(\"t was not one\"), \n        1 | 2 if t != 2 => println!(\"t was not two\"), \n        _ => println!(\"\") \n    } \n} \n```", "```rs\nstruct MyStruct \n{ \n    a: i32, \n    b: i32 \n} \n\nfn derp(){ \n    let mystruct=MyStruct{a:1, b:2}; \n    match mystruct { \n        MyStruct{a, b} => println!(\"matched the structure\"), \n        _ => println!(\"didn't match the structure\") \n    } \n} \n```", "```rs\nmatch testmatch \n{ \n    1 => println!(\"1\"), \n    _ => println!(\"not 1\") \n} \n```", "```rs\nif let 1 = testmatch { \n    println!(\"1\"); \n} \n else \n { \n    println!(\"not 1\"); \n} \n```"]