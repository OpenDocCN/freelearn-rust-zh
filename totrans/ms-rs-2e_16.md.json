["```rs\nsudo apt-get install libgtk-3-dev\n```", "```rs\n# hews/Cargo.toml\n\n[dependencies]\ngtk = { version = \"0.3.0\", features = [\"v3_18\"] }\nreqwest = \"0.9.5\"\nserde_json = \"1.0.33\"\nserde_derive = \"1.0.82\"\nserde = \"1.0.82\"\n```", "```rs\n// hews/src/main.rs\n\nmod app;\nmod hackernews;\nuse app::App;\n\nfn main() {\n    let (app, rx) = App::new();\n    app.launch(rx);\n}\n```", "```rs\n// hews/src/app.rs\n\npub struct App {\n    window: Window,\n    header: Header,\n    stories: gtk::Box,\n    spinner: Spinner,\n    tx: Sender<Msg>,\n}\n```", "```rs\npub enum Msg {\n            NewStory(Story),\n            Loading,\n            Loaded,\n            Refresh,\n        }\n```", "```rs\nimpl App {\n    pub fn new() -> (App, Receiver<Msg>) {\n        if gtk::init().is_err() {\n            println!(\"Failed to init hews window\");\n            process::exit(1);\n        }\n```", "```rs\n        let (tx, rx) = channel();\n        let window = gtk::Window::new(gtk::WindowType::Toplevel);\n        let sw = ScrolledWindow::new(None, None);\n        let stories = gtk::Box::new(gtk::Orientation::Vertical, 20);\n        let spinner = gtk::Spinner::new();\n        let header = Header::new(stories.clone(), tx.clone());\n```", "```rs\n        stories.pack_start(&spinner, false, false, 2);\n        sw.add(&stories);\n        window.add(&sw);\n        window.set_default_size(600, 350);\n        window.set_titlebar(&header.header);\n```", "```rs\n        window.connect_delete_event(move |_, _| {\n            main_quit();\n            Inhibit(false)\n        });\n```", "```rs\n    pub fn launch(&self, rx: Receiver<Msg>) {\n        self.window.show_all();\n        let client = Arc::new(reqwest::Client::new());\n        self.fetch_posts(client.clone());\n        self.run_event_loop(rx, client);\n    }\n```", "```rs\n    fn fetch_posts(&self, client: Arc<Client>) {\n        self.spinner.start();\n        self.tx.send(Msg::Loading).unwrap();\n        let tx_clone = self.tx.clone();\n        top_stories(client, 10, &tx_clone);\n    }\n```", "```rs\n    fn run_event_loop(&self, rx: Receiver<Msg>, client: Arc<Client>) {\n        let container = self.stories.clone();\n        let spinner = self.spinner.clone();\n        let header = self.header.clone();\n        let tx_clone = self.tx.clone();\n\n        gtk::timeout_add(100, move || {\n            match rx.try_recv() {\n                Ok(Msg::NewStory(s)) => App::render_story(s, &container),\n                Ok(Msg::Loading) => header.disable_refresh(),\n                Ok(Msg::Loaded) => {\n                    spinner.stop();\n                    header.enable_refresh();\n                }\n                Ok(Msg::Refresh) => {\n                    spinner.start();\n                    spinner.show();\n                    (&tx_clone).send(Msg::Loading).unwrap();\n                    top_stories(client.clone(), 10, &tx_clone);\n                }\n                Err(_) => {}\n            }\n            gtk::Continue(true)\n        });\n\n        gtk::main();\n    }\n```", "```rs\n    fn render_story(s: Story, stories: &gtk::Box) {\n        let title_with_score = format!(\"{} ({})\", s.title, s.score);\n        let label = gtk::Label::new(&*title_with_score);\n        let story_url = s.url.unwrap_or(\"N/A\".to_string());\n        let link_label = gtk::Label::new(&*story_url);\n        let label_markup = format!(\"<a href=\\\"{}\\\">{}</a>\", story_url, story_url);\n        link_label.set_markup(&label_markup);\n        stories.pack_start(&label, false, false, 2);\n        stories.pack_start(&link_label, false, false, 2);\n        stories.show_all();\n    }\n```", "```rs\n// hews/src/app.rs\n\n#[derive(Clone)]\npub struct Header {\n    pub header: HeaderBar,\n    pub refresh_btn: Button\n}\n\nimpl Header {\n    pub fn new(story_container: gtk::Box, tx: Sender<Msg>) -> Header {\n        let header = HeaderBar::new();\n        let refresh_btn = gtk::Button::new_with_label(\"Refresh\");\n        refresh_btn.set_sensitive(false);\n        header.pack_start(&refresh_btn);\n        header.set_title(\"Hews - popular stories from hacker news\");\n        header.set_show_close_button(true);\n\n        refresh_btn.connect_clicked(move |_| {\n            for i in story_container.get_children().iter().skip(1) {\n                story_container.remove(i);\n            }\n            tx.send(Msg::Refresh).unwrap();\n        });\n\n        Header {\n            header,\n            refresh_btn\n        }\n    }\n\n    fn disable_refresh(&self) {\n        self.refresh_btn.set_label(\"Loading\");\n        self.refresh_btn.set_sensitive(false);\n    }\n\n    fn enable_refresh(&self) {\n        self.refresh_btn.set_label(\"Refresh\");\n        self.refresh_btn.set_sensitive(true);\n    }\n}\n```", "```rs\n// hews/src/hackernews.rs\n\nuse crate::app::Msg;\nuse serde_json::Value;\nuse std::sync::mpsc::Sender;\nuse std::thread;\nuse serde_derive::Deserialize;\n\nconst HN_BASE_URL: &str = \"https://hacker-news.firebaseio.com/v0/\";\n\n#[derive(Deserialize, Debug)]\npub struct Story {\n    pub by: String,\n    pub id: u32,\n    pub score: u64,\n    pub time: u64,\n    pub title: String,\n    #[serde(rename = \"type\")]\n    pub _type: String,\n    pub url: Option<String>,\n    pub kids: Option<Value>,\n    pub descendents: Option<u64>,\n}\n```", "```rs\n// hews/src/hackernews.rs\n\nfn fetch_stories_parsed(client: &Client) -> Result<Value, reqwest::Error> {\n    let stories_url = format!(\"{}topstories.json\", HN_BASE_URL);\n    let body = client.get(&stories_url).send()?.text()?;\n    let story_ids: Value = serde_json::from_str(&body).unwrap();\n    Ok(story_ids)\n}\n\npub fn top_stories(client: Arc<Client>, count: usize, tx: &Sender<Msg>) {\n    let tx_clone = tx.clone();\n    thread::spawn(move || {\n        let story_ids = fetch_stories_parsed(&client).unwrap();\n        let filtered: Vec<&Value> = story_ids.as_array()\n                                             .unwrap()\n                                             .iter()\n                                             .take(count)\n                                             .collect();\n\n        let loaded = !filtered.is_empty();\n\n        for id in filtered {\n            let id = id.as_u64().unwrap();\n            let story_url = format!(\"{}item/{}.json\", HN_BASE_URL, id);\n            let story = client.get(&story_url)\n                              .send()\n                              .unwrap()\n                              .text()\n                              .unwrap();\n            let story: Story = serde_json::from_str(&story).unwrap();\n            tx_clone.send(Msg::NewStory(story)).unwrap();\n        }\n\n        if loaded {\n            tx_clone.send(Msg::Loaded).unwrap();\n        }\n    });\n}\n```", "```rs\n        let story_ids = fetch_stories_parsed(&client).unwrap();\n        let filtered: Vec<&Value> = story_ids.as_array()\n                                             .unwrap()\n                                             .iter()\n                                             .take(count)\n                                             .collect();\n```", "```rs\n       let loaded = !filtered.is_empty();\n```", "```rs\n        for id in filtered {\n            let id = id.as_u64().unwrap();\n            let story_url = format!(\"{}item/{}.json\", HN_BASE_URL, id);\n            let story = client.get(&story_url)\n                              .send()\n                              .unwrap()\n                              .text()\n                              .unwrap();\n            let story: Story = serde_json::from_str(&story).unwrap();\n            tx_clone.send(Msg::NewStory(story)).unwrap();\n        }\n```"]