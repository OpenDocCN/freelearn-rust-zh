- en: Logging and Configuring Microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices work in the real world, which is dynamic. To be useful, they have
    to be configurable, so that you can change an address or port to bind the server's
    socket. Often, you will need to set tokens, secrets, and the addresses of other
    microservices. Even if you have configured them correctly, your microservices
    may fail. In this case, you need to be able to use the server's logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use logging with the `log` crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read command-line parameters with the `clap` crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read environment variables with the `dotenv` crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to declare and use configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains how to add logging to a service and parse command-line
    parameters or the environment variables required to configure a microservice.
    You don't need any special software except the Rust compiler, version 1.31 or
    above. Install it using the rustup tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for the examples of this chapter on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter3](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter3).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding logging to a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can't use or debug a microservice if it doesn't record the actions that it
    carries out. In this section, we will start to use logging with our microservices
    to understand what is going on inside them. We will create a microservice that
    generates random values and attach a logger to a microservice to record the actions
    it carries out. Afterward, we will configure logging using environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Random-value-generating microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To discuss these more advanced topics, we need a microservices architecture
    that has a more useful purpose than generating *hello* messages. We will create
    a microservice application for generating random values. This is simple enough
    to implement and will provide us with sufficient opportunities to use logging
    and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we won''t start completely from scratch; let''s take the example from
    the previous chapter and add a dependency to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A `rand` crate provides the utilities necessary to generate random values in
    Rust. Import the necessary types in the `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two lines to the `service_fn_ok` function to handle incoming requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about the preceding code, please refer to the previous chapter,
    where we explored the `hyper` crate.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have added two lines in the closure provided to the `service_fn_ok`
    function. The first line generates a random byte with the `random` function of
    the `rand` crate. We set the generated type in the type parameter of the `rand::random::<u8>()`
    call. Now, `u8`  is an unsigned byte integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second line, we simply convert the generated byte to a string and return
    it as a `Body` of the `Response`. Try to run the code to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/164b62dc-2c6e-43d5-a135-4a257ddff4d1.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can see that the service returned the generated
    random value successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The log crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is the process of recording the activities of a program. Logs can be
    a textual flow in a specified format, which prints to a console or writes to a
    file. Rust has a great logging ecosystem based on the `log` crate. It is worth
    noting that the `log` crate contains macros without a real logger implementation.
    This gives you an opportunity to use different loggers depending on what you need
    them for. In this section, we will start to use the log crate in our microservices
    to learn how logging levels work and how to set the desired level of logs you
    want to see.
  prefs: []
  type: TYPE_NORMAL
- en: Loggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The actual logger implementations that are contained in some crates are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`env_logger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simple_logger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simplelog`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pretty_env_logger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stderrlog`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flexi_logger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4rs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fern`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be difficult to choose between these logger implementations. I recommend
    that you explore them on [crates.io](http://crates.io) to learn how they differ.
    The most popular one is `env_logger`, which is the one that we are going to use.
    `env_logger` reads the `RUST_LOG` environment variable to configure logging and
    prints logs to `stderr`. There is also the `pretty_env_logger` crate, which is
    built on top of `env_logger` and prints logs with a compact and colorful format.
    Both use the same environment variable for configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '`stderr` is one of three standard streams—`stdin`*,* where your program reads
    the input data with the console; `stdout`*,* where the program sends the output
    data; and `stderr`*, *which has the special purpose of showing errors or other
    information about working with the application. Loggers often use `stderr` to
    avoid affecting the output data. For example, let''s say that you have a tool
    that decodes an input stream. You want the tool to send the decoded data only
    to the output stream. How will the program inform you about any issues it is experiencing?
    In this case, we can use the `stderr` stream, which works as an output stream,
    but doesn''t pollute `stdout`? There is `stderr` stream that works as output stream,
    but doesn''t pollute `stdout`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the logger to the dependencies list of your `Cargo.toml`  file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add these types to your `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Log levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier, with the `log` crate, we need to import the following
    logging macros. We can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`trace!`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug!`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info!`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warn!`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error!`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are ordered by the importance of the information they print, with `trace!`
    being the least important and `error!` being the most important:'
  prefs: []
  type: TYPE_NORMAL
- en: '`trace!`: Used to print verbose information about any pivotal activity. It
    allows web servers to trace any incoming chunk of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug!`: Used for less verbose messages, such as the incoming server requests.
    It is useful for debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info!`: Used for important information such as the runtime or server configuration.
    It is rarely used in library crates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warn!`: Informs the user about non-critical errors, such as if the client
    has used broken cookies or if the necessary microservice is temporarily unavailable
    and cached data is used for responses instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error!`: Provides an alert about critical errors. This is used when the database
    connection is broken.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We imported the necessary macro directly from the `log` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Logging messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logging is not useful without the contextual data of the code. Every logging
    macro expects a text message that can contain positional parameters. For example,
    take a look at the `println!` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will work for types that implement the `Display` trait. As
    in the `println!` macro, you can add types that implement the `Debug` trait with
    the `{:?}` formatter. It's useful to derive the `Debug` trait for all types in
    your code with `#[derive(Debug)]` and set the  `#![deny(missing_debug_implementations)]`
    attribute for the whole crate.
  prefs: []
  type: TYPE_NORMAL
- en: Custom level of messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Levels have an important role in the logging process. They are used for filtering
    the records by their priority. If you set the `info` level for the `logger`, it
    will skip all the `debug` and `trace` records. Obviously, you need more verbose
    logging for debugging purposes and less verbose logging to use the server in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, every macro of the `log` crate uses the `log!` macro, which has
    an argument to set the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It takes an instance of the `Level` enumeration that has the following variants—`Trace`,
    `Debug`, `Info`, `Warn`, and `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking logging is enabled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, logging may require a lot of resources. In this case, you can use
    the `log_enabled!` macro to check that a certain logging level has been enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Own target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every log record has a target. A typical logging record looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c33631fa-2d5f-4e41-a7d4-24b88db2bd90.png)'
  prefs: []
  type: TYPE_IMG
- en: The log record consists of the logging level, the time (not shown in this output),
    the target, and the message. You can think about the target as a namespace. If
    no target is specified, the `log` crate uses the `module_path!` macro to set one.
    We can use the target to detect the module where an error or warning has happened
    or use it for filtering records by name. We will see how to set filtering by environment
    variable in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Using logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now add logging to our microservice. In the following example, we will
    print information about the socket address, the incoming request, and a generated
    random value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using logging is quite simple. We can use macros to print the address of the
    socket and information about the request and response.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a logger with variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some environment variables that you can use to configure a logger.
    Let's take a look at each variable.
  prefs: []
  type: TYPE_NORMAL
- en: RUST_LOG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compile this example. To run it with an activated logger, you have to set the `RUST_LOG`
    environment variable. The `env_logger` crate reads it and configures the logger
    using filters from this variable. A `logger` instance must be configured with
    a corresponding logging level.
  prefs: []
  type: TYPE_NORMAL
- en: You can set the `RUST_LOG` variable globally. If you use the Bash shell, you
    can set it in your `.bashrc` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set `RUST_LOG` temporarily before the `cargo run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this will also print a lot of `cargo` tool and compiler records, because
    the Rust compiler also uses the `log` crate for logging. You can exclude all records
    except for those of your program using filtering by name. You only need to use
    part of the target name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This value of the `RUST_LOG` variable filters all records by the *warn* level
    and uses the *trace* level for targets starting with the `random_service` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: RUST_LOG_STYLE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RUST_LOG_STYLE` variable sets the style of printed records. It has three
    variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '**auto**: Tries to use the style characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**always**: Always uses the style characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**never**: Turns off the style characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I recommend that you use the `never` value if you redirect the `stderr` output
    a file or if you want to use `grep` or `awk` to extract values with special patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the RUST_LOG variable to your own
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you release your own product, you may need to change the name of the `RUST_LOG`
    and the `RUST_LOG_STYLE` variable to your own. New releases of the `env_logger`
    contain the `init_from_env` special function to fix this. This expects one argument—an
    instance of the `Env` object. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It creates an `Env` instance and sets the `OWN_LOG_VAR` variable to configure
    logging and the `OWN_LOG_STYLE_VAR` variable to control the style of the logs.
    When the `env` object is created, we will use it as an argument for the `init_from_env`
    function call of the `env_logger` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Reading environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we used a value of the `RUST_LOG` environment variable
    to set filtering parameters for logging. We can use other environment variables
    to set parameters for our server as well. In the following example, we will use
    the `ADDRESS` environment variable to set the address of the socket we want to
    bind.
  prefs: []
  type: TYPE_NORMAL
- en: Standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are enough functions in the `std::env` standard module to work with environment
    variables. It contains the `var` function to read external values. This function
    returns a `Result` with a `String` value of the variable if it exists, or a `VarError`
    error if it doesn''t exist. Add the import of the `env` module to your `main.rs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to replace the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This new code reads the `ADDRESS` value. If this value doesn't exist, we won't
    let the code throw a panic. Instead, we will replace it with the default value, `"127.0.0.1:8080"`,
    using the `unwrap_or_else` method call. As the `var` function returns a `String`,
    we also have to convert `&'static str` into a `String` instance with the `into`
    method call.
  prefs: []
  type: TYPE_NORMAL
- en: If we can't parse an address, we will throw a panic in the `except` method call.
  prefs: []
  type: TYPE_NORMAL
- en: Your server will now use the `addr` variable, which takes a value from the `ADDRESS`
    environment variable or from the default value.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables are a simple way of configuring your application. They
    are also widely supported with hosting or cloud platforms and Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that all sensitive data is visible to the system administrator of the
    host. In Linux, the system administrator can read this data simply by using the ``cat
    /proc/`pidof random-service-with-env`/environ` | tr '\0' '\n'`` command. This
    means that it's not a good idea to set the secret key of your bitcoin wallet to
    the environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using the .env file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting many environment variables is time-consuming. We can simplify this using
    configuration files, which we will explore further at the end of this chapter.
    However, configuration files can't be used in cases where the crates or dependencies
    use environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: To make this process simple, we can use the `dotenv` crate. This is used to
    set environment variables from a file. This practice appeared as part of *The
    Twelve-Factor App* methodology *([https://12factor.net/](https://12factor.net/))*.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Twelve-Factor App* approach is a methodology for building **Software as
    a Service** (**SaaS**) applications to fulfill the following three objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Configurations in declarative formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum portability with operating systems and clouds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous deployment and scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This methodology encourages you to use environment variables to configure the
    application. The *Twelve-Factor App* approach doesn't require disk space for configuration
    and it is extremely portable, meaning that all operating systems support the environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dotenv crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `dotenv` crate allows you to set environment variables in a file called
    `.env` and join them with variables set in the traditional way. You don't need
    to read this file manually. All you need to do is add the dependency and call
    the initialization method of the crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this crate to the list of `dependencies` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following imports to the `main.rs` file of the previous example to
    use the `dotenv` crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Initialize it with the `dotenv` function, which will try to find the `.env`
    file. It will return a `Result` with a path to this file. Call the `ok` method
    of the `Result` to ignore it if the file hasn't been found.
  prefs: []
  type: TYPE_NORMAL
- en: Adding variables to the .env file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `.env` file contains pairs of names and values of environment variables.
    For our service, we will set the `RUST_LOG`, `RUST_BACKTRACE`, and `ADDRESS` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we set all the targets of the `logger` to the `debug` level,
    because `cargo` doesn't use `dotenv` and therefore skips these settings.
  prefs: []
  type: TYPE_NORMAL
- en: The `RUST_BACKTRACE` variable sets the flag to print a backtrace of the application
    in the case of panic.
  prefs: []
  type: TYPE_NORMAL
- en: Store this file in the working directory from which you will run the application.
    You can have multiple files and use them for different configurations. This file
    format is also compatible with Docker and can be used to set variables to the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you add the `.env` file to your `.gitignore` to prevent leaking
    of sensitive or local data. This means that every user or developer who works
    with your project has their own environment and needs their own version of the `.env`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Environment variables are useful for using with containers. If you use your
    application from a console or you want to avoid a conflict of names with other
    variables, you can use command-line parameters. This is a more conventional way
    for developers to set parameters to the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also get command-line arguments with the `env` module. This contains
    the `args` function, which returns an `Args` object. This object is not an array
    or vector, but it''s iterable and you can use the `for` loop processes all command-line
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This variant may come in handy in simple cases. For parsing arguments with complex
    rules, however, you have to use a command-line argument parser. A good implementation
    of this is contained in the `clap` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Using the clap crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the `clap` crate for parsing arguments, you have to build a parser and
    use it for arguments. To build a parser, you start by creating an instance of
    the `App` type. To use it, add all the necessary imports.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a dependency to `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This crate provides useful macros for adding meta information about the program.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`crate_name!`: Returns the name of the crate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crate_version!`: Returns the version of the crate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crate_authors!`: Returns the list of authors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crate_description!`: Provides the description of the crate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All information for these macros is taken from the `Cargo.toml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary types. We need two types, which are `App` and `Arg`, and
    the macros mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Building a parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of building a parser is quite simple. You will create an `App`
    instance and feed this type with the `Arg` instances. The `App` also has methods
    that can be used to set information about the application. Add the following code
    to the `main` function of our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, we create an `App` instance with a `new` method that expects the name
    of the crate. We provide this using the `crate_name!` macro. After that, we use
    the `version`, `author`, and `about` methods to set this data using the corresponding
    macros. We can chain these method calls, because every method consumes and returns
    the updated `App` object. When we set meta-information about the application,
    we have to declare the supported arguments with the `arg` method.
  prefs: []
  type: TYPE_NORMAL
- en: To add an argument, we have to create an `Arg` instance with the `with_name`
    method, provide the name, and set extra parameters using chaining-of-methods calls.
    We can set a short form of the argument with the `short` method and the long form
    with the `long` method. You can set the name of the value for the generated documentation
    using the `value_name` method. You can provide a description of an argument using
    the  `help` method. The `takes_value` method is used to indicate that this argument
    requires a value. There is also a `required` method to indicate that an option
    is required, but we didn't use that here. All options are optional in our server.
  prefs: []
  type: TYPE_NORMAL
- en: We added the `--address` argument using these methods to set the address of
    the socket that we will use to bind the server. It also supports the short form
    `a` of the argument. We will read this value later.
  prefs: []
  type: TYPE_NORMAL
- en: The server will support the `--config` argument to set a configuration file.
    We have added this argument to the builder, but we will use it in the next section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the builder, we call the `get_matches` method. This reads arguments
    with `std::env::args_os` and returns an `ArgMatches` instance, which we can use
    to get the values of the command-line parameters. We assign it to the `matches`
    local variable.
  prefs: []
  type: TYPE_NORMAL
- en: We should add the `get_matches` method before any logging call because it also
    prints help messages. We should avoid printing logs with the help description.
  prefs: []
  type: TYPE_NORMAL
- en: Reading arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To read arguments, `ArgMatches` contains a `value_of` method, where you add
    the name of a parameter. In this case, it is convenient to use constants to avoid
    typos. Extract the  `--address` argument, and if this does not exist, then check
    the `ADDRESS` environment variable. This means that the command-line argument
    is a higher priority than the environment variable and you can override the parameters
    from the `.env` file with command-line parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we have converted all of the provided string references with the
    `&str` type to solid `String` objects. This is useful if you want to use the object
    later in the code or if you need to move it elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you use the `clap` crate in your application, you can use command-line
    parameters to tweak it. The `clap` crate adds a `--help` argument, which the user
    can use to print information about all the arguments. This description was generated
    automatically by the crate, as can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application successfully printed the usage info: it provided us with all
    flags, options, and usage variants. If you need to add your own help description,
    you can use the `help` method of the `App` instance to set any string as a help
    message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the `cargo run` command, you can also set command-line parameters
    after the `--` parameter. This means that it stops reading the `run` command and
    passes all remaining arguments to the running application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now start the server and set an address using the `--address` parameter
    with value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The server has started and prints to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How to add subcommands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some popular applications, such as `cargo` and `docker`, use subcommands to
    provide multiple commands inside a single binary. We can also support subcommands
    with the `clap` crate. A microservice might have two commands: one to run the
    server and one to generate a secret for the HTTP cookies. Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used two methods. The `setting` method tweaks the builder and
    you can set it with variants of the `AppSettings` enumeration. The `SubcommandRequiredElseHelp` method
    requires us to use subcommands or prints help message if no subcommands are provided.
    To add a subcommand, we use the `subcommand` method with the `SubCommand` instance
    that we created with the `with_name` method. A subcommand instance also has methods
    to set meta information about a subcommand, like we did with the `App` instance.
    Subcommands can also take arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example above, we added two subcommands—`run`, to run the
    server, and `key`, to generate secrets. You can use these when you start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have two `run` arguments because the cargo has a command with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the configuration from file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Environment variables and command-line arguments are useful to add temporary
    change parameters for a single run. They are a more convenient way to configure
    servers to use configuration files. This approach doesn't conform to The *Twelve-Factor
    App* methodology, but it's useful in cases when you need to set long parameters.
  prefs: []
  type: TYPE_NORMAL
- en: There are many formats that can be used for configuration files. The popular
    ones include TOML, YAML, and JSON. We will use TOML, because it is widely used
    with the Rust programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the TOML config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TOML file format is implemented in the `toml` crate. It previously used
    the now-obsolete `rustc-serialize` crate, but the last few versions have used
    the `serde` crate for serialization and deserialization. We will use both the `toml`
    and the `serde` crates.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We actually need not only the `serde` crate but also the `serde_derive` crate.
    Both crates help with the serialization struct in various serialization formats.
    Add all three crates to the dependencies list in `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The full list of imports in the `main.rs` file contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we haven't imported the `serde` crate here. We won't use it
    directly in the code because it's necessary to use the `serde_derive` crate instead.
    We have imported all macros from the `serde_derive` crate, because the `serde`
    crate contains the `Serialize` and `Deserialize` traits and `serde_derive` helps
    us to derive these for our structs.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices often need to serialize and deserialize data when interacting
    with the client. We will cover this topic in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a struct for configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now imported all the necessary dependencies and can declare our configuration
    file structure. Add the `Config` struct to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This struct contains only one field with the address. You can add more, but
    remember that all fields have to implement the `Deserialize` trait. The `serde`
    crate already has implementations for standard library types. For our types, we
    have to derive the implementation of `Deserialize` with the macro of the `serde_derive`
    crate.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is ready for us to read the configuration from the file.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our server will expect to find a configuration file in the current working
    folder with the name `microservice.toml`. To read a configuration and convert
    it to the `Config` struct, we need to find and read this file if it exists. Add
    the following code to the `main` function of the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a chain of method calls that start with the `File` instance.
    We use the `open` method to open the file and provide the name `microservice.toml`.
    The call returns a `Result`, which we will process in the chain. At the end of
    the processing, we will convert it to an option using the `ok` method and ignore
    any errors that occur during the parsing of the config file. This is because our
    service also supports environment variables and command-line parameters and has
    defaults for unset parameters.
  prefs: []
  type: TYPE_NORMAL
- en: When the file is ready, we will try to convert it into a `String`. We created
    an empty string, called a buffer, and used the `read_to_string` method of the `File`
    instance to move all of the data into the buffer. This is a synchronous operation.
    It's suitable for reading a configuration but you shouldn't use it for reading
    files to send to the client, because it will lock the runtime of the server until
    the file is read.
  prefs: []
  type: TYPE_NORMAL
- en: After we have read the `buffer` variable, we will try to parse it as a TOML
    file into the `Config` struct. The `toml` crate has a `from_str` method in the
    root namespace of the crate. It expects a type parameter to deserialize and an
    input string. We use the `Config` struct for the output type and our `buffer`
    for the input. But there is a problem: the `File` uses `io::Error` for errors,
    but `from_str` uses `toml::de:Error` for the error type. We can convert the second
    type to `io::Error` to make it compatible with the chain of calls.
  prefs: []
  type: TYPE_NORMAL
- en: The penultimate part of the chain is the `map_err` method call. We use this
    to write any errors with the configuration file to logs. As you can see, we used
    the `Warn` level. Issues with the configuration file are not critical, but it
    is important to be aware of them because they can affect the configuration. This
    makes the `microservices.toml` file optional.
  prefs: []
  type: TYPE_NORMAL
- en: Joining all values by a priority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our server has four sources of address settings:'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command-line parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to join these in this order. It''s simple to implement this using a
    set of options and using the `or` method to set a value if the option doesn''t
    contain anything. Use the following code to get address values from all of the
    sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: At first, this code takes a value from the `--address` command-line parameter.
    If it doesn't contain any value, the code tries to get a value from the `ADDRESS`
    environment variable. After that, we try to parse a textual value to the socket
    address. If all these steps fail, we can try to get a value from the `Config`
    instance that we read from `microservice.toml`.  We will use the default address
    value if the value wasn't set by a user. In the previous address-parsing code,
    we also parsed the default value from a string. In this code, we use a tuple to
    construct the `SocketAddr` instance. Since we are guaranteed to get a value, we
    `unwrap` the option to extract it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using the configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now create a configuration file and run the server. Create the `microservice.toml`
    file in the root folder of the project and add the following line to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and start the service and you will see it has bound to that address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99563a72-b365-490a-a091-846628f66c5e.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added logging to the server and learned how to activate
    the `logger` and set filters to it. After that, we transformed our unflexible
    server to a configurable microservice that can read settings from different sources—the
    configuration file, the environment variable, and the command-line parameters.
    We became familiar with *The Twelve-Factor App* methodology and used the `dotenv`
    crate, which helped us to read environment variables from a file. We also used
    the `clap` crate to add a command-line parser. Finally, we touched on the `serde`
    crate, which introduced us to the world of serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter we will learn how to use `serde` crate for needs of a microservices:
    to deserialize request and serialize responses to a certain format like JSON,
    CBOR, BSON, MessagePack, etc.'
  prefs: []
  type: TYPE_NORMAL
