["```rs\ncargo new --bin ftp-server\n```", "```rs\n[dependencies]\nbytes = \"^0.4.5\"\ntokio-core = \"^0.1.10\"\ntokio-io = \"^0.1.3\"\n\n[dependencies.futures-await]\ngit = \"https://github.com/alexcrichton/futures-await\"\n```", "```rs\nrustup default nightly\n```", "```rs\n#![feature(proc_macro, conservative_impl_trait, generators)]\n\nextern crate bytes;\nextern crate futures_await as futures;\nextern crate tokio_core;\nextern crate tokio_io;\n```", "```rs\nmod cmd;\nmod ftp;\n```", "```rs\nuse std::path::{Path, PathBuf};\nuse std::str::{self, FromStr};\n\nuse error::{Error, Result};\n\n#[derive(Clone, Debug)]\npub enum Command {\n    Auth,\n    Cwd(PathBuf),\n    List(Option<PathBuf>),\n    Mkd(PathBuf),\n    NoOp,\n    Port(u16),\n    Pasv,\n    Pwd,\n    Quit,\n    Retr(PathBuf),\n    Rmd(PathBuf),\n    Stor(PathBuf),\n    Syst,\n    Type(TransferType),\n    CdUp,\n    Unknown(String),\n    User(String),\n}\n```", "```rs\nimpl AsRef<str> for Command {\n    fn as_ref(&self) -> &str {\n        match *self {\n            Command::Auth => \"AUTH\",\n            Command::Cwd(_) => \"CWD\",\n            Command::List(_) => \"LIST\",\n            Command::Pasv => \"PASV\",\n            Command::Port(_) => \"PORT\",\n            Command::Pwd => \"PWD\",\n            Command::Quit => \"QUIT\",\n            Command::Retr(_) => \"RETR\",\n            Command::Stor(_) => \"STOR\",\n            Command::Syst => \"SYST\",\n            Command::Type(_) => \"TYPE\",\n            Command::User(_) => \"USER\",\n            Command::CdUp => \"CDUP\",\n            Command::Mkd(_) => \"MKD\",\n            Command::Rmd(_) => \"RMD\",\n            Command::NoOp => \"NOOP\",\n            Command::Unknown(_) => \"UNKN\", // doesn't exist\n        }\n    }\n}\n```", "```rs\nimpl Command {\n    pub fn new(input: Vec<u8>) -> Result<Self> {\n        let mut iter = input.split(|&byte| byte == b' ');\n        let mut command = iter.next().ok_or_else(\n         || Error::Msg(\"empty command\".to_string()))?.to_vec();\n        to_uppercase(&mut command);\n        let data = iter.next().ok_or_else(|| Error::Msg(\"no command  \n         parameter\".to_string()));\n        let command =\n            match command.as_slice() {\n                b\"AUTH\" => Command::Auth,\n                b\"CWD\" => Command::Cwd(data.and_then(|bytes|  \n                Ok(Path::new(str::from_utf8(bytes)?).to_path_buf()))?),\n                b\"LIST\" => Command::List(data.and_then(|bytes|  \n                 Ok(Path::new(str::from_utf8(bytes)?).to_path_buf())).ok()),\n                b\"PASV\" => Command::Pasv,\n                b\"PORT\" => {\n                    let addr = data?.split(|&byte| byte == b',')\n                        .filter_map(|bytes| \n                         str::from_utf8(bytes).ok()\n                         .and_then(|string| u8::from_str(string).ok()))\n                        .collect::<Vec<u8>>();\n                    if addr.len() != 6 {\n                        return Err(\"Invalid address/port\".into());\n                    }\n\n                    let port = (addr[4] as u16) << 8 | (addr[5] as \n                     u16);\n                    if port <= 1024 {\n                        return Err(\"Port can't be less than\n                      10025\".into());\n                    }\n                    Command::Port(port)\n                },\n                b\"PWD\" => Command::Pwd,\n                b\"QUIT\" => Command::Quit,\n                b\"RETR\" => Command::Retr(data.and_then(|bytes|  \n                Ok(Path::new(str::from_utf8(bytes)?).to_path_buf()))?),\n                b\"STOR\" => Command::Stor(data.and_then(|bytes|   \n                Ok(Path::new(str::from_utf8(bytes)?).to_path_buf()))?),\n                b\"SYST\" => Command::Syst,\n                b\"TYPE\" => {\n                    match TransferType::from(data?[0]) {\n                        TransferType::Unknown => return \n                         Err(\"command not implemented \n                        for that parameter\".into()),\n                        typ => {\n                            Command::Type(typ)\n                        },\n                    }\n                },\n                b\"CDUP\" => Command::CdUp,\n                b\"MKD\" => Command::Mkd(data.and_then(|bytes|  \n                Ok(Path::new(str::from_utf8(bytes)?).to_path_buf()))?),\n                b\"RMD\" => Command::Rmd(data.and_then(|bytes|  \n                Ok(Path::new(str::from_utf8(bytes)?).to_path_buf()))?),\n                b\"USER\" => Command::User(data.and_then(|bytes|  \n                String::from_utf8(bytes.to_vec()).map_err(Into::into))?),\n                b\"NOOP\" => Command::NoOp,\n                s => \n                 Command::Unknown(str::from_utf8(s).unwrap_or(\"\").to_owned()),\n            };\n        Ok(command)\n    }\n}\n```", "```rs\nfn to_uppercase(data: &mut [u8]) {\n    for byte in data {\n        if *byte >= 'a' as u8 && *byte <= 'z' as u8 {\n            *byte -= 32;\n        }\n    }\n}\n```", "```rs\n#[derive(Clone, Copy, Debug)]\npub enum TransferType {\n    Ascii,\n    Image,\n    Unknown,\n}\n\nimpl From<u8> for TransferType {\n    fn from(c: u8) -> TransferType {\n        match c {\n            b'A' => TransferType::Ascii,\n            b'I' => TransferType::Image,\n            _ => TransferType::Unknown,\n        }\n    }\n}\n```", "```rs\npub struct Answer {\n    pub code: ResultCode,\n    pub message: String,\n}\n\nimpl Answer {\n    pub fn new(code: ResultCode, message: &str) -> Self {\n        Answer {\n            code,\n            message: message.to_string(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\n#[repr(u32)]\n#[allow(dead_code)]\npub enum ResultCode {\n    RestartMarkerReply = 110,\n    ServiceReadInXXXMinutes = 120,\n    DataConnectionAlreadyOpen = 125,\n    FileStatusOk = 150,\n    Ok = 200,\n    CommandNotImplementedSuperfluousAtThisSite = 202,\n    SystemStatus = 211,\n    DirectoryStatus = 212,\n    FileStatus = 213,\n    HelpMessage = 214,\n    SystemType = 215,\n    ServiceReadyForNewUser = 220,\n    ServiceClosingControlConnection = 221,\n    DataConnectionOpen = 225,\n    ClosingDataConnection = 226,\n    EnteringPassiveMode = 227,\n    UserLoggedIn = 230,\n    RequestedFileActionOkay = 250,\n    PATHNAMECreated = 257,\n    UserNameOkayNeedPassword = 331,\n    NeedAccountForLogin = 332,\n    RequestedFileActionPendingFurtherInformation = 350,\n    ServiceNotAvailable = 421,\n    CantOpenDataConnection = 425,\n    ConnectionClosed = 426,\n    FileBusy = 450,\n    LocalErrorInProcessing = 451,\n    InsufficientStorageSpace = 452,\n    UnknownCommand = 500,\n    InvalidParameterOrArgument = 501,\n    CommandNotImplemented = 502,\n    BadSequenceOfCommands = 503,\n    CommandNotImplementedForThatParameter = 504,\n    NotLoggedIn = 530,\n    NeedAccountForStoringFiles = 532,\n    FileNotFound = 550,\n    PageTypeUnknown = 551,\n    ExceededStorageAllocation = 552,\n    FileNameNotAllowed = 553,\n}\n```", "```rs\nmod error;\n```", "```rs\nuse std::io;\nuse std::str::Utf8Error;\nuse std::string::FromUtf8Error;\n\npub enum Error {\n    FromUtf8(FromUtf8Error),\n    Io(io::Error),\n    Msg(String),\n    Utf8(Utf8Error),\n}\n```", "```rs\nuse std::fmt::{self, Display, Formatter};\n\nuse self::Error::*;\n\nimpl Display for Error {\n    fn fmt(&self, formatter: &mut Formatter) -> fmt::Result {\n        match *self {\n            FromUtf8(ref error) => error.fmt(formatter),\n            Io(ref error) => error.fmt(formatter),\n            Utf8(ref error) => error.fmt(formatter),\n            Msg(ref msg) => write!(formatter, \"{}\", msg),\n        }\n    }\n}\n```", "```rs\nuse std::error;\n\nimpl error::Error for Error {\n    fn description(&self) -> &str {\n        match *self {\n            FromUtf8(ref error) => error.description(),\n            Io(ref error) => error.description(),\n            Utf8(ref error) => error.description(),\n            Msg(ref msg) => msg,\n        }\n    }\n\n    fn cause(&self) -> Option<&error::Error> {\n        let cause: &error::Error =\n            match *self {\n                FromUtf8(ref error) => error,\n                Io(ref error) => error,\n                Utf8(ref error) => error,\n                Msg(_) => return None,\n            };\n        Some(cause)\n    }\n}\n```", "```rs\nIo(_) => \"IO error\",\n```", "```rs\n#[derive(Debug)]\npub enum Error {\n    FromUtf8(FromUtf8Error),\n    Io(io::Error),\n    Msg(String),\n    Utf8(Utf8Error),\n}\n```", "```rs\nuse std::result;\n\npub type Result<T> = result::Result<T, Error>;\n```", "```rs\nlet val =\n    match result {\n        Ok(val) => val,\n        Err(error) => return Err(Error::Io(error)),\n    };\n```", "```rs\nimpl From<io::Error> for Error {\n    fn from(error: io::Error) -> Self {\n        Io(error)\n    }\n}\n\nimpl<'a> From<&'a str> for Error {\n    fn from(message: &'a str) -> Self {\n        Msg(message.to_string())\n    }\n}\n\nimpl From<Utf8Error> for Error {\n    fn from(error: Utf8Error) -> Self {\n        Utf8(error)\n    }\n}\n\nimpl From<FromUtf8Error> for Error {\n    fn from(error: FromUtf8Error) -> Self {\n        FromUtf8(error)\n    }\n}\n```", "```rs\nlet val =\n    match result {\n        Ok(val) => val,\n        Err(error) => return Err(error.into()),\n    };\n```", "```rs\nimpl<T, U> Into<U> for T\nwhere U: From<T>,\n```", "```rs\nlet val = result?;\n```", "```rs\nuse tokio_core::reactor::Core;\n\nfn main() {\n    let mut core = Core::new().expect(\"Cannot create tokio Core\");\n    if let Err(error) = core.run(server()) {\n        println!(\"Error running the server: {}\", error);\n    }\n}\n```", "```rs\nuse std::io;\n\nuse futures::prelude::async;\n\n#[async]\nfn server() -> io::Result<()> {\n    Ok(())\n}\n```", "```rs\nuse futures::prelude::async_block;\n\nfn main() {\n    let mut core = Core::new().expect(\"Cannot create tokio Core\");\n    let server = async_block! {\n        Ok(())\n    };\n    let result: Result<_, io::Error> = core.run(server);\n    if let Err(error) = result {\n        println!(\"Error running the server: {}\", error);\n    }\n}\n```", "```rs\nuse std::net::{IpAddr, Ipv4Addr, SocketAddr};\n\nuse tokio_core::reactor::Handle;\nuse tokio_core::net::TcpListener;\n\n#[async]\nfn server(handle: Handle) -> io::Result<()> {\n    let port = 1234;\n    let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);\n    let listener = TcpListener::bind(&addr, &handle)?;\n\n    println!(\"Waiting clients on port {}...\", port);\n    #[async]\n    for (stream, addr) in listener.incoming() {\n        let address = format!(\"[address : {}]\", addr);\n        println!(\"New client: {}\", address);\n        handle.spawn(handle_client(stream));\n        println!(\"Waiting another client...\");\n    }\n    Ok(())\n}\n```", "```rs\nfn main() {\n    let mut core = Core::new().expect(\"Cannot create tokio Core\");\n    let handle = core.handle();\n    if let Err(error) = core.run(server(handle)) {\n        println!(\"Error running the server: {}\", error);\n    }\n}\n```", "```rs\nuse std::result;\n\nuse futures::prelude::await;\n\n#[async]\nuse tokio_core::net::TcpStream;\n\nfn handle_client(stream: TcpStream) -> result::Result<(), ()> {\n    await!(client(stream))\n        .map_err(|error| println!(\"Error handling client: {}\", error))\n}\n```", "```rs\nuse futures::{Sink, Stream};\nuse futures::stream::SplitSink;\nuse tokio_io::AsyncRead;\nuse tokio_io::codec::Framed;\n\nuse codec::FtpCodec;\nuse error::Result;\nuse ftp::{Answer, ResultCode};\n\n#[async]\nfn client(stream: TcpStream) -> Result<()> {\n    let (writer, reader) = stream.framed(FtpCodec).split();\n    let writer = await!(writer.send(Answer::new(ResultCode::ServiceReadyForNewUser, \n    \"Welcome to this FTP server!\")))?;\n    let mut client = Client::new(writer);\n    #[async]\n    for cmd in reader {\n        client = await!(client.handle_cmd(cmd))?;\n    }\n    println!(\"Client closed\");\n    Ok(())\n}\n```", "```rs\ntype Writer = SplitSink<Framed<TcpStream, FtpCodec>>;\n\nstruct Client {\n    writer: Writer,\n}\n```", "```rs\nuse cmd::Command;\n\nimpl Client {\n    fn new(writer: Writer) -> Client {\n        Client {\n            writer,\n        }\n    }\n\n    #[async]\n    fn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n        Ok(self)\n    }\n}\n```", "```rs\nclient = await!(client.handle_cmd(cmd))?;\n```", "```rs\nmod codec;\n```", "```rs\npub struct FtpCodec;\n```", "```rs\nuse tokio_io::codec::{Decoder, Encoder};\n```", "```rs\nuse std::io;\n\nuse bytes::BytesMut;\n\nuse cmd::Command;\nuse error::Error;\n\nimpl Decoder for FtpCodec {\n    type Item = Command;\n    type Error = io::Error;\n\n    fn decode(&mut self, buf: &mut BytesMut) ->\n     io::Result<Option<Command>> {\n        if let Some(index) = find_crlf(buf) {\n            let line = buf.split_to(index);\n            buf.split_to(2); // Remove \\r\\n.\n            Command::new(line.to_vec())\n                .map(|command| Some(command))\n                .map_err(Error::to_io_error)\n        } else {\n            Ok(None)\n        }\n    }\n}\n```", "```rs\nimpl Error {\n    pub fn to_io_error(self) -> io::Error {\n        match self {\n            Io(error) => error,\n            FromUtf8(_) | Msg(_) | Utf8(_) => \n             io::ErrorKind::Other.into(),\n        }\n    }\n}\n```", "```rs\nfn find_crlf(buf: &mut BytesMut) -> Option<usize> {\n    buf.windows(2)\n        .position(|bytes| bytes == b\"\\r\\n\")\n}\n```", "```rs\nuse ftp::Answer;\n\nimpl Encoder for FtpCodec {\n    type Item = Answer;\n    type Error = io::Error;\n\n    fn encode(&mut self, answer: Answer, buf: &mut BytesMut) -> io::Result<()> {\n        let answer =\n            if answer.message.is_empty() {\n                format!(\"{}\\r\\n\", answer.code as u32)\n            } else {\n                format!(\"{} {}\\r\\n\", answer.code as u32, \n                 answer.message)\n            };\n        buf.extend(answer.as_bytes());\n        Ok(())\n    }\n}\n```", "```rs\nimpl Client {\n    #[async]\n    fn send(mut self, answer: Answer) -> Result<Self> {\n        self.writer = await!(self.writer.send(answer))?;\n        Ok(self)\n    }\n}\n```", "```rs\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    println!(\"Received command: {:?}\", cmd);\n    match cmd {\n        Command::User(content) => {\n            if content.is_empty() {\n                self = await! \n          (self.send(Answer::new(ResultCode::InvalidParameterOrArgument, \"Invalid  \n           username\")))?;\n            } else {\n                self = await!(self.send(Answer::new(ResultCode::UserLoggedIn,  \n                &format!(\"Welcome {}!\", content))))?;\n            }\n        }\n        Command::Unknown(s) =>\n            self = await!(self.send(Answer::new(ResultCode::UnknownCommand,\n            &format!(\"\\\"{}\\\": Not implemented\", s))))? ,\n        _ => self = await!(self.send(Answer::new(ResultCode::CommandNotImplemented,  \n       \"Not implemented\")))?,\n    }\n    Ok(self)\n}\n```", "```rs\nuse std::path::PathBuf;\n\nstruct Client {\n    cwd: PathBuf,\n    writer: Writer,\n}\n```", "```rs\nimpl Client {\n    fn new(writer: Writer) -> Client {\n        Client {\n            cwd: PathBuf::from(\"/\"),\n            writer,\n        }\n    }\n}\n```", "```rs\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    println!(\"Received command: {:?}\", cmd);\n    match cmd {\n        Command::Pwd => {\n            let msg = format!(\"{}\", self.cwd.to_str().unwrap_or(\"\"));\n            if !msg.is_empty() {\n                let message = format!(\"\\\"/{}\\\" \", msg);\n                self = await!(self.send(Answer::new(ResultCode::PATHNAMECreated,  \n                &message)))?;\n            } else {\n                self = await!(self.send(Answer::new(ResultCode::FileNotFound, \"No  \n                such file or directory\")))?;\n            }\n        }\n        // …\n    }\n}\n```", "```rs\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    match cmd {\n        Command::Cwd(directory) => self = await!(self.cwd(directory))?,\n        // …\n    }\n}\n```", "```rs\n#[async]\nfn cwd(mut self, directory: PathBuf) -> Result<Self> {\n    let path = self.cwd.join(&directory);\n    let (new_self, res) = self.complete_path(path);\n    self = new_self;\n    if let Ok(dir) = res {\n        let (new_self, res) = self.strip_prefix(dir);\n        self = new_self;\n        if let Ok(prefix) = res {\n            self.cwd = prefix.to_path_buf();\n            self = await!(self.send(Answer::new(ResultCode::Ok,\n                                                &format!(\"Directory changed to \\\" \n             {}\\\"\", directory.display()))))?;\n            return Ok(self)\n        }\n    }\n    self = await!(self.send(Answer::new(ResultCode::FileNotFound,\n                                        \"No such file or directory\")))?;\n    Ok(self)\n}\n```", "```rs\nuse std::path::StripPrefixError;\n\nfn complete_path(self, path: PathBuf) -> (Self, result::Result<PathBuf, io::Error>) {\n    let directory = self.server_root.join(if path.has_root() {\n        path.iter().skip(1).collect()\n    } else {\n        path\n    });\n    let dir = directory.canonicalize();\n    if let Ok(ref dir) = dir {\n        if !dir.starts_with(&self.server_root) {\n            return (self, \n             Err(io::ErrorKind::PermissionDenied.into()));\n        }\n    }\n    (self, dir)\n}\n\nfn strip_prefix(self, dir: PathBuf) -> (Self, result::Result<PathBuf, StripPrefixError>) {\n    let res = dir.strip_prefix(&self.server_root).map(|p| p.to_path_buf());\n    (self, res)\n}\n```", "```rs\nstruct Client {\n    cwd: PathBuf,\n    server_root: PathBuf,\n    writer: Writer,\n}\n```", "```rs\nimpl Client {\n    fn new(writer: Writer, server_root: PathBuf) -> Client {\n        Client {\n            cwd: PathBuf::from(\"/\"),\n            server_root,\n            writer,\n        }\n    }\n}\n```", "```rs\n#[async]\nfn client(stream: TcpStream, server_root: PathBuf) -> Result<()> {\n    // …\n    let mut client = Client::new(writer, server_root);\n    // …\n}\n\n#[async]\nfn handle_client(stream: TcpStream, server_root: PathBuf) -> result::Result<(), ()> {\n    await!(client(stream, server_root))\n        .map_err(|error| println!(\"Error handling client: {}\", \n         error))\n}\n```", "```rs\n#[async]\nfn server(handle: Handle, server_root: PathBuf) -> io::Result<()> {\n    // …\n    #[async]\n    for (stream, addr) in listener.incoming() {\n        let address = format!(\"[address : {}]\", addr);\n        println!(\"New client: {}\", address);\n        handle.spawn(handle_client(stream, server_root.clone()));\n        println!(\"Waiting another client...\");\n    }\n    Ok(())\n}\n```", "```rs\nuse std::env;\n\nfn main() {\n    let mut core = Core::new().expect(\"Cannot create tokio Core\");\n    let handle = core.handle();\n\n    match env::current_dir() {\n        Ok(server_root) => {\n            if let Err(error) = core.run(server(handle, \n             server_root)) {\n                println!(\"Error running the server: {}\", error);\n            }\n        }\n        Err(e) => println!(\"Couldn't start server: {:?}\", e),\n    }\n}\n```", "```rs\nuse cmd::TransferType;\n\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    match cmd {\n        // …\n        Command::Type(typ) => {\n            self.transfer_type = typ;\n            self = await!(self.send(Answer::new(ResultCode::Ok, \"Transfer type \n            changed successfully\")))?;\n        }\n        // …\n    }\n}\n```", "```rs\nstruct Client {\n    cwd: PathBuf,\n    server_root: PathBuf,\n    transfer_type: TransferType,\n    writer: Writer,\n}\n```", "```rs\nimpl Client {\n    fn new(writer: Writer, server_root: PathBuf) -> Client {\n        Client {\n            cwd: PathBuf::from(\"/\"),\n            server_root,\n            transfer_type: TransferType::Ascii,\n            writer,\n        }\n    }\n}\n```", "```rs\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    match cmd {\n        // …\n        Command::Pasv => self = await!(self.pasv())?,\n        // …\n    }\n}\n```", "```rs\nuse futures::stream::SplitStream;\n\nuse codec::BytesCodec;\n\ntype DataReader = SplitStream<Framed<TcpStream, BytesCodec>>;\ntype DataWriter = SplitSink<Framed<TcpStream, BytesCodec>>;\n\nstruct Client {\n    data_port: Option<u16>,\n    data_reader: Option<DataReader>,\n    data_writer: Option<DataWriter>,\n    handle: Handle,\n    // …\n}\n```", "```rs\nimpl Client {\n    fn new(handle: Handle, writer: Writer, server_root: PathBuf) -> Client {\n        Client {\n            data_port: None,\n            data_reader: None,\n            data_writer: None,\n            handle,\n            // …\n        }\n    }\n}\n```", "```rs\n#[async]\nfn client(stream: TcpStream, handle: Handle, server_root: PathBuf) -> Result<()> {\n    let (writer, reader) = stream.framed(FtpCodec).split();\n    let writer = await!(writer.send(Answer::new(ResultCode::ServiceReadyForNewUser,  \n    \"Welcome to this FTP server!\")))?;\n    let mut client = Client::new(handle, writer, server_root);\n    // …\n}\n```", "```rs\n#[async]\nfn handle_client(stream: TcpStream, handle: Handle, server_root: PathBuf) -> result::Result<(), ()> {\n    await!(client(stream, handle, server_root))\n        .map_err(|error| println!(\"Error handling client: {}\", error))\n}\n```", "```rs\n#[async]\nfn server(handle: Handle, server_root: PathBuf) -> io::Result<()> {\n    // …\n    #[async]\n    for (stream, addr) in listener.incoming() {\n        // …\n        handle.spawn(handle_client(stream, handle.clone(), server_root.clone()));\n    }\n}\n```", "```rs\n#[async]\nfn pasv(mut self) -> Result<Self> {\n    let port =\n        if let Some(port) = self.data_port {\n            port\n        } else {\n            0\n        };\n    if self.data_writer.is_some() {\n        self = await!(self.send(Answer::new(ResultCode::DataConnectionAlreadyOpen,  \n       \"Already listening...\")))?;\n        return Ok(self);\n    }\n\n    // …\n```", "```rs\n    // …\n\n    let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);\n    let listener = TcpListener::bind(&addr, &self.handle)?;\n    let port = listener.local_addr()?.port();\n\n    self = await!(self.send(Answer::new(ResultCode::EnteringPassiveMode,\n                          &format!(\"127,0,0,1,{},{}\", port >> 8, port & 0xFF))))?;\n\n    println!(\"Waiting clients on port {}...\", port);\n    #[async]\n    for (stream, _rest) in listener.incoming() {\n        let (writer, reader) = stream.framed(BytesCodec).split();\n        self.data_writer = Some(writer);\n        self.data_reader = Some(reader);\n        break;\n    }\n    Ok(self)\n}\n```", "```rs\nlet port = listener.local_addr()?.port();\n```", "```rs\npub struct BytesCodec;\n```", "```rs\nimpl Decoder for BytesCodec {\n    type Item = Vec<u8>;\n    type Error = io::Error;\n\n    fn decode(&mut self, buf: &mut BytesMut) -> io::Result<Option<Vec<u8>>> {\n        if buf.len() == 0 {\n            return Ok(None);\n        }\n        let data = buf.to_vec();\n        buf.clear();\n        Ok(Some(data))\n    }\n}\n```", "```rs\nimpl Encoder for BytesCodec {\n    type Item = Vec<u8>;\n    type Error = io::Error;\n\n    fn encode(&mut self, data: Vec<u8>, buf: &mut BytesMut) -> io::Result<()> {\n        buf.extend(data);\n        Ok(())\n    }\n}\n```", "```rs\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    match cmd {\n        Command::Quit => self = await!(self.quit())?,\n        // …\n    }\n}\n```", "```rs\n#[async]\nfn quit(mut self) -> Result<Self> {\n    if self.data_writer.is_some() {\n        unimplemented!();\n    } else {\n        self = await!(self.send(Answer::new(ResultCode::ServiceClosingControlConnection, \"Closing connection...\")))?;\n        self.writer.close()?;\n    }\n    Ok(self)\n}\n```", "```rs\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    match cmd {\n        Command::Mkd(path) => self = await!(self.mkd(path))?,\n        // …\n    }\n}\n```", "```rs\nuse std::fs::create_dir;\n\n#[async]\nfn mkd(mut self, path: PathBuf) -> Result<Self> {\n    let path = self.cwd.join(&path);\n    let parent = get_parent(path.clone());\n    if let Some(parent) = parent {\n        let parent = parent.to_path_buf();\n        let (new_self, res) = self.complete_path(parent);\n        self = new_self;\n        if let Ok(mut dir) = res {\n```", "```rs\n            if dir.is_dir() {\n                let filename = get_filename(path);\n                if let Some(filename) = filename {\n                    dir.push(filename);\n                    if create_dir(dir).is_ok() {\n                        self = await! \n               (self.send(Answer::new(ResultCode::PATHNAMECreated,\n               \"Folder successfully created!\")))?;\n                        return Ok(self);\n                    }\n                }\n            }\n        }\n    }\n    self = await!(self.send(Answer::new(ResultCode::FileNotFound,\n                                        \"Couldn't create folder\")))?;\n    Ok(self)\n}\n```", "```rs\nuse std::ffi::OsString;\n\nfn get_parent(path: PathBuf) -> Option<PathBuf> {\n    path.parent().map(|p| p.to_path_buf())\n}\n\nfn get_filename(path: PathBuf) -> Option<OsString> {\n    path.file_name().map(|p| p.to_os_string())\n}\n```", "```rs\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    match cmd {\n        Command::Rmd(path) => self = await!(self.rmd(path))?,\n        // …\n    }\n}\n```", "```rs\nuse std::fs::remove_dir_all;\n\n#[async]\nfn rmd(mut self, directory: PathBuf) -> Result<Self> {\n    let path = self.cwd.join(&directory);\n    let (new_self, res) = self.complete_path(path);\n    self = new_self;\n    if let Ok(dir) = res {\n        if remove_dir_all(dir).is_ok() {\n            self = await!(self.send(Answer::new(ResultCode::RequestedFileActionOkay,\n                                                \"Folder successfully removed\")))?;\n            return Ok(self);\n        }\n    }\n    self = await!(self.send(Answer::new(ResultCode::FileNotFound,\n                                        \"Couldn't remove folder\")))?;\n    Ok(self)\n}\n```"]