<html><head></head><body>
		<div><h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>A Quick Introduction to Rust</h1>
			<p><strong class="bold">Rust</strong> is growing in popularity, but it has a steep learning curve. By covering the basic rules around Rust, as well as learning how to manipulate a range of data types and variables, we will be able to write simple programs in the same fashion as dynamically-typed languages using a similar number of lines of code.</p>
			<p>The goal of this chapter is to cover the main differences between Rust and generic dynamic languages and to provide you with a quick understanding of how to utilize Rust. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Why is Rust revolutionary?</li>
				<li>Reviewing data types and variables in Rust</li>
				<li>Controlling variable ownership</li>
				<li>Building structs</li>
				<li>Metaprogramming with macros</li>
			</ul>
			<p>Once we have covered the main concepts in this chapter, you will be able to code basic programs in Rust that will run. You will also be able to debug your programs and understand the error messages that are thrown by the Rust compiler. As a result, you will have the foundations to be productive in Rust. You will also be able to move on to structuring Rust code over multiple files. </p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>For this chapter, we only need access to the internet as we will be using the online Rust playground to implement the code. The code examples provided can be run in the online Rust playground at <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>.</p>
			<p>For detailed instructions, please refer to the file found here: <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter01">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter01</a></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Why is Rust revolutionary?</h1>
			<p>With programming, there is usually a trade-off<a id="_idIndexMarker000"/> between speed and resources and development speed and safety. Low-level languages such as C/C++ can give the developer fine-grained control over the computer with fast code execution and minimal resource consumption. However, this is not free. Manual memory management can introduce bugs and security vulnerabilities. A simple example of this is a buffer overflow attack. This occurs when the programmer does not allocate enough memory. For instance, if the buffer only has a size of 15 bytes, and 20 bytes are sent, then the excess 5 bytes might be written past the boundary. An attacker can exploit this by passing in more bytes than the buffer can handle. This can potentially overwrite areas that hold executable code with their own code. There are other ways to exploit a program that does not have correctly managed memory. On top of increased vulnerabilities, it takes more code and time to solve a problem in a low-level language. As a result of this, C++ web frameworks do not take up a large share of web development. Instead, it usually makes sense to go for high-level languages such as Python, Ruby, and JavaScript. Using such languages will generally result in the developer solving problems safely and quickly. </p>
			<p>However, it must be noted that this memory safety comes at a cost. These high-level languages generally keep track of all the variables defined and their references to a memory address. When there are no more variables pointing to a memory address, the data in that memory address gets deleted. This process<a id="_idIndexMarker001"/> is called garbage collection and consumes extra resources and time as a program must be stopped to clean up the variables. </p>
			<p>With Rust, memory safety is ensured without the costly garbage collection process. Rust ensures memory safety through a set of ownership rules checked at compile time with a borrow checker. These rules are the quirks mentioned in the following section. Because of this, Rust enables rapid, safe problem-solving with truly performant code, thus breaking the speed/safety trade-off. </p>
			<p class="callout-heading">Memory safety</p>
			<p class="callout">Memory safety<a id="_idIndexMarker002"/> is the property of programs having memory pointers that always point to valid memory. </p>
			<p>With more data processing, traffic, and complex<a id="_idIndexMarker003"/> tasks lifted into the web stack, Rust, with its growing number of web frameworks and libraries, has now become a viable choice for web development. This has led to some truly amazing results in the web space for Rust. In 2020, Shimul Chowdhury ran a series of tests against servers with the same specs but different languages and frameworks. The results can be seen in the following figure:</p>
			<div><div><img src="img/Figure_1.1_B18722.jpg" alt="Figure 1.1 – Results of different frameworks and languages by Shimul Chowdhury (found at https://www.shimul.dev/posts/06-04-2020-benchmarking-flask-falcon-actix-web-rocket-nestjs/)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Results of different frameworks and languages by Shimul Chowdhury (found at https://www.shimul.dev/posts/06-04-2020-benchmarking-flask-falcon-actix-web-rocket-nestjs/)</p>
			<p>In the preceding figure, we can see that there are some variations in the languages and frameworks. However, we must note that the Rust frameworks comprise Actix Web and Rocket. These Rust servers are in a completely different league when it comes to total requests handled and data transferred. Other languages, such as Golang, have come onto the scene, but the lack of garbage collection in Rust has managed to outshine Golang. This was demonstrated in Jesse Howarth’s blog post <em class="italic">Why Discord is switching from Go to Rust</em>, where the following graph was published:</p>
			<div><div><img src="img/Figure_1.2_B18722.jpg" alt="Figure 1.2 – Discord’s findings =&gt; Golang is spikey and Rust is smooth (found at https://discord.com/blog/why-discord-is-switching-from-go-to-rust)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Discord’s findings =&gt; Golang is spikey and Rust is smooth (found at https://discord.com/blog/why-discord-is-switching-from-go-to-rust)</p>
			<p>The garbage collection<a id="_idIndexMarker004"/> that Golang was implementing to keep the memory safe resulted in 2-minute spikes. This is not to say that we should use Rust for everything. It is best practice to use the right tool for the job. All these languages have different merits. What we have done in the preceding figure is merely display Rust’s merits. </p>
			<p>The lack of need for garbage collection<a id="_idIndexMarker005"/> is because Rust uses enforced rules to ensure memory safety using the borrow checker. Now that we have understood why we want to code in Rust, we can move on to reviewing data types in the next section. </p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Reviewing data types and variables in Rust</h1>
			<p>If you have coded in another language<a id="_idIndexMarker006"/> before, you will have used variables<a id="_idIndexMarker007"/> and handled different data types. However, Rust does have some quirks that can put off developers. This is especially true if the developer has come from a dynamic language, as these quirks mainly revolve around memory management and reference to variables. These can be intimidating initially, but when you get to understand them, you will learn to appreciate them. Some people might hear about these quirks and wonder why they should bother with the language at all. This is understandable, but these quirks are why Rust is such a paradigm-shifting language. Working with borrow checking<a id="_idIndexMarker008"/> and wrestling with concepts such as lifetimes and references<a id="_idIndexMarker009"/> gives us the high-level memory safety of a dynamic language such as Python. However, we can also get memory safe low-level resources such as those delivered by C and C++. This means that we do not have to worry about dangling pointers, buffer overflows, null pointers, segmentation faults, data races, and other issues when coding in Rust. Issues such as null pointers and data races can be hard to debug. With this in mind, the rules enforced are a good trade-off as we must learn about Rust’s quirks to get the speed and control of non-memory safe languages, but we do not get the headaches these non-memory-safe languages introduce.</p>
			<p>Before we do any web development, we need to run our first program. We can do this in the Rust playground at <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>.</p>
			<p>If you have never visited the Rust playground before, you will see the following layout once you are there:</p>
			<pre class="source-code">
fn main() {
    println!("hello world");
}</pre>
			<p>The preceding code will look like the following screenshot when it comes to using the online Rust playground:</p>
			<div><div><img src="img/Figure_1.3_B18722.jpg" alt="Figure 1.3 – View of the online Rust playground"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – View of the online Rust playground</p>
			<p>In our <code>hello world</code> code, what we have<a id="_idIndexMarker010"/> is a <code>main</code> function, which is our entry point. This function<a id="_idIndexMarker011"/> fires when we run our program. All programs have entry points. If you have not heard of the concept before, due to coming from a dynamic language, the entry point is the script file that you point your interpreter at. For Python, a closer analogy would be the <code>main</code> block that runs if the file is directly run by the interpreter, denoted as follows:</p>
			<pre class="source-code">
if __name__ == "__main__":
    print("Hello, World!")</pre>
			<p>If you were to code in Python, you would probably see this used in a Flask application. Right now, we have not done anything new. This<a id="_idIndexMarker012"/> is a standard <em class="italic">Hello World</em> example with a little<a id="_idIndexMarker013"/> change in syntax; however, even with this example, the string that we are printing is not all that it seems. For instance, let us write our own function that accepts a string and prints it out with the following code:</p>
			<pre class="source-code">
fn print(message: str) {
    println!("{}", message);
}
fn main() {
    let message = "hello world";
    print(message);
}</pre>
			<p>This code should just work. We pass it into our function and print it. However, if we do print it, we get the following printout:</p>
			<pre class="console">
10 |     print(message);
   |           ^^^^^^^ doesn't have a size known at compile-time
   |
   = help: the trait `Sized` is not implemented for `str`
   = note: all function arguments must have a statically known size </pre>
			<p>This is not very straightforward, but it brings us to the first area we must understand if we are to code in Rust, and this is strings. Don’t worry, strings are the quirkiest variable that you need to get your head around to write functional Rust code. </p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Using strings in Rust</h2>
			<p>Before we explore the error<a id="_idIndexMarker014"/> in the previous<a id="_idIndexMarker015"/> section, let us rectify it, so we know what to work toward. We can get the <code>print</code> function to work without any errors with the following code:</p>
			<pre class="source-code">
fn print(message: String) {
    println!("{}", message);
}
fn main() {
    let message = String::from("hello world");
    print(message);
}</pre>
			<p>What we did was create a <code>String</code> from <code>"hello world"</code> and passed the <code>String</code> into the <code>print</code> function. This time<a id="_idIndexMarker016"/> the compiler<a id="_idIndexMarker017"/> did not throw an error because we always know the size of a <code>String</code>, so we can keep the right amount of memory free for it. This may sound counterintuitive because strings are usually of different lengths. It would not be a very flexible programming language if we were only allowed to use the same length of letters for every string in our code. This is because strings are essentially pointers implemented as a vector of bytes, which<a id="_idIndexMarker018"/>, in Rust, is denoted as <code>Vec&lt;u8&gt;</code>. This holds a reference<a id="_idIndexMarker019"/> to the string content (<code>str</code>, also known as a string slice) in the heap memory, as seen in the following figure:</p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><img src="img/Figure_1.4_B18722.png" alt=""/> </p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – A string’s relationship to str “one”</p>
			<p>We can see, in <em class="italic">Figure 1</em><em class="italic">.4</em>, that a string<a id="_idIndexMarker020"/> is a vector of three numbers. One is the actual memory<a id="_idIndexMarker021"/> address of the <code>str</code> it is referencing. The second number is the size of the memory allocated, and the third is the length of the string content. Therefore, we can access string literals in our code without having to pass variables of various sizes around our code. We know that <code>String</code> has a set size and, therefore, can allocate this size in the <code>print</code> function. It also must be noted that <code>String</code> is on the stack memory while our string literal is on the heap memory. Considering that we know that <code>String</code> has a set size while our string literal varies, we can deduce that the stack memory is used for predictable memory sizes and is allocated ahead of time when the program runs. Our heap memory is dynamic, and therefore memory is allocated when it is needed. Now that we know the basics of strings, we can use the different ways in which they are created, as seen in the following code:</p>
			<pre class="source-code">
    let string_one = "hello world".to_owned();
    let string_two = "hello world".to_string();
    let string_three = string_two.clone();</pre>
			<p>We must note, however, that creating <code>string_three</code> is expensive as we must copy the underlying data in the heap, and heap operations are expensive. This is not a unique quirk of Rust. In our example, we are just experiencing what happens under the hood. For instance, if we alter strings in Python, we will have different outcomes: </p>
			<pre class="source-code">
# slower method 
data = ["one", "two", "three", "four"]
string = ""
for i in data:
    string += i   
# faster method
"".join(data)</pre>
			<p>Looping through and adding the strings is slower because Python must allocate new memory and copy the entire string to that new memory address. The <code>join</code> method is faster because Python can allocate the memory of all the data of the list and then copy over the strings in the array, meaning the string must only be copied once. This shows us that although high-level languages like Python may not force you to think about the memory allocation of strings, you will still end up paying the price if you don’t acknowledge it. </p>
			<p>We can also pass a string literal into the <code>print</code> function by borrowing it, as seen in the following code:</p>
			<pre class="source-code">
fn print(message: &amp;str) {
    println!("{}", message);
}
fn main() {
    print(&amp;"hello world");
}</pre>
			<p>The borrow is denoted by <code>&amp;</code>. We will go into borrowing later in the chapter. For now, however, we can deduce that the borrow is only a fixed-size reference to a variable-sized string slice. If the borrow <a id="_idIndexMarker022"/>was a fixed size, we would not be able to pass it into the <code>print</code> function<a id="_idIndexMarker023"/> because we would not know the size. At this point, we can comfortably use strings in Rust productively. The next concept that we must understand before we start writing Rust programs is integers and floats. </p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Using integers and floats</h2>
			<p>In most high-level web<a id="_idIndexMarker024"/> programming languages, we merely<a id="_idIndexMarker025"/> assign a float or integer to a variable name and move on with the program. However, from what we have been exposed to in the previous section on strings, we now understand that we must worry about memory size when using strings in Rust. This is no different with integers and floats. We know that integers and floats have a range of sizes. Therefore, we must tell Rust what we are passing around our code. Rust supports signed integers, which are denoted by <code>i</code>, and unsigned integers, which are denoted by <code>u</code>. These integers consist of 8, 16, 32, 64, and 128 bits. Exploring the math behind numbers being represented in binary is not relevant for this book; however, we do need to understand the range of numbers that can be represented with several bits, as this will help us understand<a id="_idIndexMarker026"/> what the different types of floats and integers<a id="_idIndexMarker027"/> in Rust denote. Because binary is either a 0 or a 1, we can calculate the range of integers that can be represented by the bits by raising 2 to the power of the number of bits we have. For example, if we have an integer that is represented by 8 bits, 2 to the power of 8 equates to 256. We must remember that 0 is also represented. Considering this, an integer of 8 bits has a range of 0 to 255. We can test this calculation with the following code:</p>
			<pre class="source-code">
let number: u8 = 256;</pre>
			<p>This is one higher than the range that we calculated. As a result, we should not be surprised to see the overflow error as follows:</p>
			<pre class="console">
the literal `256` does not fit into the type 
`u8` whose range is `0..=255`</pre>
			<p>So, we can deduce that if we lower the unsigned integer to <code>255</code>, it will pass. However, let’s say we change the unsigned integer into a signed integer with the following code:</p>
			<pre class="source-code">
let number: i8 = 255;</pre>
			<p>We will see that we get a helpful error message as follows:</p>
			<pre class="console">
the literal `255` does not fit into the type 
`i8` whose range is `-128..=127`</pre>
			<p>With this helpful error message, we can see that a signed integer considers negative numbers, so the absolute value that a signed integer can take is roughly half. Therefore, we can increase the range by assigning the number as a 16-bit signed integer with the following code:</p>
			<pre class="source-code">
let number: i16 = 255;</pre>
			<p>This would work. However, let us add our 16-bit integer with our 8-bit integer using the following code:</p>
			<pre class="source-code">
let number = 255i16;
let number_two = 5i8;
let result = number + number_two;</pre>
			<p>The previous code might look a little different to you. All we have done in the preceding code is define the data type with a suffix instead. So, <code>number</code> has a value of <code>255</code> and a type of <code>i16</code>, and <code>number_two</code> has a value of <code>5</code> and a type of <code>i8</code>. If we run the previous code, we get the following error:</p>
			<pre class="console">
11 |     let result = number + number_two;
   |                         ^ no implementation for `i16 + i8`
   |
   = help: the trait `Add&lt;i8&gt;` is not implemented for `i16`</pre>
			<p>We will cover traits<a id="_idIndexMarker028"/> later in this chapter. For now, all we must<a id="_idIndexMarker029"/> understand is that we cannot add the two different integers. If they were both the same type, then we could. We can change the integer type through casting using <code>as</code>, as seen in the following line of code:</p>
			<pre class="source-code">
 let result = number + number_two as i16;</pre>
			<p>This means that <code>number_two</code> is now a 16-bit integer, and <code>result</code> will be 260. However, we must be careful with casting because if we were to do it the wrong way, we could end up with a silent bug, which is unusual for Rust. If we cast <code>number</code> as <code>i8</code> instead of casting <code>number_two</code> as <code>i16</code>, then <code>result</code> would equate to 4, which does not make sense because 255 + 5 equals 260. This is because <code>i8</code> is smaller than <code>i16</code>. So, if we cast an <code>i16</code> integer as an <code>i8</code> integer, we are essentially chopping off some of the data, by just taking the lower bits of the number and disregarding the upper bits. Therefore, <code>number</code> ends up being -1 if we cast it to an <code>i8</code> integer. To be safer, we can use the <code>i8::from</code> function, as seen in the following code:</p>
			<pre class="source-code">
let result = i8::from(number) + number_two;</pre>
			<p>Running this will give us the following error:</p>
			<pre class="console">
let result = i8::from(number) + number_two;
|                  ^^^^^^^^ the trait `From&lt;i16&gt;` is not 
                            implemented for `i8`</pre>
			<p>Again, we will go over traits later on in the chapter, but we can see in the preceding code that because the <code>From&lt;i16&gt;</code> trait is not implemented for an <code>i8</code> integer, we cannot cast an <code>i8</code> integer into an <code>i16</code> integer. With this understood, we are free to work with integers safely and productively. One last point about integer sizes in Rust is that they are not continuous. The supported sizes are shown in the following table:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Bits</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Calculation</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Size</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>8</p>
						</td>
						<td class="No-Table-Style">
							<p>2^8</p>
						</td>
						<td class="No-Table-Style">
							<p>256</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>16</p>
						</td>
						<td class="No-Table-Style">
							<p>2^16</p>
						</td>
						<td class="No-Table-Style">
							<p>65536</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>32</p>
						</td>
						<td class="No-Table-Style">
							<p>2^32</p>
						</td>
						<td class="No-Table-Style">
							<p>4294967296</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>64</p>
						</td>
						<td class="No-Table-Style">
							<p>2^64</p>
						</td>
						<td class="No-Table-Style">
							<p>1.8446744e+19</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>128</p>
						</td>
						<td class="No-Table-Style">
							<p>2^128</p>
						</td>
						<td class="No-Table-Style">
							<p>3.4028237e+38</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1 – Size of integer types</p>
			<p>When it comes to floats, Rust accommodates <code>f32</code> and <code>f64</code> floating-point numbers. Both these floating-point types support negative and positive values. Declaring a floating-point variable requires the same syntax as integers, as seen in the following code:</p>
			<pre class="source-code">
let float: f32 = 2.6;</pre>
			<p>With this, we can comfortably work<a id="_idIndexMarker030"/> with integers and floats in our Rust code. However, we know as developers<a id="_idIndexMarker031"/> that just declaring floats and integers is not very useful. We want to be able to contain and loop through them. In the next section, we will do just that with vectors and arrays. </p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Storing data in vectors and arrays</h2>
			<p>In Rust, we can store<a id="_idIndexMarker032"/> our floats, integers, and strings<a id="_idIndexMarker033"/> in arrays and vectors. First, we<a id="_idIndexMarker034"/> will focus<a id="_idIndexMarker035"/> on arrays. Arrays are stored on stack memory. Knowing this, and remembering what we learned about strings, we can deduce that arrays are of a fixed size. This is because, as we remember, if the variable is stored on the stack, then the memory is allocated and loaded into the stack when the program starts. We can define an array of integers, loop through it, print each integer, and then access an integer by index with the following code:</p>
			<pre class="source-code">
fn main() {
    let int_array: [i32; 3] = [1, 2, 3];
    for i in int_array {
        println!("{}", i);
    }
    println!("{}", int_array[1]);
}</pre>
			<p>With the previous code, we define<a id="_idIndexMarker036"/> the type and size by wrapping<a id="_idIndexMarker037"/> them in square<a id="_idIndexMarker038"/> brackets. For instance, if we were going<a id="_idIndexMarker039"/> to create an array of floats with a length of 4, we would use <code>int_array: [f32; 4] = [1.1, 2.2, 3.3, 4.4]</code>. Running the preceding code will give you the following printout:</p>
			<pre class="console">
1
2
3
2</pre>
			<p>In the preceding printout, we see that the loop works and that we can access the second integer with square brackets. Although the memory size of the array is fixed, we can still change it. This is where mutability comes in. When we define a variable as mutable, this means that we can mutate it. In other words, we can alter the value of the variable after it has been defined if it is mutable. If you tried to update any of the variables in the code that we have written in this chapter, you will have realized that you can’t. This is because all variables in Rust are immutable by default. We can make any variable in Rust mutable by putting a <code>mut</code> tag in front of the variable name. Going back to the fixed array, we cannot change the size of the array, meaning we cannot append/push new integers to it due to it being stored on stack memory. However, if we define a mutable array, we can update parts of it with other integers that are the same memory size. An example of this is the following code:</p>
			<pre class="source-code">
fn main() {
    let mut mutable_array: [i32; 3] = [1, 2, 0];
    mutable_array[2] = 3;
    println!("{:?}", mutable_array);
    println!("{}", mutable_array.len());
}</pre>
			<p>In the preceding<a id="_idIndexMarker040"/> code, we can see that the last integer<a id="_idIndexMarker041"/> in our array<a id="_idIndexMarker042"/> is updated to <code>3</code>. We then print <a id="_idIndexMarker043"/>out the full array and then print out the length. You may have also noted that the first print statement of the preceding code now employs <code>{:?}</code>. This calls the <code>Debug</code> trait. If <code>Debug</code> is implemented for the thing that we are trying to print, then the full representation of the thing we are printing is then displayed in the console. You can also see that we print out the result of the length of the array. Running this code will give the following printout:</p>
			<pre class="console">
[1, 2, 3]
3</pre>
			<p>With the preceding printout, we can confirm that the array is now updated. We can also access slices with our arrays. To demonstrate this, we can create an array of 100 zeros. We can then take a slice of this and print it out with the following code:</p>
			<pre class="source-code">
fn main() {
    let slice_array: [i32; 100] = [0; 100];
    println!("length: {}", slice_array.len());
    println!("slice: {:?}", &amp;slice_array[5 .. 8]);
}</pre>
			<p>Running the preceding code will result in the following printout:</p>
			<pre class="console">
length: 100
slice: [0, 0, 0]</pre>
			<p>We are now able to be productive with arrays. Arrays can be useful for caching. For instance, if we know the amount that we need to store, then we can use arrays effectively. However, we have only managed to store one type of data in the array. If we tried to store strings and integers in the same array, we would have a problem. How would we define the type? This problem<a id="_idIndexMarker044"/> goes for all collections, such as vectors and <strong class="bold">HashMaps</strong>. There are multiple ways to do this, but the most straightforward is using enums. Enums are, well, enums. In dynamic languages such as Python, you may not have had to use them due to being able to pass any type anywhere you want. However, they are still available. Enum is short for enumerated<a id="_idIndexMarker045"/> type and basically defines<a id="_idIndexMarker046"/> a type with possible<a id="_idIndexMarker047"/> variants. In our case, we want<a id="_idIndexMarker048"/> our array to store strings and integers in the same collection. We can do this by initially defining our enum with the following code:</p>
			<pre class="source-code">
enum SomeValue {
    StringValue(String),
    IntValue(i32)
}</pre>
			<p>In the preceding code, we can see that we defined an enum with the name of <code>SomeValue</code>. We then denoted that <code>StringValue</code> holds the value of a string and that <code>IntValue</code> holds the value of an integer. We can then define an array with a length of <code>4</code>, consisting of 2 strings and 2 integers, with the following code:</p>
			<pre class="source-code">
    let multi_array: [SomeValue; 4] = [
        SomeValue::StringValue(String::from("one")),
        SomeValue::IntValue(2),
        SomeValue::StringValue(String::from("three")),
        SomeValue::IntValue(4)
    ];</pre>
			<p>In the preceding code, we can see that we wrap our strings and integers in our enum. Now, looping through and getting it out is going to be another task. For instance, there are things that we can do to an integer that we cannot do to a string and vice versa. Considering this, we are going to have to use a <code>match</code> statement when looping through the array, as seen in the following code:</p>
			<pre class="source-code">
    for i in multi_array {
        match i {
            SomeValue::StringValue(data) =&gt; {
                println!("The string is: {}", data);
            },
            SomeValue::IntValue(data) =&gt; {
                println!("The int is: {}", data);
            }
        }
    }</pre>
			<p>In the preceding code, we can see that if <code>i</code> is <code>SomeValue::StringValue</code>, we then assign<a id="_idIndexMarker049"/> the data<a id="_idIndexMarker050"/> wrapped in <code>SomeValue::StringValue</code> to the variable<a id="_idIndexMarker051"/> named <code>data</code>. We then pass <code>data</code> into the inner<a id="_idIndexMarker052"/> scope to be printed. We use the same approach with our integer. Even though we are merely printing to demonstrate the concept, we can do anything in these inner scopes to the <code>data</code> variable that the type allows us to. Running the preceding code gives the following printout:</p>
			<pre class="console">
The string is: one
The int is: 2
The string is: three
The int is: 4</pre>
			<p>Using enums to wrap data and <code>match</code> statements to handle them can be applied to HashMaps and vectors. Also, what we have covered with arrays can be applied to vectors. The only difference is that we do not have to define the length and that we can increase the size of the vector if needed. To demonstrate this, we can create a vector of strings and then add a string to the end with the following code:</p>
			<pre class="source-code">
    let mut string_vector: Vec&lt;&amp;str&gt; = vec!["one", "two", 
        "three"];
    println!("{:?}", string_vector);
    string_vector.push("four");
    println!("{:?}", string_vector);</pre>
			<p>In the preceding code, we can see that we use the <code>vec!</code> macro to create the vector of strings. You may have noticed with macros such as <code>vec!</code> and <code>println!</code> that we can vary the number of inputs. We will cover macros later in the chapter. Running the preceding code will result in the following printout:</p>
			<pre class="console">
["one", "two", "three"]
["one", "two", "three", "four"]</pre>
			<p>We can also create an empty vector with the <code>new</code> function from the <code>Vec</code> struct with <code>let _empty_vector: Vec&lt;&amp;str&gt; = Vec::new();</code>. You may be wondering when to use vectors and when to use arrays. Vectors are more flexible. You may be tempted to reach for arrays for performance gains. At face value, this seems logical as it is stored in the stack. Accessing the stack is going to be quicker because the memory sizes can be computed at compile time, making the allocation and deallocation simpler compared to the heap. However, because it is on the stack it cannot outlive the scope that it is allocated. Moving a vector around would merely require moving a pointer around. However, moving an array requires copying the whole array. Therefore, copying fixed-size arrays is more expensive<a id="_idIndexMarker053"/> than moving a vector. If you have a small<a id="_idIndexMarker054"/> amount of data that you only need<a id="_idIndexMarker055"/> in a small scope and you know<a id="_idIndexMarker056"/> the size of the data, then reaching for an array does make sense. However, if you’re going to be moving the data around, even if you know the size of the data, using vectors is a better choice. Now that we can be productive with basic collections, we can move on to a more advanced collection, a HashMap. </p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Mapping data with HashMaps</h2>
			<p>In some other languages, HashMaps <a id="_idIndexMarker057"/>are referred to<a id="_idIndexMarker058"/> as dictionaries. They have a key<a id="_idIndexMarker059"/> and a value. We can insert and get values using the key. Now that we have learned about handling collections, we can get a little more adventurous in this section. We can create a simple profile of a game character. In this character profile, we are going to have a name, age, and a list of items that they have. This means that we need an enum that houses a string, an integer, and a vector that also houses strings. We will want to print out the complete HashMap to see whether our code is correct in one glance. To do this, we are going to implement the <code>Debug</code> trait for our enum, as seen in the following code:</p>
			<pre class="source-code">
#[derive(Debug)]
enum CharacterValue {
    Name(String),
    Age(i32),
    Items(Vec&lt;String&gt;)
}</pre>
			<p>In the preceding code, we can<a id="_idIndexMarker060"/> see that we have annotated our enum with the <code>derive</code> attribute. An attribute<a id="_idIndexMarker061"/> is metadata that can be applied to the <code>CharacterValue</code> enum in this case. The <code>derive</code> attribute tells the compiler to provide a basic implementation of a trait. So, in the preceding code, we are telling the compiler to apply the basic implementation of <code>Debug</code> to the <code>CharacterValue</code> enum. With this, we can then create a new HashMap that has keys pointing to the values we defined with the following code:    </p>
			<pre class="source-code">
use std::collections::HashMap;
fn main() {
    let mut profile: HashMap&lt;&amp;str, CharacterValue&gt; = 
                     HashMap::new();
}</pre>
			<p>We stated that it is mutable because we are going to insert values with the following code:</p>
			<pre class="source-code">
profile.insert("name", CharacterValue::Name("Maxwell".to_string()));
profile.insert("age", CharacterValue::Age(32));
profile.insert("items", CharacterValue::Items(vec![
    "laptop".to_string(),
    "book".to_string(),
    "coat".to_string()
]));
println!("{:?}", profile);</pre>
			<p>We can see that we have inserted all the data that we need. Running this would give us the following printout:</p>
			<pre class="console">
{"items": Items(["laptop", "book", "coat"]), "age": Age(32), 
"name": Name("Maxwell")}</pre>
			<p>In the preceding output, we can see<a id="_idIndexMarker062"/> that our data is correct. Inserting<a id="_idIndexMarker063"/> it is one thing; however, we now must get it out again. We can do this with a <code>get</code> function. The <code>get</code> function returns an <code>Option</code> type. The <code>Option</code> type returns either <code>Some</code> or <code>None</code>. So, if we were to get <code>name</code> from our HashMap, we would need to do two matches, as seen in the following code:</p>
			<pre class="source-code">
    match profile.get("name") {
        Some(value_data) =&gt; {
            match value_data {
                CharacterValue::Name(name) =&gt; {
                    println!("the name is: {}", name);
                },
                _ =&gt; panic!("name should be a string") 
            }
        },
        None =&gt; {
            println!("name is not present");
        }
    }</pre>
			<p>In the preceding code, we can check to see if there is a name in the keys. If there is not, then we just print out that it was not present. If the <code>name</code> key is present, we then move on to our second check, which prints out the name if it is <code>CharacterValue::Name</code>. However, there is something wrong if the <code>name</code> key is not housing  <code>CharacterValue::Name</code>. So, we add only one more check in <code>match</code>, which is <code>_</code>. This is a catch meaning <code>anything else</code>. We are not interested in anything other than <code>CharacterValue::Name</code>. Therefore, the <code>_</code> catch maps to a <code>panic!</code> macro, which essentially throws an error. We could make this shorter. If we know that the <code>name</code> key is going to be in the HashMap, we can employ the <code>unwrap</code> function with the following code:             </p>
			<pre class="source-code">
    match profile.get("name").unwrap() {
        CharacterValue::Name(name) =&gt; {
            println!("the name is: {}", name);
        }, 
        _ =&gt; panic!("name should be a string") 
    }</pre>
			<p>The <code>unwrap</code> function directly exposes the result. However, if the result is <code>None</code>, then it will directly result in an error terminating the program, which would look like the following printout:</p>
			<pre class="console">
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value'</pre>
			<p>This might seem risky, but in practice, you will end up using the <code>unwrap</code> function a lot because you need direct<a id="_idIndexMarker064"/> access to the result, and you cannot carry<a id="_idIndexMarker065"/> on the program without it anyway. A prime example is connecting to a database. In a lot of web programming, if the database connection is not successful, then you cannot carry on with the API call. Therefore, it makes sense to just allow an error like most other web languages would. Now that we have been exposed to errors terminating the program, we might as well learn how to handle errors in the next section. </p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Handling results and errors</h2>
			<p>In the previous section, we learned<a id="_idIndexMarker066"/> that directly<a id="_idIndexMarker067"/> unwrapping <code>Option</code> resulting in <code>None</code> panics a thread. There is another outcome that can also throw an error if unsuccessfully unwrapped, and this is <code>Result</code>. The <code>Result</code> type can return either <code>Ok</code> or <code>Err</code>. To demonstrate this, we can create a basic function that returns a <code>Result</code> type based on a simple Boolean we pass into it with the following code:</p>
			<pre class="source-code">
fn error_check(check: bool) -&gt; Result&lt;i8, &amp;'static str&gt; {
    if check {
        Err("this is an error")
        } 
    else {
        Ok(1)
    }
}</pre>
			<p>In the preceding code, we can<a id="_idIndexMarker068"/> see that we return <code>Result&lt;i8, &amp;'static str&gt;</code>. This means<a id="_idIndexMarker069"/> that we return an integer if <code>Result</code> is <code>Ok</code>, or we return an integer if <code>Result</code> is <code>Err</code>. The <code>&amp;'static str</code> variable is basically our error string. We can tell it’s a reference because of <code>&amp;</code>. The <code>'static</code> part means that the reference is valid for the entire lifetime of the running program. If this does not make sense now, do not worry, we will be covering lifetimes later in the chapter. Now that we have created our error-checking function, we can test to see what these outcomes look like with the following code:</p>
			<pre class="source-code">
fn main() {
    println!("{:?}", error_check(false));
    println!("{:?}", error_check(false).is_err());
    println!("{:?}", error_check(true));
    println!("{:?}", error_check(true).is_err());
}</pre>
			<p>Running the preceding code gives us the following printout:</p>
			<pre class="console">
Ok(1)
false
Err("this is an error")
true</pre>
			<p>In the preceding output, we can see that it returned exactly what we wanted. We can also note that we can run the <code>is_err()</code> function on the <code>Result</code> variable, resulting in <code>false</code> if returning <code>Ok</code> or <code>true</code> if returning <code>Err</code>. We can also directly unwrap but add extra tracing to the stack trace with the following <code>expect</code> function:</p>
			<pre class="source-code">
let result: i8 = error_check(true).expect("this has been caught");</pre>
			<p>The preceding function will result in the following printout:</p>
			<pre class="console">
thread 'main' panicked at 'this has been caught: "this is an error"'</pre>
			<p>Through the preceding example, we can see that we get the message from the <code>expect</code> function first, and then the error message returned in <code>Result</code>. With this understanding, we can throw, handle, and add extra tracing to errors. However, we are<a id="_idIndexMarker070"/> getting more exposed to lifetimes<a id="_idIndexMarker071"/> and borrow references as we move forward. Now is the time to address this by understanding variable ownership. </p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Controlling variable ownership</h1>
			<p>As we remember from the beginning<a id="_idIndexMarker072"/> of the chapter, Rust does not have a garbage collector. However, it has memory safety. It achieves this by having strict rules around variable ownership. These rules are enforced when Rust is being compiled. If you are coming<a id="_idIndexMarker073"/> from a dynamic language, then this can initially lead to frustration. This is known as <em class="italic">fighting the borrow checker</em>. Sadly, this unjustly gives Rust the false <em class="italic">steep learning curve</em> reputation, as when you are fighting the borrow checker without knowing what is going on, it can seem like an impossible task to get even the most basic programs written. However, if we take the time to learn the rules before we try and code anything too complex, the knowledge of the rules and the helpfulness of the compiler will make writing code in Rust fun and rewarding. Again, I take the time to remind you that Rust has been the most favorited language 7 years in a row. This is not because it’s impossible to get anything done in it. The people who vote for Rust in these surveys understand the rules around ownership. Rust’s compiling, checking, and enforcing of these rules protect against the following errors:</p>
			<ul>
				<li><strong class="bold">Use after frees</strong>: This occurs when memory is accessed<a id="_idIndexMarker074"/> once it has been freed, which can cause crashes. It can also allow hackers to execute code via this memory address.</li>
				<li><strong class="bold">Dangling pointers</strong>: This occurs when a reference points<a id="_idIndexMarker075"/> to a memory address that no longer houses the data that the pointer was referencing. Essentially, this pointer now points to null or random data.</li>
				<li><strong class="bold">Double frees</strong>: This occurs when allocated memory<a id="_idIndexMarker076"/> is freed and then freed again. This can cause the program to crash and increases the risk of sensitive data being revealed. This also enables a hacker to execute arbitrary code.</li>
				<li><strong class="bold">Segmentation faults</strong>: This occurs when the program<a id="_idIndexMarker077"/> tries to access the memory it’s not allowed to access.</li>
				<li><strong class="bold">Buffer overrun</strong>: An example of this error is reading<a id="_idIndexMarker078"/> off the end of an array. This can cause the program to crash.</li>
			</ul>
			<p>To protect against these errors and thus achieve memory safety, Rust enforces the following rules:</p>
			<ul>
				<li>Values are owned by the variables assigned to them </li>
				<li>As soon as the variable moves out of the scope of where it was defined, it is then deallocated from the memory</li>
				<li>Values can be referenced and altered if we adhere to the rules for copying, moving, immutable borrowing, and mutable borrowing </li>
			</ul>
			<p>Knowing the rules<a id="_idIndexMarker079"/> is one thing but, to practically work with the rules in Rust code, we need to understand copying, moving, and borrowing in more detail. </p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Copying variables</h2>
			<p>Copying<a id="_idIndexMarker080"/> occurs when a value is copied. Once it has been copied, the new variable owns the value, while the existing variable also owns its own value. </p>
			<div><div><img src="img/Figure_1.5_B18722.jpg" alt="Figure 1.5 – Variable copy path"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Variable copy path</p>
			<p>In <em class="italic">Figure 1</em><em class="italic">.5</em>, we can see that the path of <code>copy</code> trait, then it will automatically be copied, as seen in the following code:</p>
			<pre class="source-code">
let one: i8 = 10;
let two: i8 = one + 5;
println!("{}", one);
println!("{}", two);</pre>
			<p>Running the preceding code will give us the following printout:</p>
			<pre class="console">
10
15</pre>
			<p>In the preceding example, we appreciate that the very fact that variables <code>one</code> and <code>two</code> can be printed indicates that <code>one</code> has been copied for <code>two</code> to utilize. To test this, we can test our example with strings using the following code:</p>
			<pre class="source-code">
let one = "one".to_string();
let two = one;
println!("{}", one);
println!("{}", two);</pre>
			<p>Running this code will result in the following error:</p>
			<pre class="console">
move occurs because `one` has type `String`, which does not implement the `Copy` trait</pre>
			<p>Because strings do not implement<a id="_idIndexMarker081"/> the <code>Copy</code> trait, the code does not work, as <code>one</code> was moved to <code>two</code>. However, the code will run if we get rid of <code>println!("{}", one);</code>. This brings us to the next concept that we must understand: moving.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Moving variables</h2>
			<p>Moving refers to when<a id="_idIndexMarker082"/> the value is moved from one variable to another. However, unlike copying, the original variable no longer owns the value.</p>
			<p class="IMG---Figure"><img src="img/Figure_1.6_B18722.png" alt="Figure 1.6 – Variable move path"/></p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Variable move path</p>
			<p>From what we can see in <em class="italic">Figure 1</em><em class="italic">.6</em>, <code>one</code> can no longer be accessed once it’s moved to <code>two</code>. To really establish<a id="_idIndexMarker083"/> what is going on here and how strings are affected, we can set up some code designed to fail as follows:</p>
			<pre class="source-code">
let one: String = String::from("one");
let two: String = one + " two";
println!("{}", two);
println!("{}", one);</pre>
			<p>Running the preceding code gives the following error:</p>
			<pre class="console">
let one: String = String::from("one");
    --- move occurs because `one` has type 
    `String`, which does not implement the 
    `Copy` trait
let two: String = one + " two";
                  ------------ `one` moved due to usage in operator
println!("{}", two);
println!("{}", one);
               ^^^ value borrowed here after move</pre>
			<p>As we can see, the compiler has been helpful here. It shows us where the string was moved to and where the value of that string is borrowed. So, we can make the code run instantly by merely removing the <code>println!("{}", one);</code> line. However, we want to be able to use that <code>print</code> function at the bottom of the preceding code block. We should not have to constrain the functionality of the code due to the rules implemented by Rust. We can solve this by using the <code>to_owned</code> function with the following code:</p>
			<pre class="source-code">
let two: String = one.to_owned() + " two";</pre>
			<p>The <code>to_owned</code> function is available because strings implement the <code>ToOwned</code> trait. We will cover traits later in the chapter, so do not halt your reading if you do not know what this means yet. We could have used <code>clone</code> on the string. We must note that <code>to_owned</code> is a generalized implementation of <code>clone</code>. However, it does not really matter which approach we use. It is understandable to wonder why strings do not have the <code>Copy</code> trait. This is because the string is a pointer to a string literal. If we were to copy strings, we would have multiple unconstrained pointers to the same string literal data, which would be dangerous. Because of this, we can explore the move concept using strings. If we force our string outside of the scope with a function, we can see how this affects our move. This can be done with the following code:</p>
			<pre class="source-code">
fn print(value: String) {
    println!("{}", value);
}
fn main() {
    let one = "one".to_string();
    print(one);
    println!("{}", one);
}</pre>
			<p>If we run the preceding code, we will get an error stating that the <code>print</code> function moved the <code>one</code> value. As a result, the <code>println!("{}", one);</code> line borrows <code>one</code> after it is moved into the <code>print</code> function. The key part<a id="_idIndexMarker084"/> of this message is the word <em class="italic">borrow</em>. To understand what is going on, we need to explore the concept of immutable borrowing.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Immutable borrowing of variables</h2>
			<p>An immutable borrow<a id="_idIndexMarker085"/> occurs when a variable can be referenced<a id="_idIndexMarker086"/> by another variable without having to clone or copy it. This essentially solves our problem. If the borrowed variable falls out of scope, then it is not deallocated from the memory and the original reference to the value can still be used.</p>
			<div><div><img src="img/Figure_1.7_B18722.jpg" alt="Figure 1.7 – Immutable borrow path"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Immutable borrow path</p>
			<p>We can see in <em class="italic">Figure 1</em><em class="italic">.7</em> that <code>two</code> borrows the value<a id="_idIndexMarker087"/> from <code>one</code>. It must be noted that when <code>one</code> is borrowed from, <code>one</code> is locked and cannot be accessed until the borrow is finished. To perform a borrow operation, we merely apply a prefix with <code>&amp;</code>. This can be demonstrated with the following code:</p>
			<pre class="source-code">
fn print(value: &amp;String) {
    println!("{}", value);
}
fn main() {
    let one = "one".to_string();
    print(&amp;one);
    println!("{}", one);
}</pre>
			<p>In the preceding code, we can see<a id="_idIndexMarker088"/> that our immutable borrow enables us to pass a string into the <code>print</code> function and still print<a id="_idIndexMarker089"/> it afterward. This can be confirmed with the following printout:</p>
			<pre class="console">
one
one</pre>
			<p>From what we see in our code, the immutable borrow that we performed can be demonstrated in <em class="italic">Figure 1</em><em class="italic">.8</em>. </p>
			<div><div><img src="img/Figure_1.8_B18722.jpg" alt="Figure 1.8 – Immutable borrow in relation to the print function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Immutable borrow in relation to the print function</p>
			<p>In the preceding figure, we can see that <code>one</code> is not available when the <code>print</code> function is running. We can demonstrate this with the following code:</p>
			<pre class="source-code">
fn print(value: &amp;String, value_two: String) {
    println!("{}", value);
    println!("{}", value_two);
}
fn main() {
    let one = "one".to_string();
    print(&amp;one, one);
    println!("{}", one);
}</pre>
			<p>If we run the preceding code, we will get the following error:</p>
			<pre class="console">
print(&amp;one, one);
----- ----  ^^^ move out of `one` occurs here
|     |
|     borrow of `one` occurs here
borrow later used by call</pre>
			<p>We can see that we cannot utilize <code>one</code> even though it is utilized in the <code>print</code> function after <code>&amp;one</code>. This is because<a id="_idIndexMarker090"/> the lifetime of <code>&amp;one</code> is throughout the entire lifetime<a id="_idIndexMarker091"/> of the <code>print</code> function. Thus, we can conclude that <em class="italic">Figure 1</em><em class="italic">.8</em> is correct. However, we can run one more experiment. We can change <code>value_one</code> to a borrow to see what happens with the following code:</p>
			<pre class="source-code">
fn print(value: &amp;String, value_two: &amp;String) {
    println!("{}", value);
    println!("{}", value_two);
}
fn main() {
    let one = "one".to_string();
    print(&amp;one, &amp;one);
    println!("{}", one);
}</pre>
			<p>In the preceding code, we can see that we do two immutable borrows of <code>one</code>, and the code runs. This highlights <a id="_idIndexMarker092"/>an important fact: we can make as many immutable borrows<a id="_idIndexMarker093"/> as we like. However, what happens if the borrow is mutable? To understand, we must explore mutable borrows.   </p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Mutable borrowing of variables</h2>
			<p>A mutable borrow<a id="_idIndexMarker094"/> is essentially the same as an immutable<a id="_idIndexMarker095"/> borrow, except that the borrow is mutable. Therefore, we can change the borrowed value. To demonstrate this, we can create a <code>print</code> statement that will alter the borrowed value before printing it. We then print it in the <code>main</code> function to establish that the value has been changed with the following code:</p>
			<pre class="source-code">
fn print(value: &amp;mut i8) {
     value += 1;
    println!("In function the value is: {}", value);
}
fn main() {
    let mut one: i8 = 5;
    print(&amp;mut one);
    println!("In main the value is: {}", one);
}</pre>
			<p>Running the preceding code will give us the following printout:</p>
			<pre class="console">
In function the value is: 6
In main the value is: 6</pre>
			<p>The preceding output proves that <code>one</code> is <code>6</code> even after the lifetime of the mutable reference in the <code>print</code> function has expired. We can see that in the <code>print</code> function, we update the value of <code>one</code> using a <code>*</code> operator. This is called a dereference operator. This dereference operator<a id="_idIndexMarker096"/> exposes the underlying value so it can be operated. This all seems<a id="_idIndexMarker097"/> straightforward, but is it exactly like our immutable references? If we remember, we could have multiple immutable references. We can put this to the test with the following code:</p>
			<pre class="source-code">
fn print(value: &amp;mut i8, value_two: &amp;mut i8) {
     value += 1;
    println!("In function the value is: {}", value);
     value_two += 1;
}
fn main() {
    let mut one: i8 = 5;
    print(&amp;mut one, &amp;mut one);
    println!("In main the value is: {}", one);
}</pre>
			<p>In the preceding code, we can see that we make two mutable references and pass them through, just like in the previous section, but with immutable references. However, running it gives us the following error:</p>
			<pre class="console">
error[E0499]: cannot borrow `one` as mutable more than once at a time</pre>
			<p>Through this example, we can confirm that we cannot have more than one mutable reference at a time. This prevents data races and has given Rust the <em class="italic">fearless concurrency</em> tag. With what we have covered here, we can now be productive when the compiler is combined with the borrow checker. However, we have touched on the concepts of scope and lifetimes. The use<a id="_idIndexMarker098"/> of them has been intuitive, but like the rules around borrowing, we need to dive into scopes and then lifetimes in more detail. </p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Scopes</h2>
			<p>To understand scopes, let us go back<a id="_idIndexMarker099"/> to how we declare variables. You will have noticed that when we declare a new variable, we use <code>let</code>. When we do, that variable is the only one that owns the resource. Therefore, if the value is moved or reassigned, then the initial variable no longer owns the value. When a variable is moved, it is essentially moved into another scope. Variables declared in an outer scope<a id="_idIndexMarker100"/> can be referenced<a id="_idIndexMarker101"/> in an inner scope, but a variable declared in an inner scope cannot be accessed in the inner scope once the inner scope has expired. We can break down some code into scopes in the following diagram:</p>
			<div><div><img src="img/Figure_1.9_B18722.jpg" alt="Figure 1.9 – Basic Rust code broken into scopes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Basic Rust code broken into scopes</p>
			<p><em class="italic">Figure 1</em><em class="italic">.9</em> shows us that we can create an inner scope by merely using curly brackets. Applying what we just learned about scopes to <em class="italic">Figure 1</em><em class="italic">.9</em>, can you work out whether it will crash? If it will crash, how will it? </p>
			<p>If you guessed that it would<a id="_idIndexMarker102"/> result in a compiler error, then you are correct. Running the code would result in the following error:</p>
			<pre class="console">
println!("{}", two);
               ^^^ not found in this scope</pre>
			<p>Because <code>one</code> is defined in the inner scope, we will not be able to reference it in the outer scope. We can solve this problem by declaring the variable in the outer scope<a id="_idIndexMarker103"/> but assigning the value in the inner scope<a id="_idIndexMarker104"/> with the following code:</p>
			<pre class="source-code">
fn main() {
    let one = &amp;"one";
    let two: &amp;str;
    {
        println!("{}", one);
        two = &amp;"two";
    }
    println!("{}", one);
    println!("{}", two);
}</pre>
			<p>In the preceding code, we can see that we do not use <code>let</code> when assigning the value because we have already declared the variable in the outer scope. Running the preceding code gives us the following printout:</p>
			<pre class="console">
one
one
two</pre>
			<p>We also must remember that if we move a variable into a function, then the variable gets destroyed once the scope of the function finishes. We cannot access the variable after the execution of the function, even though we declared the variable before the execution of the function. This is because once the variable has been moved into the function, it is no longer in the original scope. It has been moved. And because it has been moved to that scope, it is then bound<a id="_idIndexMarker105"/> to the lifetime of the scope that it was moved into. This brings us to our next section: lifetimes. </p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Running through lifetimes</h2>
			<p>Understanding lifetimes<a id="_idIndexMarker106"/> will wrap up our exploration of borrowing rules and scopes. We can explore the effect of lifetimes with the following code:</p>
			<pre class="source-code">
fn main() {
    let one: &amp;i8;
    {
        let two: i8 = 2;
        one = &amp;two;
    } // -----------------------&gt; two lifetime stops here
    println!("r: {}", one);
}</pre>
			<p>With the preceding code, we declare <code>one</code> before the inner scope starts. However, we assign it to have a reference of <code>two</code>. <code>two</code> only has the lifetime of the inner scope, so the lifetime dies before we try and print it out. This is established with the following error:</p>
			<pre class="console">
one = &amp;two;    }    println!("r: {}", one);}
      ^^^^     -                      --- borrow later used here
      |        |
      |        `two` dropped here while still borrowed
      borrowed value does not live long enough</pre>
			<p><code>two</code> is dropped when the lifetime of <code>two</code> has finished. With this, we can state that the lifetimes of <code>one</code> and <code>two</code> are not equal.</p>
			<p>While it is great<a id="_idIndexMarker107"/> that this is flagged when compiling, Rust does not stop here. This concept also applies to functions. Let’s say that we build a function that references two integers, compares them, and returns the highest integer reference. The function is an isolated piece of code. In this function, we can denote the lifetimes of the two integers. This is done by using the <code>'</code> prefix, which is a lifetime notation. The names of the notations can be anything you come up with, but it is convention to use <code>a</code>, <code>b</code>, <code>c</code>, and so on. We can explore this by creating a simple function that takes in two integers and returns the highest one with the following code:</p>
			<pre class="source-code">
fn get_highest&lt;'a&gt;(first_number: &amp;'a i8, second_number: &amp;'a
    i8) -&gt; &amp;'a i8 {
    if first_number &gt; second_number {
        first_number
        } else {
        second_number
    }
}
fn main() {
    let one: i8 = 1;
    let outcome: &amp;i8;
    {
        let two: i8 = 2;
        let outcome: &amp;i8 = get_highest(&amp;one, &amp;two);
    }
    println!("{}", outcome);
}</pre>
			<p>As we can see, the first and second lifetimes<a id="_idIndexMarker108"/> have the same notation of <code>a</code>. They both must be present for the duration of the function. We also must note that the function returns an <code>i8</code> integer with the lifetime of <code>a</code>. If we were to try and use lifetime notation on function parameters without a borrow, we would get some very confusing errors. In short, it is not possible to use lifetime notation without a borrow. This is because if we do not use a borrow, the value passed into the function is moved into the function. Therefore, its lifetime is the lifetime of the function. This seems straightforward; however, when we run it, we get the following error:</p>
			<pre class="console">
println!("{}", outcome);}
               ^^^^^^^ use of possibly-uninitialized `outcome`</pre>
			<p>The error occurs because all the lifetimes of the parameters passed into the function and the returned integer are the same. Therefore, the compiler does not know what could be returned. As a result, <code>two</code> could be returned. If <code>two</code> is returned, then the result of the function will not live long<a id="_idIndexMarker109"/> enough to be printed. However, if <code>one</code> is returned, then it will. Therefore, there is a possibility of not having a value to print after the inner scope is executed. In a dynamic language, we would be able to run code that runs the risk of referencing variables that have not been initialized yet. However, with Rust, we can see that if there is a possibility of an error like this, it will not compile. In the short term, it might seem like Rust takes longer to code, but as the project progresses, this strictness will save a lot of time by preventing silent bugs. In conclusion of our error, there is no way of solving our problem with the exact function and main layout that we have. We would either have to move our printing of the outcome into the inner scope or clone the integers and pass them into the function. </p>
			<p>We can create one more function to explore functions with different lifetime parameters. This time we will create a <code>filter</code> function. If the first number is lower than the second number, we will then return <code>0</code>. Otherwise, we will return the first number. This can be achieved with the following code:</p>
			<pre class="source-code">
fn filter&lt;'a, 'b&gt;(first_number: &amp;'a i8, second_number: &amp;'b
    i8) -&gt; &amp;'a i8 {
    if first_number &lt; second_number {
        &amp;0
    } else {
        first_number
    }
}
fn main() {
    let one: i8 = 1;
    let outcome: &amp;i8;
    {
        let two: i8 = 2;
        outcome = filter(&amp;one, &amp;two);
    }
    println!("{}", outcome);
}</pre>
			<p>The preceding code works because we know the lifetimes are different. The first parameter has the same lifetime<a id="_idIndexMarker110"/> as the returned integer. If we were to implement <code>filter(&amp;two, &amp;one)</code> instead, we would get an error stating that the outcome does not live long enough to be printed. We have now covered all that we need to know for now to write productive code in Rust without the borrow checker getting in our way. We now need to move on to creating bigger building blocks for our programs so we can focus on tackling the complex problems we want to solve with code. We will start this with a versatile building block of programs: <strong class="bold">structs</strong>. </p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Building structs</h1>
			<p>In modern high-level dynamic languages, objects<a id="_idIndexMarker111"/> have been the bedrock for building big applications and solving complex problems, and for good reason. Objects enable us to encapsulate data, functionality, and behavior. In Rust, we do not have objects. However, we do have structs that can hold data in fields. We can then manage the functionality of these structs and group them together with traits. This is a powerful approach, and it gives us the benefits of objects without the high coupling, as highlighted in the following figure:</p>
			<div><div><img src="img/Figure_1.10_B18722.jpg" alt="Figure 1.10 – Difference between Rust structs and objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – Difference between Rust structs and objects</p>
			<p>We will start with something basic by creating a <code>Human</code> struct with the following code:</p>
			<pre class="source-code">
#[derive(Debug)]
struct Human&lt;'a&gt; {
    name: &amp;'a str,
    age: i8,
    current_thought: &amp;'a str
}</pre>
			<p>In the preceding code, we can see that our string literal fields<a id="_idIndexMarker112"/> have the same lifetime as the struct itself. We have also applied the <code>Debug</code> trait to the <code>Human</code> struct, so we can print it out and see everything. We can then create the <code>Human</code> struct and print the struct out using the following code:</p>
			<pre class="source-code">
fn main() {
    let developer = Human{
        name: "Maxwell Flitton",
        age: 32,
        current_thought: "nothing"
    };
    println!("{:?}", developer);
    println!("{}", developer.name);
}</pre>
			<p>Running the preceding code would give us the following printout:</p>
			<pre class="source-code">
Human { name: "Maxwell Flitton", age: 32, current_thought:    "nothing" }
Maxwell Flitton</pre>
			<p>We can see that our fields<a id="_idIndexMarker113"/> are what we expect. However, we can change our string slice fields to strings to get rid of lifetime parameters. We may also want to add another field where we can reference another <code>Human</code> struct under a <code>friend</code> field. However, we may also have no friends. We can account for this by creating an enum that is either a friend or not and assigning this to a <code>friend</code> field, as seen in the following code:</p>
			<pre class="source-code">
#[derive(Debug)]
enum Friend {
    HUMAN(Human),
    NIL
}
#[derive(Debug)]
struct Human {
    name: String,
    age: i8,
    current_thought: String,
    friend: Friend
}</pre>
			<p>We can then define the <code>Human</code> struct initially<a id="_idIndexMarker114"/> with no friends just to see if it works with the following code:</p>
			<pre class="source-code">
    let developer = Human{
        name: "Maxwell Flitton".to_string(),
        age: 32,
        current_thought: "nothing".to_string(),
        friend: Friend::NIL
    };</pre>
			<p>However, when we run the compiler, it does not work. I would like to think this is because the compiler cannot believe that I have no friends. But alas, it’s to do with the compiler not knowing how much memory to allocate for this declaration. This is shown through the following error code:</p>
			<pre class="console">
enum Friend {    HUMAN(Human),    NIL}#[derive(Debug)]
^^^^^^^^^^^            ----- recursive without indirection
|
recursive type has infinite size</pre>
			<p>Because of the enum, theoretically, the memory needed to store this variable could be infinite. One <code>Human</code> struct could reference another <code>Human</code> struct as a <code>friend</code> field, which could in turn reference another <code>Human</code> struct, resulting in a potentially infinite number of <code>Human</code> structs being linked together through the <code>friend</code> field. We can solve this problem with pointers. Instead of storing all the data of a <code>Human</code> struct in the <code>friend</code> field, we store a memory<a id="_idIndexMarker115"/> address that we know has a maximum value because it’s a standard integer. This memory address points to where another <code>Human</code> struct is stored in the memory. As a result, the program knows exactly how much memory to allocate when it crosses a <code>Human</code> struct, irrespective of whether the <code>Human</code> struct has a <code>friend</code> field or not. This can be achieved by using a <code>Box</code> struct, which is essentially a smart pointer for our enum, with the following code:</p>
			<pre class="source-code">
#[derive(Debug)]
enum Friend {
    HUMAN(Box&lt;Human&gt;),
    NIL
}</pre>
			<p>So, now our enum states whether the friend exists or not, and if so, it has a memory address if we need to extract<a id="_idIndexMarker116"/> information about this friend. We can achieve this with the following code:</p>
			<pre class="source-code">
fn main() {
    let another_developer = Human{
        name: "Caroline Morton".to_string(),
        age:30,
        current_thought: "I need to code!!".to_string(),
        friend: Friend::NIL
    };
    let developer = Human{
        name: "Maxwell Flitton".to_string(),
        age: 32,
        current_thought: "nothing".to_string(),
        friend: Friend::HUMAN(Box::new(another_developer))
    };
    match &amp;developer.friend {
        Friend::HUMAN(data) =&gt; {
            println!("{}", data.name);
        },
        Friend::NIL =&gt; {}
    }
}</pre>
			<p>In the preceding code, we can see that we have created one <code>Human</code> struct, and then another <code>Human</code> struct with a reference to the first <code>Human</code> struct as a <code>friend</code> field. We then access the second <code>Human</code> struct’s <code>friend</code> through the <code>friend</code> field. Remember, we must handle both possibilities as it could be a nil value. </p>
			<p>While it is exciting that friends<a id="_idIndexMarker117"/> can be made, if we take a step back, we can see that there is a lot of code written for each human we create. This is not helpful if we must create a lot of humans in a program. We can reduce this by implementing some functionality for our struct. We will essentially create a constructor for the struct with extra functions, so we can add optional values if we want. We will also make the <code>thought</code> field optional. So, a basic struct with a constructor populating only the most essential fields can be achieved with the following code:</p>
			<pre class="source-code">
#[derive(Debug)]
struct Human {
    name: String,
    age: i8,
    current_thought: Option&lt;String&gt;,
    friend: Friend
}
impl Human {    
    fn new(name: &amp;str, age: i8) -&gt; Human {
        return Human{
            name: name.to_string(),
            age: age,
            current_thought: None,
            friend: Friend::NIL
        }
    }
}</pre>
			<p>Therefore, creating a new human<a id="_idIndexMarker118"/> now only takes the following line of code:</p>
			<pre class="source-code">
let developer = Human::new("Maxwell Flitton", 32);</pre>
			<p>This will have the following field values:</p>
			<ul>
				<li>Name: <code>"</code><code>Maxwell Flitton"</code></li>
				<li>Age: <code>32</code></li>
				<li>Current Thought: <code>None</code></li>
				<li>Friend: <code>NIL</code></li>
			</ul>
			<p>We can add more functions in the implement block for adding friends and a current thought with the following code:</p>
			<pre class="source-code">
    fn with_thought(mut self, thought: &amp;str) -&gt; Human {
        self.current_thought = Some(thought.to_string());
        return self
    }
    fn with_friend(mut self, friend: Box&lt;Human&gt;) -&gt; Human {
        self.friend = Friend::HUMAN(friend);
        return self
    }</pre>
			<p>In the preceding code, we can see that we pass in a mutable version of the struct that is calling these functions. These functions can be chained because they return the struct that called them. If we want to create a developer with a thought, we can do this with the following code:</p>
			<pre class="source-code">
let developer = Human::new("Maxwell Flitton", 32)
    .with_thought("I love Rust!");</pre>
			<p>We must note that a function<a id="_idIndexMarker119"/> that does not require <code>self</code> as a parameter can be called with <code>::</code>, while a function that does require <code>self</code> as a parameter can be called with a simple dot (<code>.</code>). If we want to create a developer with a friend, it can be done using the following code:</p>
			<pre class="source-code">
let developer_friend = Human::new("Caroline Morton", 30);
let developer = Human::new("Maxwell Flitton", 32)
    .with_thought("I love Rust!")
    .with_friend(Box::new(developer_friend));
Println!("{:?}", developer);</pre>
			<p>Running the code will result in the following parameters for <code>developer</code>:</p>
			<pre class="console">
Name: "Maxwell Flitton"
Age: 32
Current Thought: Some("I love Rust!")
Friend: HUMAN(Human { name: "Caroline Morton", age: 30, 
    current_thought: None, friend: NIL })</pre>
			<p>We can see that structs combined with enums and functions that have been implemented with these structs can be powerful building blocks. We can define fields and functionality with only a small amount of code if we have defined our structs well. However, writing the same functionality for multiple structs can be time-consuming and result in a lot of repeated code. If you have worked with objects before, you may have utilized inheritance<a id="_idIndexMarker120"/> for that. Rust goes one better. It has traits, which we will explore in the next section.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Verifying with traits</h2>
			<p>We can see enums can empower<a id="_idIndexMarker121"/> structs so that they can handle multiple types. This can<a id="_idIndexMarker122"/> also be translated for any type of function or data structure. However, this can lead to a lot of repetition. Take, for instance, a <code>User</code> struct. Users have a core set of values, such as a username and password. However, they could also have extra functionality based on roles. With users, we must check roles before firing certain processes. We can wrap up structs with traits by creating a simple toy program that defines users and their roles with the following steps:</p>
			<ol>
				<li>We can define<a id="_idIndexMarker123"/> our users<a id="_idIndexMarker124"/> with the following code:<pre class="source-code">
struct AdminUser {</pre><pre class="source-code">
    username: String,</pre><pre class="source-code">
    password: String</pre><pre class="source-code">
}</pre><pre class="source-code">
struct User {</pre><pre class="source-code">
    username: String,</pre><pre class="source-code">
    password: String</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We can see in the preceding code that the <code>User</code> and <code>AdminUser</code> structs have the same fields. For this exercise, we merely need two different structs to demonstrate the effect traits have on them. Now that our structs are defined, we can move on to our next step, which is creating the traits.</p>
			<ol>
				<li value="2">We will be implementing these traits in our structs. The total traits that we will have are, comprise create, edit, and delete. We will be using them to assign permissions to our users. We can create these three traits with the following code:<pre class="source-code">
trait CanEdit {</pre><pre class="source-code">
    fn edit(&amp;self) {</pre><pre class="source-code">
        println!("admin is editing");</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre><pre class="source-code">
trait CanCreate {</pre><pre class="source-code">
    fn create(&amp;self) {</pre><pre class="source-code">
        println!("admin is creating");</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre><pre class="source-code">
trait CanDelete {</pre><pre class="source-code">
    fn delete(&amp;self) {</pre><pre class="source-code">
        println!("admin is deleting");</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We can see that the functions<a id="_idIndexMarker125"/> for the traits only take in <code>self</code>. We cannot make<a id="_idIndexMarker126"/> any references to the fields in the functions to <code>self</code> as we do not know what structs will be implemented. However, we can override functions when we implement the trait to the struct if needed. If we are to return <code>self</code>, we will need to wrap it in a <code>Box</code> struct, as the compiler will not know the size of the struct being returned. We also must note that the signature of the function (input parameters and return values) must be the same as the original if we overwrite the function for a struct. Now that we have defined the traits, we can move on to the next step of implementing the traits to define roles for our user.</p>
			<ol>
				<li value="3">With our roles, we can make our admin have every permission and our user only the edit permission. This can be achieved with the following code:<pre class="source-code">
impl CanDelete for AdminUser {}</pre><pre class="source-code">
impl CanCreate for AdminUser {}</pre><pre class="source-code">
impl CanEdit for AdminUser {}</pre><pre class="source-code">
impl CanEdit for User {</pre><pre class="source-code">
    fn edit(&amp;self) {</pre><pre class="source-code">
        println!("A standard user {} is editing", </pre><pre class="source-code">
    self.username);</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>From our previous step, we can remember that all the functions already worked for the admin by printing<a id="_idIndexMarker127"/> out that the admin is doing the action. Therefore, we do<a id="_idIndexMarker128"/> not have to do anything for the implementation of the traits for the admin. We can also see that we can implement multiple traits for a single struct. This adds a lot of flexibility. In our user implementation of the <code>CanEdit</code> trait, we have overwritten the <code>edit</code> function so that we can have the correct statement printed out. Now that we have implemented the traits, our <code>user</code> structs have permission in the code to enter scopes that require those traits. We can now build the functions for using these traits in the next step.</p>
			<ol>
				<li value="4">We could utilize the functions in the traits by directly running them in the <code>main</code> function on the structs that have implemented them. However, if we do this, we will not see their true power in this exercise. We may also want this standard functionality throughout our program in the future when we span multiple files. The following code shows how we create functions that utilize the traits:<pre class="source-code">
fn create&lt;T: CanCreate&gt;(user: &amp;T) -&gt; () {</pre><pre class="source-code">
    user.create();</pre><pre class="source-code">
}</pre><pre class="source-code">
fn edit&lt;T: CanEdit&gt;(user: &amp;T) -&gt; () {</pre><pre class="source-code">
    user.edit();</pre><pre class="source-code">
}</pre><pre class="source-code">
fn delete&lt;T: CanDelete&gt;(user: &amp;T) -&gt; () {</pre><pre class="source-code">
    user.delete();</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The preceding notation<a id="_idIndexMarker129"/> is fairly like the lifetime annotation. We use angle<a id="_idIndexMarker130"/> brackets before the input definitions to define the trait we want to accept at <code>T</code>. We then state that we will accept a borrowed struct that has implemented the trait as <code>&amp;T</code>. This means that any struct that implements that specific trait can pass through the function. Because we know what the trait can do, we can then use the trait functions. However, because we do not know what struct is going to be passed through, we cannot utilize specific fields. But remember, we can overwrite a trait function to utilize struct fields when we implement the trait for the struct. This might seem rigid, but the process enforces good, isolated, decoupled coding that is safe. For instance, let’s say we remove a function from a trait or remove a trait from a struct. The compiler would refuse to compile until all the effects of this change were complete. Thus, we can see that, especially for big systems, Rust is safe, and can save time by reducing the risk of silent bugs. Now that we have defined the functions, we can use them in the <code>main</code> function in the next step.   </p>
			<ol>
				<li value="5">We can test to see whether all the traits work with the following code:<pre class="source-code">
fn main() {</pre><pre class="source-code">
    let admin = AdminUser{</pre><pre class="source-code">
        username: "admin".to_string(), </pre><pre class="source-code">
        password: "password".to_string()</pre><pre class="source-code">
    };</pre><pre class="source-code">
    let user = User{</pre><pre class="source-code">
        username: "user".to_string(), </pre><pre class="source-code">
        password: "password".to_string()</pre><pre class="source-code">
    };</pre><pre class="source-code">
    create(&amp;admin);</pre><pre class="source-code">
    edit(&amp;admin);</pre><pre class="source-code">
    edit(&amp;user);</pre><pre class="source-code">
    delete(&amp;admin);</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We can see that the functions that accept traits are used just like any other function. </p>
			<p>Running the entire program will give us the following printout:</p>
			<pre class="source-code">
admin is creating
admin is editing
A standard user user is editing
admin is deleting</pre>
			<p>In our output, we can see that the overriding of the <code>edit</code> function for the <code>User</code> struct works. </p>
			<p>We have now learned enough<a id="_idIndexMarker131"/> about traits to be productive with web development. Traits<a id="_idIndexMarker132"/> get even more powerful, and we will be using them for some key parts of our web programming. For instance, several web frameworks have traits that execute before the request is processed by the view/API endpoint. Implementing structs with these traits automatically loads the <code>view</code> function with the result of the <code>trait</code> function. This can be database connections, extraction of tokens from headers, or anything else we wish to work with. There is also one last concept that we need to tackle before we move on to the next chapter, and that is macros. </p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Metaprogramming with macros</h1>
			<p><strong class="bold">Metaprogramming</strong> can generally be described as a way in which<a id="_idIndexMarker133"/> the program can manipulate itself based <a id="_idIndexMarker134"/>on certain instructions. Considering the strong typing Rust has, one of the simplest ways in which we can meta program is by using generics. A classic example of demonstrating generics is through coordinates, as follows:</p>
			<pre class="source-code">
struct Coordinate &lt;T&gt; {
    x: T,
    y: T
}
fn main() {
    let one = Coordinate{x: 50, y: 50};
    let two = Coordinate{x: 500, y: 500};
    let three = Coordinate{x: 5.6, y: 5.6};
}</pre>
			<p>In the preceding snippet, we can see that the <code>Coordinate</code> struct managed to take in and handle three different types of numbers. We can add even more variance to the <code>Coordinate</code> struct so we can have two different types of numbers in one struct with the following code:</p>
			<pre class="source-code">
struct Coordinate &lt;T, X&gt; {
    x: T,
    y: X
}
fn main() {
    let one = Coordinate{x: 50, y: 500};
    let two = Coordinate{x: 5.6, y: 500};
    let three = Coordinate{x: 5.6, y: 50};
}</pre>
			<p>What is happening in the preceding code with generics is that the compiler is looking for all instances where the struct<a id="_idIndexMarker135"/> is used, creating structs with the types used when the compilation is running. Now that we have covered generics, we can move on to the main mechanism of metaprogramming: macros. </p>
			<p>Macros enable us to abstract code. We’ve already been using macros in our print functions. The <code>!</code> notation at the end of the function denotes that this is a macro that’s being called. Defining our own macros is a blend of defining a function and using a lifetime notation within a <code>match</code> statement in the function. To demonstrate this, we will define a macro that capitalizes a string with the following code: </p>
			<pre class="source-code">
macro_rules! capitalize {
    ($a: expr) =&gt; {
        let mut v: Vec&lt;char&gt; = $a.chars().collect();
        v[0] = v[0].to_uppercase().nth(0).unwrap();
        $a = v.into_iter().collect();
    }
}
fn main() {
    let mut x = String::from("test");
    capitalize!(x);
    println!("{}", x);
}</pre>
			<p>Instead of using the term <code>fn</code>, we use the <code>macro_rules!</code> definition. We then say that <code>$a</code> is the expression passed into the macro. We get the expression, convert it into a vector of chars, then make<a id="_idIndexMarker136"/> the first <code>char</code> uppercase, and then convert it back to a string. We must note that we don’t return anything in the <code>capitalize</code> macro, and when we call the macro, we don’t assign a variable to it. However, when we print the <code>x</code> variable at the end, we can see that it is capitalized. This does not behave like an ordinary function. We also must note that we didn’t define a type, instead, we just said it was an expression; the macro still does checks via traits. Passing an integer into the macro creates the following error:</p>
			<pre class="console">
|     capitalize!(32);
|     ---------------- in this macro invocation
|
= help: the trait `std::iter::FromIterator&lt;char&gt;` is not implemented for `{integer}`</pre>
			<p>Lifetimes, blocks, literals, paths, metaprogramming, and more, can also be passed instead of an expression. While it’s important to have a brief understanding of what’s under the hood of a basic macro for debugging and further reading, diving more into developing complex macros will not help us in developing web apps. We must remember that macros are a last resort and should be used sparingly. Errors thrown in macros can be hard to debug. In web<a id="_idIndexMarker137"/> development, a lot of the macros are already defined in third-party packages. Because of this, we do not need to write macros ourselves to get a web app up and running. Instead, we will mainly be using derive macros out of the box. </p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Summary</h1>
			<p>With Rust, we have seen that there are some traps when coming from a dynamic programming language background. However, with a little bit of knowledge of referencing and basic memory management, we can avoid common pitfalls and write safe, performant code quickly that can handle errors. By utilizing structs and traits, we can build objects that are analogous to classes in standard dynamic programming languages. On top of this, the traits enabled us to build mixin-like functionality. This not only enables us to slot in functionality when it’s useful to us but also perform checks on the structs through typing to ensure that the container or function is processing structs with certain attributes belonging to the trait that we can utilize in the code.</p>
			<p>With our fully functioning structs, we bolted on even more functionality with macros and looked under the hood of basic macros by building our own <code>capitalize</code> function, giving us guidance for further reading and debugging. We also got to see a brief demonstration of how powerful macros combined with structs can be in web development with JSON serialization. With what we have learned in this chapter, we can now write basic Rust programs. Because we understand the concepts that the borrow checker enforces, we can debug the application that we code. Like other languages, there are limited real-world applications that we can do yet. However, we do have the essential foundation to build real-world applications spanning multiple files running on our own local computers.  </p>
			<p>We can now move on to the next chapter and investigate setting up a Rust environment on our own computers to structure files and code to enable us to build programs that can solve real-world problems.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Questions</h1>
			<ol>
				<li value="1">What is the difference between <code>str</code> and <code>String</code>?</li>
				<li>Why can’t string slices be passed into a function (string slice meaning <code>str</code> as opposed to <code>&amp;str</code>)?</li>
				<li>How do we access the data belonging to a key in a HashMap?</li>
				<li>When a function results in an error, can we handle other processes, or will the error crash the program instantly? </li>
				<li>Why does Rust only allow one mutable borrow at a point in time?</li>
				<li>When would we need to define two different lifetimes in a function?</li>
				<li>How can structs link to the same struct via one of their fields?</li>
				<li>How can we add extra functionality to a struct where the functionality can also be implemented by other structs?</li>
				<li>How do we allow a container or function to accept different data structures? </li>
				<li>What’s the quickest way to add a trait, such as <code>Copy</code>, to a struct?</li>
			</ol>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Answers</h1>
			<ol>
				<li value="1"><code>String</code> is a fixed-size reference stored in the stack that points to string-type data on the heap. <code>str</code> is an immutable sequence of bytes stored somewhere in memory. Because the size of <code>str</code> is unknown, it can only be handled by a <code>&amp;</code><code>str</code> pointer.</li>
				<li>Since we do not know the size of the string slice at compile time, we cannot allocate the correct amount of memory for it. Strings, on the other hand, have a fixed-size reference stored on the stack that points to the string slice on the heap. Because we know this fixed size of the string reference, we can allocate the correct amount of memory and pass it through to a function. </li>
				<li>We use the HashMap’s <code>get</code> function. However, we must remember that the <code>get</code> function merely returns an <code>Option</code> struct. If we are confident that there is something there or we want the program to crash if nothing is found, we can directly unwrap it. However, if we don’t want that, we can use a <code>match</code> statement and handle the <code>Some</code> and <code>None</code> output as we wish.  </li>
				<li>No, results must be unwrapped before exposing the error. A simple <code>match</code> statement can handle unwrapping the result and managing the error as we see fit. </li>
				<li>Rust only allows one mutable borrow to prevent memory unsafety. In Goregaokar’s blog, the example of an enum is used to illustrate this. If an enum supports two different data types (<code>String</code> and <code>i64</code>), if a mutable reference of the string variant of the enum is made, and then another reference is made, the mutable reference can change the data, and then the second reference would still be referencing the string variant of the enum. The second reference would then try to dereference the string variant of the enum, potentially causing a segmentation fault. Elaboration on this example and others is provided in the <em class="italic">Further reading</em> section. </li>
				<li>We would need to define two different lifetimes when the result of a function relies on one of the lifetimes and the result of the function is needed outside of the scope of where it is called. </li>
				<li>If a struct is referencing itself in one of its fields, the size could be infinite as it could continue to reference itself continuously. To prevent this, we can wrap the reference to the struct in the field in a <code>Box</code> struct.  </li>
				<li>We can slot extra functionality and freedom into a struct by using traits. Implementing a trait will give the struct the ability to use functions that belong to the trait. The trait’s implementation also allows the struct to pass typing checks for that trait. </li>
				<li>We allow a container or function to accept different data structures by declaring enums or traits in the type checking or by utilizing generics (see the <em class="italic">Further reading </em>section: <em class="italic">Mastering Rust</em> or <em class="italic">Hands-On Functional Programming in Rust (first chapter)</em>). </li>
				<li>The quickest way to add a trait to a struct is by annotating the struct with a derive macro that has the copy and clone traits. </li>
			</ol>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Further reading</h1>
			<ul>
				<li><em class="italic">Hands-On Functional Programming in Rust</em> (2018) by Andrew Johnson, Packt Publishing</li>
				<li><em class="italic">Mastering Rust</em> (2019) by Rahul Sharma and Vesa Kaihlavirta, Packt Publishing</li>
				<li><em class="italic">The Rust Programming Language</em> (2018): <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a></li>
				<li><em class="italic">The Problem With Single-threaded Shared Mutability</em> (2015) by Manish Goregaokar: <a href="https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/">https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/</a></li>
			</ul>
		</div>
	</body></html>