<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Matching and Structures</h1>
                
            
            <article>
                
<p class="calibre1">On top of the primitive variables and generics, which we will come to in <a href="part0207.html#65D4E0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3"><span>Chapter 9</span></a>, <em class="calibre9">Introducing Generics, Impl, and Traits</em>, Rust is capable of storing groups of different types of variables in a <kbd class="calibre10">struct</kbd> construct that may be familiar to those who have developed in the C family of languages. There's also a related concept called <strong class="calibre8">enumerations</strong> for creating types with alternating options. If that is not enough, Rust can combine these in its powerful pattern-matching code.</p>
<p class="calibre1">In this chapter, we will cover the following topics:</p>
<ul class="calibre12">
<li class="calibre13">Learning how to use and manipulate <kbd class="calibre10">struct</kbd> data types</li>
<li class="calibre13">Understanding tuples and the <strong class="calibre8">tuple struct</strong> hybrid</li>
<li class="calibre13">Creating and using enums</li>
<li class="calibre13">Understanding and applying the basics of patterns and matching</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Structs 101</h1>
                
            
            <article>
                
<p class="calibre1">For this chapter, I am going to ask you to imagine the following scenario. I have a house. My house has a certain number of rooms and each room has a name. Each room has one or more doors and windows and a carpet (with a color), and the rooms have a width and length. We will use structs and enums to model all this.</p>
<p class="calibre1">Structs in Rust are very common; they are used in many facets of the language and are useful to understand and use. In terms of the house example, we'll see how useful they can be.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Variables, variables everywhere</h1>
                
            
            <article>
                
<p class="calibre1">Let's look at the house and create some variables to describe it, as well as types. Start with the house, which can be considered the most basic of objects. We will need only to model the number of rooms it has:</p>
<pre class="calibre21">number_of_rooms: i32 </pre>
<p class="calibre1">Let's consider rooms next.</p>
<p class="calibre1">Each room will have a number of properties. Is it upstairs or downstairs, assuming it's a two-level house? Number of doors. Number of windows. Types of windows. Do the window have curtains? Wood or carpet floor covering? Color of the carpet. Room name. Does it have a wardrobe/closet? Room width. Room length. You can go deeper than that, but this will do for now.</p>
<p class="calibre1">As variables, these will be as follows:</p>
<pre class="calibre21">is_upstairs: bool 
number_of_doors: i32 
number_of_windows: i32 
window_type: String 
has_curtains: bool // true = yes 
wood_or_carpet: bool // true = carpet 
carpet_color: String 
room_name: String 
has_wardrobe: bool // true = yes 
room_width: f32 
room_height: f32 </pre>
<p class="calibre1">There is no reason why you can't define these as discrete variables; however, as they are properties that describe a feature within the house or room, why not group them as we already have? This is where a <kbd class="calibre10">struct</kbd> type comes in useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The structure of a struct</h1>
                
            
            <article>
                
<p class="calibre1">A <kbd class="calibre10">struct</kbd> type consists of three parts: the keyword <kbd class="calibre10">struct</kbd>, the <kbd class="calibre10">struct</kbd> name, and the variables it holds. Let's consider the following command as an example:</p>
<pre class="calibre21">struct MyStruct 
{ 
    foo: i32, 
    bar: f32, 
} </pre>
<p class="calibre1">It is important to note that, unlike normal variable definitions, a comma follows directly after the variable type and not a semicolon.</p>
<p class="calibre1">For our example, we can define two <kbd class="calibre10">struct</kbd> types, one for the room and one for the house, as follows:</p>
<pre class="calibre21">struct Room 
{  
    is_upstairs: bool, 
    number_of_doors: i32, 
    number_of_windows: i32, 
    window_type: String, 
    has_curtains: bool, 
    wood_or_carpet: bool, 
    carpet_color: String, 
    room_name: String, 
    has_wardrobe: bool, 
    room_width: f32, 
    room_height: f32, 
} </pre>
<p class="calibre1">Our house will therefore be as follows:</p>
<pre class="calibre21">struct House 
{ 
    room:... um... 
} </pre>
<p class="calibre1">A <kbd class="calibre10">struct</kbd>, while a special type of variable, is still a variable, and as such as a type; a <kbd class="calibre10">struct</kbd>. We can therefore assign it the same way as we can any other variable type:</p>
<pre class="calibre21">struct House 
{ 
     room: Room, 
} </pre>
<p class="calibre1">This is fine if we have a house with a single room! We can define an array of rooms, but then that means we will have a fixed number of rooms. Instead, we will define it as the type used within a vector:</p>
<pre class="calibre21">struct House 
{ 
     rooms: Vec&lt;Room&gt; 
} </pre>
<p class="calibre1">We created two special types of variable that we can declare and access as we would with any other variable. If we look at the room definition, we can break the structure down further; but why would we want to do that?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Smaller is better</h1>
                
            
            <article>
                
<p class="calibre1">There is an argument that the smaller you make the parent structure, the easier it becomes to manage. This is true, but let's look at it in a different way. As it stands, we have a couple of what can be described as objects in their own right within that structure. Here, an object is something that will have its own properties. Let's look at the window.</p>
<p class="calibre1">A window has a size—width and height; it has a type—sash, for instance; it has blinds or curtains, and the blinds/curtains have a color. The window may also have a lock. It may also be a single or double window and the opening may be at the top or side.</p>
<p class="calibre1">There is also no reason why there should only be a single window. If there is more than one window, then we will need to define our window multiple times. Therefore, it makes more sense to define our window and reference that back as a vector in the main structure.</p>
<p class="calibre1">Before that, though, we said the window will have a size (width, length). Each room will have a size and, probably, so will many other things within the house; therefore, we will remove the size and have that as its own <kbd class="calibre10">struct</kbd>.</p>
<p class="calibre1">Therefore, we have this following <kbd class="calibre10">struct</kbd> for the window:</p>
<pre class="calibre21">struct Area 
{ 
    width: f32, 
    length: f32, 
} 
 
struct Window 
{ 
    window_area: Area, 
    window_type: String, 
    has_blinds: bool, 
    curtain_color: String, 
    has_lock: bool, 
    top_open: bool, 
    single_window: bool, 
} </pre>
<p class="calibre1">This, back in the parent <kbd class="calibre10">struct</kbd>, will transform into the following:</p>
<pre class="calibre21">struct Room 
{  
    is_upstairs: bool, 
    number_of_doors: i32, 
    window: Vec&lt;Window&gt; ,
    wood_or_carpet: bool, 
    carpet_color: String, 
    room_name: String, 
    has_wardrobe: bool, 
    room_area: Area, 
} </pre>
<p class="calibre1">We can carry on doing this for anything else in the room, including a <kbd class="calibre10">struct</kbd> variable for furniture, as well as possibly reducing the size for carpet—what you do with it is up to you. For now, we'll keep it at this level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessing a struct</h1>
                
            
            <article>
                
<p class="calibre1">In order to access a <kbd class="calibre10">struct</kbd> variable, we will need to create a variable that can access it:</p>
<pre class="calibre21">let mut room = Room { is_upstairs: true, <br class="calibre2"/> number_of_doors: 1, wood_or_carpet: true, carpet_color: "Red", <br class="calibre2"/> room_name: "Bedroom 1", has_wardrobe: true };</pre>
<div class="packt_infobox">The code for this section is in the <kbd class="calibre22">07/simplestruct</kbd> folder in the supporting code bundle of this book.</div>
<p class="calibre1">We have not defined all of the variables within that structure, which, for now, is fine, as they still need to be defined before the code will compile. The variable is mutable since we want to change its contents later.</p>
<p class="calibre1">To access one of the members of the <kbd class="calibre10">struct</kbd>, we will use the dot notation. In this case, we can have the following:</p>
<pre class="calibre21">println!("Bedroom {} has {} door", room.room_name, <br class="calibre2"/> room.number_of_door);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Defining the child structures</h1>
                
            
            <article>
                
<p class="calibre1">We have two types of <kbd class="calibre10">struct</kbd>—parent and child. Here, the <kbd class="calibre10">struct</kbd> of <kbd class="calibre10">Room</kbd> is the parent and it has two children: the window definition and room size. They are very different beasts as the window definition is a <kbd class="calibre10">Vec</kbd> type, while the other is just a <kbd class="calibre10">struct</kbd> type.</p>
<p class="calibre1">For the room area, we can use the following when creating an instance of the room type:</p>
<pre class="calibre21">room_area: Area {width: 2.3f32, length: 4.3f32} </pre>
<p class="calibre1">We are defining <kbd class="calibre10">room_area</kbd>, for which we will then define an inline variable which will act as the pointer to the area structure and, finally, create the size of the room. This is accessed using the following code snippet:</p>
<pre class="calibre21">println!("The room width is {}m by {}m", room.room_area.width, room.room_area.length); </pre>
<p class="calibre1">Finally, we have to define the vector of Windows.</p>
<p class="calibre1">This is done in a very similar way to how we define any other vector, which is as follows:</p>
<pre class="calibre21">window: vec![  
        Window { 
            window_area: Area {width: 1.3f32, length: 1.4f32}, 
            window_type: "Main".to_owned(), 
            has_blinds: true, 
            curtain_color: "Blue".to_owned(), 
            has_lock: false, 
            top_open: true, 
            single_window: true, 
        }, 
        Window { 
            window_area: Area {width: 0.9f32, length: 1.1f32}, 
            window_type: "Small".to_owned(), 
            has_blinds: true, 
            curtain_color: "Blue".to_owned(), 
            has_lock: false, 
            top_open: true, 
            single_window: true, 
        } </pre>
<p class="calibre1">We will then add a few more <kbd class="calibre10">println!</kbd> lines to show we have some data:</p>
<pre class="calibre21">println!("The room width is {}m by {}m", room.room_area.width, room.room_area.length);  
let ref window_two = room.window[1]; 
println!("Window 2 is {}m by {}m and has {} curtains", window_two.window_area.width, window_two.window_area.length,  window_two.curtain_color); </pre>
<p class="calibre1">When compiled, the code produces the following result:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00049.jpeg"/></div>
<p class="calibre1">We have very quickly, and simply, created a multi-level structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Multi-file version</h1>
                
            
            <article>
                
<p class="calibre1">If you look at the source code in the <kbd class="calibre10">simplestruct</kbd> file, you'll find the structures at the start with the code under it. There is nothing wrong with that, but after a while, it becomes cumbersome, especially if we have a lot of structures and enumerations.</p>
<p class="calibre1">To remove this problem, we can split the structures and code over two files.</p>
<p class="calibre1">However, before we build the code, we will have to provide the <kbd class="calibre10">main.rs</kbd> file with some sort of pointer to the structures. We can do this in one of three ways. The simplest is to use the <kbd class="calibre10">include!</kbd> macro:</p>
<pre class="calibre21">include!("structs.rs"); </pre>
<div class="packt_infobox">The source for this section is in the <kbd class="calibre22">Chapter 7/multifile</kbd> folder, present in the supporting code bundle provided for this book.</div>
<p class="calibre1">This just inserts the contents of the file in the place of the macro call, so it's not the most elegant way and completely sidesteps Rust's module system. So let's look at a better way.</p>
<p class="calibre1">The better way is to reference the module using the following snippet:</p>
<pre class="calibre21">mod structs; 
use structs::*; </pre>
<p class="calibre1">This can lead to a large number of issues, the biggest being the protection level, <kbd class="calibre10">public</kbd> or <kbd class="calibre10">private</kbd>. When compiled like this, many errors, such as the following example, occur:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00050.jpeg"/></div>
<p class="calibre1">The error will indicate that, though the structure is <kbd class="calibre10">public</kbd>, the fields within it aren't, so they can't be accessed. The solution is to make all of the fields <kbd class="calibre10">public</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Private versus public fields</h1>
                
            
            <article>
                
<p class="calibre1">By default, all fields within a <kbd class="calibre10">struct</kbd> are <kbd class="calibre10">private</kbd> to the module it is created in. This has its uses; for example, if you want to protect a value within the <kbd class="calibre10">struct</kbd>, you can make it only accessible via a <kbd class="calibre10">read</kbd>/<kbd class="calibre10">write</kbd> function, as shown in the following example:</p>
<pre class="calibre21">// readwrite.rs 
pub struct RWData 
{ 
    pub X: i32, 
    Y: i32 
} 
 
static mut rwdata: RWData = RWData {X: 0, Y: 0}; 
 
pub fn store_y(val: i32) 
{ 
    unsafe { rwdata.Y = val; }
} 
 
pub fn new_y() -&gt; i32 
{ 
    unsafe { rwdata.Y * 6 }
} 
 
// main.rs 
mod readwrite; 
use readwrite::*; 
 
fn main() { 
    
 
        store_y(6); 
        println!("Y is now {}", new_y()); 
     
} </pre>
<div class="packt_infobox">The code for this section is in the <kbd class="calibre22">07/readwrite</kbd> folder, present in the supporting code bundle provided for this book.</div>
<p class="calibre1">When we build and run this, we will get the following output:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00051.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Structs 102</h1>
                
            
            <article>
                
<p class="calibre1">While we have defined our own structs, we also have access to a structure known as a unit-like <kbd class="calibre10">struct</kbd>. Unlike our own structs, we can see the likes of the following:</p>
<pre class="calibre21">struct someStruct; 
let x = someStruct; </pre>
<p class="calibre1">They have nothing after them—no fields defined. These are not the same as the ones we defined, so how do they work?</p>
<p class="calibre1">To understand how they work, we need to understand a tuple <kbd class="calibre10">struct</kbd> and, in order to understand those, we need to know what a tuple is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tuples</h1>
                
            
            <article>
                
<p class="calibre1">Here are two ways to initialize a tuple:</p>
<pre class="calibre21">let tup = (3, "foo"); 
let tup: (i32, &amp;str) = (3, "foo"); 
 </pre>
<p class="calibre1">On the first line, we let local type inference work and just declare what is inside the tuple. Rust will figure out the types. On the second line, we declare the types explicitly.</p>
<p class="calibre1">We can have as many (or as few) elements in the list as they are, in fact, an ordered list of a fixed size.</p>
<p class="calibre1">As with other variable types, we can assign one tuple to equal another as long as they contain the same types and number of parameters (arity). For example, the following have the same types and arity and so can be used to assign to each other:</p>
<pre class="calibre21">let mut change = (1.1f32, 1); 
let into = (3.14f32, 6); 
change = into; </pre>
<p class="calibre1">The following wouldn't be allowed as the types don't match, even though the arity does:</p>
<pre class="calibre21">let mut change = (1.1f32, 1); 
let into = (1, 3.14f32); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using a tuple to define a variable</h1>
                
            
            <article>
                
<p class="calibre1">Let's consider the following:</p>
<pre class="calibre21">let test = 1i32; </pre>
<p class="calibre1">We created a variable called <kbd class="calibre10">test</kbd> that has the value <kbd class="calibre10">1</kbd> of type <kbd class="calibre10">i32</kbd> bound to it (binding was discussed in <a href="part0106.html#352RK0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3"><span>Chapter 5</span></a>, <em class="calibre9">Remember, Remember</em>). How can we do something similar with a tuple? So far, we've done the following:</p>
<pre class="calibre21">let test = (1, 4f32); </pre>
<p class="calibre1">We bound <kbd class="calibre10">test</kbd> to a tuple containing two values: <kbd class="calibre10">(i32, f32)</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tuple indexing</h1>
                
            
            <article>
                
<p class="calibre1">To get at the <kbd class="calibre10">f32</kbd> value, we will have to use tuple indexing. This is very similar to indexing an array, but we replace the following snippet:</p>
<pre class="calibre21">let t = someArray[3]; </pre>
<p class="calibre1">We use the following snippet instead:</p>
<pre class="calibre21">let t = test.1 </pre>
<p class="calibre1">As with array indexes, the tuple indexes range from <kbd class="calibre10">0</kbd> to <kbd class="calibre10">n-1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Destructuring with let</h1>
                
            
            <article>
                
<p class="calibre1">To avoid using a tuple index, Rust has a way to destructure a tuple. This is very similar to a normal <kbd class="calibre10">let</kbd> statement, except we will define multiple variable names at once:</p>
<pre class="calibre21">let (one, two, three) = (1, 2, 3); </pre>
<p class="calibre1">If there are the same number of names on the left as there are arguments on the right, Rust will break these up internally to create three bindings at once.</p>
<p class="calibre1">We now have three bindings and can access them as we would any other variable:</p>
<pre class="calibre21">let (one, two, three) = (1, 2, 3); 
println!("One = {}", one); // outputs One = 1 </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tuple structs – the hybrid of two</h1>
                
            
            <article>
                
<p class="calibre1">Consider a <kbd class="calibre10">struct</kbd> with three fields. It will have a name for the <kbd class="calibre10">struct</kbd> type and the three fields with their types:</p>
<pre class="calibre21">struct Test 
{ 
     drink: bool, 
     number: i32, 
     price: f32 
} </pre>
<p class="calibre1">Let's consider what this actually is and if we can we not rewrite this as follows:</p>
<pre class="calibre21">let Test: (bool, i32, f32) = (false, 4, 1.55); </pre>
<p class="calibre1">Well, we can, but we will now run into how to access the members of the tuple. We will also run into assigning one tuple to another. You can't really define two structs, which are identical in everything other than the <kbd class="calibre10">struct</kbd> type name, and then assign the second <kbd class="calibre10">struct</kbd> type to the first.</p>
<p class="calibre1">To get around this, Rust has the tuple <kbd class="calibre10">struct</kbd> hybrid. It contains the <kbd class="calibre10">struct</kbd> type but then assigns the fields as a tuple:</p>
<pre class="calibre21">struct TestOne (f32, i8, &amp;str); 
struct TestTwo (f32, i8, &amp;str); </pre>
<p class="calibre1">We now have the flexibility of a tuple, but with the protection of the <kbd class="calibre10">struct</kbd>. Despite the arity being the same and the types inside the struct being the same, they are different types.</p>
<p class="calibre1">As with a regular tuple, we can access the members of the tuple <kbd class="calibre10">struct</kbd> in the same way:</p>
<pre class="calibre21">let i = TestOne.1; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The single element tuple struct</h1>
                
            
            <article>
                
<p class="calibre1">At this point, you're probably wondering whether there are any uses for a tuple <kbd class="calibre10">struct</kbd> over a standard <kbd class="calibre10">struct</kbd>. One of the uses is when the tuple <kbd class="calibre10">struct</kbd> has a single element. Here, we are able to create a variable based on the tuple. It's similar to a destructured tuple in appearance:</p>
<pre class="calibre21">struct MyPi(f32);  
fn main()  
{ 
    let my_pi = MyPi(22f32 / 7f32); 
    let MyPi(pi) = my_pi;  
    println!("pi = {}", pi); 
} </pre>
<div class="packt_infobox">The source for this section is in the <kbd class="calibre22">07/newtype</kbd> folder, present in the supporting code bundle provided for this book.</div>
<p class="calibre1">This produces the following output when compiled and run:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00052.jpeg"/></div>
<p class="calibre1">This form of assignment is known as a new type pattern; it has allowed the creation of a new type distinct from the contained value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Back to the unit-like struct</h1>
                
            
            <article>
                
<p class="calibre1">Now that we have an understanding of tuples and the tuple <kbd class="calibre10">struct</kbd>, we can now look at the unit-like <kbd class="calibre10">struct</kbd>. This can be considered to be a <kbd class="calibre10">struct</kbd> with an empty tuple and as with a tuple <kbd class="calibre10">struct</kbd>, it defines a new type.</p>
<p class="calibre1">Typically, we will use this in conjunction with a trait or if you don't have any data to store in it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Enumerations</h1>
                
            
            <article>
                
<p class="calibre1">If are you are used to C, you will be well used to enumerations, for example:</p>
<pre class="calibre21">enum myEnum {start = 4, next, nextone, lastone=999};  </pre>
<p class="calibre1">This creates an <kbd class="calibre10">enum</kbd> type that auto-fills <kbd class="calibre10">next</kbd> and <kbd class="calibre10">nextone</kbd> to be start <kbd class="calibre10">+ 1</kbd> and start <kbd class="calibre10">+ 2</kbd> respectively. If the first named parameter has nothing to give an initial value to, it is given the value <kbd class="calibre10">0</kbd> with everything after it being one larger than the last. They are accessed as <kbd class="calibre10">myEnum.nextone</kbd>.</p>
<p class="calibre1">An <kbd class="calibre10">enum</kbd> type in Rust has a very similar structure to a <kbd class="calibre10">struct</kbd> type, as shown in the following code:</p>
<pre class="calibre21">enum MyEnum 
{ 
     TupleType(f32, i8, &amp;str), 
     StructType { varone: i32, vartwo: f64 }, 
     NewTypeTuple(i32), 
     SomeVarName 
} </pre>
<p class="calibre1">As with C though, an <kbd class="calibre10">enum</kbd> is a single type, but the value of the <kbd class="calibre10">enum</kbd> can match any of its members.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessing enumeration members</h1>
                
            
            <article>
                
<p class="calibre1">Given the possibility of the contents of a Rust <kbd class="calibre10">enum</kbd>, you may be thinking that accessing one of the members within the enumeration may not be the simplest of tasks. Thankfully, it is, as an <kbd class="calibre10">enum</kbd> variable is sometimes referred to as a <em class="calibre9">scopable</em> variable. For example, if we wanted to access members, we could use the following:</p>
<pre class="calibre21">enum MyFirstEnum 
{ 
    TupleType(f32, i8, String), 
    StuctType {varone: i32, vartwo: f64}, 
    NewTypeTuple(i32), 
    SomeVarName 
} 
 
enum MySecondEnum 
{ 
    TupleType(f32, i8, String), 
    StuctType {varone: i32, vartwo: f64}, 
    NewTypeTuple(i32), 
} 
 
fn main()  
{ 
    let mut text1 = "".to_owned(); // text1: String 
    let mut text2 = "".to_owned(); // text2: String 
    let mut num1 = 0f32; 
     
    let value = MyFirstEnum::TupleType(3.14, 1, "Hello".to_owned()); 
    let value2 = MySecondEnum::TupleType(6.28, 0, "World".to_owned()); 
     
    if let MyFirstEnum::TupleType(f,i,s)  = value 
    { 
        text1 = s; 
        num1 = f; 
    } 
     
    if let MySecondEnum::TupleType(f,i,s) = value2 
    { 
        text2 = s; 
    } 
     
    println!("{} {} from the {} man", text1, text2, num1) 
} </pre>
<div class="packt_infobox">The code for this section is in the <kbd class="calibre22">07/enumscope</kbd> folder, present in the supporting code bundle provided for this book.</div>
<p class="calibre1">The variables, <kbd class="calibre10">value1</kbd> and <kbd class="calibre10">value2</kbd>, are scoped (uses <kbd class="calibre10">::</kbd>) to <kbd class="calibre10">MyFirstEnum</kbd> and <kbd class="calibre10">MySecondEnum</kbd> respectively. When compiled, we will see the following output:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00053.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The two questions you should be asking</h1>
                
            
            <article>
                
<p class="calibre1">The code is a bit of head-scratcher. Surely we should have been able to use something similar to the following code?</p>
<pre class="calibre21">let value = MyFirstEnum::TupleType(3.14, 1, "Hello".to_owned()); </pre>
<p class="calibre1">And then use <kbd class="calibre10">value.2</kbd> to obtain the string part directly within the <kbd class="calibre10">println!</kbd> statement, instead of the <kbd class="calibre10">if let</kbd> construct?</p>
<p class="calibre1">The reason why we can't is that <kbd class="calibre10">enum</kbd> variants aren't their own type, so as soon as we create the preceding value, above it is immediately lost.</p>
<p class="calibre1">The second question should be: What is the <kbd class="calibre10">if let</kbd> construct?</p>
<p class="calibre1">In Rust, <kbd class="calibre10">if let</kbd> is used as a way to perform certain types of pattern-matching.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Patterns and matching</h1>
                
            
            <article>
                
<p class="calibre1">Rust, as we have seen, contains many very powerful facilities. We will now consider two that are often seen, and then double back to examine how we can use the <kbd class="calibre10">if let</kbd> construct.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Matching</h1>
                
            
            <article>
                
<p class="calibre1">Let's look at a very unpleasant code block and then examine what it means:</p>
<pre class="calibre21">fn my_test(x: i32) -&gt; String 
{ 
    if x == 1 
    {   
        return "one".to_owned(); 
    } 
    else if x == 2 
    { 
        return "two".to_owned(); 
    } 
    else if x == 3 
    { 
        return "three".to_owned(); 
    } 
    return "not found".to_owned(); 
} </pre>
<p class="calibre1">The code takes an <kbd class="calibre10">i32</kbd> parameter and tests to see what it equals. If the condition is met, some text is returned for that number; otherwise, <kbd class="calibre10">"not found"</kbd> is returned.</p>
<p class="calibre1">This is a trivial example, but imagine if you're testing against 10 different conditions; the <kbd class="calibre10">if-else</kbd> construct will become ugly.</p>
<p class="calibre1">If we were in C, we could use <kbd class="calibre10">switch</kbd>/<kbd class="calibre10">case</kbd> and Rust can also do something similar, but the keyword is <kbd class="calibre10">match</kbd> instead. If we used the <kbd class="calibre10">match</kbd> expression, our function would be as follows:</p>
<pre class="calibre21">fn my_test(x: i32) -&gt; String 
{ 
    let mut t = "".to_owned(); 
    match x 
    { 
        1 =&gt; t = "one".to_owned(), 
        2 =&gt; t = "two".to_owned(), 
        3 =&gt; t = "three".to_owned(), 
        _ =&gt; t = "not found".to_owned() 
    } 
    return t; 
} </pre>
<p class="calibre1">In this instance, when <kbd class="calibre10">x</kbd> is matched to the value inside of the <kbd class="calibre10">match</kbd> expression, <kbd class="calibre10">t</kbd> is assigned. If it is not matched (<kbd class="calibre10">_ = &gt; ...</kbd>), then <kbd class="calibre10">t</kbd> is set to be <kbd class="calibre10">not found</kbd>. There must be a <kbd class="calibre10">_</kbd> wildcard pattern case within the <kbd class="calibre10">match</kbd>. This is down to Rust enforcing exhaustiveness checking. In other words, until the <kbd class="calibre10">_</kbd> wildcard is reached, Rust assumes that there must be other values to attempt to match.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Let's really make the function simple</h1>
                
            
            <article>
                
<p class="calibre1">While the preceding example is fairly compact, we can further reduce the footprint of the code by using <kbd class="calibre10">match</kbd> as an expression.</p>
<p class="calibre1">If you're used to <kbd class="calibre10">?</kbd> in C#, you will be familiar with a construct such as the following:</p>
<pre class="calibre21">var t = SomeCondition == 3 ? "three" : (SomeCondition == 4 ? <br class="calibre2"/> "four" : "not three or four");</pre>
<p class="calibre1">This means that we can assign <kbd class="calibre10">t</kbd> to be <kbd class="calibre10">three</kbd> if <kbd class="calibre10">SomeCondition == 3</kbd> else <kbd class="calibre10">if</kbd><kbd class="calibre10">SomeCondition == 4</kbd>, <kbd class="calibre10">t = four</kbd>. If this falls through, we can set <kbd class="calibre10">t</kbd> as <kbd class="calibre10">not three or four</kbd>.</p>
<p class="calibre1">It can get messy. Rust can do the same, only far more cleanly.</p>
<p class="calibre1">In the origin code, we had the following:</p>
<pre class="calibre21">let mut t = "".to_string(); 
match x 
{ </pre>
<p class="calibre1">We can use <kbd class="calibre10">match</kbd> as an expression to set the value to be returned:</p>
<pre class="calibre21">let t = match x 
{ 
    ... 
}; 
return t; </pre>
<p class="calibre1">Or, more simply, by just returning the result of the match:</p>
<pre class="calibre21">return match x 
{ 
    ... 
}; 
 </pre>
<p class="calibre1">Or even more simply, when we remember that, in Rust, a block returns the result of its last expression when we omit the <kbd class="calibre10">;</kbd>:</p>
<pre class="calibre21">fn my_test(x: i32) -&gt; String { 
    match x { 
        1 =&gt; "one".to_owned(), 
        2 =&gt; "two".to_owned(), 
        3 =&gt; "three".to_owned(), 
        _ =&gt; "not found".to_owned() 
    } <br class="calibre2"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using match with an enum</h1>
                
            
            <article>
                
<p class="calibre1">We have already seen in this chapter how enums can be somewhat tricky to handle. Thankfully, we can use <kbd class="calibre10">match</kbd> on an <kbd class="calibre10">enum</kbd>:</p>
<pre class="calibre21">enum MyFirstEnum 
{ 
    TupleType(f32, i8, String), 
    StructType {varone: i32, vartwo: f64}, 
    NewTypeTuple(i32), 
    SomeVarName 
} 
fn tuple_type(v: f32, c: i8, st: String) {//code} 
fn struct_type(v1: i32, v2: f64) {//code} 
fn new_type_tuple(n: i32) {//code} 
fn process_varname() {//code}  
 
fn match_enum_code(e: MyFirstEnum) 
{ 
match e { 
   MyFirstEnum::SomeVarName =&gt; process_varname(), 
   MyFirstEnum::TupleType(f,i,s) =&gt; tuple_type(f,i,s), 
   MyFirstEnum::StructType(v1,v2) =&gt; struct_type(v1,v2), 
   MyFirstEnum::NewTypeTuple(i) =&gt; new_type_tuple(i) 
}; 
} </pre>
<p class="calibre1">You will notice that in this example, <kbd class="calibre10">_</kbd> is not included. That's because we explicitly match against all the possible choices of the enum, so we don't need a catch-all case. If, for instance, we missed <kbd class="calibre10">NewTypeTuple</kbd>, the code would need to include a catch-all:</p>
<pre class="calibre21">fn match_enum_code(e:MyFirstEnum) 
{ 
match e { 
   MyFirstEnum::SomeVarName =&gt; process_varname(), 
   MyFirstEnum::TupleType(f,i,s) =&gt; tuple_type(f,i,s), 
   MyFirstEnum::StructType(v1,v2) =&gt; struct_type(v1,v2), 
   _ =&gt; return  // breaks out of the match 
}; 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Ignoring a parameter with match</h1>
                
            
            <article>
                
<p class="calibre1">It is entirely possible to ignore a parameter within a <kbd class="calibre10">match</kbd> construct. Take the following <kbd class="calibre10">struct</kbd>:</p>
<pre class="calibre21">struct Test  
{ 
    answer: i32, 
    real_answer: i32, 
    score: i32,
} </pre>
<p class="calibre1">We can use this <kbd class="calibre10">struct</kbd> within a <kbd class="calibre10">match</kbd> construct as we can any other type. However, we want to ignore anything after <kbd class="calibre10">real_answer</kbd>. To do this, we will use the <kbd class="calibre10">..</kbd> operator. Our match will look like this:</p>
<pre class="calibre21">fn match_test(t: Test) 
{ 
    match t 
    { 
        Test {answer: Question::MyAnswer, real_answer: <br class="calibre2"/>         Question::RealAnswer, ..} =&gt; {...} 
    } 
} </pre>
<p class="calibre1">We can also use <kbd class="calibre10">_</kbd> as a parameter (we expect a value, but we don't care what it is):</p>
<pre class="calibre21">fn match_test(t:Test) 
{ 
    match t 
    { 
        Test {answer: Question::MyAmswer, real_answer: <br class="calibre2"/>         Question::RealAnswer, score:_} =&gt; {...} 
    } 
} </pre>
<p class="calibre1">You can appreciate that the <kbd class="calibre10">match</kbd> construct is powerful, but let's see it in action with patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fall through patterns</h1>
                
            
            <article>
                
<p class="calibre1">Let's say that we want to have a fall through construct in the same way as we would have in C:</p>
<pre class="calibre21">switch(foo) 
{ 
    case 1: 
    case 2: printf("1 and 2\n"); 
            break; 
    case 3: printf("3\n"); 
            break; 
} </pre>
<p class="calibre1">We can do this in Rust using the <kbd class="calibre10">|</kbd> pattern, which is as follows:</p>
<pre class="calibre21">match foo  
{ 
    1 | 2 =&gt; println!("1 and 2"), 
    3 =&gt; println!("3"), 
    _ =&gt; println!("anything else") 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Ranges</h1>
                
            
            <article>
                
<p class="calibre1">In a similar way to using <kbd class="calibre10">|</kbd>, we can match on a range of values, as follows:</p>
<pre class="calibre21">match foo 
{ 
    1 ... 10 =&gt; println!("Value between 1 and 10"), 
    _ =&gt; println!("Value not between 1 and 10") 
} </pre>
<p class="calibre1">We can use something similar with <kbd class="calibre10">char</kbd>, as shown in the following example:</p>
<pre class="calibre21">match char_foo 
{ 
    'A' ... 'M' =&gt; println!("A - M"), 
    'N' ... 'Y' =&gt; println!("N - Y"), 
    'Z' =&gt; println!("Z"), 
    _ =&gt; println!("something else") 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a binding within a match pattern</h1>
                
            
            <article>
                
<p class="calibre1">Sometimes, it is very useful to create a temporary variable within a <kbd class="calibre10">match</kbd> construct and bind the result of the pattern to it. This is performed using <kbd class="calibre10">@</kbd>, as follows:</p>
<pre class="calibre21">match test 
{ 
    e @ 1 ... 10 =&gt; println!("the value is {}", e), 
    _ =&gt; println!("nothing doing") 
} </pre>
<p class="calibre1">This attempts to match the pattern <kbd class="calibre10">1</kbd> to <kbd class="calibre10">10</kbd> to the value of <kbd class="calibre10">test</kbd>. If it is a match, the value is bound to <kbd class="calibre10">t</kbd>, which we can then manipulate as we would any other variable.</p>
<p class="calibre1">We can also bind to the variable with a fall through construct as done in the following example:</p>
<pre class="calibre21">match test 
{ 
    t @ 1 ... 5 | t @ 10 ... 15 =&gt; println!("our value for t = {}", t), 
    _ =&gt; println!("dunno!") 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Let's add an if into the mix</h1>
                
            
            <article>
                
<p class="calibre1">We can include an <kbd class="calibre10">if</kbd> statement within a <kbd class="calibre10">match</kbd> pattern, as follows:</p>
<pre class="calibre21"> 
fn testcode(t: u8) 
{ 
    match t 
    { 
        1 | 2 if t != 1 =&gt; println!("t was not one"), 
        1 | 2 if t != 2 =&gt; println!("t was not two"), 
        _ =&gt; println!("") 
    } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using match with a compound type</h1>
                
            
            <article>
                
<p class="calibre1">A compound type is a type that contains many different types—a <kbd class="calibre10">struct</kbd> is possibly the simplest example here. The following also applies to enums and tuples.</p>
<p class="calibre1">We can match on a <kbd class="calibre10">struct</kbd> pattern the same way we can match on any other type of pattern, which is shown in the following example:</p>
<pre class="calibre21">struct MyStruct 
{ 
    a: i32, 
    b: i32 
} 
 
fn derp(){ 
    let mystruct=MyStruct{a:1, b:2}; 
    match mystruct { 
        MyStruct{a, b} =&gt; println!("matched the structure"), 
        _ =&gt; println!("didn't match the structure") 
    } 
} </pre>
<p class="calibre1">As described in the matching section, we can ignore parameters in the <kbd class="calibre10">struct</kbd> pattern match using <kbd class="calibre10">..</kbd>, or just throw them away using <kbd class="calibre10">_</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">And back to if let</h1>
                
            
            <article>
                
<p class="calibre1">You have probably realized now that <kbd class="calibre10">if let</kbd> is, in actuality, a <kbd class="calibre10">match</kbd> construct that is just written in a slightly different way.</p>
<p class="calibre1">A <kbd class="calibre10">match</kbd> construct is as follows:</p>
<pre class="calibre21">match testmatch 
{ 
    1 =&gt; println!("1"), 
    _ =&gt; println!("not 1") 
} </pre>
<p class="calibre1">The <kbd class="calibre10">if let</kbd> version would be as follows:</p>
<pre class="calibre21">if let 1 = testmatch { 
    println!("1"); 
} 
 else 
 { 
    println!("not 1"); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1">In this chapter, we saw how Rust deals with some fairly complex types that allow us to create a type which contains many different types, and how handling these compound types can be a mostly painless affair. We have also drawn attention to pitfalls when using enums.</p>
<p class="calibre1">We have examined the structured and flexible approach Rust takes to patterns and matching and the power that simplicity provides to developers.</p>
<p class="calibre1">In the next chapter, we will be looking at something that takes a fair bit of practice to understand and even more to get right—the Rust lifetime system.</p>


            </article>

            
        </section>
    </body></html>