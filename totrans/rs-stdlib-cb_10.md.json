["```rs\nrustup default nightly\n```", "```rs\n1   #![feature(inclusive_range_syntax)]\n2   \n3   fn main() {\n4     // Retrieve the entire alphabet in lower and uppercase:\n5     let alphabet: Vec<_> = (b'A' .. b'z' + 1) // Start as u8\n6       .map(|c| c as char)      // Convert all to chars\n7       .filter(|c| c.is_alphabetic()) // Filter only alphabetic     \n        chars\n8       .collect(); // Collect as Vec\n9     println!(\"alphabet: {:?}\", alphabet);\n10  \n11    // Do the same, but using the inclusive range syntax:\n12    let alphabet: Vec<_> = (b'A' ..= b'z') // Start as u8\n13      .map(|c| c as char)      // Convert all to chars\n14      .filter(|c| c.is_alphabetic()) // Filter only alphabetic  \n         chars\n15      .collect(); // Collect as Vec\n16    println!(\"alphabet: {:?}\", alphabet);\n17  }\n```", "```rs\n1   #![feature(conservative_impl_trait)]\n2   \n3   trait Animal {\n4     fn do_sound(&self);\n5   }\n6   \n7   struct Dog;\n8   impl Animal for Dog {\n9     fn do_sound(&self) {\n10      println!(\"Woof\");\n11    }\n12  }\n13  \n14  fn main() {\n15    // The caller doesn't know which exact object he gets\n16    // He knows only that it implements the Animal trait\n17    let animal = create_animal();\n18    animal.do_sound();\n19  \n20    for word in caps_words_iter(\"do you feel lucky, punkâ€½\") {\n21      println!(\"{}\", word);\n22    }\n23  \n24    let multiplier = create_multiplier(23);\n25    let result = multiplier(3);\n26    println!(\"23 * 3 = {}\", result);\n27  }\n28  \n29  // The impl trait syntax allows us to use abstract return types\n30  // This means that we don't specify which exact struct we return\n31  // but which trait(s) it implements\n32  fn create_animal() -> impl Animal {\n33    Dog {}\n34  }\n35  \n36  // Any iterator can be returned as an abstract return type\n37  fn caps_words_iter<'a>(text: &'a str) -> impl Iterator + 'a {\n38    // Return an iterator over every word converted into ALL_CAPS\n39    text.trim().split(' ').map(|word| word.to_uppercase())\n40  }\n41  \n42  // Same goes for closures\n43  fn create_multiplier(a: i32) -> impl Fn(i32) -> i32 {\n44    move |b| a * b\n45  }\n```", "```rs\ntrait Animal {\n    fn do_sound(&self);\n}\n\nstruct Dog;\nimpl Animal for Dog {\n    fn do_sound(&self) {\n        println!(\"Woof\");\n    }\n}\nstruct Cat;\nimpl Animal for Cat {\n    fn do_sound(&self) {\n        println!(\"Meow\");\n    }\n}\n\nenum AnimalType {\n    Dog,\n    Cat,\n}\n\nfn create_animal(animal_type: AnimalType) -> impl Animal {\n    match animal_type {\n        AnimalType::Cat => Cat {},\n        AnimalType::Dog => Dog {},\n    }\n}\n```", "```rs\nfn create_animal(animal_type: AnimalType) -> Box<Animal> {\n    match animal_type {\n        AnimalType::Cat => Box::new(Cat {}),\n        AnimalType::Dog => Box::new(Dog {}),\n    }\n}\n```", "```rs\n1   #![feature(conservative_impl_trait)]\n2   \n3   // The compose! macro takes a variadic amount of closures and  \n    returns\n4   // a closure that applies them all one after another\n5   macro_rules! compose {\n6     ( $last:expr ) => { $last };\n7     ( $head:expr, $ ($tail:expr), +) => {\n8       compose_two($head, compose!($ ($tail), +))\n9     };\n10  }\n11  \n12  // compose_two is a helper function used to\n13  // compose only two closures into one\n14  fn compose_two<FunOne, FunTwo, Input, Intermediate, Output>(\n15    fun_one: FunOne,\n16    fun_two: FunTwo,\n17  ) -> impl Fn(Input) -> Output\n18  where\n19    FunOne: Fn(Input) -> Intermediate,\n20    FunTwo: Fn(Intermediate) -> Output,\n21  {\n22    move |x| fun_two(fun_one(x))\n23  }\n24  \n25  fn main() {\n26    let add = |x| x + 2.0;\n27    let multiply = |x| x * 3.0;\n28    let divide = |x| x / 4.0;\n29    // itermediate(x) returns ((x + 2) * 3) / 4\n30    let intermediate = compose!(add, multiply, divide);\n31  \n32    let subtract = |x| x - 5.0;\n33    // finally(x) returns (((x + 2) * 3) / 4) - 5\n34    let finally = compose!(intermediate, subtract);\n35  \n36    println!(\"(((10 + 2) * 3) / 4) - 5 is: {}\", finally(10.0));\n37  }\n```", "```rs\nwhere\n    FunOne: Fn(Input) -> Intermediate,\n    FunTwo: Fn(Intermediate) -> Output,\n```", "```rs\nmove |x| fun_two(fun_one(x))\n```", "```rs\n1   #![feature(string_retain)]\n2   \n3   fn main() {\n4     let mut some_text = \"H_el_l__o_ ___Wo_r__l_d_\".to_string();\n5     println!(\"Original text: {}\", some_text);\n6     // retain() removes all chars that don't fulfill a\n7     // predicate in place, making it very efficient\n8     some_text.retain(|c| c != '_');\n9     println!(\"Text without underscores: {}\", some_text);\n10    some_text.retain(char::is_lowercase);\n11    println!(\"Text with only lowercase letters: {}\", some_text);\n12  \n13    // Before retain, you had to filter the string as an iterator \n      over chars\n14    // This will however create a new String, generating overhead\n15    let filtered: String = \"H_el_l__o_ ___Wo_r__l_d_\"\n16      .chars()\n17      .filter(|c| *c != '_')\n18      .collect();\n19    println!(\"Text filtered by an iterator: {}\", filtered);\n20  }\n```", "```rs\n1   #![feature(iterator_step_by)]\n2   \n3   fn main() {\n4     // step_by() will start on the first element of an iterator,\n5     // but then skips a certain number of elements on every  \n      iteration\n6     let even_numbers: Vec<_> = (0..100).step_by(2).collect();\n7     println!(\"The first one hundred even numbers: {:?}\",  \n      even_numbers);\n8   \n9     // step_by() will always start at the beginning.\n10    // If you need to skip the first few elements as well, use  \n      skip()\n11    let some_data = [\"Andrei\", \"Romania\", \"Giuseppe\", \"Italy\",  \n      \"Susan\", \"Britain\"];\n12    let countries: Vec<_> =  \n      some_data.iter().skip(1).step_by(2).collect();\n13    println!(\"Countries in the data: {:?}\", countries);\n14  \n15    let grouped_stream = \"Aaron 182cm 70kg Alice 160cm 90kg Bob \n      197cm 83kg\";\n16    let weights: Vec<_> = grouped_stream\n17      .split_whitespace()\n18      .skip(2)\n19      .step_by(3)\n20      .collect();\n21    println!(\"The weights of the people are: {:?}\", weights);\n22  }\n```", "```rs\nperson0 height0 weight0 person1 height1 weight1 person2 height2 weight2\n```", "```rs\n1   #![feature(test)]\n2   // The test crate was primarily designed for\n3   // the Rust compiler itself, so it has no stability guaranteed\n4   extern crate test;\n5   \n6   pub fn slow_fibonacci_recursive(n: u32) -> u32 {\n7     match n {\n8       0 => 0,\n9       1 => 1,\n10      _ => slow_fibonacci_recursive(n - 1) +  \n        slow_fibonacci_recursive(n - 2),\n11    }\n12  }\n13  \n14  pub fn fibonacci_imperative(n: u32) -> u32 {\n15    match n {\n16      0 => 0,\n17      1 => 1,\n18      _ => {\n19        let mut penultimate;\n20        let mut last = 1;\n21        let mut fib = 0;\n22        for _ in 0..n {\n23          penultimate = last;\n24          last = fib;\n25          fib = penultimate + last;\n26        }\n27        fib\n28      }\n29    }\n30  }\n31  \n32  pub fn memoized_fibonacci_recursive(n: u32) -> u32 {\n33    fn inner(n: u32, penultimate: u32, last: u32) -> u32 {\n34      match n {\n35        0 => penultimate,\n36        1 => last,\n37        _ => inner(n - 1, last, penultimate + last),\n38      }\n39    }\n40    inner(n, 0, 1)\n41  }\n42  \n43  pub fn fast_fibonacci_recursive(n: u32) -> u32 {\n44    fn inner(n: u32, penultimate: u32, last: u32) -> u32 {\n45      match n {\n46        0 => last,\n47        _ => inner(n - 1, last, penultimate + last),\n48      }\n49    }\n50    match n {\n51      0 => 0,\n52      _ => inner(n - 1, 0, 1),\n53    }\n54  }\n```", "```rs\n56  #[cfg(test)]\n57  mod tests {\n58    use super::*;\n59    use test::Bencher;\n60  \n61    // Functions annotated with the bench attribute will\n62    // undergo a performance evaluation when running \"cargo bench\"\n63    #[bench]\n64    fn bench_slow_fibonacci_recursive(b: &mut Bencher) {\n65      b.iter(|| {\n66        // test::block_box is \"black box\" for the compiler and   \n          LLVM\n67        // Telling them to not optimize a variable away\n68        let n = test::black_box(20);\n69        slow_fibonacci_recursive(n)\n70      });\n71    }\n72  \n73    #[bench]\n74    fn bench_fibonacci_imperative(b: &mut Bencher) {\n75      b.iter(|| {\n76        let n = test::black_box(20);\n77        fibonacci_imperative(n)\n78      });\n79    }\n80  \n81    #[bench]\n82    fn bench_memoized_fibonacci_recursive(b: &mut Bencher) {\n83      b.iter(|| {\n84        let n = test::black_box(20);\n85        memoized_fibonacci_recursive(n)\n86      });\n87    }\n88  \n89    #[bench]\n90    fn bench_fast_fibonacci_recursive(b: &mut Bencher) {\n91      b.iter(|| {\n92        let n = test::black_box(20);\n93        fast_fibonacci_recursive(n)\n94      });\n95    }\n96  }\n```", "```rs\n1   #![feature(generators, generator_trait,  \n    conservative_impl_trait)]\n2   \n3   fn main() {\n4     // A closure that uses the keyword \"yield\" is called a \n      generator\n5     // Yielding a value \"remembers\" where you left off\n6     // when calling .resume() on the generator\n7     let mut generator = || {\n8       yield 1;\n9       yield 2;\n10    };\n11    if let GeneratorState::Yielded(value) = generator.resume() {\n12      println!(\"The generator yielded: {}\", value);\n13    }\n14    if let GeneratorState::Yielded(value) = generator.resume() {\n15      println!(\"The generator yielded: {}\", value);\n16    }\n17    // When there is nothing left to yield,\n18    // a generator will automatically return an empty tuple\n19    if let GeneratorState::Complete(value) = generator.resume() {\n20      println!(\"The generator completed with: {:?}\", value);\n21    }\n22  \n23    // At the moment, you can return a different type\n24    // than you yield, although this feature is considered for  \n      removal\n25    let mut generator = || {\n26      yield 100;\n27      yield 200;\n28      yield 300;\n29      \"I'm a string\"\n30    };\n31    loop {\n32      match generator.resume() {\n33        GeneratorState::Yielded(value) => println!(\"The generator   \n          yielded: {}\", value),\n34        GeneratorState::Complete(value) => {\n35          println!(\"The generator completed with: {}\", value);\n36          break;\n37        }\n38      }\n39    }\n40  \n41    // Generators are great for implementing iterators.\n42    // Eventually, all Rust iterators are going to be rewritten \n      with generators\n43    let fib: Vec<_> = fibonacci().take(10).collect();\n44    println!(\"First 10 numbers of the fibonacci sequence: {:?}\", \n      fib);\n45  }\n46  \n47  // As of the time of writing, a generator does not have a\n48  // direct conversion to an iterator yet, so we need a wrapper:\n49  use std::ops::{Generator, GeneratorState};\n50  struct GeneratorIterator(T);\n51  impl Iterator for GeneratorIterator\n52  where\n53    T: Generator,\n54  {\n55    type Item = T::Yield;\n56    fn next(&mut self) -> Option {\n57      match self.0.resume() {\n58        GeneratorState::Yielded(value) => Some(value),\n59        GeneratorState::Complete(_) => None,\n60      }\n61    }\n62  }\n63  \n64  fn fibonacci() -> impl Iterator {\n65    // Using our wrapper\n66    GeneratorIterator(move || {\n67      let mut curr = 0;\n68      let mut next = 1;\n69      loop {\n70        yield curr;\n71        let old = curr;\n72        curr = next;\n73        next += old;\n74      }\n75    })\n76  }\n```", "```rs\nfn fibonacci() -> Fibonacci {\n    Fibonacci { curr: 0, next: 1 }\n}\nstruct Fibonacci {\n    curr: u32,\n    next: u32,\n}\nimpl Iterator for Fibonacci {\n    type Item = u32;\n    fn next(&mut self) -> Option<u32> {\n        let old = self.curr;\n        self.curr = self.next;\n        self.next += old;\n        Some(old)\n    }\n}\n```"]