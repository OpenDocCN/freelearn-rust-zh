["```rs\n1  fn main() {\n2    // Create a vector with some elements\n3    let fruits = vec![\"apple\", \"tomato\", \"pear\"];\n4    // A vector cannot be directly printed\n5    // But we can debug-print it\n6    println!(\"fruits: {:?}\", fruits);\n7\n8    // Create an empty vector and fill it\n9    let mut fruits = Vec::new();\n10    fruits.push(\"apple\");\n11   fruits.push(\"tomato\");\n12    fruits.push(\"pear\");\n13    println!(\"fruits: {:?}\", fruits);\n14\n15    // Remove the last element\n16    let last = fruits.pop();\n17    if let Some(last) = last {\n18        println!(\"Removed {} from {:?}\", last, fruits);\n19    }\n20\n21    // Insert an element into the middle of the vector\n22    fruits.insert(1, \"grape\");\n23    println!(\"fruits after insertion: {:?}\", fruits);\n24\n25    // Swap two elements\n26    fruits.swap(0, 1);\n27    println!(\"fruits after swap: {:?}\", fruits);\n```", "```rs\n29    // Access the first and last elements\n30    let first = fruits.first();\n31    if let Some(first) = first {\n32      println!(\"First fruit: {}\", first);\n33    }\n34    let last = fruits.last();\n35    if let Some(last) = last {\n36      println!(\"Last fruit: {}\", last);\n37    }\n38 \n39    // Access arbitrary elements\n40    let second = fruits.get(1);\n41    if let Some(second) = second {\n42      println!(\"Second fruit: {}\", second);\n43    }\n44    // Access arbitrary elements without bonds checking\n45    let second = fruits[1];\n46    println!(\"Second fruit: {}\", second);\n```", "```rs\n50    // Initialize the vector with a value\n51    // Here, we fill our vector with five zeroes\n52    let bunch_of_zeroes = vec![0; 5];\n53    println!(\"bunch_of_zeroes: {:?}\", bunch_of_zeroes);\n54 \n55    // Remove some item and shift all that come after\n56    // into place\n57    let mut nums = vec![1, 2, 3, 4];\n58    let second_num = nums.remove(1);\n59    println!(\"Removed {} from {:?}\", second_num, nums); \n60 \n61    // Filter the vector in place\n62    let mut names = vec![\"Aaron\", \"Felicia\", \"Alex\", \"Daniel\"];\n63    // Only keep names starting with 'A'\n64    names.retain(|name| name.starts_with('A'));\n65    println!(\"Names starting with A: {:?}\", names);\n66 \n67    // Check if the vector contains an element\n68    println!(\"Does 'names' contain \\\"Alex\\\"? {}\", \n        names.contains(&\"Alex\"));\n69 \n70 \n71 \n72    // Remove consecutive(!) duplicates\n73    let mut nums = vec![1, 2, 2, 3, 4, 4, 4, 5];\n74    nums.dedup();\n75    println!(\"Deduped, pre-sorted nums: {:?}\", nums);\n76 \n77    // Be careful if your data is not sorted!\n78    let mut nums = vec![2, 1, 4, 2, 3, 5, 1, 2];\n79    nums.dedup();\n80    // Doens't print what you might expect\n81    println!(\"Deduped, unsorted nums: {:?}\", nums);\n82 \n83    // Sort a vector\n84    nums.sort();\n85    println!(\"Manually sorted nums: {:?}\", nums);\n86    nums.dedup();\n87    println!(\"Deduped, sorted nums: {:?}\", nums);\n88 \n89    // Reverse a vector\n90    nums.reverse();\n91    println!(\"nums after being reversed: {:?}\", nums);\n92 \n93    // Create a consuming iterator over a range\n94    let mut alphabet = vec!['a', 'b', 'c'];\n95    print!(\"The first two letters of the alphabet are: \");\n96    for letter in alphabet.drain(..2) {\n97      print!(\"{} \", letter);\n98    }\n99    println!();\n100   // The drained elements are no longer in the vector\n101   println!(\"alphabet after being drained: {:?}\", alphabet);\n102 \n103 \n104   // Check if a vector is empty\n105   let mut fridge = vec![\"Beer\", \"Leftovers\", \"Mayonaise\"];\n106   println!(\"Is the fridge empty {}\", fridge.is_empty());\n107   // Remove all elements\n108   fridge.clear();\n109   println!(\"Is the fridge now empty? {}\", fridge.is_empty());\n```", "```rs\n111   // Split a vector into two pieces\n112   let mut colors = vec![\"red\", \"green\", \"blue\", \"yellow\"];\n113   println!(\"colors before splitting: {:?}\", colors);\n114   let half = colors.len() / 2;\n115   let mut second_half = colors.split_off(half);\n116   println!(\"colors after splitting: {:?}\", colors);\n117   println!(\"second_half: {:?}\", second_half);\n118 \n119   // Put two vectors together\n120   colors.append(&mut second_half);\n121   println!(\"colors after appending: {:?}\", colors);\n122   // This empties the second vector\n123   println!(\"second_half after appending: {:?}\", second_half);\n```", "```rs\n127   let mut stuff = vec![\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"];\n128   println!(\"Original stuff: {:?}\", stuff);\n129   let stuff_to_insert = vec![\"a\", \"b\", \"c\"];\n130   let removed_stuff: Vec<_> = stuff.splice(1..4, \n        stuff_to_insert).collect();\n131   println!(\"Spliced stuff: {:?}\", stuff);\n132   println!(\"Removed stuff: {:?}\", removed_stuff);\n```", "```rs\n136   // Initialize the vector with a certain capacity\n137   let mut large_vec: Vec<i32> = Vec::with_capacity(1_000_000);\n138   println!(\"large_vec after creation:\");\n139   println!(\"len:\\t\\t{}\", large_vec.len());\n140   println!(\"capacity:\\t{}\", large_vec.capacity());\n141 \n142   // Shrink the vector as close as possible to its length\n143   large_vec.shrink_to_fit();\n144   println!(\"large_vec after shrinking:\");\n145   println!(\"len:\\t\\t{}\", large_vec.len());\n146   println!(\"capacity:\\t{}\", large_vec.capacity());\n147 \n148   // Remove some item, replacing it with the last\n149   let mut nums = vec![1, 2, 3, 4];\n150   let second_num = nums.swap_remove(1);\n151   // This changes the order, but works in O(1)\n152   println!(\"Removed {} from {:?}\", second_num, nums);\n153 }\n```", "```rs\n1   fn main() {\n2     // As a String is a kind of vector,\n3     // you can construct them the same way\n4     let mut s = String::new();\n5     s.push('H');\n6     s.push('i');\n7     println!(\"s: {}\", s);\n8\n9     // The String however can also be constructed\n10    // from a string slice (&str)\n11    // The next two ways of doing to are equivalent\n12    let s = \"Hello\".to_string();\n13    println!(\"s: {}\", s);\n14    let s = String::from(\"Hello\");\n15    println!(\"s: {}\", s);\n16\n17    // A String in Rust will always be valid UTF-8\n18    let s = \" Þjóðhildur  \".to_string();\n19    println!(\"s: {}\", s);\n20\n21    // Append strings to each other\n22    let mut s = \"Hello \".to_string();\n23    s.push_str(\"World\");\n24\n25    // Iterate over the character\n26    // A \"character\" is defined here as a\n27    // Unicode Scalar Value\n28    for ch in \"Tubular\".chars() {\n29        print!(\"{}.\", ch);\n30    }\n31    println!();\n32    // Be careful though, a \"character\" might not\n33    // always be what you expect\n34    for ch in \"y̆\".chars() {\n35        // This does NOT print y̆\n36        print!(\"{} \", ch);\n37    }\n38    println!();\n```", "```rs\n42    // Split a string slice into two halves\n43    let (first, second) = \"HelloThere\".split_at(5);\n44    println!(\"first: {}, second: {}\", first, second);\n45\n46    // Split on individual lines\n47    let haiku = \"\\\n48                 she watches\\n\\\n49                 satisfied after love\\n\\\n50                 he lies\\n\\\n51                 looking up at nothing\\n\\\n52                 \";\n53    for line in haiku.lines() {\n54        println!(\"\\t{}.\", line);\n55    }\n56\n57    // Split on substrings\n58    for s in \"Never;Give;Up\".split(';') {\n59        println!(\"{}\", s);\n60    }\n61    // When the splitted string is at the beginning or end,\n62    // it will result in the empty string\n63    let s: Vec<_> = \"::Hi::There::\".split(\"::\").collect();\n64    println!(\"{:?}\", s);\n65\n66    // If you can eliminate the empty strings at the end\n67    // by using split_termitor\n68    let s: Vec<_> = \"Mr. T.\".split_terminator('.').collect();\n69    println!(\"{:?}\", s);\n70\n71    // char has a few method's that you can use to split on\n72    for s in \"I'm2fast4you\".split(char::is_numeric) {\n73        println!(\"{}\", s);\n74    }\n75\n76    // Split only a certain amount of times\n77    for s in \"It's not your fault, it's mine\".splitn(3,\n        char::is_whitespace) {\n78        println!(\"{}\", s);\n79    }\n80\n81    // Get only the substrings that match a pattern\n82    // This is the opposite of splitting\n83    for c in \"The Dark Knight rises\".matches(char::is_uppercase) {\n84        println!(\"{}\", c);\n85    }\n86\n87    // Check if a string starts with something\n88    let saying = \"The early bird gets the worm\";\n89    let starts_with_the = saying.starts_with(\"The\");\n90    println!(\n        \"Does \\\"{}\\\" start with \\\"The\\\"?: {}\",\n         saying,\n         starts_with_the\n      );\n91    let starts_with_bird = saying.starts_with(\"bird\");\n92    println!(\n        \"Does \\\"{}\\\" start with \\\"bird\\\"?: {}\",\n         saying,\n         starts_with_bird\n      );\n93\n94    // Check if a string ends with something\n95    let ends_with_worm = saying.ends_with(\"worm\");\n96    println!(\"Does \\\"{}\\\" end with \\\"worm\\\"?: {}\", saying,\n        ends_with_worm);\n```", "```rs\n97\n98    // Check if the string contains something somewhere\n99    let contains_bird = saying.contains(\"bird\");\n100   println!(\"Does \\\"{}\\\" contain \\\"bird\\\"?: {}\", saying,\n        contains_bird);\n```", "```rs\n105   // Splitting on whitespace might not result in what you expect\n106   let a_lot_of_whitespace = \"    I   love spaaace     \";\n107   let s: Vec<_> = a_lot_of_whitespace.split(' ').collect();\n108   println!(\"{:?}\", s);\n109   // Use split_whitespace instead\n110   let s: Vec<_> = \n        a_lot_of_whitespace.split_whitespace().collect();\n111   println!(\"{:?}\", s);\n112\n113   // Remove leading and trailing whitespace\n114   let username = \"   P3ngu1n\\n\".trim();\n115   println!(\"{}\", username);\n116   // Remove only leading whitespace\n117   let username = \"   P3ngu1n\\n\".trim_left();\n118   println!(\"{}\", username);\n119   // Remove only trailing whitespace\n120   let username = \"   P3ngu1n\\n\".trim_right();\n121   println!(\"{}\", username);\n122\n123\n124   // Parse a string into another data type\n125   // This requires type annotation\n126   let num = \"12\".parse::<i32>();\n127   if let Ok(num) = num {\n128     println!(\"{} * {} = {}\", num, num, num * num);\n129   }\n```", "```rs\n133   // Replace all occurences of a pattern\n134   let s = \"My dad is the best dad\";\n135   let new_s = s.replace(\"dad\", \"mom\");\n136   println!(\"new_s: {}\", new_s);\n137\n138   // Replace all characters with their lowercase\n139   let lowercase = s.to_lowercase();\n140   println!(\"lowercase: {}\", lowercase);\n141\n142   // Replace all characters with their uppercase\n143   let uppercase = s.to_uppercase();\n144   println!(\"uppercase: {}\", uppercase);\n145\n146   // These also work with other languages\n147   let greek = \"ὈΔΥΣΣΕΎΣ\";\n148   println!(\"lowercase greek: {}\", greek.to_lowercase());\n149\n150   // Repeat a string\n151   let hello = \"Hello! \";\n152   println!(\"Three times hello: {}\", hello.repeat(3));\n153 }\n```", "```rs\n    let s = \"Hello\".to_string();\n    println!(\"s: {}\", s);\n    let s = String::from(\"Hello\");\n    println!(\"s: {}\", s);\n```", "```rs\n1   fn main() {\n2     let names = vec![\"Joe\", \"Miranda\", \"Alice\"];\n3     // Iterators can be accessed in many ways.\n4     // Nearly all collections implement .iter() for this purpose\n5     let mut iter = names.iter();\n6     // A string itself is not iterable, but its characters are\n7     let mut alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars();\n8     // Ranges are also (limited) iterators\n9     let nums = 0..10;\n10    // You can even create infinite iterators!\n11    let all_nums = 0..;\n12\n13    // As the name says, you can iterate over iterators\n14    // This will consume the iterator\n15    for num in nums {\n16        print!(\"{} \", num);\n17    }\n18    // nums is no longer usable\n19    println!();\n20\n21    // Get the index of the current item\n22    for (index, letter) in \"abc\".chars().enumerate() {\n23      println!(\"#{}. letter in the alphabet: {}\", index + 1,\n          letter);\n24    }\n```", "```rs\n26    // going through an iterator, step by step\n27    if let Some(name) = iter.next() {\n28        println!(\"First name: {}\", name);\n29    }\n30    if let Some(name) = iter.next() {\n31        println!(\"Second name: {}\", name);\n32    }\n33    if let Some(name) = iter.next() {\n34        println!(\"Third name: {}\", name);\n35    }\n36    if iter.next().is_none() {\n37        println!(\"No names left\");\n38    }\n39\n40    // Arbitrary access to an item in the iterator\n41    let letter = alphabet.nth(3);\n42    if let Some(letter) = letter {\n43      println!(\"the fourth letter in the alphabet is: {}\",\n          letter);\n44    }\n45    // This works by consuming all items up to a point\n46    let current_first = alphabet.nth(0);\n47    if let Some(current_first) = current_first {\n48      // This will NOT print 'A'\n49      println!(\n50        \"The first item in the iterator is currently: {}\",\n51           current_first\n52      );\n53    }\n54    let current_first = alphabet.nth(0);\n55    if let Some(current_first) = current_first {\n56      println!(\n57        \"The first item in the iterator is currently: {}\",\n58           current_first\n59      );\n60    }\n61\n62    // Accessing the last item; This will\n63    // consume the entire iterator\n64    let last_letter = alphabet.last();\n65    if let Some(last_letter) = last_letter {\n66      println!(\"The last letter of the alphabet is: {}\",\n          last_letter);\n67    }\n```", "```rs\n69    // Collect iterators into collections\n70    // This requires an anotation of which collection we want\n71    // The following two are equivalent:\n72    let nums: Vec<_> = (1..10).collect();\n73    println!(\"nums: {:?}\", nums);\n74    let nums = (1..10).collect::<Vec<_>>();\n75    println!(\"nums: {:?}\", nums)\n```", "```rs\n79    // Taking only the first n items\n80    // This is often used to make an infinite iterator finite\n81    let nums: Vec<_> = all_nums.take(5).collect();\n82    println!(\"The first five numbers are: {:?}\", nums);\n83\n84    // Skip the first few items\n85    let nums: Vec<_> = (0..11).skip(2).collect();\n86    println!(\"The last 8 letters in a range from zero to 10:\n        {:?}\", nums);\n87\n88    // take and skip accept predicates in the form of\n89    // take_while and skip_while\n90    let nums: Vec<_> = (0..).take_while(|x| x * x <\n      50).collect();\n91    println!(\n92      \"All positive numbers that are less than 50 when squared: \n93        {:?}\", nums\n94    );\n95\n96    // This is useful to filter an already sorted vector\n97    let names = [\"Alfred\", \"Andy\", \"Jose\", \"Luke\"];\n98    let names: Vec<_> = names.iter().skip_while(|x|\n        x.starts_with('A')).collect();\n99    println!(\"Names that don't start with 'A': {:?}\", names);\n100\n101   // Filtering iterators\n102   let countries = [\n103     \"U.S.A.\",\n        \"Germany\",\n        \"France\",\n        \"Italy\",\n        \"India\",\n        \"Pakistan\",\n        \"Burma\",\n104   ];\n105   let countries_with_i: Vec<_> = countries\n106     .iter()\n107     .filter(|country| country.contains('i'))\n108     .collect();\n109   println!(\n110     \"Countries containing the letter 'i': {:?}\",\n111     countries_with_i\n112   );\n```", "```rs\n116   // Find the first element that satisfies a condition\n117   if let Some(country) = countries.iter().find(|country| \n118     country.starts_with('I')) {\n119       println!(\"First country starting with the letter 'I':\n            {}\", country);\n        }\n120\n121   // Don't get the searched item but rather its index\n122   if let Some(pos) = countries\n123     .iter()\n124     .position(|country| country.starts_with('I'))\n125     {\n126       println!(\"It's index is: {}\", pos);\n127     }\n128\n129   // Check if at least one item satisfies a condition\n130   let are_any = countries.iter().any(|country| country.len() ==\n        5);\n131   println!(\n132     \"Is there at least one country that has exactly five \n         letters? {}\",\n133      are_any\n134   );\n135\n136   // Check if ALL items satisfy a condition\n137   let are_all = countries.iter().all(|country| country.len() ==\n        5);\n138   println!(\"Do all countries have exactly five letters? {}\",\n        are_all);\n```", "```rs\n141   let sum: i32 = (1..11).sum();\n142   let product: i32 = (1..11).product();\n143   println!(\n144     \"When operating on the first ten positive numbers\\n\\\n145      their sum is {} and\\n\\\n146      their product is {}.\",\n147      sum, product\n148   );\n149 \n150   let max = (1..11).max();\n151   let min = (1..11).min();\n152   if let Some(max) = max {\n153     println!(\"They have a highest number, and it is {}\", max);\n154   }\n155   if let Some(min) = min {\n156     println!(\"They have a smallest number, and it is {}\", min);\n157   }\n```", "```rs\n161   // Combine an iterator with itself, making it infinite\n162   // When it reaches its end, it starts again\n163   let some_numbers: Vec<_> = (1..4).cycle().take(10).collect();\n164   // Reader exercise: Try to guess what this will print\n165   println!(\"some_numbers: {:?}\", some_numbers);\n166 \n167   // Combine two iterators by putting them after another\n168   let some_numbers: Vec<_> = (1..4).chain(10..14).collect();\n169   println!(\"some_numbers: {:?}\", some_numbers);\n170 \n171   // Zip two iterators together by grouping their first items\n172   // together, their second items together, etc.\n173   let swiss_post_codes = [8957, 5000, 5034];\n174   let swiss_towns = [\"Spreitenbach\", \"Aarau\", \"Suhr\"];\n175   let zipped: Vec<_> =\n        swiss_post_codes.iter().zip(swiss_towns.iter()).collect();\n176   println!(\"zipped: {:?}\", zipped);\n177 \n178   // Because zip is lazy, you can use two infine ranges\n179   let zipped: Vec<_> = (b'A'..)\n180     .zip(1..)\n181     .take(10)\n182     .map(|(ch, num)| (ch as char, num))\n183     .collect();\n184   println!(\"zipped: {:?}\", zipped);\n```", "```rs\n188   // Change the items' types\n189   let numbers_as_strings: Vec<_> = (1..11).map(|x|\n        x.to_string()).collect();\n190   println!(\"numbers_as_strings: {:?}\", numbers_as_strings);\n191 \n192   // Access all items\n193   println!(\"First ten squares:\");\n194   (1..11).for_each(|x| print!(\"{} \", x));\n195   println!();\n196 \n197   // filter and map items at the same time!\n198   let squares: Vec<_> = (1..50)\n199     .filter_map(|x| if x % 3 == 0 { Some(x * x) } else { None })\n200     .collect();\n201   println!(\n202     \"Squares of all numbers under 50 that are divisible by 3: \n203      {:?}\", squares\n204   );\n```", "```rs\n208   // Retrieve the entire alphabet in lower and uppercase:\n209   let alphabet: Vec<_> = (b'A' .. b'z' + 1) // Start as u8\n210     .map(|c| c as char) // Convert all to chars\n211     .filter(|c| c.is_alphabetic()) // Filter only alphabetic chars\n212     .collect(); // Collect as Vec<char>\n213   println!(\"alphabet: {:?}\", alphabet);\n214 }\n```", "```rs\n    let alphabet: Vec<_> = (b'A' .. b'z' + 1) // Start as u8\n        .map(|c| c as char)            // Convert all to chars\n        .filter(|c| c.is_alphabetic()) // Filter only alphabetic chars\n        .collect(); // Collect as Vec<char>\n```", "```rs\nfor (int i = 0; i < some_length; i++) { \n    ... \n}\n```", "```rs\nlet nums: Vec<_> = (1..10).collect();\nlet nums = (1..10).collect::<Vec<_>>();\n```", "```rs\n1   use std::collections::VecDeque;\n2 \n3   fn main() {\n4     // A VecDeque is best thought of as a\n5     // First-In-First-Out (FIFO) queue\n6 \n7     // Usually, you will use it to push_back data\n8     // and then remove it again with pop_front\n9     let mut orders = VecDeque::new();\n10    println!(\"A guest ordered oysters!\");\n11    orders.push_back(\"oysters\");\n12 \n13    println!(\"A guest ordered fish and chips!\");\n14    orders.push_back(\"fish and chips\");\n15 \n16    let prepared = orders.pop_front();\n17    if let Some(prepared) = prepared {\n18      println!(\"{} are ready\", prepared);\n19    }\n20 \n21    println!(\"A guest ordered mozarella sticks!\");\n22    orders.push_back(\"mozarella sticks\");\n23 \n24    let prepared = orders.pop_front();\n25    if let Some(prepared) = prepared {\n26      println!(\"{} are ready\", prepared);\n27    }\n28 \n29    println!(\"A guest ordered onion rings!\");\n30    orders.push_back(\"onion rings\");\n31 \n32    let prepared = orders.pop_front();\n33    if let Some(prepared) = prepared {\n34      println!(\"{} are ready\", prepared);\n35    }\n36 \n37    let prepared = orders.pop_front();\n38    if let Some(prepared) = prepared {\n39      println!(\"{} are ready\", prepared);\n40    }\n41 \n42    // You can freely switch your pushing\n43    // from front to back and vice versa\n44    let mut sentence = VecDeque::new();\n45    sentence.push_back(\"a\");\n46    sentence.push_front(\"had\");\n47    sentence.push_back(\"little\");\n48    sentence.push_front(\"Mary\");\n49    sentence.push_back(\"Lamb\");\n50    println!(\"sentence: {:?}\", sentence);\n51 \n52    // The same applies to popping data\n53    sentence.pop_front();\n54    sentence.push_front(\"Jimmy\");\n55    sentence.pop_back();\n56    sentence.push_back(\"Cat\");\n57    println!(\"sentence: {:?}\", sentence);\n58 \n59 \n60    // The rest of the VecDeque's methods are\n61    // pretty much the same as the vector's\n62    // However, the VecDeque has additional options\n63    // when swap removing!\n64    let mut some_queue = VecDeque::with_capacity(5);\n65    some_queue.push_back(\"A\");\n66    some_queue.push_back(\"B\");\n67    some_queue.push_back(\"C\");\n68    some_queue.push_back(\"D\");\n69    some_queue.push_back(\"E\");\n70    println!(\"some_queue: {:?}\", some_queue);\n71 \n72    // This is the same as Vec's swap_remove\n73    some_queue.swap_remove_back(2);\n74    println!(\"some_quere after swap_remove_back: {:?}\",\n        some_queue);\n75 \n76    // This is the nearly the same, but swaps the removed\n77    // element with the first one instead of the last one\n78    some_queue.swap_remove_front(2);\n79    println!(\"some_quere after swap_remove_front: {:?}\",\n        some_queue);\n80    }\n```", "```rs\n1   use std::collections::HashMap; \n2 \n3   fn main() {\n4     // The HashMap can map any hashable type to any other\n5     // The first type is called the \"key\"\n6     // and the second one the \"value\"\n7     let mut tv_ratings = HashMap::new();\n8     // Here, we are mapping &str to i32\n9     tv_ratings.insert(\"The IT Crowd\", 8);\n10    tv_ratings.insert(\"13 Reasons Why\", 7);\n11    tv_ratings.insert(\"House of Cards\", 9);\n12    tv_ratings.insert(\"Stranger Things\", 8);\n13    tv_ratings.insert(\"Breaking Bad\", 10);\n14 \n15    // Does a key exist?\n16    let contains_tv_show = tv_ratings.contains_key(\"House of\n        Cards\");\n17    println!(\"Did we rate House of Cards? {}\", contains_tv_show);\n18    let contains_tv_show = tv_ratings.contains_key(\"House\");\n19    println!(\"Did we rate House? {}\", contains_tv_show);\n20 \n21    // Access a value\n22    if let Some(rating) = tv_ratings.get(\"Breaking Bad\") {\n23      println!(\"I rate Breaking Bad {} out of 10\", rating);\n24    }\n25 \n26    // If we insert a value twice, we overwrite it\n27    let old_rating = tv_ratings.insert(\"13 Reasons Why\", 9);\n28    if let Some(old_rating) = old_rating {\n29      println!(\"13 Reasons Why's old rating was {} out of 10\",\n          old_rating);\n30    }\n31    if let Some(rating) = tv_ratings.get(\"13 Reasons Why\") {\n32      println!(\"But I changed my mind, it's now {} out of 10\",\n          rating);\n33    }\n34 \n35    // Remove a key and its value\n36    let removed_value = tv_ratings.remove(\"The IT Crowd\");\n37    if let Some(removed_value) = removed_value {\n38       println!(\"The removed series had a rating of {}\",\n           removed_value);\n39    }\n40 \n41    // Iterating accesses all keys and values\n42    println!(\"All ratings:\");\n43    for (key, value) in &tv_ratings {\n44      println!(\"{}\\t: {}\", key, value);\n45    }\n46 \n47    // We can iterate mutably\n48    println!(\"All ratings with 100 as a maximum:\");\n49    for (key, value) in &mut tv_ratings {\n50      *value *= 10;\n51      println!(\"{}\\t: {}\", key, value);\n52    }\n53 \n54    // Iterating without referencing the HashMap moves its\n        contents\n55    for _ in tv_ratings {}\n56    // tv_ratings is not usable anymore\n```", "```rs\n58    // Like with the other collections, you can preallocate a size\n59    // to gain some performance\n60    let mut age = HashMap::with_capacity(10);\n61    age.insert(\"Dory\", 8);\n62    age.insert(\"Nemo\", 5);\n63    age.insert(\"Merlin\", 10);\n64    age.insert(\"Bruce\", 9);\n65 \n66    // Iterate over all keys\n67    println!(\"All names:\");\n68    for name in age.keys() {\n69      println!(\"{}\", name);\n70    }\n71 \n72    // Iterate over all values\n73    println!(\"All ages:\");\n74    for age in age.values() {\n75      println!(\"{}\", age);\n76    }\n77 \n78    // Iterate over all values and mutate them\n79    println!(\"All ages in 10 years\");\n80    for age in age.values_mut() {\n81      *age += 10;\n82      println!(\"{}\", age);\n83    }\n84\n```", "```rs\n87    {\n88      let age_of_coral = age.entry(\"coral\").or_insert(11);\n89      println!(\"age_of_coral: {}\", age_of_coral);\n90    }\n91    let age_of_coral = age.entry(\"coral\").or_insert(15);\n92    println!(\"age_of_coral: {}\", age_of_coral);\n93 }\n```", "```rs\n    {\n        let age_of_coral = age.entry(\"coral\").or_insert(11);\n        println!(\"age_of_coral: {}\", age_of_coral);\n    }\n    let age_of_coral = age.entry(\"coral\").or_insert(15);\n    println!(\"age_of_coral: {}\", age_of_coral);\n```", "```rs\n1   use std::collections::HashSet;\n2 \n3   fn main() {\n4     // Most of the interface of HashSet\n5     // is the same as HashMap, just without\n6     // the methods that handle values\n7     let mut books = HashSet::new();\n8     books.insert(\"Harry Potter and the Philosopher's Stone\");\n9     books.insert(\"The Name of the Wind\");\n10    books.insert(\"A Game of Thrones\");\n11 \n12    // A HashSet will ignore duplicate entries\n13    // but will return if an entry is new or not\n14    let is_new = books.insert(\"The Lies of Locke Lamora\");\n15    if is_new {\n16      println!(\"We've just added a new book!\");\n17    }\n18 \n19    let is_new = books.insert(\"A Game of Thrones\");\n20    if !is_new {\n21      println!(\"Sorry, we already had that book in store\");\n22    }\n23 \n24    // Check if it contains a key\n25    if !books.contains(\"The Doors of Stone\") {\n26      println!(\"We sadly don't have that book yet\");\n27    }\n28 \n29    // Remove an entry\n30    let was_removed = books.remove(\"The Darkness that comes\n        before\");\n31    if !was_removed {\n32      println!(\"Couldn't remove book; We didn't have it to begin \n          with\");\n33    }\n34    let was_removed = books.remove(\"Harry Potter and the \n        Philosopher's Stone\");\n35    if was_removed {\n36      println!(\"Oops, we lost a book\");\n37    }\n```", "```rs\n41    let one_to_five: HashSet<_> = (1..6).collect();\n42    let five_to_ten: HashSet<_> = (5..11).collect();\n43    let one_to_ten: HashSet<_> = (1..11).collect();\n44    let three_to_eight: HashSet<_> = (3..9).collect();\n45 \n46    // Check if two HashSets have no elements in common\n47    let is_disjoint = one_to_five.is_disjoint(&five_to_ten);\n48    println!(\n49      \"is {:?} disjoint from {:?}?: {}\",\n50       one_to_five,\n51       five_to_ten,\n52       is_disjoint\n53    );\n54    let is_disjoint = one_to_five.is_disjoint(&three_to_eight);\n55    println!(\n56      \"is {:?} disjoint from {:?}?: {}\",\n57       one_to_five,\n58       three_to_eight,\n59       is_disjoint\n60    );\n61 \n62    // Check if a HashSet is fully contained in another\n63    let is_subset = one_to_five.is_subset(&five_to_ten);\n64    println!(\n65      \"is {:?} a subset of {:?}?: {}\",\n66       one_to_five,\n67       five_to_ten,\n68       is_subset\n69    );\n70    let is_subset = one_to_five.is_subset(&one_to_ten);\n71    println!(\n72      \"is {:?} a subset of {:?}?: {}\",\n73       one_to_five,\n74       one_to_ten,\n75       is_subset\n76    );\n77 \n78    // Check if a HashSet fully contains another\n79    let is_superset = three_to_eight.is_superset(&five_to_ten);\n80    println!(\n81      \"is {:?} a superset of {:?}?: {}\",\n82      three_to_eight,\n83      five_to_ten,\n84      is_superset\n85    );\n86    let is_superset = one_to_ten.is_superset(&five_to_ten);\n87    println!(\n88    \"is {:?} a superset of {:?}?: {}\",\n89      one_to_ten,\n90      five_to_ten,\n91      is_superset\n92    );\n```", "```rs\n96    // Get the values that are in the first HashSet\n97    // but not in the second\n98    let difference = one_to_five.difference(&three_to_eight);\n99    println!(\n100     \"The difference between {:?} and {:?} is {:?}\",\n101      one_to_five,\n102      three_to_eight,\n103      difference\n104   );\n105 \n106   // Get the values that are in either HashSets, but not in both\n107   let symmetric_difference = \n        one_to_five.symmetric_difference(&three_to_eight);\n108   println!(\n109     \"The symmetric difference between {:?} and {:?} is {:?}\",\n110      one_to_five,\n111      three_to_eight,\n112      symmetric_difference\n113   );\n114 \n115   // Get the values that are in both HashSets\n116   let intersection = one_to_five.intersection(&three_to_eight);\n117   println!(\n118     \"The intersection difference between {:?} and {:?} is {:?}\",\n119      one_to_five,\n120      three_to_eight,\n121      intersection\n122   );\n123 \n124   // Get all values in both HashSets\n125   let union = one_to_five.union(&three_to_eight);\n126   println!(\n127     \"The union difference between {:?} and {:?} is {:?}\",\n128      one_to_five,\n129      three_to_eight,\n130      union\n131   );\n132 }\n```", "```rs\n1   fn main() {\n2     let fib: Vec<_> = fibonacci().take(10).collect();\n3     println!(\"First 10 numbers of the fibonacci sequence: {:?}\", \n        fib);\n4 \n5     let mut squared_vec = SquaredVec::new();\n6     squared_vec.push(1);\n7     squared_vec.push(2);\n8     squared_vec.push(3);\n9     squared_vec.push(4);\n10    for (index, num) in squared_vec.iter().enumerate() {\n11      println!(\"{}^2 is {}\", index + 1, num);\n12    }\n13  }\n14 \n15 \n16  fn fibonacci() -> Fibonacci {\n17    Fibonacci { curr: 0, next: 1 }\n18  }\n19  struct Fibonacci {\n20  curr: u32,\n21  next: u32,\n22  }\n23  // A custom iterator has to implement\n24  // only one method: What comes next\n25  impl Iterator for Fibonacci {\n26    type Item = u32;\n27    fn next(&mut self) -> Option<u32> {\n28      let old = self.curr;\n29      self.curr = self.next;\n30      self.next += old;\n31      Some(old)\n32    }\n33  }\n34 \n35 \n36  use std::ops::Mul;\n37  struct SquaredVec<T>\n38  where\n39  T: Mul + Copy,\n40  {\n41    vec: Vec<T::Output>,\n42  }\n43  impl<T> SquaredVec<T>\n44  where\n45  T: Mul + Copy,\n46  {\n47    fn new() -> Self {\n48    SquaredVec { vec: Vec::new() }\n49  }\n50  fn push(&mut self, item: T) {\n51    self.vec.push(item * item);\n52  }\n53 }\n54 \n55  // When creating an iterator over a collection-like struct\n56  // It's best to just allow it to be convertible into\n57  // a slice of your underlying type.\n58  // This way you automatically implemented a bunch of methods\n59  // and are flexible enough to change your implementation later\n      on\n60  use std::ops::Deref;\n61  impl<T> Deref for SquaredVec<T>\n62  where\n63  T: Mul + Copy,\n64  {\n65    type Target = [T::Output];\n66    fn deref(&self) -> &Self::Target {\n67    &self.vec\n68  }\n69 }\n```", "```rs\nslab = \"0.4.0\"\n```", "```rs\n1   extern crate slab;\n2   use slab::{Slab, VacantEntry};\n3 \n4   fn main() {\n5     // A slab is meant to be used as a limited buffer\n6     // As such, you should initialize it with a pre-\n7     // defined capacity\n8     const CAPACITY: usize = 1024;\n9     let mut slab = Slab::with_capacity(CAPACITY);\n10 \n11    // You cannot simply access a slab's entry by\n12    // index or by searching it. Instead, every\n13    // insert gives you a key that you can use to\n14    // access its entry\n15    let hello_key = slab.insert(\"hello\");\n16    let world_key = slab.insert(\"world\");\n17 \n18    println!(\"hello_key -> '{}'\", slab[hello_key],);\n19    println!(\"world_key -> '{}'\", slab[world_key],);\n20 \n21 \n22    // You can pass an \"empty spot\" around\n23    // in order to be filled\n24    let data_key = {\n25    let entry = slab.vacant_entry();\n26      fill_some_data(entry)\n27    };\n28    println!(\"data_key -> '{}'\", slab[data_key],);\n29 \n30    // When iterating, you get a key-value pair\n31    for (key, val) in &slab {\n32      println!(\"{} -> {}\", key, val);\n33    }\n34 \n35    // If you want to keep your slab at a constant\n36    // capacity, you have to manually check its\n37    // length before inserting data\n38    if slab.len() != slab.capacity() {\n39      slab.insert(\"the slab is not at capacity yet\");\n40    }\n41  }\n42 \n43 \n44  fn fill_some_data(entry: VacantEntry<&str>) -> usize {\n45    let data = \"Some data\";\n46    // insert() consumes the entry\n47    // so we need to get the key before\n48    let key = entry.key();\n49    entry.insert(data);\n50    key\n51  }\n```", "```rs\n    if slab.len() != slab.capacity() {\n        slab.insert(\"the slab is not at capacity yet\");\n    }\n```"]