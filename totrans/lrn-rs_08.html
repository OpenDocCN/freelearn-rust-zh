<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Rust Application Lifetime</h1>
                
            
            
                
<p class="calibre1">Rust, as we have seen, is a very stable language. It is also what can be described as a memory-safe language in that, when the code is compiling, the compiler tests the code to ensure that things don't go wrong, such as accessing outside of an array or freeing memory twice.</p>
<p class="calibre1">This is purely down to Rust obeying three key rules—ownership, references (or borrowing, as it's more commonly known), and the application lifetime.</p>
<p class="calibre1">In this chapter, we will discuss and see how the three key facets work to ensure that your Rust application always behaves itself. They are as follows:</p>
<ul class="calibre12">
<li class="calibre13">Ownership</li>
<li class="calibre13">Borrowing</li>
<li class="calibre13">Lifetime</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">What are they?</h1>
                
            
            
                
<p class="calibre1">In a nutshell, we can think of the three facets in these terms.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Ownership</h1>
                
            
            
                
<p class="calibre1">When we think of ownership, we inevitably think of possession. I have a MacBook Pro, which I'm writing this text on currently. It is not part of any finance agreement, stolen, borrowed, or on a lease, therefore the ownership of it is mine.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Borrowing</h1>
                
            
            
                
<p class="calibre1">Should I sell or dispose of my computer, I will release the ownership to the next party, or to the recycling facilities. If my son has a DVD that I want to use, I will borrow it from him—he has not released ownership to me, just given it to me for a finite period. He will keep a record, or a reference, that I have it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Lifetime</h1>
                
            
            
                
<p class="calibre1">This is how long something lasts and, unfortunately, virtually nothing lasts forever. Once the application or ownership ends, the time from taking ownership to removing ownership, which includes the borrowing of something, is considered the lifetime of that object or process.</p>
<p class="calibre1">Let's consider each of these facets in more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Ownership in Rust</h1>
                
            
            
                
<p class="calibre1">In order to appreciate ownership, we will need to take a small detour into compilation abstractions and a very common pitfall.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Abstractions</h1>
                
            
            
                
<p class="calibre1">One aspect of any Rust application that holds it above other applications from other languages is that they are really fast and memory-safe. This is down to an ideal called a <strong class="calibre8">zero-cost abstraction</strong>. An abstraction is a way of hoisting a low-level construct higher, making it easier, safer, and more reliable. These are commonly seen in cross-platform libraries where a user interface has a common abstraction layer, so developers only need to say <kbd class="calibre10">var n = new Label {Text = "Hello"};</kbd> to create a label for the UI without needing to know what is going on under the hood.</p>
<p class="calibre1">It is usual that abstractions cause some sort of penalties, meaning that code that uses abstractions would run slower or use more memory than corresponding lower-level code. In terms of Rust, these zero-cost abstractions mean that, in terms of computer resources, they cause no penalties. This is normally performed during compilation; the compiler generates the abstractions and executes them. Once done, the compiler will generate the best possible code.</p>
<p class="calibre1">This does have a problem—the compiler will object to code that the developer considers completely fine. This is because, as people, we don't think the same way as a language does, so what we consider as correct ownership is not how Rust considers it. Thankfully, as time goes on, and you use Rust more, this problem becomes far less of one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Ownership – from the beginning</h1>
                
            
            
                
<p class="calibre1">Let's start by considering a very simple piece of code to help you understand how this works. We have seen the likes of the following plenty of times up to this point:</p>
<pre class="calibre21">fn my_function() 
{ 
    let mypi = 3.14f32; 
} </pre>
<p class="calibre1">When <kbd class="calibre10">my_function</kbd> is called (it comes into scope), Rust will allocate memory on the stack to store this value. When the function ends (it goes out of scope), Rust will do an automatic cleanup to deallocate any memory used by <kbd class="calibre10">mypi</kbd>.</p>
<p class="calibre1">A vector, or anything else that uses the heap, works in a similar way:</p>
<pre class="calibre21">fn my_second_function() 
{ 
    let myvec = vec![1.1f32, 2.2f32, 3.14f32]; 
} </pre>
<p class="calibre1">If you recall from <a href="part0106.html#352RK0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 5</a>, <em class="calibre9">Remember, Remember</em>, the vector requires memory both on the heap and on the stack and can be thought of like this:</p>
<table class="calibre4">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1">Function name</p>
</td>
<td class="calibre7">
<p class="calibre1">Address</p>
</td>
<td class="calibre7">
<p class="calibre1">Variable name</p>
</td>
<td class="calibre7">
<p class="calibre1">Value</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">heap</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">heap_posn - 1</kbd></p>
</td>
<td class="calibre7"/>
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">base_of_vecs</kbd></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7"/>
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">heap_posn - 2</kbd></p>
</td>
<td class="calibre7"/>
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">Vec[1]</kbd></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">my_second_function</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">0</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">myvec</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">heap_posn - 1</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="calibre1"> </p>
<p class="calibre1">This time, when <kbd class="calibre10">my_second_function</kbd> goes out of scope, not only is the position on the stack cleared, but also the contiguous locations pointed to by <kbd class="calibre10">myvec</kbd> on the heap.</p>
<p class="calibre1">I've given two examples of variables here for a good reason—the handling is different; a vector takes a generic parameter and these are handled differently to a standard variable type.</p>
<p class="calibre1">It's not quite as simple as this though, and to really understand how things work with ownership, we will really need to consider things on a basic level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Variable binding</h1>
                
            
            
                
<p class="calibre1">Let's consider the creation of a variable:</p>
<pre class="calibre21">let myvar = 10i32; </pre>
<p class="calibre1">We have created a non-mutable variable with the name <kbd class="calibre10">myvar</kbd>. We will then say that this variable has the value <kbd class="calibre10">10</kbd> as a 32-bit integer. In other words, if this was in C, it would be as follows:</p>
<pre class="calibre21">const int myvar = 32; </pre>
<p class="calibre1">What we have actually done here is create a binding between the variable name and the value. We say that <kbd class="calibre10">10i32</kbd> is bound to <kbd class="calibre10">myvar</kbd>. Bindings are very important when it comes to ownership. Rust has a rule that you can only have something bound to something else once.</p>
<p class="calibre1">Let's consider the following snippet as it demonstrates why things go wrong when at the zero-cost abstraction level:</p>
<pre class="calibre21">let myvec = vec![1i32, 2i32, 3i32]; 
let myothervec = myvec; </pre>
<p class="calibre1">Normally, as a developer, you'd look at this and say that <kbd class="calibre10">myvec</kbd> is bound to a vector of type <kbd class="calibre10">i32</kbd>, which contains three elements. You'd then assume that <kbd class="calibre10">myothervec</kbd> is just a copy of the first vector as in the likes of C, C++, and C#; that is what it means. The implementation will vary, but the meaning is the same.</p>
<p class="calibre1">The problem is that, in Rust, what it means is that I have first created <kbd class="calibre10">myvec</kbd>. When I then say that <kbd class="calibre10">myothervec = myvec</kbd>, I am actually telling the compiler that the ownership of what <kbd class="calibre10">myvec</kbd> was bound to has now been given to <kbd class="calibre10">myothervec</kbd> and therefore <kbd class="calibre10">myvec</kbd> is out of scope and if (as a developer) I try to do anything with <kbd class="calibre10">myvec</kbd>, then the compiler is to fail the build.</p>
<p class="calibre1">The following screenshot demonstrates this (it can be found in <kbd class="calibre10">Chapter 8/outofscope</kbd>). When you attempt to build it, you will get the following results:</p>
<div><img class="image-border6" src="img/00054.jpeg"/></div>
<p class="calibre1">We will get a similar sort of issue when a function takes ownership.</p>
<p class="calibre1">The following can be found in <kbd class="calibre10">08/function_outofscope</kbd>:</p>
<pre class="calibre21">fn transfer_vec(v: Vec&lt;i32&gt;)  
{ 
    println!("v[0] in transfer_vec = {}", v[0]); 
} 
 
fn main()  
{ 
    let myvec = vec![1i32, 2i32, 3i32];  
    transfer_vec(myvec);  
    println!("myvec[0] is: {}", myvec[0]); 
} </pre>
<p class="calibre1">On the first look through, we don't see the obvious transfer of ownership and, usually, when you pass a variable to a function, you don't really consider that as a transfer. In Rust, passing a variable directly to another function is the same as in our first example: the ownership is released from <kbd class="calibre10">myvec</kbd> and passed to the function.</p>
<p class="calibre1">To prove this, try to compile the code and you will end up with the following output:</p>
<div><img class="image-border6" src="img/00055.jpeg"/></div>
<p class="calibre1">In other words, it's the same error as earlier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Stack and heap variables</h1>
                
            
            
                
<p class="calibre1">To understand why we get this problem, we will need to understand in depth how Rust works, and by this I mean at memory level.</p>
<p class="calibre1">Let's start with our variable:</p>
<pre class="calibre21">let myvar = 32i32; </pre>
<p class="calibre1">As I've said, in our minds, we will create a <kbd class="calibre10">myvar</kbd> variable of type <kbd class="calibre10">i32</kbd> and bind it to the value <kbd class="calibre10">32</kbd>. Rust, on the other hand, does it differently.</p>
<p class="calibre1">Firstly, it identifies that we will need space on the stack for a value that is the size of <kbd class="calibre10">i32</kbd>.</p>
<p class="calibre1">Next, it copies the value for <kbd class="calibre10">32</kbd> into that space allocated on the stack.</p>
<p class="calibre1">Lastly, it binds the binding to the position of the stack allocated block to the variable name.</p>
<p class="calibre1">In other words, the complete opposite to how we do it in our minds.</p>
<p class="calibre1">Let's see what happens when we create another binding, like this:</p>
<pre class="calibre21">let myvartwo = myvar; </pre>
<p class="calibre1">The compiler moves the binding to where the data sits on the stack for <kbd class="calibre10">myvar</kbd> and then says that that position (and data) belongs to <kbd class="calibre10">myvartwo</kbd>. The binding will be transferred. What happens to <kbd class="calibre10">myvar</kbd> though? Rust won't allow things to <em class="calibre9">dangle</em> or allow information to be bound to two different objects. Once the binding is transferred, <kbd class="calibre10">myvar</kbd> is removed.</p>
<p class="calibre1">The same thing happens if the binding points to something in the heap. Therefore, when we consider <kbd class="calibre10">let myvec = vec![1i32, 2i32, 3i32];</kbd>, <kbd class="calibre10">let myvec = vec![1i32, 2i32, 3i32];</kbd> we know how this will work. The compiler knows that it requires space on the heap, enough to hold three elements of type <kbd class="calibre10">i32</kbd>. These values are copied into the locations and the base address of the contiguous chunk of memory is bound to <kbd class="calibre10">myvec</kbd>.</p>
<p class="calibre1">Now, let's transfer ownership:</p>
<pre class="calibre21">let vectwo = myvec; </pre>
<p class="calibre1">Now, <kbd class="calibre10">vectwo</kbd> is the only usable binding to the vector on the heap, and <kbd class="calibre10">myvec</kbd> gets invalidated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Why is this important?</h1>
                
            
            
                
<p class="calibre1">A very common error in the likes of C# is when you have the following code:</p>
<pre class="calibre21">var myList = new List&lt;int&gt;{1,2,3,4,5,6}; 
var dupVar = myList; 
dupVar.Remove(4); // 4 
foreach(var n in myList) 
    Console.WriteLine(n); </pre>
<p class="calibre1">The output we will get from this may not be as you would expect, which is as follows:</p>
<div><img class="image-border14" src="img/00056.jpeg"/></div>
<p class="calibre1">It may be expected that, as we have removed the duplicate from <kbd class="calibre10">dupVar</kbd>, the <kbd class="calibre10">myList</kbd> variable should still have all of the numbers it was set to originally. In this code, what is happening is that <kbd class="calibre10">dupVar</kbd> is known as a copy pointer—we have two variables bound to the same pointer on the stack. While it may not seem that big a deal, we have two variable names that are able to change data. This catches a lot of people out and leads to more memory and content bugs than it is worth.</p>
<p class="calibre1">As Rust only allows one pointer per block, we cannot have the likes of this. Once ownership is transferred, the original bound name can no longer be accessed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Copy trait</h1>
                
            
            
                
<p class="calibre1">The code for this section can be found in <kbd class="calibre10">08/copyint</kbd> and <kbd class="calibre10">08/copyf32</kbd>.</p>
<p class="calibre1">Rust does have a way to create a copy of the original: the <kbd class="calibre10">Copy</kbd> trait (traits are covered in <a href="part0238.html#72V5S0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 10</a>, <em class="calibre9">Creating your own Crate</em>) and all primitives implement <kbd class="calibre10">Copy</kbd>. If we have something along the lines of <kbd class="calibre10">let varone = 1i32;</kbd> or <kbd class="calibre10">let vartwo = varone;</kbd>, then <kbd class="calibre10">i32</kbd> is a primitive type and the <kbd class="calibre10">vartwo</kbd> variable will contain a copy of <kbd class="calibre10">varone</kbd>. Both will have their own allocations on the stack, rather than <kbd class="calibre10">vartwo</kbd> pointing to <kbd class="calibre10">varone</kbd>. Ownership will not be changed; the value is duplicated and bound to the new variable.</p>
<p>The code for this section can be found in the <kbd class="calibre22">08/copyint</kbd> and <kbd class="calibre22">08/copyf32</kbd> folders in the supporting code bundle provided for this book.</p>
<p class="calibre1">Therefore, we can write the code as follows:</p>
<pre class="calibre21">fn do_something(number: i32) -&gt; i32  
{ 
    number + 32 
} 
 
fn main()  
{ 
    let num = 10i32;  
    let numtwo = do_something(num);  
    println!("num is: {}", num); 
    println!("numtwo is : {}", numtwo); 
} </pre>
<p class="calibre1">The preceding code will give the following output when compiled (<kbd class="calibre10">numone</kbd> is an <kbd class="calibre10">i32</kbd> value, which is a primitive, so it makes a copy of itself when passed to <kbd class="calibre10">do_something</kbd> with an <kbd class="calibre10">i32</kbd> being returned into <kbd class="calibre10">numtwo</kbd>):</p>
<div><img class="image-border6" src="img/00057.jpeg"/></div>
<p class="calibre1">The <kbd class="calibre10">copyf32</kbd> example shows the same <kbd class="calibre10">Copy</kbd> trait in action but for an <kbd class="calibre10">f32</kbd> primitive.</p>
<p class="calibre1">There must be a way around this.</p>
<p class="calibre1">In a way, we've seen an answer already in many examples used throughout this book—we hand the ownership back; however, as the following code block shows, it can get a bit messy:</p>
<pre class="calibre21">fn sumprod(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) 
{ 
    let sum = v1.iter().fold(0i32, |a, &amp;b| a + b); 
    let product = v2.iter().fold(1i32, |a, &amp;b| a * b); 
    return (v1, v2, sum + product); // return ownership 
} 
 
fn main()  
{ 
    let vecone = vec![2,3,5]; 
    let vectwo = vec![3,5];  
    let (vecone, vectwo, ans) = sumprod(vecone, vectwo); // pass ownership  
    println!("ans = {}", ans); 
} </pre>
<p class="calibre1">The preceding code will give the following output:</p>
<div><img class="image-border6" src="img/00058.jpeg"/></div>
<p>The code for this section can be found in the <kbd class="calibre22">Chapter8/handback</kbd> folder in the supporting code bundle provided for this book.</p>
<p class="calibre1">Thankfully, Rust does provide a neater way to pass ownership around. Instead of giving ownership, we can borrow ownership.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Borrowing in Rust</h1>
                
            
            
                
<p class="calibre1">Way back in Chapter 2, <em class="calibre9">Variables</em>, we referred to something known as a reference and it was said to be a copy of the pointer to some memory location. This is a big part of what is meant by borrowing in Rust.</p>
<p class="calibre1">In our preceding example, we can make use of borrowing. Our code for it is as follows:</p>
<pre class="calibre21">fn sumprod(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 
{ 
    let sum = v1.iter().fold(0i32, |a, &amp;b| a + b); 
    let product = v2.iter().fold(1i32, |a, &amp;b| a * b); 
    return sum + product;  
} 
 
fn main()  
{ 
    let vecone = vec![2,3,5]; 
    let vectwo = vec![3,5];  
    let ans = sumprod(&amp;vecone, &amp;vectwo);  
    println!("ans = {}", ans); 
} </pre>
<p>The code for this section can be found in the <kbd class="calibre22">08/handback</kbd> folder which can be found in the supporting code bundle of this book.</p>
<p class="calibre1">We will no longer pass ownership, but rather we will pass the reference to the vector. When compiled, we will get the following result:</p>
<div><img class="image-border15" src="img/00059.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Borrow immutability</h1>
                
            
            
                
<p class="calibre1">If we look back to the start of this chapter, I described borrowing as borrowing a DVD from my son. When I take possession of the DVD, I cannot change it, as my son would expect the same DVD back.</p>
<p class="calibre1">The same applies for Rust: the references cannot be changed as they are immutable values. If you think about it, this makes sense. Let me explain.</p>
<p class="calibre1">I have created a <kbd class="calibre10">Vec&lt;T&gt;</kbd> array type, which is, let's say, eight values long (it doesn't matter what the values are or the type they are). When the binding between the heap and stack is made, it will be of a particular type. If we allow the reference to alter the vector, we will have the same problem as the C# example and so the guarantees can't be assured and the Rust compiler will fail the build. To ensure that the guarantee is kept, Rust simply says that you are unable to change the values borrowed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Mutable borrows</h1>
                
            
            
                
<p class="calibre1">This is more a writable DVD than a prerecorded one if we use the analogy of borrowing a DVD.</p>
<p class="calibre1">Here, we are using a mutable reference, and we have to be careful how we use these.</p>
<p>The code for this section is in the <kbd class="calibre22">08/mutableref1</kbd> and <kbd class="calibre22">08/mutableref2</kbd> folders in the supporting code bundle provided for this book.</p>
<p class="calibre1">In our first example <kbd class="calibre10">(mutableref1</kbd>), we will create a variable, the reference, do something, and get a new value out:</p>
<pre class="calibre21">fn main()  
{ 
    let mut mutvar = 5; 
    { 
        println!("{}", mutvar); // outputs 5 
        let y = &amp;mut mutvar; // creates the mutable ref to mutvar 
        *y += 1; // adds one to the reference and passes it back in to mutvar 
    } 
    println!("{}", mutvar); // outputs 6 
} </pre>
<p class="calibre1">The important line here is <kbd class="calibre10">*y += 1</kbd>; and, in particular, the <kbd class="calibre10">*</kbd>, as this means we're directly altering the value of the memory position that the reference points to. When dealing with anything to do with memory, absolute care has to be observed.</p>
<p class="calibre1">The second important point to observe is that we have a set of braces around the code used in the mutable reference. Remove them and everything fails (<kbd class="calibre10">mutableref2</kbd>):</p>
<div><img class="image-border6" src="img/00060.jpeg"/></div>
<p class="calibre1">The important line is the result of the error; it is saying that you cannot borrow the same item as both mutable and immutable at the same time. It's like saying you can borrow something that can and can't be changed at the same time! Utter nonsense. This is down to borrowing having rules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Rust borrowing rules</h1>
                
            
            
                
<p class="calibre1">There are two rules that must be observed with borrowing, which are as follows:</p>
<ul class="calibre12">
<li class="calibre13">What you borrow must not outlive the original</li>
<li class="calibre13">You can have one of the following types of borrow, but never at the same time:
<ul class="calibre31">
<li class="calibre13">One (or more) references of type <kbd class="calibre10">&amp;T</kbd> to a resource</li>
<li class="calibre13">Only one mutable reference</li>
</ul>
</li>
</ul>
<p class="calibre1">The first rule makes sense: you can't have the reference outlive where it came from as once where it comes from goes out of scope, it is destroyed and, once destroyed, what are you borrowing exactly?</p>
<p class="calibre1">The second one requires a bit more thought about why it is as it should be and what it is that Rust is trying to achieve.</p>
<p class="calibre1">In this case, Rust is ensuring that something known as a <strong class="calibre8">race condition</strong> occurs (if you are used to writing multithreaded applications, you'll already understand these).</p>
<p class="calibre1">Here, Rust is trying to prevent two references trying to access the same point of memory at the same time. In other words, Rust is trying to prevent a synchronization error.</p>
<p class="calibre1">With non-mutable references, you can have as many as you'd like, as the references can never be written to. With a mutable reference, Rust prevents the problem by allowing just a single reference to be valid.</p>
<p class="calibre1">With this in mind, can we use these rules to fix our code from <kbd class="calibre10">mutableref2</kbd> in order to do away with the <kbd class="calibre10">{}</kbd> braces around the mutable reference?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Fixing the problem</h1>
                
            
            
                
<p class="calibre1">Let's examine the code again (I've removed anything from the original that is not required here):</p>
<pre class="calibre21">let mut mutvar = 5; 
let y = &amp;mut mutvar;  
*y += 1;  
println!("{}", mutvar); </pre>
<p class="calibre1">When we try and compile, we get the following output returned from the compiler:</p>
<div><img class="image-border6" src="img/00061.jpeg"/></div>
<p class="calibre1">We have broken the second rule—you can only have a single mutable or many immutables, never both.</p>
<p class="calibre1">How can we solve this? Let's look back to the original <kbd class="calibre10">mutableref1</kbd>:</p>
<pre class="calibre21">fn main()  
{ 
    let mut mutvar = 5; 
    { 
        println!("{}", mutvar); // outputs 5 
        let y = &amp;mut mutvar; // creates mutable reference to mutvar 
        *y += 1; // adds 1 and passes result back in to mutvar 
    } 
    println!("{}", mutvar); // outputs 6 
} </pre>
<p class="calibre1">This works, but why?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Think about the scope</h1>
                
            
            
                
<p class="calibre1">What is actually happening with this code is that we created a new scope for the borrowing section of the code, which passes back in to <kbd class="calibre10">mutvar</kbd> before the final <kbd class="calibre10">println!</kbd> is reached. In other words, the scope changes; therefore, when <kbd class="calibre10">mutvar</kbd> is hit on the <kbd class="calibre10">println!</kbd>, no borrowing is occurring and we're just displaying whatever is bound to the <kbd class="calibre10">mutvar</kbd> variable.</p>
<p class="calibre1">If we want to remove the braces, we will have to ensure that the borrowing has finished before we output through <kbd class="calibre10">println!</kbd></p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">It's all for your own good</h1>
                
            
            
                
<p class="calibre1">These compiler rules are there to help you as a developer. They prevent the sorts of issues commonly found in other languages, the biggest being writing to a variable after it is destroyed or doing something stupid, such as trying to mutate a vector inside of a loop iterating through that vector:</p>
<pre class="calibre21">fn main()  
{ 
    let mut myvec = vec![5i32, 10i32, 15i32, 20i32, 25i32, 30i32]; 
     
    for i in &amp;myvec 
    { 
        println!("i = {}", i); 
        myvec.push(35i32);  
    } 
} </pre>
<p>The source for this section is in the <kbd class="calibre22">08/invaliditerator</kbd> folder in the supporting code bundle for this book, with additional discussion in Chapter 5, <em class="calibre23">Memory Management</em>.</p>
<p class="calibre1">This is obviously never going to work. If you think about it, we have a loop that takes <kbd class="calibre10">myvec</kbd> as the argument and then, within the loop, we will add to the vector, so the loop never knows about one of the guarantees, as that guarantee is not there: the iterator count. It won't build as well because we are breaking the second borrowing rule.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The lifetime</h1>
                
            
            
                
<p class="calibre1">Let's consider another piece of code which won't work:</p>
<pre class="calibre21">let varname: &amp;f32; 
{ 
    let x = 3.14f32; 
    varname = &amp;x; 
} 
println!("varname = {}", varname); </pre>
<p class="calibre1">When trying to build this piece of code, the compiler will complain as follows:</p>
<div><img class="image-border16" src="img/00062.jpeg"/></div>
<p class="calibre1">You may recall that we had something similar to the following piece of code back in Chapter 4, <em class="calibre9">Conditions, Recursion, and Loops</em>:</p>
<pre class="calibre21">let y: &amp;f32; 
{ 
    let x_squared = x * x; 
    let x_cube = x_squared * x; 
    y = &amp;(x_cube + x_squared + x); 
}; 
println!("Y = {}", *y); </pre>
<p class="calibre1">In Chapter 5, <em class="calibre9">Memory Management</em>, we then explained why the preceding code would not work.</p>
<p class="calibre1">We are assigning <kbd class="calibre10">y</kbd> to the value of a variable that only exists in a small scope and then trying to access that value, which is giving rise to undefined behavior. As we've seen, the Rust compiler will do everything it can to prevent this sort of error. In this case, the compiler keeps track of each and every reference and fails to build if a reference lasts longer than the pointer in use.</p>
<p class="calibre1">We have the same happening here: <kbd class="calibre10">varname</kbd> is declared before <kbd class="calibre10">x</kbd>; therefore, it lives longer than <kbd class="calibre10">x</kbd>, which is what gives rise to the error.</p>
<p class="calibre1">The preceding code is a simple demonstration of a lifetime, but it's not as simple as that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The mythical bank account</h1>
                
            
            
                
<p class="calibre1">To demonstrate a more complex problem with lifetimes, let's consider a mythical bank account:</p>
<ul class="calibre12">
<li class="calibre13">I am given access to a bank account, legally, of course</li>
<li class="calibre13">I decide that I want my friend to have access to it</li>
<li class="calibre13">After a certain amount of time, I decide I no longer want access to the account and have my access removed</li>
<li class="calibre13">My friend then tries to use the account</li>
</ul>
<p class="calibre1">When my friend comes to use the account, he is unable to do so, as the reference I had, and which was passed to him, no longer exists. He is trying to <em class="calibre9">use after free</em> (in programming terms) and he is known here as a <strong class="calibre8">dangling reference</strong>.</p>
<p class="calibre1">It sounds far-fetched, but in development terms, it happens far more frequently than you would possibly give credit for.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The lifetime variable - '</h1>
                
            
            
                
<p class="calibre1">We have two types of lifetime within Rust—implicit and explicit. We have seen the implicit functions plenty of times:</p>
<pre class="calibre21">fn myfunction(pi: &amp;f32) 
{ 
    // do something 
} </pre>
<p class="calibre1">The lifetime of the function is the length of time the code inside of the braces exists once it is called.</p>
<p class="calibre1">We also have an explicit lifetime, denoted by <kbd class="calibre10">'</kbd> before the name:</p>
<pre class="calibre21">fn expfunction&lt;'a&gt;(pi: &amp;'a f32) 
{ 
    // do something 
} </pre>
<p class="calibre1">However, what exactly does the <kbd class="calibre10">'a</kbd> mean?</p>
<p class="calibre1">It means, for the lifetime of <kbd class="calibre10">a</kbd>. The <kbd class="calibre10">&lt;&gt;</kbd> after <kbd class="calibre10">expfunction</kbd> means that the function is taking a generic parameter (these will all become clear in Chapter 9, <em class="calibre9">Generics and Traits</em>), but it means of a type. If you consider <kbd class="calibre10">Vec</kbd>, it is actually <kbd class="calibre10">Vec&lt;T&gt;</kbd>. When we create a vector of type <kbd class="calibre10">f32</kbd>, <kbd class="calibre10">T</kbd> becomes <kbd class="calibre10">f32</kbd>, so it's <kbd class="calibre10">Vec&lt;f32&gt;</kbd> when it comes to compile time. In the case of <kbd class="calibre10">expfunction</kbd>, <kbd class="calibre10">T</kbd> is <kbd class="calibre10">'a</kbd>, and therefore the type inside the <kbd class="calibre10">()</kbd> has to also be <kbd class="calibre10">'a</kbd>.</p>
<p class="calibre1">If we had another parameter within the <kbd class="calibre10">&lt;&gt;</kbd>, we would have <kbd class="calibre10">&lt;'a, 'b&gt;(f: &amp;'a f32, g: &amp;'b i32)</kbd>, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Lifetime of other types</h1>
                
            
            
                
<p class="calibre1">We will commonly see lifetimes expressed with the likes of <kbd class="calibre10">struct</kbd> and <kbd class="calibre10">impl</kbd> (<kbd class="calibre10">impl</kbd> and the <kbd class="calibre10">impl</kbd> lifetime are dealt with in Chapter 10, <em class="calibre9">Matching and Structures</em>). You can have multiple lifetimes used as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Lifetime within an struct</h1>
                
            
            
                
<p class="calibre1">As seen in Chapter 7, <em class="calibre9">Structs</em>, within Rust have a special purpose and they can also take multiple types within them and can be extended as much as required with as many parameters as required. Let's consider the following piece of code as an example:</p>
<pre class="calibre21">struct MyStruct 
{ 
    a: i32, 
    b: f32, 
    c: bool, 
} </pre>
<p class="calibre1">The preceding code creates a <kbd class="calibre10">struct</kbd> called <kbd class="calibre10">MyStruct</kbd> with three properties called <kbd class="calibre10">a</kbd>, <kbd class="calibre10">b</kbd>, and <kbd class="calibre10">c</kbd>. When an instance of <kbd class="calibre10">mystruct</kbd> is called into scope, the elements within <kbd class="calibre10">struct</kbd> can be readily accessed. If we want <kbd class="calibre10">struct</kbd> to be able to take a lifetime variable, we will have to both explicitly ask <kbd class="calibre10">struct</kbd> to take that lifetime variable and then allocate it to an element, as shown in the following code:</p>
<pre class="calibre21">struct&lt;'a&gt; MyStruct 
{ 
    lifetimevar: &amp;'a f32, 
    nvar: i32, 
} </pre>
<p class="calibre1">With the lifetime variable in there, we can be assured that the structure cannot outlive the <kbd class="calibre10">f32</kbd> reference it was passed to.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Multiple lifetimes</h1>
                
            
            
                
<p class="calibre1">Both of these are acceptable to define multiple lifetimes within a function:</p>
<pre class="calibre21">fn mylifetime&lt;'a&gt;(life: &amp;'a i32, universe: &amp;'a i32) -&gt; &amp;'a i32 
{ 
     // do something, return an i32 value 
} </pre>
<p class="calibre1">We have two parameters of the lifetime of <kbd class="calibre10">'a</kbd> cast as an <kbd class="calibre10">i32</kbd> value and return an <kbd class="calibre10">i32</kbd> value.</p>
<p class="calibre1">We can also have multiple lifetimes passed in, as follows:</p>
<pre class="calibre21">fn mymultilife&lt;'a, 'b&gt;(foo: &amp;'a f32, bar: &amp;'b i32) 
{ 
    // do something 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Always consider the scope</h1>
                
            
            
                
<p class="calibre1">As with borrowing, we have to consider the scope to ensure that things work correctly.</p>
<p class="calibre1">The following piece of code, for example, won't work:</p>
<pre class="calibre21">struct MyStruct&lt;'a&gt; { 
    lifea: &amp;'a i32, 
} 
 
fn main()  
{ 
    let x;  
    {   
        let y = &amp;5; // means let y = 5; let y = &amp;y; 
        let f = MyStruct { lifea: y };  
        x = &amp;f.lifea  
    }  
    println!("{}", x);  
} </pre>
<p>The code for this section is in the <kbd class="calibre22">08/lifetimescope</kbd> folder of the supporting code bundle provided along with this book.</p>
<p class="calibre1">It may not seem obvious at first why this should not work. In terms of scope, <kbd class="calibre10">f</kbd> is created after <kbd class="calibre10">y</kbd>, so is in the scope of <kbd class="calibre10">y</kbd> and <kbd class="calibre10">y</kbd> is created within the scope of <kbd class="calibre10">x</kbd>. Or is it?</p>
<p class="calibre1">When the code is built, we will get the following output:</p>
<div><img class="image-border17" src="img/00063.jpeg"/></div>
<p class="calibre1">The error will be the <kbd class="calibre10">x = &amp;f.lifea</kbd>, as we attempted to assign a value of something about to go out of scope.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">'struct</h1>
                
            
            
                
<p class="calibre1">One aspect of many languages that is useful is to have a variable that lives for the lifetime of the entire application. While some purists argue that having a variable that lasts for the life of an application is not good practice, they cannot argue that it has its uses.</p>
<p class="calibre1">Within Rust, we can also do this using a special <kbd class="calibre10">struct</kbd> type, a lifetime <kbd class="calibre10">struct</kbd>:</p>
<pre class="calibre21">let version: &amp;'static str = "v1.3, 22nd May 2016";  </pre>
<p class="calibre1">Local type inference allows us to omit the type when it is not global, so this is equivalent to the above when inside a function:</p>
<pre class="calibre21">let version = "v1.3, 22nd May 2016"; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Input and output lifetimes</h1>
                
            
            
                
<p class="calibre1">Although not commonly considered, there are two types of lifetimes: input (going into the function) and output (coming out of the function).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Input only</h1>
                
            
            
                
<p class="calibre1">The following code snippet is an example of a function with an input lifetime:</p>
<pre class="calibre21">fn inponlyfn&lt;'a&gt;(inp: &amp;'a as i32) {...} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Output only</h1>
                
            
            
                
<p class="calibre1">The following code snippet is an example of a function with an output lifetime:</p>
<pre class="calibre21">fn outonlyfn&lt;'a&gt;() -&gt; &amp;'a as i32 {...} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Input and output</h1>
                
            
            
                
<p class="calibre1">The following code snippet is an example of a function with both input and output lifetimes:</p>
<pre class="calibre21">fn inandout&lt;'a&gt;(inp: &amp;'a str) -&gt; &amp;'a str {...} </pre>
<p class="calibre1">We can conclude the following from the preceding code snippet:</p>
<ul class="calibre12">
<li class="calibre13">Each lifetime in the function argument becomes a distinct lifetime parameter</li>
<li class="calibre13">If there is one input lifetime, the lifetime is assigned to all lifetimes in the return value</li>
</ul>
<p class="calibre1">There is another concept that we will need to include: if there are multiple input lifetimes and one of them points to <kbd class="calibre10">&amp;self</kbd> (either mutable or immutable), the lifetime of self applies to all output lifetimes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre1">Understanding how Rust deals with the lifetime of variables is of key importance in ensuring that as few mistakes as possible are made when creating your Rust applications. We have considered how information is moved around functions and seen how the Rust model ensures that we are never left with dangling references or code that is addressing a memory location that no longer belongs to the variable. We have also seen how Rust removes the ability to have data-race conditions.</p>
<p class="calibre1">In the next chapter, we will consider generic types, their importance to your Rust application, and how the compiler deals with them.</p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>


            

            
        
    </body></html>