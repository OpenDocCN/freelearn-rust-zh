- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Creating Our Own Fibers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的纤程
- en: In this chapter, we take a deep dive into a very popular way of handling concurrency.
    There is no better way of getting a fundamental understanding of the subject than
    doing it yourself. Fortunately, even though the topic is a little complex, we
    only need around 200 lines of code to get a fully working example in the end.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨一种非常流行的处理并发的方式。没有比亲自实践更好的方式来获得对这一主题的根本理解了。幸运的是，尽管这个主题有点复杂，我们只需要大约200行代码就能最终得到一个完全工作的示例。
- en: What makes the topic complex is that it requires quite a bit of fundamental
    understanding of how CPUs, operating systems, and assembly work. This complexity
    is also what makes this topic so interesting. If you explore and work through
    this example in detail, you will be rewarded with an eye-opening understanding
    of topics you might only have heard about or only have a rudimentary understanding
    of. You will also get the chance to get to know a few aspects of the Rust language
    that you haven’t seen before, expanding your knowledge of both Rust and programming
    in general.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个主题复杂的是，它需要相当多的对CPU、操作系统和汇编工作方式的基本理解。这种复杂性也是这个主题如此有趣的原因。如果你详细地探索并完成这个示例，你将获得一个令人耳目一新的对那些你可能只听说过或只有初步了解的主题的理解。你还将有机会了解一些你之前没有见过的Rust语言的方面，这将扩大你对Rust以及一般编程的知识。
- en: We start off by introducing a little background knowledge that we need before
    we start writing code. Once we have that in place, we’ll start with some small
    examples that will allow us to show and discuss the most technical and difficult
    parts of our example in detail so we can introduce the topics gradually. Lastly,
    we’ll build on the knowledge we’ve gained and create our main example, which is
    a working example of fibers implemented in Rust.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍一些在开始编写代码之前我们需要的一些基础知识。一旦我们有了这些知识，我们就会从一些小例子开始，这些例子将允许我们详细展示和讨论我们示例中最技术性和困难的部分，这样我们就可以逐步介绍这些主题。最后，我们将基于我们获得的知识来创建我们的主要示例，这是一个在Rust中实现的纤程的工作示例。
- en: As a bonus, you’ll get two expanded versions of the example in the repository
    to inspire you to go on and change, adapt, and build upon what we’ve created to
    make it your own.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外奖励，你将在仓库中获得两个扩展的示例版本，以激发你继续前进，改变、适应并基于我们所创建的内容来使其成为你自己的。
- en: 'I’ll list the main topics here so you can refer to them later on:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里列出主要主题，以便你以后可以参考：
- en: How to use the repository alongside the book
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在书中使用仓库
- en: Background information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景信息
- en: An example we can build upon
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个我们可以构建的示例
- en: The stack
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Implementing our own fibers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现我们自己的纤程
- en: Final thoughts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的想法
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we’ll use the terms “fibers” and “green threads” to refer to
    this exact implementation of stackful coroutines. The term “threads” in this chapter,
    which is used in the code we write, will refer to the green threads/fibers we
    implement in our example and not OS threads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用“纤程”和“绿色线程”这两个术语来指代这种具体的堆栈纤程实现。本章中使用的“线程”术语，在我们在代码中使用的，将指代我们在示例中实现的绿色线程/纤程，而不是操作系统线程。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the examples, you will need a computer running on a CPU using the x86-64
    instruction set. Most popular desktop, server, and laptop CPUs out there today
    use this instruction set, as do most modern CPUs from Intel and AMD (which are
    most CPU models from these manufacturers produced in the last 10–15 years).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，你需要一台运行在x86-64指令集上的CPU。今天大多数流行的桌面、服务器和笔记本电脑CPU都使用这个指令集，包括大多数来自Intel和AMD的现代CPU（这些制造商在过去10-15年中生产的绝大多数CPU型号）。
- en: One caveat is that the modern M-series Macs use the ARM ISA (instruction set),
    which won’t be compatible with the examples we write here. However, older Intel-based
    Macs do, so you should be able to use a Mac to follow along if you don’t have
    the latest version.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的问题是，现代M系列Mac使用ARM指令集（指令集），与我们在这里编写的示例不兼容。然而，较老的基于Intel的Mac是兼容的，所以如果你没有最新版本，你应该能够使用Mac来跟随学习。
- en: 'If you don’t have a computer using this instruction set available, you have
    a few options to install Rust and run the examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用这个指令集的计算机可用，你有几种选择来安装Rust并运行示例：
- en: Mac users on M-series chips can use Rosetta (which ships with newer MacOS versions)
    and get the examples working with just four simple steps. You’ll find the instructions
    in the repository under `ch05/How-to-MacOS-M.md`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用M系列芯片的Mac用户可以使用Rosetta（随较新的MacOS版本提供）并通过四个简单的步骤使示例工作。你可以在仓库中的`ch05/How-to-MacOS-M.md`找到说明。
- en: '[https://mac.getutm.app/](https://mac.getutm.app/) (some even have a free layer)
    a remote server running Linux on x86-64\. I have experience with Linode’s offering
    (/), but there are many more options out there.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://mac.getutm.app/](https://mac.getutm.app/)（有些甚至有免费层）是一个运行在x86-64上的Linux远程服务器。我有使用Linode提供的服务的经验(/)，但还有更多选择。'
- en: To follow along with the examples in the book, you also need a Unix-based operating
    system. The example code will work natively on any Linux and BSD operating system
    (such as Ubuntu or macOS) as long as it’s running on an x86-64 CPU.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与书中的示例同步，你还需要一个基于Unix的操作系统。只要运行在x86-64 CPU上，示例代码将原生适用于任何Linux和BSD操作系统（如Ubuntu或macOS）。
- en: If you’re on Windows, there is a version of the example in the repository that
    works natively with Windows too, but to follow along with the book, my clear recommendation
    is to set up **Windows Subsystem for Linux** (**WSL**) ([https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install)),
    install Rust, and follow along using Rust on WSL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows，仓库中有一个与Windows原生兼容的示例版本，但为了与书中内容同步，我明确的建议是设置**Windows Subsystem
    for Linux**（**WSL**）([https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install))，安装Rust，并在WSL上使用Rust进行操作。
- en: I personally use VS Code as my editor, as it makes it very easy to switch between
    using a Linux version on WSL and Windows—simply press *Ctrl* + *Shift* + *P* and
    search for `the Reopen folder` `in WSL`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人使用VS Code作为我的编辑器，因为它使得在WSL和Windows之间切换使用Linux版本变得非常容易——只需按下*Ctrl* + *Shift*
    + *P*并搜索`在WSL中重新打开文件夹`。
- en: How to use the repository alongside the book
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将仓库与书籍一起使用
- en: 'The recommended way to read this chapter is to have the repository open alongside
    the book. In the repository, you’ll find three different folders that correspond
    to the examples we go through in this chapter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章的推荐方法是同时打开仓库和书籍。在仓库中，你会发现三个不同的文件夹，对应于本章中我们讨论的示例：
- en: '`ch05/a-stack swap`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch05/a-stack swap`'
- en: '`ch05/b-show-stack`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch05/b-show-stack`'
- en: '`ch05/c-fibers`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch05/c-fibers`'
- en: 'In addition, you will get two more examples that I refer to in the book but
    that should be explored in the repository:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将获得两个我在书中提到的例子，但这些例子应该在仓库中进一步探索：
- en: '`ch05/d-fibers-closure`: This is an extended version of the first example that
    might inspire you to do more complex things yourself. The example tries to mimic
    the API used in the Rust standard library using `std::thread::spawn`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch05/d-fibers-closure`：这是第一个示例的扩展版本，可能会激发你做更复杂的事情。示例尝试使用`std::thread::spawn`模仿Rust标准库中使用的API。'
- en: '`ch05/e-fibers-windows`: This is a version of the example that we go through
    in this book that works on both Unix-based systems and Windows. There is a quite
    detailed explanation in the README of the changes we make for the example work
    on Windows. I consider this recommended reading if you want to dive deeper into
    the topic, but it’s not important to understand the main concepts we go through
    in this chapter.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch05/e-fibers-windows`：这是本书中我们讨论的示例的版本，可以在基于Unix的系统上和Windows上运行。在README中有一个相当详细的解释，说明了我们为使示例在Windows上工作所做的更改。如果你想要深入了解这个主题，我将其视为推荐阅读，但它对于理解本章中我们讨论的主要概念并不重要。'
- en: Background information
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景信息
- en: We are going to interfere with and control the CPU directly. This is not very
    portable since there are many kinds of CPUs out there. While the overall implementation
    will be the same, there is a small but important part of the implementation that
    will be very specific to the CPU architecture we’re programming for. Another aspect
    that limits the portability of our code is that operating systems have different
    ABIs that we need to adhere to, and those same pieces of code will have to change
    based on the different ABIs. Let’s explain exactly what we mean here before we
    go further so we know we’re on the same page.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接干扰和控制CPU。由于存在许多不同类型的CPU，这并不非常便携。虽然整体实现将是相同的，但实现中有一个小但重要的部分将非常具体于我们为它编程的CPU架构。另一个限制我们代码便携性的方面是操作系统有不同的ABIs，我们需要遵守，并且相同的代码片段将根据不同的ABIs而改变。在我们进一步讨论之前，让我们具体解释一下我们的意思，以确保我们处于同一页面上。
- en: Instruction sets, hardware architectures, and ABIs
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令集、硬件架构和 ABI
- en: Okay, before we start, we need to know the differences between an **application
    binary interface** (**ABI**), a **CPU architecture**, and an **instruction set
    architecture** (**ISA**). We need this to write our own stack and make the CPU
    jump over to it. Fortunately, while this might sound complex, we only need to
    know a few specific things for our example to run. The information presented here
    is useful in many more circumstances than just our example, so it’s worthwhile
    to cover it in some detail.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在我们开始之前，我们需要了解 **应用程序二进制接口**（**ABI**）、**CPU 架构**和 **指令集架构**（**ISA**）之间的区别。我们需要这些信息来编写自己的栈，并让
    CPU 跳转到它。幸运的是，虽然这听起来可能很复杂，但为了我们的示例运行，我们只需要了解一些具体的事情。这里提供的信息在许多情况下都很有用，而不仅仅是我们的示例，所以详细地介绍它是值得的。
- en: An ISA describes an abstract model of a CPU that defines how the CPU is controlled
    by the software it runs. We often simply refer to this as the *instruction set*,
    and it defines what instructions the CPU can execute, what registers programmers
    can use, how the hardware manages memory, etc. Examples of ISAs are **x86-64**,
    **x86**, and the **ARM ISA** (used in Mac M-series chips).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ISA 描述了一个 CPU 的抽象模型，它定义了软件如何控制 CPU。我们通常简单地称其为 **指令集**，它定义了 CPU 可以执行哪些指令，程序员可以使用哪些寄存器，硬件如何管理内存等。ISA
    的例子包括 **x86-64**、**x86** 和 **ARM ISA**（用于 Mac M 系列芯片）。
- en: ISAs are broadly classified into two subgroups, **complex instruction set computers**
    (**CISC**) and **reduced instruction set computers** (**RISC**), based on their
    complexity. CISC architectures offer a lot of different instructions that the
    hardware must know how to execute, resulting in some instructions that are very
    specialized and rarely used by programs. RISC architectures accept fewer instructions
    but require some operations to be handled by software that could be directly handled
    by the hardware in a CISC architecture. The x86-64 instruction set we’ll focus
    on is an example of a CISC architecture.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ISA 可以广泛分为两个子组，**复杂指令集计算机**（**CISC**）和 **精简指令集计算机**（**RISC**），根据它们的复杂性。CISC
    架构提供了大量的不同指令，硬件必须知道如何执行这些指令，导致一些指令非常专业且很少被程序使用。RISC 架构接受较少的指令，但要求一些操作由软件处理，而在
    CISC 架构中这些操作可以直接由硬件处理。我们将关注的 x86-64 指令集是一个 CISC 架构的例子。
- en: To add a little complexity (you know, it’s not fun if it’s too easy), there
    are different names that refer to the same ISA. For example, the x86-64 instruction
    set is also referred to as the AMD64 instruction set and the Intel 64 instruction
    set, so no matter which one you encounter, just know that they refer to the same
    thing. In our book, we’ll simply call it the x86-64 instruction set.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加一点复杂性（你知道，如果太简单就不好玩了），不同的名称可能指的是相同的 ISA。例如，x86-64 指令集也被称为 AMD64 指令集和 Intel
    64 指令集，所以无论你遇到哪个，只需知道它们指的是同一件事。在我们的书中，我们将简单地称之为 x86-64 指令集。
- en: Tip
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To find the architecture on your current system, run one of the following commands
    in your terminal:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到您当前系统的架构，请在您的终端中运行以下命令之一：
- en: 'On Linux and MacOS: `arch` or `uname -m`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 MacOS 上：`arch` 或 `uname -m`
- en: 'On Windows PowerShell: `$env:PROCESSOR_ARCHITECTURE`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows PowerShell 中：`$env:PROCESSOR_ARCHITECTURE`
- en: 'On Windows Command Prompt: `echo %PROCESSOR_ARCHITECTURE%`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 命令提示符中：`echo %PROCESSOR_ARCHITECTURE%`
- en: The instruction set just defines how a program can interface with the CPU. The
    concrete implementation of an ISA can vary between different manufacturers, and
    a specific implementation is referred to as a CPU architecture, such as Intel
    Core processors. However, in practice, these terms are often used interchangeably
    since they all perform the same functions from a programmer’s perspective and
    there is seldom a need to target a specific implementation of an ISA.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集仅定义了程序如何与 CPU 交互。ISA 的具体实现可能因不同制造商而异，特定的实现被称为 CPU 架构，例如英特尔酷睿处理器。然而，在实践中，这些术语通常可以互换使用，因为从程序员的视角来看，它们都执行相同的功能，而且很少需要针对
    ISA 的特定实现进行目标定位。
- en: The ISA specifies the minimum set of instructions the CPU must be able to execute.
    Over time, there have been extensions to this instruction set, such as **Streaming
    SIMD Extensions** (**SSE**), that add more instructions and registers that programmers
    can take advantage of.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ISA 指定了 CPU 必须能够执行的最小指令集。随着时间的推移，这个指令集已经扩展，例如 **Streaming SIMD Extensions**（**SSE**），它添加了更多的指令和寄存器，程序员可以利用这些指令和寄存器。
- en: For the examples in this chapter, we will target the x86-64 ISA, a popular architecture
    used in most desktop computers and servers today.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，我们将针对x86-64 ISA（指令集架构），这是今天大多数桌面计算机和服务器上使用的一种流行架构。
- en: So, we know that a processor architecture presents an interface that programmers
    can use. Operating system implementors use this infrastructure to create operating
    systems.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道处理器架构提供了一个程序员可以使用的接口。操作系统实现者使用这个基础设施来创建操作系统。
- en: Operating systems such as Windows and Linux define an ABI that specifies a set
    of rules that the programmer has to adhere to for their programs to work correctly
    on that platform. Examples of operating system ABI’s are **System V ABI** (Linux)
    and **Win64** (Windows). The ABI specifies how the operating system expects a
    stack to be set up, how you should call a function, how you create a file that
    will load and run as a program, the name of the function that will be called once
    the program has loaded, etc.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统如Windows和Linux定义了一个ABI（应用程序二进制接口），它指定了一组规则，程序员必须遵守这些规则，以确保他们的程序在该平台上正确运行。操作系统ABI的例子包括**System
    V ABI**（Linux）和**Win64**（Windows）。ABI指定了操作系统期望如何设置堆栈，如何调用函数，如何创建一个可以加载并作为程序运行的文件，程序加载后将被调用的函数名称等。
- en: A very important part of the ABI that operating systems must specify is its
    **calling convention**. The calling convention defines how the stack is used and
    how functions are called.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统必须指定的ABI的一个重要部分是其**调用约定**。调用约定定义了堆栈的使用方式和函数的调用方式。
- en: 'Let’s illustrate this with an example of how Linux and Windows handle arguments
    to a function on x86-64; for example, a function with a signature such as `fn
    foo(a: i64,` `b: i64)`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们用一个例子来说明Linux和Windows在x86-64架构上如何处理函数的参数；例如，一个具有如下签名的函数：`fn foo(a: i64,
    b: i64)`。'
- en: 'The x86-64 ISA defines 16 general-purpose registers. These are registers the
    CPU provides for programmers to use for whatever they see fit. Note that *programmers*
    here include the ones that write the operating system, and they can lay additional
    restrictions on what registers you can use for what when you create a program
    to run on their operating system. In our specific example, Windows and Unix-based
    systems have different requirements for where to place the arguments for a function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 ISA定义了16个通用寄存器。这些是CPU提供给程序员使用的寄存器，程序员可以根据需要使用它们。请注意，这里的*程序员*包括编写操作系统的那些人，他们可以在创建在他们的操作系统上运行的程序时对可用的寄存器施加额外的限制。在我们的具体例子中，Windows和基于Unix的系统对函数参数的放置位置有不同的要求：
- en: Linux specifies that a function that takes two arguments should place the first
    argument to the function in the `rdi` register and the second one in the `rsi`
    register
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux指定，一个接受两个参数的函数应将第一个参数放置在`rdi`寄存器中，第二个参数放置在`rsi`寄存器中
- en: Windows requires that the first two arguments be passed in the registers `rcx`
    and `rdx`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows要求前两个参数必须通过寄存器`rcx`和`rdx`传递
- en: This is just one of many ways in which a program that is written for one platform
    won’t work on another. Usually, these details are the concern of compiler developers,
    and the compiler will handle the different calling conventions when you compile
    for a specific platform.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是许多情况下，为某个平台编写的程序在另一个平台上无法工作的一种方式。通常，这些细节是编译器开发者的关注点，当为特定平台编译时，编译器将处理不同的调用约定。
- en: So to sum it up, CPUs implement an instruction set. The instruction set defines
    what instructions the CPU can execute and the infrastructure it should provide
    to programmers (such as registers). An operating system uses this infrastructure
    in different ways, and it provides additional rules that a programmer must obey
    to run their program correctly on their platform. Most of the time, the only programmers
    that need to care about these details are the ones who write operating systems
    or compilers. However, when we write low-level code ourselves, we need to know
    about the ISA *and* the OS ABI to have our code work correctly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以总结一下，CPU实现了指令集。指令集定义了CPU可以执行哪些指令以及它应该为程序员提供哪些基础设施（例如寄存器）。操作系统以不同的方式使用这个基础设施，并为程序员提供额外的规则，程序员必须遵守这些规则才能在他们的平台上正确运行程序。大多数时候，唯一需要关注这些细节的程序员是编写操作系统或编译器的人。然而，当我们自己编写底层代码时，我们需要了解ISA和OS
    ABI，以确保我们的代码在平台上正确运行。
- en: Since we need to write this kind of code to implement our own fibers/green threads,
    we must potentially write different code for each OS ABI/ISA combination that
    exists. That means one for Windows/x86-64, one for Windows/ARM, one for MacOS/x86-64,
    one for Macos/M, etc.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要编写这种代码来实现自己的纤维/绿色线程，我们必须可能为每个存在的OS ABI/ISA组合编写不同的代码。这意味着一个用于Windows/x86-64，一个用于Windows/ARM，一个用于MacOS/x86-64，一个用于Macos/M等等。
- en: As you understand, this is also one major contributor to the complexity of using
    fibers/green threads for handling concurrency. It has a lot of advantages once
    it’s correctly implemented for an ISA/OS ABI combination, but it requires a lot
    of work to get it right.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所理解，这也是使用纤维/绿色线程处理并发复杂性的一个主要贡献者。一旦为ISA/OS ABI组合正确实现，它就有很多优点，但要做到正确需要大量的工作。
- en: 'For the purpose of the examples in this book, we will only focus on one such
    combination: the System V ABI for x86-64.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书中的示例，我们将只关注一种这样的组合：x86-64的System V ABI。
- en: Note!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意！
- en: In the accompanying repository, you will find a version of the main example
    for this chapter for Windows x86-64\. The changes we have to make to make it work
    on Windows are explained in the README.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在随附的仓库中，你可以找到本章主要示例的Windows x86-64版本。在README中解释了我们需要做的更改以使其在Windows上工作。
- en: The System V ABI for x86-64
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: x86-64的System V ABI
- en: 'As mentioned earlier, this architecture of the CPU features a set of 16 general-purpose
    64-bit registers, 16 SSE registers with 128-bit width, and 8 floating point registers
    with 80-bit width:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这种CPU架构具有一组16个64位通用寄存器，16个128位宽度的SSE寄存器，以及8个80位宽度的浮点寄存器：
- en: '![Figure 5.1 – x86-64 CPU registers](img/B20892_05_1.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – x86-64 CPU寄存器](img/B20892_05_1.jpg)'
- en: Figure 5.1 – x86-64 CPU registers
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – x86-64 CPU寄存器
- en: 'There are architectures that build upon this base and extend it, such as the
    Intel **Advanced Vector Extensions** (**AVX**), which provide an additional 16
    registers of 256 bits in width. Let’s take a look at a page from the System V
    ABI specification:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些架构建立在基础之上并对其进行扩展，例如Intel的**高级向量扩展**（**AVX**），它提供了额外的16个256位宽度的寄存器。让我们看看System
    V ABI规范中的一页：
- en: '![Figure 5.2 – Register usage](img/B20892_05_2.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 寄存器使用](img/B20892_05_2.jpg)'
- en: Figure 5.2 – Register usage
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 寄存器使用
- en: '*Figure 5**.1* shows an overview of the general-purpose registers in the x86-64
    architecture. Out of special interest for us right now are the registers marked
    as *callee saved*. These are the registers we need to keep track of our context
    across function calls. It includes the next instructions to run, the base pointer,
    the stack pointer, and so on. While the registers themselves are defined by the
    ISA, the rules on what is considered callee saved are defined by the System V
    ABI. We’ll get to know this more in detail later.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.1* 展示了x86-64架构中通用寄存器的一般概述。对我们目前来说，特别感兴趣的是标记为 *被调用者保存* 的寄存器。这些是我们需要在函数调用之间跟踪上下文的寄存器。它包括下一个要执行的指令、基指针、栈指针等等。虽然寄存器本身由ISA定义，但被认为是被调用者保存的规则由System
    V ABI定义。我们将在稍后了解更多细节。'
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Windows has a slightly different convention. On Windows, the register XMM6:XMM15
    is also calle-saved and must be saved and restored if our functions use them.
    The code we write in this first example runs fine on Windows since we don’t really
    adhere to any ABI yet and just focus on how we’ll instruct the CPU to do what
    we want.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Windows有一个稍微不同的约定。在Windows上，寄存器XMM6:XMM15也被认为是被调用者保存的，并且如果我们的函数使用它们，必须保存和恢复。我们编写的这个第一个示例在Windows上运行良好，因为我们还没有真正遵循任何ABI，只是关注我们将如何指导CPU执行我们想要的操作。
- en: 'If we want to issue a very specific set of commands to the CPU directly, we
    need to write small pieces of code in assembly. Fortunately, we only need to know
    some very basic assembly instructions for our first mission. Specifically, we
    need to know how to move values to and from registers:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要直接向CPU发出一组非常具体的命令，我们需要在汇编语言中编写小的代码片段。幸运的是，对于我们第一个任务，我们只需要了解一些非常基础的汇编指令。具体来说，我们需要知道如何将值移动到寄存器和从寄存器中取出：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A quick introduction to Assembly language
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编语言的快速介绍
- en: First and foremost, **Assembly** language isn’t particularly portable since
    it’s the lowest level of human-readable instructions we can write to the CPU,
    and the instructions we write in assembly will vary from architecture to architecture.
    Since we will only write assembly targeting the x86-64 architecture going forward,
    we only need to learn a few instructions for this particular architecture.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**汇编语言** 并不特别便携，因为它是我们可以写入 CPU 的最低级别的人类可读指令，我们编写的汇编指令会因架构而异。由于我们将只编写针对 x86-64
    架构的汇编，因此我们只需要学习这个特定架构的几个指令。
- en: 'Before we go too deep into the specifics, you need to know that there are two
    popular dialects used in assembly: the **AT&T dialect** and the **Intel dialect**.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入具体细节之前，您需要知道在汇编中有两种流行的语法：**AT&T 语法** 和 **Intel 语法**。
- en: The Intel dialect is the standard when writing inline assembly in Rust, but
    in Rust, we can specify that we want to use the AT&T dialect instead if we want
    to. Rust has its own take on how to do inline assembly that at first glance looks
    foreign to anyone used to inline assembly in C. It’s well thought through though,
    and I’ll spend a bit of time explaining it in more detail as we go through the
    code, so both readers with experience with the C-type inline assembly and readers
    who have no experience should be able to follow along.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Intel 语法是编写 Rust 中内联汇编的标准，但在 Rust 中，我们可以指定我们想要使用 AT&T 语法，如果我们想的话。Rust 对内联汇编有自己的看法，对于习惯于
    C 中内联汇编的人来说，一开始看起来可能很陌生。但它经过深思熟虑，随着我们通过代码进行详细解释，我将花一些时间来解释它，以便有经验的 C 类内联汇编读者和没有经验的读者都能够跟上。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will use the Intel dialect in our examples.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用 Intel 语法。
- en: 'Assembly has strong backward compatibility guarantees. That’s why you will
    see that the same registers are addressed in different ways. Let’s look at the
    rax register we used as an example as an explanation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编有强大的向后兼容性保证。这就是为什么您会看到以不同方式引用相同的寄存器。让我们以我们用作示例的 rax 寄存器为例进行解释：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, this is basically like watching the history of CPUs evolve in
    front of us. Since most CPUs today are 64 bits, we will use the 64-bit versions
    in our code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这基本上就像在我们面前观看 CPU 的发展历史。由于今天的大多数 CPU 都是 64 位，因此我们将使用代码中的 64 位版本。
- en: The word size in the assembly also has historical reasons. It stems from the
    time when the CPU had 16-bit data buses, so a word is 16 bits. This is relevant
    because you will see many instructions suffixed with `q` (quad word) or `l` (long
    word). So, a `movq` would mean a move of 4 * 16 bits, which is 64 bits.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编中，字大小也有历史原因。它源于 CPU 有 16 位数据总线的时候，所以一个字是 16 位。这很重要，因为您会看到许多带有 `q`（四倍字）或 `l`（长字）后缀的指令。所以，`movq`
    就意味着移动 4 * 16 位，即 64 位。
- en: A plain `mov` will use the size of the register you target on most modern assemblers.
    This is the one you will see most used in both AT&T and the Intel dialect when
    writing inline assembly, and it’s the one we will use in our code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代汇编器中，一个普通的 `mov` 会使用您目标寄存器的大小。这是您在编写内联汇编时在 AT&T 和 Intel 语法中看到的最常用的一个，我们也会在我们的代码中使用它。
- en: One more thing to note is that the **stack alignment** on x86-64 is 16 bytes.
    Just remember this for later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，x86-64 上的 **栈对齐** 是 16 字节。只需记住这一点以备后用。
- en: An example we can build upon
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以构建的示例
- en: This is a short example where we will create our own stack and make our CPU
    return out of its current execution context and over to the stack we just created.
    We will build on these concepts in the following chapters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简短的示例，我们将创建自己的栈，并让我们的 CPU 从当前的执行上下文返回到我们刚刚创建的栈。我们将在接下来的章节中在此基础上构建这些概念。
- en: Setting up our project
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的项目
- en: 'First, let’s start a new project by creating a folder named `a-stack-swap`.
    Enter the new folder and run the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过创建一个名为 `a-stack-swap` 的新文件夹来开始一个新的项目。进入新文件夹并运行以下命令：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also navigate to the folder called `ch05/a-stack-swap` in the accompanying
    repository and see the whole example there.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以导航到附带的仓库中名为 `ch05/a-stack-swap` 的文件夹，并在那里查看整个示例。
- en: 'In our `main.rs`, we start by importing the `asm!` macro:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `main.rs` 中，我们首先导入 `asm!` 宏：
- en: ch05/a-stack-swap/src/main.rs
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ch05/a-stack-swap/src/main.rs
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s set a small stack size of only 48 bytes here so that we can print the
    stack and look at it before we switch contexts after we get the first example
    to work:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里设置一个小的栈大小，仅为 48 字节，这样我们就可以在切换上下文之前打印栈并查看它，以便在第一个示例工作后：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There seems to be an issue in macOS using such a small stack. The minimum for
    this code to run is a stack size of 624 bytes. The code works on the Rust Playground,
    at [https://play.rust-lang.org](https://play.rust-lang.org), if you want to follow
    this exact example (however, you’ll need to wait roughly 30 seconds for it to
    time out due to our loop in the end).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上使用如此小的栈似乎存在问题。此代码运行的最小栈大小为624字节。如果你想要跟随这个精确的示例，可以在[Rust Playground](https://play.rust-lang.org)上运行此代码（然而，由于我们最后的循环，你可能需要等待大约30秒才能超时）。
- en: 'Then let’s add a struct that represents our CPU state. We’ll only focus on
    the register that stores the stack pointer for now since that is all we need:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们添加一个表示CPU状态的`struct`。我们现在只关注存储栈指针的寄存器，因为这是我们目前需要的所有：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In later examples, we will use all the registers marked as *callee saved* in
    the specification document I linked to. These are the registers described in the
    System V x86-64 ABI that we’ll need to save our context, but right now, we only
    need one register to make the CPU jump over to our stack.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的示例中，我们将使用我在链接的规范文档中标记为*调用者保存*的所有寄存器。这些是在System V x86-64 ABI中描述的寄存器，我们需要保存我们的上下文，但目前为止，我们只需要一个寄存器来让CPU跳转到我们的栈。
- en: Note that this needs to be `#[repr(C)]` because of how we access the data in
    our assembly. Rust doesn’t have a stable language ABI, so there is no way for
    us to be sure that this will be represented in memory with `rsp` as the first
    8 bytes. C has a stable language ABI and that’s exactly what this attribute tells
    the compiler to use. Granted, our struct only has one field right now, but we
    will add more later.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这需要是`#[repr(C)]`，因为我们在汇编中访问数据的方式。Rust没有稳定的语言ABI，所以我们无法确定这将以`rsp`作为前8个字节在内存中表示。C有一个稳定的语言ABI，这正是这个属性告诉编译器要使用的。当然，我们的结构体目前只有一个字段，但我们会稍后添加更多。
- en: 'For this very simple example, we will define a function that just prints out
    a message and then loops forever:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个非常简单的示例，我们将定义一个只打印消息然后无限循环的函数：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next up is our inline assembly, where we switch over to our own stack:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的内联汇编，我们将切换到自己的栈：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At first glance, you might think that there is nothing special about this piece
    of code, but let’s stop and consider what happens here for a moment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，你可能认为这段代码没有什么特别之处，但让我们停下来，暂时考虑一下这里发生了什么。
- en: If we refer back to *Figure 5**.1*, we’ll see that `rsp` is the register that
    stores the **stack pointer** that the CPU uses to figure out the current location
    on the stack.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们参考*图5**.1，我们会看到`rsp`是存储CPU用于确定栈当前位置的**栈指针**的寄存器。
- en: Now, what we actually want to do if we want the CPU to swap to a different stack
    is to set the register for the stack pointer (`rsp`) to the top of our new stack
    and set the instruction pointer (`rip`) on the CPU to point to the address `hello`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想让CPU切换到不同的栈，我们实际上想要做的是将栈指针寄存器（`rsp`）设置为新的栈顶，并将CPU上的指令指针（`rip`）设置为指向`hello`的地址。
- en: The instruction pointer, or program counter as it’s sometimes called on different
    architectures, points to the *next* instruction to run. If we can manipulate it
    directly, the CPU would fetch the instruction pointed to by the `rip` register
    and execute the first instruction we wrote in our `hello` function. The CPU will
    then push/pop data on the new stack using the address pointed to by the stack
    pointer and simply leave our old stack as it was.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 指令指针，有时在不同的架构上被称为程序计数器，它指向要运行的*下一个*指令。如果我们能直接操作它，CPU就会获取由`rip`寄存器指向的指令并执行我们在`hello`函数中编写的第一个指令。然后，CPU将使用栈指针指向的地址在新的栈上推送/弹出数据，而简单地保留我们的旧栈不变。
- en: Now, this is where it gets a little difficult. On the x86-64 instruction set,
    there is no way for us to manipulate `rip` directly, so we have to use a little
    trick.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里会变得有点困难。在x86-64指令集中，我们无法直接操作`rip`，所以我们必须使用一个小技巧。
- en: The first thing we do is set up the new stack and write the address to the function
    we want to run at a 16-byte offset from the top of the stack (the ABI dictates
    a 16-byte stack alignment, so the top of our stack frame must start at a 16-byte
    offset). We’ll see how to create a continuous piece of memory a little later,
    but it’s a rather straightforward process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置新的栈，并将我们想要运行的函数的地址写入栈顶16字节偏移处（ABI规定栈对齐为16字节，因此我们的栈帧顶部必须从16字节偏移开始）。我们稍后会看到如何创建连续的内存块，但这是一个相当直接的过程。
- en: Next, we pass the address of the first byte in which we stored this address
    on our newly created stack to the `rsp` register (the address we set to `new.rsp`
    will point to an address located on our own stack, which in turn is an address
    that leads to the `hello` function). Got it?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将存储在我们新创建的栈中这个地址的第一个字节的地址传递给 `rsp` 寄存器（我们设置的 `new.rsp` 地址将指向我们自己的栈上的一个地址，而这个地址又指向
    `hello` 函数）。明白了吗？
- en: The `ret` keyword transfers program control to what would normally be the return
    address located on top of the stack frame it’s currently in. Since we placed the
    address to `hello` on our new stack and set the `rsp` register to point to our
    new stack, the CPU will think `rsp` now points to the return address of the function
    it’s currently running, but instead, it’s pointing to a location on our new stack.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret` 关键字将程序控制权转移到当前栈帧顶部通常的返回地址。由于我们将 `hello` 的地址放置在了我们新的栈上，并将 `rsp` 寄存器设置为指向我们的新栈，CPU
    会认为 `rsp` 现在指向了它正在运行的函数的返回地址，但实际上，它指向的是我们新栈上的一个位置。'
- en: When the CPU executes the `ret` instruction it will pop the first value of the
    stack (which is conveniently the address to our `hello` function) and place that
    address in the rip register for us. On the next cycle, the CPU will fetch the
    instructions located at that function pointer and start executing those instructions.
    Since `rsp` now points to our new stack, it will use that stack going forward.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CPU 执行 `ret` 指令时，它将从栈中弹出第一个值（恰好是我们 `hello` 函数的地址）并将该地址放入 rip 寄存器。在下个周期，CPU
    将从该函数指针处获取指令并开始执行这些指令。由于 `rsp` 现在指向我们的新栈，它将从此栈开始使用。
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you feel a little confused right now, that’s very understandable. These details
    are hard to understand and get right, and it takes time to get comfortable with
    how it works. As we’ll see later in this chapter, there is a little more data
    that we need to save and restore (right now, we don’t have a way to resume the
    stack we just swapped from), but the technical details on how the stack swap happens
    are the same as described previously.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在感到有些困惑，这是完全可以理解的。这些细节很难理解并正确执行，而且需要时间来熟悉其工作方式。正如我们将在本章后面看到的那样，我们需要保存和恢复更多的数据（目前，我们没有方法来恢复我们刚刚交换的栈），但栈交换的技术细节与之前描述的是相同的。
- en: Before we explain how we set up the new stack, we’ll use this opportunity to
    go line by line and explain how the inline assembly macro works.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释如何设置新栈之前，我们将利用这个机会逐行解释内联汇编宏是如何工作的。
- en: An introduction to Rust inline assembly macro
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 内联汇编宏简介
- en: We’ll use the body of our `gt_switch` function as a starting point by going
    through everything step by step.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过逐步分析 `gt_switch` 函数的主体来使用它作为起点。
- en: If you haven’t used inline assembly before, this might look foreign, but we’ll
    use an extended version of the example later to switch contexts, so we need to
    understand what’s going on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过内联汇编，这可能会看起来有些陌生，但稍后我们会使用示例的扩展版本来切换上下文，因此我们需要理解正在发生的事情。
- en: '`unsafe` is a keyword that indicates that Rust cannot enforce the safety guarantees
    in the function we write. Since we are manipulating the CPU directly, this is
    most definitely unsafe. The function will also take a pointer to an instance of
    our `ThreadContext` from which we will only read one field:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe` 是一个关键字，表示 Rust 无法在所写的函数中强制执行安全性保证。由于我们正在直接操作 CPU，这绝对是不安全的。该函数还将从一个
    `ThreadContext` 实例的指针中读取一个字段：'
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next line is the `asm!` macro in the Rust standard library. It will check
    our syntax and provide an error message if it encounters something that doesn’t
    look like valid Intel (by default) assembly syntax.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条是 Rust 标准库中的 `asm!` 宏。它将检查我们的语法，如果遇到看起来不像有效的 Intel（默认）汇编语法的部分，将提供错误信息。
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first thing the macro takes as input is the assembly template:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 宏首先接受的是汇编模板：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a simple instruction that moves the value stored at `0x00` offset (that
    means no offset at all in hex) from the memory location at `{0}` to the `rsp`
    register. Since the `rsp` register usually stores a pointer to the most recently
    pushed value on the stack, we effectively push the address to `hello` on top of
    the current stack so that the CPU will return to that address instead of resuming
    where it left off in the previous stack frame.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一条简单的指令，它将存储在 `{0}` 内存位置偏移 `0x00` 处的值（这意味着在十六进制中没有偏移）移动到 `rsp` 寄存器。由于 `rsp`
    寄存器通常存储指向最近推入栈的值的指针，我们实际上将 `hello` 的地址推到当前栈的顶部，这样 CPU 将返回到该地址而不是从上一个栈帧的断点恢复。
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we don’t need to write `[{0} + 0x00]` when we don’t want an offset
    from the memory location. Writing `mov rsp, [{0}]` would be perfectly fine. However,
    I chose to introduce how we do an offset here as we’ll need it later on when we
    want to access more fields in our `ThreadContext` struct.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们不想从内存位置偏移时，不需要写 `[{0} + 0x00]`。写入 `mov rsp, [{0}]` 就完全可以。然而，我选择介绍如何在这里进行偏移，因为我们稍后需要访问
    `ThreadContext` 结构体中的更多字段。
- en: Note that the `mov a, b` means “move what’s at `a` to `b`”, but the Intel dialect
    usually dictates that the destination register is first and the source is second.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`mov a, b` 的意思是“将 `a` 中的内容移动到 `b`”，但 Intel 语法通常规定目标寄存器在前，源寄存器在后。
- en: To make this confusing, this is the opposite of what’s typically the case with
    the `a` to `b`” is the correct thing to do. This is one of the fundamental differences
    between the two dialects, and it’s useful to be aware of.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更复杂，这与通常的“从 `a` 到 `b`”的做法相反。这是两种语法之间的一个基本区别，了解这一点是有用的。
- en: You will not see `{0}` used like this in normal assembly. This is part of the
    assembly template and is a placeholder for the value passed as the first parameter
    to the macro. You’ll notice that this closely matches how string templates are
    formatted in Rust using `println!` or the like. The parameters are numbered in
    ascending order starting from 0\. We only have one input parameter here, which
    corresponds to `{0}`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的汇编代码中，你不会看到 `{0}` 被这样使用。这是汇编模板的一部分，是作为宏的第一个参数传递的值的占位符。你会注意到这非常接近 Rust 中使用
    `println!` 或类似方式格式化的字符串模板。参数按升序编号，从 0 开始。这里我们只有一个输入参数，对应于 `{0}`。
- en: You don’t really have to index your parameters like this; writing `{}` in the
    correct order would suffice (as you would do using the `println!` macro). However,
    using an index improves readability and I would strongly recommend doing it that
    way.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上并不需要像这样索引你的参数；正确地写入 `{}` 就足够了（就像使用 `println!` 宏那样）。然而，使用索引可以提高可读性，我强烈建议这样做。
- en: The `[]` basically means “get what’s at this memory location”, you can think
    of it as the same as dereferencing a pointer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]` 基本上意味着“获取这个内存位置的内容”，你可以把它想象成与解引用指针相同。'
- en: 'Let’s try to sum up what we do here with words:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用词来总结一下我们在这里所做的工作：
- en: Move what’s at the `+ 0x00` offset from the memory location that `{compiler_chosen_general_purpose_register}`
    points to to the `rsp` register.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `{compiler_chosen_general_purpose_register}` 指向的内存位置偏移 `+ 0x00` 处的内容移动到 `rsp`
    寄存器。
- en: The next line is the `ret` keyword, which instructs the CPU to pop a memory
    location off the stack and then makes an unconditional jump to that location.
    In effect, we have hijacked our CPU and made it return to our stack.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行是 `ret` 关键字，它指示 CPU 从栈中弹出一个内存位置，然后无条件跳转到该位置。实际上，我们已经劫持了 CPU，使其返回到我们的栈。
- en: 'Next up is the first non-assembly argument to the `asm!` macro is our input
    parameter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `asm!` 宏的第一个非汇编参数，即我们的输入参数：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we write `in(reg)`, we let the compiler decide on a general-purpose register
    to store the value of `new`. `out(reg)` means that the register is an output,
    so if we write `out(reg) new`, we need `new` to be `mut` so we can write a value
    to it. You’ll also find other versions such as `inout` and `lateout`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写 `in(reg)` 时，我们让编译器决定一个通用寄存器来存储 `new` 的值。`out(reg)` 意味着该寄存器是输出，所以如果我们写 `out(reg)
    new`，则需要 `new` 是 `mut`，这样我们才能向它写入值。你还会发现其他版本，如 `inout` 和 `lateout`。
- en: Options
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项
- en: The last thing we need to introduce to get a minimal understanding of Rust’s
    inline assembly for now is the `options` keyword. After the input and output parameters,
    you’ll often see something like `options(att_syntax)`, which specifies that the
    assembly is written with the AT&T syntax instead of the Intel syntax. Other options
    include `pure`, `nostack`, and several others.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了现在对Rust的内联汇编有一个最小限度的理解，我们需要介绍的最后一件事情是`options`关键字。在输入和输出参数之后，您通常会看到类似`options(att_syntax)`的东西，这指定了汇编是用AT&T语法而不是Intel语法编写的。其他选项包括`pure`、`nostack`和几个其他选项。
- en: 'I’ll refer you to the documentation for you to read about them since they’re
    explained in detail there:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我将引导您查阅文档来了解它们，因为它们在那里有详细的解释：
- en: '[https://doc.rust-lang.org/nightly/reference/inline-assembly.html#options](https://doc.rust-lang.org/nightly/reference/inline-assembly.html#options)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.rust-lang.org/nightly/reference/inline-assembly.html#options](https://doc.rust-lang.org/nightly/reference/inline-assembly.html#options)'
- en: Inline assembly is quite complex, so we’ll take this step by step and introduce
    more details on how it works along the way through our examples.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 内联汇编相当复杂，所以我们将一步一步地进行，并在我们的示例中逐步介绍其工作原理的更多细节。
- en: Running our example
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的示例
- en: 'The last bit we need is the main function to run our example. I’ll present
    the whole function and we’ll walk through it step by step:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个部分是运行我们示例的主函数。我将展示整个函数，然后我们一步一步地分析它：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, in this function, we’re actually creating our new stack. `hello` is a pointer
    already (a function pointer), so we can cast it directly as an `u64` since all
    pointers on 64-bit systems will be, well, 64-bit. Then, we write this pointer
    to our new stack.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个函数中，我们实际上在创建我们的新栈。`hello`已经是一个指针了（一个函数指针），所以我们可以直接将其转换为`u64`，因为64位系统上的所有指针都将是这样，64位。然后，我们将这个指针写入我们的新栈。
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We’ll talk more about the stack in the next segment, but one thing we need to
    know now is that the stack grows downwards. If our 48-byte stack starts at index
    `0` and ends on index `47`, index `32` will be the first index of a 16-byte offset
    from the start/base of our stack.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一部分更多地讨论栈，但我们需要知道的是，栈是向下增长的。如果我们的48字节栈从索引`0`开始，到索引`47`结束，索引`32`将是我们的栈起始/基址的16字节偏移量的第一个索引。
- en: Make note that we write the pointer to an offset of 16 bytes from the base of
    our stack.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们写入的是从栈基址16字节偏移的指针。
- en: What does the line let sb_aligned = (stack_bottom as usize &! 15) as *mut u8;
    do?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码`let sb_aligned = (stack_bottom as usize &! 15) as *mut u8;`的作用是什么？
- en: When we ask for memory like we do when creating a `Vec<u8>`, there is no guarantee
    that the memory we get is 16-byte-aligned when we get it. This line of code essentially
    rounds our memory address down to the nearest 16-byte-aligned address. If it’s
    already 16 byte-aligned, it does nothing. This way, we know that we end up at
    a 16-byte-aligned address if we simply subtract 16 from the base of our stack.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们像创建`Vec<u8>`时请求内存，我们无法保证我们得到的内存在我们得到它时是16字节对齐的。这一行代码实际上将我们的内存地址向下舍入到最近的16字节对齐地址。如果它已经是对齐的，它就什么都不做。这样，我们知道如果我们简单地从栈的基址减去16，我们最终会到达一个16字节对齐的地址。
- en: We cast the address to `hello` as a pointer to a `u64` instead of a pointer
    to a `u8`. We want to write to position “32, 33, 34, 35, 36, 37, 38, 39”, which
    is the 8-byte space we need to store our `u64`. If we don’t do this cast, we try
    to write a `u64` only to position 32, which is not what we want.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将地址`hello`作为一个指向`u64`的指针，而不是指向`u8`的指针。我们想要写入位置“32, 33, 34, 35, 36, 37, 38,
    39”，这是我们存储`u64`所需的8字节空间。如果我们不进行这种转换，我们尝试只将`u64`写入位置32，这并不是我们想要的。
- en: 'When we run the example by writing `cargo run` in our terminal, we get:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在终端中通过写入`cargo run`来运行示例时，我们得到：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As we end the program in an endless loop, you’ll have to exit by pressing *Ctrl*
    +*C*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在一个无限循环中结束程序，您必须通过按*Ctrl* +*C*来退出。
- en: OK, so what happened? We didn’t call the function `hello` at any point, but
    it still executed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么发生了什么？我们没有在任何地方调用`hello`函数，但它仍然执行了。
- en: What happened is that we actually made the CPU jump over to our own stack, and
    since it thinks it returns from a function, it will read the address to `hello`
    and start executing the instructions it points to. We have taken the first step
    toward implementing a context switch.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是我们实际上让CPU跳转到我们的自己的栈上，由于它认为它从函数返回，它将读取`hello`的地址并开始执行它指向的指令。我们迈出了实现上下文切换的第一步。
- en: In the next sections, we will talk about the stack in a bit more detail before
    we implement our fibers. It will be easier now that we have covered so much of
    the basics.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现我们的纤程之前，我们将在下一节中更详细地讨论栈。由于我们已经涵盖了这么多基础知识，现在会更容易。
- en: The stack
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: A stack is nothing more than a piece of contiguous memory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 栈不过是一块连续的内存。
- en: This is important to know. A computer only has memory, it doesn’t have a special
    stack memory and a heap memory; it’s all part of the same memory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很重要的。计算机只有内存，它没有特殊的栈内存和堆内存；它们都是同一内存的一部分。
- en: The difference is how this memory is accessed and used. The stack supports simple
    push/pop instructions on a contiguous part of memory, that’s what makes it fast
    to use. The heap memory is allocated by a memory allocator on demand and can be
    scattered around in different locations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于如何访问和使用这块内存。栈支持在连续内存部分上的简单 push/pop 指令，这就是它使用快速的原因。堆内存由内存分配器按需分配，并且可以分散在不同的位置。
- en: We’ll not go through the differences between the stack and the heap here since
    there are numerous articles explaining them in detail, including a chapter in
    *The Rust Programming Language* at [https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap](https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会讲解栈和堆之间的区别，因为已经有许多文章详细解释了它们，包括 *《Rust 编程语言》* 中的一个章节，在 [https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap](https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap)。
- en: What does the stack look like?
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈看起来是什么样子？
- en: Let’s start with a simplified view of the stack. A 64-bit CPU will read 8 bytes
    at a time. Even though the natural way for us to see a stack is a long line of
    `u8` as shown in *Figure 5**.2*, the CPU will treat it more like a long line of
    `u64` instead since it won’t be able to read less than 8 bytes when it makes a
    load or a store.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对栈的简化视图开始。64 位 CPU 会一次读取 8 个字节。尽管我们看栈的自然方式是像 *图 5.2* 所示的长串 `u8`，但 CPU 会更像是长串的
    `u64`，因为它在执行加载或存储时无法读取少于 8 个字节。
- en: '![Figure 5.3 – The stack](img/B20892_05_3.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 栈](img/B20892_05_3.jpg)'
- en: Figure 5.3 – The stack
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 栈
- en: When we pass a pointer, we need to make sure we pass in a pointer to either
    address `0016`, `0008`, or `0000` in the example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递指针时，我们需要确保传递的是指向示例中地址 `0016`、`0008` 或 `0000` 的指针。
- en: The stack grows downwards, so we start at the top and work our way down.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 栈向下增长，所以我们从顶部开始，向下工作。
- en: When we set the `0008` (remember the stack starts on the top).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置 `0008`（记住栈是从顶部开始的）。
- en: 'If we add the following lines of code to our example in the last chapter just
    before we do the switch in our `main` function, we can effectively print out our
    stack and have a look at it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在上一章的例子中在 `main` 函数的切换之前添加以下几行代码，我们就可以有效地打印出我们的栈并查看它：
- en: ch05/b-show-stack
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ch05/b-show-stack
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output we get is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果如下：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I’ve printed out the memory addresses as `u64` here, so it’s easier to parse
    if you’re not very familiar with hex.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里以 `u64` 的形式打印出了内存地址，这样如果你不太熟悉十六进制，解析起来会更容易。
- en: The first thing to note is that this is just a contiguous piece of memory, starting
    at address `2643866716673` and ending at `2643866716720`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这只是一个连续的内存块，从地址 `2643866716673` 开始，到 `2643866716720` 结束。
- en: The addresses `2643866716704` to `2643866716712` are of special interest to
    us. The first address is the address of our stack pointer, the value we write
    to the `rsp` register of the CPU. The range represents the values we wrote to
    the stack before we made the switch.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 `2643866716704` 到 `2643866716712` 对我们来说特别有趣。第一个地址是栈指针的地址，我们将其写入 CPU 的 `rsp`
    寄存器。这个范围代表了我们切换之前写入栈的值。
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The actual addresses you get will be different every time you run the program.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行程序时，你得到的实际地址都会不同。
- en: In other words, the values `240, 205, 252, 56, 67, 86, 0, 0` represent the pointer
    to our `hello()` function written as `u8` values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，值 `240, 205, 252, 56, 67, 86, 0, 0` 代表了我们的 `hello()` 函数的指针，这些值被写成 `u8`。
- en: Endianness
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 大小端序
- en: An interesting side note here is that the order the CPU writes an `u64` as a
    set of 8 `u8` bytes is dependent on its endianness. In other words, a CPU can
    write our pointer address as `240, 205, 252, 56, 67, 86, 0, 0` if it’s little-endian
    or `0, 0, 86, 67, 56, 252, 205, 240` if it’s big-endian. Think of it like how
    Hebrew, Arabic, and Persian languages read and write from right to left, while
    Latin, Greek, and Indic languages read and write from left to right. It doesn’t
    really matter as long as you know it in advance, and the results will be the same.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的旁注：CPU将`u64`作为一个由8个`u8`字节组成的集合写入的顺序取决于其端序。换句话说，如果它是小端序，CPU可以将我们的指针地址写入`240,
    205, 252, 56, 67, 86, 0, 0`，如果是大端序，则写入`0, 0, 86, 67, 56, 252, 205, 240`。想象一下，像希伯来语、阿拉伯语和波斯语这样的语言是从右到左阅读和书写的，而拉丁语、希腊语和印度语系的语言是从左到右阅读和书写的。只要您事先知道这一点，结果就会相同。
- en: The x86-64 architecture uses a little-endian format, so if you try to parse
    the data manually, you’ll have to bear this in mind.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64架构使用小端格式，所以如果您尝试手动解析数据，您必须记住这一点。
- en: 'As we write more complex functions, our extremely small 48-byte stack will
    soon run out of space. You see, as we run the functions we write in Rust, the
    CPU will now push and pop values on our new stack to execute our program and it’s
    left to the programmer to make sure they don’t overflow the stack. This brings
    us to our next topic: stack sizes.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们编写更复杂的函数，我们那极小的48字节栈空间很快就会耗尽。您可以看到，当我们运行在Rust中编写的函数时，CPU现在会在我们的新栈上推入和弹出值以执行我们的程序，而确保它们不会溢出栈空间的责任就留给了程序员。这引出了我们的下一个主题：栈大小。
- en: Stack sizes
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈大小
- en: We touched upon this topic earlier in [*Chapter 2*](B20892_02.xhtml#_idTextAnchor043),
    but now that we’ve created our own stack and made our CPU jump over to it, you
    might get a better sense of the issue. One of the advantages of creating our own
    green threads is that we can freely choose how much space we reserve for each
    stack.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B20892_02.xhtml#_idTextAnchor043)中提到了这个主题，但现在我们已经创建了我们的栈，并让CPU跳转到它，您可能会对这个问题有更好的理解。创建我们自己的绿色线程的一个优点是，我们可以自由地选择为每个栈预留多少空间。
- en: When you start a process in most modern operating systems, the standard stack
    size is normally 8 MB, but it can be configured differently. This is enough for
    most programs, but it’s up to the programmer to make sure we don’t use more than
    we have. This is the cause of the dreaded stack overflow that most of us have
    experienced.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在大多数现代操作系统中启动一个进程时，标准栈大小通常是8MB，但可以配置为不同的值。这对大多数程序来说已经足够了，但程序员必须确保我们不会使用超过我们拥有的。这就是我们大多数人都有过经验的可怕的栈溢出的原因。
- en: However, when we can control the stacks ourselves, we can choose the size we
    want. 8 MB for each task is way more than we need when running simple functions
    in a web server, for example, so by reducing the stack size, we can have millions
    of fibers/green threads running on a machine. We run out of memory a lot sooner
    using stacks provided by the operating system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们能够自己控制栈时，我们可以选择我们想要的尺寸。例如，在运行Web服务器中的简单函数时，每个任务8MB的空间远远超过了我们的需求，因此通过减少栈大小，我们可以在一台机器上运行数百万个纤程/绿色线程。使用操作系统提供的栈，我们很快就会耗尽内存。
- en: Anyway, we need to consider how to handle the stack size, and most production
    systems such as **Boost.Coroutine** or the one you find in **Go** will use either
    segmented stacks or growable stacks. We will make this simple for ourselves and
    use a fixed stack size going forward.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们需要考虑如何处理栈大小，而大多数生产系统，如**Boost.Coroutine**或您在**Go**中找到的系统，将使用分段栈或可增长栈。我们将使这个过程变得简单，并从现在开始使用固定大小的栈。
- en: Implementing our own fibers
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们自己的纤程
- en: Before we start, I want to make sure you understand that the code we write is
    quite unsafe and is not a “best practice” when writing Rust. I want to try to
    make this as safe as possible without introducing a lot of unnecessary complexity,
    but there is no way to avoid the fact that there will be a lot of unsafe code
    in this example. We will also prioritize focusing on *how* this works and explain
    it as simply as possible, which will be enough of a challenge in and of itself,
    so the focus on best practices and safety will have to take the back seat on this
    one.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我想确保您明白我们编写的代码相当不安全，并且不是编写Rust时的“最佳实践”。我想尽量使代码尽可能安全，而不引入过多的不必要复杂性，但在这个例子中不可避免地会有很多不安全代码。我们还将优先关注*如何*实现这一点，并尽可能简单地解释它，这本身就是一个很大的挑战，因此在这个问题上，最佳实践和安全性的关注将不得不退居次要位置。
- en: Let’s start off by creating a whole new project called `c-fibers` and removing
    the code in `main.rs` so we start with a blank sheet.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个全新的项目`c-fibers`并从`main.rs`中移除代码开始，这样我们就从一个空白页开始。
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will also find this example in the repository under the `ch05/c-fibers`
    folder. This example, as well as `ch05/d-fibers-closure` `and` `ch05/e-fibers-windows`,
    needs to be compiled using the nightly compiler since we use an unstable feature.
    You can do this in one of two ways:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`ch05/c-fibers`文件夹下的存储库中找到这个例子。这个例子，以及`ch05/d-fibers-closure`和`ch05/e-fibers-windows`，需要使用nightly编译器编译，因为我们使用了不稳定的功能。你可以通过以下两种方式之一来完成：
- en: • Override the default toolchain for the entire directory you’re in by writing
    `rustup override set nightly` (I personally prefer this option).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过编写`rustup override set nightly`覆盖你所在目录的默认工具链（我个人更喜欢这个选项）。
- en: • Tell cargo to use the nightly toolchain every time you compile or run the
    program using `cargo +nightly run`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用`cargo +nightly run`告诉cargo每次编译或运行程序时使用nightly工具链。
- en: We’ll create a simple runtime with a very simple scheduler. Our fibers will
    save/restore their state so they can be stopped and resumed at any point during
    execution. Each fiber will represent a task that we want to progress concurrently,
    and we simply create a new fiber for each task we want to run.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的运行时，具有一个非常简单的调度器。我们的纤程将保存/恢复它们的状态，以便在执行过程中的任何时刻停止和恢复。每个纤程将代表我们想要并发推进的任务，我们只需为每个想要运行的任务创建一个新的纤程。
- en: 'We start off the example by enabling a specific feature we need, importing
    the `asm` macro, and defining a few constants:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从启用一个特定的功能开始，导入`asm`宏，并定义一些常量：
- en: ch05/c-fibers/main.rs
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ch05/c-fibers/main.rs
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The feature we want to enable is called the `naked_functions` feature. Let’s
    explain what a naked function is right away.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要启用的功能被称为`naked_functions`功能。让我们立即解释一下什么是裸函数。
- en: Naked functions
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 裸函数
- en: If you remember when we talked about the operating system ABI and calling conventions
    earlier, you probably remember that each architecture and OS have different requirements.
    This is especially important when creating new stack frames, which is what happens
    when you call a function. So, the compiler knows about what each architecture/OS
    requires and adjusts layout, and parameter placement on the stack and saves/restores
    certain registers to make sure we satisfy the ABI on the platform we’re on. This
    happens both when we enter and exit a function and is often called a function
    **prologue** and **epilogue**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们之前讨论操作系统ABI和调用约定的时候，你可能还记得每个架构和操作系统都有不同的要求。这在创建新的栈帧时尤为重要，当你调用一个函数时就会发生这种情况。因此，编译器知道每个架构/操作系统需要什么，并调整布局和栈上的参数位置，保存/恢复某些寄存器，以确保我们在当前平台上满足ABI。这发生在我们进入和退出函数时，通常被称为函数的**序言**和**尾声**。
- en: In Rust, we can enable this feature and mark a function as `#[naked]`. A naked
    function tells the compiler that we don’t want it to create a function prologue
    and epilogue and that we want to take care of this ourselves. Since we do the
    trick where we return over to a new stack and want to resume the old one at a
    later point we don’t want the compiler to think it manages the stack layout at
    these points. It worked in our first example since we never switched back to the
    original stack, but it won’t work going forward.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们可以启用此功能并将函数标记为`#[naked]`。裸函数告诉编译器我们不想让它创建函数序言和尾声，而想自己处理这些。由于我们在返回到新栈并希望在稍后某个时刻恢复旧栈时做了这个技巧，我们不希望编译器认为它在这些点管理栈布局。在我们的第一个例子中它有效，因为我们从未切换回原始栈，但向前推进时它将不起作用。
- en: Our `DEFAULT_STACK_SIZE` is set to 2 MB, which is more than enough for our use.
    We also set `MAX_THREADS` to `4` since we don’t need more for our example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DEFAULT_STACK_SIZE`设置为2 MB，这对于我们的使用来说已经足够多了。我们还把`MAX_THREADS`设置为`4`，因为我们不需要更多的线程来运行我们的例子。
- en: The last static constant, `RUNTIME`, is a pointer to our runtime (yeah, I know,
    it’s not pretty with a mutable global variable, but it’s making it easier for
    us to focus on the important parts of the example later on).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个静态常量`RUNTIME`是指向我们的运行时的指针（是的，我知道，使用可变的全局变量看起来并不漂亮，但它有助于我们专注于示例的重要部分）。
- en: 'The next thing we do is set up some data structures to represent the data we’ll
    be working with:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置一些数据结构来表示我们将要处理的数据：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Runtime` is going to be our main entry point. We are basically going to create
    a very small runtime with a very simple scheduler and switch between our threads.
    The runtime holds an array of `Thread` structs and a `current` field to indicate
    which thread we are currently running.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runtime` 将成为我们的主要入口点。我们将创建一个非常小的运行时，具有一个非常简单的调度器，并在线程之间切换。运行时包含一个 `Thread`
    结构体的数组和一个 `current` 字段，用于指示我们当前正在运行的线程。'
- en: '`Thread` holds data for a thread. The `ctx` field is a context representing
    the data our CPU needs to resume where it left off on a stack and a `state` field
    that holds our thread state.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread` 存储线程的数据。`ctx` 字段是一个上下文，表示我们的 CPU 需要在栈上恢复的位置，以及一个 `state` 字段，用于存储线程状态。'
- en: '`State` is an **enum** representing the states our threads can be in:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`State` 是一个 **枚举**，表示线程可能处于的状态：'
- en: '`Available` means the thread is available and ready to be assigned a task if
    needed'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Available` 表示线程可用，并且如果需要可以分配任务'
- en: '`Running` means the thread is running'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Running` 表示线程正在运行'
- en: '`Ready` means the thread is ready to move forward and resume execution'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ready` 表示线程准备好向前移动并继续执行'
- en: '`ThreadContext` holds data for the registers that the CPU needs to resume execution
    on a stack.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadContext` 存储了 CPU 需要在栈上恢复执行的寄存器数据。'
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The registers we save in our `ThreadContext` struct are the registers that are
    marked as *callee saved* in *Figure 5**.1*. We need to save these since the ABI
    states that the *callee* (which will be our `switch` function from the perspective
    of the OS) needs to restore them before the *caller* is resumed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `ThreadContext` 结构体中保存的寄存器是标记为 *callee saved* 的 *图 5**.1* 中的寄存器。我们需要保存这些寄存器，因为
    ABI 规定在 *caller*（从操作系统的角度来看，将是我们的 `switch` 函数）恢复之前，*callee*（即我们的 `switch` 函数）需要恢复它们。
- en: 'Next up is how we initialize the data to a newly created thread:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是如何初始化新创建的线程的数据：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is pretty easy. A new thread starts in the `Available` state, indicating
    it is ready to be assigned a task.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。一个新的线程以 `Available` 状态开始，表示它准备好被分配一个任务。
- en: One thing I want to point out here is that we allocate our stack here. That
    is not needed and is not an optimal use of our resources since we allocate memory
    for threads we might need instead of allocating on first use. However, this lowers
    the complexity in the parts of our code that have a more important focus than
    allocating memory for our stack.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里指出的是，我们在这里分配我们的栈。这不是必需的，并且不是我们资源的最优使用，因为我们为可能需要的线程分配内存而不是在首次使用时分配。然而，这降低了我们代码中比分配栈内存更重要的部分的复杂性。
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Once a stack is allocated it must not move! No `push()` on the vector or any
    other methods that might trigger a reallocation. If the stack is reallocated,
    any pointers that we hold to it are invalidated.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配了栈，它就不能移动！不要在向量上执行 `push()` 或其他可能触发重新分配的方法。如果栈被重新分配，我们持有的任何指向它的指针都将无效。
- en: It’s worth mentioning that `Vec<T>` has a method called `into_boxed_slice()`,
    which returns a reference to an allocated slice `Box<[T]>`. Slices can’t grow,
    so if we store that instead, we can avoid the reallocation problem. There are
    several other ways to make this safer, but we’ll not focus on those in this example.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Vec<T>` 有一个名为 `into_boxed_slice()` 的方法，它返回一个指向已分配切片 `Box<[T]>` 的引用。切片不能增长，所以如果我们用这个来存储，我们可以避免重新分配的问题。还有其他几种方法可以使这更安全，但在这个例子中我们不会关注那些。
- en: Implementing the runtime
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现运行时
- en: The first thing we need to do is to initialize a new runtime to a base state.
    The next code segments all belong to the `impl Runtime` block, and I’ll make sure
    to let you know when the block ends since it can be hard to spot the closing bracket
    when we divide it up as much as we do here.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将一个新的运行时初始化到基本状态。接下来的代码段都属于 `impl Runtime` 块，我会确保让你知道何时结束该块，因为当我们像这里这样将其拆分时，找到结束括号可能很难。
- en: 'The first thing we do is to implement a `new` function on our `Runtime` struct:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 `Runtime` 结构体上实现一个 `new` 函数：
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we instantiate our `Runtime`, we set up a base thread. This thread will
    be set to the `Running` state and will make sure we keep the runtime running until
    all tasks are finished.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化我们的 `Runtime` 时，我们设置一个基本线程。这个线程将被设置为 `Running` 状态，并确保我们保持运行时运行，直到所有任务完成。
- en: Then, we instantiate the rest of the threads and set the current thread (the
    base thread) to `0.`
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实例化其余的线程，并将当前线程（基本线程）设置为 `0`。
- en: The next thing we do is admittedly a little bit hacky since we do something
    that’s usually a no-go in Rust. As I mentioned when we went through the constants,
    we want to access our runtime struct from anywhere in our code so that we can
    call yield on it at any point in our code. There are ways to do this safely, but
    the topic at hand is already complex, so even though we’re juggling with knives
    here, I will do everything I can to keep everything that’s not the main focal
    point of this example as simple as it can be.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情在某种程度上是有点黑客式的，因为我们做了一些在 Rust 中通常不被推荐的事情。正如我提到过的，当我们查看常量时，我们希望从代码的任何地方访问我们的运行时结构体，这样我们就可以在任何代码点调用
    yield。有安全地做到这一点的方法，但当前的话题已经很复杂，所以尽管我们在玩刀子，我会尽我所能使所有不是本例主要焦点的部分尽可能简单。
- en: After we call initialize on the Runtime, we have to make sure we don’t do anything
    that can invalidate the pointer we take to `self` once it’s initialized.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对运行时调用 initialize 之后，我们必须确保我们不做任何可能使我们对 `self` 指针的引用无效的事情。
- en: '[PRE20]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is where we start running our runtime. It will continually call `t_yield()`
    until it returns `false`, which means that there is no more work to do and we
    can exit the process:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始运行运行时的地方。它将不断调用 `t_yield()`，直到它返回 `false`，这意味着没有更多的工作要做，我们可以退出进程：
- en: '[PRE21]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`yield` is a reserved word in Rust, so we can’t name our function that. If
    that was not the case, it would be my preferred name for it over the slightly
    more cryptic `t_yield`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield` 是 Rust 中的一个保留字，所以我们不能将我们的函数命名为这个名字。如果不是这样，那将是我对它稍显晦涩的 `t_yield` 的首选名称。'
- en: 'This is the return function that we call when a thread is finished. `return`
    is another reserved keyword in Rust, so we name this `t_return()`. Make a note
    that the user of our threads does not call this; we set up our stack so this is
    called when the task is done:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在线程完成时调用的返回函数。`return` 是 Rust 中的另一个保留关键字，所以我们将其命名为 `t_return()`。请注意，我们的线程用户不会调用这个函数；我们设置我们的堆栈，以便在任务完成时调用这个函数：
- en: '[PRE22]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the calling thread is the `base_thread`, we won’t do anything. Our runtime
    will call `t_yield` for us on the base thread. If it’s called from a spawned thread,
    we know it’s finished since all threads will have a `guard` function on top of
    their stack (which we’ll show further down), and the only place where this function
    is called is on our `guard` function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用线程是 `base_thread`，我们不会做任何事情。我们的运行时会在基础线程上为我们调用 `t_yield`。如果是从一个派生线程中调用的，我们知道它已经完成，因为所有线程的堆栈顶部都有一个
    `guard` 函数（我们将在下面展示），而这个函数被调用的唯一地方就是我们的 `guard` 函数。
- en: We set its state to `Available`, letting the runtime know it’s ready to be assigned
    a new task, and then immediately call `t_yield`, which will schedule a new thread
    to be run.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其状态设置为 `Available`，让运行时知道它已准备好分配新的任务，然后立即调用 `t_yield`，这将安排一个新的线程运行。
- en: 'So, finally, we get to the heart of our runtime: the `t_yield` function.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，最终，我们来到了运行时的核心：`t_yield` 函数。
- en: The first part of this function is our scheduler. We simply go through all the
    threads and see if any are in the `Ready` state, which indicates that it has a
    task it is ready to make progress. This could be a database call that has returned
    in a real-world application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的前一部分是我们的调度器。我们只是遍历所有线程，看看是否有任何线程处于 `Ready` 状态，这表明它有一个准备进行进展的任务。这可能是现实世界应用程序中返回的数据库调用。
- en: If no thread is `Ready`, we’re all done. This is an extremely simple scheduler
    using only a round-robin algorithm. A real scheduler might have a much more sophisticated
    way of deciding what task to run next.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有线程处于 `Ready` 状态，我们就完成了。这是一个极其简单的调度器，仅使用轮询算法。一个真正的调度器可能会有一种更复杂的方式来决定下一个要运行的任务。
- en: If we find a thread that’s ready to be run, we change the state of the current
    thread from `Running` to `Ready`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个可以运行的线程，我们将当前线程的状态从 `Running` 改为 `Ready`。
- en: 'Let’s present the function before we go on to explain the last part of it:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释这个函数的最后部分之前，让我们先展示这个函数：
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next thing we do is to call the function `switch`, which will save the current
    context (the old context) and load the new context into the CPU. The new context
    is either a new task or all the information the CPU needs to resume work on an
    existing task.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是调用 `switch` 函数，这将保存当前上下文（旧上下文）并将新上下文加载到 CPU 中。新上下文要么是一个新任务，要么是 CPU
    需要恢复现有任务的所有信息。
- en: Our `switch` function, which we will cover a little further down, takes two
    arguments and is marked as `#[naked]`. Naked functions are not like normal functions.
    They don’t accept formal arguments, for example, so we can’t simply call it in
    Rust as a normal function like `switch(old, new)`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要进一步介绍的`switch`函数接受两个参数，并标记为`#[naked]`。裸函数与普通函数不同。它们不接受形式参数，例如，所以我们不能像在Rust中调用普通函数一样简单地调用它，如`switch(old,
    new)`。
- en: You see, usually, when we call a function with two arguments, the compiler will
    place each argument in a register described by the calling convention for the
    platform. However, when we call a `#[naked]` function, we need to take care of
    this ourselves. Therefore, we pass in the address to our old and new `ThreadContext`
    using assembly. `rdi` is the register for the first argument in the System V ABI
    calling convention and `rsi` is the register used for the second argument.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，通常，当我们用两个参数调用一个函数时，编译器会将每个参数放置在平台调用约定描述的寄存器中。然而，当我们调用一个`#[naked]`函数时，我们需要自己处理这个问题。因此，我们通过汇编传递我们旧的和新`ThreadContext`的地址。`rdi`是System
    V ABI调用约定中第一个参数的寄存器，而`rsi`是用于第二个参数的寄存器。
- en: The `#[inline(never)]` attribute prevents the compiler from simply substituting
    a call to our function with a copy of the function content wherever it’s called
    (this is what inlining means). This is almost never a problem on debug builds,
    but in this case, our program will fail if the compiler `Runtime` as a static
    `usize` that we then cast as a `*mut` pointer (which is almost guaranteed to cause
    UB), it’s *most likely* caused by the compiler making the wrong assumptions when
    this function is inlined and called by casting and dereferencing `RUNTIME` in
    one of the helper methods that will be outlined. Just make a note that this is
    probably avoidable if we change our design; it’s not something worth dwelling
    on for too long in this specific case.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[inline(never)]`属性阻止编译器简单地用函数内容的副本替换我们的函数调用（这就是内联的含义）。在调试构建中这几乎永远不会成为问题，但在这个案例中，如果编译器将`Runtime`作为静态`usize`处理，然后将其转换为`*mut`指针（这几乎肯定会引起未定义行为），那么它*最有可能*是由于编译器在将此函数内联并调用时，在将要概述的辅助方法中通过强制转换和间接引用`RUNTIME`时做出了错误的假设。请注意，如果我们改变我们的设计，这可能是有避免的；这不是在这个特定情况下值得长时间深思的问题。'
- en: More inline assembly
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 更多内联汇编
- en: We need to explain the new concepts we introduced here. The assembly calls the
    function `switch` (the function is tagged with `#[no_mangle]` so we can call it
    by name). The `in("rdi") old` and `in("rsi") new` arguments place the value of
    `old` and `new` to the `rdi` and `rsi` registers, respectively. The System V ABI
    for x86-64 states that the `rdi` register holds the first argument to a function
    and `rsi` holds the second argument.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解释我们在这里引入的新概念。汇编调用函数`switch`（该函数被标记为`#[no_mangle]`，因此我们可以通过名称调用它）。`in("rdi")
    old`和`in("rsi") new`参数将`old`和`new`的值分别放置到`rdi`和`rsi`寄存器中。x86-64的System V ABI指出，`rdi`寄存器持有函数的第一个参数，而`rsi`持有第二个参数。
- en: The `clobber_abi("C")` argument tells the compiler that it may not assume any
    that any general-purpose registers are preserved across the `asm!` block. The
    compiler will emit instructions to push the registers it uses to the stack and
    restore them when resuming after the `asm!` block.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`clobber_abi("C")`参数告诉编译器它不能假设任何通用寄存器在`asm!`块执行期间被保留。编译器将发出指令将使用的寄存器推送到栈上，并在`asm!`块执行后恢复它们。'
- en: If you take one more look at the list in *Figure 5**.1*, we already know that
    we need to take special care with registers that are marked as *callee saved*.
    When calling a normal function, the compiler will insert code* to save/restore
    all the non-callee-saved, or caller saved, registers before calling a function
    so it can resume with the correct state when the function returns. Since we marked
    the function we’re calling as `#[naked]`, we explicitly told the compiler to not
    insert this code, so the safest thing is to make sure the compiler doesn’t assume
    that it can rely on any register being untouched when it resumes after the call
    we make in our `asm!` block.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再仔细看看*图5**.1*中的列表，我们已经知道我们需要特别小心标记为*调用者保留*的寄存器。在调用普通函数时，编译器会在调用函数之前插入代码*保存/恢复所有非调用者保留或调用者保留的寄存器，以便在函数返回时能够以正确的状态恢复。由于我们将要调用的函数标记为`#[naked]`，我们明确告诉编译器不要插入此代码，因此最安全的事情是确保编译器在执行我们的`asm!`块中的调用后恢复时不会假设任何寄存器未被触及。
- en: '*In some instances, the compiler will know that a register is untouched by
    the function call since it controls the register usage in both the caller and
    the callee and it will not emit any special instructions to save/restore registers
    they know will be untouched when the function returns'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*在某些情况下，编译器会知道一个寄存器在函数调用中没有被修改，因为它控制了调用者和被调用者的寄存器使用，并且它不会发出任何特殊的指令来保存/恢复它们知道在函数返回时不会被修改的寄存器'
- en: The `self.threads.len() > 0` line at the end is just a way for us to prevent
    the compiler from optimizing our code away. This happens to me on Windows but
    not on Linux, and it is a common problem when running benchmarks, for example.
    There are other ways of preventing the compiler from optimizing this code, but
    I chose the simplest way I could find. As long as it’s commented, it should be
    OK to do. The code never reaches this point anyway.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `self.threads.len() > 0` 行只是我们防止编译器优化我们的代码的一种方式。这种情况在 Windows 上会发生，但在 Linux
    上不会，这是运行基准测试时常见的常见问题。还有其他防止编译器优化这段代码的方法，但我选择了我能找到的最简单的方法。只要它被注释掉，做这个应该没问题。代码永远不会到达这个点。
- en: 'Next up is our `spawn` function. I’ll present the function first and guide
    you through it after:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的 `spawn` 函数。我先展示这个函数，然后再引导你了解它：
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I promised to point out where we close the `impl Runtime` block, and we do that
    after the `spawn` function. The upcoming functions are “free” functions that don’t
    belong to a struct.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我承诺指出我们关闭 `impl Runtime` 块的位置，我们是在 `spawn` 函数之后做的。接下来的函数是“免费”函数，不属于任何结构体。
- en: While I think `t_yield` is the logically interesting function in this example,
    I think `spawn` is the most interesting one technically.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我认为 `t_yield` 是这个例子中逻辑上有趣的功能，但我认为 `spawn` 在技术上是最有趣的。
- en: 'The first thing to note is that the function takes one argument: `f: fn()`.
    This is simply a function pointer to the function we take as an argument. This
    function is the task we want to run concurrently with other tasks. If this was
    a library, this is the function that users actually pass to us and want our runtime
    to handle concurrently.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '首先要注意的是，这个函数接受一个参数：`f: fn()`。这只是一个指向我们作为参数传递的函数的函数指针。这个函数是我们想要与其他任务并发运行的作业。如果这是一个库，那么这个函数就是用户实际传递给我们并希望我们的运行时并发处理的函数。'
- en: In this example, we take a simple function as an argument, but if we modify
    the code slightly we can also accept a closure.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们以一个简单的函数作为参数，但如果我们稍微修改一下代码，我们也可以接受一个闭包。
- en: Tip
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In example `ch05/d-fibers-closure`, you can see a slightly modified example
    that accepts a closure instead, making it more flexible than the one we walk through
    here. I would really encourage you to check that one out once you’ve finished
    this example.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ch05/d-fibers-closure` 示例中，你可以看到一个稍微修改过的例子，它接受一个闭包而不是函数，这使得它比我们这里展示的更灵活。我真心建议你在完成这个例子后去查看一下那个例子。
- en: The rest of the function is where we set up our stack as we discussed in the
    previous chapter and make sure our stack looks like the one specified in the System
    V ABI stack layout.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分是我们根据前一章讨论的内容设置我们的栈，并确保我们的栈看起来像 System V ABI 栈布局中指定的那样。
- en: When we spawn a new fiber (or userland thread), we first check if there are
    any available userland threads (threads in `Available` state). If we run out of
    threads, we panic in this scenario, but there are several (better) ways to handle
    that. We’ll keep things simple for now.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个新的纤程（或用户空间线程）时，我们首先检查是否有任何可用的用户空间线程（处于 `Available` 状态的线程）。如果我们用完了线程，在这个场景下我们会恐慌，但还有几种（更好的）处理方式。我们现在会保持简单。
- en: When we find an available thread, we get the stack length and a pointer to our
    `u8` byte array.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们找到一个可用的线程时，我们获取栈长度以及指向我们的 `u8` 字节数组的指针。
- en: In the next segment, we have to use some unsafe functions. We’ll explain the
    functions we refer to here later, but this is where we set them up in our new
    stack so that they’re called in the right order for our runtime to work.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个部分，我们必须使用一些不安全的功能。我们稍后会解释我们在这里提到的函数，但这是我们在新的栈中设置它们，以便它们以正确的顺序被我们的运行时调用的地方。
- en: First, we make sure that the memory segment we’ll use is 16-byte-aligned. Then,
    we write the address to our `guard` function that will be called when the task
    we provide finishes and the function returns.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保我们将要使用的内存段是 16 字节对齐的。然后，我们将地址写入我们的 `guard` 函数，该函数将在我们提供的任务完成并返回时被调用。
- en: Second, we’ll write the address to a `skip` function, which is there just to
    handle the gap when we return from `f`, so that `guard` will get called on a 16-byte
    boundary. The next value we write to the stack is the address to `f`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们将地址写入 `skip` 函数，这个函数只是用来处理从 `f` 返回时的间隙，这样 `guard` 就会在 16 字节边界上被调用。我们接下来写入栈的下一个值是
    `f` 的地址。
- en: Why do we need the skip function?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要 `skip` 函数？
- en: Remember how we explained how the stack works? We want the `f` function to be
    the first to run, so we set the base pointer to `f` and make sure it’s 16-byte
    aligned. We then push the address to the `skip` function and lastly the `guard`
    function. Since, `skip` is simply one instruction, `ret`, doing this makes sure
    that our call to `guard` is 16-byte aligned so that we adhere to the ABI requirements.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们是如何解释栈的工作原理的吗？我们希望 `f` 函数首先运行，因此我们将基指针设置为 `f` 并确保它是 16 字节对齐的。然后我们推送 `skip`
    函数的地址，最后推送 `guard` 函数。由于 `skip` 只有一个指令 `ret`，这样做确保我们的 `guard` 调用是 16 字节对齐的，这样我们就遵守了
    ABI 要求。
- en: After we’ve written our function pointers to the stack, we set the value of
    `rsp`, which is the stack pointer to the address of our provided function, so
    we start executing that first when we are scheduled to run.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将函数指针写入栈后，我们设置 `rsp` 的值，即栈指针，指向我们提供的函数地址，这样当我们被调度运行时，我们首先执行该函数。
- en: Lastly, we set the state to `Ready`, which means we have work to do and that
    we are ready to do it. Remember, it’s up to our scheduler to actually start up
    this thread.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将状态设置为 `Ready`，这意味着我们有工作要做，并且我们已经准备好去做。记住，启动这个线程实际上是由我们的调度器来完成的。
- en: We’re now finished implementing our `Runtime`, if you got all this, you basically
    understand how fibers/green threads work. However, there are still a few details
    needed to make it all work.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 `Runtime` 的实现，如果你理解了这一切，你基本上就明白了 fibers/green threads 的工作原理。然而，还有一些细节需要完善才能使整个系统工作。
- en: Guard, skip, and switch functions
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 守护、跳过和切换函数
- en: 'There are a few functions we’ve referred to that are really important for our
    Runtime to actually work. Fortunately, all but one of them are extremely simple
    to understand. We’ll start with the `guard` function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个我们提到的重要函数对于我们的运行时真正工作至关重要。幸运的是，除了一个之外，它们都非常简单易懂。我们将从 `guard` 函数开始：
- en: '[PRE25]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `guard` function is called when the function that we passed in, `f`, has
    returned. When `f` returns, it means our task is finished, so we de-reference
    our `Runtime` and call `t_return()`. We could have made a function that does some
    additional work when a thread is finished, but right now, our `t_return()` function
    does all we need. It marks our thread as `Available` (if it’s not our base thread)
    and yields so we can resume work on a different thread.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递的函数 `f` 返回时，会调用 `guard` 函数。当 `f` 返回时，意味着我们的任务已经完成，因此我们取消引用 `Runtime` 并调用
    `t_return()`。我们本可以创建一个函数，在线程完成时执行一些额外的工作，但当前我们的 `t_return()` 函数已经足够满足需求。它将我们的线程标记为
    `Available`（如果不是基本线程）并释放，这样我们就可以在不同的线程上继续工作。
- en: 'Next is our `skip` function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的 `skip` 函数：
- en: '[PRE26]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is not much happening in the `skip` function. We use the `#[naked]` attribute
    so that this function essentially compiles down to just `ret` instruction. `ret`
    will just pop off the next value from the stack and jump to whatever instructions
    that address points to. In our case, this is the `guard` function.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `skip` 函数中并没有发生太多事情。我们使用 `#[naked]` 属性，使得这个函数实际上编译成只有一个 `ret` 指令。`ret` 将从栈中弹出下一个值，并跳转到该地址指向的指令。在我们的例子中，这是
    `guard` 函数。
- en: 'Next up is a small helper function named `yield_thread`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个名为 `yield_thread` 的小型辅助函数：
- en: '[PRE27]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This helper function lets us call `t_yield` on our `Runtime` from an arbitrary
    place in our code without needing any references to it. This function is very
    unsafe, and it’s one of the places where we make big shortcuts to make our example
    slightly simpler to understand. If we call this and our Runtime is not initialized
    yet or the runtime is dropped, it will result in undefined behavior. However,
    making this safer is not a priority for us just to get our example up and running.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助函数允许我们从代码的任意位置调用 `Runtime` 上的 `t_yield`，而不需要任何对该函数的引用。这个函数非常不安全，并且是我们为了使示例稍微简单易懂而做出的大胆简化的地方之一。如果我们调用这个函数，而我们的
    `Runtime` 尚未初始化或者运行时被丢弃，这将导致未定义的行为。然而，为了使这个函数更安全，对我们来说并不是一个优先事项，只是为了让我们的示例能够运行起来。
- en: 'We are very close to the finish line; just one more function to go. The last
    bit we need is our `switch` function, and you already know the most important
    parts of it already. Let’s see how it looks and explain how it differs from our
    first stack swap function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经非常接近终点；只需再完成一个函数。我们最后需要的函数是`switch`函数，你已经知道了它的最重要的部分。让我们看看它的样子，并解释一下它与我们的第一个栈交换函数有何不同：
- en: '[PRE28]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So, this is our full stack switch function. You probably remember from our first
    example that this is just a bit more elaborate. We first read out the values of
    all the registers we need and then set all the register values to the register
    values we saved when we suspended execution on the new thread.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们完整的栈交换函数。你可能还记得，从我们的第一个例子中，这只是一个更详细的过程。我们首先读取所有需要的寄存器的值，然后将所有寄存器值设置为我们在新线程上挂起执行时保存的寄存器值。
- en: This is essentially all we need to do to save and resume the execution.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是我们保存和恢复执行所需做的所有事情。
- en: Here we see the `#[naked]` attribute used again. Usually, every function has
    a prologue and an epilogue and we don’t want that here since this is all assembly
    and we want to handle everything ourselves. If we don’t include this, we will
    fail to switch back to our stack the second time.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到再次使用了`#[naked]`属性。通常，每个函数都有一个前缀和后缀，我们在这里不希望有这些，因为这里全是汇编，我们希望自行处理所有事情。如果我们不包括这个，我们将在第二次切换回我们的栈时失败。
- en: 'You can also see us using the offset we introduced earlier in practice:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到我们在实践中使用我们之前引入的偏移量：
- en: '[PRE29]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These are hex numbers indicating the offset from the memory pointer to which
    we want to read/write. I wrote down the base 10 numbers as comments, so as you
    can see, we only offset the pointer in 8-byte steps, which is the same size as
    the `u64` fields on our `ThreadContext` struct.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是表示从内存指针到我们想要读取/写入的偏移量的十六进制数字。我在注释中写下了十进制数字，所以正如你所见，我们只以8字节步长偏移指针，这与我们的`ThreadContext`结构体上的`u64`字段大小相同。
- en: This is also why it’s important to annotate `ThreadContext` with `#[repr(C)]`;
    it tells us that the data will be represented in memory in this exact way so we
    write to the right field. The Rust ABI makes no guarantee that they are represented
    in the same order in memory; however, the C-ABI does.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么用`#[repr(C)]`注释`ThreadContext`很重要的原因；它告诉我们数据将以这种方式在内存中表示，因此我们写入正确的字段。Rust
    ABI不保证它们在内存中以相同的顺序表示；然而，C-ABI确实如此。
- en: Finally, there is one new option added to the `asm!` block. `option(noreturn)`
    is a requirement when writing naked functions and we will receive a compile error
    if we don’t add it. Usually, the compiler will assume that a function call will
    return, but naked functions are not anything like the functions we’re used to.
    They’re more like labeled containers of assembly that we can call, so we don’t
    want the compiler to emit `ret` instructions at the end of the function or make
    any assumptions that we return to the previous stack frame. By using this option,
    we tell the compiler to treat the assembly block as if it never returns, and we
    make sure that we never fall through the assembly block by adding a `ret` instruction
    ourselves.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`asm!`块中添加了一个新的选项。在编写裸函数时，`option(noreturn)`是一个必需的要求，如果我们不添加它，将会收到编译错误。通常，编译器会假设函数调用将会返回，但裸函数与我们习惯的函数完全不同。它们更像是我们可以调用的汇编标签容器，因此我们不希望编译器在函数末尾发出`ret`指令或做出任何关于我们返回到上一个栈帧的假设。通过使用这个选项，我们告诉编译器将汇编块视为永远不会返回，并通过添加一个`ret`指令来确保我们永远不会通过汇编块。
- en: 'Next up is our `main` function, which is pretty straightforward, so I’ll simply
    present the code here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`main`函数，它相当直接，所以我将在这里简单地展示代码：
- en: '[PRE30]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you see here, we initialize our runtime and spawn two threads: one that
    counts to 10 and yields between each count and one that counts to 15\. When we
    `cargo run` our project, we should get the following output:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们初始化我们的运行时并创建了两个线程：一个从1数到10并在每个计数之间交出控制权，另一个从1数到15。当我们`cargo run`我们的项目时，我们应该得到以下输出：
- en: '[PRE31]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Beautiful! Our threads alternate since they yield control on each count until
    `THREAD 1` finishes and `THREAD 2` counts the last numbers before it finishes
    its task.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 精美！我们的线程交替，因为它们在每个计数之间交出控制权，直到`THREAD 1`完成，然后`THREAD 2`在它完成任务之前数最后几个数字。
- en: Finishing thoughts
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束语
- en: I want to round off this chapter by pointing out some of the advantages and
    disadvantages of this approach, which we went through in [*Chapter 2*](B20892_02.xhtml#_idTextAnchor043),
    since we now have first-hand experience with this topic.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我想通过指出这种方法的一些优缺点来结束本章，这些优缺点我们在[*第二章*](B20892_02.xhtml#_idTextAnchor043)中讨论过，因为我们现在对这个主题有了第一手经验。
- en: First of all, the example we implemented here is an example of what we called
    a stackful coroutine. Each coroutine (or thread, as we call it in the example
    implementation) has its own stack. This also means that we can interrupt and resume
    execution at any point in time. It doesn’t matter if we’re in the middle of a
    stack frame (in the middle of executing a function); we can simply tell the CPU
    to save the state we need to the stack, return to a different stack and restore
    the state it needs there, and resume as if nothing has happened.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在这里实现的例子是我们所说的栈满协程的例子。每个协程（或线程，如我们在示例实现中称呼它）都有自己的栈。这也意味着我们可以在任何时间点中断和恢复执行。我们是否在栈帧的中间（在执行函数的中间）无关紧要；我们只需告诉CPU将我们需要的状态保存到栈上，返回到不同的栈并恢复那里的状态，然后像什么都没发生一样继续执行。
- en: You can also see that we have to manage our stacks in some way. In our example,
    we just create a static stack (much like the OS does when we ask it for a thread,
    but smaller), but for this to be more efficient than using OS threads, we need
    to select a strategy to solve that potential problem.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到，我们必须要以某种方式管理我们的栈。在我们的例子中，我们只是创建了一个静态栈（就像操作系统在请求线程时所做的，但更小），但为了使其比使用操作系统线程更有效率，我们需要选择一种策略来解决这个潜在的问题。
- en: If you look at our slightly expanded example in `ch05/d-fibers-closure`, you’ll
    notice that we can make the API pretty easy to use, much like the API used for
    `std::thread::spawn` in the standard library. The flipside is of course the complexity
    of implementing this correctly on all combinations of ISA/ABIs that we want to
    support, and while specific to Rust, it’s challenging to create a great and *safe*
    API over these kinds of stackful coroutines without any native language support
    for it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`ch05/d-fibers-closure`中稍微扩展的例子，你会注意到我们可以使API非常易于使用，就像标准库中用于`std::thread::spawn`的API一样。当然，另一方面是实现这个API的正确性在所有我们想要支持的ISA/ABIs组合上的复杂性，虽然这特定于Rust，但没有原生语言的支持，在这些类型的栈满协程上创建一个优秀且*安全*的API是具有挑战性的。
- en: To tie this into [*Chapter 3*](B20892_03.xhtml#_idTextAnchor063), where we discuss
    event queues and non-blocking calls, I want to point out that if you use fibers
    to handle concurrency, you would call yield after you’ve made a read interest
    in your non-blocking call. Typically, a runtime would supply these non-blocking
    calls, and the fact that we yield would be opaque to the user, but the fiber is
    suspended at that point. We would probably add one more state to our `State` enum
    called `Pending` or something else that signifies that the thread is waiting for
    some external event.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其与[*第三章*](B20892_03.xhtml#_idTextAnchor063)联系起来，在那里我们讨论了事件队列和非阻塞调用，我想指出，如果你使用纤维来处理并发，你会在你的非阻塞调用中做出读取兴趣之后调用yield。通常，运行时会提供这些非阻塞调用，而我们yield的事实对用户来说是透明的，但纤维在那个点被挂起。我们可能会在我们的`State`枚举中添加一个名为`Pending`或其它表示线程正在等待某些外部事件的额外状态。
- en: When the OS signals that the data is ready, we would mark the thread as `State::Ready`
    to resume and the scheduler would resume execution just like in this example.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统指示数据已准备好时，我们会将线程标记为`State::Ready`以恢复，调度器会像在这个例子中一样继续执行。
- en: While it requires a more sophisticated scheduler and infrastructure, I hope
    that you have gotten a good idea of how such a system would work in practice.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它需要一个更复杂的调度器和基础设施，但我希望你已经对这种系统在实际中的工作方式有了很好的了解。
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: First of all, congratulations! You have now implemented a super simple but working
    example of fibers. You’ve set up your own stack and learned about ISAs, ABIs,
    calling conventions, and inline assembly in Rust.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，恭喜！你现在已经实现了一个超级简单但有效的纤维示例。你已经设置了自己的栈，并了解了Rust中的ISAs、ABIs、调用约定和内联汇编。
- en: It was quite the ride we had to take, but if you came this far and read through
    everything, you should give yourself a big pat on the back. This is not for the
    faint of heart, but you pulled through.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经历了一段相当刺激的旅程，但如果你已经走到这一步并阅读了所有内容，你应该给自己一个大大的掌声。这不是给胆小的人准备的，但你做到了。
- en: This example (and chapter) might take a little time to fully digest, but there
    is no rush for that. You can always go back to this example and read the code
    again to fully understand it. I really do recommend that you play around with
    the code yourself and get to know it. Change the scheduling algorithm around,
    add more context to the threads you create, and use your imagination.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子（和章节）可能需要一些时间来完全消化，但不必急于一时。你总是可以回过头来再次阅读这段代码，以完全理解它。我真心建议你自己动手操作代码，去熟悉它。改变调度算法，为创建的线程添加更多上下文，并发挥你的想象力。
- en: You will probably experience that debugging problems in low-level code like
    this can be pretty hard, but that’s part of the learning process and you can always
    revert back to a working version.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，在像这样低级别的代码中调试问题可能相当困难，但这正是学习过程的一部分，你总是可以回退到一个可工作的版本。
- en: Now that we have covered one of the largest and most difficult examples in this
    book, we’ll go on to learn about another popular way of handling concurrency by
    looking into how futures and async/await works in Rust. The rest of this book
    is in fact dedicated solely to learning about futures and async/await in Rust,
    and since we've gained so much fundamental knowledge at this point, it will be
    much easier for us to get a good and deep understanding of how they work. You've
    done a great job so far!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了这本书中最大、最困难的例子之一，我们将继续学习另一种处理并发的方法，即通过研究Rust中Futures和async/await的工作原理。实际上，本书的其余部分完全致力于学习Rust中的Futures和async/await，由于我们在此阶段已经获得了大量的基础知识，因此我们将更容易获得对它们如何工作的良好和深入的理解。你到目前为止已经做得很好了！
- en: Part 3:Futures and async/await in Rust
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：Rust中的Futures和async/await
- en: This part will explain Futures and async/await in Rust from the ground up. Building
    upon the knowledge acquired thus far, we will construct a central example that
    will serve as a recurring theme in the subsequent chapters, eventually leading
    to the creation of a runtime capable of executing futures in Rust. Throughout
    this exploration, we will delve into concepts such as coroutines, runtimes, reactors,
    executors, wakers, and much more.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将从基础开始解释Rust中的Futures和async/await。在迄今为止获得的知识基础上，我们将构建一个中心示例，这个示例将在后续章节中反复出现，最终将导致一个能够在Rust中执行Futures的运行时的创建。在整个探索过程中，我们将深入研究诸如协程、运行时、反应器、执行器、唤醒器等概念。
- en: 'This part comprises the following chapters:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 6*](B20892_06.xhtml#_idTextAnchor113)*, Futures in Rust*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B20892_06.xhtml#_idTextAnchor113)*，Rust中的Futures*'
- en: '[*Chapter 7*](B20892_07.xhtml#_idTextAnchor122)*, Coroutines and async/await*'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B20892_07.xhtml#_idTextAnchor122)*，协程和async/await*'
- en: '[*Chapter 8*](B20892_08.xhtml#_idTextAnchor138)*, Runtimes, Wakers, and the
    Reactor-Executor Pattern*'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B20892_08.xhtml#_idTextAnchor138)*，运行时，唤醒器以及反应器-执行器模式*'
- en: '[*Chapter 9*](B20892_09.xhtml#_idTextAnchor156)*, Coroutines, Self-referential
    Structs, and Pinning*'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B20892_09.xhtml#_idTextAnchor156)*，协程，自引用结构体和固定*'
- en: '[*Chapter 10*](B20892_10.xhtml#_idTextAnchor178)*, Create Your Own Runtime*'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B20892_10.xhtml#_idTextAnchor178)*，创建你自己的运行时*'
