["```rs\n// scopes.rs\n\nfn main() {\n    let mut b = 4;\n    {\n        let mut a = 34 + b;\n        a += 1;\n    }\n\n    b = a;   \n}\n```", "```rs\n// block_expr.rs\n\nfn main() {\n    // using bare blocks to do multiple things at once\n    let precompute = {\n        let a = (-34i64).abs();\n        let b = 345i64.pow(3);\n        let c = 3;\n        a + b + c\n    };\n\n    // match expressions\n    let result_msg = match precompute {\n        42 => \"done\",\n        a if a % 2 == 0 => \"continue\",\n        _ => panic!(\"Oh no !\")\n    };\n\n    println!(\"{}\", result_msg);\n}\n```", "```rs\n// if_expr.rs\n\nfn compute(i: i32) -> i32 {\n    2 * i\n}\n\nfn main() {\n    let result_msg = \"done\";\n\n    // if expression assignments\n    let result = if result_msg == \"done\" {\n        let some_work = compute(8);\n        let stuff = compute(4);\n        compute(2) + stuff // last expression gets assigned to result\n    } else {\n        compute(1)\n    };\n\n    println!(\"{}\", result);\n}\n```", "```rs\nresult = None\nif (state == \"continue\"):\n    let stuff = work()\n    result = compute_next_result() + stuff\nelse:\n    result = compute_last_result()\n```", "```rs\nfn main() {\n    let mut a: i32;\n    println!(\"{:?}\", a);    // error\n    a = 23;\n    println!(\"{:?}\", a);    // fine now\n}\n```", "```rs\n   Compiling playground v0.0.1 (file:///playground)\nerror[E0381]: use of possibly uninitialized variable: `a`\n --> src/main.rs:7:22\n  |\n7 |     println!(\"{:?}\", a);\n  |                      ^ use of possibly uninitialized `a`\n```", "```rs\nlet a = 23;\nlet mut b = 403;\n```", "```rs\n// let_ref_mut.rs\n\n#[derive(Debug)]\nstruct Items(u32);\n\nfn main() {\n    let items = Items(2);\n    let items_ptr = &items;\n    let ref items_ref = items;\n\n    assert_eq!(items_ptr as *const Items, items_ref as *const Items);\n\n    let mut a = Items(20);\n    // using scope to limit the mutation of `a` within this block by b\n    {\n        // can take a mutable reference like this too\n        let ref mut b = a; // same as: let b = &mut a;\n        b.0 += 25;\n    }\n\n    println!(\"{:?}\", items);\n\n    println!(\"{:?}\", a);   // without the above scope\n                           // this does not compile. Try removing the scope\n}\n```", "```rs\n// destructure_struct.rs\n\nenum Food {\n    Pizza,\n    Salad\n}\n\nenum PaymentMode {\n    Bitcoin,\n    Credit\n}\n\nstruct Order {\n    count: u8,\n    item: Food,\n    payment: PaymentMode\n}\n\nfn main() {\n    let food_order = Order { count: 2,\n                             item: Food::Salad,\n                             payment: PaymentMode::Credit };\n\n    // let can pattern match inner fields into new variables\n    let Order { count, item, .. } = food_order;\n}\n```", "```rs\nlet Order { count, item, .. } = &food_order;\n// or\nlet Order { ref count, ref item, .. } = food_order;\n```", "```rs\nlet mut food_order = Foo { count: 2,\n                           item: Food::Salad,\n                           payment: PaymentMode::Credit };\nlet Order { count, item, .. } = &mut food_order;\n```", "```rs\n// match_ref.rs\n\nstruct Person(String);\n\nfn main() {\n    let a = Person(\"Richard Feynman\".to_string());\n    match a {\n        Person(&name) => println!(\"{} was a great physicist !\", name),\n         _ => panic!(\"Oh no !\")\n    }\n\n    let b = a;\n}\n```", "```rs\n// destructure_enum.rs\n\nenum Container {\n    Item(u64),\n    Empty\n}\n\nfn main() {\n    let maybe_item = Container::Item(0u64);\n    let has_item = if let Container::Item(0) = maybe_item {\n        true\n    } else {\n        false\n    };\n}\n```", "```rs\n// destructure_func_param.rs\n\nstruct Container {\n    items_count: u32\n}\n\nfn increment_item(Container {mut items_count}: &mut Container) {\n    items_count += 1;\n}\n\nfn calculate_cost(Container {items_count}: &Container) -> u32 {\n    let rate = 67;\n    rate * items_count\n}\n\nfn main() {\n    let mut container = Container {\n        items_count: 10\n    };\n\n    increment_item(&mut container);\n    let total_cost = calculate_cost(&container);\n    println!(\"Total cost: {}\", total_cost);\n}\n```", "```rs\n// refutable_pattern.rs\n\nenum Container {\n    Item(u64),\n    Empty\n}\n\nfn main() {\n    let mut item = Container::Item(56);\n    let Container::Item(it) = item;\n}\n```", "```rs\n// loop_expr.rs\n\nfn main() {\n    let mut i = 0;\n    let counter = loop {\n        i += 1;\n        if i == 10 {\n            break i;\n        }\n    };\n    println!(\"{}\", counter);\n}\n```", "```rs\nstruct ConnectionPool {\n    pool_count: usize\n}\n```", "```rs\n#include <iostream>\nint main(int argc, const char * argv[]) {\n    uint foo = 5;\n    int bar = 6;\n    auto difference = foo - bar;\n    std::cout << difference;\n    return 0;\n}\n```", "```rs\n// safe_arithmetic.rs\n\nfn main() {\n    let foo: u32 = 5;\n    let bar: i32 = 6;\n    let difference = foo - bar;\n  println!(\"{}\", difference);\n}\n```", "```rs\nlet mut v = vec![];\nv.push(2);    // can figure type of `v` now to be of Vec<i32>\n```", "```rs\n// type_inference_iterator.rs\n\nuse std::fs::File;\nuse std::io::Read;\n\nfn main() {\n    let file = File::open(\"foo.txt\").unwrap();\n    let bytes = file.bytes().collect();\n}\n```", "```rs\n let bytes: Vec<Result<u8, _>> = file.bytes().collect();\n```", "```rs\n// type_alias.rs\n\npub struct ParsedPayload<T> {\n    inner: T\n}\n\npub struct ParseError<E> {\n    inner: E\n}\n\npub fn parse_payload<T, E>(stream: &[u8]) -> Result<ParsedPayload<T>, ParseError<E>> {\n    unimplemented!();\n}\n\nfn main() {\n    // todo\n}\n```", "```rs\n// added a type alias\ntype ParserResult<T, E> = Result<ParsedPayload<T>, ParseError<E>>;\n\n// and modify parse_payload function as:\npub fn parse_payload<T, E>(stream: &[u8]) -> ParserResult<T, E> {\n    unimplemented!();\n}\n```", "```rs\ntype MyString = String;\n```", "```rs\ntype SomethingComplex<T> = Vec<Result<Option<T>>>;\n```", "```rs\nstruct SuperComplexParser<'s> {\n    stream: &'a [u8]\n}\n\ntype Parser<'s> = SuperComplexParser<'s>;\n```", "```rs\n// strings.rs\n\nfn main() {\n    let a: String = \"Hello\".to_string();    \n    let b = String::from(\"Hello\");\n    let c = \"World\".to_owned();\n    let d = c.clone();\n}\n```", "```rs\n// string_apis.rs\n\nfn main() { \n    let mut empty_string = String::new(); \n    let empty_string_with_capacity = String::with_capacity(50); \n    let string_from_bytestring: String = String::from_utf8(vec![82, 85, 83,\n    84]).expect(\"Creating String from bytestring failed\"); \n\n    println!(\"Length of the empty string is {}\", empty_string.len()); \n    println!(\"Length of the empty string with capacity is {}\",\n    empty_string_with_capacity.len()); \n    println!(\"Length of the string from a bytestring is {}\",\n    string_from_bytestring.len()); \n\n    println!(\"Bytestring says {}\", string_from_bytestring); \n\n    empty_string.push('1'); \n    println!(\"1) Empty string now contains {}\", empty_string); \n    empty_string.push_str(\"2345\"); \n    println!(\"2) Empty string now contains {}\", empty_string); \n    println!(\"Length of the previously empty string is now {}\",\n    empty_string.len()); \n} \n```", "```rs\n// str_type.rs\n\nfn main() {\n    let message: str = \"Wait, but why ?\";\n}\n```", "```rs\n// borrowed_strings.rs\n\nfn get_str_literal() -> &'static str {\n    \"from function\"\n}\n\nfn main() {\n    let my_str = \"This is borrowed\";\n    let from_func = get_str_literal();\n    println!(\"{} {}\", my_str, from_func);\n}\n```", "```rs\n// strings_indexing.rs\n\nfn main() {\n    let hello = String::from(\"Hello\");\n    let first_char = hello[0];\n}\n```", "```rs\n// string_range_slice.rs\n\nfn main() {\n    let my_str = String::from(\"Strings are cool\");\n    let first_three = &my_str[0..3];\n    println!(\"{:?}\", first_three);\n}\n```", "```rs\n// strings_chars.rs\n\nfn main() {\n    let hello = String::from(\"Hello\");\n    for c in hello.chars() {\n        println!(\"{}\", c);\n    }\n}\n```", "```rs\n// string_slices_func.rs\n\nfn say_hello(to_whom: &str) { \n    println!(\"Hey {}!\", to_whom) \n} \n\nfn main() { \n    let string_slice: &'static str = \"you\"; \n    let string: String = string_slice.into(); \n    say_hello(string_slice); \n    say_hello(&string); \n} \n```", "```rs\n// string_concat.rs\n\nfn main() {\n    let a = \"Foo\";\n    let b = \"Bar\";\n    let c = a + b;\n}\n```", "```rs\n// string_concat.rs\n\nfn main() {\n    let foo = \"Foo\";\n    let bar = \"Bar\";\n    let baz = foo.to_string() + bar;\n}\n```", "```rs\n// constants.rs\n\nconst HEADER: &'static [u8; 4] = b\"Obj\\0\"; \n\nfn main() {\n    println!(\"{:?}\", HEADER);\n}\n```", "```rs\n// statics.rs\n\nstatic mut BAZ: u32 = 4; \nstatic FOO: u8 = 9; \n\nfn main() {\n    unsafe {\n        println!(\"baz is {}\", BAZ);\n        BAZ = 42;\n        println!(\"baz is now {}\", BAZ);\n        println!(\"foo is {}\", FOO);\n    }\n}\n```", "```rs\n// const_fns.rs\n\nconst fn salt(a: u32) -> u32 {\n    0xDEADBEEF ^ a\n}\n\nconst CHECKSUM: u32 = salt(23);\n\nfn main() {\n    println!(\"{}\", CHECKSUM);\n}\n```", "```rs\n// const_fn_file.rs\n\nconst fn read_header(a: &[u8]) -> (u8, u8, u8, u8) {\n    (a[0], a[1], a[2], a[3])\n}\n\nconst FILE_HEADER: (u8,u8,u8,u8) = read_header(include_bytes!(\"./const_fn_file.rs\"));\n\nfn main() {\n    println!(\"{:?}\", FILE_HEADER);\n}\n```", "```rs\n// lazy_static_demo\n\nuse std::sync::Mutex;\n\nlazy_static! {\n    static ref ITEMS: Mutex<Vec<u64>> = {\n        let mut v = vec![];\n        v.push(9);\n        v.push(2);\n        v.push(1);\n        Mutex::new(v)\n    }\n}\n```", "```rs\npub trait Iterator {\n    type Item;\n    fn next(&mut self) -> Option<Self::Item>;\n    // other default methods omitted\n}\n```", "```rs\nfor i in 0..20 {\n    // do stuff\n}\n```", "```rs\nlet a = Range(..);\nwhile let Some(i) = a.next() {\n    // do stuff\n}\n```", "```rs\n// custom_iterator.rs\n\nuse std::usize;\n\nstruct Primes {\n    limit: usize\n}\n\nfn main() {\n    let primes = Primes::new(100);\n    for i in primes.iter() {\n        println!(\"{}\", i);\n    }\n}\n```", "```rs\n// custom_iterator.rs\n\nimpl Primes {\n    fn iter(&self) -> PrimesIter {\n        PrimesIter {\n            index: 2,\n            computed: compute_primes(self.limit)\n        }\n    }\n\n    fn new(limit: usize) -> Primes {\n        Primes { limit }\n    }\n}\n```", "```rs\n// custom_iterator.rs\n\nfn compute_primes(limit: usize) -> Vec<bool> {\n    let mut sieve = vec![true; limit];\n    let mut m = 2;\n    while m * m < limit {\n        if sieve[m] {\n            for i in (m * 2..limit).step_by(m) {\n                sieve[i] = false;\n            }\n        }\n        m += 1;\n    }\n    sieve\n}\n```", "```rs\n// custom_iterator.rs\n\nstruct PrimesIter {\n    index: usize,\n    computed: Vec<bool>\n}\n\nimpl Iterator for PrimesIter {\n    type Item = usize;\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            self.index += 1;\n            if self.index > self.computed.len() - 1 {\n                return None;\n            } else if self.computed[self.index] {\n                return Some(self.index);\n            } else {\n                continue\n            }\n        }\n    }\n}\n```", "```rs\n// custom_iterator.rs\n\nuse std::usize;\n\nstruct Primes {\n    limit: usize\n}\n\nfn compute_primes(limit: usize) -> Vec<bool> {\n    let mut sieve = vec![true; limit];\n    let mut m = 2;\n    while m * m < limit {\n        if sieve[m] {\n            for i in (m * 2..limit).step_by(m) {\n                sieve[i] = false;\n            }\n        }\n        m += 1;\n    }\n    sieve\n}\n\nimpl Primes {\n    fn iter(&self) -> PrimesIter {\n        PrimesIter {\n            index: 2,\n            computed: compute_primes(self.limit)\n        }\n    }\n\n    fn new(limit: usize) -> Primes {\n        Primes { limit }\n    }\n}\n\nstruct PrimesIter {\n    index: usize,\n    computed: Vec<bool>\n}\n\nimpl Iterator for PrimesIter {\n    type Item = usize;\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            self.index += 1;\n            if self.index > self.computed.len() - 1 {\n                return None;\n            } else if self.computed[self.index] {\n                return Some(self.index);\n            } else {\n                continue\n            }\n        }\n    }\n}\n\nfn main() {\n    let primes = Primes::new(100);\n    for i in primes.iter() {\n        print!(\"{},\", i);\n    }\n}\n```", "```rs\n3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97\n```", "```rs\n// unsized_types.rs\n\nfn main() {\n    let a: str = \"2048\";\n}\n```", "```rs\n// function_types.rs\n\nfn add_two(a: u32, b: u32) -> u32 {\n    a + b\n}\n\nfn main() {\n    let my_func = add_two;\n    let res = my_func(3, 4);\n    println!(\"{:?}\", res);\n}\n\n```", "```rs\n// unions.rs\n\n#[repr(C)]\nunion Metric {\n    rounded: u32,\n    precise: f32,\n}\n\nfn main() {\n    let mut a = Metric { rounded: 323 };\n    unsafe {\n        println!(\"{}\", a.rounded);\n    }\n    unsafe {\n        println!(\"{}\", a.precise);\n    }\n    a.precise = 33.3;\n    unsafe {\n        println!(\"{}\", a.precise);\n    }\n}\n```", "```rs\nerror: union expressions should have exactly one field\n  --> unions.rs:10:17\n   |\n10 |     let mut a = Metric { rounded: 323, precise:23.0 };\n```", "```rs\n323\n0.000000000000000000000000000000000000000000453\n33.3\n```", "```rs\npub enum Cow<'a, B> where B: 'a + ToOwned + 'a + ?Sized,  {\n    Borrowed(&'a B),\n    Owned(<B as ToOwned>::Owned),\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, U> Into<U> for T where U: From<T> {\n    fn into(self) -> U {\n        U::from(self)\n    }\n}\n```", "```rs\n// object_safety.rs\n\ntrait Foo {\n    fn foo();\n}\n\nfn generic(val: &Foo) {\n\n}\n\nfn main() {\n\n}\n```", "```rs\ntrait Foo {\n    fn foo(&self);\n}\n```", "```rs\n// ufcs.rs\n\ntrait Driver {\n    fn drive(&self) {\n        println!(\"Driver's driving!\");\n    }\n}\n\nstruct MyCar;\n\nimpl MyCar {\n    fn drive(&self) {\n        println!(\"I'm driving!\");\n    }\n}\n\nimpl Driver for MyCar {}\n\nfn main() {\n    let car = MyCar;\n    car.drive();\n}\n```", "```rs\nI'm driving\n```", "```rs\n// fn_closure.rs\n\nfn main() {\n    let a = String::from(\"Hey!\");\n    let fn_closure = || {\n        println!(\"Closure says: {}\", a);    \n    };\n    fn_closure();\n    println!(\"Main says: {}\", a);\n}\n```", "```rs\nClosure says: Hey!\nMain says: Hey!\n```", "```rs\n// fn_mut_closure.rs\n\nfn main() {\n    let mut a = String::from(\"Hey!\");\n    let fn_mut_closure = || {\n        a.push_str(\"Alice\");    \n    };\n    fn_mut_closure();\n    println!(\"Main says: {}\", a);\n}\n```", "```rs\n// fn_once.rs\n\nfn main() {\n    let mut a = Box::new(23);\n    let call_me = || {\n        let c = a;\n    };\n\n    call_me();\n    call_me();\n}\n```", "```rs\n// trait_constants.rs\n\ntrait Circular {\n    const PI: f64 = 3.14;\n    fn area(&self) -> f64;\n}\n\nstruct Circle {\n    rad: f64\n}\n\nimpl Circular for Circle {\n    fn area(&self) -> f64 {\n        Circle::PI * self.rad * self.rad\n    }\n}\n\nfn main() {\n    let c_one = Circle { rad: 4.2 };\n    let c_two = Circle { rad: 75.2 };\n    println!(\"Area of circle one: {}\", c_one.area());\n    println!(\"Area of circle two: {}\", c_two.area());\n}\n```", "```rs\n// enum_struct_consts.rs\n\nenum Item {\n    One,\n    Two\n}\n\nstruct Food {\n    Cake,\n    Chocolate\n}\n\nimpl Item {\n    const DEFAULT_COUNT: u32 = 34;\n}\n\nimpl Food {\n    const FAVORITE_FOOD: &str = \"Cake\";\n}\n\nfn main() {\n\n}\n```", "```rs\n// nested_imports.rs\n\nuse std::sync::{Mutex, Arc, mpsc::channel};\n\nfn main() {\n    let (tx, rx) = channel();\n}\n```", "```rs\n// reexports_demo/src/foo/bar.rs\n\npub struct Bar;\n```", "```rs\n// reexports_demo/src/main.rs\n\nuse foo::bar::Bar;\n\nfn main() {\n\n}\n```", "```rs\n// reexports_demo/src/foo.rs\n\nmod bar;\npub use bar::Bar;\n```", "```rs\n// pub_crate.rs\n\nfn main() {\n\n}\n```", "```rs\n// complex_destructure.rs\n\nenum Foo {\n    One, Two, Three\n}\n\nenum Bar(Foo);\n\nstruct Dummy {\n    inner: Bar\n}\n\nstruct ComplexStruct {\n    obj: Dummy\n}\n\nfn get_complex_struct() -> ComplexStruct {\n    ComplexStruct {\n        obj: Dummy { inner: Bar(Foo::Three) }\n    }\n}\n\nfn main() {\n    let a = get_complex_struct();\n}\n```", "```rs\nlet a = 34u8;\nlet b = a as u64;\n```", "```rs\n// cast_trait_object.rs\n\nuse std::fmt::Display;\n\nfn show_me(item: &Display) {\n    println!(\"{}\", item);\n}\n\nfn main() {\n    let a = \"hello\".to_string();\n    let b = &a;\n    show_me(b);\n    // let c = b as &Display;\n}\n```", "```rs\n// mem_introspection.rs\n\nuse std::cell::Cell; \nuse std::cell::RefCell; \nuse std::rc::Rc; \n\nfn main() { \n    println!(\"type u8: {}\", std::mem::size_of::<u8>()); \n    println!(\"type f64: {}\", std::mem::size_of::<f64>()); \n    println!(\"value 4u8:  {}\", std::mem::size_of_val(&4u8)); \n    println!(\"value 4:  {}\", std::mem::size_of_val(&4)); \n    println!(\"value 'a': {}\", std::mem::size_of_val(&'a')); \n\n    println!(\"value \\\"Hello World\\\" as a static str slice: {}\", std::mem::size_of_val(\"Hello World\")); \n    println!(\"value \\\"Hello World\\\" as a String: {}\", std::mem::size_of_val(\"Hello World\").to_string()); \n\n    println!(\"Cell(4)): {}\", std::mem::size_of_val(&Cell::new(84))); \n    println!(\"RefCell(4)): {}\", std::mem::size_of_val(&RefCell::new(4))); \n\n    println!(\"Rc(4): {}\", std::mem::size_of_val(&Rc::new(4))); \n    println!(\"Rc<RefCell(8)>): {}\", std::mem::size_of_val(&Rc::new(RefCell::new(4)))); \n}\n```", "```rs\n// pointer_layouts.rs\n\ntrait Position {}\n\nstruct Coordinates(f64, f64);\n\nimpl Position for Coordinates {}\n\nfn main() {\n    let val = Coordinates(1.0, 2.0);\n    let ref_: &Coordinates = &val;\n    let pos_ref: &Position = &val as &Position;\n    let ptr:       *const Coordinates = &val as *const Coordinates;\n    let pos_ptr: *const Position  = &val as *const Position;\n\n    println!(\"ref_: {}\", std::mem::size_of_val(&ref_));\n    println!(\"ptr: {}\", std::mem::size_of_val(&ptr));\n    println!(\"val: {}\", std::mem::size_of_val(&val));\n    println!(\"pos_ref: {}\", std::mem::size_of_val(&pos_ref));\n    println!(\"pos_ptr: {}\", std::mem::size_of_val(&pos_ptr));\n}\n```", "```rs\nref_: 8\nptr: 8\nval: 16\npos_ref: 16\npos_ptr: 16\n```", "```rs\n# serde_demo/Cargo.toml\n\n[dependencies]\nserde = \"1.0.84\"\nserde_derive = \"1.0.84\"\nserde_json = \"1.0.36\"\n```", "```rs\n\nserde_demo/src/main.rs\n\nuse serde_derive::{Serialize, Deserialize};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Foo {\n    a: String,\n    b: u64\n}\n\nimpl Foo {\n    fn new(a: &str, b: u64) -> Self {\n        Self {\n            a: a.to_string(),\n            b\n        }\n    }\n}\n\nfn main() {\n    let foo_json = serde_json::to_string(Foo::new(\"It's that simple\", 101)).unwrap();\n    println!(\"{:?}\", foo_json);\n    let foo_value: Foo = serde_json::from_str(foo_json).unwrap();\n    println!(\"{:?}\", foo_value);\n}\n```"]