- en: Creating a REST Web Service
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: Historically, a lot of technologies have been developed and used to create a
    client-server system. In recent decades, though, all client-server architectures
    tend to be web-based—that is, based on the **HyperText Transfer Protocol** (**HTTP**).
    HTTP is based on the **Transfer Control Protocol** (**TCP**) and the **Internet
    Protocol** (**IP**). In particular, two web-based architectures have become popular—the **Simple
    Object Access Protocol** (**SOAP**) and **Representational State Transfer** (**REST**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: While SOAP is an actual protocol, REST is only a collection of *principles*.
    The web services adhering to the REST principles are said to be RESTful. In this
    chapter, we'll see how to build RESTful services using the popular Actix web framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Any web service (REST web services included) can be used by any web client—that
    is, any program that can send HTTP requests over a TCP/IP network. The most typical
    web clients are web pages running in a web browser, and containing JavaScript
    code. Any program written in any programming language and running in any operating
    system implementing the TCP/IP protocols can act as a web client.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The web servers are also known as the **backend**, while the web client is known
    as the **frontend**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The REST architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a stub of a web service using the Actix web framework and implementing
    the REST principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a complete web service capable of uploading files, downloading files,
    and deleting files on client request
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling an inner state as a memory database or a pool of connections to a database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **JavaScript Object Notation** (**JSON**) format to send data to clients
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To easily understand this chapter, you should have beginner knowledge of HTTP.
    The required concepts are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Uniform Resource Identifiers** (**URIs**)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods (such as `GET`)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Headers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content type (such as `plain/text`)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status code (such as `Not Found=404`)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before starting the projects in this chapter, a generic HTTP client should be
    installed on your computer. The tool used in the examples is the command-line
    tool **curl**, freely available for many operating systems. The official download
    page is [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html).
    In particular, the page for Microsoft Windows is [https://curl.haxx.se/windows/](https://curl.haxx.se/windows/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use one of the several good, free web-browser utilities,
    such as Advanced REST Client for Chrome, or RESTED and RESTer for Firefox.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code for this chapter is in the `Chapter03` folder of the
    repository, located at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The REST architecture
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The REST architecture is strongly based on the HTTP protocol but does not require
    any specific kind of data format, and so it can transmit data in several formats
    such as plain text, JSON, **Extensible Markup Language** (**XML**), or binary
    (encoded as Base64).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: REST架构在HTTP协议的基础上构建得非常牢固，但它不要求任何特定的数据格式，因此它可以以多种格式传输数据，如纯文本、JSON、**可扩展标记语言**（**XML**）或二进制（编码为Base64）。
- en: Many web resources describe what the REST architectural paradigm is. One such
    can be found at [https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络资源描述了REST架构范式是什么。其中一个可以在[https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)找到。
- en: However, the concept of the REST architecture is quite simple. It is the purest
    extension of the ideas behind the **World Wide Web** (**WWW**) project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，REST架构的概念非常简单。它是**万维网**（**WWW**）项目背后的思想的纯粹扩展。
- en: The WWW project was born in 1989 as a global library of **hypertexts**. A hypertext
    is a document that contains links to other documents so that, by clicking repeatedly
    on the links, you can see many documents by using only your mouse. Such documents
    are scattered over the internet and are identified by a unique description, the
    **Uniform Resource Locator** (**URL**). The protocol to share such documents is
    HTTP, and the documents are written in **HyperText Markup Language** (**HTML**).
    A document can embed images, referenced by URL addresses too.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**万维网**项目于1989年诞生，作为一个全球性的**超文本**图书馆。超文本是一种包含指向其他文档链接的文档，通过反复点击链接，你可以仅使用鼠标查看许多文档。这样的文档散布在互联网上，并由一个唯一的描述符，即**统一资源定位符**（**URL**）进行标识。共享此类文档的协议是HTTP，文档是用**超文本标记语言**（**HTML**）编写的。文档可以嵌入图像，这些图像也通过URL地址进行引用。'
- en: The HTTP protocol allows you to download pages to your document viewer (the
    web browser), but also to upload new documents to be shared with other people.
    You can also replace existing documents with a new version, or delete existing
    documents.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议允许你将页面下载到你的文档查看器（网页浏览器）中，也可以上传新文档与他人共享。你还可以用新版本替换现有文档，或删除现有文档。
- en: If the concept of a *document* or *file* is replaced by that of *named data*,
    or a *resource*, you get the concept of REST. Any interaction with a RESTful server
    is a manipulation of a piece of data, referencing it by its name. Of course, such
    data can be a disk file, but it can also be a set of records in a database that
    is identified by a query, or even a variable kept in memory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将**文档**或**文件**的概念替换为**命名数据**或**资源**的概念，你就得到了REST的概念。与RESTful服务器的任何交互都是对数据片段的操作，通过其名称进行引用。当然，这样的数据可以是磁盘文件，也可以是数据库中的一组记录，这些记录通过查询进行标识，甚至可以是内存中保留的变量。
- en: A peculiar aspect of RESTful servers is the absence of server-side client sessions.
    As with any hypertext server, RESTful servers do not store the fact that a client
    has logged in. If there is some data associated with a session, such as the current
    user or the previously visited pages, that data belongs only to the client side. As
    a consequence, any time the client needs access to privileged services, or to
    user-specific data, the request must contain the credentials of the user.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务器的一个独特之处在于服务器端没有客户端会话。与任何超文本服务器一样，RESTful服务器不会存储客户端已登录的事实。如果有与会话相关的数据，例如当前用户或之前访问的页面，这些数据仅属于客户端。因此，每当客户端需要访问受保护的服务或特定用户的数据时，请求必须包含用户的凭据。
- en: To improve performance, the server can store session information in a cache,
    but that should be transparent. The server (except for its performance) should
    behave as if it doesn't keep any session information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，服务器可以将会话信息存储在缓存中，但这应该是透明的。服务器（除了性能之外）应该表现得好像它没有保留任何会话信息。
- en: Project overview
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'We are going to build several projects, introducing new features in every project.
    Let''s look at each one, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建几个项目，每个项目都引入了新的功能。让我们依次看看每个项目：
- en: The first project will build a stub of a service that should allow any client
    to upload, download, or delete files from the server. This project shows how to
    create a REST **application programming interface** (**API**), but it does no
    useful work.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个项目将构建一个服务的雏形，该服务应允许任何客户端上传、下载或从服务器删除文件。这个项目展示了如何创建REST **应用程序编程接口**（**API**），但它并不执行任何有用的操作。
- en: The second project will implement the API described in the previous project.
    It will build a service that actually allows any client to upload, download, or
    delete files from the server filesystem.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个项目将实现前一个项目中描述的API。它将构建一个服务，实际上允许任何客户端从服务器文件系统中上传、下载或删除文件。
- en: The third project will build a service that allows clients to add key-value
    records to a memory database residing in the server process, and to recall some
    predefined queries built into the server. The result of such queries will be sent
    back to the client in plain text format.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个项目将构建一个服务，允许客户端向服务器进程中的内存数据库添加键值记录，并调用服务器中预定义的一些查询。这些查询的结果将以纯文本格式发送回客户端。
- en: The fourth project will be similar to the third one, but the results will be
    encoded in JSON format.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个项目将与第三个项目类似，但结果将以JSON格式编码。
- en: Our source code is small, but it includes the Actix web crate, which in turn
    includes around 200 crates, and so the first build of any project will take around
    10 minutes. Following any changes to the application code, a build will take from
    12 to 30 seconds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的源代码很小，但它包括了Actix web crate，而Actix web crate又包括了大约200个crate，因此任何项目的第一次构建将需要大约10分钟。在应用代码的任何更改之后，构建将需要12到30秒。
- en: The Actix web crate has been chosen as it is the most feature-full, reliable,
    high-performance, and well-documented server-side web application framework for
    Rust.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Actix web crate是因为它是功能最全面、最可靠、高性能且文档良好的Rust后端Web应用程序框架。
- en: This framework is not limited to RESTful services, as it can be used to build
    different kinds of server-side web software. It is an extension of the Actix net
    framework, which is a framework designed to implement different kinds of network
    services.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架不仅限于RESTful服务，因为它可以用来构建不同类型的后端Web软件。它是Actix net框架的扩展，这是一个旨在实现不同类型网络服务的框架。
- en: Essential background theory and context
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的背景理论和上下文
- en: Previously, we said that a RESTful service is based on the HTTP protocol. This
    is a rather complex protocol, but its most important parts are quite simple. Here
    is a simplified version of it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，RESTful服务基于HTTP协议。这是一个相当复杂的协议，但它的最重要的部分相当简单。下面是它的简化版本。
- en: The protocol is based on a pair of messages. First, the client sends a request
    to the server, and after the server receives this request, it replies by sending
    a response to the client. Both messages are in **American Standard Code for Information
    Interchange** (**ASCII**) text, and so they are easily manipulated.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 协议基于一对消息。首先，客户端向服务器发送请求，服务器在接收到这个请求后，通过向客户端发送响应来回复。这两个消息都是**美国信息交换标准代码**（**ASCII**）文本，因此它们很容易被操作。
- en: The HTTP protocol is usually based on the TCP/IP protocol, which guarantees
    that these messages arrive at the addressed process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议通常基于TCP/IP协议，这保证了这些消息到达指定的进程。
- en: 'Let''s see a typical HTTP request message, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个典型的HTTP请求消息，如下所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This message contains six lines because there is an empty line at the end.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息包含六行，因为结尾有一个空行。
- en: The first line begins with the word `GET`. This word is the *method* that specifies
    which operation is requested. Then, there is a Unix-style *path* of a resource,
    and then the version of the protocol (here, it is `1.1`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以单词`GET`开头。这个单词是*方法*，它指定了请求的操作。然后是一个Unix风格的*路径*，然后是协议的版本（这里，它是`1.1`）。
- en: Then, there are four lines containing rather simple attributes. These attributes
    are name **headers**. There are many possible optional headers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是四行相对简单的属性。这些属性是*头信息*。有许多可能的可选头信息。
- en: What follows the first empty line is the *body*. Here, the body is empty. The
    body is used to send raw data—even a lot of data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行空行之后的文本是*主体*。在这里，主体是空的。主体用于发送原始数据——甚至大量数据。
- en: So, any request from the HTTP protocol sends a command name (the method) to
    a specific server, followed by an identifier of a resource (the path). Then, there
    are a few attributes (one per line), then an empty line, and, finally, the possible
    raw data (the body).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何HTTP协议的请求都会向特定的服务器发送一个命令名（方法），然后是一个资源标识符（路径）。然后是一系列属性（每行一个），然后是一个空行，最后是可能的原始数据（主体）。
- en: 'The most important methods are detailed as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的方法如下详细说明：
- en: '`GET`: This requests a resource to be downloaded from the server (typically
    an HTML file or an image file, but also any data). The path specifies where the
    resource should be read.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This sends some data to the server that the server should consider
    as new. The path specifies where to add this data. If the path identifies any
    existing data, the server should return an error code. The contents of the data
    to post are in the body section.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This is similar to the `POST` command, but it is meant to replace existing
    data.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This requests the resource to be removed specified by the path. It
    has an empty body.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a typical HTTP response message:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line of any response message begins with the protocol version, followed
    by the status code both in text format and in numeric format. Success is represented
    by `200 OK`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Then, there are several headers—six, in this example—then an empty line, and
    then the body, which may be empty. In this case, the body contains some HTML code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information regarding the HTTP protocol at: [https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Building a stub of a REST web service
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The typical example of a REST service is a web service designed for uploading
    and downloading text files. As it would be too complex to understand, first we
    will look at a simpler project, the `file_transfer_stub` project, which mimics
    this service without actually doing anything on the filesystem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: You will see how an API of a RESTless web service is structured, without being
    overwhelmed by the details regarding the implementation of the commands.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, this example will be completed with the needed implementation,
    to obtain a working file-managing web app.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Running and testing the service
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run this service, it is enough to type the command `cargo run` in a console.
    After building the program, it will print `Listening at address 127.0.0.1:8080
    ...`, and it will remain listening for incoming requests.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To test it, we need a web client. You can use a browser extension if you prefer,
    but in this chapter, the curl command-line utility will be used.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'The `file_transfer_stub` service and the `file_transfer` service (we''ll see
    them in the next section) have the same API, containing the following four commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Download a file with a specified name.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload a file with a specified name and specified contents.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload a file with a specified name prefix and specified contents, obtaining
    the complete name as a response.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete a file with a specified name.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting a resource using the GET method
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To download a resource in the REST architecture, the `GET` method should be
    used. For these commands, the URL should specify the name of the file to download.
    No additional data should be passed, and the response should contain the contents
    of the file and the status code, which can be `200`, `404`, or `500`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command into a console:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中输入以下命令：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In that console, the following mock line should be printed, and then the prompt
    should appear immediately:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个控制台中，应该打印以下模拟行，然后立即出现提示符：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Meanwhile, on the other console, the following line should be printed:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，在另一个控制台中，应该打印以下行：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command mimics the request to download the `datafile.txt` file from the
    filesystem of the server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令模拟从服务器文件系统中下载 `datafile.txt` 文件的请求。
- en: 'The `GET` method is the default one for curl, and hence you can simply type
    the following:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET` 方法是 curl 的默认方法，因此你可以简单地输入以下命令：'
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In addition, you can redirect the output to any file by typing the following:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，你可以通过输入以下命令将输出重定向到任何文件：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, we have now seen how our web service can be used by curl to download a remote
    file, to print it on the console, or to save it in a local file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经看到我们的网络服务如何通过 curl 下载远程文件，将其打印到控制台，或者将其保存到本地文件。
- en: Sending a named resource to the server using the PUT method
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PUT 方法将命名资源发送到服务器
- en: 'To upload a resource in the REST architecture, either the `PUT` or `POST` methods
    should be used. The `PUT` method is used when the client knows *where* the resource
    should be stored, in essence, what will be its *identifying key*. If there is
    already a resource that has this key, that resource will be replaced by the newly
    uploaded resource:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 架构中上传资源时，应使用 `PUT` 或 `POST` 方法。`PUT` 方法用于客户端知道资源应存储的位置时，本质上，它将是其 *标识键*。如果已存在具有该键的资源，则该资源将被新上传的资源替换：
- en: 'Type the following command into a console:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中输入以下命令：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In that console, the prompt should appear immediately. Meanwhile, on the other
    console, the following line should be printed:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个控制台中，提示符应立即出现。同时，在另一个控制台中，应该打印以下行：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command mimics the request to send a file to the server, with the client
    specifying the name of that resource, so that if a resource with that name already
    exists, it is overwritten.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令模拟向服务器发送文件的请求，客户端指定该资源的名称，因此如果已存在同名资源，则该资源将被覆盖。
- en: 'You can use *curl* to send the data contained in a specified local file in
    the following way:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 *curl* 以以下方式发送指定本地文件中的数据：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the `curl` command has an additional argument, `-d`, which allows us to
    specify the data we want to send to the server. If it is followed by an `@` symbol,
    the text following this symbol is used as the path of the uploaded file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`curl` 命令有一个额外的参数 `-d`，它允许我们指定要发送到服务器的数据。如果它后面跟着一个 `@` 符号，则该符号后面的文本用作上传文件的路径。
- en: For these commands, the URI should specify the name of the file to upload and
    also the contents of the file, and the response should contain only the status
    code, which can be `200`, `201` (Created), or `500`. The difference between `200`
    and `201` is that in the first case, an existing file is overwritten, and in the
    second case, a new file is created.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些命令，URI 应指定要上传的文件名称和文件内容，并且响应应只包含状态码，可以是 `200`、`201`（已创建）或 `500`。`200` 和
    `201` 之间的区别在于，在第一种情况下，现有文件被覆盖，在第二种情况下，创建了一个新文件。
- en: So, we have now learned how our web service can be used by curl to upload a
    string into a remote file, while also specifying the name of the file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经学会了如何使用 curl 通过我们的网络服务上传字符串到远程文件，同时指定文件名。
- en: Sending a new resource to the server using the POST method
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 POST 方法将新资源发送到服务器
- en: 'In the REST architecture, the `POST` method is the one to use when it is the
    responsibility of the service to generate an identifier key for the new resource.
    Thus, the request does not have to specify it. The client can specify a pattern
    or prefix for the identifier, though. As the key is automatically generated and
    unique, there cannot be another resource that has the same key. The generated
    key should be returned to the client, though, because otherwise, it cannot reference
    that resource afterward:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 架构中，`POST` 方法是在服务负责为新资源生成标识键时使用的方法。因此，请求不需要指定它。客户端可以指定标识符的模式或前缀。由于键是自动生成的且唯一，因此不可能有另一个具有相同键的资源。但是，应该将生成的键返回给客户端，否则，之后无法引用该资源：
- en: 'To upload a file with an unknown name, type the following command into the console:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要上传一个未知名称的文件，请在控制台中输入以下命令：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In that console, the text `data17.txt` should be printed, and then the prompt
    should appear. This text is the simulated name of the file, received from the
    server. Meanwhile, on the other console, the following line should be printed:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command represents the request to send a file to the server, with the server
    specifying a new unique name for that resource so that no other resource will
    be overwritten.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: For this command, the URI should not specify the full name of the file to upload,
    but only a prefix; of course, the request should also contain the contents of
    the file. The response should contain the complete name of the newly created file
    and the status code. In this case, the status code can only be `201` or `500`,
    because the possibility of a file already existing is ruled out.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how our web service can be used by curl to upload a string
    into a new remote file, leaving the task of inventing a new name for that file
    to the server. We have also seen that the generated filename is sent back as a
    response.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a resource using the DELETE method
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the REST architecture, to delete a resource, the `DELETE` method should
    be used:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command into a console (don''t worry—no file will be deleted!):'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After typing that command, the prompt should appear immediately. Meanwhile,
    in the server console, the following line should be printed:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command represents the request to delete a file from the filesystem of
    the server. For such a command, the URL should specify the name of the file to
    delete. No additional data needs to be passed, and the only response is the status
    code, which can be `200`, `404`, or `500`. So, we have seen how our web service
    can be used by *curl* to delete a remote file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'As a summary, the possible status codes of this service are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '`200`: OK'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201`: Created'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404`: Not Found'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500`: Internal Server Error'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, the four commands of our API are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **URI** | **Request data format** | **Response data format**
    | **Status codes** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/{filename}` | --- | text/plain | `200`, `404`, `500` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/{filename}` | text/plain | --- | `200`, `201`, `500` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/{filename` prefix} | text/plain | text/plain | `201`, `500` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/{filename}` | --- | --- | `200`, `404`, `500` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: Sending an invalid command
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see the behavior of the server when an invalid command is received:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command into a console:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In that console, the prompt should appear immediately. Meanwhile, in the other
    console, the following line should be printed:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command represents the request to get the `/a/b` resource from the server,
    but, as our API does not permit this method of specifying a resource, the service
    rejects the request.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Examining the code
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `main` function contains the following statements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first line creates an instance of an HTTP server. Here, the body of the
    closure is omitted.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The second line binds the server to an IP endpoint, which is a pair composed
    of an IP address and an IP port, and returns an error if such a binding fails.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将服务器绑定到一个IP端点，这是一个由IP地址和IP端口组成的对，如果绑定失败则返回错误。
- en: The third line puts the current thread in listening mode on that endpoint. It
    blocks the thread, waiting for incoming TCP connection requests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行将当前线程置于该端点的监听模式。它阻塞线程，等待传入的TCP连接请求。
- en: 'The argument of the `HttpServer::new` call is a closure, shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpServer::new`调用的参数是一个闭包，如下所示：'
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this closure, a new web app is created, and then one call to the `service` function
    is applied to it. Such a function contains a call to the `resource` function,
    which returns an object on which four calls to the `route` function are applied.
    Lastly, a call to the `default_service` function is applied to the application
    object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个闭包中，创建了一个新的Web应用，然后对其应用了一个对`service`函数的调用。这样一个函数包含了对`resource`函数的调用，该函数返回一个对象，对其应用了四个对`route`函数的调用。最后，对应用对象应用了`default_service`函数的调用。
- en: This complex statement implements a mechanism to decide which function to call
    based on the path and method of the HTTP request. In web programming parlance,
    such a kind of mechanism is named **routing**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复杂的语句实现了一个基于HTTP请求的路径和方法来决定调用哪个函数的机制。在Web编程术语中，这种机制被称为**路由**。
- en: The request routing first performs pattern matching between the address URI
    and one or several patterns. In this case, there is only one pattern, `/{filename}`,
    which describes a URI that has an initial slash and then a word. The word is associated
    with the `filename` name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请求路由首先在地址URI和一或多个模式之间执行模式匹配。在这种情况下，只有一个模式，`/{filename}`，它描述了一个具有初始斜杠然后是一个单词的URI。这个单词与`filename`名称相关联。
- en: The four calls to the `route` method proceed with the routing, based on the
    HTTP method (`DELETE`, `GET`, `PUT`, `POST`). There is a specific function for
    every possible HTTP method, followed by a call to the `to` function that has a
    handling function as an argument.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对`route`方法的四个调用基于HTTP方法（`DELETE`、`GET`、`PUT`、`POST`）进行路由。对于每个可能的HTTP方法都有一个特定的函数，然后调用一个`to`函数，该函数的参数是一个处理函数。
- en: 'Such calls to `route` mean that the following applies:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的`route`调用意味着以下内容：
- en: If the request method of the current HTTP command is `DELETE`, then such a request
    should be handled by going to the `delete_file` function.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前HTTP命令的请求方法是`DELETE`，则应该通过转到`delete_file`函数来处理这样的请求。
- en: If the request method of the current HTTP command is `GET`, then such a request
    should be handled by going to the `download_file` function.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前HTTP命令的请求方法是`GET`，则应该通过转到`download_file`函数来处理这样的请求。
- en: If the request method of the current HTTP command is `PUT`, then such a request
    should be handled by going to the `upload_specified_file` function.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前HTTP命令的请求方法是`PUT`，则应该通过转到`upload_specified_file`函数来处理这样的请求。
- en: If the request method of the current HTTP command is `POST`, then such a request
    should be handled by going to the `upload_new_file` function.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前HTTP命令的请求方法是`POST`，则应该通过转到`upload_new_file`函数来处理这样的请求。
- en: Such four handling functions, named **handlers**, must of course be implemented in
    the current scope. In actuality, they are defined, albeit interleaved with `TODO` comments,
    recalling what is missing to have a working application instead of a stub. Nevertheless,
    such handlers contain much functionality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个名为**处理程序**的处理函数当然必须在当前作用域中实现。实际上，它们被定义了，尽管与`TODO`注释交织在一起，回忆起要有一个工作应用程序而不是存根所缺少的内容。尽管如此，这些处理程序包含了很多功能。
- en: 'Such a routing mechanism can be read in English, in this way—for example, for
    a `DELETE` command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的路由机制可以用英语阅读，例如，对于一个`DELETE`命令：
- en: Create a `service` to manage the `web::resource` named `/{filename}`, to `route`
    a `delete` command to the `delete_file` handler.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`service`来管理名为`/{filename}`的`web::resource`，将`delete`命令路由到`delete_file`处理程序。
- en: After all of the patterns, there is the call to the `default_service` function that
    represents a catch-all pattern, typically to handle invalid URIs, such as `/a/b` in
    the previous example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有模式之后，是对`default_service`函数的调用，它代表一个捕获所有模式，通常用于处理无效URI，如前例中的`/a/b`。
- en: 'The argument of the catch-all statement—that is, `web::route().to(invalid_resource)`,
    causes the routing to the `invalid_resource` function. You can read it as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获所有语句的参数——即`web::route().to(invalid_resource)`——导致路由到`invalid_resource`函数。你可以这样读：
- en: For this `web` command, `route` it to the `invalid_resource` function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the handlers, starting with the simplest one, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function receives an `HttpRequest` object and returns something implementing
    the `Responder` trait. It means that it processes an HTTP request, and returns
    something that can be converted to an HTTP response.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: This function is quite simple because it does so little. It prints the URI to
    the console and returns a *Not Found* HTTP status code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'The other four handlers get a different argument, though. It is the following: `info:
    Path<(String,)>`. Such an argument contains a description of the path matched
    before, with the `filename` argument put into a single-value tuple, inside a `Path`
    object. This is because such handlers do not need the whole HTTP request, but
    they need the parsed argument of the path.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have one handler receiving an argument of the `HttpRequest` type,
    and the others receiving an argument of the `Path<(String,)>` type. This syntax
    is possible because the `to` function, called in the `main` function, expects
    as an argument a generic function, whose arguments can be of several different
    types.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'All four handlers begin with the following statement:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Such a statement extracts a reference to the first (and only) field of the tuple
    containing the parameters resulting from the pattern matching of the path. This
    works as long as the path contained exactly one parameter. The `/a/b` path cannot
    be matched with the pattern, because it has two parameters. Also, the `/` path
    cannot be matched, because it has no parameters. Such cases end in the *catch-all*
    pattern.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s examine the `delete_file` function specifically. It continues with
    the following lines:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It has two informational printing statements, and it ends returning a success
    value. In the middle, the actual statement to delete the file is still missing. The
    call to the `flush_stdout` function is needed to emit the text on the console
    immediately.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The `download_file` function is similar, but, as it has to send back the contents
    of the file, it has a more complex response, as illustrated in the following code
    snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The object returned by the call to `Ok()` is decorated, first by calling `content_type` and
    setting `text/plain` as the type of the returned body, and then by calling `body` and
    setting the contents of the file as the body of the response.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The `upload_specified_file` function is quite simple, as its two main jobs
    are missing: getting the text to put in the file from the body of the request,
    and saving that text into the file, as illustrated in the following code block:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `upload_new_file` function is similar, but it should have another step
    that is still missing: to generate a unique filename for the file to save, as
    illustrated in the following code block:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, we have examined all of the Rust code of the stub of the web service. In
    the next section, we'll look at the complete implementation of this service.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Building a complete web service
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `file_transfer` project completes the `file_transfer_stub` project, by filling
    in the missing features.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The features were omitted in the previous project for the following reasons:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: To have a very simple service that actually does not really access the filesystem
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have only synchronous processing
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ignore any kind of failure, and keep the code simple
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, these restrictions have been removed. First of all, let's see what happens
    if you compile and run the `file_transfer` project, and then test it using the
    same commands as in the previous section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Downloading a file
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s try the following steps on how to download a file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command into the console:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the download is successful, the server prints the following line to the
    console:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the console of the client, curl prints the contents of that file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of an error, the service prints the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have now seen how our web service can be used by curl to download a file.
    In the next sections, we'll learn how our web service can perform other operations
    on remote files.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a string to a specified file
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the command to upload a string into a remote file with a specified
    name:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the upload is successful, the server prints the following to the console:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the file already existed, it is overwritten. If it didn't exist, it is created.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of an error, the web service prints the following line:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, it prints the following line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is how our web service can be used by curl to upload a string into a remote
    file while specifying the name of the file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a string to a new file
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the command to upload a string into a remote file with a name chosen
    by the server:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the upload is successful, the server prints to the console something similar
    to the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This output shows that the name of the file contains a pseudo-random number—
    for this example, this is `917`, but you'll probably see some other number.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: In the console of the client, curl prints the name of that new file, as the
    server has sent it back to the client.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of an error, the server prints the following line:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, it prints the following line:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is how our web service can be used by curl to upload a string into a new
    remote file, leaving the task of inventing a new name for that file to the server.
    The curl tool receives this new name as a response.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a file
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the command to delete a remote file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the deletion is successful, the server prints the following line to the
    console:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Otherwise, it prints this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is how our web service can be used by curl to delete a remote file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Examining the code
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now examine the differences between this program and the one described
    in the previous section. The `Cargo.toml` file contains two new dependencies,
    as illustrated in the following code snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `futures` crate is needed for asynchronous operations, and the `rand` crate
    is needed for randomly generating the unique names of the uploaded files.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Many new data types have been imported from the external crates, as can be
    seen in the following code block:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The main function has just two changes, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, two calls to the `to` function have been replaced by calls to the `to_async`
    function. While the `to` function is *synchronous* (that is, it keeps the current
    thread busy until that function is completed), the `to_async` function is *asynchronous* (that
    is, it can be postponed until the expected events have happened).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: This change was required by the nature of upload requests. Such requests can
    send large files (several megabytes), and the TCP/IP protocol sends such files
    split into small packets. If the server, when it receives the first packet, just
    waits for the arrival of all the packets, it can waste a lot of time. Even with
    multithreading, if many users upload files concurrently, the system will dedicate
    as many threads as possible to handle such uploads, and this is rather inefficient.
    A more performant solution is asynchronous processing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The `to_async` function, though, cannot receive as an argument a synchronous
    handler. It must receive a function that returns a value having the `impl Future<Item
    = HttpResponse, Error = Error>` type, instead of the `impl Responder` type, returned
    by synchronous handlers. This is actually the type returned by the two upload
    handlers: `upload_specified_file` and `upload_new_file`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The object returned is of an abstract type, but it must implement the `Future` trait. The
    concept of a *future*, used also in C++ since 2011, is similar to JavaScript *promises*.
    It represents a value that will be available in the future, and in the meantime,
    the current thread can handle some other events.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Futures are implemented as asynchronous closures, meaning that these closures
    are put in a queue in an internal futures list, and not run immediately. When no
    other task is running in the current thread, the future at the top of the queue
    is removed from the queue and executed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: If two futures are chained, the failure of the first chain causes the second
    future to be destroyed. Otherwise, if the first future of the chain succeeds,
    the second future has the opportunity to run.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the two upload functions, another change for their signature is
    the fact that they now get two arguments. In addition to the argument of the `Path<(String,)>`
    type, containing the filename, there is an argument of the `Payload` type. Remember
    that the contents can arrive piece-wise, and so such a `Payload` argument does
    not contain the text of the file, but it is an object to get the contents of the
    uploaded file asynchronously.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Its use is somewhat complex.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'First, for both upload handlers, there is the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The call to `map_err` is required to convert the error type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The call to `fold` receives from the network one chunk of data at a time and
    uses it to extend an object of the `BytesMut` type. Such a type implements a kind
    of extensible buffer.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The call to `and_then` chains another future to the current one. It receives
    a closure that will be called when the processing of `fold` will be finished.
    Such a closure receives all the uploaded contents as an argument. This is a way
    to chain two futures—any closure invoked in this way is executed asynchronously,
    after the previous one is finished.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the closure simply write the received contents into a file with
    the specified name. This operation is synchronous.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the closure is `ok(HttpResponse::Ok().finish())`. This is the
    way to return from a future. Notice the lowercase `ok`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The `upload_new_file` function is similar to the previous one, in terms of
    the web programming concepts. It is more complex, just because of the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having a complete filename, only a prefix is provided, and the rest
    must be generated as a pseudo-random number.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting filename must be sent to the client.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The algorithm to generate a unique filename is the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: A three-digit pseudo-random number is generated, and it is concatenated to the
    prefix.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name obtained is used to create a file; this avoids overwriting an existing
    file with that name.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a collision happens, another number is generated until a new file is created,
    or until 100 failed attempts have been tried.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, this assumes that the number of uploaded files will always be significantly
    less than 1,000.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Other changes have been made to consider the chance of failure.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of the `delete_file` function now looks like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code handles the case of a failure in the deletion of the file. Notice
    that in the case of an error, instead of returning the success status code `HttpResponse::Ok()` representing
    the number `200`, a `HttpResponse::NotFound()` failure code is returned, representing
    the number `404`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The `download_file` function now contains a local function to read the whole
    contents of a file into a string, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The function ends with some code to handle the possible failure of the function,
    as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Building a stateful server
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web app of the `file_transfer_stub` project was completely stateless, meaning
    that every operation had the same behavior independently of the previous operations.
    Other ways to explain this are that no data was kept from one command to the next,
    or that it computed pure functions only.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The web app of the `file_transfer` project had a state, but that state was confined
    to the filesystem. Such a state was the content of the data files. Nevertheless,
    the application itself was still stateless. No variable survived from one request
    handling to another request handling.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The REST principles are usually interpreted as prescribing that any API *must
    be stateless*. That is a misnomer because REST services *can* have a state, but
    they *must behave as if they were stateless*. To be stateless means that, except
    for the filesystem and the database, no information survives in the server from
    one request handling to another request handling. To behave as if stateless means
    that any sequence of requests should obtain the same results even if the server
    is terminated and restarted between one request and a successive one.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, if the server is terminated, its state is lost. So, to behave as stateless
    means that the behavior should be the same even if the state is reset. So, what
    is the purpose of the possible server state? It is to store information that can
    be obtained again with any request, but that would be costly to do so. This is
    the concept of caching.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Usually, any REST web server has an internal state. The typical information
    stored in this state is a pool of connections to the database. A pool is initially
    empty, and when the first handler must connect to the database, it searches the
    pool for an available connection. If it finds one, it uses it. Otherwise, a new
    connection is created and added to the pool. A pool is a shared state that must
    be passed to any request handler.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In the projects of the previous sections, the request handlers were pure functions;
    they had no possibility of sharing a common state. In the `memory_db` project,
    we'll see how we can have a shared state in the Actix web framework that is passed
    to any request handler.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: This web app represents access to a very simple database. Instead of performing
    actual access to a database, which would require further installations in your
    computer, it simply invokes some functions exported by the `data_access` module,
    defined in the `src/data_access.rs` file, that keep the database in memory.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: A memory database is a state that is shared by all the request handlers. In
    a more realistic app, a state would contain only one or more connections to an
    external database.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: How to have a stateful server
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To have a state in an Actix service, a struct must be declared, and any data
    that should be part of the state should be a field of that struct.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of the `main.rs` file, there is the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the state of our web app, we need only one field, but other fields can be
    added.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DbConnection` type declared in the `db_access` module represents the state
    of our web app. In the `main` function, just before creating the server, there
    is the following statement that instantiates the `AppState`, and then properly
    encapsulates it:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The state is shared by all the requests, and the Actix web framework uses several
    threads to handle the requests, and so the state must be thread-safe. The typical
    way of declaring a thread-safe object in Rust is to encapsulate it in a `Mutex` object.
    This object is then encapsulated in a `Data` object.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that such a state is passed to any handler, the following line must
    be added before calling the `service` functions:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, the `db_conn` object is cloned (cheaply, as it is a smart pointer), and
    it is registered into the app.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'The effect of this registration is that it is now possible to add another type
    of argument to the request handlers (both synchronous and asynchronous), as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Such an argument can be used in statements like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, the state is locked to prevent concurrent access by other requests, and
    its `db` field is accessed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The API of this service
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rest of the code in this app is not particularly surprising. The API is
    clear from the names used in the `main` function, as illustrated in the following
    code block:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that the first three patterns use the `GET` method, and so they *query*
    the database. The last one uses the `POST` method, and so it inserts new records
    into the database.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Notice also the following lexical conventions.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The path of the URI for the first and third patterns begins with the plural
    word `persons`, which means that zero, one, or several items will be managed by
    this request and that any such item represents a person. Instead, the path of
    the URI for the second and fourth patterns begins with the singular word `person`,
    and this means that no more than one item will be managed by this request.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The first pattern ends with the plural word `ids`, and so several items regarding
    the `id` will be handled. It has no condition, and so all the IDs are requested. The
    second pattern contains the word `name_by_id`, followed by an `id` parameter,
    and so it is a request of the `name` database column for all the records for which
    the `id` column has the value specified.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Even in the case of any doubt, the name of the handling functions or comments
    should make the behavior of the service clear, without having to read the code
    of the handlers. When looking at the implementation of the handlers, notice that
    they either return nothing at all or simple text.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Testing the service
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's test the service with some curl operations.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we should populate the database that is initially empty. Remember
    that, being only in memory, it is empty any time you start the service.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'After starting the program, type the following commands:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After the first command, a number `1` should be printed to the console. After
    the second command, `2` should be printed, and after the third command, `3` should
    be printed. They are the IDs of the inserted names of people.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, type the following command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It should print the following: `1, 2, 3`. This is the set of all the IDs in
    the database.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, type the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It should print the following: `Mary Jane`. This is the name of the unique
    person for which the `id` is equal to `3`. Notice that the input sequence `%20`
    has been decoded into a blank.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, type the following command:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It should print the following: `2: Jonathan; 3: Mary Jane`. This is the set
    of all the people for which the `name` column contains the `an` substring.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the database
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The whole database implementation is kept in the `db_access.rs` source file.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the database is quite simple. It is a `DbConnection` type,
    containing `Vec<Person>`, where `Person` is a struct of two fields—`id` and `name`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods of `DbConnection` are described as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '`new`: This creates a new database.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_all_persons_ids(&self) -> impl Iterator<Item = u32> + ''_`: This returns
    an iterator that provides all the IDs contained in the database. The lifetime
    of such an iterator must be no more than that of the database itself.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_person_name_by_id(&self, id: u32) -> Option<String>`: This returns the
    name of the unique person having the specified ID if there is one, or zero if
    there isn''t one.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_persons_id_and_name_by_partial_name<''a>(&''a self, subname: &''a str)
    -> impl Iterator<Item = (u32, String)> + ''a`: This returns an iterator that provides
    the ID and the name of all the people whose name contains the specified string. The
    lifetime of such an iterator must be no more than that of the database itself,
    and also no more than that of the specified string.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert_person(&mut self, name: &str) -> u32`: This adds a record to the database,
    containing a generated ID and the specified `name`. This returns the generated
    ID.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling queries
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The request handlers, contained in the `main.rs` file, get arguments of several
    types, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '`web::Data<Mutex<AppState>>`: As described previously, this is used to access
    the shared app state.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path<(String,)>`: As described in the previous sections, this is used to access
    the path of the request.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpRequest`: As described in the previous sections, this is used to access
    general request information.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But also, the request handlers get the `web::Query<Filter>` argument to access
    the optional arguments of the request.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_persons` handler has a query argument—it is a generic argument, whose
    parameter is the `Filter` type. Such a type is defined as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This definition allows requests such as `http://localhost:8080/persons?partial_name=an`.
    In this request, the path is just `/persons`, while `?partial_name=an` is the
    so-called query. In this case, it contains just one argument whose key is `partial_name`,
    and whose value is `an`. It is a string and it is optional. This is exactly what
    is described by the `Filter` struct.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: In addition, such a type is deserializable, as such an object must be read by
    the request through serialization.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_persons` function accesses the query through the following expression:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `partial_name` field is cloned to get a string. If it is nonexistent, it
    is taken as an empty string.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Returning JSON data
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section returned data in plain text. This is unusual in a web service
    and rarely satisfactory. Usually, web services return data in JSON, XML, or another
    structured format. The `json_db` project is identical to the `memory_db` project,
    except for its returning data in the JSON format.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s see what happens when the same curl commands from the
    previous section are executed on it, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The insertions have the same behavior because they just printed a number.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first query should print the following: `[1,2,3]`. The three numbers are
    in an array, and so they are enclosed in brackets.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second query should print the following: `"Mary Jane"`. The name is a string,
    and so it is enclosed in quotation marks.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third query should print the following: `[[2,"Jonathan"],[3,"Mary Jane"]]`. The
    sequence of persons is an array of two records, and each of them is an array of
    two values, which are a number and a string.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's see the differences in the code of this project with respect to the
    previous one.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Cargo.toml` file, one dependency has been added, as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is needed to serialize the data in JSON format.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.rs` file, the `get_all_persons_ids` function (instead of returning
    simply a string) has the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: First, a response with a status code `Ok` is created; then, its content type
    is set to `application/json`, to let the client know how to interpret the data
    it will receive; and lastly, its body is set, using the `json` macro taken from
    the `serde_json` crate. This macro takes an expression—in this case, with type, `Vec<Person>`—and
    returns a `serde_json::Value` value. Now, we need a string, and so `to_string()`
    is called. Notice that the `json!` macro requires its argument to implement the
    `Serialize` trait or to be convertible into a string.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The `get_person_name_by_id`, `get_persons`, and `insert_person` functions have
    similar changes. The `main` function has no changes. The `db_access.rs` files
    are identical.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned about a few features of the Actix web framework. It is a really
    complex framework that covers most needs of the backend web developer, and it
    is still in active development.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Particularly, in the `file_transfer_stub` project, we learned how to create
    an API of a RESTful service. In the `file_transfer` project, we discussed how
    to implement the operations of our web service. In the `memory_db` project, we
    went through how to manage an inner state, in particular, one containing a database
    connection. In the `json_db` project, we have seen how to send a response in JSON
    format.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be learning how to create a full server-side web
    application.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the REST principles, what are the meanings of the `GET`, `PUT`,
    `POST`, and `DELETE` HTTP methods?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command-line tool can be used to test a web service?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a request handler retrieve the value of URI parameters?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can the content type of an HTTP response be specified?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a unique file name be generated?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do services that have a stateless API need to manage a state?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why must the state of a service be encapsulated in a `Data` and a `Mutex` object?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why may asynchronous processing be useful in a web service?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `and_then` function of futures?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which crates are useful to compose an HTTP response in JSON format?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about the Actix framework, view the official documentation at [https://actix.rs/docs/](https://actix.rs/docs/),
    and view official examples at [https://github.com/actix/examples/](https://github.com/actix/examples/).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
