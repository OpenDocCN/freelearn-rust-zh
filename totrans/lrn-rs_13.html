<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Standard Library</h1>
                
            
            <article>
                
<p class="calibre1">As with all programming languages, Rust comes with a rich library to make the life of the developer that much simpler by providing frequently-used functionality without having to recode the same thing time and again. We have already encountered part of the standard library in this book, and I have no doubt that you will have seen any number of instances of it in other code examples.</p>
<p class="calibre1">Over the next two chapters, we will be looking at what the library provides and how to use it.</p>
<p class="calibre1">In this chapter, we will be dealing with the standard crate (<kbd class="calibre10">std::</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Chapter format</h1>
                
            
            <article>
                
<p class="calibre1">Unlike the other chapters in this book, due to the sheer size of the library this chapter will be slightly different. It will look like this:</p>
<p class="calibre1"><em class="calibre9">Trait name</em></p>
<p class="calibre1"><em class="calibre9">What it does / provides</em></p>
<p class="calibre1"><em class="calibre9">Notes</em></p>
<p class="calibre1"><em class="calibre9">Traits / Structs and Enums provided</em></p>
<p class="calibre1"><em class="calibre9">Download example</em></p>
<p class="calibre1">Due to Rust also having two main variants (stable and unstable), I won't be covering anything that is currently classed as unstable within the library; there is no guarantee that it will remain in the library or will remain the same.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is the standard library?</h1>
                
            
            <article>
                
<p class="calibre1">The standard library contains the core functionality for Rust. It is split into four parts:</p>
<ul class="calibre12">
<li class="calibre13">The standard modules</li>
<li class="calibre13">Primitive types</li>
<li class="calibre13">Macros</li>
<li class="calibre13">Prelude</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The standard modules (overview)</h1>
                
            
            <article>
                
<p class="calibre1">The standard modules implement the likes of string handling, IO, network, and operating system calls. There are around 60 of these modules in total. Some are self-contained while others provide implementations for traits and structs.</p>
<p class="calibre1">The module names may give rise to some confusion as they share the same name with a primitive type (such as <kbd class="calibre10">i32</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Primitive types (overview)</h1>
                
            
            <article>
                
<p class="calibre1">Primitive types are those types that are provided for us. In other languages, they would be the likes of <kbd class="calibre10">int</kbd>, <kbd class="calibre10">float</kbd>, and <kbd class="calibre10">char</kbd>. In Rust, we have <kbd class="calibre10">i32</kbd>, <kbd class="calibre10">d32</kbd>, and <kbd class="calibre10">i8</kbd> (respectively). Rust provides the developer with 19 primitives, some of which will provide additional implementations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Macros (overview)</h1>
                
            
            <article>
                
<p class="calibre1">Macros play a significant role in Rust application development; they have been designed to provide a number of very convenient shortcuts to avoid the pain of having to implement common functionality (such as <kbd class="calibre10">println!(...)</kbd> and <kbd class="calibre10">format!(...)</kbd>). Rust provides 30 macros.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Prelude</h1>
                
            
            <article>
                
<p class="calibre1">Prelude is very useful. You may have wondered why many of the examples in this book use standard modules, but you rarely see <kbd class="calibre10">use std::</kbd> at the top of source files. The reason is that Rust auto-injects the prelude module into every source file, which provides the source file with a number of core modules. It inserts the following in no particular order:</p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">std::marker::{Copy, Send, Sized, Sync}</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::ops::{Drop, Fn, FnMut, FnOnce}</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::mem::drop</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::boxed::Box</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::borrow::ToOwned</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::clone::Clone</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::cmp::{PartialEq, PartialOrd, Eq, Ord }</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::convert::{AsRef, AsMut, Into, From}</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::default::Default</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::iter::{Iterator, Extend, IntoIterator, DoubleEndedIterator, ExactSizeIterator}</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::option::Option::{self, Some, None}</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::result::Result::{self, Ok, Err}</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::slice::SliceConcatExt</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::string::{String, ToString}</kbd></li>
<li class="calibre13"><kbd class="calibre10">std::vec::Vec</kbd></li>
</ul>
<p class="calibre1">It inserts into each crate <kbd class="calibre10">extern crate std;</kbd> and into each module <kbd class="calibre10">use std::prelude::v1::*;</kbd>. This is all that is needed for prelude - it is that simple! Each module, though, will be dealt with in turn.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The standard modules</h1>
                
            
            <article>
                
<p class="calibre1">With the overviews done, let's look at the standard modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::Any</h1>
                
            
            <article>
                
<p class="calibre1">This module enables the dynamic casting of <kbd class="calibre10">'static</kbd> via runtime reflection.</p>
<div class="packt_infobox">It can be used to obtain a <kbd class="calibre22">TypeId</kbd>. When used as a borrowed trait reference (<kbd class="calibre22">&amp;Any</kbd>), it can be used to determine whether the value is a given type (using <kbd class="calibre22">Is</kbd>) and also to get a reference to the inner value as a type (using <kbd class="calibre22">downcast_ref</kbd>). <kbd class="calibre22">&amp;mut Any</kbd> will allow access to <kbd class="calibre22">downcast_mut</kbd>, which obtains the mutable reference to the inner value. <kbd class="calibre22">&amp;Any</kbd> can only be used for testing a specific type and cannot be used to test whether a type implements a trait.</div>
<p class="calibre1"><strong class="calibre8">Structs</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">TypeId</kbd>: <kbd class="calibre10">TypeId</kbd> is an opaque object that cannot be examined, but does allow for clone, compare, print, and show. Only available for types that use <kbd class="calibre10">'static</kbd>.</li>
</ul>
<p class="calibre1"><strong class="calibre8">Implement</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">of&lt;T&gt;() -&gt; TypeId where T:’static + Reflect + ?Sized</kbd>: <span>This returns the <kbd class="calibre10">TypeId</kbd> of the type <kbd class="calibre10">T</kbd> the function was instantiated with.</span></li>
</ul>
<p class="calibre1"><strong class="calibre8">Traits</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">pub trait Any: 'static + Reflect {fn get_type_id(&amp;self) -&gt; TypeId;}</kbd>: <span>Emulates dynamic typing.</span></li>
</ul>
<p class="calibre37"><strong class="calibre8">Trait methods</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">impl Any + 'static</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">is&lt;T&gt;(&amp;self) -&gt; bool where T:Any</kbd>: Returns <kbd class="calibre10">true</kbd> if the boxed type is the same as <kbd class="calibre10">T</kbd></li>
<li class="calibre13"><kbd class="calibre10">downcast_ref&lt;T&gt;(&amp;self) -&gt; Option&lt;&amp;T&gt; where T:Any</kbd>: Returns <kbd class="calibre10">ref</kbd> to the boxed value whether it is of type <kbd class="calibre10">T</kbd> or <kbd class="calibre10">None</kbd></li>
<li class="calibre13"><kbd class="calibre10">downcast_mut&lt;T&gt;(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; where T:Any</kbd>: As for <kbd class="calibre10">downcast_ref</kbd> but returns a mutable <kbd class="calibre10">ref</kbd> or <kbd class="calibre10">None</kbd></li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl Any + 'static + Send</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">is&lt;T&gt;(&amp;self) -&gt; bool where T:Any</kbd>: Sends to the method defined on the type <kbd class="calibre10">Any</kbd></li>
<li class="calibre13"><kbd class="calibre10">downcast_ref&lt;T&gt;(&amp;self) -&gt; Option&lt;&amp;T&gt; where T:Any</kbd>: Sends to the method defined on the type <kbd class="calibre10">Any</kbd></li>
<li class="calibre13"><kbd class="calibre10">downcast_mut&lt;T&gt;(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; where T:Any</kbd>: Sends to the method defined on the type <kbd class="calibre10">Any</kbd></li>
</ul>
</li>
</ul>
<p class="calibre1"><strong class="calibre8">Trait implementations</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">impl Debug for Any + ‘static</kbd> 
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Format the value using the formatter</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl Debug for Any + ‘static + Send</kbd> 
<ul class="calibre31">
<li class="calibre13">
<p class="calibre38"><kbd class="calibre10">fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Sends to the method defined on the <kbd class="calibre10">Debug</kbd> method</p>
</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::ascii</h1>
                
            
            <article>
                
<p class="calibre1">This module performs operations on ASCII strings.</p>
<div class="packt_infobox"><span class="chapterrefpackt">The </span><kbd class="calibre22">AsciiExt</kbd><span class="chapterrefpackt"> trait contains a number of useful string slice utilities for testing, as well as conversion to upper and lowercase.</span></div>
<p class="calibre37"><strong class="calibre8">Structs</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">pub struct EscapeDefault</kbd>: Iterates over the escaped version of a byte</li>
<li class="calibre13"><kbd class="calibre10">impl</kbd> iterator for <kbd class="calibre10">EscapeDefault</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">type Item = u8</kbd>: Type of the elements iterated over</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl</kbd> iterator for <kbd class="calibre10">EscapeDefault</kbd> functions
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">next(&amp;mut self) -&gt; Option&lt;u8&gt;</kbd>: Advances the iterator and return the next value</li>
<li class="calibre13"><kbd class="calibre10">size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;)</kbd>: Returns the bounds on the remaining length of the iterator</li>
<li class="calibre13"><kbd class="calibre10">count(self) -&gt; usize</kbd>: Returns the number of iterations</li>
<li class="calibre13"><kbd class="calibre10">last(self) -&gt; Option&lt;Self::Item&gt;</kbd>: Returns the last element</li>
<li class="calibre13"><kbd class="calibre10">nth(&amp;mut self, n:usize) -&gt; Option&lt;Self::Item&gt;</kbd>: Returns the next element after the n<sup class="calibre27">th</sup> position</li>
<li class="calibre13"><kbd class="calibre10">chain&lt;U&gt;(self, other:U) -&gt; Chain&lt;Self, U::IntoIterator&gt; where U: IntoIterator&lt;Item=Self::Item&gt;</kbd>: Takes two iterators and creates a new one over both in sequence</li>
<li class="calibre13"><kbd class="calibre10">zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, U:IntoIterator&gt; where U:IntoIterator</kbd>: Takes two iterators and makes them into a single pair iterator</li>
<li class="calibre13"><kbd class="calibre10">map&lt;T,U&gt;(self, u: U) -&gt; Map&lt;Self, U&gt; where U:FnMut(Self::Item) -&gt; T</kbd>: Creates an iterator from a closure that calls that closure on each element</li>
<li class="calibre13"><kbd class="calibre10">filter&lt;F&gt;(self, predicate: F) -&gt; Filter&lt;Self, F&gt; where F: FnMut(&amp;Self::Item) -&gt; bool</kbd>: Creates an iterator that uses a closure to determine whether an element should be returned</li>
<li class="calibre13"><kbd class="calibre10">enumerate(self) -&gt; Enumerate&lt;Self&gt;</kbd>: Gives the current iteration count and the next value</li>
<li class="calibre13"><kbd class="calibre10">peekable(self) -&gt; Peekable&lt;Self&gt;</kbd>: Peeks at the next value without the iterator consuming it</li>
<li class="calibre13"><kbd class="calibre10">skip_while&lt;P&gt;(self, predicate:P) -&gt; SkipWhile&lt;Self, P&gt; where P:FnMut(&amp;Self::Item) -&gt; bool</kbd>: Creates an iterator that skips <em class="calibre9">n</em> elements based on the predicate.</li>
<li class="calibre13"><kbd class="calibre10">take_while&lt;P&gt;(self, predicate:P) -&gt; TakeWhile&lt;Self, P&gt; where P:FnMut(&amp;Self::Item) -&gt; bool</kbd>: Creates an iterator that yields elements based on the predicate.</li>
<li class="calibre13"><kbd class="calibre10">skip(self, n: usize) -&gt; Skip&lt;Self&gt;</kbd>: Skips the first <em class="calibre9">n</em> elements</li>
<li class="calibre13"><kbd class="calibre10">take(self, n: usize) -&gt; Take&lt;Self&gt;</kbd>: The iterator that yields the first <em class="calibre9">n</em> elements</li>
<li class="calibre13"><kbd class="calibre10">scan&lt;S, T, U&gt;(self, interal_state: S, u: U) -&gt; Scan&lt;Self, S, U&gt; where U:FnMut(&amp;mut S, Self::Item)-&gt; Option&lt;T&gt;</kbd>: The iterator adapter that holds an internal state and produces a new iterator</li>
<li class="calibre13"><kbd class="calibre10">flat_map&lt;T, U&gt;(self, u:U) -&gt; Flat_Map&lt;Self, T, U&gt; where U:FnMut(Self::Item) -&gt; T, T:IntoIterator</kbd>: Creates an iterator that works like a map, but produces a flattened, nested structure</li>
<li class="calibre13"><kbd class="calibre10">fuse(self)-&gt;Fuse(Self)</kbd>: Iterator that terminates after the first instance of <kbd class="calibre10">None</kbd></li>
<li class="calibre13"><kbd class="calibre10">inspect&lt;T&gt;(self, t: T)-&gt;Insepect&lt;Self, T&gt; where T: FnMut(&amp;self::Item)-&gt;()</kbd>: Does something with each iterated element and passes the value on.</li>
<li class="calibre13"><kbd class="calibre10">by_ref(&amp;mut self) -&gt; &amp;mut Self</kbd>: Borrows rather than consumes the iterator</li>
<li class="calibre13"><kbd class="calibre10">collect&lt;T&gt;(self) -&gt; T where T:FromIterator(Self::Item)</kbd>: Makes a collection from an iterator</li>
<li class="calibre13"><kbd class="calibre10">partition&lt;T, U&gt;(self, u:U) -&gt; (T,T) where T:Default + Extend&lt;Self::Item&gt;, U:FnMut(&amp;Self::Item&gt; -&gt; bool</kbd>: Takes the iterator and creates two collections from it</li>
<li class="calibre13"><kbd class="calibre10">fold&lt;T, U&gt;(self, init:T, u:U)-&gt;T where U:FnMut(T, Self::Item) -&gt; T</kbd>: The iterator adapter that applies a function to produce a single final result</li>
<li class="calibre13"><kbd class="calibre10">all&lt;T&gt;(&amp;mut self, t:T) -&gt; bool where T:FnMut(Self::Item) -&gt; bool</kbd>: Tests whether all elements of the iterator match the predicate <kbd class="calibre10">T</kbd></li>
<li class="calibre13"><kbd class="calibre10">any&lt;T&gt;(&amp;mut self, t:T) -&gt; bool where T:FnMut(Self::Item) -&gt; bool</kbd>: Tests whether any elements of the iterator match the predicate <kbd class="calibre10">T</kbd></li>
<li class="calibre13"><kbd class="calibre10">find&lt;T&gt;(&amp;mut self, predicate:T) -&gt; Option&lt;Self::Item&gt; where T: FnMut(&amp;Self::Item) -&gt; bool</kbd>: Searches the iterator for a match to the predicate</li>
<li class="calibre13"><kbd class="calibre10">position&lt;T&gt;(&amp;mut self, predicate:T) -&gt; Option&lt;usize&gt; where T:FnMut(Self::Item) -&gt; bool</kbd>: Searches the iterator for a match to the predicate and return the index</li>
<li class="calibre13"><kbd class="calibre10">rposition&lt;T&gt;(&amp;mut self, predicate:T) -&gt; Option&lt;usize&gt; where T:FnMut(Self::Item) -&gt; bool, Self:ExtractSizeIterator + doubleEndedIterator</kbd>: As for position, except it searches from the right</li>
<li class="calibre13"><kbd class="calibre10">max(self_ =&gt; Option&lt;Self::Item&gt;</kbd>: Returns the max element of the iterator</li>
<li class="calibre13"><kbd class="calibre10">min(self_ =&gt; Option&lt;Self::Item&gt;</kbd>: Returns the min element of the iterator</li>
<li class="calibre13"><kbd class="calibre10">rev(self) -&gt; Rev&lt;Self&gt; where Self:DoubleEndedIterator</kbd>: Reverses the direction of the iterator</li>
<li class="calibre13"><kbd class="calibre10">unzip&lt;T, U, FromT, FromU&gt;(self) -&gt; (FromT, FromU) -&gt; Where FromT: Default + Extend&lt;T&gt;, FromU: Default + Extend&lt;U&gt;, Self::Iterator&lt;Item=(T,U)&gt;</kbd>: Performs the reverse of ZIP (two collections from a single iterator)</li>
<li class="calibre13"><kbd class="calibre10">cloned&lt;'a, Y&gt;(self) -&gt; Cloned&lt;Self&gt; where Self:Iterator&lt;Item = &amp;'a T&gt;, T: 'a + Clone</kbd>: Creates an iterator that clones all of its elements</li>
<li class="calibre13"><kbd class="calibre10">cycle(self) -&gt; Cycle&lt;Self&gt; where Self:Clone</kbd>: Repeats the iterator endlessly</li>
<li class="calibre13"><kbd class="calibre10">sum&lt;T&gt;(self) -&gt; T where Y:Add&lt;Self::Item, Output=T&gt; + Zero</kbd>: Returns the sum of the iterator elements</li>
<li class="calibre13"><kbd class="calibre10">Product&lt;T&gt;(self) -&gt; T where T: Mul&lt;Self::Item, Output = T&gt; + One</kbd>: Multiplies the elements of the iterator and returns the value</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl DoubleEndedIterator for EscapeDefault</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">next_back(&amp;mut self) -&gt; Option&lt;u8&gt;</kbd>: Iterator able to yield a result from both ends</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl ExactSizeIterator for EscapeDefault</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">Len(&amp;self) -&gt; usize</kbd>: Returns the number of times the iterator will iterate.</li>
</ul>
</li>
</ul>
<p class="calibre1"><strong class="calibre8">Traits</strong></p>
<pre class="calibre21">pub trait AsciiExt {<br class="calibre2"/>  type Owned;<br class="calibre2"/>  fn is_ascii(&amp;self) -&gt; bool ;<br class="calibre2"/>  fn to_ascii_uppercase(&amp;self) -&gt; Self:: Owned ;<br class="calibre2"/>  fn to_ascii_lowercase(&amp;self) -&gt; Self:: Owned ;<br class="calibre2"/>  fn eq_ignore_ascii_case(&amp;self, other: &amp;Self) -&gt; bool ;<br class="calibre2"/>  fn make_ascii_uppercase(&amp;mut self);<br class="calibre2"/>  fn make_ascii_lowercase(&amp;mut self);<br class="calibre2"/>}</pre>
<p class="calibre1">The following are extension methods for ASCII subset operations on string slices:</p>
<ul class="calibre12">
<li class="calibre13">Associated type
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">Owned:</kbd> Container for copied ASCII characters.</li>
</ul>
</li>
<li class="calibre13">Required methods
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">is_ascii(&amp;self) -&gt; bool</kbd>: Whether value is an ASCII value</li>
<li class="calibre13"><kbd class="calibre10">to_ascii_uppercase(&amp;self) -&gt; Self::Owned</kbd>: Makes a copy of the string in ASCII uppercase</li>
<li class="calibre13"><kbd class="calibre10">to_ascii_lowercase(&amp;self) -&gt; Self::Owned</kbd>: As for uppercase, but in lowercase</li>
<li class="calibre13"><kbd class="calibre10">eq_ignore_ascii_case(&amp;self, other: &amp;Self) -&gt; bool</kbd>: Are two strings the same ignoring the case</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::borrow</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for working with borrowed data.</p>
<p class="calibre1">enum <kbd class="calibre10">Cow</kbd> (clone-on-write smarter pointer)</p>
<p class="calibre1">The <kbd class="calibre10">Cow</kbd> allows for immutable access to borrowed data (and can enclose this data) and permits cloning lazily when mutation or ownership is required. It is designed to work using the <kbd class="calibre10">Borrow</kbd> trait. It also implements <kbd class="calibre10">Deref</kbd>, which will allow access to non-mutating methods on the data <kbd class="calibre10">Cow</kbd> has enclosed. <kbd class="calibre10">to_mut</kbd> will provide a mutable reference to the owned value.</p>
<p class="calibre1"> </p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">Trait std::borrow::Borrow</kbd>: Data can be borrowed in a number of different ways: shared borrowing (<kbd class="calibre10">T</kbd> and <kbd class="calibre10">&amp;T</kbd>), mutable borrowing (<kbd class="calibre10">&amp;mut T</kbd>), and borrowed slices from the likes of <kbd class="calibre10">Vec&lt;T&gt; (&amp;[T]</kbd>, and <kbd class="calibre10">&amp;mut[T])</kbd>.<br class="calibre2"/>
The <kbd class="calibre10">Borrow</kbd> trait provides a convenient method to abstract over the given type. For example: <kbd class="calibre10">T: Borrow&lt;U&gt;</kbd> means that <kbd class="calibre10">&amp;U</kbd> is borrowed from <kbd class="calibre10">&amp;T</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn borrow(&amp;self) -&gt; &amp;Borrowed</kbd>: Immutably borrows from an owned value</li>
</ul>
</li>
<li class="calibre13">
<p class="calibre39"><kbd class="calibre40">Trait std::borrow::BorrowMut</kbd>: Used for mutably borrowing data</p>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn borrow_mut(&amp;mut self) -&gt; &amp;mut Borrowed</kbd>: Mutably borrows from an owned value</li>
</ul>
</li>
<li class="calibre13">
<p class="calibre38"><kbd class="calibre10">Trait std::borrow:ToOwned</kbd>: A generalization of <kbd class="calibre10">Clone</kbd> for borrowing data. <kbd class="calibre10">Clone</kbd> only works when going from <kbd class="calibre10">&amp;T</kbd> to <kbd class="calibre10">T</kbd>. <kbd class="calibre10">ToOwned</kbd> generalizes <kbd class="calibre10">Clone</kbd> to construct owned data from any borrow of a given type.</p>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn to_owned(&amp;self) -&gt; Self::Owned</kbd>: Creates owned data from borrowed data</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::boxed</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for heap allocation.</p>
<div class="packt_infobox">A very simple way to allocate memory on the heap, provide ownership, and drop when out of scope.</div>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Box&lt;T&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn new(x:T) -&gt; Box&lt;T&gt;</kbd>: Allocates memory on the heap and places <kbd class="calibre10">x</kbd> into it</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl &lt;T&gt; Box&lt;T&gt; where T: ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">unsafe fn from_raw(raw: *mut T) -&gt; Box&lt;T&gt;</kbd>: Constructs a box from a raw pointer. After creation, the pointer is owned by the new <kbd class="calibre10">Box</kbd>. It is unsafe for this very reason; the <kbd class="calibre10">Box</kbd> destructor will call the destructor of <kbd class="calibre10">T</kbd> and free the allocated memory. This may lead to double freeing that will cause a crash.</li>
<li class="calibre13"><kbd class="calibre10">fn into_raw(b: Box&lt;T&gt; -&gt; *mut T</kbd>: Consumes the box and returns the wrapped raw pointer.</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl Box&lt;Any + 'static&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn downcast&lt;T&gt;(self) -&gt; Result&lt;Box&lt;T&gt;, Box&lt;Any + 'static&gt;&gt; where T:Any</kbd>: Attempts to downcast the box to a concrete type.</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl Box&lt;Any + 'static + Send&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn downcast&lt;T&gt;(self) -&gt; Result&lt;Box&lt;T&gt;, Box&lt;Any + ‘static + Send&gt;&gt; where T:Any</kbd>: Attempts to downcast the box to a concrete type</li>
</ul>
</li>
</ul>
<p class="calibre41">Methods</p>
<p class="calibre41">Trait Implementations</p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">Impl &lt;T&gt; Default for Box&lt;T&gt; where T:Default</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn default() -&gt; Box&lt;T&gt;</kbd>: Returns the default value for the type</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Default for Box&lt;[T]&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn default() -&gt; Box&lt;T&gt;</kbd>: Returns the default value for the type</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Clone for Box&lt;T&gt; where T:Clone</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn clone(&amp;self) -&gt; Box&lt;T&gt;</kbd>: Returns a new box with a clone of the box's contents</li>
<li class="calibre13"><kbd class="calibre10">fn clone_from(&amp;mut self, source: &amp;Box&lt;T&gt;)</kbd>: Copies <em class="calibre9">sources</em> contents into self without creating a new allocation</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl Clone for Box&lt;str&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn clone(&amp;self) -&gt; Box&lt;str&gt;</kbd>: Returns a copy of the value</li>
<li class="calibre13"><kbd class="calibre10">fn clone_from(&amp;mut self, source: &amp;Self)</kbd>: Performs a copy-assignment from <em class="calibre9">source</em></li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; PartialEq&lt;Box&lt;T&gt;&gt; for Box&lt;T&gt; where T:PartialEq&lt;T&gt; + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn eq(&amp;self, other: &amp;Box&lt;T&gt;) -&gt; bool</kbd>: Test self and other to be equal. Used by <kbd class="calibre10">==</kbd></li>
<li class="calibre13"><kbd class="calibre10">fn ne(&amp;self, other: &amp;Box&lt;T&gt;) -&gt;</kbd>: Tests for inequality. Used by <kbd class="calibre10">!=</kbd></li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; PartialOrd&lt;Box&lt;T&gt;&gt; for Box&lt;T&gt; where T:PartialOrd&lt;T&gt; + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn partial_cmp(&amp;self, other: &amp;Box&lt;T&gt;) -&gt; Option&lt;Ordering&gt;</kbd>: Returns an ordering between self and other values if it exists</li>
<li class="calibre13"><kbd class="calibre10">fn lt(&amp;self, other: &amp;Box&lt;T&gt;) -&gt; bool</kbd>: Tests whether self is less than other. Used by <kbd class="calibre10">&lt;</kbd></li>
<li class="calibre13"><kbd class="calibre10">fn le(&amp;self, other: &amp;Box&lt;T&gt;) -&gt; bool</kbd>: Tests whether self is less than or equal to other. Used by <kbd class="calibre10">&lt;=</kbd></li>
<li class="calibre13"><kbd class="calibre10">fn ge(&amp;self, other: &amp;Box&lt;T&gt;) -&gt; bool</kbd>: Tests whether self is greater than or equal to other. Used by <kbd class="calibre10">&gt;=</kbd></li>
<li class="calibre13"><kbd class="calibre10">Fn gt(&amp;self, other: &amp;Box&lt;T&gt;) -&gt; bool</kbd>: Tests whether self is greater than other. Used by <kbd class="calibre10">&gt;</kbd></li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl &lt;T&gt; Ord for Box&lt;T&gt; where T:Ord + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn cmp(&amp;self, other: &amp;Box&lt;T&gt;) -&gt; Ordering</kbd>: Returns an ordering between self and other</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl &lt;T&gt; Hash for Box&lt;T&gt; where T: Hash + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn hash&lt;H&gt;(&amp;self, state: &amp;mut H) where H: Hasher</kbd>: Feeds the value into the state and updates the hasher if required</li>
<li class="calibre13"><kbd class="calibre10">fn hash_slice&lt;H&gt;(data: &amp;[Self], state &amp;mut H) where H: Hasher</kbd>: Feeds the slice of this type into the state</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; From&lt;T&gt; for Box&lt;T&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn from(t: T) -&gt; Box&lt;T&gt;</kbd>: Performs a conversion</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Display for Box&lt;T&gt; where T: Display + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Formats the value using the given formatter</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Debug for Box&lt;T&gt; where T:Debug + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Formats the value using the given formatter</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Pointer for Box&lt;T&gt; where T: ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Formats the value using the given formatter</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Deref for Box&lt;T&gt; where T: ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn deref(&amp;self) -&gt; &amp;T</kbd>: Dereference a value</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; DerefMut for Box&lt;T&gt; where T: ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn deref_mut(&amp;mut self) -&gt; &amp;mut T</kbd>: Mutably dereference a value</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;I&gt; Iterator for Box&lt;I&gt; where I: Iterator + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn next(&amp;mut self) -&gt; Option&lt;I::Item&gt;</kbd>: Advances the iterator and returns the next value</li>
<li class="calibre13"><kbd class="calibre10">fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;)</kbd>: Returns the bounds on the remaining length of the iterator</li>
<li class="calibre13"><kbd class="calibre10">fn count(self) -&gt; usize</kbd>: Returns the number of iterations</li>
<li class="calibre13"><kbd class="calibre10">fn last(self) -&gt; Option&lt;Self::Item&gt;</kbd>: Returns the last element</li>
<li class="calibre13"><kbd class="calibre10">fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt;</kbd>: Consumes <em class="calibre9">n</em> elements of the iterator and returns the next one after that</li>
<li class="calibre13"><kbd class="calibre10">fn chain&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, U::Iterator&gt; where U: IntoIterator &lt;Item=Self::Item&gt;</kbd>: Takes two iterators and creates a new one over both in sequence</li>
<li class="calibre13"><kbd class="calibre10">fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, U::IntoIter&gt; where U: IntoIter</kbd>: Zips two iterators into a single pair</li>
<li class="calibre13"><kbd class="calibre10">fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; where F: FnMut(Self::Item) -&gt; B</kbd>: Takes a closure and creates an iterator that calls that closure on each element</li>
<li class="calibre13"><kbd class="calibre10">fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt; where P: FnMut(&amp;Self::Item) -&gt; bool</kbd>: Creates an iterator that uses a closure to see if an element should be yielded</li>
<li class="calibre13"><kbd class="calibre10">Fn filter_map&lt;B, F&gt;(self, f: F) -&gt; FilterMap&lt;Self, F&gt; where F: FnMut(Self::Item) -&gt; Option&lt;B&lt;</kbd>: Creates an iterator that filters and maps</li>
<li class="calibre13"><kbd class="calibre10">fn enumerate(self) -&gt; Enumerate&lt;Self&gt;</kbd>: Creates an iterator that gives the current iteration count and the next value</li>
<li class="calibre13"><kbd class="calibre10">fn peekable(self) -&gt; Peekable&lt;Self&gt;</kbd>: Creates an iterator to peek at the next element of the iterator without consuming</li>
<li class="calibre13"><kbd class="calibre10">fn skip_while&lt;P&gt;(self, predicate: P)-&gt; SkipWhile&lt;Self, P&gt; where P: FnMut(&amp;Self::Item) -&gt; bool</kbd>: Creates an iterator that skips elements based on the predicate</li>
<li class="calibre13"><kbd class="calibre10">fn skip(self, n: usize) -&gt; Skip&lt;Self&gt;</kbd>: Creates an iterator that skips the first <em class="calibre9">n</em> elements</li>
<li class="calibre13"><kbd class="calibre10">fn take(self, n:usize) -&gt; Take&lt;Self&gt;</kbd>: Creates an iterator that yields the first <em class="calibre9">n</em> elements</li>
<li class="calibre13"><kbd class="calibre10">fn take_while&lt;P&gt;(self, predicate: P) -&gt; TakeWhile&lt;Self. P&gt; where P:FnMut(&amp;Self::Item) -&gt; bool</kbd>: Creates an iterator that yields elements based on the predicate</li>
<li class="calibre13"><kbd class="calibre10">fn scan&lt;St, B, F&gt;(self, init_state: St, f : F) -&gt; Scan&lt;Self, St, F&gt; where F: FnMut(&amp;mut St, Self::Item) -&gt; Option&lt;B&gt;</kbd>: An iterator adaptor similar to <kbd class="calibre10">fold()</kbd> that holds the internal state and produces a new iterator</li>
<li class="calibre13"><kbd class="calibre10">fn flat_map&lt;U, F&gt;(self f: F) -&gt; FlatMap&lt;Self, U, F&gt; where F: FnMut(Self::Item) -&gt; U, U:IntoIterator</kbd>: Creates a flattened nested structure. Works like map.</li>
<li class="calibre13"><kbd class="calibre10">fn fuse(self) -&gt; Fuse&lt;Self&gt;</kbd>: Creates an iterator that ends after the first instance of <kbd class="calibre10">None</kbd></li>
<li class="calibre13"><kbd class="calibre10">fn inspect&lt;F&gt;(self, f: F) -&gt; Inspect&lt;Self, F&gt; where F:FnMut(&amp;Self::Item) -&gt; ()</kbd>: Does something with each element and passes the value on</li>
<li class="calibre13"><kbd class="calibre10">fn by_ref(&amp;mut self) -&gt; &amp;mut Self</kbd>: Borrow the iterator. Doesn’t consume it.</li>
<li class="calibre13"><kbd class="calibre10">fn collect&lt;B&gt;(self) -&gt; B where B: FromIterator &lt;Self::Item&gt;</kbd>: Changes the iterator to a collection</li>
<li class="calibre13"><kbd class="calibre10">fn partition&lt;B, F&gt;(self, f: F) -&gt; (B, B) where B: Default + Extend&lt;Self::Item&gt;, F: FnMut(&amp;Self::Item) -&gt; bool</kbd>: Consumes an iterator, creating two collections from it</li>
<li class="calibre13"><kbd class="calibre10">fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B where F: FnMut(B, Self::Item) -&gt; B</kbd>: An iterator adaptor that applies a function, producing a single, final value</li>
<li class="calibre13"><kbd class="calibre10">fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where F: FnMut(Self::Item) -&gt; bool</kbd>: Tests if every element of the iterator matches a predicate</li>
<li class="calibre13"><kbd class="calibre10">fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where F: FnMut(Self::Item) -&gt; bool</kbd>: Tests if any element of the iterator matches a predicate</li>
<li class="calibre13"><kbd class="calibre10">fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where P: FnMut(&amp;Self::Item) -&gt; bool</kbd>: Searches for an element of an iterator that satisfies a predicate</li>
<li class="calibre13"><kbd class="calibre10">fn position&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt; where P: FnMut(Self::Item) -&gt; bool</kbd>: Searches for an element in an iterator, returning its index</li>
<li class="calibre13"><kbd class="calibre10">fn rposition&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt; where P: FnMut(Self::Item) -&gt; bool, Self: ExactSizeIterator + DoubleEndedIterator</kbd>: Searches for an element in an iterator from the right, returning its index</li>
<li class="calibre13"><kbd class="calibre10">fn max(self) -&gt; Option&lt;Self::Item&gt; where Self::Item: Ord</kbd>: Returns the maximum element of an iterator</li>
<li class="calibre13"><kbd class="calibre10">fn min(self) -&gt; Option&lt;Self::Item&gt; where Self::Item: Ord</kbd>: Returns the minimum element of an iterator</li>
<li class="calibre13"><kbd class="calibre10">fn max_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt; where B: Ord, F: FnMut(&amp;Self::Item) -&gt; B</kbd>: Returns the element that gives the maximum value from the specified function</li>
<li class="calibre13"><kbd class="calibre10">fn min_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt; where B: Ord, F: FnMut(&amp;Self::Item) -&gt; B</kbd>: Returns the element that gives the minimum value from the specified function</li>
<li class="calibre13"><kbd class="calibre10">fn rev(self) -&gt; Rev&lt;Self&gt; where Self: DoubleEndedIterator</kbd>: Reverses an iterator's direction</li>
<li class="calibre13"><kbd class="calibre10">fn unzip &lt;A, B, FromA, FromB&gt; (self) -&gt; (FromA, FromB) where FromA: Default + Extend&lt;A&gt;, FromB: Default + Extend&lt;B&gt;, Self: Iterator&lt;Item=(A, B)&gt;</kbd>: Converts an iterator of pairs into a pair of containers</li>
<li class="calibre13"><kbd class="calibre10">fn cloned&lt;'a, T&gt;(self) -&gt; Cloned&lt;Self&gt; where Self: Iterator&lt;Item=&amp;'a T&gt;, T: 'a + Clone</kbd>: Creates an iterator that clones all of its elements</li>
<li class="calibre13"><kbd class="calibre10">fn cycle(self) -&gt; Cycle&lt;Self&gt; where Self: Clone</kbd>: Repeats an iterator endlessly</li>
<li class="calibre13"><kbd class="calibre10">fn sum&lt;S&gt;(self) -&gt; S where S: Sum&lt;Self::Item&gt;</kbd>: Sums the elements of an iterator</li>
<li class="calibre13"><kbd class="calibre10">fn product&lt;P&gt;(self) -&gt; P where P: Product&lt;Self::Item&gt;</kbd>: Iterates over the entire iterator, multiplying all the elements</li>
<li class="calibre13"><kbd class="calibre10">fn cmp&lt;I&gt;(self, other: I) -&gt; Ordering where I: IntoIterator &lt;Item=Self::Item&gt;, Self::Item: Ord</kbd>: Compares the elements of this Iterator with those of another</li>
<li class="calibre13"><kbd class="calibre10">fn partial_cmp&lt;I&gt;(self, other: I) -&gt; Option&lt;Ordering&gt; where I: IntoIterator, Self::Item: PartialOrd&lt;I::Item&gt;</kbd>: Compares the elements of this Iterator with those of another</li>
<li class="calibre13"><kbd class="calibre10">fn eq&lt;I&gt;(self, other: I) -&gt; bool where I: IntoIterator, Self::Item: PartialEq&lt;I::Item&gt;</kbd>: Determines if the elements of this Iterator are equal to those of another</li>
<li class="calibre13"><kbd class="calibre10">fn ne&lt;I&gt;(self, other: I) -&gt; bool where I: IntoIterator, Self::Item: PartialEq&lt;I::Item&gt;</kbd>: Determines if the elements of this <kbd class="calibre10">Iterator</kbd> are unequal to those of another</li>
<li class="calibre13"><kbd class="calibre10">fn lt&lt;I&gt;(self, other: I) -&gt; bool where I: IntoIterator, Self::Item: PartialOrd&lt;I::Item&gt;</kbd>: Determines if the elements of this Iterator are less than those of another</li>
<li class="calibre13"><kbd class="calibre10">fn le&lt;I&gt;(self, other: I) -&gt; bool where I: IntoIterator, Self::Item: PartialOrd&lt;I::Item&gt;</kbd>: Determines if the elements of this Iterator are less than or equal to those of another</li>
<li class="calibre13"><kbd class="calibre10">fn gt&lt;I&gt;(self, other: I) -&gt; bool where I: IntoIterator, Self::Item: PartialOrd&lt;I::Item&gt;</kbd>: Determines if the elements of this Iterator are greater than those of another</li>
<li class="calibre13"><kbd class="calibre10">fn ge&lt;I&gt;(self, other: I) -&gt; bool where I: IntoIterator, Self::Item: PartialOrd&lt;I::Item&gt;</kbd>: Determines if the elements of this Iterator are greater than or equal to those of another</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;I&gt; DoubleEndedIterator for Box&lt;I&gt; where I: DoubleEndedIterator + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn next_back(&amp;mut self) -&gt; Option&lt;I::Item&gt;</kbd>: Removes and returns an element from the end of the iterator</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl &lt;T&gt; ExactSizeIterator for Box&lt;I&gt; where I: ExactSizeIterator + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn len(&amp;self) -&gt; usize</kbd>: Returns the exact number of times the iterator will iterate.</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Clone for Box&lt;[T]&gt; where T:Clone</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn clone(&amp;self) -&gt; Box&lt;[T]&gt;</kbd>: Returns a copy of the value</li>
<li class="calibre13"><kbd class="calibre10">fn clone_from(&amp;mut self, source: &amp;Self)</kbd>: Performs copy-assignment from source</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Borrow&lt;T&gt; for Box&lt;T&gt; where T:?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn borrow(&amp;self) -&gt; &amp;T</kbd>: Immutably borrows from an owned value</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; BorrowMut&lt;T&gt; for Box&lt;T&gt; where T:?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</kbd>: Mutably borrows from an owned value</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; AsRef&lt;T&gt; for Box&lt;T&gt; where T:?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn as_ref(&amp;self) -&gt; &amp;T</kbd>: Performs the conversion</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; AsMut for Box&lt;T&gt; where T:?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn as_mut(&amp;mut self) -&gt; &amp;mut T</kbd>: Performs the conversion</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;’a, E: Error + ‘a&gt; From&lt;E&gt; from Box&lt;Error + ‘a&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn from(err: E) -&gt; Box&lt;Error + 'a&gt;</kbd>: Performs the conversion</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl From&lt;String&gt; for Box&lt;Error + Send + Sync&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn from(err: String) -&gt; Box&lt;Error + Send + Sync&gt;</kbd>: Performs the conversion</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl From&lt;’a, ‘b&gt; From&lt;&amp;’b str&gt; for Box&lt;Error + Send + Sync + ‘a&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn from(err: &amp;'b str) -&gt; Box&lt;Error + Send + Sync + 'a&gt;</kbd>: Performs the conversion</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T: Error&gt; Error for Box&lt;T&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn description(&amp;self) -&gt; &amp;str</kbd>: Short description of the error</li>
<li class="calibre13"><kbd class="calibre10">fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt;</kbd>: Lower-level cause of this error, if any</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;R: Read + ?Sized&gt; Read for Box&lt;R&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;</kbd>: Pulls some bytes from this source into the specified buffer, returning how many bytes were read</li>
<li class="calibre13"><kbd class="calibre10">fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;</kbd>: Reads all bytes until EOF in this source, placing them into <kbd class="calibre10">buf</kbd></li>
<li class="calibre13"><kbd class="calibre10">fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;</kbd>: Reads all bytes until EOF in this source, placing them into <kbd class="calibre10">buf</kbd></li>
<li class="calibre13"><kbd class="calibre10">fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;()&gt;</kbd>: Reads the exact number of bytes required to fill <kbd class="calibre10">buf</kbd></li>
<li class="calibre13"><kbd class="calibre10">fn by_ref(&amp;mut self) -&gt; &amp;mut Self where Self: Sized</kbd>: Creates a <em class="calibre9">by reference</em> adaptor for this instance of <kbd class="calibre10">Read</kbd></li>
<li class="calibre13"><kbd class="calibre10">fn bytes(self) -&gt; Bytes&lt;Self&gt; where Self: Sized</kbd>: Transforms this <kbd class="calibre10">Read</kbd> instance to an Iterator over its bytes</li>
<li class="calibre13"><kbd class="calibre10">fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt; where Self: Sized</kbd>: Creates an adaptor that will chain this stream with another</li>
<li class="calibre13"><kbd class="calibre10">fn take(self, limit: u64) -&gt; Take&lt;Self&gt; where Self: Sized</kbd>: Creates an adaptor that will read at most limit bytes from it</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl &lt;W: Write + ?Sized&gt; Write for Box&lt;W&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;</kbd>: Writes a buffer into this object, returning how many bytes were written</li>
<li class="calibre13"><kbd class="calibre10">fn flush(&amp;mut self) -&gt; Result&lt;()&gt;</kbd>: Flushes this output stream, ensuring that all intermediately buffered contents reach their destination</li>
<li class="calibre13"><kbd class="calibre10">fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;</kbd>: Attempts to write an entire buffer into this write</li>
<li class="calibre13"><kbd class="calibre10">fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;</kbd>: Writes a formatted string into this writer, returning any error encountered</li>
<li class="calibre13"><kbd class="calibre10">fn by_ref(&amp;mut self) -&gt; &amp;mut Self where Self: Sized</kbd>: Creates a <em class="calibre9">by reference</em> adaptor for this instance of <kbd class="calibre10">Write</kbd></li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;S: Seek + ?Sized&gt; Seek for Box&lt;S&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn seek(&amp;mut self, pos: SeekFrom) -&gt; Result&lt;u64&gt;</kbd>: Seeks to an offset, in bytes, in a stream</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;B: BufRead + ?Sized&gt; BufRead for Box&lt;B&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fill_buf(&amp;mut self) -&gt; Result&lt;&amp;[u8]&gt;</kbd>: Fills the internal buffer of this object, returning the buffer contents</li>
<li class="calibre13"><kbd class="calibre10">fn consume(&amp;mut self, amt: usize)</kbd>: Tells this buffer that amt bytes have been consumed from the buffer, so they should no longer be returned in calls to be read</li>
<li class="calibre13"><kbd class="calibre10">fn read_until(&amp;mut self, byte: u8, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;</kbd>: Reads all bytes into <kbd class="calibre10">buf</kbd> until the delimiter byte is reached</li>
<li class="calibre13"><kbd class="calibre10">fn read_line(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;</kbd>: Reads all bytes until a newline (the 0 x A byte) is reached, and appends them to the provided buffer</li>
<li class="calibre13"><kbd class="calibre10">fn split(self, byte: u8) -&gt; Split&lt;Self&gt; where Self: Sized</kbd>: Returns an iterator over the contents of this reader split on the byte byte</li>
<li class="calibre13"><kbd class="calibre10">fn lines(self) -&gt; Lines&lt;Self&gt; where Self: Sized</kbd>: Returns an iterator over the lines of this reader</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::cell</h1>
                
            
            <article>
                
<p class="calibre1">Used in conjunction with shared mutable containers:</p>
<div class="packt_infobox">For details on using <kbd class="calibre22">Cells</kbd>, <kbd class="calibre22">RefCell</kbd>, and both interior and external references, see <a href="part0265.html#7SN520-a5175cb437d742a9aed0ea574000ee2d" class="calibre42">Chapter 11</a>, <em class="calibre23">Concurrency in Rust</em>.</div>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">Std::cell::BorrowError</kbd>: Returned by <kbd class="calibre10">RefCell::try_borrow</kbd></li>
<li class="calibre13"><kbd class="calibre10">impl Display for BorrowError</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Formats the value using the given formatter.</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl Debug for BorrowError</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Formats the value using the given formatter.</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl Error for BorrowError</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn description(&amp;self) -&gt; &amp;str</kbd>: A short description of the error</li>
<li class="calibre13"><kbd class="calibre10">fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt;</kbd>: The lower-level cause of this error, if any</li>
</ul>
</li>
</ul>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">std::cell::BorrowMutError</kbd>: Returned by <kbd class="calibre10">RefCell::try_borrow_mut</kbd></li>
<li class="calibre13"><kbd class="calibre10">impl Display for BorrowMutError</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Formats the value using the given formatter</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl Debug for BorrowMutError</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Formats the value using the given formatter</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl Error for BorrowMutError</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn description(&amp;self) -&gt; &amp;str</kbd>: A short description of the error</li>
<li class="calibre13"><kbd class="calibre10">fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt;</kbd>: The lower-level cause of this error, if any</li>
</ul>
</li>
</ul>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">std::cell::Cell</kbd>: A mutable memory location that admits only <kbd class="calibre10">Copy</kbd> data</li>
</ul>
<p class="calibre1"><strong class="calibre8">Methods</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Cell&lt;T&gt; where T: Copy</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn new(value: T) -&gt; Cell&lt;T&gt;</kbd>: Creates a new Cell containing the given value</li>
<li class="calibre13"><kbd class="calibre10">fn get(&amp;self) -&gt; T</kbd>: Returns a copy of the contained value</li>
<li class="calibre13"><kbd class="calibre10">fn set(&amp;self, value: T)</kbd>: Sets the contained value</li>
<li class="calibre13"><kbd class="calibre10">fn as_ptr(&amp;self) -&gt; *mut T</kbd>: Returns a raw pointer to the underlying data in this cell</li>
<li class="calibre13"><kbd class="calibre10">fn get_mut(&amp;mut self) -&gt; &amp;mut T</kbd>: Returns a mutable reference to the underlying data</li>
</ul>
</li>
</ul>
<p class="calibre1"><strong class="calibre8">Traits</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; PartialEq&lt;Cell&lt;T&gt;&gt; for Cell&lt;T&gt; where T: Copy + PartialEq&lt;T&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn eq(&amp;self, other: &amp;Cell&lt;T&gt;) -&gt; bool</kbd>: Tests for self and other values being equal, and is used by <kbd class="calibre10">==</kbd></li>
<li class="calibre13"><kbd class="calibre10">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</kbd>: Tests for <kbd class="calibre10">!=</kbd></li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Default for Cell&lt;T&gt; where T: Copy + Default</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn default() -&gt; Cell&lt;T&gt;</kbd>: Creates a <kbd class="calibre10">Cell&lt;T&gt;</kbd>, with the <kbd class="calibre10">Default</kbd> value for <kbd class="calibre10">T</kbd></li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Clone for Cell&lt;T&gt; where T: Copy</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn clone(&amp;self) -&gt; Cell&lt;T&gt;</kbd>: Returns a copy of the value</li>
<li class="calibre13"><kbd class="calibre10">fn clone_from(&amp;mut self, source: &amp;Self)</kbd>: Performs copy-assignment from source</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; From&lt;T&gt; for Cell&lt;T&gt; where T: Copy</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn from(t: T) -&gt; Cell&lt;T&gt;</kbd>: Performs the conversion</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Ord for Cell&lt;T&gt; where T: Copy + Ord</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn cmp(&amp;self, other: &amp;Cell&lt;T&gt;) -&gt; Ordering</kbd>: This method returns an <kbd class="calibre10">Ordering</kbd> between self and other</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Debug for Cell&lt;T&gt; where T: Copy + Debug</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Formats the value using the given formatter</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; PartialOrd&lt;Cell&lt;T&gt;&gt; for Cell&lt;T&gt; where T: Copy + PartialOrd&lt;T&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn partial_cmp(&amp;self, other: &amp;Cell&lt;T&gt;) -&gt; Option&lt;Ordering&gt;</kbd>: This method returns an ordering between self and other values if one exists</li>
<li class="calibre13"><kbd class="calibre10">fn lt(&amp;self, other: &amp;Cell&lt;T&gt;) -&gt; bool</kbd>: This method tests less than (for self and other) and is used by the <kbd class="calibre10">&lt;</kbd> operator</li>
<li class="calibre13"><kbd class="calibre10">fn le(&amp;self, other: &amp;Cell&lt;T&gt;) -&gt; bool</kbd>: This method tests less than or equal to (for self and other) and is used by the <kbd class="calibre10">&lt;=</kbd> operator</li>
<li class="calibre13"><kbd class="calibre10">fn gt(&amp;self, other: &amp;Cell&lt;T&gt;) -&gt; bool</kbd>: This method tests greater than (for self and other) and is used by the <kbd class="calibre10">&gt;</kbd> operator</li>
<li class="calibre13"><kbd class="calibre10">fn ge(&amp;self, other: &amp;Cell&lt;T&gt;) -&gt; bool</kbd>: This method tests greater than or equal to (for self and other) and is used by the <kbd class="calibre10">&gt;=</kbd> operator</li>
</ul>
</li>
</ul>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">Std::cell::Ref</kbd>: Wraps a borrowed reference to a value in a <kbd class="calibre10">RefCell</kbd> box</li>
</ul>
<p class="calibre1"><strong class="calibre8">Methods</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">impl&lt;'b, T&gt; Ref&lt;'b, T&gt; where T: ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn clone(orig: &amp;Ref&lt;'b, T&gt;) -&gt; Ref&lt;'b, T&gt;</kbd>: Copies a <kbd class="calibre10">Ref</kbd>. The <kbd class="calibre10">RefCell</kbd> is already immutably borrowed, so this cannot fail.</li>
<li class="calibre13"><kbd class="calibre10">fn map&lt;U, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; Ref&lt;'b, U&gt;</kbd><br class="calibre2"/>
<kbd class="calibre10">where F: FnOnce(&amp;T) -&gt; &amp;U, U: ?Sized</kbd>: Makes a new <kbd class="calibre10">Ref</kbd> for a component of the borrowed data. The <kbd class="calibre10">RefCell</kbd> is already immutably borrowed, so this cannot fail.</li>
</ul>
</li>
</ul>
<p class="calibre1"><strong class="calibre8">Trait implementation</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">impl&lt;'b, T&gt; Debug for Ref&lt;'b, T&gt; where T: Debug + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Formats the value using the given formatter</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;'b, T&gt; Deref for Ref&lt;'b, T&gt; where T: ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn deref(&amp;self) -&gt; &amp;T</kbd>: The method is called to dereference a value</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">Std::cell::RefCell</kbd>: A mutable memory location with dynamically checked borrow rules</li>
</ul>
<p class="calibre1"><strong class="calibre8">Methods</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; RefCell&lt;T&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn new(value: T) -&gt; RefCell&lt;T&gt;</kbd>: Creates a new <kbd class="calibre10">RefCell</kbd> containing a value</li>
<li class="calibre13"><kbd class="calibre10">fn into_inner(self) -&gt; T</kbd>: Consumes the <kbd class="calibre10">RefCell</kbd>, returning the wrapped value.</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; RefCell&lt;T&gt; where T: ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn borrow(&amp;self) -&gt; Ref&lt;T&gt;</kbd>: Immutably borrows the wrapped value.<br class="calibre2"/>
The borrow lasts until the returned <kbd class="calibre10">Ref</kbd> exits scope. Multiple immutable borrows can be taken out at the same time. Throws a panic if the value is currently mutably borrowed.</li>
<li class="calibre13"><kbd class="calibre10">fn try_borrow(&amp;self) -&gt; Result&lt;Ref&lt;T&gt;, BorrowError&gt;</kbd>: Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed. The borrow lasts until the returned <kbd class="calibre10">Ref</kbd> exits scope. Multiple immutable borrows can be taken out at the same time.</li>
<li class="calibre13"><kbd class="calibre10">fn borrow_mut(&amp;self) -&gt; RefMut&lt;T&gt;</kbd>: Mutably borrows the wrapped value. The borrow lasts until the returned <kbd class="calibre10">RefMut</kbd> exits scope. The value cannot be borrowed while this borrow is active (throws a panic).</li>
<li class="calibre13"><kbd class="calibre10">fn try_borrow_mut(&amp;self) -&gt; Result&lt;RefMut&lt;T&gt;, BorrowMutError&gt;</kbd>: Mutably borrows the wrapped value, returning an error if the value is currently borrowed. The borrow lasts until the returned <kbd class="calibre10">RefMut</kbd> exits scope. The value cannot be borrowed while this borrow is active.</li>
<li class="calibre13"><kbd class="calibre10">fn as_ptr(&amp;self) -&gt; *mut T</kbd>:  Returns a raw pointer to the underlying data in this cell.</li>
<li class="calibre13"><kbd class="calibre10">fn get_mut(&amp;mut self) -&gt; &amp;mut T</kbd>: Returns a mutable reference to the underlying data.</li>
</ul>
</li>
</ul>
<p class="calibre1"><strong class="calibre8">Trait implementations</strong></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; PartialEq&lt;RefCell&lt;T&gt;&gt; for RefCell&lt;T&gt; where T: PartialEq&lt;T&gt; + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn eq(&amp;self, other: &amp;RefCell&lt;T&gt;) -&gt; bool</kbd>: Tests for self and other values being equal, and is used by <kbd class="calibre10">==</kbd></li>
<li class="calibre13"><kbd class="calibre10">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</kbd>: Tests for <kbd class="calibre10">!=</kbd></li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Default for RefCell&lt;T&gt; where T: Default</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn default() -&gt; RefCell&lt;T&gt;</kbd>: Creates a <kbd class="calibre10">RefCell&lt;T&gt;</kbd>, with the <kbd class="calibre10">Default</kbd> value for <kbd class="calibre10">T</kbd></li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Clone for RefCell&lt;T&gt; where T: Clone</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn clone(&amp;self) -&gt; RefCell&lt;T&gt;</kbd>: Returns a copy of the value</li>
<li class="calibre13"><kbd class="calibre10">fn clone_from(&amp;mut self, source: &amp;Self)</kbd>: Performs copy-assignment from source</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; From&lt;T&gt; for RefCell&lt;T&gt;</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn from(t: T) -&gt; RefCell&lt;T&gt;</kbd>: Performs the conversion</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Ord for RefCell&lt;T&gt; where T: Ord + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn cmp(&amp;self, other: &amp;RefCell&lt;T&gt;) -&gt; Ordering</kbd>: Returns an <kbd class="calibre10">Ordering</kbd> between self and other</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; Debug for RefCell&lt;T&gt; where T: Debug + ?Sized</kbd>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;</kbd>: Formats the value using the given formatter</li>
</ul>
</li>
<li class="calibre13"><kbd class="calibre10">impl&lt;T&gt; PartialOrd&lt;RefCell&lt;T&gt;&gt; for RefCell&lt;T&gt; where T: PartialOrd&lt;T&gt; + ?Sized</kbd><br class="calibre2"/>
<ul class="calibre31">
<li class="calibre13"><kbd class="calibre10">fn partial_cmp(&amp;self, other: &amp;RefCell&lt;T&gt;) -&gt; Option&lt;Ordering&gt;</kbd>: Returns an ordering between self and other values if one exists</li>
<li class="calibre13"><kbd class="calibre10">fn lt(&amp;self, other: &amp;RefCell&lt;T&gt;) -&gt; bool</kbd>: Tests less than (for self and other) and is used by the <kbd class="calibre10">&lt;</kbd> operator</li>
<li class="calibre13"><kbd class="calibre10">fn le(&amp;self, other: &amp;RefCell&lt;T&gt;) -&gt; bool</kbd>: Tests less than or equal to (for self and other) and is used by the <kbd class="calibre10">&lt;=</kbd> operator</li>
<li class="calibre13"><kbd class="calibre10">fn gt(&amp;self, other: &amp;RefCell&lt;T&gt;) -&gt; bool</kbd>: Tests greater than (for self and other) and is used by the <kbd class="calibre10">&gt;</kbd> operator</li>
<li class="calibre13"><kbd class="calibre10">fn ge(&amp;self, other: &amp;RefCell&lt;T&gt;) -&gt; bool</kbd>: Tests greater than or equal to (for self and other) and is used by the <kbd class="calibre10">&gt;=</kbd> operator</li>
</ul>
</li>
</ul>
<div class="packt_tip"><span class="chapterrefpackt">The code </span>examples are in <span class="chapterrefpackt"><a href="part0265.html#7SN520-a5175cb437d742a9aed0ea574000ee2d" class="calibre42">Chapter 11</a>, <em class="calibre23">Concurrency in Rust</em></span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::char</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for the Structs, Traits, and Enum character types.</p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">DecodeUtf16</kbd>, <kbd class="calibre10">DecodeUtf16Error</kbd>, <kbd class="calibre10">EscapeDefault</kbd>, <kbd class="calibre10">EscapeUnicode</kbd>, <kbd class="calibre10">ToLowercase</kbd>, and <kbd class="calibre10">ToUpperCase</kbd>.</li>
<li class="calibre13"><strong class="calibre8">Constants</strong>: <kbd class="calibre10">Max</kbd> and <kbd class="calibre10">Replacement_Character</kbd>.</li>
<li class="calibre13"><strong class="calibre8">Functions</strong>: <kbd class="calibre10">decode_utf16</kbd>, <kbd class="calibre10">from_digit</kbd>, <kbd class="calibre10">from_u32</kbd>, and <kbd class="calibre10">from_u32_unchecked</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::clone</h1>
                
            
            <article>
                
<p class="calibre1">This is for use with types that cannot be implicitly copied.</p>
<p class="calibre1"><span>More complex types (such as strings) are not implicitly copyable. These types have to be made explicitly copyable using the </span><kbd class="calibre10">Clone</kbd><span> trait and clonable using the </span><kbd class="calibre10">clone</kbd><span> method.</span></p>
<p class="calibre1"><span><strong class="calibre8">Structs, Traits, and Enums</strong>: </span><span>Trait </span><kbd class="calibre10">Clone</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::cmp</h1>
                
            
            <article>
                
<p class="calibre1">This module provides the ability to order and compare data.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines both</span> <kbd class="calibre22">PartialOrd</kbd><span class="chapterrefpackt"> (overloads </span><kbd class="calibre22">&lt;</kbd><span class="chapterrefpackt">. </span><kbd class="calibre22">&lt;=</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">&gt;</kbd><span class="chapterrefpackt">, and </span><kbd class="calibre22">&gt;=</kbd><span class="chapterrefpackt">) and </span><kbd class="calibre22">PartialEq</kbd><span class="chapterrefpackt"> traits (overloads </span><kbd class="calibre22">==</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">!=</kbd><span class="chapterrefpackt">) .</span></div>
<p class="calibre1"><span><strong class="calibre8">Structs, Traits, and Enums</strong>: E</span><span>num </span><kbd class="calibre10">Ordering</kbd><span>, traits </span><kbd class="calibre10">Eq</kbd><span> (equality comparisons), </span><kbd class="calibre10">Ord</kbd><span> (total order), </span><kbd class="calibre10">PartialEq</kbd><span> (partial equality relations), </span><kbd class="calibre10">PartialOrd</kbd><span> (values that can be compared for a sort-order) .</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::collections</h1>
                
            
            <article>
                
<p class="calibre1">This covers the vectors, maps, sets, and binary heaps.</p>
<p class="calibre1">There are four main categories of collection, but for the majority of the time <kbd class="calibre10">Vec</kbd> and <kbd class="calibre10">HashMap</kbd> should be used.</p>
<p class="calibre41">The collection types are</p>
<ul class="calibre43">
<li class="calibre13">Sequences (<kbd class="calibre40">Vec</kbd>, <kbd class="calibre40">VecDeque</kbd>, <kbd class="calibre40">LinkedList</kbd> - if you're used to C#, these provide the functionality of <kbd class="calibre40">List&lt;T&gt;</kbd>)</li>
<li class="calibre13">Maps (<kbd class="calibre40">HashMap</kbd>, <kbd class="calibre40">BTreeMap</kbd>. For C# users, these equate roughly to <kbd class="calibre40">Dictionary&lt;T, U&gt;</kbd>, and <kbd class="calibre40">Map</kbd>)</li>
<li class="calibre13">Sets (<kbd class="calibre40">HashSet</kbd>, <kbd class="calibre40">BTreeSet</kbd>)</li>
<li class="calibre13">BinaryHeap</li>
</ul>
<p class="calibre1">Which collection should be used depends on what you want to do. Each will have a performance impact depending on what you're doing, though usually it's only <kbd class="calibre10">HashMap</kbd> that will give a negative impact.</p>
<p class="calibre1"><span>Examples of use:</span></p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">Vec</kbd>: <span>Creates a collection of type <kbd class="calibre10">T</kbd> that can be resized; elements can be added to the end</span></li>
<li class="calibre13"><kbd class="calibre10">VecDeque</kbd>: Creates a collection of type <kbd class="calibre10">T</kbd>, but with elements insertable at both ends; needs a queue or double-ended queue (deque)</li>
<li class="calibre13"><kbd class="calibre10">LinkedList</kbd>: Used when you want a <kbd class="calibre10">Vec</kbd> or <kbd class="calibre10">VecDeque</kbd>, and to split and append lists</li>
<li class="calibre13"><kbd class="calibre10">HashMap</kbd>: Creates a cached association of keys with values</li>
<li class="calibre13">BTreeMap: Use with key-pair values where in general you want the largest and smallest key-pair values</li>
<li class="calibre13">BinaryHeap: Stores elements, but only processes the biggest or most important ones when you want them</li>
</ul>
<p class="calibre1">Each of these collections deals with its own memory handling. This is important as collections are able to allocate more space as required (and within the limitations of the hardware capacity of the machine they are running on).</p>
<p class="calibre1">Consider the following: I create a <kbd class="calibre10">Vec&lt;T&gt;</kbd> without setting a capacity. Let <kbd class="calibre10">T</kbd> be a structure. This is not an uncommon occurrence. I add a number of objects to the <kbd class="calibre10">Vec</kbd>, and each is then allocated on the heap. The heap expands, which is fine. I then delete a number of these objects. Rust then <em class="calibre9">repositions</em> the other members of the heap belonging to the <kbd class="calibre10">Vec</kbd>.</p>
<p class="calibre1">If I allocated space using <kbd class="calibre10">with_capacity</kbd>, then we have a maximum allocation available, which further helps with memory handling. We can help memory allocation further by using <kbd class="calibre10">shrink_to_fit</kbd>, which reduces the size of our <kbd class="calibre10">Vec</kbd> to fit the size required.</p>
<p class="calibre41"><strong class="calibre8">Iterators</strong></p>
<p class="calibre1">Iterators are very useful and used in libraries. Primarily, an iterator is used in a for loop. Almost all collections provide three iterators: <kbd class="calibre10">iter</kbd>, <kbd class="calibre10">iter_mut</kbd>, and <kbd class="calibre10">into_iter</kbd>. Each of the iterator types performs a different function:</p>
<ul class="calibre43">
<li class="calibre13"><kbd class="calibre40">iter</kbd>: This provides an iterator of immutable references to all contents of the collection in the order that best suits the collection type.</li>
<li class="calibre13"><kbd class="calibre40">iter_mut</kbd>: This provides an iterator of mutable references in the same order as <kbd class="calibre40">iter</kbd>.</li>
<li class="calibre13"><kbd class="calibre40">into_iter</kbd>: This transforms the collection into an iterator. Very useful when the collection isn't needed, but its contents are. The <kbd class="calibre40">into_iter</kbd> iterator also includes the ability to extend a vector.</li>
</ul>
<p class="calibre1"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">BTreeMap</kbd>, <kbd class="calibre10">BTreeSet</kbd>, <kbd class="calibre10">BinaryHeap</kbd>, <kbd class="calibre10">HashMap</kbd>, <kbd class="calibre10">HashSet</kbd>, <kbd class="calibre10">LinkedList</kbd>, and <kbd class="calibre10">VecDeque</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::convert</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for the conversion between types.</p>
<div class="packt_infobox"><span class="chapterrefpackt">When writing a library, implement </span><kbd class="calibre22">From&lt;T&gt;</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">TryFrom&lt;T&gt;</kbd><span class="chapterrefpackt"> instead of </span><kbd class="calibre22">Into&lt;T&gt;</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">TryInto&lt;T&gt;</kbd><span class="chapterrefpackt"> as the </span><kbd class="calibre22">From</kbd><span class="chapterrefpackt"> forms provide greater flexibility.</span></div>
<ul class="calibre12">
<li class="calibre13"><span><strong class="calibre8">Implementations</strong>: </span><kbd class="calibre10">As*</kbd><span> (reference-to-reference conversions), </span><kbd class="calibre10">Into</kbd><span> (consume the value in the conversion), </span><kbd class="calibre10">From</kbd><span> (useful for value and reference conversion), </span><kbd class="calibre10">TryFrom</kbd><span>, and </span><kbd class="calibre10">TryInto</kbd><span> (similar to </span><kbd class="calibre10">From</kbd><span> and </span><kbd class="calibre10">Into</kbd><span>, allows for failure) </span></li>
<li class="calibre13"><span><strong class="calibre8">Structs, Traits, and Enums</strong>: </span><span>Traits </span><kbd class="calibre10">AsMut</kbd><span>, </span><kbd class="calibre10">AsRef</kbd><span>, </span><kbd class="calibre10">From</kbd><span>, and </span><kbd class="calibre10">Into</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::default</h1>
                
            
            <article>
                
<p class="calibre1">This trait provides meaningful values for types.</p>
<div class="packt_infobox"><span class="chapterrefpackt">Default provides default values for various primitive types. If a complex type is used, you will need to implement <kbd class="calibre22">Default</kbd>.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong><span>: </span><span>Trait </span><kbd class="calibre10">Default</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std:env</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for dealing with process environment.</p>
<div class="packt_infobox"><span class="chapterrefpackt">Provides a number of functions to obtain values from the current operating systems.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Enum</strong>: <kbd class="calibre10">VarError</kbd> (possible errors from the <kbd class="calibre10">env::var</kbd> method)</li>
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">Args</kbd> (yields a <kbd class="calibre10">String</kbd> for each argument), <kbd class="calibre10">ArgOs</kbd> (yields an <kbd class="calibre10">OsString</kbd> for each argument), <kbd class="calibre10">JoinPathsError</kbd> (returns an error when the paths fail to join), <kbd class="calibre10">SplitPaths</kbd> (iterates over <kbd class="calibre10">PathBuf</kbd> for parsing an environment variable to platform-specific conventions), <kbd class="calibre10">Vars</kbd>, and <kbd class="calibre10">VarsOS</kbd> (iterates over a snapshot of the environment variables for a process) </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std:error</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for working with errors.</p>
<p class="calibre1"><span><strong class="calibre8">Structs, Traits, and Enums</strong>: </span><span>Trait </span><kbd class="calibre10">Error</kbd><span> (base functionality for all errors) </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::f32</h1>
                
            
            <article>
                
<p class="calibre1">This module is used to deal with 32-bit floating point types.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module provides basic math constants: </span><kbd class="calibre22">Digits</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Epsilon</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Infinity</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Mantissa_Digits</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Max</kbd><span class="chapterrefpackt"> (largest finite <kbd class="calibre22">f32</kbd> value), </span><kbd class="calibre22">Max_10_Exp</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Max_Exp</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Min</kbd><span class="chapterrefpackt"> (smallest finite <kbd class="calibre22">f32</kbd> value), </span><kbd class="calibre22">Min_10_Exp</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Min_Exp</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Min_Positive</kbd><span class="chapterrefpackt"> (smallest possible normalized <kbd class="calibre22">f32</kbd> value), </span><kbd class="calibre22">NAN</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Neg_Infinity</kbd><span class="chapterrefpackt">, and </span><kbd class="calibre22">Radix</kbd><span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::f64</h1>
                
            
            <article>
                
<p class="calibre1">This module is used to deal with 64-bit floating point types.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module provides basic math constants: </span><kbd class="calibre22">Digits</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Epsilon</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Infinity</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Mantissa_Digits</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Max</kbd><span class="chapterrefpackt"> (largest finite <kbd class="calibre22">f64</kbd> value), </span><kbd class="calibre22">Max_10_Exp</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Max_Exp</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Min</kbd><span class="chapterrefpackt"> (smallest finite <kbd class="calibre22">f64</kbd> value), </span><kbd class="calibre22">Min_10_Exp</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Min_Exp</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Min_Positive</kbd><span class="chapterrefpackt"> (smallest possible normalized <kbd class="calibre22">f64</kbd> value), </span><kbd class="calibre22">NAN</kbd><span class="chapterrefpackt">, </span><kbd class="calibre22">Neg_Infinity</kbd><span class="chapterrefpackt">, and </span><kbd class="calibre22">Radix</kbd><span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std:ffi</h1>
                
            
            <article>
                
<p class="calibre1">FFI is Rust's method of interacting with non-Rust libraries. This trait provides a number of utilities for this purpose.</p>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong><span>: </span><span>Structs </span><kbd class="calibre10">CStr</kbd><span>, </span><kbd class="calibre10">CString</kbd><span> (representation of a borrowed C string and an owned C-compatible string respectively), </span><kbd class="calibre10">FromBytesWithNullError</kbd><span> (error returned from </span><kbd class="calibre10">CStr::from_bytes_with_nul</kbd><span>), </span><kbd class="calibre10">IntoStringError</kbd><span> (error returned from </span><kbd class="calibre10">CString::into_string</kbd><span> to indicate a UTF8 error during a conversion), </span><kbd class="calibre10">NulError</kbd><span> (returns an error from </span><kbd class="calibre10">CString::new</kbd><span> indicating a null byte was found in the provided vector), </span><kbd class="calibre10">OsStr</kbd><span>, and </span><kbd class="calibre10">OsString</kbd><span> (slices into OS strings).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::fmt</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for formatting and outputting strings.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module provides the </span><kbd class="calibre22">format!</kbd><span class="chapterrefpackt"> macro for dealing with output. The macro is extremely powerful and very flexible, and provides a great deal of functionality.</span></div>
<p class="calibre1"><span><strong class="calibre8">Structs, Traits, and Enums</strong></span></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">Arguments</kbd> (represents a safely precompiled version of a format string and arguments), <kbd class="calibre10">DebugList</kbd>, <kbd class="calibre10">DebugMap</kbd>, <kbd class="calibre10">DebugSet</kbd>, <kbd class="calibre10">DebugStruct</kbd>, <kbd class="calibre10">DebugTuple</kbd> (helps with <kbd class="calibre10">fmt::Debug</kbd> implementations), <kbd class="calibre10">Error</kbd> (an error type returned from formatting a message into a stream), and <kbd class="calibre10">Formatter</kbd> (represents both where to emit formatting strings and how to format them).</li>
<li class="calibre13"><strong class="calibre8">Traits</strong>: <kbd class="calibre10">Binary</kbd>, <kbd class="calibre10">Debug</kbd>, <kbd class="calibre10">Display</kbd>, <kbd class="calibre10">LowerExp</kbd>, <kbd class="calibre10">LowerHex</kbd>, <kbd class="calibre10">Octal</kbd>, <kbd class="calibre10">Pointer</kbd>, <kbd class="calibre10">UpperExp</kbd>, <kbd class="calibre10">UpperHex</kbd>, and <kbd class="calibre10">Write</kbd> (provides collection of methods that are required to format a message into a stream).</li>
<li class="calibre13"><strong class="calibre8">Functions</strong>: <kbd class="calibre10">format</kbd> (takes a precompiled format string with arguments and returns a formatted string) and  <kbd class="calibre10">write</kbd> (takes an output stream, a precompiled format string and list of arguments. The arguments will be formatted according to the specified format string).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::fs</h1>
                
            
            <article>
                
<p class="calibre1">This module is used when using the filesystem and manipulating files.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module provides a set of cross-platform methods to manipulate the filesystem the application is sitting on. If at all possible, avoid using the </span><kbd class="calibre22">remove_dir_all</kbd><span class="chapterrefpackt"> function.</span></div>
<p class="calibre1"><span>Structs, Traits, and Enums</span></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">DirBuilder</kbd> (used to create directories), <kbd class="calibre10">DirEntry</kbd> (returned by the <kbd class="calibre10">ReadDir</kbd> iterator), File (opens a file on the filesystem), <kbd class="calibre10">FileType</kbd> (represents a type of file with accessors to each file type), <kbd class="calibre10">Metadata</kbd> (information about the file), <kbd class="calibre10">OpenOptions</kbd> (options and flags used to configure how a file is opened), <kbd class="calibre10">Permissions</kbd> (file permissions on a file), and <kbd class="calibre10">ReadDir</kbd> (an iterator over the entries in a directory).</li>
<li class="calibre13"><strong class="calibre8">Functions</strong>: <kbd class="calibre10">canonicalize</kbd> (returns the canonical form of a path), <kbd class="calibre10">copy</kbd> (copies files), <kbd class="calibre10">create_dir</kbd>, <kbd class="calibre10">create_dir_all</kbd> (recursively creates a directory and all parent components if missing), <kbd class="calibre10">hard_link</kbd> (creates a hard link on the file system), <kbd class="calibre10">metadata</kbd> (gets the metadata for a given path and file), <kbd class="calibre10">read_dir</kbd> (returns an iterator over the entries within a directory), <kbd class="calibre10">read_link</kbd> (reads a symbolic link returning the file it points to), <kbd class="calibre10">remove_dir</kbd> (removes an empty directory), <kbd class="calibre10">remove_dir_all</kbd> (removes a directory on a path recursively—on some operating systems this can completely delete your hard drive, so be careful!), <kbd class="calibre10">remove_file</kbd> (deletes a file), <kbd class="calibre10">rename</kbd> (renames a given file or directory), <kbd class="calibre10">set_permissions</kbd> (sets permissions on a given file or directory), and <kbd class="calibre10">symlink_metadata</kbd> (queries the metadata for a file without following any symlinks).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::hash</h1>
                
            
            <article>
                
<p class="calibre1">This module is used to provide hashing support.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module ensures that the easiest way to create a hash for a given type is to use </span><kbd class="calibre22">#[derive(Hash)]</kbd><span class="chapterrefpackt">.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">BuildHasherDefault</kbd> (implements <kbd class="calibre10">BuildHasher</kbd> for all Hasher types that also implement <kbd class="calibre10">Default</kbd>) and <kbd class="calibre10">SipHasher</kbd> (implementation of <kbd class="calibre10">SipHash</kbd>)</li>
<li class="calibre13"><strong class="calibre8">Traits</strong>: <kbd class="calibre10">BuildHasher</kbd>, <kbd class="calibre10">Hash</kbd>, and <kbd class="calibre10">Hasher</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::i8</h1>
                
            
            <article>
                
<p class="calibre1">This module defines the 8-bit integer type.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines the</span> <kbd class="calibre22">MAX</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">MIN</kbd> constants<span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::i16</h1>
                
            
            <article>
                
<p class="calibre1">This module defines the 16-bit integer type.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines the</span> <kbd class="calibre22">MAX</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">MIN</kbd> constants<span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::i32</h1>
                
            
            <article>
                
<p class="calibre1">This module defines the 32-bit integer type.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines the</span> <kbd class="calibre22">MAX</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">MIN</kbd> constants<span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::i64</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for working with the 64-bit integer type.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines the</span> <kbd class="calibre22">MAX</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">MIN</kbd> constants.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::io</h1>
                
            
            <article>
                
<p class="calibre1">This module provides a number of facilities for core input/output.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module provides code </span><kbd class="calibre22">Read</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">Write</kbd><span class="chapterrefpackt"> functionality for not only normal control, but also for various stream types (such as TCP and File). Access can be sequential or random. IO behavior also depends on the platform the application sits on, so testing is highly encouraged.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">BufReader</kbd> (adds buffering to any reader), <kbd class="calibre10">BufWriter</kbd> (buffers the writer output), <kbd class="calibre10">Bytes</kbd> (an iterator of values of a reader), <kbd class="calibre10">Chain</kbd> (chains two readers), <kbd class="calibre10">Cursor</kbd> (wraps another type and provides the Seek implementation), <kbd class="calibre10">Empty</kbd> (reader that is always at EOF), <kbd class="calibre10">Error</kbd> (error type for IO operations), <kbd class="calibre10">IntoInnerError</kbd> (error returned by <kbd class="calibre10">into_inner</kbd> that combines the error and buffered writer object, which may be recovered), <kbd class="calibre10">LineWriter</kbd> (wraps a writer and buffers into it), <kbd class="calibre10">Lines</kbd> (iterates over the lines of <kbd class="calibre10">BufRead</kbd>), <kbd class="calibre10">Repeat</kbd> (reader that continually returns a byte), <kbd class="calibre10">Sink</kbd> (writer that moves data to null), <kbd class="calibre10">Split</kbd> (an iterator over the contents of <kbd class="calibre10">BufRead</kbd> split at a point), <kbd class="calibre10">Stderr</kbd> (a handle for the process standard error stream), <kbd class="calibre10">StdErrLock</kbd> (locked ref. to <kbd class="calibre10">Stderr</kbd>), <kbd class="calibre10">Stdin</kbd> (standard input stream), <kbd class="calibre10">StdinLock</kbd> (locked ref. to <kbd class="calibre10">Stdin</kbd>), <kbd class="calibre10">Stdout</kbd> (global output stream), <kbd class="calibre10">StdoutLock</kbd> (locked ref. to <kbd class="calibre10">Stdout</kbd>), and <kbd class="calibre10">Take</kbd> (limits the bytes read from the reader).</li>
<li class="calibre13"><strong class="calibre8">Enums</strong>: <kbd class="calibre10">ErrorKind</kbd> and <kbd class="calibre10">SeekFrom</kbd>.</li>
<li class="calibre13"><strong class="calibre8">Traits</strong>: <kbd class="calibre10">BufRead</kbd> (buffered input read), <kbd class="calibre10">Read</kbd> (reads bytes from source), <kbd class="calibre10">Seek</kbd> (provides cursor that can be moved within the stream), and <kbd class="calibre10">Write</kbd>.</li>
<li class="calibre13"><strong class="calibre8">Functions</strong>: <kbd class="calibre10">copy</kbd> (copies contents of reader to writer), <kbd class="calibre10">empty</kbd> (new handle to an empty reader), <kbd class="calibre10">repeat</kbd> (creates an instance of reader that repeats 1 byte forever), <kbd class="calibre10">sink</kbd> (an instance of the writer that consumes all data), <kbd class="calibre10">stderr</kbd> (a new handle to <kbd class="calibre10">stderr</kbd>), <kbd class="calibre10">stdin</kbd> (a new handle to <kbd class="calibre10">stdin</kbd>), and <kbd class="calibre10">stdout</kbd> (a new handle to <kbd class="calibre10">stdout</kbd>).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::isize</h1>
                
            
            <article>
                
<p class="calibre1">This module is for use with the pointer-sized integer type.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines the</span> <kbd class="calibre22">MAX</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">MIN</kbd> constants<span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::iter</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for iteration.</p>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">Chain</kbd> (strings two iterators together), <kbd class="calibre10">Cloned</kbd> (clones the underlying iterator), <kbd class="calibre10">Cycle</kbd> (never-ending iterator), <kbd class="calibre10">Empty</kbd> (yields nothing), <kbd class="calibre10">Enumerate</kbd> (yields the current count and element while iterating), <kbd class="calibre10">Filter</kbd> (filters the elements of <kbd class="calibre10">iter</kbd> with predicate), <kbd class="calibre10">FilterMap</kbd> (iterator that uses a type for both filter and map from <kbd class="calibre10">iter</kbd>), <kbd class="calibre10">FlatMap</kbd> (maps each element to the iterator, yields the elements produced), <kbd class="calibre10">Fuse</kbd> (yields <kbd class="calibre10">None</kbd> continually once the underlying iterator first iterates <kbd class="calibre10">None</kbd>), <kbd class="calibre10">Inspect</kbd> (calls a function with a reference to each element before yielding it), <kbd class="calibre10">Map</kbd> (maps the values of <kbd class="calibre10">iter</kbd> with a type), <kbd class="calibre10">Once</kbd> (yields an element once), <kbd class="calibre10">Peekable</kbd> (allows <kbd class="calibre10">peek()</kbd> to be used), <kbd class="calibre10">Repeat</kbd> (repeats an element forever), <kbd class="calibre10">Rev</kbd> (double ended iterator with the read direction reversed), <kbd class="calibre10">Scan</kbd> (maintains state while iterating another iterator), <kbd class="calibre10">Skip</kbd> (skips <em class="calibre9">n</em> elements of <kbd class="calibre10">iter</kbd>), <kbd class="calibre10">SkipWhile</kbd> (rejects elements while predicate is true), <kbd class="calibre10">Take</kbd> (only iterates over the first <em class="calibre9">n</em> of <kbd class="calibre10">iter</kbd>), <kbd class="calibre10">TakeWhile</kbd> (only accepts elements to iterate over while the predicate is true), and <kbd class="calibre10">Zip</kbd> (iterates two iterators simultaneously).</li>
<li class="calibre13"><span><strong class="calibre8">Traits</strong>: </span><kbd class="calibre10">DoubleEndedIterator</kbd><span> (yields the elements at both ends), </span><kbd class="calibre10">ExactSizeIterator</kbd><span> (exact length known), </span><kbd class="calibre10">Extend</kbd><span> (extends a collection with the contents of an iterator), </span><kbd class="calibre10">FromIterator</kbd><span> (converts from </span><kbd class="calibre10">Iterator</kbd><span>), </span><kbd class="calibre10">ToIterator</kbd><span> (converts into </span><kbd class="calibre10">Iterator</kbd><span>), and </span><kbd class="calibre10">Iterator</kbd><span> (interface for dealing with iterators).</span></li>
<li class="calibre13"><strong class="calibre8">Functions</strong>: <kbd class="calibre10">empty</kbd> (new iterator that yields nothing), <kbd class="calibre10">once</kbd> (new iterator that yields an element once), and <kbd class="calibre10">repeat</kbd> (new iterator that continually repeats a single element).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::marker</h1>
                
            
            <article>
                
<p class="calibre1">This module provides primitive traits and markers to represent basic kinds of type.</p>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Struct</strong>: <kbd class="calibre10">PhantomData</kbd> (allows the description of type <kbd class="calibre10">T</kbd>).</li>
<li class="calibre13"><strong class="calibre8">Traits</strong>: <kbd class="calibre10">Copy</kbd> (types that can be copied), <kbd class="calibre10">Send</kbd> (types that can be transferred across threads), <kbd class="calibre10">Sized</kbd> (types with a constant size), and <kbd class="calibre10">Sync</kbd> (types that can be safely shared between threads).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::mem</h1>
                
            
            <article>
                
<p class="calibre1">This module performs memory handling functions.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module is used to query size and alignment types, initialization, and the manipulation of memory.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><span><strong class="calibre8">Functions</strong>: </span><kbd class="calibre10">align_of</kbd><span> (returns alignment in memory of type), </span><kbd class="calibre10">align_of_val</kbd><span> (minimum alignment of type of value </span><kbd class="calibre10">val</kbd><span> points to), </span><kbd class="calibre10">drop</kbd><span> (disposes), </span><kbd class="calibre10">forget</kbd><span> (leaves a value to void, takes ownership but doesn't run the destructor), </span><kbd class="calibre10">replace</kbd><span> (replaces the value at a </span><kbd class="calibre10">mut</kbd><span> location with a new one, returns the old value but doesn't de-initialize or copy either one), </span><kbd class="calibre10">size_of</kbd><span> (returns size of type in bytes), </span><kbd class="calibre10">size_of_val</kbd><span> (returns the size of a value in bytes), </span><kbd class="calibre10">swap</kbd><span> (swaps the values of two mut locations; must be of the same type), </span><kbd class="calibre10">transmute</kbd><span> (unsafely transforms a value of one type into another), </span><kbd class="calibre10">transmute_copy</kbd><span> (interprets <kbd class="calibre10">src</kbd> as </span><kbd class="calibre10">&amp;T</kbd><span>, then reads <kbd class="calibre10">src</kbd> without moving the contained value), </span><kbd class="calibre10">uninitialized</kbd><span> (bypasses Rust's memory initialization requirement), and </span><kbd class="calibre10">zeroed</kbd><span> (creates a value initialized to zero).</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std:net</h1>
                
            
            <article>
                
<p class="calibre1">This module provides basic TCP/UDP communication primitives.</p>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">AddrParseError</kbd> (error returned when parsing an IP or socket address), <kbd class="calibre10">Incoming</kbd> (infinite iterator over connections from <kbd class="calibre10">TcpListener</kbd>), <kbd class="calibre10">Ipv4Addr</kbd> (represents an IPv4 address), <kbd class="calibre10">Ipv6Addr</kbd> (represents an IPv6 address), <kbd class="calibre10">SocketAddrV4</kbd> (IPv4 socket address), <kbd class="calibre10">SocketAddrV6</kbd> (IPv6 socket address), <kbd class="calibre10">TcpListener</kbd> (represents a socket server), <kbd class="calibre10">TcpStream</kbd> (represents a TCP stream between the local and remote sockets), and <kbd class="calibre10">UdpSocket</kbd> (UDP socket).</li>
<li class="calibre13"><strong class="calibre8">Enums</strong>: <kbd class="calibre10">IpAddr</kbd> (either an IPv4 or IPv6 address), <kbd class="calibre10">Shutdown</kbd> (values passed to the shutdown method of <kbd class="calibre10">TcpStream</kbd>), and <kbd class="calibre10">SocketAddr</kbd> (socket address for networking applications).</li>
<li class="calibre13"><strong class="calibre8">Trait</strong>: <kbd class="calibre10">ToSocketAddrs</kbd> (object that can be converted to or resolved from one or more <kbd class="calibre10">SocketAddr</kbd> values).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::num</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for dealing with numbers.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module provides extra types that are useful for dealing with numbers.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums </strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">ParseFloatError</kbd> (error returned when parsing a <kbd class="calibre10">float</kbd>), <kbd class="calibre10">ParseIntError</kbd> (error returned when parsing an <kbd class="calibre10">int</kbd>), and <kbd class="calibre10">Wrapping</kbd> (intentionally-wrapped arithmetic on <kbd class="calibre10">T</kbd>).</li>
<li class="calibre13"><strong class="calibre8">Enum</strong>: <kbd class="calibre10">FpCategory</kbd> (classification of floating point numbers).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::os</h1>
                
            
            <article>
                
<p class="calibre1">This module contains functions that provide abstracted access to the OS the application is running on.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module contains three modules:</span> <kbd class="calibre22">linux</kbd><span class="chapterrefpackt"> (Linux-specific), </span><kbd class="calibre22">raw</kbd><span class="chapterrefpackt"> (raw OS-specific types for current platform), and </span><kbd class="calibre22">unix</kbd><span class="chapterrefpackt"> (experimental extension).</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::panic</h1>
                
            
            <article>
                
<p class="calibre1">This module provides support for panic within the standard library.</p>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">AssertUnwindSafe</kbd> (checks whether a type is panic-safe), <kbd class="calibre10">Location</kbd> (information about the panic location), and <kbd class="calibre10">PanicInfo</kbd> (information about the panic).</li>
<li class="calibre13"><strong class="calibre8">Traits</strong>: <kbd class="calibre10">RefUnwindSafe</kbd> (trait that represents types where the shared ref is considered <kbd class="calibre10">recovery</kbd> safe) and <kbd class="calibre10">UnwindSafe</kbd> (trait that represents panic-safe types in Rust).</li>
<li class="calibre13"><strong class="calibre8">Functions</strong>: <kbd class="calibre10">catch_unwind</kbd> (invokes a closure, captures the cause of the unwind), <kbd class="calibre10">resume_unwind</kbd> (triggers a panic without invoking the panic), <kbd class="calibre10">set_hook</kbd> (registers a custom panic hook and replaces previous hooks), and <kbd class="calibre10">take_hook</kbd> (unregisters a current panic hook).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::path</h1>
                
            
            <article>
                
<p class="calibre1">This module provides abstracted access to the path in a cross-platform way for manipulation.</p>
<div class="packt_infobox"><span class="chapterrefpackt">Two types are provided, </span><kbd class="calibre22">PathBuf</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">Path</kbd><span class="chapterrefpackt">. These are wrappers around </span><kbd class="calibre22">OsString</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">OsStr</kbd><span class="chapterrefpackt"> and allow direct work to be performed on strings according to the local platform path.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">Components</kbd> (core iterator giving the parts of a path), <kbd class="calibre10">Display</kbd> (for safely printing paths with <kbd class="calibre10">format!()</kbd> and <kbd class="calibre10">{}</kbd>), <kbd class="calibre10">Iter</kbd> (iterator over the parts of a path), <kbd class="calibre10">Path</kbd> (slice of a path), <kbd class="calibre10">PathBuf</kbd> (owned mutable path), <kbd class="calibre10">PrefixComponent</kbd> (Windows-specific path prefix), and <kbd class="calibre10">StripPrefixError</kbd> (error returned from the <kbd class="calibre10">Path::strip_prefix</kbd> method indicating the prefix was not found in self).</li>
<li class="calibre13"><strong class="calibre8">Enums</strong>: <kbd class="calibre10">Component</kbd> (single component of a path) and <kbd class="calibre10">Prefix</kbd> (path prefix [Windows only]).</li>
<li class="calibre13"><strong class="calibre8">Function</strong>: <kbd class="calibre10">is_separator</kbd> (determines whether the character is one of the permitted path separators).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::process</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for working with processes.</p>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">Child</kbd> (represents a running or exited child process), <kbd class="calibre10">ChildStderr</kbd> (handle to a child process stderr), <kbd class="calibre10">ChildStdin</kbd> (handle child process stdin), <kbd class="calibre10">ChildStdout</kbd> (handle for child process stdout), <kbd class="calibre10">Command</kbd> (acts as a process builder), <kbd class="calibre10">ExitStatus</kbd> (describes the result of a process after it is terminated), <kbd class="calibre10">Output</kbd> (output of finished process), and <kbd class="calibre10">Stdio</kbd> (describes what to do with the standard IO stream for a child process).</li>
<li class="calibre13"><strong class="calibre8">Function</strong>: <kbd class="calibre10">exit</kbd> (terminates current process with exit code).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::ptr</h1>
                
            
            <article>
                
<p class="calibre1">This module provides access for handling raw, unsafe pointers.</p>
<div class="packt_infobox"><span class="chapterrefpackt">See <a href="part0106.html#352RK0-a5175cb437d742a9aed0ea574000ee2d" class="calibre42">Chapter 5</a>, <em class="calibre23">Remember, Remember</em>, for more details.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<p class="calibre1"><span><strong class="calibre8">Functions</strong>: </span><kbd class="calibre10">copy</kbd><span> (copies </span><kbd class="calibre10">count * size_of&lt;T&gt;</kbd><span> from </span><kbd class="calibre10">src</kbd><span> to </span><kbd class="calibre10">dest</kbd><span>; can overlap), </span><kbd class="calibre10">copy_nonoverlapping</kbd><span> (same as </span><kbd class="calibre10">copy</kbd><span>, except cannot overlap), </span><kbd class="calibre10">drop_in_place</kbd><span> (executes destructor of the pointed-to value), </span><kbd class="calibre10">null</kbd><span> (new null raw pointer), </span><kbd class="calibre10">null_mut</kbd><span> (new null mutable raw pointer), </span><kbd class="calibre10">read</kbd><span> (reads value from </span><kbd class="calibre10">src</kbd><span> without moving it), </span><kbd class="calibre10">read_volatile</kbd><span> (volatile read of the value from </span><kbd class="calibre10">src</kbd><span> without moving it), </span><kbd class="calibre10">replace</kbd><span> (replaces value at </span><kbd class="calibre10">dest</kbd><span> with </span><kbd class="calibre10">src</kbd><span>, returning the old value), </span><kbd class="calibre10">swap</kbd><span> (swaps the values at two mutable locations of the same type), </span><kbd class="calibre10">write</kbd><span> (overwrites the memory location with the value without reading or dropping the old value), </span><kbd class="calibre10">write_bytes</kbd><span> (invokes </span><kbd class="calibre10">memset</kbd><span> on the specified pointer), and </span><kbd class="calibre10">write_volatile</kbd><span> (performs a volatile write of a memory location with a given value).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::slice</h1>
                
            
            <article>
                
<p class="calibre1">This module provides a dynamically-sized placement into a contiguous <kbd class="calibre10">[T]</kbd>.</p>
<div class="packt_infobox"><span class="chapterrefpackt">Slices are mutable (</span><kbd class="calibre22">&amp;mut [T]</kbd><span class="chapterrefpackt">) or shared slices (</span><kbd class="calibre22">&amp;[T]</kbd><span class="chapterrefpackt">) of memory represented as a pointer. They implement </span><kbd class="calibre22">IntoIter</kbd><span class="chapterrefpackt">, which duplicates the type </span><kbd class="calibre22">IntoIter</kbd><span class="chapterrefpackt"> is being performed on.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">Chunks</kbd> (iterates over a non-overlapping slice in chunks of <kbd class="calibre10">size_of&lt;T&gt;</kbd> elements at a time), <kbd class="calibre10">ChunksMut</kbd> (as for <kbd class="calibre10">Chunks</kbd> except are mutable), <kbd class="calibre10">Iter</kbd> (immutable iterator), <kbd class="calibre10">IterMut</kbd> (mutable iterator), <kbd class="calibre10">RSplitN</kbd> and <kbd class="calibre10">RSplitNMut</kbd> (iterate over sub-slices that match a predicate, limited to a given number of splits, and start from the end of the slice). <kbd class="calibre10">Split</kbd> and <kbd class="calibre10">SplitMut</kbd> (iterator over sub-slice separated by elements that match a predicate function or predicate respectively), and <kbd class="calibre10">SplitN</kbd> and <kbd class="calibre10">SplitNMut</kbd> (iterate over sub-slices that match predicate function), and <kbd class="calibre10">Windows</kbd> (iterates over overlapping sub-slice of length <kbd class="calibre10">size_of&lt;T&gt;</kbd>).</li>
<li class="calibre13"><span><strong class="calibre8">Functions</strong>: </span><kbd class="calibre10">from_raw_parts</kbd><span> (forms a slice from a pointer and length) and </span><kbd class="calibre10">from_raw_parts_mut</kbd><span> (as </span><kbd class="calibre10">from_raw_parts</kbd><span> except the slice returned is mutable).</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::str</h1>
                
            
            <article>
                
<p class="calibre1">This module is used for Unicode string slices.</p>
<p class="calibre1"><span><strong class="calibre8">Structs, Traits, and Enums</strong></span></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">Bytes</kbd> (iterator for a strings bytes), <kbd class="calibre10">CharIndices</kbd> (iterator for a string's characters and byte offsets), <kbd class="calibre10">Chars</kbd> (iterator for the char of a string), <kbd class="calibre10">EncodeUtf16</kbd> (external iterator for a string's UTF16 code), <kbd class="calibre10">Lines</kbd> (created with <kbd class="calibre10">lines()</kbd>), <kbd class="calibre10">MatchIndices</kbd> (created with <kbd class="calibre10">match_indices()</kbd>), <kbd class="calibre10">Matches</kbd> (created with <kbd class="calibre10">matches()</kbd>), <kbd class="calibre10">ParseBoolError</kbd> (error returned when passing a <kbd class="calibre10">bool</kbd> from a string fail), <kbd class="calibre10">RMatchIndicies</kbd> (created with <kbd class="calibre10">rmatch_indicies()</kbd>), <kbd class="calibre10">RMatches</kbd> (created with <kbd class="calibre10">rmatches()</kbd>), <kbd class="calibre10">RSplit</kbd> (created with <kbd class="calibre10">rsplit()</kbd>), <kbd class="calibre10">RSplitN</kbd> (created with <kbd class="calibre10">rsplitn()</kbd>), <kbd class="calibre10">RSplitTerminator</kbd> (created with <kbd class="calibre10">rsplit_terminator()</kbd>), <kbd class="calibre10">Split</kbd> (created with <kbd class="calibre10">split()</kbd>), <kbd class="calibre10">SplitN</kbd> (created with <kbd class="calibre10">splitn()</kbd>), <kbd class="calibre10">SplitTerminator</kbd> (created with <kbd class="calibre10">split_terminator()</kbd>), <kbd class="calibre10">SplitWhitespace</kbd> (iterates over the non-whitespace substrings of a string), and <kbd class="calibre10">Utf8Error</kbd> (error that can occur when attempting to interpret a sequence of <kbd class="calibre10">u8</kbd> as a string)</li>
<li class="calibre13"><span><strong class="calibre8">Trait</strong>: </span><kbd class="calibre10">FromStr</kbd><span> (abstracts the idea of creating a new instance of a type from a string)</span></li>
<li class="calibre13"><strong class="calibre8">Functions</strong>: <kbd class="calibre10">from_utf8</kbd> (converts a slice of bytes to a string slice) and <kbd class="calibre10">from_utf8_unchecked</kbd> (as with <kbd class="calibre10">from_utf8</kbd> without checking the string contains valid UTF8)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::string</h1>
                
            
            <article>
                
<p class="calibre1">This module provides string handling with a UTF-8 encoded growable string.</p>
<div class="packt_infobox"><span class="chapterrefpackt">Contains the String type and a trait to convert to a String (</span><kbd class="calibre22">ToString</kbd><span class="chapterrefpackt">) as well as error types.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">Drain</kbd> (draining iterator), <kbd class="calibre10">FromUtf16Error</kbd> (possible error value when converting from a UTF16 slice), and <kbd class="calibre10">FromUtf8Error</kbd> (as for <kbd class="calibre10">FromUtf16Error</kbd> except for UTF8), and <kbd class="calibre10">String</kbd> (UTF8-encoded growing string).</li>
<li class="calibre13"><strong class="calibre8">Enum</strong>: <kbd class="calibre10">ParseError</kbd>.</li>
<li class="calibre13"><strong class="calibre8">Trait</strong>: <kbd class="calibre10">ToString</kbd> (converts a value to a string).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::sync</h1>
                
            
            <article>
                
<p class="calibre1">This module provides thread synchronization functions.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This is covered in </span><span class="chapterrefpackt"><a href="part0265.html#7SN520-a5175cb437d742a9aed0ea574000ee2d" class="calibre42">Chapter 11</a>, <em class="calibre23">Concurrency in Rust</em></span><span class="chapterrefpackt">.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">Arc</kbd> (atomic ref counted wrapper), <kbd class="calibre10">Barrier</kbd> (enables multiple threads to synchronize the beginning of some computation), <kbd class="calibre10">BarrierWaitResult</kbd> (result from a thread wait), <kbd class="calibre10">Condvar</kbd> (CONDitional VARiable), <kbd class="calibre10">Mutex</kbd> (mutual exclusion primitive), <kbd class="calibre10">MutexGuard</kbd> (scoped lock mutex; becomes unlocked when the structure goes out of scope), <kbd class="calibre10">Once</kbd> (sync primitive used to run a one-time global initialization), <kbd class="calibre10">PoisonError</kbd> (error that can be returned when a lock is required), <kbd class="calibre10">RwLock</kbd> (read/write lock), <kbd class="calibre10">RWLockReadGuard</kbd> (used to release shared read access to a lock when dropped), <kbd class="calibre10">RWWriteGuard</kbd> (used to release shared write access if a lock when dropped), <kbd class="calibre10">WaitTimeoutResult</kbd> (type used to determine whether a condition variable timed out or not), and <kbd class="calibre10">Weak</kbd> (weak pointer to <kbd class="calibre10">Arc</kbd>).</li>
<li class="calibre13"><strong class="calibre8">Enum</strong>: <kbd class="calibre10">TryLockError</kbd> (errors that may occur when calling <kbd class="calibre10">try_lock</kbd>).</li>
</ul>
<div class="packt_infobox"><span class="chapterrefpackt">See the code examples in </span><span class="chapterrefpackt"><a href="part0265.html#7SN520-a5175cb437d742a9aed0ea574000ee2d" class="calibre42">Chapter 11</a>, <em class="calibre23">Concurrency in Rust</em></span><span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::thread</h1>
                
            
            <article>
                
<p class="calibre1">This is the main threading module, providing native threads to your Rust application.</p>
<div class="packt_infobox"><span class="chapterrefpackt">Threading is covered in </span><span class="chapterrefpackt"><a href="part0265.html#7SN520-a5175cb437d742a9aed0ea574000ee2d" class="calibre42">Chapter 11</a>, <em class="calibre23">Concurrency in Rust</em></span><span class="chapterrefpackt">.</span></div>
<p class="calibre1"><span><strong class="calibre8">Structs, Traits, and Enums</strong><br class="calibre2"/></span></p>
<ul class="calibre12">
<li class="calibre13"><strong class="calibre8">Structs</strong>: <kbd class="calibre10">Builder</kbd> (provides detailed control over new threads), <kbd class="calibre10">JoinHandle</kbd> (owned permission to join on a thread), <kbd class="calibre10">LocalKey</kbd> (key to local storage that owns the contents), and <kbd class="calibre10">Thread</kbd> (handle to thread).</li>
<li class="calibre13"><span><strong class="calibre8">Functions</strong>: </span><kbd class="calibre10">current</kbd><span> (get handle to the thread invocation), </span><kbd class="calibre10">panicking</kbd><span> (if the thread is unwinding due to a panic), </span><kbd class="calibre10">park</kbd><span> (blocks unless or until the token is available), </span><kbd class="calibre10">park_timeout</kbd><span> (blocks for a duration), and </span><kbd class="calibre10">sleep</kbd><span> (puts the current thread to sleep for a duration), </span><kbd class="calibre10">spawn</kbd><span> (spawns a new thread, returns a </span><kbd class="calibre10">JoinHandle</kbd><span>), and </span><kbd class="calibre10">yield_now</kbd><span> (gives up a timeslice to the OS scheduler).</span></li>
</ul>
<div class="packt_infobox"><span class="chapterrefpackt">See the code examples in </span><span class="chapterrefpackt"><a href="part0265.html#7SN520-a5175cb437d742a9aed0ea574000ee2d" class="calibre42">Chapter 11</a>, <em class="calibre23">Concurrency in Rust</em></span><span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::time</h1>
                
            
            <article>
                
<p class="calibre1">This is a module for handling time.</p>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<p class="calibre1"><span><strong class="calibre8">Structs</strong>: </span><kbd class="calibre10">Duration</kbd><span> (represents a span of time), </span><kbd class="calibre10">Instant</kbd><span> (measurement of a monotonically increasing clock), </span><kbd class="calibre10">SystemTime</kbd><span> (measures the system clock), and </span><kbd class="calibre10">SystemTimeError</kbd><span> (error returned from </span><kbd class="calibre10">SystemTime.duration_since()</kbd><span>).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::u8</h1>
                
            
            <article>
                
<p class="calibre1">This module defines the unsigned 8-bit integer type.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines the</span> <kbd class="calibre22">MAX</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">MIN</kbd> constants.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::u16</h1>
                
            
            <article>
                
<p class="calibre1">This module defines the unsigned 16-integer type.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines the</span> <kbd class="calibre22">MAX</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">MIN</kbd> constants.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::u32</h1>
                
            
            <article>
                
<p class="calibre1">This module defines the unsigned 32-bit integer type.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines the</span> <kbd class="calibre22">MAX</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">MIN</kbd> <span class="chapterrefpackt">constants</span><span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::u64</h1>
                
            
            <article>
                
<p class="calibre1">This module defines the unsigned 64-bit integer type.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines the</span> <kbd class="calibre22">MAX</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">MIN</kbd> <span class="chapterrefpackt">constants</span><span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::usize</h1>
                
            
            <article>
                
<p class="calibre1">This is the pointer-sized unsigned integer type.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This module defines the</span> <kbd class="calibre22">MAX</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">MIN</kbd> constants<span class="chapterrefpackt">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">std::vec</h1>
                
            
            <article>
                
<p class="calibre1">This module defines the growable array type with heap-allocated contents.</p>
<div class="packt_infobox"><span class="chapterrefpackt">This is written as </span><kbd class="calibre22">Vec&lt;T&gt;</kbd><span class="chapterrefpackt">, and values are added to (or removed from) the end of the </span><kbd class="calibre22">vec</kbd><span class="chapterrefpackt"> using </span><kbd class="calibre22">push</kbd><span class="chapterrefpackt"> and </span><kbd class="calibre22">pull</kbd><span class="chapterrefpackt">, respectively.</span></div>
<p class="calibre1"><strong class="calibre8">Structs, Traits, and Enums</strong></p>
<p class="calibre1"><span><strong class="calibre8">Structs</strong>: </span><kbd class="calibre10">Drain</kbd><span> (draining iterator for </span><kbd class="calibre10">Vec&lt;T&gt;</kbd><span>), </span><kbd class="calibre10">IntoIter</kbd><span> (iterator that moves out of a vector), and </span><kbd class="calibre10">Vec</kbd><span> (contiguous growable array type).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1">We have covered a sizable portion of the Rust standard library. Always check the official documentation online at <a href="https://doc.rust-lang.org/std/" class="calibre3"><span>https://doc.rust-lang.org/std/</span></a>—it is of an exceptionally high quality and always up-to-date!</p>
<p class="calibre1">In the next and last chapter, we will take a look at using external libraries from Rust via its <strong class="calibre8">Foreign Function Interface</strong> (<strong class="calibre8">FFI</strong>).</p>
<p class="calibre1"/>
<p class="calibre1"/>


            </article>

            
        </section>
    </body></html>