- en: '*Chapter 2*: Building Our First Rocket Web Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*: 构建我们的第一个 Rocket Web 应用程序'
- en: In this chapter, we're going to explore Rocket, a framework to create web applications
    using the Rust programming language. We will learn a little bit about Rocket before
    we create our first web application using the Rocket framework. After that, we
    will learn how to configure our Rocket web application. Finally, we will explore
    how to get help for this web framework at the end of this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Rocket，这是一个使用 Rust 编程语言创建 Web 应用程序的框架。在我们使用 Rocket 框架创建第一个 Web 应用程序之前，我们将对
    Rocket 有一些了解。之后，我们将学习如何配置我们的 Rocket Web 应用程序。最后，在本章末尾，我们将探讨如何获取这个 Web 框架的帮助。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing Rocket – a web framework written in the Rust language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Rocket – 使用 Rust 语言编写的 Web 框架
- en: Creating our first Rocket web application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Rocket Web 应用程序
- en: Configuring our Rocket web application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置我们的 Rocket Web 应用程序
- en: Getting help
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取帮助
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this and subsequent chapters, you will need to have the requirements mentioned
    in [*Chapter 1*](B16825_01_ePub.xhtml#_idTextAnchor014), *Introducing the Rust
    Language*, and the Rust toolchain installed. If you still don't have the Rust
    compiler toolchain installed, please follow the installation guide in [*Chapter
    1*](B16825_01_ePub.xhtml#_idTextAnchor014), *Introducing the Rust Language*. Also,
    it would be helpful to have a text editor with a Rust extension installed and
    Rust tools such as `rustfmt` or `clippy`. If you don't have a text editor installed
    already, you can use open source software such as Visual Studio Code with the
    `rust-analyzer` extension. As we're going to make HTTP requests to the application
    that we're going to create, you should have a web browser or other HTTP client
    installed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章和随后的章节，你需要安装在 [*第一章*](B16825_01_ePub.xhtml#_idTextAnchor014) 中提到的要求，即 *介绍
    Rust 语言* 和 Rust 工具链。如果你还没有安装 Rust 编译器工具链，请遵循 *第一章* 中提到的安装指南，即 *介绍 Rust 语言*。此外，安装一个带有
    Rust 扩展的文本编辑器以及 Rust 工具如 `rustfmt` 或 `clippy` 会很有帮助。如果你还没有安装文本编辑器，可以使用带有 `rust-analyzer`
    扩展的 Visual Studio Code 等开源软件。由于我们将向我们要创建的应用程序发出 HTTP 请求，你应该安装一个网络浏览器或其他 HTTP 客户端。
- en: Finally, the Rocket framework has a few releases, all of which are slightly
    different. We will only be discussing Rocket *0.5.0*. Don't worry if you are planning
    to use a different version of Rocket, as the terminology and concepts are almost
    the same. Use the API documentation mentioned in the *Getting help* section of
    this chapter to see the correct documentation for your Rocket framework version.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Rocket 框架有几个版本发布，它们都略有不同。我们只会讨论 Rocket *0.5.0* 版本。如果你计划使用 Rocket 的其他版本，请不要担心，因为术语和概念几乎相同。你可以使用本章
    *获取帮助* 部分中提到的 API 文档来查看你使用的 Rocket 框架版本的正确文档。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter02](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter02](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter02)
    找到。
- en: Introducing Rocket – a web framework written in the Rust language
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Rocket – 使用 Rust 语言编写的 Web 框架
- en: The development of the Rocket web framework began as a project of Sergio Benitez
    in 2016\. For a long time, it was being created with a lot of Rust macrosystems
    to simplify the development process; because of this, a stable Rust compiler could
    not be used until recently, in 2021\. During the development process, async/await
    capabilities were added to Rust. Rocket began to incorporate async/await until
    the issue tracker for it closed in 2021.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket Web 框架的开发始于 2016 年 Sergio Benitez 的一个项目。长期以来，它一直使用大量的 Rust 宏系统来简化开发过程；因此，直到最近
    2021 年，才可以使用稳定的 Rust 编译器。在开发过程中，Rust 添加了 async/await 功能。Rocket 开始整合 async/await，直到
    2021 年关闭了相关的问题跟踪器。
- en: Rocket is a fairly simple web framework without many bells and whistles, such
    as database **Object-relational mapping** (**ORM**) or mailing systems. Programmers
    can extend Rocket's capabilities using other Rust crates, for example, by adding
    third-party logging or connecting to memory store applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket 是一个相当简单的 Web 框架，没有很多花哨的功能，例如数据库 **对象关系映射**（ORM）或邮件系统。程序员可以使用其他 Rust 包扩展
    Rocket 的功能，例如，通过添加第三方日志记录或连接到内存存储应用程序。
- en: The HTTP request life cycle in Rocket
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rocket 中的 HTTP 请求生命周期
- en: Handling HTTP requests is an integral part of web applications. The Rocket web
    framework treats incoming HTTP requests as a life cycle. The first thing the web
    application does is checks and determines which function or functions will be
    able to handle the incoming request. This part is called **routing**. For example,
    if there's a *GET/something* incoming request, Rocket will check all the registered
    routes for matches.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 HTTP 请求是网络应用的一个基本组成部分。Rocket 网络框架将传入的 HTTP 请求视为一个生命周期。网络应用首先要做的是检查并确定哪个或哪些函数能够处理传入的请求。这部分称为**路由**。例如，如果有一个
    *GET/something* 传入请求，Rocket 将检查所有已注册的路由以查找匹配项。
- en: After routing, Rocket will perform the **validation** of the incoming request
    against types and guards declared in the first function. If the result does not
    match and the next route handling function is available, Rocket will continue
    validation against the next function until there are no more functions available
    to handle that incoming request.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由之后，Rocket 将对传入请求进行**验证**，以检查与第一个函数中声明的类型和守卫是否匹配。如果结果不匹配且下一个处理传入请求的函数可用，Rocket
    将继续对下一个函数进行验证，直到没有更多函数可以处理该传入请求。
- en: After validation, Rocket will then **process** with what the programmer wrote
    in the body of the function. For example, a programmer creates a SQL query with
    the data from the request, sends the query to the database, retrieves the result
    from the database, and creates an HTML using the result.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 验证后，Rocket 将根据程序员在函数体中编写的代码进行**处理**。例如，程序员使用请求中的数据创建一个 SQL 查询，将查询发送到数据库，从数据库检索结果，并使用结果创建
    HTML。
- en: Rocket will finally return a **response**, which contains the HTTP status, headers,
    and body. The request life cycle is then complete.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket 最后将返回一个**响应**，其中包含 HTTP 状态、头和主体。请求生命周期随后完成。
- en: To recap, the life cycle of a Rocket request is **Routing → Validation → Processing
    → Response**. Next, let's discuss how the Rocket application starts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Rocket 请求的生命周期是**路由 → 验证 → 处理 → 响应**。接下来，让我们讨论 Rocket 应用程序的启动方式。
- en: Rocket launch sequence
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rocket 发射序列
- en: Like a real-life rocket, we start by building the Rocket application. In the
    building process, we mount the **routes** (functions that handle incoming requests)
    to the Rocket application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 就像现实生活中的火箭一样，我们首先构建 Rocket 应用程序。在构建过程中，我们将**路由**（处理传入请求的函数）挂载到 Rocket 应用程序上。
- en: In the building process, the Rocket application also manages various **states**.
    A state is a Rust object that can be accessed in a route handler. For example,
    let's say we want a logger that sends events to a logging server. We initialize
    the logger object when we build the Rocket application, and when there's an incoming
    request, we can use the already managed logger object in the request handler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，Rocket 应用程序还管理各种**状态**。状态是一个可以在路由处理程序中访问的 Rust 对象。例如，假设我们想要一个将事件发送到日志服务器的记录器。我们在构建
    Rocket 应用程序时初始化记录器对象，当有传入请求时，我们可以在请求处理程序中使用已管理的记录器对象。
- en: Still in the building process, we can also attach **fairings**. In many web
    frameworks, there is usually a middleware component that filters, inspects, authorizes,
    or modifies incoming HTTP requests or responses. In the Rocket framework, the
    function that provides middleware functionality is called a fairing. For example,
    if we want to have a **universally unique identifier** (**UUID**) for every HTTP
    request for audit purposes, we first create a fairing that generates a random
    UUID and appends it to the request HTTP header. We also make the fairing append
    the same UUID to the generated HTTP response. Next, we attach it to Rocket. This
    fairing will then intercept the incoming request and response and modify it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，我们还可以附加**整流罩**。在许多网络框架中，通常有一个中间件组件，用于过滤、检查、授权或修改传入的 HTTP 请求或响应。在 Rocket
    框架中，提供中间件功能的函数被称为整流罩。例如，如果我们想为每个 HTTP 请求创建一个用于审计的**通用唯一标识符**（**UUID**），我们首先创建一个生成随机
    UUID 并将其附加到请求 HTTP 头部的整流罩。我们还将整流罩附加到生成的 HTTP 响应中。接下来，我们将它附加到 Rocket 上。这个整流罩将拦截传入的请求和响应并进行修改。
- en: After the Rocket application is built and ready, the next step is, of course,
    launching it. Yay, the launch is successful! Now, our Rocket application is operational
    and ready to serve incoming requests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rocket 应用程序构建并准备就绪后，下一步当然是启动它。太好了，发射成功！现在，我们的 Rocket 应用程序已处于运行状态，准备好处理传入的请求。
- en: Now that we have an overview of the Rocket application, let's try creating a
    simple Rocket application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Rocket 应用程序有了总体了解，让我们尝试创建一个简单的 Rocket 应用程序。
- en: Creating our first Rocket web application
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Rocket Web 应用程序
- en: 'In this section, we are going to create a very simple web application that
    handles only one HTTP path. Follow these steps to create our first Rocket web
    application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个非常简单的 Web 应用程序，它只处理一个 HTTP 路径。按照以下步骤创建我们的第一个 Rocket Web 应用程序：
- en: 'Create a new Rust application using Cargo:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 创建一个新的 Rust 应用程序：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are creating an application named `hello_rocket` in a folder named `01hello_rocket`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个名为 `01hello_rocket` 的文件夹中创建了一个名为 `hello_rocket` 的应用程序。
- en: 'After that, let''s modify the `Cargo.toml` file. Add the following line after
    `[dependencies]`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，让我们修改 `Cargo.toml` 文件。在 `[dependencies]` 之后添加以下行：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Append the following lines at the top of the `src/main.rs` file:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 文件顶部追加以下行：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are telling the Rust compiler to use macros from the Rocket crate by
    using the `#[macro_use]` attribute. We can skip using that attribute, but that
    would mean we must specify `use` for every single macro that we are going to use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在告诉 Rust 编译器通过使用 `#[macro_use]` 属性来使用 Rocket crate 中的宏。我们可以省略使用该属性，但那样就意味着我们必须为将要使用的每个宏指定
    `use`。
- en: 'Add the following line to tell the compiler that we are using the definition
    from the Rocket crate:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下行以告知编译器我们正在使用来自 Rocket crate 的定义：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that, let''s create our first HTTP handler. Add the following lines after
    the preceding ones:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，让我们创建我们的第一个 HTTP 处理器。在前面几行之后添加以下行：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we define a function that returns a reference to a `str`. The `'a` in
    the Rust language means that a variable has a `'a` lifetime. The life span of
    a reference depends on many things. We will discuss these in [*Chapter 9*](B16825_09_ePub.xhtml#_idTextAnchor109),
    *Displaying User's Post*, when we discuss object scope and lifetime in more depth.
    But, a `'static` notation is special because it means that it will last as long
    as the application is still alive. We can also see that the return value is `"Hello,
    Rocket"` since it is the last line and we did not put a semicolon at the end.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了一个返回 `str` 引用的函数。Rust 语言中的 `'a` 表示一个变量具有 `'a` 生命周期。引用的生存期取决于许多因素。我们将在
    [*第 9 章*](B16825_09_ePub.xhtml#_idTextAnchor109) *显示用户帖子* 中讨论这些内容，当我们更深入地讨论对象作用域和生命周期时。但是，`'static`
    符号是特殊的，因为它意味着它将持续到应用程序仍然存活。我们还可以看到返回值是 `"Hello, Rocket"`，因为它是在最后一行，我们没有在末尾放置分号。
- en: 'But, what is the `#[get("/")]` attribute? Remember before when we used the
    `#[macro_use]` attribute? The `rocket::get` attribute is a macro attribute that
    specifies the HTTP method a function handles, and the route, HTTP paths, and parameters
    it handles. There are seven method-specific route attributes that we can use:
    `get`, `put`, `post`, `delete`, `head`, `options`, and `patch`. All of them correspond
    to their respective HTTP method name.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`#[get("/")]` 属性是什么？记得之前我们使用过 `#[macro_use]` 属性吗？`rocket::get` 属性是一个宏属性，它指定了函数处理的
    HTTP 方法、路由、HTTP 路径和参数。我们可以使用七个特定方法的路由属性：`get`、`put`、`post`、`delete`、`head`、`options`
    和 `patch`。所有这些都与它们各自的 HTTP 方法名称相对应。
- en: 'We can also use alternate macros to specify route handlers by replacing the
    attribute macro with the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用替代宏来指定路由处理器，通过用以下内容替换属性宏：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, delete the `fn main()` function and add the following lines:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，删除 `fn main()` 函数并添加以下行：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have created a function that will generate the `main` function because we
    used the `#[launch]` attribute. Inside the function, we built the Rocket and mounted
    the routes that have an `index` function to the `"/"` path.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个函数来生成 `main` 函数，因为我们使用了 `#[launch]` 属性。在函数内部，我们构建了 Rocket 并将具有 `index`
    函数的路由挂载到 `"/"` 路径上。
- en: 'Let''s try running the `hello_rocket` application:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试运行 `hello_rocket` 应用程序：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see the application printed the application configuration, such as keep-alive
    timeout duration, request size limits, log level, routes, and many more that you
    typically see in an HTTP server to the terminal. After that, the application printed
    the various parts of the Rocket. We created a single-route `index` function, which
    handles `GET /`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到应用程序打印了应用程序配置，例如保持活动超时时间、请求大小限制、日志级别、路由等，这些通常在 HTTP 服务器中看到，到终端。之后，应用程序打印了
    Rocket 的各个部分。我们创建了一个单路由 `index` 函数，它处理 `GET /`。
- en: Then, there is the default built-in fairing, **Shield**. Shield works by injecting
    HTTP security and privacy headers to all responses by default.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有默认的内置公平性（Fairing），**Shield**。Shield 通过默认向所有响应注入 HTTP 安全性和隐私头来实现。
- en: We also see that the application was successfully launched and is now accepting
    requests on the address `127.0.0.1` and port `8000`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到应用程序已成功启动，现在正在`127.0.0.1`地址和`8000`端口上接受请求。
- en: 'Now, let''s test whether the application is really accepting requests. You
    can use a web browser or any HTTP client since it''s a very simple request, but
    if you use the command line, don''t stop the running application; open another
    terminal:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试应用程序是否真的在接收请求。您可以使用Web浏览器或任何HTTP客户端，因为这是一个非常简单的请求，但如果您使用命令行，请不要停止运行的应用程序；打开另一个终端：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see that the application responded perfectly. You can also see the
    log of the application:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到应用程序响应得非常完美。您还可以看到应用程序的日志：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s try requesting something that does not exist in our application:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试请求我们应用程序中不存在的东西：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s see what''s going on in the application terminal output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看应用程序终端输出中发生了什么：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now know that Rocket already has default handlers for `404` status situations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道Rocket已经为`404`状态情况提供了默认的处理程序。
- en: Let's recall the Rocket life cycle, *Routing → Validation → Processing → Response*.
    The first request to http://127`.0.0.1:8000/` was successful because the application
    found the handler for the `GET /` route. Since we didn't create any validation
    in the application, the function then performed some very simple processing, returning
    a string. The Rocket framework already implemented the `Responder` trait for `&str`,
    so it created and returned an appropriate HTTP response. The other request to
    `/somepath` did not pass the routing part, and we did not create any error handler,
    so the Rocket application returned a default error handler for this request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下Rocket的生命周期，*路由 → 验证 → 处理 → 响应*。对http://127.0.0.1:8000/的第一次请求是成功的，因为应用程序找到了`GET
    /`路由的处理程序。由于我们没有在应用程序中创建任何验证，该函数随后执行了一些非常简单的处理，返回了一个字符串。Rocket框架已经为`&str`实现了`Responder`特质，因此它创建并返回了适当的HTTP响应。对`/somepath`的另一个请求没有通过路由部分，我们没有创建任何错误处理程序，因此Rocket应用程序为这个请求返回了一个默认的错误处理程序。
- en: 'Try opening it in the browser and inspecting the response using developer tools,
    or try running the `curl` command again in verbose mode to see the complete HTTP
    response, `curl -v` http://127`.0.0.1:8000/` and `curl -v http://127.0.0.1:8000/somepath`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在浏览器中打开它，并使用开发者工具检查响应，或者再次以详细模式运行`curl`命令以查看完整的HTTP响应，`curl -v http://127.0.0.1:8000/`和`curl
    -v http://127.0.0.1:8000/somepath`：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see that access to `/` worked perfectly and access to `/somepath` returned
    an HTTP response with a `404` status and with some HTML content. There are some
    default privacy and security HTTP headers too, which were injected by the Shield
    fairing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到对`/`的访问完美无缺，而对`/somepath`的访问返回了一个带有`404`状态和某些HTML内容的HTTP响应。还有一些默认的隐私和安全HTTP头，这些是由Shield
    fairing注入的。
- en: Congratulations! You just created your first Rocket-powered web application.
    What you just built is a regular Rocket web application. Next, let's modify it
    to be an asynchronous web application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚创建了一个由Rocket驱动的第一个Web应用程序。您刚刚构建的是一个常规的Rocket Web应用程序。接下来，让我们将其修改为异步Web应用程序。
- en: An asynchronous application
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步应用程序
- en: What is an asynchronous application? Let's say our web application is sending
    a query to a database. While waiting for the response for a few milliseconds,
    our application thread is just doing nothing. For a single user and a single request,
    this is not a problem. An asynchronous application is an application that allows
    a processor to do other tasks while there are blocking tasks, such as waiting
    for the response from the database. We will discuss this in detail later; right
    now, we just want to convert our application into an asynchronous application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是异步应用程序？让我们假设我们的Web应用程序正在向数据库发送查询。在等待响应的几毫秒内，我们的应用程序线程只是在做无用功。对于单个用户和单个请求来说，这并不是问题。异步应用程序是一种允许处理器在存在阻塞任务（如等待数据库响应）时执行其他任务的应用程序。我们将在稍后详细讨论这个问题；现在，我们只想将我们的应用程序转换为异步应用程序。
- en: 'Let''s modify the application that we created earlier and make it asynchronous.
    You can find the example folder in `02hello_rocket_async`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前创建的应用程序，使其变为异步。您可以在`02hello_rocket_async`文件夹中找到示例：
- en: Remove the `use rocket::{Build, Rocket};` line, since we are not going to use
    it.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`use rocket::{Build, Rocket};`这一行，因为我们不会使用它。
- en: After that, let's add the `async` keyword before `fn index()`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们在`fn index()`之前添加`async`关键字。
- en: Replace the `#[launch]` attribute with `#[rocket::main]`. This is to signify
    that this function is going to be the main function in our application.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`#[launch]`属性替换为`#[rocket::main]`。这是为了表示这个函数将成为我们应用程序中的主函数。
- en: Add the `async` keyword and rename `fn launch()` to `fn main()`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`async`关键字，并将`fn launch()`重命名为`fn main()`。
- en: We also don't want the main function to return anything, so use `remove -> Rocket<build>`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也不希望主函数返回任何内容，所以使用`remove -> Rocket<build>`。
- en: Add `.launch().await;` after calling `mount`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`mount`之后添加`.launch().await;`。
- en: 'The final code should look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的代码应该看起来像这样：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Stop the old version from running on the server by using the *Ctrl* + *C* command.
    You should see something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *C*命令停止旧版本在服务器上的运行。你应该会看到类似以下的内容：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We don't have any blocking task in our `"/"` handler right now, so we will not
    see any noticeable benefit. Now that we have created our application, let's configure
    it in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前在`"/"`处理程序中没有任何阻塞任务，所以我们不会看到任何明显的收益。现在我们已经创建了我们的应用程序，让我们在下一节中对其进行配置。
- en: Configuring our Rocket web application
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置我们的Rocket网络应用程序
- en: Let's learn how to configure our Rocket web application, starting with different
    profiles for different situations. Then, we will use the `Rocket.toml` file to
    configure it. And finally, we will learn how to use environment variables to configure
    our application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何配置我们的Rocket网络应用程序，从为不同情况设置不同的配置文件开始。然后，我们将使用`Rocket.toml`文件进行配置。最后，我们将学习如何使用环境变量来配置我们的应用程序。
- en: Starting the Rocket application in different profiles
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以不同配置文件启动Rocket应用程序
- en: 'Let''s run our synchronous application server without a release flag, and in
    another terminal, let''s see whether we can benchmark it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的同步应用程序服务器，不使用发布标志，然后在另一个终端中，让我们看看我们是否可以对其进行基准测试：
- en: First, let's install the application using `cargo install benchrs`. That's right,
    you can install the application using Cargo too! There are very good Rust programs
    that you can use in your terminal, for example, `ripgrep`, which is one of the
    fastest applications for grepping string in your code.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用`cargo install benchrs`安装应用程序。没错，你也可以使用Cargo来安装应用程序！在你的终端中，你可以使用非常优秀的Rust程序，例如`ripgrep`，这是在代码中搜索字符串最快的应用程序之一。
- en: 'If you want to call the Cargo-installed application, you can use the full path
    or add it to your terminal path if you are using a Unix-based terminal. Append
    the following line to your `~/.profile` or any other profile file that will be
    loaded by your terminal:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想调用Cargo安装的应用程序，你可以使用完整路径，或者如果你使用的是基于Unix的终端，将其添加到你的终端路径中。将以下行追加到你的`~/.profile`或任何将被终端加载的其他配置文件中：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Rustup should already have added Cargo's `bin` folder to your path if you are
    using Windows.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Windows，Rustup应该已经将Cargo的`bin`文件夹添加到你的路径中了。
- en: 'Run the benchmark against your running application:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对运行中的应用程序进行基准测试：
- en: '[PRE26]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see that our application handles around 3,000 requests in `0.7199552`
    seconds. Not a bad value for a simple application if we compare it to other heavy
    frameworks. After that, stop the application for now.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的应用程序在`0.7199552`秒内处理了大约3,000个请求。如果我们与其他重型框架进行比较，这是一个简单的应用程序的不错值。之后，现在暂时停止应用程序。
- en: Now, let's run the application again but this time in release mode. Do you still
    remember how to do it from the previous chapter?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行应用程序，但这次是在发布模式下。你还记得如何在前一章中这样做吗？
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It should then compile our application for release and run it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它应该编译我们的应用程序以发布并运行它。
- en: 'After the application is ready to accept the request again, in another terminal,
    run the benchmark again:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序准备好再次接受请求后，在另一个终端中再次运行基准测试：
- en: '[PRE28]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, the result is very impressive, but what's going on here? The total benchmark
    time now becomes roughly 0.08 seconds, almost 10 times faster than the previous
    total benchmark time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，结果非常令人印象深刻，但这里发生了什么？总的基准时间现在大约是0.08秒，比之前的总基准时间快了几乎10倍。
- en: To understand the reason for the speed increase, we need to know about Rocket
    **profiles**. A profile is a name we give for a set of configurations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解速度增加的原因，我们需要了解Rocket **配置文件**。配置文件是为一组配置所赋予的名称。
- en: 'Rocket application has two meta-profiles: **default** and **global**. The default
    profile has all the default configuration values. If we create a profile and do
    not set the values of its configuration, the values from the default configuration
    will be used. As for the global profile, if we set the configuration values, then
    it will override the values set in a profile.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket应用程序有两个元配置文件：**default**和**global**。默认配置文件包含所有默认配置值。如果我们创建一个配置文件而没有设置其配置值，则将使用默认配置的值。至于全局配置文件，如果我们设置了配置值，则它将覆盖配置文件中设置的值。
- en: Besides those two meta-profiles, the Rocket framework also provides two configurations.
    When running or compiling the application in release mode, Rocket will use the
    **release** profile, and while running or compiling in debug mode, Rocket will
    select the **debug** profile. Running the application in release mode will obviously
    generate an optimized executable binary, but there are other optimizations in
    the application itself. For example, you will see the difference in the application
    output. The debug profile by default shows the output on the terminal, but the
    release profile by default will not show any request in the terminal output.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个元配置文件之外，Rocket框架还提供了两个配置。当以发布模式运行或编译应用程序时，Rocket将使用**release**配置文件，而在调试模式运行或编译时，Rocket将选择**debug**配置文件。以发布模式运行应用程序将显然生成一个优化的可执行二进制文件，但应用程序本身还有其他优化。例如，您将在应用程序输出中看到差异。默认情况下，调试配置文件会在终端上显示输出，但默认情况下，发布配置文件不会在终端输出中显示任何请求。
- en: We can create any name for a profile, for example, `development`, `test`, `staging`,
    `sandbox`, or `production`. Use any name that makes sense to your development
    process. For example, in a machine used for QA testing, you might want to give
    the profile the name `testing`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为配置文件创建任何名称，例如，`development`、`test`、`staging`、`sandbox`或`production`。使用对您的开发过程有意义的任何名称。例如，在一个用于QA测试的机器上，您可能希望将配置文件命名为`testing`。
- en: To choose which profile we want to use, we can specify it in the environment
    variable. Use `ROCKET_PROFILE=profile_name cargo run` in the command line. For
    example, you can write `ROCKET_PROFILE=profile_name cargo run –release`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择我们想要使用的配置文件，我们可以在环境变量中指定它。在命令行中使用`ROCKET_PROFILE=profile_name cargo run`。例如，您可以编写`ROCKET_PROFILE=profile_name
    cargo run –release`。
- en: Now that we know how to start the application with a certain profile, let's
    learn how to create a profile and configure the Rocket application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何以特定配置启动应用程序，让我们学习如何创建配置文件并配置Rocket应用程序。
- en: Configuring the Rocket web application
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Rocket Web应用程序
- en: Rocket has a way to configure web applications. The web framework uses the `Provider`
    trait). Someone can make a type that reads JSON from a file and implements a `Provider`
    trait for that type. That type can then be consumed by an application that uses
    the figment crate as the source of the configuration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket有一种配置Web应用程序的方法。Web框架使用`Provider`特质。有人可以创建一个从文件中读取JSON的类型，并为该类型实现`Provider`特质。该类型然后可以被使用figment
    crate作为配置源的应用程序消费。
- en: 'In Rust, there''s a convention to initialize a struct with a default value
    if it implements a standard library trait, `std::default::Default`. That trait
    is written as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，有一个约定，如果结构实现了标准库特质`std::default::Default`，则使用默认值初始化结构。该特质被编写如下：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For example, a struct named `StructName`, which implements the `Default` trait,
    will then be called `StructName::default()`. Rocket has a `rocket::Config` struct
    that implements the `Default` trait. The default value is then used to configure
    the application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个名为`StructName`的结构，实现了`Default`特质，将被调用为`StructName::default()`。Rocket有一个实现`Default`特质的`rocket::Config`结构。然后使用默认值来配置应用程序。
- en: 'If you look at the source for the `rocket::Config` struct, it is written as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`rocket::Config`结构的源代码，它被编写如下：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, there are fields such as `address` and `port`, which will obviously
    dictate how the application behaves. If you check further in the source code,
    you can see the `Default` trait implementation for the `Config` struct.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有诸如`address`和`port`之类的字段，这些字段显然将决定应用程序的行为。如果您进一步检查源代码，您可以看到`Config`结构的`Default`特质实现。
- en: Rocket also has a couple of figment providers that override the default `rocket::Config`
    value when we use the `rocket::build()` method in our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket还有一些figment提供者，当我们在应用程序中使用`rocket::build()`方法时，会覆盖默认的`rocket::Config`值。
- en: The first figment provider reads from the `Rocket.toml` file, or the file that
    we specify if we run the application with the `ROCKET_CONFIG` environment variable.
    If we specify `ROCKET_CONFIG` (for example, `ROCKET_CONFIG=our_config.toml`),
    it will search `our_config.toml` at the root directory of the application. If
    the application cannot find that configuration file, then the application will
    look in the parent folder until it reaches the root of the filesystem. If we specify
    an absolute path, for example, `ROCKET_CONFIG=/some/directory/our_config.toml`,
    then the application will only search for the file in that location.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个片段提供者从 `Rocket.toml` 文件中读取，或者如果我们使用 `ROCKET_CONFIG` 环境变量运行应用程序，则是我们指定的文件。如果我们指定
    `ROCKET_CONFIG`（例如，`ROCKET_CONFIG=our_config.toml`），它将在应用程序根目录中搜索 `our_config.toml`。如果应用程序找不到该配置文件，则应用程序将在父文件夹中查找，直到达到文件系统的根。如果我们指定绝对路径，例如，`ROCKET_CONFIG=/some/directory/our_config.toml`，则应用程序将仅在指定位置搜索该文件。
- en: The second figment provider reads the value from Environment variables. We will
    see how to do it later, but first, let's try configuring the Rocket application
    using the `Rocket.toml` file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个片段提供者从环境变量中读取值。我们将在稍后看到如何做到这一点，但首先，让我们尝试使用 `Rocket.toml` 文件来配置 Rocket 应用程序。
- en: Configuring the Rocket application using Rocket.toml
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Rocket.toml 配置 Rocket 应用程序
- en: 'The first thing we need to know is the list of keys we can use in the configuration
    file. These are the keys that we can use in the configuration file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要了解的是可以在配置文件中使用的键列表。这些是我们可以在配置文件中使用的键：
- en: '`address`: The application will serve at this address.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`: 应用程序将在该地址提供服务。'
- en: '`port`: The application will serve on this port.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`: 应用程序将在该端口上提供服务。'
- en: '`workers`: The application will use this number of threads.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workers`: 应用程序将使用此数量的线程。'
- en: '`ident`: If we specify `false`, the application will not put an identity in
    the server HTTP header; if we specify `string`, the application will use it as
    an identity in the server HTTP header.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ident`: 如果我们指定 `false`，则应用程序不会在服务器 HTTP 标头中放置身份；如果我们指定 `string`，则应用程序将使用它作为服务器
    HTTP 标头的身份。'
- en: '`keep_alive`: Keep-alive timeout in seconds. Use `0` to disable `keep_alive`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keep_alive`: 以秒为单位保持连接的超时时间。使用 `0` 来禁用 `keep_alive`。'
- en: '`log_level`: The maximum level to log (off/normal/debug/critical).'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_level`: 记录的最大级别（关闭/正常/调试/关键）。'
- en: '`temp_dir`: The path to a directory to store temporary files.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temp_dir`: 存储临时文件的目录路径。'
- en: '`cli_colors`: Use colors and emojis on the log, or not. This is useful to disable
    bells and whistles in the release environment.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cli_colors`: 在日志中使用颜色和表情符号，或者不使用。这在禁用发布环境中的铃声和哨声很有用。'
- en: '`secret_key`: The Rocket application has a type to store private cookies in
    the application. The private cookies are encrypted by this key. The key length
    is 256 bits, and you can generate it using tools such as `openssl rand -base64
    32`. Since this is an important key, you might want to keep it in a safe place.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secret_key`: Rocket 应用程序有一个类型来存储应用程序中的私有 cookies。私有 cookies 由此密钥加密。密钥长度为 256
    位，您可以使用如 `openssl rand -base64 32` 这样的工具生成它。由于这是一个重要的密钥，您可能希望将其保存在安全的地方。'
- en: '`tls`: Use `tls.key` and `tls.certs` to enter the path to your TLS (Transport
    Layer Security) key and certificate file.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tls`: 使用 `tls.key` 和 `tls.certs` 进入您的 TLS（传输层安全性）密钥和证书文件的路径。'
- en: '`limits`: This configuration is nested and is used to limit the server read
    size. You can write the value in multibyte units such as 1 MB (megabyte) or 1
    MiB (mebibyte). There are several default options:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits`: 此配置是嵌套的，用于限制服务器读取大小。您可以将值写入多字节单位，例如 1 MB（兆字节）或 1 MiB（梅吉字节）。有几个默认选项：'
- en: '`limits.form` – 32 KiB'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.form` – 32 KiB'
- en: '`limits.data-form` – 2 MiB'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.data-form` – 2 MiB'
- en: '`limits.file` – 1 MiB'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.file` – 1 MiB'
- en: '`limits.string` – 8 KiB'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.string` – 8 KiB'
- en: '`limits.bytes` – 8 KiB'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.bytes` – 8 KiB'
- en: '`limits.json` – 1 MiB'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.json` – 1 MiB'
- en: '`limits.msgpack` – 1 MiB'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.msgpack` – 1 MiB'
- en: '`shutdown`: If a web application is terminated abruptly when it''s still processing
    something, the data being processed might accidentally get corrupted. For example,
    let''s say a Rocket application is in the middle of sending updated data to the
    database server, but the process is then terminated suddenly. As a result, there
    is data inconsistency. This option configures Rocket''s smooth shutdown behavior.
    Like `limits`, it has several subconfigurations:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown`: 如果一个网络应用程序在处理某些内容时突然终止，正在处理的数据可能会意外损坏。例如，假设一个 Rocket 应用程序正在向数据库服务器发送更新数据的途中，但随后进程被突然终止。结果，数据不一致。此选项配置
    Rocket 的平稳关闭行为。与 `limits` 类似，它有几个子配置：'
- en: '`shutdown.ctrlc` – Does the application ignore the *Ctrl* + *C* keystrokes
    or not?'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown.ctrlc` – 应用程序是否忽略 *Ctrl* + *C* 键盘按键？'
- en: '`shutdown.signals` – An array of Unix signals that trigger a shutdown. Only
    works on Unix or Unix-like operating systems.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown.signals` – 触发关闭的 Unix 信号数组。仅在 Unix 或类 Unix 操作系统上有效。'
- en: '`shutdown.grace` – The number of seconds in which to finish outstanding server
    I/O before stopping it.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown.grace` – 在停止服务器之前完成未完成的服务器 I/O 的秒数。'
- en: '`shutdown.mercy` – The number of seconds in which to finish outstanding connection
    I/O before stopping it.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown.mercy` – 在停止之前完成未完成的连接 I/O 的秒数。'
- en: '`shutdown.force` – Specifies whether or not to kill a process that refuses
    to cooperate.'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown.force` – 指定是否要杀死拒绝合作的进程。'
- en: 'Now that we know what keys we can use, let''s try configuring our application.
    Remember what port our application is running on? Suppose now we want to run the
    application on port `3000`. Let''s create a `Rocket.toml` file in the root folder
    of our application:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们可以使用哪些密钥，让我们尝试配置我们的应用程序。记得我们的应用程序运行在哪个端口上吗？假设现在我们想在端口 `3000` 上运行应用程序。让我们在我们的应用程序根目录中创建一个
    `Rocket.toml` 文件：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, try running the application again:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次尝试运行应用程序：
- en: '[PRE50]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can see that it''s working; we''re running the application in port `3000`.
    But, what if we want to run the application in a different configuration for a
    different profile? Let''s try adding these lines in the `Rocket.toml` file and
    running the application in release mode:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它在工作；我们正在端口 `3000` 上运行应用程序。但是，如果我们想为不同的配置文件运行不同的应用程序配置呢？让我们尝试在 `Rocket.toml`
    文件中添加这些行，并以发布模式运行应用程序：
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'That''s right, we can specify the configuration for a different profile. What
    do we do if our option is nested? Because this file is a `.toml` file, we can
    write it as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，我们可以为不同的配置文件指定配置。如果我们的选项是嵌套的，我们该怎么办？因为这个文件是一个 `.toml` 文件，我们可以这样写：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or, we can write it in the following way:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样写：
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let''s see the whole file with the default configuration:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看具有默认配置的整个文件：
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Even though we can create the file with the whole configuration, the best practice
    for using `Rocket.toml` is to rely on the default value and only write what we
    really need to override.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以创建包含完整配置的文件，但使用 `Rocket.toml` 的最佳实践是依赖默认值，并且只写入我们真正需要覆盖的内容。
- en: Overriding the configuration with environment variables
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用环境变量覆盖配置
- en: After checking `Rocket.toml`, the application then overrides the `rocket::Config`
    value again with environment variables. The application will check the availability
    of the `ROCKET_*` environment variables. For example, we might define `ROCKET_IDENT="Merpay"`
    or `ROCKET_TLS={certs="abc.pem",key="def.pem"}`. This is very useful if we are
    doing development and have multiple team members, or if we don't want something
    to exist in the configuration files and rely on environment variables, for example,
    when we store `secret_key` in Kubernetes Secrets. In this case, getting the `secret`
    value from environment variables is more secure compared to writing the value
    in `Rocket.toml` and committing it to your source code versioning system.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查 `Rocket.toml` 后，应用程序再次使用环境变量覆盖 `rocket::Config` 值。应用程序将检查 `ROCKET_*` 环境变量的可用性。例如，我们可能定义
    `ROCKET_IDENT="Merpay"` 或 `ROCKET_TLS={certs="abc.pem",key="def.pem"}`。如果我们正在进行开发并且有多个团队成员，或者我们不希望在配置文件中存在某些内容并依赖于环境变量，例如，当我们在
    Kubernetes Secrets 中存储 `secret_key` 时，这非常有用。在这种情况下，从环境变量中获取 `secret` 值比将其写入 `Rocket.toml`
    并提交到源代码版本控制系统更安全。
- en: 'Let''s try overriding the configuration by running the application with `ROCKET_PORT=4000`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过运行应用程序并设置 `ROCKET_PORT=4000` 来覆盖配置：
- en: '[PRE86]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The environment variable override works; we are running the application in port
    `4000` even though we specified port `3000` in the `Rocket.toml` file. We will
    learn how to extend the default `rocket::Config` with custom configuration when
    we configure the application to connect to a database in [*Chapter 4*](B16825_04_ePub.xhtml#_idTextAnchor063),
    *Building, Igniting, and Launching Rocket*. Now that we have learned how to configure
    the Rocket application, let's find out where we can get documentation and help
    for the Rocket web framework.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量覆盖是有效的；尽管我们在 `Rocket.toml` 文件中指定了端口 `3000`，但我们正在端口 `4000` 上运行应用程序。当我们配置应用程序连接到数据库时，我们将在
    [*第 4 章*](B16825_04_ePub.xhtml#_idTextAnchor063) *构建、点燃和发射火箭* 中学习如何扩展默认的 `rocket::Config`
    以使用自定义配置。现在我们已经学会了如何配置 Rocket 应用程序，让我们找出我们可以在哪里获得 Rocket 网络框架的文档和帮助。
- en: Getting help
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取帮助
- en: Getting help with a web framework is essential. In this part, we will see where
    we can get help and documentation for the Rocket framework.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络框架获得帮助是至关重要的。在本部分中，我们将了解我们可以在哪里获得Rocket框架的帮助和文档。
- en: 'You can get help from the website of the Rocket framework itself: [https://rocket.rs/](https://rocket.rs/).
    On that website, there is a guide as follows: [https://rocket.rs/v0.5-rc/guide/](https://rocket.rs/v0.5-rc/guide/).
    In the top-left corner of that page, there is a dropdown where you can choose
    documentation for previous versions of the Rocket web framework.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Rocket框架本身的网站上获得帮助：[https://rocket.rs/](https://rocket.rs/). 在该网站上，有一个如下指南：[https://rocket.rs/v0.5-rc/guide/](https://rocket.rs/v0.5-rc/guide/).
    在该页面的左上角，有一个下拉菜单，您可以通过它选择Rocket网络框架的先前版本的文档。
- en: At [https://api.rocket.rs](https://api.rocket.rs), you can see the documentation
    for the API, but, unfortunately, this documentation is for the master branch of
    the Rocket web framework. If you want to see the API documentation for your framework
    version, you have to manually search for it, such as `https://api.rocket.rs/v0.3/rocket/`
    or `https://api.rocket.rs/v0.4/rocket/`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://api.rocket.rs](https://api.rocket.rs)上，您可以查看API的文档，但遗憾的是，这份文档是针对Rocket网络框架的master分支的。如果您想查看您框架版本的API文档，您必须手动搜索，例如`https://api.rocket.rs/v0.3/rocket/`或`https://api.rocket.rs/v0.4/rocket/`。
- en: There is an alternative way to generate offline documentation for the Rocket
    framework. Go and download the source code of Rocket from the official repository
    at [https://github.com/SergioBenitez/Rocket](https://github.com/SergioBenitez/Rocket).
    Then, inside the folder, type `./scripts/mk-docs.sh` to run the shell script.
    The generated documentation is useful because, sometimes, there are items that
    are different from those at [https://api.rocket.rs](https://api.rocket.rs). For
    example, the definition for `rocket::Config` and its default value in the code
    is a little bit different from the one in the API documentation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为Rocket框架生成离线文档的另一种方法是。从官方仓库[https://github.com/SergioBenitez/Rocket](https://github.com/SergioBenitez/Rocket)下载Rocket的源代码。然后，在文件夹内输入`./scripts/mk-docs.sh`来运行shell脚本。生成的文档很有用，因为有时其中的一些内容与[https://api.rocket.rs](https://api.rocket.rs)上的内容不同。例如，`rocket::Config`的定义及其在代码中的默认值与API文档中的略有不同。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned a little bit about the Rocket start sequence and
    request life cycle. We also created a very simple application and converted it
    to an asynchronous application. After that, we learned about the Rocket configuration,
    wrote the configuration using `Rocket.toml`, and overrode it using environment
    variables. Finally, we learned where to find the documentation for the Rocket
    framework.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要了解了Rocket的启动序列和请求生命周期。我们还创建了一个非常简单的应用程序，并将其转换为异步应用程序。之后，我们学习了Rocket的配置，使用`Rocket.toml`编写配置，并使用环境变量覆盖它。最后，我们学习了在哪里可以找到Rocket框架的文档。
- en: Now that we have created a simple application with the Rocket web framework,
    let's discuss requests and responses further in the next chapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Rocket网络框架创建了一个简单的应用程序，让我们在下一章中进一步讨论请求和响应。
