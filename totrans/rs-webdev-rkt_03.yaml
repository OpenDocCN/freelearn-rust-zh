- en: '*Chapter 2*: Building Our First Rocket Web Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to explore Rocket, a framework to create web applications
    using the Rust programming language. We will learn a little bit about Rocket before
    we create our first web application using the Rocket framework. After that, we
    will learn how to configure our Rocket web application. Finally, we will explore
    how to get help for this web framework at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Rocket – a web framework written in the Rust language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our first Rocket web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring our Rocket web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this and subsequent chapters, you will need to have the requirements mentioned
    in [*Chapter 1*](B16825_01_ePub.xhtml#_idTextAnchor014), *Introducing the Rust
    Language*, and the Rust toolchain installed. If you still don't have the Rust
    compiler toolchain installed, please follow the installation guide in [*Chapter
    1*](B16825_01_ePub.xhtml#_idTextAnchor014), *Introducing the Rust Language*. Also,
    it would be helpful to have a text editor with a Rust extension installed and
    Rust tools such as `rustfmt` or `clippy`. If you don't have a text editor installed
    already, you can use open source software such as Visual Studio Code with the
    `rust-analyzer` extension. As we're going to make HTTP requests to the application
    that we're going to create, you should have a web browser or other HTTP client
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Rocket framework has a few releases, all of which are slightly
    different. We will only be discussing Rocket *0.5.0*. Don't worry if you are planning
    to use a different version of Rocket, as the terminology and concepts are almost
    the same. Use the API documentation mentioned in the *Getting help* section of
    this chapter to see the correct documentation for your Rocket framework version.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter02](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Rocket – a web framework written in the Rust language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development of the Rocket web framework began as a project of Sergio Benitez
    in 2016\. For a long time, it was being created with a lot of Rust macrosystems
    to simplify the development process; because of this, a stable Rust compiler could
    not be used until recently, in 2021\. During the development process, async/await
    capabilities were added to Rust. Rocket began to incorporate async/await until
    the issue tracker for it closed in 2021.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket is a fairly simple web framework without many bells and whistles, such
    as database **Object-relational mapping** (**ORM**) or mailing systems. Programmers
    can extend Rocket's capabilities using other Rust crates, for example, by adding
    third-party logging or connecting to memory store applications.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP request life cycle in Rocket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handling HTTP requests is an integral part of web applications. The Rocket web
    framework treats incoming HTTP requests as a life cycle. The first thing the web
    application does is checks and determines which function or functions will be
    able to handle the incoming request. This part is called **routing**. For example,
    if there's a *GET/something* incoming request, Rocket will check all the registered
    routes for matches.
  prefs: []
  type: TYPE_NORMAL
- en: After routing, Rocket will perform the **validation** of the incoming request
    against types and guards declared in the first function. If the result does not
    match and the next route handling function is available, Rocket will continue
    validation against the next function until there are no more functions available
    to handle that incoming request.
  prefs: []
  type: TYPE_NORMAL
- en: After validation, Rocket will then **process** with what the programmer wrote
    in the body of the function. For example, a programmer creates a SQL query with
    the data from the request, sends the query to the database, retrieves the result
    from the database, and creates an HTML using the result.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket will finally return a **response**, which contains the HTTP status, headers,
    and body. The request life cycle is then complete.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, the life cycle of a Rocket request is **Routing → Validation → Processing
    → Response**. Next, let's discuss how the Rocket application starts.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket launch sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like a real-life rocket, we start by building the Rocket application. In the
    building process, we mount the **routes** (functions that handle incoming requests)
    to the Rocket application.
  prefs: []
  type: TYPE_NORMAL
- en: In the building process, the Rocket application also manages various **states**.
    A state is a Rust object that can be accessed in a route handler. For example,
    let's say we want a logger that sends events to a logging server. We initialize
    the logger object when we build the Rocket application, and when there's an incoming
    request, we can use the already managed logger object in the request handler.
  prefs: []
  type: TYPE_NORMAL
- en: Still in the building process, we can also attach **fairings**. In many web
    frameworks, there is usually a middleware component that filters, inspects, authorizes,
    or modifies incoming HTTP requests or responses. In the Rocket framework, the
    function that provides middleware functionality is called a fairing. For example,
    if we want to have a **universally unique identifier** (**UUID**) for every HTTP
    request for audit purposes, we first create a fairing that generates a random
    UUID and appends it to the request HTTP header. We also make the fairing append
    the same UUID to the generated HTTP response. Next, we attach it to Rocket. This
    fairing will then intercept the incoming request and response and modify it.
  prefs: []
  type: TYPE_NORMAL
- en: After the Rocket application is built and ready, the next step is, of course,
    launching it. Yay, the launch is successful! Now, our Rocket application is operational
    and ready to serve incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an overview of the Rocket application, let's try creating a
    simple Rocket application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first Rocket web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to create a very simple web application that
    handles only one HTTP path. Follow these steps to create our first Rocket web
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Rust application using Cargo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are creating an application named `hello_rocket` in a folder named `01hello_rocket`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, let''s modify the `Cargo.toml` file. Add the following line after
    `[dependencies]`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the following lines at the top of the `src/main.rs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are telling the Rust compiler to use macros from the Rocket crate by
    using the `#[macro_use]` attribute. We can skip using that attribute, but that
    would mean we must specify `use` for every single macro that we are going to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to tell the compiler that we are using the definition
    from the Rocket crate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, let''s create our first HTTP handler. Add the following lines after
    the preceding ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we define a function that returns a reference to a `str`. The `'a` in
    the Rust language means that a variable has a `'a` lifetime. The life span of
    a reference depends on many things. We will discuss these in [*Chapter 9*](B16825_09_ePub.xhtml#_idTextAnchor109),
    *Displaying User's Post*, when we discuss object scope and lifetime in more depth.
    But, a `'static` notation is special because it means that it will last as long
    as the application is still alive. We can also see that the return value is `"Hello,
    Rocket"` since it is the last line and we did not put a semicolon at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, what is the `#[get("/")]` attribute? Remember before when we used the
    `#[macro_use]` attribute? The `rocket::get` attribute is a macro attribute that
    specifies the HTTP method a function handles, and the route, HTTP paths, and parameters
    it handles. There are seven method-specific route attributes that we can use:
    `get`, `put`, `post`, `delete`, `head`, `options`, and `patch`. All of them correspond
    to their respective HTTP method name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use alternate macros to specify route handlers by replacing the
    attribute macro with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, delete the `fn main()` function and add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have created a function that will generate the `main` function because we
    used the `#[launch]` attribute. Inside the function, we built the Rocket and mounted
    the routes that have an `index` function to the `"/"` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try running the `hello_rocket` application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see the application printed the application configuration, such as keep-alive
    timeout duration, request size limits, log level, routes, and many more that you
    typically see in an HTTP server to the terminal. After that, the application printed
    the various parts of the Rocket. We created a single-route `index` function, which
    handles `GET /`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, there is the default built-in fairing, **Shield**. Shield works by injecting
    HTTP security and privacy headers to all responses by default.
  prefs: []
  type: TYPE_NORMAL
- en: We also see that the application was successfully launched and is now accepting
    requests on the address `127.0.0.1` and port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test whether the application is really accepting requests. You
    can use a web browser or any HTTP client since it''s a very simple request, but
    if you use the command line, don''t stop the running application; open another
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see that the application responded perfectly. You can also see the
    log of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try requesting something that does not exist in our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s see what''s going on in the application terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now know that Rocket already has default handlers for `404` status situations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recall the Rocket life cycle, *Routing → Validation → Processing → Response*.
    The first request to http://127`.0.0.1:8000/` was successful because the application
    found the handler for the `GET /` route. Since we didn't create any validation
    in the application, the function then performed some very simple processing, returning
    a string. The Rocket framework already implemented the `Responder` trait for `&str`,
    so it created and returned an appropriate HTTP response. The other request to
    `/somepath` did not pass the routing part, and we did not create any error handler,
    so the Rocket application returned a default error handler for this request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try opening it in the browser and inspecting the response using developer tools,
    or try running the `curl` command again in verbose mode to see the complete HTTP
    response, `curl -v` http://127`.0.0.1:8000/` and `curl -v http://127.0.0.1:8000/somepath`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can see that access to `/` worked perfectly and access to `/somepath` returned
    an HTTP response with a `404` status and with some HTML content. There are some
    default privacy and security HTTP headers too, which were injected by the Shield
    fairing.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just created your first Rocket-powered web application.
    What you just built is a regular Rocket web application. Next, let's modify it
    to be an asynchronous web application.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is an asynchronous application? Let's say our web application is sending
    a query to a database. While waiting for the response for a few milliseconds,
    our application thread is just doing nothing. For a single user and a single request,
    this is not a problem. An asynchronous application is an application that allows
    a processor to do other tasks while there are blocking tasks, such as waiting
    for the response from the database. We will discuss this in detail later; right
    now, we just want to convert our application into an asynchronous application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the application that we created earlier and make it asynchronous.
    You can find the example folder in `02hello_rocket_async`:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `use rocket::{Build, Rocket};` line, since we are not going to use
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, let's add the `async` keyword before `fn index()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the `#[launch]` attribute with `#[rocket::main]`. This is to signify
    that this function is going to be the main function in our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `async` keyword and rename `fn launch()` to `fn main()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also don't want the main function to return anything, so use `remove -> Rocket<build>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `.launch().await;` after calling `mount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Stop the old version from running on the server by using the *Ctrl* + *C* command.
    You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We don't have any blocking task in our `"/"` handler right now, so we will not
    see any noticeable benefit. Now that we have created our application, let's configure
    it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our Rocket web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn how to configure our Rocket web application, starting with different
    profiles for different situations. Then, we will use the `Rocket.toml` file to
    configure it. And finally, we will learn how to use environment variables to configure
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Rocket application in different profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s run our synchronous application server without a release flag, and in
    another terminal, let''s see whether we can benchmark it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's install the application using `cargo install benchrs`. That's right,
    you can install the application using Cargo too! There are very good Rust programs
    that you can use in your terminal, for example, `ripgrep`, which is one of the
    fastest applications for grepping string in your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to call the Cargo-installed application, you can use the full path
    or add it to your terminal path if you are using a Unix-based terminal. Append
    the following line to your `~/.profile` or any other profile file that will be
    loaded by your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Rustup should already have added Cargo's `bin` folder to your path if you are
    using Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the benchmark against your running application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see that our application handles around 3,000 requests in `0.7199552`
    seconds. Not a bad value for a simple application if we compare it to other heavy
    frameworks. After that, stop the application for now.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's run the application again but this time in release mode. Do you still
    remember how to do it from the previous chapter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It should then compile our application for release and run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the application is ready to accept the request again, in another terminal,
    run the benchmark again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, the result is very impressive, but what's going on here? The total benchmark
    time now becomes roughly 0.08 seconds, almost 10 times faster than the previous
    total benchmark time.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the reason for the speed increase, we need to know about Rocket
    **profiles**. A profile is a name we give for a set of configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rocket application has two meta-profiles: **default** and **global**. The default
    profile has all the default configuration values. If we create a profile and do
    not set the values of its configuration, the values from the default configuration
    will be used. As for the global profile, if we set the configuration values, then
    it will override the values set in a profile.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides those two meta-profiles, the Rocket framework also provides two configurations.
    When running or compiling the application in release mode, Rocket will use the
    **release** profile, and while running or compiling in debug mode, Rocket will
    select the **debug** profile. Running the application in release mode will obviously
    generate an optimized executable binary, but there are other optimizations in
    the application itself. For example, you will see the difference in the application
    output. The debug profile by default shows the output on the terminal, but the
    release profile by default will not show any request in the terminal output.
  prefs: []
  type: TYPE_NORMAL
- en: We can create any name for a profile, for example, `development`, `test`, `staging`,
    `sandbox`, or `production`. Use any name that makes sense to your development
    process. For example, in a machine used for QA testing, you might want to give
    the profile the name `testing`.
  prefs: []
  type: TYPE_NORMAL
- en: To choose which profile we want to use, we can specify it in the environment
    variable. Use `ROCKET_PROFILE=profile_name cargo run` in the command line. For
    example, you can write `ROCKET_PROFILE=profile_name cargo run –release`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to start the application with a certain profile, let's
    learn how to create a profile and configure the Rocket application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Rocket web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rocket has a way to configure web applications. The web framework uses the `Provider`
    trait). Someone can make a type that reads JSON from a file and implements a `Provider`
    trait for that type. That type can then be consumed by an application that uses
    the figment crate as the source of the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, there''s a convention to initialize a struct with a default value
    if it implements a standard library trait, `std::default::Default`. That trait
    is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For example, a struct named `StructName`, which implements the `Default` trait,
    will then be called `StructName::default()`. Rocket has a `rocket::Config` struct
    that implements the `Default` trait. The default value is then used to configure
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the source for the `rocket::Config` struct, it is written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are fields such as `address` and `port`, which will obviously
    dictate how the application behaves. If you check further in the source code,
    you can see the `Default` trait implementation for the `Config` struct.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket also has a couple of figment providers that override the default `rocket::Config`
    value when we use the `rocket::build()` method in our application.
  prefs: []
  type: TYPE_NORMAL
- en: The first figment provider reads from the `Rocket.toml` file, or the file that
    we specify if we run the application with the `ROCKET_CONFIG` environment variable.
    If we specify `ROCKET_CONFIG` (for example, `ROCKET_CONFIG=our_config.toml`),
    it will search `our_config.toml` at the root directory of the application. If
    the application cannot find that configuration file, then the application will
    look in the parent folder until it reaches the root of the filesystem. If we specify
    an absolute path, for example, `ROCKET_CONFIG=/some/directory/our_config.toml`,
    then the application will only search for the file in that location.
  prefs: []
  type: TYPE_NORMAL
- en: The second figment provider reads the value from Environment variables. We will
    see how to do it later, but first, let's try configuring the Rocket application
    using the `Rocket.toml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Rocket application using Rocket.toml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to know is the list of keys we can use in the configuration
    file. These are the keys that we can use in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`address`: The application will serve at this address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: The application will serve on this port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workers`: The application will use this number of threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ident`: If we specify `false`, the application will not put an identity in
    the server HTTP header; if we specify `string`, the application will use it as
    an identity in the server HTTP header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keep_alive`: Keep-alive timeout in seconds. Use `0` to disable `keep_alive`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log_level`: The maximum level to log (off/normal/debug/critical).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`temp_dir`: The path to a directory to store temporary files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cli_colors`: Use colors and emojis on the log, or not. This is useful to disable
    bells and whistles in the release environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secret_key`: The Rocket application has a type to store private cookies in
    the application. The private cookies are encrypted by this key. The key length
    is 256 bits, and you can generate it using tools such as `openssl rand -base64
    32`. Since this is an important key, you might want to keep it in a safe place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tls`: Use `tls.key` and `tls.certs` to enter the path to your TLS (Transport
    Layer Security) key and certificate file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits`: This configuration is nested and is used to limit the server read
    size. You can write the value in multibyte units such as 1 MB (megabyte) or 1
    MiB (mebibyte). There are several default options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.form` – 32 KiB'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.data-form` – 2 MiB'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.file` – 1 MiB'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.string` – 8 KiB'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.bytes` – 8 KiB'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.json` – 1 MiB'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.msgpack` – 1 MiB'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown`: If a web application is terminated abruptly when it''s still processing
    something, the data being processed might accidentally get corrupted. For example,
    let''s say a Rocket application is in the middle of sending updated data to the
    database server, but the process is then terminated suddenly. As a result, there
    is data inconsistency. This option configures Rocket''s smooth shutdown behavior.
    Like `limits`, it has several subconfigurations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown.ctrlc` – Does the application ignore the *Ctrl* + *C* keystrokes
    or not?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown.signals` – An array of Unix signals that trigger a shutdown. Only
    works on Unix or Unix-like operating systems.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown.grace` – The number of seconds in which to finish outstanding server
    I/O before stopping it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown.mercy` – The number of seconds in which to finish outstanding connection
    I/O before stopping it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown.force` – Specifies whether or not to kill a process that refuses
    to cooperate.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know what keys we can use, let''s try configuring our application.
    Remember what port our application is running on? Suppose now we want to run the
    application on port `3000`. Let''s create a `Rocket.toml` file in the root folder
    of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try running the application again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that it''s working; we''re running the application in port `3000`.
    But, what if we want to run the application in a different configuration for a
    different profile? Let''s try adding these lines in the `Rocket.toml` file and
    running the application in release mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s right, we can specify the configuration for a different profile. What
    do we do if our option is nested? Because this file is a `.toml` file, we can
    write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can write it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the whole file with the default configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Even though we can create the file with the whole configuration, the best practice
    for using `Rocket.toml` is to rely on the default value and only write what we
    really need to override.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the configuration with environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After checking `Rocket.toml`, the application then overrides the `rocket::Config`
    value again with environment variables. The application will check the availability
    of the `ROCKET_*` environment variables. For example, we might define `ROCKET_IDENT="Merpay"`
    or `ROCKET_TLS={certs="abc.pem",key="def.pem"}`. This is very useful if we are
    doing development and have multiple team members, or if we don't want something
    to exist in the configuration files and rely on environment variables, for example,
    when we store `secret_key` in Kubernetes Secrets. In this case, getting the `secret`
    value from environment variables is more secure compared to writing the value
    in `Rocket.toml` and committing it to your source code versioning system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try overriding the configuration by running the application with `ROCKET_PORT=4000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The environment variable override works; we are running the application in port
    `4000` even though we specified port `3000` in the `Rocket.toml` file. We will
    learn how to extend the default `rocket::Config` with custom configuration when
    we configure the application to connect to a database in [*Chapter 4*](B16825_04_ePub.xhtml#_idTextAnchor063),
    *Building, Igniting, and Launching Rocket*. Now that we have learned how to configure
    the Rocket application, let's find out where we can get documentation and help
    for the Rocket web framework.
  prefs: []
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting help with a web framework is essential. In this part, we will see where
    we can get help and documentation for the Rocket framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get help from the website of the Rocket framework itself: [https://rocket.rs/](https://rocket.rs/).
    On that website, there is a guide as follows: [https://rocket.rs/v0.5-rc/guide/](https://rocket.rs/v0.5-rc/guide/).
    In the top-left corner of that page, there is a dropdown where you can choose
    documentation for previous versions of the Rocket web framework.'
  prefs: []
  type: TYPE_NORMAL
- en: At [https://api.rocket.rs](https://api.rocket.rs), you can see the documentation
    for the API, but, unfortunately, this documentation is for the master branch of
    the Rocket web framework. If you want to see the API documentation for your framework
    version, you have to manually search for it, such as `https://api.rocket.rs/v0.3/rocket/`
    or `https://api.rocket.rs/v0.4/rocket/`.
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative way to generate offline documentation for the Rocket
    framework. Go and download the source code of Rocket from the official repository
    at [https://github.com/SergioBenitez/Rocket](https://github.com/SergioBenitez/Rocket).
    Then, inside the folder, type `./scripts/mk-docs.sh` to run the shell script.
    The generated documentation is useful because, sometimes, there are items that
    are different from those at [https://api.rocket.rs](https://api.rocket.rs). For
    example, the definition for `rocket::Config` and its default value in the code
    is a little bit different from the one in the API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a little bit about the Rocket start sequence and
    request life cycle. We also created a very simple application and converted it
    to an asynchronous application. After that, we learned about the Rocket configuration,
    wrote the configuration using `Rocket.toml`, and overrode it using environment
    variables. Finally, we learned where to find the documentation for the Rocket
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created a simple application with the Rocket web framework,
    let's discuss requests and responses further in the next chapter.
  prefs: []
  type: TYPE_NORMAL
