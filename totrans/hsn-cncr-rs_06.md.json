["```rs\nA: Enq(x)       0\nB: Enq(y)       1\nB: Ok(())       2\nA: Ok(())       3\nB: Deq()        4\nB: Ok(x)        5\nA: Deq()        6\nA: Ok(y)        7\nA: Enq(z)       8\n```", "```rs\nA: Enq(x)       0\nA: Ok(())       3\nB: Enq(y)       1\nB: Ok(())       2\nB: Deq()        4\nB: Ok(x)        5\nA: Deq()        6\nA: Ok(y)        7\nA: Enq(z)       8\nA: Ok(())\n```", "```rs\nA: Enq(x)       0\nB: Deq()        1\nC: Ok(x)        2\n```", "```rs\nA: Enq(x)       0\nA: Ok(())\nB: Deq()        1\nB: Ok(x)        2\n```", "```rs\nA: Enq(x)       0\nA: Ok(())       1\nB: Enq(y)       2\nB: Ok(())       3\nA: Deq()        4\nA: Ok(y)        5\n```", "```rs\n    pub unsafe fn push_back(\n        &self,\n        elem: T,\n        guard: &mut MutexGuard<BackGuardInner<S>>,\n    ) -> Result<bool, Error<T>> {\n        let mut must_wake_dequeuers = false;\n        if self.size.load(Ordering::Acquire) == self.capacity {\n            return Err(Error::Full(elem));\n        } else {\n            assert!((*self.data.offset((*guard).offset)).is_none());\n            *self.data.offset((*guard).offset) = Some(elem);\n            (*guard).offset += 1;\n            (*guard).offset %= self.capacity as isize;\n            if self.size.fetch_add(1, Ordering::Release) == 0 {\n                must_wake_dequeuers = true;\n            }\n        }\n        Ok(must_wake_dequeuers)\n    }\n```", "```rs\n    pub unsafe fn pop_front(&self) -> T {\n        let mut guard = self.front_lock.lock()\n                          .expect(\"front lock poisoned\");\n        while self.size.load(Ordering::Acquire) == 0 {\n            guard = self.not_empty\n                .wait(guard)\n                .expect(\"oops could not wait pop_front\");\n        }\n        let elem: Option<T> = mem::replace(&mut \n        *self.data.offset((*guard).offset), None);\n        assert!(elem.is_some());\n        *self.data.offset((*guard).offset) = None;\n        (*guard).offset += 1;\n        (*guard).offset %= self.capacity as isize;\n        self.size.fetch_sub(1, Ordering::Release);\n        elem.unwrap()\n    }\n```", "```rs\nA: store X                   1\nA: store[Release] Y          2\nB: load[Acquire] Y           3\nB: load X                    4\nB: store[Release] Z          5\nC: load[Acquire] Z           6\nC: load X                    7\n```", "```rs\n#[macro_use]\nextern crate lazy_static;\n\nuse std::thread;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n\nlazy_static! {\nstatic ref X: Arc<AtomicBool> = Arc::new(AtomicBool::new(false));\nstatic ref Y: Arc<AtomicBool> = Arc::new(AtomicBool::new(false));\nstatic ref Z: Arc<AtomicUsize> = Arc::new(AtomicUsize::new(0));\n}\n\nfn write_x() {\n    X.store(true, Ordering::SeqCst);\n}\n\nfn write_y() {\n    Y.store(true, Ordering::SeqCst);\n}\n\nfn read_x_then_y() {\n    while !X.load(Ordering::SeqCst) {}\n    if Y.load(Ordering::SeqCst) {\n        Z.fetch_add(1, Ordering::Relaxed);\n    }\n}\n\nfn read_y_then_x() {\n    while !Y.load(Ordering::SeqCst) {}\n    if X.load(Ordering::SeqCst) {\n        Z.fetch_add(1, Ordering::Relaxed);\n    }\n}\n\nfn main() {\n    let mut jhs = Vec::new();\n    jhs.push(thread::spawn(write_x)); // a\n    jhs.push(thread::spawn(write_y)); // b\n    jhs.push(thread::spawn(read_x_then_y)); // c\n    jhs.push(thread::spawn(read_y_then_x)); // d\n    for jh in jhs {\n        jh.join().unwrap();\n    }\n    assert!(Z.load(Ordering::Relaxed) != 0);\n}\n```", "```rs\nlock(m0)\nunlock(m0)\nlock(m1)\nunlock(m1)\n```", "```rs\nlock(m0)\nlock(m1)\nunlock(m0)\nunlock(m1)\n```", "```rs\n[package]\nname = \"synchro\"\nversion = \"0.1.0\"\nauthors = [\"Brian L. Troutwine <brian@troutwine.us>\"]\n\n[[bin]]\nname = \"swap_mutex\"\ndoc = false\n\n[[bin]]\nname = \"status_demo\"\ndoc = false\n\n[[bin]]\nname = \"mutex_status_demo\"\ndoc = false\n\n[[bin]]\nname = \"spin_mutex_status_demo\"\ndoc = false\n\n[[bin]]\nname = \"queue_spin\"\ndoc = false\n\n[[bin]]\nname = \"crossbeam_queue_spin\"\ndoc = false\n\n[dependencies]\ncrossbeam = { git = \"https://github.com/crossbeam-rs/crossbeam.git\", rev = \"89bd6857cd701bff54f7a8bf47ccaa38d5022bfb\" }\n\n[dev-dependencies]\nquickcheck = \"0.6\"\n```", "```rs\nextern crate crossbeam;\n\nmod queue;\nmod swap_mutex;\nmod semaphore;\n\npub use semaphore::*;\npub use swap_mutex::*;\npub use queue::*;\n```", "```rs\nextern crate crossbeam;\n\nmod queue;\nmod swap_mutex;\nmod semaphore;\n```", "```rs\npub struct SwapMutex<T> {\n    locked: AtomicBool,\n    data: *mut T,\n}\n```", "```rs\nimpl<T> SwapMutex<T> {\n    pub fn new(t: T) -> Self {\n        let boxed_data = Box::new(t);\n        SwapMutex {\n            locked: AtomicBool::new(false),\n            data: Box::into_raw(boxed_data),\n        }\n    }\n```", "```rs\n    pub fn lock(&self) -> SwapMutexGuard<T> {\n        while self.locked.swap(true, Ordering::AcqRel) {\n            thread::yield_now();\n        }\n        SwapMutexGuard::new(self)\n    }\n```", "```rs\n    fn unlock(&self) -> () {\n        assert!(self.locked.load(Ordering::Relaxed) == true);\n        self.locked.store(false, Ordering::Release);\n    }\n```", "```rs\nimpl<T> Drop for SwapMutex<T> {\n    fn drop(&mut self) {\n        let data = unsafe { Box::from_raw(self.data) };\n        drop(data);\n    }\n}\n\npub struct SwapMutexGuard<'a, T: 'a> {\n    __lock: &'a SwapMutex<T>,\n}\n\nimpl<'a, T> SwapMutexGuard<'a, T> {\n    fn new(lock: &'a SwapMutex<T>) -> SwapMutexGuard<'a, T> {\n        SwapMutexGuard { __lock: lock }\n    }\n}\n\nimpl<'a, T> Deref for SwapMutexGuard<'a, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        unsafe { &*self.__lock.data }\n    }\n}\n\nimpl<'a, T> DerefMut for SwapMutexGuard<'a, T> {\n    fn deref_mut(&mut self) -> &mut T {\n        unsafe { &mut *self.__lock.data }\n    }\n}\n\nimpl<'a, T> Drop for SwapMutexGuard<'a, T> {\n    #[inline]\n    fn drop(&mut self) {\n        self.__lock.unlock();\n    }\n}\n```", "```rs\nextern crate synchro;\n\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::Arc;\nuse synchro::SwapMutex;\nuse std::{thread, time};\n\n#[derive(Debug)]\nenum Bridge {\n    Empty,\n    Left(u8),\n    Right(u8),\n}\n```", "```rs\nstatic LHS_TRANSFERS: AtomicUsize = AtomicUsize::new(0);\nstatic RHS_TRANSFERS: AtomicUsize = AtomicUsize::new(0);\n```", "```rs\nfn lhs(rope: Arc<SwapMutex<Bridge>>) -> () {\n    loop {\n        let mut guard = rope.lock();\n        match *guard {\n            Bridge::Empty => {\n                *guard = Bridge::Right(1);\n            }\n            Bridge::Right(i) => {\n                if i < 5 {\n                    *guard = Bridge::Right(i + 1);\n                }\n            }\n            Bridge::Left(0) => {\n                *guard = Bridge::Empty;\n            }\n            Bridge::Left(i) => {\n                LHS_TRANSFERS.fetch_add(1, Ordering::Relaxed);\n                *guard = Bridge::Left(i - 1);\n            }\n        }\n    }\n}\n\nfn rhs(rope: Arc<SwapMutex<Bridge>>) -> () {\n    loop {\n        let mut guard = rope.lock();\n        match *guard {\n            Bridge::Empty => {\n                *guard = Bridge::Left(1);\n            }\n            Bridge::Left(i) => {\n                if i < 5 {\n                    *guard = Bridge::Left(i + 1);\n                }\n            }\n            Bridge::Right(0) => {\n                *guard = Bridge::Empty;\n            }\n            Bridge::Right(i) => {\n                RHS_TRANSFERS.fetch_add(1, Ordering::Relaxed);\n                *guard = Bridge::Right(i - 1);\n            }\n        }\n    }\n}\n```", "```rs\nfn main() {\n    let mtx: Arc<SwapMutex<Bridge>> = Arc::new(SwapMutex::new(Bridge::Empty));\n\n    let lhs_mtx = Arc::clone(&mtx);\n    let _lhs = thread::spawn(move || lhs(lhs_mtx));\n    let _rhs = thread::spawn(move || rhs(mtx));\n\n    let one_second = time::Duration::from_millis(1_000);\n    loop {\n        thread::sleep(one_second);\n        println!(\n            \"Transfers per second:\\n    LHS: {}\\n    RHS: {}\",\n            LHS_TRANSFERS.swap(0, Ordering::Relaxed),\n            RHS_TRANSFERS.swap(0, Ordering::Relaxed)\n        );\n    }\n}\n```", "```rs\n> cargo build\n> ./target/debug/swap_mutex\nTransfers per second:\n    LHS: 787790\n    RHS: 719371\nTransfers per second:\n    LHS: 833537\n    RHS: 770782\nTransfers per second:\n    LHS: 848662\n    RHS: 776678\nTransfers per second:\n    LHS: 783769\n    RHS: 726334\nTransfers per second:\n    LHS: 828969\n    RHS: 761439\n```", "```rs\nuse std::ptr::null_mut;\nuse std::sync::atomic::{AtomicPtr, Ordering};\n\nunsafe impl<T: Send> Send for Queue<T> {}\nunsafe impl<T: Send> Sync for Queue<T> {}\n```", "```rs\nstruct Node<T> {\n    value: *const T,\n    next: AtomicPtr<Node<T>>,\n}\n\nimpl<T> Default for Node<T> {\n    fn default() -> Self {\n        Node {\n            value: null_mut(),\n            next: AtomicPtr::default(),\n        }\n    }\n}\n\nimpl<T> Node<T> {\n    fn new(val: T) -> Self {\n        Node {\n            value: Box::into_raw(Box::new(val)),\n            next: AtomicPtr::default(),\n        }\n    }\n}\n```", "```rs\nstruct InnerQueue<T> {\n    head: AtomicPtr<Node<T>>,\n    tail: AtomicPtr<Node<T>>,\n}\n```", "```rs\nimpl<T> InnerQueue<T> {\n    pub fn new() -> Self {\n        let node = Box::into_raw(Box::new(Node::default()));\n        InnerQueue {\n            head: AtomicPtr::new(node),\n            tail: AtomicPtr::new(node),\n        }\n    }\n```", "```rs\n    pub unsafe fn enq(&mut self, val: T) -> () {\n        let node = Box::new(Node::new(val));\n        let node: *mut Node<T> = Box::into_raw(node);\n\n        loop {\n            let tail: *mut Node<T> = self.tail.load(Ordering::Acquire);\n            let next: *mut Node<T> = \n            (*tail).next.load(Ordering::Relaxed);\n            if tail == self.tail.load(Ordering::Relaxed) {\n                if next.is_null() {\n                    if (*tail).next.compare_and_swap(next, node, \n                     Ordering::Relaxed) == next {\n                        self.tail.compare_and_swap(tail, node, \n                         Ordering::Release);\n                        return;\n                    }\n                }\n            } else {\n                self.tail.compare_and_swap(tail, next, \n                Ordering::Release);\n            }\n        }\n    }\n```", "```rs\n    pub unsafe fn enq(&mut self, val: T) -> () {\n        let node = Box::new(Node::new(val));\n        let node: *mut Node<T> = Box::into_raw(node);\n```", "```rs\n        loop {\n            let tail: *mut Node<T> = self.tail.load(Ordering::Acquire);\n            let next: *mut Node<T> = \n            (*tail).next.load(Ordering::Relaxed);\n```", "```rs\n            if tail == self.tail.load(Ordering::Relaxed) {\n                if next.is_null() {\n```", "```rs\n                    if (*tail).next.compare_and_swap(next, node, \n                     Ordering::Relaxed) == next {\n                        self.tail.compare_and_swap(tail, node, \n                         Ordering::Release);\n                        return;\n                    }\n```", "```rs\n                }\n            } else {\n                self.tail.compare_and_swap(tail, next, \n                 Ordering::Release);\n            }\n        }\n    }\n```", "```rs\n    pub unsafe fn deq(&mut self) -> Option<T> {\n        let mut head: *mut Node<T>;\n        let value: T;\n        loop {\n            head = self.head.load(Ordering::Acquire);\n            let tail: *mut Node<T> = self.tail.load(Ordering::Relaxed);\n            let next: *mut Node<T> = \n            (*head).next.load(Ordering::Relaxed);\n            if head == self.head.load(Ordering::Relaxed) {\n                if head == tail {\n                    if next.is_null() {\n                        return None;\n                    }\n                    self.tail.compare_and_swap(tail, next, \n                     Ordering::Relaxed);\n                } else {\n                    let val: *mut T = (*next).value as *mut T;\n                    if self.head.compare_and_swap(head, next, \n                    Ordering::Release) == head {\n                        value = *Box::from_raw(val);\n                        break;\n                    }\n                }\n            }\n        }\n        let head: Node<T> = *Box::from_raw(head);\n        drop(head);\n        Some(value)\n    }\n}\n```", "```rs\npub struct Queue<T> {\n    inner: *mut InnerQueue<T>,\n}\n\nimpl<T> Clone for Queue<T> {\n    fn clone(&self) -> Queue<T> {\n        Queue { inner: self.inner }\n    }\n}\n\nimpl<T> Queue<T> {\n    pub fn new() -> Self {\n        Queue {\n            inner: Box::into_raw(Box::new(InnerQueue::new())),\n        }\n    }\n\n    pub fn enq(&self, val: T) -> () {\n        unsafe { (*self.inner).enq(val) }\n    }\n\n    pub fn deq(&self) -> Option<T> {\n        unsafe { (*self.inner).deq() }\n    }\n```", "```rs\n#[cfg(test)]\nmod test {\n    extern crate quickcheck;\n\n    use super::*;\n    use std::collections::VecDeque;\n    use std::sync::atomic::AtomicUsize;\n    use std::thread;\n    use std::sync::Arc;\n    use self::quickcheck::{Arbitrary, Gen, QuickCheck, TestResult};\n\n    #[derive(Clone, Debug)]\n    enum Op {\n        Enq(u32),\n        Deq,\n    }\n\n    impl Arbitrary for Op {\n        fn arbitrary<G>(g: &mut G) -> Self\n        where\n            G: Gen,\n        {\n            let i: usize = g.gen_range(0, 2);\n            match i {\n                0 => Op::Enq(g.gen()),\n                _ => Op::Deq,\n            }\n        }\n    }\n```", "```rs\n    #[test]\n    fn sequential() {\n        fn inner(ops: Vec<Op>) -> TestResult {\n            let mut vd = VecDeque::new();\n            let q = Queue::new();\n\n            for op in ops {\n                match op {\n                    Op::Enq(v) => {\n                        vd.push_back(v);\n                        q.enq(v);\n                    }\n                    Op::Deq => {\n                        assert_eq!(vd.pop_front(), q.deq());\n                    }\n                }\n            }\n            TestResult::passed()\n        }\n        QuickCheck::new().quickcheck(inner as fn(Vec<Op>) -> \n        TestResult);\n    }\n```", "```rs\n    fn parallel_exp(total: usize, enqs: u8, deqs: u8) -> bool {\n        let q = Queue::new();\n        let total_expected = total * (enqs as usize);\n        let total_retrieved = Arc::new(AtomicUsize::new(0));\n\n        let mut ejhs = Vec::new();\n        for _ in 0..enqs {\n            let mut q = q.clone();\n            ejhs.push(\n                thread::Builder::new()\n                    .spawn(move || {\n                        for i in 0..total {\n                            q.enq(i);\n                        }\n                    })\n                    .unwrap(),\n            );\n        }\n\n        let mut djhs = Vec::new();\n        for _ in 0..deqs {\n            let mut q = q.clone();\n            let total_retrieved = Arc::clone(&total_retrieved);\n            djhs.push(\n                thread::Builder::new()\n                    .spawn(move || {\n                        while total_retrieved.load(Ordering::Relaxed) \n                        != total_expected {\n                            if q.deq().is_some() {\n                                total_retrieved.fetch_add(1, \n                                Ordering::Relaxed);\n                            }\n                        }\n                    })\n                    .unwrap(),\n            );\n        }\n\n        for jh in ejhs {\n            jh.join().unwrap();\n        }\n        for jh in djhs {\n            jh.join().unwrap();\n        }\n\n        assert_eq!(total_retrieved.load(Ordering::Relaxed), \n        total_expected);\n        true\n    }\n```", "```rs\n    #[test]\n    fn repeated() {\n        for i in 0..10_000 {\n            println!(\"{}\", i);\n            parallel_exp(73, 2, 2);\n        }\n    }\n\n    #[test]\n    fn parallel() {\n        fn inner(total: usize, enqs: u8, deqs: u8) -> TestResult {\n            if enqs == 0 || deqs == 0 {\n                TestResult::discard()\n            } else {\n                TestResult::from_bool(parallel_exp(total, enqs, deqs))\n            }\n        }\n        QuickCheck::new().quickcheck(inner as fn(usize, u8, u8) -> \n        TestResult);\n    }\n}\n```", "```rs\nextern crate synchro;\n\nuse synchro::Queue;\nuse std::thread;\n\nfn main() {\n    let q = Queue::new();\n\n    let mut jhs = Vec::new();\n\n    for _ in 0..4 {\n        let eq = q.clone();\n        jhs.push(thread::spawn(move || {\n            let mut i = 0;\n            loop {\n                eq.enq(i);\n                i += 1;\n                eq.deq();\n            }\n        }))\n    }\n\n    for jh in jhs {\n        jh.join().unwrap();\n    }\n}\n```", "```rs\n> time cargo run --bin queue_spin\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/queue_spin`\nSegmentation fault\n\nreal    0m0.588s\nuser    0m0.964s\nsys     0m0.016s\n```", "```rs\n> lldb-3.9 target/debug/queue_spin\n(lldb) target create \"target/debug/queue_spin\"\nCurrent executable set to 'target/debug/queue_spin' (x86_64).\n(lldb) run\nProcess 12917 launched: '/home/blt/projects/us/troutwine/concurrency_in_rust/external_projects/synchro/target/debug/queue_spin' (x86_64)\nProcess 12917 stopped\n* thread #2: tid = 12920, 0x0000555555560585 queue_spin`_$LT$synchro..queue..InnerQueue$LT$T$GT$$GT$::deq::heefaa8c9b1d410ee(self=0x00007ffff6c2a010) + 261 at queue.rs:78, name = 'queue_spin', stop reason = signal SIGSEGV: invalid address (fault address: 0x0)\n    frame #0: 0x0000555555560585 queue_spin`_$LT$synchro..queue..InnerQueue$LT$T$GT$$GT$::deq::heefaa8c9b1d410ee(self=0x00007ffff6c2a010) + 261 at queue.rs:78\n   75                       }\n   76                       self.tail.compare_and_swap(tail, next, \n                            Ordering::Relaxed);\n   77                   } else {\n-> 78                       let val: *mut T = (*next).value as *mut T;\n   79                       if self.head.compare_and_swap(head, next, \n                            Ordering::Release) == head {\n   80                           value = *Box::from_raw(val);\n   81                           break;\n  thread #3: tid = 12921, 0x0000555555560585 queue_spin`_$LT$synchro..queue..InnerQueue$LT$T$GT$$GT$::deq::heefaa8c9b1d410ee(self=0x00007ffff6c2a010) + 261 at queue.rs:78, name = 'queue_spin', stop reason = signal SIGSEGV: invalid address (fault address: 0x0)\n    frame #0: 0x0000555555560585 queue_spin`_$LT$synchro..queue..InnerQueue$LT$T$GT$$GT$::deq::heefaa8c9b1d410ee(self=0x00007ffff6c2a010) + 261 at queue.rs:78\n   75                       }\n   76                       self.tail.compare_and_swap(tail, next, \n                            Ordering::Relaxed);\n   77                   } else {\n-> 78                       let val: *mut T = (*next).value as *mut T;\n   79                       if self.head.compare_and_swap(head, next, \n                            Ordering::Release) == head {\n   80                           value = *Box::from_raw(val);\n   81                           break;\n```", "```rs\n(lldb) p next\n(synchro::queue::Node<i32> *) $0 = 0x0000000000000000\n```", "```rs\n(lldb) Process 12893 launched: '/home/blt/projects/us/troutwine/concurrency_in_rust/external_projects/synchro/target/debug/queue_spin' (x86_64)\nProcess 12893 stopped\n* thread #2: tid = 12896, 0x000055555555fb3e queue_spin`core::sync::atomic::atomic_load::hd37078e3d501f11f(dst=0x0000000000000008, order=Relaxed) + 78 at atomic.rs:1502, name = 'queue_spin', stop reason = signal SIGSEGV: invalid address (fault address: 0x8)\n    frame #0: 0x000055555555fb3e queue_spin`core::sync::atomic::atomic_load::hd37078e3d501f11f(dst=0x0000000000000008, order=Relaxed) + 78 at atomic.rs:1502\n  thread #3: tid = 12897, 0x000055555555fb3e queue_spin`core::sync::atomic::atomic_load::hd37078e3d501f11f(dst=0x0000000000000008, order=Relaxed) + 78 at atomic.rs:1502, name = 'queue_spin', stop reason = signal SIGSEGV: invalid address (fault address: 0x8)\n    frame #0: 0x000055555555fb3e queue_spin`core::sync::atomic::atomic_load::hd37078e3d501f11f(dst=0x0000000000000008, order=Relaxed) + 78 at atomic.rs:1502\n  thread #4: tid = 12898, 0x000055555555fb3e queue_spin`core::sync::atomic::atomic_load::hd37078e3d501f11f(dst=0x0000000000000008, order=Relaxed) + 78 at atomic.rs:1502, name = 'queue_spin', stop reason = signal SIGSEGV: invalid address (fault address: 0x8)\n    frame #0: 0x000055555555fb3e queue_spin`core::sync::atomic::atomic_load::hd37078e3d501f11f(dst=0x0000000000000008, order=Relaxed) + 78 at atomic.rs:1502\n  thread #5: tid = 12899, 0x000055555555fb3e queue_spin`core::sync::atomic::atomic_load::hd37078e3d501f11f(dst=0x0000000000000008, order=Relaxed) + 78 at atomic.rs:1502, name = 'queue_spin', stop reason = signal SIGSEGV: invalid address (fault address: 0x8)\n    frame #0: 0x000055555555fb3e\nqueue_spin`core::sync::atomic::atomic_load::hd37078e3d501f11f(dst=0x0000000000000008, order=Relaxed) + 78 at atomic.rs:1502\n```", "```rs\n 64    pub unsafe fn deq(&mut self) -> Option<T> {\n 65        let mut head: *mut Node<T>;\n 66        let value: T;\n 67        loop {\n 68            head = self.head.load(Ordering::Acquire);\n 69            let tail: *mut Node<T> = \n               self.tail.load(Ordering::Relaxed);\n 70            let next: *mut Node<T> = \n               (*head).next.load(Ordering::Relaxed);\n 71            if head == self.head.load(Ordering::Relaxed) {\n 72                if head == tail {\n 73                    if next.is_null() {\n 74                        return None;\n 75                    }\n 76                    self.tail.compare_and_swap(tail, next, \n                       Ordering::Relaxed);\n 77                } else {\n 78                    let val: *mut T = (*next).value as *mut T;\n 79                    if self.head.compare_and_swap(head, next,  \n                       Ordering::Release) == head {\n 80                        value = *Box::from_raw(val);\n 81                        break;\n 82                    }\n 83                }\n 84            }\n 85        }\n 86        let head: Node<T> = *Box::from_raw(head);\n 87        drop(head);\n 88        Some(value)\n 89    }\n```", "```rs\nextern crate crossbeam;\n\nuse crossbeam::sync::MsQueue;\nuse std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let q = Arc::new(MsQueue::new());\n\n    let mut jhs = Vec::new();\n\n    for _ in 0..4 {\n        let q = Arc::clone(&q);\n        jhs.push(thread::spawn(move || {\n            let mut i = 0;\n            loop {\n                q.push(i);\n                i += 1;\n                q.pop();\n            }\n        }))\n    }\n\n    for jh in jhs {\n        jh.join().unwrap();\n    }\n}\n```", "```rs\nuse crossbeam::sync::MsQueue;\n\nunsafe impl Send for Semaphore {}\nunsafe impl Sync for Semaphore {}\n\npub struct Semaphore {\n    capacity: MsQueue<()>,\n}\n\nimpl Semaphore {\n    pub fn new(capacity: usize) -> Self {\n        let q = MsQueue::new();\n        for _ in 0..capacity {\n            q.push(());\n        }\n        Semaphore { capacity: q }\n    }\n\n    pub fn wait(&self) -> () {\n        self.capacity.pop();\n    }\n\n    pub fn signal(&self) -> () {\n        self.capacity.push(());\n    }\n}\n```", "```rs\nextern crate synchro;\n\nuse std::sync::Arc;\nuse synchro::Semaphore;\nuse std::{thread, time};\n\nconst THRS: usize = 4;\nstatic mut COUNTS: &'static mut [u64] = &mut [0; THRS];\nstatic mut STATUS: &'static mut [bool] = &mut [false; THRS];\n\nfn worker(id: usize, gate: Arc<Semaphore>) -> () {\n    unsafe {\n        loop {\n            gate.wait();\n            STATUS[id] = true;\n            COUNTS[id] += 1;\n            STATUS[id] = false;\n            gate.signal();\n        }\n    }\n}\n\nfn main() {\n    let semaphore = Arc::new(Semaphore::new(1));\n\n    for i in 0..THRS {\n        let semaphore = Arc::clone(&semaphore);\n        thread::spawn(move || worker(i, semaphore));\n    }\n\n    let mut counts: [u64; THRS] = [0; THRS];\n    loop {\n        unsafe {\n            thread::sleep(time::Duration::from_millis(1_000));\n            print!(\"|\");\n            for i in 0..THRS {\n                print!(\" {:>5}; {:010}/sec |\", STATUS[i], \n                       COUNTS[i] - counts[i]);\n                counts[i] = COUNTS[i];\n            }\n            println!();\n        }\n    }\n}\n```", "```rs\n> ./target/release/status_demo\n| false; 0000170580/sec |  true; 0000170889/sec |  true; 0000169847/sec | false; 0000169220/sec |\n| false; 0000170262/sec | false; 0000170560/sec |  true; 0000169077/sec |  true; 0000169699/sec |\n| false; 0000169109/sec | false; 0000169333/sec | false; 0000168422/sec | false; 0000168790/sec |\n| false; 0000170266/sec |  true; 0000170653/sec | false; 0000168184/sec |  true; 0000169570/sec |\n| false; 0000170907/sec | false; 0000171324/sec |  true; 0000170137/sec | false; 0000169227/sec |\n...\n```", "```rs\n> ./target/release/status_demo\n| false; 0000068840/sec |  true; 0000063798/sec | false; 0000063918/sec | false; 0000063652/sec |\n| false; 0000074723/sec | false; 0000074253/sec |  true; 0000074392/sec |  true; 0000074485/sec |\n|  true; 0000075138/sec | false; 0000074842/sec | false; 0000074791/sec |  true; 0000074698/sec |\n| false; 0000075099/sec | false; 0000074117/sec | false; 0000074648/sec | false; 0000075083/sec |\n| false; 0000075070/sec |  true; 0000074509/sec | false; 0000076196/sec |  true; 0000074577/sec |\n|  true; 0000075257/sec |  true; 0000075682/sec | false; 0000074870/sec | false; 0000075887/sec |\n...\n```", "```rs\ndiff --git a/external_projects/synchro/src/bin/status_demo.rs b/external_projects/synchro/src/bin/status_demo.rs\nindex cb3e850..fef2955 100644\n--- a/external_projects/synchro/src/bin/status_demo.rs\n+++ b/external_projects/synchro/src/bin/status_demo.rs\n@@ -21,7 +21,7 @@ fn worker(id: usize, gate: Arc<Semaphore>) -> () {\n }\n\n fn main() {\n-    let semaphore = Arc::new(Semaphore::new(2));\n+    let semaphore = Arc::new(Semaphore::new(1));\n\n     for i in 0..THRS {\n         let semaphore = Arc::clone(&semaphore);\n```", "```rs\n| false; 0000090992/sec |  true; 0000090993/sec |  true; 0000091000/sec | false; 0000090993/sec |\n| false; 0000090469/sec | false; 0000090468/sec |  true; 0000090467/sec |  true; 0000090469/sec |\n|  true; 0000090093/sec | false; 0000090093/sec | false; 0000090095/sec | false; 0000090093/sec |\n```", "```rs\nuse std::sync::{Arc, Mutex};\nuse std::{thread, time};\n\nconst THRS: usize = 4;\nstatic mut COUNTS: &'static mut [u64] = &mut [0; THRS];\nstatic mut STATUS: &'static mut [bool] = &mut [false; THRS];\n\nfn worker(id: usize, gate: Arc<Mutex<()>>) -> () {\n    unsafe {\n        loop {\n            let guard = gate.lock().unwrap();\n            STATUS[id] = true;\n            COUNTS[id] += 1;\n            STATUS[id] = false;\n            drop(guard);\n        }\n    }\n}\n\nfn main() {\n    let mutex = Arc::new(Mutex::new(()));\n\n    for i in 0..THRS {\n        let mutex = Arc::clone(&mutex);\n        thread::spawn(move || worker(i, mutex));\n    }\n\n    let mut counts: [u64; THRS] = [0; THRS];\n    loop {\n        unsafe {\n            thread::sleep(time::Duration::from_millis(1_000));\n            print!(\"|\");\n            for i in 0..THRS {\n                print!(\" {:>5}; {:010}/sec |\", STATUS[i], \n                       COUNTS[i] - counts[i]);\n                counts[i] = COUNTS[i];\n            }\n            println!();\n        }\n    }\n}\n```", "```rs\n| false; 0001856267/sec | false; 0002109238/sec |  true; 0002036852/sec |  true; 0002172337/sec |\n| false; 0001887803/sec |  true; 0002072647/sec | false; 0002065467/sec |  true; 0002143558/sec |\n| false; 0001848387/sec | false; 0002044828/sec |  true; 0002098595/sec |  true; 0002178304/sec |\n```", "```rs\n|  true; 0012527450/sec | false; 0011959925/sec |  true; 0011863078/sec | false; 0012509126/sec |\n|  true; 0012573119/sec | false; 0011949160/sec |  true; 0011894659/sec | false; 0012495174/sec |\n| false; 0012481696/sec |  true; 0011952472/sec |  true; 0011856956/sec | false; 0012595455/sec |\n```"]