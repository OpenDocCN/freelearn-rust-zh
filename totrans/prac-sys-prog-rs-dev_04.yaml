- en: '*Chapter 3*: Introduction to the Rust Standard Library'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built a command-line tool using various Rust language
    primitives and modules from the Rust Standard Library. However, in order to fully
    exploit the power of Rust, it is imperative to understand the breadth of what
    features are available within the standard library for system programming tasks,
    without having to reach out to third-party crates.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll deep-dive into the structure of the Rust Standard Library.
    You'll get an introduction to the standard modules for accessing system resources
    and learn how to manage them programmatically. With the knowledge gained, we will
    implement a tiny portion of a template engine in Rust. By the end of this chapter,
    you will be able to confidently navigate the Rust Standard Library and make use
    of it in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key learning outcomes for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Rust Standard Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing one feature of a template engine using the standard library modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rustup and Cargo must be installed in your local development environment. The
    GitHub repository for the examples in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: The Rust Standard Library and systems programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the standard library, let's understand the context of how
    it fits into systems programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In systems programming, one of the cardinal requirements is to manage system
    resources such as memory, files, network I/O, devices, and processes. Every operating
    system has a kernel (or equivalent), which is the central software module that
    is loaded in memory and connects the system hardware with the application processes.
    You may think, where does the Rust Standard Library fit in then? Are we going
    to write a kernel in Rust? No, that''s not the purpose of this book. The most
    popular operating systems, which are basically the Unix, Linux, and Windows variants,
    all have kernels written mostly in **C** with a mix of assembly. It is still early
    days for Rust to augment C as the kernel development language, though there are
    several experimental efforts in that direction. However, what the Rust Standard
    Library offers is an API interface to make system calls from Rust programs, in
    order to manage and manipulate various system resources. The following figure
    shows this context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Rust Standard Library](img/Figure_3.1_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Rust Standard Library
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through this figure to understand each of the components better:'
  prefs: []
  type: TYPE_NORMAL
- en: '`read()`, which the kernel will then execute on behalf of the editor program.
    The reason for this restriction is that modern processor architectures (such as
    x86-64) allow the CPU to operate at two different privilege levels—*kernel mode*
    and *user mode*. The user mode has a lower level of privilege than the kernel
    mode. The CPU can perform certain operations only while running in the kernel
    mode. This design prevents user programs from accidentally doing tasks that could
    adversely affect the system operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System call (syscall) interface**: The kernel also provides a system call
    *application programming interface* that acts as the entry point for processes
    to request the kernel to perform various tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libc` (or `glibc`). For the Windows operating system, there are equivalent
    APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libc` (or another platform-specific equivalent library) internally to invoke
    system calls. The Rust Standard Library is cross-platform, which means that the
    details of how system calls are invoked (or which wrapper libraries are used)
    are abstracted away from the Rust developer. There are ways to invoke system calls
    from Rust code without using the standard library (for example, in embedded systems
    development), but that is beyond the scope of this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User space programs**: These are the programs that you will write as part
    of this book using the standard library. The *arithmetic expression evaluator*
    you wrote in the previous chapter is an example of this. In this chapter, you
    will learn how to write a feature of the template engine using the standard library,
    which is also a user space program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Not all modules and functions within the Rust Standard Library invoke system
    calls (for example, there are methods for string manipulation, and to handle errors).
    As we go through the standard library, it is important to remember this distinction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's now begin our journey to understand and start using the Rust Standard
    Library.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Rust Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We earlier discussed the role of the Rust Standard Library in enabling user
    programs to invoke kernel operations. The following are some of the notable features
    of the standard library, which we will refer to as `std` for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std` is cross-platform. It provides functionality that hides the differences
    among underlying platform architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std` is available to all Rust crates by default. The `use` statement gives
    access to the respective modules and their constituents (traits, methods, structs,
    and so on). For example, the statement `use std::fs` gives access to the module
    providing file manipulation operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std` includes operations on standard Rust primitives (such as integers and
    floating-point numbers). For example, `std::i8::MAX` is a constant implemented
    in the standard library that specifies the maximum value that can be stored in
    a variable of type i8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It implements core data types such as *vector, strings*, and *smart pointers*
    such as `Box`, `Rc`, and `Arc`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides functionality for operations such as data manipulation, memory allocation,
    error handling, networking, I/O, concurrency, async I/O primitives, and foreign
    function interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows a high-level view of the Rust standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Rust Standard Library – high-level view](img/Figure_3.2_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Rust Standard Library – high-level view
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rust Standard Library (`std`) is broadly organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rust language primitives**, which contain basic types such as signed and
    unsigned, integers, bool, floating point, char, array, tuple, slice, and string.
    Primitives are implemented by the compiler. The Rust Standard Library includes
    the primitives and builds on top of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `libc`) or other external dependencies. You can instruct the compiler to
    compile without the Rust Standard Library and use the core crate instead (such
    an environment is called `no_std` in Rust parlance, which is annotated with the
    `#![no_std]` attribute), and this is used commonly in embedded programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Box<T>`), reference-counted pointers (`Rc<T>`), and atomically reference-counted
    pointers (`Arc<T>`). It also includes and collections such as `Vec` and `String`
    (note that `String` is implemented in Rust as a UTF-8 sequence). This crate does
    not need to be used directly when the standard library is used, as the contents
    of the `alloc` crate are re-exported and made available as part of the `std` library.
    The only exception to this rule is when developing in a `no_std` environment,
    when this crate can be directly used to access its functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core` or `alloc` crates) include rich functionality for operations around
    concurrency, I/O, file system access, networking, async I/O, errors, and OS-specific
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will not directly work with the `core` or `alloc` crates, but
    use the Rust Standard Library modules that are a higher-level abstraction over
    these crates.
  prefs: []
  type: TYPE_NORMAL
- en: We will now analyze the key modules within the Rust Standard Library with a
    focus on systems programming. The standard library is organized into modules.
    For example, the functionality that enables user programs to run on multiple threads
    for concurrency is in the `std::thread` module, and the Rust constructs for dealing
    with synchronous I/O are in the `std::io` module. Understanding how the functionality
    within the standard library is organized across modules is a critical part of
    being an effective and productive Rust programmer.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.3* shows the layout of the standard library modules organized into
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Rust Standard Library modules](img/Figure_3.3_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Rust Standard Library modules
  prefs: []
  type: TYPE_NORMAL
- en: The modules in this figure have been grouped by their primary area of focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we know, though, which of these modules is related to managing system
    resources? As this might be of interest for the purposes of this book, let''s
    attempt to classify the modules further into one of these two buckets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syscalls-oriented**: These are modules that either manage system hardware
    resources directly or require the kernel for other privileged operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Computation-oriented**: These are the modules that are oriented towards data
    representation, computation, and instructions to the compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 3.4* shows the same module grouping as in *Figure 3.3* but segregated
    as **Syscalls-oriented** or **Computation-oriented**. Note that this may not be
    a perfect classification as not all methods in all modules marked in the **Syscalls-oriented**
    category involve actual system calls. But this classification can serve as a guide
    to find our way around the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Rust modules with classification](img/Figure_3.4_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Rust modules with classification
  prefs: []
  type: TYPE_NORMAL
- en: Let's get to know the functionality of each module.
  prefs: []
  type: TYPE_NORMAL
- en: Computation-oriented modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard library modules in this section deal *mostly* with programming
    constructs that deal with data processing, data modeling, error handling, and
    instructions to the compiler. Some of the modules may have functionality that
    overlaps with the syscalls-oriented category, but this grouping is based on the
    primary focus of each module.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The modules related to data types and structures in the Rust Standard Library
    are mentioned in this section. There are broadly two categories of data types
    in Rust. The first group comprises primitive types such as integers (signed, unsigned),
    floating points, and char, which are a core part of the language and compiler
    and the standard library adds additional functionality to those types. The second
    group consists of higher-level data structures and traits such as vectors and
    strings, which are implemented within the standard library. Modules from both
    these groups are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`any`: This can be used when the type of the value passed to a function is
    not known at compile time. Runtime reflection is used to check the type and perform
    suitable processing. An example of using this would be in the logging function,
    where we want to customize what is logged depending on the data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array`: It contains utility functions such as comparing arrays, implemented
    over the primitive array type. Note that Rust arrays are value types, that is,
    they are allocated on the stack, and have a fixed length (not growable).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`: This contains utility functions implemented over the `char` primitive
    type, such as checking for digits, converting to uppercase, encoding to UTF-8,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collections`: This is Rust''s standard collection library, which contains
    efficient implementations of common collection data structures used in programming.
    Collections in this library include `Vectors`, `LinkedLists`, `HashMaps`, `HashSet`,
    `BTtreeMap`, `BTreeSet`, and `BinaryHeap`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f32`, `f64`: This library provides constants specific to floating point implementations
    of the `f32` and `f64` primitive types. Examples of constants are `MAX` and `MIN`,
    which provide the maximum and minimum value of floating point numbers that can
    be stored by `f32` and `f64` types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i8`, `i16`, `i32`, `i64`, `i128`: Signed integer types of various sizes. For
    example, `i8` represents a signed integer of length 8 bits (1 byte) and `i128`
    represents a signed integer of length 128 bits (16 bytes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u8`, `u16`, `u32`, `u64`, `u128`: Unsigned integer types of various sizes.
    For example, `u8` represents an unsigned integer of length 8 bits (1 byte) and
    `u128` represents an unsigned integer of length 128 bits (16 bytes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isize`, `usize`: Rust has two data types, `isize` and `usize`, that correspond
    to signed and unsigned integer types. The uniqueness of these types is that their
    size is dependent on whether the CPU uses a 32-bit or 64-bit architecture. For
    example, on a 32-bit system, the size of the `isize` and `usize` data types is
    32 bits (4 bytes), and likewise, for 64-bit systems, their size is 64 bits (8
    bytes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`marker`: Basic properties that can be attached to types (in the form of traits)
    are described in this module. Examples include `Copy` (types whose values can
    be duplicated by a simple copy of its bits) and `Send` (thread-safe types).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slice`: Contains structs and methods useful to perform operations such as
    `iterate` and `split` on `slice` data types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: This module contains the `String` type and methods such as `to_string`,
    which allows converting a value to a `String`. Note that `String` is not a primitive
    data type in Rust. The primitive types in Rust are listed here: [https://doc.rust-lang.org/std/](https://doc.rust-lang.org/std/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str`: This module contains structs and methods associated with string slices
    such as `iterate` and `split` on `str` slices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vec`: This module contains the `Vector` type, which is a growable array with
    heap-allocated contents, and associated methods for operating on vectors such
    as splicing and iterating. A `vec` module is an owned reference and a smart pointer
    (such as `Box<T>`). Note that `vec` was originally defined in the `alloc` crate,
    but was made available as part of both the `std::vec` and `std::collections` modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an assorted collection of modules that provides helper methods for
    different types of processing such as dealing with ASCII characters, comparing,
    ordering, and printing formatted values, arithmetic operations, and iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ascii`: Most string operations in Rust act on UTF-8 strings and characters.
    But in some cases, there may be a need to operate on ASCII characters only. This
    module provides operations on ASCII strings and characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmp`: This module contains functions for ordering and comparing values, and
    associated macros. For example, implementing the `Eq` trait contained in this
    module allows a comparison of custom struct instances using the `==` and `!=`
    operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmt`: This module contains utilities to format and print strings. Implementing
    this trait enables printing any custom data type using the `format!` macro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hash`: This module provides functionality to compute a hash of data objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iter`: This module contains the `Iterator` trait, which is part and parcel
    of idiomatic Rust code, and a popular feature of Rust. This trait can be implemented
    by custom data types for iterating over their values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num`: This module provides additional data types for numeric operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops`: This module has a set of traits that allow you to overload operators
    for custom data types. For example, the `Add` trait can be implemented for a custom
    struct and the `+` operator can be used to add two structs of that type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This group consists of modules that have functionality for error handling in
    Rust programs. The `Error` trait is the foundational construct to represent errors.
    `Result` deals with the presence or absence of errors in the return value of functions,
    and `Option` deals with the presence or absence of values in a variable. The latter
    prevents the dreaded *null value* error that plagues several programming languages.
    `Panic` is provided as a way to exit the program if errors cannot be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '`error`: This module contains the `Error` trait, which represents the basic
    expectations of error values. All errors implement the trait `Error`, and this
    module is used to implement custom or application-specific error types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`option`: This module contains the `Option` type, which provides the ability
    for a value to be initialized to either `Some` value or `None` value. The `Option`
    type can be considered as a very basic way to handle errors involving the absence
    of values. Null values cause havoc in other programming languages in the form
    of null pointer exceptions or the equivalent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`panic`: This module provides support to deal with panic including capturing
    the cause of panic and setting hooks to trigger custom logic on panic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result`: This module contains the `Result` type, which along with the `Error`
    trait and `Option` type form the foundation of error handling in Rust. `Result`
    is represented as `Result<T,E>`, which is used to return either values or errors
    from functions. Functions return the `Result` type whenever errors are expected
    and if the error is recoverable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreign function interface (FFI)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FFI is provided by the `ffi` module. This module provides utilities to exchange
    data across non-Rust interface boundaries, such as working with other programming
    languages or to deal directly with the underlying operating system/kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This group contains modules that are related to the Rust compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '`hint`: This module contains functions to hint to the compiler about how code
    should be emitted or optimized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prelude`: The prelude is the list of items that Rust automatically imports
    into each Rust program. It is a convenience feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`primitive`: This module re-exports Rust primitive types, normally for use
    in macro code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've so far seen the **computation-oriented** modules of the Rust standard
    library. Let's take a look at the **syscalls-oriented** modules now.
  prefs: []
  type: TYPE_NORMAL
- en: Syscalls-oriented modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the previous group of modules was related to in-memory computations, this
    section deals with operations that involve managing hardware resources or other
    privileged operations that *normally* require kernel intervention. Note that not
    all methods in these modules involve system calls to the kernel, but it helps
    to construct a mental model at the module level.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This grouping contains a set of modules from the standard library that deal
    with memory management and smart pointers. Memory management includes static memory
    allocation (on the stack), dynamic memory allocation (on the heap), memory deallocation
    (when a variable goes out of scope, its destructor is run), cloning or copying
    values, managing raw pointers and smart pointers (which are pointers to data on
    the heap), and fixing memory locations for objects so that they cannot be moved
    around (which is needed for special situations). The modules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alloc`: This module contains APIs for the allocation and deallocation of memory,
    and to register a custom or third-party memory allocator as the standard library''s
    default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`borrow`: In Rust, it is common to use different representations of a given
    type for different use cases. For example, a value can be stored and managed as
    `Box<T>`, `Rc<T>`, or `Arc<T>`. Similarly, a string value can be stored as the
    `String` or `str` type. Rust provides methods that allow one type to be borrowed
    as some other type, by implementing the `borrow` method from the `Borrow` trait.
    So basically, a type is free to be borrowed as many different types. This module
    contains the trait `Borrow`, which allows the conversion of an owned value to
    borrowed or to convert borrowed data of any type to an owned value. For example,
    a value of type `String` (which is an owned type) can be borrowed as `str`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cell`: In Rust, memory safety is based on the rule that a value can have either
    several immutable references to it or a single mutable reference. But there may
    be scenarios where a shared, mutable reference is required. This module provides
    shareable mutable containers that include `Cell` and `RefCell`. These types provide
    controlled mutability of shared types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone`: In Rust, primitive types such as integers are *copyable*, that is,
    they implement the `Copy` trait. This means that when assigning the value of a
    variable to another variable or while passing a parameter to a function, the value
    of the object is duplicated. But not all types can be copied, because they may
    require memory allocations (for example, `String` or `Vec` types where memory
    is allocated in the heap, rather than the stack). In such cases, a `clone()` method
    is used to duplicate a value. This module provides the `Clone` trait, which allows
    values of custom data types to be duplicated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convert`: This module contains functionality to facilitate the conversion
    between data types. For example, by implementing the `AsRef` trait contained in
    this module, you can write a function that takes a parameter of type `AsRef<str>`,
    which means that this function can accept any reference that can be converted
    into a string reference (`&str`). Since both the `str` and `String` types implement
    the `AsRef` trait, you can pass either a `String` reference (`String`) or string
    slice reference (`&str`) to this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: This module has the trait `Default`, which is used to assign meaningful
    default values for data types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mem`: This module contains memory-related functions including querying memory
    size, initialization, swapping, and other memory manipulation operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pin`: Types in Rust are movable, by default. For example, on a `Vec` type,
    a `pop()` operation moves a value out and a push operation may result in the reallocation
    of memory. However, there are situations where it is useful to have objects that
    have fixed memory locations and do not move. For example, self-referencing data
    structures such as linked lists. For such cases, Rust provides a data type that
    pins data to a location in memory. This is achieved by wrapping a type in the
    pinned pointer, `Pin<P>`, which pins the value `P` in its place in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ptr`: Working with raw pointers in Rust is not common, and is used only in
    selective use cases. Rust allows working with raw pointers in unsafe code blocks,
    where the compiler does not take responsibility for memory safety and the programmer
    is responsible for memory-safe operations. This module provides functions to work
    with raw pointers. Rust supports two types of raw pointers—immutable (for example,
    `*const i32`) and mutable (for example, `*mut i32`). Raw pointers have no restrictions
    on how they are used. They are the only pointer type in Rust that can be null,
    and there is no automatic dereferencing of raw pointers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rc`: This module provides single-threaded reference-counting pointers, where
    `rc` stands for reference-counted. A reference-counted pointer to an object of
    type `T` can be represented as `Rc<T>`. `Rc<T>` provides shared ownership of value
    `T`, which is allocated in the heap. If a value of this type is cloned, it returns
    a new pointer to the same memory location in the heap (does not duplicate the
    value in memory). This value is retained until the last `Rc` pointer that references
    this value is in existence, after which the value is dropped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This category groups modules related to synchronous concurrent processing. Concurrent
    programs can be designed in Rust by spawning processes, spawning threads within
    a process, and having ways to synchronize and share data across threads and processes.
    Asynchronous concurrency is covered under the `Async` group.
  prefs: []
  type: TYPE_NORMAL
- en: '`env`: This module allows inspecting and manipulating a process''s environment,
    including environment variables, the arguments of a process, and paths. This module
    could belong to its own category as it is widely used beyond just concurrency,
    but it is grouped here along with the `process` module because this module is
    designed to work with a *process* (for example, getting and setting the environment
    variables of a process or getting the command-line parameters used to start a
    process).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process`: This module provides functions for dealing with processes including
    spawning a new process, handling I/O, and terminating processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync`: The sequence of instructions executed in a Rust program may vary in
    cases where concurrency is involved. In such cases, there may be multiple threads
    of execution in parallel (for example, multiple threads in a multi-core CPU),
    in which case synchronization primitives are needed to coordinate operations across
    threads. This module includes synchronization primitives such as `Arc`, `Mutex`,
    `RwLock`, and `Condvar`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread`: Rust''s threading model consists of native OS threads. This module
    provides functionality to work with threads such as spawning new threads, and
    configuring, naming, and synchronizing them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This contains two modules that deal with filesystem operations. The `fs` module
    deals with methods for working with and manipulating the contents of the local
    file system. The `path` module provides methods to navigate and manipulate directory
    and file system paths programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fs`: This module contains operations to work with and manipulate file systems.
    Note that operations in this module can be used cross-platform. Structs and methods
    in this module deal with files, naming, file types, directories, file metadata,
    permissions, and iterating over entries in a directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: This module provides the types `PathBuf` and `Path` for working with
    and manipulating paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input-Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This contains the `io` module, which provides core I/O functionality. The `io`
    module contains common functions that are used while dealing with inputs and outputs.
    This includes reading and writing to I/O types, such as files or TCP streams,
    buffered reads and writes for better performance, and working with standard input
    and output.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The core networking functionality is provided by the `net` module. This module
    contains the primitives for TCP and UDP communications and for working with ports
    and sockets.
  prefs: []
  type: TYPE_NORMAL
- en: OS-specific
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OS-specific functions are provided in the `os` module. This module contains
    platform-specific definitions and extensions for the Linux, Unix, and Windows
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `time` module provides functions to work with system time. This module contains
    structs to deal with system time and to compute durations, typically used for
    system timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: Async
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Asynchronous I/O functionality is provided by the `future` and `task` modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`future`: This contains the `Future` trait that serves as the foundation for
    building asynchronous services in Rust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`task`: This module provides functions needed to work with asynchronous tasks
    including `Context`, `Waker`, and `Poll`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A note on the prelude module
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we've seen, Rust comes with a lot of functionality in the standard library.
    To use it, you have to import the respective modules into the programs. However,
    there is a set of commonly needed *traits*, *types*, and *functions* that Rust
    automatically imports into every Rust program, so the Rust programmer does not
    have to manually import them. This is called the `use std::prelude::v1::*` into
    Rust programs. This module re-exports frequently used Rust constructs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The list of items exported by the `prelude` module includes traits, types, and
    functions including `Box`, `Copy`, `Send`, `Sync`, `drop`, `Clone`, `Into`, `From`,
    `Iterator`, `Option`, `Result`, `String`, and `Vec`. The list of modules re-exported
    can be found at [https://doc.rust-lang.org/std/prelude/v1/index.html](https://doc.rust-lang.org/std/prelude/v1/index.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This concludes the overview of the Rust Standard Library modules. The Rust Standard
    Library is vast and is rapidly evolving. It is highly recommended that you review
    the official documentation at [https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html)
    with the understanding gained in this chapter, for specific methods, traits, data
    structures, and example snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the next section where we will put this knowledge to use
    by writing some code.
  prefs: []
  type: TYPE_NORMAL
- en: Building a template engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the design of an **HTML template engine** and
    implement one of the features using the Rust Standard Library. Let's first understand
    what a template engine is.
  prefs: []
  type: TYPE_NORMAL
- en: Applications such as web and mobile apps use structured data stored in datastores
    such as relational databases, NoSQL databases, and key-value stores. However,
    there is a lot of data on the web that is unstructured. One particular example
    is text data that all web pages contain. Web pages are generated as HTML files
    that have a text-based format.
  prefs: []
  type: TYPE_NORMAL
- en: 'On observing closely, we can see that an HTML page has two parts: *static text
    literals* and *dynamic parts*. The HTML page is authored as a template with the
    static and dynamic parts, and the context for HTML generation comes from a data
    source. While generating a web page, the generator should take the static text
    and output it without change, while it should combine some processing and the
    supplied context to generate the dynamic string result. Generating HTML pages
    involves syscalls (to create, open, read, and write files) and computationally
    intensive in-memory string manipulations.'
  prefs: []
  type: TYPE_NORMAL
- en: A **template engine** is the system software component that can be used to generate
    dynamic HTML pages in a performant manner. It contains a combination of software
    components including parsers, tokenizers, generators, and template files.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.5* shows the process involved in generating HTML with a template
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.5_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Generating HTML with templates
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s take an example of an internet banking page
    showing a statement of transactions for a customer. This can be built using an
    HTML template, where:'
  prefs: []
  type: TYPE_NORMAL
- en: The static HTML includes the bank name, logo, other branding, and content that
    is *common to all users*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dynamic portion of the web page contains the actual list of past transactions
    *for the logged-in user*. The transaction list varies from user to user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The advantage of this approach is the segregation of responsibilities in the
    web development life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: A *frontend (web) designer* can author the static HTML with sample data using
    web design tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *template designer* would convert the static HTML into an HTML template embedding
    the metadata for the dynamic portions of the page in specific syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At runtime (when the page request comes into the server), *the template engine*
    takes the template file from the specified location, applies the transaction list
    for the logged-in user from the database, and generates the final HTML page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of popular template engines include *Jinja, Mustache, Handlebars, HAML,
    Apache Velocity, Twig*, and *Django*. There are differences in the architectures
    and syntax adopted by the various template engines.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will write the structure for a basic template engine that uses
    a syntax similar to **Django templates**. *Django* is a popular web framework
    in Python. Commercial templating engines such as that in *Django* are full-featured
    and complex. It will not be possible for us to recreate them completely in this
    chapter, but we will build the code structure and implement a representative feature.
  prefs: []
  type: TYPE_NORMAL
- en: Types of HTML template engines
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of HTML template engines, based on when the template data
    is parsed.
  prefs: []
  type: TYPE_NORMAL
- en: The first type of template engines parse the HTML template and convert it into
    code, at compilation time. Then, at runtime, dynamic data is fetched and loaded
    into the compiled template. These tend to have better runtime performance as part
    of the work is done at compilation time.
  prefs: []
  type: TYPE_NORMAL
- en: The second type of template engines do both the parsing of the template and
    HTML generation at runtime. We will be using this type in our project, as it is
    relatively simple to understand and implement.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the design of an HTML template file.
  prefs: []
  type: TYPE_NORMAL
- en: Template syntax and design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A template is essentially a text file. A list of common features supported
    by a template file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Literals, for example, `<h1> hello world </h1>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template variables surrounded by `{{` and `}}`, for example, `<p> {{name}} </p>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control logic using an `if` tag, for example, `{% if amount > 100000 %} {% endif
    %}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop control with a `for` tag, for example, `<ul>{% for customer in customer_list}<li>{{customer.name}}</li>{%
    endfor %}</ul>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content import, for example, `{% include "footer.html" %}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters, for example, `{{name | upper}}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 3.6* shows a sample template and the HTML generated from the template
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Conceptual model of the template engine](img/Figure_3.6_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Conceptual model of the template engine
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3.6*, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side, a sample template file is shown. The template file is
    a mix of static and dynamic content. An example of static content is `<h1> Welcome
    to XYZ Bank </h1>`. An example of dynamic content is `<p> Welcome {{name}} </p>`,
    because the value for `name` will be substituted at runtime. There are three types
    of dynamic content shown in the template file – an `if` tag, a `for` tag, and
    a template variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the middle of the figure, we can see the template engine with two sources
    of inputs – template file and data source. The template engine takes these inputs
    and generates the output HTML file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 3.7* explains the working of the template engine using an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Illustrated example for a template engine](img/Figure_3.7_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Illustrated example for a template engine
  prefs: []
  type: TYPE_NORMAL
- en: 'From a design standpoint, the template engine has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by understanding the steps involved in HTML generation using the
    template engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template file contains a set of statements. Some of these are static literals
    while others are placeholders for dynamic content represented using special syntax.
    The template engine reads each statement from the template file. Let''s call each
    line read as a template string, henceforth. The process flow begins with the template
    string read from the template file:'
  prefs: []
  type: TYPE_NORMAL
- en: The template string is fed to the parser. The template string in our example
    is `<p> Welcome {{name}} </p>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parser first determines the type of template string, which is called `if`
    tags, `for` tags, and template variables. In this example, a token of type template
    variable is generated (if the template string contains a static literal, it is
    written to the HTML output without any changes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then the template string is parsed into a static literal, `Welcome`, and a template
    variable `{{name}}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The outputs of the parser (from steps 2 and 3) are passed to the HTML generator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data from a data source is passed as context by the template engine to the generator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parsed token and strings (from steps 2 and 3) are combined with the context
    data (from *step 5*) to produce the result string, which is written to the output
    HTML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps are repeated for every statement (template string) read
    from the template file.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use the parser we created for arithmetic parsing in [*Chapter 2*](B16405_02_Final_NM_ePUB.xhtml#_idTextAnchor041),
    *A Tour of the Rust Programming Language*, for this example, as we need something
    specific for the HTML template language syntax. We could use the general-purpose
    parsing libraries (for example, `nom`, `pest`, and `lalrpop` are a few popular
    parsing libraries in Rust), but for this book, we will custom-build a template
    parser. The reason for this approach is that each parsing library has its own
    API and grammar that we need to familiarize ourselves with. Doing that would deviate
    from the goal of this book, which is learning to write idiomatic code in Rust
    from the first principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a new library project with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `src/lib.rs` file (which is automatically created by the `cargo` tool) will
    contain all the functionality of the template engine.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, `src/main.rs`. The `main()` function will be placed in this
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now design the code structure for the template engine. *Figure 3.8*
    shows the detailed design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: Design of the template engine](img/Figure_3.8_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Design of the template engine'
  prefs: []
  type: TYPE_NORMAL
- en: Let's cover the key data structures and functions of the template engine along
    with some code snippets. We will start with the data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ContentType` is the main data structure to classify the *template string*
    read from the *template file*. It is represented as `enum` and contains the list
    of possible `ContentType` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Pay special attention to the annotations `PartialEq` and `Debug`. The former
    is used to allow content types to be compared, and the latter is used to print
    the values of the content to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Derivable traits
  prefs: []
  type: TYPE_NORMAL
- en: The Rust compiler can automatically derive default implementations for a few
    traits defined in the standard library. Such traits are called *derivable traits*.
    To instruct the compiler to provide default trait implementations, the `#[derive]`
    attribute is used. Note that this can be done only for types such as custom structs
    and enums that you have defined, not for types defined in other libraries that
    you don't own.
  prefs: []
  type: TYPE_NORMAL
- en: Types for which trait implementations can be derived automatically include comparison
    traits such as `Eq`, `PartialEq`, and `Ord`, and others such as `Copy`, `Clone`,
    `Hash`, `Default`, and `Debug`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TagType` is a supporting data structure that is used to indicate whether a
    template string corresponds to a `for-tag` (repetitive loop) or `if-tag` (display
    control):'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a struct to store the result of the tokenization of the template
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that `head` and `tail` are of type `Option<String>` to allow for the possibility
    that a template variable may not contain static literal text before or after it.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the template string is first tokenized as type `ContentType::TemplateVariable(ExpressionData)`,
    and `ExpressionData` is parsed into `head="Hello"`, `variable="name"`, and `tail
    =",welcome"`.
  prefs: []
  type: TYPE_NORMAL
- en: Key functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at the key functions to implement the template engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Program: main()`: This is the starting point of the program. It first calls
    functions to tokenize and parse the template string, accepts context data to feed
    into the template, and then calls functions to generate the HTML using the parser
    outputs and context data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program: get_content_type()`: This is the entry point into the parser. It
    parses each line of the template file (which we refer to as the template string)
    and classifies it as one of the following token types: Literal, Template variable,
    Tag, or Unrecognized. The Tag token type can be either a `for` tag or an `if`
    tag. If the token is of type Template variable, it parses the template string
    to extract the head, tail, and template variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These types are defined as part of the `ContentType` enum. Let''s write a few
    test cases to crystallize what we would like to see as inputs and outputs to this
    function, and then look at the actual code for `get_content_type()`. Let''s take
    a `tests` module by adding the following block of code in `src/lib.rs`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Place the unit tests within this `tests` module. Each test will begin with the
    annotation `#[test]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case 1**: To check if the content type is a literal:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This test case is to check whether the literal string stored in variable `s`
    is tokenized as `ContentType::Literal(s)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case 2**: To check if the content type is of the template variable type:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For the `Template String` token type, this test case checks to see if the expression
    in the template string is parsed into the `head`, `variable`, and `tail` components,
    and successfully returned as type `ContentType::TemplateVariable (ExpressionData)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ForTag`:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This test case is to check if a statement containing a `for` tag is tokenized
    successfully as `ContentType::Tag(TagType::ForTag)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`IfTag`:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This test case is to check if a statement containing an `if` tag is tokenized
    successfully as `ContentType::Tag(TagType::IfTag)`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have written the unit test cases, let's write the code for the template
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the template engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two key parts to writing the template engine – the parser and HTML
    generator. We will start with the parser. *Figure 3.9* shows the design of the
    parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.9_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Parser design'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief description of the various methods in the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_content_type()`: Entry point for parser. Accepts an input statement and
    tokenizes it into one of an `if` tag, a `for` tag, or a template variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check_symbol_string()`: This is a supporting method that checks if a symbol
    is present within another string. For example, we can check if the pattern `{%`
    is present in a statement from the template file, and use it to determine if it
    is a tag statement or template variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check matching pair()`: This is a supporting method that is used to verify
    if a statement in a template file is syntactically correct. For example, we can
    check for the presence of matching pairs `{%` and `%}`. Otherwise, the statement
    is marked as `Unrecognized`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_index_for_symbol()`: This method returns the starting index of a substring
    within another string. It is used for string manipulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_expression_data()`: This method parses a template string into its constituent
    parts for a token of type `TemplateString`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the parser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s first look at the `get_content_type()` method. Here is a summary of
    the program logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for` tags are enclosed by `{%` and `%}` and contain the `for` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` tags are enclosed by `{%` and `%}` and contain the `if` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template variables are enclosed by `{{` and `}}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on these rules, the statement is parsed and the appropriate token is returned
    – a `for` tag, an `if` tag, or a template variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete code listing for the `get_content_type()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Supporting functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s now talk about supporting functions. The parser utilizes these supporting
    functions to perform operations such as checking for the presence of a substring
    within a string, checking for matching pairs of braces, and so on. They are needed
    to check whether the template string is syntactically correct, and also to parse
    the template string into its constituent parts. Before writing some more code,
    let''s look at the test cases for these supporting functions to understand how
    they will be used, and then see the code. Note that these functions are designed
    to enable reuse across projects. All supporting functions are placed in `src/lib.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`check_symbol_string()`: Checks if a symbol string, for example, `''{%''`,
    is contained within another string. Here is the test case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the code for the function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The standard library provides a straightforward way to check for a substring
    within a string slice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`check_matching_pair()`: This function checks for matching symbol strings.
    Here is the test case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'pub fn check_matching_pair(input: &str, symbol1: &str,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'symbol2: &str) -> bool {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: input.contains(symbol1) && input.contains(symbol2)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`get_expression_data()`: This parses an expression with a template variable,
    parses it into `head`, `variable`, and `tail` components, and returns the results.
    Here is the test case for this function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the code for the function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`get_index_for_symbol`: This function takes two parameters and returns the
    index where the second value is found within the first value. This makes it easy
    to split the template string into three parts – `head`, `variable`, and `tail`.
    Here is the test case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'pub fn get_index_for_symbol(input: &str, symbol: char)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -> (bool, usize) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut characters = input.char_indices();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut does_exist = false;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut index = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: while let Some((c, d)) = characters.next() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if d == symbol {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: does_exist = true;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: index = c;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: break;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (does_exist, index)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This concludes the code for the `Parser` module. Let's now look at the main
    function that ties all the pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: The main() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `main()` function is the entry point into the template engine. *Figure
    3.10* shows the design of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: The main() function](img/Figure_3.10_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: The main() function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` function performs the coordination role tying all pieces together.
    It invokes the parser, initializes the context data, and then invokes the generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashMap` to pass values for the template variables mentioned in the template.
    We add values for `name` and `city` to this `HashMap`. The `HashMap` is passed
    to the generator function along with the parsed template input:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`get_context_data()` function for each line of input read from the command
    line (standard input).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a) If the line contains template variable, it invokes the HTML generator `generate_html_template_var()`
    to create the HTML output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) If the line contains a literal string, it simply echoes back the input HTML
    literal string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c) If the line contains `for` or `if` tags, right now, we simply print out
    a statement that the feature is not yet implemented. We will implement this in
    future chapters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`io::stdin()` function creates a new handle to the standard input of the current
    process. The standard input is read one line at a time using the following `for`
    loop, which is then passed on to the parser for processing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the complete code listing for the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: src/main.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation for the `generate_html_template_var()` function is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This function constructs the output `html` statement consisting of *head*, *text
    content*, and *tail*. To construct the text content, the template variables are
    replaced with the values from the context data. The constructed `html` statement
    is returned from the function.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code from this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Executing the template engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have, for now, the outline and foundations for a basic template engine that
    can deal with two kinds of input – static literals and template variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the program and run some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the project with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`<h2> Hello, welcome to my page </h2>`. You will see the same string printed
    out as there is no transformation to be done.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<p> My name is {{name}} </p>` or `<p> I live in {{city}} </p>`. You will see
    `<p> My name is Bob </p>` or `<p> I live in Boston </p>` printed out corresponding
    to the input. This is because we initialized the variable `name` to `Bob` and
    `city` to `Boston` in the `main()` program. You are encouraged to enhance this
    code to add support for two template vars in a single HTML statement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{%` and `%}`, and containing either the string `for` or `if`. You will see
    one of the following messages printed out to the terminal: `For Tag not implemented`
    or `If Tag not implemented`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are encouraged to write the code for the `for` tag and `if` tag as an exercise.
    Ensure to check for the right sequence of symbols. For example, an invalid format
    such as `{% for }%` or `%} if {%` should be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we are not able to implement more features of the template engine,
    in this chapter, we have seen how to use the Rust Standard Library in a real-life
    use case. We have primarily used the `io`, `collections`, `iter`, and `str` modules
    from the Rust Standard Library to implement the code in this chapter. As we go
    through future chapters, we will cover more of the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the overall structure of the Rust Standard Library
    and classified the modules of the standard library into different categories for
    better understanding. You got a brief introduction to the modules in areas of
    concurrency, memory management, file system operations, data processing, data
    types, error handling, compiler-related, FFI, networking, I/O, OS-specific, and
    time-related features.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at what a template engine is, how it works, and defined the scope
    and requirements of our project. We designed the template engine in terms of Rust
    data structures (enum and struct) and Rust functions. We saw how to write code
    for parsing templates and to generate HTML for statements involving template variables.
    We executed the program providing input data and verified the generated HTML in
    the terminal (command line).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a closer look at the Rust Standard Library
    modules that deal with managing process environment, command-line arguments, and
    time-related functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Django template language**: [https://docs.djangoproject.com/en/3.0/ref/templates/language/](https://docs.djangoproject.com/en/3.0/ref/templates/language/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rust Standard Library**: [https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
