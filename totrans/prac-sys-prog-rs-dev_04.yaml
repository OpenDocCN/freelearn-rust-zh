- en: '*Chapter 3*: Introduction to the Rust Standard Library'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：Rust 标准库简介'
- en: In the previous chapter, we built a command-line tool using various Rust language
    primitives and modules from the Rust Standard Library. However, in order to fully
    exploit the power of Rust, it is imperative to understand the breadth of what
    features are available within the standard library for system programming tasks,
    without having to reach out to third-party crates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用各种 Rust 语言原语和 Rust 标准库中的模块构建了一个命令行工具。然而，为了充分利用 Rust 的力量，了解标准库中为系统编程任务提供的功能范围至关重要，而无需求助于第三方
    crate。
- en: In this chapter, we'll deep-dive into the structure of the Rust Standard Library.
    You'll get an introduction to the standard modules for accessing system resources
    and learn how to manage them programmatically. With the knowledge gained, we will
    implement a tiny portion of a template engine in Rust. By the end of this chapter,
    you will be able to confidently navigate the Rust Standard Library and make use
    of it in your projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 Rust 标准库的结构。你将了解用于访问系统资源的标准模块的介绍，并学习如何通过编程方式管理它们。通过获得的知识，我们将用 Rust
    实现一个模板引擎的小部分。到本章结束时，你将能够自信地导航 Rust 标准库并在你的项目中使用它。
- en: 'The following are the key learning outcomes for this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键学习成果如下：
- en: Introducing the Rust Standard Library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Rust 标准库
- en: Writing one feature of a template engine using the standard library modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准库模块编写模板引擎的一个特性
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Rustup and Cargo must be installed in your local development environment. The
    GitHub repository for the examples in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Rustup 和 Cargo 必须安装在你的本地开发环境中。本章示例的 GitHub 仓库可以在[https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03)找到。
- en: The Rust Standard Library and systems programming
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 标准库和系统编程
- en: Before we dive into the standard library, let's understand the context of how
    it fits into systems programming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究标准库之前，让我们了解它如何适应系统编程的上下文。
- en: 'In systems programming, one of the cardinal requirements is to manage system
    resources such as memory, files, network I/O, devices, and processes. Every operating
    system has a kernel (or equivalent), which is the central software module that
    is loaded in memory and connects the system hardware with the application processes.
    You may think, where does the Rust Standard Library fit in then? Are we going
    to write a kernel in Rust? No, that''s not the purpose of this book. The most
    popular operating systems, which are basically the Unix, Linux, and Windows variants,
    all have kernels written mostly in **C** with a mix of assembly. It is still early
    days for Rust to augment C as the kernel development language, though there are
    several experimental efforts in that direction. However, what the Rust Standard
    Library offers is an API interface to make system calls from Rust programs, in
    order to manage and manipulate various system resources. The following figure
    shows this context:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，一个基本要求是管理系统资源，如内存、文件、网络 I/O、设备和进程。每个操作系统都有一个内核（或等效物），它是加载到内存中的中央软件模块，将系统硬件与应用程序进程连接起来。你可能想知道，Rust
    标准库在这里有什么作用？我们是不是要用 Rust 编写一个内核？不，这不是本书的目的。最流行的操作系统，基本上是 Unix、Linux 和 Windows
    变体，它们的内核主要是用 **C** 编写的，混合了一些汇编语言。尽管有几个实验性的努力朝这个方向前进，但 Rust 作为内核开发语言的补充还处于早期阶段。然而，Rust
    标准库提供的是 API 接口，以便从 Rust 程序中发出系统调用，以管理和操作各种系统资源。以下图显示了这一上下文：
- en: '![Figure 3.1 – Rust Standard Library](img/Figure_3.1_B16405.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – Rust 标准库](img/Figure_3.1_B16405.jpg)'
- en: Figure 3.1 – Rust Standard Library
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Rust 标准库
- en: 'Let''s walk through this figure to understand each of the components better:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个图来更好地理解每个组件：
- en: '`read()`, which the kernel will then execute on behalf of the editor program.
    The reason for this restriction is that modern processor architectures (such as
    x86-64) allow the CPU to operate at two different privilege levels—*kernel mode*
    and *user mode*. The user mode has a lower level of privilege than the kernel
    mode. The CPU can perform certain operations only while running in the kernel
    mode. This design prevents user programs from accidentally doing tasks that could
    adversely affect the system operation.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read()`，内核将代表编辑程序执行。这种限制的原因是现代处理器架构（如 x86-64）允许 CPU 在两种不同的特权级别下运行—*内核模式*和*用户模式*。用户模式的特权级别低于内核模式。CPU
    只能在内核模式下执行某些操作。这种设计防止用户程序意外执行可能影响系统操作的任务。'
- en: '**System call (syscall) interface**: The kernel also provides a system call
    *application programming interface* that acts as the entry point for processes
    to request the kernel to perform various tasks.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统调用（syscall）接口**：内核还提供了一个系统调用 *应用程序编程接口*，作为进程请求内核执行各种任务的入口点。'
- en: '`libc` (or `glibc`). For the Windows operating system, there are equivalent
    APIs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libc`（或 `glibc`）。对于 Windows 操作系统，有等效的 API。'
- en: '`libc` (or another platform-specific equivalent library) internally to invoke
    system calls. The Rust Standard Library is cross-platform, which means that the
    details of how system calls are invoked (or which wrapper libraries are used)
    are abstracted away from the Rust developer. There are ways to invoke system calls
    from Rust code without using the standard library (for example, in embedded systems
    development), but that is beyond the scope of this book.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libc`（或另一个特定平台的等效库）内部调用系统调用。Rust 标准库是跨平台的，这意味着系统调用的调用细节（或使用的包装库）被从 Rust 开发者那里抽象出来。从
    Rust 代码中调用系统调用而不使用标准库的方法（例如，在嵌入式系统开发中）是存在的，但这超出了本书的范围。'
- en: '**User space programs**: These are the programs that you will write as part
    of this book using the standard library. The *arithmetic expression evaluator*
    you wrote in the previous chapter is an example of this. In this chapter, you
    will learn how to write a feature of the template engine using the standard library,
    which is also a user space program.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户空间程序**：这些是你将使用标准库作为本书的一部分编写的程序。你在上一章中编写的 *算术表达式评估器* 就是这样一个例子。在本章中，你将学习如何使用标准库编写模板引擎的功能，这也是一个用户空间程序。'
- en: Note
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Not all modules and functions within the Rust Standard Library invoke system
    calls (for example, there are methods for string manipulation, and to handle errors).
    As we go through the standard library, it is important to remember this distinction.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rust 标准库中的所有模块和函数并不都调用系统调用（例如，有字符串操作和处理错误的方法）。当我们遍历标准库时，记住这个区别是很重要的。
- en: Let's now begin our journey to understand and start using the Rust Standard
    Library.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始我们的旅程，了解并开始使用 Rust 标准库。
- en: Exploring the Rust Standard Library
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Rust 标准库
- en: 'We earlier discussed the role of the Rust Standard Library in enabling user
    programs to invoke kernel operations. The following are some of the notable features
    of the standard library, which we will refer to as `std` for brevity:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了 Rust 标准库在启用用户程序调用内核操作中的作用。以下是一些标准库的显著特性，我们将简称为 `std`：
- en: '`std` is cross-platform. It provides functionality that hides the differences
    among underlying platform architectures.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std` 是跨平台的。它提供了隐藏底层平台架构差异的功能。'
- en: '`std` is available to all Rust crates by default. The `use` statement gives
    access to the respective modules and their constituents (traits, methods, structs,
    and so on). For example, the statement `use std::fs` gives access to the module
    providing file manipulation operations.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std` 默认对所有 Rust 包可用。`use` 语句提供了对相应模块及其组成部分（特质、方法、结构体等）的访问。例如，`use std::fs`
    语句提供了对提供文件操作操作的模块的访问。'
- en: '`std` includes operations on standard Rust primitives (such as integers and
    floating-point numbers). For example, `std::i8::MAX` is a constant implemented
    in the standard library that specifies the maximum value that can be stored in
    a variable of type i8.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std` 包含对标准 Rust 原始数据类型（如整数和浮点数）的操作。例如，`std::i8::MAX` 是在标准库中实现的一个常量，指定了可以存储在类型为
    i8 的变量中的最大值。'
- en: It implements core data types such as *vector, strings*, and *smart pointers*
    such as `Box`, `Rc`, and `Arc`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了核心数据类型，如 *向量*、*字符串* 和 *智能指针*，如 `Box`、`Rc` 和 `Arc`。
- en: It provides functionality for operations such as data manipulation, memory allocation,
    error handling, networking, I/O, concurrency, async I/O primitives, and foreign
    function interfaces.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了数据操作、内存分配、错误处理、网络、I/O、并发、异步I/O原语和外部函数接口等功能。
- en: 'The following figure shows a high-level view of the Rust standard library:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了Rust标准库的高级视图：
- en: '![Figure 3.2 – Rust Standard Library – high-level view](img/Figure_3.2_B16405.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – Rust标准库 – 高级视图](img/Figure_3.2_B16405.jpg)'
- en: Figure 3.2 – Rust Standard Library – high-level view
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – Rust标准库 – 高级视图
- en: 'The Rust Standard Library (`std`) is broadly organized as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库(`std`)的组织结构大致如下：
- en: '**Rust language primitives**, which contain basic types such as signed and
    unsigned, integers, bool, floating point, char, array, tuple, slice, and string.
    Primitives are implemented by the compiler. The Rust Standard Library includes
    the primitives and builds on top of them.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust语言原语**，包含基本类型，如有符号和无符号整数、布尔值、浮点数、字符、数组、元组、切片和字符串。原语由编译器实现。Rust标准库包括原语，并在此基础上构建。'
- en: The `libc`) or other external dependencies. You can instruct the compiler to
    compile without the Rust Standard Library and use the core crate instead (such
    an environment is called `no_std` in Rust parlance, which is annotated with the
    `#![no_std]` attribute), and this is used commonly in embedded programming.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`libc`)或其他外部依赖。你可以指示编译器在不使用Rust标准库的情况下进行编译，并使用核心crate（在Rust术语中，这种环境被称为`no_std`，并带有`#![no_std]`属性），这在嵌入式编程中很常见。
- en: The `Box<T>`), reference-counted pointers (`Rc<T>`), and atomically reference-counted
    pointers (`Arc<T>`). It also includes and collections such as `Vec` and `String`
    (note that `String` is implemented in Rust as a UTF-8 sequence). This crate does
    not need to be used directly when the standard library is used, as the contents
    of the `alloc` crate are re-exported and made available as part of the `std` library.
    The only exception to this rule is when developing in a `no_std` environment,
    when this crate can be directly used to access its functionality.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Box<T>`）、引用计数指针(`Rc<T>`)、以及原子引用计数指针(`Arc<T>`)。它还包括集合，如`Vec`和`String`（注意，`String`在Rust中实现为UTF-8序列）。当使用标准库时，不需要直接使用此crate，因为`alloc`crate的内容被重新导出，并作为`std`库的一部分提供。唯一例外的情况是在`no_std`环境中开发时，此时可以直接使用此crate来访问其功能。'
- en: '`core` or `alloc` crates) include rich functionality for operations around
    concurrency, I/O, file system access, networking, async I/O, errors, and OS-specific
    functions.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`core`或`alloc`crate)包括围绕并发、I/O、文件系统访问、网络、异步I/O、错误和特定于操作系统的函数的丰富功能。
- en: In this book, we will not directly work with the `core` or `alloc` crates, but
    use the Rust Standard Library modules that are a higher-level abstraction over
    these crates.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将不会直接与`core`或`alloc`crate进行工作，而是使用这些crate之上的高级抽象的Rust标准库模块。
- en: We will now analyze the key modules within the Rust Standard Library with a
    focus on systems programming. The standard library is organized into modules.
    For example, the functionality that enables user programs to run on multiple threads
    for concurrency is in the `std::thread` module, and the Rust constructs for dealing
    with synchronous I/O are in the `std::io` module. Understanding how the functionality
    within the standard library is organized across modules is a critical part of
    being an effective and productive Rust programmer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将分析Rust标准库中的关键模块，重点关注系统编程。标准库被组织成模块。例如，允许用户程序在多个线程上运行的并发功能位于`std::thread`模块中，而处理同步I/O的Rust构造位于`std::io`模块中。理解标准库中功能如何在模块间组织是成为一名高效且富有成效的Rust程序员的关键部分。
- en: '*Figure 3.3* shows the layout of the standard library modules organized into
    groups:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.3*展示了标准库模块组织成组的布局：'
- en: '![Figure 3.3 – Rust Standard Library modules](img/Figure_3.3_B16405.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – Rust标准库模块](img/Figure_3.3_B16405.jpg)'
- en: Figure 3.3 – Rust Standard Library modules
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – Rust标准库模块
- en: The modules in this figure have been grouped by their primary area of focus.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本图中的模块已按其主要关注领域进行分组。
- en: 'How do we know, though, which of these modules is related to managing system
    resources? As this might be of interest for the purposes of this book, let''s
    attempt to classify the modules further into one of these two buckets:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何知道这些模块中哪些与管理系统资源相关呢？鉴于这可能对本书的用途感兴趣，让我们尝试将模块进一步分类到以下两个类别之一：
- en: '**Syscalls-oriented**: These are modules that either manage system hardware
    resources directly or require the kernel for other privileged operations.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以系统调用为导向**：这些模块要么直接管理系统硬件资源，要么需要内核执行其他特权操作。'
- en: '**Computation-oriented**: These are the modules that are oriented towards data
    representation, computation, and instructions to the compiler.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以计算为导向**：这些模块以数据表示、计算和向编译器发出的指令为导向。'
- en: '*Figure 3.4* shows the same module grouping as in *Figure 3.3* but segregated
    as **Syscalls-oriented** or **Computation-oriented**. Note that this may not be
    a perfect classification as not all methods in all modules marked in the **Syscalls-oriented**
    category involve actual system calls. But this classification can serve as a guide
    to find our way around the standard library:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.4* 展示了与 *图 3.3* 相同的模块分组，但被划分为 **以系统调用为导向** 或 **以计算为导向**。请注意，这可能不是一种完美的分类，因为并非所有标记为
    **以系统调用为导向** 类别的模块都涉及实际系统调用。但这种分类可以作为在标准库中找到方向的指南：'
- en: '![Figure 3.4 – Rust modules with classification](img/Figure_3.4_B16405.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Rust 模块分类](img/Figure_3.4_B16405.jpg)'
- en: Figure 3.4 – Rust modules with classification
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Rust 模块分类
- en: Let's get to know the functionality of each module.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来了解每个模块的功能。
- en: Computation-oriented modules
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以计算为导向的模块
- en: The standard library modules in this section deal *mostly* with programming
    constructs that deal with data processing, data modeling, error handling, and
    instructions to the compiler. Some of the modules may have functionality that
    overlaps with the syscalls-oriented category, but this grouping is based on the
    primary focus of each module.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的标准库模块主要处理与数据处理、数据建模、错误处理和向编译器发出的指令相关的编程结构。一些模块可能具有与以系统调用为导向的类别重叠的功能，但这种分组是基于每个模块的主要关注点。
- en: Data types
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'The modules related to data types and structures in the Rust Standard Library
    are mentioned in this section. There are broadly two categories of data types
    in Rust. The first group comprises primitive types such as integers (signed, unsigned),
    floating points, and char, which are a core part of the language and compiler
    and the standard library adds additional functionality to those types. The second
    group consists of higher-level data structures and traits such as vectors and
    strings, which are implemented within the standard library. Modules from both
    these groups are listed here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提到了与 Rust 标准库中的数据类型和结构相关的模块。Rust 中的数据类型大致分为两类。第一组包括整数（有符号、无符号）、浮点数和 char 等原始类型，它们是语言、编译器和标准库的核心部分，标准库为这些类型添加了额外的功能。第二组包括向量、字符串等高级数据结构和特性，这些都是在标准库中实现的。这两个组中的模块在此列出：
- en: '`any`: This can be used when the type of the value passed to a function is
    not known at compile time. Runtime reflection is used to check the type and perform
    suitable processing. An example of using this would be in the logging function,
    where we want to customize what is logged depending on the data type.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`：当传递给函数的值的类型在编译时未知时可以使用。使用运行时反射来检查类型并执行适当的处理。使用此功能的示例可以是日志函数，其中我们希望根据数据类型自定义记录的内容。'
- en: '`array`: It contains utility functions such as comparing arrays, implemented
    over the primitive array type. Note that Rust arrays are value types, that is,
    they are allocated on the stack, and have a fixed length (not growable).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`：它包含对原始数组类型实现的实用函数，例如比较数组。请注意，Rust 数组是值类型，即它们在栈上分配，并且具有固定长度（不可增长）。'
- en: '`char`: This contains utility functions implemented over the `char` primitive
    type, such as checking for digits, converting to uppercase, encoding to UTF-8,
    and so on.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`：它包含对 `char` 原始类型实现的实用函数，例如检查数字、转换为大写、编码为 UTF-8 等。'
- en: '`collections`: This is Rust''s standard collection library, which contains
    efficient implementations of common collection data structures used in programming.
    Collections in this library include `Vectors`, `LinkedLists`, `HashMaps`, `HashSet`,
    `BTtreeMap`, `BTreeSet`, and `BinaryHeap`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections`：这是 Rust 的标准集合库，其中包含编程中常用的常见集合数据结构的有效实现。该库中的集合包括 `Vectors`、`LinkedLists`、`HashMaps`、`HashSet`、`BTtreeMap`、`BTreeSet`
    和 `BinaryHeap`。'
- en: '`f32`, `f64`: This library provides constants specific to floating point implementations
    of the `f32` and `f64` primitive types. Examples of constants are `MAX` and `MIN`,
    which provide the maximum and minimum value of floating point numbers that can
    be stored by `f32` and `f64` types.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f32`, `f64`: 本库提供了针对 `f32` 和 `f64` 原始类型实现的特定常量。常量的例子包括 `MAX` 和 `MIN`，它们提供了
    `f32` 和 `f64` 类型可以存储的最大和最小浮点数值。'
- en: '`i8`, `i16`, `i32`, `i64`, `i128`: Signed integer types of various sizes. For
    example, `i8` represents a signed integer of length 8 bits (1 byte) and `i128`
    represents a signed integer of length 128 bits (16 bytes).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i8`, `i16`, `i32`, `i64`, `i128`: 各种大小的有符号整数类型。例如，`i8` 表示长度为 8 位（1 字节）的有符号整数，而
    `i128` 表示长度为 128 位（16 字节）的有符号整数。'
- en: '`u8`, `u16`, `u32`, `u64`, `u128`: Unsigned integer types of various sizes.
    For example, `u8` represents an unsigned integer of length 8 bits (1 byte) and
    `u128` represents an unsigned integer of length 128 bits (16 bytes).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u8`, `u16`, `u32`, `u64`, `u128`: 各种大小的无符号整数类型。例如，`u8` 表示长度为 8 位（1 字节）的无符号整数，而
    `u128` 表示长度为 128 位（16 字节）的无符号整数。'
- en: '`isize`, `usize`: Rust has two data types, `isize` and `usize`, that correspond
    to signed and unsigned integer types. The uniqueness of these types is that their
    size is dependent on whether the CPU uses a 32-bit or 64-bit architecture. For
    example, on a 32-bit system, the size of the `isize` and `usize` data types is
    32 bits (4 bytes), and likewise, for 64-bit systems, their size is 64 bits (8
    bytes).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isize`, `usize`: Rust 有两种数据类型，`isize` 和 `usize`，分别对应有符号和无符号整数类型。这些类型的独特之处在于它们的大小取决于
    CPU 是否使用 32 位或 64 位架构。例如，在 32 位系统上，`isize` 和 `usize` 数据类型的大小为 32 位（4 字节），同样，对于
    64 位系统，它们的大小为 64 位（8 字节）。'
- en: '`marker`: Basic properties that can be attached to types (in the form of traits)
    are described in this module. Examples include `Copy` (types whose values can
    be duplicated by a simple copy of its bits) and `Send` (thread-safe types).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`marker`: 本模块描述了可以附加到类型（以 trait 的形式）上的基本属性。例如包括 `Copy`（其值可以通过简单复制其位来复制的类型）和
    `Send`（线程安全的类型）。'
- en: '`slice`: Contains structs and methods useful to perform operations such as
    `iterate` and `split` on `slice` data types.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice`: 包含用于在 `slice` 数据类型上执行 `iterate` 和 `split` 等操作的 struct 和方法。'
- en: '`string`: This module contains the `String` type and methods such as `to_string`,
    which allows converting a value to a `String`. Note that `String` is not a primitive
    data type in Rust. The primitive types in Rust are listed here: [https://doc.rust-lang.org/std/](https://doc.rust-lang.org/std/).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`: 本模块包含 `String` 类型以及 `to_string` 等方法，允许将值转换为 `String`。请注意，`String`
    在 Rust 中不是一个原始数据类型。Rust 中的原始类型在此列出：[https://doc.rust-lang.org/std/](https://doc.rust-lang.org/std/)。'
- en: '`str`: This module contains structs and methods associated with string slices
    such as `iterate` and `split` on `str` slices.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str`: 本模块包含与字符串切片相关的 struct 和方法，例如在 `str` 切片上执行 `iterate` 和 `split`。'
- en: '`vec`: This module contains the `Vector` type, which is a growable array with
    heap-allocated contents, and associated methods for operating on vectors such
    as splicing and iterating. A `vec` module is an owned reference and a smart pointer
    (such as `Box<T>`). Note that `vec` was originally defined in the `alloc` crate,
    but was made available as part of both the `std::vec` and `std::collections` modules.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vec`: 本模块包含 `Vector` 类型，它是一个具有堆分配内容的可增长数组，以及用于操作向量（如切片和迭代）的相关方法。`vec` 模块是一个所有者引用和智能指针（如
    `Box<T>`）。请注意，`vec` 最初是在 `alloc` crate 中定义的，但现在作为 `std::vec` 和 `std::collections`
    模块的一部分提供。'
- en: Data processing
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据处理
- en: 'This is an assorted collection of modules that provides helper methods for
    different types of processing such as dealing with ASCII characters, comparing,
    ordering, and printing formatted values, arithmetic operations, and iterators:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个各种模块的集合，提供了针对不同类型处理的辅助方法，例如处理 ASCII 字符、比较、排序、打印格式化值、算术运算和迭代器：
- en: '`ascii`: Most string operations in Rust act on UTF-8 strings and characters.
    But in some cases, there may be a need to operate on ASCII characters only. This
    module provides operations on ASCII strings and characters.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ascii`: Rust 中的大多数字符串操作作用于 UTF-8 字符串和字符。但在某些情况下，可能需要仅对 ASCII 字符进行操作。本模块提供了对
    ASCII 字符串和字符的操作。'
- en: '`cmp`: This module contains functions for ordering and comparing values, and
    associated macros. For example, implementing the `Eq` trait contained in this
    module allows a comparison of custom struct instances using the `==` and `!=`
    operators.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmp`：此模块包含用于排序和比较值的函数以及相关宏。例如，实现此模块中包含的 `Eq` 特性允许使用 `==` 和 `!=` 运算符比较自定义结构体实例。'
- en: '`fmt`: This module contains utilities to format and print strings. Implementing
    this trait enables printing any custom data type using the `format!` macro.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt`：此模块包含用于格式化和打印字符串的实用工具。实现此特性使得可以使用 `format!` 宏打印任何自定义数据类型。'
- en: '`hash`: This module provides functionality to compute a hash of data objects.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash`：此模块提供计算数据对象哈希的功能。'
- en: '`iter`: This module contains the `Iterator` trait, which is part and parcel
    of idiomatic Rust code, and a popular feature of Rust. This trait can be implemented
    by custom data types for iterating over their values.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iter`：此模块包含 `Iterator` 特性，它是 Rust 习惯性代码的一部分，也是 Rust 的一个流行特性。此特性可以通过自定义数据类型实现，以便迭代其值。'
- en: '`num`: This module provides additional data types for numeric operations.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num`：此模块提供用于数值操作的附加数据类型。'
- en: '`ops`: This module has a set of traits that allow you to overload operators
    for custom data types. For example, the `Add` trait can be implemented for a custom
    struct and the `+` operator can be used to add two structs of that type.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`：此模块提供一组特性，允许您为自定义数据类型重载运算符。例如，可以为自定义结构体实现 `Add` 特性，并使用 `+` 运算符来添加该类型的两个结构体。'
- en: Error handling
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'This group consists of modules that have functionality for error handling in
    Rust programs. The `Error` trait is the foundational construct to represent errors.
    `Result` deals with the presence or absence of errors in the return value of functions,
    and `Option` deals with the presence or absence of values in a variable. The latter
    prevents the dreaded *null value* error that plagues several programming languages.
    `Panic` is provided as a way to exit the program if errors cannot be handled:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此组包含具有 Rust 程序错误处理功能的模块。`Error` 特性是表示错误的基础结构。`Result` 处理函数返回值中的错误存在与否，而 `Option`
    处理变量中的值的存在与否。后者防止了困扰许多编程语言的可怕 *空值* 错误：“Panic” 提供了一种退出程序的方式，如果无法处理错误：
- en: '`error`: This module contains the `Error` trait, which represents the basic
    expectations of error values. All errors implement the trait `Error`, and this
    module is used to implement custom or application-specific error types.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：此模块包含 `Error` 特性，它表示错误值的基本期望。所有错误都实现了 `Error` 特性，并且此模块用于实现自定义或特定于应用程序的错误类型。'
- en: '`option`: This module contains the `Option` type, which provides the ability
    for a value to be initialized to either `Some` value or `None` value. The `Option`
    type can be considered as a very basic way to handle errors involving the absence
    of values. Null values cause havoc in other programming languages in the form
    of null pointer exceptions or the equivalent.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`option`：此模块包含 `Option` 类型，它提供了将值初始化为 `Some` 值或 `None` 值的能力。`Option` 类型可以被视为处理涉及值缺失的错误的一种非常基本的方式。空值在其他编程语言中以空指针异常或等效形式造成混乱。'
- en: '`panic`: This module provides support to deal with panic including capturing
    the cause of panic and setting hooks to trigger custom logic on panic.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`panic`：此模块提供处理 panic 的支持，包括捕获 panic 的原因和设置钩子以在 panic 时触发自定义逻辑。'
- en: '`result`: This module contains the `Result` type, which along with the `Error`
    trait and `Option` type form the foundation of error handling in Rust. `Result`
    is represented as `Result<T,E>`, which is used to return either values or errors
    from functions. Functions return the `Result` type whenever errors are expected
    and if the error is recoverable.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result`：此模块包含 `Result` 类型，它与 `Error` 特性和 `Option` 类型一起构成了 Rust 中错误处理的基础。`Result`
    表示为 `Result<T,E>`，用于从函数返回值或错误。当预期错误时，函数返回 `Result` 类型，如果错误可恢复。'
- en: Foreign function interface (FFI)
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部函数接口 (FFI)
- en: FFI is provided by the `ffi` module. This module provides utilities to exchange
    data across non-Rust interface boundaries, such as working with other programming
    languages or to deal directly with the underlying operating system/kernel.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: FFI 由 `ffi` 模块提供。此模块提供用于在非 Rust 接口边界之间交换数据的实用工具，例如与其他编程语言一起工作或直接与底层操作系统/内核交互。
- en: Compiler
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器
- en: This group contains modules that are related to the Rust compiler.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此组包含与 Rust 编译器相关的模块。
- en: '`hint`: This module contains functions to hint to the compiler about how code
    should be emitted or optimized.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hint`: 此模块包含向编译器提示代码应该如何发出或优化的函数。'
- en: '`prelude`: The prelude is the list of items that Rust automatically imports
    into each Rust program. It is a convenience feature.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prelude`: 预言是 Rust 自动导入到每个 Rust 程序中的项目列表。这是一个便利功能。'
- en: '`primitive`: This module re-exports Rust primitive types, normally for use
    in macro code.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`primitive`: 此模块重新导出 Rust 原始类型，通常用于宏代码中。'
- en: We've so far seen the **computation-oriented** modules of the Rust standard
    library. Let's take a look at the **syscalls-oriented** modules now.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Rust 标准库的计算导向模块。现在让我们看看系统调用导向的模块。
- en: Syscalls-oriented modules
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用导向模块
- en: While the previous group of modules was related to in-memory computations, this
    section deals with operations that involve managing hardware resources or other
    privileged operations that *normally* require kernel intervention. Note that not
    all methods in these modules involve system calls to the kernel, but it helps
    to construct a mental model at the module level.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的模块组与内存中的计算相关，但本节处理涉及管理硬件资源或其他通常需要内核干预的特权操作的操作。请注意，这些模块中的所有方法并不都涉及对内核的系统调用，但这有助于在模块级别构建心理模型。
- en: Memory management
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存管理
- en: 'This grouping contains a set of modules from the standard library that deal
    with memory management and smart pointers. Memory management includes static memory
    allocation (on the stack), dynamic memory allocation (on the heap), memory deallocation
    (when a variable goes out of scope, its destructor is run), cloning or copying
    values, managing raw pointers and smart pointers (which are pointers to data on
    the heap), and fixing memory locations for objects so that they cannot be moved
    around (which is needed for special situations). The modules are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此分组包含来自标准库的一组模块，用于处理内存管理和智能指针。内存管理包括静态内存分配（在栈上）、动态内存分配（在堆上）、内存释放（当变量超出作用域时，其析构函数会被执行）、复制或复制值、管理原始指针和智能指针（它们是指向堆上数据的指针），以及固定对象的内存位置，以便它们不能被移动（这在特殊情况下是需要的）。模块如下：
- en: '`alloc`: This module contains APIs for the allocation and deallocation of memory,
    and to register a custom or third-party memory allocator as the standard library''s
    default.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alloc`: 此模块包含内存分配和释放的 API，以及注册自定义或第三方内存分配器作为标准库的默认分配器。'
- en: '`borrow`: In Rust, it is common to use different representations of a given
    type for different use cases. For example, a value can be stored and managed as
    `Box<T>`, `Rc<T>`, or `Arc<T>`. Similarly, a string value can be stored as the
    `String` or `str` type. Rust provides methods that allow one type to be borrowed
    as some other type, by implementing the `borrow` method from the `Borrow` trait.
    So basically, a type is free to be borrowed as many different types. This module
    contains the trait `Borrow`, which allows the conversion of an owned value to
    borrowed or to convert borrowed data of any type to an owned value. For example,
    a value of type `String` (which is an owned type) can be borrowed as `str`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`borrow`: 在 Rust 中，根据不同的使用场景，通常会对给定的类型使用不同的表示形式。例如，一个值可以存储和管理为 `Box<T>`、`Rc<T>`
    或 `Arc<T>`。同样，一个字符串值可以存储为 `String` 或 `str` 类型。Rust 提供了方法，允许通过实现 `Borrow` 特质中的
    `borrow` 方法，将一种类型借用为另一种类型。所以基本上，一个类型可以自由地借用为许多不同的类型。此模块包含 `Borrow` 特质，它允许将拥有的值转换为借用值，或将任何类型的借用数据转换为拥有值。例如，`String`
    类型的值（它是一个拥有类型）可以借用为 `str`。'
- en: '`cell`: In Rust, memory safety is based on the rule that a value can have either
    several immutable references to it or a single mutable reference. But there may
    be scenarios where a shared, mutable reference is required. This module provides
    shareable mutable containers that include `Cell` and `RefCell`. These types provide
    controlled mutability of shared types.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cell`: 在 Rust 中，内存安全基于规则：一个值可以有多个不可变引用或单个可变引用。但可能存在需要共享、可变引用的场景。此模块提供了可共享的可变容器，包括
    `Cell` 和 `RefCell`。这些类型提供了对共享类型的受控可变性。'
- en: '`clone`: In Rust, primitive types such as integers are *copyable*, that is,
    they implement the `Copy` trait. This means that when assigning the value of a
    variable to another variable or while passing a parameter to a function, the value
    of the object is duplicated. But not all types can be copied, because they may
    require memory allocations (for example, `String` or `Vec` types where memory
    is allocated in the heap, rather than the stack). In such cases, a `clone()` method
    is used to duplicate a value. This module provides the `Clone` trait, which allows
    values of custom data types to be duplicated.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone`: 在Rust中，原始类型如整数是可复制的，即它们实现了`Copy`特质。这意味着当将变量的值赋给另一个变量或传递参数给函数时，对象的值会被复制。但并非所有类型都可以复制，因为它们可能需要内存分配（例如，`String`或`Vec`类型，其中内存是在堆上分配，而不是在栈上）。在这种情况下，使用`clone()`方法来复制值。此模块提供了`Clone`特质，允许自定义数据类型的值被复制。'
- en: '`convert`: This module contains functionality to facilitate the conversion
    between data types. For example, by implementing the `AsRef` trait contained in
    this module, you can write a function that takes a parameter of type `AsRef<str>`,
    which means that this function can accept any reference that can be converted
    into a string reference (`&str`). Since both the `str` and `String` types implement
    the `AsRef` trait, you can pass either a `String` reference (`String`) or string
    slice reference (`&str`) to this function.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convert`: 此模块包含便于数据类型之间转换的功能。例如，通过实现此模块中包含的`AsRef`特质，你可以编写一个接受类型为`AsRef<str>`的参数的函数，这意味着此函数可以接受任何可以转换为字符串引用的引用（`&str`）。由于`str`和`String`类型都实现了`AsRef`特质，你可以传递`String`引用（`String`）或字符串切片引用（`&str`）给此函数。'
- en: '`default`: This module has the trait `Default`, which is used to assign meaningful
    default values for data types.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`: 此模块具有`Default`特质，用于为数据类型分配有意义的默认值。'
- en: '`mem`: This module contains memory-related functions including querying memory
    size, initialization, swapping, and other memory manipulation operations.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem`: 此模块包含与内存相关的函数，包括查询内存大小、初始化、交换以及其他内存操作。'
- en: '`pin`: Types in Rust are movable, by default. For example, on a `Vec` type,
    a `pop()` operation moves a value out and a push operation may result in the reallocation
    of memory. However, there are situations where it is useful to have objects that
    have fixed memory locations and do not move. For example, self-referencing data
    structures such as linked lists. For such cases, Rust provides a data type that
    pins data to a location in memory. This is achieved by wrapping a type in the
    pinned pointer, `Pin<P>`, which pins the value `P` in its place in memory.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pin`: Rust中的类型默认是可移动的。例如，在`Vec`类型上，`pop()`操作会移动一个值出来，而`push`操作可能会导致内存重新分配。然而，在某些情况下，拥有固定内存位置且不移动的对象是有用的。例如，自引用数据结构，如链表。对于这种情况，Rust提供了一个将数据固定在内存位置的数据类型。这是通过将类型包裹在固定指针`Pin<P>`中实现的，它将值`P`固定在内存中的位置。'
- en: '`ptr`: Working with raw pointers in Rust is not common, and is used only in
    selective use cases. Rust allows working with raw pointers in unsafe code blocks,
    where the compiler does not take responsibility for memory safety and the programmer
    is responsible for memory-safe operations. This module provides functions to work
    with raw pointers. Rust supports two types of raw pointers—immutable (for example,
    `*const i32`) and mutable (for example, `*mut i32`). Raw pointers have no restrictions
    on how they are used. They are the only pointer type in Rust that can be null,
    and there is no automatic dereferencing of raw pointers.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ptr`: 在Rust中，使用原始指针并不常见，并且仅在选择性用例中使用。Rust允许在不可安全代码块中处理原始指针，编译器不负责内存安全，程序员负责内存安全的操作。此模块提供用于处理原始指针的函数。Rust支持两种类型的原始指针——不可变（例如，`*const
    i32`）和可变（例如，`*mut i32`）。原始指针在使用上没有限制。它们是Rust中唯一可以设置为null的指针类型，并且原始指针没有自动解引用。'
- en: '`rc`: This module provides single-threaded reference-counting pointers, where
    `rc` stands for reference-counted. A reference-counted pointer to an object of
    type `T` can be represented as `Rc<T>`. `Rc<T>` provides shared ownership of value
    `T`, which is allocated in the heap. If a value of this type is cloned, it returns
    a new pointer to the same memory location in the heap (does not duplicate the
    value in memory). This value is retained until the last `Rc` pointer that references
    this value is in existence, after which the value is dropped.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rc`: 此模块提供单线程引用计数指针，其中 `rc` 代表引用计数。类型 `T` 的对象的引用计数指针可以表示为 `Rc<T>`。`Rc<T>`
    提供了值 `T` 的共享所有权，该值在堆上分配。如果此类型的值被克隆，它将返回指向堆中相同内存位置的新的指针（不会在内存中复制值）。此值保留，直到最后一个引用此值的
    `Rc` 指针存在，之后该值将被丢弃。'
- en: Concurrency
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发
- en: This category groups modules related to synchronous concurrent processing. Concurrent
    programs can be designed in Rust by spawning processes, spawning threads within
    a process, and having ways to synchronize and share data across threads and processes.
    Asynchronous concurrency is covered under the `Async` group.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别将有关同步并发处理的模块分组在一起。可以在 Rust 中通过启动进程、在进程内启动线程以及有方法在线程和进程之间同步和共享数据来设计并发程序。异步并发在
    `Async` 组中介绍。
- en: '`env`: This module allows inspecting and manipulating a process''s environment,
    including environment variables, the arguments of a process, and paths. This module
    could belong to its own category as it is widely used beyond just concurrency,
    but it is grouped here along with the `process` module because this module is
    designed to work with a *process* (for example, getting and setting the environment
    variables of a process or getting the command-line parameters used to start a
    process).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`: 此模块允许检查和操作进程的环境，包括环境变量、进程的参数和路径。此模块可以属于其自己的类别，因为它在并发之外被广泛使用，但它被归类在此处与
    `process` 模块一起，因为此模块旨在与 *进程* 一起工作（例如，获取和设置进程的环境变量或获取启动进程使用的命令行参数）。'
- en: '`process`: This module provides functions for dealing with processes including
    spawning a new process, handling I/O, and terminating processes.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process`: 此模块提供了处理进程的功能，包括启动新进程、处理 I/O 和终止进程。'
- en: '`sync`: The sequence of instructions executed in a Rust program may vary in
    cases where concurrency is involved. In such cases, there may be multiple threads
    of execution in parallel (for example, multiple threads in a multi-core CPU),
    in which case synchronization primitives are needed to coordinate operations across
    threads. This module includes synchronization primitives such as `Arc`, `Mutex`,
    `RwLock`, and `Condvar`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync`: 在涉及并发的情况下，Rust 程序中执行的指令序列可能会有所不同。在这种情况下，可能存在多个并行执行的执行线程（例如，多核 CPU 中的多个线程），在这种情况下，需要同步原语来协调线程间的操作。此模块包括同步原语，如
    `Arc`、`Mutex`、`RwLock` 和 `Condvar`。'
- en: '`thread`: Rust''s threading model consists of native OS threads. This module
    provides functionality to work with threads such as spawning new threads, and
    configuring, naming, and synchronizing them.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread`: Rust 的线程模型由原生操作系统线程组成。此模块提供了处理线程的功能，例如启动新线程、配置、命名和同步它们。'
- en: File system
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统
- en: 'This contains two modules that deal with filesystem operations. The `fs` module
    deals with methods for working with and manipulating the contents of the local
    file system. The `path` module provides methods to navigate and manipulate directory
    and file system paths programmatically:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含处理文件系统操作的两个模块。`fs` 模块处理与操作本地文件系统内容的方法。`path` 模块提供用于程序化导航和操作目录和文件系统路径的方法：
- en: '`fs`: This module contains operations to work with and manipulate file systems.
    Note that operations in this module can be used cross-platform. Structs and methods
    in this module deal with files, naming, file types, directories, file metadata,
    permissions, and iterating over entries in a directory.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`: 此模块包含用于处理和操作文件系统的操作。请注意，此模块中的操作可以在跨平台上使用。此模块中的结构体和方法处理文件、命名、文件类型、目录、文件元数据、权限以及遍历目录中的条目。'
- en: '`path`: This module provides the types `PathBuf` and `Path` for working with
    and manipulating paths.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 此模块提供了用于处理和操作路径的类型 `PathBuf` 和 `Path`。'
- en: Input-Output
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入输出
- en: This contains the `io` module, which provides core I/O functionality. The `io`
    module contains common functions that are used while dealing with inputs and outputs.
    This includes reading and writing to I/O types, such as files or TCP streams,
    buffered reads and writes for better performance, and working with standard input
    and output.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了一个`io`模块，它提供了核心I/O功能。`io`模块包含在处理输入和输出时使用的常用函数。这包括对I/O类型（如文件或TCP流）的读写操作，以及用于提高性能的缓冲读写操作，以及与标准输入和输出一起工作。
- en: Networking
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络通信
- en: The core networking functionality is provided by the `net` module. This module
    contains the primitives for TCP and UDP communications and for working with ports
    and sockets.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 核心网络功能由`net`模块提供。此模块包含TCP和UDP通信的原语，以及处理端口和套接字的功能。
- en: OS-specific
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与操作系统相关的
- en: The OS-specific functions are provided in the `os` module. This module contains
    platform-specific definitions and extensions for the Linux, Unix, and Windows
    operating systems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作系统相关的函数由`os`模块提供。此模块包含Linux、Unix和Windows操作系统的平台特定定义和扩展。
- en: Time
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间
- en: The `time` module provides functions to work with system time. This module contains
    structs to deal with system time and to compute durations, typically used for
    system timeouts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`模块提供了处理系统时间的函数。此模块包含处理系统时间和计算持续时间的结构体，通常用于系统超时。'
- en: Async
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步
- en: 'Asynchronous I/O functionality is provided by the `future` and `task` modules:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 异步I/O功能由`future`和`task`模块提供：
- en: '`future`: This contains the `Future` trait that serves as the foundation for
    building asynchronous services in Rust.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`future`：这包含了一个`Future`特质，它是构建Rust中异步服务的基础。'
- en: '`task`: This module provides functions needed to work with asynchronous tasks
    including `Context`, `Waker`, and `Poll`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task`：此模块提供了处理异步任务所需的函数，包括`Context`、`Waker`和`Poll`。'
- en: A note on the prelude module
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于预置模块的说明
- en: As we've seen, Rust comes with a lot of functionality in the standard library.
    To use it, you have to import the respective modules into the programs. However,
    there is a set of commonly needed *traits*, *types*, and *functions* that Rust
    automatically imports into every Rust program, so the Rust programmer does not
    have to manually import them. This is called the `use std::prelude::v1::*` into
    Rust programs. This module re-exports frequently used Rust constructs.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们所见，Rust在标准库中提供了很多功能。要使用它们，你必须将相应的模块导入到程序中。然而，有一组常用的*特质*、*类型*和*函数*，Rust会自动导入到每个Rust程序中，因此Rust程序员不需要手动导入它们。这被称为将`use
    std::prelude::v1::*`导入到Rust程序中。此模块重新导出常用Rust构造。
- en: The list of items exported by the `prelude` module includes traits, types, and
    functions including `Box`, `Copy`, `Send`, `Sync`, `drop`, `Clone`, `Into`, `From`,
    `Iterator`, `Option`, `Result`, `String`, and `Vec`. The list of modules re-exported
    can be found at [https://doc.rust-lang.org/std/prelude/v1/index.html](https://doc.rust-lang.org/std/prelude/v1/index.html).
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`prelude`模块导出的项目包括特质、类型和函数，包括`Box`、`Copy`、`Send`、`Sync`、`drop`、`Clone`、`Into`、`From`、`Iterator`、`Option`、`Result`、`String`和`Vec`。重新导出模块的列表可以在[https://doc.rust-lang.org/std/prelude/v1/index.html](https://doc.rust-lang.org/std/prelude/v1/index.html)找到。'
- en: This concludes the overview of the Rust Standard Library modules. The Rust Standard
    Library is vast and is rapidly evolving. It is highly recommended that you review
    the official documentation at [https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html)
    with the understanding gained in this chapter, for specific methods, traits, data
    structures, and example snippets.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对Rust标准库模块的概述。Rust标准库非常庞大，并且正在快速发展。强烈建议您使用本章中获得的理解，在[https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html)上查看官方文档，以了解具体的方法、特质、数据结构和示例片段。
- en: Let's now move on to the next section where we will put this knowledge to use
    by writing some code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到下一节，我们将通过编写一些代码来应用这些知识。
- en: Building a template engine
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模板引擎
- en: In this section, we will look at the design of an **HTML template engine** and
    implement one of the features using the Rust Standard Library. Let's first understand
    what a template engine is.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨HTML模板引擎的设计，并使用Rust标准库实现其中一个功能。让我们首先了解什么是模板引擎。
- en: Applications such as web and mobile apps use structured data stored in datastores
    such as relational databases, NoSQL databases, and key-value stores. However,
    there is a lot of data on the web that is unstructured. One particular example
    is text data that all web pages contain. Web pages are generated as HTML files
    that have a text-based format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Web和移动应用等应用程序使用存储在关系数据库、NoSQL数据库和键值存储中的结构化数据。然而，网络上存在大量非结构化数据。一个特定的例子是所有网页都包含的文本数据。网页作为基于文本格式的HTML文件生成。
- en: 'On observing closely, we can see that an HTML page has two parts: *static text
    literals* and *dynamic parts*. The HTML page is authored as a template with the
    static and dynamic parts, and the context for HTML generation comes from a data
    source. While generating a web page, the generator should take the static text
    and output it without change, while it should combine some processing and the
    supplied context to generate the dynamic string result. Generating HTML pages
    involves syscalls (to create, open, read, and write files) and computationally
    intensive in-memory string manipulations.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察后，我们可以看到HTML页面有两个部分：*静态文本字面量* 和 *动态部分*。HTML页面作为一个模板编写，包含静态和动态部分，HTML生成的上下文来自数据源。在生成网页时，生成器应将静态文本输出而不改变，同时应结合一些处理和提供的上下文来生成动态字符串结果。生成HTML页面涉及系统调用（创建、打开、读取和写入文件）和计算密集型的内存字符串操作。
- en: A **template engine** is the system software component that can be used to generate
    dynamic HTML pages in a performant manner. It contains a combination of software
    components including parsers, tokenizers, generators, and template files.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **模板引擎** 是一个可以用来以高效方式生成动态HTML页面的系统软件组件。它包含了解析器、标记化器、生成器和模板文件等软件组件的组合。
- en: '*Figure 3.5* shows the process involved in generating HTML with a template
    engine:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.5* 展示了使用模板引擎生成HTML所涉及的过程：'
- en: '![](img/Figure_3.5_B16405.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.5_B16405.jpg)'
- en: Figure 3.5 – Generating HTML with templates
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 使用模板生成HTML
- en: 'To understand this better, let''s take an example of an internet banking page
    showing a statement of transactions for a customer. This can be built using an
    HTML template, where:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们以一个显示客户交易记录的网上银行页面为例。这可以通过使用HTML模板来实现，其中：
- en: The static HTML includes the bank name, logo, other branding, and content that
    is *common to all users*.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态HTML包括银行名称、标志、其他品牌和所有用户都通用的内容。
- en: The dynamic portion of the web page contains the actual list of past transactions
    *for the logged-in user*. The transaction list varies from user to user.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页的动态部分包含登录用户的实际历史交易列表。交易列表因用户而异。
- en: 'The advantage of this approach is the segregation of responsibilities in the
    web development life cycle:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于在Web开发生命周期中职责的分离：
- en: A *frontend (web) designer* can author the static HTML with sample data using
    web design tools.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *前端（Web）设计师* 可以使用Web设计工具使用示例数据编写静态HTML。
- en: A *template designer* would convert the static HTML into an HTML template embedding
    the metadata for the dynamic portions of the page in specific syntax.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *模板设计师* 会将静态HTML转换为嵌入页面动态部分元数据的HTML模板，使用特定的语法。
- en: At runtime (when the page request comes into the server), *the template engine*
    takes the template file from the specified location, applies the transaction list
    for the logged-in user from the database, and generates the final HTML page.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时（当页面请求到达服务器时），*模板引擎* 从指定位置获取模板文件，应用登录用户的交易列表从数据库中，并生成最终的HTML页面。
- en: Examples of popular template engines include *Jinja, Mustache, Handlebars, HAML,
    Apache Velocity, Twig*, and *Django*. There are differences in the architectures
    and syntax adopted by the various template engines.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的模板引擎示例包括 *Jinja, Mustache, Handlebars, HAML, Apache Velocity, Twig* 和 *Django*。不同的模板引擎在架构和语法上存在差异。
- en: In this book, we will write the structure for a basic template engine that uses
    a syntax similar to **Django templates**. *Django* is a popular web framework
    in Python. Commercial templating engines such as that in *Django* are full-featured
    and complex. It will not be possible for us to recreate them completely in this
    chapter, but we will build the code structure and implement a representative feature.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将编写一个类似 **Django模板** 语法的简单模板引擎的结构。*Django* 是Python中流行的Web框架。像 *Django*
    这样的商业模板引擎功能全面且复杂。我们不可能在本章中完全重新创建它们，但我们将构建代码结构和实现一个代表性功能。
- en: Types of HTML template engines
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 模板引擎的类型
- en: There are two types of HTML template engines, based on when the template data
    is parsed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据模板数据解析的时间，有两种类型的 HTML 模板引擎。
- en: The first type of template engines parse the HTML template and convert it into
    code, at compilation time. Then, at runtime, dynamic data is fetched and loaded
    into the compiled template. These tend to have better runtime performance as part
    of the work is done at compilation time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种类型的模板引擎在编译时解析 HTML 模板并将其转换为代码。然后，在运行时，动态数据被检索并加载到编译后的模板中。这些模板通常具有更好的运行时性能，因为其中一部分工作是在编译时完成的。
- en: The second type of template engines do both the parsing of the template and
    HTML generation at runtime. We will be using this type in our project, as it is
    relatively simple to understand and implement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的模板引擎在运行时同时解析模板和生成 HTML。我们将在我们的项目中使用这种类型，因为它相对简单易懂且易于实现。
- en: Let's begin with the design of an HTML template file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设计一个 HTML 模板文件开始。
- en: Template syntax and design
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板语法和设计
- en: 'A template is essentially a text file. A list of common features supported
    by a template file is shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模板本质上是一个文本文件。以下列出了一些模板文件支持的常见特性：
- en: Literals, for example, `<h1> hello world </h1>`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面量，例如，`<h1> hello world </h1>`
- en: Template variables surrounded by `{{` and `}}`, for example, `<p> {{name}} </p>`
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被包围在 `{{` 和 `}}` 之间的模板变量，例如，`<p> {{name}} </p>`
- en: Control logic using an `if` tag, for example, `{% if amount > 100000 %} {% endif
    %}`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `if` 标签进行控制逻辑，例如，`{% if amount > 100000 %} {% endif %}`
- en: Loop control with a `for` tag, for example, `<ul>{% for customer in customer_list}<li>{{customer.name}}</li>{%
    endfor %}</ul>`
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `for` 标签进行循环控制，例如，`<ul>{% for customer in customer_list}<li>{{customer.name}}</li>{%
    endfor %}</ul>`
- en: Content import, for example, `{% include "footer.html" %}`
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容导入，例如，`{% include "footer.html" %}`
- en: Filters, for example, `{{name | upper}}`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器，例如，`{{name | upper}}`
- en: '*Figure 3.6* shows a sample template and the HTML generated from the template
    engine:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.6* 展示了一个示例模板和由模板引擎生成的 HTML：'
- en: '![Figure 3.6 – Conceptual model of the template engine](img/Figure_3.6_B16405.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 模板引擎的概念模型](img/Figure_3.6_B16405.jpg)'
- en: Figure 3.6 – Conceptual model of the template engine
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 模板引擎的概念模型
- en: 'In *Figure 3.6*, we can see the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3.6* 中，我们可以看到以下内容：
- en: On the left-hand side, a sample template file is shown. The template file is
    a mix of static and dynamic content. An example of static content is `<h1> Welcome
    to XYZ Bank </h1>`. An example of dynamic content is `<p> Welcome {{name}} </p>`,
    because the value for `name` will be substituted at runtime. There are three types
    of dynamic content shown in the template file – an `if` tag, a `for` tag, and
    a template variable.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧，显示了一个示例模板文件。模板文件是静态内容和动态内容的混合。静态内容的示例是 `<h1> Welcome to XYZ Bank </h1>`。动态内容的示例是
    `<p> Welcome {{name}} </p>`，因为 `name` 的值将在运行时被替换。模板文件中显示了三种类型的动态内容 – 一个 `if` 标签，一个
    `for` 标签和一个模板变量。
- en: In the middle of the figure, we can see the template engine with two sources
    of inputs – template file and data source. The template engine takes these inputs
    and generates the output HTML file.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图中间，我们可以看到模板引擎有两个输入来源 – 模板文件和数据源。模板引擎接收这些输入并生成输出 HTML 文件。
- en: '*Figure 3.7* explains the working of the template engine using an example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.7* 使用示例解释了模板引擎的工作原理：'
- en: '![Figure 3.7 – Illustrated example for a template engine](img/Figure_3.7_B16405.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 模板引擎的示例](img/Figure_3.7_B16405.jpg)'
- en: Figure 3.7 – Illustrated example for a template engine
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 模板引擎的示例
- en: 'From a design standpoint, the template engine has two parts:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计角度来看，模板引擎有两个部分：
- en: Parser
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器
- en: HTML generator
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML 生成器
- en: Let's start by understanding the steps involved in HTML generation using the
    template engine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解使用模板引擎进行 HTML 生成所涉及的步骤。
- en: 'The template file contains a set of statements. Some of these are static literals
    while others are placeholders for dynamic content represented using special syntax.
    The template engine reads each statement from the template file. Let''s call each
    line read as a template string, henceforth. The process flow begins with the template
    string read from the template file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 模板文件包含一系列语句。其中一些是静态字面量，而其他则是使用特殊语法表示的动态内容的占位符。模板引擎从模板文件中读取每个语句。让我们称每个读取的行为一个模板字符串，从现在开始。这个过程从从模板文件中读取的模板字符串开始：
- en: The template string is fed to the parser. The template string in our example
    is `<p> Welcome {{name}} </p>`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板字符串被送入解析器。在我们的例子中，模板字符串是 `<p> Welcome {{name}} </p>`。
- en: The parser first determines the type of template string, which is called `if`
    tags, `for` tags, and template variables. In this example, a token of type template
    variable is generated (if the template string contains a static literal, it is
    written to the HTML output without any changes).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器首先确定模板字符串的类型，这被称为 `if` 标签、`for` 标签和模板变量。在这个例子中，生成了一个模板变量类型的标记（如果模板字符串包含静态字面量，则将其写入
    HTML 输出而不做任何更改）。
- en: Then the template string is parsed into a static literal, `Welcome`, and a template
    variable `{{name}}`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将模板字符串解析为静态字面量，`Welcome`，和一个模板变量 `{{name}}`。
- en: The outputs of the parser (from steps 2 and 3) are passed to the HTML generator.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器的输出（步骤 2 和 3）传递给 HTML 生成器。
- en: Data from a data source is passed as context by the template engine to the generator.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板引擎通过上下文将数据源的数据传递给生成器。
- en: The parsed token and strings (from steps 2 and 3) are combined with the context
    data (from *step 5*) to produce the result string, which is written to the output
    HTML file.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析的标记和字符串（步骤 2 和 3）与上下文数据（步骤 5）结合，生成结果字符串，并将其写入输出 HTML 文件。
- en: The preceding steps are repeated for every statement (template string) read
    from the template file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤会针对从模板文件中读取的每个语句（模板字符串）重复进行。
- en: We cannot use the parser we created for arithmetic parsing in [*Chapter 2*](B16405_02_Final_NM_ePUB.xhtml#_idTextAnchor041),
    *A Tour of the Rust Programming Language*, for this example, as we need something
    specific for the HTML template language syntax. We could use the general-purpose
    parsing libraries (for example, `nom`, `pest`, and `lalrpop` are a few popular
    parsing libraries in Rust), but for this book, we will custom-build a template
    parser. The reason for this approach is that each parsing library has its own
    API and grammar that we need to familiarize ourselves with. Doing that would deviate
    from the goal of this book, which is learning to write idiomatic code in Rust
    from the first principles.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用在 [*第 2 章*](B16405_02_Final_NM_ePUB.xhtml#_idTextAnchor041)，“Rust 编程语言之旅”中为算术解析创建的解析器，因为在这个例子中，我们需要针对
    HTML 模板语言语法特定的东西。我们可以使用通用解析库（例如，`nom`、`pest` 和 `lalrpop` 是 Rust 中几个流行的解析库），但为了这本书，我们将自定义构建一个模板解析器。这样做的原因是每个解析库都有自己的
    API 和语法，我们需要熟悉它们。这样做会偏离本书的目标，即从第一原理学习如何用 Rust 编写惯用代码。
- en: 'First, let''s create a new library project with the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的库项目，如下所示：
- en: '[PRE0]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `src/lib.rs` file (which is automatically created by the `cargo` tool) will
    contain all the functionality of the template engine.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/lib.rs` 文件（由 `cargo` 工具自动创建）将包含模板引擎的所有功能。'
- en: Create a new file, `src/main.rs`. The `main()` function will be placed in this
    file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`src/main.rs`。`main()` 函数将放置在这个文件中。
- en: 'Let''s now design the code structure for the template engine. *Figure 3.8*
    shows the detailed design:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来设计模板引擎的代码结构。*图 3.8* 展示了详细的设计：
- en: '![Figure 3.8: Design of the template engine](img/Figure_3.8_B16405.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8：模板引擎的设计](img/Figure_3.8_B16405.jpg)'
- en: 'Figure 3.8: Design of the template engine'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：模板引擎的设计
- en: Let's cover the key data structures and functions of the template engine along
    with some code snippets. We will start with the data structures.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们结合一些代码片段，来介绍模板引擎的关键数据结构和函数。我们将从数据结构开始。
- en: Data structures
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据结构
- en: '`ContentType` is the main data structure to classify the *template string*
    read from the *template file*. It is represented as `enum` and contains the list
    of possible `ContentType` is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentType` 是用于分类从 *模板文件* 中读取的 *模板字符串* 的主要数据结构。它以 `enum` 的形式表示，并包含可能的 `ContentType`
    列表如下：'
- en: src/lib.rs
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE1]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pay special attention to the annotations `PartialEq` and `Debug`. The former
    is used to allow content types to be compared, and the latter is used to print
    the values of the content to the console.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意 `PartialEq` 和 `Debug` 这两个注释。前者用于允许内容类型进行比较，后者用于将内容值打印到控制台。
- en: Derivable traits
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 可推导特质
- en: The Rust compiler can automatically derive default implementations for a few
    traits defined in the standard library. Such traits are called *derivable traits*.
    To instruct the compiler to provide default trait implementations, the `#[derive]`
    attribute is used. Note that this can be done only for types such as custom structs
    and enums that you have defined, not for types defined in other libraries that
    you don't own.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器可以自动为标准库中定义的一些特质提供默认实现。这些特质被称为*可推导特质*。为了指示编译器提供默认特质实现，使用`#[derive]`属性。请注意，这只能对您定义的自定义结构体和枚举类型执行，不能对您不拥有的其他库中定义的类型执行。
- en: Types for which trait implementations can be derived automatically include comparison
    traits such as `Eq`, `PartialEq`, and `Ord`, and others such as `Copy`, `Clone`,
    `Hash`, `Default`, and `Debug`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可以自动推导特质实现的类型包括比较特质，如`Eq`、`PartialEq`和`Ord`，以及其他如`Copy`、`Clone`、`Hash`、`Default`和`Debug`。
- en: '`TagType` is a supporting data structure that is used to indicate whether a
    template string corresponds to a `for-tag` (repetitive loop) or `if-tag` (display
    control):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`TagType`是一个支持数据结构，用于指示模板字符串是否对应于`for-tag`（重复循环）或`if-tag`（显示控制）：'
- en: src/lib.rs
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE2]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will create a struct to store the result of the tokenization of the template
    string:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个结构体来存储模板字符串分词的结果：
- en: src/lib.rs
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE3]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that `head` and `tail` are of type `Option<String>` to allow for the possibility
    that a template variable may not contain static literal text before or after it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`head`和`tail`的类型为`Option<String>`，以允许模板变量可能不包含静态字面文本在其前后。
- en: To summarize, the template string is first tokenized as type `ContentType::TemplateVariable(ExpressionData)`,
    and `ExpressionData` is parsed into `head="Hello"`, `variable="name"`, and `tail
    =",welcome"`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，模板字符串首先被分词为`ContentType::TemplateVariable(ExpressionData)`类型，然后`ExpressionData`被解析为`head="Hello"`、`variable="name"`和`tail
    =",welcome"`。
- en: Key functions
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键函数
- en: 'Let''s look at the key functions to implement the template engine:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现模板引擎的关键函数：
- en: '`Program: main()`: This is the starting point of the program. It first calls
    functions to tokenize and parse the template string, accepts context data to feed
    into the template, and then calls functions to generate the HTML using the parser
    outputs and context data.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`程序：main()`：这是程序的起点。它首先调用函数来分词和解析模板字符串，接受上下文数据以输入到模板中，然后调用函数使用解析器的输出和上下文数据生成HTML。'
- en: '`Program: get_content_type()`: This is the entry point into the parser. It
    parses each line of the template file (which we refer to as the template string)
    and classifies it as one of the following token types: Literal, Template variable,
    Tag, or Unrecognized. The Tag token type can be either a `for` tag or an `if`
    tag. If the token is of type Template variable, it parses the template string
    to extract the head, tail, and template variable.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`程序：get_content_type()`：这是解析器的入口点。它解析模板文件（我们称之为模板字符串）的每一行，并将其分类为以下标记类型之一：字面量、模板变量、标记或未识别。标记类型可以是`for`标记或`if`标记。如果标记是模板变量类型，它将解析模板字符串以提取头部、尾部和模板变量。'
- en: 'These types are defined as part of the `ContentType` enum. Let''s write a few
    test cases to crystallize what we would like to see as inputs and outputs to this
    function, and then look at the actual code for `get_content_type()`. Let''s take
    a `tests` module by adding the following block of code in `src/lib.rs`:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些类型被定义为`ContentType`枚举的一部分。让我们编写一些测试用例，明确我们希望这个函数的输入和输出是什么，然后查看`get_content_type()`的实际代码。让我们在`src/lib.rs`中添加以下代码块来创建一个`tests`模块：
- en: '[PRE4]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Place the unit tests within this `tests` module. Each test will begin with the
    annotation `#[test]`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将单元测试放在这个`tests`模块中。每个测试都将以注释`#[test]`开始。
- en: '**Test case 1**: To check if the content type is a literal:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例 1**：检查内容类型是否为字面量：'
- en: src/lib.rs
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE5]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This test case is to check whether the literal string stored in variable `s`
    is tokenized as `ContentType::Literal(s)`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例是为了检查存储在变量`s`中的字面量字符串是否被分词为`ContentType::Literal(s)`。
- en: '**Test case 2**: To check if the content type is of the template variable type:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例 2**：检查内容类型是否为模板变量类型：'
- en: src/lib.rs
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE6]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For the `Template String` token type, this test case checks to see if the expression
    in the template string is parsed into the `head`, `variable`, and `tail` components,
    and successfully returned as type `ContentType::TemplateVariable (ExpressionData)`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Template String`标记类型，这个测试用例检查模板字符串中的表达式是否被解析为`head`、`variable`和`tail`组件，并成功返回为类型`ContentType::TemplateVariable
    (ExpressionData)`。
- en: '`ForTag`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForTag`:'
- en: src/lib.rs
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE7]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This test case is to check if a statement containing a `for` tag is tokenized
    successfully as `ContentType::Tag(TagType::ForTag)`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例是为了检查包含`for`标签的语句是否成功被标记为`ContentType::Tag(TagType::ForTag)`。
- en: '`IfTag`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`IfTag`:'
- en: src/lib.rs
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE8]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This test case is to check if a statement containing an `if` tag is tokenized
    successfully as `ContentType::Tag(TagType::IfTag)`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例是为了检查包含`if`标签的语句是否成功被标记为`ContentType::Tag(TagType::IfTag)`。
- en: Now that we have written the unit test cases, let's write the code for the template
    engine.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了单元测试用例，接下来让我们编写模板引擎的代码。
- en: Writing the template engine
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写模板引擎
- en: 'There are two key parts to writing the template engine – the parser and HTML
    generator. We will start with the parser. *Figure 3.9* shows the design of the
    parser:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 编写模板引擎有两个关键部分——解析器和HTML生成器。我们将从解析器开始。*图3.9*显示了解析器的结构：
- en: '![](img/Figure_3.9_B16405.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.9_B16405.jpg)'
- en: 'Figure 3.9: Parser design'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：解析器设计
- en: 'Here is a brief description of the various methods in the parser:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是解析器中各种方法的简要描述：
- en: '`get_content_type()`: Entry point for parser. Accepts an input statement and
    tokenizes it into one of an `if` tag, a `for` tag, or a template variable.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_content_type()`: 解析器的入口点。接受一个输入语句，并将其标记化为`if`标签、`for`标签或模板变量之一。'
- en: '`check_symbol_string()`: This is a supporting method that checks if a symbol
    is present within another string. For example, we can check if the pattern `{%`
    is present in a statement from the template file, and use it to determine if it
    is a tag statement or template variable.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_symbol_string()`: 这是一个辅助方法，用于检查一个符号是否存在于另一个字符串中。例如，我们可以检查模式`{%`是否存在于模板文件的语句中，并据此确定它是一个标签语句还是模板变量。'
- en: '`check matching pair()`: This is a supporting method that is used to verify
    if a statement in a template file is syntactically correct. For example, we can
    check for the presence of matching pairs `{%` and `%}`. Otherwise, the statement
    is marked as `Unrecognized`.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check matching pair()`: 这是一个辅助方法，用于验证模板文件中的语句是否在语法上正确。例如，我们可以检查是否存在匹配的成对`{%`和`%}`。否则，该语句将被标记为`Unrecognized`。'
- en: '`get_index_for_symbol()`: This method returns the starting index of a substring
    within another string. It is used for string manipulation.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_index_for_symbol()`: 这个方法返回一个子字符串在另一个字符串中的起始索引。它用于字符串操作。'
- en: '`get_expression_data()`: This method parses a template string into its constituent
    parts for a token of type `TemplateString`.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_expression_data()`: 这个方法将模板字符串解析为其组成部分，用于类型为`TemplateString`的标记。'
- en: Writing the parser
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写解析器
- en: 'Let''s first look at the `get_content_type()` method. Here is a summary of
    the program logic:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`get_content_type()`方法。以下是程序逻辑的摘要：
- en: '`for` tags are enclosed by `{%` and `%}` and contain the `for` keyword.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`标签被`{%`和`%}`包围，并包含`for`关键字。'
- en: '`if` tags are enclosed by `{%` and `%}` and contain the `if` keyword.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`标签被`{%`和`%}`包围，并包含`if`关键字。'
- en: Template variables are enclosed by `{{` and `}}`.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板变量被`{{`和`}}`包围。
- en: Based on these rules, the statement is parsed and the appropriate token is returned
    – a `for` tag, an `if` tag, or a template variable.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些规则，语句被解析，并返回适当的标记——一个`for`标签、一个`if`标签或一个模板变量。
- en: 'Here is the complete code listing for the `get_content_type()` function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`get_content_type()`函数的完整代码列表：
- en: src/lib.rs
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE9]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Supporting functions
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持函数
- en: 'Let''s now talk about supporting functions. The parser utilizes these supporting
    functions to perform operations such as checking for the presence of a substring
    within a string, checking for matching pairs of braces, and so on. They are needed
    to check whether the template string is syntactically correct, and also to parse
    the template string into its constituent parts. Before writing some more code,
    let''s look at the test cases for these supporting functions to understand how
    they will be used, and then see the code. Note that these functions are designed
    to enable reuse across projects. All supporting functions are placed in `src/lib.rs`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈支持函数。解析器使用这些支持函数执行诸如检查字符串中是否存在子字符串、检查花括号匹配对等操作。它们用于检查模板字符串是否语法正确，以及将模板字符串解析为其组成部分。在编写更多代码之前，让我们看看这些支持函数的测试用例，以了解它们将如何被使用，然后查看代码。请注意，这些函数被设计为可以在多个项目中重用。所有支持函数都放在
    `src/lib.rs` 中：
- en: '`check_symbol_string()`: Checks if a symbol string, for example, `''{%''`,
    is contained within another string. Here is the test case:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_symbol_string()`: 检查一个符号字符串，例如 `''{%''`，是否包含在另一个字符串中。以下是这个函数的测试用例：'
- en: '[PRE10]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the code for the function:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是该函数的代码：
- en: '[PRE11]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The standard library provides a straightforward way to check for a substring
    within a string slice.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标准库提供了一个简单的方法来检查字符串切片中的子字符串。
- en: '`check_matching_pair()`: This function checks for matching symbol strings.
    Here is the test case:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_matching_pair()`: 这个函数检查匹配的符号字符串。以下是这个函数的测试用例：'
- en: '[PRE12]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'pub fn check_matching_pair(input: &str, symbol1: &str,'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'pub fn check_matching_pair(input: &str, symbol1: &str,'
- en: 'symbol2: &str) -> bool {'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'symbol2: &str) -> bool {'
- en: input.contains(symbol1) && input.contains(symbol2)
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: input.contains(symbol1) && input.contains(symbol2)
- en: '}'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`get_expression_data()`: This parses an expression with a template variable,
    parses it into `head`, `variable`, and `tail` components, and returns the results.
    Here is the test case for this function:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_expression_data()`: 这个函数解析带有模板变量的表达式，将其解析为 `head`、`variable` 和 `tail`
    组件，并返回结果。以下是这个函数的测试用例：'
- en: '[PRE14]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the code for the function:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是该函数的代码：
- en: '[PRE15]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`get_index_for_symbol`: This function takes two parameters and returns the
    index where the second value is found within the first value. This makes it easy
    to split the template string into three parts – `head`, `variable`, and `tail`.
    Here is the test case:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_index_for_symbol`: 这个函数接受两个参数，并返回第二个值在第一个值中找到的索引。这使得将模板字符串分成三部分——`head`、`variable`
    和 `tail` 变得容易。以下是这个函数的测试用例：'
- en: '[PRE16]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'pub fn get_index_for_symbol(input: &str, symbol: char)'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'pub fn get_index_for_symbol(input: &str, symbol: char)'
- en: -> (bool, usize) {
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> (bool, usize) {
- en: let mut characters = input.char_indices();
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let mut characters = input.char_indices();
- en: let mut does_exist = false;
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let mut does_exist = false;
- en: let mut index = 0;
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let mut index = 0;
- en: while let Some((c, d)) = characters.next() {
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: while let Some((c, d)) = characters.next() {
- en: if d == symbol {
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if d == symbol {
- en: does_exist = true;
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: does_exist = true;
- en: index = c;
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: index = c;
- en: break;
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: (does_exist, index)
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (does_exist, index)
- en: '}'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This concludes the code for the `Parser` module. Let's now look at the main
    function that ties all the pieces together.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `Parser` 模块的代码。现在让我们看看将所有部分联系在一起的主要函数。
- en: The main() function
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`main()` 函数'
- en: 'The `main()` function is the entry point into the template engine. *Figure
    3.10* shows the design of the `main()` function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数是模板引擎的入口点。*图 3.10* 展示了 `main()` 函数的设计：'
- en: '![Figure 3.10: The main() function](img/Figure_3.10_B16405.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10：`main()` 函数](img/Figure_3.10_B16405.jpg)'
- en: 'Figure 3.10: The main() function'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：`main()` 函数
- en: 'The `main()` function performs the coordination role tying all pieces together.
    It invokes the parser, initializes the context data, and then invokes the generator:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数执行协调角色，将所有部分联系在一起。它调用解析器，初始化上下文数据，然后调用生成器：'
- en: '`HashMap` to pass values for the template variables mentioned in the template.
    We add values for `name` and `city` to this `HashMap`. The `HashMap` is passed
    to the generator function along with the parsed template input:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashMap` 用于传递模板中提到的模板变量的值。我们将 `name` 和 `city` 的值添加到这个 `HashMap` 中。这个 `HashMap`
    与解析后的模板输入一起传递给生成函数：'
- en: '[PRE18]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`get_context_data()` function for each line of input read from the command
    line (standard input).'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为从命令行（标准输入）读取的每一行输入的 `get_context_data()` 函数。
- en: a) If the line contains template variable, it invokes the HTML generator `generate_html_template_var()`
    to create the HTML output.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 如果行包含模板变量，它将调用 HTML 生成器 `generate_html_template_var()` 来创建 HTML 输出。
- en: b) If the line contains a literal string, it simply echoes back the input HTML
    literal string.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 如果一行包含一个字面字符串，它将简单地回显输入的 HTML 字面字符串。
- en: 'c) If the line contains `for` or `if` tags, right now, we simply print out
    a statement that the feature is not yet implemented. We will implement this in
    future chapters:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 如果一行包含 `for` 或 `if` 标签，目前我们只是打印出一个声明该功能尚未实现。我们将在未来的章节中实现它：
- en: '[PRE19]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`io::stdin()` function creates a new handle to the standard input of the current
    process. The standard input is read one line at a time using the following `for`
    loop, which is then passed on to the parser for processing:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io::stdin()` 函数创建当前进程的标准输入的新句柄。标准输入使用以下 `for` 循环逐行读取，然后传递给解析器进行处理：'
- en: '[PRE20]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the complete code listing for the `main()` function:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `main()` 函数的完整代码列表：
- en: src/main.rs
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: src/main.rs
- en: '[PRE21]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The implementation for the `generate_html_template_var()` function is shown
    here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_html_template_var()` 函数的实现如下所示：'
- en: src/lib.rs
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE22]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function constructs the output `html` statement consisting of *head*, *text
    content*, and *tail*. To construct the text content, the template variables are
    replaced with the values from the context data. The constructed `html` statement
    is returned from the function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数构建输出 `html` 语句，该语句由 *head*、*文本内容* 和 *tail* 组成。为了构建文本内容，模板变量被替换为上下文数据中的值。构建的
    `html` 语句由函数返回。
- en: The complete code from this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在 [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03)
    找到。
- en: Executing the template engine
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行模板引擎
- en: We have, for now, the outline and foundations for a basic template engine that
    can deal with two kinds of input – static literals and template variables.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经有了基本模板引擎的轮廓和基础，它可以处理两种类型的输入——静态字面量和模板变量。
- en: 'Let''s execute the program and run some tests:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行程序并运行一些测试：
- en: 'Build and run the project with the following:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建和运行项目：
- en: '[PRE23]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`<h2> Hello, welcome to my page </h2>`. You will see the same string printed
    out as there is no transformation to be done.'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<h2> 你好，欢迎来到我的页面 </h2>`。您将看到相同的字符串被打印出来，因为没有需要进行转换。'
- en: '`<p> My name is {{name}} </p>` or `<p> I live in {{city}} </p>`. You will see
    `<p> My name is Bob </p>` or `<p> I live in Boston </p>` printed out corresponding
    to the input. This is because we initialized the variable `name` to `Bob` and
    `city` to `Boston` in the `main()` program. You are encouraged to enhance this
    code to add support for two template vars in a single HTML statement.'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<p> 我的名字是 {{name}} </p>` 或 `<p> 我住在 {{city}} </p>`。您将看到 `<p> 我的名字是 Bob </p>`
    或 `<p> 我住在波士顿 </p>` 被相应地打印出来。这是因为我们在 `main()` 程序中将变量 `name` 初始化为 `Bob`，将 `city`
    初始化为 `Boston`。我们鼓励您增强此代码以支持在单个 HTML 语句中添加对两个模板变量的支持。'
- en: '`{%` and `%}`, and containing either the string `for` or `if`. You will see
    one of the following messages printed out to the terminal: `For Tag not implemented`
    or `If Tag not implemented`.'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{%` 和 `%}`，并且包含字符串 `for` 或 `if`。您将在终端看到以下消息之一被打印出来：`For Tag not implemented`
    或 `If Tag not implemented`。'
- en: You are encouraged to write the code for the `for` tag and `if` tag as an exercise.
    Ensure to check for the right sequence of symbols. For example, an invalid format
    such as `{% for }%` or `%} if {%` should be rejected.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您被鼓励编写 `for` 标签和 `if` 标签的代码作为练习。确保检查符号的正确顺序。例如，无效的格式如 `{% for }%` 或 `%} if {%`
    应该被拒绝。
- en: Even though we are not able to implement more features of the template engine,
    in this chapter, we have seen how to use the Rust Standard Library in a real-life
    use case. We have primarily used the `io`, `collections`, `iter`, and `str` modules
    from the Rust Standard Library to implement the code in this chapter. As we go
    through future chapters, we will cover more of the standard library.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们无法在此章节中实现模板引擎的更多功能，但我们已经看到了如何在实际用例中使用 Rust 标准库。我们主要使用了 Rust 标准库中的 `io`、`collections`、`iter`
    和 `str` 模块来实现本章中的代码。随着我们进入未来的章节，我们将涵盖更多标准库的内容。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the overall structure of the Rust Standard Library
    and classified the modules of the standard library into different categories for
    better understanding. You got a brief introduction to the modules in areas of
    concurrency, memory management, file system operations, data processing, data
    types, error handling, compiler-related, FFI, networking, I/O, OS-specific, and
    time-related features.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 Rust 标准库的整体结构，并将标准库的模块按不同类别进行分类，以便更好地理解。您对并发、内存管理、文件系统操作、数据处理、数据类型、错误处理、与编译器相关、FFI、网络、I/O、特定于操作系统和与时间相关的功能等领域的模块进行了简要介绍。
- en: We looked at what a template engine is, how it works, and defined the scope
    and requirements of our project. We designed the template engine in terms of Rust
    data structures (enum and struct) and Rust functions. We saw how to write code
    for parsing templates and to generate HTML for statements involving template variables.
    We executed the program providing input data and verified the generated HTML in
    the terminal (command line).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了模板引擎是什么，它是如何工作的，并定义了我们项目的范围和需求。我们根据 Rust 数据结构（枚举和结构体）和 Rust 函数设计了模板引擎。我们看到了如何编写解析模板的代码以及为涉及模板变量的语句生成
    HTML 的代码。我们提供了输入数据并执行程序，在终端（命令行）中验证了生成的 HTML。
- en: In the next chapter, we will take a closer look at the Rust Standard Library
    modules that deal with managing process environment, command-line arguments, and
    time-related functionality.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨 Rust 标准库中处理管理进程环境、命令行参数和与时间相关的功能的模块。
- en: Further reading
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Django template language**: [https://docs.djangoproject.com/en/3.0/ref/templates/language/](https://docs.djangoproject.com/en/3.0/ref/templates/language/)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Django 模板语言**：[https://docs.djangoproject.com/en/3.0/ref/templates/language/](https://docs.djangoproject.com/en/3.0/ref/templates/language/)'
- en: '**Rust Standard Library**: [https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust 标准库**：[https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html)'
