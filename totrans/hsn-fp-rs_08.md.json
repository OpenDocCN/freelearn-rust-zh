["```rs\nuse std::process::Command;\nuse std::env::current_exe;\n\nfn main() {\n   let path = current_exe()\n             .expect(\"could not find current executable\");\n   let path = path.with_file_name(\"process_b\");\n\n   let mut children = Vec::new();\n   for _ in 0..3 {\n      children.push(\n         Command::new(path.as_os_str())\n                 .spawn()\n                 .expect(\"failed to execute process\")\n      );\n   }\n   for mut c in children {\n      c.wait()\n       .expect(\"failed to wait on child\");\n   }\n}\n```", "```rs\nuse std::{thread,time};\nuse std::process;\nfn main() {\n   let t = time::Duration::from_millis(1000);\n   loop {\n      println!(\"process b #{}\", process::id());\n      thread::sleep(t);\n   }\n}\n```", "```rs\nprocess b #54061\nprocess b #54060\nprocess b #54059\nprocess b #54061\nprocess b #54059\nprocess b #54060\n```", "```rs\n$ ps -a | grep process_a\n54058 ttys001    0:00.00 process_a\n55093 ttys004    0:00.00 grep process_a\n$ pstree 54058\n54058 process_a\n>   54059 process_b\n>   54060 process_b\n>   54061 process_b\n```", "```rs\nextern crate nix;\nuse nix::unistd::{fork,ForkResult};\nuse std::{thread,time};\nuse std::process;\n\nfn main() {\n   let mut children = Vec::new();\n   for _ in 0..3 {\n      match fork().expect(\"fork failed\") {\n         ForkResult::Parent{ child: pid } => { children.push(pid); }\n         ForkResult::Child => {\n            let t = time::Duration::from_millis(1000);\n            loop {\n               println!(\"child process #{}\", process::id());\n               thread::sleep(t);\n            }\n         }\n      }\n   }\n   let t = time::Duration::from_millis(1000);\n   loop {\n      println!(\"parent process #{}\", process::id());\n      thread::sleep(t);\n   }\n}\n```", "```rs\nextern crate nix;\nuse nix::unistd::{fork};\nuse std::{thread,time};\n\nfn main() {\n   let mut big_data: Vec<u8> = Vec::with_capacity(200000000);\n   big_data.push(1);\n   big_data.push(2);\n   big_data.push(3);\n   //Both sides of the fork, will continue to fork\n   //This is called a fork bomb\n   for _ in 0..9 {\n      fork().expect(\"fork failed\");\n   }\n   //2^9 = 512\n\n   let t = time::Duration::from_millis(1000);\n   loop {\n      //copy on write, not on read\n      big_data[2];\n      thread::sleep(t);\n   }\n}\n```", "```rs\nextern crate nix;\nuse nix::unistd::{fork,ForkResult};\nuse std::{thread,time};\nuse std::process;\nuse std::io::prelude::*;\nuse std::net::TcpListener;\n\nfn serve(listener: TcpListener) -> ! {\n   for stream in listener.incoming() {\n      let mut buffer = [0; 2048];\n      let mut tcp = stream.unwrap();\n      tcp.read(&mut buffer).expect(\"tcp read failed\");\n      let response = format!(\"respond from #{}\\n\", process::id());\n      tcp.write(response.as_bytes()).expect(\"tcp write failed\");\n   }\n   panic!(\"unreachable\");\n}\n\nfn main() {\n   let listener = TcpListener::bind(\"127.0.0.1:8888\").unwrap();\n   let mut children = Vec::new();\n   for _ in 0..3 {\n      match fork().expect(\"fork failed\") {\n         ForkResult::Parent{ child: pid } => { children.push(pid); }\n         ForkResult::Child => { serve(listener) }\n      }\n   }\n\n   let t = time::Duration::from_millis(1000);\n   loop {\n      thread::sleep(t);\n   }\n}\n```", "```rs\n$ curl 'http://localhost:8888/'\nrespond from #59485\n$ curl 'http://localhost:8888/'\nrespond from #59486\n$ curl 'http://localhost:8888/'\nrespond from #59487\n$ curl 'http://localhost:8888/'\nrespond from #59485\n$ curl 'http://localhost:8888/'\nrespond from #59486\n```", "```rs\nuse std::{thread,time};\nuse std::process;\nextern crate thread_id;\n\nfn main() {\n   for _ in 0..3 {\n      thread::spawn(|| {\n         let t = time::Duration::from_millis(1000);\n         loop {\n            println!(\"child thread #{}:{}\", process::id(), \n       thread_id::get());\n            thread::sleep(t);\n         }\n      });\n   }\n   let t = time::Duration::from_millis(1000);\n   loop {\n      println!(\"parent thread #{}:{}\", process::id(), \n      thread_id::get());\n      thread::sleep(t);\n   }\n}\n```", "```rs\nparent thread #59804:140735902303104\nchild thread #59804:123145412530176\nchild thread #59804:123145410420736\nchild thread #59804:123145408311296\nparent thread #59804:140735902303104\nchild thread #59804:123145410420736\nchild thread #59804:123145408311296\n```", "```rs\nuse std::{thread,time};\nuse std::sync::{Mutex, Arc};\n\nfn main() {\n   let mut big_data: Vec<u8> = Vec::with_capacity(200000000);\n   big_data.push(1);\n   big_data.push(2);\n   big_data.push(3);\n   let big_data = Arc::new(Mutex::new(big_data));\n   for _ in 0..512 {\n      let big_data = Arc::clone(&big_data);\n      thread::spawn(move || {\n         let t = time::Duration::from_millis(1000);\n         loop {\n            let d = big_data.lock().unwrap();\n            (*d)[2];\n            thread::sleep(t);\n         }\n      });\n   }\n   let t = time::Duration::from_millis(1000);\n   loop {\n      thread::sleep(t);\n   }\n}\n```", "```rs\nuse std::{thread,time};\nuse std::process;\nextern crate thread_id;\nuse std::io::prelude::*;\nuse std::net::{TcpListener,TcpStream};\nuse std::sync::{Arc,Mutex};\n\nfn serve(incoming: Arc<Mutex<Vec<TcpStream>>>) {\n   let t = time::Duration::from_millis(10);\n   loop {\n      {\n         let mut incoming = incoming.lock().unwrap();\n         for stream in incoming.iter() {\n            let mut buffer = [0; 2048];\n            let mut tcp = stream;\n            tcp.read(&mut buffer).expect(\"tcp read failed\");\n            let response = format!(\"respond from #{}:{}\\n\", \n              process::id(), thread_id::get());\n            tcp.write(response.as_bytes()).expect(\"tcp write failed\");\n         }\n         incoming.clear();\n      }\n      thread::sleep(t);\n   }\n}\n\nfn main() {\n   let listener = TcpListener::bind(\"127.0.0.1:8888\").unwrap();\n   let incoming = Vec::new();\n   let incoming = Arc::new(Mutex::new(incoming));\n   for _ in 0..3 {\n      let incoming = Arc::clone(&incoming);\n      thread::spawn(move || {\n         serve(incoming);\n      });\n   }\n\n   for stream in listener.incoming() {\n      let mut incoming = incoming.lock().unwrap();\n      (*incoming).push(stream.unwrap());\n   }\n}\n```", "```rs\nuse std::{thread,time};\nuse std::process;\nuse std::io::prelude::*;\nextern crate thread_id;\nuse std::net::{TcpListener,TcpStream};\nuse std::sync::mpsc::{channel,Receiver};\nuse std::collections::VecDeque;\n\nfn serve(receiver: Receiver<TcpStream>) {\n   let t = time::Duration::from_millis(10);\n   loop {\n      let mut tcp = receiver.recv().unwrap();\n      let mut buffer = [0; 2048];\n      tcp.read(&mut buffer).expect(\"tcp read failed\");\n      let response = format!(\"respond from #{}:{}\\n\", process::id(), \n             thread_id::get());\n      tcp.write(response.as_bytes()).expect(\"tcp write failed\");\n      thread::sleep(t);\n   }\n}\n\nfn main() {\n   let listener = TcpListener::bind(\"127.0.0.1:8888\").unwrap();\n   let mut channels = VecDeque::new();\n   for _ in 0..3 {\n      let (sender, receiver) = channel();\n      channels.push_back(sender);\n      thread::spawn(move || {\n         serve(receiver);\n      });\n   }\n   for stream in listener.incoming() {\n      let round_robin = channels.pop_front().unwrap();\n      round_robin.send(stream.unwrap()).unwrap();\n      channels.push_back(round_robin);\n   }\n}\n```", "```rs\nuse std::{thread,time};\nextern crate rand;\nuse std::sync::{Arc,Mutex};\n#[macro_use] extern crate lazy_static;\nlazy_static! {\n   static ref NEURAL_NET_WEIGHTS: Vec<Arc<Mutex<Vec<f64>>>> = {\n      let mut nn = Vec::with_capacity(10000);\n      for _ in 0..10000 {\n         let mut mm = Vec::with_capacity(100);\n         for _ in 0..100 {\n            mm.push(rand::random::<f64>());\n         }\n         let mm = Arc::new(Mutex::new(mm));\n         nn.push(mm);\n      }\n      nn\n   };\n}\n\nfn train() {\n   let t = time::Duration::from_millis(100);\n   loop {\n      for _ in 0..100 {\n         let update_position = rand::random::<u64>() % 1000000;\n         let update_column = update_position / 10000;\n         let update_row = update_position % 100;\n         let update_value = rand::random::<f64>();\n         let mut update_column = NEURAL_NET_WEIGHTS[update_column as usize].lock().unwrap();\n         update_column[update_row as usize] = update_value;\n      }\n      thread::sleep(t);\n   }\n}\n\nfn main() {\n   let t = time::Duration::from_millis(1000);\n   for _ in 0..500 {\n      thread::spawn(train);\n   }\n   loop {\n      thread::sleep(t);\n   }\n}\n```", "```rs\nuse std::thread;\n\nfn main() {\n   let a = vec![1, 2, 3];\n\n   thread::spawn(|| {\n      println!(\"a = {:?}\", a);\n   });\n}\n```", "```rs\nclosure may outlive the current function, but it borrows `a`, which is owned by the current function\n```", "```rs\nuse std::thread;\n\nfn main() {\n   let a = vec![1, 2, 3];\n\n   thread::spawn(move || {\n      println!(\"a = {:?}\", a);\n   });\n}\n```", "```rs\nuse std::thread;\n\nfn main() {\n   let a = vec![1, 2, 3];\n\n   thread::spawn(move || {\n      println!(\"a = {:?}\", a);\n   });\n\n   thread::spawn(move || {\n      println!(\"a = {:?}\", a);\n   });\n}\n```", "```rs\n$ rustc t.rs\nerror[E0382]: capture of moved value: `a`\n  --> t.rs:11:28\n   |\n6  |    thread::spawn(move || {\n   |                  ------- value moved (into closure) here\n...\n11 |       println!(\"a = {:?}\", a);\n   |                            ^ value captured here after move\n   |\n   = note: move occurs because `a` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n```", "```rs\nfn main() {\n   let a = vec![1, 2, 3];\n   let b = a;\n}\n```", "```rs\nuse std::thread;\n\nfn main() {\n   static A: [u8; 100] = [22; 100];\n\n   thread::spawn(|| {\n      A[3];\n   });\n\n   thread::spawn(|| {\n      A[3]\n   });\n}\n```", "```rs\nuse std::thread;\n#[macro_use] extern crate lazy_static;\n\nlazy_static! {\n   static ref A: Vec<u32> = {\n      vec![1, 2, 3]\n   };\n}\n\nfn main() {\n   thread::spawn(|| {\n      A[1];\n   });\n\n   thread::spawn(|| {\n      A[2];\n   });\n}\n```", "```rs\nuse std::thread;\nuse std::sync::{Arc};\n\nfn main() {\n   let a = Arc::new(vec![1, 2, 3]);\n   {\n      let a = Arc::clone(&a);\n      thread::spawn(move || {\n         a[1];\n      });\n   }\n\n   {\n      let a = Arc::clone(&a);\n      thread::spawn(move || {\n         a[1];\n      });\n   }\n}\n```", "```rs\nuse std::thread;\nuse std::sync::{Arc,Mutex};\n\nfn main() {\n   let a = Arc::new(Mutex::new(vec![1, 2, 3]));\n   {\n      let a = Arc::clone(&a);\n      thread::spawn(move || {\n         let mut a = a.lock().unwrap();\n         (*a)[1] = 2;\n      });\n   }\n   {\n      let a = Arc::clone(&a);\n      thread::spawn(move || {\n         let mut a = a.lock().unwrap();\n         (*a)[1] = 3;\n      });\n   }\n}\n```", "```rs\nuse std::thread;\n\nstruct MyBox(u8);\nunsafe impl Send for MyBox {}\nunsafe impl Sync for MyBox {}\n\nstatic A: MyBox = MyBox(22);\n\nfn main() {\n   thread::spawn(move || {\n      A.0\n   });\n   thread::spawn(move || {\n      A.0\n   });\n}\n```", "```rs\nuse std::thread;\nuse std::sync::mpsc::{channel};\nuse std::time;\n\nfn main() {\n   let (pinginsend,pinginrecv) = channel();\n   let (pingoutsend,pingoutrecv) = channel();\n   let mut ping = 1;\n   thread::spawn(move || {\n      let t = time::Duration::from_millis(1000);\n      loop {\n         let n = pinginrecv.recv().unwrap();\n         ping += n;\n         println!(\"ping {}\", ping);\n         thread::sleep(t);\n         pingoutsend.send(ping).unwrap();\n      }\n   });\n\n   let (ponginsend,ponginrecv) = channel();\n   let (pongoutsend,pongoutrecv) = channel();\n   let mut pong = 2;\n   thread::spawn(move || {\n      let t = time::Duration::from_millis(1000);\n      loop {\n         let n = ponginrecv.recv().unwrap();\n         pong += n;\n         println!(\"pong {}\", pong);\n         thread::sleep(t);\n         pongoutsend.send(pong).unwrap();\n      }\n   });\n\n   let mut d = 3;\n   loop {\n      pinginsend.send(d).unwrap();\n      d = pingoutrecv.recv().unwrap();\n      ponginsend.send(d).unwrap();\n      d = pongoutrecv.recv().unwrap();\n   }\n}\n```", "```rs\nuse std::thread;\nuse std::sync::mpsc::{channel,Sender,Receiver};\nuse std::time;\nextern crate rand;\n\nfn new_ping() -> (Sender<u64>, Receiver<u64>) {\n   let (pinginsend,pinginrecv) = channel();\n   let (pingoutsend,pingoutrecv) = channel();\n   let mut ping = 1;\n   thread::spawn(move || {\n      let t = time::Duration::from_millis(1000);\n      loop {\n         let n = pinginrecv.recv().unwrap();\n         ping += n;\n         println!(\"ping {}\", ping);\n         thread::sleep(t);\n         pingoutsend.send(ping).unwrap();\n      }\n   });\n   (pinginsend, pingoutrecv)\n}\n\nfn new_pong() -> (Sender<u64>, Receiver<u64>) {\n   let (ponginsend,ponginrecv) = channel();\n   let (pongoutsend,pongoutrecv) = channel();\n   let mut pong = 2;\n   thread::spawn(move || {\n      let t = time::Duration::from_millis(1000);\n      loop {\n         let n = ponginrecv.recv().unwrap();\n         pong += n;\n         println!(\"pong {}\", pong);\n         thread::sleep(t);\n         pongoutsend.send(pong).unwrap();\n      }\n   });\n   (ponginsend, pongoutrecv)\n}\n```", "```rs\nfn main() {\n   let pings = vec![new_ping(), new_ping(), new_ping()];\n   let pongs = vec![new_pong(), new_pong(), new_pong()];\n   loop {\n      let mut d = 3;\n\n      let (ref pingin,ref pingout) = pings[(rand::random::<u64>() % 3) as usize];\n      pingin.send(d).unwrap();\n      d = pingout.recv().unwrap();\n\n      let (ref pongin,ref pongout) = pongs[(rand::random::<u64>() % 3) as usize];\n      pongin.send(d).unwrap();\n      pongout.recv().unwrap();\n   }\n}\n```", "```rs\nuse std::thread;\nuse std::sync::mpsc::{channel,Sender,Receiver};\nuse std::time;\nextern crate rand;\n\nenum Address {\n   Ping,\n   Pong\n}\n\nenum Message {\n   PingPlus(u64),\n   PongPlus(u64),\n}\n```", "```rs\nfn new_ping() -> (Sender<Message>, Receiver<(Address,Message)>) {\n   let (pinginsend,pinginrecv) = channel();\n   let (pingoutsend,pingoutrecv) = channel();\n   let mut ping = 1;\n   thread::spawn(move || {\n      let t = time::Duration::from_millis(1000);\n      loop {\n         let msg = pinginrecv.recv().unwrap();\n         match msg {\n            Message::PingPlus(n) => { ping += n; },\n            _ => panic!(\"Unexpected message\")\n         }\n         println!(\"ping {}\", ping);\n         thread::sleep(t);\n         pingoutsend.send((\n            Address::Pong,\n            Message::PongPlus(ping)\n         )).unwrap();\n         pingoutsend.send((\n            Address::Pong,\n            Message::PongPlus(ping)\n         )).unwrap();\n      }\n   });\n   (pinginsend, pingoutrecv)\n}\n\nfn new_pong() -> (Sender<Message>, Receiver<(Address,Message)>) {\n   let (ponginsend,ponginrecv) = channel();\n   let (pongoutsend,pongoutrecv) = channel();\n   let mut pong = 1;\n   thread::spawn(move || {\n      let t = time::Duration::from_millis(1000);\n      loop {\n         let msg = ponginrecv.recv().unwrap();\n         match msg {\n            Message::PongPlus(n) => { pong += n; },\n            _ => panic!(\"Unexpected message\")\n         }\n         println!(\"pong {}\", pong);\n         thread::sleep(t);\n         pongoutsend.send((\n            Address::Ping,\n            Message::PingPlus(pong)\n         )).unwrap();\n         pongoutsend.send((\n            Address::Ping,\n            Message::PingPlus(pong)\n         )).unwrap();\n      }\n   });\n   (ponginsend, pongoutrecv)\n}\n```", "```rs\nfn main() {\n   let pings = vec![new_ping(), new_ping(), new_ping()];\n   let pongs = vec![new_pong(), new_pong(), new_pong()];\n\n   //Start the action\n   pings[0].0.send(Message::PingPlus(1)).unwrap();\n\n   //This thread will be the router\n   //This is a busy wait and otherwise bad code\n   //select! would be much better, but it is still experimental\n   //https://doc.rust-lang.org/std/macro.select.html\n   let t = time::Duration::from_millis(10);\n   loop {\n      let mut mail = Vec::new();\n\n      for (_,r) in pings.iter() {\n         for (addr,msg) in r.try_iter() {\n            mail.push((addr,msg));\n         }\n      }\n      for (_,r) in pongs.iter() {\n         for (addr,msg) in r.try_iter() {\n            mail.push((addr,msg));\n         }\n      }\n\n      for (addr,msg) in mail.into_iter() {\n         match addr {\n            Address::Ping => {\n               let (ref s,_) = pings[(rand::random::<u32>() as usize) % pings.len()];\n               s.send(msg).unwrap();\n            },\n            Address::Pong => {\n               let (ref s,_) = pongs[(rand::random::<u32>() as usize) % pongs.len()];\n               s.send(msg).unwrap();\n            }\n         }\n      }\n      thread::sleep(t);\n   }\n}\n```"]