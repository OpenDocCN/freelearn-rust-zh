<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building Web Applications with Rust</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we'll explore building web applications with Rust. We'll get to know the benefits of a static type system and the speed of a compiled language when building web applications with it. We'll also explore Rust's strongly typed HTTP libraries and build a URL shortener as an exercise. Following that, we'll look at a very popular framework called Actix-web and build a bookmark API server with it.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Web applications in Rust</li>
<li>Building a URL shortener with Hyper Crate</li>
<li>The need for web frameworks</li>
<li>Understanding the Actix-web framework</li>
<li>Building an HTTP Rest API using Actix-web</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web applications in Rust</h1>
                </header>
            
            <article>
                
<div class="packt_quote"><em>"The most important property of a program is whether it accomplishes the intention of its user." </em></div>
<p class="CDPAlignRight CDPAlign">– <em>C. A. R. Hoare</em></p>
<p>It's rare for a low-level language to enable developers to write web applications with it while providing thekind of high-level ergonomics that dynamic languages do. With Rust, it's quite the opposite. Developing web applications with Rust is a similar experience one might expect from dynamic languages such as Ruby or Python, due to its high-level abstractions.</p>
<p class="mce-root"/>
<p>Web applications developed in dynamic languages can only get you so far though. A lot of developers find to what, as their code base reaches about a 100,000 lines of code, they start seeing the brittle nature of dynamic languages. With every small change you make, you need to have tests in place to let you know what parts of the application are affected. As the application grows, it becomes a whack-a-mole situation in terms of testing and updating.</p>
<p>Building web applications in a statically typed language such as Rust is another level of experience. Here, you get compile-time checks on your code, thus reducing the amount of unit tests you have to write by a large amount. You don't have the overhead of a language runtime such as an interpreter either, as is the case with dynamic languages that run a GC along with your application. Web applications written in a statically typed language can be compiled as a single static binary that can be deployed with minimal setup needed. Besides, you get speed and accuracy guarantees from the type system and there is a lot of help from the compiler during code refactoring. Rust gives you all of these guarantees, along with the same high-level feel of dynamic languages.</p>
<p>Web applications primarily sit on the application layer protocol and speak the HTTP protocol. HTTP is a stateless protocol where each message is either a request or a response from the client or the server. A message in the HTTP protocol consists of a header and a payload. The header provides context for the kind of HTTP message, such as its origin or the length of the payload, while the payload contains the actual data. HTTP is a text-based protocol, and we generally use libraries to do the hard work of parsing strings as proper HTTP messages. These libraries are further used to build high-level abstractions on top of them, such as a web framework.</p>
<p>To speak HTTP in Rust, we have the <kbd>hyper</kbd> crate, which we'll explore next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Typed HTTP with Hyper</h1>
                </header>
            
            <article>
                
<p>The <strong>hyper</strong> crate can parse HTTP messages, and has an elegant design with focus on strongly typed APIs. It is designed as a type-safe abstraction for raw HTTP requests, as opposed to a common theme in HTTP libraries: describing everything as strings. For example, HTTP status codes in Hyper are defined as enums, for example, the type <kbd>StatusCode</kbd>. The same goes for pretty much everything that can be strongly typed, such as HTTP methods, MIME types, HTTP headers, and so on.</p>
<p class="mce-root"/>
<p>Hyper has both client and server functionality split into separate modules. The client side allows you to build and make HTTP requests with a configurable request body, headers, and other low-level configurations. The server side allows you to open a listening socket and attach request handlers to it. However, it does not include any request route handler implementation <span>– that is</span> left to web frameworks. It is designed to be used as a foundational crate to build higher-level web frameworks. It uses the same <kbd>tokio</kbd> and <kbd>futures</kbd> async abstractions under the hood and thus is very performant.</p>
<p>At its core, Hyper has the concept  <kbd>Service</kbd> trait concept:</p>
<pre class="rust trait">pub trait Service {
    type ReqBody: Payload;
    type ResBody: Payload;
    type Error: Into&lt;Box&lt;dyn StdError + Send + Sync&gt;&gt;;
    type Future: Future&lt;Item = Response&lt;Self::ResBody&gt;, Error = Self::Error&gt;;
    fn call(&amp;mut self, req: Request&lt;Self::ReqBody&gt;) -&gt; Self::Future;
}</pre>
<p>The <kbd>Service</kbd> trait represents a type that handles HTTP requests that are sent from any client and returns a <kbd>Response</kbd>, which is a future. The core API of this trait that types need to implement is the <kbd>call</kbd> method, which takes in a <kbd>Request</kbd> that's parameterized over a generic type <kbd>Body</kbd> and returns a <kbd>Future</kbd> that resolves to a <kbd>Response</kbd>, which is parameterized over the associated type <kbd>ResBody</kbd>. We don't need to manually implement this trait, as hyper includes a bunch of factory methods that can implement the <kbd>Service</kbd> trait for you. You simply need to provide a function that takes HTTP requests and returns responses.</p>
<p>In the following section, we'll explore both the client and server APIs of hyper. Let's start by exploring the server APIs by building a URL shortener from scratch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hyper server APIs – building a URL shortener </h1>
                </header>
            
            <article>
                
<p>In this section, we'll build a URL shortener server that exposes a <kbd>/shorten</kbd> endpoint. This endpoint accepts a <kbd>POST</kbd> request, with the body containing the URL to be shortened. Let's fire up a new project by running <kbd>cargo new hyperurl</kbd> with the following dependencies in <kbd>Cargo.toml</kbd>:</p>
<pre># hyperurl/Cargo.toml<br/><br/>[dependencies]<br/>hyper = "0.12.17"<br/>serde_json = "1.0.33"<br/>futures = "0.1.25"<br/>lazy_static = "1.2.0"<br/>rust-crypto = "0.2.36"<br/>log = "0.4"<br/>pretty_env_logger = "0.3"</pre>
<p>We'll name our URL shortening server, <strong>hyperurl</strong>. A URL shortener service is a service that provides the functionality to create a shorter URL for any given URL. When you have a really long URL, it becomes tedious to share it with someone. A lot of URL shortening services exist today, such as <em>bit.ly</em>. If you have used Twitter, users use short URL in tweets quite often, to save space.</p>
<p> Here's our initial implementation in <kbd>main.rs</kbd>:</p>
<pre>// hyperurl/src/main.rs<br/><br/>use log::{info, error};<br/>use std::env;<br/><br/>use hyper::Server;<br/>use hyper::service::service_fn;<br/><br/>use hyper::rt::{self, Future};<br/><br/>mod shortener;<br/>mod service;<br/>use crate::service::url_service;<br/><br/>fn main() {<br/>    env::set_var("RUST_LOG","hyperurl=info");<br/>    pretty_env_logger::init();<br/><br/>    let addr = "127.0.0.1:3002".parse().unwrap();<br/>    let server = Server::bind(&amp;addr)<br/>        .serve(|| service_fn(url_service))<br/>        .map_err(|e| error!("server error: {}", e));<br/>    info!("URL shortener listening on http://{}", addr);<br/>    rt::run(server);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>In <kbd>main</kbd>, we create a <kbd>Server</kbd> instance and bind it to our loopback address and port string <kbd>"127.0.0.1:3002"</kbd>. This returns a builder instance on which we call <kbd>serve</kbd> before passing in the function <kbd>url_service</kbd> which implements the <kbd>Service</kbd> trait. The function <kbd>url_service</kbd> maps a <kbd>Request</kbd> to a future of <kbd>Response</kbd>. <kbd>service_fn</kbd> is a factory function that has the following signature:</p>
<pre>pub fn service_fn&lt;F, R, S&gt;(f: F) -&gt; ServiceFn&lt;F, R&gt; where<br/>    F: Fn(Request&lt;R&gt;) -&gt; S,<br/>    S: IntoFuture,</pre>
<p>As you can see, F needs to be a Fn closure that</p>
<p>Our function <kbd>url_service</kbd> implements the <kbd>Service</kbd> trait. Next, let's see the code in <kbd>service.rs</kbd>:</p>
<pre>// hyperurl/src/service.rs<br/><br/>use std::sync::RwLock;<br/>use std::collections::HashMap;<br/>use std::sync::{Arc};<br/>use std::str;<br/>use hyper::Request;<br/>use hyper::{Body, Response};<br/>use hyper::rt::{Future, Stream};<br/><br/>use lazy_static::lazy_static;<br/><br/>use crate::shortener::shorten_url;<br/><br/>type UrlDb = Arc&lt;RwLock&lt;HashMap&lt;String, String&gt;&gt;&gt;;<br/>type BoxFut = Box&lt;Future&lt;Item = Response&lt;Body&gt;, Error = hyper::Error&gt; + Send&gt;;<br/><br/>lazy_static! {<br/>    static ref SHORT_URLS: UrlDb = Arc::new(RwLock::new(HashMap::new()));<br/>}<br/><br/>pub(crate) fn url_service(req: Request&lt;Body&gt;) -&gt; BoxFut {<br/>    let reply = req.into_body().concat2().map(move |chunk| {<br/>        let c = chunk.iter().cloned().collect::&lt;Vec&lt;u8&gt;&gt;();<br/>        let url_to_shorten = str::from_utf8(&amp;c).unwrap();<br/>        let shortened_url = shorten_url(url_to_shorten);<br/>        SHORT_URLS.write().unwrap().insert(shortened_url, url_to_shorten.to_string());<br/>        let a = &amp;*SHORT_URLS.read().unwrap();<br/>        Response::new(Body::from(format!("{:#?}", a)))<br/>    });<br/><br/>    Box::new(reply)<br/>}</pre>
<p>This module exposes a single function <kbd>url_service</kbd>, which implements the <kbd>Service</kbd> trait. Our <kbd>url_service</kbd> method implements the method <kbd>call</kbd> by taking in a req of the <kbd>Request&lt;Body&gt;</kbd> type and returns a future that is behind a <kbd>Box</kbd>. </p>
<p>Next, is our <kbd>shortener</kbd> module:</p>
<pre>// hyperurl/src/shortener.rs<br/><br/>use crypto::digest::Digest;<br/>use crypto::sha2::Sha256;<br/><br/>pub(crate) fn shorten_url(url: &amp;str) -&gt; String {<br/>    let mut sha = Sha256::new();<br/>    sha.input_str(url);<br/>    let mut s = sha.result_str();<br/>    s.truncate(5);<br/>    format!("https://u.rl/{}", s)<br/>}</pre>
<p>Our <kbd>shorten_url</kbd> function takes in a URL to shorten as a <kbd>&amp;str</kbd>. It then computes the SHA-256 hash of the URL and truncates it to a string of length five. This is obviously not how a real URL shortener works and is not a scalable solution either. However, it's fine for our demonstration purposes.</p>
<p>Let's take this for a spin:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f550a241-244e-4c30-ac50-b0d294eddb26.png" style="width:45.08em;height:2.08em;"/></p>
<p>Our server is running. At this point we can either send requests POST through curl. We'll do this the other way by building a command-line client for sending URLs to shorten this server.</p>
<p>While Hyper is recommended for complex HTTP applications, it's quite cumbersome every time to create a handler service, register it, and run it in a runtime. Often, for to build smaller tools such as a CLI application that needs to make a couple of <kbd>GET</kbd> requests, this becomes overkill. Fortunately, we have another opinionated wrapper over hyper called the <kbd>reqwest</kbd> crate. As the name suggests, it is inspired by Python's Requests library. We'll use this to build our hyperurl client that sends URL shorten requests.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">hyper as a client – building a URL shortener client</h1>
                </header>
            
            <article>
                
<p>Now that we have our URL shortener service ready, let's explore the client side of hyper. Although we can build a web UI that we can use for shortening URLs, we'll keep it simple and build a <strong>Command-Line Interface (CLI)</strong> tool. The CLI can be used to pass any URL that needs to be shortened. In response, we'll get back the shortened URL from our hyperurl server.</p>
<p>While hyper is recommended for building complex web applications, a lot of setup is involved every time you need to create a handler service, register it, and run it in a runtime instance. When building smaller tools, such as a CLI application that needs to make a few GET requests, all of these steps become overkill. Fortunately, we have a convenient wrapper crate over hyper called <strong>reqwest</strong> that abstracts hyper's client APIs. As the name suggests, it is inspired by Python's Requests library.</p>
<p>Let's create a new project by running <kbd>cargo new shorten</kbd> with the following dependencies in our <kbd>Cargo.toml</kbd> file:</p>
<pre># shorten/Cargo.toml<br/><br/>[dependencies]<br/>quicli = "0.4"<br/>structopt = "0.2"<br/>reqwest = "0.9"<br/>serde = "1"</pre>
<p>To build the CLI tool, we'll use the <kbd>quicli</kbd> framework, which is a collection of high- quality crates that help build CLI tools. The <kbd>structopt</kbd> crate is used along with <kbd>quicli</kbd>, while the <kbd>serde</kbd> crate is used by the <kbd>structopt</kbd> crate for the derive macro. To make <kbd>POST</kbd> requests to our hyperurl server, we'll use the <kbd>reqwest</kbd> crate.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Our <kbd>main.rs</kbd> has the following code inside it:</p>
<pre class="mce-root">// shorten/src/main.rs<br/><br/>use quicli::prelude::*;<br/>use structopt::StructOpt;<br/><br/>const CONN_ADDR: &amp;str = "127.0.0.1:3002";<br/><br/>/// This is a small CLI tool to shorten urls using the hyperurl<br/>/// url shortening service<br/>#[derive(Debug, StructOpt)]<br/>struct Cli {<br/>    /// The url to shorten<br/>    #[structopt(long = "url", short = "u")]<br/>    url: String,<br/>    // Setting logging for this CLI tool<br/>    #[structopt(flatten)]<br/>    verbosity: Verbosity,<br/>}<br/><br/>fn main() -&gt; CliResult {<br/>    let args = Cli::from_args();<br/>    println!("Shortening: {}", args.url);<br/>    let client = reqwest::Client::new();<br/>    let mut res = client<br/>        .post(&amp;format!("http://{}/shorten", CONN_ADDR))<br/>        .body(args.url)<br/>        .send()?;<br/>    let a: String = res.text().unwrap();<br/>    println!("http://{}", a);<br/>    Ok(())<br/>}</pre>
<p>With our hyperurl server still running, we'll open a new terminal window and invoke shorten with <kbd>cargo run -- --url https://rust-lang.org</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/93a8e603-0cea-4082-81a8-be8d91fec8bc.png" style="width:46.75em;height:4.83em;"/></p>
<p>Let's head over to a browser with the shortened URL, that is, <kbd>http://127.0.0.1:3002/abf27</kbd>:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/548e4c05-76d0-4567-9af3-1952a6c01582.png"/></p>
<p>Having explored hyper, let's get a bit more high level. In the next section, we'll explore Actix-web, a fast web application framework based on the actor model implementation in the <kbd>actix</kbd> crate. But, first let's talk about why we need web frameworks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web frameworks</h1>
                </header>
            
            <article>
                
<p>Before we begin exploring <kbd>actix-web</kbd>, we need to get some motivation as to why we need web frameworks in the first place. The web, as many of us know, is a complex, evolving space. There are lots of details to take care of when writing web applications. You need to set up routing rules and authentication policies. On top of that, as applications evolve, there are best practices and similar patterns that one will have to repeat implementing, if you're not using a web framework.</p>
<p>It's quite tedious having to reinvent these foundational attributes of web applications every time you want to build a web application yourself. A concrete example is when you are providing different routes in your application. In a web application built from scratch, you would have to parse the resource path from the request, do some matching on it, and act on the request. A web framework automates the matching of routes and route handlers by providing DSLs to allow you to configure routing rules in a cleaner way. Web frameworks also abstract all the best practices, common patterns, and idioms around building web applications, and give developers a head start, allowing them to focus on their business logic rather than reinventing solutions for problems that has already been solved.</p>
<p class="mce-root"/>
<p>The Rust community has seen a lot of web frameworks in the works, lately such as Tower, Tide, Rocket, <kbd>actix-web</kbd>, Gotham, and so on. At the time of writing this book, the most feature-rich and active frameworks are Rocket and <kbd>actix-web</kbd>. While Rocket is quite concise and a polished framework, it requires a nightly version of the Rust compiler. This restriction will soon be removed, though, as the APIs that Rocket depends on get stabilized. Its direct competitor at the moment is <kbd>actix-web</kbd>, which runs on stable Rust and is quite close to the ergonomics that are provided by the Rocket framework. We will be covering <kbd>actix-web</kbd> next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Actix-web basics</h1>
                </header>
            
            <article>
                
<p>The Actix-web framework builds upon the actor model that's implemented by the actix crate, which we already covered in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts</em>. Actix-web advertises itself as a small, fast, and pragmatic HTTP web framework. It's primarily an asynchronous framework that relies internally on tokio and the futures crate but also provides a synchronous API and both of these APIs can be composed together seamlessly.</p>
<p>The entry point of any web application written using <kbd>actix-web</kbd> is the <kbd>App</kbd> struct. On an <kbd>App</kbd> instance, we can configure various route handlers and middlewares. We can also initialize our <kbd>App</kbd> with any state that we need to maintain across a request response. The route handlers that are provided on <kbd>App</kbd> implement the <kbd>Handler</kbd> trait and are simply functions that map a request to a response. They can also include request filters, which can forbid access to a particular route based on a predicate.</p>
<p>Actix-web internally spawns a number of worker threads, each with its own tokio runtime. </p>
<p>That's the basics out of the way, so let's dive right in, and go through the implementation of a REST API server using Actix-web.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a bookmarks API using Actix-web</h1>
                </header>
            
            <article>
                
<p>We'll create a REST API server that allows you to store bookmarks and links to any blog or website that you wish to read later. We'll name our server <kbd>linksnap</kbd><strong>.</strong> Let's create a new project by running <kbd>cargo new linksnap</kbd>. In this implementation, we won't be using a database for persistence for any link that is sent to our API, and will simply use an in-memory <kbd>HashMap</kbd> to store our entries. This means that every time our server restarts, all of the stored bookmarks will get removed. In <a href="059e4aef-2091-490e-9358-2b8dd620c1f0.xhtml">Chapter 14</a>, <em>Interacting with Databases in Rust</em>, we'll integrate a database with <kbd>linksnap</kbd>, which will allow us to persist bookmarks.</p>
<p class="mce-root"/>
<p>Under the <kbd>linksnap/</kbd> directory, we have the following contents in <kbd>Cargo.toml</kbd>:</p>
<pre># linksnap/Cargo.toml<br/><br/>[dependencies]<br/>actix = "0.7"<br/>actix-web = "0.7"<br/>futures = "0.1"<br/>env_logger = "0.5"<br/>bytes = "0.4"<br/>serde = "1.0.80"<br/>serde_json = "1.0.33"<br/>serde_derive = "1.0.80"<br/>url = "1.7.2"<br/>log = "0.4.6"<br/>chrono = "0.4.6"</pre>
<p>We'll implement the following endpoints in our API server:</p>
<ul>
<li><kbd>/links</kbd> is a <kbd>GET</kbd> method that retrieves a list of all links stored on the server.</li>
<li><kbd>/add</kbd> is a <kbd>POST</kbd> method that stores an entry of the link and returns a type <kbd>LinkId</kbd> as a response. This can be used to remove the link from the server.</li>
<li><kbd>/rm</kbd> is a <kbd>DELETE</kbd> method that removes a link with a given <kbd>LinkId</kbd>.</li>
</ul>
<p>We have divided our server implementation into three modules:</p>
<ul>
<li><kbd>links</kbd>: This module provides the <kbd>Links</kbd> and <kbd>Link</kbd> types, which represent a collection of links and a link, respectively</li>
<li><kbd>route_handlers</kbd>: This module contains all of our route handlers</li>
<li><kbd>state</kbd>: This module contains the implementation of an actor and all the messages it can receive on our <kbd>Db</kbd> struct.</li>
</ul>
<p class="mce-root"/>
<p>An example flow of our app from the user request to the actor goes like this on the <kbd>/links</kbd> endpoint:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2978326f-60f9-403f-899e-390953d59425.png" style="width:53.17em;height:25.33em;"/></p>
<p class="mce-root"/>
<p>Let's go through the implementation, starting by looking at the contents in <kbd>main.rs</kbd>:</p>
<pre>// linksnap/src/main.rs<br/><br/>mod links;<br/>mod route_handlers;<br/>mod state;<br/><br/>use std::env;<br/>use log::info;<br/>use crate::state::State;<br/>use crate::route_handlers::{index, links, add_link, rm_link};<br/>use actix_web::middleware::Logger;<br/>use actix_web::{http, server, App};<br/><br/>fn init_env() {<br/>    env::set_var("RUST_LOG", "linksnap=info");<br/>    env::set_var("RUST_BACKTRACE", "1");<br/>    env_logger::init();<br/>    info!("Starting http server: 127.0.0.1:8080");<br/>}<br/><br/>fn main() {<br/>    init_env();<br/>    let system = actix::System::new("linksnap");<br/>    let state = State::init();<br/><br/>    let web_app = move || {<br/>        App::with_state(state.clone())<br/>            .middleware(Logger::default())<br/>            .route("/", http::Method::GET, index)<br/>            .route("/links", http::Method::GET, links)<br/>            .route("/add", http::Method::POST, add_link)<br/>            .route("/rm", http::Method::DELETE, rm_link)<br/>    };<br/><br/>    server::new(web_app).bind("127.0.0.1:8080").unwrap().start();<br/>    let _ = system.run();<br/>}</pre>
<p>In <kbd>main</kbd>, we first call <kbd>init_env</kbd>, which sets up our environment for getting logs from the server, turns on the <kbd>RUST_BACKTRACE</kbd> variable for printing a detailed trace of any error, and initializes our logger by invoking <kbd>env_logger::init()</kbd>.We then create our System actor which is the parent actor for all actors in the actor model. We then create our server state by calling <kbd>State::init()</kbd> and store it in <kbd>state</kbd>. This encapsulates our in-memory database actor type <kbd>Db</kbd> in <kbd>state.rs</kbd>. We'll go through this later.</p>
<p>We then create our <kbd>App</kbd> instance within a closure by calling <kbd>App::with_state</kbd>, thereby passing in our clone of our application <kbd>state</kbd>. The <kbd>clone</kbd> call on state is important here, as we need to have a single shared state across multiple actix worker threads. Actix-web internally spawns multiple threads with new App instances to handle requests, and each invocation of this state will have its own copy of the application state. If we don't share a reference to a single source of truth, then each <kbd>App</kbd> will have its own copy of the <kbd>HashMap</kbd> entries, which we don't want.</p>
<p>Next, we chain on our <kbd>App</kbd> with the method <kbd>middleware</kbd> by passing in a <kbd>Logger</kbd>. This will log any requests when a client hits one of our provisioned endpoints. We then add a bunch of <kbd>route</kbd> method calls. The <kbd>route</kbd> method takes an <kbd>HTTP</kbd> path as a string, an HTTP method, and a <kbd>handler</kbd> function that maps an <kbd>HttpRequest</kbd> to a <kbd>HttpResponse</kbd>. We'll explore <kbd>handler</kbd> functions later.</p>
<p>With our <kbd>App</kbd> instance configured and stored in <kbd>web_app</kbd>, we pass it to <kbd>server::new()</kbd>, followed by binding it to the address string <kbd>"127.0.0.1:8080"</kbd>. We then call <kbd>start</kbd> to start the app in a new <kbd>Arbiter</kbd> instance, which is simply a new thread. According to actix, an <kbd>Arbiter</kbd> is a thread where actors are run and can access the event loop. Finally, we run our system actor by calling <kbd>system.run()</kbd>. The <kbd>run</kbd> method internally spins up a <kbd>tokio</kbd> runtime and starts all the arbiter threads.</p>
<p class="mce-root"/>
<p>Next, let's look at our route handlers in <kbd>route_handlers.rs</kbd>. This module defines all kinds of routes that are available in our server implementation:</p>
<pre>// linksnap/src/route_handlers.rs<br/><br/>use actix_web::{Error, HttpRequest, HttpResponse};<br/><br/>use crate::state::{AddLink, GetLinks, RmLink};<br/>use crate::State;<br/>use actix_web::AsyncResponder;<br/>use actix_web::FromRequest;<br/>use actix_web::HttpMessage;<br/>use actix_web::Query;<br/>use futures::Future;<br/><br/>type ResponseFuture = Box&lt;Future&lt;Item = HttpResponse, Error = Error&gt;&gt;;<br/><br/>macro_rules! server_err {<br/>    ($msg:expr) =&gt; {<br/>        Err(actix_web::error::ErrorInternalServerError($msg))<br/>    };<br/>}</pre>
<p>First, we have a bunch of imports followed by a couple of helper types defined. <kbd>ResponseFuture</kbd> is a convenient type alias for a boxed <kbd>Future</kbd> which resolves to an <kbd>HttpResponse</kbd>. We then have a helper macro named <kbd>server_err!</kbd>, which returns an <kbd>actix_web::error</kbd> type with the given description. We use this macro as a convenient way to return error whenver any of our client request processing fails.</p>
<p>Next, we have our simplest router handler for handling get requests on the <kbd>/</kbd> endpoint:</p>
<pre>linksnap/src/route_handlers.rs<br/><br/>pub fn index(_req: HttpRequest&lt;State&gt;) -&gt; HttpResponse {<br/>    HttpResponse::from("Welcome to Linksnap API server")<br/>}</pre>
<p>The <kbd>index</kbd> function takes an  <kbd>HttpRequest</kbd> and simply returns a <kbd>HttpResponse</kbd> constructed from a string. The <kbd>HttpRequest</kbd> type can be parameterized over any type. By default, it is a <kbd>()</kbd>. For our route handlers, we have parameterized it over our <kbd>State</kbd> type. This <kbd>State</kbd> encapsulates our in-memory database, which is implemented as an actor. <kbd>State</kbd> is a wrapper over <kbd>Addr&lt;Db&gt;</kbd>, which is an address to our <kbd>Db</kbd> actor.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This is a reference to our in-memory database. We'll use this to send messages to our in-memory database to insert, remove, or get links. We'll explore those APIs later. Let's look at some other handlers that are in the same file:</p>
<pre>// linksnap/src/route_handlers.rs<br/><br/>pub fn add_link(req: HttpRequest&lt;State&gt;) -&gt; ResponseFuture {<br/>    req.json()<br/>        .from_err()<br/>        .and_then(move |link: AddLink| {<br/>            let state = req.state().get();<br/>            state.send(link).from_err().and_then(|e| match e {<br/>                Ok(_) =&gt; Ok(HttpResponse::Ok().finish()),<br/>                Err(_) =&gt; server_err!("Failed to add link"),<br/>            })<br/>        })<br/>        .responder()<br/>}</pre>
<p>Our <kbd>add_link</kbd> function handles <kbd>POST</kbd> requests for adding a link. This handler expects a JSON body of this format:</p>
<pre>{<br/>    title: "Title of the link or bookmark",<br/>    url: "The URL of the link"<br/>}</pre>
<p>In this function, we first get the request body as JSON by calling <kbd>req.json()</kbd>. This returns a future. We then map any error originated from the json method to an actix compatible error using the <kbd>from_err</kbd> method. <span>The <kbd>json</kbd> method can extract typed information from a request's payload, thereby returning a <kbd>JsonBody&lt;T&gt;</kbd> future. This <kbd>T</kbd> is inferred by the next method chain <kbd>and_then</kbd> as <kbd>AddLink</kbd> where we take the parsed value and send it to our <kbd>Db</kbd> actor. Sending a message to our actor can fail, so if this happens, we again match on the returned value. In the case of <kbd>Ok</kbd>, we reply with an empty HTTP response of success, otherwise we fail with our <kbd>server_err!</kbd> macro passing in an error description.</span></p>
<p>Next, we have our <kbd>"/links"</kbd> endpoint:</p>
<pre>// linksnap/src/route_handlers.rs<br/><br/>pub fn links(req: HttpRequest&lt;State&gt;) -&gt; ResponseFuture {<br/>    let state = &amp;req.state().get();<br/>    state<br/>        .send(GetLinks)<br/>        .from_err()<br/>        .and_then(|res| match res {<br/>            Ok(res) =&gt; Ok(HttpResponse::Ok().body(res)),<br/>            Err(_) =&gt; server_err!("Failed to retrieve links"),<br/>        })<br/>        .responder()<br/>}</pre>
<p>The <kbd>links</kbd> handler simply sends a <kbd>GetLinks</kbd> message to the <kbd>Db</kbd> actor and returns the received response before sending it back to the client using the <kbd>body</kbd> method. We then have our <kbd>rm_link</kbd> handler, which is defined as follows:</p>
<pre>// linksnap/src/route_handlers.rs<br/><br/>pub fn rm_link(req: HttpRequest&lt;State&gt;) -&gt; ResponseFuture {<br/>    let params: Query&lt;RmLink&gt; = Query::extract(&amp;req).unwrap();<br/>    let state = &amp;req.state().get();<br/>    state<br/>        .send(RmLink { id: params.id })<br/>        .from_err()<br/>        .and_then(|e| match e {<br/>            Ok(e) =&gt; Ok(HttpResponse::Ok().body(format!("{}", e))),<br/>            Err(_) =&gt; server_err!("Failed to remove link"),<br/>        })<br/>        .responder()<br/>}</pre>
<p>To remove a link, we need to pass the link ID (an <kbd>i32</kbd>) as a query parameter. The <kbd>rm_link</kbd> method extracts the query parameters into a <kbd>RmLink</kbd> type using the convenient <kbd>Query::extract</kbd> method, which takes in the <kbd>HttpRequest</kbd> instance. Next, we get a reference to our <kbd>Db</kbd> actor and send an  <kbd>RmLink</kbd> <span>message </span>to it with the ID. We return the reply as a string by constructing the <kbd>HttpRespnse</kbd> with the <kbd>body</kbd> method.</p>
<p>Here's our <kbd>State</kbd> and <kbd>Db</kbd> types in <kbd>state.rs</kbd>:</p>
<pre>// linksnap/src/state.rs<br/><br/>use actix::Actor;<br/>use actix::SyncContext;<br/>use actix::Message;<br/>use actix::Handler;<br/>use actix_web::{error, Error};<br/>use std::sync::{Arc, Mutex};<br/>use crate::links::Links;<br/>use actix::Addr;<br/>use serde_derive::{Serialize, Deserialize};<br/>use actix::SyncArbiter;<br/><br/>const DB_THREADS: usize = 3;<br/><br/>#[derive(Clone)]<br/>pub struct Db {<br/>    pub inner: Arc&lt;Mutex&lt;Links&gt;&gt;<br/>}<br/><br/>impl Db {<br/>    pub fn new(s: Arc&lt;Mutex&lt;Links&gt;&gt;) -&gt; Db {<br/>        Db { inner: s }<br/>    }<br/>}<br/><br/>impl Actor for Db {<br/>    type Context = SyncContext&lt;Self&gt;;<br/>}<br/><br/>#[derive(Clone)]<br/>pub struct State {<br/>    pub inner: Addr&lt;Db&gt;<br/>}<br/><br/>impl State {<br/>    pub fn init() -&gt; Self {<br/>        let state = Arc::new(Mutex::new(Links::new()));<br/>        let state = SyncArbiter::start(DB_THREADS, move || Db::new(state.clone()));<br/>        let state = State {<br/>            inner: state<br/>        };<br/>        state<br/>    }<br/><br/>    pub fn get(&amp;self) -&gt; &amp;Addr&lt;Db&gt; {<br/>        &amp;self.inner<br/>    }<br/>}</pre>
<p>First, we have set our <kbd>DB_THREADS</kbd> to a value of <kbd>3</kbd> which we have chosen arbitrarily. We'll have a thread pool through which we'll be making requests to the in-memory database. In this case, we could have also used a normal actor, but since we'll be integrating it with our database in <a href="059e4aef-2091-490e-9358-2b8dd620c1f0.xhtml">Chapter 14</a>, <em>Interacting with Databases in Rust</em>, we have chosen the <kbd>SyncArbiter</kbd> thread.</p>
<p class="mce-root"/>
<p>Next, we have the <kbd>Db</kbd> struct definition that wraps the <kbd>Links</kbd> type in a thread safe wrapper of <kbd>Arc&lt;Mutex&lt;Links&gt;</kbd>. We then implement the <kbd>Actor</kbd> trait on it, where in we specify the associated type <kbd>Context</kbd> as <kbd>SyncContext&lt;Self&gt;</kbd>.</p>
<p>We then have a <kbd>State</kbd> struct definition which is a <kbd>Addr&lt;Db&gt;</kbd>, i.e., a handle to an instance of the <kbd>Db</kbd> actor. We also have two methods on State - <kbd>init</kbd> which creates a new <kbd>State</kbd> instance and <kbd>get</kbd> which returns a reference to the handle to the <kbd>Db</kbd> actor.</p>
<p>Next, we have a bunch of message types that will be sent to our <kbd>Db</kbd> actor. Our <kbd>Db</kbd> is an actor and will receive three messages:</p>
<p><strong>GetLinks</strong>: This is sent by the <kbd>/links</kbd> route handler to retrieve all links stored on the server. It is defined as follows:</p>
<pre>// linksnap/src/state.rs<br/><br/>pub struct GetLinks;<br/><br/>impl Message for GetLinks {<br/>    type Result = Result&lt;String, Error&gt;;<br/>}<br/><br/>impl Handler&lt;GetLinks&gt; for Db {<br/>    type Result = Result&lt;String, Error&gt;;<br/>    fn handle(&amp;mut self, _new_link: GetLinks, _: &amp;mut Self::Context) -&gt; Self::Result {<br/>        Ok(self.inner.lock().unwrap().links())<br/>    }<br/>}</pre>
<p>First is the <kbd>GetLinks</kbd> message, which is sent to the <kbd>Db</kbd> actor from the <kbd>/links</kbd> route handler. To make this an actor message, we'll implement the <kbd>Message</kbd> trait for it. The <kbd>Message</kbd> trait defines an associated type <kbd>Result</kbd>, which is the type returned from the handler of the message. Next, we implement the <kbd>Handler</kbd> trait that is parameterized over the message <kbd>GetLinks</kbd> for the <kbd>Db</kbd> actor.</p>
<pre>// linksnap/src/state.rs<br/><br/>pub struct GetLinks;<br/><br/>impl Message for GetLinks {<br/>    type Result = Result&lt;String, Error&gt;;<br/>}<br/><br/>impl Handler&lt;GetLinks&gt; for Db {<br/>    type Result = Result&lt;String, Error&gt;;<br/>    fn handle(&amp;mut self, _new_link: GetLinks, _: &amp;mut Self::Context) -&gt; Self::Result {<br/>        Ok(self.inner.lock().unwrap().links())<br/>    }<br/>}</pre>
<p>We implement the <kbd>Message</kbd> trait for it, which returns the string of all the links as the response.</p>
<p><strong>AddLink</strong>: This is sent by the <kbd>/add</kbd> route handler on any new link that's sent by the client. It is defined as follows:</p>
<pre>// linksnap/src/state.rs<br/><br/>#[derive(Debug, Serialize, Deserialize)]<br/>pub struct AddLink {<br/>    pub title: String,<br/>    pub url: String<br/>}<br/><br/>impl Message for AddLink {<br/>    type Result = Result&lt;(), Error&gt;;<br/>}<br/><br/>impl Handler&lt;AddLink&gt; for Db {<br/>    type Result = Result&lt;(), Error&gt;;<br/><br/>    fn handle(&amp;mut self, new_link: AddLink, _: &amp;mut Self::Context) -&gt; Self::Result {<br/>        let mut db_ref = self.inner.lock().unwrap();<br/>        db_ref.add_link(new_link);<br/>        Ok(())<br/>    }<br/>}</pre>
<p class="mce-root">Th <kbd>AddLink</kbd> type performs a double duty. With the <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> traits implemented, it acts as a type that can be extracted from the incoming json response body in the <kbd>add_link</kbd> route. Second, it also implements the <kbd>Message</kbd> trait, which we can send to our <kbd>Db</kbd> actor.</p>
<p><strong>RmLink</strong>: This is sent by the <kbd>/rm</kbd> route handler. It is defined as follows:</p>
<pre>// linksnap/src/state.rs<br/><br/>#[derive(Serialize, Deserialize)]<br/>pub struct RmLink {<br/>    pub id: LinkId,<br/>}<br/><br/>impl Message for RmLink {<br/>    type Result = Result&lt;usize, Error&gt;;<br/>}<br/><br/>impl Handler&lt;RmLink&gt; for Db {<br/>    type Result = Result&lt;usize, Error&gt;;<br/>    fn handle(&amp;mut self, link: RmLink, _: &amp;mut Self::Context) -&gt; Self::Result {<br/>        let db_ref = self.get_conn()?;<br/>        Link::rm_link(link.id, db_ref.deref())<br/>            .map_err(|_| error::ErrorInternalServerError("Failed to remove links"))<br/>    }<br/>}<br/><br/></pre>
<p>This is the message sent when one wants to remove a link entry. It takes the RmLink message and forwards it</p>
<p>We can insert a link with the following curl command:</p>
<pre><strong>curl --header "Content-Type: application/json" \</strong><br/><strong>  --request POST \ </strong><br/><strong>  --data '{"title":"rust blog","url":"https://rust-lang.org"}' \</strong><br/><strong>  127.0.0.1:8080/add</strong></pre>
<p>To view the inserted links, we can issue:</p>
<pre><strong>curl 127.0.0.1:8080/links</strong></pre>
<p>To remove a link, given its Id, we can send a DELETE request using curl as:</p>
<pre><strong>curl -X DELETE 127.0.0.1:8080/rm?id=1</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored a lot about building web applications with Rust and how easy it is to get started, given the high-quality crates that are available to us. Being a compiled language, web applications written in Rust are many times smaller than other frameworks that are written in dynamic languages. Most of the web framework space is dominated by interpreted dynamic languages that can hog a lot of CPU but aren't very resource-efficient. However, people use them because web applications are very convenient to write with them.</p>
<p>Web applications that are written with Rust take up a lot less space at runtime. Rust also takes up less memory during runtime, as no interpreter is needed, as is the case with dynamic languages. With Rust, you get the best of both worlds, that is, the same feel of dynamic languages while at the same time being performant, like C. This is a great deal for the web.</p>
<p>In the next chapter, we'll explore how Rust can talk to databases and add data persistence to our <kbd>read_list</kbd> server by using a type-safe <strong>Object Relational Mapper (ORM)</strong> library called <strong>diesel</strong><em>.</em></p>


            </article>

            
        </section>
    </body></html>