- en: Matching and Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配和结构
- en: On top of the primitive variables and generics, which we will come to in [Chapter
    9](part0207.html#65D4E0-a5175cb437d742a9aed0ea574000ee2d), *Introducing Generics,
    Impl, and Traits*, Rust is capable of storing groups of different types of variables
    in a `struct` construct that may be familiar to those who have developed in the
    C family of languages. There's also a related concept called **enumerations**
    for creating types with alternating options. If that is not enough, Rust can combine
    these in its powerful pattern-matching code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始变量和泛型的基础上，我们将在第9章[介绍泛型、Impl和Traits](part0207.html#65D4E0-a5175cb437d742a9aed0ea574000ee2d)中介绍，Rust能够将不同类型的变量组合在`struct`结构中，这对于在C系列语言中开发的人来说可能很熟悉。还有一个相关的概念叫做**枚举**，用于创建具有交替选项的类型。如果还不够，Rust还可以通过其强大的模式匹配代码将这些结合在一起。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning how to use and manipulate `struct` data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用和操作`struct`数据类型
- en: Understanding tuples and the **tuple struct** hybrid
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解元组和**元组结构体**混合体
- en: Creating and using enums
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用枚举
- en: Understanding and applying the basics of patterns and matching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和应用模式匹配的基础
- en: Structs 101
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体101
- en: For this chapter, I am going to ask you to imagine the following scenario. I
    have a house. My house has a certain number of rooms and each room has a name.
    Each room has one or more doors and windows and a carpet (with a color), and the
    rooms have a width and length. We will use structs and enums to model all this.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我将要求你想象以下场景。我有一所房子。我的房子有一定数量的房间，每个房间都有一个名字。每个房间有一扇或多扇门和窗户，以及一块地毯（有颜色），房间有宽度和长度。我们将使用结构体和枚举来模拟所有这些。
- en: Structs in Rust are very common; they are used in many facets of the language
    and are useful to understand and use. In terms of the house example, we'll see
    how useful they can be.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的结构体非常常见；它们在语言的许多方面都有应用，理解和使用它们是有用的。在房子示例中，我们将看到它们有多么有用。
- en: Variables, variables everywhere
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量，无处不在的变量
- en: 'Let''s look at the house and create some variables to describe it, as well
    as types. Start with the house, which can be considered the most basic of objects.
    We will need only to model the number of rooms it has:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看房子，并创建一些变量来描述它以及类型。从房子开始，它可以被认为是最基本的对象。我们只需要模拟它有多少个房间：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's consider rooms next.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来考虑房间。
- en: Each room will have a number of properties. Is it upstairs or downstairs, assuming
    it's a two-level house? Number of doors. Number of windows. Types of windows.
    Do the window have curtains? Wood or carpet floor covering? Color of the carpet.
    Room name. Does it have a wardrobe/closet? Room width. Room length. You can go
    deeper than that, but this will do for now.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个房间将有一些属性。假设它是一个两层楼的房子，它是楼上还是楼下？门的数量。窗户的数量。窗户的类型。窗户有窗帘吗？木地板或地毯覆盖？地毯的颜色。房间名称。是否有衣柜/壁橱？房间宽度。房间长度。你可以做得更深入，但这对现在来说已经足够了。
- en: 'As variables, these will be as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为变量，它们如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is no reason why you can't define these as discrete variables; however,
    as they are properties that describe a feature within the house or room, why not
    group them as we already have? This is where a `struct` type comes in useful.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由你不能将这些定义为离散变量；然而，由于它们是描述房子或房间内特征的属性，为什么不按我们已有的方式将它们分组呢？这就是`struct`类型发挥作用的地方。
- en: The structure of a struct
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体的结构
- en: 'A `struct` type consists of three parts: the keyword `struct`, the `struct`
    name, and the variables it holds. Let''s consider the following command as an
    example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 类型由三个部分组成：关键字 `struct`、`struct` 名称以及它所包含的变量。以下命令作为例子：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is important to note that, unlike normal variable definitions, a comma follows
    directly after the variable type and not a semicolon.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，与常规变量定义不同，变量类型后面直接跟逗号，而不是分号。
- en: 'For our example, we can define two `struct` types, one for the room and one
    for the house, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，我们可以定义两个`struct`类型，一个用于房间，一个用于房子，如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our house will therefore be as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的房子如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A `struct`, while a special type of variable, is still a variable, and as such
    as a type; a `struct`. We can therefore assign it the same way as we can any other
    variable type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`struct`是一种特殊的变量类型，但它仍然是一种变量，并且作为类型；一个`struct`。因此，我们可以像对任何其他变量类型一样分配它：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is fine if we have a house with a single room! We can define an array
    of rooms, but then that means we will have a fixed number of rooms. Instead, we
    will define it as the type used within a vector:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个只有一个房间的房子，这没问题！我们可以定义一个房间数组，但这意味着我们将有固定数量的房间。相反，我们将将其定义为向量中使用的类型：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We created two special types of variable that we can declare and access as we
    would with any other variable. If we look at the room definition, we can break
    the structure down further; but why would we want to do that?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两种特殊的变量类型，我们可以像声明和访问任何其他变量一样声明和访问它们。如果我们查看房间定义，我们可以进一步分解结构；但为什么我们要这样做呢？
- en: Smaller is better
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小的更好
- en: There is an argument that the smaller you make the parent structure, the easier
    it becomes to manage. This is true, but let's look at it in a different way. As
    it stands, we have a couple of what can be described as objects in their own right
    within that structure. Here, an object is something that will have its own properties.
    Let's look at the window.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个论点是，你使父结构越小，管理起来就越容易。这是真的，但让我们从不同的角度来看。就目前而言，我们在这个结构中有几个可以被视为独立对象的元素。在这里，一个对象是具有其自身属性的东西。让我们看看窗户。
- en: A window has a size—width and height; it has a type—sash, for instance; it has
    blinds or curtains, and the blinds/curtains have a color. The window may also
    have a lock. It may also be a single or double window and the opening may be at
    the top or side.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 窗户有一个大小——宽度和高度；它有一个类型——例如，窗扇；它有百叶窗或窗帘，百叶窗/窗帘有颜色。窗户还可能有锁。它可能是一扇单窗或双窗，开启位置可能在顶部或侧面。
- en: There is also no reason why there should only be a single window. If there is
    more than one window, then we will need to define our window multiple times. Therefore,
    it makes more sense to define our window and reference that back as a vector in
    the main structure.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由说只能有一个窗户。如果有多个窗户，那么我们需要多次定义我们的窗户。因此，定义我们的窗户并在主结构中将其作为向量引用更有意义。
- en: Before that, though, we said the window will have a size (width, length). Each
    room will have a size and, probably, so will many other things within the house;
    therefore, we will remove the size and have that as its own `struct`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之前，我们说过窗户将有大小（宽度，长度）。每个房间都将有大小，而且房子里的许多其他东西可能也是如此；因此，我们将移除大小，将其作为一个单独的`struct`。
- en: 'Therefore, we have this following `struct` for the window:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们为窗户定义了以下`struct`：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This, back in the parent `struct`, will transform into the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这在父`struct`中将转换为以下内容：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can carry on doing this for anything else in the room, including a `struct`
    variable for furniture, as well as possibly reducing the size for carpet—what
    you do with it is up to you. For now, we'll keep it at this level.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为房间中的任何其他东西继续这样做，包括家具的`struct`变量，以及可能减少地毯的大小——你如何处理它取决于你。现在，我们将保持在这个级别。
- en: Accessing a struct
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问`struct`
- en: 'In order to access a `struct` variable, we will need to create a variable that
    can access it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问`struct`变量，我们需要创建一个可以访问它的变量：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code for this section is in the `07/simplestruct` folder in the supporting
    code bundle of this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码位于本书支持代码包的`07/simplestruct`文件夹中。
- en: We have not defined all of the variables within that structure, which, for now,
    is fine, as they still need to be defined before the code will compile. The variable
    is mutable since we want to change its contents later.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有定义该结构中的所有变量，目前这没关系，因为它们仍然需要在代码编译前定义。这个变量是可变的，因为我们想稍后更改其内容。
- en: 'To access one of the members of the `struct`, we will use the dot notation.
    In this case, we can have the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`struct`的一个成员，我们将使用点符号。在这种情况下，我们可以有如下内容：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Defining the child structures
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义子`struct`
- en: 'We have two types of `struct`—parent and child. Here, the `struct` of `Room`
    is the parent and it has two children: the window definition and room size. They
    are very different beasts as the window definition is a `Vec` type, while the
    other is just a `struct` type.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种类型的`struct`——父`struct`和子`struct`。在这里，`Room`的`struct`是父`struct`，它有两个子`struct`：窗户定义和房间大小。它们非常不同，因为窗户定义是一个`Vec`类型，而另一个只是一个`struct`类型。
- en: 'For the room area, we can use the following when creating an instance of the
    room type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于房间面积，在创建房间类型的实例时，我们可以使用以下内容：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We are defining `room_area`, for which we will then define an inline variable
    which will act as the pointer to the area structure and, finally, create the size
    of the room. This is accessed using the following code snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义`room_area`，然后我们将定义一个内联变量，它将作为指向面积结构体的指针，最后创建房间的尺寸。这是通过以下代码片段来访问的：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, we have to define the vector of Windows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须定义窗口的向量。
- en: 'This is done in a very similar way to how we define any other vector, which
    is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以与我们定义任何其他向量非常相似的方式完成的，如下所示：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will then add a few more `println!` lines to show we have some data:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加几行`println!`来展示我们有一些数据：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When compiled, the code produces the following result:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时，代码会产生以下结果：
- en: '![](img/00049.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00049.jpeg)'
- en: We have very quickly, and simply, created a multi-level structure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常快速且简单地创建了一个多级结构。
- en: Multi-file version
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多文件版本
- en: If you look at the source code in the `simplestruct` file, you'll find the structures
    at the start with the code under it. There is nothing wrong with that, but after
    a while, it becomes cumbersome, especially if we have a lot of structures and
    enumerations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`simplestruct`文件中的源代码，你会发现结构体在开始处，下面跟着相应的代码。这并没有什么问题，但过了一段时间，它就会变得繁琐，尤其是如果我们有很多结构和枚举时。
- en: To remove this problem, we can split the structures and code over two files.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以将结构和代码分散在两个文件中。
- en: 'However, before we build the code, we will have to provide the `main.rs` file
    with some sort of pointer to the structures. We can do this in one of three ways.
    The simplest is to use the `include!` macro:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们构建代码之前，我们必须向`main.rs`文件提供某种指向结构的指针。我们可以通过以下三种方式之一来实现。最简单的是使用`include!`宏：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The source for this section is in the `Chapter 7/multifile` folder, present
    in the supporting code bundle provided for this book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的内容来源位于`Chapter 7/multifile`文件夹中，该文件夹包含在此书提供的配套代码包中。
- en: This just inserts the contents of the file in the place of the macro call, so
    it's not the most elegant way and completely sidesteps Rust's module system. So
    let's look at a better way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将文件内容插入到宏调用的位置，因此这不是最优雅的方式，并且完全绕过了Rust的模块系统。所以让我们看看更好的方法。
- en: 'The better way is to reference the module using the following snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用以下代码片段来引用模块：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This can lead to a large number of issues, the biggest being the protection
    level, `public` or `private`. When compiled like this, many errors, such as the
    following example, occur:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致大量问题，最大的问题是保护级别，`public`或`private`。按照这种方式编译时，会出现许多错误，例如以下示例所示：
- en: '![](img/00050.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00050.jpeg)'
- en: The error will indicate that, though the structure is `public`, the fields within
    it aren't, so they can't be accessed. The solution is to make all of the fields
    `public`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 错误将指示，尽管结构体是`public`的，但其中的字段不是，因此无法访问。解决方案是将所有字段设置为`public`。
- en: Private versus public fields
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有与公共字段
- en: 'By default, all fields within a `struct` are `private` to the module it is
    created in. This has its uses; for example, if you want to protect a value within
    the `struct`, you can make it only accessible via a `read`/`write` function, as
    shown in the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，结构体中的所有字段对其创建的模块都是`private`的。这有其用途；例如，如果你想保护结构体中的某个值，你可以通过`read`/`write`函数使其仅可通过，如下例所示：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code for this section is in the `07/readwrite` folder, present in the supporting
    code bundle provided for this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的相关代码位于`07/readwrite`文件夹中，该文件夹包含在此书提供的配套代码包中。
- en: 'When we build and run this, we will get the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建并运行这个程序时，我们会得到以下输出：
- en: '![](img/00051.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00051.jpeg)'
- en: Structs 102
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体 102
- en: 'While we have defined our own structs, we also have access to a structure known
    as a unit-like `struct`. Unlike our own structs, we can see the likes of the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经定义了自己的结构体，但我们也可以访问一种称为单元结构体`struct`的结构。与我们的结构体不同，我们可以看到以下内容：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: They have nothing after them—no fields defined. These are not the same as the
    ones we defined, so how do they work?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它们后面没有任何内容——没有定义字段。这些与我们所定义的不同，那么它们是如何工作的呢？
- en: To understand how they work, we need to understand a tuple `struct` and, in
    order to understand those, we need to know what a tuple is.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解它们是如何工作的，我们需要了解元组结构体`struct`，为了理解这些，我们需要知道什么是元组。
- en: Tuples
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'Here are two ways to initialize a tuple:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化元组有两种方式：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On the first line, we let local type inference work and just declare what is
    inside the tuple. Rust will figure out the types. On the second line, we declare
    the types explicitly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们让局部类型推断工作，只声明元组内的内容。Rust 会找出类型。在第二行，我们显式声明类型。
- en: We can have as many (or as few) elements in the list as they are, in fact, an
    ordered list of a fixed size.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的元素可以有（或没有）多少，实际上，它们是一个固定大小的有序列表。
- en: 'As with other variable types, we can assign one tuple to equal another as long
    as they contain the same types and number of parameters (arity). For example,
    the following have the same types and arity and so can be used to assign to each
    other:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他变量类型一样，只要它们包含相同类型和参数数量（arity），我们就可以将一个元组赋值给另一个。例如，以下具有相同的类型和arity，因此可以相互赋值：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following wouldn''t be allowed as the types don''t match, even though the
    arity does:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不允许的，因为类型不匹配，尽管arity相同：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using a tuple to define a variable
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元组定义变量
- en: 'Let''s consider the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下内容：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We created a variable called `test` that has the value `1` of type `i32` bound
    to it (binding was discussed in [Chapter 5](part0106.html#352RK0-a5175cb437d742a9aed0ea574000ee2d),
    *Remember, Remember*). How can we do something similar with a tuple? So far, we''ve
    done the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `test` 的变量，该变量绑定了一个类型为 `i32` 的值为 `1`（绑定在[第5章](part0106.html#352RK0-a5175cb437d742a9aed0ea574000ee2d)，*记住，记住*）的变量。我们如何用元组做类似的事情？到目前为止，我们已经做了以下事情：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We bound `test` to a tuple containing two values: `(i32, f32)`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `test` 绑定到一个包含两个值的元组上：`(i32, f32)`。
- en: Tuple indexing
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组索引
- en: 'To get at the `f32` value, we will have to use tuple indexing. This is very
    similar to indexing an array, but we replace the following snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 `f32` 值，我们必须使用元组索引。这与索引数组非常相似，但我们替换以下片段：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We use the following snippet instead:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下片段代替：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As with array indexes, the tuple indexes range from `0` to `n-1`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组索引一样，元组索引的范围从 `0` 到 `n-1`。
- en: Destructuring with let
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 let 进行解构
- en: 'To avoid using a tuple index, Rust has a way to destructure a tuple. This is
    very similar to a normal `let` statement, except we will define multiple variable
    names at once:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用元组索引，Rust 有一种解构元组的方法。这与正常的 `let` 语句非常相似，但我们将一次定义多个变量名称：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If there are the same number of names on the left as there are arguments on
    the right, Rust will break these up internally to create three bindings at once.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左侧的名称数量与右侧的参数数量相同，Rust 将内部拆分这些名称以一次创建三个绑定。
- en: 'We now have three bindings and can access them as we would any other variable:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有三个绑定，可以像访问任何其他变量一样访问它们：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tuple structs – the hybrid of two
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组结构体 – 两种的结合
- en: 'Consider a `struct` with three fields. It will have a name for the `struct`
    type and the three fields with their types:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个有三个字段的 `struct`。它将有一个 `struct` 类型的名称和三个带有其类型的字段：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s consider what this actually is and if we can we not rewrite this as
    follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这实际上是什么，以及我们是否可以将其重写如下：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Well, we can, but we will now run into how to access the members of the tuple.
    We will also run into assigning one tuple to another. You can't really define
    two structs, which are identical in everything other than the `struct` type name,
    and then assign the second `struct` type to the first.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们可以，但现在我们会遇到如何访问元组成员的问题。我们还会遇到将一个元组赋值给另一个元组的问题。实际上，你不能定义两个结构体，除了 `struct`
    类型名称外，其他一切相同，然后将第二个 `struct` 类型赋值给第一个。
- en: 'To get around this, Rust has the tuple `struct` hybrid. It contains the `struct`
    type but then assigns the fields as a tuple:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Rust 有元组 `struct` 混合体。它包含 `struct` 类型，然后将字段作为元组分配：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We now have the flexibility of a tuple, but with the protection of the `struct`.
    Despite the arity being the same and the types inside the struct being the same,
    they are different types.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了元组的灵活性，但又有 `struct` 的保护。尽管arity相同，结构体内部的类型也相同，但它们是不同的类型。
- en: 'As with a regular tuple, we can access the members of the tuple `struct` in
    the same way:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规元组一样，我们可以以相同的方式访问元组 `struct` 的成员：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The single element tuple struct
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元素元组结构体
- en: 'At this point, you''re probably wondering whether there are any uses for a
    tuple `struct` over a standard `struct`. One of the uses is when the tuple `struct`
    has a single element. Here, we are able to create a variable based on the tuple.
    It''s similar to a destructured tuple in appearance:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道元组 `struct` 与标准 `struct` 相比有什么用途。其中一个用途是当元组 `struct` 只有一个元素时。在这里，我们能够根据元组创建一个变量。它的外观类似于解构的元组：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The source for this section is in the `07/newtype` folder, present in the supporting
    code bundle provided for this book.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本节源代码位于 `07/newtype` 文件夹中，该文件夹包含本书提供的配套代码包。
- en: 'This produces the following output when compiled and run:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行后，它会产生以下输出：
- en: '![](img/00052.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: This form of assignment is known as a new type pattern; it has allowed the creation
    of a new type distinct from the contained value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的赋值称为新类型模式；它允许创建一个与包含值不同的新类型。
- en: Back to the unit-like struct
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到类似单元的 struct
- en: Now that we have an understanding of tuples and the tuple `struct`, we can now
    look at the unit-like `struct`. This can be considered to be a `struct` with an
    empty tuple and as with a tuple `struct`, it defines a new type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了元组和元组 `struct`，我们现在可以看看类似单元的 `struct`。这可以被认为是一个具有空元组的 `struct`，并且与元组
    `struct` 一样，它定义了一个新类型。
- en: Typically, we will use this in conjunction with a trait or if you don't have
    any data to store in it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将它与特质一起使用，或者如果你没有数据要存储在其中。
- en: Enumerations
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'If are you are used to C, you will be well used to enumerations, for example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了 C 语言，你将很熟悉枚举，例如：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This creates an `enum` type that auto-fills `next` and `nextone` to be start
    `+ 1` and start `+ 2` respectively. If the first named parameter has nothing to
    give an initial value to, it is given the value `0` with everything after it being
    one larger than the last. They are accessed as `myEnum.nextone`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个自动填充 `next` 和 `nextone` 为起始值 `+ 1` 和 `+ 2` 的 `enum` 类型。如果第一个命名参数没有提供初始值，它将被赋予
    `0` 的值，并且所有后续的值都比上一个值大 1。它们可以通过 `myEnum.nextone` 访问。
- en: 'An `enum` type in Rust has a very similar structure to a `struct` type, as
    shown in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的 `enum` 类型结构与 `struct` 类型结构非常相似，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As with C though, an `enum` is a single type, but the value of the `enum` can
    match any of its members.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与 C 语言一样，`enum` 是一个单一类型，但 `enum` 的值可以匹配其任何成员。
- en: Accessing enumeration members
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问枚举成员
- en: 'Given the possibility of the contents of a Rust `enum`, you may be thinking
    that accessing one of the members within the enumeration may not be the simplest
    of tasks. Thankfully, it is, as an `enum` variable is sometimes referred to as
    a *scopable* variable. For example, if we wanted to access members, we could use
    the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Rust `enum` 的内容可能性，你可能认为在枚举中访问一个成员可能不是最简单的任务。幸运的是，它确实如此，因为 `enum` 变量有时被称为
    *可作用域* 变量。例如，如果我们想访问成员，我们可以使用以下方法：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The code for this section is in the `07/enumscope` folder, present in the supporting
    code bundle provided for this book.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码位于 `07/enumscope` 文件夹中，该文件夹包含本书提供的配套代码包。
- en: 'The variables, `value1` and `value2`, are scoped (uses `::`) to `MyFirstEnum`
    and `MySecondEnum` respectively. When compiled, we will see the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `value1` 和 `value2` 分别作用域于 `MyFirstEnum` 和 `MySecondEnum`。当编译时，我们将看到以下输出：
- en: '![](img/00053.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: The two questions you should be asking
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该问的两个问题
- en: The code is a bit of head-scratcher. Surely we should have been able to use
    something similar to the following code?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有点让人挠头。我们当然应该能够使用类似以下代码的东西？
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And then use `value.2` to obtain the string part directly within the `println!`
    statement, instead of the `if let` construct?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `value.2` 在 `println!` 语句中直接获取字符串部分，而不是使用 `if let` 构造？
- en: The reason why we can't is that `enum` variants aren't their own type, so as
    soon as we create the preceding value, above it is immediately lost.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能这样做的原因是 `enum` 变体不是它们自己的类型，所以一旦我们创建了前面的值，上面的值就会立即丢失。
- en: 'The second question should be: What is the `if let` construct?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是：`if let` 构造是什么？
- en: In Rust, `if let` is used as a way to perform certain types of pattern-matching.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，`if let` 被用作执行某些类型模式匹配的一种方式。
- en: Patterns and matching
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和匹配
- en: Rust, as we have seen, contains many very powerful facilities. We will now consider
    two that are often seen, and then double back to examine how we can use the `if
    let` construct.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Rust 包含许多非常强大的功能。我们现在将考虑两个经常看到的，然后回过头来检查我们如何使用 `if let` 构造。
- en: Matching
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配
- en: 'Let''s look at a very unpleasant code block and then examine what it means:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常不愉快的代码块，然后分析它的含义：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code takes an `i32` parameter and tests to see what it equals. If the condition
    is met, some text is returned for that number; otherwise, `"not found"` is returned.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码接受一个 `i32` 参数并测试它等于什么。如果条件满足，将返回该数字的一些文本；否则，返回 `"not found"`。
- en: This is a trivial example, but imagine if you're testing against 10 different
    conditions; the `if-else` construct will become ugly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但想象一下如果你正在测试 10 个不同的条件；`if-else` 构造将变得很丑陋。
- en: 'If we were in C, we could use `switch`/`case` and Rust can also do something
    similar, but the keyword is `match` instead. If we used the `match` expression,
    our function would be as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 C 中，我们可以使用 `switch`/`case`，Rust 也可以做类似的事情，但关键字是 `match`。如果我们使用 `match`
    表达式，我们的函数将如下所示：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this instance, when `x` is matched to the value inside of the `match` expression,
    `t` is assigned. If it is not matched (`_ = > ...`), then `t` is set to be `not
    found`. There must be a `_` wildcard pattern case within the `match`. This is
    down to Rust enforcing exhaustiveness checking. In other words, until the `_`
    wildcard is reached, Rust assumes that there must be other values to attempt to
    match.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当 `x` 与 `match` 表达式内的值匹配时，`t` 被赋值。如果没有匹配（`_ => ...`），则 `t` 被设置为 `未找到`。`match`
    中必须有一个 `_` 通配符模式情况。这是由于 Rust 强制执行详尽性检查。换句话说，直到遇到 `_` 通配符之前，Rust 假设必须还有其他值尝试匹配。
- en: Let's really make the function simple
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们真正使函数简单
- en: While the preceding example is fairly compact, we can further reduce the footprint
    of the code by using `match` as an expression.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子相当紧凑，但我们可以通过将 `match` 用作表达式来进一步减少代码的足迹。
- en: 'If you''re used to `?` in C#, you will be familiar with a construct such as
    the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了 C# 中的 `?`，你将熟悉以下构造：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This means that we can assign `t` to be `three` if `SomeCondition == 3` else
    `if``SomeCondition == 4`, `t = four`. If this falls through, we can set `t` as
    `not three or four`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将 `t` 赋值为 `three`，如果 `SomeCondition == 3`，否则 `if SomeCondition == 4`，`t
    = four`。如果这会传递，我们可以将 `t` 设置为 `not three or four`。
- en: It can get messy. Rust can do the same, only far more cleanly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会变得混乱。Rust 可以做到同样的事情，但更加干净利落。
- en: 'In the origin code, we had the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始代码中，我们有以下内容：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can use `match` as an expression to set the value to be returned:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `match` 用作表达式来设置要返回的值：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or, more simply, by just returning the result of the match:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更简单地说，只需返回 match 的结果：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or even more simply, when we remember that, in Rust, a block returns the result
    of its last expression when we omit the `;`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简单地说，当我们记住在 Rust 中，如果一个块没有使用 `;`，它会返回其最后一个表达式的结果：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using match with an enum
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用枚举与 match
- en: 'We have already seen in this chapter how enums can be somewhat tricky to handle.
    Thankfully, we can use `match` on an `enum`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经看到，枚举有时很难处理。幸运的是，我们可以在枚举上使用 `match`：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You will notice that in this example, `_` is not included. That''s because
    we explicitly match against all the possible choices of the enum, so we don''t
    need a catch-all case. If, for instance, we missed `NewTypeTuple`, the code would
    need to include a catch-all:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在这个例子中，没有包含 `_`。这是因为我们明确地匹配了枚举的所有可能选择，所以不需要一个通配符情况。例如，如果我们遗漏了 `NewTypeTuple`，代码将需要包含一个通配符：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Ignoring a parameter with match
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 match 忽略参数
- en: 'It is entirely possible to ignore a parameter within a `match` construct. Take
    the following `struct`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `match` 构造中忽略参数是完全可能的。以下是一个 `struct` 的例子：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can use this `struct` within a `match` construct as we can any other type.
    However, we want to ignore anything after `real_answer`. To do this, we will use
    the `..` operator. Our match will look like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `match` 构造中使用这个 `struct`，就像使用任何其他类型一样。然而，我们想要忽略 `real_answer` 之后的任何内容。为此，我们将使用
    `..` 操作符。我们的 `match` 将看起来像这样：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can also use `_` as a parameter (we expect a value, but we don''t care what
    it is):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将 `_` 用作参数（我们期望一个值，但我们不在乎它是什么）：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can appreciate that the `match` construct is powerful, but let's see it
    in action with patterns.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以欣赏到 `match` 构造的强大功能，但让我们通过模式来看看它的实际应用。
- en: Fall through patterns
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递模式
- en: 'Let''s say that we want to have a fall through construct in the same way as
    we would have in C:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在 C 中以相同的方式有一个传递构造：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can do this in Rust using the `|` pattern, which is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Rust 中使用 `|` 模式来做这件事，如下所示：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Ranges
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: 'In a similar way to using `|`, we can match on a range of values, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于使用 `|`，我们可以在一系列值上匹配，如下所示：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can use something similar with `char`, as shown in the following example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方式与 `char` 一起使用，如下面的例子所示：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Creating a binding within a match pattern
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 match 模式中创建绑定
- en: 'Sometimes, it is very useful to create a temporary variable within a `match`
    construct and bind the result of the pattern to it. This is performed using `@`,
    as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在`match`构造中创建一个临时变量非常有用，并将模式的结果绑定到它。这可以通过使用`@`来完成，如下所示：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This attempts to match the pattern `1` to `10` to the value of `test`. If it
    is a match, the value is bound to `t`, which we can then manipulate as we would
    any other variable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这尝试将模式`1`到`10`与`test`的值进行匹配。如果匹配成功，值将被绑定到`t`，然后我们可以像处理任何其他变量一样对其进行操作。
- en: 'We can also bind to the variable with a fall through construct as done in the
    following example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用类似于以下示例中的fall through构造来绑定到变量：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Let's add an if into the mix
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们在其中加入一个if语句
- en: 'We can include an `if` statement within a `match` pattern, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`match`模式中包含一个`if`语句，如下所示：
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Using match with a compound type
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用复合类型与match结合
- en: A compound type is a type that contains many different types—a `struct` is possibly
    the simplest example here. The following also applies to enums and tuples.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 复合类型是一种包含许多不同类型的类型——在这里，`struct`可能是最简单的例子。以下也适用于枚举和元组。
- en: 'We can match on a `struct` pattern the same way we can match on any other type
    of pattern, which is shown in the following example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`struct`模式匹配，就像我们可以匹配任何其他类型的模式一样，以下是一个示例：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As described in the matching section, we can ignore parameters in the `struct`
    pattern match using `..`, or just throw them away using `_`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如匹配部分所述，我们可以使用`..`在`struct`模式匹配中忽略参数，或者简单地使用`_`丢弃它们。
- en: And back to if let
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 然后回到if let
- en: You have probably realized now that `if let` is, in actuality, a `match` construct
    that is just written in a slightly different way.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经意识到，实际上`if let`是一个以稍微不同的方式编写的`match`构造。
- en: 'A `match` construct is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`构造如下：'
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `if let` version would be as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`if let`版本如下：'
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how Rust deals with some fairly complex types that allow
    us to create a type which contains many different types, and how handling these
    compound types can be a mostly painless affair. We have also drawn attention to
    pitfalls when using enums.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Rust如何处理一些相当复杂的数据类型，这些数据类型允许我们创建包含许多不同类型的类型，以及处理这些复合类型通常可以是一个相对无痛的过程。我们还注意到了使用枚举时的陷阱。
- en: We have examined the structured and flexible approach Rust takes to patterns
    and matching and the power that simplicity provides to developers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了Rust对模式和匹配的结构化和灵活方法，以及简单性为开发者提供的强大功能。
- en: In the next chapter, we will be looking at something that takes a fair bit of
    practice to understand and even more to get right—the Rust lifetime system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些需要相当多的实践才能理解，甚至更难正确处理的内容——Rust的生命周期系统。
