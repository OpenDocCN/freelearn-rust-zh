- en: Matching and Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On top of the primitive variables and generics, which we will come to in [Chapter
    9](part0207.html#65D4E0-a5175cb437d742a9aed0ea574000ee2d), *Introducing Generics,
    Impl, and Traits*, Rust is capable of storing groups of different types of variables
    in a `struct` construct that may be familiar to those who have developed in the
    C family of languages. There's also a related concept called **enumerations**
    for creating types with alternating options. If that is not enough, Rust can combine
    these in its powerful pattern-matching code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to use and manipulate `struct` data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding tuples and the **tuple struct** hybrid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and applying the basics of patterns and matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, I am going to ask you to imagine the following scenario. I
    have a house. My house has a certain number of rooms and each room has a name.
    Each room has one or more doors and windows and a carpet (with a color), and the
    rooms have a width and length. We will use structs and enums to model all this.
  prefs: []
  type: TYPE_NORMAL
- en: Structs in Rust are very common; they are used in many facets of the language
    and are useful to understand and use. In terms of the house example, we'll see
    how useful they can be.
  prefs: []
  type: TYPE_NORMAL
- en: Variables, variables everywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the house and create some variables to describe it, as well
    as types. Start with the house, which can be considered the most basic of objects.
    We will need only to model the number of rooms it has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's consider rooms next.
  prefs: []
  type: TYPE_NORMAL
- en: Each room will have a number of properties. Is it upstairs or downstairs, assuming
    it's a two-level house? Number of doors. Number of windows. Types of windows.
    Do the window have curtains? Wood or carpet floor covering? Color of the carpet.
    Room name. Does it have a wardrobe/closet? Room width. Room length. You can go
    deeper than that, but this will do for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'As variables, these will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is no reason why you can't define these as discrete variables; however,
    as they are properties that describe a feature within the house or room, why not
    group them as we already have? This is where a `struct` type comes in useful.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `struct` type consists of three parts: the keyword `struct`, the `struct`
    name, and the variables it holds. Let''s consider the following command as an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that, unlike normal variable definitions, a comma follows
    directly after the variable type and not a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we can define two `struct` types, one for the room and one
    for the house, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our house will therefore be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A `struct`, while a special type of variable, is still a variable, and as such
    as a type; a `struct`. We can therefore assign it the same way as we can any other
    variable type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fine if we have a house with a single room! We can define an array
    of rooms, but then that means we will have a fixed number of rooms. Instead, we
    will define it as the type used within a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We created two special types of variable that we can declare and access as we
    would with any other variable. If we look at the room definition, we can break
    the structure down further; but why would we want to do that?
  prefs: []
  type: TYPE_NORMAL
- en: Smaller is better
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an argument that the smaller you make the parent structure, the easier
    it becomes to manage. This is true, but let's look at it in a different way. As
    it stands, we have a couple of what can be described as objects in their own right
    within that structure. Here, an object is something that will have its own properties.
    Let's look at the window.
  prefs: []
  type: TYPE_NORMAL
- en: A window has a size—width and height; it has a type—sash, for instance; it has
    blinds or curtains, and the blinds/curtains have a color. The window may also
    have a lock. It may also be a single or double window and the opening may be at
    the top or side.
  prefs: []
  type: TYPE_NORMAL
- en: There is also no reason why there should only be a single window. If there is
    more than one window, then we will need to define our window multiple times. Therefore,
    it makes more sense to define our window and reference that back as a vector in
    the main structure.
  prefs: []
  type: TYPE_NORMAL
- en: Before that, though, we said the window will have a size (width, length). Each
    room will have a size and, probably, so will many other things within the house;
    therefore, we will remove the size and have that as its own `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we have this following `struct` for the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This, back in the parent `struct`, will transform into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can carry on doing this for anything else in the room, including a `struct`
    variable for furniture, as well as possibly reducing the size for carpet—what
    you do with it is up to you. For now, we'll keep it at this level.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to access a `struct` variable, we will need to create a variable that
    can access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code for this section is in the `07/simplestruct` folder in the supporting
    code bundle of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We have not defined all of the variables within that structure, which, for now,
    is fine, as they still need to be defined before the code will compile. The variable
    is mutable since we want to change its contents later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access one of the members of the `struct`, we will use the dot notation.
    In this case, we can have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Defining the child structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have two types of `struct`—parent and child. Here, the `struct` of `Room`
    is the parent and it has two children: the window definition and room size. They
    are very different beasts as the window definition is a `Vec` type, while the
    other is just a `struct` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the room area, we can use the following when creating an instance of the
    room type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We are defining `room_area`, for which we will then define an inline variable
    which will act as the pointer to the area structure and, finally, create the size
    of the room. This is accessed using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have to define the vector of Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in a very similar way to how we define any other vector, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then add a few more `println!` lines to show we have some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When compiled, the code produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have very quickly, and simply, created a multi-level structure.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-file version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look at the source code in the `simplestruct` file, you'll find the structures
    at the start with the code under it. There is nothing wrong with that, but after
    a while, it becomes cumbersome, especially if we have a lot of structures and
    enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: To remove this problem, we can split the structures and code over two files.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we build the code, we will have to provide the `main.rs` file
    with some sort of pointer to the structures. We can do this in one of three ways.
    The simplest is to use the `include!` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The source for this section is in the `Chapter 7/multifile` folder, present
    in the supporting code bundle provided for this book.
  prefs: []
  type: TYPE_NORMAL
- en: This just inserts the contents of the file in the place of the macro call, so
    it's not the most elegant way and completely sidesteps Rust's module system. So
    let's look at a better way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The better way is to reference the module using the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This can lead to a large number of issues, the biggest being the protection
    level, `public` or `private`. When compiled like this, many errors, such as the
    following example, occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The error will indicate that, though the structure is `public`, the fields within
    it aren't, so they can't be accessed. The solution is to make all of the fields
    `public`.
  prefs: []
  type: TYPE_NORMAL
- en: Private versus public fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, all fields within a `struct` are `private` to the module it is
    created in. This has its uses; for example, if you want to protect a value within
    the `struct`, you can make it only accessible via a `read`/`write` function, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code for this section is in the `07/readwrite` folder, present in the supporting
    code bundle provided for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we build and run this, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Structs 102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we have defined our own structs, we also have access to a structure known
    as a unit-like `struct`. Unlike our own structs, we can see the likes of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: They have nothing after them—no fields defined. These are not the same as the
    ones we defined, so how do they work?
  prefs: []
  type: TYPE_NORMAL
- en: To understand how they work, we need to understand a tuple `struct` and, in
    order to understand those, we need to know what a tuple is.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are two ways to initialize a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On the first line, we let local type inference work and just declare what is
    inside the tuple. Rust will figure out the types. On the second line, we declare
    the types explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: We can have as many (or as few) elements in the list as they are, in fact, an
    ordered list of a fixed size.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other variable types, we can assign one tuple to equal another as long
    as they contain the same types and number of parameters (arity). For example,
    the following have the same types and arity and so can be used to assign to each
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following wouldn''t be allowed as the types don''t match, even though the
    arity does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using a tuple to define a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a variable called `test` that has the value `1` of type `i32` bound
    to it (binding was discussed in [Chapter 5](part0106.html#352RK0-a5175cb437d742a9aed0ea574000ee2d),
    *Remember, Remember*). How can we do something similar with a tuple? So far, we''ve
    done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We bound `test` to a tuple containing two values: `(i32, f32)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tuple indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get at the `f32` value, we will have to use tuple indexing. This is very
    similar to indexing an array, but we replace the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the following snippet instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As with array indexes, the tuple indexes range from `0` to `n-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring with let
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To avoid using a tuple index, Rust has a way to destructure a tuple. This is
    very similar to a normal `let` statement, except we will define multiple variable
    names at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If there are the same number of names on the left as there are arguments on
    the right, Rust will break these up internally to create three bindings at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have three bindings and can access them as we would any other variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tuple structs – the hybrid of two
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider a `struct` with three fields. It will have a name for the `struct`
    type and the three fields with their types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider what this actually is and if we can we not rewrite this as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Well, we can, but we will now run into how to access the members of the tuple.
    We will also run into assigning one tuple to another. You can't really define
    two structs, which are identical in everything other than the `struct` type name,
    and then assign the second `struct` type to the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around this, Rust has the tuple `struct` hybrid. It contains the `struct`
    type but then assigns the fields as a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We now have the flexibility of a tuple, but with the protection of the `struct`.
    Despite the arity being the same and the types inside the struct being the same,
    they are different types.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with a regular tuple, we can access the members of the tuple `struct` in
    the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The single element tuple struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you''re probably wondering whether there are any uses for a
    tuple `struct` over a standard `struct`. One of the uses is when the tuple `struct`
    has a single element. Here, we are able to create a variable based on the tuple.
    It''s similar to a destructured tuple in appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The source for this section is in the `07/newtype` folder, present in the supporting
    code bundle provided for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This produces the following output when compiled and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This form of assignment is known as a new type pattern; it has allowed the creation
    of a new type distinct from the contained value.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the unit-like struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an understanding of tuples and the tuple `struct`, we can now
    look at the unit-like `struct`. This can be considered to be a `struct` with an
    empty tuple and as with a tuple `struct`, it defines a new type.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, we will use this in conjunction with a trait or if you don't have
    any data to store in it.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If are you are used to C, you will be well used to enumerations, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This creates an `enum` type that auto-fills `next` and `nextone` to be start
    `+ 1` and start `+ 2` respectively. If the first named parameter has nothing to
    give an initial value to, it is given the value `0` with everything after it being
    one larger than the last. They are accessed as `myEnum.nextone`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `enum` type in Rust has a very similar structure to a `struct` type, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As with C though, an `enum` is a single type, but the value of the `enum` can
    match any of its members.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing enumeration members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given the possibility of the contents of a Rust `enum`, you may be thinking
    that accessing one of the members within the enumeration may not be the simplest
    of tasks. Thankfully, it is, as an `enum` variable is sometimes referred to as
    a *scopable* variable. For example, if we wanted to access members, we could use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The code for this section is in the `07/enumscope` folder, present in the supporting
    code bundle provided for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables, `value1` and `value2`, are scoped (uses `::`) to `MyFirstEnum`
    and `MySecondEnum` respectively. When compiled, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The two questions you should be asking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code is a bit of head-scratcher. Surely we should have been able to use
    something similar to the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: And then use `value.2` to obtain the string part directly within the `println!`
    statement, instead of the `if let` construct?
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we can't is that `enum` variants aren't their own type, so as
    soon as we create the preceding value, above it is immediately lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second question should be: What is the `if let` construct?'
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, `if let` is used as a way to perform certain types of pattern-matching.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust, as we have seen, contains many very powerful facilities. We will now consider
    two that are often seen, and then double back to examine how we can use the `if
    let` construct.
  prefs: []
  type: TYPE_NORMAL
- en: Matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a very unpleasant code block and then examine what it means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The code takes an `i32` parameter and tests to see what it equals. If the condition
    is met, some text is returned for that number; otherwise, `"not found"` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: This is a trivial example, but imagine if you're testing against 10 different
    conditions; the `if-else` construct will become ugly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were in C, we could use `switch`/`case` and Rust can also do something
    similar, but the keyword is `match` instead. If we used the `match` expression,
    our function would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, when `x` is matched to the value inside of the `match` expression,
    `t` is assigned. If it is not matched (`_ = > ...`), then `t` is set to be `not
    found`. There must be a `_` wildcard pattern case within the `match`. This is
    down to Rust enforcing exhaustiveness checking. In other words, until the `_`
    wildcard is reached, Rust assumes that there must be other values to attempt to
    match.
  prefs: []
  type: TYPE_NORMAL
- en: Let's really make the function simple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the preceding example is fairly compact, we can further reduce the footprint
    of the code by using `match` as an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re used to `?` in C#, you will be familiar with a construct such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This means that we can assign `t` to be `three` if `SomeCondition == 3` else
    `if``SomeCondition == 4`, `t = four`. If this falls through, we can set `t` as
    `not three or four`.
  prefs: []
  type: TYPE_NORMAL
- en: It can get messy. Rust can do the same, only far more cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the origin code, we had the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `match` as an expression to set the value to be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, more simply, by just returning the result of the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even more simply, when we remember that, in Rust, a block returns the result
    of its last expression when we omit the `;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Using match with an enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen in this chapter how enums can be somewhat tricky to handle.
    Thankfully, we can use `match` on an `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that in this example, `_` is not included. That''s because
    we explicitly match against all the possible choices of the enum, so we don''t
    need a catch-all case. If, for instance, we missed `NewTypeTuple`, the code would
    need to include a catch-all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Ignoring a parameter with match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is entirely possible to ignore a parameter within a `match` construct. Take
    the following `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this `struct` within a `match` construct as we can any other type.
    However, we want to ignore anything after `real_answer`. To do this, we will use
    the `..` operator. Our match will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `_` as a parameter (we expect a value, but we don''t care what
    it is):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can appreciate that the `match` construct is powerful, but let's see it
    in action with patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Fall through patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that we want to have a fall through construct in the same way as
    we would have in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do this in Rust using the `|` pattern, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a similar way to using `|`, we can match on a range of values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use something similar with `char`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Creating a binding within a match pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it is very useful to create a temporary variable within a `match`
    construct and bind the result of the pattern to it. This is performed using `@`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This attempts to match the pattern `1` to `10` to the value of `test`. If it
    is a match, the value is bound to `t`, which we can then manipulate as we would
    any other variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also bind to the variable with a fall through construct as done in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Let's add an if into the mix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can include an `if` statement within a `match` pattern, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Using match with a compound type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A compound type is a type that contains many different types—a `struct` is possibly
    the simplest example here. The following also applies to enums and tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can match on a `struct` pattern the same way we can match on any other type
    of pattern, which is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As described in the matching section, we can ignore parameters in the `struct`
    pattern match using `..`, or just throw them away using `_`.
  prefs: []
  type: TYPE_NORMAL
- en: And back to if let
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have probably realized now that `if let` is, in actuality, a `match` construct
    that is just written in a slightly different way.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `match` construct is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if let` version would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how Rust deals with some fairly complex types that allow
    us to create a type which contains many different types, and how handling these
    compound types can be a mostly painless affair. We have also drawn attention to
    pitfalls when using enums.
  prefs: []
  type: TYPE_NORMAL
- en: We have examined the structured and flexible approach Rust takes to patterns
    and matching and the power that simplicity provides to developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at something that takes a fair bit of
    practice to understand and even more to get right—the Rust lifetime system.
  prefs: []
  type: TYPE_NORMAL
