<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Logging and Configuring Microservice</h1>
                </header>
            
            <article>
                
<p>Microservices work in the real world, which is dynamic. To be useful, they have to be configurable, so that you can change an address or port to bind the server's socket. Often, you will need to set tokens, secrets, and the addresses of other microservices. Even if you have configured them correctly, your microservices may fail. In this case, you need to be able to use the server's logs.</p>
<p>In this chapter, we'll learn the following skills:</p>
<ul>
<li>How to use logging with the <kbd>log</kbd> crate</li>
<li>How to read command-line parameters with the <kbd>clap</kbd> crate</li>
<li>How to read environment variables with the <kbd>dotenv</kbd> crate</li>
<li>How to declare and use configuration files</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter explains how to add logging to a service and parse command-line parameters or the environment variables required to configure a microservice. You don't need any special software except the Rust compiler, version 1.31 or above. Install it using the rustup tool.</p>
<p>You can find the code for the examples of this chapter on GitHub: <a href="https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter3">https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter3</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding logging to a microservice</h1>
                </header>
            
            <article>
                
<p>We can't use or debug a microservice if it doesn't record the actions that it carries out. In this section, we will start to use logging with our microservices to understand what is going on inside them. We will create a microservice that generates random values and attach a logger to a microservice to record the actions it carries out. Afterward, we will configure logging using environment variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Random-value-generating microservices</h1>
                </header>
            
            <article>
                
<p>To discuss these more advanced topics, we need a microservices architecture that has a more useful purpose than generating <em>hello</em> messages. We will create a microservice application for generating random values. This is simple enough to implement and will provide us with sufficient opportunities to use logging and configuration.</p>
<p>However, we won't start completely from scratch; let's take the example from the previous chapter and add a dependency to it:</p>
<pre>[dependencies]<br/>hyper = "0.12"<br/>rand = "0.5"</pre>
<p>A <kbd>rand</kbd> crate provides the utilities necessary to generate random values in Rust. Import the necessary types in the <kbd>main.rs</kbd> file:</p>
<pre>use hyper::{Body, Response, Server};<br/>use hyper::rt::Future;<br/>use hyper::service::service_fn_ok;</pre>
<p>Add two lines to the <kbd>service_fn_ok</kbd> function to handle incoming requests:</p>
<pre>fn main() {<br/>    let addr = ([127, 0, 0, 1], 8080).into();<br/>    let builder = Server::bind(&amp;addr);<br/>    let server = builder.serve(|| {<br/>        service_fn_ok(|_| {<br/>            let random_byte = rand::random::&lt;u8&gt;();<br/>            Response::new(Body::from(random_byte.to_string()))<br/>        })<br/>    });<br/>    let server = server.map_err(drop);<br/>    hyper::rt::run(server);<br/>}</pre>
<p>To learn more about the preceding code, please refer to the previous chapter, where we explored the <kbd>hyper</kbd> crate. </p>
<p>As you can see, we have added two lines in the closure provided to the <kbd>service_fn_ok</kbd> function. The first line generates a random byte with the <kbd>random</kbd> function of the <kbd>rand</kbd> crate. We set the generated type in the type parameter of the <kbd><span>rand::random::&lt;u8&gt;()</span></kbd> call. Now, <kbd>u8</kbd>  is an unsigned byte integer.</p>
<p>In the second line, we simply convert the generated byte to a string and return it as a <kbd>Body</kbd> of the <kbd>Response</kbd>. Try to run the code to test it:</p>
<p class="CDPAlignCenter CDPAlign"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/164b62dc-2c6e-43d5-a135-4a257ddff4d1.png" style="width:32.08em;height:12.50em;"/></p>
<p>From the preceding screenshot, you can see that the service returned the generated random value successfully.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The log crate</h1>
                </header>
            
            <article>
                
<p>Logging is the process of recording the activities of a program. Logs can be a textual flow in a specified format, which prints to a console or writes to a file. Rust has a great logging ecosystem based on the <kbd>log</kbd> crate. It is worth noting that the <kbd>log</kbd> crate contains macros without a real logger implementation. This gives you an opportunity to use different loggers depending on what you need them for. In this section, we will start to use the log crate in our microservices to learn how logging levels work and how to set the desired level of logs you want to see.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loggers</h1>
                </header>
            
            <article>
                
<p>The actual logger implementations that are contained in some crates are as follows:</p>
<ul>
<li><kbd>env_logger</kbd></li>
<li><kbd>simple_logger</kbd></li>
<li><kbd>simplelog</kbd></li>
<li><kbd>pretty_env_logger</kbd></li>
<li><kbd>stderrlog</kbd></li>
<li><kbd>flexi_logger</kbd></li>
<li><kbd>log4rs</kbd></li>
<li><kbd>fern</kbd></li>
</ul>
<p>It can be difficult to choose between these logger implementations. I recommend that you explore them on <a href="http://crates.io">crates.io</a> to learn how they differ. The most popular one is <kbd>env_logger</kbd>, which is the one that we are going to use. <kbd>env_logger</kbd> reads the <kbd>RUST_LOG</kbd> environment variable to configure logging and prints logs to <kbd>stderr</kbd>. There is also the <kbd>pretty_env_logger</kbd> crate, which is built on top of <kbd>env_logger</kbd> and prints logs with a compact and colorful format. Both use the same environment variable for configuration.</p>
<div class="packt_tip"><kbd>stderr</kbd> is one of three standard streams—<kbd>stdin</kbd><em>,</em> where your program reads the input data with the console; <kbd>stdout</kbd><em>,</em> where the program sends the output data; and <kbd>stderr</kbd><em>, </em>which has the special purpose of showing errors or other information about working with the application. Loggers often use <kbd>stderr</kbd> to avoid affecting the output data. For example, let's say that you have a tool that decodes an input stream. You want the tool to send the decoded data only to the output stream. How will the program inform you about any issues it is experiencing? In this case, we can use the <kbd>stderr</kbd> stream, which works as an output stream, but doesn't pollute <kbd>stdout</kbd>? There is <kbd>stderr</kbd> stream that works as output stream, but doesn't pollute <kbd>stdout</kbd>.</div>
<p>Add the logger to the dependencies list of your <kbd>Cargo.toml</kbd>  file:</p>
<pre>[dependencies]<br/>log = "0.4"<br/>pretty_env_logger = "0.2"<br/>hyper = "0.12"<br/>rand = "0.5"</pre>
<p class="mce-root"/>
<p>Then add these types to your <kbd>main.rs</kbd> file:</p>
<pre>use hyper::{Body, Response, Server};<br/>use hyper::rt::Future;<br/>use hyper::service::service_fn_ok;<br/>use log::{debug, info, trace};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Log levels</h1>
                </header>
            
            <article>
                
<p>As we discussed earlier, with the <kbd>log</kbd> crate, we need to import the following logging macros. We can use the following:</p>
<ul>
<li><kbd>trace!</kbd></li>
<li><kbd>debug!</kbd></li>
<li><kbd>info!</kbd></li>
<li><kbd>warn!</kbd></li>
<li><kbd>error!</kbd></li>
</ul>
<p>These are ordered by the importance of the information they print, with <kbd>trace!</kbd> being the least important and <kbd>error!</kbd> being the most important:</p>
<ul>
<li><kbd>trace!</kbd>: Used to print verbose information about any pivotal activity. It allows web servers to trace any incoming chunk of data.</li>
<li><kbd>debug!</kbd>: Used for less verbose messages, such as the incoming server requests. It is useful for debugging.</li>
<li><kbd>info!</kbd>: Used for important information such as the runtime or server configuration. It is rarely used in library crates.</li>
<li><kbd>warn!</kbd>: Informs the user about non-critical errors, such as if the client has used broken cookies or if the necessary microservice is temporarily unavailable and cached data is used for responses instead.</li>
<li><kbd>error!</kbd>: Provides an alert about critical errors. This is used when the database connection is broken.</li>
</ul>
<p>We imported the necessary macro directly from the <kbd>log</kbd> crate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging messages</h1>
                </header>
            
            <article>
                
<p>Logging is not useful without the contextual data of the code. Every logging macro expects a text message that can contain positional parameters. For example, take a look at the <kbd>println!</kbd> macro:</p>
<pre>debug!("Trying to bind server to address: {}", addr);</pre>
<p>The preceding code will work for types that implement the <kbd>Display</kbd> trait. As in the <kbd>println!</kbd> macro, you can add types that implement the <kbd>Debug</kbd> trait with the <kbd>{:?}</kbd> formatter. It's useful to derive the <kbd>Debug</kbd> trait for all types in your code with <kbd>#[derive(Debug)]</kbd> and set the  <kbd>#![deny(missing_debug_implementations)]</kbd> attribute for the whole crate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom level of messages</h1>
                </header>
            
            <article>
                
<p>Levels have an important role in the logging process. They are used for filtering the records by their priority. If you set the <kbd>info</kbd> level for the <kbd>logger</kbd>, it will skip all the <kbd>debug</kbd> and <kbd>trace</kbd> records. Obviously, you need more verbose logging for debugging purposes and less verbose logging to use the server in production.</p>
<p>Internally, every macro of the <kbd>log</kbd> crate uses the <kbd>log!</kbd> macro, which has an argument to set the level:</p>
<pre class="rust rust-example-rendered"><span class="macro">log</span><span class="macro">!</span>(<span class="ident">Level</span>::<span class="ident">Error</span>, <span class="string">"Error information: {}"</span>, error);</pre>
<p>It takes an instance of the <kbd>Level</kbd> enumeration that has the following variants—<kbd>Trace</kbd>, <kbd>Debug</kbd>, <kbd>Info</kbd>, <kbd>Warn</kbd>, and <kbd>Error</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking logging is enabled</h1>
                </header>
            
            <article>
                
<p>Sometimes, logging may require a lot of resources. In this case, you can use the <kbd>log_enabled!</kbd> macro to check that a certain logging level has been enabled:</p>
<pre class="rust rust-example-rendered"><span class="kw">if</span> <span class="macro">log_enabled</span><span class="macro">!</span>(<span class="ident">Debug</span>) {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> get_data_which_requires_resources();
    <span class="macro">debug</span><span class="macro">!</span>(<span class="string">"expensive data: {}"</span>, <span class="ident">data</span>);
}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Own target</h1>
                </header>
            
            <article>
                
<p>Every log record has a target. A typical logging record looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c33631fa-2d5f-4e41-a7d4-24b88db2bd90.png" style="width:56.50em;height:23.08em;"/></p>
<p>The log record consists of the logging level, the time (not shown in this output), the target, and the message. You can think about the target as a namespace. If no target is specified, the <kbd>log</kbd> crate uses the <kbd>module_path!</kbd> macro to set one. We can use the target to detect the module where an error or warning has happened or use it for filtering records by name. We will see how to set filtering by environment variable in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using logging</h1>
                </header>
            
            <article>
                
<p>We can now add logging to our microservice. In the following example, we will print information about the socket address, the incoming request, and a generated random value:</p>
<pre>fn main() {<br/>     logger::init();<br/>     info!("Rand Microservice - v0.1.0");<br/>     trace!("Starting...");<br/>     let addr = ([127, 0, 0, 1], 8080).into();<br/>     debug!("Trying to bind server to address: {}", addr);<br/>     let builder = Server::bind(&amp;addr);<br/>     trace!("Creating service handler...");<br/>     let server = builder.serve(|| {<br/>         service_fn_ok(|req| {<br/>             trace!("Incoming request is: {:?}", req);<br/>             let random_byte = rand::random::&lt;u8&gt;();<br/>             debug!("Generated value is: {}", random_byte);<br/>             Response::new(Body::from(random_byte.to_string()))<br/>         })<br/>     });<br/>     info!("Used address: {}", server.local_addr());<br/>     let server = server.map_err(drop);<br/>     debug!("Run!");<br/>     hyper::rt::run(server);<br/> }</pre>
<p>Using logging is quite simple. We can use macros to print the address of the socket and information about the request and response.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring a logger with variables</h1>
                </header>
            
            <article>
                
<p>There are some environment variables that you can use to configure a logger. Let's take a look at each variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RUST_LOG</h1>
                </header>
            
            <article>
                
<p>Compile this example. To run it with an activated logger, you have to set the <kbd>RUST_LOG</kbd> environment variable. The <kbd>env_logger</kbd> crate reads it and configures the logger using filters from this variable. A <kbd>logger</kbd> instance must be configured with a corresponding logging level.</p>
<div class="packt_tip">You can set the <kbd>RUST_LOG</kbd> variable globally. If you use the Bash shell, you can set it in your <kbd>.bashrc</kbd> file.</div>
<p>You can set <kbd>RUST_LOG</kbd> temporarily before the <kbd>cargo run</kbd> command:</p>
<pre><strong>RUST_LOG=trace cargo run</strong></pre>
<p class="mce-root">However, this will also print a lot of <kbd>cargo</kbd> tool and compiler records, because the Rust compiler also uses the <kbd>log</kbd> crate for logging. You can exclude all records except for those of your program using filtering by name. You only need to use part of the target name, as follows:</p>
<pre><strong> RUST_LOG=random_service=trace,warn cargo run</strong></pre>
<p>This value of the <kbd>RUST_LOG</kbd> variable filters all records by the <em>warn</em> level and uses the <em>trace</em> level for targets starting with the <kbd>random_service</kbd> prefix.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RUST_LOG_STYLE</h1>
                </header>
            
            <article>
                
<p>The <kbd>RUST_LOG_STYLE</kbd> variable sets the style of printed records. It has three variants:</p>
<ul>
<li><strong>auto</strong>: Tries to use the style characters</li>
<li><strong>always</strong>: Always uses the style characters</li>
<li><strong>never</strong>: Turns off the style characters</li>
</ul>
<p>See the following example:</p>
<pre><strong>RUST_LOG_STYLE=auto cargo run</strong></pre>
<p>I recommend that you use the <kbd>never</kbd> value if you redirect the <kbd>stderr</kbd> output a file or if you want to use <kbd>grep</kbd> or <kbd>awk</kbd> to extract values with special patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing the RUST_LOG variable to your own</h1>
                </header>
            
            <article>
                
<p>If you release your own product, you may need to change the name of the <kbd>RUST_LOG</kbd> and the <kbd>RUST_LOG_STYLE</kbd> variable to your own. New releases of the <kbd>env_logger</kbd> contain the <kbd>init_from_env</kbd> special function to fix this. This expects one argument—an instance of the <kbd>Env</kbd> object. Take a look at the following code:</p>
<pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">env</span> <span class="op">= </span><span class="ident">env_logger::</span><span class="ident">Env</span>::<span class="ident">new</span>()<br/>    .<span class="ident">filter</span>(<span class="string">"OWN_LOG_VAR"</span>)<br/>    .<span class="ident">write_style</span>(<span class="string">"OWN_LOG_STYLE_VAR"</span>);<br/><span class="ident">env_logger</span>::<span class="ident">init_from_env</span>(<span class="ident">env</span>);</pre>
<p>It creates an <kbd>Env</kbd> instance and sets the <kbd>OWN_LOG_VAR</kbd> variable to configure logging and the <kbd>OWN_LOG_STYLE_VAR</kbd> variable to control the style of the logs. When the <kbd>env</kbd> object is created, we will use it as an argument for the <kbd>init_from_env</kbd> function call of the <kbd>env_logger</kbd> crate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading environment variables</h1>
                </header>
            
            <article>
                
<p>In the previous example, we used a value of the <kbd>RUST_LOG</kbd> environment variable to set filtering parameters for logging. We can use other environment variables to set parameters for our server as well. In the following example, we will use the <kbd>ADDRESS</kbd> environment variable to set the address of the socket we want to bind.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Standard library</h1>
                </header>
            
            <article>
                
<p>There are enough functions in the <kbd>std::env</kbd> standard module to work with environment variables. It contains the <kbd>var</kbd> function to read external values. This function returns a <kbd>Result</kbd> with a <kbd>String</kbd> value of the variable if it exists, or a <kbd>VarError</kbd> error if it doesn't exist. Add the import of the <kbd>env</kbd> module to your <kbd>main.rs</kbd> file:</p>
<pre>use std::env;</pre>
<p>We need to replace the following line:</p>
<pre>let addr = ([127, 0, 0, 1], 8080).into();</pre>
<p>Replace it with the following:</p>
<pre>let addr = env::var("ADDRESS")<br/>    .unwrap_or_else(|_| "127.0.0.1:8080".into())<br/>    .parse()<br/>    .expect("can't parse ADDRESS variable");</pre>
<p class="mce-root">This new code reads the <kbd>ADDRESS</kbd> value. If this value doesn't exist, we won't let the code throw a panic. Instead, we will replace it with the default value, <kbd>"127.0.0.1:8080"</kbd>, using the <kbd>unwrap_or_else</kbd> method call. As the <kbd>var</kbd> function returns a <kbd>String</kbd>, we also have to convert <kbd>&amp;'static str</kbd> into a <kbd>String</kbd> instance with the <kbd>into</kbd> method call.</p>
<p class="mce-root">If we can't parse an address, we will throw a panic in the <kbd>except</kbd> method call.</p>
<p class="mce-root">Your server will now use the <kbd>addr</kbd> variable, which takes a value from the <kbd>ADDRESS</kbd> environment variable or from the default value.</p>
<p class="mce-root">Environment variables are a simple way of configuring your application. They are also widely supported with hosting or cloud platforms and Docker containers.</p>
<div class="packt_tip">Remember that all sensitive data is visible to the system administrator of the host. In Linux, the system administrator can read this data simply by using the <kbd>cat /proc/`pidof random-service-with-env`/environ` | tr '\0' '\n'</kbd> command. This means that it's not a good idea to set the secret key of your bitcoin wallet to the environment variable.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the .env file</h1>
                </header>
            
            <article>
                
<p>Setting many environment variables is time-consuming. We can simplify this using configuration files, which we will explore further at the end of this chapter. However, configuration files can't be used in cases where the crates or dependencies use environment variables.</p>
<p>To make this process simple, we can use the <kbd>dotenv</kbd> crate. This is used to set environment variables from a file. This practice appeared as part of <em>The Twelve-Factor App</em> methodology <em>(<a href="https://12factor.net/">https://12factor.net/</a>)</em>.</p>
<p><em>The Twelve-Factor App</em> approach is a methodology for building <strong>Software as a Service</strong> (<strong>SaaS</strong>) applications to fulfill the following three objectives:</p>
<ul>
<li>Configurations in declarative formats</li>
<li>Maximum portability with operating systems and clouds</li>
<li>Continuous deployment and scaling</li>
</ul>
<p>This methodology encourages you to use environment variables to configure the application. The <em>Twelve-Factor App</em> approach doesn't require disk space for configuration and it is extremely portable, meaning that all operating systems support the environment variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the dotenv crate</h1>
                </header>
            
            <article>
                
<p>The <kbd>dotenv</kbd> crate allows you to set environment variables in a file called <kbd>.env</kbd> and join them with variables set in the traditional way. You don't need to read this file manually. All you need to do is add the dependency and call the initialization method of the crate.</p>
<p>Add <span>this crate </span><span>to the list of</span> <kbd>dependencies</kbd><span> :</span></p>
<pre>dotenv = "0.13"</pre>
<p>Add the following imports to the <kbd>main.rs</kbd> file of the previous example to use the <kbd>dotenv</kbd> crate:</p>
<pre>use dotenv::dotenv;<br/>use std::env;</pre>
<p>Initialize it with the <kbd>dotenv</kbd> function, which will try to find the <kbd>.env</kbd> file. It will return a <kbd>Result</kbd> with a path to this file. Call the <kbd>ok</kbd> method of the <kbd>Result</kbd> to ignore it if the file hasn't been found.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding variables to the .env file</h1>
                </header>
            
            <article>
                
<p>The <kbd>.env</kbd> file contains pairs of names and values of environment variables. For our service, we will set the <kbd>RUST_LOG</kbd>, <kbd>RUST_BACKTRACE</kbd>, and <kbd>ADDRESS</kbd> variables:</p>
<pre>RUST_LOG=debug<br/>RUST_BACKTRACE=1<br/>ADDRESS=0.0.0.0:1234</pre>
<p>As you can see, we set all the targets of the <kbd>logger</kbd> to the <kbd>debug</kbd> level, because <kbd>cargo</kbd> doesn't use <kbd>dotenv</kbd> and therefore skips these settings.</p>
<p>The <kbd>RUST_BACKTRACE</kbd> variable sets the flag to print a backtrace of the application in the case of panic.</p>
<p>Store this file in the working directory from which you will run the application. You can have multiple files and use them for different configurations. This file format is also compatible with Docker and can be used to set variables to the container.</p>
<div class="packt_tip">I recommend that you add the <kbd>.env</kbd> file to your <kbd>.gitignore</kbd> to prevent leaking of sensitive or local data. This means that every user or developer who works with your project has their own environment and needs their own version of the <kbd>.env</kbd> file.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing command-line arguments</h1>
                </header>
            
            <article>
                
<p>Environment variables are useful for using with containers. If you use your application from a console or you want to avoid a conflict of names with other variables, you can use command-line parameters. This is a more conventional way for developers to set parameters to the program.</p>
<p>You can also get command-line arguments with the <kbd>env</kbd> module. This contains the <kbd>args</kbd> function, which returns an <kbd>Args</kbd> object. This object is not an array or vector, but it's iterable and you can use the <kbd>for</kbd> loop processes all command-line arguments:</p>
<pre class="rust rust-example-rendered"><span class="kw">for</span> <span class="ident">arg</span> <span class="kw">in</span> <span class="ident">env</span>::<span class="ident">args</span>() {
    // Interpret the arg here
}</pre>
<p>This variant may come in handy in simple cases. For parsing arguments with complex rules, however, you have to use a command-line argument parser. A good implementation of this is contained in the <kbd>clap</kbd> crate.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the clap crate</h1>
                </header>
            
            <article>
                
<p>To use the <kbd>clap</kbd> crate for parsing arguments, you have to build a parser and use it for arguments. To build a parser, you start by creating an instance of the <kbd>App</kbd> type. To use it, add all the necessary imports.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding dependencies</h1>
                </header>
            
            <article>
                
<p>Add a dependency to <kbd>Cargo.toml</kbd>:</p>
<pre>clap = "2.32"</pre>
<p>This crate provides useful macros for adding meta information about the program. These are as follows:</p>
<ul>
<li><kbd>crate_name!</kbd>: Returns the name of the crate</li>
<li><kbd>crate_version!</kbd>: Returns the version of the crate</li>
<li><kbd>crate_authors!</kbd>: Returns the list of authors</li>
<li><kbd>crate_description!</kbd>: Provides the description of the crate</li>
</ul>
<p>All information for these macros is taken from the <kbd>Cargo.toml</kbd> file.</p>
<p>Import the necessary types. We need two types, which are <kbd>App</kbd> and <kbd>Arg</kbd>, and the macros mentioned previously:</p>
<pre>use clap::{crate_authors, crate_description, crate_name, crate_version, Arg, App};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a parser</h1>
                </header>
            
            <article>
                
<p>The process of building a parser is quite simple. You will create an <kbd>App</kbd> instance and feed this type with the <kbd>Arg</kbd> instances. The <kbd>App</kbd> also has methods that can be used to set information about the application. Add the following code to the <kbd>main</kbd> function of our server:</p>
<pre>let matches = App::new(crate_name!())<br/>         .version(crate_version!())<br/>         .author(crate_authors!())<br/>         .about(crate_description!())<br/>         .arg(Arg::with_name("address")<br/>              .short("a")<br/>              .long("address")<br/>              .value_name("ADDRESS")<br/>              .help("Sets an address")<br/>              .takes_value(true))<br/>         .arg(Arg::with_name("config")<br/>              .short("c")<br/>              .long("config")<br/>              .value_name("FILE")<br/>              .help("Sets a custom config file")<br/>              .takes_value(true))<br/>        .get_matches();</pre>
<p>First, we create an <kbd>App</kbd> instance with a <kbd>new</kbd> method that expects the name of the crate. We provide this using the <kbd>crate_name!</kbd> macro. After that, we use the <kbd>version</kbd>, <kbd>author</kbd>, and <kbd>about</kbd> methods to set this data using the corresponding macros. We can chain these method calls, because every method consumes and returns the updated <kbd>App</kbd> object. When we set meta-information about the application, we have to declare the supported arguments with the <kbd>arg</kbd> method.</p>
<p>To add an argument, we have to create an <kbd>Arg</kbd> instance with the <kbd>with_name</kbd> method, provide the name, and set extra parameters using chaining-of-methods calls. We can set a short form of the argument with the <kbd>short</kbd> method and the long form with the <kbd>long</kbd> method. You can set the name of the value for the generated documentation using the <kbd>value_name</kbd> method. You can provide a description of an argument using the  <kbd>help</kbd> method. The <kbd>takes_value</kbd> method is used to indicate that this argument requires a value. There is also a <kbd>required</kbd> method to indicate that an option is required, but we didn't use that here. All options are optional in our server.</p>
<p>We added the <kbd>--address</kbd> argument using these methods to set the address of the socket that we will use to bind the server. It also supports the short form <kbd>a</kbd> of the argument. We will read this value later.</p>
<p>The server will support the <kbd>--config</kbd> argument to set a configuration file. We have added this argument to the builder, but we will use it in the next section of this chapter.</p>
<p class="mce-root">After we create the builder, we call the <kbd>get_matches</kbd> method. This reads arguments with <kbd>std::env::args_os</kbd> and returns an <kbd>ArgMatches</kbd> instance, which we can use to get the values of the command-line parameters. We assign it to the <kbd>matches</kbd> local variable.</p>
<div class="packt_tip">We should add the <kbd>get_matches</kbd> method before any logging call because it also prints help messages. We should avoid printing logs with the help description.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading arguments</h1>
                </header>
            
            <article>
                
<p>To read arguments, <kbd>ArgMatches</kbd> contains a <kbd>value_of</kbd> method, where you add the name of a parameter. In this case, it is convenient to use constants to avoid typos. Extract the  <kbd>--address</kbd> argument, and if this does not exist, then check the <kbd>ADDRESS</kbd> environment variable. This means that the command-line argument is a higher priority than the environment variable and you can override the parameters from the <kbd>.env</kbd> file with command-line parameters:</p>
<pre>let addr = matches.value_of("address")<br/>    .map(|s| s.to_owned())<br/>    .or(env::var("ADDRESS").ok())<br/>    .unwrap_or_else(|| "127.0.0.1:8080".into())<br/>    .parse()<br/>    .expect("can't parse ADDRESS variable");</pre>
<p>In this code, we have converted all of the provided string references with the <kbd>&amp;str</kbd> <span>type</span><span> </span><span>to solid</span> <kbd>String</kbd> <span>objects. This is useful if you want to use the object later in the code or if you need to move it elsewhere.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Usage</h1>
                </header>
            
            <article>
                
<p>When you use the <kbd>clap</kbd> crate in your application, you can use command-line parameters to tweak it. The <kbd>clap</kbd> crate adds a <kbd>--help</kbd> argument, which the user can use to print information about all the arguments. This description was generated automatically by the crate, as can be seen in the following example:</p>
<pre><strong>$ ./target/debug/random-service-with-args --help</strong><br/><strong>random-service-with-env 0.1.0</strong><br/><strong>Your Name</strong><br/><strong>Rust Microservice</strong><br/><br/><strong>USAGE:</strong><br/><strong>    random-service-with-env [OPTIONS]</strong><br/><br/><strong>FLAGS:</strong><br/><strong>    -h, --help       Prints help information</strong><br/><strong>    -V, --version    Prints version information</strong><br/><br/><strong>OPTIONS:</strong><br/><strong>    -a, --address &lt;ADDRESS&gt;    Sets an address</strong><br/><strong>    -c, --config &lt;FILE&gt;        Sets a custom config file</strong></pre>
<p>Our application successfully printed the usage info: it provided us with all flags, options, and usage variants. If you need to add your own help description, you can use the <kbd>help</kbd> method of the <kbd>App</kbd> instance to set any string as a help message.</p>
<p>If you use the <kbd>cargo run</kbd> command, you <span>can </span>also set command-line parameters after the <kbd>--</kbd> parameter. This means that it stops reading the <kbd>run</kbd> command and passes all remaining arguments to the running application:</p>
<pre><strong>$ cargo run -- --help</strong></pre>
<p>You can now start the server and set an address using the <kbd>--address</kbd> parameter with value:</p>
<pre><strong>$ cargo run -- --address 0.0.0.0:2345</strong></pre>
<p>The server has started and prints to the console:</p>
<pre>    Finished dev [unoptimized + debuginfo] target(s) in 0.10s                                                                                             Running `target/debug/random-service-with-args --address '0.0.0.0:2345'`<br/> INFO 2018-07-26T04:23:52Z: random_service_with_env: Rand Microservice - v0.1.0<br/>DEBUG 2018-07-26T04:23:52Z: random_service_with_env: Trying to bind server to address: 0.0.0.0:2345<br/> INFO 2018-07-26T04:23:52Z: random_service_with_env: Used address: 0.0.0.0:2345<br/>DEBUG 2018-07-26T04:23:52Z: random_service_with_env: Run!<br/>DEBUG 2018-07-26T04:23:52Z: tokio_reactor::background: starting background reactor</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to add subcommands</h1>
                </header>
            
            <article>
                
<p>Some popular applications, such as <kbd>cargo</kbd> and <kbd>docker</kbd>, use subcommands to provide multiple commands inside a single binary. We can also support subcommands with the <kbd>clap</kbd> crate. A microservice might have two commands: one to run the server and one to generate a secret for the HTTP cookies. Take a look at the following code:</p>
<pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">matches</span> <span class="op">=</span> <span class="ident">App</span>::<span class="ident">new</span>(<span class="string">"Server with keys"</span>)<br/>    .setting(AppSettings::SubcommandRequiredElseHelp)
    .<span class="ident">subcommand</span>(<span class="ident">SubCommand</span>::<span class="ident">with_name</span>(<span class="string">"run"</span>)
        .<span class="ident">about</span>(<span class="string">"run the server"</span>)
        .<span class="ident">arg</span>(<span class="ident">Arg</span>::<span class="ident">with_name</span>(<span class="string">"address"</span>)
            .<span class="ident">short</span>(<span class="string">"a"</span>)<br/>            .long("address")<br/>            .takes_value(true)
            .<span class="ident">help</span>(<span class="string">"address of the server"</span>))<br/>    .<span class="ident">subcommand</span>(<span class="ident">SubCommand</span>::<span class="ident">with_name</span>(<span class="string">"key"</span>)
        .<span class="ident">about</span>(<span class="string">"generates a secret key for cookies"</span>)))<br/>    .<span class="ident">get_matches</span>();</pre>
<p>Here, we have used two methods. The <kbd>setting</kbd> method tweaks the builder and you can set it with variants of the <kbd>AppSettings</kbd> enumeration. The <kbd>SubcommandRequiredElseHelp</kbd> method requires us to use subcommands or prints help message if no subcommands are provided. To add a subcommand, we use the <kbd>subcommand</kbd> method with the <kbd>SubCommand</kbd> instance that we created with the <kbd>with_name</kbd> method. A subcommand instance also has methods to set meta information about a subcommand, like we did with the <kbd>App</kbd> instance. Subcommands can also take arguments.</p>
<p>In the preceding example above, we added two subcommands—<kbd>run</kbd>, to run the server, and <kbd>key</kbd>, to generate secrets. You can use these when you start the application:</p>
<pre><strong>$ cargo run -- run --address 0.0.0.0:2345</strong></pre>
<p>We have two <kbd>run</kbd> arguments because the cargo has a command with the same name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading the configuration from file</h1>
                </header>
            
            <article>
                
<p>Environment variables and command-line arguments are useful to add temporary change parameters for a single run. They are a more convenient way to configure servers to use configuration files. This approach doesn't conform to The <em>Twelve-Factor App</em> methodology, but it's useful in cases when you need to set long parameters.</p>
<p>There are many formats that can be used for configuration files. The popular ones include TOML, YAML, and JSON. We will use TOML, because it is widely used with the Rust programming language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the TOML config</h1>
                </header>
            
            <article>
                
<p>The TOML file format is implemented in the <kbd>toml</kbd> crate. It previously used the now-obsolete <kbd>rustc-serialize</kbd> crate, but the last few versions have used the <kbd>serde</kbd> crate for serialization and deserialization. We will use both the <kbd>toml</kbd> and the <kbd>serde</kbd> crates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding dependencies</h1>
                </header>
            
            <article>
                
<p>We actually need not only the <kbd>serde</kbd> crate but also the <kbd>serde_derive</kbd> crate. Both crates help with the serialization struct in various serialization formats. Add all three crates to the dependencies list in <kbd>Cargo.toml</kbd>:</p>
<pre>serde = "1.0"<br/>serde_derive = "1.0"<br/>toml = "0.4"</pre>
<p>The full list of imports in the <kbd>main.rs</kbd> file contains the following:</p>
<pre>use clap::{crate_authors, crate_description, crate_name, crate_version, Arg, App};<br/>use dotenv::dotenv;<br/>use hyper::{Body, Response, Server};<br/>use hyper::rt::Future;<br/>use hyper::service::service_fn_ok;<br/>use log::{debug, info, trace, warn};<br/>use serde_derive::Deserialize;<br/>use std::env;<br/>use std::io::{self, Read};<br/>use std::fs::File;<br/>use std::net::SocketAddr;</pre>
<p>As you can see, we haven't imported the <kbd>serde</kbd> crate here. We won't use it directly in the code because it's necessary to use the <kbd>serde_derive</kbd> crate instead. We have imported all macros from the <kbd>serde_derive</kbd> crate, because the <kbd>serde</kbd> crate contains the <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> traits and <kbd>serde_derive</kbd> helps us to derive these for our structs.</p>
<p>Microservices often need to serialize and deserialize data when interacting with the client. We will cover this topic in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring a struct for configuration</h1>
                </header>
            
            <article>
                
<p>We have now imported all the necessary dependencies and can declare our configuration file structure. Add the <kbd>Config</kbd> struct to your code:</p>
<pre>#[derive(Deserialize)]<br/>struct Config {<br/>    address: SocketAddr,<br/>}</pre>
<p>This struct contains only one field with the address. You can add more, but remember that all fields have to implement the <kbd>Deserialize</kbd> trait. The <kbd>serde</kbd> crate already has implementations for standard library types. For our types, we have to derive the implementation of <kbd>Deserialize</kbd> with the macro of the <kbd>serde_derive</kbd> crate.</p>
<p>Everything is ready for us to read the configuration from the file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading the configuration file</h1>
                </header>
            
            <article>
                
<p>Our server will expect to find a configuration file in the current working folder with the name <kbd>microservice.toml</kbd>. To read a configuration and convert it to the <kbd>Config</kbd> struct, we need to find and read this file if it exists. Add the following code to the <kbd>main</kbd> function of the server:</p>
<pre>let config = File::open("microservice.toml")<br/>    .and_then(|mut file| {<br/>        let mut buffer = String::new();<br/>        file.read_to_string(&amp;mut buffer)?;<br/>        Ok(buffer)<br/>    })<br/>    .and_then(|buffer| {<br/>        toml::from_str::&lt;Config&gt;(&amp;buffer)<br/>            .map_err(|err| io::Error::new(io::ErrorKind::Other, err))<br/>    })<br/>    .map_err(|err| {<br/>        warn!("Can't read config file: {}", err);<br/>    })<br/>    .ok();</pre>
<p>The preceding code is a chain of method calls that start with the <kbd>File</kbd> instance. We use the <kbd>open</kbd> method to open the file and provide the name <kbd>microservice.toml</kbd>. The call returns a <kbd>Result</kbd>, which we will process in the chain. At the end of the processing, we will convert it to an option using the <kbd>ok</kbd> method and ignore any errors that occur during the parsing of the config file. This is because our service also supports environment variables and command-line parameters and has defaults for unset parameters.</p>
<p>When the file is ready, we will try to convert it into a <kbd>String</kbd>. We created an empty string, called a buffer, and used the <kbd>read_to_string</kbd> method of the <kbd>File</kbd> instance to move all of the data into the buffer. This is a synchronous operation. It's suitable for reading a configuration but you shouldn't use it for reading files to send to the client, because it will lock the runtime of the server until the file is read.</p>
<p>After we have read the <kbd>buffer</kbd> variable, we will try to parse it as a TOML file into the <kbd>Config</kbd> struct. The <kbd>toml</kbd> crate has a <kbd>from_str</kbd> <span>method</span><span> </span><span>in the root namespace of the crate. It expects a type parameter to deserialize and an input string. We use</span> the <kbd>Config</kbd> <span>struct for the output type and our</span> <kbd>buffer</kbd> <span>for the input. But there is a problem:</span> the <kbd>File</kbd> <span>uses</span> <kbd>io::Error</kbd> <span>for errors, but</span> <kbd>from_str</kbd> <span>uses</span> <kbd>toml::de:Error</kbd> <span>for the error type. We can convert the second type to</span> <kbd>io::Error</kbd> <span>to make it compatible with the chain of calls.</span></p>
<p>The penultimate part of the chain is the <kbd>map_err</kbd> method call. We use this to write any errors with the configuration file to logs. As you can see, we used the <kbd>Warn</kbd> level. Issues with the configuration file are not critical, but it is important to be aware of them because they can affect the configuration. This makes the <kbd>microservices.toml</kbd> file optional.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Joining all values by a priority</h1>
                </header>
            
            <article>
                
<p>Our server has four sources of address settings:</p>
<ul>
<li>The configuration file</li>
<li>The environment variable</li>
<li>The command-line parameter</li>
<li>The default value</li>
</ul>
<p>We have to join these in this order. It's simple to implement this using a set of options and using the <kbd>or</kbd> method to set a value if the option doesn't contain anything. Use the following code to get address values from all of the sources:</p>
<pre>let addr = matches.value_of("address")<br/>    .map(|s| s.to_owned())<br/>    .or(env::var("ADDRESS").ok())<br/>    .and_then(|addr| addr.parse().ok())<br/>    .or(config.map(|config| config.address))<br/>    .or_else(|| Some(([127, 0, 0, 1], 8080).into()))<br/>    .unwrap();</pre>
<p>At first, this code takes a value from the <kbd>--address</kbd> command-line parameter. If it doesn't contain any value, the code tries to get a value from the <kbd>ADDRESS</kbd> environment variable. After that, we try to parse a textual value to the socket address. If all these steps fail, we can try to get a value from the <kbd>Config</kbd> instance that we read from <kbd>microservice.toml</kbd>.  We will use the default address value if the value wasn't set by a user. In the previous address-parsing code, we also parsed the default value from a string. In this code, we use a tuple to construct the <kbd>SocketAddr</kbd> instance. Since we are guaranteed to get a value, we <kbd>unwrap</kbd> the option to extract it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and using the configuration file</h1>
                </header>
            
            <article>
                
<p>We can now create a configuration file and run the server. Create the <kbd>microservice.toml</kbd> file in the root folder of the project and add the following line to it:</p>
<pre>address = "0.0.0.0:9876"</pre>
<p>Compile and start the service and you will see it has bound to that address:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/99563a72-b365-490a-a091-846628f66c5e.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we added logging to the server and learned how to activate the <kbd>logger</kbd> and set filters to it. After that, we transformed our unflexible server to a configurable microservice that can read settings from different sources—the configuration file, the environment variable, and the command-line parameters. We became familiar with <em>The Twelve-Factor App</em> methodology and used the <kbd>dotenv</kbd> crate, which helped us to read environment variables from a file. We also used the <kbd>clap</kbd> crate to add a command-line parser. Finally, we touched on the <kbd>serde</kbd> crate, which introduced us to the world of serialization.</p>
<p>In the next chapter we will learn how to use <kbd>serde</kbd> crate for needs of a microservices: to deserialize request and serialize responses to a certain format like JSON, CBOR, BSON, MessagePack, etc.</p>


            </article>

            
        </section>
    </body></html>