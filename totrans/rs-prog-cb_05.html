<html><head></head><body><div><h1 class="header-title">Handling Errors and Other Results</h1>
                
            
            
                
<p>Handling errors is always an interesting challenge in every programming language. There are many styles available: returning numeric values, exceptions (software interrupts), result and option types, and so on. Each way requires different architectures and has implications for performance, readability, and maintainability. Rust's approach is—just like many functional programming languages—based on integrating failure as part of the regular workflow. This means that whatever the return value, an error is not a special case but integrated into the handling. <kbd>Option</kbd> and <kbd>Result</kbd> are the central types that allow for returning results as well as errors. <kbd>panic!</kbd> is an additional macro to halt the thread immediately in case it cannot/should not continue.</p>
<p>In this chapter, we'll cover some basic recipes and architectures to use Rust's error handling effectively so that your code is easy to read, understand, and maintain. For this reason, in this chapter, you can look forward to learning about the following recipes:</p>
<ul>
<li>Panicking responsibly</li>
<li>Handling multiple errors</li>
<li>Working with exceptional results</li>
<li>Seamless error handling</li>
<li>Customizing errors</li>
<li>Resilient programming</li>
<li>Working with external crates for error handling</li>
<li>Moving between Option and Result</li>
</ul>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">Panicking responsibly</h1>
                
            
            
                
<p>Sometimes, there is no way for an execution thread to continue. This may be due to things such as invalid configuration files, unresponsive peers or servers, or OS-related errors. Rust has many ways to panic, explicitly or implicitly. The most ubiquitous one is probably <kbd>unwrap()</kbd> for multiple <kbd>Option</kbd> types and related types, which panic on error or <kbd>None</kbd>. Yet, for more complex programs, it is essential to take control of the panicking (for example, by avoiding multiple <kbd>unwrap()</kbd> calls and libraries that use it) and the <kbd>panic!</kbd> macro supports that. </p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's examine how we can take control of multiple <kbd>panic!</kbd> instances:</p>
<ol>
<li>Create a new project with <kbd>cargo new panicking-responsibly --lib</kbd> and open it with VS Code. </li>
<li>Open <kbd>src/lib.rs</kbd> and replace the default tests with a regular, straightforward panic instances:</li>
</ol>
<pre style="padding-left: 60px">#[cfg(test)]<br/>mod tests {<br/><br/>    #[test]<br/>    #[should_panic]<br/>    fn test_regular_panic() {<br/>        panic!();<br/>    }<br/>}</pre>
<ol start="3">
<li>There are many other ways to halt the program too. Let's add another <kbd>test</kbd> instance:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    #[should_panic]<br/>    fn test_unwrap() {<br/>        // panics if "None"<br/>        None::&lt;i32&gt;.unwrap();<br/>    }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="4">
<li>However, these panics all have a generic error message, which is not very informative with regard to what the application was doing. Using <kbd>expect()</kbd> lets you provide an error message to explain the causes of the error:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    #[should_panic(expected = "Unwrap with a message")]<br/>    fn test_expect() {<br/>        None::&lt;i32&gt;.expect("Unwrap with a message");<br/>    }</pre>
<ol start="5">
<li>The <kbd>panic!</kbd> macro provides a similar way of explaining the sudden halt:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    #[should_panic(expected = "Everything is lost!")]<br/>    fn test_panic_message() {<br/>        panic!("Everything is lost!");<br/>    }<br/><br/>    #[test]<br/>    #[should_panic(expected = "String formatting also works")]<br/>    fn test_panic_format() {<br/>        panic!("{} formatting also works.", "String");<br/>    }</pre>
<ol start="6">
<li>The macro can also return numerical values, something that is very important for Unix-type OSes that can check for those values. Add another test to return  an integer code to indicate a specific failure:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    #[should_panic]<br/>    fn test_panic_return_value() {<br/>        panic!(42);<br/>    }</pre>
<ol start="7">
<li>Another great way of halting the program based on invalid values is by using the <kbd>assert!</kbd> macro. It should be well-known from writing tests, so let's add a few to see Rust's variants:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    #[should_panic]<br/>    fn test_assert() {<br/>        assert!(1 == 2);<br/>    }<br/><br/>    #[test]<br/>    #[should_panic]<br/>    fn test_assert_eq() {<br/>        assert_eq!(1, 2);<br/>    }<br/><br/>    #[test]<br/>    #[should_panic]<br/>    fn test_assert_neq() {<br/>        assert_ne!(1, 1);<br/>    }</pre>
<ol start="8">
<li>The last step is, as usual, to compile and run the code we have just written using <kbd>cargo test</kbd>. The output shows whether the tests have passed (which they should):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/> Compiling panicking-responsibly v0.1.0 (Rust- Cookbook/Chapter05<br/> /panicking-responsibly)<br/>Finished dev [unoptimized + debuginfo] target(s) in 0.29s<br/>Running target/debug/deps/panicking_responsibly-6ec385e96e6ee9cd<br/><br/>running 9 tests<br/>test tests::test_assert ... ok<br/>test tests::test_assert_eq ... ok<br/>test tests::test_assert_neq ... ok<br/>test tests::test_panic_format ... ok<br/>test tests::test_expect ... ok<br/>test tests::test_panic_message ... ok<br/>test tests::test_panic_return_value ... ok<br/>test tests::test_regular_panic ... ok<br/>test tests::test_unwrap ... ok<br/><br/>test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests panicking-responsibly<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>But how does this allow us to panic responsibly? Let's see how it works.</p>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Thanks to Rust's ability to check panic results, we can verify the messages and the fact that the panic occurred. From <em>step 2</em> to <em>step 4</em>, we are simply panicking using various (common) methods, such as <kbd>unwrap()</kbd> (<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap">https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap</a>) or <kbd>panic!()</kbd> (<a href="https://doc.rust-lang.org/std/macro.panic.html">https://doc.rust-lang.org/std/macro.panic.html</a>). These methods return messages such as <kbd>'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:347:21</kbd>, or <kbd>panicked at 'explicit panic', src/lib.rs:64:9</kbd>, which are not easy to debug.</p>
<p>However, there is a variation of <kbd>unwrap()</kbd> called <kbd>expect()</kbd>, which takes a <kbd>&amp;str</kbd> parameter as a simple message for users to debug the issue further. <em>Steps 4</em> to<em> 6</em> show how messages and return values are incorporated. In <em>step 7</em>, we cover the additional <kbd>assert!</kbd> macro that is typically seen in tests but finds its way into productive systems as well to guard against rare and irrecoverable values. </p>
<p class="mce-root">Halting the execution of a thread or program should always be the last resort, especially when you are creating a library for others to use. Think about it—some bug leads to an unexpected value in a third-party library, which then panics and brings the service to an immediate unexpected halt. Imagine if that happened thanks to a call to <kbd>unwrap()</kbd> instead of using more robust methods. </p>
<p>We've successfully learned how to panic responsibly. Now, let's move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Handling multiple errors</h1>
                
            
            
                
<p>Whenever an application becomes more complex and includes third-party frameworks, all kinds of error types need to be taken care of <em>consistently </em>without having a condition for each one. For example, a web service's large range of possible errors can bubble up to the handler where they need to be translated into HTTP codes with informative messages. These expected errors can range from parser errors to invalid authentication details, failed database connections, or an application-specific error with an error code. In this recipe, we'll cover how to deal with this variety of errors using wrappers.</p>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's create an error wrapper in a few steps:</p>
<ol>
<li>Open the project you created with <kbd>cargo new multiple-errors</kbd> with VS Code.</li>
<li>Open <kbd>src/main.rs</kbd> to and add some imports at the top:</li>
</ol>
<pre style="padding-left: 60px">use std::fmt;<br/>use std::io;<br/>use std::error::Error;</pre>
<ol start="3">
<li>In our application, we will deal with three user-defined errors. Let's declare them right after the imports:</li>
</ol>
<pre style="padding-left: 60px">#[derive(Debug)]<br/>pub struct InvalidDeviceIdError(usize);<br/>#[derive(Debug)]<br/>pub struct DeviceNotPresentError(usize);<br/>#[derive(Debug)]<br/>pub struct UnexpectedDeviceStateError {}</pre>
<ol start="4">
<li>Now for the wrapper: since we are dealing with multiple variations of something, <kbd>enum</kbd> will fit the purpose perfectly:</li>
</ol>
<pre style="padding-left: 60px"><br/>#[derive(Debug)]<br/>pub enum ErrorWrapper {<br/>    Io(io::Error),<br/>    Db(InvalidDeviceIdError),<br/>    Device(DeviceNotPresentError), <br/>    Agent(UnexpectedDeviceStateError)<br/>}</pre>
<ol start="5">
<li>However, it would be nice to have the same interface as other errors, so let's implement the <kbd>std::error::Error</kbd> trait:</li>
</ol>
<pre style="padding-left: 60px">impl Error for ErrorWrapper {<br/>    fn description(&amp;self) -&gt; &amp;str {<br/>        match *self {<br/>            ErrorWrapper::Io(ref e) =&gt; e.description(),<br/>            ErrorWrapper::Db(_) | ErrorWrapper::Device(_) =&gt; "No <br/>             device present with this id, check formatting.",<br/>            _ =&gt; "Unexpected error. Sorry for the inconvenience."<br/>        }<br/>    }<br/>}</pre>
<ol start="6">
<li>The trait makes it necessary to implement <kbd>std::fmt::Display</kbd> as well, so this will be the next <kbd>impl</kbd> block:</li>
</ol>
<pre style="padding-left: 60px">impl fmt::Display for ErrorWrapper {<br/>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {<br/>        match *self {<br/>            ErrorWrapper::Io(ref e) =&gt; write!(f, "{} [{}]", e, <br/>                self.description()), <br/>            ErrorWrapper::Db(ref e) =&gt; write!(f, "Device with id \"<br/>             {}\" not found [{}]", e.0, self.description()),<br/>            ErrorWrapper::Device(ref e) =&gt; write!(f, "Device with<br/>             id\"{}\" is currently unavailable [{}]", e.0,         <br/>             self.description()),<br/>            ErrorWrapper::Agent(_) =&gt; write!(f, "Unexpected device <br/>             state [{}]", self.description())<br/>        }<br/>    }<br/>}</pre>
<ol start="7">
<li>Now, we want to see the results of our labor. Replace the existing <kbd>main</kbd> function as follows:</li>
</ol>
<pre style="padding-left: 60px">fn main() {<br/>    println!("{}",     <br/>    ErrorWrapper::Io(io::Error::from(io::ErrorKind::InvalidData)));<br/>    println!("{}", ErrorWrapper::Db(InvalidDeviceIdError(42)));<br/>    println!("{}", ErrorWrapper::Device<br/>     (DeviceNotPresentError(42)));<br/>    println!("{}", ErrorWrapper::Agent(UnexpectedDeviceStateError <br/>{}));<br/>}</pre>
<ol start="8">
<li>Finally, we execute <kbd>cargo run</kbd> to see that the output matches what we expected before:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/> Compiling multiple-errors v0.1.0 (Rust-Cookbook/Chapter05<br/> /multiple-errors)<br/> Finished dev [unoptimized + debuginfo] target(s) in 0.34s<br/> Running `target/debug/multiple-errors`<br/>invalid data [invalid data]<br/>Device with id "42" not found [No device present with this id, check formatting.]<br/>Device with id "42" is currently unavailable [No device present with this id, check formatting.]<br/>Unexpected device state [Unexpected error. Sorry for the inconvenience.]</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Multiple errors may not seem much of an issue at first, but for a clean, readable architecture, it is necessary to address them somehow. An enum that wraps possible variants has been shown to be the most practical solution, and, by implementing <kbd>std::error::Error</kbd> (and the <kbd>std::fmt::Display</kbd> requirement), the handling of the new error type should be seamless. In <em>steps 3</em> to<em> 6</em>, we show an example implementation of the required traits in a reductionist fashion. <em>Step 7</em> shows how to use the wrapping enum and how to use the <kbd>Display</kbd> and <kbd>Error</kbd> implementations to help match the variants.</p>
<p>Implementing the <kbd>Error</kbd> trait will allow interesting aspects in the future, including recursive nesting. Check the documentation at <a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.source">https://doc.rust-lang.org/std/error/trait.Error.html#method.source</a> to find out more. Typically, we would not create these error variants themselves if we can avoid it, which is why there are supportive crates taking care of all of the boilerplate code—we'll cover that in a different recipe in this chapter.</p>
<p>Let's move on to the next recipe to complement our newfound skills in handling multiple errors!</p>


            

            
        
    </div>
<div><h1 class="header-title">Working with exceptional results</h1>
                
            
            
                
<p>Other than the <kbd>Option</kbd> type, a <kbd>Result</kbd> type can have two custom types, which means that <kbd>Result</kbd> provides additional information about the cause of the error. This is more expressive than returning <kbd>Option</kbd>, which returns a single type instance or <kbd>None</kbd>. However, this <kbd>None</kbd> instance can mean anything from <em>failure to process</em> to <em>wrong input</em>. This way, the <kbd>Result</kbd> type can be seen as a similar system as exceptions in other languages, but they are part of the regular workflow of a program. One example is a search, where a multitude of scenarios can happen: </p>
<ul>
<li>The desired value is found.</li>
<li>The desired value is not found.</li>
<li>The collection was invalid.</li>
<li>The value was invalid.</li>
</ul>
<p>How can you use the <kbd>Result</kbd> type effectively? Let's find out in this recipe!</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Here are some steps for working with <kbd>Result</kbd> and <kbd>Option</kbd>:</p>
<ol>
<li>Create a new project with <kbd>cargo new exceptional-results --lib</kbd> and open it with VS Code. </li>
<li>Open <kbd>src/lib.rs</kbd> and add a function before the <kbd>test</kbd> module:</li>
</ol>
<pre style="padding-left: 60px">/// <br/>/// Finds a needle in a haystack, returns -1 on error <br/>/// <br/>pub fn bad_practice_find(needle: &amp;str, haystack: &amp;str) -&gt; i32 {<br/>    haystack.find(needle).map(|p| p as i32).unwrap_or(-1)<br/>}</pre>
<ol start="3">
<li>As the name suggests, this is not the best way to communicate failure in Rust. What is a better way, though? One answer is to utilize the <kbd>Option</kbd> enum. Add another function underneath the first one:</li>
</ol>
<pre style="padding-left: 60px">/// <br/>/// Finds a needle in a haystack, returns None on error <br/>/// <br/>pub fn better_find(needle: &amp;str, haystack: &amp;str) -&gt; Option&lt;usize&gt; {<br/>    haystack.find(needle)<br/>}</pre>
<ol start="4">
<li>This makes it possible to reason about the expected return values, but Rust allows a more expressive variation—such as the <kbd>Result</kbd> type. Add the following to the current collection of functions:</li>
</ol>
<pre style="padding-left: 60px">#[derive(Debug, PartialEq)]<br/>pub enum FindError {<br/>    EmptyNeedle,<br/>    EmptyHaystack,<br/>    NotFound,<br/>}<br/><br/>/// <br/>/// Finds a needle in a haystack, returns a proper Result <br/>/// <br/>pub fn best_find(needle: &amp;str, haystack: &amp;str) -&gt; Result&lt;usize, FindError&gt; {<br/>    if needle.len() &lt;= 0 {<br/>        Err(FindError::EmptyNeedle)<br/>    } else if haystack.len() &lt;= 0 {<br/>        Err(FindError::EmptyHaystack)<br/>    } else {<br/>        haystack.find(needle).map_or(Err(FindError::NotFound), |n| <br/>    Ok(n))<br/>    }<br/>}</pre>
<ol start="5">
<li>Now that we implemented a few variations of the same function, let's test them. For the first function, add the following to the <kbd>test</kbd> module and replace the existing (default) test:</li>
</ol>
<pre>    use super::*;<br/><br/>    #[test]<br/>    fn test_bad_practice() {<br/>        assert_eq!(bad_practice_find("a", "hello world"), -1);<br/>        assert_eq!(bad_practice_find("e", "hello world"), 1);<br/>        assert_eq!(bad_practice_find("", "hello world"), 0);<br/>        assert_eq!(bad_practice_find("a", ""), -1);<br/>    }</pre>
<ol start="6">
<li>The other test functions look very similar. To have consistent outcomes and show the differences between the return types, add these to the <kbd>test</kbd> module:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn test_better_practice() {<br/>        assert_eq!(better_find("a", "hello world"), None);<br/>        assert_eq!(better_find("e", "hello world"), Some(1));<br/>        assert_eq!(better_find("", "hello world"), Some(0)); <br/>        assert_eq!(better_find("a", ""), None); <br/>    }<br/><br/>    #[test]<br/>    fn test_best_practice() {<br/>        assert_eq!(best_find("a", "hello world"), <br/>        Err(FindError::NotFound));<br/>        assert_eq!(best_find("e", "hello world"), Ok(1));<br/>        assert_eq!(best_find("", "hello world"), <br/>        Err(FindError::EmptyNeedle));<br/>        assert_eq!(best_find("e", ""), <br/>        Err(FindError::EmptyHaystack)); <br/>    }</pre>
<p class="mce-root"/>
<ol start="7">
<li>Let's run <kbd>cargo test</kbd> to see the test results:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>Compiling exceptional-results v0.1.0 (Rust-Cookbook/Chapter05<br/> /exceptional-results)<br/>Finished dev [unoptimized + debuginfo] target(s) in 0.53s<br/>Running target/debug/deps/exceptional_results-97ca0d7b67ae4b8b<br/><br/>running 3 tests<br/>test tests::test_best_practice ... ok<br/>test tests::test_bad_practice ... ok<br/>test tests::test_better_practice ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests exceptional-results<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Now, let's see what's behind the scenes to understand the code better.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">Rust and many other programming languages use the <kbd>Result</kbd> type to communicate multiple function outcomes at once. This way, the function can return just as it was designed without (unexpected) jumps such as the exception mechanism. </p>
<p>In <em>step 3</em> of this recipe, we show one way of communicating errors that is common in other languages (for example, Java)—however, as we can see in the test (<em>step 6</em>), the outcome for an empty string is unexpected (<kbd>0</kbd> instead of <kbd>-1</kbd>). In <em>step 3</em>, we define a better return type, but is it enough? No, it isn't. In <em>step 4</em>, we implement the best version of the function where each <kbd>Result</kbd> type is easy to interpret and clearly defined.</p>
<p>One even greater example of how to use <kbd>Result</kbd> can be found in the standard library. It's the <kbd>quick_search</kbd> function on the <kbd>slice</kbd> trait, which returns <kbd>Ok()</kbd> with the position that it found the item in and <kbd>Err()</kbd> with the position that the item should have been found at. Check out the documentation at <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search">https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search</a> for more details.</p>
<p>Others will love your expressive APIs once you master using multiple <kbd>Result</kbd> and <kbd>Option</kbd> types to communicate beyond success and failure. Keep learning by moving on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Seamless error handling</h1>
                
            
            
                
<p>Exceptions represent a special case in many programs: they have their own execution path and the program can jump into this path any time. Is this ideal, though? This depends on the size of the <kbd>try</kbd> block (or whatever the name); this might cover several statements and debugging a runtime exception stops being fun quickly. A better way to achieve safe error handling could be to integrate errors in the results of a function call—a practice that can already be seen in C functions where the parameters do the data transfer and the return code indicates success/failure. Newer, more functional paradigms suggest something akin to the <kbd>Result</kbd> type in Rust—which comes with functions to elegantly deal with the various outcomes. This makes the errors an expected outcome of a function and enables smooth error handling without additional <kbd>if</kbd> conditions for every call.</p>
<p>In this recipe, we'll go over several methods to work with errors seamlessly.  </p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's go through some steps to handle errors seamlessly:</p>
<ol>
<li>Create a new project with <kbd>cargo new exceptional-results --lib</kbd> and open it with VS Code.</li>
<li>Open <kbd>src/lib.rs</kbd> and replace the existing test with a new test:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn positive_results() {<br/>       // code goes here<br/>    }</pre>
<ol start="3">
<li>As the name suggests, we'll add some positive result tests in the function's body. Let's start with a declaration and something simple. Replace the preceding <kbd>// code goes here</kbd> section with the following:</li>
</ol>
<pre>        let ok: Result&lt;i32, f32&gt; = Ok(42);<br/><br/>        assert_eq!(ok.and_then(|r| Ok(r + 1)), Ok(43));<br/>        assert_eq!(ok.map(|r| r + 1), Ok(43));</pre>
<ol start="4">
<li>Let's add some more variation since multiple <kbd>Result</kbd> types can behave just like Booleans. Add some more code into the <kbd>good_results</kbd> test:</li>
</ol>
<pre style="padding-left: 60px">        // Boolean operations with Results. Take a close look at <br/>        // what's returned<br/>        assert_eq!(ok.and(Ok(43)), Ok(43));<br/>        let err: Result&lt;i32, f32&gt; = Err(-42.0);<br/>        assert_eq!(ok.and(err), err);<br/>        assert_eq!(ok.or(err), ok);</pre>
<ol start="5">
<li>However, where there are good results, bad results may happen too! In the case of the <kbd>Result</kbd> type, it is about the <kbd>Err</kbd> variant. Add another empty test called <kbd>negative_results</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn negative_results() {<br/>        // code goes here<br/>    }</pre>
<ol start="6">
<li>Just like before, we are replacing the <kbd>//code goes here</kbd> comment with some actual tests:</li>
</ol>
<pre style="padding-left: 60px">        let err: Result&lt;i32, f32&gt; = Err(-42.0);<br/>        let ok: Result&lt;i32, f32&gt; = Ok(-41);<br/><br/>        assert_eq!(err.or_else(|r| Ok(r as i32 + 1)), ok);<br/>        assert_eq!(err.map(|r| r + 1), Err(-42.0));<br/>        assert_eq!(err.map_err(|r| r + 1.0), Err(-41.0));</pre>
<ol start="7">
<li>Other than the positive results, the negative results often have their own functions such as <kbd>map_err</kbd>. Contrary to that, the Boolean functions behave consistently and treat the <kbd>Err</kbd> result as false. Add the following to the <kbd>negative_results</kbd> test:</li>
</ol>
<pre style="padding-left: 60px">        let err2: Result&lt;i32, f32&gt; = Err(43.0);<br/>        let ok: Result&lt;i32, f32&gt; = Ok(42);<br/>        assert_eq!(err.and(err2), err);<br/>        assert_eq!(err.and(ok), err);<br/>        assert_eq!(err.or(ok), ok);</pre>
<ol start="8">
<li>As the last step, we run <kbd>cargo test</kbd> to see the test results:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/> Compiling seamless-errors v0.1.0 (Rust-Cookbook/Chapter05<br/>  /seamless-errors)<br/> Finished dev [unoptimized + debuginfo] target(s) in 0.37s<br/> Running target/debug/deps/seamless_errors-7a2931598a808519<br/><br/>running 2 tests<br/>test tests::positive_results ... ok<br/>test tests::negative_results ... ok<br/><br/>test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests seamless-errors<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Do you want to know more? Keep reading to find out how it works.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>Result</kbd> type is important for creating code that integrates all of the possible function outcomes into the regular workflow. This eliminates the need for special handling of exceptions, making the code less verbose and easier to reason about. Since these types are known beforehand, the library can offer specialized functions as well, which is what we are looking at in this recipe. </p>
<p>In the first few steps (<em>step 2</em> to <em>step 4</em>), we are working with positive results, which means values that are wrapped in the <kbd>Ok</kbd> enum variant. First, we covered the <kbd>and_then</kbd> function, which provides chaining of various functions that should only be executed when the initial <kbd>Result</kbd> is <kbd>Ok</kbd>. In the case of an <kbd>Err</kbd> return value of one of the functions in the chain, the <kbd>Err</kbd> result is passed through, skipping the positive handlers (such as <kbd>and_then</kbd> and <kbd>map</kbd>). Similarly, <kbd>map()</kbd> allows transformation within the <kbd>Result</kbd> type. Both <kbd>map</kbd> and <kbd>and_then</kbd> only make it possible to transform <kbd>Result&lt;i32, i32&gt;</kbd> into <kbd>Result&lt;MyOwnType, i32&gt;</kbd> but not <kbd>MyOwnType</kbd> alone. Lastly, the test covers Boolean operations with the multiple <kbd>Result</kbd> types summarized in this table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 14.6176%"><strong>A</strong></td>
<td style="width: 17.0378%"><strong>B</strong></td>
<td style="width: 20.4259%"><strong>A and B</strong></td>
</tr>
<tr>
<td style="width: 14.6176%"><kbd>Ok</kbd></td>
<td style="width: 17.0378%"><kbd>Ok</kbd></td>
<td style="width: 20.4259%"><kbd>Ok</kbd> (B)</td>
</tr>
<tr>
<td style="width: 14.6176%"><kbd>Ok</kbd></td>
<td style="width: 17.0378%"><kbd>Err</kbd></td>
<td style="width: 20.4259%"><kbd>Err</kbd></td>
</tr>
<tr>
<td style="width: 14.6176%"><kbd>Err</kbd></td>
<td style="width: 17.0378%"><kbd>Ok</kbd></td>
<td style="width: 20.4259%"><kbd>Err</kbd> </td>
</tr>
<tr>
<td style="width: 14.6176%"><kbd>Err</kbd></td>
<td style="width: 17.0378%"><kbd>Err</kbd></td>
<td style="width: 20.4259%"><kbd>Err</kbd> (A)</td>
</tr>
<tr>
<td style="width: 14.6176%"><kbd>Ok</kbd></td>
<td style="width: 17.0378%"><kbd>Ok</kbd></td>
<td style="width: 20.4259%"><kbd>Ok</kbd> (A)</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p>The remaining steps (<em>step 5</em> to <em>step 7</em>) show the same process with a negative result type: <kbd>Err</kbd>. In the same manner that <kbd>map()</kbd> handles only <kbd>Ok</kbd> results, <kbd>map_err()</kbd> transforms <kbd>Err</kbd>. A special case of that is the <kbd>or_else()</kbd> function, which executes the provided closure whenever <kbd>Err</kbd> was returned. The last parts of the test cover the Boolean functions of multiple <kbd>Result</kbd> types and show how they work with various <kbd>Err</kbd> parameters.</p>
<p>Now that we have seen many different variations of working with <kbd>Ok</kbd> and <kbd>Err</kbd>, let's move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Customizing errors</h1>
                
            
            
                
<p>While the <kbd>Result</kbd> type doesn't care about the type it returns in the <kbd>Err</kbd> branch, returning <kbd>String</kbd> instances for error messages is not ideal either. Typical errors have several things to consider: </p>
<ul>
<li>Is there a root cause or error?</li>
<li>What is the error message?</li>
<li>Is there a more in-depth message to output?</li>
</ul>
<p>The standard library's errors all follow a common trait from <kbd>std::error::Error</kbd>—let's see how they are implemented.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Defining error types is not hard—just follow these steps:</p>
<ol>
<li>Create a new project with <kbd>cargo new custom-errors</kbd> and open it with VS Code. </li>
<li>Using VS Code, open <kbd>src/main.rs</kbd> and create a basic struct called <kbd>MyError</kbd>:</li>
</ol>
<pre style="padding-left: 60px">use std::fmt;<br/>use std::error::Error;<br/><br/>#[derive(Debug)]<br/>pub struct MyError {<br/>    code: usize,<br/>}</pre>
<ol start="3">
<li>There is an <kbd>Error</kbd> trait that we can implement, as follows:</li>
</ol>
<pre style="padding-left: 60px">impl Error for MyError {<br/>    fn description(&amp;self) -&gt; &amp;str {<br/>        "Occurs when someone makes a mistake"<br/> }<br/>}</pre>
<ol start="4">
<li>However, the trait also requires us (next to <kbd>Debug</kbd>—which we derived) to implement <kbd>std::fmt::Display</kbd>: </li>
</ol>
<pre style="padding-left: 60px">impl fmt::Display for MyError {<br/>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {<br/>       write!(f, "Error code {:#X}", self.code) <br/>    }<br/>}</pre>
<ol start="5">
<li>Lastly, let's see these traits in action and replace the <kbd>main</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fn main() {<br/>    println!("Display: {}", MyError{ code: 1535 });<br/>    println!("Debug: {:?}", MyError{ code: 42 });<br/>    println!("Description: {:?}", (MyError{ code: 42 <br/>    }).description());<br/>}</pre>
<ol start="6">
<li>Then, we can see everything work together using <kbd>cargo run</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>Compiling custom-errors v0.1.0 (Rust-Cookbook/Chapter05/custom-errors)<br/> Finished dev [unoptimized + debuginfo] target(s) in 0.23s<br/> Running `target/debug/custom-errors`<br/>Display: Error code 0x5FF<br/>Debug: MyError { code: 42 }<br/>Description: "Occurs when someone makes a mistake"</pre>
<p>Let's see whether we can get behind the scenes of this short recipe.</p>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Although any type will work just fine in a <kbd>Result</kbd> arm, Rust offers an error trait that can be implemented for better integration into other crates. An example of that is the <kbd>actix_web</kbd> framework's error handling (<a href="https://actix.rs/docs/errors/">https://actix.rs/docs/errors/</a>) that works with <kbd>std::error::Error</kbd> as well as with its own types (we will look at that in more depth in <a href="e90b9507-b016-4a88-aefa-54e710617d96.xhtml">Chapter 8</a>, <em>Safe Programming for the Web</em>).</p>
<p>In addition to that, the <kbd>Error</kbd> trait also offers nesting, and, using dynamic dispatch, all <kbd>Errors</kbd> can follow a common API. In <em>step 2</em>, we declare the type and derive the (mandatory) <kbd>Debug</kbd> trait. In <em>step 3</em> and <em>step 4</em>, the remaining implementations follow. The rest of the recipe executes the code. </p>
<p>In this short and sweet recipe, we can create custom error types. Now, let's move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Resilient programming</h1>
                
            
            
                
<p>Returning <kbd>Result</kbd> or <kbd>Option</kbd> will always follow a certain pattern that generates a lot of boilerplate code—especially for uncertain operations such as reading or creating files and searching for values. In particular, the pattern produces either code that uses early returns a lot (remember <kbd>goto</kbd>?) or nested statements, both of which produce code that is hard to reason about. Therefore, early versions of the Rust library implemented a <kbd>try!</kbd> macro, which has been replaced with the <kbd>?</kbd> operator as a quick early return option. Let's see how that influences the code. </p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to write more resilient programs:</p>
<ol>
<li>Create a new project with <kbd>cargo new resilient-programming</kbd> and open it with VS Code. </li>
<li>Open <kbd>src/main.rs</kbd> to add a function:</li>
</ol>
<pre style="padding-left: 60px">use std::fs;<br/>use std::io;<br/><br/>fn print_file_contents_qm(filename: &amp;str) -&gt; Result&lt;(), io::Error&gt; {<br/>    let contents = fs::read_to_string(filename)?;<br/>    println!("File contents, external fn: {:?}", contents);<br/>    Ok(())<br/>}</pre>
<ol start="3">
<li>The preceding function prints the file contents if it finds the file; in addition to that, we have to call this function. For that, replace the existing <kbd>main</kbd> function with this:</li>
</ol>
<pre style="padding-left: 60px">fn main() -&gt; Result&lt;(), std::io::Error&gt; {<br/>    println!("Ok: {:?}", print_file_contents_qm("testfile.txt"));<br/>    println!("Err: {:?}", print_file_contents_qm("not-a-file"));<br/>    <br/>    let contents = fs::read_to_string("testfile.txt")?;<br/>    println!("File contents, main fn: {:?}", contents);<br/>    Ok(())<br/>}</pre>
<ol start="4">
<li>That's it—run <kbd>cargo run</kbd> to find out what the results are:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/> Compiling resilient-programming v0.1.0 (Rust-Cookbook/Chapter05<br/>  /resilient-programming)<br/> Finished dev [unoptimized + debuginfo] target(s) in 0.21s<br/> Running `target/debug/resilient-programming`<br/>File contents, external fn: "Hello World!"<br/>Ok: Ok(())<br/>Err: Err(Os { code: 2, kind: NotFound, message: "No such file or directory" })<br/>File contents, main fn: "Hello World!"</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In these four steps, we saw the use of the question mark operator and how it can avoid the boilerplate typically associated with guards. In <em>step 3</em>, we create a function that prints the file contents if the file has been found (and was readable), and, by using the <kbd>?</kbd> operator, we can skip checking the return value and exiting the function if necessary—it's all done with a simple <kbd>?</kbd> operator. </p>
<p>In <em>step 4</em>, we not only call the previously created function, but we are also printing the result to show how it works. On top of that, the same pattern is applied to the (special) <kbd>main</kbd> function, which now has a return value. Therefore, <kbd>?</kbd> is not limited to sub-functions but can be applied throughout the application.  </p>
<p>In just a few simple steps, we have seen how to use the <kbd>?</kbd> operator to unwrap <kbd>Result</kbd> safely. Now, let's move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Working with external crates for error handling</h1>
                
            
            
                
<p>Creating and wrapping errors is a common task in modern programs. However, as we have seen in various recipes in this chapter, it can be quite tedious to handle every possible case and, on top of that, care about each possible variation that might be returned. This problem is well known and the Rust community has come up with ways to make that a lot easier. We'll touch on macros in the next chapter (<a href="a8fae7de-6021-4d6e-9c75-e24288bc92e7.xhtml">Chapter 6</a>, <em>Expressing Yourself with Macros</em>), but creating error types leans a lot on using macros. Additionally, this recipe mirrors a previous recipe (<em>Handling multiple errors</em>) to show the differences in code.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's pull in some external crates to handle errors better in just a few steps:</p>
<ol>
<li>Create a new project with <kbd>cargo new external-crates</kbd> and open it with VS Code. </li>
<li>Edit <kbd>Cargo.toml</kbd> to add the <kbd>quick-error</kbd> dependency:</li>
</ol>
<pre style="padding-left: 60px">[dependencies]<br/>quick-error = "1.2"</pre>
<ol start="3">
<li>To use the provided macros in <kbd>quick-error</kbd>, we need to import them explicitly. Add the following <kbd>use</kbd> statements to <kbd>src/main.rs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#[macro_use] extern crate quick_error;<br/><br/>use std::convert::From;<br/>use std::io;</pre>
<ol start="4">
<li>In one step, we are then going to add all of the errors we want to declare inside the <kbd>quick_error!</kbd> macro:</li>
</ol>
<pre style="padding-left: 60px">quick_error! {<br/>    #[derive(Debug)]<br/>    pub enum ErrorWrapper {<br/>        InvalidDeviceIdError(device_id: usize) {<br/>            from(device_id: usize) -&gt; (device_id)<br/>            description("No device present with this id, check <br/>            formatting.")<br/>        }<br/><br/>        DeviceNotPresentError(device_id: usize) {<br/>            display("Device with id \"{}\" not found", device_id)<br/>        }<br/><br/>        UnexpectedDeviceStateError {}<br/><br/>        Io(err: io::Error) {<br/>            from(kind: io::ErrorKind) -&gt; (io::Error::from(kind))<br/>            description(err.description())<br/>            display("I/O Error: {}", err)<br/>        } <br/>    }<br/>}</pre>
<ol start="5">
<li>The code is only complete when the <kbd>main</kbd> function is added as well:</li>
</ol>
<pre style="padding-left: 60px">fn main() {<br/>    println!("(IOError) {}", <br/>    ErrorWrapper::from(io::ErrorKind::InvalidData));<br/>    println!("(InvalidDeviceIdError) {}", <br/>    ErrorWrapper::InvalidDeviceIdError(42));<br/>    println!("(DeviceNotPresentError) {}", <br/>    ErrorWrapper::DeviceNotPresentError(42));<br/>    println!("(UnexpectedDeviceStateError) {}", <br/>    ErrorWrapper::UnexpectedDeviceStateError {});<br/>}</pre>
<ol start="6">
<li>Use <kbd>cargo run</kbd> to find the output of the program:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/> Compiling external-crates v0.1.0 (Rust-Cookbook/Chapter05<br/>  /external-crates)<br/> Finished dev [unoptimized + debuginfo] target(s) in 0.27s<br/>  Running `target/debug/external-crates`<br/>(IOError) I/O Error: invalid data<br/>(InvalidDeviceIdError) No device present with this id, check formatting.<br/>(DeviceNotPresentError) Device with id "42" not found<br/>(UnexpectedDeviceStateError) UnexpectedDeviceStateError</pre>
<p>Did you understand the code? Let's find out how it works.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Compared to the previous recipe where we declared multiple errors, this declaration is much shorter and has several added benefits. The first benefit is that each error type can be created using the <kbd>From</kbd> trait (first <kbd>IOError</kbd> in <em>step 4</em>). Secondly, each type generates an automated description and <kbd>Display</kbd> implementation (see <em>step 3,</em> <kbd>UnexpectedDeviceStateError</kbd>, and then <em>step 5</em>) with the error's name. This is not perfect, but OK as a first step.</p>
<p>Under the hood, <kbd>quick-error</kbd> generates one enum that handles all possible cases and generates the implementations if necessary. Check out the <kbd>main</kbd> macro—quite impressive (<a href="http://tailhook.github.io/quick-error/quick_error/macro.quick_error.html">http://tailhook.github.io/quick-error/quick_error/macro.quick_error.html</a>)! To tailor the use of <kbd>quick-error</kbd> to your needs, check out the rest of their documentation at <a href="http://tailhook.github.io/quick-error/quick_error/index.html">http://tailhook.github.io/quick-error/quick_error/index.html</a>. Alternatively, there is the <kbd>error-chain</kbd> crate (<a href="https://github.com/rust-lang-nursery/error-chain">https://github.com/rust-lang-nursery/error-chain</a>), which takes a different approach to create those error types. Either of these options lets you vastly improve the readability and implementation speed of your errors while removing all of the boilerplate code. </p>
<p>We've successfully learned how to improve our error handling by using external crates. Now, let's move on to the next recipe.</p>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">Moving between Option and Result</h1>
                
            
            
                
<p>Whenever a binary result is to be returned from a function, the choice is between using <kbd>Result</kbd> or <kbd>Option</kbd>. Both can communicate a failed function call—but the former provides too much specificity, while the latter may give too little. While this is a decision to make for the specific situation, Rust's types provide the tools to move between them with ease. Let's go over them in this recipe.  </p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In a few quick steps, you'll know how to move between <kbd>Option</kbd> and <kbd>Result</kbd>:</p>
<ol>
<li>Create a new project with <kbd>cargo new options-results --lib</kbd> and open it with VS Code. </li>
<li>Let's edit <kbd>src/lib.rs</kbd> and replace the existing test (inside <kbd>mod tests</kbd>) with the following:</li>
</ol>
<pre style="padding-left: 60px">    #[derive(Debug, Eq, PartialEq, Copy, Clone)]<br/>    struct MyError;<br/><br/>    #[test]<br/>    fn transposing() {<br/>        // code will follow<br/>    }</pre>
<ol start="3">
<li>We have to replace <kbd>// code will follow</kbd> with an example of how to use the <kbd>transpose()</kbd> function: </li>
</ol>
<pre>        let this: Result&lt;Option&lt;i32&gt;, MyError&gt; = Ok(Some(42));<br/>        let other: Option&lt;Result&lt;i32, MyError&gt;&gt; = Some(Ok(42));<br/>        assert_eq!(this, other.transpose());</pre>
<ol start="4">
<li>This works with <kbd>Err</kbd> as well and, for proof, add this to the <kbd>transpose()</kbd> test:</li>
</ol>
<pre>        let this: Result&lt;Option&lt;i32&gt;, MyError&gt; = Err(MyError);<br/>        let other: Option&lt;Result&lt;i32, MyError&gt;&gt; = Some(Err(MyError));<br/>        assert_eq!(this, other.transpose());</pre>
<ol start="5">
<li>What's left is the special case of <kbd>None</kbd>. Complete the <kbd>transpose()</kbd> test with this:</li>
</ol>
<pre style="padding-left: 60px">assert_eq!(None::&lt;Result&lt;i32, MyError&gt;&gt;.transpose(), Ok(None::<br/> &lt;i32&gt;));</pre>
<ol start="6">
<li>Moving between the two types is not only about transposing—there are more complex ways to do that too. Create another <kbd>test</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn conversion() {<br/>        // more to follow<br/>    }</pre>
<ol start="7">
<li>As a first test, let's replace <kbd>// more to follow</kbd> with something that can be used instead of <kbd>unwrap()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">        let opt = Some(42);<br/>        assert_eq!(opt.ok_or(MyError), Ok(42));<br/><br/>        let res: Result&lt;i32, MyError&gt; = Ok(42);<br/>        assert_eq!(res.ok(), opt);<br/>        assert_eq!(res.err(), None);</pre>
<ol start="8">
<li>To complete the conversion test, also add the following to <kbd>test</kbd>. These are conversions but from the <kbd>Err</kbd> side:</li>
</ol>
<pre style="padding-left: 60px">        let opt: Option&lt;i32&gt; = None;<br/>        assert_eq!(opt.ok_or(MyError), Err(MyError));<br/><br/>        let res: Result&lt;i32, MyError&gt; = Err(MyError);<br/>        assert_eq!(res.ok(), None);<br/>        assert_eq!(res.err(), Some(MyError));</pre>
<ol start="9">
<li>Lastly, we should run the code using <kbd>cargo test</kbd> and see successful test results:</li>
</ol>
<pre style="padding-left: 60px">$ cargo test<br/>Compiling options-results v0.1.0 (Rust-Cookbook/Chapter05/options-results)<br/> Finished dev [unoptimized + debuginfo] target(s) in 0.44s<br/> Running target/debug/deps/options_results-111cad5a9a9f6792<br/><br/>running 2 tests<br/>test tests::conversion ... ok<br/>test tests::transposing ... ok<br/><br/>test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests options-results<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>While the discussion of when to use <kbd>Option</kbd> and when to use <kbd>Result</kbd> takes place on a high level, Rust supports the transition between the two types with several functions. In addition to <kbd>map()</kbd>, <kbd>and_then()</kbd>, and so on (discussed in the <em>Seamless error handling</em> section in this chapter), these functions provide powerful and elegant ways to work with a variety of errors. In <em>step 1</em> to <em>step 4,</em> we are slowly building a simple test that shows the applicability of the transpose function. It makes it possible to switch from <kbd>Ok(Some(42))</kbd> to <kbd>Some(Ok(42))</kbd> (notice the subtle difference) with a single call to a function. Similarly, the <kbd>Err</kbd> variation of the call goes from a regular <kbd>Err(MyError)</kbd> function to <kbd>Some(Err(MyError))</kbd>. </p>
<p>The remaining steps (<em>step 6</em> to <em>step 8</em>) show more traditional ways to convert between the two types. These include fetching the values of <kbd>Ok</kbd> and <kbd>Err</kbd>, as well as providing an error instance for positive results. In general, these functions should be enough to replace most <kbd>unwrap()</kbd> or <kbd>expect()</kbd> calls and have a single execution path through the program without having to resort to <kbd>if</kbd> and <kbd>match</kbd> conditionals. This adds the bonus of robustness and readability, and your future colleagues and users will thank you!</p>


            

            
        
    </div></body></html>