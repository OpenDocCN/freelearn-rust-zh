- en: '*Chapter 5*: Understanding Sections in WebAssembly Modules'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A WebAssembly module is composed of zero or more sections. Each section has
    its own functionality. In the previous chapters, we saw how functions are defined
    inside a WebAssembly module. A function is a section inside a WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the various other sections inside a WebAssembly
    module. Understanding the various sections inside a WebAssembly module will make
    it easier for us to identify, debug, and write efficient WebAssembly modules.
    We will cover the following sections in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exports and imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Globals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/05-wasm-sections](https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/05-wasm-sections).
  prefs: []
  type: TYPE_NORMAL
- en: Exports and imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A WebAssembly module consists of export and import sections. These sections
    are responsible for exporting functions out of and importing functions into the
    WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: Exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to call the functions defined in a WebAssembly module from JavaScript,
    we need to export the functions from the WebAssembly module. The export section
    is where we will define all the functions that are exported out of the WebAssembly
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our classic `add.wat` example from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have exported the `add` function using the `(export "add" (func $add))`
    statement. To export a function, we have used the `export` keyword followed by
    the name of the function and then the pointer to the exported function itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that WebAssembly is compact-sized. Thus, we can represent the export
    statement along with the function definition itself, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use WABT''s `wat2wasm` tool to convert the WebAssembly text format into
    a WebAssembly module with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the generated byte code using the `hexdump` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the first byte consists of the magic header and version of the
    binary `00 61 73 6d 01 00 00 00`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next bit is `01`, which represents the section index of the type section.
    Following that, we have the size of the type section, which is `07`. The next
    seven bits are the type section. `01` represents the number of type definitions
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have `60`, which represents `func`. Following that, we have `02`,
    representing the two parameters. `7f` is the opcode for defining the i32 type.
    Since both the parameters are i32, we have consecutive `7f` opcodes. Following
    that, the last two bits represent the return type and there is also `7f` representing
    i32:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `type` section, we have the `func` section. The unique identifier
    for the `func` section is `03`. Following that, we have `02`, which defines the
    size of the function section. That is the size of the function section is just
    2 bits. But we defined the function definition for `add` in the WebAssembly text
    format and the function is more than 2 bits in size. So, how is it possible? The
    reason is that the function section does not have the body of the function; instead,
    it just defines the available functions. The functions are defined in the code
    section. The next `01` defines that there is only one function defined in the
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the export section, which starts with `07`. The next `07` represents
    the size of the export section. Then, we define the number of exports exported
    in the export section. The next bit represents the length of the exported function
    name. The next `03` bits represent the function name, `add`. Then, the export
    section has the kind of export and function index of the exported function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The last segment starts with `0a`. `0a` is a unique identifier for the code
    section. The code section is of length `09`. Next, `01` represents the number
    of functions defined in the code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `07` represents the length of the function definition. The next seven
    bits actually define the function block. `00` indicates that the function block
    does not have any local declarations. `20` is the opcode for `get_local` and we
    take the `00` index, and then again we have `20` opcode to `get_local` and we
    take the `01` index. Then, we add them using `i32.add`. The opcode for the i32
    addition is `6a`. Finally, we use `0b` to end the function code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have seen how the export section is represented in a WebAssembly module.
    In the next section, let's see how the import section is represented in a WebAssembly
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to import a function from another WebAssembly module or JavaScript
    module, we need to import the functions in the WebAssembly module. The import
    section is where we will import all the external dependencies into the WebAssembly
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s imagine that a JavaScript module exports a function named `jsAdd`.
    We can import the `jsAdd` function using the `import` keyword. Create a file called
    `jsAdd.wat` and add the following content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are defining a function with the `func` keyword, followed by the name
    of the function, `$i`. We use `$i` to call the function inside the WebAssembly
    module. Then, we have the `import` keyword. The `import` keyword is followed by
    the module name. The module name here refers to the JavaScript module, and then
    we have the name of the function to import from the JavaScript module.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have `param`. Since a WebAssembly module is typed, we have to define
    the input parameters and return types in the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use WABT''s `wat2wasm` to convert the WebAssembly text format into a
    WebAssembly module with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the generated byte code using the `hexdump` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The binary consists of the import section, which starts at the index of 16\.
    The import section starts with `02` because the unique section index of the import
    section is `02`. After that, we have `11`, which represents the size of the import
    section in the binary. The next bit represents the number of imports, `01`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the definition for the import. `07` here represents the length
    of the imported function. The next seven bits represent the name of the import
    module. The next bit represents the length of the function name, `05`, and the
    next five bits represent the function name. Finally, we have the kind and type
    signature of the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can call the `jsAdd` function like you would other functions inside
    a WebAssembly module using the `$i` identifier.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored how both the import and export sections are defined inside
    a WebAssembly module and how they help to import and export a function. Now, let's
    explore how to import and export values in and out of a WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: Globals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The globals section is where we can import and export values in and out of WebAssembly
    modules. In a WebAssembly module, you can import either mutable or immutable values
    from JavaScript. Additionally, WebAssembly also supports `wasmValue`, an internal
    immutable value inside the WebAssembly module itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `globals.wat` and add the following contents to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a module (`module`) and three global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$mutableValue` – This value is imported from the `js` JavaScript module and
    the `mutableGlobal` variable. We also define the global variable to be of the
    `mut i32` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$immutableValue` – This value is imported from the `js` JavaScript module
    and the `immutableGlobal` variable. We also define the global variable to be of
    the `i32` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$wasmValue` – This is a global constant. We define the `global` keyword followed
    by the name of the global variable, `$wasmValue`, then the type of `i32`, and
    finally the actual value (`i32.const 10`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$wasmValue` is immutable and cannot be exported to the external world.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we have a set of functions that helps to get and set the global variables.
    `getWasmValue`, `getImmutableValue`, and `getMutableValue` get the values of the
    `wasmValue` global constant, the `immutableValue` global constant, and the `mutableValue`
    global variable, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a function that sets `mutableValue` to a new value is `setMutableValue`.
    `setMutableValue` takes in `param $v`, which sets the value to `$mutableValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use WABT to convert the WebAssembly text format into a WebAssembly module
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `globals.html` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's define the `run` function inside `<script>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `WebAssembly.Global` object represents a global variable instance, accessible
    from JavaScript and importable/exportable across one or more `WebAssembly.Module`
    instances. The `WebAssembly.Global` constructor expects a descriptor and value.
    The descriptor defines the type and mutability of the global variable defined:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This global variable constructor provides an option to dynamically link multiple
    WebAssembly modules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We create two global values using the `WebAssembly.Global` constructor. They
    are `immutableGlobal` and `mutableGlobal`. The former is `mutable:false`, while
    the latter is `mutable:true`. So, we can change the value of the latter using
    `mutableGlobal.value` but not the former. If we try changing the value of `immutableGlobal`,
    then we will receive an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we fetch the `globals.wasm` WebAssembly module. Then, we instantiate
    `arrayBuffer` with the response and `arrayBuffer` with the `WebAssembly.instantiate`
    constructor. In addition to this, the `WebAssembly.instantiate` constructor accepts
    `importsObject`. We can send the JavaScript module via `importsObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are sending in the `js` module along with the `mutableGlobal`
    and `immutableGlobal` values. The `wasm` variable now holds the WebAssembly module.
    We invoke `wasm.instance.exports` to get all the exported functions from the WebAssembly
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`getWasmValue`, `getMutableValue`, `setMutableValue`, and `getImmutableValue`
    are the functions exported from the WebAssembly module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getWasmValue` function returns the value of the `wasmValue` inside the
    WebAssembly module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getMutableValue` and `setMutableValue` functions return and set the `mutableGlobal`
    field defined in JavaScript and passed into the WebAssembly module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we get the immutable value using the `getImmutableValue` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run an example in the browser using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, launch the URL `http://localhost:8000/globals.html` and open the developer
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: The WebAssembly binary contains an import section. The import section has a
    unique identifier, `02`, followed by the size of the section, which is `2b` (which
    is 43 in decimal). The next 43 bits represent the import section.
  prefs: []
  type: TYPE_NORMAL
- en: '`02` at the `000015` index represents the number of imports. Then, we have
    two sections that define the imported global functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Each global segment consists of the module string length and the module name,
    followed by the function string length and the function name. Finally, it has
    the kind of import, the type, and the mutability of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After that, we have the `Global` section. The `Global` section has the unique
    section ID of `6`. The next bit defines the size of the `Global` section, which
    is `06`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we have the number of globals available. The number of globals
    is `01`. This is because the other two globals are imported. The type, mutability,
    and value are the next 4 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `function` body inside the code section looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`function` is four bits in length. The first `00` says that the function has
    no local declaration. The next `23` is the opcode for getting the global value.
    The next `02` defines the index of the global value. Even though the preceding
    global section specifies there is only one global value, the entire module takes
    the imported globals into account. Since there are two imported global values,
    we index the local global values after the imported global value. So, the `$wasmValue`
    global has an index of 3\. Finally, we end the function code with the `0b` opcode.
    Similarly, the second and third function bodies define how we get the other two
    imported global values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In function body 4, we set the global value using `global.set`, which has an
    opcode of `24`.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored how to import and export values in and out of WebAssembly modules.
    Now, let's explore the special `start` function in the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: Start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start is a special function that runs after the WebAssembly module is initialized.
    Let''s take the same example that we used for the globals. We add the following
    content to `globals.wat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We define the `initMutableValue` function, which sets `mutableValue` to `200`.
    After that, we add a start block, which starts with `startkeyword` followed by
    the name of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The function referenced at the start should not return any value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use WABT to convert the WebAssembly text format into a WebAssembly module
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the example in a browser using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, launch the URL `http://localhost:8000/globals.html` and open the developer
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: The start function is similar to other functions, except that it is not classified
    into any type. The types may or may not be initialized at the time of the function.
    The start section of a WebAssembly module points to a function index (the index
    of the location of the function section inside the function component).
  prefs: []
  type: TYPE_NORMAL
- en: 'The section ID of the start function is `8`. When decoded, the start function
    represents the start component of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, tools such as webpack do not support the `start` function. The
    start section is rewritten into a normal function and then the function is invoked
    when the JavaScript is initialized by the bundler itself.
  prefs: []
  type: TYPE_NORMAL
- en: '`start` is an interesting and useful function that enables setting up some
    values when the module is initialized to prevent unnecessary side effects that
    the module might cause. Now, let''s explore the memory section. The memory section
    is responsible for transferring memory between JavaScript and WebAssembly.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transferring data between JavaScript and WebAssembly is an expensive operation.
    In order to reduce the transfer of data between JavaScript and WebAssembly modules,
    WebAssembly uses `sharedArrayBuffer`. With `sharedArrayBuffer` both the JavaScript
    and WebAssembly modules can access the same memory and use it to share the data
    from one to the other.
  prefs: []
  type: TYPE_NORMAL
- en: The memory section of a WebAssembly module is a vector of linear memories. The
    linear memory model is a memory addressing technique in which the memory is organized
    in a single contiguous address space. It is also known as a flat memory model.
    The linear memory model makes it easier to understand, program, and represent
    the memory. But the linear memory model comes with a huge disadvantage of high
    execution time for rearranging elements in the memory and the wastage of memory
    space. Here, the memory represents a vector of raw bytes of uninterpreted data.
    They use resizable array buffers to hold the raw bytes of memory. We use `sharedArrayBuffers`
    for defining and maintaining this memory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that this memory is accessible and mutable by JavaScript
    and WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We allocate the memory using the `WebAssembly.Memory()` constructor. The constructor
    can accept an argument that defines the initial and maximum value of memory, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define that `WebAssembly.Memory` has an initial memory of `10` and
    a maximum memory of `100`. Then, we instantiate the WebAssembly module with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the global example, here we are passing `importObject`, which takes
    in the `js` module and the memory object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file called `memory.wat` and add the following content
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Inside the module, we import the memory from the `js` module with the name memory.
    After that, we define a function sum and export the function outside the module.
    The function accepts two parameters as arguments and returns an i32 as an output.
    The first parameter is named `$ptr`. It is a pointer to the index of where the
    value is present in `sharedArrayBuffer`. The next argument is `$len`, which defines
    the length of the shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create two local variables, `$end` and `$sum`. First, we set `$end`
    to the value of `$ptr` plus four times the value of `$len`. Then, we create a
    block and start a loop. The loop ends when the value of `$end` is equal to the
    value of `$ptr`. We then set the value of `$sum` by adding the existing value
    of `$sum` with the value of `$ptr`. Then, we increment `$ptr` to the next value.
    Finally, we exit the loop and return `$sum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code is analogous to the following in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to `memory.html` and initialize the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an unsigned array using `Uint32Array` using the memory object we
    created. Then, we populate the array buffer with the cube of numbers from 1 to
    50:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we call the sum inside the WebAssembly module and ask it to provide
    the sum of all the cubic numbers in the shared array buffer starting at 0 up to
    the length of 50.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use WABT to convert the WebAssembly text format into a WebAssembly module
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run an example in the browser using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, launch the URL `http://localhost:8000/globals.html` and open the developer
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Memory sections are very useful when we have to transfer a large amount of data
    between two worlds. The memory sections make it easier to define, share, and access
    memory between the WebAssembly and JavaScript world.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the import, export, start, and memory sections
    in a WebAssembly module. We saw how they are structured and defined inside a WebAssembly
    module. Each of these sections carries one specific function and it is essential
    to understand, analyze, and debug the WebAssembly modules. In the next chapter,
    we will explore Binaryen.
  prefs: []
  type: TYPE_NORMAL
