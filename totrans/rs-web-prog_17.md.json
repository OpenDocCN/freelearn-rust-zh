["```rs\n├── Cargo.toml\n└── src\n    ├── actors\n    │   ├── messages.rs\n    │   ├── mod.rs\n    │   ├── runner.rs\n    │   └── state.rs\n    └── main.rs\n```", "```rs\n[dependencies]\ntokio = { version = \"1\", features = [\"full\"] }\nhyper = { version = \"0.14.20\", features = [\"full\"] }\nreqwest = { version = \"0.11.12\", features = [\"json\"] }\nserde_json = \"1.0.86\"\nserde = { version = \"1.0.136\", features = [\"derive\"] }\n```", "```rs\nuse serde::Serialize;\nuse std::env;\n```", "```rs\n#[derive(Debug, Serialize)]\npub enum MessageType {\n    INPUT,\n    OUTPUT,\n    EMPTY\n}\n```", "```rs\n#[derive(Debug, Serialize)]\npub struct StateActorMessage {\n    pub message_type: MessageType,\n    pub chat_id: Option<i32>,\n    pub single_data: Option<String>,\n    pub block_data: Option<Vec<String>>\n}\n```", "```rs\nimpl StateActorMessage {\n    pub async fn send_to_server(&self) {\n        let lib_url = env::var(\"SERVER_URL\").unwrap();\n        let joined =\n            self.block_data.clone().unwrap().join(\"$\");\n        let body = PostBody {\n            chat_id: self.chat_id.unwrap(),\n            block_data: joined\n        };\n        let client = reqwest::Client::new();\n        let res = client.post(lib_url)\n                                  .json(&body)\n                                  .send()\n                                  .await.unwrap();\n        println!(\"{:?}\", res);\n    }\n}\n```", "```rs\n#[derive(Debug, Serialize)]\nstruct PostBody {\n    pub chat_id: i32,\n    pub block_data: String\n}\n```", "```rs\nuse super::messages::{MessageType, StateActorMessage};\nuse tokio::sync::mpsc::{Sender, Receiver};\nuse std::time;\n```", "```rs\npub struct RunnerActor {\n    pub interval: i32,\n    pub receiver: Receiver<StateActorMessage>,\n    pub sender: Sender<StateActorMessage>,\n}\n```", "```rs\nimpl RunnerActor {\n    pub fn new(receiver: Receiver<StateActorMessage>,\n               sender: Sender<StateActorMessage>,\n               interval: i32) -> RunnerActor {\n        return RunnerActor { interval, receiver, sender }\n    }\n    pub async fn run(mut self) {\n        . . .\n    }\n}\n```", "```rs\npub async fn run(mut self) {\n    println!(\"runner actor is running\");\n    let seconds = time::Duration::from_secs(self.interval\n                                            as u64);\n    loop {\n        tokio::time::sleep(seconds).await;\n        let message = StateActorMessage {\n            message_type: MessageType::OUTPUT,\n            chat_id: None,\n            single_data: None,\n            block_data: None\n        };\n        match self.sender.send(message).await {\n            . . .\n        };\n    }\n}\n```", "```rs\nmatch self.sender.send(message).await {\n    Ok(_) => {\n        let message = self.receiver.recv().await.unwrap();\n        match message.message_type {\n            MessageType::OUTPUT => {\n                message.send_to_server().await;\n            },\n            _ => {\n                println!(\"state is empty\");\n            }\n        }\n    },\n    Err(_) => {\n        println!(\"runner is failed to send message\");\n    }\n};\n```", "```rs\nuse std::collections::{HashMap, VecDeque};\nuse std::mem;\nuse tokio::sync::mpsc::{Sender, Receiver};\nuse super::messages::{MessageType, StateActorMessage};\n```", "```rs\n#[derive(Debug)]\npub struct StateActor {\n    pub chat_queue: VecDeque<i32>,\n    pub chat_logs: HashMap<i32, Vec<String>>,\n    pub receiver: Receiver<StateActorMessage>,\n    pub sender: Sender<StateActorMessage>,\n}\n```", "```rs\nimpl StateActor {\n    pub fn new(receiver: Receiver,\n               sender: Sender) -> StateActor {\n        . . .\n    }\n    pub fn get_message_data(&mut self,\n                            chat_id: i32) -> Vec<String> {\n        . . .\n    }\n    pub fn insert_message(&mut self,\n                          chat_id: i32, message_data:\n                              String) {\n        . . .\n    }\n    async fn handle_message(&mut self,\n                            message: StateActorMessage) {\n        . . .\n    }\n    pub async fn run(mut self) {\n        . . .\n    }\n}\n```", "```rs\npub fn new(receiver: Receiver, sender: Sender) -> StateActor {\n    let chat_queue: VecDeque<i32> = VecDeque::new();\n    let chat_logs: HashMap<i32, Vec<String>> =\n        HashMap::new();\n    return StateActor {chat_queue, chat_logs, receiver,\n                       sender}\n}\n```", "```rs\npub fn get_message_data(&mut self, chat_id: i32) ->\n    Vec<String> {\n        self.chat_logs.remove(&chat_id).unwrap()\n}\n```", "```rs\npub fn insert_message(&mut self, chat_id: i32,\n    message_data: String) {\n    match self.chat_logs.get_mut(&chat_id) {\n        Some(patient_log) => {\n            patient_log.push(message_data);\n        },\n        None => {\n            self.chat_queue.push_back(chat_id);\n            self.chat_logs.insert(chat_id,\n                                  vec![message_data]);\n        }\n    }\n}\n```", "```rs\nasync fn handle_message(&mut self,\n    message: StateActorMessage) {\n    println!(\"state actor is receiving a message\");\n    match message.message_type {\n        MessageType::INPUT => {\n            self.insert_message(message.chat_id.unwrap(),\n                                message.single_data\n                                .unwrap());\n        },\n        MessageType::OUTPUT => {\n            . . .\n        },\n        MessageType::EMPTY => {\n            panic!(\n              \"empty messages should not be sent to the\n                   state actor\"\n            );\n        }\n    }\n    println!(\"{:?}\", self.chat_logs);\n    println!(\"{:?}\", self.chat_queue);\n}\n```", "```rs\nMessageType::OUTPUT => {\n    match self.chat_queue.pop_front() {\n        Some(chat_id) => {\n            let data = self.get_message_data(chat_id);\n            let message = StateActorMessage {\n                message_type: MessageType::OUTPUT,\n                chat_id: Some(chat_id),\n                single_data: None,\n                block_data: Some(data)\n            };\n            let _ =\n                self.sender.send(message).await.unwrap();\n        },\n        None => {\n            let message = StateActorMessage {\n                message_type: MessageType::EMPTY,\n                chat_id: None,\n                single_data: None,\n                block_data: None\n            };\n            let _ =\n                self.sender.send(message).await.unwrap();\n        }\n    }\n},\n```", "```rs\npub async fn run(mut self) {\n    println!(\"state actor is running\");\n    while let Some(msg) = self.receiver.recv().await {\n        self.handle_message(msg).await;\n    }\n}\n```", "```rs\nuse tokio::sync::{mpsc, mpsc::Sender};\nuse hyper::{Body, Request, Response, Server};\nuse hyper::body;\nuse hyper::service::{make_service_fn, service_fn};\nuse serde_json;\nuse serde::Deserialize;\nuse std::net::SocketAddr;\n```", "```rs\nmod actors;\nuse actors::state::StateActor;\nuse actors::runner::RunnerActor;\nuse actors::messages::StateActorMessage;\nuse actors::messages::MessageType;\n```", "```rs\n#[derive(Deserialize, Debug)]\nstruct IncomingBody {\n      pub chat_id: i32,\n      pub timestamp: i32,\n      pub input: String,\n      pub output: String\n}\n```", "```rs\nasync fn handle(req: Request<Body>, channel_sender:\n    Sender<StateActorMessage>) -> Result<Response<Body>,\n        &'static str> {\n    . . .\n}\n```", "```rs\nprintln!(\"incoming message from the outside\");\nlet method = req.method().clone();\nprintln!(\"{}\", method);\nlet uri = req.uri();\nprintln!(\"{}\", uri);\n```", "```rs\nlet bytes = body::to_bytes(req.into_body()).await.unwrap();\nlet string_body = String::from_utf8(bytes.to_vec())\n    expect(\"response was not valid utf-8\");\nlet value: IncomingBody = serde_json::from_str(\n    &string_body.as_str()).unwrap();\n```", "```rs\nlet message = StateActorMessage {\n    message_type: MessageType::INPUT,\n    chat_id: Some(value.chat_id),\n    single_data: Some(format!(\"{}>>{}>>{}>>\",\n                               value.input,\n                               value.output,\n                               value.timestamp)),\n    block_data: None\n};\nchannel_sender.send(message).await.unwrap();\nOk(Response::new(format!(\"{:?}\", value).into()))\n```", "```rs\n#[tokio::main]\nasync fn main() {\n    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));\n    . . .\n}\n```", "```rs\nlet (state_tx, state_rx) =\n    mpsc::channel::<StateActorMessage>(1);\nlet (runner_tx, runner_rx) =\n    mpsc::channel::<StateActorMessage>(1);\nlet channel_sender = state_tx.clone();\n```", "```rs\ntokio::spawn(async move {\n    let state_actor = StateActor::new(state_rx, runner_tx);\n    state_actor.run().await;\n});\ntokio::spawn(async move {\n    let lib_runner_actor = RunnerActor::new(runner_rx,\n                                            state_tx, 30);\n    lib_runner_actor.run().await;\n});\n```", "```rs\nlet server = Server::bind(&addr).serve(make_service_fn( |_conn| {\n    let channel = channel_sender.clone();\n    async {\n        Ok::<_, hyper::Error>(service_fn(move |req| {\n            let channel = channel.clone();\n            async {handle(req, channel).await}\n        }))\n    }\n}));\n```", "```rs\nif let Err(e) = server.await {\n    eprintln!(\"server error: {}\", e);\n}\n```", "```rs\nexport SERVER_URL=\"https://httpbin.org/post\"\n```", "```rs\ncargo run\n```", "```rs\nstate actor is running\nrunner actor is running\n```", "```rs\nstate is empty\nstate actor is receiving a message\n{}\n[]\nstate is empty\nstate actor is receiving a message\n{}\n[]\nstate is empty\nstate actor is receiving a message\n{}\n[]\n```", "```rs\nincoming message from the outside\nPOST\n/test\nstate actor is receiving a message\n{23: [\"what is your name>>my name is maxwell>>1>>\"]}\n[23]\n```", "```rs\nincoming message from the outside\nPOST\n/test\nstate actor is receiving a message\n{23: [\"what is your name>>my name is maxwell>>1>>\",\n      \"what is your name>>my name is maxwell>>1>>\"]}\n[23]\nincoming message from the outside\nPOST\n/test\nstate actor is receiving a message\n{23: [\"what is your name>>my name is maxwell>>1>>\",\n      \"what is your name>>my name is maxwell>>1>>\",\n      \"what is your name>>my name is maxwell>>1>>\"]}\n[23]\n```", "```rs\nincoming message from the outside\nPOST\n/test\nstate actor is receiving a message\n{24: [\"what is your name>>my name is maxwell>>1>>\"],\n23: [\"what is your name>>my name is maxwell>>1>>\",\n     \"what is your name>>my name is maxwell>>1>>\",\n     \"what is your name>>my name is maxwell>>1>>\"]}\n[23, 24]\n```", "```rs\nstate actor is receiving a message\n{23: [\"what is your name>>my name is maxwell>>1>>\"}\n[23]\nResponse { url: Url { scheme: \"https\",\ncannot_be_a_base: false,\nusername: \"\", password: None,\nhost: Some(Domain(\"httpbin.org\")),\nport: None, path: \"/post\",\n. . .\n\"*\", \"access-control-allow-credentials\": \"true\"} }\n```"]