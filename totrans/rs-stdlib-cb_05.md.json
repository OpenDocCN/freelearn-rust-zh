["```rs\nlazy_static = \"1.0\"\nregex = \"0.2\"\n```", "```rs\n1    #[macro_use] \n2    extern crate lazy_static;\n3    extern crate regex;\n4 \n5    use regex::Regex;\n6    use std::collections::HashMap;\n7    use std::sync::RwLock;\n8 \n9    // Global immutable static\n10   lazy_static! {\n11     static ref CURRENCIES: HashMap<&'static str, &'static str> = \n       {\n12       let mut m = HashMap::new();\n13       m.insert(\"EUR\", \"Euro\");\n14       m.insert(\"USD\", \"U.S. Dollar\");\n15       m.insert(\"CHF\", \"Swiss Francs\");\n16       m\n17     };\n18   }\n19 \n20   // Global mutable static\n21   lazy_static! {\n22     static ref CLIENTS: RwLock<Vec<String>> = \n       RwLock::new(Vec::new());\n23   }\n24 \n25   // Local static\n26   fn extract_day(date: &str) -> Option<&str> {\n27     // lazy static objects are perfect for\n28     // compiling regexes only once\n29     lazy_static! {\n30       static ref RE: Regex =\n31       Regex::new(r\"(\\d{2}).(\\d{2}).(\\d{4})\")\n32         .expect(\"Failed to create regex\");\n33     }\n34     RE.captures(date)\n35       .and_then(|cap| cap.get(1).map(|day| day.as_str()))\n36   }\n37 \n38   fn main() {\n39     // The first access to CURRENCIES initializes it\n40     let usd = CURRENCIES.get(\"USD\");\n41     if let Some(usd) = usd {\n42       println!(\"USD stands for {}\", usd);\n43     }\n44 \n45     // All accesses will now refer to the same,\n46     // already constructed object\n47     if let Some(chf) = CURRENCIES.get(\"CHF\") {\n48       println!(\"CHF stands for {}\", chf);\n49     }\n50 \n51     // Mutable the global static\n52     CLIENTS\n53       .write()\n54       .expect(\"Failed to unlock clients for writing\")\n55       .push(\"192.168.0.1\".to_string());\n56 \n57     // Get an immutable reference to the global static\n58     let clients = CLIENTS\n59       .read()\n60       .expect(\"Failed to unlock clients for reading\");\n61     let first_client = clients.get(0).expect(\"CLIENTS is\n       empty\");\n62     println!(\"The first client is: {}\", first_client);\n63 \n64     let date = \"12.01.2018\";\n65     // The static object is nicely hidden inside\n66     // the definition of extract_day()\n67     if let Some(day) = extract_day(date) {\n68       println!(\"The date \\\"{}\\\" contains the day \\\"{}\\\"\", date, \n         day);\n69     }\n70   }\n```", "```rs\nlazy_static!{\n    static ref FOO: Vec<&'static str> = vec![\"a\", \"b\", \"c\"];\n}\n```", "```rs\nconst FOO: [&str; 3] = [\"a\", \"b\", \"c\"];\n```", "```rs\nfn extract_day(date: &str) -> Option<&str> {\n    lazy_static! {\n        static ref RE: Regex =\n            Regex::new(r\"(\\d{2}).(\\d{2}).(\\d{4})\")\n            .expect(\"Failed to create regex\");\n    }\n    RE.captures(date)\n        .and_then(|cap| cap.get(1).map(|day| day.as_str()))\n}\n```", "```rs\nlazy_static! {\n    static ref CLIENTS: RwLock<Vec<String>> = RwLock::new(Vec::new());\n}\n```", "```rs\nlazy_static! {\n    static ref foo: Foo = Foo::new();\n}\n```", "```rs\nbitflags = \"1.0\"\n```", "```rs\n1    #[macro_use]\n2    extern crate bitflags;\n3 \n4    bitflags! {\n5      struct Spices: u32 {\n6        const SALT    = 0b0000_0001;\n7        const PEPPER  = 0b0000_0010;\n8        const CHILI   = 0b0000_0100;\n9        const SAFFRON = 0b0000_1000;\n10       const ALL     = Self::SALT.bits\n11                     | Self::PEPPER.bits\n12                     | Self::CHILI.bits\n13                     | Self::SAFFRON.bits;\n14     }\n15   }\n16 \n17   impl Spices {\n18     // Implementing a \"clear\" method can be useful\n19     pub fn clear(&mut self) -> &mut Self {\n20       self.bits = 0;\n21       self\n22     }\n23   }\n24 \n25   fn main() {\n26     let classic = Spices::SALT | Spices::PEPPER;\n27     let spicy = Spices::PEPPER | Spices::CHILI;\n28     // Bit fields can nicely be printed\n29     println!(\"Classic: {:?}\", classic);\n30     println!(\"Bits: {:08b}\", classic.bits());\n31     println!(\"Spicy: {:?}\", spicy);\n32     println!(\"Bits: {:08b}\", spicy.bits());\n33 \n34     println!();\n35 \n36     // Use set operations\n37     println!(\"Union: {:?}\", classic | spicy);\n38     println!(\"Intersection: {:?}\", classic & spicy);\n39     println!(\"Difference: {:?}\", classic - spicy);\n40     println!(\"Complement: {:?}\", !classic);\n41 \n42     // Interact with flags in a bit field\n43     let mut custom = classic | spicy;\n44     println!(\"Custom spice mix: {:?}\", custom);\n45     custom.insert(Spices::SAFFRON);\n46     // Note that ALL is now also contained in the bit field\n47     println!(\"Custom spice after adding saffron: {:?}\", custom);\n48     custom.toggle(Spices::CHILI);\n49     println!(\"Custom spice after toggling chili: {:?}\", custom);\n50     custom.remove(Spices::SALT);\n51     println!(\"Custom spice after removing salt: {:?}\", custom);\n52 \n53     // This could be user input\n54     let wants_salt = true;\n55     custom.set(Spices::SALT, wants_salt);\n56     if custom.contains(Spices::SALT) {\n57       println!(\"I hope I didn't put too much salt in it\");\n58     }\n59 \n60     // Read flags from raw bits\n61     let bits = 0b0000_1101;\n62     if let Some(from_bits) = Spices::from_bits(bits) {\n63       println!(\"The bits {:08b} represent the flags {:?}\", bits,\n         from_bits);\n64     }\n65 \n66     custom.clear();\n67     println!(\"Custom spice mix after clearing: {:?}\", custom);\n68   }\n```", "```rs\nconst SPICY = Self::PEPPER.bits | Self::CHILI.bits;\n```", "```rs\nCustom spice after adding saffron: SALT | PEPPER | CHILI | SAFFRON | ALL\n```", "```rs\nif custom.contains(Spices::SALT | Spices::PEPPER) {\n    println!(\"The custom spice contains both salt and pepper\");\n}\n```", "```rs\n[lib]\nproc-macro = true\n```", "```rs\nsyn = \"0.11.11\"\nquote = \"0.3.15\"\n\n```", "```rs\n1    extern crate proc_macro; \n2    #[macro_use]\n3    extern crate quote;\n4    extern crate syn;\n5 \n6    use proc_macro::TokenStream;\n7 \n8    // HelloWorld is the name for the derive\n9    // hello_world_name is the name of our optional attribute\n10   #[proc_macro_derive(HelloWorld, attributes(hello_world_name))]\n11   pub fn hello_world(input: TokenStream) -> TokenStream {\n12     // Construct a string representation of the type definition\n13     let s = input.to_string();\n14     // Parse the string representation into an abstract syntax \n          tree\n15     let ast = syn::parse_derive_input(&s).expect(\"Failed to \n       parse the source into an AST\");\n16 \n17     // Build the implementation\n18     let gen = impl_hello_world(&ast);\n19 \n20     // Return the generated implementation\n21     gen.parse()\n22       .expect(\"Failed to parse the AST generated from deriving \n          from HelloWorld\")\n23   }\n24 \n25   fn impl_hello_world(ast: &syn::DeriveInput) -> quote::Tokens {\n26     let identifier = &ast.ident;\n27     // Use the name provided by the attribute\n28     // If there is no attribute, use the identifier\n29     let hello_world_name = \n       get_name_attribute(ast).unwrap_or_else(||    \n       identifier.as_ref());\n30     quote! {\n31       // Insert an implementation for our trait\n32       impl HelloWorld for #identifier {\n33         fn hello_world() {\n34           println!(\n35             \"The struct or enum {} says: \\\"Hello world from    \n                {}!\\\"\",\n36              stringify!(#identifier),\n37              #hello_world_name\n38           );\n39         } //end of fn hello_world()\n40       } //end of impl HelloWorld\n41     } //end of quote\n42   } //end of fn impl_hello_world\n43 \n44   fn get_name_attribute(ast: &syn::DeriveInput) -> Option<&str> {\n45     const ATTR_NAME: &str = \"hello_world_name\";\n46 \n47     // Go through all attributes and find one with our name\n48     if let Some(attr) = ast.attrs.iter().find(|a| a.name() == \n       ATTR_NAME) {\n49       // Check if it's in the form of a name-value pair\n50       if let syn::MetaItem::NameValue(_, ref value) = attr.value \n         {\n51         // Check if the value is a string\n52         if let syn::Lit::Str(ref value_as_str, _) = *value {\n53           Some(value_as_str)\n54         } else {\n55             panic!(\n56               \"Expected a string as the value of {}, found {:?} \n                  instead\",\n57                ATTR_NAME, value\n58             );\n59           }\n60         } else {\n61             panic!(\n62               \"Expected an attribute in the form #[{} = \\\"Some \n                  value\\\"]\",\n63                ATTR_NAME\n64             );\n65           }\n66         } else {\n67             None\n68         }\n69   }\n```", "```rs\ncustom-derive = { path = \"custom-derive\" }\n```", "```rs\n1    #[macro_use]\n2    extern crate chapter_five_derive;\n3 \n4    // trait definitions have to be in \"consumer\" crate\n5    trait HelloWorld {\n6      // This method will send a friendly greeting\n7      fn hello_world();\n8    }\n9 \n10   // thanks to the code in the custom_derive crate\n11   // we can derive from HelloWorld in order to provide\n12   // an automatic implementation for the HelloWorld trait\n13   #[derive(HelloWorld)]\n14   struct Switzerland;\n15 \n16   #[derive(HelloWorld)]\n17   struct Britain;\n18 \n19   #[derive(HelloWorld)]\n20   // We can use an optional attribute to change the message\n21   #[hello_world_name = \"the Land Down Under\"]\n22   struct Australia;\n23 \n24   fn main() {\n25     Switzerland::hello_world();\n26     Britain::hello_world();\n27     Australia::hello_world();\n28   }\n```", "```rs\n[lib]\nproc-macro = true\n```", "```rs\nimpl HelloWorld for #struct_name { ... }\n```", "```rs\nimpl HelloWorld for Switzerland { ... }\n```", "```rs\n#[proc_macro_derive(HelloWorld)]\n```", "```rs\nstruct Switzerland;\n```", "```rs\nlet gen = impl_hello_world(&ast);\n```", "```rs\ngen.parse()\n```", "```rs\nimpl HelloWorld for Switzerland {\n    fn hello_world() {\n        println!(\n            \"The struct or enum {} says: \\\"Hello world from {}!\\\"\",\n            Switzerland,\n            \"Switzerland\"\n        );\n    }\n}\n```", "```rs\nif let Some(attr) = ast.attrs.iter().find(|a| a.name() == ATTR_NAME) { ... }\n```", "```rs\nif let syn::MetaItem::NameValue(_, ref value) = attr.value { ... }\n```", "```rs\nif let syn::Lit::Str(ref value_as_str, _) = *value { ... }\n```", "```rs\n1    use std::ops::MulAssign; \n2    use std::fmt::Display;\n3 \n4    // This structure doubles all elements it stores\n5    #[derive(Debug)]\n6    struct DoubleVec<T>(Vec<T>);\n7 \n8 \n9    // Allowing conversion from a Vec<T>,\n10   // where T is multipliable with an integer\n11   impl<T> From<Vec<T>> for DoubleVec<T>\n12   where\n13   T: MulAssign<i32>,\n14   {\n15     fn from(mut vec: Vec<T>) -> Self {\n16       for elem in &mut vec {\n17         *elem *= 2;\n18       }\n19       DoubleVec(vec)\n20     }\n21   }\n22 \n23   // Allowing conversion from a slice of Ts\n24   // where T is again multipliable with an integer\n25   impl<'a, T> From<&'a [T]> for DoubleVec<T>\n26   where\n27   T: MulAssign<i32> + Clone,\n28   {\n29     fn from(slice: &[T]) -> Self {\n30       // Vec<T: MulAssign<i32>> automatically\n31       // implements Into<DoubleVec<T>>\n32       slice.to_vec().into()\n33     }\n34   }\n35 \n36   // Allowing conversion from a &DoubleVec<T> to a &Vec<T>\n37   impl<T> AsRef<Vec<T>> for DoubleVec<T> {\n38     fn as_ref(&self) -> &Vec<T> {\n39       &self.0\n40     }\n41   }\n42 \n43 \n44   fn main() {\n45     // The following three are equivalent\n46     let hello_world = \"Hello World\".to_string();\n47     let hello_world: String = \"Hello World!\".into();\n48     let hello_world = String::from(\"Hello World!\");\n49 \n50     // Vec<u8> implements From<&str>\n51     // so hello_world_bytes has the value b\"Hello World!\"\n52     let hello_world_bytes: Vec<u8> = \"Hello World!\".into();\n53     let hello_world_bytes = Vec::<u8>::from(\"Hello World!\");\n54 \n55     // We can convert a Vec<T: MulAssign<i32>> into a DoubleVec\n56     let vec = vec![1, 2, 3];\n57     let double_vec = DoubleVec::from(vec);\n58     println!(\"Creating a DoubleVec from a Vec: {:?}\", \n       double_vec);\n59 \n60     // Vec<T: MulAssign<i32>> automatically implements \n          Into<DoubleVec<T>>\n61     let vec = vec![1, 2, 3];\n62     let double_vec: DoubleVec<_> = vec.into();\n63     println!(\"Converting a Vec into a DoubleVec: {:?}\", \n       double_vec);\n64 \n65     // A reference to DoubleVec can be converted to a reference \n          to Vec\n66     // Which in turn dereferences to a slice\n67     print_elements(double_vec.as_ref());\n68 \n69     // The standard library provides From<T> for Option<T>\n70     // You can design your API in an ergonomic way thanks to this\n71     easy_public_func(Some(1337), Some(123), None);\n72     ergonomic_public_func(1337, 123, None);\n73   }\n74 \n75 \n76   fn print_elements<T>(slice: &[T])\n77   where\n78   T: Display,\n79   {\n80     for elem in slice {\n81       print!(\"{} \", elem);\n82     }\n83     println!();\n84   }\n85 \n86 \n87   // Easily written but cumbersome to use\n88   fn easy_public_func(foo: Option<i32>, bar: Option<i32>, baz: \n     Option<i32>) {\n89     println!(\n90       \"easy_public_func = foo: {:?}, bar: {:?}, baz: {:?}\",\n91        foo,\n92        bar,\n93        baz\n94     );\n95   }\n96 \n97 \n98   // This is quite some extra typing, so it's only worth to do \n        for\n99   // public functions with many optional parameters\n100  fn ergonomic_public_func<Foo, Bar, Baz>(foo: Foo, bar: Bar, \n     baz: Baz)\n101  where\n102  Foo: Into<Option<i32>>,\n103  Bar: Into<Option<i32>>,\n104  Baz: Into<Option<i32>>,\n105  {\n106    let foo: Option<i32> = foo.into();\n107    let bar: Option<i32> = bar.into();\n108    let baz: Option<i32> = baz.into();\n109 \n110    println!(\n111     \"ergonomic_public_func = foo: {:?}, bar: {:?}, baz: {:?}\",\n112      foo,\n113      bar,\n114      baz\n115    );\n116  }\n```", "```rs\nt *= 2;\n```", "```rs\nfn from(slice: &[T]) -> Self {\n    slice.to_vec().into()\n}\n```", "```rs\n// From implies Into\nimpl<T, U> Into<U> for T where U: From<T>\n{\n    fn into(self) -> U {\n        U::from(self)\n    }\n}\n```", "```rs\nfn from(slice: &[T]) -> Self {\n    slice.to_vec().into()\n}\n```", "```rs\nlet hello_world_name = get_name_attribute(ast).unwrap_or_else(|| identifier.as_ref());\n```", "```rs\nprint_elements(double_vec.as_ref());\n```", "```rs\nimpl<T> From<T> for Option<T> {\n    fn from(val: T) -> Option<T> {\n        Some(val)\n    }\n}\n```", "```rs\neasy_public_func(Some(1337), Some(123), None);\nergonomic_public_func(1337, 123, None);\n```", "```rs\n1    use std::fs::File;\n2    use std::io::BufReader;\n3    use std::result::Result;\n4    use std::error::Error;\n5    use std::io::Read;\n6    use std::fmt::Debug;\n7 \n8    #[derive(Debug)]\n9    struct Node<T> {\n10     data: T,\n11     child_nodes: Option<(BoxedNode<T>, BoxedNode<T>)>,\n12   }\n13   type BoxedNode<T> = Box<Node<T>>;\n14 \n15   impl<T> Node<T> {\n16     fn new(data: T) -> Self {\n17       Node {\n18         data,\n19         child_nodes: None,\n20       }\n21     }\n22 \n23     fn is_leaf(&self) -> bool {\n24       self.child_nodes.is_none()\n25     }\n26 \n27     fn add_child_nodes(&mut self, a: Node<T>, b: Node<T>) {\n28       assert!(\n29         self.is_leaf(),\n30         \"Tried to add child_nodes to a node that is not a leaf\"\n31       );\n32       self.child_nodes = Some((Box::new(a), Box::new(b)));\n33     }\n34   }\n35 \n36   // Boxes enable you to use traditional OOP polymorph\n37   trait Animal: Debug {\n38     fn sound(&self) -> &'static str;\n39   }\n40 \n41   #[derive(Debug)]\n42   struct Dog;\n43   impl Animal for Dog {\n44     fn sound(&self) -> &'static str {\n45       \"Woof!\"\n46     }\n47   }\n48 \n49   #[derive(Debug)]\n50   struct Cat;\n51   impl Animal for Cat {\n52     fn sound(&self) -> &'static str {\n53       \"Meow!\"\n54     }\n55   }\n56 \n57   fn main() {\n58     let mut root = Node::new(12);\n59     root.add_child_nodes(Node::new(3), Node::new(-24));\n60     root.child_nodes\n61       .as_mut()\n62       .unwrap()\n63       0\n64       .add_child_nodes(Node::new(0), Node::new(1803));\n65     println!(\"Our binary tree looks like this: {:?}\", root);\n66 \n67     // Polymorphism\n68     let mut zoo: Vec<Box<Animal>> = Vec::new();\n69     zoo.push(Box::new(Dog {}));\n70     zoo.push(Box::new(Cat {}));\n71     for animal in zoo {\n72       println!(\"{:?} says {}\", animal, animal.sound());\n73     }\n74 \n75     for word in caps_words_iter(\"do you feel lucky, punkâ€½\") {\n76       println!(\"{}\", word);\n77     }\n78 \n79     // Assuming a file called number.txt exists\n80     let num = read_file_as_number(\"number.txt\").expect(\"Failed \n       read the file as a number\");\n81     println!(\"number.txt contains the number {}\", num);\n82 \n83     // Dynamically composing functions\n84     let multiplier = create_multiplier(23);\n85     let result = multiplier(3);\n86     println!(\"23 * 3 = {}\", result);\n87   }\n88 \n89   // Via trait objects we can return any iterator\n90   fn caps_words_iter<'a>(text: &'a str) -> Box<Iterator<Item = \n     String> + 'a> {\n91     // Return an iterator over every word converted into \n       ALL_CAPS\n92     Box::new(text.trim().split(' ').map(|word| \n       word.to_uppercase()))\n93   }\n94 \n95   // Same goes for errors\n96   fn read_file_as_number(filename: &str) -> Result<i32, \n     Box<Error>> {\n97     let file = File::open(filename)?;\n98     let mut buf_reader = BufReader::new(file);\n99     let mut content = String::new();\n100    buf_reader.read_to_string(&mut content)?;\n101    let number: i32 = content.parse()?;\n102    Ok(number)\n103  }\n104 \n105  fn create_multiplier(a: i32) -> Box<Fn(i32) -> i32> {\n106    Box::new(move |b| a * b)\n107  }\n```", "```rs\nstruct Foo {\n    bar: i32\n}\n```", "```rs\nstruct Foo {\n    bar: i32,\n    baz: Foo,\n}\n```", "```rs\nstruct Foo {\n    bar: i32,\n    baz: Box<Foo>,\n}\n```", "```rs\nlet mut zoo: Vec<Box<Animal>> = Vec::new();\n```", "```rs\nfn caps_words_iter<'a>(text: &'a str) -> Box<Iterator<Item = String> + 'a> { ... }\n```", "```rs\n1    use std::rc::Rc;\n2 \n3    // The ball will survive until all kids are done playing with \n        it\n4    struct Kid {\n5      ball: Rc<Ball>,\n6    }\n7    struct Ball;\n8 \n9    fn main() {\n10     {\n11       // rc is created and count is at 1\n12       let foo = Rc::new(\"foo\");\n13       // foo goes out of scope; count decreases\n14       // count is zero; the object gets destroyed\n15     }\n16 \n17     {\n18       // rc is created and count is at 1\n19       let bar = Rc::new(\"bar\");\n20       // rc is cloned; count increases to 2\n21       let second_bar = Rc::clone(&bar);\n22       // bar goes out of scode; count decreases to 1\n23       // bar goes out of scode; count decreases to 0\n24     }\n25 \n26     {\n27       // rc is created and count is at 1\n28       let baz = Rc::new(\"baz\");\n29       {\n30         // rc is cloned; count increases to 2\n31         let second_baz = Rc::clone(&baz);\n32         // second_baz goes out of scode; count decreases to 1\n33       }\n34       // baz goes out of scode; count decreases to 0\n35     }\n36     let kid_one = spawn_kid_with_new_ball();\n37     let kid_two = Kid {\n38       ball: Rc::clone(&kid_one.ball),\n39     };\n40     let kid_three = Kid {\n41       ball: Rc::clone(&kid_one.ball),\n42     };\n43     // ball lives until here\n44   }\n45 \n46   fn spawn_kid_with_new_ball() -> Kid {\n47     let ball = Rc::new(Ball);\n48     Kid {\n49       ball: Rc::clone(&ball),\n50     }\n51     // Although the ball goes out of scope here, the object \n          behind it\n52\n53     // will survive as part of the kid\n54   }\n```", "```rs\n1    trait EmailSender { \n2      fn send_mail(&self, msg: &Email) -> Option<String>;\n3    }\n4 \n5    #[derive(Debug, Clone)]\n6    struct Email {\n7      from: String,\n8      to: String,\n9      msg: String,\n10   }\n11 \n12   #[derive(Debug)]\n13   struct Customer {\n14     address: String,\n15     wants_news: bool,\n16   }\n17 \n18   // Send news to every customer that wants to receive them\n19   fn publish_news(msg: &str, sender: &EmailSender, customers: &\n     [Customer]) -> Option<i32> {\n20     let mut count = 0;\n21     let mut mail = Email {\n22     from: \"Rust Newsletter\".to_string(),\n23     to: \"\".to_string(),\n24     msg: msg.to_string(),\n25   };\n26   for customer in customers {\n27     if !customer.wants_news {\n28       continue;\n29     }\n30     mail.to = customer.address.to_string();\n31     if sender.send_mail(&mail).is_none() {\n32       return None;\n33     }\n34     count += 1;\n35   }\n36   Some(count)\n37 }\n38 \n39   fn main() {\n40   // No code running as we are concentrating on the tests instead\n41   }\n42 \n43 \n44   #[cfg(test)]\n45   mod tests {\n46     use super::*;\n47     use std::cell::RefCell;\n48 \n49     struct MockEmailSender {\n50       // sent_mails can be modified even if MockEmailSender is \n            immutable\n51       sent_mails: RefCell<Vec<Email>>,\n52     }\n53     impl MockEmailSender {\n54       fn new() -> Self {\n55         MockEmailSender {\n56           sent_mails: RefCell::new(Vec::new()),\n57         }\n58       }\n59     }\n60 \n61     impl EmailSender for MockEmailSender {\n62     fn send_mail(&self, msg: &Email) -> Option<String> {\n63       // Borrow sent_mails mutably\n64       self.sent_mails.borrow_mut().push(msg.clone());\n65       Some(\"200 OK\".to_string())\n66     }\n67   }\n68 \n69   #[test]\n70   fn sends_zero_to_zero_customers() {\n71     let sent = publish_news(\"hello world!\", \n       &MockEmailSender::new(), &[]);\n72     assert_eq!(Some(0), sent);\n73   }\n74 \n75   #[test]\n76   fn sends_one_to_one_willing() {\n77     let customer = Customer {\n78       address: \"herbert@herbert.com\".to_string(),\n79       wants_news: true,\n80     };\n81     let sent = publish_news(\"hello world!\", \n       &MockEmailSender::new(), &[customer]);\n82     assert_eq!(Some(1), sent);\n83   }\n84 \n85 #[test]\n86   fn sends_none_to_unwilling() {\n87     let customer_one = Customer {\n88       address: \"herbert@herbert.com\".to_string(),\n89       wants_news: false,\n90     };\n91     let customer_two = Customer {\n92       address: \"michael@jackson.com\".to_string(),\n93       wants_news: false,\n94     };\n95     let sent = publish_news(\n96       \"hello world!\",\n97        &MockEmailSender::new(),\n98        &[customer_one, customer_two],\n99     );\n100     assert_eq!(Some(0), sent);\n101   }\n102 \n103   #[test]\n104   fn sends_correct_mail() {\n105     let customer = Customer {\n106       address: \"herbert@herbert.com\".to_string(),\n107       wants_news: true,\n108     };\n109     let sender = MockEmailSender::new();\n110     publish_news(\"hello world!\", &sender, &\n        [customer]).expect(\"Failed to send mail\");\n111 \n112     // Borrow sent_mails immutable\n113     let mails = sender.sent_mails.borrow();\n114     assert_eq!(1, mails.len());\n115     assert_eq!(\"Rust Newsletter\", mails[0].from);\n116     assert_eq!(\"herbert@herbert.com\", mails[0].to);\n117     assert_eq!(\"hello world!\", mails[0].msg);\n118   }\n119 }\n```"]