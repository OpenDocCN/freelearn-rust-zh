<html><head></head><body>
		<div id="_idContainer007">
			<h1 id="_idParaDest-14"><em class="italic"><a id="_idTextAnchor013"/>Chapter 1</em>: Understanding LLVM</h1>
			<p>JavaScript is one of the most popular programming languages. However, JavaScript has two main disadvantages: </p>
			<ul>
				<li><strong class="bold">Unpredictable performance</strong> </li>
			</ul>
			<p>JavaScript executes<a id="_idIndexMarker000"/> inside the environment and runtime provided by JavaScript engines. There are various JavaScript engines (V8, WebKit, and Gecko). All of them were built differently and run the same JavaScript code in a different way. Added to that, JavaScript is dynamically typed. This means JavaScript engines should guess the type while executing the JavaScript code. These factors lead to unpredictable performance in JavaScript execution. The optimizations for one type of JavaScript engine may cause undesirable side effects on other types of JavaScript engines. This leads to unpredictable performance.</p>
			<ul>
				<li><strong class="bold">Bundle size</strong></li>
			</ul>
			<p>The JavaScript engine waits until it downloads the entire JavaScript file before parsing and executing. The larger the JavaScript file, the longer the wait will be. This will degrade your application's performance. Bundlers such as webpack help to minimize the bundle size. But when your application grows, the bundle size grows exponentially.</p>
			<p>Is there a tool that provides native performance and comes in a much smaller size? Yes, WebAssembly. </p>
			<p>WebAssembly<a id="_idIndexMarker001"/> is the future of web and node development. WebAssembly is statically typed and precompiled, and thus it provides better performance than JavaScript. Precompilation of the binary provides an option to generate tiny binary bundles. WebAssembly allows languages such as Rust, C, and C++ to be compiled into binaries that run inside the JavaScript engine along with JavaScript. All WebAssembly<a id="_idIndexMarker002"/> compilers use LLVM underneath to convert the native code into WebAssembly binary code. Thus, it is important to understand what LLVM is and how it works. </p>
			<p>In this chapter, we will learn what the various components of a compiler are and how they work. Then, we will explore what LLVM is and how it helps the compiled languages. Finally, we will see how the LLVM compiler compiles native code. We will cover the following topics in this chapter:</p>
			<ul>
				<li>Understanding compilers</li>
				<li>Exploring LLVM</li>
				<li>LLVM in action</li>
			</ul>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Technical requirements</h1>
			<p>We will make use of <strong class="bold">Clang</strong>, which is a compiler that compiles C/C++ code into native code. </p>
			<p>For Linux and Mac users, Clang should be available out of the box.</p>
			<p>For Windows users, Clang can be installed from the following link: <a href="https://llvm.org/docs/GettingStarted.html?highlight=installing%20clang%20windows#getting-the-source-code-and-building-llvm">https://llvm.org/docs/GettingStarted.html?highlight=installing%20clang%20windows#getting-the-source-code-and-building-llvm</a> to install Clang.</p>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a></p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Understanding compilers</h1>
			<p>Programming languages are broadly classified into compiled and interpreted languages.</p>
			<p>In the compiled<a id="_idIndexMarker003"/> world, the code is first compiled into target machine code. This process of converting<a id="_idIndexMarker004"/> the code into binary is called <em class="italic">compilation</em>. The software program that converts the code into target machine code is called a <em class="italic">compiler</em>. During the compilation, the compiler runs a series of checks, passes, and validation on the code written and generates an efficient and optimized binary. A few examples of compiled languages are C, C++, and Rust. </p>
			<p>In the interpreted world, the code is read and executed in a single pass. Since the compilation happens at runtime, the generated machine code is not as optimized as its compiled counterpart. Interpreted languages<a id="_idIndexMarker005"/> are significantly slower than compiled ones, but they provide dynamic typing and a smaller program size.</p>
			<p>In this book, we will focus only on compiled languages.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>Compiled languages</h2>
			<p>A compiler is a translator<a id="_idIndexMarker006"/> that translates source code into machine code (or in a more abstract way, converts the code from one programming language to another). A compiler is complicated because it should understand the language in which the source code is written (its syntax, semantics, and context); it should also understand the target machine code (its syntax, semantics, and context) and should create a representation that maps the source code into the target machine code.</p>
			<p>A compiler has the following components:</p>
			<ul>
				<li><strong class="bold">Frontend</strong> – The frontend<a id="_idIndexMarker007"/> is responsible for handling the source language.</li>
				<li><strong class="bold">Optimizer</strong> – The optimizer<a id="_idIndexMarker008"/> is responsible for optimizing the code.</li>
				<li><strong class="bold">Backend</strong> – The backend<a id="_idIndexMarker009"/> is responsible for handling the target language.</li>
			</ul>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/Figure_1.1_B14844.jpg" alt=" Figure 1.1 – Components of a compiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 1.1 – Components of a compiler</p>
			<h3>Frontend</h3>
			<p>The frontend focuses on handling the source<a id="_idIndexMarker010"/> language. The frontend parses the code upon<a id="_idIndexMarker011"/> receiving it. The code is then checked for any grammar or syntax issues. After that, the code<a id="_idIndexMarker012"/> is converted (mapped) into an <strong class="bold">intermediate representation</strong> (<strong class="bold">IR</strong>). Consider IR as a format that represents the code that the compiler processes. The IR <a id="_idIndexMarker013"/>is the compiler's version<a id="_idIndexMarker014"/> of your code.</p>
			<h3>Optimizer </h3>
			<p>The second component in the compiler is the optimizer. This is optional, but as the name indicates, the optimizer<a id="_idIndexMarker015"/> analyzes the IR and transforms it into a much more<a id="_idIndexMarker016"/> efficient one. Few compilers have multiple IRs. The compiler efficiently optimizes the code on every pass over the IR. The optimizer is an IR-to-IR transformer. The optimizer analyzes, runs passes, and rewrites the IR. The optimizations here include removing redundant computations, eliminating dead code (code that cannot be reached), and various other optimizing options, which will be explored in future chapters. It is important to note that the optimizers need not be language-specific. Since they act on the IR, they can be built as a generic component and reused with multiple languages.</p>
			<h3>Backend</h3>
			<p>The backend focuses on producing the target<a id="_idIndexMarker017"/> language. The backend receives<a id="_idIndexMarker018"/> the generated (optimized) IR and converts it into another language (such as machine code). It is also possible to chain multiple backends that convert the code into some other languages. The backend is responsible for generating the target machine code from the IR. This machine code is the actual code that runs on the bare metal. In order to produce efficient machine code, the backend should understand the architecture in which the code is executed.</p>
			<p>Machine code<a id="_idIndexMarker019"/> is a set of instructions that instructs the machine to store some values in registers and do some computation on them. For example, the generated machine code is responsible for efficiently storing a 64-bit number in 32-bit architecture in a free register (and things like that). The backend should understand the target environment to efficiently create a set of instructions and properly select and schedule the instructions to increase the performance of the application execution.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Compiler efficiency</h2>
			<p><em class="italic">The faster the execution, the better the performance.</em></p>
			<p>The efficiency of the compiler<a id="_idIndexMarker020"/> depends on how it selects the instruction, allocates the register, and schedules the instruction execution in the given architecture. An instruction set is a set of operations supported<a id="_idIndexMarker021"/> by a processor, and this overall design is called an <strong class="bold">Instruction Set Architecture</strong> (<strong class="bold">ISA</strong>). The ISA is an abstract model of a computer and is often referred to as computer architecture. Various processors convert the ISA in different implementations. The different implementations may vary in performance. The ISA is an interface between the hardware and the software.</p>
			<p>If you are implementing<a id="_idIndexMarker022"/> a new programming language and you want this language to be running on different architectures (or, more abstractly, different processors), then you should build the backend for each of these architectures/targets. But building these backends for every architecture is difficult and will take time, cost, and effort to embark on a language creation journey.</p>
			<p>What if we create a common IR and build a compiler that converts this IR into machine code that runs efficiently on various architecture? Let's call this compiler a low-level virtual machine. Now, the role of your frontend in the compiler chain is just to convert the source code into an IR that is compatible with a low-level virtual machine (such as LLVM). Now, the general purpose of a low-level virtual machine is to be a common reusable component that maps the IR into native code for various targets. But the low-level virtual machine will only understand<a id="_idIndexMarker023"/> the common IR. This IR is called the <strong class="bold">LLVM IR </strong>and the compiler is called<strong class="bold"> LLVM</strong>.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Exploring LLVM</h1>
			<p>LLVM is a part of the LLVM Project. The LLVM Project<a id="_idIndexMarker024"/> hosts compilers and toolchain technologies. The <em class="italic">LLVM core</em> is a part of the LLVM Project. The LLVM core<a id="_idIndexMarker025"/> is responsible for providing source- and target-independent optimization and for generating code for many CPU architectures. This enables language developers to just create a frontend that generates an LLVM-compatible IR or LLVM IR from the source language.</p>
			<p class="callout-heading">Did You Know?</p>
			<p class="callout">LLVM is not an acronym. When the project was started as a research project, it meant Low-Level Virtual Machine. But later, it was decided to use the name as it is rather than as an acronym.</p>
			<p>The main advantages<a id="_idIndexMarker026"/> of LLVM are as follows:</p>
			<ul>
				<li>LLVM uses a simple low-level language that looks similar to C.</li>
				<li>LLVM is strongly typed.</li>
				<li>LLVM has strictly defined semantics.</li>
				<li>LLVM has accurate and precise garbage collection.</li>
				<li>LLVM provides various optimizations that you can choose based on the requirement. It has <em class="italic">aggressive</em>, <em class="italic">scalar</em>, <em class="italic">inter-procedural</em>, <em class="italic">simple-loop</em>, and <em class="italic">profile-driven</em> optimizations.</li>
				<li>LLVM provides various compilation models. They are <em class="italic">link time</em>, <em class="italic">install time</em>, <em class="italic">runtime</em>, and <em class="italic">offline</em>.</li>
				<li>LLVM generates machine code for various target architectures.</li>
				<li>LLVM provides DWARF debugging information.<p class="callout-heading">Note</p><p class="callout">DWARF is a debugging<a id="_idIndexMarker027"/> file format used by many compilers and debuggers to support source-level debugging. DWARF is architecture-independent and applicable to any processor or operating system. It uses<a id="_idIndexMarker028"/> a data structure called a <strong class="bold">Debugging Information Entry</strong> (<strong class="bold">DIE</strong>) to represent each variable, type, procedure, and so on. </p><p class="callout">If you want to explore<a id="_idIndexMarker029"/> more about DWARF, refer to <a href="http://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf">http://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf</a>.</p><p class="callout-heading">Important Note</p><p class="callout">LLVM is not a single monolithic project. It is a collection of subprojects and other projects. These projects are used by various languages, such as Ruby, Python, Haskell, Rust, and D, for compilation. </p></li>
			</ul>
			<p>Now that we have an understanding of compilers and LLVM, we will see how it is used.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>LLVM in action</h1>
			<p>In this section, let's use LLVM's Clang compiler to compile native code into LLVM IR. This will give a better idea of how LLVM works<a id="_idIndexMarker030"/> and will be useful for understanding how the compilers use LLVM in future chapters.</p>
			<p>We first create a C file called <strong class="source-inline">sum.c</strong> and enter the following contents:</p>
			<p class="source-code"> $ touch sum.c</p>
			<p class="source-code"> // sum.c</p>
			<p class="source-code"> unsigned sum(unsigned a, unsigned b) {</p>
			<p class="source-code">    return a + b;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">sum.c</strong> file contains a simple <strong class="source-inline">sum</strong> function that takes in two unsigned integers and returns the sum of them. LLVM provides the Clang LLVM compiler to compile the C source code. In order to generate the LLVM IR, run the following command:</p>
			<p class="source-code">$ clang -S -O3 -emit-llvm sum.c</p>
			<p>We provided the Clang compiler with the <strong class="source-inline">-S</strong>, <strong class="source-inline">-O3</strong>, and <strong class="source-inline">-emit-llvm</strong> options:</p>
			<ul>
				<li>The <strong class="source-inline">-S</strong> option specifies for the compiler to only run the preprocess and compilation steps.</li>
				<li>The <strong class="source-inline">-O3</strong> option specifies for the compiler to generate a well-optimized binary.</li>
				<li>The <strong class="source-inline">-emit-llvm</strong> option specifies for the compiler to emit the LLVM IR while generating the machine code.</li>
			</ul>
			<p>The preceding code will print out the following LLVM IR:</p>
			<p class="source-code">define i32 @sum(i32, i32) local_unnamed_addr #0 {</p>
			<p class="source-code">  %3 = add i32 %1, %0</p>
			<p class="source-code">  ret i32 %3</p>
			<p class="source-code">}</p>
			<p>The syntax of the LLVM IR is structurally much closer to C. The <strong class="source-inline">define</strong> keyword defines the beginning of a function. Next to that is the return<a id="_idIndexMarker031"/> type of the function, <strong class="source-inline">i32</strong>. Next, we have the name of the function, <strong class="source-inline">@sum</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Note the <strong class="source-inline">@</strong> symbol there? LLVM uses <strong class="source-inline">@</strong> to identify the global variables and function. It uses <strong class="source-inline">%</strong> to identify the local variables.</p>
			<p>After the function name, we state the types of the input argument (<strong class="source-inline">i32</strong> in this case). The <strong class="source-inline">local_unnamed_addr</strong> attribute indicates that the address is known not to be significant within the module. The variables in the LLVM IR are <em class="italic">immutable</em>. That is, once you define them, you cannot change them. So inside the `block`, we create a new local value, <strong class="source-inline">%3</strong>, and assign it the value of <strong class="source-inline">add</strong>. <strong class="source-inline">add</strong> is an opcode that takes in the `type` of the arguments followed by the two arguments, <strong class="source-inline">%0</strong> and <strong class="source-inline">%1</strong>. <strong class="source-inline">%0</strong> and <strong class="source-inline">%1</strong> denote the first and second local variables. Finally, we return <strong class="source-inline">%3</strong> with the <strong class="source-inline">ret</strong> keyword followed by the `type`.</p>
			<p>This IR is transformable; that is, the IR can be transformed from the textual representation into memory and then into actual bit code that run on the bare metal. Also, from bit code, you can transform them back to the textual representation.</p>
			<p>Imagine that you are writing a new language. The success of the language depends on how versatile the language is at performing on various architectures. Generating optimized byte codes for various architectures (such as x86, ARM, and others) takes a long time and it is not easy. LLVM provides an easy way to achieve it. Instead of targeting the different architecture, create a compiler frontend that converts the source code into an LLVM compatible IR. Then, LLVM will convert the IR into efficient and optimized byte code that runs on any architecture.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">LLVM is an umbrella project. It has so many components that you could write a set of books on them. Covering the whole of LLVM and how to install and run them is beyond the scope of this book. If you are interested in learning more about various components of LLVM, how they work, and how to use them, then check<a id="_idIndexMarker032"/> out the website: <a href="https://llvm.org">https://llvm.org</a>.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Summary</h1>
			<p>In this chapter, we have seen how compiled languages work and how LLVM helps to compile them. We have compiled a sample program with LLVM to understand how it works. In <a id="_idTextAnchor021"/>the next chapter, we'll explore Emscripten, a tool that converts C/C++ into a WebAssembly module. Emscripten uses the LLVM backend to do the compilation.</p>
		</div>
	</body></html>