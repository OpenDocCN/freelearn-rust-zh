<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Integrating Rust with Other Languages</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Integrating Rust with Other Languages</h1>
                </header>
            
            <article>
                
<p>We will be covering the following <span>recipes in this chapter:</span></p>
<ul>
<li>Calling C operations from Rust</li>
<li>Calling Rust commands from C</li>
<li>Calling Rust operations from Node.js apps</li>
<li>Calling Rust operations from Python</li>
<li>Writing a Python module in Rust</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the techniques and steps that will help us create Rust units in our existing applications that are written in other languages, such as C, Node.js, and Python. We will deep dive into the concept of foreign function interface, which helps us in writing bindings for a foreign code base. Rust outperforms many programming languages in the aspect of stability and safer parallelism. It would be ideal for production level application developers to try out Rust for building small units in the code, and test to see if there is a considerable amount of performance change. This chapter helps to facilitate these kinds of thoughts and ideas.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calling C operations from Rust</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will call an external C function from a Rust application. This technique can be really helpful when a developer wants to use some project-specific C library dependencies in the Rust code.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following crate before we can go ahead and create the binding between Rust and C. Follow the given steps to download and set up the <kbd>libc</kbd> crate, <kbd>gcc</kbd> crate, and <kbd>gcc</kbd> compiler for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust library project using the Cargo tool:</li>
</ol>
<pre><strong>      cargo new --bin rust-to-c</strong>
</pre>
<ol start="3">
<li>Enter the newly created Rust library project:</li>
</ol>
<pre><strong>      cd rust-to-c</strong>
</pre>
<ol start="4">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification shown in the following screenshot. Here, we'll use <kbd>libc</kbd> version <kbd>0.1</kbd> and <kbd>gcc</kbd> version <kbd>0.3</kbd>, and we'll also mention the <kbd>build</kbd> script, which is <kbd>build.rs</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="187" width="399" src="images/c7b38900-6992-40b6-a9d5-d7c05456eac6.png"/></div>
<ol start="5">
<li>Install the <kbd>gcc</kbd> compiler on your machine, which is usually present by default:</li>
</ol>
<pre><strong>      sudo apt-get install gcc</strong>
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>build.rs</kbd> in the root location of the project and open it your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Build script<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 14 April 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Enter the following code in the script:</li>
</ol>
<pre>        extern crate gcc;<br/><br/>        fn main() {<br/>          gcc::Config::new().file("src/double.c")<br/>          .compile("libdouble.a");<br/>        }
</pre>
<ol start="4">
<li>Change to the <kbd>src</kbd> directory in the project:</li>
</ol>
<pre><strong>      cd src</strong>
</pre>
<ol start="5">
<li>Create the <kbd>double.c</kbd> script, which is the C application:</li>
</ol>
<pre><strong>      touch double.c</strong>
</pre>
<ol start="6">
<li>Create a <kbd>double_input</kbd> function in the <kbd>double.c</kbd> application, which we will use in the Rust application:</li>
</ol>
<pre>        int double_input(int input) {<br/>          return input * 2;<br/>        }
</pre>
<ol start="7">
<li>Enter the <kbd>main.rs</kbd> script and enter the following code:</li>
</ol>
<pre>        extern crate libc;<br/><br/>        extern {<br/>          fn double_input(input: libc::c_int) -&gt; libc::c_int;<br/>        }<br/><br/>        fn main() {<br/>          let input = 4;<br/>          let output = unsafe { double_input(input) };<br/>          println!("{} * 2 = {}", input, output);<br/>        }
</pre>
<p>We will get the following output on the successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="92" width="575" src="images/b8ca9761-3f76-4e74-801d-b0d27d75bd15.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a Rust project that can be used as a third-party package C application in the Rust code.</p>
<p>We used the <kbd>libc</kbd> crate, which is used as a library for types and bindings to native C functions that are often found in other common platform libraries. This project dependency is mentioned in the <kbd>Cargo.toml</kbd> file under the <kbd>dependencies</kbd> field, and, then, in the <kbd>build-dependencies</kbd> section of the manifest, we have <kbd>gcc</kbd> = <kbd>0.3</kbd>, which is the dependency of the <kbd>build</kbd> script.</p>
<div class="packt_infobox">The <kbd>build</kbd> script does not have the access to dependencies listed in the dependencies of the <kbd>Cargo.toml</kbd> manifest section. The <kbd>build</kbd> dependencies will not be available to the package files; this is done by the Cargo tool so that the package and the build script are compiled separately, so their dependencies need not coincide.</div>
<p>Rust provides a <kbd>build</kbd> script support where some packages need to compile third-party non-Rust code; for example, in our case we have a C script called <kbd>double.c</kbd>. The packages needed to link to C script, which can either be located on the system or possibly need to be built from source. Cargo does not replace other tools for building these packages, but it integrates them with the <kbd>build</kbd> configuration option, like, in our case, in the <kbd>package</kbd> section of the manifest, where we have a file named <kbd>build</kbd> with the <kbd>build.rs</kbd> script.</p>
<p>The Rust file designated by the <kbd>build</kbd> command, which, in our case, is <kbd>build.rs</kbd>, will be compiled first, before anything else is compiled in the package. This allows your Rust code to depend on the built or generated artifacts. In the <kbd>build.rs</kbd> script, we are building the native C code as part of the package; this package will later be used by the Rust code. We use an external crate named <kbd>gcc</kbd>, which invokes the externally maintained C compiler.</p>
<p>The <kbd>build</kbd> script starts out in the <kbd>main</kbd> function where <kbd>gcc::Config::new().file("src/double.c").compile("libdouble.a")</kbd> starts off by compiling our C file into an object file (by invoking <kbd>gcc</kbd>) and then converting the object file (<kbd>double.o</kbd>) into a static library (<kbd>libdouble.a</kbd>). The object file is stored in <kbd>target/debug/build/&lt;package&gt;/out location</kbd>.</p>
<p>In the <kbd>src</kbd> directory, we have the Rust project package file in which we have the native C script, <kbd>double.c</kbd>. The <kbd>double.c</kbd> script has a function named <kbd>double_input</kbd>, which takes in an integer argument named <kbd>input</kbd> and returns <kbd>input * 2</kbd>, which basically doubles the value passed.</p>
<p>In <kbd>main.rs</kbd>, we first import the <kbd>libc</kbd> crate and then define the function signature in the <kbd>extern</kbd> block (since it's a third-party package) as <kbd>fn double_input(input: libc::c_int) -&gt; libc::c_int</kbd>. Here, we use the <kbd>libc</kbd> type so that there is a smooth conversion of types between Rust and C, which we do not have to handle while calling the foreign function, <kbd>double_input</kbd>. From the <kbd>main</kbd> function, we place it in the <kbd>unsafe</kbd> block.</p>
<div class="packt_infobox">The <kbd>extern</kbd> block is a list of function signatures in a foreign library and the foreign functions are assumed to be unsafe. So, when we call them, <span>they</span> need to be wrapped with the <kbd>unsafe</kbd> block as a promise to the compiler that everything contained within is truly safe.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calling Rust commands from C</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will perform the exact opposite operation of the last recipe. Here, we will call a Rust function from the C script. This technique can be really helpful when the developer wants to build a specific Rust unit in their C project.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following system dependencies before we can go ahead and create a Rust unit for the C project. Follow the given steps to download and install the <kbd>build-essential</kbd> package for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust library project using the Cargo tool:</li>
</ol>
<pre><strong>      cargo new c-to-rust</strong>
</pre>
<ol start="3">
<li>Enter the newly created Rust library project:</li>
</ol>
<pre><strong>      cd c_to_rust</strong>
</pre>
<ol start="4">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="130" width="351" src="images/3432406c-c878-41d2-8a5e-a4ba0d8b6af1.png"/></div>
<ol start="5">
<li>Install the <kbd>build-essential</kbd> tool on your machine, which is usually present by default:</li>
</ol>
<pre><strong>      sudo apt-get update &amp;&amp; apt-get install build-essential</strong>
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>lib.rs</kbd> and open it in your text editor.</li>
</ol>
<ol start="2">
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Rust Function for <br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 14 April 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create the <kbd>double_input</kbd> function in <kbd>lib.rs</kbd> Rust script with the given attributes:</li>
</ol>
<pre>        #![crate_type = "staticlib"]<br/><br/>        #[no_mangle]<br/>        pub extern fn double_input(input: i32) -&gt; i32 {<br/>        input * 2<br/>        }
</pre>
<ol start="4">
<li>Create the file <kbd>main.c</kbd> in the <kbd>c_to_rust</kbd>/<kbd>src</kbd> directory, which is the C script:</li>
</ol>
<pre>        #include &lt;stdint.h&gt;<br/>        #include &lt;stdio.h&gt;<br/><br/>        extern int32_t double_input(int32_t input);<br/><br/>        int main() {<br/>        int input = 4;<br/>        int output = double_input(input);<br/>        printf("%d * 2 = %d\n", input, output);<br/>        return 0;<br/>        }
</pre>
<ol start="5">
<li>Create <kbd>Makefile</kbd> in the root location of the project directory, <kbd>c_to_rust</kbd>, for creating the <kbd>build</kbd> rules:</li>
</ol>
<pre>        ifeq ($(shell uname),Darwin)<br/>        LDFLAGS := -Wl,-dead_strip<br/>        else<br/>        LDFLAGS := -Wl,--gc-sections -lpthread<br/>        endif<br/><br/>        all: target/double<br/>        target/double<br/><br/>        target:<br/>        mkdir -p $@<br/><br/>        target/double: target/main.o<br/>        target/debug/libdouble_input.a<br/>        $(CC) -o $@ $^ $(LDFLAGS)<br/><br/>        target/debug/libdouble_input.a: src/lib.rs Cargo.toml<br/>        cargo build<br/><br/>        target/main.o: src/main.c | target<br/>        $(CC) -o $@ -c $&lt;<br/><br/>        clean:<br/>        rm -rf target
</pre>
<p>We will get the following output on the successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="320" width="628" src="images/7cb5a30d-14f0-4b52-b39a-7641619ddfd3.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created an external library in Rust, which can be used by other foreign code. The <kbd>lib.rs</kbd> file inside the <kbd>src</kbd> folder is the entry point for packages and libraries in Rust.</p>
<p>In <kbd>Cargo.toml</kbd>, while setting up the project, we set the <kbd>crate-type</kbd> field as <kbd>["staticlib"]</kbd>, which lets Cargo know the project should be compiled as a library.</p>
<div class="packt_infobox">The <kbd>lib</kbd> section helps when building a specific target. In our case, it is to <kbd>build</kbd> a package. The <kbd>name</kbd> field of a target is the name of the library that will be generated and it is the default name of the package or project. The dashes in the name of the project will be replaced with underscores.</div>
<p>In <kbd>lib.rs</kbd>, we created a <kbd>staticlib</kbd> type crate where we have the <kbd>double_input</kbd> function, which takes an integer input and returns an integer output by multiplying the input by <kbd>2</kbd>. We set the <kbd>double_input</kbd> function as public using the <kbd>pub</kbd> keyword, which allows external sources to call the function and the <kbd>extern</kbd> keyword makes this function stick to the C calling conventions. The <kbd>no_mangle</kbd> attribute turns off Rust's name mangling so that it is easier to link.</p>
<p>In the <kbd>main.c</kbd> file, we call the externally created <kbd>double_input</kbd> function using the <kbd>extern</kbd> keyword with the declaration of <kbd>int32_t double_input(int32_t input)</kbd>.</p>
<p>In order to compile and run this program, we used the <kbd>make</kbd> tool and created some rules, which are sequential steps for executing the project. We created <kbd>Makefile</kbd> where we first determined the shell using the command <kbd>($(shell uname),Darwin)</kbd> for detecting the OS type for setting the corresponding flags. If the OS is <kbd>Darwin</kbd>, then the <kbd>LDFLAGS</kbd> would be <kbd>-Wl,-dead_strip</kbd>; else <kbd>LDFLAGS</kbd> is set as <kbd>-Wl,--gc-sections -lpthread</kbd>. These are the flags to the linker (lD). The <kbd>all</kbd> rule is dependant on the <kbd>target/double</kbd> rule and it executes the same rule once the rules dependant to<kbd>target/double</kbd> are satisfied.</p>
<p>The <kbd>target</kbd> rule creates the target directory using the command <kbd>mkdir -p $@</kbd>, where <kbd>$@</kbd> refers to the left of the <kbd>:</kbd> in the rule. <span>The</span> <kbd>target/double</kbd> <span>is dependent on the rules,</span> <kbd>target/main.o</kbd> <span>and</span> <kbd>target/debug/libdouble_input.a</kbd><span>. When</span> <kbd>target/main.o</kbd> <span>runs, we are basically running</span> <kbd>cc -o target/main.o -c src/main.c</kbd><span>, which creates the</span> <kbd>main.o</kbd> <span>in the</span> <kbd>target</kbd> <span>directory. The</span> <kbd>target/debug/libdouble_input.a</kbd> <span>runs</span> <kbd>cargo build</kbd> <span>command, which creates</span> <kbd>libdouble_input.a</kbd><span>. The</span> <kbd>target/double</kbd> <span>is run with</span> <kbd>cc -o target/double target/main.o target/debug/libdouble_input.a -Wl,--gc-sections -lpthread</kbd><span>, where the links are created. Finally, the executable</span> <kbd>double</kbd> <span>is run.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calling Rust operations from Node.js apps</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will create a Rust function, which can be called from JavaScript, and this technique can be really helpful when the developer wants to improve the performance of a certain unit of their web application.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following system dependencies before we can go ahead and create a Rust unit for the Node.js project. Follow the given steps to download and install the node dependencies package for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust library project using the Cargo tool:</li>
</ol>
<pre><strong>      cargo new node-to-rust</strong>
</pre>
<ol start="3">
<li>Enter the newly created Rust library project:</li>
</ol>
<pre><strong>      cd node_to_rust</strong>
</pre>
<ol start="4">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification shown in the following screenshot:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="text-align: center;color: black;font-size: 1em" height="134" width="361" src="images/df0bb655-741d-4c15-8969-504e2df7d602.png"/></div>
<ol start="5">
<li>Install Node.js and <kbd>npm</kbd> in your machine:</li>
</ol>
<pre><strong>      sudo apt-get update</strong><br/><strong>      curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -</strong><br/><strong>      sudo apt-get install npm</strong><br/><strong>      sudo apt-get install nodejs</strong>
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Open a file named <kbd>lib.rs</kbd> located in the <kbd>node_to_rust/src</kbd> directory and open it your text editor.</li>
</ol>
<ol start="2">
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Rust Function for Js<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 14 April 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create the <kbd>double_input</kbd> function in the Rust script with the given attributes:</li>
</ol>
<pre>        #[no_mangle]<br/>        pub extern fn double_input(input: i32) -&gt; i32 {<br/>          input * 2<br/>        }
</pre>
<ol start="4">
<li>Create the <kbd>main.js</kbd> file in the <kbd>node_to_rust/src</kbd> directory, which is the JavaScript code:</li>
</ol>
<pre>        var ffi = require('ffi');<br/><br/>        var lib = ffi.Library('target/debug/libdouble_input', {<br/>        'double_input': [ 'int', [ 'int' ] ]<br/>        });<br/><br/>        var input = 4;<br/>        var output = lib.double_input(input);<br/>        console.log(input + " * 2 = " + output);
</pre>
<ol start="5">
<li>Create <kbd>Makefile</kbd> in the <kbd>node_to_rust/</kbd> directory for creating <kbd>build</kbd> rules:</li>
</ol>
<pre>        ifeq ($(shell uname),Darwin)<br/>        EXT := dylib<br/>        else<br/>        EXT := so<br/>        endif<br/><br/>        all: target/debug/libdouble_input.$(EXT)<br/>        node_modules/ffi<br/>        node src/main.js<br/><br/>        target/debug/libdouble_input.$(EXT): src/lib.rs<br/>        Cargo.toml<br/>        cargo build<br/><br/>        node_modules/ffi:<br/>        npm install ffi<br/><br/>        clean:<br/>        rm -rf target<br/>        rm -rf node_modules
</pre>
<p class="mce-root">We will get the following output on the successful execution of our code:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="78" width="594" src="images/08534f2a-ec5f-4494-a862-47a2acec8385.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we create an external library in Rust, which can be used by other foreign code. The <kbd>lib.rs</kbd> file inside the <kbd>src</kbd> folder is the entry point for packages and libraries in Rust.</p>
<p>In <kbd>Cargo.toml</kbd>, while setting up the project, we set the <kbd>crate-type</kbd> field as <kbd>["dylib"]</kbd>, which lets Cargo know the project should be compiled as a dynamic library.</p>
<p>In <kbd>lib.rs</kbd>, we created a <kbd>dylib</kbd> type crate and we have a <kbd>double_input</kbd> function, which takes an integer input and returns an integer output by doubling the given input. We can see that it's the <kbd>pub</kbd> keyword that allows external sources to call the function, and <kbd>extern</kbd> makes this function stick to the Js calling conventions. The <kbd>no_mangle</kbd> attribute turns off Rust's name mangling so that it is easier to link.</p>
<p>In the <kbd>main.js</kbd> file, where we call the externally created <kbd>double_input</kbd> function using the <kbd>ffi</kbd> node package, we create a variable, <kbd>ffi</kbd>, which is loaded with the units of <kbd>ffi</kbd> node module using the <kbd>require</kbd> keyword. Using the inbuilt <kbd>ffi.library</kbd> function, we load the <kbd>build</kbd> package at <kbd>target/debug/libdouble_input</kbd> and assign the return object type to the variable <kbd>lib</kbd>, which contains the method <kbd>double_input</kbd>. Later, we can use this function as <kbd>lib.double_int(input)</kbd>, where the <kbd>input</kbd> variable is assigned to a value of <kbd>4</kbd> in the previous statements of the Js code.</p>
<p>In order to compile and run this program, we use the <kbd>make</kbd> tool and create certain rules, which are sequential steps for executing the project. We create <kbd>Makefile</kbd> where we first determine the <kbd>($(shell uname),Darwin)</kbd> shell for detecting the OS type to set the flags. If the OS is <kbd>Darwin</kbd>, then <kbd>EXT</kbd> would be <kbd>EXT := dylib</kbd>; else <kbd>EXT</kbd> is set to <kbd><span><span>so</span></span></kbd>. The <kbd>all</kbd> rule runs <kbd>target/debug/libdouble_input.$(EXT)</kbd> and <kbd>node_modules/ffi</kbd> before executing <kbd>node src/main.js</kbd>, which will run the JavaScript and produce the logs. The first rule is <kbd>target/debug/libdouble_input.$(EXT)</kbd>, which creates the crate by building the Rust project using the <kbd>cargo build</kbd> command, and the next rule is <kbd>node_modules/ffi</kbd>, which installs the node package <kbd>ffi</kbd> by <kbd>npm install ffi</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calling Rust operations from Python</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will follow the steps that we implemented for the last two recipes where we created a Rust function and used it in other languages as integral units. Here, we will call the Rust unit using Python.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following system dependencies before we can go ahead and create a Rust unit for the Python project. Follow the given steps to download and install the node dependencies package for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust library project using the Cargo tool:</li>
</ol>
<pre><strong>      cargo new python-to-rust</strong>
</pre>
<ol start="3">
<li>Enter the newly created Rust library project:</li>
</ol>
<pre><strong>      cd python-to-rust</strong>
</pre>
<ol start="4">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="116" width="327" src="images/e7b81156-7984-4ddb-b310-c8f80b010461.png"/></div>
<ol start="5">
<li>Install Python on your machine, which is pre-installed on your machine:</li>
</ol>
<pre><strong>      sudo apt-get update </strong><br/><strong>      sudo apt-get -y upgrade</strong>
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>lib.rs</kbd> and open it your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Rust Function for python<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 14 April 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create the <kbd>double_input</kbd> function in the Rust script with the given attributes:</li>
</ol>
<pre>        #[no_mangle]<br/>        pub extern fn double_input(input: i32) -&gt; i32 {<br/>          input * 2<br/>        }
</pre>
<ol start="4">
<li>Create the <kbd>main.py</kbd> file, which is the Python code:</li>
</ol>
<pre class="mce-root">        from ctypes import cdll<br/>        from sys import platform<br/>        if platform == 'darwin':<br/>            prefix = 'lib'<br/>            ext = 'dylib'<br/>        elif platform == 'win32':<br/>            prefix = ''<br/>            ext = 'dll'<br/>        else:<br/>            prefix = 'lib'<br/>            ext = 'so'<br/>        lib = cdll.LoadLibrary('target/debug/{}double_input<br/>        .{}'.format(prefix, ext))<br/>        double_input = lib.double_input<br/>        input = 4<br/>        output = double_input(input)<br/>        print('{} * 2 = {}'.format(input, output))
</pre>
<p class="mce-root"></p>
<ol start="5">
<li>Create <kbd>Makefile</kbd> for creating the <kbd>build</kbd> rules:</li>
</ol>
<pre>        ifeq ($(shell uname),Darwin)<br/>        EXT := dylib<br/>        else<br/>        EXT := so<br/>        endif<br/><br/>        all: target/debug/libdouble_input.$(EXT)<br/>        python src/main.py<br/><br/>        target/debug/libdouble_input.$(EXT): src/lib.rs<br/>        Cargo.toml<br/>        cargo build<br/><br/>        clean:<br/>        rm -rf target
</pre>
<p>We will get the following output on the successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="83" width="673" src="images/991e769c-87fe-42aa-8b20-8f80b407658a.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created an external library in Rust, which can be used by other foreign code. The <kbd>lib.rs</kbd> file inside the <kbd>src</kbd> folder is the entry point for packages and libraries in Rust.</p>
<p>In <kbd>Cargo.toml</kbd>, while setting up the project, we set the <kbd>crate-type</kbd> field as <kbd>["dylib"]</kbd>, which lets Cargo know the project should be compiled as a dynamic library.</p>
<p>In <kbd>lib.rs</kbd>, we created a <kbd>dylib</kbd> type crate and we have a <kbd>double_input</kbd> function, which takes an integer input and returns an integer output by doubling the given input. We can see that it's the <kbd>pub</kbd> keyword that allows external sources to call the function, and <kbd>extern</kbd> makes this function stick to the Js calling conventions. The <kbd>no_mangle</kbd> attribute turns off Rust's name mangling so that it is easier to link.</p>
<p>In the <kbd>main.py</kbd> file, we call the externally created <kbd>double_input</kbd> function build using Rust code by using the <kbd>cdll</kbd> unit of the <kbd>ctypes</kbd> Python module where we use the <kbd>LoadLibrary</kbd> function. We pass the location of the <kbd>so</kbd>(shared object) file generated after compilation of the Rust project to the <kbd>LoadLibrary</kbd> Python function, which in our case is located at <kbd>target/debug/libdouble_input.so</kbd>. On successful loading of the <kbd>so</kbd> file, we assign <kbd>double_input</kbd> as <kbd>lib.double_input</kbd> and call it later in the script.</p>
<p>In order to compile and run this program, we use the <kbd>make</kbd> tool and create certain rules, which are sequential steps for executing the project. We create a <kbd>Makefile</kbd> where we first determine the <kbd>($(shell uname),Darwin)</kbd> shell for detecting the OS type to set the flags. If the OS is <kbd>Darwin</kbd> then <kbd>EXT</kbd> would be <kbd>EXT := dylib</kbd>; else <kbd>EXT</kbd> is set as <kbd><span>so</span></kbd>. The <kbd>all</kbd> rule runs <kbd>target/debug/libdouble_input.$(EXT)</kbd> before running the Python <kbd>src/main.py</kbd>. The other rule basically builds the Rust project to build the <kbd>libdouble_input.so</kbd> file, which is used by the Python script to run the corresponding <kbd>double_input</kbd> function.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing a Python module in Rust</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will create a Python module or library in Rust and import the <kbd>create</kbd> module in the Python script. Rust provides a great list of safe production-level type systems, so the current Python units of a project can be rewritten in Rust to achieve faster processing and a safer application. Here, we create a library in Rust named <kbd>example</kbd> with a function named <kbd>fibo</kbd>, which takes in an index value and produces the Fibonacci sequence value at the index.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following system dependencies before we can go ahead and create a Python module using Rust. Follow the given steps to download and install the dependencies package for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor for developing the Rust code snippet.</li>
<li>Create a Rust library project using the Cargo tool:</li>
</ol>
<pre><strong>      cargo new python-rust-library</strong>
</pre>
<ol start="3">
<li>Enter the newly created Rust library project:</li>
</ol>
<pre><strong>      cd python-rust-library</strong>
</pre>
<ol start="4">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="179" width="349" src="images/72a8d93d-4ab0-4b37-bb86-b46b5208027e.png"/></div>
<ol start="5">
<li>We need to have Python installed on the machine for the executing the steps in this recipe. In most of the systems Python comes pre-installed on the machine, if not run the following commands below:</li>
</ol>
<pre><strong>      sudo apt-get update </strong><br/><strong>      sudo apt-get -y upgrade<br/>      sudo apt-get install python-pip python-dev build-essential</strong>
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>lib.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Rust-python module<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 14 April 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Import the <kbd>cpython</kbd> library and the corresponding module:</li>
</ol>
<pre>        #[macro_use] extern crate cpython;<br/><br/>        use cpython::{Python, PyResult};
</pre>
<ol start="4">
<li>Create the <kbd>fibo</kbd> function in the Rust language, which is an implementation of the Fibonacci sequence:</li>
</ol>
<pre>        fn fibo(py: Python, n : u64) -&gt; PyResult&lt;u64&gt; {<br/>          if n &lt; 2 {<br/>            return Ok(1)<br/>          }<br/>          let mut prev1 = 1;<br/>          let mut prev2 = 1;<br/>          for _ in 1..n {<br/>            let new = prev1 + prev2;<br/>            prev2 = prev1;<br/>            prev1 = new;<br/>          }<br/>          Ok(prev1) <br/>        }
</pre>
<ol start="5">
<li>Create the Python module interface, which exposes the <kbd>fibo</kbd> function to Python calls:</li>
</ol>
<pre>        // To build a Python compatible module we need an<br/>        intialiser which expose the public interface<br/>        py_module_initializer!(example, initexample,<br/>        PyInit_example, |py, m| {<br/>        // Expose the function fibo as `extern "C"`<br/>        try!(m.add(py, "fibo", py_fn!(py, fibo(rand_int:<br/>        u64))));<br/><br/>        // Initialiser's macro needs a Result&lt;&gt; as return value<br/>        Ok(())<br/>        });
</pre>
<ol start="6">
<li>Create the <kbd>test.py</kbd> file outside the <kbd>src</kbd> directory, which is the Python code:</li>
</ol>
<pre>        import example<br/><br/>        # Running the Rust module<br/>        print(example.fibo(4))
</pre>
<ol start="7">
<li>Create <kbd>Makefile</kbd> <span>for creating <kbd>build</kbd> rules:</span></li>
</ol>
<pre>        all: run<br/><br/>        build:<br/>        cargo build --release<br/>        cp ./target/release/libexample.so ./example.so<br/><br/>        run: build<br/>        python test.py<br/><br/>        clean:<br/>        cargo clean<br/>        rm ./example.so
</pre>
<p>We will get the following output on the successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="90" width="597" src="images/d1d5f620-4601-4b7b-a74a-44283692f9ba.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we create an external library in Rust, which can be used by other foreign code. The <kbd>lib.rs</kbd> file inside the <kbd>src</kbd> folder is the entry point for packages and libraries in Rust.</p>
<p>In <kbd>Cargo.toml</kbd>, while setting up the project, we set the <kbd>crate-type</kbd> field as <kbd>["dylib"]</kbd>, which lets Cargo know that the project should be compiled as a dynamic library. The name of the library is <kbd>example</kbd>.</p>
<p>We installed the latest <kbd>rust-cpython</kbd> crate from git, which makes it possible to execute Python code from Rust and build a module in Rust for Python. The Python module created can be used for both Python 2.7 and 3; for Python 2.7 we have to enable <kbd>features = ["python27-sys"]</kbd> while building the Rust project for the first time.</p>
<p>In <kbd>lib.rs</kbd>, we import the <kbd>cpython</kbd> crate and use the modules <kbd>Python</kbd> and <kbd>PyResult</kbd>. Then, we create a Rust function named <kbd>fibo</kbd>, which has taken in arguments of the <kbd>py: Python</kbd> and <kbd>n : u64</kbd> types, and the return type is <kbd>PyResult&lt;u64&gt;</kbd>. Here the <kbd>py</kbd> argument is of the <kbd>Python</kbd> type and the return value is wrapped to be a <kbd>PyResult</kbd> type, which is an alias to the Result type curated for custom made Python operations. Since we have these types in the <kbd>rust-cpython</kbd> project, we don't have to explicitly handle type conversions from Python to Rust. In the <kbd>fibo</kbd> function, we implement the sequence.</p>
<p>If the entered <kbd>n</kbd> value is less than <kbd>2</kbd>, we return <kbd>OK(1)</kbd>, and, for all other values greater than <kbd>2</kbd>, we have two mutable variable <kbd>prev1</kbd> and <kbd>prev2</kbd> initially assigned to <kbd>1</kbd>. We then iterate using a <kbd>for</kbd> loop till <kbd>n</kbd>. Inside the <kbd>for</kbd> loop, we create an immutable variable, <kbd>new</kbd>, which is the sum of <kbd>prev1</kbd> and <kbd>prev2</kbd>. After the sum operation, the <kbd>prev1</kbd> value is assigned to <kbd>prev2</kbd> and <kbd>new</kbd> is assigned to <kbd>prev1</kbd>. We then return <kbd>OK(prev1)</kbd> once the loop ends. The next step is to expose the <kbd>fibo</kbd> function as part of the module; this can be done with the <kbd>py_module_initializer!</kbd> and <kbd>py_fn!</kbd> macros. The <kbd>py_module_initializer</kbd> macro basically creates a Python-compatible module. We need an initializer that exposes the public interface. To expose the <kbd>fibo</kbd> function, we use the <kbd>try!</kbd> macro by calling <kbd>m.add(py, "fibo", py_fn!(py, fibo(rand_int: u64)))</kbd>, where <kbd>m.add</kbd> adds the <kbd>fibo</kbd> function with the <kbd>py_fn!</kbd> macro defining the Python module. The initializer's macro needs a <kbd>Result&lt;&gt;</kbd> as the return value. So, we return <kbd>Ok(())</kbd> at the end of the macro.</p>
<p>In the <kbd>test.py</kbd> file, we import the <kbd>example</kbd> module and print the result of the Fibonacci function for an input index <kbd>4</kbd> using <kbd>print(example.fibo(4))</kbd>.</p>
<p>In order to compile and run this program, we use the <kbd>make</kbd> tool and create certain rules, which are sequential steps for executing the project. We create <kbd>Makefile</kbd> where we have the <kbd>all</kbd> rule, which depends on <kbd>run</kbd>. The <kbd>run</kbd> rule, in turn, depends on <kbd>build</kbd>. In the <kbd>build</kbd> step, the Rust projects are built using <kbd>cargo build --release</kbd>, which creates the external shared object file <kbd>libexample.so</kbd> in <kbd>target/release</kbd>. Post building, we copy the created <kbd>so</kbd> file as <kbd>example.so</kbd> in the home directory of the project where the <kbd>test.py</kbd> code is located. We then execute the <kbd>run</kbd> rule, which basically runs the <kbd>test.py</kbd> code and prints the result.</p>


            </article>

            
        </section>
    </div>
</body>
</html>