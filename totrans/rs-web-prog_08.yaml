- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building RESTful Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建RESTful服务
- en: Our to-do application, written in Rust, technically works. However, there are
    some improvements that we need to make. In this chapter, we will apply these improvements
    as we explore the concepts of the **RESTful** **API** design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用Rust编写的待办事项应用在技术上是可以工作的。然而，我们还需要做一些改进。在本章中，我们将随着对**RESTful** **API**设计概念的探索来应用这些改进。
- en: In this chapter, we will finally reject unauthorized users before the request
    hits the view by assessing the layers of our system and refactoring how we handle
    requests throughout the request lifetime. We’ll then use this authentication to
    enable individual users to have their own list of to-do items. Finally, we will
    log our requests so that we can troubleshoot our application and get a deeper
    look into how our application runs, caching data in the frontend to reduce API
    calls. We will also explore nice-to-have concepts such as executing code on command
    and creating a uniform interface to split the frontend URLs from the backend URLs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在请求击中视图之前最终拒绝未经授权的用户，通过评估我们系统的层次结构并重构我们处理请求的方式在整个请求生命周期中。然后，我们将使用这种身份验证来允许单个用户拥有他们自己的待办事项列表。最后，我们将记录我们的请求，以便我们可以调试我们的应用程序并深入了解我们的应用程序是如何运行的，在前端缓存数据以减少API调用。我们还将探索一些有用的概念，例如按命令执行代码和创建统一的接口来分割前端URL和后端URL。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are RESTful services?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是RESTful服务？
- en: Mapping our layered system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射我们的分层系统
- en: Building a uniform interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建统一接口
- en: Implementing statelessness
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现无状态
- en: Logging our server traffic
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录我们的服务器流量
- en: Caching
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Code on demand
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需代码
- en: By the end of this chapter, we will have refactored our Rust application to
    support the principles of RESTful APIs. This means that we are going to map out
    the layers of our Rust application, create uniform API endpoints, log requests
    in our application, and cache results in the frontend.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将重构我们的Rust应用程序以支持RESTful API的原则。这意味着我们将绘制出Rust应用程序的层次结构，创建统一的API端点，记录应用程序中的请求，并在前端缓存结果。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter08](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter08)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter08](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter08)找到
- en: What are RESTful services?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是RESTful服务？
- en: '`GET`), update (`PUT`), create (`POST`), and delete (`DELETE`) our users and
    to-do items. The goal of a RESTful approach is to increase speed/performance,
    reliability, and the ability to grow by reusing components that can be managed
    and updated without affecting the system.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`（获取）、`PUT`（更新）、`POST`（创建）和`DELETE`（删除）我们的用户和待办事项。RESTful方法的目的是通过重用可以管理和更新的组件来提高速度/性能、可靠性和可扩展性，这些组件不会影响系统。'
- en: 'You may have noticed that before Rust, slow, high-level languages seemed to
    be a wise choice for web development. This is because they are quicker and safer
    to write. This is due to the main bottleneck for the speed of processing data
    in web development being the network connection speed. The RESTful design aims
    to improve the speed by economizing the system, such as reducing API calls, as
    opposed to just focusing on algorithm speed. With that in mind, in this section,
    we will be covering the following RESTful concepts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在Rust之前，慢速的高级语言似乎在Web开发中是一个明智的选择。这是因为它们编写起来更快、更安全。这是由于Web开发中数据处理速度瓶颈主要是网络连接速度。RESTful设计旨在通过优化系统来提高速度，例如减少API调用，而不是仅仅关注算法速度。考虑到这一点，在本节中，我们将涵盖以下RESTful概念：
- en: '**Layered system**: This enables us to add extra functionality, such as authorization,
    without having to change the interface. For instance, if we must check the **JSON
    Web Token** (**JWT**) in every view, then this is a lot of repetitive code that
    is hard to maintain and is prone to error.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**：这使我们能够添加额外的功能，例如授权，而无需更改接口。例如，如果我们必须在每个视图中检查**JSON Web Token**（JWT），那么这将是一大堆重复的代码，难以维护且容易出错。'
- en: '**Uniform system**: This simplifies and decouples the architecture, enabling
    whole parts of the application to evolve independently without clashing.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一系统**：这简化并解耦了架构，使得应用的部分可以独立进化而不会相互冲突。'
- en: '**Statelessness**: This ensures that our application does not directly save
    anything on the server. This has implications for microservices and cloud computing.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态性**：这确保了我们的应用程序不会直接在服务器上保存任何东西。这对微服务和云计算有影响。'
- en: '**Logging**: This enables us to peek into our application and see how it runs,
    exposing undesirable behavior even if there are no errors displayed.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录**：这使我们能够窥视我们的应用程序并查看其运行情况，即使没有显示错误，也能暴露出不良行为。'
- en: '**Caching**: This enables us to store data in the frontend to reduce the number
    of API calls to our backend API.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：这使我们能够在前端存储数据，以减少对后端API的API调用次数。'
- en: '**Code on demand**: This is where our backend server directly runs code on
    the frontend.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需代码**：这是我们的后端服务器在前端直接运行代码的地方。'
- en: We’ll look at the layered system concept in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探讨分层系统概念。
- en: Mapping our layered system
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射我们的分层系统
- en: 'A layered system consists of layers with different units of functionality.
    It could be argued that these layers are different servers. This can be true in
    microservices and big systems. This can be the case when it comes to different
    layers of data. In big systems, it makes sense to have *hot data* that gets accessed
    and updated regularly and *cold data* where it is rarely accessed. However, while
    it is easy to think of layers as on different servers, they can be on the same
    server. We can map our layers with the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 分层系统由具有不同功能单元的层组成。可以认为这些层是不同的服务器。这在微服务和大型系统中可能是正确的。当涉及到数据的不同层时，这也可能是正确的。在大型系统中，拥有经常被访问和更新的*热数据*和很少被访问的*冷数据*是有意义的。然而，虽然将层视为位于不同的服务器上很容易，但它们可以位于同一服务器上。我们可以用以下图表来映射我们的层：
- en: '![Figure 8.1 – The layers in our app](img/Figure_8.1_B18722.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 我们应用程序的层](img/Figure_8.1_B18722.jpg)'
- en: Figure 8.1 – The layers in our app
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 我们应用程序的层
- en: 'As you can see, our app follows this process:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的应用程序遵循以下流程：
- en: First, our *HTTP Handler* accepts the call by listening to the port that we
    defined when creating the server.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们的*HTTP处理器*通过监听我们在创建服务器时定义的端口来接受调用。
- en: Then, it goes through the *middleware*, which is defined by using the `wrap_fn`
    function on our app.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它通过*中间件*，这是通过在我们的应用程序上使用`wrap_fn`函数定义的。
- en: Once this is done, the URL of the request is mapped to the right view and the
    schemas we defined in our `src/json_serialization/` directory. These get passed
    into the resource (our views) defined in the `src/views` directory.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，请求的URL就会被映射到正确的视图以及我们在`src/json_serialization/`目录中定义的模式。这些模式会被传递到在`src/views`目录中定义的资源（我们的视图）。
- en: If we then want to update or get data from the database, we use the Diesel ORM
    to map these requests. At this stage, all our layers have been defined to manage
    the flow of data effectively, apart from our middleware. As pointed out in the
    previous chapter, [*Chapter 7*](B18722_07.xhtml#_idTextAnchor149), *Managing User
    Sessions*, we have implemented our middleware for authentication with the `JwToken`
    struct by implementing the `FromRequest` trait. With this, we can see that we
    can implement our middleware using either the `wrap_fn` or implementing the `FromRequest`
    trait. When do you think we should use the `wrap_fn` or `FromRequest` trait? Both
    have advantages and disadvantages. If we want to implement our middleware for
    specific individual views, then implementing the `FromRequest` trait is the best
    option. This is because we can slot a struct implementing the `FromRequest` trait
    into the view that we want. Authentication is a good use case for implementing
    the `FromRequest` trait because we want to pick and choose what endpoints require
    authentication. However, if we want to implement a blanket rule, we would be better
    off implementing the selection of views for authentication in the `wrap_fn` function.
    Implementing our middleware in the `wrap_fn` function means that it is implemented
    for every request.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想更新或从数据库获取数据，我们使用Diesel ORM将这些请求映射。在这个阶段，我们已经定义了所有层来有效地管理数据流，除了我们的中间件。正如前一章所指出的，[*第7章*](B18722_07.xhtml#_idTextAnchor149)，*管理用户会话*，我们已经通过实现`FromRequest`特质来为`JwToken`结构体实现了我们的中间件以进行身份验证。有了这个，我们可以看到我们可以使用`wrap_fn`或实现`FromRequest`特质来实现我们的中间件。你认为我们应该在什么时候使用`wrap_fn`或`FromRequest`特质？两者都有优点和缺点。如果我们想为特定的单个视图实现中间件，那么实现`FromRequest`特质是最好的选择。这是因为我们可以将实现`FromRequest`特质的结构体插入我们想要的视图中。身份验证是实现`FromRequest`特质的良好用例，因为我们想挑选和选择哪些端点需要身份验证。然而，如果我们想实施一个一揽子规则，我们最好在`wrap_fn`函数中实现视图的认证选择。在`wrap_fn`函数中实现我们的中间件意味着它适用于每个请求。
- en: 'An example of this could be that we are no longer supporting version one for
    all our endpoints. If we were going to do this, we would have to warn third-party
    users of our decision to no longer support version one of our API. Once our date
    has passed, we will have to give a helpful message that we are no longer supporting
    version one. Before we start working on our middleware layer, we must define the
    following imports at the top of our `main.rs` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个例子可能是我们不再支持所有端点的版本一。如果我们打算这样做，我们必须警告第三方用户我们不再支持API的版本一的决定。一旦我们的日期过去，我们必须提供一个有用的消息，说明我们不再支持版本一。在我们开始工作于我们的中间件层之前，我们必须在`main.rs`文件顶部定义以下导入：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To ensure that we know that the incoming request is destined for a `v1` endpoint,
    we must define a flag that we can check later when deciding whether to process
    the request or reject it. We can do this by using the following code in our `main.rs`
    file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们知道进入的请求是针对一个`v1`端点的，我们必须定义一个标志，我们可以在稍后决定是否处理请求或拒绝它时进行检查。我们可以通过在我们的`main.rs`文件中使用以下代码来实现这一点：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding code, we can see that we declare that there is a Boolean
    under the name of `passed`. If `v1` is not in the URL, then it is set to `true`.
    If `v1` is present in the URL, then `passed` is set to `false`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到我们声明有一个名为`passed`的布尔值。如果`v1`不在URL中，则将其设置为`true`。如果`v1`存在于URL中，则`passed`被设置为`false`。
- en: 'Now that we have defined a flag, we can use it to dictate what happens to the
    request. Before we do this, we must take note of the last lines of `wrap_fn`,
    as denoted in this code block:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个标志，我们可以用它来决定请求会发生什么。在我们这样做之前，我们必须注意`wrap_fn`的最后几行，如以下代码块所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are waiting for the call to finish, then returning the result as the variable
    called `result`. With our blocking of the `v1` API called, we must check to see
    whether the request passes. If it does, we then run the preceding code. However,
    if the request fails, we must bypass this and define another future, which is
    just the response.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在等待调用完成，然后返回名为`result`的变量作为结果。在我们的`v1` API调用阻塞之后，我们必须检查请求是否通过。如果它通过了，我们就运行前面的代码。然而，如果请求失败，我们必须绕过这一点并定义另一个future，它只是响应。
- en: At face value, this can seem straightforward. Both will return the same thing,
    that is, a response. However, Rust will not compile. It will throw an error based
    on incompatible types. This is because `async` blocks behave like closures. This
    means that every `async` block is its own type. This can be frustrating, and due
    to this subtle detail, it can lead to developers burning hours trying to get the
    two futures to play with each other.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从字面上看，这似乎很简单。两者都将返回相同的结果，即响应。然而，Rust 不会编译。它将基于不兼容的类型抛出一个错误。这是因为`async`块的行为类似于闭包。这意味着每个`async`块都是其自己的类型。这可能会令人沮丧，并且由于这个细微的细节，它可能导致开发者花费数小时试图让两个未来相互配合。
- en: 'Luckily, there is an enum in the futures crate that solves this problem for
    us. The `Either` enum combines two different futures, streams, or sinks that have
    the same associated types into a single type. This enables us to match the `passed`
    flag, and fire and return the appropriate process with the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 futures crate 中有一个枚举可以为我们解决这个问题。`Either`枚举将具有相同关联类型的两个不同的未来、流或汇合并入一个单一类型。这使得我们能够匹配`passed`标志，并使用以下代码触发并返回适当的过程：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the preceding code, we can see that we assign `end_result` to be called
    as a view, or directly return it to an unauthorized response depending on the
    `passed` flag. We then return this at the end of `wrap_fn`. Knowing how to use
    the `Either` enum is a handy trick to have up your sleeve and will save you hours
    when you need your code to choose between two different futures.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到我们根据`passed`标志将`end_result`分配为视图调用，或者直接返回一个未授权的响应。然后我们在`wrap_fn`的末尾返回这个结果。了解如何使用`Either`枚举是一个很有用的技巧，当你需要代码在两个不同的未来之间进行选择时，这将为你节省数小时。
- en: 'To check to see whether we are blocking `v1`, we can call a simple `get` request
    as seen in the following figure:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们是否正在阻止`v1`，我们可以调用一个简单的`get`请求，如下面的图所示：
- en: '![Figure 8.2 – The response to blocked v1](img/Figure_8.2_B18722.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 阻塞 v1 的响应](img/Figure_8.2_B18722.jpg)'
- en: Figure 8.2 – The response to blocked v1
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 阻塞 v1 的响应
- en: 'We can see that our API call is blocked with a helpful message. If we do the
    API call through Postman, we will see that we get a `501 Not Implemented` error
    as seen in the following figure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的 API 调用被一个有用的消息阻止。如果我们通过 Postman 进行 API 调用，我们将看到我们得到一个`501 Not Implemented`错误，如下面的图所示：
- en: '![Figure 8.3 – Postman’s response to blocked v1](img/Figure_8.3_B18722.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 阻塞 v1 的 Postman 响应](img/Figure_8.3_B18722.jpg)'
- en: Figure 8.3 – Postman’s response to blocked v1
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 阻塞 v1 的 Postman 响应
- en: We might want to add more resources for getting items in the future. This poses
    a potential problem because some views might start clashing with the app views.
    For instance, our to-do item API views only have the prefix `item`. Getting all
    the items requires the `v1/item/get` endpoint.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望在将来添加更多获取项的资源。这可能会引起潜在的问题，因为一些视图可能会与应用程序视图发生冲突。例如，我们的待办事项项 API 视图只有前缀`item`。获取所有项需要`v1/item/get`端点。
- en: It could be reasonable to develop a view for the app that looks at a to-do item
    in detail for editing with the `v1/item/get/{id}` endpoint later. However, this
    increases the risk of clashes between the frontend app views and the backend API
    calls. To prevent this, we are going to have to ensure that our API has a uniform
    interface.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可以合理地开发一个视图，用于以后通过`v1/item/get/{id}`端点详细查看待办事项并进行编辑。然而，这增加了前端应用程序视图和后端 API 调用之间发生冲突的风险。为了防止这种情况，我们必须确保我们的
    API 具有统一的接口。
- en: Building a uniform interface
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建统一的接口
- en: 'Having a uniform interface means that our resources can be uniquely identifiable
    through a URL. This decouples the backend endpoints and frontend views, enabling
    our app to scale without clashes between the frontend views and backend endpoints.
    We have decoupled our backend from the frontend using the version tag. When a
    URL endpoint includes a version tag, such as `v1` or `v2`, we know that call is
    hitting the backend Rust server. When we are developing our Rust server, we might
    want to work on a newer version of our API calls. However, we do not want to allow
    users to access the version in development. To enable live users to access one
    version while we deploy another version on a test server, we will need to dynamically
    define the API version for the server. With the knowledge that you have acquired
    so far in this book, you could simply define the version number in the `config.yml`
    file and load it. However, we would have to read the `config.yml` config file
    for every request. Remember that when we set up the database connection pool we
    read the connection string from the `config.yml` file once, meaning that it is
    present for the entire lifetime of the program. We would like to define the version
    once and then refer to it for the lifecycle of the program. Intuitively, you might
    want to define the version in the `main` function in the `main.rs` file before
    we define the server and then access the definition of the version inside the
    `wrap_fn`, as seen in the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 具有统一的接口意味着我们的资源可以通过URL唯一识别。这解耦了后端端点和前端视图，使得我们的应用可以扩展而不会在前端视图和后端端点之间发生冲突。我们使用版本标签解耦了后端和前端。当一个URL端点包含版本标签，如`v1`或`v2`，我们知道这个调用正在击中后端Rust服务器。当我们开发我们的Rust服务器时，我们可能想要在API调用的新版本上工作。然而，我们不想允许用户访问正在开发中的版本。为了使实时用户能够访问一个版本，同时我们在测试服务器上部署另一个版本，我们需要动态地为服务器定义API版本。根据你在本书中迄今为止获得的知识，你可以在定义服务器之前，在`main.rs`文件的`main`函数中简单地定义版本号并加载它。然而，我们必须为每个请求读取`config.yml`配置文件。记住，当我们设置数据库连接池时，我们只从`config.yml`文件中读取一次连接字符串，这意味着它在程序的整个生命周期中都是存在的。我们希望定义版本一次，然后在程序的整个生命周期中引用它。直观上，你可能会想在定义服务器之前，在`main.rs`文件的`main`函数中定义版本，然后在`wrap_fn`内部访问版本的定义，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, if we try and compile the preceding code, it will fail as the lifetime
    of the `outcome` variable is not long enough. We can convert our `outcome` variable
    as a constant with the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试编译前面的代码，它将失败，因为`outcome`变量的生命周期不够长。我们可以通过以下代码将`outcome`变量转换为常量：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code will run without any lifetime issues. However, if we were
    to load our version, we will have to read it from a file. In Rust, if we read
    from a file, we do not know what the size of the variable being read from the
    file is. Therefore, the variable we read from the file is going to be a string.
    The problem here is that allocating a string is not something that can be computed
    at compile time. Therefore, we are going to have to write the version directly
    into our `main.rs` file. We can do this by using a `build` file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将无任何生命周期问题地运行。然而，如果我们加载我们的版本，我们必须从文件中读取它。在Rust中，如果我们从文件中读取，我们不知道从文件中读取的变量的大小。因此，我们从文件中读取的变量将是一个字符串。这里的问题是分配字符串不是在编译时可以计算的事情。因此，我们将不得不直接将版本写入我们的`main.rs`文件。我们可以通过使用`build`文件来实现这一点。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We utilize `build` files in this problem to teach the concept of `build` files
    so you can use them if needed. There is nothing stopping you from hardcoding the
    constant in the code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个问题中利用`build`文件来教授`build`文件的概念，这样你如果需要的话就可以使用它们。没有任何阻止你在代码中硬编码常量的因素。
- en: 'This is where a single Rust file runs before the Rust application is run. This
    `build` file will automatically run when we are compiling the main Rust application.
    We can define the dependencies needed to run our `build` file in the `build dependencies`
    section in the `Cargo.toml` file with the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Rust应用程序运行之前单个Rust文件运行的阶段。当我们在编译主Rust应用程序时，这个`build`文件将自动运行。我们可以在`Cargo.toml`文件的`build
    dependencies`部分定义运行我们的`build`文件所需的依赖项，以下是一段代码：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This means that our `build` Rust file is defined in the root of the application
    in the `build.rs` file. We will then define the dependencies needed for the build
    phase in the `[build-dependencies]` section. Now that our dependencies are defined,
    our `build.rs` file can take the following form:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的 `build` Rust 文件定义在应用程序的根目录中的 `build.rs` 文件中。然后，我们在 `[build-dependencies]`
    部分中定义构建阶段所需的依赖项。现在，我们的依赖项已经定义，我们的 `build.rs` 文件可以采取以下形式：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here we can see that we need to import what we need to read from a YAML file
    and write it to a standard text file. Then, we will open a `build_config.yml`
    file, which is in the root of the web application next to the `config.yml` file.
    We will then extract the `ALLOWED_VERSION` from the `build_config.yml` file and
    write it into a text file. Now that we have defined the build process and what
    is needed from the `build_config.yml` file, our `build_config.yml` file will have
    to take the following form:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们需要从 YAML 文件中导入我们需要读取的内容，并将其写入标准文本文件。然后，我们将打开一个 `build_config.yml`
    文件，该文件位于 Web 应用程序的根目录中，与 `config.yml` 文件相邻。然后，我们将从 `build_config.yml` 文件中提取 `ALLOWED_VERSION`
    并将其写入文本文件。现在我们已经定义了构建过程以及从 `build_config.yml` 文件中需要的内容，我们的 `build_config.yml`
    文件将必须采取以下形式：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have everything defined for our build, we can introduce a `const`
    instance for our version through the file that we wrote to in our `build.rs` file.
    To do this, our `main.rs` file will need a few changes. First, we define the `const`
    with the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的构建定义了一切，我们可以通过我们在 `build.rs` 文件中写入的文件引入一个 `const` 实例来表示我们的版本。为此，我们的
    `main.rs` 文件需要一些更改。首先，我们使用以下代码定义 `const`：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then deem the request to pass if the version is allowed with the following
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码认为请求通过，如果版本是被允许的：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we define the error response and service call with the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码定义错误响应和服务调用：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We are now ready to build and run our application with a specific version supported.
    If we run our application and make a `v2` request, we get the following response:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构建并运行我们的应用程序，并支持特定版本。如果我们运行我们的应用程序并发出一个 `v2` 请求，我们会得到以下响应：
- en: '![Figure 8.4 – Postman response to blocked v2](img/Figure_8.4_B18722.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 邮递员对被阻止 v2 的响应](img/Figure_8.4_B18722.jpg)'
- en: Figure 8.4 – Postman response to blocked v2
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 邮递员对被阻止 v2 的响应
- en: We can see that our version guard is now working. This also means that we must
    use the React application to access the frontend views or you can add a `v1` to
    the frontend API endpoints.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的版本保护器现在正在工作。这也意味着我们必须使用 React 应用程序来访问前端视图，或者你可以在前端 API 端点中添加一个 `v1`。
- en: Now, if we run our app, we can see that our frontend works with the new endpoints.
    With this, we are one step closer to developing a RESTful API for our app. However,
    we still have some glaring shortcomings. Right now, we can create another user
    and log in under that user. In the next section, we’ll explore how to manage our
    user state in a stateless fashion.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的应用程序，我们可以看到我们的前端与新的端点一起工作。有了这个，我们离为我们的应用程序开发 RESTful API 又近了一步。然而，我们仍然有一些明显的不足。目前，我们可以创建另一个用户并使用该用户登录。在下一节中，我们将探讨如何以无状态的方式管理我们的用户状态。
- en: Implementing statelessness
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现无状态
- en: Statelessness is where the server does not store any information about the client
    session. The advantages here are straightforward. It enables our application to
    scale more easily as we free up resources on the server side by storing session
    information on the client’s side instead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态是指服务器不存储任何关于客户端会话的信息。这里的优势是显而易见的。它使我们的应用程序能够更容易地扩展，因为我们通过在客户端而不是服务器端存储会话信息来释放服务器端的资源。
- en: It also empowers us to be more flexible with our computing approach. For instance,
    let’s say that our application has exploded in popularity. As a result, we may
    want to spin our app up on two computing instances or servers and have a load
    balancer direct traffic to both instances in a balanced manner. If information
    is stored on the server, the user will have an inconsistent experience.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使我们能够更灵活地选择计算方法。例如，假设我们的应用程序在受欢迎程度上爆炸式增长。结果，我们可能希望在我们的两个计算实例或服务器上启动我们的应用程序，并让负载均衡器以平衡的方式将流量引导到这两个实例。如果信息存储在服务器上，用户将会有不一致的体验。
- en: 'They may update the state of their session on one computing instance, but then,
    when they make another request, they may hit another computing instance that has
    outdated data. Considering this, statelessness cannot just be achieved by storing
    everything in the client. If our database is not dependent on a computing instance
    of our app, we can also store our data on this database, as shown in the following
    diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可能在某个计算实例上更新会话状态，但当他们再次请求时，他们可能会遇到另一个具有过时数据的计算实例。考虑到这一点，仅仅通过在客户端存储所有内容来实现无状态是不够的。如果我们的数据库不依赖于我们应用程序的计算实例，我们也可以在这个数据库上存储我们的数据，如下面的图所示：
- en: '![Figure 8.5 – Our stateless approach](img/Figure_8.5_B18722.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 我们的无状态方法](img/Figure_8.5_B18722.jpg)'
- en: Figure 8.5 – Our stateless approach
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 我们的无状态方法
- en: 'As you can see, our app is already stateless. It stores the user ID in a JWT
    in the frontend and we store our user data models and to-do items in our PostgreSQL
    database. However, we might want to store Rust structs in our application. For
    instance, we could build a struct that counts the number of requests hitting the
    server. With reference to *Figure 8**.5*, we cannot just save our structs locally
    on the server. Instead, we will store our structs in Redis, carrying out the processes
    in the following figure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的应用程序已经是无状态的。我们在前端将用户ID存储在JWT中，并将我们的用户数据模型和待办事项存储在我们的PostgreSQL数据库中。然而，我们可能想在应用程序中存储Rust结构体。例如，我们可以构建一个结构体来计算击中服务器的请求数量。根据*图8**.5*，我们不能仅仅在服务器上本地保存我们的结构体。相反，我们将我们的结构体存储在Redis中，按照以下图中的过程执行：
- en: '![Figure 8.6 – Steps to saving structs in Redis](img/Figure_8.6_B18722.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 在Redis中保存结构体的步骤](img/Figure_8.6_B18722.jpg)'
- en: Figure 8.6 – Steps to saving structs in Redis
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 在Redis中保存结构体的步骤
- en: The difference between PostgreSQL and Redis
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL和Redis之间的区别
- en: Redis is a database, but it is different from a PostgreSQL database. Redis is
    closer to a key-value store. Redis is also fast due to the data being in memory.
    While Redis is not as complete as PostgreSQL for managing tables and how they
    relate to each other, Redis does have advantages. Redis supports useful data structures
    such as lists, sets, hashes, queues, and channels. You can also set expiry times
    on the data that you insert into Redis. You also do not need to handle data migrations
    with Redis. This makes Redis an ideal database for caching data that you need
    quick access to, but you are not too concerned about persistence. For the channels
    and queues, Redis is also ideal for facilitating communications between subscribers
    and publishers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个数据库，但它与PostgreSQL数据库不同。Redis更接近于键值存储。由于数据存储在内存中，Redis也很快。虽然Redis在管理表及其相互关系方面不如PostgreSQL完整，但它确实具有优势。Redis支持有用的数据结构，如列表、集合、散列、队列和通道。您还可以为插入Redis的数据设置过期时间。您也不需要使用Redis处理数据迁移。这使得Redis成为缓存您需要快速访问但不太关心持久性的数据的理想数据库。对于通道和队列，Redis也是促进订阅者和发布者之间通信的理想选择。
- en: 'We can achieve the process in *Figure 8**.6* by carrying out the following
    steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下步骤来实现*图8**.6*中的过程：
- en: Define Redis service for Docker.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义Redis服务的Docker。
- en: Update Rust dependencies.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Rust依赖项。
- en: Update our config file for a Redis connection.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Redis连接的配置文件。
- en: Build a counter struct that can be saved and loaded in a Redis database.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个可以保存和加载到Redis数据库中的计数器结构体。
- en: Implement the counter for each request.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个请求实现计数器。
- en: 'Let’s go over each step in detail:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细回顾每个步骤：
- en: 'When it comes to spinning up a Redis Docker service, we need to use a standard
    Redis container with standard ports. After we have implemented our Redis service,
    our `docker-compose.yml` file should have the current state:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到启动Redis Docker服务时，我们需要使用标准Redis容器和标准端口。在我们实现了Redis服务之后，我们的`docker-compose.yml`文件应该处于以下状态：
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see that we now have the Redis service and the database service running
    on the local machine. Now that Redis can be run, we need to update our dependencies
    in the next step.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们现在已经在本地机器上运行了Redis服务和数据库服务。现在Redis可以运行，我们需要在下一步更新我们的依赖项。
- en: 'Recalling *Figure 8**.6*, we need to serialize the Rust struct into bytes before
    inserting it into Redis. With these steps in mind, we need the following dependencies
    in our `Cargo.toml` file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾*图8**.6*，在将数据插入Redis之前，我们需要将Rust结构体序列化为字节。考虑到这些步骤，我们需要在`Cargo.toml`文件中添加以下依赖项：
- en: '[PRE29]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We are using the `redis` crate to connect to the Redis database. Now that our
    dependencies are defined, we can start defining our config file in the next step.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`redis`crate连接到Redis数据库。现在我们的依赖项已经定义，我们可以开始定义我们的配置文件。
- en: 'When it comes to our `config.yml` file, we must add the URL for the Redis database
    connection. At this point in time of the book, our `config.yml` file should have
    the following form:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到我们的`config.yml`文件时，我们必须添加Redis数据库连接的URL。在本书的这个时间点，我们的`config.yml`文件应该具有以下形式：
- en: '[PRE32]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have not added the port number for our `REDIS_URL` parameter. This is because
    we are using the standard port in our Redis service, which is `6379`, so we do
    not have to define the port. We now have all the data ready to define a struct
    that can connect to Redis, which we will do in the next step.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有为`REDIS_URL`参数添加端口号。这是因为我们正在使用Redis服务的标准端口，即`6379`，所以我们不需要定义端口。我们现在有了所有数据，可以定义一个可以连接到Redis的结构体，我们将在下一步中这样做。
- en: 'We will define our `Counter` struct in the `src/counter.rs` file. First, we
    will have to import the following:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`src/counter.rs`文件中定义我们的`Counter`结构体。首先，我们必须导入以下内容：
- en: '[PRE36]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will be using the `Config` instance to get the Redis URL, and the `Deserialize`
    and `Serialize` traits to enable conversion to bytes. Our `Counter` struct takes
    the following form:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`Config`实例来获取Redis URL，并使用`Deserialize`和`Serialize`特质来启用转换为字节。我们的`Counter`结构体具有以下形式：
- en: '[PRE38]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that we have our `Counter` struct defined with all the traits, we need
    to define the functions that are required for our operations with the following
    code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了具有所有特质的`Counter`结构体，我们需要定义以下代码中所需的函数：
- en: '[PRE42]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With the preceding functions defined, we can load and save our `Counter` struct
    into the Redis database. When it comes to building our `get_redis_url` function,
    it should be no surprise that it can take the following form:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义了前面的函数之后，我们可以将我们的`Counter`结构体加载和保存到Redis数据库中。当涉及到构建我们的`get_redis_url`函数时，它应该具有以下形式：
- en: '[PRE53]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now that we have the Redis URL, we can save our `Counter` struct with the following
    code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了Redis URL，我们可以使用以下代码保存我们的`Counter`结构体：
- en: '[PRE59]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here, we can see that we can serialize our `Counter` struct to a `Vec<u8>`.
    We will then define the client for the Redis and insert our serialized `Counter`
    struct under the key `"COUNTER"`. There are more features to Redis, however, you
    can utilize Redis for this chapter by thinking about Redis as being a big scalable
    in-memory hashmap. With the hashmap concept in mind, how do you think we could
    get the `Counter` struct from the Redis database? You probably guessed it; we
    use the `GET` command with the `"COUNTER"` key and then deserialize it with the
    following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们可以将我们的`Counter`结构体序列化为`Vec<u8>`。然后我们将定义Redis客户端，并在键`"COUNTER"`下插入我们的序列化`Counter`结构体。然而，Redis还有更多功能，但你可以通过将Redis视为一个大型的可扩展内存哈希表来利用Redis本章。带着哈希表的概念，你认为我们如何从Redis数据库中获取`Counter`结构体？你可能已经猜到了；我们使用带有`"COUNTER"`键的`GET`命令，然后使用以下代码反序列化：
- en: '[PRE77]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We have now defined our `Counter` struct. We have everything in-line to implement
    in our `main.rs` file in the next step.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了`Counter`结构体。我们已经在`main.rs`文件中实现了所有内容。
- en: 'When it comes to increasing the count by one every time a request comes in,
    we need to carry out the following code in the `main.rs` file:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当每次接收到请求时增加计数，我们需要在`main.rs`文件中执行以下代码：
- en: '[PRE95]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Here, we can see that we define the `counter` module. Before we spin up the
    server, we need to create the new `Counter` struct and insert it into Redis. We
    then get the `Counter` from Redis, increase the count, then save it for every
    request.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们定义了`counter`模块。在我们启动服务器之前，我们需要创建新的`Counter`结构体并将其插入Redis。然后我们从Redis获取`Counter`，增加计数，然后为每个请求保存它。
- en: 'Now when we run our server, we can see that our counter is increasing every
    time we hit our server with a request. Our printout should look like the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行服务器时，我们可以看到每次我们用请求击中我们的服务器时，计数器都在增加。我们的打印输出应该如下所示：
- en: '[PRE115]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Now that we have integrated another storage option, our app essentially functions
    the way we want it to. If we wanted to ship our application now, there is nothing
    really stopping us from configuring the build with Docker and deploying it on
    a server with a database and **NGINX**.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经集成了另一个存储选项，我们的应用程序本质上按我们想要的方式运行。如果我们现在想要发布我们的应用程序，实际上没有什么能阻止我们使用Docker配置构建，并在带有数据库和**NGINX**的服务器上部署它。
- en: Concurrency issues
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 并发问题
- en: If two servers request the counter at the same time, there is a risk of missing
    a request. The counter example was explored to demonstrate how to store serialized
    structs in Redis. If you need to implement a simple counter in a Redis database
    and concurrency is a concern, it is suggested that you use the `INCR` command.
    The `INCR` command increases the number under the key you select by one in the
    Redis database, returning the new increased number as a result. Seeing as the
    counter is increased in the Redis database, we have reduced the risk of concurrency
    issues.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个服务器同时请求计数器，可能会错过请求。计数器示例被探索以展示如何将序列化结构存储在Redis中。如果您需要在Redis数据库中实现一个简单的计数器并且并发是一个关注点，建议您使用`INCR`命令。`INCR`命令在Redis数据库中增加所选键下的数字，并返回新的增加后的数字。鉴于计数器在Redis数据库中增加，我们已经降低了并发问题的风险。
- en: However, there are always things we can add. In the next section, we’ll investigate
    logging requests.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们总是可以添加一些内容。在下一节中，我们将研究日志请求。
- en: Logging our server traffic
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录我们的服务器流量
- en: So far, our application does not log anything. This does not directly affect
    the running of the app. However, there are some advantages to logging. Logging
    enables us to debug our applications.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序没有记录任何内容。这不会直接影响应用程序的运行。然而，日志记录有一些优点。日志记录使我们能够调试我们的应用程序。
- en: 'Right now, as we are developing locally, it may not seem like logging is really
    needed. However, in a production environment, there are many reasons why an application
    can fail, including Docker container orchestration issues. Logs that note what
    processes have happened can help us to pinpoint an error. We can also use logging
    to see when edge cases and errors arise for us to monitor the general health of
    our application. When it comes to logging, there are four types of logs that we
    can build:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，由于我们正在本地开发，可能感觉日志记录并不是真的必要。然而，在生产环境中，有许多原因可能导致应用程序失败，包括Docker容器编排问题。记录已发生的过程的日志可以帮助我们定位错误。我们还可以使用日志来查看边缘情况和错误何时出现，以便监控应用程序的整体健康状况。在日志记录方面，我们可以构建四种类型的日志：
- en: '**Informational (info)**: This is general logging. If we want to track a general
    process and how it is progressing, we use this type of log. Examples of using
    this are starting and stopping the server and logging certain checkpoints that
    we want to monitor, such as HTTP requests.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息性（info）**: 这是一种通用日志记录。如果我们想跟踪一般过程及其进展，我们使用这种类型的日志。使用示例包括启动和停止服务器，以及记录我们想要监控的某些检查点，例如HTTP请求。'
- en: '**Verbose**: This is information such as the type defined in the previous point.
    However, it is more granular to inform us of a more detailed flow of a process.
    This type of log is mainly used for debugging purposes and should generally be
    avoided when it comes to production settings.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗长**: 这类信息类似于前一点中定义的类型。然而，它提供了更细粒度的信息，以告知我们过程的更详细流程。这种类型的日志主要用于调试目的，并且在生产设置中通常应避免使用。'
- en: '**Warning**: We use this type when we are logging a process that is failing
    and should not be ignored. However, we can use this instead of raising an error
    because we do not want the service to be interrupted or the user to be aware of
    the specific error. The logs themselves are for us to be alerted of the problem
    to allow us to then act. Problems such as calls to another server failing are
    appropriate for this category.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告**: 我们在记录一个失败的过程且不应被忽略时使用此类型。然而，我们可以使用此代替引发错误，因为我们不希望服务中断或用户意识到具体的错误。日志本身是为了让我们意识到问题，以便我们可以采取行动。如调用另一个服务器失败等问题适合此类。'
- en: '**Error**: This is where the process is interrupted due to an error and we
    need to sort it out as quickly as possible. We also need to inform the user that
    the transaction did not go through. A good example of this is a failure to connect
    or insert data into a database. If this happens, there is no record of the transaction
    happening and it cannot be solved retroactively. However, it should be noted that
    the process can continue running.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**: 这是指由于错误而中断过程的地方，我们需要尽快解决这个问题。我们还需要通知用户交易没有完成。一个很好的例子是连接或向数据库插入数据失败。如果发生这种情况，交易发生的记录将不存在，并且无法事后解决。然而，应该注意的是，过程可以继续运行。'
- en: If a warning comes up about the server failing to send an email, connect to
    another server to dispatch a product for shipping, and so on. Once we have sorted
    out the problem, we can retroactively make a database call to transactions in
    this timeframe and make the calls to the server with the right information.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现关于服务器无法发送电子邮件、连接到另一个服务器以调度产品进行发货等问题警告。一旦我们解决了问题，我们可以在这一时间段内回溯性地进行数据库调用，并使用正确的信息调用服务器。
- en: In the worst case, there will be a delay. With the error type, we will not be
    able to make the database call as the server was interrupted by an error before
    the order was even entered in the database. Considering this, it is clear why
    error logging is highly critical, as the user needs to be informed that there
    is a problem and their transaction did not go through, prompting them to try again
    later.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，会有延迟。由于服务器在订单甚至进入数据库之前就被错误中断，我们将无法进行数据库调用。考虑到这一点，很明显为什么错误日志记录非常重要，因为用户需要被告知存在问题，并且他们的交易没有完成，这会促使他们稍后再次尝试。
- en: We could consider the option of including enough information in the error logs
    to retroactively go back and update the database and complete the rest of the
    process when the issue is resolved, removing the need to inform the user. While
    this is tempting, we must consider two things. Log data is generally unstructured.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑在错误日志中包含足够的信息，以便在问题解决后回溯性地更新数据库并完成剩余的过程，从而消除通知用户的需求。虽然这很有吸引力，但我们必须考虑两件事。日志数据通常是未结构化的。
- en: There is no quality control for what goes into a log. Therefore, once we have
    finally managed to manipulate the log data into the right format, there is still
    a chance that corrupt data could find its way into the database.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 进入日志的内容没有质量控制。因此，一旦我们最终成功将日志数据转换成正确的格式，仍然有可能损坏的数据会进入数据库。
- en: The second issue is that logs are not considered secure. They get copied and
    sent to other developers in a crisis and they can be plugged into other pipelines
    and websites, such as *Bugsnag*, to monitor logs. Considering the nature of logs,
    it is not good practice to have any identifiable information in a log.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是日志不被认为是安全的。它们被复制并发送给其他开发人员在危机中，并且可以被插入到其他管道和网站上，例如 *Bugsnag*，以监控日志。考虑到日志的性质，在日志中包含任何可识别的信息都不是一个好的做法。
- en: 'Now that we have understood the uses of logging, we can start configuring our
    own logger. When it comes to logging, we are going to use the Actix-web logger.
    This gives us flexibility on what we log while having the underlying mechanics
    of logging configured and working well with our Actix server. To build our logger,
    we must define a new crate in our `Cargo.toml` file with the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了日志记录的用途，我们可以开始配置我们自己的记录器。当涉及到日志记录时，我们将使用Actix-web记录器。这让我们在配置和良好地与我们的Actix服务器一起工作的情况下，有灵活性来记录什么。为了构建我们的记录器，我们必须在`Cargo.toml`文件中定义一个新的crate，以下代码：
- en: '[PRE116]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'This enables us to configure a logger using environment variables. We can now
    focus on `main.rs` as this is where our logger is configured and used. First,
    we will import our logger with the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用环境变量来配置记录器。现在我们可以专注于`main.rs`，因为这是我们的记录器被配置和使用的地方。首先，我们将使用以下代码导入我们的记录器：
- en: '[PRE117]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'With this import, we can define our logger in the `main` function with the
    following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个导入，我们可以在`main`函数中定义我们的记录器，以下代码：
- en: '[PRE118]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Here, we are stating that our logger is going to log information to the info
    stream. With the logger configured, we can then wrap our server with the logger
    using the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明我们的记录器将信息记录到info流中。记录器配置完成后，我们可以使用以下代码将记录器包装到我们的服务器上：
- en: '[PRE119]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We can see in our logger that we passed in the `"&a %{User-Agent}I %r %s %D"`
    string. This string is interpreted by the logger, tell them what to log. The Actix
    logger can take the following inputs:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的记录器中看到我们传递了`"&a %{User-Agent}I %r %s %D"`字符串。这个字符串被记录器解释，告诉它们要记录什么。Actix记录器可以接受以下输入：
- en: '`%%`: The percent sign'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%%`: 百分号'
- en: '`%a`: The remote IP address (IP address of proxy if using reverse proxy)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%a`: 远程IP地址（如果使用反向代理，则为代理的IP地址）'
- en: '`%t`: The time when the request was started to process'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%t`: 请求开始处理的时间'
- en: '`%P`: The process ID of the child that serviced the request'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%P`: 服务请求的子进程的进程ID'
- en: '`%r`: The first line of request'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%r`: 请求的第一行'
- en: '`%s`: The response status code'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%s`: 响应状态码'
- en: '`%b`: The size of the response in bytes, including HTTP headers'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%b`: 响应的大小（包括HTTP头部的字节数）'
- en: '`%T`: The time taken to serve the request, in seconds with floating fraction
    in .06f format'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%T`：处理请求所需的时间，以秒为单位，带有小数点后六位的浮点格式'
- en: '`%D`: The time taken to serve the request, in milliseconds'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%D`：处理请求所需的时间，以毫秒为单位'
- en: '`%{``FOO}i`: `request.headers[''FOO'']`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%{``FOO}i`：`request.headers[''FOO'']`'
- en: '`%{``FOO}o`: `response.headers[''FOO'']`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%{``FOO}o`：`response.headers[''FOO'']`'
- en: '`%{``FOO}e`: `os.environ[''FOO'']`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%{``FOO}e`：`os.environ[''FOO'']`'
- en: 'With these inputs, we can work out that we are going to log the remote IP address,
    user-agent, endpoint of the request, and the time taken to process the request.
    We will do this for every request that our Rust server has. Starting our Rust
    server with the logging gives us the following output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些输入，我们可以计算出我们将记录远程IP地址、用户代理、请求端点和处理请求所需的时间。我们将为我们的Rust服务器上的每个请求都这样做。以日志记录启动我们的Rust服务器会给我们以下输出：
- en: '[PRE120]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Here, we can see that the time of the starting of the server with the number
    of workers is automatically logged. Then, if we start our frontend, we should
    be prompted to log in as the token should have expired by now. A full standard
    request log should look like the following output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到服务器启动时自动记录了工作进程的数量。然后，如果我们启动我们的前端，我们应该被提示登录，因为令牌现在应该已经过期了。一个完整的标准请求日志应该看起来像以下输出：
- en: '[PRE121]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We can see the time, the fact that it is an `INFO`-level log, and what logger
    is logging it. We can also see my IP address, which is local as I am running my
    application locally, my computer/browser details, and the API call with a `401`
    response code. If we trim everything from the request log apart from the method,
    API endpoint, response code, and response time, our login prompt will look like
    the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到时间、这是一个`INFO`级别的日志以及哪个记录器记录了它。我们还可以看到我的IP地址，因为我是在本地运行我的应用程序，我的电脑/浏览器详情以及带有`401`响应代码的API调用。如果我们从请求日志中删除除方法、API端点、响应代码和响应时间之外的所有内容，我们的登录提示将看起来像以下：
- en: '[PRE122]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We can see that I fail in getting items, with an unauthorized response. I then
    log in and get an `OK` response from the login. Here, we can see an `OPTIONS`
    and `POST` method. The `OPTIONS` method is for our CORS, which is why the `OPTIONS`
    calls processing time is a fraction of other API requests. We can see that we
    then get our items that are then rendered to the page. However, we can see what
    happens in the following logs when we refresh the page:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我在获取项目时失败了，得到了一个未授权的响应。然后我登录并从登录中得到了一个`OK`响应。在这里，我们可以看到一个`OPTIONS`和`POST`方法。`OPTIONS`方法是为了我们的CORS，这就是为什么`OPTIONS`调用处理时间只是其他API请求的一小部分。我们可以看到我们随后得到了我们的项目，然后渲染到页面上。然而，我们可以看到在刷新页面时以下日志中发生的事情：
- en: '[PRE123]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We can see that there are two `GET` requests for the items. However, we have
    not altered the to-do items in the database. This is not an error, but it is wasteful.
    To optimize this, we can utilize the REST constraint of caching in the following
    section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有两个针对项目的`GET`请求。然而，我们没有更改数据库中的待办事项。这不是错误，但这是浪费的。为了优化这一点，我们可以在下一节利用缓存的REST约束。
- en: Caching
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: Caching is where we store data in the frontend to be reused. This enables us
    to reduce the number of API calls to the backend and reduce latency. Because the
    benefits are so clear, it can be tempting to cache everything. However, there
    are some things to consider.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是我们将数据存储在前端以便重复使用的地方。这使我们能够减少对后端API调用的次数并降低延迟。因为好处如此明显，所以可能会诱使我们缓存一切。然而，还有一些事情需要考虑。
- en: Concurrency is a clear issue. The data could be outdated, leading to confusion
    and data corruption when sending the wrong information to the backend. There are
    also security concerns. If one user logs out and another user logs in on the same
    computer, there is a risk that the second user will be able to access the first
    user’s items. With this, there must be a couple of checks in place. The correct
    user needs to be logged in and the data needs to be timestamped so that if the
    cached data is accessed past a certain period, a `GET` request is made to refresh
    the data.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是一个明显的问题。数据可能会过时，导致发送错误信息到后端时产生混淆和数据损坏。也存在安全方面的担忧。如果一个用户注销，另一个用户在同一台电脑上登录，那么第二个用户可能会访问第一个用户的物品。因此，必须有一些检查措施。正确的用户需要登录，数据需要带时间戳，这样如果缓存的数据在某个时间段后被访问，就会发起一个`GET`请求来刷新数据。
- en: 'Our application is fairly locked down. We cannot access anything unless we
    are logged in. The main process that we could cache in our application is the
    `GET` items call. All other calls that edit the state of the item list in the
    backend return the updated items. Considering this, our caching mechanism looks
    like the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序相当安全。除非我们登录，否则我们无法访问任何内容。我们可以在应用程序中缓存的主体过程是`GET`项目调用。所有其他编辑后端项目列表状态的调用都会返回更新后的项目。考虑到这一点，我们的缓存机制看起来如下：
- en: '![Figure 8.7 – Our caching approach](img/Figure_8.7_B18722.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 我们的缓存方法](img/Figure_8.7_B18722.jpg)'
- en: Figure 8.7 – Our caching approach
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 我们的缓存方法
- en: The loop in the diagram can be executed as many times as we want when refreshing
    the page. However, this might not be a good idea. If a user logs onto our application
    on their phone when they are in the kitchen to update the list, then the user
    will have a problem when they go back to their computer to do some work, refreshing
    the page on the computer and updating the list. This caching system would expose
    the user to out-of-date data that will be sent to the backend. We can reduce the
    risk of this happening by referencing the time stamp. When the timestamp is older
    than the cutoff, we will then make another API call to refresh the data when the
    user refreshes the page.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中的循环可以在刷新页面时执行任意多次。然而，这可能不是一个好主意。如果一个用户在厨房使用手机登录我们的应用程序来更新列表，那么当用户回到电脑上工作并刷新电脑页面时，用户会遇到问题。这个缓存系统会暴露用户给过时的数据，这些数据将被发送到后端。我们可以通过引用时间戳来降低这种情况发生的风险。当时间戳超过截止时间时，我们将在用户刷新页面时发起另一个API调用以刷新数据。
- en: 'When it comes to our caching logic, it will all be implemented in the `front_end/src/App.js`
    file under the `getItems` function. Our `getItems` function will take the following
    layout:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到我们的缓存逻辑时，它将全部在`front_end/src/App.js`文件下的`getItems`函数中实现。我们的`getItems`函数将具有以下布局：
- en: '[PRE124]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Here, we state that the time difference between the last cached items and the
    current time must be less than 120 seconds, which is 2 minutes. If the time difference
    is below 2 minutes, we will get our data from the cache. However, if the time
    difference is above 2 minutes, then we make a request to our API backend. If we
    get an unauthorized response, we will then log out. First, in this `getItems`
    function, we get the date that the items were cached and calculate the difference
    between then and now, using the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明最后缓存的项和当前时间之间的时间差必须小于120秒，即2分钟。如果时间差低于2分钟，我们将从缓存中获取我们的数据。然而，如果时间差超过2分钟，我们将向我们的API后端发起请求。如果我们收到未授权的响应，我们将注销。首先，在这个`getItems`函数中，我们获取项目缓存的日期，并使用以下代码计算那时和现在之间的差异：
- en: '[PRE125]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If our time difference is 2 minutes, we will get our data from the local storage
    and update our state with that data with the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的时间差是2分钟，我们将从本地存储中获取我们的数据，并使用以下代码用这些数据更新我们的状态：
- en: '[PRE126]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Here, we must parse the data from the local storage because the local storage
    only handles string data. Because local storage only handles strings, we must
    stringify the data that we are inserting into the local storage when we make the
    API request with the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须解析来自本地存储的数据，因为本地存储只处理字符串数据。由于本地存储只处理字符串，我们必须在用以下代码发起API请求时将我们插入本地存储的数据进行字符串化：
- en: '[PRE127]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'If we run our application, we only make one API call. If we refresh our application
    before the 2 minutes are up, we can see that there are no new API calls despite
    our frontend rendering all the items from the cache. However, if we create, edit,
    or delete an item, and then refresh the page before the 2 minutes is up, we will
    see that our view will revert to the previous out-of-date state. This is because
    the created, edited, and deleted items also return to their previous state but
    they are not stored in the local storage. This can be handled by updating our
    `handleReturnedState` function with the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的应用程序，我们只会发起一次API调用。如果我们在大约2分钟内刷新我们的应用程序，我们会看到尽管我们的前端从缓存中渲染了所有项目，但并没有新的API调用。然而，如果我们创建、编辑或删除一个项目，然后在2分钟内刷新页面，我们会看到我们的视图会恢复到之前过时的状态。这是因为创建、编辑和删除的项目也会回到它们之前的状态，但它们并没有存储在本地存储中。这可以通过更新我们的`handleReturnedState`函数以及以下代码来处理：
- en: '[PRE128]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Here, we have it. We have managed to cache our data and reuse it to prevent
    our backend API from being hit excessively. This can be applied to other frontend
    processes too. For instance, a customer basket could be cached and used when the
    user checks out.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做到了。我们已经成功缓存了我们的数据，并重新使用它以防止我们的后端API被过度调用。这也可以应用于其他前端过程。例如，当用户结账时，可以缓存并使用客户购物车。
- en: This takes our simple website one step closer to being a web app. However, we
    must acknowledge that as we use caching more, the complexity of the frontend increases.
    For our application, this is where the caching stops. Right now, there are no
    more alterations needed on our applications for the rest of the hour. However,
    there is one more concept that we should briefly cover, which is code on demand.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们的简单网站更接近成为一个网络应用程序。然而，我们必须承认，随着我们越来越多地使用缓存，前端复杂性也在增加。对于我们的应用程序，这就是缓存停止的地方。目前，我们不需要在接下来的一个小时里对我们的应用程序进行任何更多的修改。然而，还有一个概念我们应该简要介绍，那就是按需代码。
- en: Code on demand
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按需代码
- en: 'Code on demand is where the backend server directly executes code on the frontend.
    This constraint is optional and not widely used. However, it can be useful as
    it gives the backend server the right to decide as and when code is executed on
    the frontend. We have already been doing this; in our logout view, we directly
    execute JavaScript on the frontend by simply returning it in a string. This is
    done in the `src/views/auth/logout.rs` file. We must remember that we have now
    added to-do items to our local storage. If we do not remove these items from our
    local storage when logging out, somebody else would be able to access our to-do
    items if they manage to log in to their own account on the same computer within
    2 minutes. While this is highly unlikely, we might as well be safe. Remember that
    our logout view in the `src/views/auth/logout.rs` file takes the following form:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 按需代码是在后端服务器直接在前端执行代码。这个限制是可选的，并且并不广泛使用。然而，它可能很有用，因为它赋予后端服务器决定何时以及如何在前端执行代码的权利。我们已经在做这件事了；在我们的登出视图中，我们通过简单地以字符串的形式返回它，直接在前端执行JavaScript。这是在`src/views/auth/logout.rs`文件中完成的。我们必须记住，我们现在已经将待办事项添加到了我们的本地存储中。如果我们不在登出时从本地存储中删除这些项目，那么如果有人设法在2分钟内登录到同一台电脑上的自己的账户，他们就能访问我们的待办事项。虽然这种情况非常不可能发生，但我们还是应该确保安全。记住，我们的登出视图在`src/views/auth/logout.rs`文件中具有以下形式：
- en: '[PRE129]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Inside the body of our response, we have the following content:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的响应体中，我们有以下内容：
- en: '[PRE130]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: With this, we have not only removed the user token, but we have also removed
    all items and dates. With this, our data is safe once we have logged out.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们不仅删除了用户令牌，还删除了所有项目和日期。这样，一旦我们登出，我们的数据就安全了。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have gone through the different aspects of RESTful design
    and implemented them into our application. We have assessed the layers of our
    application, enabling us to refactor the middleware to enable two different futures
    to be processed depending on the outcome. This doesn’t just stop at authorizing
    requests. Based on the parameters of the request, we could implement middleware
    to redirect requests to other servers, or directly respond with a code-on-demand
    response that makes some changes to the frontend and then makes another API call.
    This approach gives us another tool, custom logic with multiple future outcomes
    in the middleware before the view is hit.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经探讨了RESTful设计的各个方面，并将它们应用到我们的应用程序中。我们已经评估了应用程序的层，使我们能够重构中间件，以便根据结果处理两种不同的未来。这不仅仅停止在授权请求。根据请求的参数，我们可以实现中间件将请求重定向到其他服务器，或者直接以按需代码响应的形式做出一些更改，然后进行另一个API调用。这种方法为我们提供了另一个工具，在视图之前，在中间件中具有多个未来结果的定制逻辑。
- en: We then refactored our path struct to make the interface uniform, preventing
    clashes between frontend and backend views.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重构了我们的路径结构，以使接口统一，防止前端和后端视图之间的冲突。
- en: We then explored the different levels of logging and logged all our requests
    to highlight silent yet undesirable behavior. After refactoring our frontend to
    rectify this, we then used our logging to assess whether our caching mechanism
    was working correctly when caching to-do items into the frontend to prevent excessive
    API calls. Now, our application is passable. We can always make improvements;
    however, we are not at the stage where if we were to deploy our application onto
    a server, we would be able to monitor it, check the logs when something is going
    wrong, manage multiple users with their own to-do lists, and reject unauthorized
    requests before they even hit the view. We also have caching, and our application
    is stateless, accessing and writing data on a PostgreSQL and Redis database.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了不同的日志级别，并记录了所有请求以突出显示沉默但不受欢迎的行为。在重构我们的前端以纠正这个问题后，我们随后使用日志来评估当将待办事项缓存到前端以防止过多的API调用时，我们的缓存机制是否工作正常。现在，我们的应用程序可以接受了。我们总是可以做出改进；然而，我们还没有达到如果我们将应用程序部署到服务器上，我们就能监控它、在出现问题时代码日志、管理具有各自待办事项的多用户以及在他们到达视图之前拒绝未经授权的请求的阶段。我们还有缓存，我们的应用程序是无状态的，在PostgreSQL和Redis数据库上访问和写入数据。
- en: In the next chapter, we will be writing unit tests for our Rust structs and
    functional tests for our API endpoints, as well as cleaning the code up ready
    for deployment.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的Rust结构编写单元测试，为我们的API端点编写功能测试，以及清理代码以准备部署。
- en: Questions
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why can we not simply code multiple futures into the middleware and merely call
    and return the one that is right considering request parameters and authorization
    outcomes, but must wrap them in an enum instead?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不能简单地将多个未来状态编码到中间件中，仅仅根据请求参数和授权结果调用并返回正确的一个，而必须用枚举来包装它们呢？
- en: How do we add a new version of views but still support the old views in case
    our API is serving mobile apps and third parties that might not update instantly?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何添加新版本的视图，同时仍然支持旧视图，以防我们的API为可能不会立即更新的移动应用和第三方提供服务？
- en: Why is the stateless constraint becoming more important in the era of elastic
    cloud computing?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在弹性云计算时代，无状态约束变得越来越重要？
- en: How could we enable another service to be incorporated utilizing the properties
    of the JWT?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何利用JWT的特性来集成另一个服务？
- en: A warning log message hides the fact that an error has happened from the user
    but still alerts us to fix it. Why do we ever bother telling the user that an
    error has occurred and to try again with an error log?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 警告日志消息隐藏了错误已经发生的事实，但仍然提醒我们修复它。我们为什么要麻烦告诉用户发生了错误并尝试使用错误日志再次尝试？
- en: What are the advantages of logging all requests?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录所有请求的优点是什么？
- en: Why do we sometimes have to use `async move`?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们有时必须使用`async move`？
- en: Answers
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Rust’s strong typing system will complain. This is because `async` blocks behave
    like closures meaning that every `async` block is its own type. Pointing to multiple
    futures is like pointing to multiple types, and thus it will look like we are
    returning multiple different types.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rust的强类型系统会抱怨。这是因为`async`块的行为类似于闭包，意味着每个`async`块都是其自己的类型。指向多个未来就像指向多个类型一样，因此它看起来像我们正在返回多个不同的类型。
- en: We add a new module in the views directory with the new views. These have the
    same endpoints and views with new parameters that are needed. We can then add
    a version parameter in the factory function. These new views will have the same
    endpoints with `v2` in them. This enables users to use the new and old API endpoints.
    We then notify users when the old version will no longer be supported, giving
    them time to update. At a specific time, we will move our version in the build
    to `v2`, cutting all requests that make `v1` calls and responding with a helpful
    message that `v1` is no longer supported. For this transition to work, we will
    have to update the allowed versions in the `build` config to a list of supported
    versions.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在视图目录中添加了一个新模块，其中包含新的视图。这些视图具有相同的端点和视图，但需要新的参数。然后我们可以在工厂函数中添加一个版本参数。这些新视图将具有包含`v2`的相同端点。这使用户能够使用新旧API端点。然后我们通知用户旧版本将不再被支持，给他们时间来更新。在特定时间，我们将构建中的版本移动到`v2`，切断所有执行`v1`调用的请求，并返回一个有用的消息，指出`v1`不再被支持。为了使这个过渡工作，我们必须更新`build`配置中允许的版本列表以支持版本。
- en: With orchestration tools, microservices, and elastic computing instances on
    demand, spinning up and shutting down elastic computing instances due to demand
    is becoming more common practice. If we store data on the instance itself, when
    the user makes another API call, there is no guarantee that the user will hit
    the same instance, getting inconsistent data read and writes.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着编排工具、微服务和按需弹性计算实例的普及，根据需求启动和关闭弹性计算实例已成为更常见的做法。如果我们将数据存储在实例本身上，当用户进行另一个API调用时，无法保证用户会访问到相同的实例，从而导致数据读取和写入的不一致性。
- en: The JWT token enables us to store the user ID. If the second service has the
    same secret key, we can merely pass requests to the other service with the JWT
    in the header. The other service does not have to have the login views or access
    to the user database and can still function.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT令牌使我们能够存储用户ID。如果第二个服务有相同的密钥，我们只需将带有JWT的请求传递给其他服务即可。其他服务不需要有登录视图或访问用户数据库的权限，但仍能正常工作。
- en: When an error happens that prevents us from retroactively going back and sorting
    out the issue, then we must raise an error instead of a warning. A classic example
    of an error is not being able to write to a database. A good example of a warning
    is another service not responding. When the other service is up and running, we
    can do a database call and call the service to finish off the process.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发生错误，使我们无法事后回溯并解决问题时，我们必须引发错误而不是警告。一个经典的错误例子是无法写入数据库。一个良好的警告例子是另一个服务没有响应。当其他服务运行时，我们可以进行数据库调用并调用该服务以完成整个过程。
- en: In production, it is needed to assess the state of a server when troubleshooting.
    For instance, if a user is not experiencing an update, we can quickly check the
    logs to see if the server is in fact receiving the request or if there is an error
    with the caching in the frontend. We can also use it to see if our app is behaving
    the way we expect it to.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产环境中，当进行故障排除时，需要评估服务器的状态。例如，如果用户没有体验到更新，我们可以快速检查日志以查看服务器是否实际上接收到了请求，或者前端缓存是否存在错误。我们还可以用它来查看我们的应用程序是否按预期运行。
- en: There could be a possibility that the lifetime of the variable that we are referencing
    in the `async` block might not live long enough to see the end of the `async`
    block. To resolve this, we can shift the ownership of the variable to the block
    with an `async` `move` block.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能存在一种可能性，即我们在`async`块中引用的变量的生命周期可能不足以看到`async`块的结束。为了解决这个问题，我们可以将变量的所有权转移到带有`async`
    `move`块的块中。
- en: Part 4:Testing and Deployment
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：测试和部署
- en: When an application is built, we need to deploy it on a server so others can
    use it. We also need to test it to ensure it works to our expectations before
    we deploy it. In this part, we will cover unit and end-to-end testing using tools
    such as Postman. We’ll build our own build and testing pipelines to automate the
    testing, building, and deployment processes. We’ll cover how HTTP requests route
    to servers and what the HTTPS protocol is so we can implement it on AWS. We will
    also route traffic to our frontend and backend with NGINX, balance traffic between
    two individual servers on AWS, and lock down traffic to these servers and load
    balancer with AWS security groups. We will automate the AWS infrastructure using
    Terraform.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序构建完成后，我们需要将其部署到服务器上以便其他人可以使用它。我们还需要测试它以确保它符合我们的预期，然后再部署它。在本部分中，我们将介绍使用Postman等工具进行的单元测试和端到端测试。我们将构建自己的构建和测试管道来自动化测试、构建和部署过程。我们将介绍HTTP请求如何路由到服务器以及HTTPS协议是什么，以便我们可以在AWS上实现它。我们还将使用NGINX将流量路由到我们的前端和后端，在AWS上的两个独立服务器之间平衡流量，并使用AWS安全组锁定这些服务器和负载均衡器的流量。我们将使用Terraform自动化AWS基础设施。
- en: 'This part includes the following chapters:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 9*](B18722_09.xhtml#_idTextAnchor182), *Testing Our Application Endpoints
    and Components*'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18722_09.xhtml#_idTextAnchor182), *测试我们的应用程序端点和组件*'
- en: '[*Chapter 10*](B18722_10.xhtml#_idTextAnchor200), *Deploying Our Application
    on AWS*'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18722_10.xhtml#_idTextAnchor200), *在AWS上部署我们的应用程序*'
- en: '[*Chapter 11*](B18722_11.xhtml#_idTextAnchor222), *Configuring HTTPS with NGINX
    on AWS*'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18722_11.xhtml#_idTextAnchor222), *在AWS上使用NGINX配置HTTPS*'
