- en: '*Chapter 6*: Working with Python Objects in Rust'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have managed to fuse Rust with Python to speed up our code. However,
    software programs written in Rust can get complicated. While we can get by with
    passing integers and strings into Rust functions from Python code, it would be
    useful to handle more complex data structures from Python and objects. In this
    chapter, we accept and process Python data structures such as a **dictionary**.
    We will go further by processing custom Python objects and even creating Python
    objects inside our Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing complex Python objects into Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting and working with custom Python objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing our own custom Python objects in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found via the following GitHub link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_six](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_six)'
  prefs: []
  type: TYPE_NORMAL
- en: Passing complex Python objects into Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key skill that enables us to take our Rust `pip` module development to the
    next level is taking in complex Python data structures/objects and using them.
    In [*Chapter 5*](B17720_05_Final_SK_ePub.xhtml#_idTextAnchor084), *Creating a
    Rust Interface for Our pip Module*, we accepted integers. We noticed that these
    raw integers were just directly transferred to our Rust function. However, with
    Python objects, it is more complex than this.
  prefs: []
  type: TYPE_NORMAL
- en: To explore this, we will create a new command-line function that reads a .`yml`
    file and passes a Python dictionary into our Rust function. The data in this dictionary
    will have the parameters needed for firing our `fibonacci_numbers` and `fibonacci_number`
    Rust functions, adding the results of those functions to the Python dictionary
    and passing it back to the Python system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we must carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Update our `setup.py` file to support .`yml` loading and a command-line function
    that reads it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a command-line function that reads the `.yml` file and feeds it into
    Rust.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process data from our Python dictionary for `fibonacci_numbers` in Rust.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract data from our config file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return our Python dictionary to our Python system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach will require us to write the whole process before we can run it.
    This can be frustrating because we cannot see it working until the end. However,
    it is laid out in this book this way so that we can see the data flow. We are
    exploring the concept of passing complex data structures into Rust for the first
    time. Once we understand how this works, we can then develop `pip` modules that
    work for us as individuals.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our setup.py file to support .yml loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start this journey by updating our `setup.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new command-line function, we read a .`yml` file and pass through
    that data to our Rust function. This requires our Python `pip` module to have
    the `pyyaml` Python module. This can be done by adding the `requirements` parameter
    to our `setup` initialization, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We remember that we can keep adding more dependencies to our module by just
    adding them to our `requirements` list. If we want our module to be more flexible
    for multiple installs to different systems, it is advised that we can lower the
    version number for our `pyyaml` module requirement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have defined our requirements, we can define a new console script,
    resulting in the `entry_points` parameter in our `setup` initialization, which
    looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, we can see that our new console script will be in the `flitton_fib_rs/config_number_command.py`
    directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `flitton_fib_rs/config_number_command.py` directory, we need to build
    a function called `config_number_command`. First, we need to import the required
    modules, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`os` will help us with the path definition to the `.yml` file. The `pprint`
    function will just help us print the data in an easy-to-read format on the console.
    We have also defined a Rust function that will process our dictionary as `run_config`.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining our .yml loading command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our imports have been done, we can define our function and collect
    the command-line arguments. Here''s how we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can see that we take in a string, which is the path to the `.yml`
    file with the `--path` tag, and we parse it. Now that we have parsed the path,
    we can open our `.yml` file by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we attach our path with the `os.getcwd()` function. This
    is because we must know where the user is calling the command. For instance, if
    we are in the `x/y/` directory and we want to point to the `x/y/z.yml` file, we
    will have to run the `config-fib --path z.yml` command. If the directory of the
    file were `x/y/test/z.yml`, we would have had to run the `config-fib --path test/z.yml`
    command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have our data loaded from the `.yml` file, we can print it out
    and print out the results of our Rust function by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, we have now completed all our Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Processing data from our Python dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to have to build Rust functions that process the Python dictionaries.
    Here''s how we''ll go about this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to processing input dictionaries, we must agree on a format that
    we are going to accept. To keep this simple, our Python dictionaries will have
    two keys. The `number` key is for a list of integers that can call Fibonacci number
    calculations individually, while the `numbers` key is for a list of lists of integers.
    To ensure that our Rust code does not become disorganized, we are going to define
    our interfaces in our own interface directory, giving our Rust code the following
    structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will build our configuration interface in the `src/interface/config.rs`
    file. First, we are going to import all the functions and macros that we need,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are going to use `pyfunction` to wrap our interface that takes in a Python
    dictionary. We will return the dictionary back to the Python program wrapped in
    a `pyResult` struct. Seeing as we are accepting a Python dictionary, we will be
    using a `PyDict` struct to describe the dictionary being passed in and returned.
    We will also be accessing the lists in the dictionary using a `PyList` struct.
    If there is an issue with our dictionary not housing lists, then we will have
    to throw an error that the Python system will understand. To do this, we will
    use a `PyTypeError` struct. Finally, we will be using our Fibonacci number functions
    to calculate the Fibonacci numbers. We can see that we are simply importing from
    another module in the Rust code with `use crate::`. Even though our Fibonacci
    number functions have the `pyfunction` macro applied to them, nothing is stopping
    us from using them as normal Rust functions elsewhere in our Rust code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we write our interface function, we need to build a private function
    that accepts our lists of lists, calculates the Fibonacci numbers, and returns
    them in a list of lists, as seen in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should be straightforward at this stage in the book. Considering this,
    we now have everything we need to build our interface. First, we need to define
    a `pyfunction` function that accepts and returns the same data by running the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we tell the Rust compiler that the Python dictionary that
    we accept must have the same lifetime as the Python dictionary that we are returning.
    This makes sense as we are returning the same dictionary after adding the results
    to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our first process is to see if the `number` key is present in the dictionary
    by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that is the `number` key is not there, so we merely print that
    it is not there. We can change the rules to throw an error instead, but we are
    accepting a forgiving `config` file. If the user does not have any individual
    Fibonacci numbers to compute, only lists of them, then we should not throw errors,
    insisting that the user adds the field. The three dots in the code snippet shown
    in *Step 6* are where the code is going to be executed if the `number` key is
    present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We substitute the three dots in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can see that we downcast the data we extracted belonging to the `number`
    key to the `PyList` struct. If this fails, then we actively throw a type error
    because the user has tried to configure the `number` key but failed. If it passes,
    we can run the Fibonacci function by substituting the three dots in the preceding
    code snippet with the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, what we have done is create `Vec<i32>` by running the `extract` function
    on the `PyList` struct. We directly unwrap it so that if there is an error, it
    will be thrown straight away. We then create `Vec<u64>`, which houses the calculated
    Fibonacci numbers, by iterating through the vector with the `iter()` function.
    We then map each `i32` integer of that vector with the `map` function. Inside
    the `map` function, we define a closure that is mapped to each `i32` integer in
    the vector. It must be noted that we apply the `fibonacci` function where we dereference
    the `i32` integer being passed in because it is now a borrowed reference. We collect
    the results of this mapping with the `.collect()` function, which results in the
    `processed_results` variable being a collection of `i32` calculated Fibonacci
    numbers. We then add the calculated numbers to the dictionary under the `NUMBER
    RESULT` key. We can see the flow of what was just described in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_6.1_B17720.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Data extraction flow
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we will carry out a similar process to the one displayed in
    *Figure 6.1* to process the list of lists under the `numbers` key.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data from our config file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, it would be a good idea to try to implement the process for
    the `numbers` key by yourself. To make things easier, you can use the `process_numbers`
    function that we defined earlier in *Step 3* of the *Processing data from our
    Python dictionary* section. We will cover the solution to this in the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `numbers` key can be processed by our `run_config` function with the code
    defined here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that the `process_numbers` function actually makes this implementation
    simpler than the `numbers` key processing. If the complexity starts to grow, it
    is always worth breaking down the logic into smaller functions. It also must be
    noted that we return a result that wraps the config dictionary. Now that we have
    finished the logic behind processing our dictionary, we need to return our dictionary
    in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, we must publicly define our `src/interface/config.rs` file in the `src/interface/mod.rs`
    file by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then import it into our `src/lib.rs` file by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add the function to our module in the `src/lib.rs` file by running
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now carried out all the steps.
  prefs: []
  type: TYPE_NORMAL
- en: Returning our Rust dictionary to our Python system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `pip` module can now take in a configuration file, convert it into a Python
    dictionary, pass the Python dictionary into the Rust function that calculates
    the Fibonacci numbers, and return the results in the form of a dictionary back
    to Python. This can be achieved by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `.yml` file to be ingested by our program. An example `.yml` file
    that can run what we have just done can be defined via the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I have saved the preceding .`yml` code on my desktop for demonstration purposes
    under the filename `example.yml`. Remember to update your GitHub repository and
    uninstall your current module in your Python environment, and install our new
    module instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can then pass in the `.yml` file into our module entry point with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'I ran this command from my desktop, where I stored the `example.yml` file.
    Running the previous command gives us the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that our Python interface fed the Python dictionary into the
    Rust interface. We then got the results of the Fibonacci functions passed back
    in the same dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we introduce a breaking change in our `.yml` file. We can test our error
    by changing the `number` key to a dictionary as opposed to a list of integers
    in our `example.yml` file by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally we run our code again, expecting the correct error message. This gives
    us the following error when running our command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see how the `extract` function handles a string being put in, thereby
    changing the `number` key to a list of strings as opposed to a list of integers
    in our `example.yml` file, by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running our command again gives us the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that the error string is a little harder to interpret because
    we did not directly code an error telling the user what we want; however, it is
    still `TypeError`. We can also see here that errors raised by functions that are
    acted on Python objects are Python-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: We have now concluded how to interact with complex Python data structures. Nothing
    is stopping you from building Python `pip` modules in Rust that fuse seamlessly
    with a Python program. However, we can take our Rust `pip` modules to the next
    level by working with and inspecting custom Python objects in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting and working with custom Python objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technically, everything in Python is an object. The Python dictionary that
    we worked on within the previous section is an object, so we have already managed
    Python objects. However, as we know, Python enables us to build custom objects.
    In this section, we will get our Rust function to accept a custom Python class
    that will have `number` and `numbers` attributes. To achieve this, we must carry
    out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an object that passes itself into our Rust interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acquire the Python `PyDict` struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the custom object's attributes to our newly created `PyDict` struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the attributes of the custom object to the results of our `run_config` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an object for our Rust interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start our journey by setting up our interface object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We house our object that will pass itself into our Rust code in the `flitton_fib_rs/object_interface.py`
    file. Initially, we import what we need by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define the `__init__` method of our object by running the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we can pass in the Fibonacci numbers that we want to be
    calculated in the parameters. We then just set our attributes to the parameters
    that we passed in. The result parameters defined here are of a `None` value. However,
    they will be populated by the Rust code when we pass this object into our Rust
    object interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then define a function that will pass our object into the Rust code by running
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that this is done by merely passing the `self` reference into
    the function. Now that we have defined our object, we can move on to build our
    interface and interact with the Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring the Python GIL in Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our interface, we will house our function in the `src/interface/object.rs`
    file. We''ll proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must import all of what we need by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most of these imports will be familiar by now. The new import that we must make
    note of is the `Python` import. `Python` is a struct that is essentially a marker
    that is required for the Python operations that we will be doing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have imported everything we need, we can build parameters for our
    interface and create a `PyDict` struct by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, what we have essentially done is acquire the Python GIL, and then use
    this to create a `PyDict` struct. To fully understand what we are doing, it is
    best to explore what the Python GIL is. In [*Chapter 3*](B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046),
    *Understanding Concurrency*, we covered the concept of thread blocking. This means
    that if another thread is executing, then all other threads are locked. The GIL
    ensures that this happens, as demonstrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – GIL flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – GIL flow
  prefs: []
  type: TYPE_NORMAL
- en: This is because Python does not have any concept of ownership. A Python object
    can be referenced as many times as we want. We can also mutate the variable from
    any of those references. When we acquire the `gil` variable, we ensure that only
    one thread can use the Python interpreter and the Python `gil` variable is a `GILGuard`
    struct that ensures that we acquire the GIL before we run any operations on Python
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to our newly created PyDict struct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have control over Python objects with the GIL, we can move on to
    our next step, where we add the data from the input object to our newly created
    `PyDict` struct, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our approach in this step can be summarized in the following diagram:![](img/Figure_6.3_B17720.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.3 – PyDict flow
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can achieve the first cycle depicted in *Figure 6.3* by running the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we match the `getattr` function, throwing an error if
    `input_object` does not have the `number` attribute. If we do have the attribute,
    we assign it to `config_dict`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can do the second cycle by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It must be noted that there is a fair amount of repetition, with only one change.
    We could refactor this into a single function with an `attribute` parameter by
    running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can see that we get a lot of flexibility with our Python objects.
    This function can be used multiple times with the refactored code in our `object_interface`
    function, as seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we have changed `config_dict` to a mutable. Now that we
    have loaded our `PyDict` struct with all the data that we need, all we must do
    is run our `run_config` function, add it to the input object's attributes, and
    return it to the Python interface in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the attributes of our custom object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now in the final stage of our interface module. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass the output from our `run_config` function to our Python object
    interface by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we get the `output_dict` Python dictionary from the `run_config`
    function. Once we have got this, we set the `input_object` attribute based on
    the items from `output_dict`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have now completed our interface and we must subsequently plug it into our
    Rust module. We publicly define our interface file in the `src/interface/mod.rs`
    file by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then define our interface function in our Rust module by importing it
    into our `src/lib.rs` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add our function to our module, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our module is now fully functioning. As always, we must remember to update
    our GitHub repository, uninstall our old module in our Python environment, and
    reinstall it. Once this is done, we can test it by running a Python shell. In
    our shell, we can test our object by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we import the object that we are going to use. We then
    initialize it and run the `process` function. Once this is done, we can see that
    our Rust code accepted our object and interacted with it as we have the correct
    results for our `number_results` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can interact with Python custom objects, the problems we can solve and
    how we can interact with the Python system are powerful. Custom Python objects
    do not hold us back. However, it is important not to get too carried away with
    Python objects in our Rust code. While we should use them in our interface, we
    shouldn't have to rely on them to build the whole program. In this section, we
    did do this, as we were leaning on a function that we built in the previous section
    to avoid excessive code, to get a point across. However, in your projects, Python
    objects should leave your code after the interface. If you find yourself using
    Python objects in your Rust code throughout, then you must ask yourself why you
    are not just using pure Python. Coding in Python will be slower than coding in
    Rust, but the metaclass, dynamic attributes, and many other Python features will
    make coding in Python easier and more enjoyable than trying to force a Python
    style of coding into Rust. Rust offers structs, traits, enums, and strong typing
    with lifetimes that get cut after moving out of scope to keep resources low.
  prefs: []
  type: TYPE_NORMAL
- en: So, lean into this style of coding to fully reap the benefits of building `pip`
    modules in Rust. Push past your comfort zone of the Python coding style. The next
    section is about building Python objects in Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing our own custom Python objects in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this final section, we will build a Python module in Rust that can be interacted
    with in the Python system as if it were a native Python object. To do this, we
    must follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a Python class with all our attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define class static methods to process numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a class constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining a Python class with the required attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start our journey, we define our class in the `src/class_module/fib_processor.rs`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build our class, we need to import the required macros by running the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are using the `pyclass` macro to define our Rust Python class. We then
    use `pymethods` and `staticmethod` to define methods attached to the class. We
    also use standard Fibonacci numbers to calculate the Fibonacci numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have imported everything we need, we can define the class and the
    attributes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we use Rust typing for our attributes. We also use a macro
    to state what we can do with these attributes. For our `number` and `numbers`
    attributes, we can get and set data belonging to these attributes. However, with
    our `results` attributes, we can only get data as this is set by the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Defining class static methods to process input numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now use our attributes to implement class methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with standard structs, we can implement methods attached to the class
    with an `impl` block, as seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we have applied the `pymethods` macro to our `impl` block.
    We also apply the `staticmethod` macro to our `process_numbers` static method.
    This function was used before, in the previous section, to process lists of lists.
    Now that our static method is defined, we can use this in our constructor method
    in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a class constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps we need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define our constructor method in our `impl` block by running the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we accept inputs for the calculations of the Fibonacci numbers. We then
    clone them because we are going to pass them through the Fibonacci number functions.
    Once this is done, we apply the `fibonacci_number` function by mapping the input
    and collecting the results. We also collect the results from our static method.
    Once all the data is calculated, we construct the class and return it. Once this
    is done, all we must do is connect our class to our module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This can be done by publicly declaring our class file in the `src/class_module/mod.rs`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that this is done, we import it into our `src/lib.rs` file by running the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, we can add our class to our module in the same file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now fully integrated our class into the `pip` module.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up and testing our module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, when we get to the end of a section, we must remember to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the GitHub repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uninstall the current `pip` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinstall it in our Python environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have finished building our module and updated the installed version,
    we can manually test our module in the Python system by following these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can open our Python shell and test our class by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see that our Rust object works seamlessly in our Python system with
    calculated results. We must remember that we have set rules around our attributes.
    To check this, we can try to assign our `results` attribute, which will give us
    the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can see that our `results` attribute is not writable. We can also
    test typing. Although our `number` attribute is writable, it is supposed to be
    a vector of integers. If we try to assign a string to this attribute, we get the
    following printout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can see that our typing is also enforced, even though it looks and
    acts like a native Python object. Finally, we can test to see if we can write
    a new value to the `number` attribute by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It seems that we can write when the type and permissions are correct. Considering
    all of this, what is the point of creating these classes? They make the interface
    for our module smoother, but how much faster is this class?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To quantify this, we can create a simple testing Python script in our Python
    environment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in our Python script, we import our Rust class and the `time` module
    by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must now create a pure Python object with the same functionality in this
    script, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that our benchmark pure Python object is defined, we are now at the timing
    stage of the script, where we put the same inputs into both classes and test them
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this gives us the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This translates to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember, the Rust class is the top reading. This means that our Rust class
    is *43 times faster than our Python class!* To put this into perspective, we can
    see the difference in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Class speed difference between Rust and Python'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Class speed difference between Rust and Python
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that our class interfaces built in Rust are faster than our
    Python classes. `pyo3` supports class inheritance and other features. More resources
    on this are supplied in the *Further reading* section. We now have a strong base
    when it comes to working with Python objects in Rust. There are always more features
    to read up on, and these can be built on top of the structures that we have built.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added a third-party `pip` module into our `setup.py` file
    so that we could add another entry point that could read .`yml` files. We read
    the .`yml` file and passed the data from that file in the form of a dictionary
    into our Rust functions, handling the complex data structure under the `PyDict`
    struct. We then downcasted data from our complex data structure into other Python
    objects and Rust data types. This gave us the power to handle a range of Python
    data types passed into our Rust code, giving us extra flexibility in how our Python
    code interacts with our Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: We went one step further than complex Python data structures by accepting custom
    Python objects under the `PyAny` struct. Once we accepted custom Python objects,
    we could inspect attributes and set them as and when we wanted to. We even acquired
    the Python GIL to create our own Python data structures to help us work with the
    custom Python objects passed into our Rust code. To polish off our Python object
    skills, we built Python classes within our Rust code that not only can be imported
    into the Python system, acting just like a pure Python class, but are also 44
    times faster. We now have a powerful tool that will not only speed up our Python
    code but will also enable us to interact with Python systems seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we tackle the final hurdle that is stopping us from infusing
    Rust into every Python project we have. People reach for Python due to the extensive
    third-party modules that are built for it, such as statistical and `numpy` module
    and use it in our Rust code. This will enable us to utilize third-party Python
    modules in our Rust extension.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you extract a vector of `i32` integers from a `PyDict` struct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have a vector of strings but we apply a `.extract::<Vec<i32>>()`  function
    on it and we directly unwrap it, what will happen?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you be able to loop through a `Vec<i32>` vector, doubling each item
    and packaging the results in another vector in one line of Rust code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we acquire the Python GIL to create a `PyDict` struct, will this affect the
    Python system in any way?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although our Python classes built in our Rust code essentially run the same
    way as our pure Python classes, there are some core differences. What are they?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we must get a list from the `PyDict` struct by applying the `get_item`
    function to `PyDict`. If there is data under the key that we use, we then perform
    `.downcast::<PyList>()` to convert our data into a `PyList` struct. If we achieve
    this, we then perform `.extract::<Vec<i32>>()` on the `PyList` struct, giving
    us a `Vec<i32>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `extract` function will automatically throw a `PyTypeError` Python-friendly
    error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this, we use the `iter`, `map`, and `collect` functions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: No—the Python system that is running the code has already acquired the GIL.
    If it does not have the GIL, it would just wait for another thread to finish before
    acquiring the GIL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The typing system is still enforced. If we try to set an attribute that is a
    list of integers to a string, an error will be thrown. Another difference is that
    `set` and `get` macros for each attribute must be defined. If they are not, then
    the attribute cannot be accessed or set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*PyO3* (2021). *PyO3 user guide*—*Python Classes* [https://pyo3.rs/v0.13.2/class.html](https://pyo3.rs/v0.13.2/class.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
