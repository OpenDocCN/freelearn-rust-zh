- en: '*Chapter 6*: Working with Python Objects in Rust'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：在Rust中使用Python对象'
- en: So far, we have managed to fuse Rust with Python to speed up our code. However,
    software programs written in Rust can get complicated. While we can get by with
    passing integers and strings into Rust functions from Python code, it would be
    useful to handle more complex data structures from Python and objects. In this
    chapter, we accept and process Python data structures such as a **dictionary**.
    We will go further by processing custom Python objects and even creating Python
    objects inside our Rust code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功地将Rust与Python融合在一起，以加快我们的代码。然而，用Rust编写的软件程序可能会变得复杂。虽然我们可以通过将整数和字符串传递到Rust函数中从Python代码中应付过去，但处理来自Python的更复杂的数据结构和对象将是有用的。在本章中，我们接受并处理Python数据结构，如**字典**。我们将进一步通过处理自定义Python对象，甚至在我们的Rust代码中创建Python对象。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Passing complex Python objects into Rust
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将复杂Python对象传递给Rust
- en: Inspecting and working with custom Python objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查和使用自定义Python对象
- en: Constructing our own custom Python objects in Rust
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rust中构建我们自己的自定义Python对象
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found via the following GitHub link:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以通过以下GitHub链接找到：
- en: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_six](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_six)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_six](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_six)'
- en: Passing complex Python objects into Rust
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将复杂Python对象传递给Rust
- en: A key skill that enables us to take our Rust `pip` module development to the
    next level is taking in complex Python data structures/objects and using them.
    In [*Chapter 5*](B17720_05_Final_SK_ePub.xhtml#_idTextAnchor084), *Creating a
    Rust Interface for Our pip Module*, we accepted integers. We noticed that these
    raw integers were just directly transferred to our Rust function. However, with
    Python objects, it is more complex than this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一项关键技能使我们能够将我们的Rust `pip`模块开发提升到下一个层次，就是接受并使用复杂的Python数据结构/对象。在[*第5章*](B17720_05_Final_SK_ePub.xhtml#_idTextAnchor084)
    *为我们的pip模块创建Rust接口*中，我们接受了整数。我们注意到这些原始整数是直接传递到我们的Rust函数中的。然而，对于Python对象，这比这更复杂。
- en: To explore this, we will create a new command-line function that reads a .`yml`
    file and passes a Python dictionary into our Rust function. The data in this dictionary
    will have the parameters needed for firing our `fibonacci_numbers` and `fibonacci_number`
    Rust functions, adding the results of those functions to the Python dictionary
    and passing it back to the Python system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这一点，我们将创建一个新的命令行函数，该函数读取一个`.yml`文件并将一个Python字典传递给我们的Rust函数。这个字典中的数据将包含触发我们的`fibonacci_numbers`和`fibonacci_number`Rust函数所需的参数，将这些函数的结果添加到Python字典中，并将其传递回Python系统。
- en: 'To achieve this, we must carry out the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们必须执行以下步骤：
- en: Update our `setup.py` file to support .`yml` loading and a command-line function
    that reads it.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们的`setup.py`文件以支持`.yml`加载和一个读取它的命令行函数。
- en: Define a command-line function that reads the `.yml` file and feeds it into
    Rust.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个命令行函数，该函数读取`.yml`文件并将其输入到Rust中。
- en: Process data from our Python dictionary for `fibonacci_numbers` in Rust.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Rust中处理来自我们的Python字典的`fibonacci_numbers`数据。
- en: Extract data from our config file.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从配置文件中提取数据。
- en: Return our Python dictionary to our Python system.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的Python字典返回到我们的Python系统。
- en: This approach will require us to write the whole process before we can run it.
    This can be frustrating because we cannot see it working until the end. However,
    it is laid out in this book this way so that we can see the data flow. We are
    exploring the concept of passing complex data structures into Rust for the first
    time. Once we understand how this works, we can then develop `pip` modules that
    work for us as individuals.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法要求我们在运行之前先写出整个流程。这可能会让人感到沮丧，因为我们无法在结束时看到它的工作情况。然而，本书正是以这种方式安排的，这样我们就可以看到数据流。我们首次探索将复杂的数据结构传递给Rust的概念。一旦我们理解了它是如何工作的，我们就可以开发出为我们个人工作的`pip`模块。
- en: Updating our setup.py file to support .yml loading
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的`setup.py`文件以支持`.yml`加载
- en: 'Let''s start this journey by updating our `setup.py` file, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更新我们的`setup.py`文件开始这段旅程，如下所示：
- en: 'With our new command-line function, we read a .`yml` file and pass through
    that data to our Rust function. This requires our Python `pip` module to have
    the `pyyaml` Python module. This can be done by adding the `requirements` parameter
    to our `setup` initialization, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们新的命令行函数，我们读取一个`.yml`文件并将数据传递给我们的Rust函数。这要求我们的Python `pip`模块必须包含`pyyaml`
    Python模块。这可以通过在`setup`初始化中添加`requirements`参数来实现，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We remember that we can keep adding more dependencies to our module by just
    adding them to our `requirements` list. If we want our module to be more flexible
    for multiple installs to different systems, it is advised that we can lower the
    version number for our `pyyaml` module requirement.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们记得我们只需将它们添加到我们的`requirements`列表中，就可以继续添加更多的依赖到我们的模块中。如果我们想让我们的模块对多个系统的安装更加灵活，建议我们可以降低`pyyaml`模块需求版本的数字。
- en: 'Now that we have defined our requirements, we can define a new console script,
    resulting in the `entry_points` parameter in our `setup` initialization, which
    looks like this:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的需求，我们可以定义一个新的控制台脚本，这将在`setup`初始化中的`entry_points`参数中产生，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this, we can see that our new console script will be in the `flitton_fib_rs/config_number_command.py`
    directory.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这个，我们可以看到我们的新控制台脚本将位于`flitton_fib_rs/config_number_command.py`目录下。
- en: 'In the `flitton_fib_rs/config_number_command.py` directory, we need to build
    a function called `config_number_command`. First, we need to import the required
    modules, as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`flitton_fib_rs/config_number_command.py`目录下，我们需要构建一个名为`config_number_command`的函数。首先，我们需要导入所需的模块，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`os` will help us with the path definition to the `.yml` file. The `pprint`
    function will just help us print the data in an easy-to-read format on the console.
    We have also defined a Rust function that will process our dictionary as `run_config`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`将帮助我们定义到`.yml`文件的路径。`pprint`函数将帮助我们以易于阅读的格式在控制台上打印数据。我们还定义了一个将处理我们的字典的Rust函数，名为`run_config`。'
- en: Defining our .yml loading command
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们的.yml加载命令
- en: 'Now that our imports have been done, we can define our function and collect
    the command-line arguments. Here''s how we do this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了导入，我们可以定义我们的函数并收集命令行参数。以下是我们的操作步骤：
- en: 'You can start with the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从以下代码开始：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we can see that we take in a string, which is the path to the `.yml`
    file with the `--path` tag, and we parse it. Now that we have parsed the path,
    we can open our `.yml` file by running the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们接收一个字符串，它是带有`--path`标签的`.yml`文件路径，然后我们解析它。现在我们已经解析了路径，我们可以通过运行以下代码来打开我们的`.yml`文件：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we can see that we attach our path with the `os.getcwd()` function. This
    is because we must know where the user is calling the command. For instance, if
    we are in the `x/y/` directory and we want to point to the `x/y/z.yml` file, we
    will have to run the `config-fib --path z.yml` command. If the directory of the
    file were `x/y/test/z.yml`, we would have had to run the `config-fib --path test/z.yml`
    command.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们使用`os.getcwd()`函数附加我们的路径。这是因为我们必须知道用户在哪里调用命令。例如，如果我们位于`x/y/`目录下，并想指向`x/y/z.yml`文件，我们必须运行`config-fib
    --path z.yml`命令。如果文件的目录是`x/y/test/z.yml`，我们就必须运行`config-fib --path test/z.yml`命令。
- en: 'Now that we have our data loaded from the `.yml` file, we can print it out
    and print out the results of our Rust function by running the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经从`.yml`文件中加载数据，我们可以打印它，并通过运行以下代码打印出我们Rust函数的结果：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this, we have now completed all our Python code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们现在已经完成了所有的Python代码。
- en: Processing data from our Python dictionary
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理来自Python字典的数据
- en: 'We are now going to have to build Rust functions that process the Python dictionaries.
    Here''s how we''ll go about this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要构建Rust函数来处理Python字典。以下是我们的操作步骤：
- en: 'When it comes to processing input dictionaries, we must agree on a format that
    we are going to accept. To keep this simple, our Python dictionaries will have
    two keys. The `number` key is for a list of integers that can call Fibonacci number
    calculations individually, while the `numbers` key is for a list of lists of integers.
    To ensure that our Rust code does not become disorganized, we are going to define
    our interfaces in our own interface directory, giving our Rust code the following
    structure:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到处理输入字典时，我们必须就我们将接受的格式达成一致。为了保持简单，我们的Python字典将有两个键。`number`键用于一个整数列表，可以单独调用斐波那契数计算，而`numbers`键用于整数列表的列表。为了确保我们的Rust代码不会变得杂乱无章，我们将在自己的接口目录中定义我们的接口，给我们的Rust代码以下结构：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will build our configuration interface in the `src/interface/config.rs`
    file. First, we are going to import all the functions and macros that we need,
    as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`src/interface/config.rs`文件中构建我们的配置接口。首先，我们将导入我们需要的所有函数和宏，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are going to use `pyfunction` to wrap our interface that takes in a Python
    dictionary. We will return the dictionary back to the Python program wrapped in
    a `pyResult` struct. Seeing as we are accepting a Python dictionary, we will be
    using a `PyDict` struct to describe the dictionary being passed in and returned.
    We will also be accessing the lists in the dictionary using a `PyList` struct.
    If there is an issue with our dictionary not housing lists, then we will have
    to throw an error that the Python system will understand. To do this, we will
    use a `PyTypeError` struct. Finally, we will be using our Fibonacci number functions
    to calculate the Fibonacci numbers. We can see that we are simply importing from
    another module in the Rust code with `use crate::`. Even though our Fibonacci
    number functions have the `pyfunction` macro applied to them, nothing is stopping
    us from using them as normal Rust functions elsewhere in our Rust code.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`pyfunction`来封装我们的接口，该接口接受一个Python字典。我们将返回一个包含在`pyResult`结构体中的字典给Python程序。鉴于我们接受一个Python字典，我们将使用`PyDict`结构体来描述传入和返回的字典。我们还将使用`PyList`结构体来访问字典中的列表。如果我们的字典没有包含列表，那么我们将不得不抛出一个Python系统可以理解的错误。为此，我们将使用`PyTypeError`结构体。最后，我们将使用我们的斐波那契数函数来计算斐波那契数。我们可以看到，我们在Rust代码中简单地使用`use
    crate::`从另一个模块导入。即使我们的斐波那契数函数应用了`pyfunction`宏，这也阻止不了我们在Rust代码的其他地方将它们作为正常的Rust函数使用。
- en: 'Before we write our interface function, we need to build a private function
    that accepts our lists of lists, calculates the Fibonacci numbers, and returns
    them in a list of lists, as seen in the following code snippet:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们编写接口函数之前，我们需要构建一个私有函数，该函数接受我们的列表列表，计算斐波那契数，并以列表列表的形式返回它们，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should be straightforward at this stage in the book. Considering this,
    we now have everything we need to build our interface. First, we need to define
    a `pyfunction` function that accepts and returns the same data by running the
    following code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这本书的这个阶段，这应该是直截了当的。考虑到这一点，我们现在已经拥有了构建接口所需的一切。首先，我们需要定义一个`pyfunction`函数，通过运行以下代码来接受和返回相同的数据：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we can see that we tell the Rust compiler that the Python dictionary that
    we accept must have the same lifetime as the Python dictionary that we are returning.
    This makes sense as we are returning the same dictionary after adding the results
    to it.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，我们告诉Rust编译器，我们接受的Python字典必须与我们要返回的Python字典具有相同的生命周期。这很有道理，因为我们添加结果后返回的是同一个字典。
- en: 'Our first process is to see if the `number` key is present in the dictionary
    by running the following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是检查字典中是否存在`number`键，如下所示：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we can see that is the `number` key is not there, so we merely print that
    it is not there. We can change the rules to throw an error instead, but we are
    accepting a forgiving `config` file. If the user does not have any individual
    Fibonacci numbers to compute, only lists of them, then we should not throw errors,
    insisting that the user adds the field. The three dots in the code snippet shown
    in *Step 6* are where the code is going to be executed if the `number` key is
    present.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，如果没有`number`键，我们就仅仅打印出它不存在。我们可以更改规则，抛出一个错误，但我们是接受一个宽容的`config`文件。如果用户没有要计算的任何单独的斐波那契数，只有它们的列表，那么我们就不应该抛出错误，坚持要求用户添加该字段。在*步骤6*中显示的代码片段中的三个点表示如果存在`number`键，代码将在这里执行。
- en: 'We substitute the three dots in the following code snippet:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在以下代码片段中替换了三个点：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we can see that we downcast the data we extracted belonging to the `number`
    key to the `PyList` struct. If this fails, then we actively throw a type error
    because the user has tried to configure the `number` key but failed. If it passes,
    we can run the Fibonacci function by substituting the three dots in the preceding
    code snippet with the following code:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，我们将属于`number`键的提取数据向下转换为`PyList`结构体。如果这失败，我们将主动抛出一个类型错误，因为用户尝试配置`number`键但失败了。如果它通过，我们可以通过用以下代码替换前面代码片段中的三个点来运行斐波那契函数：
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, what we have done is create `Vec<i32>` by running the `extract` function
    on the `PyList` struct. We directly unwrap it so that if there is an error, it
    will be thrown straight away. We then create `Vec<u64>`, which houses the calculated
    Fibonacci numbers, by iterating through the vector with the `iter()` function.
    We then map each `i32` integer of that vector with the `map` function. Inside
    the `map` function, we define a closure that is mapped to each `i32` integer in
    the vector. It must be noted that we apply the `fibonacci` function where we dereference
    the `i32` integer being passed in because it is now a borrowed reference. We collect
    the results of this mapping with the `.collect()` function, which results in the
    `processed_results` variable being a collection of `i32` calculated Fibonacci
    numbers. We then add the calculated numbers to the dictionary under the `NUMBER
    RESULT` key. We can see the flow of what was just described in the following diagram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们所做的是通过在 `PyList` 结构体上运行 `extract` 函数来创建 `Vec<i32>`。我们直接解包它，这样如果出现错误，它将立即抛出。然后我们通过使用
    `iter()` 函数遍历向量来创建 `Vec<u64>`，它包含了计算出的斐波那契数。然后我们使用 `map` 函数将那个向量中的每个 `i32` 整数映射。在
    `map` 函数内部，我们定义一个闭包，它被映射到向量中的每个 `i32` 整数。必须注意的是，我们在应用 `fibonacci` 函数时取消引用传入的 `i32`
    整数，因为它现在是一个借用引用。我们使用 `.collect()` 函数收集这个映射的结果，这使得 `processed_results` 变量成为 `i32`
    计算出的斐波那契数的集合。然后我们在 `NUMBER RESULT` 键下将计算出的数字添加到字典中。我们可以在以下图中看到刚刚描述的流程：
- en: '![](img/Figure_6.1_B17720.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1](img/Figure_6.1_B17720.jpg)'
- en: Figure 6.1 – Data extraction flow
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 数据提取流程
- en: In the next step, we will carry out a similar process to the one displayed in
    *Figure 6.1* to process the list of lists under the `numbers` key.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将执行与 *图 6.1* 中显示的类似的过程来处理 `numbers` 键下的列表。
- en: Extracting data from our config file
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从我们的配置文件中提取数据
- en: 'At this point, it would be a good idea to try to implement the process for
    the `numbers` key by yourself. To make things easier, you can use the `process_numbers`
    function that we defined earlier in *Step 3* of the *Processing data from our
    Python dictionary* section. We will cover the solution to this in the next steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，尝试自己实现 `numbers` 键的处理过程是个好主意。为了使事情更容易，你可以使用我们在 *处理来自 Python 字典的数据* 部分的
    *步骤 3* 中定义的 `process_numbers` 函数。我们将在接下来的步骤中介绍这个解决方案：
- en: 'The `numbers` key can be processed by our `run_config` function with the code
    defined here:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`numbers` 键可以通过我们在此处定义的代码由我们的 `run_config` 函数处理：'
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we can see that the `process_numbers` function actually makes this implementation
    simpler than the `numbers` key processing. If the complexity starts to grow, it
    is always worth breaking down the logic into smaller functions. It also must be
    noted that we return a result that wraps the config dictionary. Now that we have
    finished the logic behind processing our dictionary, we need to return our dictionary
    in the next step.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `process_numbers` 函数实际上使这个实现比 `numbers` 键的处理更简单。如果复杂性开始增加，总是值得将逻辑分解成更小的函数。还必须注意的是，我们返回一个封装了配置字典的结果。现在我们已经完成了处理我们字典的逻辑，我们需要在下一步中返回我们的字典。
- en: 'Here, we must publicly define our `src/interface/config.rs` file in the `src/interface/mod.rs`
    file by running the following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们必须通过运行以下代码在 `src/interface/mod.rs` 文件中公开定义我们的 `src/interface/config.rs`
    文件：
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then import it into our `src/lib.rs` file by running the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过运行以下代码将其导入到我们的 `src/lib.rs` 文件中：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then add the function to our module in the `src/lib.rs` file by running
    the following code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过运行以下代码将函数添加到我们的 `src/lib.rs` 模块中：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have now carried out all the steps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了所有步骤。
- en: Returning our Rust dictionary to our Python system
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的 Rust 字典返回到 Python 系统
- en: 'Our `pip` module can now take in a configuration file, convert it into a Python
    dictionary, pass the Python dictionary into the Rust function that calculates
    the Fibonacci numbers, and return the results in the form of a dictionary back
    to Python. This can be achieved by carrying out the following steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `pip` 模块现在可以接受一个配置文件，将其转换为 Python 字典，将 Python 字典传递给计算斐波那契数的 Rust 函数，并以字典的形式将结果返回到
    Python。这可以通过执行以下步骤实现：
- en: 'Define a `.yml` file to be ingested by our program. An example `.yml` file
    that can run what we have just done can be defined via the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个将被我们的程序处理的 `.yml` 文件。可以通过以下代码定义一个可以运行我们刚刚所做操作的示例 `.yml` 文件：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I have saved the preceding .`yml` code on my desktop for demonstration purposes
    under the filename `example.yml`. Remember to update your GitHub repository and
    uninstall your current module in your Python environment, and install our new
    module instead.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我为了演示目的，将前面的`.yml`代码保存在我的桌面上，文件名为`example.yml`。请记住更新你的GitHub仓库，并在你的Python环境中卸载当前的模块，然后安装我们的新模块。
- en: 'We can then pass in the `.yml` file into our module entry point with the following
    command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令将`.yml`文件传递到我们的模块入口点：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I ran this command from my desktop, where I stored the `example.yml` file.
    Running the previous command gives us the following output:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我在我的桌面（存储了`example.yml`文件的地方）运行了这个命令。运行前面的命令给出了以下输出：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we can see that our Python interface fed the Python dictionary into the
    Rust interface. We then got the results of the Fibonacci functions passed back
    in the same dictionary.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的Python接口将Python字典喂给了Rust接口。然后，我们将斐波那契函数的结果通过相同的字典传递回来。
- en: 'Now, we introduce a breaking change in our `.yml` file. We can test our error
    by changing the `number` key to a dictionary as opposed to a list of integers
    in our `example.yml` file by running the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在`.yml`文件中引入一个破坏性变更。我们可以通过在`example.yml`文件中将`number`键从整数列表更改为字典来测试我们的错误，如下所示运行以下代码：
- en: '[PRE20]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally we run our code again, expecting the correct error message. This gives
    us the following error when running our command again:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后我们再次运行我们的代码，期望得到正确的错误消息。当我们再次运行命令时，给出了以下错误：
- en: '[PRE21]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see how the `extract` function handles a string being put in, thereby
    changing the `number` key to a list of strings as opposed to a list of integers
    in our `example.yml` file, by running the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下代码，我们可以看到`extract`函数如何处理字符串的输入，从而将`example.yml`文件中的`number`键从整数列表更改为字符串列表：
- en: '[PRE22]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running our command again gives us the following output:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行我们的命令，给出了以下输出：
- en: '[PRE23]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we can see that the error string is a little harder to interpret because
    we did not directly code an error telling the user what we want; however, it is
    still `TypeError`. We can also see here that errors raised by functions that are
    acted on Python objects are Python-friendly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到错误字符串的解析稍微困难一些，因为我们没有直接编写一个错误代码来告诉用户我们想要什么；然而，它仍然是`TypeError`。我们还可以看到，由作用于Python对象的函数引发的错误是Python友好的。
- en: We have now concluded how to interact with complex Python data structures. Nothing
    is stopping you from building Python `pip` modules in Rust that fuse seamlessly
    with a Python program. However, we can take our Rust `pip` modules to the next
    level by working with and inspecting custom Python objects in the next section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经总结了解如何与复杂的Python数据结构交互。没有什么可以阻止你在Rust中构建与Python程序无缝融合的Python `pip`模块。然而，我们可以在下一节中通过处理和检查自定义Python对象将我们的Rust
    `pip`模块提升到下一个层次。
- en: Inspecting and working with custom Python objects
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查和操作自定义Python对象
- en: 'Technically, everything in Python is an object. The Python dictionary that
    we worked on within the previous section is an object, so we have already managed
    Python objects. However, as we know, Python enables us to build custom objects.
    In this section, we will get our Rust function to accept a custom Python class
    that will have `number` and `numbers` attributes. To achieve this, we must carry
    out the following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，Python中的所有内容都是一个对象。我们在上一节中工作的Python字典是一个对象，因此我们已经管理了Python对象。然而，正如我们所知，Python使我们能够构建自定义对象。在本节中，我们将使我们的Rust函数接受一个具有`number`和`numbers`属性的自定义Python类。为了实现这一点，我们必须执行以下步骤：
- en: Create an object that passes itself into our Rust interface.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将自身传递到我们的Rust接口的对象。
- en: Acquire the Python `PyDict` struct.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取Python的`PyDict`结构体。
- en: Add the custom object's attributes to our newly created `PyDict` struct.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自定义对象的属性添加到我们新创建的`PyDict`结构体中。
- en: Set the attributes of the custom object to the results of our `run_config` function.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自定义对象的属性设置为`run_config`函数的结果。
- en: Creating an object for our Rust interface
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的Rust接口创建一个对象
- en: 'We start our journey by setting up our interface object, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下方式设置我们的接口对象开始我们的旅程：
- en: 'We house our object that will pass itself into our Rust code in the `flitton_fib_rs/object_interface.py`
    file. Initially, we import what we need by running the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将传递自身到我们的Rust代码中的对象放在`flitton_fib_rs/object_interface.py`文件中。最初，我们通过以下代码导入我们需要的内容：
- en: '[PRE24]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then define the `__init__` method of our object by running the following
    code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过以下代码定义我们的对象的`__init__`方法：
- en: '[PRE25]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we can see that we can pass in the Fibonacci numbers that we want to be
    calculated in the parameters. We then just set our attributes to the parameters
    that we passed in. The result parameters defined here are of a `None` value. However,
    they will be populated by the Rust code when we pass this object into our Rust
    object interface.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们可以将想要计算的斐波那契数作为参数传递。然后我们只需将我们的属性设置为传递给我们的参数。这里定义的结果参数的值为`None`。然而，当我们将此对象传递到我们的Rust对象接口时，它们将由Rust代码填充。
- en: 'We then define a function that will pass our object into the Rust code by running
    the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个函数，通过运行以下代码将我们的对象传递到Rust代码中：
- en: '[PRE26]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we can see that this is done by merely passing the `self` reference into
    the function. Now that we have defined our object, we can move on to build our
    interface and interact with the Python GIL.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这是通过仅仅将`self`引用传递到函数中实现的。现在我们已经定义了我们的对象，我们可以继续构建我们的接口并与Python GIL交互。
- en: Acquiring the Python GIL in Rust
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Rust中获取Python GIL
- en: 'For our interface, we will house our function in the `src/interface/object.rs`
    file. We''ll proceed as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的接口，我们将在`src/interface/object.rs`文件中放置我们的函数。我们将按以下步骤进行：
- en: 'First, we must import all of what we need by running the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须通过运行以下代码导入所有我们需要的东西：
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Most of these imports will be familiar by now. The new import that we must make
    note of is the `Python` import. `Python` is a struct that is essentially a marker
    that is required for the Python operations that we will be doing.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到现在为止，大多数这些导入都是熟悉的。我们必须注意的新导入是`Python`导入。`Python`是一个结构体，本质上是一个标记，是我们将要进行的Python操作所必需的。
- en: 'Now that we have imported everything we need, we can build parameters for our
    interface and create a `PyDict` struct by running the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所有需要的东西，我们可以通过运行以下代码为我们的接口构建参数并创建一个`PyDict`结构体：
- en: '[PRE28]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, what we have essentially done is acquire the Python GIL, and then use
    this to create a `PyDict` struct. To fully understand what we are doing, it is
    best to explore what the Python GIL is. In [*Chapter 3*](B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046),
    *Understanding Concurrency*, we covered the concept of thread blocking. This means
    that if another thread is executing, then all other threads are locked. The GIL
    ensures that this happens, as demonstrated in the following diagram:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实际上所做的是获取Python GIL，然后使用它来创建一个`PyDict`结构体。为了完全理解我们在做什么，最好探索一下Python GIL是什么。在[*第3章*](B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046)，*理解并发*中，我们介绍了线程阻塞的概念。这意味着如果另一个线程正在执行，则所有其他线程都会被锁定。GIL确保了这一点，如下面的图所示：
- en: '![Figure 6.2 – GIL flow'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.2 – GIL流程'
- en: '](img/Figure_6.2_B17720.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B17720.jpg)'
- en: Figure 6.2 – GIL flow
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – GIL流程
- en: This is because Python does not have any concept of ownership. A Python object
    can be referenced as many times as we want. We can also mutate the variable from
    any of those references. When we acquire the `gil` variable, we ensure that only
    one thread can use the Python interpreter and the Python `gil` variable is a `GILGuard`
    struct that ensures that we acquire the GIL before we run any operations on Python
    objects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Python没有所有权概念。Python对象可以被引用多次，我们可以从任何这些引用中修改变量。当我们获取`gil`变量时，我们确保只有一个线程可以使用Python解释器和Python
    `gil`变量是一个`GILGuard`结构体，它确保我们在对Python对象执行任何操作之前获取GIL。
- en: Adding data to our newly created PyDict struct
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们新创建的PyDict结构体添加数据
- en: 'Now that we have control over Python objects with the GIL, we can move on to
    our next step, where we add the data from the input object to our newly created
    `PyDict` struct, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过GIL控制了Python对象，我们可以继续到下一步，将输入对象的数据添加到我们新创建的`PyDict`结构体中，如下所示：
- en: Our approach in this step can be summarized in the following diagram:![](img/Figure_6.3_B17720.jpg)
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个步骤中的方法可以总结如下：![](img/Figure_6.3_B17720.jpg)
- en: Figure 6.3 – PyDict flow
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.3 – PyDict流程
- en: 'We can achieve the first cycle depicted in *Figure 6.3* by running the following
    code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码实现*图6.3*中描述的第一个循环：
- en: '[PRE29]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we can see that we match the `getattr` function, throwing an error if
    `input_object` does not have the `number` attribute. If we do have the attribute,
    we assign it to `config_dict`.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们匹配`getattr`函数，如果`input_object`没有`number`属性，则抛出错误。如果我们有这个属性，我们将其分配给`config_dict`。
- en: 'We can do the second cycle by running the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码进行第二个循环：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It must be noted that there is a fair amount of repetition, with only one change.
    We could refactor this into a single function with an `attribute` parameter by
    running the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须注意的是，这里有很多重复，只有一处变化。我们可以通过运行以下代码将这个重构为一个带有 `attribute` 参数的单个函数：
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we can see that we get a lot of flexibility with our Python objects.
    This function can be used multiple times with the refactored code in our `object_interface`
    function, as seen here:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，我们的 Python 对象提供了很多灵活性。这个函数可以在我们的 `object_interface` 函数中多次使用重构后的代码，就像这里所看到的那样：
- en: '[PRE32]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we can see that we have changed `config_dict` to a mutable. Now that we
    have loaded our `PyDict` struct with all the data that we need, all we must do
    is run our `run_config` function, add it to the input object's attributes, and
    return it to the Python interface in the next step.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，我们将 `config_dict` 改为了可变的。现在我们已经用所有需要的数据加载了我们的 `PyDict` 结构体，我们只需运行我们的
    `run_config` 函数，将其添加到输入对象的属性中，并在下一步将其返回到 Python 接口。
- en: Setting the attributes of our custom object
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们自定义对象的属性
- en: 'We are now in the final stage of our interface module. Here are the steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于接口模块的最后阶段。以下是步骤：
- en: 'We can pass the output from our `run_config` function to our Python object
    interface by running the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码将我们的 `run_config` 函数的输出传递到我们的 Python 对象接口：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we can see that we get the `output_dict` Python dictionary from the `run_config`
    function. Once we have got this, we set the `input_object` attribute based on
    the items from `output_dict`.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，我们从 `run_config` 函数中获取了 `output_dict` Python 字典。一旦我们得到了这个，我们就根据 `output_dict`
    中的条目设置 `input_object` 属性。
- en: 'We have now completed our interface and we must subsequently plug it into our
    Rust module. We publicly define our interface file in the `src/interface/mod.rs`
    file by running the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经完成了接口，接下来必须将其插入到我们的 Rust 模块中。我们通过在 `src/interface/mod.rs` 文件中运行以下代码来公开定义我们的接口文件：
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can then define our interface function in our Rust module by importing it
    into our `src/lib.rs` file, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的 Rust 模块中通过将其导入到我们的 `src/lib.rs` 文件中来定义我们的接口函数，如下所示：
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then add our function to our module, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将我们的函数添加到我们的模块中，如下所示：
- en: '[PRE36]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our module is now fully functioning. As always, we must remember to update
    our GitHub repository, uninstall our old module in our Python environment, and
    reinstall it. Once this is done, we can test it by running a Python shell. In
    our shell, we can test our object by running the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在模块已经完全运行。和往常一样，我们必须记得更新我们的 GitHub 仓库，在我们的 Python 环境中卸载我们的旧模块，并重新安装它。一旦完成，我们可以通过运行一个
    Python 虚拟环境来测试它。在我们的虚拟环境中，我们可以通过运行以下代码来测试我们的对象：
- en: '[PRE37]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we can see that we import the object that we are going to use. We then
    initialize it and run the `process` function. Once this is done, we can see that
    our Rust code accepted our object and interacted with it as we have the correct
    results for our `number_results` attribute.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，我们导入了我们将要使用的对象。然后我们初始化它并运行 `process` 函数。一旦完成，我们可以看到我们的 Rust 代码接受并交互了我们的对象，因为我们有正确的
    `number_results` 属性的结果。
- en: Now we can interact with Python custom objects, the problems we can solve and
    how we can interact with the Python system are powerful. Custom Python objects
    do not hold us back. However, it is important not to get too carried away with
    Python objects in our Rust code. While we should use them in our interface, we
    shouldn't have to rely on them to build the whole program. In this section, we
    did do this, as we were leaning on a function that we built in the previous section
    to avoid excessive code, to get a point across. However, in your projects, Python
    objects should leave your code after the interface. If you find yourself using
    Python objects in your Rust code throughout, then you must ask yourself why you
    are not just using pure Python. Coding in Python will be slower than coding in
    Rust, but the metaclass, dynamic attributes, and many other Python features will
    make coding in Python easier and more enjoyable than trying to force a Python
    style of coding into Rust. Rust offers structs, traits, enums, and strong typing
    with lifetimes that get cut after moving out of scope to keep resources low.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以与Python自定义对象交互，我们可以解决的问题以及我们如何与Python系统交互都是强大的。自定义Python对象不会限制我们。然而，在Rust代码中，我们不应该过分沉迷于Python对象。虽然我们应该在我们的接口中使用它们，但我们不应该依赖它们来构建整个程序。在本节中，我们确实这样做了，因为我们依赖前一个部分中构建的函数来避免过多的代码，以便传达一个观点。然而，在你的项目中，Python对象应该在接口之后离开你的代码。如果你发现自己一直在Rust代码中使用Python对象，那么你必须问自己为什么你不用纯Python。用Python编写代码会比用Rust慢，但元类、动态属性以及许多其他Python特性将使在Python中编写代码比试图将Python风格的编码强加到Rust中更容易和更有趣。Rust提供了结构体、特质、枚举和具有生命周期的强类型，这些类型在超出作用域后会切断以保持资源低。
- en: So, lean into this style of coding to fully reap the benefits of building `pip`
    modules in Rust. Push past your comfort zone of the Python coding style. The next
    section is about building Python objects in Rust code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，深入这种编码风格，以充分利用在Rust中构建`pip`模块的好处。超越你对于Python编码风格的舒适区。下一节是关于在Rust代码中构建Python对象。
- en: Constructing our own custom Python objects in Rust
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rust中构建我们自己的自定义Python对象
- en: 'In this final section, we will build a Python module in Rust that can be interacted
    with in the Python system as if it were a native Python object. To do this, we
    must follow these steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将构建一个Rust中的Python模块，该模块可以在Python系统中交互，就像它是本地的Python对象一样。为此，我们必须遵循以下步骤：
- en: Define a Python class with all our attributes.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义具有所有属性的Python类。
- en: Define class static methods to process numbers.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类静态方法以处理数字。
- en: Define a class constructor.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类构造函数。
- en: Defining a Python class with the required attributes
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义具有所需属性的Python类
- en: 'To start our journey, we define our class in the `src/class_module/fib_processor.rs`
    file, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的旅程，我们在`src/class_module/fib_processor.rs`文件中定义我们的类，如下所示：
- en: 'To build our class, we need to import the required macros by running the following
    code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建我们的类，我们需要运行以下代码来导入所需的宏：
- en: '[PRE38]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we are using the `pyclass` macro to define our Rust Python class. We then
    use `pymethods` and `staticmethod` to define methods attached to the class. We
    also use standard Fibonacci numbers to calculate the Fibonacci numbers.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`pyclass`宏来定义我们的Rust Python类。然后我们使用`pymethods`和`staticmethod`来定义附加到类的方法。我们还使用标准的斐波那契数来计算斐波那契数。
- en: 'Now that we have imported everything we need, we can define the class and the
    attributes, as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所有需要的，我们可以定义类和属性，如下所示：
- en: '[PRE39]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we can see that we use Rust typing for our attributes. We also use a macro
    to state what we can do with these attributes. For our `number` and `numbers`
    attributes, we can get and set data belonging to these attributes. However, with
    our `results` attributes, we can only get data as this is set by the calculations.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们使用Rust类型来定义我们的属性。我们还使用宏来声明我们可以对这些属性做什么。对于我们的`number`和`numbers`属性，我们可以获取和设置属于这些属性的数据。然而，对于我们的`results`属性，我们只能获取数据，因为这是由计算设置的。
- en: Defining class static methods to process input numbers
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类静态方法以处理输入数字
- en: We can now use our attributes to implement class methods.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们的属性来实现类方法。
- en: 'Just as with standard structs, we can implement methods attached to the class
    with an `impl` block, as seen in the following code snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标准结构体一样，我们可以通过`impl`块实现附加到类的方法，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we can see that we have applied the `pymethods` macro to our `impl` block.
    We also apply the `staticmethod` macro to our `process_numbers` static method.
    This function was used before, in the previous section, to process lists of lists.
    Now that our static method is defined, we can use this in our constructor method
    in the next step.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经将 `pymethods` 宏应用到我们的 `impl` 块中。我们还应用了 `staticmethod` 宏到我们的 `process_numbers`
    静态方法上。这个函数在上一节中已经被使用，用于处理列表的列表。现在我们的静态方法已经定义，我们可以在下一步的构造方法中使用它。
- en: Defining a class constructor
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类构造函数
- en: 'Here are the steps we need to take:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取以下步骤：
- en: 'We can define our constructor method in our `impl` block by running the following
    code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码在我们的 `impl` 块中定义我们的构造方法：
- en: '[PRE52]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we accept inputs for the calculations of the Fibonacci numbers. We then
    clone them because we are going to pass them through the Fibonacci number functions.
    Once this is done, we apply the `fibonacci_number` function by mapping the input
    and collecting the results. We also collect the results from our static method.
    Once all the data is calculated, we construct the class and return it. Once this
    is done, all we must do is connect our class to our module.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们接受输入以计算斐波那契数。然后我们克隆它们，因为我们将要通过斐波那契数函数传递它们。一旦完成，我们通过映射输入并收集结果来应用 `fibonacci_number`
    函数。我们还从我们的静态方法中收集结果。一旦所有数据都被计算，我们构建类并返回它。一旦完成，我们只需将我们的类连接到我们的模块。
- en: 'This can be done by publicly declaring our class file in the `src/class_module/mod.rs`
    file, as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以通过在 `src/class_module/mod.rs` 文件中公开声明我们的类文件来完成，如下所示：
- en: '[PRE53]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that this is done, we import it into our `src/lib.rs` file by running the
    following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经完成，我们通过运行以下代码将它们导入到我们的 `src/lib.rs` 文件中：
- en: '[PRE54]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once this is done, we can add our class to our module in the same file, as
    follows:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以在同一文件中将我们的类添加到我们的模块中，如下所示：
- en: '[PRE55]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We have now fully integrated our class into the `pip` module.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全将我们的类集成到 `pip` 模块中。
- en: Wrapping up and testing our module
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收尾和测试我们的模块
- en: 'As always, when we get to the end of a section, we must remember to do the
    following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 总是，当我们到达一个章节的结尾时，我们必须记住做以下事情：
- en: Update the GitHub repository.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 GitHub 仓库。
- en: Uninstall the current `pip` module.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卸载当前的 `pip` 模块。
- en: Reinstall it in our Python environment.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 Python 环境中重新安装它。
- en: 'Now that we have finished building our module and updated the installed version,
    we can manually test our module in the Python system by following these next steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了模块的构建并更新了安装的版本，我们可以通过以下步骤在 Python 系统中手动测试我们的模块：
- en: 'We can open our Python shell and test our class by running the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以打开我们的 Python shell 并通过运行以下代码来测试我们的类：
- en: '[PRE56]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can see that our Rust object works seamlessly in our Python system with
    calculated results. We must remember that we have set rules around our attributes.
    To check this, we can try to assign our `results` attribute, which will give us
    the following output:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到我们的 Rust 对象在我们的 Python 系统中无缝工作，并计算出结果。我们必须记住，我们已经为我们的属性设置了规则。为了检查这一点，我们可以尝试分配我们的
    `results` 属性，这将给出以下输出：
- en: '[PRE57]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we can see that our `results` attribute is not writable. We can also
    test typing. Although our `number` attribute is writable, it is supposed to be
    a vector of integers. If we try to assign a string to this attribute, we get the
    following printout:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的 `results` 属性是不可写的。我们也可以测试类型。尽管我们的 `number` 属性是可写的，但它应该是一个整数向量。如果我们尝试将一个字符串分配给这个属性，我们会得到以下输出：
- en: '[PRE58]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, we can see that our typing is also enforced, even though it looks and
    acts like a native Python object. Finally, we can test to see if we can write
    a new value to the `number` attribute by running the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的类型检查也得到了强制执行，尽管它看起来和表现得像是一个原生的 Python 对象。最后，我们可以通过运行以下代码来测试我们是否可以写入
    `number` 属性的新值：
- en: '[PRE59]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It seems that we can write when the type and permissions are correct. Considering
    all of this, what is the point of creating these classes? They make the interface
    for our module smoother, but how much faster is this class?
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看起来，当类型和权限正确时，我们可以写入。考虑到所有这些，创建这些类的目的是什么？它们使我们的模块接口更加平滑，但这个类有多快？
- en: 'To quantify this, we can create a simple testing Python script in our Python
    environment, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了量化这一点，我们可以在我们的 Python 环境中创建一个简单的测试 Python 脚本，如下所示：
- en: 'First, in our Python script, we import our Rust class and the `time` module
    by running the following code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在我们的 Python 脚本中，我们通过运行以下代码导入我们的 Rust 类和 `time` 模块：
- en: '[PRE60]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We must now create a pure Python object with the same functionality in this
    script, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在必须在这个脚本中创建一个具有相同功能的纯 Python 对象，如下所示：
- en: '[PRE61]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now that our benchmark pure Python object is defined, we are now at the timing
    stage of the script, where we put the same inputs into both classes and test them
    with the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了基准纯 Python 对象，我们现在处于脚本的计时阶段，我们将相同的输入放入两个类中，并使用以下代码进行测试：
- en: '[PRE62]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Running this gives us the following output:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此代码会给我们以下输出：
- en: '[PRE63]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This translates to the following:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这等价于以下内容：
- en: '[PRE64]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Remember, the Rust class is the top reading. This means that our Rust class
    is *43 times faster than our Python class!* To put this into perspective, we can
    see the difference in the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Rust 类是最高效的。这意味着我们的 Rust 类比我们的 Python 类快 **43 倍**！为了更直观地了解这一点，我们可以看到以下截图中的差异：
- en: '![Figure 6.4 – Class speed difference between Rust and Python'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.4 – Class speed difference between Rust and Python](img/Figure_6.4_B17720.jpg)'
- en: '](img/Figure_6.4_B17720.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.4 – Class speed difference between Rust and Python](img/Figure_6.4_B17720.jpg)'
- en: Figure 6.4 – Class speed difference between Rust and Python
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – Rust 和 Python 之间的类速度差异
- en: Here, we can see that our class interfaces built in Rust are faster than our
    Python classes. `pyo3` supports class inheritance and other features. More resources
    on this are supplied in the *Further reading* section. We now have a strong base
    when it comes to working with Python objects in Rust. There are always more features
    to read up on, and these can be built on top of the structures that we have built.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们用 Rust 构建的类接口比我们的 Python 类更快。`pyo3` 支持类继承和其他功能。更多相关信息可以在 *进一步阅读*
    部分找到。现在，我们在 Rust 中处理 Python 对象方面有了坚实的基础。总有更多功能需要阅读，这些功能可以建立在我们所构建的结构之上。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added a third-party `pip` module into our `setup.py` file
    so that we could add another entry point that could read .`yml` files. We read
    the .`yml` file and passed the data from that file in the form of a dictionary
    into our Rust functions, handling the complex data structure under the `PyDict`
    struct. We then downcasted data from our complex data structure into other Python
    objects and Rust data types. This gave us the power to handle a range of Python
    data types passed into our Rust code, giving us extra flexibility in how our Python
    code interacts with our Rust code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将第三方 `pip` 模块添加到我们的 `setup.py` 文件中，以便我们可以添加另一个入口点，该入口点可以读取 `.yml` 文件。我们读取了
    `.yml` 文件，并将该文件中的数据以字典的形式传递到我们的 Rust 函数中，在 `PyDict` 结构体下处理复杂的数据结构。然后，我们将复杂的数据结构向下转换为其他
    Python 对象和 Rust 数据类型。这使得我们能够处理传递到 Rust 代码中的各种 Python 数据类型，从而在 Python 代码与 Rust
    代码交互方面提供了额外的灵活性。
- en: We went one step further than complex Python data structures by accepting custom
    Python objects under the `PyAny` struct. Once we accepted custom Python objects,
    we could inspect attributes and set them as and when we wanted to. We even acquired
    the Python GIL to create our own Python data structures to help us work with the
    custom Python objects passed into our Rust code. To polish off our Python object
    skills, we built Python classes within our Rust code that not only can be imported
    into the Python system, acting just like a pure Python class, but are also 44
    times faster. We now have a powerful tool that will not only speed up our Python
    code but will also enable us to interact with Python systems seamlessly.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `PyAny` 结构体下接受自定义 Python 对象，比复杂的 Python 数据结构更进一步。一旦我们接受了自定义 Python 对象，我们就可以检查属性并在需要时设置它们。我们甚至获得了
    Python GIL，以创建我们自己的 Python 数据结构，帮助我们处理传递到 Rust 代码中的自定义 Python 对象。为了完善我们的 Python
    对象技能，我们在 Rust 代码中构建了 Python 类，这些类不仅可以被导入到 Python 系统中，就像纯 Python 类一样，而且速度要快 44
    倍。我们现在有一个强大的工具，它不仅可以加快我们的 Python 代码，还可以使我们能够无缝地与 Python 系统交互。
- en: In the next chapter, we tackle the final hurdle that is stopping us from infusing
    Rust into every Python project we have. People reach for Python due to the extensive
    third-party modules that are built for it, such as statistical and `numpy` module
    and use it in our Rust code. This will enable us to utilize third-party Python
    modules in our Rust extension.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解决阻止我们将 Rust 添加到我们拥有的每个 Python 项目的最后一个障碍。人们之所以选择 Python，是因为为其构建了大量的第三方模块，例如统计和
    `numpy` 模块，并在我们的 Rust 代码中使用它们。这将使我们能够在 Rust 扩展中利用第三方 Python 模块。
- en: Questions
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you extract a vector of `i32` integers from a `PyDict` struct?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从 `PyDict` 结构体中提取一个 `i32` 整数向量？
- en: If we have a vector of strings but we apply a `.extract::<Vec<i32>>()`  function
    on it and we directly unwrap it, what will happen?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有一个字符串向量，但我们对其应用了一个 `.extract::<Vec<i32>>()` 函数，并且直接解包它，会发生什么？
- en: How would you be able to loop through a `Vec<i32>` vector, doubling each item
    and packaging the results in another vector in one line of Rust code?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Rust 代码的一行中遍历一个 `Vec<i32>` 向量，将每个元素加倍并将结果包装在另一个向量中？
- en: If we acquire the Python GIL to create a `PyDict` struct, will this affect the
    Python system in any way?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们获取 Python GIL 来创建一个 `PyDict` 结构体，这会以任何方式影响 Python 系统吗？
- en: Although our Python classes built in our Rust code essentially run the same
    way as our pure Python classes, there are some core differences. What are they?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们在 Rust 代码中构建的 Python 类本质上与我们的纯 Python 类运行方式相同，但有一些核心区别。它们是什么？
- en: Answers
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: First, we must get a list from the `PyDict` struct by applying the `get_item`
    function to `PyDict`. If there is data under the key that we use, we then perform
    `.downcast::<PyList>()` to convert our data into a `PyList` struct. If we achieve
    this, we then perform `.extract::<Vec<i32>>()` on the `PyList` struct, giving
    us a `Vec<i32>`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须通过将 `get_item` 函数应用于 `PyDict` 来从 `PyDict` 结构体中获取一个列表。如果我们在使用的键下有数据，我们然后执行
    `.downcast::<PyList>()` 将我们的数据转换为 `PyList` 结构体。如果我们做到了这一点，我们然后在 `PyList` 结构体上执行
    `.extract::<Vec<i32>>()`，给我们一个 `Vec<i32>`。
- en: Our `extract` function will automatically throw a `PyTypeError` Python-friendly
    error.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `extract` 函数将自动抛出一个 Python 友好的 `PyTypeError` 错误。
- en: 'With this, we use the `iter`, `map`, and `collect` functions, as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个，我们使用 `iter`、`map` 和 `collect` 函数，如下所示：
- en: '[PRE65]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: No—the Python system that is running the code has already acquired the GIL.
    If it does not have the GIL, it would just wait for another thread to finish before
    acquiring the GIL.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不——正在运行代码的 Python 系统已经获取了全局解释器锁（GIL）。如果没有 GIL，它将等待另一个线程完成后再获取 GIL。
- en: The typing system is still enforced. If we try to set an attribute that is a
    list of integers to a string, an error will be thrown. Another difference is that
    `set` and `get` macros for each attribute must be defined. If they are not, then
    the attribute cannot be accessed or set.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型系统仍然被强制执行。如果我们尝试将一个整数列表属性设置为字符串，将会抛出一个错误。另一个区别是，每个属性的 `set` 和 `get` 宏都必须定义。如果没有定义，则无法访问或设置该属性。
- en: Further reading
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*PyO3* (2021). *PyO3 user guide*—*Python Classes* [https://pyo3.rs/v0.13.2/class.html](https://pyo3.rs/v0.13.2/class.html)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PyO3* (2021). *PyO3 用户指南*—*Python 类* [https://pyo3.rs/v0.13.2/class.html](https://pyo3.rs/v0.13.2/class.html)'
