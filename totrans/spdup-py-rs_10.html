<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-183"><em class="italic"><a id="_idTextAnchor182"/>Chapter 10</em>: Injecting Rust into a Python Flask App</h1>&#13;
			<p>In <a href="B17720_09_Final_SK_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 9</em></a>, <em class="italic">Structuring a Python Flask App for Rust</em>, we set up a basic Python web application in Flask that could be deployed using Docker. In this chapter, we are going to fuse Rust into every aspect of that web application. This means polishing our skills of defining Rust packages that can be installed using <code>pip</code>. With these packages, we are going to plug Rust code into our Flask and Celery containers. We are also going to directly interact with an existing database using Rust, without having to worry about migrations. This is because our Rust package is going to mirror the schema of the existing database. We will need a Rust <code>nightly</code> version to compile our package, so we will also learn how to manage Rust <code>nightly</code> when building our Flask image. We will also learn how to use Rust packages from private GitHub repositories. </p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Fusing Rust into Flask and Celery</li>&#13;
				<li>Deploying Flask and Celery with Rust </li>&#13;
				<li>Deploying with a private GitHub repository</li>&#13;
				<li>Fusing Rust with data access</li>&#13;
				<li>Deploying Rust <code>nightly</code> in Flask</li>&#13;
			</ul>&#13;
			<p>Learning about these topics will enable us to use our Rust packages in a Python web application so that it can be deployed in Docker. This will bring our Rust skills directly in line with the real world, enabling us to speed up Python web applications without having to rewrite our entire infrastructure. If you are a Python web developer, you will be able to turn up to work after reading this chapter and start injecting Rust into web applications to introduce fast, safe code without much risk. </p>&#13;
			<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>Technical requirements</h1>&#13;
			<p>The following are the technical requirements for this chapter:</p>&#13;
			<ul>&#13;
				<li>The code and data for this chapter can be found at <a href="https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_ten">https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_ten</a>.</li>&#13;
				<li>In this chapter, you will be building a Docker-contained Flask application. This is available via the following GitHub repository: <a href="https://github.com/maxwellflitton/fib-flask">https://github.com/maxwellflitton/fib-flask</a>.</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-185"><a id="_idTextAnchor184"/>Fusing Rust into Flask and Celery</h1>&#13;
			<p>We will fuse <a id="_idIndexMarker677"/>Rust into our Flask application by installing our <a id="_idIndexMarker678"/>Rust Fibonacci calculation library using <code>pip</code>. We will then use it in our views and <a id="_idIndexMarker679"/>Celery tasks. This will<a id="_idIndexMarker680"/> speed up our Flask application without us having to make big changes to our infrastructure. To achieve this, we will carry out the following steps:</p>&#13;
			<ol>&#13;
				<li>Define our dependency on the Rust Fibonacci number calculation package.</li>&#13;
				<li>Build our calculation module with Rust.</li>&#13;
				<li>Create a calculation view using Rust in our Flask application.</li>&#13;
				<li>Insert Rust into our Celery task.</li>&#13;
			</ol>&#13;
			<p>With this, we will have a Flask application that has a speedup due to Rust. Let's get started!</p>&#13;
			<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/>Defining our dependency on the Rust Fibonacci number calculation package</h2>&#13;
			<p>When it <a id="_idIndexMarker681"/>comes to our Rust dependency, it would be tempting to just put our Rust dependency in our <code>requirements.txt</code> file. However, this can become confusing. Also, we are using an automated process to update our <code>requirements.txt</code> file. This runs the risk of wiping our GitHub repositories from the <code>requirements.txt</code> file. We must remember that our <code>requirements.txt</code> file is just a text file. Therefore, nothing is stopping<a id="_idIndexMarker682"/> us from just adding another text file that lists our GitHub repositories and using it to install the GitHub repositories that our application is dependent on. To do this, we will populate our <code>src/git_repos.txt</code> file with the following dependency:</p>&#13;
			<pre>git+https://github.com/maxwellflitton/flitton-fib-rs@main</pre>&#13;
			<p>Now, we can install our GitHub repository dependencies with the following command:</p>&#13;
			<pre>pip install -r git_repos.txt</pre>&#13;
			<p>This will result in our Python system downloading the GitHub repository and compiling it in our Python packages. We now know which GitHub repositories are powering our application, so we can start using automation tools to update our <code>requirements.txt</code> file. Now that we have installed our Rust package, we can start building a calculation module that will use Rust.</p>&#13;
			<h2 id="_idParaDest-187"><a id="_idTextAnchor186"/>Building our calculation model with Rust</h2>&#13;
			<p>Our <a id="_idIndexMarker683"/>calculation<a id="_idIndexMarker684"/> module will have the following structure:</p>&#13;
			<pre>src</pre>&#13;
			<pre>├── fib_calcs</pre>&#13;
			<pre>│   ├── __init__.py</pre>&#13;
			<pre>│   ├── enums.py</pre>&#13;
			<pre>│   └── fib_calculation.py</pre>&#13;
			<p>We already have our Python calculation in the <code>fib_calculation.py</code> file from the previous chapter. However, we are now supporting both Rust and Python implementations. </p>&#13;
			<p>To do this, we will start by defining an enum in our <code>enums.py</code> file with the following code:</p>&#13;
			<pre>from enum import Enum</pre>&#13;
			<pre>class CalculationMethod(Enum):</pre>&#13;
			<pre>    PYTHON = "python"</pre>&#13;
			<pre>    RUST = "rust"</pre>&#13;
			<p>With<a id="_idIndexMarker685"/> this enum, we can keep adding methods. For instance, if we were to develop microservices later on and have a separate server for calculating our Fibonacci numbers, we can add an API call to our enum and support it in <a id="_idIndexMarker686"/>our calculation interface. Depending on the configuration file, we can switch between all of them. Now that we have defined our enums, we can build our interface in the <code>src/fib_calcs/__init__.py</code> file:</p>&#13;
			<ol>&#13;
				<li value="1">First of all, we have to import what we need with the following code:<pre>import time
from flitton_fib_rs.flitton_fib_rs import \
  fibonacci_number
from fib_calcs.enums import CalculationMethod
from fib_calcs.fib_calculation import FibCalculation</pre><p>Here, we used the <code>time</code> module to time how long a process takes to run. We also imported our Python and Rust implementations for our calculations. Finally, we imported our enum to map which method we used.</p></li>&#13;
				<li>With all of this, we can start building the time process function in our <code>src/fib_calcs/__init__.py</code> file with the following code:<pre>def _time_process(processor, input_number):
    start = time.time()
    calc = processor(input_number)
    finish = time.time()
    time_taken = finish - start
    return calc, time_taken</pre><p>Here, we took in a calculation function under the <code>processor</code> parameter name and passed the <code>input_number</code> parameter into the function. We also timed this process<a id="_idIndexMarker687"/> and returned it with the Fibonacci number. Now that we've done this, we can build a function that processes an input string and convert that into our enum. We will not always pass a string into our interface, but if we can load a string signaling what process type we want from a configuration file, this will be important.</p></li>&#13;
				<li>Our <a id="_idIndexMarker688"/>processing method can be defined with the following code:<pre>def _process_method(input_method):
    calc_enum = CalculationMethod._value2member_map_.
                get(input_method)
    if calc_enum is None:
        raise ValueError(
            f"{input_method} is not supported, "
            f"please choose from "
     f"{CalculationMethod._value2member_map_.keys()}")
    return calc_enum</pre><p>Here, we can see that our string is stored in the key values of the <code>_value2member_map_</code> map. If it is not in the keys, then our enum will not support it, and the method will throw an error. However, if it exists, we return the enum associated with the key value.</p></li>&#13;
				<li>Now, we can define the two helper functions for our interface with the following code:<pre>def calc_fib_num(input_number, method):
    if isinstance(method, str):
        method = _process_method(input_method=method)
    if method == CalculationMethod.PYTHON:
        calc, time_taken = _time_process(
            processor=FibCalculation,
            input_number=input_number
        )
        return calc.fib_number, time_taken
    elif method == CalculationMethod.RUST:
        calc, time_taken = _time_process(
            processor=fibonacci_number,
            input_number=input_number
        )
        return calc, time_taken</pre></li>&#13;
			</ol>&#13;
			<p>Here, if we <a id="_idIndexMarker689"/>pass in a string for our method, we can convert it into an enum. If the enum points to Python, we can pass our Python calculation object, along with the input number, into our <code>_time_process</code> function. Then, we can <a id="_idIndexMarker690"/>return the Fibonacci number and time taken. If our enum points to Rust, we can perform the same operations but with the Rust function. With this approach, we can add and take away functionality. For instance, we can switch the timing process with another parameter that's pointing to another calculation function that does not time the process, resulting in a process that just performs the calculation without timing it if we want. However, for this example, we will be using the timing process to compare speeds. Now that we have built our interface, we can create our calculation view with this interface. </p>&#13;
			<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>Creating a calculation view using Rust</h2>&#13;
			<p>We are<a id="_idIndexMarker691"/> hosting our view in the <code>src/app.py</code> file. First, we will import our interface with the following code:</p>&#13;
			<pre>from fib_calcs import calc_fib_num</pre>&#13;
			<pre>from fib_calcs.enums import CalculationMethod</pre>&#13;
			<p>With this<a id="_idIndexMarker692"/> new interface and enum, we can make changes to our standard calculation view with the following code:</p>&#13;
			<pre>@app.route("/calculate/&lt;int:number&gt;")</pre>&#13;
			<pre>def calculate(number):</pre>&#13;
			<pre>    fib_calc = dal.session.query(FibEntry).filter_by(</pre>&#13;
			<pre>      input_number=number).one_or_none()</pre>&#13;
			<pre>    if fib_calc is None:</pre>&#13;
			<pre>        if number &lt; 50:</pre>&#13;
			<pre>            fib_number, time_taken = calc_fib_num(</pre>&#13;
			<pre>                input_number=number,</pre>&#13;
			<pre>                method=CalculationMethod.PYTHON</pre>&#13;
			<pre>            )</pre>&#13;
			<pre>            . . .</pre>&#13;
			<pre>            return f"you entered {number} " \</pre>&#13;
			<pre>                   f"which has a Fibonacci number of " \</pre>&#13;
			<pre>                   f"{fib_number} which took {time_taken}"</pre>&#13;
			<pre>    . . .</pre>&#13;
			<p>Here, we are using the new interface. Because of this, we can also return the time taken to perform the calculation. Now, we can build our Rust calculation view. It will take the same form as the standard calculation view, meaning that you can refactor it to have the Rust and Python calculation methods in the same view based on the parameter that's passed<a id="_idIndexMarker693"/> into the URL. If not, our Rust calculation<a id="_idIndexMarker694"/> view will take the form of the following code:</p>&#13;
			<pre>@app.route("/rust/calculate/&lt;int:number&gt;")</pre>&#13;
			<pre>def rust_calculate(number):</pre>&#13;
			<pre>    . . .</pre>&#13;
			<pre>    if fib_calc is None:</pre>&#13;
			<pre>        if number &lt; 50:</pre>&#13;
			<pre>            fib_number, time_taken = calc_fib_num(</pre>&#13;
			<pre>                input_number=number,</pre>&#13;
			<pre>                method=CalculationMethod.RUST</pre>&#13;
			<pre>            )</pre>&#13;
			<pre>            . . .</pre>&#13;
			<p>The dots in the aforementioned code show that this is the same code that's used in the standard calculation function. Now that our Rust package has been fused with our Flask application, we can insert Rust into our Celery task. </p>&#13;
			<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>Inserting Rust into our Celery task</h2>&#13;
			<p>When it comes to<a id="_idIndexMarker695"/> our background task in Celery, we do not have<a id="_idIndexMarker696"/> to worry about the timing. Because of the interface and configuration, we have to import the parameters and interface into the <code>src/task_queue/fib_calc_task.py</code> file with the following code:</p>&#13;
			<pre>from config import GlobalParams</pre>&#13;
			<pre>from fib_calcs import calc_fib_num</pre>&#13;
			<p>With this, we can now refactor our Celery task with the following code:</p>&#13;
			<pre>def create_calculate_fib(input_celery):</pre>&#13;
			<pre>    @input_celery.task()</pre>&#13;
			<pre>    def calculate_fib(number):</pre>&#13;
			<pre>        params = GlobalParams()</pre>&#13;
			<pre>        fib_number, _ = calc_fib_num(input_number=number,</pre>&#13;
			<pre>                                     method=params.get(</pre>&#13;
			<pre>                                     "CELERY_METHOD", </pre>&#13;
			<pre>                                     "rust"))</pre>&#13;
			<pre>        fib_entry = FibEntry(input_number=number,</pre>&#13;
			<pre>            calculated_number=fib_number)</pre>&#13;
			<pre>        dal.session.add(fib_entry)</pre>&#13;
			<pre>        dal.session.commit()</pre>&#13;
			<pre>    return calculate_fib</pre>&#13;
			<p>Here, we can see that we get the global parameters. We pass the <code>CELERY_METHOD</code> global<a id="_idIndexMarker697"/> parameter into the <code>params</code>. Considering that the parameters are inherited from the dictionary class, we can use the built-in <code>get</code> method. We can set the default <a id="_idIndexMarker698"/>calculation method to <code>rust</code> if we have not defined <code>CELERY_METHOD</code> in the configuration file.</p>&#13;
			<p>The application is now fully integrated, which means we can test our application. We must remember to run our development <code>docker-compose</code> environment, Flask application, and Celery worker. Accessing our two views will give us the following output:</p>&#13;
			<p class="figure-caption">  </p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B17720_10_01.jpg" alt="" width="1206" height="416"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 10.1 – Flask, Python, and Rust requests</p>&#13;
			<p>In the preceding screenshot, we can see that our Rust call is four times faster, even though the Rust <a id="_idIndexMarker699"/>request number is higher. We now have a working Python<a id="_idIndexMarker700"/> application that uses Rust to speed up the calculations. However, this is not very useful if we cannot deploy it. The internet is full of half-baked tutorials that teach you how to do something superficially in a development environment, while not being able to use or configure it in a production environment. In the next section, we will configure our Docker environment so that we can deploy our application. </p>&#13;
			<h1 id="_idParaDest-190"><a id="_idTextAnchor189"/>Deploying Flask and Celery with Rust</h1>&#13;
			<p>For our Flask <a id="_idIndexMarker701"/>application's Docker image to support our Rust packages, we need to make some changes to the <code>src/Dockerfile</code> file. Looking at this file, we<a id="_idIndexMarker702"/> can see that our image is built on <code>python:3.6.13-stretch</code>. This is essentially a Linux environment with Python installed. When we see this, we realize<a id="_idIndexMarker703"/> that we can be confident in<a id="_idIndexMarker704"/> manipulating our Docker image environment. If we can do this in Linux, there is a high chance we can do this in our Docker image. Considering this, what we must do in our <code>src/Dockerfile</code> file is install Rust and register <code>cargo</code> with the following code:</p>&#13;
			<pre>. . .</pre>&#13;
			<pre>RUN apt-get update -y</pre>&#13;
			<pre>RUN apt-get install -y python3-dev python-dev gcc</pre>&#13;
			<pre># setup rust</pre>&#13;
			<pre>RUN curl https://sh.rustup.rs -sSf | bash -s -- -y –profile </pre>&#13;
			<pre>  minimal –no-modify-path</pre>&#13;
			<pre># Add .cargo/bin to PATH</pre>&#13;
			<pre>ENV PATH="/root/.cargo/bin:${PATH}"</pre>&#13;
			<pre>. . .</pre>&#13;
			<p>Luckily <a id="_idIndexMarker705"/>for us, Rust is very easy to install. Remember that the <code>apt-get install -y python3-dev python-dev gcc</code> command allows us <a id="_idIndexMarker706"/>to use compiled extensions when using Python. Now <a id="_idIndexMarker707"/>that we've done this, we can pull and compile<a id="_idIndexMarker708"/> our Rust package with the following code:</p>&#13;
			<pre>. . .</pre>&#13;
			<pre># Install the dependencies</pre>&#13;
			<pre>RUN pip install --upgrade pip setuptools wheel</pre>&#13;
			<pre>RUN pip install -r requirements.txt</pre>&#13;
			<pre>RUN pip install -r git_repos.txt</pre>&#13;
			<pre>. . .</pre>&#13;
			<p>Everything else is the same. Our image is now ready to be built with the following command while our terminal is in the root of the <code>src/</code> directory:</p>&#13;
			<pre>docker build . -t flask-fib</pre>&#13;
			<p>This will rebuild our Docker image for our Flask application. Some bits might be skipped over in this build. Don't worry – Docker caches the layers in the image build that have not been changed. This is denoted with the following printout:</p>&#13;
			<pre>Step 1/14 : FROM python:3.6.13-stretch</pre>&#13;
			<pre> ---&gt; b45d914a4516</pre>&#13;
			<pre>Step 2/14 : WORKDIR /app</pre>&#13;
			<pre> ---&gt; Using cache</pre>&#13;
			<pre> ---&gt; b0331f8a005d</pre>&#13;
			<pre>Step 3/14 : ADD . /app</pre>&#13;
			<pre> ---&gt; Using cache</pre>&#13;
			<p>Once a<a id="_idIndexMarker709"/> step has been changed, every step following it will be rerun since the interrupted step might change the outcome of the steps following <a id="_idIndexMarker710"/>it. Note that the build might hang when <code>pip</code> installs our Rust<a id="_idIndexMarker711"/> package. This is because the package is being compiled. You may have noticed that we have to do this every time we install the <a id="_idIndexMarker712"/>Rust package. A more optimal distribution strategy will be explored in the next chapter. Now, if we run <code>docker-compose</code> in our deployment directory, we will see that we can use our Rust Flask container without any problems. </p>&#13;
			<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>Deploying with a private GitHub repository</h1>&#13;
			<p>If you are coding <a id="_idIndexMarker713"/>for a side project, company, or paid feature, you will be working with private GitHub repositories. This makes sense as we do not want people accessing a repository for free that you or your company plans on charging them for. However, if we set our Rust Fibonacci package's GitHub repository to private, delete all of our Flask images using the <code>docker image rm YOUR_IMAGE_ID_HERE</code> command, and run our <code>docker build . -t flask-fib</code> command again, we would get the following printout:</p>&#13;
			<pre>Collecting git+https://github.com/maxwellflitton/flitton-</pre>&#13;
			<pre>fib-rs@main</pre>&#13;
			<pre>Running command git clone -q </pre>&#13;
			<pre>https://github.com/maxwellflitton/</pre>&#13;
			<pre>flitton-fib-rs /tmp/pip-req-build-ctmjnoq0</pre>&#13;
			<pre>Cloning https://github.com/maxwellflitton/flitton-fib-rs </pre>&#13;
			<pre>(to revision main) to /tmp/pip-req-build-ctmjnoq0</pre>&#13;
			<pre>fatal: could not read Username for 'https://github.com': </pre>&#13;
			<pre>No such device or address</pre>&#13;
			<p>This is <a id="_idIndexMarker714"/>because our isolated Linux-based Docker image that is being built is not logged into GitHub, even though we are. As a result, the image that's being built could not pull the package from the GitHub repository. We could pass our GitHub credentials into the build via arguments, but this will show up in the image build layers. Therefore, anyone who has access to our image could look and see our GitHub credentials. This is a security hazard. Docker does have some documentation on passing in secrets. However, at the time of writing this book, the documentation is sparse and convoluted. A more straightforward approach is to clone our <code>flitton-fib-rs</code> package outside the image and pass it into the Docker image build, as shown here:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/B17720_10_02.jpg" alt="" width="978" height="818"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 10.2 – Private repository image build flow</p>&#13;
			<p>If we are<a id="_idIndexMarker715"/> going to use a continuous integration tool such as GitHub Actions or Travis, then we can run the process laid out in the preceding diagram with GitHub credentials passed in as secrets. GitHub Actions and Travis handle secrets with efficiency and simplicity. If we are building it locally, as we are doing in this example, then we should already be logged into GitHub as we are directly working on the Flask project in this project. To carry out the process laid out in the preceding diagram, we must carry out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Build a Bash script that orchestrates the process depicted in the preceding diagram.</li>&#13;
				<li>Reconfigure our Rust Fib package installment in our Dockerfile.</li>&#13;
			</ol>&#13;
			<p>This is the most straightforward approach to using private GitHub repositories in our web application builds. We will start by looking at the Bash script.</p>&#13;
			<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>Building a Bash script that orchestrates the whole process</h2>&#13;
			<p>Our script is housed in <code>src/build_image.sh</code>. First, we must declare that this is a Bash script <a id="_idIndexMarker716"/>and that the code should run in the directory of the Flask application. To do so, we must change to the directory that contains the script with the following code:</p>&#13;
			<pre>#!/usr/bin/env bash</pre>&#13;
			<pre>SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"</pre>&#13;
			<pre>cd $SCRIPTPATH</pre>&#13;
			<p>Now, we have to clone our package and remove our <code>.git</code> file from the repository with the following code:</p>&#13;
			<pre>git clone https://github.com/maxwellflitton/flitton-fib-</pre>&#13;
			<pre>  rs.git</pre>&#13;
			<pre>rm -rf ./flitton-fib-rs/.git</pre>&#13;
			<p>Now, our package is just a directory. We are ready to build our Docker image. However, if we do so, it might not work because our files might be cached. To prevent this from happening, we can run our build with no cache and then remove our cloned package after the build with the following code:</p>&#13;
			<pre>docker build . --no-cache -t flask-fib</pre>&#13;
			<pre>rm -rf ./flitton-fib-rs</pre>&#13;
			<p>We will have to run this script to run a build of our Flask application. However, if we were to run a build now, it would not work as our Dockerfile will still be trying to pull the directory from GitHub. To fix this, we will move on to the second step.</p>&#13;
			<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/>Reconfiguring the Rust Fib package installment in our Dockerfile </h2>&#13;
			<p>In our <code>src/Dockerfile</code> file, we<a id="_idIndexMarker717"/> must remove the <code>RUN pip install -r git_repos.txt</code> line as this will stop our image build from trying to pull from the GitHub repository. Now, we can <code>pip</code> <code>install</code> the local directory that has been passed in, and then remove it with the following code:</p>&#13;
			<pre>RUN pip install ./flitton-fib-rs</pre>&#13;
			<pre>RUN rm -rf ./flitton-fib-rs</pre>&#13;
			<p>Now, we<a id="_idIndexMarker718"/> can build our Flask image by running the following command:</p>&#13;
			<pre>sh build_image.sh</pre>&#13;
			<p>This will result in a long printout that will eventually tell us that the image was successfully built. Running our deployment <code>docker-compose</code> file will confirm this. You may want to install our package from a different Git branch. This can be done by adding three more lines to our <code>src/build_image.sh</code> file, as shown here:</p>&#13;
			<pre>. . .</pre>&#13;
			<pre>git clone –branch $1 </pre>&#13;
			<pre>  https://github.com/maxwellflitton/flitton-fib-rs.git</pre>&#13;
			<pre>cd flitton-fib-rs</pre>&#13;
			<pre>cd ..</pre>&#13;
			<pre>rm -rf ./flitton-fib-rs/.git</pre>&#13;
			<pre>. . .</pre>&#13;
			<p>Here, we cloned the repository containing the branch, whose name is based on the argument that's passed into the script. Once we've done this, we can remove the Git history by removing the <code>.git</code> file.</p>&#13;
			<p>Our Rust package is now fully fused with our Python web application in Docker. One bonus of installing our Rust package when building an image is that it does not have to be compiled every time we use the image. </p>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">We can go one step further when it comes to reducing our build, though this is optional. You do not have to do this to complete this chapter. Right now, we are installing Rust and then compiling our Rust Python package for the Fibonacci calculations. We can avoid the need to install Rust and compile every time by building wheels for a range of Linux distributions and Python versions. This can be done by pulling the ManyLinux Docker images and using them to compile our package into multiple distributions.</p>&#13;
			<p class="callout">The detailed steps on how to do this to your Python <code>pip</code> package coded in Rust are laid out in the Rust setup tools documentation (see the <em class="italic">Further reading</em> section). Once those steps are completed, you will end up with a range of wheels in your <code>dist</code> directory. Copy and paste the 3.6 version into your Flask <code>src</code> directory and instruct your Dockerfile to copy it into the image when it is being built. Once you've done this, you can point the <code>pip install</code> command directly to the wheel file you copied into the image build. The installation will be nearly instant. </p>&#13;
			<p>While <a id="_idIndexMarker719"/>fusing Rust with our Flask application is certainly useful, since we now have a real-world example of how our Rust code can be used in a deployment setting, we can go even further. In the next section, we will have our Rust code interact with our database.</p>&#13;
			<h1 id="_idParaDest-194"><a id="_idTextAnchor193"/>Fusing Rust with data access</h1>&#13;
			<p>In web applications, accessing a database is a big part of the process. We could import the <code>dal</code> object that<a id="_idIndexMarker720"/> we created in the <code>src/data_access.py</code> file and pass it into our Rust function, executing database operations through Python. While this will technically work, it is not ideal as we will have to waste time and effort extracting objects from the database queries, inspecting them, and converting them into Rust structs. We would then have to convert the Rust structs into Python objects before inserting them into the database. This is a lot of excess code that has a lot of interaction with Python, reducing its speed gain.</p>&#13;
			<p>Because a database is external from the Python web application, and it contains information about its schema, we can completely bypass Python's implementations by using the <code>diesel</code> Rust crate to automatically write our schema and database models in Rust based on the live database. We can also use <code>diesel</code> to manage the connection to the database. As a result, we can directly interact with the database, reducing our reliance on Python, speeding up our code, and reducing the amount of code that we have to write. To achieve this, we have to carry out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Set up our database cloning package.</li>&#13;
				<li>Set up our <code>diesel</code> environment.</li>&#13;
				<li>Autogenerate and configure our database models and schema.</li>&#13;
				<li>Define our database connection in Rust.</li>&#13;
				<li>Create a Rust function that gets all the Fibonacci records and returns them. </li>&#13;
			</ol>&#13;
			<p>Once we have <a id="_idIndexMarker721"/>completed these steps, we will have a Rust package that interacts with the database that can be added to our Flask application build and used if needed. We will start by setting up our database cloning package.</p>&#13;
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>Setting up our database cloning package</h2>&#13;
			<p>We should <a id="_idIndexMarker722"/>now be familiar with setting up a standard Rust package for Python. For our database package, we will have the following layout:</p>&#13;
			<pre>├── Cargo.toml</pre>&#13;
			<pre>├── diesel.toml</pre>&#13;
			<pre>├── rust_db_cloning</pre>&#13;
			<pre>│   └── __init__.py</pre>&#13;
			<pre>├── setup.py</pre>&#13;
			<pre>├── src</pre>&#13;
			<pre>│   ├── database.rs</pre>&#13;
			<pre>│   ├── lib.rs</pre>&#13;
			<pre>│   ├── models.rs</pre>&#13;
			<pre>│   └── schema.rs</pre>&#13;
			<pre>├── .env</pre>&#13;
			<p>You should know the role of some of these files by now. The new files have the following purposes:</p>&#13;
			<ul>&#13;
				<li><code>database.rs</code>: Houses the function that returns a database connection</li>&#13;
				<li><code>models.rs</code>: Houses the structs that define the database models, fields, and the behavior of the individual rows of a table in the database</li>&#13;
				<li><code>schema.rs</code>: Houses the schema of the tables of the database</li>&#13;
				<li><code>.env</code>: Houses the database URL for our <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) interactions</li>&#13;
				<li><code>Diesel.toml</code>: Houses the configuration for our <code>diesel</code> CLI</li>&#13;
			</ul>&#13;
			<p>Now, we <a id="_idIndexMarker723"/>can turn our attention to the <code>setup.py</code> file. Looking at the package layout, you should be able to define this file yourself, and I encourage you to give it a try. Here is an example of the barebones <code>setup.py</code> file that is needed to enable this package to be installed with <code>pip</code>:</p>&#13;
			<pre>#!/usr/bin/env python</pre>&#13;
			<pre>from setuptools import dist</pre>&#13;
			<pre>dist.Distribution().fetch_build_eggs(['setuptools_rust'])</pre>&#13;
			<pre>from setuptools import setup</pre>&#13;
			<pre>from setuptools_rust import Binding, RustExtension</pre>&#13;
			<pre>setup(</pre>&#13;
			<pre>    name="rust-database-cloning",</pre>&#13;
			<pre>    version="0.1",</pre>&#13;
			<pre>    rust_extensions=[RustExtension(</pre>&#13;
			<pre>        ".rust_db_cloning.rust_db_cloning",</pre>&#13;
			<pre>        path="Cargo.toml", binding=Binding.PyO3)],</pre>&#13;
			<pre>    packages=["rust_db_cloning"],</pre>&#13;
			<pre>    zip_safe=False,</pre>&#13;
			<pre>)</pre>&#13;
			<p>With this, our <code>rust_db_cloning/__init__.py</code> file contains the following code:</p>&#13;
			<pre>from .rust_db_cloning import *</pre>&#13;
			<p>Now, we <a id="_idIndexMarker724"/>can move onto our <code>Cargo.toml</code> file, which will list some dependencies that you are familiar with, as well as the new <code>diesel</code> dependency:</p>&#13;
			<pre>[package]</pre>&#13;
			<pre>name = "rust_db_cloning"</pre>&#13;
			<pre>version = "0.1.0"</pre>&#13;
			<pre>authors = ["maxwellflitton"]</pre>&#13;
			<pre>edition = "2018"</pre>&#13;
			<pre>[dependencies]</pre>&#13;
			<pre>diesel = { version = "1.4.4", features = ["postgres"] }</pre>&#13;
			<pre>dotenv = "0.15.0"</pre>&#13;
			<pre>[lib]</pre>&#13;
			<pre>name = "rust_db_cloning"</pre>&#13;
			<pre>crate-type = ["cdylib"]</pre>&#13;
			<pre>[dependencies.pyo3]</pre>&#13;
			<pre>version = "0.13.2"</pre>&#13;
			<pre>features = ["extension-module"]</pre>&#13;
			<p>With that, we have defined the basics for our package to be installed via <code>pip</code>. It will not be installed yet as we have nothing in our <code>src/lib.rs</code> file, but we will fill that file out in the final step. Now, we can move on to the next step, which is setting up our <code>diesel</code> environment.</p>&#13;
			<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>Setting up the diesel environment</h2>&#13;
			<p>We will be <a id="_idIndexMarker725"/>cloning our schema from our development database so that we can hardcode the URL into our <code>.env</code> file, as follows:</p>&#13;
			<pre>DATABASE_URL=postgresql://user:password@localhost:5432/fib</pre>&#13;
			<p>Since this database configuration will never end up in a production environment and is merely used to generate the schema and models from a development database, it is OK if this URL gets into the wrong hands. Having this hardcoded into your GitHub repository is not the end of the world. With this in mind, we can define where we want our schema to be printed in our <code>diesel.toml</code> file with the following code:</p>&#13;
			<pre>[print_schema]</pre>&#13;
			<pre>file = "src/schema.rs"</pre>&#13;
			<p>Now that we have written everything we need, we can start installing and running the <code>diesel</code> CLI. You may get compilation errors when installing and compiling <code>diesel</code>. If this is the case while you are reading this, you can get around these compilation errors by switching to Rust <code>nightly</code>. Rust <code>nightly</code> provides the latest releases of Rust; however, it is less stable. Therefore, you should try and follow these steps without switching to <code>nightly</code> but if you find that you need to, then you can switch to <code>nightly</code> by installing it with the following code:</p>&#13;
			<pre>rustup toolchain install nightly</pre>&#13;
			<p>Once it has been installed, we can switch to <code>nightly</code> with the following command:</p>&#13;
			<pre>rustup default nightly</pre>&#13;
			<p>Your Rust compilations will be running in <code>nightly</code> now. Going back to setting up our <code>diesel</code> environment, we have to install the <code>diesel</code> CLI with the following command:</p>&#13;
			<pre>cargo install diesel_cli --no-default-features </pre>&#13;
			<pre>--features postgres</pre>&#13;
			<p>With this, we can now use the CLI combined with the URL in the <code>.env</code> file to interact with our database.</p>&#13;
			<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Autogenerating and configuring our database models and schema </h2>&#13;
			<p>In this step, we will be interacting with the development database in Docker. Considering this, before<a id="_idIndexMarker726"/> moving on, you need to open another terminal and run the development <code>docker-compose</code> environment in the <code>flask-fib</code> repository. Running this will run the <a id="_idIndexMarker727"/>database that we will connect to so that we can access the database schema and models. Now that the CLI has been installed, we can print the schema with the following command:</p>&#13;
			<pre>diesel print-schema &gt; src/schema.rs</pre>&#13;
			<p>There will be no printouts in the terminal but if we open our <code>src/schema.rs</code> file, we will see the following code:</p>&#13;
			<pre>table! {</pre>&#13;
			<pre>    alembic_version (version_num) {</pre>&#13;
			<pre>        version_num -&gt; Varchar,</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>table! {</pre>&#13;
			<pre>    fib_entries (id) {</pre>&#13;
			<pre>        id -&gt; Int4,</pre>&#13;
			<pre>        input_number -&gt; Nullable&lt;Int4&gt;,</pre>&#13;
			<pre>        calculated_number -&gt; Nullable&lt;Int4&gt;,</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>allow_tables_to_appear_in_same_query!(</pre>&#13;
			<pre>    alembic_version,</pre>&#13;
			<pre>    fib_entries,</pre>&#13;
			<pre>);</pre>&#13;
			<p>Here, we can see that our <code>alembic</code> version is in the schema as a separate table. This is how <code>alembic</code> keeps track of the migrations. We can also see that our <code>fib_entries</code> table has<a id="_idIndexMarker728"/> been mapped. While we could have done this ourselves without the <code>diesel</code> CLI, it is a lifesaver, ensuring <a id="_idIndexMarker729"/>that the schema is always up to date with the database. This also saves time in big, complex databases and reduces errors. </p>&#13;
			<p>Now that our schema has been defined, we can define our models with the following command:</p>&#13;
			<pre>diesel_ext &gt; src/models.rs</pre>&#13;
			<p>This gives us the following code:</p>&#13;
			<pre>#![allow(unused)]</pre>&#13;
			<pre>#![allow(clippy::all)]</pre>&#13;
			<pre>#[derive(Queryable, Debug, Identifiable)]</pre>&#13;
			<pre>#[primary_key(version_num)]</pre>&#13;
			<pre>pub struct AlembicVersion {</pre>&#13;
			<pre>    pub version_num: String,</pre>&#13;
			<pre>}</pre>&#13;
			<pre>#[derive(Queryable, Debug)]</pre>&#13;
			<pre>pub struct FibEntry {</pre>&#13;
			<pre>    pub id: i32,</pre>&#13;
			<pre>    pub input_number: Option&lt;i32&gt;,</pre>&#13;
			<pre>    pub calculated_number: Option&lt;i32&gt;,</pre>&#13;
			<pre>}</pre>&#13;
			<p>This is not completely perfect, and we have to make some changes. The models do not have the tables defined. <code>diesel</code> assumes that the table name is just the plural of the model's name. For instance, if we have a data model called <em class="italic">test</em>, then <code>diesel</code> would assume that the table is called <em class="italic">tests</em>. However, for us, this is not the case as we specifically defined our tables in our Flask application when running migrations in the previous <a id="_idIndexMarker730"/>chapter. We can also remove the two <code>allow</code> macros as we will not be using this functionality. Instead, we <a id="_idIndexMarker731"/>will import our schemas and define them in the <code>table</code> macro. After this rearrangement, our <code>src/models.rs</code> file should look like this:</p>&#13;
			<pre>use crate::schema::fib_entries;</pre>&#13;
			<pre>use crate::schema::alembic_version;</pre>&#13;
			<pre>#[derive(Queryable, Debug, Identifiable)]</pre>&#13;
			<pre>#[primary_key(version_num)]</pre>&#13;
			<pre>#[table_name="alembic_version"]</pre>&#13;
			<pre>pub struct AlembicVersion {</pre>&#13;
			<pre>    pub version_num: String,</pre>&#13;
			<pre>}</pre>&#13;
			<pre>#[derive(Queryable, Debug, Identifiable)]</pre>&#13;
			<pre>#[table_name="fib_entries"]</pre>&#13;
			<pre>pub struct FibEntry {</pre>&#13;
			<pre>    pub id: i32,</pre>&#13;
			<pre>    pub input_number: Option&lt;i32&gt;,</pre>&#13;
			<pre>    pub calculated_number: Option&lt;i32&gt;,</pre>&#13;
			<pre>}</pre>&#13;
			<p>Our models and schema are now ready to be used in our Rust package. Considering this, we can move on to the next step, which is defining our database connection. </p>&#13;
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Defining our database connection in Rust</h2>&#13;
			<p>Our <a id="_idIndexMarker732"/>database connection would traditionally take the database URL from the environment and use this to make a connection. However, this is a Rust package that is an appendage to our Flask application. There is no point in having another sensitive piece of information that has to be loaded. Therefore, to avoid extra complications and another point of security failure, we will merely pass the database URL from the Flask application to make the connection, since the Flask application is managing the configuration and loading the sensitive data anyway. The entirety of our database connection can be handled in our <code>src/database.rs</code> file. First, we must import what we need with the following code:</p>&#13;
			<pre>use diesel::prelude::*;</pre>&#13;
			<pre>use diesel::pg::PgConnection;</pre>&#13;
			<p><code>prelude</code> helps us use the <code>diesel</code> macros, and <code>PgConnection</code> is what we will return to get a database connection. With this, we can build our database connection function with the following code:</p>&#13;
			<pre>pub fn establish_connection(url: String) -&gt; PgConnection {</pre>&#13;
			<pre>    PgConnection::establish(&amp;url)</pre>&#13;
			<pre>      .expect(&amp;format!("Error connecting to {}", url))</pre>&#13;
			<pre>}</pre>&#13;
			<p>This can be imported anywhere where we need a database connection. At this point, we can start creating a function that gets all the records and returns them in dictionaries. </p>&#13;
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Creating a Rust function that gets all the Fibonacci records and returns them</h2>&#13;
			<p>To avoid excessive<a id="_idIndexMarker733"/> complexity in this example, we will be doing everything in the <code>src/lib.rs</code> file. However, it is advised that you build some modules and import them into the <code>src/lib.rs</code> file for more complex packages. First of all, we will import everything we need to build the function and bind it with the following code:</p>&#13;
			<pre>#[macro_use] extern crate diesel;</pre>&#13;
			<pre>extern crate dotenv;</pre>&#13;
			<pre>use diesel::prelude::*;</pre>&#13;
			<pre>use pyo3::prelude::*;</pre>&#13;
			<pre>use pyo3::wrap_pyfunction;</pre>&#13;
			<pre>use pyo3::types::PyDict;</pre>&#13;
			<pre>mod database;</pre>&#13;
			<pre>mod schema;</pre>&#13;
			<pre>mod models;</pre>&#13;
			<pre>use database::establish_connection;</pre>&#13;
			<pre>use models::FibEntry;</pre>&#13;
			<pre>use schema::fib_entries;</pre>&#13;
			<p>The <a id="_idIndexMarker734"/>order of the imports matters here. We import the <code>diesel</code> crate with macro use straightaway. Therefore, files such as <code>database</code> and <code>schema</code> will not error out because they are using <code>diesel</code> macros. <code>dotenv</code> is not being used in our example as we are passing in the database URL from the Python system. However, it's useful to know about this if you want to get database URLs from the environment. Then, we can import the <code>pyo3</code> macros and structs that we need, and the structs and functions that we defined. With these imports, we can define our <code>get_fib_entries</code> function with the following code:</p>&#13;
			<pre>#[pyfunction]</pre>&#13;
			<pre>fn get_fib_entries(url: String, py: Python) -&gt; Vec&lt;&amp;PyDict&gt; </pre>&#13;
			<pre>{</pre>&#13;
			<pre>   let connection = establish_connection(url);  </pre>&#13;
			<pre>   let fibs = fib_entries::table</pre>&#13;
			<pre>       .order(fib_entries::columns::input_number.asc())</pre>&#13;
			<pre>       .load::&lt;FibEntry&gt;(&amp;connection)</pre>&#13;
			<pre>       .unwrap();</pre>&#13;
			<pre>   </pre>&#13;
			<pre>   let mut buffer = Vec::new();</pre>&#13;
			<pre>   for i in fibs {</pre>&#13;
			<pre>       let placeholder = PyDict::new(py);</pre>&#13;
			<pre>       placeholder.set_item("input number", </pre>&#13;
			<pre>         i.input_number.unwrap());</pre>&#13;
			<pre>       placeholder.set_item("fib number", </pre>&#13;
			<pre>          i.calculated_number.unwrap());</pre>&#13;
			<pre>       buffer.push(placeholder);</pre>&#13;
			<pre>   }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Using Python <a id="_idIndexMarker735"/>to build a list of dictionaries is not new, and neither is the definition of the function. What is new, however, is establishing a connection, ordering it using the schema columns, and loading it as a list of <code>FibEntry</code> structs. We pass a reference to the connection into our query and unwrap it as it returns a result. We can chain more functions to it, such as <code>.filter</code>, if needed. The <code>diesel</code> documentation does a good job of covering the different types of queries and inserts you can perform. Once we've done this, we can add it to our <code>rust_db_cloning</code> module with the following code:</p>&#13;
			<pre>#[pymodule]</pre>&#13;
			<pre>fn rust_db_cloning(py: Python, m: &amp;PyModule) </pre>&#13;
			<pre>    -&gt; PyResult&lt;()&gt; {</pre>&#13;
			<pre>    m.add_wrapped(wrap_pyfunction!(get_fib_enteries));</pre>&#13;
			<pre>    Ok(())</pre>&#13;
			<pre>}</pre>&#13;
			<p>With this, our <a id="_idIndexMarker736"/>code is ready to be uploaded to the GitHub repository and used in our Flask application. </p>&#13;
			<p>Now, we can quickly test whether our package works before defining it in our Dockerfile. First of all, we need to <code>pip</code> <code>install</code> it in our Flask application virtual environment. This is another point where you might have compilation issues. To get around this, you might have to switch to Rust <code>nightly</code> to <code>pip</code> <code>install</code> the package you just built. Once our package has been installed, we can check it out by adding a simple <code>get</code> view to our Flask application. In the <code>src/app.py</code> file of our Flask application, we can import our function with the following code:</p>&#13;
			<pre>from rust_db_cloning import get_fib_entries</pre>&#13;
			<p>Now, we can define our <code>get</code> view with the following code:</p>&#13;
			<pre>@app.route("/get")</pre>&#13;
			<pre>def get():</pre>&#13;
			<pre>    return str(get_fib_entries(dal.url))</pre>&#13;
			<p>Remember that in the previous chapter, we defined the <code>url</code> attribute of <code>dal</code> with the URL from <code>GlobalParams</code>, which was loaded from the <code>.yml</code> config file. We have to turn it into a string; otherwise, the Flask serialization will not be able to process it. Running this in the development <code>docker-compose</code> environment will give us the following output:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/B17720_10_03.jpg" alt="Figure 10.3 – Simple get view from our Flask application&#13;&#10;" width="1440" height="174"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 10.3 – Simple get view from our Flask application</p>&#13;
			<p>You may have different numbers, depending on what you have in your database. However, what <a id="_idIndexMarker737"/>we have here is a Rust package that keeps up with the changes in the database that can interact directly with the database. Now that this is working in our development setup, we can start packaging our Rust <code>nightly</code> package for deployment. </p>&#13;
			<h1 id="_idParaDest-200"><a id="_idTextAnchor199"/>Deploying Rust nightly in Flask</h1>&#13;
			<p>To<a id="_idIndexMarker738"/> package our <code>nightly</code> database Rust package so that it can be deployed, we have to add another clone of our GitHub repository to our build Bash script, install <code>nightly</code>, and switch to it when we are installing our database package with <code>pip</code>. You can probably guess what we are going to achieve by cloning our database GitHub repository in our Bash script. </p>&#13;
			<p>For reference, our <code>src/build_image.sh</code> file will take the form of the following code:</p>&#13;
			<pre>. . .</pre>&#13;
			<pre>git clone https://github.com/maxwellflitton/</pre>&#13;
			<pre>flitton-fib-rs.git</pre>&#13;
			<pre>git clone https://github.com/maxwellflitton/</pre>&#13;
			<pre>rust-db-cloning.git</pre>&#13;
			<pre>rm -rf ./flitton-fib-rs/.git</pre>&#13;
			<pre>rm -rf ./rust-db-cloning/.git</pre>&#13;
			<pre>docker build . --no-cache -t flask-fib</pre>&#13;
			<pre>rm -rf ./flitton-fib-rs</pre>&#13;
			<pre>rm -rf ./rust-db-cloning</pre>&#13;
			<p>Here, we can see that we have merely added the code for cloning the <code>rust-db-cloning</code> repository, removed the <code>.git</code> file in that <code>rust-db-cloning</code> repository, and then removed the <code>rust-db-cloning</code> repository once the image build has finished. When it <a id="_idIndexMarker739"/>comes to our Dockerfile, these steps will remain the same. The only difference is that after installing our normal Rust package, we install <code>nightly</code>, switch to it, and then install our database package. This can be achieved with the following code:</p>&#13;
			<pre>. . .</pre>&#13;
			<pre>RUN pip install ./flitton-fib-rs</pre>&#13;
			<pre>RUN rm -rf ./flitton-fib-rs</pre>&#13;
			<pre>RUN rustup toolchain install nightly</pre>&#13;
			<pre>RUN rustup default nightly</pre>&#13;
			<pre>RUN pip install ./rust-db-cloning</pre>&#13;
			<pre>RUN rm -rf ./rust-db-cloning</pre>&#13;
			<pre>. . .</pre>&#13;
			<p>Even though one is compiled with normal Rust, while the other is compiled with Rust <code>nightly</code>, they will both run fine when the application is running. Building this image and running it in the deployment <code>docker-compose</code> environment will show us that the container will process the Rust computation view and get it from the database view without any problems. With this, we now have all the tools we need to fuse Rust into Python web applications and deploy them in Docker. </p>&#13;
			<h1 id="_idParaDest-201"><a id="_idTextAnchor200"/>Summary</h1>&#13;
			<p>In this chapter, we have put all our Rust fusing skills to work to build packages that are baked into Docker images for a Python web application. We attached Rust packages directly to the web application, and then to the Celery worker, resulting in a significant speedup when we asked our web application to calculate the Fibonacci number.</p>&#13;
			<p>Then, we altered our build process to take Rust packages from private GitHub repositories when building our Python web application image. Finally, we connected directly to the database with Rust and used Rust <code>nightly</code> to compile it. We managed to include this in our Python web application Docker build. This resulted in us not only being able to fuse Rust into a deployable web application but also use Rust <code>nightly</code> and databases to solve our problems</p>&#13;
			<p>With this in mind, we can now use what we have learned in this book for production web applications. You can now start coding in Rust and plug your Rust packages into existing Python web applications that can be deployed in Docker, without having to make major changes to the Python web application build process.</p>&#13;
			<p>Reaching for Rust to solve a speed bottleneck or to ensure that the code is consistent and safe in a live Python web application is something you can do in your day job tomorrow. You can now bring forward the fastest memory-safe programming language into your Python projects without having to overhaul your existing system. You are now capable of bridging the gap between practically maintaining an existing tried and tested system and a cutting-edge language. In the next and final chapter, we will cover some best practices. But right now, you know the key concepts to go and change your project or organization. </p>&#13;
			<h1 id="_idParaDest-202"><a id="_idTextAnchor201"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">How does directly connecting to a database in Rust reduce code?</li>&#13;
				<li>Why can't we just pass login credentials into our Docker image build Dockerfile?</li>&#13;
				<li>We did not make any migrations in this chapter. How did we map our models and schema of a database to our Rust module, and how do we continue to keep up with database changes?</li>&#13;
				<li>Why do we pass the database URL into our database Rust package as opposed to loading it from a config file or environment? </li>&#13;
				<li>Do we have to do anything extra if we were going to fuse Rust with a Django, bottle, or FastAPI Python web application?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-203"><a id="_idTextAnchor202"/>Answers</h1>&#13;
			<ol>&#13;
				<li value="1">Directly connecting to a database with Rust reduces the amount of code we must write as we do not have to inspect the Python objects that are returned from the Python database call. We also do not have to package data into Python objects before inserting them into the database. This essentially removes a whole layer of code that we must write when interacting with the database. </li>&#13;
				<li>If someone gets hold of our image, they can access the layers of the build. As a result, they can access the arguments that have been passed into the build. This will mean that they can see the credentials we use to log in.</li>&#13;
				<li>We used the <code>diesel</code> crate to connect to the database and automatically print the schemas and models based on the database it connects to. We can do this repeatedly to keep up to date with new database migrations.  </li>&#13;
				<li>We must remember that our Rust database package is an appendage to our Python web application. Our Python web application has already loaded the database URL. Loading credentials into our package just adds another possibility for a security breach with no advantages.</li>&#13;
				<li>No – our fusing method is completely detached from the <code>pip</code> installation process and the database mapping process.</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-204"><a id="_idTextAnchor203"/>Further reading</h1>&#13;
			<ul>&#13;
				<li>Diesel documentation for Rust (2021): Crate Diesel: <a href="https://diesel.rs">https://diesel.rs</a></li>&#13;
				<li>Setup tools Rust documentation (2021): Distributing a Rust Python package with wheels: <a href="https://pypi.org/project/setuptools-rust/">https://pypi.org/project/setuptools-rust/</a> </li>&#13;
				<li>ManyLinux GitHub (2021): <a href="https://github.com/pypa/manylinux%0D">https://github.com/pypa/manylinux</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>