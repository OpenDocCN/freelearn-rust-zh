- en: Functional Control Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The control flow is the most basic building block of programming. Early languages
    had no concept of data structures or functions, only program flow. These control
    flow structures have evolved over time, from simple branches and loops to the
    complex value expressions available in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start developing the project that will form the basis
    of all code examples in this book. The first project's requirements are introduced
    immediately. Then, we will provide you with actionable steps to transform project
    requirements into a code outline with tests. Lastly, we will develop code for
    the full deliverable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learning outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering project requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecting a solution based on project requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using and recognizing expressions in functional style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the solution with integration and unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A recent version of Rust is necessary to run the examples provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code is also available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  prefs: []
  type: TYPE_NORMAL
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To design the program, let's look at the various aspects required for the project.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering project requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this situation: Your engineering firm is being considered for a contract
    to design software to control the elevators for a real estate developer. The contract
    lists three buildings under development with various heights and non-uniform elevator
    designs. The elevator designs are being finalized by other subcontractors and
    will become available shortly after the software contract is awarded.'
  prefs: []
  type: TYPE_NORMAL
- en: To submit your proposal, your firm should demonstrate the basic capabilities
    of your elevator control software. Then, once awarded, you will be expected to
    integrate these capabilities into the final software, along with modifications
    that are necessary to accommodate the physical elevator specifications and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To win the proposal, your team agrees on several key points on which to outperform
    competitors. Namely, your elevators should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Take less time moving between floors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop at each floor location more precisely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a smoother ride for passengers in transit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a program deliverable to accompany the project proposal, you are expected
    to provide a simulation of elevator behavior. You are responsible for further
    details and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following questions should be resolved now:'
  prefs: []
  type: TYPE_NORMAL
- en: What data will the program access and store?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What input will the program expect?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What output should the program produce?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After some deliberation, your team agrees on some behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: The program should emphasize the elevator's location, velocity, and acceleration.
    Velocity determines ride duration. Acceleration determines ride comfort. The location,
    at rest, determines stop precision. These are the key selling points that your
    company will emphasize, so the demonstration software should mirror the same message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As input, the program should take a file describing the number of floors and
    floor height, and finally a list of floor requests for the elevator to process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of the program should be real-time information regarding the elevator's
    location, velocity, and acceleration. After processing all floor requests, the
    program should print average and standard deviations for location, velocity, and
    acceleration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecting a code map from requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To outline our code solution, we will use the `stubs` method. To use this process,
    we simply start a code project normally and fill out high-level details as we
    think of them. Details will be left unimplemented until we finalize the outline.
    After we are satisfied with the overall program design, then we can start implementing
    program logic. We will begin the project now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Rust project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new Rust project, we will perform the following steps (alternatively,
    you can invoke `cargo new`):'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder for the Rust project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `Cargo.toml` file, which is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `src/main.rs` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can build the project with `cargo build`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing stubs for each program requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Program requirements are typically phrased as outcomes. What effects should
    this program have when you run it? Answering this question with code is often
    straightforward. Here is a list of steps to methodically transform project requirements
    into code:'
  prefs: []
  type: TYPE_NORMAL
- en: List all program requirements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List dependencies or prerequisites for each requirement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a dependency graph from the requirements and dependencies lists
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write stubs that implement the dependency graph
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With practice, these steps can be combined into a single step of writing the
    stub code. However, if you become overwhelmed during the architecture phase of
    a project, then it may be helpful to go through these steps explicitly. This is
    a reliable method to break down complex problems into smaller problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, to list all program requirements, from earlier consideration, we know
    that we need to store real-time data for location, velocity, and acceleration.
    The program should accept an input file or standard input describing the number
    of floors, floor height, and a list of floor requests to be processed. The output
    of the program should be real-time elevator location, velocity, and acceleration,
    with a summary, upon completion, of all transport requests. The summary should
    list average and standard deviation for location, velocity, and acceleration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Secondly, list dependencies or prerequisites for each requirement. The data
    seems to be atomic with no dependencies or prerequisites. The program flow seems
    to naturally take the form of a polling loop, updating real-time state information
    from sensors and issuing motion commands once per loop. There is a time-lagged
    circular dependency between elevator state and motion commands: motion commands
    are chosen based on state, and the next loop will realize the time-adjusted effect
    of those commands.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thirdly, create a dependency graph from the requirements and dependencies lists
    with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the location, velocity, and acceleration state
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the motor input voltage
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the input building description and floor requests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the input and store as building description and floor requests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Loop while there are remaining floor requests:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the location, velocity, and acceleration
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the next floor request in the queue is satisfied, then remove it from the
    queue
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust motor control to process the next floor request
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Print real-time statistics
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the summary
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fourthly, write stubs that implement the dependency graph. We will update `src/main.rs`
    to implement this stub logic. Note that the variables, declared by `let` bindings,
    are stored inside the `main` function. The mutable state must be stored inside
    a function or a data structure. This is shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could have written the loop as a separate function. The function
    would check the condition, and the function would potentially call itself again.
    When a function calls itself, this is called **recursion**. Recursion is an extremely
    common and important pattern in functional programming. However, this specific
    type of recursion, known as **tail recursion**, is not recommended in Rust currently
    (see RFC #271 ([https://github.com/rust-lang/rfcs/issues/271](https://github.com/rust-lang/rfcs/issues/271))—without
    this proposed optimization, the tail recursion may unnecessarily use extra stack
    space and run out of memory).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive loop code would become as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Implementing program logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a stub program has been created, we can proceed to replace stubs with working
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Filling in the blanks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have code stubs and a map of each feature that needs to be implemented,
    we can begin writing the code logic. At this point, if you are working on a team,
    then this would be a good time to divide the work. The architecture phase may
    be done by one person, or as a team, but it can't be done in parallel. In contrast,
    the implementation phase can be broken into parts to work on separately.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing input and storing as building description and floor requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To parse input, we first need to decide whether to expect input from `stdin`
    or from a file. We will adopt the convention that if a filename is provided to
    the program, then we will read from the file; if the file name is `-` then read
    from `stdin`, and otherwise read from `test1.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Rust `std::env` package and a pattern `match` statement, we can accomplish
    this quite easily. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to parse the string''s input. For each line in the input, we store
    the parsed value as either a floor count, floor height, or floor request, in that
    order. Here is the code to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Updating location, velocity, and acceleration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we need to update the program's state to reflect physical changes in the
    state variables since the previous loop iteration. All of these changes depend
    on knowledge of how much time has elapsed since the previous iteration, but we
    don't have that information store. So, let's make some small changes to our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Store a timestamp of the previous iteration outside of the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculate the elapsed time, then overwrite the previous timestamp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To improve accuracy, sleep for a while at the end of the loop (it is difficult
    to accurately record sub-millisecond measurements):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can start to calculate the new location, velocity, and acceleration.
    The location is calculated as previous location plus velocity over time. Velocity
    is calculated as previous velocity plus acceleration over time. Acceleration is
    calculated as *F=ma* and will be calculated from the motor force and carriage
    weight. At this point, we realize that carriage weight is not specified in the
    input file, but after some discussion, the team decides to use a standard carriage
    weight rather than change the input format.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a little research, you find that an elevator carriage weighs about 1,200
    kg. Similarly, you estimate that a simple DC motor can produce roughly eight newtons
    of force per volt. The resulting code looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the next floor request in the queue is satisfied, then remove it from the
    queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete a floor request, we must be at the destination floor and stopped.
    We assume that a sufficiently low velocity can be stopped with some sort of brake.
    This will hold us in place steadily until passengers depart or enter the elevator.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Adjusting motor control to process the next floor request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To adjust motor control, we need to decide how much acceleration we want, and
    then calculate how much force is required to achieve the target acceleration.
    According to our objectives, we want shorter travel time, less motion sickness,
    and accurate stop locations.
  prefs: []
  type: TYPE_NORMAL
- en: The metrics that we should optimize to achieve these objectives are to maximize
    average velocity, minimize acceleration, and minimize stop location error. All
    of these objectives compete with one another for precedence, so we will need to
    compromise between each to achieve good overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: With some research, you find that comfortable acceleration is limited to between
    1 and 1.5 meters per second squared. You decide to aim for a maximum of  1 m/s²,
    with a slack of up to 1.5 m/s² in exceptional circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: For velocity, you decide that carriage speeds over 5 m/s are unsafe, so you
    will implement a maximum velocity, otherwise, the velocity should always be maximized
    to reach the next floor.
  prefs: []
  type: TYPE_NORMAL
- en: For location precision, the calculation of target acceleration versus current
    velocity versus target destination is essential. Here, you will try to keep the
    acceleration near 1 m/s², with significant room for additional acceleration. When
    sufficiently close to the destination, it may be necessary to use a different
    acceleration target to make smaller motions and velocity adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this with code, we first calculate the deceleration range. This
    is defined as the distance from which, at the current velocity, we would need
    to decelerate at greater than 1 m/s² to stop at the destination. Our acceleration
    buffer provides some room for correction, making this a safe target from which
    to start decelerating before reaching the next floor. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the target acceleration, we have three cases to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: If we are in the deceleration range, then we should slow down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are not in the deceleration range and not at maximum velocity, then we
    should accelerate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we are outside of the deceleration range but already at maximum velocity,
    then we should not change velocity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, using the target acceleration, we can calculate how much voltage we
    should apply to each motor to achieve the desired acceleration. By inverting the
    formula previously used to calculate acceleration, we can now calculate our desired
    voltage from the target acceleration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Printing real-time statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To print real-time statistics, we will use a console formatting library. This
    allows us to easily move the cursor around the screen and write clear and easily
    formattable text. This is depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we should grab some information and a handle to `stdout` and
    store it outside of our loop. This is shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the loop, let''s start by clearing a space to render our output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can render the elevator shaft and carriage. The elevator shaft will
    be simple brackets, one for each floor on the left and right. The elevator carriage
    will be an `X` mark placed on the floor closest to the current carriage location.
    We calculate each floor location by multiplying `floor_height` by floor offset
    from the ground floor. Then, we compare each floor location to the carriage locations
    to find the closest one. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to print real-time statistics. In addition to location, velocity,
    and acceleration, let''s also display the nearest floor and motor input voltage,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we find that the Terminal screen is tearing, so let''s adjust the output
    to use a buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, our screen will clearly display real-time information until the loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: Printing summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To print our summary, we should include averages and standard deviations for
    location, velocity, and acceleration. Additionally, it may be interesting to see
    statistics for motor control, so let's also display voltage statistics. At this
    point, we realize that the data is not storing enough information to calculate
    average or standard deviation numbers.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the average value for a variable, we will need to calculate a sum
    of each recorded value and record a count of how many data points we recorded.
    Then, we will calculate the average value by dividing the total value by the record
    count, giving us our estimation of the average value over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the standard deviation, we will require a full record of each
    observed value of the variable. Additionally, the average value and record count
    are required. Then, we will use the following formula to calculate standard deviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c852df4-1086-4609-bfd9-3bec0b76abb5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To store our data, we need to declare new variables before our loop starts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To store data using new variables, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, at each iteration, before calculating the new values, we will store each
    data point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we calculate the statistics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Before exiting the program, we must print the statistics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, having assembled the pieces, we have a complete simulation. Running the
    program on a test input produces a nice graphic and result summary. This should
    be sufficient to accompany the initial proposal.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down long segments into components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the project is functional, we can begin to look for opportunities to simplify
    the design and eliminate redundancies. The first step here should be to look for
    patterns of similar code. Our summary statistics are a very good example of code
    that should be cleaned up. We have four variables that we track and display statistics
    for. The calculation of each statistic is identical, yet we repeat the calculation
    explicitly for each variable. There are also similarities in the output formatting,
    so let's also clean that up.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix redundancy, the first question to ask is whether the code can be rewritten
    as a function. Here, we do have the opportunity to use this pattern by creating
    a function that accepts the variable data and prints the summary. This is done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write this function, which is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the function, we provide each `name` and `data` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This rewrite improves the program in two significant ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The statistics calculation is much easier to read and debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the statistics and summary function involves very little redundancy, which
    reduces the likelihood of accidentally using incorrect variable names or other
    common errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short, literate code is robust and prevents mistakes. Long, redundant code is
    brittle and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After writing a code draft, it is a good practice to read through the code again
    and look for possible improvements.  When reviewing a project, look specifically
    for ugly code, anti-patterns, and unchecked assumptions. After review, we find
    the code does not need correcting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should, however, point out one functional abstraction that was used that
    reduced line count significantly, which is the use of iterators. In calculating
    our variable summaries, we always used iterators to calculate sums and statistics.
    Some of the operators have not been introduced, so let''s look closer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, there are two important iterator methods being used—`map` and `fold`.
    `map` accept a mapping function and return an iterator of the modified values.
    The `fold` method holds an accumulator value (argument 1), and, for each element
    in the iterator, applies the accumulator function (argument 2), returning the
    accumulated value as a result. The `fold` function consumes the iterator when
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'An iterator is defined by a trait with a `next` method, which may return the
    next item in the sequence. A simple infinite list could be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These objects define an iterator. The `map` function and other stream modifiers
    simply wrap the input stream inside of another iterator that applies the modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the statistics calculation could have been defined with `for`
    loops. The result would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By comparison, we can see that the functional code is a little bit shorter.
    More importantly, the functional code is declarative. When code only describes
    requirements, we call that code **declarative**. When code describes machine instructions
    to satisfy requirements, we call that code **imperative**. The primary benefits
    of declarative style over imperative style are that declarative style is self-documenting
    and prevents mistakes by making them more obvious.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, when searching for abstractions, we encourage looking at
    `for` loops. In most cases, `for` loops can be messy or otherwise undesirable.
    Iterators and combinators may be a good solution to help improve code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run tests from the command line, type `cargo test`. We will be doing this
    a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing focuses on testing internal interfaces and components of a program.
    It is also called **whitebox testing**. To first create unit tests, it is a good
    idea to look at all of the top-level types, traits, and functions. All top-level
    identifiers make for good test cases. Depending on the structure of the program,
    it may also be a good idea to test combinations of these components to cover expected
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one utility function, the statistic calculation, which would be a good
    candidate to write a unit test for. However, this function doesn''t return any
    result. Instead, it immediately prints output to the console. To test this, we
    should break the function into two components—one that calculates the statistics,
    and a second function that prints the statistics. This would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have isolated the statistics calculation into its own function,
    we can write unit tests for it much more easily. First, we supply some test data,
    and then verify each result. Also note that unit tests have access to private
    functions as long as we add `use super::*;` to the test declaration. Here are
    some unit tests for our statistics calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we run `cargo test`, the unit tests will run. The result should show
    one test passing.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration testing focuses on testing external interfaces of a program. It
    is also called **blackbox testing**. To create integration tests, focus on what
    the input and output of a program or module should be. Think of the different
    configurations of options, data, and possible internal interactions to create
    tests. These tests should then provide good coverage of high-level behavior of
    the completed program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an integration test, we first need to reconfigure our project as
    a module that can be imported. Integration tests do not have access to symbols
    other than what they can reference from `use` statements. To accomplish this,
    we can move the program logic into a `src/lib.rs` file and use a simple wrapper
    for `src/main.rs` . After this change, the `lib.rs` file should contain all of
    the code from `main.rs`, with the one change of renaming the `main` function to
    `run_simulation` and making the function public. The `main.rs` wrapper should
    then look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to create an integration test:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a  `tests/` directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `integration_tests.rs` file inside the `tests/` directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `integration_tests.rs` file, create functions for each test case
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create a single test case here to accept a specific elevator request
    and check that the requests are processed in a reasonable amount of time. The
    test harness is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As input, we will use a `5` story building, `5.67` meters for each floor, and
    `7` floor requests. The file will be stored as `test1.txt` and should have the
    following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With these tests in place, we can now confirm that the basic logic is working
    and that the program as a whole function properly. To run all tests, call `cargo
    test`, or use a specific test case with `cargo test casename`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample test run is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the simulation completes, the summary and test results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we outlined the steps taken to gather project requirements,
    architect a solution, and then implement the completed deliverable. We focused
    on how this process can be clarified using functional thinking.
  prefs: []
  type: TYPE_NORMAL
- en: When gathering program requirements, the required data, input, and output should
    be clarified. When translating requirements into a code plan, creating a dependency
    graph as an intermediary step can help simplify complex designs. When testing,
    functions become great units to cover. By comparison, lines and lines of imperative
    code are almost impossible to test.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to develop this software project throughout the book. This
    first simulation deliverable will accompany the project proposal and will hopefully
    help our firm be selected for the contract. In the next chapter, you will receive
    feedback from the developers and meet your competitor.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the ternary operator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is another name for unit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is another name for integration tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is declarative programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is imperative programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is defined in the iterator trait?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which direction will fold traverse the iterator sequence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a dependency graph?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two constructors of `Option`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
