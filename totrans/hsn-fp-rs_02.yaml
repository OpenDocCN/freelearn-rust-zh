- en: Functional Control Flow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式控制流
- en: The control flow is the most basic building block of programming. Early languages
    had no concept of data structures or functions, only program flow. These control
    flow structures have evolved over time, from simple branches and loops to the
    complex value expressions available in Rust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流是编程的最基本构建块。早期的语言没有数据结构或函数的概念，只有程序流程。这些控制流结构随着时间的推移而演变，从简单的分支和循环到Rust中可用的复杂值表达式。
- en: In this chapter, we will start developing the project that will form the basis
    of all code examples in this book. The first project's requirements are introduced
    immediately. Then, we will provide you with actionable steps to transform project
    requirements into a code outline with tests. Lastly, we will develop code for
    the full deliverable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始开发构成本书所有代码示例基础的项目。第一个项目的需求将立即介绍。然后，我们将为您提供将项目需求转化为带有测试的代码概要的具体步骤。最后，我们将开发完整的可交付成果的代码。
- en: 'Learning outcomes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 学习成果：
- en: Gathering project requirements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集项目需求
- en: Architecting a solution based on project requirements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据项目需求构建解决方案
- en: Using and recognizing expressions in functional style
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和识别函数式风格的表达式
- en: Testing the solution with integration and unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集成和单元测试测试解决方案
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A recent version of Rust is necessary to run the examples provided:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 运行提供的示例需要Rust的最近版本：
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
- en: 'This chapter''s code is also available on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码也可在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每章的`README.md`文件中也包含了具体的安装和构建说明。
- en: Designing the program
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计程序
- en: To design the program, let's look at the various aspects required for the project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计程序，让我们看看项目所需的各种方面。
- en: Gathering project requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集项目需求
- en: 'Consider this situation: Your engineering firm is being considered for a contract
    to design software to control the elevators for a real estate developer. The contract
    lists three buildings under development with various heights and non-uniform elevator
    designs. The elevator designs are being finalized by other subcontractors and
    will become available shortly after the software contract is awarded.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况：您的工程公司正在考虑签订一份合同，为房地产开发商设计控制电梯的软件。合同列出了三个正在开发中的建筑，它们具有不同的高度和非均匀的电梯设计。电梯设计将由其他分包商最终确定，并在软件合同中标后不久可用。
- en: To submit your proposal, your firm should demonstrate the basic capabilities
    of your elevator control software. Then, once awarded, you will be expected to
    integrate these capabilities into the final software, along with modifications
    that are necessary to accommodate the physical elevator specifications and behaviors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提交您的提案，您的公司应展示您电梯控制软件的基本功能。一旦中标，您将需要将这些功能整合到最终软件中，以及必要的修改以适应物理电梯的规格和行为。
- en: 'To win the proposal, your team agrees on several key points on which to outperform
    competitors. Namely, your elevators should do the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了赢得提案，您的团队就几个关键点达成一致，以超越竞争对手。具体来说，您的电梯应做到以下几点：
- en: Take less time moving between floors
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在楼层之间移动的时间更短
- en: Stop at each floor location more precisely
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个楼层位置停留得更精确
- en: Provide a smoother ride for passengers in transit
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为乘客提供更平稳的乘坐体验
- en: As a program deliverable to accompany the project proposal, you are expected
    to provide a simulation of elevator behavior. You are responsible for further
    details and implementation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为项目提案的配套程序交付成果，您应提供电梯行为的模拟。您负责进一步的细节和实现。
- en: 'The following questions should be resolved now:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该解决以下问题：
- en: What data will the program access and store?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序将访问和存储哪些数据？
- en: What input will the program expect?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序将期望什么输入？
- en: What output should the program produce?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序应该产生什么输出？
- en: 'After some deliberation, your team agrees on some behaviors:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番考虑，您的团队就一些行为达成一致：
- en: The program should emphasize the elevator's location, velocity, and acceleration.
    Velocity determines ride duration. Acceleration determines ride comfort. The location,
    at rest, determines stop precision. These are the key selling points that your
    company will emphasize, so the demonstration software should mirror the same message.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序应强调电梯的位置、速度和加速度。速度决定乘坐时间。加速度决定乘坐舒适度。静止时的位置决定停靠精度。这些都是您公司需要强调的关键卖点，因此演示软件应反映相同的信息。
- en: As input, the program should take a file describing the number of floors and
    floor height, and finally a list of floor requests for the elevator to process.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序应以文件作为输入，描述楼层数和楼层高度，以及电梯需要处理的楼层请求列表。
- en: The output of the program should be real-time information regarding the elevator's
    location, velocity, and acceleration. After processing all floor requests, the
    program should print average and standard deviations for location, velocity, and
    acceleration.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序输出应该是关于电梯位置、速度和加速度的实时信息。在处理完所有楼层请求后，程序应打印位置、速度和加速度的平均值和标准差。
- en: Architecting a code map from requirements
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从需求构建代码图
- en: To outline our code solution, we will use the `stubs` method. To use this process,
    we simply start a code project normally and fill out high-level details as we
    think of them. Details will be left unimplemented until we finalize the outline.
    After we are satisfied with the overall program design, then we can start implementing
    program logic. We will begin the project now.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了概述我们的代码解决方案，我们将使用 `stubs` 方法。为了使用此过程，我们只需正常启动一个代码项目，并在想到时填写高级细节。细节将在最终确定大纲之前保持未实现状态。在我们对整体程序设计满意后，我们就可以开始实现程序逻辑了。我们现在开始这个项目。
- en: Creating a Rust project
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Rust 项目
- en: 'To create a new Rust project, we will perform the following steps (alternatively,
    you can invoke `cargo new`):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 Rust 项目，我们将执行以下步骤（或者，您也可以调用 `cargo new`）：
- en: Create a new folder for the Rust project
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Rust 项目创建一个新文件夹
- en: 'Create a `Cargo.toml` file, which is shown as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Cargo.toml` 文件，其内容如下：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `src/main.rs` file, as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `src/main.rs` 文件，如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we can build the project with `cargo build`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `cargo build` 构建项目。
- en: Writing stubs for each program requirement
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为每个程序需求编写存根
- en: 'Program requirements are typically phrased as outcomes. What effects should
    this program have when you run it? Answering this question with code is often
    straightforward. Here is a list of steps to methodically transform project requirements
    into code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 程序要求通常表述为结果。运行此程序时应该产生哪些效果？用代码回答这个问题通常很简单。以下是将项目需求系统地转化为代码的步骤列表：
- en: List all program requirements
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有程序需求
- en: List dependencies or prerequisites for each requirement
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出每个需求的相关依赖或先决条件
- en: Create a dependency graph from the requirements and dependencies lists
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从需求列表和依赖列表创建依赖图
- en: Write stubs that implement the dependency graph
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写实现依赖图的存根
- en: 'With practice, these steps can be combined into a single step of writing the
    stub code. However, if you become overwhelmed during the architecture phase of
    a project, then it may be helpful to go through these steps explicitly. This is
    a reliable method to break down complex problems into smaller problems:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实践，这些步骤可以合并为编写存根代码的单一步骤。然而，如果在项目的架构阶段感到不知所措，那么明确执行这些步骤可能有所帮助。这是一个将复杂问题分解为更小问题的可靠方法：
- en: Firstly, to list all program requirements, from earlier consideration, we know
    that we need to store real-time data for location, velocity, and acceleration.
    The program should accept an input file or standard input describing the number
    of floors, floor height, and a list of floor requests to be processed. The output
    of the program should be real-time elevator location, velocity, and acceleration,
    with a summary, upon completion, of all transport requests. The summary should
    list average and standard deviation for location, velocity, and acceleration.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，列出所有程序需求，从之前的考虑中我们知道我们需要存储位置、速度和加速度的实时数据。程序应接受一个描述楼层数、楼层高度和要处理的楼层请求列表的输入文件或标准输入。程序输出应该是实时电梯的位置、速度和加速度，并在完成时总结所有运输请求。总结应列出位置、速度和加速度的平均值和标准差。
- en: 'Secondly, list dependencies or prerequisites for each requirement. The data
    seems to be atomic with no dependencies or prerequisites. The program flow seems
    to naturally take the form of a polling loop, updating real-time state information
    from sensors and issuing motion commands once per loop. There is a time-lagged
    circular dependency between elevator state and motion commands: motion commands
    are chosen based on state, and the next loop will realize the time-adjusted effect
    of those commands.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，为每个需求列出依赖项或先决条件。数据似乎具有原子性，没有依赖项或先决条件。程序流程似乎自然地采用轮询循环的形式，从传感器更新实时状态信息，并在每次循环中发出运动命令。电梯状态和运动命令之间存在时间延迟的循环依赖：运动命令基于状态选择，下一个循环将实现这些命令的时间调整效果。
- en: 'Thirdly, create a dependency graph from the requirements and dependencies lists
    with the following:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三，使用以下内容从需求列表和依赖列表创建依赖图：
- en: Store the location, velocity, and acceleration state
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储位置、速度和加速度状态
- en: Store the motor input voltage
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储电机输入电压
- en: Store the input building description and floor requests
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储输入建筑描述和楼层请求
- en: Parse the input and store as building description and floor requests
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析输入并将其存储为建筑描述和楼层请求
- en: 'Loop while there are remaining floor requests:'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当有剩余的楼层请求时循环：
- en: Update the location, velocity, and acceleration
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新位置、速度和加速度
- en: If the next floor request in the queue is satisfied, then remove it from the
    queue
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果队列中的下一个楼层请求得到满足，则从队列中移除它
- en: Adjust motor control to process the next floor request
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整电机控制以处理下一个楼层请求
- en: Print real-time statistics
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印实时统计信息
- en: Print the summary
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印摘要
- en: 'Fourthly, write stubs that implement the dependency graph. We will update `src/main.rs`
    to implement this stub logic. Note that the variables, declared by `let` bindings,
    are stored inside the `main` function. The mutable state must be stored inside
    a function or a data structure. This is shown in the following code block:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四，编写实现依赖图的占位符。我们将更新`src/main.rs`以实现此占位符逻辑。注意，由`let`绑定声明的变量存储在`main`函数内部。可变状态必须存储在函数或数据结构内部。这在下述代码块中显示：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, we could have written the loop as a separate function. The function
    would check the condition, and the function would potentially call itself again.
    When a function calls itself, this is called **recursion**. Recursion is an extremely
    common and important pattern in functional programming. However, this specific
    type of recursion, known as **tail recursion**, is not recommended in Rust currently
    (see RFC #271 ([https://github.com/rust-lang/rfcs/issues/271](https://github.com/rust-lang/rfcs/issues/271))—without
    this proposed optimization, the tail recursion may unnecessarily use extra stack
    space and run out of memory).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '或者，我们也可以将循环作为单独的函数编写。该函数将检查条件，并且该函数可能会再次调用自己。当一个函数调用自己时，这被称为**递归**。递归是函数式编程中极其常见且重要的模式。然而，这种特定的递归类型，称为**尾递归**，目前在Rust中不建议使用（参见RFC
    #271 ([https://github.com/rust-lang/rfcs/issues/271](https://github.com/rust-lang/rfcs/issues/271))——没有这个提议的优化，尾递归可能会不必要地使用额外的堆栈空间并耗尽内存）。'
- en: 'The recursive loop code would become as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 递归循环代码将如下所示：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Implementing program logic
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现程序逻辑
- en: Once a stub program has been created, we can proceed to replace stubs with working
    code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了占位程序，我们就可以继续用工作代码替换占位符。
- en: Filling in the blanks
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填写空白
- en: Now that we have code stubs and a map of each feature that needs to be implemented,
    we can begin writing the code logic. At this point, if you are working on a team,
    then this would be a good time to divide the work. The architecture phase may
    be done by one person, or as a team, but it can't be done in parallel. In contrast,
    the implementation phase can be broken into parts to work on separately.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了代码占位符和每个需要实现的功能的映射，我们可以开始编写代码逻辑。在此阶段，如果你在一个团队中工作，那么这是一个划分工作的好时机。架构阶段可能由一个人完成，或者作为一个团队，但不能并行进行。相比之下，实现阶段可以分解成单独工作的部分。
- en: Parsing input and storing as building description and floor requests
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析输入并将其存储为建筑描述和楼层请求
- en: To parse input, we first need to decide whether to expect input from `stdin`
    or from a file. We will adopt the convention that if a filename is provided to
    the program, then we will read from the file; if the file name is `-` then read
    from `stdin`, and otherwise read from `test1.txt`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析输入，我们首先需要决定是期望从`stdin`还是从文件接收输入。我们将采用以下约定：如果程序提供了文件名，则从该文件读取；如果文件名是`-`，则从`stdin`读取，否则从`test1.txt`读取。
- en: 'Using the Rust `std::env` package and a pattern `match` statement, we can accomplish
    this quite easily. This is shown as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rust 的 `std::env` 包和模式 `match` 语句，我们可以相当容易地完成这项任务。如下所示：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we need to parse the string''s input. For each line in the input, we store
    the parsed value as either a floor count, floor height, or floor request, in that
    order. Here is the code to implement this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要解析字符串的输入。对于输入中的每一行，我们将解析的值存储为楼层数、楼层高度或楼层请求，按此顺序。以下是实现此功能的代码：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Updating location, velocity, and acceleration
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新位置、速度和加速度
- en: Here, we need to update the program's state to reflect physical changes in the
    state variables since the previous loop iteration. All of these changes depend
    on knowledge of how much time has elapsed since the previous iteration, but we
    don't have that information store. So, let's make some small changes to our code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要更新程序的状态，以反映自上次循环迭代以来状态变量的物理变化。所有这些变化都取决于对自上次迭代以来经过的时间的了解，但我们没有存储这些信息。所以，让我们对我们的代码做一些小的修改。
- en: 'Store a timestamp of the previous iteration outside of the loop:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环外部存储上一次迭代的时间戳：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Calculate the elapsed time, then overwrite the previous timestamp:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算经过的时间，然后覆盖上一次的时间戳：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To improve accuracy, sleep for a while at the end of the loop (it is difficult
    to accurately record sub-millisecond measurements):'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提高精度，在循环结束时暂停一段时间（记录亚毫秒级的测量值很困难）：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we can start to calculate the new location, velocity, and acceleration.
    The location is calculated as previous location plus velocity over time. Velocity
    is calculated as previous velocity plus acceleration over time. Acceleration is
    calculated as *F=ma* and will be calculated from the motor force and carriage
    weight. At this point, we realize that carriage weight is not specified in the
    input file, but after some discussion, the team decides to use a standard carriage
    weight rather than change the input format.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始计算新的位置、速度和加速度。位置是计算为前一个位置加上速度乘以时间。速度是计算为前一个速度加上加速度乘以时间。加速度是按照 *F=ma*
    计算的，并将从电机力和载重计算得出。此时，我们意识到载重没有在输入文件中指定，但在经过一些讨论后，团队决定使用标准的载重而不是更改输入格式。
- en: 'With a little research, you find that an elevator carriage weighs about 1,200
    kg. Similarly, you estimate that a simple DC motor can produce roughly eight newtons
    of force per volt. The resulting code looks like the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些研究，你发现电梯载重大约为1,200公斤。同样，你估计一个简单的直流电机可以产生大约每伏特8牛顿的力。生成的代码如下所示：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the next floor request in the queue is satisfied, then remove it from the
    queue
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果队列中的下一个楼层请求得到满足，那么就将其从队列中移除
- en: 'To complete a floor request, we must be at the destination floor and stopped.
    We assume that a sufficiently low velocity can be stopped with some sort of brake.
    This will hold us in place steadily until passengers depart or enter the elevator.
    The code is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成楼层请求，我们必须到达目的地楼层并停止。我们假设足够低的速度可以用某种形式的制动器停止。这将使我们稳定地保持在原地，直到乘客离开或进入电梯。代码如下：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adjusting motor control to process the next floor request
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整电机控制以处理下一个楼层请求
- en: To adjust motor control, we need to decide how much acceleration we want, and
    then calculate how much force is required to achieve the target acceleration.
    According to our objectives, we want shorter travel time, less motion sickness,
    and accurate stop locations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整电机控制，我们需要决定我们想要多少加速度，然后计算需要多少力来实现目标加速度。根据我们的目标，我们希望旅行时间更短，运动病更少，以及停止位置更准确。
- en: The metrics that we should optimize to achieve these objectives are to maximize
    average velocity, minimize acceleration, and minimize stop location error. All
    of these objectives compete with one another for precedence, so we will need to
    compromise between each to achieve good overall performance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，我们应该优化的指标是最大化平均速度，最小化加速度，以及最小化停止位置误差。所有这些目标相互竞争优先级，因此我们需要在它们之间做出妥协，以实现良好的整体性能。
- en: With some research, you find that comfortable acceleration is limited to between
    1 and 1.5 meters per second squared. You decide to aim for a maximum of  1 m/s²,
    with a slack of up to 1.5 m/s² in exceptional circumstances.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些研究，你发现舒适的加速度限制在每秒1到1.5米之间。你决定将目标定为最大1 m/s²，在特殊情况下可以放宽到1.5 m/s²。
- en: For velocity, you decide that carriage speeds over 5 m/s are unsafe, so you
    will implement a maximum velocity, otherwise, the velocity should always be maximized
    to reach the next floor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于速度，你决定超过5 m/s的载货速度是不安全的，所以你会实现一个最大速度，否则，速度应该总是最大化以达到下一个楼层。
- en: For location precision, the calculation of target acceleration versus current
    velocity versus target destination is essential. Here, you will try to keep the
    acceleration near 1 m/s², with significant room for additional acceleration. When
    sufficiently close to the destination, it may be necessary to use a different
    acceleration target to make smaller motions and velocity adjustments.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于位置精度，目标加速度与当前速度与目标目的地的计算是至关重要的。在这里，你将尝试将加速度保持在1 m/s²附近，同时留有足够的空间进行额外的加速度。当足够接近目的地时，可能需要使用不同的加速度目标来进行更小的动作和速度调整。
- en: 'To implement this with code, we first calculate the deceleration range. This
    is defined as the distance from which, at the current velocity, we would need
    to decelerate at greater than 1 m/s² to stop at the destination. Our acceleration
    buffer provides some room for correction, making this a safe target from which
    to start decelerating before reaching the next floor. This is shown in the following
    code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要用代码实现这一点，我们首先计算减速范围。这定义为从该距离开始，在当前速度下，我们需要以大于1 m/s²的加速度减速，以便在目的地停下。我们的加速度缓冲区提供了一些修正空间，这使得从下一个楼层开始减速之前，这是一个安全的目标。这在上面的代码中显示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To calculate the target acceleration, we have three cases to consider:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算目标加速度，我们需要考虑三种情况：
- en: If we are in the deceleration range, then we should slow down
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在减速范围内，那么我们应该减速
- en: If we are not in the deceleration range and not at maximum velocity, then we
    should accelerate
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不在减速范围内且不在最大速度，那么我们应该加速
- en: 'If we are outside of the deceleration range but already at maximum velocity,
    then we should not change velocity:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不在减速范围内但已经达到最大速度，那么我们不应该改变速度：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, using the target acceleration, we can calculate how much voltage we
    should apply to each motor to achieve the desired acceleration. By inverting the
    formula previously used to calculate acceleration, we can now calculate our desired
    voltage from the target acceleration, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用目标加速度，我们可以计算出应该施加到每个电机上的电压，以实现所需的加速度。通过倒推之前用于计算加速度的公式，我们现在可以从目标加速度计算出所需的电压，如下所示：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Printing real-time statistics
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印实时统计数据
- en: 'To print real-time statistics, we will use a console formatting library. This
    allows us to easily move the cursor around the screen and write clear and easily
    formattable text. This is depicted as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印实时统计数据，我们将使用一个控制台格式化库。这允许我们轻松地在屏幕上移动光标并写入清晰且易于格式化的文本。这在上面的代码中显示：
- en: 'To get started, we should grab some information and a handle to `stdout` and
    store it outside of our loop. This is shown in the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，我们应该获取一些信息和`stdout`的句柄，并将其存储在循环之外。这在上面的代码中显示：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the loop, let''s start by clearing a space to render our output:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内部，让我们首先清除一个空间来渲染我们的输出：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we can render the elevator shaft and carriage. The elevator shaft will
    be simple brackets, one for each floor on the left and right. The elevator carriage
    will be an `X` mark placed on the floor closest to the current carriage location.
    We calculate each floor location by multiplying `floor_height` by floor offset
    from the ground floor. Then, we compare each floor location to the carriage locations
    to find the closest one. The code is as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以渲染电梯井和载货平台。电梯井将是简单的括号，每个楼层左面和右面各一个。电梯载货平台将是一个`X`标记，放置在离当前载货平台位置最近的楼层上。我们通过将`floor_height`乘以楼层相对于地面的偏移量来计算每个楼层的位置。然后，我们将每个楼层的位置与载货平台的位置进行比较，以找到最近的一个。代码如下：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we need to print real-time statistics. In addition to location, velocity,
    and acceleration, let''s also display the nearest floor and motor input voltage,
    as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要打印实时统计数据。除了位置、速度和加速度之外，让我们还显示最近的楼层和电机输入电压，如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we find that the Terminal screen is tearing, so let''s adjust the output
    to use a buffer:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们发现终端屏幕正在撕裂，所以让我们调整输出以使用缓冲区：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, our screen will clearly display real-time information until the loop ends.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的屏幕将清楚地显示实时信息，直到循环结束。
- en: Printing summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印总结
- en: To print our summary, we should include averages and standard deviations for
    location, velocity, and acceleration. Additionally, it may be interesting to see
    statistics for motor control, so let's also display voltage statistics. At this
    point, we realize that the data is not storing enough information to calculate
    average or standard deviation numbers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印我们的摘要，我们应该包括位置、速度和加速度的平均值和标准差。此外，查看电机控制的统计数据可能也很有趣，所以让我们也显示电压统计数据。此时，我们意识到数据存储的信息不足以计算平均值或标准差。
- en: To calculate the average value for a variable, we will need to calculate a sum
    of each recorded value and record a count of how many data points we recorded.
    Then, we will calculate the average value by dividing the total value by the record
    count, giving us our estimation of the average value over time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算变量的平均值，我们需要计算每个记录值的总和，并记录我们记录了多少个数据点。然后，我们将总值除以记录数，从而得到我们对时间平均值的估计。
- en: 'To calculate the standard deviation, we will require a full record of each
    observed value of the variable. Additionally, the average value and record count
    are required. Then, we will use the following formula to calculate standard deviation:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算标准差，我们需要变量每个观测值的完整记录。此外，还需要平均值和记录数。然后，我们将使用以下公式来计算标准差：
- en: '![](img/3c852df4-1086-4609-bfd9-3bec0b76abb5.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c852df4-1086-4609-bfd9-3bec0b76abb5.png)'
- en: 'To store our data, we need to declare new variables before our loop starts:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环开始之前，我们需要声明新的变量来存储我们的数据：
- en: 'To store data using new variables, use the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用新变量存储数据，请使用以下代码：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, at each iteration, before calculating the new values, we will store each
    data point:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在每次迭代之前，在计算新值之前，我们将存储每个数据点：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we calculate the statistics:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们计算统计信息：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before exiting the program, we must print the statistics:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在退出程序之前，我们必须打印统计信息：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, having assembled the pieces, we have a complete simulation. Running the
    program on a test input produces a nice graphic and result summary. This should
    be sufficient to accompany the initial proposal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已经组装好了所有部件，我们有一个完整的模拟。在测试输入上运行程序会产生一个漂亮的图形和结果摘要。这应该足以作为初始提案的补充。
- en: Breaking down long segments into components
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将长段分解成组件
- en: Once the project is functional, we can begin to look for opportunities to simplify
    the design and eliminate redundancies. The first step here should be to look for
    patterns of similar code. Our summary statistics are a very good example of code
    that should be cleaned up. We have four variables that we track and display statistics
    for. The calculation of each statistic is identical, yet we repeat the calculation
    explicitly for each variable. There are also similarities in the output formatting,
    so let's also clean that up.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目功能正常，我们就可以开始寻找简化设计和消除冗余的机会。这里的第一个步骤应该是寻找类似代码的模式。我们的摘要统计是一个很好的例子，应该进行清理。我们有四个变量，我们跟踪并显示它们的统计数据。每个统计的计算都是相同的，但我们为每个变量显式地重复计算。输出格式化也有相似之处，所以我们也应该清理这一点。
- en: 'To fix redundancy, the first question to ask is whether the code can be rewritten
    as a function. Here, we do have the opportunity to use this pattern by creating
    a function that accepts the variable data and prints the summary. This is done
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除冗余，首先要问的问题是代码是否可以重写为一个函数。在这里，我们确实有机会通过创建一个接受变量数据和打印摘要的函数来使用这个模式。这是按照以下方式完成的：
- en: 'We can write this function, which is shown as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以编写这个函数，如下所示：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To call the function, we provide each `name` and `data` variable:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调用函数，我们需要提供每个`name`和`data`变量：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This rewrite improves the program in two significant ways:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写改进了程序的两个重要方面：
- en: The statistics calculation is much easier to read and debug
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计计算更容易阅读和调试
- en: Using the statistics and summary function involves very little redundancy, which
    reduces the likelihood of accidentally using incorrect variable names or other
    common errors
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用统计和摘要函数涉及很少的冗余，这减少了意外使用错误的变量名或其他常见错误的可能性
- en: Short, literate code is robust and prevents mistakes. Long, redundant code is
    brittle and error-prone.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 短小、易读的代码是健壮的，可以防止错误。长而冗余的代码是脆弱的，容易出错。
- en: Searching for abstractions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找抽象
- en: After writing a code draft, it is a good practice to read through the code again
    and look for possible improvements.  When reviewing a project, look specifically
    for ugly code, anti-patterns, and unchecked assumptions. After review, we find
    the code does not need correcting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码草稿后，再次阅读代码并寻找可能的改进是一个好习惯。在审查项目时，特别关注丑陋的代码、反模式和未经检查的假设。审查后，我们发现代码不需要修正。
- en: 'We should, however, point out one functional abstraction that was used that
    reduced line count significantly, which is the use of iterators. In calculating
    our variable summaries, we always used iterators to calculate sums and statistics.
    Some of the operators have not been introduced, so let''s look closer:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该指出一个使用的函数式抽象，它显著减少了行数，那就是迭代器的使用。在计算我们的变量摘要时，我们总是使用迭代器来计算总和和统计。一些运算符尚未介绍，让我们更仔细地看看：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, there are two important iterator methods being used—`map` and `fold`.
    `map` accept a mapping function and return an iterator of the modified values.
    The `fold` method holds an accumulator value (argument 1), and, for each element
    in the iterator, applies the accumulator function (argument 2), returning the
    accumulated value as a result. The `fold` function consumes the iterator when
    called.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用了两个重要的迭代器方法——`map` 和 `fold`。`map` 接受一个映射函数并返回一个修改后的值的迭代器。`fold` 方法持有一个累加器值（参数1），并且对于迭代器中的每个元素，应用累加器函数（参数2），返回累加的值作为结果。调用
    `fold` 函数时，会消耗迭代器。
- en: 'An iterator is defined by a trait with a `next` method, which may return the
    next item in the sequence. A simple infinite list could be defined as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器由一个具有 `next` 方法的特质定义，它可能返回序列中的下一个项目。一个简单的无限列表可以这样定义：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These objects define an iterator. The `map` function and other stream modifiers
    simply wrap the input stream inside of another iterator that applies the modifier.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象定义了一个迭代器。`map` 函数和其他流修改器只是将输入流包装在另一个迭代器中，该迭代器应用修改器。
- en: 'Alternatively, the statistics calculation could have been defined with `for`
    loops. The result would look like the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，统计计算可以用 `for` 循环来定义。结果看起来如下：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By comparison, we can see that the functional code is a little bit shorter.
    More importantly, the functional code is declarative. When code only describes
    requirements, we call that code **declarative**. When code describes machine instructions
    to satisfy requirements, we call that code **imperative**. The primary benefits
    of declarative style over imperative style are that declarative style is self-documenting
    and prevents mistakes by making them more obvious.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们可以看到函数式代码稍微短一点。更重要的是，函数式代码是**声明性的**。当代码只描述需求时，我们称这种代码为**声明性的**。当代码描述满足需求的机器指令时，我们称这种代码为**命令式的**。声明式风格相对于命令式风格的主要好处是声明式风格是自文档化的，并且通过使错误更明显来防止错误。
- en: For these reasons, when searching for abstractions, we encourage looking at
    `for` loops. In most cases, `for` loops can be messy or otherwise undesirable.
    Iterators and combinators may be a good solution to help improve code quality.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，在寻找抽象时，我们鼓励查看 `for` 循环。在大多数情况下，`for` 循环可能是杂乱的或不受欢迎的。迭代器和组合器可能是帮助提高代码质量的良好解决方案。
- en: Writing tests
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: To run tests from the command line, type `cargo test`. We will be doing this
    a lot.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行运行测试，请输入 `cargo test`。我们将经常这样做。
- en: Unit testing
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing focuses on testing internal interfaces and components of a program.
    It is also called **whitebox testing**. To first create unit tests, it is a good
    idea to look at all of the top-level types, traits, and functions. All top-level
    identifiers make for good test cases. Depending on the structure of the program,
    it may also be a good idea to test combinations of these components to cover expected
    use cases.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试专注于测试程序的内联接口和组件。它也被称为**白盒测试**。首先创建单元测试时，查看所有顶级类型、特性和函数是一个好主意。所有顶级标识符都适合作为测试用例。根据程序的结构，测试这些组件的组合以覆盖预期用例也可能是一个好主意。
- en: 'We have one utility function, the statistic calculation, which would be a good
    candidate to write a unit test for. However, this function doesn''t return any
    result. Instead, it immediately prints output to the console. To test this, we
    should break the function into two components—one that calculates the statistics,
    and a second function that prints the statistics. This would look as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个实用函数，即统计计算，这是一个很好的单元测试候选。然而，这个函数不返回任何结果。相反，它立即将输出打印到控制台。为了测试这一点，我们应该将函数分解为两个组件——一个用于计算统计，另一个用于打印统计。这看起来如下：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have isolated the statistics calculation into its own function,
    we can write unit tests for it much more easily. First, we supply some test data,
    and then verify each result. Also note that unit tests have access to private
    functions as long as we add `use super::*;` to the test declaration. Here are
    some unit tests for our statistics calculation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将统计计算独立成一个函数，我们可以更容易地为其编写单元测试。首先，我们提供一些测试数据，然后验证每个结果。同时请注意，只要我们在测试声明中添加`use
    super::*;`，单元测试就可以访问私有函数。以下是我们统计计算的几个单元测试：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, if we run `cargo test`, the unit tests will run. The result should show
    one test passing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行`cargo test`，单元测试将会运行。结果应该显示一个测试通过。
- en: Integration testing
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing focuses on testing external interfaces of a program. It
    is also called **blackbox testing**. To create integration tests, focus on what
    the input and output of a program or module should be. Think of the different
    configurations of options, data, and possible internal interactions to create
    tests. These tests should then provide good coverage of high-level behavior of
    the completed program.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试侧重于测试程序的外部接口。它也被称为**黑盒测试**。要创建集成测试，关注程序或模块的输入和输出应该是什么。考虑不同的选项、数据和可能的内部交互配置来创建测试。然后，这些测试应该提供对完成程序高级行为的良好覆盖。
- en: 'To create an integration test, we first need to reconfigure our project as
    a module that can be imported. Integration tests do not have access to symbols
    other than what they can reference from `use` statements. To accomplish this,
    we can move the program logic into a `src/lib.rs` file and use a simple wrapper
    for `src/main.rs` . After this change, the `lib.rs` file should contain all of
    the code from `main.rs`, with the one change of renaming the `main` function to
    `run_simulation` and making the function public. The `main.rs` wrapper should
    then look as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建集成测试，我们首先需要将我们的项目重新配置为一个可以被导入的模块。集成测试无法访问除了它们可以从`use`语句中引用的符号之外的其他符号。为了实现这一点，我们可以将程序逻辑移动到`src/lib.rs`文件中，并为`src/main.rs`使用一个简单的包装器。在此更改之后，`lib.rs`文件应包含来自`main.rs`的所有代码，其中一项更改是将`main`函数重命名为`run_simulation`并使该函数公开。`main.rs`包装器应如下所示：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, in order to create an integration test:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建集成测试：
- en: Create a  `tests/` directory
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`tests/`目录
- en: Create an `integration_tests.rs` file inside the `tests/` directory
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests/`目录中创建一个`integration_tests.rs`文件
- en: Inside the `integration_tests.rs` file, create functions for each test case
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`integration_tests.rs`文件中，为每个测试用例创建函数
- en: 'We will create a single test case here to accept a specific elevator request
    and check that the requests are processed in a reasonable amount of time. The
    test harness is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个单独的测试用例，以接受特定的电梯请求并检查请求是否在合理的时间内得到处理。测试框架如下：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As input, we will use a `5` story building, `5.67` meters for each floor, and
    `7` floor requests. The file will be stored as `test1.txt` and should have the
    following structure:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入，我们将使用一个`5`层的建筑，每层`5.67`米，以及`7`个楼层请求。文件将存储为`test1.txt`，并应具有以下结构：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With these tests in place, we can now confirm that the basic logic is working
    and that the program as a whole function properly. To run all tests, call `cargo
    test`, or use a specific test case with `cargo test casename`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些测试到位后，我们现在可以确认基本逻辑是正常工作的，并且整个程序作为整体可以正常工作。要运行所有测试，请调用`cargo test`，或使用特定的测试用例`cargo
    test casename`。
- en: 'A sample test run is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例测试运行如下：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the simulation completes, the summary and test results are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模拟完成，总结和测试结果如下：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we outlined the steps taken to gather project requirements,
    architect a solution, and then implement the completed deliverable. We focused
    on how this process can be clarified using functional thinking.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了收集项目需求、设计解决方案以及实施完成交付物的步骤。我们关注了如何使用功能思维来明确这个过程。
- en: When gathering program requirements, the required data, input, and output should
    be clarified. When translating requirements into a code plan, creating a dependency
    graph as an intermediary step can help simplify complex designs. When testing,
    functions become great units to cover. By comparison, lines and lines of imperative
    code are almost impossible to test.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集程序需求时，所需的数据、输入和输出应该被明确。当将需求转换为代码计划时，创建一个依赖图作为中间步骤可以帮助简化复杂的设计。在测试时，函数成为很好的单元来覆盖。相比之下，一行又一行的命令式代码几乎不可能进行测试。
- en: We will continue to develop this software project throughout the book. This
    first simulation deliverable will accompany the project proposal and will hopefully
    help our firm be selected for the contract. In the next chapter, you will receive
    feedback from the developers and meet your competitor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中持续开发这个软件项目。这个第一个模拟交付成果将伴随项目提案，并希望有助于我们的公司获得合同。在下一章中，你将收到开发者的反馈，并遇到你的竞争对手。
- en: Questions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the ternary operator?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三元运算符是什么？
- en: What is another name for unit tests?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试的另一个名称是什么？
- en: What is another name for integration tests?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成测试的另一个名称是什么？
- en: What is declarative programming?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明式编程的另一个名称是什么？
- en: What is imperative programming?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令式编程是什么？
- en: What is defined in the iterator trait?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器特质中定义了什么？
- en: In which direction will fold traverse the iterator sequence?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fold 将会以哪个方向遍历迭代器序列？
- en: What is a dependency graph?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖图是什么？
- en: What are the two constructors of `Option`?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Option` 有哪两个构造函数？'
