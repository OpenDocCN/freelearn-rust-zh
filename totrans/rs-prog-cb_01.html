<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Starting Off with Rust</h1>
                </header>
            
            <article>
                
<p>The Rust ecosystem has grown considerably over the last year, and the 2018 edition, in particular, brought a significant push toward stabilization. The tooling is developing and important libraries are maturing to a point where many bigger companies use Rust in production.</p>
<p>One of the features of Rust is a steep learning curve—which is mostly due to a fundamental change in how to think about memory allocation. It is not uncommon for experienced programmers in other languages (such as C#) to feel overwhelmed with the way things are done in Rust. In this chapter, we will try to overcome this and lower the bar to get started!</p>
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Getting everything ready</li>
<li><span>Working with the command line I/O</span></li>
<li>Creating and using data types</li>
<li>Controlling execution flow</li>
<li>Splitting your code with crates and modules</li>
<li>Writing tests and benchmarks</li>
<li>Documenting your code</li>
<li>Testing your documentation</li>
<li>Sharing code among types</li>
<li>Sequence types in Rust</li>
<li>Debugging Rust</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up your environment</h1>
                </header>
            
            <article>
                
<p>Since the programming language comes with a variety of toolchains, tools, linkers, and compiler versions, choosing the best-fitting variation is not easy. Additionally, Rust works on all major operating systems—which adds another variable. </p>
<p><span>However, installing Rust has become a trivial task when using </span><kbd>rustup</kbd> (<a href="https://rustup.rs/">https://rustup.rs/</a>)<span>. On the website, a helpful script (or installer on Windows) that takes care of retrieving and installing the required components can be downloaded. The same tool lets you switch between and update (and uninstall) these components as well. This is the recommended way.</span></p>
<div class="packt_infobox">Choosing to use the <strong>Microsoft Visual Studio Compiler</strong> (<strong>MSVC</strong>) together with Rust requires that you install additional software such as the Visual C++ runtime and compiler tools. </div>
<p>To write code, an editor is also required. Since Visual Studio Code sports some Rust parts, it is a great choice together with the Rust extension. It's an open source editor developed by Microsoft and is well received across the world and the Rust community. In this recipe, we will install the following components:</p>
<ul>
<li>Visual Studio Code (<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>)</li>
<li><kbd>rustup</kbd> (<a href="https://rustup.rs">https://rustup.rs</a>)</li>
<li><kbd>rustc</kbd> (and the rest of the compiler toolchains)</li>
<li><kbd>cargo</kbd></li>
<li><strong>RLS</strong> (short for <strong>Rust Language Server</strong>—this is for autocompletion)</li>
<li>Rust language support for Visual Studio Code</li>
</ul>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>On a computer running either macOS, Linux, or Windows, only a web browser and internet connection are required. Bear in mind that the Windows installation works a little bit different from the <strong>*nix</strong> systems (Linux and macOS), which use scripts. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Each of the parts requires us to navigate to their respective websites, download the installer, and follow their instructions:</p>
<ol start="1">
<li>Open the browser and navigate to<span> </span><a href="https://rustup.rs">https://rustup.rs</a> and <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>.</li>
<li>Choose the installers fit for your operating system.</li>
<li>After downloading, run the installers and follow their instructions, choosing the <kbd>stable</kbd> branches.</li>
<li>Once successfully installed, we'll go deeper into each installation.</li>
</ol>
<p>Now, let's go behind the scenes to understand the installation better</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing the Rust installation with rustup.rs</h1>
                </header>
            
            <article>
                
<p>To test whether the installation of the Rust toolchain with <kbd>rustup</kbd> was successful, the <kbd>rustc</kbd> command is available to run in Terminal (or PowerShell on Windows):</p>
<pre><strong>$ rustc --version</strong><br/>rustc 1.33.0 (2aa4c46cf 2019-02-28)</pre>
<p>Note that you will have a later version when you are running this. It doesn't matter if you stick to the 2018 edition for your code.</p>
<div class="packt_infobox"><span>Rust requires a native linker to be available on your system. On Linux or Unix systems (such as macOS), Rust calls </span><kbd>cc</kbd><span> for linking, whereas on Windows, the linker of choice is Microsoft Visual Studio's linker, which depends on having Microsoft Visual C++ Build Tools installed. While it's possible to use an open source toolchain on Windows as well, this exercise is left for more advanced users.</span></div>
<p>Even with the 2018 edition, some useful features are still only available on <kbd>nightly</kbd>. To install the nightly edition of <kbd>rustc</kbd>, perform these steps:</p>
<ol>
<li>Run <kbd>rustup install nightly</kbd> (use <kbd>nightly-msvc</kbd> on Windows if you are not using the GNU toolchain) in a Terminal or PowerShell window.</li>
<li>After the command finishes, the default toolchain (used in <kbd>cargo</kbd>) can be switched using <kbd>rustup default nightly</kbd>.</li>
</ol>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Visual Studio Code and extensions</h1>
                </header>
            
            <article>
                
<p>In its vanilla version, Visual Studio Code comes with syntax highlighting for many languages. However, for autocompletion or/and checking syntax, an extension is required. The Rust project supplies this extension:</p>
<ol>
<li>Open Visual Studio Code.</li>
<li>Use <em>Ctrl</em> <span>+</span> <em>P</em> <span>(</span><em>cmd</em> <span>+</span> <em>P</em> <span>on macOS) to open the command-line interface, then type</span> <kbd>ext install rust-lang.rust</kbd> <span>to install the extension. The process should look like this:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/dc247be2-1a02-41f7-9177-8f0bbc864424.png" style="width:50.67em;height:21.75em;"/></p>
<p><span>The extension uses RLS to do static code analysis and provide completion and syntax checking. The extension <em>should</em> install the RLS component automatically, but sometimes it will fail to do this. One solution is to add the following configuration to Visual Studio Code's <kbd>settings.json</kbd> file (use</span> <em>Ctrl</em> <em>+</em> <em>P</em>/<em>cmd</em> <em>+</em> <em>P</em> <span>to find it):</span></p>
<pre>{<br/>    "rust-client.channel":"stable"<br/>}</pre>
<p><span>Alternatively, <kbd>rustup</kbd> will also install RLS with the <kbd>rustup component add rls</kbd> command.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Troubleshooting</h1>
                </header>
            
            <article>
                
<p>Occasionally, updating the tools will lead to errors that files are missing or cannot be overwritten. This can be for a wide range of reasons, but a full reset of the installations can help. On Linux or macOS systems, the following command takes care of deleting anything <kbd>rustup</kbd> installed:</p>
<pre><strong>$ rm -Rf ~/.rustup</strong></pre>
<p>Windows's PowerShell now supports many Linux-like commands:</p>
<pre><strong>PS&gt; rm ~/.rustup</strong></pre>
<p>This leads to the same result. After deleting the current installation, install <kbd>rustup</kbd> from scratch—this should install the latest version.</p>
<p><span>Now, let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The shell script, <kbd>rustup.sh</kbd>, is a great way to install Rust and it is the primary way to install Rust and other components today. In fact, it is common to use the script also in CI systems to install the compiler and other tools. </p>
<p><kbd>rustup</kbd> is an open source project maintained by the Rust project and can be found on GitHub: <a href="https://github.com/rust-lang/rustup.rs">https://github.com/rust-lang/rustup.rs</a>. </p>
<p>We've successfully learned how to set up our environment. Now let's move on to the next recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with the command line I/O</h1>
                </header>
            
            <article>
                
<p>The traditional way of communicating with the user on the command line is using standard streams. Rust includes helpful macros to deal with these simple cases. In this recipe, we will explore the basic workings of the classic <kbd>Hello World</kbd> program.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span><span>In just five steps, we will explore command line I/O and formatting</span></span>:</p>
<ol>
<li>Open a Terminal window (PowerShell on Windows) and run the <kbd>cargo new hello-world</kbd> <span>command, </span>which creates a new Rust project in a <kbd>hello-world</kbd> folder.</li>
<li>Once created, change into the directory with <kbd>cd hello-world</kbd> <span>and open</span> <kbd>src/main.rs</kbd> <span>with a Visual Studio Code. The default code generated by</span> <kbd>cargo</kbd> <span>looks like this:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">fn main() {<br/>    println!("Hello, world!");<br/>}</pre>
<ol start="3">
<li class="mce-root">Let's expand i<span>t! These are variations on the preceding traditional <kbd>print</kbd> statement, showing some formatting options, parameters, and writing on streams, among other things. Let's start with some common prints (and imports):</span></li>
</ol>
<pre style="color: black;padding-left: 60px">use std::io::{self, Write};<br/>use std::f64;<br/><br/>fn main() {<br/>    println!("Let's print some lines:");<br/>    println!();<br/>    println!("Hello, world!");<br/>    println!("{}, {}!", "Hello", "world");<br/>    print!("Hello, ");<br/>    println!("world!");</pre>
<p style="padding-left: 60px">However, we can do much more complex argument combinations:</p>
<pre style="color: black;padding-left: 60px">    println!("Arguments can be referred to by their position: {0}, <br/>    {1}! and {1}, {0}! are built from the same arguments", "Hello", <br/>    "world");<br/><br/>    println!("Furthermore the arguments can be named: \"{greeting}, <br/>    {object}!\"", greeting = "Hello", object = "World");<br/><br/>    println!("Number formatting: Pi is {0:.3} or {0:.0} for short", <br/>    f64::consts::PI);<br/><br/>    println!("... and there is more: {0:&gt;0width$}={0:&gt;width$}=<br/>    {0:#x}", 1535, width = 5);<br/><br/>    let _ = write!(&amp;mut io::stdout(), "Underneath, it's all writing <br/>    to a stream...");<br/>    println!();<br/><br/>    println!("Write something!");<br/>    let mut input = String::new();<br/>    if let Ok(n) = io::stdin().read_line(&amp;mut input) {<br/>        println!("You wrote: {} ({} bytes) ", input, n);<br/>    }<br/>    else {<br/>        eprintln!("There was an error :(");<br/>    }<br/>}</pre>
<p style="padding-left: 60px" class="mce-root"><span>This should provide several variations of reading and writing to the console.</span></p>
<ol start="4">
<li>Go back to Terminal and navigate to the directory where <kbd>Cargo.toml</kbd> is located.</li>
<li>Use <kbd>cargo run</kbd> to see the snippet's output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling hello-world v0.1.0 (/tmp/hello-world)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.37s<br/>     Running 'target/debug/hello-world'<br/>Let's print some lines:<br/><br/>Hello, world!<br/>Hello, world!<br/>Hello, world!<br/>Arguments can be referred to by their position: Hello, world! and world, Hello! are built from the same arguments<br/>Furthermore the arguments can be named: "Hello, World!"<br/>Number formatting: Pi is 3.142 or 3 for short<br/>... and there is more: 01535= 1535=0x5ff<br/>Underneath, it's all writing to a stream...<br/>Write something!<br/>Hello, world!<br/>You wrote: Hello, world!<br/> (14 bytes) </pre>
<p style="padding-left: 60px">Each line in the output represents a way to print text to the console! We recommend playing with the variations and seeing how it changes the result. On a side note, <kbd>rustc</kbd> will check for the correct number of arguments in any <kbd>println!()</kbd> or <kbd>format!()</kbd> call.</p>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's go through the code to understand the execution flow.</p>
<div class="packt_infobox"><kbd>cargo</kbd> is described in depth in <a href="cdcbf36d-9343-4b7b-ace1-b4c570dab62c.xhtml">Chapter 2</a>, <em>Managing Projects with Cargo</em>, in this book.</div>
<p>The initial snippet is generated when <kbd>cargo new hello-world</kbd> is executed in <em>step 1</em>. As a project of type binary, a <kbd>main</kbd> function is required and <kbd>rustc</kbd> will be looking for it. Upon calling <kbd>cargo run</kbd>, <kbd>cargo</kbd> orchestrates compilation (with <kbd>rustc</kbd>) and linking (<kbd>msvc</kbd> on Windows, <kbd>cc</kbd> on *nix) and runs the resultant binary via its entry point: the <kbd>main</kbd> function (<em>step 5</em>). </p>
<p>In the function we create in <em>step 3</em>, we write a series of <kbd>print!</kbd>/<kbd>println!</kbd>/<kbd>eprintln!</kbd> statements, which are Rust macros. These macros facilitate the writing to the standard output or standard error channels of a command-line application and include additional arguments. In fact, if arguments are missing, the compiler won't compile the program.</p>
<div class="packt_infobox"><span>Rust's macros work directly on the syntax tree of the language, providing type safety and the ability to check the parameters and arguments. Therefore, they can be seen as a function call with a few special abilities—but more on that in <a href="a8fae7de-6021-4d6e-9c75-e24288bc92e7.xhtml">Chapter 6</a>, <em>Expressing Yourself with Macros</em>.   </span></div>
<p>The various arguments and the template string are combined using formatters, a powerful way to add real variables to the output without the need of concatenations or similar workarounds. This will reduce the number of allocations, considerably improving performance and memory efficiency. There is a wide range of how to format data types; to understand it more deeply, check out Rust's excellent documentation (<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>). </p>
<p>The last step then shows the output that the various combinations produced.</p>
<p>We've successfully learned to work with the command line I/O. Now, let's move on to the next recipe.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating and using data types</h1>
                </header>
            
            <article>
                
<p>Rust features all of the basic types: signed and unsigned integers up to 64 bits in width; floating-point types up to 64 bits; character types; and Booleans. Of course, any program will need more complex data structures to remain readable.</p>
<div class="packt_tip">If you are unfamiliar with unit tests in Rust (or in general), we suggest going through the <em>Writing tests and benchmarks</em> <span>recipe </span>here in this chapter<em> </em>first.</div>
<p><span>In this recipe, we'll look at good basic practices to create and use data types.</span><span> </span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's use Rust's unit tests as a playground for some data type experiments:</p>
<ol>
<li><span>Create a new project using </span><kbd>cargo new data-types -- lib</kbd> and <span>use an editor to open the <kbd>projects</kbd> directory.</span></li>
<li>Open <kbd>src/lib.rs</kbd> in your favorite text editor (Visual Studio Code).</li>
<li>In there, you will find a small snippet to run a test:</li>
</ol>
<pre style="color: black;padding-left: 60px">#[cfg(test)]<br/>mod tests {<br/>    #[test]<br/>    fn it_works() {<br/>        assert_eq!(2 + 2, 4);<br/>    }<br/>}</pre>
<ol start="4">
<li>Let's replace the default test to play with various standard data types. This test uses a few ways to work with data types and their math functions, as well as mutability and overflows:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn basic_math_stuff() {<br/>        assert_eq!(2 + 2, 4);<br/><br/>        assert_eq!(3.14 + 22.86, 26_f32);<br/><br/>        assert_eq!(2_i32.pow(2), 4);<br/>        assert_eq!(4_f32.sqrt(), 2_f32);<br/><br/>        let a: u64 = 32;<br/>        let b: u64 = 64;<br/><br/>        // Risky, this could overflow<br/>        assert_eq!(b - a, 32);<br/>        assert_eq!(a.overflowing_sub(b), (18446744073709551584, <br/>        true));<br/>        let mut c = 100;<br/>        c += 1;<br/>        assert_eq!(c, 101);<br/>    }</pre>
<ol start="5">
<li>Having the basic numeric types covered, let's check a major limitation: overflows! Rust panics when an overflow occurs, so we are going to expect that with the <kbd>#[should_panic]</kbd> attribute (the test will actually fail if it doesn't panic):</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    #[should_panic]<br/>    fn attempt_overflows() {<br/>        let a = 10_u32;<br/>        let b = 11_u32;<br/><br/>        // This will panic since the result is going to be an <br/>        // unsigned type which cannot handle negative numbers<br/>        // Note: _ means ignore the result<br/>        let _ = a - b; <br/>    }</pre>
<ol start="6">
<li>Next, let's create a custom type as well. Rust's types are <kbd>structs</kbd> and they add no overhead in memory. The type features a <kbd>new()</kbd> (constructor by convention) and a <kbd>sum()</kbd> function, both of which we'll call in a test function:</li>
</ol>
<pre style="padding-left: 60px"><br/>// Rust allows another macro type: derive. It allows to "auto-implement"<br/>// supported traits. Clone, Debug, Copy are typically handy to derive.<br/>#[derive(Clone, Debug, Copy)]<br/>struct MyCustomStruct {<br/>    a: i32,<br/>    b: u32,<br/>    pub c: f32<br/>}<br/><br/>// A typical Rust struct has an impl block for behavior<br/>impl MyCustomStruct {<br/>    <br/>    // The new function is static function, and by convention a <br/>    // constructor<br/>    pub fn new(a: i32, b: u32, c: f32) -&gt; MyCustomStruct {<br/>        MyCustomStruct {<br/>            a: a, b: b, c: c<br/>        }<br/>    }<br/><br/>    // Instance functions feature a "self" reference as the first <br/>    // parameter<br/>    // This self reference can be mutable or owned, just like other <br/>    // variables<br/>    pub fn sum(&amp;self) -&gt; f32 {<br/>        self.a as f32 + self.b as f32 + self.c<br/>    }<br/>}</pre>
<ol start="7">
<li>To see the new <kbd>struct</kbd> function in action, let's add a test to do some and clone memory tricks with types (note: pay attention to the asserts):</li>
</ol>
<pre style="padding-left: 60px">    use super::MyCustomStruct;<br/><br/>    #[test]<br/>    fn test_custom_struct() {<br/>        assert_eq!(mem::size_of::&lt;MyCustomStruct&gt;(), <br/>            mem::size_of::&lt;i32&gt;() + mem::size_of::&lt;u32&gt;() + <br/>            mem::size_of::&lt;f32&gt;());<br/><br/>        let m = MyCustomStruct::new(1, 2, 3_f32);<br/>        assert_eq!(m.a, 1);<br/>        assert_eq!(m.b, 2);<br/>        assert_eq!(m.c, 3_f32);<br/><br/>        assert_eq!(m.sum(), 6_f32);<br/>        let m2 = m.clone();<br/>        assert_eq!(format!("{:?}", m2), "MyCustomStruct { a: 1, b: <br/>         2, <br/>        c: 3.0 }");<br/>        <br/>        let mut m3 = m;        <br/>        m3.a = 100;<br/><br/>        assert_eq!(m2.a, 1);<br/>        assert_eq!(m.a, 1);<br/>        assert_eq!(m3.a, 100);<br/>    }</pre>
<ol start="8">
<li>Lastly, let's see whether all of that works. Run <kbd>cargo test</kbd> in the <kbd>data-types</kbd> directory and you should see the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>Compiling data-types v0.1.0 (Rust-Cookbook/Chapter01/data-types)<br/>warning: method is never used: `new`<br/>  --&gt; src/lib.rs:13:5<br/>   |<br/>13 | pub fn new(a: i32, b: u32, c: f32) -&gt; MyCustomStruct {<br/>   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br/>   |<br/>   = note: #[warn(dead_code)] on by default<br/><br/>warning: method is never used: `sum`<br/>  --&gt; src/lib.rs:19:5<br/>   |<br/>19 | pub fn sum(&amp;self) -&gt; f32 {<br/>   | ^^^^^^^^^^^^^^^^^^^^^^^^<br/><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.50s<br/>     Running target/debug/deps/data_types-33e3290928407ff5<br/><br/>running 3 tests<br/>test tests::basic_math_stuff ... ok<br/>test tests::attempt_overflows ... ok<br/>test tests::test_custom_struct ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests data-types<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/></pre>
<p>Now, let's go behind the scenes to understand the code better.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe played with several concepts, so let's unpack them here. After setting up a library to work with unit tests as our playground in <em>step 1</em> to <em>step 3</em>, we create a first test to work on some built-in data types to go through the basics in <em>step 4</em> and <em>step 5</em>. Since Rust is particularly picky about type conversions, the test applies some math functions on the outcomes and inputs of different types.</p>
<p>For experienced programmers, there is nothing new here, except for the fact that there is an <kbd>overflow_sub()</kbd> type operation that allows for overflowing operations. Other than that, Rust might be a bit more verbose thanks to the (intentional) lack of implicit casting. In <em>step 5</em>, we intentionally provoke an overflow, which leads to a runtime panic (and is the test result we are looking for). </p>
<p>As shown in <em>step 5</em>, Rust offers <kbd>struct</kbd> as the foundation for complex types, which can have attached implementation blocks as well as derived (<kbd>#[derive(Clone, Copy, Debug)]</kbd>) implementations (such as the <kbd>Debug</kbd> and <kbd>Copy</kbd> traits). In <em>step 6</em>, we go through using the type and its implications:</p>
<ul>
<li>No overhead on custom types: <kbd>struct</kbd> has exactly the size that the sum of its properties has</li>
<li><span>Some operations implicitly invoke a trait implementation</span><span>—</span><span>such as the assignment operator </span>or <span>the </span><span><kbd>Copy</kbd> </span><span>trait</span> (which is essentially a shallow copy)</li>
<li>Changing property values requires the mutability of the entire <kbd>struct</kbd> function</li>
</ul>
<p>There are a few aspects that work like that because the default allocation strategy is to prefer the stack whenever possible (or if nothing else is mentioned). Therefore, a shallow copy of the data performs a copy of the actual data as opposed to a reference to it, which is what happens with heap allocations. In this case, Rust forces an explicit call to <kbd>clone()</kbd> so the data behind the reference is copied as well. </p>
<p>We've successfully learned how to create and use data types. Now, let's move on to the next recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling execution flow</h1>
                </header>
            
            <article>
                
<p>In Rust, controlling the execution flow of a program goes beyond simple <kbd>if</kbd> and <kbd>while</kbd> statements. We will see how to do that in this recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>For this recipe, the steps are as follows:</p>
<ol>
<li><span>Create a new project using </span><kbd>cargo new execution-flow -- lib</kbd> and <span>open the project in an editor.</span></li>
<li>Basic conditionals such as <kbd>if</kbd> <span>statements work just like in any other language, so let's start with those and replace the default</span> <kbd>mod tests { ... }</kbd> <span>statement in the file:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">#[cfg(test)]<br/>mod tests {<br/>    #[test]<br/>    fn conditionals() {<br/>        let i = 20;<br/>        // Rust's if statement does not require parenthesis<br/>        if i &lt; 2 {<br/>            assert!(i &lt; 2);<br/>        } else if i &gt; 2 {<br/>            assert!(i &gt; 2);<br/>        } else {<br/>            assert_eq!(i, 2);<br/>        }<br/>    }<br/>}</pre>
<ol start="3">
<li>Conditionals in Rust can do much more! Here is an additional test to show what they can do—add it before the last closing parenthesis:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn more_conditionals() {<br/>        let my_option = Some(10);<br/><br/>        // If let statements can do simple pattern matching<br/>        if let Some(unpacked) = my_option {<br/>            assert_eq!(unpacked, 10);<br/>        } <br/><br/>        let mut other_option = Some(2);<br/>        // there is also while let, which does the same thing<br/>        while let Some(unpacked) = other_option {<br/><br/>            // if can also return values in assignments<br/>            other_option = if unpacked &gt; 0 {<br/>                Some(unpacked - 1)<br/>            } else { <br/>                None<br/>            }<br/>        }<br/>        assert_eq!(other_option, None)<br/>    }</pre>
<ol start="4">
<li>A conditional isn't the only statement that can be used to change the flow of execution. There is, of course, also the loop and its variations. Let's add another test for those as well, starting with a few basics:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn loops() {<br/><br/>        let mut i = 42;<br/>        let mut broke = false;<br/>        <br/>        // a basic loop with control statements<br/>        loop {<br/>            i -= 1;<br/>            if i &lt; 2 {<br/>                broke = true;<br/>                break;<br/>            } else if i &gt; 2 {<br/>                continue;<br/>            }<br/>        }<br/>        assert!(broke);<br/><br/>        // loops and other constructs can be named for better <br/>        readability ...<br/>        'outer: loop {<br/>            'inner: loop {<br/>                break 'inner; // ... and specifically jumped out of<br/>            }<br/>            break 'outer;<br/>        }</pre>
<ol start="5">
<li>Next, we will add more code to the test to see that loops are regular statements that can return values and that ranges can be used in <kbd>for</kbd> loops as well:</li>
</ol>
<pre style="padding-left: 60px">        let mut iterations: u32 = 0;<br/><br/>        let total_squared = loop {<br/>            iterations += 1;<br/><br/>            if iterations &gt;= 10 {<br/>                break iterations.pow(2);<br/>            }<br/>        };<br/>        assert_eq!(total_squared, 100);<br/><br/>        for i in 0..10 { <br/>            assert!(i &gt;= 0 &amp;&amp; i &lt; 10)<br/>        }<br/><br/>        for v in vec![1, 1, 1, 1].iter() {<br/>            assert_eq!(v, &amp;1);<br/>        }<br/>    }<br/><br/></pre>
<ol start="6">
<li>With these three tests prepared, let's run <kbd>cargo test</kbd> to see them working:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling execution-flow v0.1.0 (Rust-Cookbook/Chapter01/execution-flow)<br/>warning: value assigned to `broke` is never read<br/>  --&gt; src/lib.rs:20:17<br/>   |<br/>20 | let mut broke = false;<br/>   | ^^^^^<br/>   |<br/>   = note: #[warn(unused_assignments)] on by default<br/>   = help: maybe it is overwritten before being read?<br/><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.89s<br/>     Running target/debug/deps/execution_flow-5a5ee2c7dd27585c<br/><br/>running 3 tests<br/>test tests::conditionals ... ok<br/>test tests::loops ... ok<br/>test tests::more_conditionals ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Although not vastly different from many languages' control statements, the basic constructs in Rust can change the way you think about variable assignments. It certainly transformed our mental models to be more data-focused. This means that instead of thinking <em>if this condition is reached, assign this other value to a variable</em>, a reversed <em>assign this other value to a variable if this condition is reached</em>—or shorter <em>transform this variable if this condition applies—</em>may take over. </p>
<p>This is the functional stream in the Rust programming language and it lends itself well to shortening and focusing the important parts of a piece of code. Similar implications can be made from the loop constructs since everything is a scope and has a return value. Using these capabilities will make every program a lot more readable and shorter, especially if it's just simple operations. </p>
<p>We've successfully learned how to control execution flow. Now, let's move on to the next recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Splitting your code with crates and modules</h1>
                </header>
            
            <article>
                
<p class="mce-root">Rust knows two types of code units: crates and modules. A crate is an external library, complete with its own <kbd>Cargo.toml</kbd> configuration file, dependencies, tests, and code. Modules, on the other hand, split the crate into logical parts that are only visible to the user if they import specific functions. Since the 2018 edition of Rust, the difference in using these structural encapsulations has been minimized. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This time, we are going to create two projects: one that offers some type of function and another one to use it. Therefore, use <kbd>cargo</kbd> to create both projects: <kbd>cargo new rust-pilib --lib</kbd> and <kbd>cargo new pi-estimator</kbd>. The second command creates a binary executable so we can run the compilation result, while the former is a library (crate). </p>
<p>This recipe is going to create a small program that prints out estimations of pi (<img class="fm-editor-equation" src="Images/b35a6d88-0e56-4570-baee-314330859f14.png" style="width:0.92em;height:0.92em;"/>) and rounds them to two decimal places. It's nothing fancy and easy for anyone to understand.</p>
<div class="packt_tip">Naming crates is hard. The main repository (<a href="https://crates.io/">https://crates.io/</a>) is very permissive and has already seen name squatting (where people reserve names with the intent to sell them—think of names such as <em>YouTube</em> or <em>Facebook</em>, which would make nice API client names for these companies), and many crates are re-implementations of C libraries or wrap them. A good practice is to call the repository or directory <kbd>rust-mycoolCwrapper</kbd> and use <kbd>mycoolCwrapper</kbd> to name the crate itself. This way, only issues specific to your crate come in while the name is easy to guess in people's dependencies!</div>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<div>
<p>In just a few steps, we will be working with different modules:</p>
<ol>
<li><span>First, we are going to implement the</span> <kbd>rust-pilib</kbd> <span>crate. As a simple example, it estimates the constant pi using the Monte Carlo method. This method is somewhat similar to throwing darts at a dartboard and counting the hits. Read more on Wikipedia (</span><a href="https://en.wikipedia.org/wiki/Monte_Carlo_method">https://en.wikipedia.org/wiki/Monte_Carlo_method</a><span>). Add to the</span> <kbd>tests</kbd> <span>submodule this snippet:</span></li>
</ol>
</div>
<pre style="color: black;padding-left: 60px">use rand::prelude::*;<br/><br/>pub fn monte_carlo_pi(iterations: usize) -&gt; f32 {<br/>    let mut inside_circle = 0; <br/>    for _ in 0..iterations {<br/><br/>        // generate two random coordinates between 0 and 1<br/>        let x: f32 = random::&lt;f32&gt;();<br/>        let y: f32 = random::&lt;f32&gt;();<br/>        <br/>        // calculate the circular distance from 0, 0<br/>        if x.powi(2) + y.powi(2) &lt;= 1_f32 {<br/>            // if it's within the circle, increase the count<br/>            inside_circle += 1;<br/>        }<br/>    }<br/>    // return the ratio of 4 times the hits to the total     <br/>    iterations<br/>    (4_f32 * inside_circle as f32) / iterations as f32<br/>}</pre>
<ol start="2">
<li>Additionally, the Monte Carlo method uses a random number generator. Since Rust doesn't come with one in its standard library, an external crate is required! Modify <kbd>Cargo.toml</kbd> of the <kbd>rust-pilib</kbd> project to add the dependency:</li>
</ol>
<pre style="padding-left: 60px">[dependencies]<br/>rand = "^0.5"</pre>
<ol start="3">
<li>As good engineers, we are also going to add tests to our new library. Replace the original <kbd>test</kbd> module with the following tests to approximate <kbd>pi</kbd> using the Monte Carlo method: </li>
</ol>
<pre style="padding-left: 60px">#[cfg(test)]<br/>mod tests {<br/>    // import the parent crate's functions<br/>    use super::*;<br/><br/>    fn is_reasonably_pi(pi: f32) -&gt; bool {<br/>        pi &gt;= 3_f32 &amp;&amp; pi &lt;= 4.5_f32<br/>    }<br/><br/>    #[test]<br/>    fn test_monte_carlo_pi_1() {<br/>        let pi = monte_carlo_pi(1);<br/>        assert!(pi == 0_f32 || pi == 4_f32);<br/>    }<br/><br/>    #[test]<br/>    fn test_monte_carlo_pi_500() {<br/>        let pi = monte_carlo_pi(500);<br/>        assert!(is_reasonably_pi(pi));<br/>    }</pre>
<p style="padding-left: 60px">We can even go beyond 500 iterations:</p>
<pre style="padding-left: 60px">    #[test]<br/>    fn test_monte_carlo_pi_1000() {<br/>        let pi = monte_carlo_pi(1000);<br/>        assert!(is_reasonably_pi(pi));<br/>    }<br/><br/>    #[test]<br/>    fn test_monte_carlo_pi_5000() {<br/>        let pi = monte_carlo_pi(5000);<br/>        assert!(is_reasonably_pi(pi));<br/>    }<br/>}<br/><br/></pre>
<ol start="4">
<li>Next, let's run the tests so we are certain of the quality of our product. Run <kbd>cargo test</kbd> in the root of the <kbd>rust-pilib</kbd> project. The output should be somewhat like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling libc v0.2.50<br/>   Compiling rand_core v0.4.0<br/>   Compiling rand_core v0.3.1<br/>   Compiling rand v0.5.6<br/>   Compiling rust-pilib v0.1.0 (Rust-Cookbook/Chapter01/rust-pilib)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 3.78s<br/>     Running target/debug/deps/rust_pilib-d47d917c08b39638<br/><br/>running 4 tests<br/>test tests::test_monte_carlo_pi_1 ... ok<br/>test tests::test_monte_carlo_pi_500 ... ok<br/>test tests::test_monte_carlo_pi_1000 ... ok<br/>test tests::test_monte_carlo_pi_5000 ... ok<br/><br/>test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests rust-pilib<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<ol start="5">
<li>Now we want to offer the crate's feature(s) to the user, which is why we created a second project for the user to execute. Here, we declare to use the other library as an external crate first. Add the following to <kbd>Cargo.toml</kbd> in the <kbd>pi-estimator</kbd> project:</li>
</ol>
<pre style="padding-left: 60px">[dependencies]<br/>rust-pilib = { path = '../rust-pilib', version = '*'}</pre>
<ol start="6">
<li>Then, let's take a look at the <kbd>src/main.rs</kbd> file. Rust looks there to find a <kbd>main</kbd> function to run and, by default, it simply prints <kbd>Hello, World!</kbd> to standard output. Let's replace that with a function call:</li>
</ol>
<pre style="padding-left: 60px">// import from the module above<br/>use printer::pretty_print_pi_approx;<br/><br/><br/>fn main() {<br/>    pretty_print_pi_approx(100_000);<br/>}</pre>
<ol start="7">
<li>Now, where does this new function live? It has its own module:</li>
</ol>
<pre style="padding-left: 60px">// Rust will also accept if you implement it right away<br/>mod printer {<br/>    // import a function from an external crate (no more extern <br/>    declaration required!)<br/>    use rust_pilib::monte_carlo_pi;<br/><br/>    // internal crates can always be imported using the crate <br/>    // prefix<br/>    use crate::rounding::round;<br/><br/>    pub fn pretty_print_pi_approx(iterations: usize) {<br/>        let pi = monte_carlo_pi(iterations);<br/>        let places: usize = 2;<br/>    <br/>        println!("Pi is ~ {} and rounded to {} places {}", pi, <br/>        places, round(pi, places));<br/>    }<br/>}</pre>
<ol start="8">
<li>This module was implemented inline, which is common for tests—but works almost like it was its own file. Looking at the <kbd>use</kbd> statements, we are still missing a module, however: <kbd>rounding</kbd>. Create a file in the same directory as <kbd>main.rs</kbd> and name it <kbd>rounding.rs</kbd>. Add this public function and its test to the file:</li>
</ol>
<pre style="padding-left: 60px"><br/>pub fn round(nr: f32, places: usize) -&gt; f32 {<br/>    let multiplier = 10_f32.powi(places as i32);<br/>    (nr * multiplier + 0.5).floor() / multiplier <br/>}<br/><br/><br/>#[cfg(test)]<br/>mod tests {<br/>    use super::round;<br/><br/>    #[test]<br/>    fn round_positive() {<br/>       assert_eq!(round(3.123456, 2), 3.12);<br/>       assert_eq!(round(3.123456, 4), 3.1235);<br/>       assert_eq!(round(3.999999, 2), 4.0);<br/>       assert_eq!(round(3.0, 2), 3.0);<br/>       assert_eq!(round(9.99999, 2), 10.0); <br/>       assert_eq!(round(0_f32, 2), 0_f32);<br/>    }<br/><br/>    #[test]<br/>    fn round_negative() {<br/>       assert_eq!(round(-3.123456, 2), -3.12);<br/>       assert_eq!(round(-3.123456, 4), -3.1235);<br/>       assert_eq!(round(-3.999999, 2), -4.0);<br/>       assert_eq!(round(-3.0, 2), -3.0);<br/>       assert_eq!(round(-9.99999, 2), -10.0);<br/>    }<br/>}</pre>
<ol start="9">
<li>So far, the module is ignored by the compiler since it was never declared. Let's do just that and add two lines at the top of <kbd>main.rs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// declare the module by its file name<br/>mod rounding;</pre>
<ol start="10">
<li>Lastly, we want to see whether everything worked. <kbd>cd</kbd> into the root directory of the <kbd>pi-estimator</kbd> project and run <kbd>cargo run</kbd>. The output should look similar to this (note that the library crate and dependencies are actually built with <kbd>pi-estimator</kbd>):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling libc v0.2.50<br/>   Compiling rand_core v0.4.0<br/>   Compiling rand_core v0.3.1<br/>   Compiling rand v0.5.6<br/>   Compiling rust-pilib v0.1.0 (Rust-Cookbook/Chapter01/rust-pilib)<br/>   Compiling pi-estimator v0.1.0 (Rust-Cookbook/Chapter01/pi-<br/>   estimator)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 4.17s<br/>     Running `target/debug/pi-estimator`<br/>    Pi is ~ 3.13848 and rounded to 2 places 3.14</pre>
<ol start="11">
<li>Library crates are not the only ones to have tests. Run <kbd>cargo test</kbd> to execute the tests in the new <kbd>pi-estimator</kbd> project:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling pi-estimator v0.1.0 (Rust-Cookbook/Chapter01/pi-<br/>   estimator)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.42s<br/>     Running target/debug/deps/pi_estimator-1c0d8d523fadde02<br/><br/>running 2 tests<br/>test rounding::tests::round_negative ... ok<br/>test rounding::tests::round_positive ... ok<br/><br/>test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we explored the relationship between crates and modules. Rust supports several ways of encapsulating code into units, and the 2018 edition has made it a lot easier to do. Seasoned Rust programmers will miss the <kbd>extern crate</kbd> declaration(s) at the top of the files, which is nowadays only necessary in special cases. Instead, the crate's contents can be used right away in a <kbd>use</kbd> statement. </p>
<p>In this way, the line between modules and crates is now blurred. However, modules are much simpler to create since they are part of the project and only need to be declared in the root module to be compiled. This declaration is done using the <kbd>mod</kbd> statement, which also supports implementation in its body—something that is used a lot in testing. Regardless of the implementation's location, using an external or internal function requires a <kbd>use</kbd> statement, often prefixed with <kbd>crate::</kbd> to hint toward its location. </p>
<p>Alternatively to simple files, a module can also be a directory that contains at least a <kbd>mod.rs</kbd> <span>file.</span> This way, large code bases can nest and structure their traits and structs accordingly.</p>
<p>A note on function visibility: Rust's default parameter is module visibility. Hence, a function declared and implemented in a module can only be seen from within that module. Contrary to that, the <kbd>pub</kbd> modifier exports the function to outside users. The same goes for properties and functions attached to a struct. </p>
<p>We've successfully learned how to split our code with crates and modules. Now, let's move on to the next recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing tests and benchmarks</h1>
                </header>
            
            <article>
                
<p>When we start developing, tests take a backseat more often than not. There are several reasons why this might be necessary at the time, but the inability to set up a testing framework and surroundings is not one of them. Unlike many languages, Rust supports testing right out of the box. This recipe covers how to use these tools.</p>
<p>Although we mostly talk about unit testing here, that is, tests on a function/<kbd>struct</kbd> level, the tools remain the same for integration tests. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Again, this recipe is best worked on in its own project space. Use <kbd>cargo new testing --lib</kbd> to create the project. Inside the project directory, create another folder and call it <kbd>tests</kbd>.</p>
<p>Additionally, the benchmarks feature is still only available on the <kbd>nightly</kbd> branch of Rust. It is required to install the <kbd>nightly</kbd> build of Rust: <kbd>rustup install nightly</kbd>. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to learn more about creating a test suite for your Rust projects:</p>
<ol>
<li>Once created, a library project already contains a very simple test (probably to encourage you to write more). The <kbd>cfg(test)</kbd> and <kbd>test</kbd> attributes tell <kbd>cargo</kbd> (the test runner) how to deal with the module:</li>
</ol>
<pre style="padding-left: 60px">#[cfg(test)]<br/>mod tests {<br/>    #[test]<br/>    fn it_works() {<br/>        assert_eq!(2 + 2, 4);<br/>    }<br/>}</pre>
<ol start="2">
<li>Before we add further tests, let's add a subject that needs testing. In this case, let's use something interesting: a singly linked list from our other book (<em>Hands-On Data Structures and Algorithms with Rust</em>) made generic. It consists of three parts. First is a node type:</li>
</ol>
<pre style="padding-left: 60px">#[derive(Clone)]<br/>struct Node&lt;T&gt; where T: Sized + Clone {<br/>    value: T,<br/>    next: Link&lt;T&gt;,<br/>}<br/><br/>impl&lt;T&gt; Node&lt;T&gt; where T: Sized + Clone {<br/>    fn new(value: T) -&gt; Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt; {<br/>        Rc::new(RefCell::new(Node {<br/>            value: value,<br/>            next: None,<br/>        }))<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Second, we have a <kbd>Link</kbd> <span>type </span>to make writing easier:</p>
<pre style="padding-left: 60px">type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;</pre>
<p style="padding-left: 60px">The last type is the list complete with functions to add and remove nodes. First, we have the type definition:</p>
<pre style="padding-left: 60px">#[derive(Clone)]<br/>pub struct List&lt;T&gt; where T: Sized + Clone {<br/>    head: Link&lt;T&gt;,<br/>    tail: Link&lt;T&gt;,<br/>    pub length: usize,<br/>}</pre>
<p style="padding-left: 60px">In the <kbd>impl</kbd> block, we can then specify the operations for the type:</p>
<pre style="padding-left: 60px">impl&lt;T&gt; List&lt;T&gt; where T: Sized + Clone {<br/>    pub fn new_empty() -&gt; List&lt;T&gt; {<br/>        List { head: None, tail: None, length: 0 }<br/>    }<br/><br/>    pub fn append(&amp;mut self, value: T) {<br/>        let new = Node::new(value);<br/>        match self.tail.take() {<br/>            Some(old) =&gt; old.borrow_mut().next = Some(new.clone()), <br/>            None =&gt; self.head = Some(new.clone())<br/>        }; <br/>        self.length += 1;<br/>        self.tail = Some(new);<br/>    }<br/><br/>    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {<br/>        self.head.take().map(|head| {<br/>            if let Some(next) = head.borrow_mut().next.take() {<br/>                self.head = Some(next);<br/>            } else {<br/>                self.tail.take();<br/>            }<br/>            self.length -= 1;<br/>            Rc::try_unwrap(head)<br/>                .ok()<br/>                .expect("Something is terribly wrong")<br/>                .into_inner()<br/>                .value<br/>        })<br/>    }<br/>}</pre>
<ol start="3">
<li>With the list ready to be tested, let's add some tests for each function, starting with a benchmark:</li>
</ol>
<pre style="padding-left: 60px"><br/>#[cfg(test)]<br/>mod tests {<br/>    use super::*;<br/>    extern crate test;<br/>    use test::Bencher;<br/><br/>    #[bench]<br/>    fn bench_list_append(b: &amp;mut Bencher) {<br/>        let mut list = List::new_empty();<br/>        b.iter(|| {<br/>            list.append(10);<br/>        });<br/>    }</pre>
<p style="padding-left: 60px" class="mce-root">Add some more tests for basic list functionality inside the <kbd>test</kbd> module:</p>
<pre style="padding-left: 60px">    #[test]<br/>    fn test_list_new_empty() {<br/>        let mut list: List&lt;i32&gt; = List::new_empty();<br/>        assert_eq!(list.length, 0);<br/>        assert_eq!(list.pop(), None);<br/>    } <br/><br/>    #[test]<br/>    fn test_list_append() {<br/>        let mut list = List::new_empty();<br/>        list.append(1);<br/>        list.append(1);<br/>        list.append(1);<br/>        list.append(1);<br/>        list.append(1);<br/>        assert_eq!(list.length, 5);<br/>    }<br/><br/><br/>    #[test]<br/>    fn test_list_pop() {<br/>        let mut list = List::new_empty();<br/>        list.append(1);<br/>        list.append(1);<br/>        list.append(1);<br/>        list.append(1);<br/>        list.append(1);<br/>        assert_eq!(list.length, 5);<br/>        assert_eq!(list.pop(), Some(1));<br/>        assert_eq!(list.pop(), Some(1));<br/>        assert_eq!(list.pop(), Some(1));<br/>        assert_eq!(list.pop(), Some(1));<br/>        assert_eq!(list.pop(), Some(1));<br/>        assert_eq!(list.length, 0);<br/>        assert_eq!(list.pop(), None);<br/>    }<br/>}</pre>
<ol start="4">
<li>It's also a good idea to have an integration test that tests the library from end to end. For that, Rust offers a special folder in the project called <kbd>tests</kbd>, which can house additional tests that treat the library as a black box. Create and open the <kbd>tests/list_integration.rs</kbd> <span>file </span>to add a test that inserts 10,000 items into our list:</li>
</ol>
<pre style="padding-left: 60px">use testing::List;<br/><br/>#[test]<br/>fn test_list_insert_10k_items() {<br/>    let mut list = List::new_empty();<br/>    for _ in 0..10_000 {<br/>        list.append(100);<br/>    }<br/>    assert_eq!(list.length, 10_000);<br/>}</pre>
<ol start="5">
<li>Great, now each function has one test. Try it out by running <kbd>cargo +nightly test</kbd> in the <kbd>testing/</kbd> root directory. The result should look like this:</li>
</ol>
<pre style="padding-left: 60px">$ <strong>cargo test</strong><br/>   Compiling testing v0.1.0 (Rust-Cookbook/Chapter01/testing)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.93s<br/>     Running target/debug/deps/testing-a0355a7fb781369f<br/><br/>running 4 tests<br/>test tests::test_list_new_empty ... ok<br/>test tests::test_list_pop ... ok<br/>test tests::test_list_append ... ok<br/>test tests::bench_list_append ... ok<br/><br/>test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>     Running target/debug/deps/list_integration-77544dc154f309b3<br/><br/>running 1 test<br/>test test_list_insert_10k_items ... ok<br/><br/>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests testing<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<ol start="6">
<li>To run the benchmark, issue <kbd>cargo +nightly bench</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>cargo +nightly bench</strong><br/>   Compiling testing v0.1.0 (Rust-Cookbook/Chapter01/testing)<br/>    Finished release [optimized] target(s) in 0.81s<br/>     Running target/release/deps/testing-246b46f1969c54dd<br/><br/>running 4 tests<br/>test tests::test_list_append ... ignored<br/>test tests::test_list_new_empty ... ignored<br/>test tests::test_list_pop ... ignored<br/>test tests::bench_list_append ... bench: 78 ns/iter (+/- 238)<br/><br/>test result: ok. 0 passed; 0 failed; 3 ignored; 1 measured; 0 filtered out<br/><br/></pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Testing frameworks are a third-party library in many programming languages although well-tested code should be the default! By providing a (tiny) testing framework along with a test runner and even a small benchmarking framework (only on <kbd>nightly</kbd> as of this writing), the barrier for testing your Rust code is significantly lower. Although there are still some missing features (for example, mocking), the community is working on providing many of these things via external crates. </p>
<p>After setting everything up in <em>step 1</em>, <em>step 2</em> creates a singly linked list as the test subject. A singly linked list is a series of the same node types, connected with some sort of pointer. In this recipe, we decided to use the interior mutability pattern, which allows for borrowing mutably at runtime to modify the node it points to. The attached operations (<kbd>append()</kbd> and <kbd>pop()</kbd>) make use of this pattern. <em>Step 3</em> then creates the tests that we can use to verify that our code does what we think it should. These tests cover the basic workings of the list: create an empty list, append a few items, and remove them again using <kbd>pop</kbd>. </p>
<p><span>Tests can be failed using a variety of </span><kbd>assert!</kbd><span> macros. They cover equals (</span><kbd>assert_eq!</kbd><span>), not equals (</span><kbd>assert_ne!</kbd><span>), Boolean conditions (</span><kbd>assert!</kbd><span>), and non-release mode compilation only (</span><kbd>debug_assert!</kbd><span>). With these available and attributes such as <kbd>#[should_panic]</kbd>, there is no case that cannot be covered. Additionally, this great Rust book offers an interesting read as well: <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html">https://doc.rust-lang.org/book/ch11-01-writing-tests.html</a>.</span></p>
<p><em>Step 4</em> adds a special integration test in a separate file. This restricts programmers to think like the user of the crate, without access to internal modules and functions that can be available in the nested <kbd>tests</kbd> module. As a simple test, we insert 10,000 items into the list to see whether it can handle the volume. </p>
<div class="packt_infobox">The <kbd>+nightly</kbd> parameter instructs <kbd>cargo</kbd> to use the <kbd>nightly</kbd> toolchain for this command.</div>
<p>Only in <em>step 5</em> are we ready to run the benchmarks using <kbd>cargo +nightly test</kbd>, but tests are not automatically benchmarked. On top of that, benchmarks (<kbd>cargo +nightly bench</kbd>) compile the code using <kbd>--release</kbd> flags, thereby adding several optimizations that could lead to different outcomes from <kbd>cargo +nightly test</kbd> (including a headache for debugging those).</p>
<p><em>Step 6</em> shows the output of the benchmarking harness with nanosecond precision for each loop execution (and the standard deviation). Whenever doing any kind of performance optimization, have a benchmark ready to show that it actually worked!</p>
<p>Other nice things that the Rust documentation tool adds to testing are <kbd>doctests</kbd>. These are snippets that are compiled and executed as well as rendered as documentation. We were so delighted, we gave it its own recipe! So, let's move on to the next recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Documenting your code</h1>
                </header>
            
            <article>
                
<p>Documentation is an important part of software engineering. Instead of simply writing up some functions and chaining them together on a hunch, we like to promote writing reusable and readable code. Part of this is also writing sensible documentation—which, in ideal cases, can be rendered into other formats such as HTML or PDF. As many languages do by default, Rust provides a tool and language support as well: <kbd>rustdoc</kbd>.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Failing our high standards of software engineering, we did not document the code from the last recipe! To change that, let's load a project with code to be documented (such as the previous recipe, <em>Writing tests and benchmarks</em>) into an editor.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Compile your code comments to a shiny HTML in just a few steps:</p>
<ol start="1">
<li>Rust's docstrings (strings that explicitly are documentation to be rendered) are denoted by <kbd>///</kbd> (instead of the regular <kbd>//</kbd>). Within these sections, markdown—a shorthand language for HTML<span>—</span>can be used to create full documentation. Let's add the following before the <kbd>List&lt;T&gt;</kbd> declaration: </li>
</ol>
<pre style="padding-left: 60px">/// <br/>/// A singly-linked list, with nodes allocated on the heap using <br/>///`Rc`s and `RefCell`s. Here's an image illustrating a linked list:<br/>/// <br/>/// <br/>/// ![](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-<br/>///linked-list.svg)<br/>/// <br/>/// *Found on https://en.wikipedia.org/wiki/Linked_list*<br/>/// <br/>/// # Usage<br/>/// <br/>/// ```<br/>/// let list = List::new_empty();<br/>/// ```<br/>/// <br/>#[derive(Clone)]<br/>pub struct List&lt;T&gt; where T: Sized + Clone {<br/>[...]</pre>
<ol start="2">
<li>This makes the code a lot more verbose, but is this worth it? Let's see with <kbd>cargo doc</kbd>, a subcommand that runs <kbd>rustdoc</kbd> on the code and outputs HTML in the <kbd>target/doc</kbd> directory of the project. When opened in a browser, the <kbd>target/doc/testing/index.html</kbd> <span>page </span>shows the following (and more):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fe7c8e34-1c9e-445f-ac33-ad9809066e35.png"/></p>
<div class="packt_tip">Replace <kbd>testing</kbd> with the name of your project!</div>
<ol start="3">
<li>Great, let's add more documentation in the code. There are even special sections that are recognized by the compiler (by convention):</li>
</ol>
<pre style="padding-left: 60px">    ///<br/>    /// Appends a node to the list at the end.<br/>    /// <br/>    /// <br/>    /// # Panics<br/>    /// <br/>    /// This never panics (probably).<br/>    /// <br/>    /// # Safety<br/>    /// <br/>    /// No unsafe code was used.<br/>    /// <br/>    /// # Example<br/>    /// <br/>    /// ```<br/>    /// use testing::List;<br/>    /// <br/>    /// let mut list = List::new_empty();<br/>    /// list.append(10);<br/>    /// ```<br/>    /// <br/>    pub fn append(&amp;mut self, value: T) {<br/>    [...]</pre>
<ol start="4">
<li>The <kbd>///</kbd> comments add documentation for expressions that follow it. This is going to be a problem for modules: should we put the documentation outside of the current module? No. Not only will this make the maintainers confused, but it also has a limit. Let's use <kbd>//!</kbd> to document the module from within:</li>
</ol>
<pre style="padding-left: 60px">//!<br/>//! A simple singly-linked list for the Rust-Cookbook by Packt <br/>//! Publishing. <br/>//! <br/>//! Recipes covered in this module:<br/>//! - Documenting your code<br/>//! - Testing your documentation<br/>//! - Writing tests and benchmarks<br/>//! </pre>
<ol start="5">
<li>A quick <kbd>cargo doc</kbd> run reveals whether it worked:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6ab5a1ad-2ec2-4956-be4e-5bc3e6087d7d.png"/></p>
<ol start="6">
<li>While there is some benefit in having similar-looking documentation in any Rust project, corporate marketing often likes to have things such as logos or a custom favicon to stand out. <kbd>rustdoc</kbd> supports that with attributes on the module level—they can be added right below the module documentation (note: this is the logo of my Rust blog, <a href="https://blog.x5ff.xyz">https://blog.x5ff.xyz</a>):</li>
</ol>
<pre style="padding-left: 60px">#![doc(html_logo_url = "https://blog.x5ff.xyz/img/main/logo.png")]</pre>
<ol start="7">
<li>To see whether it worked, let's run <kbd>cargo doc</kbd> again:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/740bd4e6-4c7c-4972-8134-44fbff08e29c.png"/></p>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Markdown is a great language that allows for creating formatted documentation quickly. However, feature support is typically tricky, so check out Rust's RFC for supported formatting (<a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md</a>) to find out whether some more advanced statements can be used. In general, writing documentation is dreaded by most developers, which is why it's very important to make it as simple and effortless as possible. The <kbd>///</kbd> pattern is quite common and has been expanded in Rust so that the documentation can apply to the code that follows (<kbd>///</kbd>) or that contains it (<kbd>//!</kbd>). Examples can be seen in <em>step 1</em> and <em>step 4</em>.</p>
<p class="mce-root"/>
<p>The approach the Rust project chose allows for a few lines explaining the (<kbd>public</kbd>) function, and then the <kbd>rustdoc</kbd> compiler (invoked in <em>step 2</em> with <kbd>cargo doc</kbd>) does the rest: exposing public members, cross-linking, listing all of the available types and modules, and much more. While the output is fully customizable (<em>step 6</em>), the default is already visually quite appealing (we think). </p>
<div class="packt_infobox">By default, <kbd>cargo doc</kbd> builds the documentation for the entire project—including dependencies. </div>
<p>Special sections (<em>step 3</em>) add another dimension to the documentation output: they allow for IDEs or editors to make some sense of the provided information and highlight, for example, that (and when) a function may panic. The examples <span>section </span>in your newly generated documentation will even compile and run code in the form of <kbd>doctests</kbd> (see the <em>Testing your documentation</em> <span>recipe</span>) so you will be notified when your examples become invalid.</p>
<p>The <kbd>rustdoc</kbd> output is also independent of a web server, which means that it can be used wherever static hosting is supported. In fact, the Rust project builds and serves every crate's documentation that is hosted on <a href="https://crates.io">https://crates.io</a>, on <a href="https://docs.rs">https://docs.rs</a>. </p>
<p>Now that we can create documentation successfully, we should move on to the next recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing your documentation</h1>
                </header>
            
            <article>
                
<p>Out-of-date documentation and examples that aren't working as promised are an unfortunate truth of many technologies. However, these examples can be valuable (black box) regression tests to make sure that we didn't break anything while improving the code, so how can they be used as such? Rust's documentation strings (<kbd>///</kbd>) can include executable code snippets—and they can be seen <span>all over the place </span>on <a href="https://www.rust-lang.org/learn">https://www.rust-lang.org/learn</a>!</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We'll continue to improve the linked list from a previous recipe but focus some more on the documentation. However, the added code will work in any project, so pick one that you want to add documentation to and open it in your favorite editor. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here are the steps for this recipe:</p>
<ol>
<li>Find a function or <kbd>struct</kbd> (or module) to add a documentation string, for example, the <kbd>new_empty()</kbd><span> function of</span> <kbd>List&lt;T&gt;</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    ///<br/>    /// Creates a new empty list.<br/>    /// <br/>    /// <br/>    pub fn new_empty() -&gt; List&lt;T&gt; { <br/>        ...</pre>
<ol start="2">
<li>Use the special (<kbd>H1</kbd>) section <kbd># Example</kbd> to provide a cue for the compiler to run any snippet contained in that section:</li>
</ol>
<pre style="padding-left: 60px">    ///<br/>    /// Creates a new empty list.<br/>    /// <br/>    /// <br/>    /// # Example</pre>
<ol start="3">
<li>Now let's add a code example. Since <kbd>doctests</kbd> are considered black box tests, we import the <kbd>struct</kbd> (only if it's public, of course) and show what we want to show:</li>
</ol>
<pre style="padding-left: 60px">    ///<br/>    /// Creates a new empty list.<br/>    /// <br/>    /// <br/>    /// # Example<br/>    /// <br/>    /// ```<br/>    /// use testing::List;<br/>    /// <br/>    /// let mut list: List&lt;i32&gt; = List::new_empty();<br/>    /// ```<br/>    /// </pre>
<ol start="4">
<li>With that ready, let's see whether the tests work: run <kbd>cargo +nightly test</kbd> in the project's root directory. You can see that we cheated a little bit and added tests to the other functions as well:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo +nightly test</strong><br/>   Compiling testing v0.1.0 (Rust-Cookbook/Chapter01/testing)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.86s<br/>     Running target/debug/deps/testing-a0355a7fb781369f<br/><br/>running 6 tests<br/>[...]<br/>   Doc-tests testing<br/><br/>running 4 tests<br/>test src/lib.rs - List (line 44) ... ok<br/>test src/lib.rs - List&lt;T&gt;::new_empty (line 70) ... ok<br/>test src/lib.rs - List&lt;T&gt;::append (line 94) ... ok<br/>test src/lib.rs - List&lt;T&gt;::pop (line 121) ... ok<br/><br/>test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<ol start="5">
<li>The code obviously has been augmented with several examples that have been run in this case—is that always what we want? Sometimes, it's all about the output, and adding all of the required imports for the test to successfully run is a pain. Hence, there are options to add to the <em>fenced</em> area (<kbd>``` inside the fence ```</kbd>), and <kbd>ignore</kbd> will neither compile nor run the code:</li>
</ol>
<pre style="padding-left: 60px">/// <br/>/// A singly-linked list, with nodes allocated on the heap using `Rc`s and `RefCell`s. Here's an image illustrating a linked list:<br/>/// <br/>/// <br/>/// ![](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)<br/>/// <br/>/// *Found on https://en.wikipedia.org/wiki/Linked_list*<br/>/// <br/>/// # Example<br/>/// <br/>/// ```ignore<br/>/// <br/>/// let list = List::new_empty();<br/>/// ```<br/>/// <br/>#[derive(Clone)]<br/>pub struct List&lt;T&gt; where T: Sized + Clone { <br/>[...]</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="6">
<li>By running <kbd>cargo test</kbd> again, we see the changes reflected in the output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>[...]<br/>   Doc-tests testing<br/><br/>running 4 tests<br/>test src/lib.rs - List (line 46) ... ignored<br/>test src/lib.rs - List&lt;T&gt;::append (line 94) ... ok<br/>test src/lib.rs - List&lt;T&gt;::new_empty (line 70) ... ok<br/>test src/lib.rs - List&lt;T&gt;::pop (line 121) ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out</pre>
<ol start="7">
<li>Let's check the HTML output as well: run <kbd>cargo doc</kbd> to generate a <kbd>target/doc/</kbd> directory containing all of the <kbd>CSS/HTML/JavaScript/...</kbd> required to show the documentation in a local browser. Open <kbd>target/doc/testing/index.html</kbd> with your favorite browser:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/02f40760-8124-4075-97e4-f98dace48423.png"/></p>
<div class="packt_tip"><span>Note: Replace </span><kbd>testing</kbd><span> with the name of your project.</span></div>
<ol start="8">
<li>Let's remove the ugly <kbd>use</kbd> statement at the top of the snippet. At that point, it doubles the lines displayed without adding anything—and <kbd>rustdoc</kbd> provides a simple way to do that, too. Add <kbd>#</kbd> in front of the offending line:</li>
</ol>
<pre style="padding-left: 60px">    ///<br/>    /// Creates a new empty list.<br/>    /// <br/>    /// <br/>    /// # Example<br/>    /// <br/>    /// ```<br/>    /// # use testing::List;<br/>    /// let list: List&lt;i32&gt; = List::new_empty();<br/>    /// ```<br/>    /// <br/>    pub fn new_empty() -&gt; List&lt;T&gt; {<br/>        [...] </pre>
<ol start="9">
<li>Lastly, there are additional ways to configure the testing behavior of <kbd>doctests</kbd>. In this case, let's change warnings to errors by <em>denying</em> the warning while ignoring (allowing) unused variables:  </li>
</ol>
<pre style="padding-left: 60px">#![doc(html_logo_url = "https://blog.x5ff.xyz/img/main/logo.png",<br/>       test(no_crate_inject, attr(allow(unused_variables), <br/>        deny(warnings))))]</pre>
<ol start="10">
<li>One last time, let's check whether the output is what we expect and run <kbd>cargo doc</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/94438ebb-bd22-4720-b1ec-1a8fc65c8bd5.png"/></p>
<p>Now, let's see whether we can find out more about how the code works.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Rust's documentation is very versatile and allows for variations on <kbd>doctests</kbd> that would not be possible to cover in a single recipe. However, the documentation of these tools is also excellent, so, for more details, check out <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html">https://doc.rust-lang.org/rustdoc/documentation-tests.html</a>. </p>
<p class="mce-root"/>
<p>What we covered in this recipe is a great way to document <kbd>structs</kbd> and functions in your code by adding examples that will be compiled and run on every test run. Not only will these be helpful for your readers and regression testing, but they also require you to think about how the code works as a black box. These tests are executed whenever code (<kbd>``` in a fence ```</kbd>) is encountered in the <kbd>Example</kbd> section of the documentation. In <em>step 2</em> and <em>step 3</em>, we create these examples and see the result in <em>step 4</em> and <em>step 10</em>.  </p>
<p>If you are now wondering how some documentation can show a fraction of the code required while it is supposed to be run, <em>step 8</em> shows the resolution to this riddle: <kbd>#</kbd> can hide individual lines while executing them. However, sometimes the code is not executed at all, as <em>step 5</em> shows. We can declare a section as <kbd>ignore</kbd> and this code won't be run (without any visual indication in the output).  </p>
<p>Furthermore, these tests can fail just like any other test by panicking (which can be allowed as well) or falling through an <kbd>assert!</kbd> macro. All in all, by hiding away boilerplate or other non-essential code, the reader can focus on the important bits, while the test still covers everything. </p>
<p>We've successfully tested our documentation—we can sleep easy and move on to the next recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sharing code among types</h1>
                </header>
            
            <article>
                
<p>An unusual feature of the Rust programming language is the decision to use traits over interfaces. The latter is very common across modern object-oriented languages and unifies the API of a class (or similar) to the caller, making it possible to switch the entire implementation without the caller's knowledge. In Rust, the separation is a bit different: traits are more akin to abstract classes since they provide the API aspect as well as default implementations. <kbd>struct</kbd> can implement various traits, thereby offering the same behavior with other structs that implement the same traits. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's go through the following steps:</p>
<ol>
<li><span>Use </span><kbd>cargo</kbd><span> to create a new project,</span><span> </span><kbd>cargo new traits --lib</kbd><span>, or clone it from </span><span>this book's GitHub repository (<a href="https://github.com/PacktPublishing/Rust-Programming-Cookbook">https://github.com/PacktPublishing/Rust-Programming-Cookbook</a></span><span>). Use Visual Studio Code and Terminal to open the project's directory.</span></li>
<li>Implement a simple configuration management service. To do that, we need some structs to work with:</li>
</ol>
<pre style="padding-left: 60px">use std::io::{Read, Write};<br/><br/>///<br/>/// Configuration for our application<br/>/// <br/>pub struct Config {<br/>    values: Vec&lt;(String, String)&gt;<br/>}<br/><br/>///<br/>/// A service for managing a configuration<br/>/// <br/>pub struct KeyValueConfigService {}</pre>
<p style="padding-left: 60px">Additionally, some constructors make them easier to use:</p>
<pre style="padding-left: 60px">// Impls<br/><br/>impl Config {<br/>    pub fn new(values: Vec&lt;(String, String)&gt;) -&gt; Config {<br/>        Config { values: values }<br/>    }<br/>}<br/><br/>impl KeyValueConfigService {<br/>    pub fn new() -&gt; KeyValueConfigService {<br/>        KeyValueConfigService { }<br/>    }<br/>}</pre>
<ol start="3">
<li>To use a unified interface with other potential implementations, we have some traits to share the interface:</li>
</ol>
<pre style="padding-left: 60px">///<br/>/// Provides a get() function to return values associated with<br/>/// the specified key.<br/>/// <br/>pub trait ValueGetter {<br/>    fn get(&amp;self, s: &amp;str) -&gt; Option&lt;String&gt;;<br/>}<br/><br/>///<br/>/// Write a config<br/>/// <br/>pub trait ConfigWriter {<br/>    fn write(&amp;self, config: Config, to: &amp;mut impl Write) -&gt; std::io::Result&lt;()&gt;;<br/>}<br/><br/>///<br/>/// Read a config<br/>/// <br/>pub trait ConfigReader {<br/>    fn read(&amp;self, from: &amp;mut impl Read) -&gt; std::io::Result&lt;Config&gt;;<br/>}</pre>
<ol start="4">
<li>Rust demands its own implementation block for each trait:</li>
</ol>
<pre style="padding-left: 60px">impl ConfigWriter for KeyValueConfigService {<br/>    fn write(&amp;self, config: Config, mut to: &amp;mut impl Write) -&gt; std::io::Result&lt;()&gt; {<br/>        for v in config.values {<br/>            writeln!(&amp;mut to, "{0}={1}", v.0, v.1)?;<br/>        }<br/>        Ok(())<br/>    }<br/>}<br/><br/>impl ConfigReader for KeyValueConfigService {<br/>    fn read(&amp;self, from: &amp;mut impl Read) -&gt; std::io::Result&lt;Config&gt; {<br/>        let mut buffer = String::new();<br/>        from.read_to_string(&amp;mut buffer)?;<br/><br/>        // chain iterators together and collect the results<br/>        let values: Vec&lt;(String, String)&gt; = buffer<br/>            .split_terminator("\n") // split<br/>            .map(|line| line.trim()) // remove whitespace<br/>            .filter(|line| { // filter invalid lines<br/>                let pos = line.find("=")<br/>                    .unwrap_or(0);<br/>                pos &gt; 0 &amp;&amp; pos &lt; line.len() - 1<br/>            })<br/>            .map(|line| { // create a tuple from a line <br/>                let parts = line.split("=")<br/>                                .collect::&lt;Vec&lt;&amp;str&gt;&gt;();<br/>                (parts[0].to_string(), parts[1].to_string())<br/>            })<br/>            .collect(); // transform it into a vector<br/>        Ok(Config::new(values))<br/>    }<br/>}<br/><br/>impl ValueGetter for Config {<br/>    fn get(&amp;self, s: &amp;str) -&gt; Option&lt;String&gt; {<br/>        self.values.iter()<br/>            .find_map(|tuple| if &amp;tuple.0 == s {<br/>                    Some(tuple.1.clone())<br/>                } else {<br/>                    None<br/>            })<br/>    }<br/>}</pre>
<ol start="5">
<li>Next, we need some tests to show it in action. To cover some basics, let's add best-case unit tests:</li>
</ol>
<pre style="padding-left: 60px">#[cfg(test)]<br/>mod tests {<br/>    use super::*;<br/>    use std::io::Cursor;<br/><br/>    #[test]<br/>    fn config_get_value() {<br/>        let config = Config::new(vec![("hello".to_string(), <br/>        "world".to_string())]);<br/>        assert_eq!(config.get("hello"), Some("world".to_string()));<br/>        assert_eq!(config.get("HELLO"), None);<br/>    }<br/><br/><br/>    #[test]<br/>    fn keyvalueconfigservice_write_config() {<br/>        let config = Config::new(vec![("hello".to_string(), <br/>        "world".to_string())]);<br/><br/>        let service = KeyValueConfigService::new();<br/>        let mut target = vec![];<br/>        assert!(service.write(config, &amp;mut target).is_ok());<br/><br/>        assert_eq!(String::from_utf8(target).unwrap(), <br/>        "hello=world\n".to_string());<br/>    }<br/><br/>     #[test]<br/>    fn keyvalueconfigservice_read_config() {<br/><br/>        let service = KeyValueConfigService::new();<br/>        let readable = &amp;format!("{}\n{}", "hello=world", <br/>        "a=b").into_bytes();<br/>        <br/>        let config = service.read(&amp;mut Cursor::new(readable))<br/>            .expect("Couldn't read from the vector");<br/><br/>        assert_eq!(config.values, vec![<br/>                ("hello".to_string(), "world".to_string()),<br/>                ("a".to_string(), "b".to_string())]);<br/>    }<br/>}</pre>
<ol start="6">
<li>Lastly, we run <kbd>cargo test</kbd> and see that everything works out:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling traits v0.1.0 (Rust-Cookbook/Chapter01/traits)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.92s<br/>     Running target/debug/deps/traits-e1d367b025654a89<br/><br/>running 3 tests<br/>test tests::config_get_value ... ok<br/>test tests::keyvalueconfigservice_write_config ... ok<br/>test tests::keyvalueconfigservice_read_config ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests traits<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/></pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Using traits instead of interfaces and other object-oriented constructs has many implications for the general architecture. In fact, common architectural thinking will likely lead to more complex and verbose code that may perform worse on top of that! Let's examine popular object-oriented principles from the Gang of Four's book, <em>Design Patterns</em> (1994):</p>
<ul>
<li><strong>Program to an interface not to an implementation</strong>: This principle requires some thinking in Rust. With the 2018 edition, functions can accept an <kbd>impl MyTrait</kbd> parameter, where earlier versions had to use <kbd>Box&lt;MyTrait&gt;</kbd> or <kbd>o: T</kbd> and later <kbd>where T: MyTrait</kbd>, all of which have their own issues. It's a trade-off for every project: either less complex abstractions with the concrete type or more generics and other complexity for cleaner encapsulation. </li>
<li><strong>Favor object composition over class inheritance</strong>: While this only applies to some extent (there is no inheritance in Rust), object composition is still something that seems like a good idea. Add trait type properties to your struct instead of the actual type. However, unless it's a boxed trait (that is, slower dynamic dispatch), there is no way for the compiler to know exactly the size it should reserve—a type instance could have 10 times the size of the trait from other things. Therefore, a reference is required. Unfortunately, though, that introduces explicit lifetimes—making the code a lot more verbose and complex to handle.</li>
</ul>
<p>Rust clearly favors splitting off behavior from data, where the former goes into a trait and the latter remains with the original struct. In this recipe, <kbd>KeyValueConfigService</kbd> did not have to manage any data—its task was to read and write <kbd>Config</kbd> instances.</p>
<p>After creating these structs in <em>step 2</em>, we created the behavior traits in <em>step 3</em>. There, we split the tasks off into two individual traits to keep them small and manageable. Anything can implement these traits and thereby acquire the capabilities of writing or reading config files or retrieving a specific value by its key. </p>
<p>We kept the functions on the trait generic as well to allow for easy unit testing (we can use <kbd>Vec&lt;T&gt;</kbd> instead of faking files). Using Rust's <kbd>impl</kbd> trait feature, we only care about the fact that <kbd>std::io::Read</kbd> and <kbd>std::io::Write</kbd> have been implemented by whatever is passed in.</p>
<p class="mce-root"/>
<p><em>Step 4</em> implements the traits in an individual <kbd>impl</kbd> block for the structs. The <kbd>ConfigReader</kbd> strategy is naive: split into lines, split those lines at the first <kbd>=</kbd> character, and declare the left- and right-hand parts key and value respectively. The <kbd>ValueGetter</kbd> implementation then walks through the key-value pairs to find the requested key. We preferred <kbd>Vec</kbd> with <kbd>String</kbd> tuples here for simplicity, for example, <kbd>HashMap</kbd> can improve performance substantially.</p>
<p>The tests implemented in <em>step 5</em> provide an overview of how the system works and how we seamlessly use the types by the traits they implement. <kbd>Vec</kbd> doubles as a read/write stream, no type-casting required. To make sure the tests actually run through, we run <kbd>cargo test</kbd> in <em>step 6</em>. </p>
<p> <span>After this lesson on structuring code, let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sequence types in Rust</h1>
                </header>
            
            <article>
                
<p>Sequences are supported in many forms in Rust. The regular array is strictly implemented: it has to be defined at compile time (using literals) and be of a single data type, and cannot change in size. Tuples can have members of different types, but cannot change in size either. <kbd>Vec&lt;T&gt;</kbd> is a generic sequence type (of whatever you define as type <kbd>T</kbd>) that provides dynamic resizing—but <kbd>T</kbd> can only be of a single type. All in all, each of them has its purpose and, in this recipe, we will explore each.  </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The steps for this recipe are as follows:</p>
<ol>
<li><span>Use</span><span> </span><kbd>cargo</kbd><span> </span><span>to create a new project,</span><span> </span><kbd>cargo new sequences --lib</kbd><span>, or clone it from </span><span>this book's GitHub repository (<a href="https://github.com/PacktPublishing/Rust-Programming-Cookbook">https://github.com/PacktPublishing/Rust-Programming-Cookbook</a></span><span>). Use Visual Studio Code and Terminal to open the project's directory.</span></li>
<li>With the test module ready, let's start with arrays. Arrays in Rust have a familiar syntax but they follow a stricter definition. We can try out various abilities of the Rust array in a test:</li>
</ol>
<pre style="color: black;padding-left: 60px">    #[test]<br/>    fn exploring_arrays() {<br/>        let mut arr: [usize; 3] = [0; 3];<br/>        assert_eq!(arr, [0, 0, 0]);<br/><br/>        let arr2: [usize; 5] = [1,2,3,4,5];<br/>        assert_eq!(arr2, [1,2,3,4,5]);<br/><br/>        arr[0] = 1;<br/>        assert_eq!(arr, [1, 0, 0]);<br/>        assert_eq!(arr[0], 1);<br/>        assert_eq!(mem::size_of_val(&amp;arr), mem::size_of::&lt;usize&gt;()<br/>         * 3);<br/>    }</pre>
<ol start="3">
<li>Users of more recent programming languages and data science/math environments will also be familiar with the tuple, a fixed-size variable type collection. Add a test for working with tuples:</li>
</ol>
<pre style="padding-left: 60px">    struct Point(f32, f32);<br/><br/>    #[test]<br/>    fn exploring_tuples() {<br/>        let mut my_tuple: (i32, usize, f32) = (10, 0, -3.42);<br/><br/>        assert_eq!(my_tuple.0, 10);<br/>        assert_eq!(my_tuple.1, 0);<br/>        assert_eq!(my_tuple.2, -3.42);<br/><br/>        my_tuple.0 = 100;<br/>        assert_eq!(my_tuple.0, 100);<br/><br/>        let (_val1, _val2, _val3) = my_tuple;<br/><br/>        let point = Point(1.2, 2.1);<br/>        assert_eq!(point.0, 1.2);<br/>        assert_eq!(point.1, 2.1);<br/>    }</pre>
<ol start="4">
<li>As the last collection, the vector is the basis for all of the other quick and expandable data types. Create the following test with several assertions that show how to use the <kbd>vec!</kbd> macro and the vector's memory usage:</li>
</ol>
<pre style="padding-left: 60px">    use std::mem;<br/><br/>    #[test]<br/>    fn exploring_vec() {<br/>        assert_eq!(vec![0; 3], [0, 0, 0]);<br/>        let mut v: Vec&lt;i32&gt; = vec![];<br/><br/>        assert_eq!(mem::size_of::&lt;Vec&lt;i32&gt;&gt;(),<br/>         mem::size_of::&lt;usize&gt;<br/>         () * 3);<br/><br/>        assert_eq!(mem::size_of_val(&amp;*v), 0);<br/><br/>        v.push(10);<br/><br/>        assert_eq!(mem::size_of::&lt;Vec&lt;i32&gt;&gt;(),<br/>         mem::size_of::&lt;i32&gt;() * 6);</pre>
<p style="padding-left: 60px">The remainder of the test shows how to modify and read the vector:</p>
<pre style="padding-left: 60px">        assert_eq!(v[0], 10);<br/>        <br/>        v.insert(0, 11);<br/>        v.push(12);<br/>        assert_eq!(v, [11, 10, 12]);<br/>        assert!(!v.is_empty());<br/><br/>        assert_eq!(v.swap_remove(0), 11);<br/>        assert_eq!(v, [12, 10]);<br/><br/>        assert_eq!(v.pop(), Some(10));<br/>        assert_eq!(v, [12]);<br/><br/>        assert_eq!(v.remove(0), 12);<br/>        <br/>        v.shrink_to_fit();<br/>        assert_eq!(mem::size_of_val(&amp;*v), 0);<br/>    }<br/><br/></pre>
<ol start="5">
<li>Run <kbd>cargo test</kbd> to see the working tests run:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling sequences v0.1.0 (Rust-Cookbook/Chapter01/sequences)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 1.28s<br/>     Running target/debug/deps/sequences-f931e7184f2b4f3d<br/><br/>running 3 tests<br/>test tests::exploring_arrays ... ok<br/>test tests::exploring_tuples ... ok<br/>test tests::exploring_vec ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests sequences<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Sequence types are compound types that allocate a continuous part of the memory for faster and easier access. <kbd>Vec&lt;T&gt;</kbd> creates a simple, heap-allocated version of an array that grows (and shrinks) dynamically (<em>step 4</em>). </p>
<p>The original array (<em>step 2</em>) allocates memory on the stack and has to have a known size at compile time, which is a significant factor in using it. Both can be iterated and viewed using slices (<a href="https://doc.rust-lang.org/book/ch04-03-slices.html">https://doc.rust-lang.org/book/ch04-03-slices.html</a>).</p>
<p>Tuples (<em>step 3</em>) are a different beast since they don't lend themselves to slices and are more a group of variables that have a semantic relationship—like a point in a two-dimensional space. Another use case is to return more than one variable to the caller of a function without the use of an additional struct or misusing a collection type.</p>
<p>Sequences in Rust are special because of the low overhead they produce. The size of <kbd>Vec&lt;T&gt;</kbd> is a pointer to an <kbd>n * size of T</kbd> memory on the heap, along with the size of the allocated memory, and how much of that is used. For arrays, the capacity is the current size (which the compiler can fill in during compilation), and tuples are more or less syntactic sugar on top of three distinct variables. Each of the three types provides convenience functions to change the contents—and, in the case of <kbd>Vec&lt;T&gt;</kbd>, the size of the collection. We recommend taking a close look at the tests and their comments to find out more about each type.  </p>
<p>We have covered the basics of sequences in Rust, so let's move on to the next recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Debugging Rust</h1>
                </header>
            
            <article>
                
<p>Debugging has been a notoriously difficult topic in Rust, but still, it pales in comparison to Visual Studio debugging or IntelliJ IDEA's (<a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a>) capabilities in the Java world. However, debugging capabilities go beyond simple <kbd>println!</kbd> statements nowadays. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Debugging Rust is available via an additional extension in Visual Studio Code. Install it by running <kbd>ext install vadimcn.vscode-lldb</kbd> <span>in the command window (</span><em>Ctrl</em><span> + </span><em>P</em><span>/</span><em>cmd</em><span> + </span><em>P</em><span>).</span></p>
<div class="packt_infobox">On Windows, debugging is limited thanks to its incomplete LLVM support. However, the extension will prompt you to automatically install several things. Additionally, install <strong>Python 3.6</strong> and add it to <kbd>%PATH%</kbd>. With these dependencies installed, it worked well for us (in March 2019). <br/>
<br/>
Read more at <a href="https://github.com/vadimcn/vscode-lldb/wiki/Setup">https://github.com/vadimcn/vscode-lldb/wiki/Setup</a>.</div>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Execute the following steps for this recipe:</p>
<ol>
<li><span>Create a new binary project to debug: </span><kbd>cargo new debug-me</kbd><span>. Open this project in Visual Studio Code with the new extension loaded.</span></li>
<li>Before anything can happen, Visual Studio Code needs a launch configuration to recognize Rust's LLVM output. First, let's create this launch configuration; for that, add a <kbd>.vscode</kbd> <span>directory </span><span>containing a</span> <kbd>launch.json</kbd> <span>file</span><span> </span><span>to the project directory. This can be autogenerated, so make sure that</span> <kbd>launch.json</kbd> <span>contains the following:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">{<br/>    "version": "0.2.0",<br/>    "configurations": [<br/>        {<br/>            "type": "lldb",<br/>            "request": "launch",<br/>            "name": "Debug executable 'debug-me'",<br/>            "cargo": {<br/>                "args": [<br/>                    "build",<br/>                    "--bin=debug-me",<br/>                    "--package=debug-me"<br/>                ],<br/>                "filter": {<br/>                    "kind": "bin"<br/>                }<br/>            },<br/>            "args": [],<br/>            "cwd": "${workspaceFolder}"<br/>        },<br/>        {<br/>            "type": "lldb",<br/>            "request": "launch",<br/>            "name": "Debug unit tests in executable 'debug-me'",<br/>            "cargo": {<br/>                "args": [<br/>                    "test",<br/>                    "--no-run",<br/>                    "--bin=debug-me",<br/>                    "--package=debug-me"<br/>                ],<br/>                "filter": {<br/>                    "kind": "bin"<br/>                }<br/>            },<br/>            "args": [],<br/>            "cwd": "${workspaceFolder}"<br/>        }<br/>    ]<br/>}</pre>
<ol start="3">
<li>Now, let's open <kbd>src/main.rs</kbd> and add some code to debug:</li>
</ol>
<pre style="padding-left: 60px">struct MyStruct {<br/>    prop: usize,<br/>}<br/><br/>struct Point(f32, f32);<br/><br/>fn main() {<br/>    let a = 42;<br/>    let b = vec![0, 0, 0, 100];<br/>    let c = [1, 2, 3, 4, 5];<br/>    let d = 0x5ff;<br/>    let e = MyStruct { prop: 10 };<br/>    let p = Point(3.14, 3.14);<br/><br/>    println!("Hello, world!");<br/>}</pre>
<p class="mce-root"/>
<ol start="4">
<li>Save and add a breakpoint in VS Code's user interface. Click left of the line numbers and a red dot should appear there. This is a breakpoint: </li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b1131a2d-2e04-44c4-b77f-2bcfb2ad2df9.png"/></p>
<p class="mce-root"/>
<ol start="5">
<li>Having set a breakpoint, we expect the program to pause there and give us some insights into the current memory layout, that is, the state of any variables at that particular point in time. Run the debug launch configuration with <em>F5</em> (or <span class="packt_screen">Debug</span> <em>|</em> <span class="packt_screen">Start Debugging</span>). The window configuration should change slightly and a panel on the left-hand side of the window shows local variables (among other things):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a2e8a80c-fc38-45cc-bb91-0d2220b3ff7e.png"/></p>
<ol start="6">
<li>Using the small control panel on top, you can then control the execution flow and watch the stack and memory on the left change accordingly. Note also the difference between an array and a (heap-allocated) vector!</li>
</ol>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Rust is built on the LLVM compiler toolkit that comes with a range of features out of the box. When a Rust program compiles, it only gets translated into an intermediate language, from which the LLVM compiler creates native bytecode.</p>
<p>This is also the reason why debugging can work in this case—it builds on the LLVM debug symbols. While it clearly lacks the convenience of modern IDEs, it's a large step forward and allows users to inspect types. Future development of the tools will hopefully improve this situation as well; for now, the general debugger, GDB (<a href="https://www.gnu.org/software/gdb/">https://www.gnu.org/software/gdb/</a>), handles most of the cases where debug symbols are compiled into the program. The configuration for connecting the debugger with the code in the IDE can be found in <em>step 2</em> and, by setting the breakpoint in <em>step 4</em>, it can track the relationship between lines of code and output. With the default setting to compile to debug, the debugger can then stop at this exact point. While it's not perfect (on the UX side), its capabilities are amazing. </p>
<p>Even this simple connection to a (UX-wise) very basic debugger can have great benefits for developers and represents a huge step up from <kbd>println!()</kbd> statements to inspect the current value of a variable. </p>
<p>We hope that you can use the debugger's capabilities in the remainder of this book. With this knowledge, you can now move on to the next chapter.</p>


            </article>

            
        </section>
    </div></body></html>