["```rs\nLOAD counter            (tmp)\nADD counter 1 INTO tmp  (tmp = tmp+1)\nSTORE tmp INTO counter  (counter = tmp)\n```", "```rs\nLOAD counter            (tmp)\nSUB counter 1 INTO tmp  (tmp = tmp-1)\nSTORE tmp INTO counter  (counter = tmp)\n```", "```rs\n[A]LOAD counter                        (tmp_a == 10)\n[B]LOAD counter                        (tmp_b == 10)\n[B]SUB counter 1 INTO tmp              (tmp_b = tmp_b-1)\n[A]ADD counter 1 INTO tmp              (tmp_a = tmp_a + 1)\n[A]STORE tmp INTO counter              (counter = tmp_a)    == 11\n[A]ADD counter 1 INTO tmp              (tmp_a = tmp_a + 1)\n[A]STORE tmp INTO counter              (counter = tmp_a)    == 12\n[A]ADD counter 1 INTO tmp              (tmp_a = tmp_a + 1)\n[A]STORE tmp INTO counter              (counter = tmp_a)    == 13\n[B]STORE tmp INTO counter              (counter == tmp_b)   == 9\n```", "```rs\nuse std::{mem, thread};\nuse std::ops::{Deref, DerefMut};\n\nunsafe impl Send for Ring {}\nunsafe impl Sync for Ring {}\n\nstruct InnerRing {\n    capacity: isize,\n    size: usize,\n    data: *mut Option<u32>,\n}\n\n#[derive(Clone)]\nstruct Ring {\n    inner: *mut InnerRing,\n}\n```", "```rs\nimpl Ring {\n    fn with_capacity(capacity: usize) -> Ring {\n        let mut data: Vec<Option<u32>> = Vec::with_capacity(capacity);\n        for _ in 0..capacity {\n            data.push(None);\n        }\n        let raw_data = (&mut data).as_mut_ptr();\n        mem::forget(data);\n        let inner_ring = Box::new(InnerRing {\n            capacity: capacity as isize,\n            size: 0,\n            data: raw_data,\n        });\n\n        Ring {\n            inner: Box::into_raw(inner_ring),\n        }\n    }\n}\n```", "```rs\nimpl Deref for Ring {\n    type Target = InnerRing;\n\n    fn deref(&self) -> &InnerRing {\n        unsafe { &*self.inner }\n    }\n}\n\nimpl DerefMut for Ring {\n    fn deref_mut(&mut self) -> &mut InnerRing {\n        unsafe { &mut *self.inner }\n    }\n}\n```", "```rs\nfn writer(mut ring: Ring) -> () {\n    let mut offset: isize = 0;\n    let mut cur: u32 = 0;\n    loop {\n        unsafe {\n            if (*ring).size != ((*ring).capacity as usize) {\n                *(*ring).data.offset(offset) = Some(cur);\n                (*ring).size += 1;\n                cur = cur.wrapping_add(1);\n                offset += 1;\n                offset %= (*ring).capacity;\n            } else {\n                thread::yield_now();\n            }\n        }\n    }\n}\n```", "```rs\n                *(*ring).data.offset(offset) = Some(cur);\n                (*ring).size += 1;\n```", "```rs\n            } else {\n                thread::yield_now();\n            }\n```", "```rs\nfn reader(mut ring: Ring) -> () {\n    let mut offset: isize = 0;\n    let mut cur: u32 = 0;\n    while cur < 1_000 {\n        unsafe {\n            if let Some(num) = mem::replace(\n                &mut *(*ring).data.offset(offset), \n                None) \n            {\n                assert_eq!(num, cur);\n                (*ring).size -= 1;\n                cur = cur.wrapping_add(1);\n                offset += 1;\n                offset %= (*ring).capacity;\n            } else {\n                thread::yield_now();\n            }\n        }\n    }\n}\n```", "```rs\nfn main() {\n    let capacity = 10;\n    let ring = Ring::with_capacity(capacity);\n\n    let reader_ring = ring.clone();\n    let reader_jh = thread::spawn(move || {\n        reader(reader_ring);\n    });\n    let _writer_jh = thread::spawn(move || {\n        writer(ring);\n    });\n\n    reader_jh.join().unwrap();\n}\n```", "```rs\n> rustc -C opt-level=3 data_race00.rs && ./data_race00\nthread '<unnamed>' panicked at 'assertion failed: `(left == right)`\n left: `31`,\n right: `21`', data_race00.rs:90:17\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Any', libcore/result.rs:916:5\n```", "```rs\nsize: 0\ncapacity: 5\n\n rdr\n |\n|0: None |1: None |2: None |3: None |4: None |\n |\n wrt\n```", "```rs\nsize: 0\ncapacity: 5\n\n rdr\n |\n|0: Some(0) |1: None |2: None |3: None |4: None |\n             |\n             wrt\n```", "```rs\nsize: 5\ncapacity: 5\n\n rdr\n |\n|0: Some(5) |1: Some(6) |2: Some(7) |3: Some(8) |4: Some(9) |\n |\n wrt\n```", "```rs\nsize: 5\ncapacity: 5\n\n rdr\n |\n|0: Some(10) |1: Some(6) |2: Some(7) |3: Some(8) |4: Some(9) |\n              |\n              wrt\n```", "```rs\n> valgrind --tool=helgrind --history-level=full --log-file=\"results.txt\" ./data_race00\n```", "```rs\n==19795== ----------------------------------------------------------------\n==19795==\n==19795== Possible data race during write of size 4 at 0x621A050 by thread #3\n==19795== Locks held: none\n==19795==    at 0x10F8E2: data_race00::writer::h4524c5c44483b66e (in /home/blt/projects/us/troutwine/concurrency_in_rust/external_projects/data_races/data_race00)\n==19795==    by 0x10FE75: _ZN3std10sys_common9backtrace28__rust_begin_short_backtrace17ha5ca0c09855dd05fE.llvm.5C463C64 (in /home/blt/projects/us/troutwine/concurrency_in_rust/external_projects/data_races/data_race00)\n==19795==    by 0x12668E: __rust_maybe_catch_panic (lib.rs:102)\n==19795==    by 0x110A42: _$LT$F$u20$as$u20$alloc..boxed..FnBox$LT$A$GT$$GT$::call_box::h6b5d5a2a83058684 (in /home/blt/projects/us/troutwine/concurrency_in_rust/external_projects/data_races/data_race00)\n==19795==    by 0x1191A7: call_once<(),()> (boxed.rs:798)\n==19795==    by 0x1191A7: std::sys_common::thread::start_thread::hdc3a308e21d56a9c (thread.rs:24)\n==19795==    by 0x112408: std::sys::unix::thread::Thread::new::thread_start::h555aed63620dece9 (thread.rs:90)\n==19795==    by 0x4C32D06: mythread_wrapper (hg_intercepts.c:389)\n==19795==    by 0x5251493: start_thread (pthread_create.c:333)\n==19795==    by 0x5766AFE: clone (clone.S:97)\n==19795==\n==19795== This conflicts with a previous write of size 8 by thread #2\n==19795== Locks held: none\n==19795==    at 0x10F968: data_race00::reader::h87e804792f6b43da (in /home/blt/projects/us/troutwine/concurrency_in_rust/external_projects/data_races/data_race00)\n==19795==    by 0x12668E: __rust_maybe_catch_panic (lib.rs:102)\n==19795==    by 0x110892: _$LT$F$u20$as$u20$alloc..boxed..FnBox$LT$A$GT$$GT$::call_box::h4b5b7e5f469a419a (in /home/blt/projects/us/troutwine/concurrency_in_rust/external_projects/data_races/data_race00)\n==19795==    by 0x1191A7: call_once<(),()> (boxed.rs:798)\n==19795==    by 0x1191A7: std::sys_common::thread::start_thread::hdc3a308e21d56a9c (thread.rs:24)\n==19795==    by 0x112408: std::sys::unix::thread::Thread::new::thread_start::h555aed63620dece9 (thread.rs:90)\n==19795==    by 0x4C32D06: mythread_wrapper (hg_intercepts.c:389)\n==19795==    by 0x5251493: start_thread (pthread_create.c:333)\n==19795==    by 0x5766AFE: clone (clone.S:97)\n==19795==  Address 0x621a050 is in a rw- anonymous segment\n==19795==\n==19795== ----------------------------------------------------------------\n```", "```rs\nfn writer(mut ring: Ring) -> () {\n    let mut offset: isize = 0;\n    let mut cur: u32 = 0;\n    loop {\n        unsafe {\n            if (*ring).size != ((*ring).capacity as usize) {\n                assert!(mem::replace(&mut *(*ring).data.offset(offset), \n                Some(cur)).is_none());\n                (*ring).size += 1;\n                cur = cur.wrapping_add(1);\n                offset += 1;\n                offset %= (*ring).capacity;\n            } else {\n                thread::yield_now();\n            }\n        }\n    }\n}\n```", "```rs\n> ./data_race01\nthread '<unnamed>thread '' panicked at '<unnamed>assertion failed: mem::replace(&mut *(*ring).data.offset(offset), Some(cur)).is_none()' panicked at '', assertion failed: `(left == right)`\n  left: `20`,\n   right: `10`data_race01.rs', :data_race01.rs65::8517:\n   17note: Run with `RUST_BACKTRACE=1` for a backtrace.\n\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Any', libcore/result.rs:945:5\n```", "```rs\nuse std::{mem, thread};\nuse std::sync::{Arc, Mutex};\n\nstruct Ring {\n    size: usize,\n    data: Vec<Option<u32>>,\n}\n\nimpl Ring {\n    fn with_capacity(capacity: usize) -> Ring {\n        let mut data: Vec<Option<u32>> = Vec::with_capacity(capacity);\n        for _ in 0..capacity {\n            data.push(None);\n        }\n        Ring {\n            size: 0,\n            data: data,\n        }\n    }\n\n    fn capacity(&self) -> usize {\n        self.data.capacity()\n    }\n\n    fn is_full(&self) -> bool {\n        self.size == self.data.capacity()\n    }\n\n    fn emplace(&mut self, offset: usize, val: u32) -> Option<u32> {\n        self.size += 1;\n        let res = mem::replace(&mut self.data[offset], Some(val));\n        res\n    }\n\n    fn displace(&mut self, offset: usize) -> Option<u32> {\n        let res = mem::replace(&mut self.data[offset], None);\n        if res.is_some() {\n            self.size -= 1;\n        }\n        res\n    }\n}\n\nfn writer(ring_lk: Arc<Mutex<Ring>>) -> () {\n    let mut offset: usize = 0;\n    let mut cur: u32 = 0;\n    loop {\n        let mut ring = ring_lk.lock().unwrap();\n        if !ring.is_full() {\n            assert!(ring.emplace(offset, cur).is_none());\n            cur = cur.wrapping_add(1);\n            offset += 1;\n            offset %= ring.capacity();\n        } else {\n            thread::yield_now();\n        }\n    }\n}\n\nfn reader(read_limit: usize, ring_lk: Arc<Mutex<Ring>>) -> () {\n    let mut offset: usize = 0;\n    let mut cur: u32 = 0;\n    while (cur as usize) < read_limit {\n        let mut ring = ring_lk.lock().unwrap();\n        if let Some(num) = ring.displace(offset) {\n            assert_eq!(num, cur);\n            cur = cur.wrapping_add(1);\n            offset += 1;\n            offset %= ring.capacity();\n        } else {\n            drop(ring);\n            thread::yield_now();\n        }\n    }\n}\n\nfn main() {\n    let capacity = 10;\n    let read_limit = 1_000_000;\n    let ring = Arc::new(Mutex::new(Ring::with_capacity(capacity)));\n\n    let reader_ring = Arc::clone(&ring);\n    let reader_jh = thread::spawn(move || {\n        reader(read_limit, reader_ring);\n    });\n    let _writer_jh = thread::spawn(move || {\n        writer(ring);\n    });\n\n    reader_jh.join().unwrap();\n}\n```", "```rs\npub struct Mutex<T: ?Sized> {\n    // Note that this mutex is in a *box*, not inlined into\n    // the struct itself. Once a native mutex has been used \n    // once, its address can never change (it can't be \n    // moved). This mutex type can be safely moved at any time,\n    // so to ensure that the native mutex is used correctly we\n    // box the inner mutex to give it a constant address.\n    inner: Box<sys::Mutex>,\n    poison: poison::Flag,\n    data: UnsafeCell<T>,\n}\n```", "```rs\npub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n```", "```rs\nfn main() {\n    let capacity = 10;\n    let read_limit = 1_000_000;\n    let ring = Arc::new(Mutex::new(Ring::with_capacity(capacity)));\n\n    let reader_ring = Arc::clone(&ring);\n    let reader_jh = thread::spawn(move || {\n        reader(read_limit, reader_ring);\n    });\n    let _writer_jh = thread::spawn(move || {\n        writer(ring);\n    });\n\n    reader_jh.join().unwrap();\n}\n```", "```rs\n> perf stat --event task-clock,context-switches,page-faults,cycles,instructions,branches,branch-misses,cache-references,cache-misses ./data_race02\n\n Performance counter stats for './data_race02':\n\n        988.944526      task-clock (msec)         #    1.943 CPUs utilized\n             8,005      context-switches          #    0.008 M/sec\n               137      page-faults               #    0.139 K/sec\n     2,836,237,759      cycles                    #    2.868 GHz \n     1,074,887,696      instructions              #    0.38  insn per cycle\n       198,103,111      branches                  #  200.318 M/sec\n         1,557,868      branch-misses             #    0.79% of all branches\n        63,377,456      cache-references          #   64.086 M/sec\n             3,326      cache-misses              #    0.005 % of all cache refs\n\n       0.508990976 seconds time elapsed\n```", "```rs\nuse std::thread;\nuse std::sync::mpsc;\n\nfn writer(chan: mpsc::SyncSender<u32>) -> () {\n    let mut cur: u32 = 0;\n    while let Ok(()) = chan.send(cur) {\n        cur = cur.wrapping_add(1);\n    }\n}\n\nfn reader(read_limit: usize, chan: mpsc::Receiver<u32>) -> () {\n    let mut cur: u32 = 0;\n    while (cur as usize) < read_limit {\n        let num = chan.recv().unwrap();\n        assert_eq!(num, cur);\n        cur = cur.wrapping_add(1);\n    }\n}\n\nfn main() {\n    let capacity = 10;\n    let read_limit = 1_000_000;\n    let (snd, rcv) = mpsc::sync_channel(capacity);\n\n    let reader_jh = thread::spawn(move || {\n        reader(read_limit, rcv);\n    });\n    let _writer_jh = thread::spawn(move || {\n        writer(snd);\n    });\n\n    reader_jh.join().unwrap();\n}\n```", "```rs\n> perf stat --event task-clock,context-switches,page-faults,cycles,instructions,branches,branch-misses,cache-references,cache-misses ./data_race03\n\n Performance counter stats for './data_race03':\n\n        760.250406      task-clock (msec)   #    0.765 CPUs utilized\n           200,011      context-switches    #    0.263 M/sec\n               135      page-faults         #    0.178 K/sec\n     1,740,006,788      cycles              #    2.289 GHz\n     1,533,396,017      instructions        #    0.88  insn per cycle\n       327,682,344      branches            #  431.019 M/sec\n     741,095      branch-misses             #    0.23% of all branches\n        71,426,781      cache-references    #   93.952 M/sec\n          4,082      cache-misses          #  0.006 % of all cache refs\n\n       0.993142979 seconds time elapsed\n```", "```rs\n                                _--> high_filter --> cma_egress\n                               /\n  telemetry -> ingest_point ---\n    (udp)                      \\_--> low_filter --> ckms_egress\n```", "```rs\n[package]\nname = \"telem\"\nversion = \"0.1.0\"\n\n[dependencies]\nquantiles = \"0.7\"\nseahash = \"3.0\"\n\n[[bin]]\nname = \"telem\"\ndoc = false\n```", "```rs\nextern crate telem;\n\nuse std::{thread, time};\nuse std::sync::mpsc;\nuse telem::IngestPoint;\nuse telem::egress::{CKMSEgress, CMAEgress, Egress};\nuse telem::event::Event;\nuse telem::filter::{Filter, HighFilter, LowFilter};\n\nfn main() {\n    let limit = 100;\n    let (lp_ic_snd, lp_ic_rcv) = mpsc::channel::<Event>();\n    let (hp_ic_snd, hp_ic_rcv) = mpsc::channel::<Event>();\n    let (ckms_snd, ckms_rcv) = mpsc::channel::<Event>();\n    let (cma_snd, cma_rcv) = mpsc::channel::<Event>();\n\n    let filter_sends = vec![lp_ic_snd, hp_ic_snd];\n    let ingest_filter_sends = filter_sends.clone();\n    let _ingest_jh = thread::spawn(move || {\n        IngestPoint::init(\"127.0.0.1\".to_string(), 1990, \n        ingest_filter_sends).run();\n    });\n    let _low_jh = thread::spawn(move || {\n        let mut low_filter = LowFilter::new(limit);\n        low_filter.run(lp_ic_rcv, vec![ckms_snd]);\n    });\n    let _high_jh = thread::spawn(move || {\n        let mut high_filter = HighFilter::new(limit);\n        high_filter.run(hp_ic_rcv, vec![cma_snd]);\n    });\n    let _ckms_egress_jh = thread::spawn(move || {\n        CKMSEgress::new(0.01).run(ckms_rcv);\n    });\n    let _cma_egress_jh = thread::spawn(move || {\n        CMAEgress::new().run(cma_rcv);\n    });\n\n    let one_second = time::Duration::from_millis(1_000);\n    loop {\n        for snd in &filter_sends {\n            snd.send(Event::Flush).unwrap();\n        }\n        thread::sleep(one_second);\n    }\n}\n```", "```rs\n    let filter_sends = vec![lp_ic_snd, hp_ic_snd];\n    let ingest_filter_sends = filter_sends.clone();\n    let _ingest_jh = thread::spawn(move || {\n        IngestPoint::init(\"127.0.0.1\".to_string(), 1990, \n        ingest_filter_sends).run();\n    });\n```", "```rs\nuse event;\nuse std::{net, thread};\nuse std::net::ToSocketAddrs;\nuse std::str;\nuse std::str::FromStr;\nuse std::sync::mpsc;\nuse util;\n\npub struct IngestPoint {\n    host: String,\n    port: u16,\n    chans: Vec<mpsc::Sender<event::Event>>,\n}\n```", "```rs\n#[derive(Clone)]\npub enum Event {\n    Telemetry(Telemetry),\n    Flush,\n}\n\n#[derive(Debug, Clone)]\npub struct Telemetry {\n    pub name: String,\n    pub value: u32,\n}\n```", "```rs\nimpl IngestPoint {\n    pub fn init(\n        host: String,\n        port: u16,\n        chans: Vec<mpsc::Sender<event::Event>>,\n    ) -> IngestPoint {\n        IngestPoint {\n            chans: chans,\n            host: host,\n            port: port,\n        }\n    }\n\n    pub fn run(&mut self) {\n        let mut joins = Vec::new();\n\n        let addrs = (self.host.as_str(), self.port).to_socket_addrs();\n        if let Ok(ips) = addrs {\n            let ips: Vec<_> = ips.collect();\n            for addr in ips {\n                let listener =\n                    net::UdpSocket::bind(addr)\n                        .expect(\"Unable to bind to UDP socket\");\n                let chans = self.chans.clone();\n                joins.push(thread::spawn(move || handle_udp(chans, \n                                                   &listener)));\n            }\n        }\n\n        for jh in joins {\n            jh.join().expect(\"Uh oh, child thread panicked!\");\n        }\n    }\n}\n```", "```rs\nfn handle_udp(mut chans: Vec<mpsc::Sender<event::Event>>, \n              socket: &net::UdpSocket) {\n    let mut buf = vec![0; 16_250];\n    loop {\n        let (len, _) = match socket.recv_from(&mut buf) {\n            Ok(r) => r,\n            Err(e) => { \n                panic!(\n                    format!(\"Could not read UDP socket with \\\n                            error {:?}\", e)),\n            }\n        };\n        if let Some(telem) = \n        parse_packet(str::from_utf8(&buf[..len]).unwrap()) {\n            util::send(&mut chans, event::Event::Telemetry(telem));\n        }\n    }\n}\n```", "```rs\npub fn send(chans: &[mpsc::Sender<event::Event>], event: event::Event) {\n    if chans.is_empty() {\n        return;\n    }\n\n    for chan in chans.iter() {\n        chan.send(event.clone()).unwrap();\n    }\n}\n```", "```rs\nfn parse_packet(buf: &str) -> Option<event::Telemetry> {\n    let mut iter = buf.split_whitespace();\n    if let Some(name) = iter.next() {\n        if let Some(val) = iter.next() {\n            match u32::from_str(val) {\n                Ok(int) => {\n                    return Some(event::Telemetry {\n                        name: name.to_string(),\n                        value: int,\n                    })\n                }\n                Err(_) => return None,\n            };\n        }\n    }\n    None\n}\n```", "```rs\nuse event;\nuse std::sync::mpsc;\nuse util;\n\nmod high_filter;\nmod low_filter;\n\npub use self::high_filter::*;\npub use self::low_filter::*;\n\npub trait Filter {\n    fn process(\n        &mut self,\n        event: event::Telemetry,\n        res: &mut Vec<event::Telemetry>,\n    ) -> ();\n\n    fn run(\n        &mut self,\n        recv: mpsc::Receiver<event::Event>,\n        chans: Vec<mpsc::Sender<event::Event>>,\n    ) {\n        let mut telems = Vec::with_capacity(64);\n        for event in recv.into_iter() {\n            match event {\n                event::Event::Flush => util::send(&chans, \n                 event::Event::Flush),\n                event::Event::Telemetry(telem) => {\n                    self.process(telem, &mut telems);\n                    for telem in telems.drain(..) {\n                        util::send(&chans, \n                        event::Event::Telemetry(telem))\n                    }\n                }\n            }\n        }\n    }\n}\n```", "```rs\nuse event;\nuse filter::Filter;\n\npub struct LowFilter {\n    limit: u32,\n}\n\nimpl LowFilter {\n    pub fn new(limit: u32) -> Self {\n        LowFilter { limit: limit }\n    }\n}\n\nimpl Filter for LowFilter {\n    fn process(\n        &mut self,\n        event: event::Telemetry,\n        res: &mut Vec<event::Telemetry>,\n    ) -> () {\n        if event.value <= self.limit {\n            res.push(event);\n        }\n    }\n}\n```", "```rs\nuse event;\nuse std::sync::mpsc;\n\nmod cma_egress;\nmod ckms_egress;\n\npub use self::ckms_egress::*;\npub use self::cma_egress::*;\n\npub trait Egress {\n    fn deliver(&mut self, event: event::Telemetry) -> ();\n\n    fn report(&mut self) -> ();\n\n    fn run(&mut self, recv: mpsc::Receiver<event::Event>) {\n        for event in recv.into_iter() {\n            match event {\n                event::Event::Telemetry(telem) => self.deliver(telem),\n                event::Event::Flush => self.report(),\n            }\n        }\n    }\n}\n```", "```rs\nuse egress::Egress;\nuse event;\nuse quantiles;\nuse util;\n\npub struct CKMSEgress {\n    error: f64,\n    data: util::HashMap<String, quantiles::ckms::CKMS<u32>>,\n    new_data_since_last_report: bool,\n}\n\nimpl Egress for CKMSEgress {\n    fn deliver(&mut self, event: event::Telemetry) -> () {\n        self.new_data_since_last_report = true;\n        let val = event.value;\n        let ckms = self.data\n            .entry(event.name)\n            .or_insert(quantiles::ckms::CKMS::new(self.error));\n        ckms.insert(val);\n    }\n\n    fn report(&mut self) -> () {\n        if self.new_data_since_last_report {\n            for (k, v) in &self.data {\n                for q in &[0.0, 0.25, 0.5, 0.75, 0.9, 0.99] {\n                    println!(\"[CKMS] {} {}:{}\", k, q, \n                             v.query(*q).unwrap().1);\n                }\n            }\n            self.new_data_since_last_report = false;\n        }\n    }\n}\n\nimpl CKMSEgress {\n    pub fn new(error: f64) -> Self {\n        CKMSEgress {\n            error: error,\n            data: Default::default(),\n            new_data_since_last_report: false,\n        }\n    }\n}\n```", "```rs\n> cargo run --release\n   Compiling quantiles v0.7.0\n   Compiling seahash v3.0.5\n   Compiling telem v0.1.0 (file:///Users/blt/projects/us/troutwine/concurrency_in_rust/external_projects/telem)\n    Finished release [optimized] target(s) in 7.16 secs\n     Running `target/release/telem`\n```", "```rs\n> echo \"a 10\" | nc -c -u 127.0.0.1 1990\n> echo \"a 55\" | nc -c -u 127.0.0.1 1990\n```", "```rs\n[CKMS] a 0:10\n[CKMS] a 0.25:10\n[CKMS] a 0.5:10\n[CKMS] a 0.75:10\n[CKMS] a 0.9:10\n[CKMS] a 0.99:10\n[CKMS] a 0:10\n[CKMS] a 0.25:10\n[CKMS] a 0.5:10\n[CKMS] a 0.75:55\n[CKMS] a 0.9:55\n[CKMS] a 0.99:55\n```", "```rs\n> echo \"b 1000\" | nc -c -u 127.0.0.1 1990\n> echo \"b 2000\" | nc -c -u 127.0.0.1 1990\n> echo \"b 3000\" | nc -c -u 127.0.0.1 1990\n```", "```rs\n[CMA] b 1000\n[CMA] b 1500\n[CMA] b 2000\n```"]