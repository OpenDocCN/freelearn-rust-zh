["```rs\n#[wasm_bindgen(start)]\npub fn main_js() -> Result<(), JsValue> {\n    ....\n    let image = web_sys::HtmlImageElement::new().unwrap();\n    image.set_src(\"Idle (1).png\");\n    sierpinski(\n        &context,\n        [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)],\n        (0, 255, 0),\n        5,\n    );\n    Ok(())\n}\n```", "```rs\nimage.set_src(\"Idle (1).png\");\ncontext.draw_image_with_html_image_element(&image, 0.0, 0.0);\n...\n```", "```rs\nimage.onload = () => { alert(\"loaded\"); }\n```", "```rs\nlet image = web_sys::HtmlImageElement::new().unwrap();\nimage.set_onload(|| {\n    web_sys::console::log_1(&JsValue::from_str(\"loaded\"));\n});\nimage.set_src(\"Idle (1).png\");\n...\n```", "```rs\nerror[E0308]: mismatched types\n  --> src/lib.rs:43:22\n   |\n   |       image.set_onload(|| {\n   |  ______________________^\n   | |         web_sys::console.log_1(\"loaded\");\n   | |     });\n   | |_____^ expected enum `Option`, found closure\n   |\n   = note: expected enum `Option<&js_sys::Function>`\n           found closure `[closure@src/lib.rs:43:22: 45:6]`\n```", "```rs\nlet image = web_sys::HtmlImageElement::new().unwrap();\nlet callback = Closure::once(|| {\n    web_sys::console::log_1(&JsValue::from_str(\"loaded\"));\n});\nimage.set_onload(callback);\n```", "```rs\nerror[E0308]: mismatched types\n  --> src/lib.rs:47:22\n   |\n47 |     image.set_onload(callback);\n   |                      ^^^^^^^^ expected enum `Option`, \n   found struct `wasm_bindgen::prelude::Closure`\n```", "```rs\nimage.set_onload(Some(callback.as_ref().unchecked_ref()));\n```", "```rs\nlet image = web_sys::HtmlImageElement::new().unwrap();\nlet callback = Closure::once(|| {\n    web_sys::console::log_1(&JsValue::from_str(\"loaded\"));\n});\nimage.set_onload(Some(callback.as_ref().unchecked_ref()));\nimage.set_src(\"Idle (1).png\");\ncontext.draw_image_with_html_image_element(&image, 0.0, 0.0);\n...\n```", "```rs\nUncaught Error: closure invoked recursively or destroyed already\n```", "```rs\nimage.set_onload(Some(callback.as_ref().unchecked_ref()));\ncallback.forget();\n```", "```rs\nuse async_std::task;\nfn main() -> Result<(), surf::Error> {\n    task::block_on(async {\n        let url = \"https://www.rust-lang.org\";\n        let mut response = surf::get(url).send().await?;\n        let body = response.body_string().await?;\n        dbg!(url);\n        dbg!(response.status());\n        dbg!(response.version());\n        dbg!(response.header_names());\n        dbg!(response.header_values());\n        dbg!(body.len());\n        Ok(())\n    })\n}\n```", "```rs\ngetrandom = { version = \"0.2.3\", features = [\"js\"] }\nfutures = \"0.3.17\"\nwasm-bindgen-futures = \"0.4.28\"\n```", "```rs\nwasm_bindgen_futures::spawn_local(async move {\n    let image = web_sys::HtmlImageElement::new().unwrap();\n    let callback = Closure::once(move || {\n        web_sys::console::log_1(&JsValue::from_str(\"loaded\"));\n    });\n    image.set_onload(Some(callback.as_ref().unchecked_ref()));\n    callback.forget();\n    image.set_src(\"Idle (1).png\");\n    context.draw_image_with_html_image_element\n        (&image, 0.0, 0.0);\n    sierpinski(\n...\n});\n```", "```rs\nlet (success_tx, success_rx) = futures::channel::oneshot::channel::<()>();\nlet image = web_sys::HtmlImageElement::new().unwrap();\nlet callback = Closure::once(move || {\n    success_tx.send(());\n});\n...\n```", "```rs\nimage.set_onload(Some(callback.as_ref().unchecked_ref()));\nimage.set_src(\"Idle (1).png\");\nsuccess_rx.await;\ncontext.draw_image_with_html_image_element(&image, 0.0, 0.0);\n```", "```rs\nimage.set_onload(Some(callback.as_ref().unchecked_ref()));\nimage.set_src(\"rhg.png\");\nsuccess_rx.await;\n```", "```rs\nlet (success_tx, success_rx) = futures::channel::oneshot::channel::<Result<(), JsValue>>();\nlet image = web_sys::HtmlImageElement::new().unwrap();\nlet callback = Closure::once(move || {\n    success_tx.send(Ok(()));\n});\nlet error_callback = Closure::once(move |err| {\nsuccess_tx.send(Err(err)); \n});\nimage.set_onload(Some(callback.as_ref().unchecked_ref()));\nimage.set_onerror(Some(error_callback.as_ref().unchecked_ref()));\n```", "```rs\n70 |         let error_callback = Closure::once(move |err| {\n   |                                                     \n^^^^^^^^^^ value used here after move\n71 |             success_tx.send(Err(err));\n```", "```rs\nlet (success_tx, success_rx) = futures::channel::oneshot::channel::<Result<(), JsValue>>();\nlet success_tx = Rc::new(Mutex::new(success_tx));\nlet error_tx = Rc::clone(&success_tx);\n```", "```rs\nlet image = web_sys::HtmlImageElement::new().unwrap();\nlet callback = Closure::once(move || {\n    success_tx\n        .lock()\n        .and_then(|oneshot| Ok(oneshot.send(Ok(()))));\n});\n...\n```", "```rs\nerror[E0507]: cannot move out of dereference of `std::sync::MutexGuard<'_, futures::futures_channel::oneshot::Sender<Result<(), wasm_bindgen::JsValue>>>`\n  --> src/lib.rs:38:40\n   |\n38 |                 .and_then(|oneshot| Ok(oneshot.send(Ok(()))));\n   |                                        ^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `futures::futures_channel::oneshot::Sender<Result<(), wasm_bindgen::JsValue>>`, which does not implement the `Copy` trait\n```", "```rs\nlet (success_tx, success_rx) = futures::channel::oneshot::channel::<Result<(), JsValue>>();\nlet success_tx = Rc::new(Mutex::new(Some(success_tx)));\nlet error_tx = Rc::clone(&success_tx);\n```", "```rs\nlet callback = Closure::once(move || {\n    if let Some(success_tx) = success_tx.lock().ok()\n       .and_then(|mut opt| opt.take()) {\n        success_tx.send(Ok(()));\n    }\n});\n```", "```rs\nlet error_callback = Closure::once(move |err| {\n    if let Some(error_tx) = error_tx.lock().ok()\n       .and_then(|mut opt| opt.take()) {\n        error_tx.send(Err(err));\n    }\n});\n...\n```", "```rs\nimage.set_onload(Some(callback.as_ref().unchecked_ref()));\nimage.set_onerror(Some(error_callback.as_ref().unchecked_ref()));\n...\n```", "```rs\n{\"frames\": {\n\"Dead (1).png\":\n{\n     \"frame\": {\"x\":0,\"y\":0,\"w\":160,\"h\":136},\n     \"rotated\": false,\n     \"trimmed\": false,\n     \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":160,\"h\":136},\n     \"sourceSize\": {\"w\":160,\"h\":136}\n}\n...\n```", "```rs\nasync fn fetch_json(json_path: &str) -> Result<JsValue, JsValue> {\n    let window = web_sys::window().unwrap();\n    let resp_value = wasm_bindgen_futures::JsFuture::from(\n        window.fetch_with_str(json_path)).await?;\n    let resp: web_sys::Response = resp_value.dyn_into()?;\n    wasm_bindgen_futures::JsFuture::from(resp.json()?).await\n}\n```", "```rs\nlet resp_value = wasm_bindgen_futures::JsFuture::from(\n    window.fetch_with_str(&\"rhb.json\")).await?;\n```", "```rs\nwindow.fetch_with_str(json_path)\n```", "```rs\ncontext.draw_image_with_html_image_element(&image, 0.0, 0.0);\nlet json = fetch_json(\"rhb.json\").await.unwrap();\n```", "```rs\nserde = {version = \"1.0.131\", features = [\"derive\"] }\n```", "```rs\n{\"frames\": {\n\"Dead (1).png\":\n{\n     \"frame\": {\"x\":0,\"y\":0,\"w\":160,\"h\":136},\n     \"rotated\": false,\n     \"trimmed\": false,\n     \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":160,\"h\":136},\n     \"sourceSize\": {\"w\":160,\"h\":136}\n}\n...\n```", "```rs\nuse serde::Deserialize;\n```", "```rs\nuse std::collections::HashMap;\n```", "```rs\n#[derive(Deserialize)]\nstruct Sheet {\n    frames: HashMap<String, Cell>,\n}\n```", "```rs\n#[derive(Deserialize)]\nstruct Rect {\n    x: u16,\n    y: u16,\n    w: u16,\n    h: u16,\n}\n#[derive(Deserialize)]\nstruct Cell {\n    frame: Rect,\n}\n```", "```rs\nwasm-bindgen = { version = \"0.2.78\", features = [\"serde-serialize\"] }\n```", "```rs\nlet json = fetch_json(\"rhb.json\")\n    .await\n    .expect(\"Could not fetch rhb.json\");\nlet sheet: Sheet = json\n    .into_serde()\n    .expect(\"Could not convert rhb.json into a Sheet \n     structure\");\n```", "```rs\nlet sheet: Sheet = json\n    .into_serde()\n    .expect(\"Could not convert rhb.json into a Sheet \n     structure\");\nlet (success_tx, success_rx) = futures::channel::oneshot::channel::<()>();\n...\nimage.set_src(\"Idle (1).png\");\nsuccess_rx.await;\n```", "```rs\nimage.set_src(\"rhb.png\");\n```", "```rs\nlet sprite = sheet.frames.get(\"Run (1).png\").expect(\"Cell not found\");\ncontext.draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh(\n    &image,\n    sprite.frame.x.into(),\n    sprite.frame.y.into(),\n    sprite.frame.w.into(),\n    sprite.frame.h.into(),\n    300.0,\n    300.0,\n    sprite.frame.w.into(),\n    sprite.frame.h.into(),\n);\n```", "```rs\nlet context = canvas\n    .get_context(\"2d\")\n    .unwrap()\n    .unwrap()\n    .dyn_into::<web_sys::CanvasRenderingContext2d>()\n    .unwrap();\nwasm_bindgen_futures::spawn_local(async move {\n    let json = fetch_json(\"rhb.json\")\n        .await\n        .expect(\"Could not fetch rhb.json\");\n    ...\n```", "```rs\n    let interval_callback = Closure::wrap(Box::new(move || {}) as Box<dyn FnMut()>);\n    ```", "```rs\nwindow.set_interval_with_callback_and_timeout_and_arguments_0(\n    interval_callback.as_ref().unchecked_ref(),\n    50,\n);\n```", "```rs\nUncaught Error: closure invoked recursively or destroyed already\n```", "```rs\ninterval_callback.forget();\n```", "```rs\nlet interval_callback = Closure::wrap(Box::new(move || {\n    context.clear_rect(0.0, 0.0, 600.0, 600.0);\n}) as Box<dyn FnMut()>);\n```", "```rs\nlet interval_callback = Closure::wrap(Box::new(move || {\n    context.clear_rect(0.0, 0.0, 600.0, 600.0);\n    let sprite = sheet.frames.get(\"Run(1).png\").expect\n        (\"Cell not found\");\n    context.draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh(\n        &image,\n        sprite.frame.x.into(),\n        sprite.frame.y.into(),\n        sprite.frame.w.into(),\n        sprite.frame.h.into(),\n        300.0,\n        300.0,\n        sprite.frame.w.into(),\n        sprite.frame.h.into(),\n    );\n}) as Box<dyn FnMut()>);\n```", "```rs\nlet mut frame = -1;\nlet interval_callback = Closure::wrap(Box::new(move || {\n```", "```rs\nlet interval_callback = Closure::wrap(Box::new(move || {\n    frame = (frame + 1) % 8;\n```", "```rs\nlet interval_callback = Closure::wrap(Box::new(move || {\n    frame = (frame + 1) % 8;\n    let frame_name = format!(\"Run ({}).png\", frame + 1);\n```", "```rs\nlet frame_name = format!(\"Run ({}).png\", frame + 1);\nlet sprite = sheet.frames.get(&frame_name).expect(\"Cell not found\");\n```"]