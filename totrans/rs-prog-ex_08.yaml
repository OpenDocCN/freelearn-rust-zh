- en: Understanding FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is all about asynchronous programming in Rust. In order to show
    you how it works, we''ll write an FTP server. However, to make it as easy as possible
    for you to understand, we''ll break the subject down into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the FTP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a synchronous FTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting asynchronous programmation in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronously implementing the FTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These steps are all important in order to make you feel confident in Rust asynchronous
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's start by talking a bit about the FTP protocol!
  prefs: []
  type: TYPE_NORMAL
- en: File transfer protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **f****ile transfer protocol** (**FTP**) was created in 1971\. Its final
    RFC is 959. If you're curious, you can read more about it at  [https://tools.ietf.org/html/rfc959](https://tools.ietf.org/html/rfc959).
  prefs: []
  type: TYPE_NORMAL
- en: Being an old protocol, a few commands don't have clear specifications, so some
    alternative specifications (that are more or less official) have been written
    in order to fill those blanks. We'll go back to them when writing the server.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point to note is that FTP uses TCP connections.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've quickly introduced you to FTP, let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A client connects to a server and then sends commands to the server. Each command
    receives an answer from the server with either a success or failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the client will send the `PWD` command to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the server answered `257` (which literally means *pathname created*) and
    then gave the current working directory the client is in (which is `"/"`, in this
    case).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, every command ended with `""`. This is another standard in FTP—every
    command has to end with `""`. In case you don't know, `""` stands for carriage
    return and `""` stands for the backline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to note—the answer from the server *always* contains a string
    before the `""`. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the client''s command doesn''t require a precise output (except for the
    returned code), it''s all up to the server. It''s generally just a small sentence
    giving more information about what the server did (or what failed). On another
    server, the `NOOP` command could have given the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, FTP works with two channels:'
  prefs: []
  type: TYPE_NORMAL
- en: The first channel is used to send small commands, such as updating a status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second channel is used to send a large amount of data, such as a file transfer
    or even listing a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A funny thing about this second channel is that it's up to the client to decide
    whether the server connects to the client or vice versa. But in almost every case,
    the client asks the server to connect to him for a second time, and the server
    picks a port and they're good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now say that we''re done with a quick introduction to FTP. If it still
    doesn''t seem perfectly clear at this point, no need to worry: it''ll become more
    obvious as we go through the implementation of the server.'
  prefs: []
  type: TYPE_NORMAL
- en: So, let's start with a synchronous server implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing simple chunks of commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start slowly by first creating a very simple server that sends `"hello"`
    to a new client and then closes the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty easy, right? As usual, let''s explain what the code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For those who don't know much about the network, the preceding line of code
    is the most important for any server
  prefs: []
  type: TYPE_NORMAL
- en: 'It tries to *book* the port for your server only. If another software is using
    it, then the `bind` call will fail. The given string represents the address and
    port we want to *book*. The argument works as follows: `[IP]:[PORT]`. Here, we
    entered `0.0.0.0:1234`, which means that we want the port `1234` on the address
    `0.0.0.0`.'
  prefs: []
  type: TYPE_NORMAL
- en: It might sound strange to allow a server to pick an IP address to use, but it's
    actually not the case. You can only choose between `localhost` (alias `127.0.0.1`)
    and `0.0.0.0`. The only difference between those two is that `0.0.0.0` allows
    other computers to connect to your own (if the port can be accessed from outside
    through the box provided by your internet access provider), whereas `127.0.0.1` can
    only be accessed from the computer it has been started on. But enough with network
    explanations—this isn't the point of this book, so let's move on!
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other code that requires explanation is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `incoming` method call allows us to iterate infinitely on newly received
    connections by returning an iterator. Then, the `for` loop just calls the `next`
    method of the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for this small code sample. Now it's time to improve all this!
  prefs: []
  type: TYPE_NORMAL
- en: 'It''d be nice to handle every client separately and not close the connection
    as soon as we receive a new connection, wouldn''t it? So, let''s just update the
    previous code a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Every time a new client connects to the server, we spawn a new thread and send
    the client's socket into it. This way, we can now handle every client on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can get new clients connected, it's time to actually start implementing
    the FTP part of our server.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, since we need to read and write on sockets, having to do that again
    and again in every function wouldn't be very efficient. Therefore, we'll start
    by implementing functions to do that. For now, we won't handle errors *nicely*
    (yes, `unwrap` is evil).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `write` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, there''s nothing fancy nor difficult to understand here. However, take
    a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: Every message ends with `""` in FTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every message has to be followed by a whitespace if you want to add parameters
    or information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This also works in the exact same way when a client sends us a command.
  prefs: []
  type: TYPE_NORMAL
- en: 'What? Did I forget to provide you the `ResultCode` type? Indeed, you''re absolutely
    right. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Yep, not very beautiful... This is the exact representation of all FTP code
    types (errors, information, warnings, and so on). We can't do much better here;
    we have to rewrite all code so that we can understand it when we receive it and
    are able to give the correct code corresponding to the clients' commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I suppose, you can guess what''s coming next. The `enum Command` of course!
    This time, we''ll fulfill it while we move forward on to the implementation of
    the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, let''s get through this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time we add a new command handling, we''ll have to add a new variant
    to this `enum`. In case the command doesn''t exist (or we haven''t implemented
    it yet), `Unknown` will be returned with the command name. If the command is taking
    arguments, it''ll be added just like we saw for `Unknown`. Let''s take `Cwd` as
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `Cwd` contains a `PathBuf`. `Cwd` stands for **change working
    directory** and takes the path of the directory that the client wants to go to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you''d need to update `as_ref` by adding the following line to the
    `match` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And you''d need to update the `new` method implementation by adding the following
    line into the `match` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s explain the `AsRef` trait implementation. It''s very convenient
    when you want to write a generic function. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to this trait, as long as the type implements it, we can call `as_ref`
    on it. It's very useful in our case when sending messages to the client since
    we can just take a type implementing `AsRef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s talk about the `new` method of the `Command` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The point here is to convert the message received from the client. We need
    to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the command's arguments (if any)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we create an iterator to split our vector, so we can separate the command
    from the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we get the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, `command` is a `Vec<u8>`. To then make the matching easier (because
    nothing in the RFC of the FTP talks about the fact that commands should be in
    uppercase or that `auth` is the same as `AUTH` or even `AuTh`), we call the `uppercase`
    function, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we get the arguments by calling `next` on the iterator `iter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If there are no arguments, no problem! We'll just get `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we match the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To do so, we convert our `Vec<u8>>` into a `&[u8]` (a slice of `u8`). To also
    convert a `&str` (such as `AUTH`) into a `&[u8]`, we use the `b` operator (which
    is more like saying to the compiler, *Hey! Don't worry, just say it's a slice
    and not a* `&str`*!*) to allow the matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we''re good! We can now write the function to actually read the data from
    the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we read one byte at a time (and it's not a very efficient way to do so;
    we'll go back on this function later) and return when we get `""`. We have just
    added a little *security* by removing any whitespaces that would come before the
    command (so as long as we don't have any data in our vector, we won't add any
    whitespace).
  prefs: []
  type: TYPE_NORMAL
- en: If there is any error, we return an empty vector and stop the reading of the
    client input.
  prefs: []
  type: TYPE_NORMAL
- en: Like I said earlier, reading byte by byte isn't efficient, but is simpler to
    demonstrate how it works. So, for now, let's stick to this. This will be done
    completely differently once the asynchronous programming kicks in.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we can read and write FTP inputs it's time to actually start the
    implementation of the commands!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some quick explanations for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cwd` stands for the current working directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream` is the client''s socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` is the username you got from user authentication (which doesn''t really
    matter, as we won''t handle authentication in the first steps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now it''s time to update the `handle_client` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When a new client connects to the server, we send them a message to inform them
    that the server is ready. Then we create a new `Client` instance, listen on the
    client socket, and handle its commands. Simple, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things are missing from this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Client::new` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Client::handle_cmd` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Nothing fancy here; the current path is `"/"` (it corresponds to the root of
    the server, not to the root of the filesystem!). We have set the client's stream,
    and the name hasn't been defined yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see the `Client::handle_cmd` method (needless to say, it''ll be
    the core of this FTP server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! Ok, so that's not really *it*. We still have a lot to add. But
    my point is, we now only have to add other commands here to make it all work.
  prefs: []
  type: TYPE_NORMAL
- en: Commands implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous code, we only handled one command; any other command will receive
    an `unknown command` answer from the server. Also, our `Auth` implementation says
    it's not implemented. So, to sum this up, we handle one command that answers that
    it's not implemented. Crazy, right? For the `Auth` command, we'll look at this
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement some commands *for real*. Let''s start with a simple one:
    `Syst`. This is supposed to return which system this FTP server is running on.
    For some reason, we won''t answer that, and we''ll just send back an answer-nothing
    usable.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the SYST command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s add a new entry into the `Command` enum (I won''t do this every
    time, but the steps will remain the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s update the `as_ref` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s update the `Command::new` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Like I said earlier, just remember those three steps every time you
    add a new command and everything should be fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! We implemented a new command (which doesn't do much, but that
    isn't the point)!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the USER command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have a `name` in our `Client` structure, it'd be nice to have some
    use for it, right? So, as the title says, let's implement the `USER` command.
    Since this command takes an argument, I'll go through the command implementation
    steps once again, so you'll have an example of a command taking a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s update the `enum Command`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we update the `as_ref` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we update the `Command::new` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Phew, all done! Now we just need to implement the function (which is quite
    simple, I promise):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here's a little explanation just in case you need it; if we receive an empty
    username (or no username at all), we consider this as an invalid parameter and
    return `InvalidParameterOrArgument`. Otherwise, everything is fine and we return
    `UserLoggedIn`.
  prefs: []
  type: TYPE_NORMAL
- en: If you're wondering why we didn't return `ResultCode::Ok`, it's because the
    RFC states as such. Once again, every command, what it does, and what it should
    return is described there. If you feel lost, don't hesitate to read it again!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the NOOP command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This topic is quite a simple one. `NOOP` stands for no operation. It takes
    no argument and does nothing. Just because I''m a nice person, here''s the code
    for the `NOOP` command in the `Client::handle_cmd` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Yes, I know, you're amazed by such wonderful code. But don't worry, you'll able
    to write something as good as this when you grow older!
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to implement the next command!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the PWD command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This command is very simple as well. `PWD` stands for print working directory.
    Once again, it's not the one from your system but the one from your server (so
    again, `"/"` corresponds to the folder where you started the server).
  prefs: []
  type: TYPE_NORMAL
- en: 'The command doesn''t take any argument, so there''s no need to show you everything
    again. Let''s just focus on the command handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Nothing complicated; we try to display the path, and if we fail, we return an
    error. The only strange thing is that if everything goes fine, we have to return
    `PATHNAMECreated`. This RFC is really strange...
  prefs: []
  type: TYPE_NORMAL
- en: Sorry, this was the last *simple* command. Now we'll go deeper into the FTP
    and its strange RFC. The following command is just a nice introduction to what's
    coming next. (I hope I didn't scare you!)
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the TYPE command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, we'll have an implementation of the `TYPE` command that does nothing.
    We'll come back to it in the following chapters. However, a bit of explanation
    will come in handy, I assume.
  prefs: []
  type: TYPE_NORMAL
- en: '`TYPE` stands for the representation type. When you''re transferring data over
    the data connection (which is different from the command connection, which is
    the only one we''ve been using until now), you can transfer data differently.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the transfer type is ASCII (the main difference is that all `""`
    have to be transformed into `""`). We'll use the image one (where you send data
    as you have it) to make our lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we'll go back to this implementation in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s just add a `Type` command that doesn''t take any argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: OK, we're lying a bit, but we'll have to deal with it for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost at the end of the basics, but there's one last command to implement
    before you can try accessing the server using an FTP client.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the LIST command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `LIST` command returns a list of the current files and folders of the current
    folder or at the given parameter path. This is already very difficult itself because
    you need to check that the *final* path is accessible to the user (for example,
    if you receive `foo/../../` when you're at `"/"`, there's an issue). But that's
    not all! When you're transferring the files and folders list, there is no official
    way to format it! Fun, right? Luckily, most of the FTP clients follow some kind
    of non-official RFC for this case, and we'll use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to all of this, this command is the first one that we''ll implement
    that uses the data connection. This requires you to add another command: `PASV`.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the PASV command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to make this command work, we need to add a few new fields in our
    `Client` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to update the `Client::new` method as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PASV` command doesn''t take arguments, so I''ll let you add it to the
    structures and everything. Let''s focus on the interesting part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Phew... Let''s explain all this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we already have a data connection with this client, there''s no need to
    open a new one, so we don''t do anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This part is a bit more tricky. First, we pick a port (the best way would be
    to check if the port is available first; we'll do this in later chapters). Then,
    we have to tell the client *where* it should connect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where things get a bit more complicated. We have to transfer the address
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Every `ip` part has to be 8-bits long (so 1-byte long), whereas, each `port`
    part has to be 16-bits long (so, 2 bytes). The first part is easy; we just print
    localhost. However, the second part requires you to perform some binary operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the first byte only is simple; we just have to move 8 bits to the right.
    To sum this up, take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our `u16`. We now shift 8 bits to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Tadaa!
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second part, we could move 8 bits to the left and then 8 bits to the
    right, or we could just use the `and` binary operator. Here''s a little scheme
    to explain this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s take a nice binary to the hexadecimal converter and check the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we perform this operation, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the last 8 bits only. Great! The last part of the command handling
    is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We bind the address and port, wait for a client to connect, and then assign
    it to our data writer. There's nothing problematic in this.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the LIST command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can handle a data connection, let''s implement the `LIST`! For
    now, let''s implement it without parameters (once again, we''ll see in later chapters
    how to handle the `LIST` parameter). As usual, I''ll let you add everything where
    it''s needed and we''ll just focus on the command handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing complicated here either too. Once the transfer is over, we
    close the client socket and move on. What remains to be added are the `send_data`
    and the `add_file_info` functions. Let''s start with the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Easy, there''s no error handling, so it just stands on one line. Now let''s
    see the `add_file_info` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this code work, you''ll also need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to add `cfg_if` in your `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`cfg-if` is really good at help you do conditional compilation in a more easily
    readable way. A point to note about the `get_file_info` function now—this is one
    of the rare things that can''t be performed in the same way on all systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, Windows has its own version and Unix has another. However, the two functions
    take the same argument (the import), and one function call changes. Let''s go
    back to the `add_file_info` function now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I suppose you recognized the output of the `ls` command, right? Apparently,
    the non-official RFC is working as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'First, `d` if it''s a directory or `-` if it isn''t. Then, the rights (just
    like on Unix platforms):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The first `rwx` is for the owner, the second is about the group, and the last
    one is about everyone. Here, `r` stands for read access, `w` stands for write
    access, and `x` stands for execution access.
  prefs: []
  type: TYPE_NORMAL
- en: The rest seems explicit enough on its own, so there's no need to explain it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CWD command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CWD` command allows the user to change its current folder location. However,
    it's far from easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going into the implementation of this command, we''ll need to discuss
    a potential security issue: paths.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the user is at the `"/"` location (which will corresponds to, say, `/home/someone/somewhere`)
    and requests `foo/../../`. If we just accept the path and move the user to this
    location, it'll end up at `/home/someone`. This means that the users could access
    all of your computer without issue. You see the problem now?
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, `Rust` has a nice method on `Path` that allows us to fix this
    huge security issue. I'm talking about `Path::canonicalize` (which is an alias
    of the `fs::canonicalize` function).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does this function do? Let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it interprets the path, normalizes everything (`..` removes
    the folder component), and resolves symbolic links as well. Quite magical, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, all good things have a downside, and so does `canonicalize`.: it
    can only work on *real* paths. If a part of the path doesn''t exist, the function
    will just fail. It''s pretty easy to get through it when you know it, but it can
    sound surprising at first.'
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we fix this? Well, we need to play with a real path. So first, we
    need to append the user's server path to the real server path (the one it has
    on the computer). Once this is done, we just append the path requested by the
    user and call `canonicalize`.
  prefs: []
  type: TYPE_NORMAL
- en: That's not very complicated, but is a bit annoying to play with at first. Don't
    worry, though, the code is coming!
  prefs: []
  type: TYPE_NORMAL
- en: If you wonder why we're not just using the `chroot` function (which would solve
    all problems), remember that this FTP server is supposed to work on every platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'So first, let''s add a new command entry to the `enum Command` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Good, now let''s add it to the `Command::new` method matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! I''ll let you add it into the `AsRef` implementation as well. Now
    it''s time to go into the *real* implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For once, to make our life easier, we''ll create a new method in our `Client`,
    so all the code from the `CWD` command won''t fill the `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, that''s a lot of code. Let''s now go through the execution flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, you can''t set which folder the server is running on; it''ll be changed
    later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we join the requested directory to the current directory of the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Things start to get funny in here. The whole canonicalization process is in
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s append the user path to the (real) server path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: So, if the path is an absolute one (starting with `"/"` on Unix or a prefix
    on Windows such as `c:`), we need to remove the first component of the path, otherwise,
    we just append it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a full and potentially existent path. Let''s canonicalize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have one more thing to check—if the path doesn''t start with the server
    root, then it means that the user tried to cheat on us and tried to access non-accessible
    folders. Here is how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In the case that `canonicalize` returned an error, there's no need to check
    if it did (since it's already an error). If it succeeded but doesn't start with
    `server_root`, then we return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it for this function. Now, we''ll return the result to the caller and
    can go back to the `cwd` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we get the full directory path and have confirmed it was okay, we need
    to remove the `server_root` prefix to get the path from our server root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Finally, once this is done, we can just set the path to the user and send back
    a message that the command succeeded (and return to avoid sending back that we
    failed!).
  prefs: []
  type: TYPE_NORMAL
- en: 'If anything goes wrong, we send back the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: That's it for this command! You now know how to avoid a security issue by checking
    received paths provided by the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CDUP command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CDUP` is used to go up to the parent directory. In comparison to the `CWD`
    command implementation, it''ll be a piece of cake! The `CDUP` command doesn''t
    take arguments, so I''ll let you add it to `enums`. Now, let''s focus on the command
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. There's need to check if the parent folder exists, as it does.
    And if we're already at the root, then there's no need to do anything. Isn't it
    wonderful?
  prefs: []
  type: TYPE_NORMAL
- en: Full implementation of the LIST command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to play with paths nicely, it'd be a shame not fully implement
    the `LIST` command, right?
  prefs: []
  type: TYPE_NORMAL
- en: To complete it, you'll need to update the `Command::List` variant in order to
    make it accept `PathBuf` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we currently have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To put it simply, we just added the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the `Client::complete_path` method, things were pretty easy with
    the path manipulation. So, what happens if the given path is a file? We don''t
    check such a case but we should! Let''s replace the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'With:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! Luckily for us, we did things correctly the first time, so *it
    just works*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the MKD command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MKD` stands for make directory (yes, exactly like the Unix command but
    shorter). Just like `LIST` and `CWD`, it takes `PathBuf` as an argument. I''ll
    let you handle the other adds as usual and focus on the command implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like last time, we''ll create a new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Once again, a few things have to be done before even actually trying to make
    the directory.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to check whether all the elements of the given path are folders
    (well, only the last one in fact since otherwise, the `Client::complete_path`
    method will fail otherwise).
  prefs: []
  type: TYPE_NORMAL
- en: Then we need to once again, canonicalize this path (by calling the `Client::complete_path`
    method). Finally, we push the filename to the received path.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference here is that we don't strip the `server_root` path from
    the path returned by `Client::complete_path`.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of this is done, we can try to create the folder by using the `create_dir`
    function. If it goes well, we then return `ResultCode::PATHNAMECreated` (and for
    once it makes sense!).
  prefs: []
  type: TYPE_NORMAL
- en: If any error occurs at any level, we just send that the path was incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for this command!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the RMD command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can create folders, it'd be nice to be able to remove them, right?
    That's what `RMD` (which stands for *remove directory*) is supposed to do!
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like `MKD` (and the others), `RMD` takes `PathBuf` as an argument. Once
    again, and as usual, I''ll let you handle the `Command` part so we can focus on
    the command implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Yep, it's a new method once again. It becomes a habit at this point I suppose?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! This is even easier than `MKD` since we don't need to check if
    the last potential parent is a folder. Once we have confirmed that the path was
    an authorized one, we can just remove it.
  prefs: []
  type: TYPE_NORMAL
- en: With all these commands, I think we can say that we have a very fine base to
    build upon in order to make a complete FTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now have a (very) basic FTP server implementation. You can connect to the
    server and list the files and folders in the current folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start it with  `cargo run` and give it a try! I recommend that you use `FileZilla`.
    This is a great FTP client. Connect to `localhost` on the port `1234` and use
    the `anonymous` username (or none), and you should be able to have a bit of fun
    already:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)*Figure 8.1*'
  prefs: []
  type: TYPE_NORMAL
- en: Information on the file transfers and additional commands will be covered in
    later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the basics of the FTP. We now have a simple (synchronous)
    server implementation, and you should have a good idea about how all of this is
    working. We also looked at a potential security issue and how to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: The following chapters will introduce you to asynchronous programming in Rust.
    Thanks to this chapter, it'll go a lot quicker on the FTP RFC side so we can focus
    on the asynchronous part.
  prefs: []
  type: TYPE_NORMAL
