- en: Understanding FTP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 FTP
- en: 'This chapter is all about asynchronous programming in Rust. In order to show
    you how it works, we''ll write an FTP server. However, to make it as easy as possible
    for you to understand, we''ll break the subject down into the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于 Rust 中的异步编程。为了向您展示它是如何工作的，我们将编写一个 FTP 服务器。然而，为了尽可能让您容易理解，我们将把主题分解为以下几个部分：
- en: Presenting the FTP protocol
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示 FTP 协议
- en: Implementing a synchronous FTP server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 FTP 服务器
- en: Presenting asynchronous programmation in Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中展示异步编程
- en: Asynchronously implementing the FTP server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步实现 FTP 服务器
- en: These steps are all important in order to make you feel confident in Rust asynchronous
    programming.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤都非常重要，以便让您在 Rust 异步编程中感到自信。
- en: Now, let's start by talking a bit about the FTP protocol!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先简单谈谈 FTP 协议！
- en: File transfer protocol
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件传输协议
- en: The **f****ile transfer protocol** (**FTP**) was created in 1971\. Its final
    RFC is 959. If you're curious, you can read more about it at  [https://tools.ietf.org/html/rfc959](https://tools.ietf.org/html/rfc959).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件传输协议**（FTP）于 1971 年创建。其最终 RFC 为 959。如果你对此感兴趣，可以在 [https://tools.ietf.org/html/rfc959](https://tools.ietf.org/html/rfc959)
    上了解更多信息。'
- en: Being an old protocol, a few commands don't have clear specifications, so some
    alternative specifications (that are more or less official) have been written
    in order to fill those blanks. We'll go back to them when writing the server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种旧协议，一些命令没有明确的规范，因此已经编写了一些替代规范（或多或少是官方的），以填补这些空白。在编写服务器时，我们会回到它们。
- en: Another important point to note is that FTP uses TCP connections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要点是，FTP 使用 TCP 连接。
- en: Now that we've quickly introduced you to FTP, let's see how it works.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速介绍了 FTP，让我们看看它是如何工作的。
- en: Introduction to FTP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP 简介
- en: A client connects to a server and then sends commands to the server. Each command
    receives an answer from the server with either a success or failure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端连接到服务器并向服务器发送命令。每个命令都会收到来自服务器的成功或失败回答。
- en: 'For example, the client will send the `PWD` command to the server:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，客户端会向服务器发送 `PWD` 命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the server answered `257` (which literally means *pathname created*) and
    then gave the current working directory the client is in (which is `"/"`, in this
    case).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，服务器回答了 `257`（字面上意味着 *路径名已创建*），然后给出了客户端当前所在的当前工作目录（在这种情况下是 `"/"`）。
- en: As you can see, every command ended with `""`. This is another standard in FTP—every
    command has to end with `""`. In case you don't know, `""` stands for carriage
    return and `""` stands for the backline.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个命令都以 `""` 结尾。这是 FTP 的另一个标准——每个命令都必须以 `""` 结尾。如果您不知道，`""` 代表回车符，`""` 代表换行符。
- en: 'Another thing to note—the answer from the server *always* contains a string
    before the `""`. Consider the following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事需要注意——服务器的回答 *总是* 在 `""` 前包含一个字符串。考虑以下示例：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the client''s command doesn''t require a precise output (except for the
    returned code), it''s all up to the server. It''s generally just a small sentence
    giving more information about what the server did (or what failed). On another
    server, the `NOOP` command could have given the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端的命令不需要精确的输出（除了返回代码），那就完全取决于服务器。通常只是一个简短的句子，提供更多关于服务器所做（或失败）的信息。在另一个服务器上，`NOOP`
    命令可能会给出以下内容：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Lastly, FTP works with two channels:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，FTP 使用两个通道：
- en: The first channel is used to send small commands, such as updating a status
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个通道用于发送小命令，例如更新状态
- en: The second channel is used to send a large amount of data, such as a file transfer
    or even listing a directory
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个通道用于发送大量数据，例如文件传输或列出目录
- en: A funny thing about this second channel is that it's up to the client to decide
    whether the server connects to the client or vice versa. But in almost every case,
    the client asks the server to connect to him for a second time, and the server
    picks a port and they're good to go.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第二个通道的一个有趣之处在于，它取决于客户端决定是服务器连接到客户端还是反过来。但在几乎所有情况下，客户端都会要求服务器再次连接到它，服务器选择一个端口，然后就可以开始了。
- en: 'We can now say that we''re done with a quick introduction to FTP. If it still
    doesn''t seem perfectly clear at this point, no need to worry: it''ll become more
    obvious as we go through the implementation of the server.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以说，我们已经完成了对 FTP 的快速介绍。如果到现在为止仍然不太清楚，无需担心：随着我们逐步实现服务器，它将变得更加明显。
- en: So, let's start with a synchronous server implementation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从同步服务器实现开始。
- en: Implementing simple chunks of commands
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现简单的命令块
- en: 'Let''s start slowly by first creating a very simple server that sends `"hello"`
    to a new client and then closes the connection:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从创建一个非常简单的服务器开始，这个服务器向新客户端发送 `"hello"` 然后关闭连接：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Pretty easy, right? As usual, let''s explain what the code does:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？像往常一样，让我们解释一下代码的功能：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For those who don't know much about the network, the preceding line of code
    is the most important for any server
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不太了解网络的人来说，前面的代码行对于任何服务器来说都是最重要的。
- en: 'It tries to *book* the port for your server only. If another software is using
    it, then the `bind` call will fail. The given string represents the address and
    port we want to *book*. The argument works as follows: `[IP]:[PORT]`. Here, we
    entered `0.0.0.0:1234`, which means that we want the port `1234` on the address
    `0.0.0.0`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图只为你的服务器“预订”端口。如果其他软件正在使用它，那么 `bind` 调用将失败。给定的字符串表示我们想要“预订”的地址和端口。参数的作用如下：`[IP]:[PORT]`。在这里，我们输入了
    `0.0.0.0:1234`，这意味着我们想要在地址 `0.0.0.0` 上使用端口 `1234`。
- en: It might sound strange to allow a server to pick an IP address to use, but it's
    actually not the case. You can only choose between `localhost` (alias `127.0.0.1`)
    and `0.0.0.0`. The only difference between those two is that `0.0.0.0` allows
    other computers to connect to your own (if the port can be accessed from outside
    through the box provided by your internet access provider), whereas `127.0.0.1` can
    only be accessed from the computer it has been started on. But enough with network
    explanations—this isn't the point of this book, so let's move on!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 允许服务器选择要使用的 IP 地址听起来可能很奇怪，但实际上并非如此。你只能在这两个选项之间选择：`localhost`（别名 `127.0.0.1`）和
    `0.0.0.0`。这两个地址之间的唯一区别是，`0.0.0.0` 允许其他计算机连接到你的计算机（如果端口可以通过你的互联网接入提供商提供的盒子从外部访问），而
    `127.0.0.1` 只能从启动它的计算机访问。但是，关于网络的解释就到这里吧——这不是这本书的重点，所以让我们继续前进！
- en: 'The only other code that requires explanation is the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解释的另外一段代码如下：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `incoming` method call allows us to iterate infinitely on newly received
    connections by returning an iterator. Then, the `for` loop just calls the `next`
    method of the iterator.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`incoming` 方法调用允许我们通过返回一个迭代器无限迭代新接收到的连接。然后，`for` 循环只是调用迭代器的 `next` 方法。'
- en: That's it for this small code sample. Now it's time to improve all this!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短代码示例就到这里。现在，是时候改进所有这些了！
- en: 'It''d be nice to handle every client separately and not close the connection
    as soon as we receive a new connection, wouldn''t it? So, let''s just update the
    previous code a bit:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们想要分别处理每个客户端，而不是在收到新连接后立即关闭连接，不是吗？所以，我们只需更新一下之前的代码即可：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Every time a new client connects to the server, we spawn a new thread and send
    the client's socket into it. This way, we can now handle every client on its own.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每当新客户端连接到服务器时，我们会创建一个新的线程并将客户端的套接字发送给它。这样，我们现在可以单独处理每个客户端。
- en: Now that we can get new clients connected, it's time to actually start implementing
    the FTP part of our server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够连接新客户端了，是时候真正开始实现服务器中的 FTP 部分。
- en: Starting with basics
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从基础知识开始
- en: Of course, since we need to read and write on sockets, having to do that again
    and again in every function wouldn't be very efficient. Therefore, we'll start
    by implementing functions to do that. For now, we won't handle errors *nicely*
    (yes, `unwrap` is evil).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于我们需要在套接字上进行读写操作，如果在每个函数中都要重复这样做，那就不会很高效。因此，我们将首先实现执行这些操作的函数。目前，我们不会优雅地处理错误（是的，`unwrap`
    是邪恶的）。
- en: 'Let''s start with the `write` function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `write` 函数开始：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'OK, there''s nothing fancy nor difficult to understand here. However, take
    a look at this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里没有什么花哨的，也没有什么难以理解的。然而，看看这个：
- en: Every message ends with `""` in FTP
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 FTP 中，每条消息都以 `""` 结尾
- en: Every message has to be followed by a whitespace if you want to add parameters
    or information.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想添加参数或信息，每条消息后面都必须跟一个空格。
- en: This also works in the exact same way when a client sends us a command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发送命令给我们时，这也以完全相同的方式工作。
- en: 'What? Did I forget to provide you the `ResultCode` type? Indeed, you''re absolutely
    right. Here it is:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？我忘记提供 `ResultCode` 类型了吗？确实如此。这里就是：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Yep, not very beautiful... This is the exact representation of all FTP code
    types (errors, information, warnings, and so on). We can't do much better here;
    we have to rewrite all code so that we can understand it when we receive it and
    are able to give the correct code corresponding to the clients' commands.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，不是非常美观... 这正是所有 FTP 代码类型（错误、信息、警告等）的确切表示。在这里我们无法做得更好；我们必须重写所有代码，以便在接收到它时能够理解，并且能够给出与客户端命令相对应的正确代码。
- en: 'Now, I suppose, you can guess what''s coming next. The `enum Command` of course!
    This time, we''ll fulfill it while we move forward on to the implementation of
    the commands:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想，你可以猜到接下来会发生什么。当然，是 `enum Command`！这次，我们在前进到命令实现的过程中来完成它：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'OK, let''s get through this code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们通过这段代码：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Every time we add a new command handling, we''ll have to add a new variant
    to this `enum`. In case the command doesn''t exist (or we haven''t implemented
    it yet), `Unknown` will be returned with the command name. If the command is taking
    arguments, it''ll be added just like we saw for `Unknown`. Let''s take `Cwd` as
    an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们添加一个新的命令处理，我们都需要在这个 `enum` 中添加一个新的变体。如果命令不存在（或者我们还没有实现它），将返回带有命令名称的 `Unknown`。如果命令接受参数，它将被添加，就像我们为
    `Unknown` 所见的那样。以 `Cwd` 为例：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, `Cwd` contains a `PathBuf`. `Cwd` stands for **change working
    directory** and takes the path of the directory that the client wants to go to.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Cwd` 包含一个 `PathBuf`。`Cwd` 代表 **更改工作目录**，并接受客户端想要进入的目录路径。
- en: 'Of course, you''d need to update `as_ref` by adding the following line to the
    `match` block:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要通过在 `match` 块中添加以下行来更新 `as_ref`：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And you''d need to update the `new` method implementation by adding the following
    line into the `match` block:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要通过在 `match` 块中添加以下行来更新 `new` 方法的实现：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s explain the `AsRef` trait implementation. It''s very convenient
    when you want to write a generic function. Take a look at the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释 `AsRef` 特性的实现。当你想编写一个泛型函数时，这非常方便。看看下面的例子：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Thanks to this trait, as long as the type implements it, we can call `as_ref`
    on it. It's very useful in our case when sending messages to the client since
    we can just take a type implementing `AsRef`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个特性，只要类型实现了它，我们就可以调用 `as_ref`。在我们的情况下，当向客户端发送消息时，这非常有用，因为我们只需取一个实现了 `AsRef`
    的类型。
- en: 'Now let''s talk about the `new` method of the `Command` type:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来谈谈 `Command` 类型的 `new` 方法：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The point here is to convert the message received from the client. We need
    to do two things:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是将客户端接收到的消息进行转换。我们需要做两件事：
- en: Get the command
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取命令
- en: Get the command's arguments (if any)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取命令的参数（如果有）
- en: 'First, we create an iterator to split our vector, so we can separate the command
    from the arguments:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个迭代器来分割我们的向量，这样我们就可以将命令与参数分开：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we get the command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取命令：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, `command` is a `Vec<u8>`. To then make the matching easier (because
    nothing in the RFC of the FTP talks about the fact that commands should be in
    uppercase or that `auth` is the same as `AUTH` or even `AuTh`), we call the `uppercase`
    function, which looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，`command` 是一个 `Vec<u8>`。为了使匹配更简单（因为 FTP 的 RFC 中没有提到命令应该大写，也没有提到 `auth`
    与 `AUTH` 或 `AuTh` 相同），我们调用 `uppercase` 函数，其代码如下：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we get the arguments by calling `next` on the iterator `iter`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过在迭代器 `iter` 上调用 `next` 来获取参数：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If there are no arguments, no problem! We'll just get `None`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有参数，没问题！我们只需获取 `None`。
- en: 'Finally, we match the commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们匹配命令：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To do so, we convert our `Vec<u8>>` into a `&[u8]` (a slice of `u8`). To also
    convert a `&str` (such as `AUTH`) into a `&[u8]`, we use the `b` operator (which
    is more like saying to the compiler, *Hey! Don't worry, just say it's a slice
    and not a* `&str`*!*) to allow the matching.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将我们的 `Vec<u8>` 转换为 `&[u8]`（一个 `u8` 的切片）。为了将 `&str`（如 `AUTH`）也转换为 `&[u8]`，我们使用
    `b` 操作符（这更像是告诉编译器，“嘿！别担心，就把它说成是一个切片，而不是 `&str`！”）以允许匹配。
- en: 'And we''re good! We can now write the function to actually read the data from
    the client:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我们现在可以编写从客户端实际读取数据的函数了：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we read one byte at a time (and it's not a very efficient way to do so;
    we'll go back on this function later) and return when we get `""`. We have just
    added a little *security* by removing any whitespaces that would come before the
    command (so as long as we don't have any data in our vector, we won't add any
    whitespace).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们一次读取一个字节（这不是一个非常有效的方法；我们稍后会回到这个函数上）并在我们得到 `""` 时返回。我们通过删除任何可能出现在命令之前的空白字符增加了一点点
    *安全性*（只要我们的向量中没有数据，我们就不会添加任何空白字符）。
- en: If there is any error, we return an empty vector and stop the reading of the
    client input.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何错误，我们返回一个空向量并停止读取客户端输入。
- en: Like I said earlier, reading byte by byte isn't efficient, but is simpler to
    demonstrate how it works. So, for now, let's stick to this. This will be done
    completely differently once the asynchronous programming kicks in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我之前说的那样，逐字节读取并不高效，但更容易展示它是如何工作的。所以，现在，让我们坚持这个。一旦异步编程开始，这将被完全不同地完成。
- en: So, now that we can read and write FTP inputs it's time to actually start the
    implementation of the commands!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们可以读取和写入 FTP 输入，是时候真正开始实现命令了！
- en: 'Let''s start by creating a new structure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的结构：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here are some quick explanations for the preceding code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码的一些简要说明：
- en: '`cwd` stands for the current working directory'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cwd` 代表当前工作目录'
- en: '`stream` is the client''s socket'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream` 是客户端的套接字'
- en: '`name` is the username you got from user authentication (which doesn''t really
    matter, as we won''t handle authentication in the first steps)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是从用户认证中获得的用户名（实际上这并不重要，因为我们不会在第一步处理认证）'
- en: 'Now it''s time to update the `handle_client` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更新 `handle_client` 函数了：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When a new client connects to the server, we send them a message to inform them
    that the server is ready. Then we create a new `Client` instance, listen on the
    client socket, and handle its commands. Simple, right?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新客户端连接到服务器时，我们向他们发送一条消息，告知服务器已准备好。然后我们创建一个新的 `Client` 实例，监听客户端套接字，并处理其命令。简单，对吧？
- en: 'Two things are missing from this code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还缺少两个东西：
- en: The `Client::new` method
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client::new` 方法'
- en: The `Client::handle_cmd` method
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client::handle_cmd` 方法'
- en: 'Let''s start with the first one:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个开始：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Nothing fancy here; the current path is `"/"` (it corresponds to the root of
    the server, not to the root of the filesystem!). We have set the client's stream,
    and the name hasn't been defined yet.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的地方；当前路径是 `"/"`（它对应于服务器的根目录，而不是文件系统的根目录！）我们设置了客户端的流，而名称尚未定义。
- en: 'Now let''s see the `Client::handle_cmd` method (needless to say, it''ll be
    the core of this FTP server):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `Client::handle_cmd` 方法（不用说，这将是这个 FTP 服务器的核心）：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And that's it! Ok, so that's not really *it*. We still have a lot to add. But
    my point is, we now only have to add other commands here to make it all work.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！好吧，这还不是真正的 *it*。我们还有很多要添加。但我的观点是，我们现在只需要在这里添加其他命令，让一切都能正常工作。
- en: Commands implementation
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令实现
- en: In the previous code, we only handled one command; any other command will receive
    an `unknown command` answer from the server. Also, our `Auth` implementation says
    it's not implemented. So, to sum this up, we handle one command that answers that
    it's not implemented. Crazy, right? For the `Auth` command, we'll look at this
    later.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们只处理了一个命令；任何其他命令都会从服务器收到一个 `unknown command` 的回答。此外，我们的 `Auth` 实现表示它尚未实现。所以，总结一下，我们处理了一个回答它尚未实现的命令。疯狂，对吧？对于
    `Auth` 命令，我们稍后会看看。
- en: 'Now let''s implement some commands *for real*. Let''s start with a simple one:
    `Syst`. This is supposed to return which system this FTP server is running on.
    For some reason, we won''t answer that, and we''ll just send back an answer-nothing
    usable.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们真正实现一些命令。让我们从一个简单的命令开始：`Syst`。这个命令本应返回这个 FTP 服务器正在运行的系统。出于某种原因，我们不会回答这个问题，我们只会发送一个没有用处的回答。
- en: Implementing the SYST command
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 SYST 命令
- en: 'First, let''s add a new entry into the `Command` enum (I won''t do this every
    time, but the steps will remain the same):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `Command` 枚举中添加一个新的条目（我不会每次都这样做，但步骤将是相同的）：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, let''s update the `as_ref` implementation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们更新 `as_ref` 实现：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, let''s update the `Command::new` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新 `Command::new` 方法：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That's it! Like I said earlier, just remember those three steps every time you
    add a new command and everything should be fine.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！就像我之前说的那样，每次添加新命令时，只要记住这三个步骤，一切应该都会顺利。
- en: 'Now let''s implement the command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现这个命令：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And that's it! We implemented a new command (which doesn't do much, but that
    isn't the point)!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们实现了一个新的命令（它并不做什么，但这不是重点）！
- en: Implementing the USER command
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 USER 命令
- en: Since we have a `name` in our `Client` structure, it'd be nice to have some
    use for it, right? So, as the title says, let's implement the `USER` command.
    Since this command takes an argument, I'll go through the command implementation
    steps once again, so you'll have an example of a command taking a parameter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`Client`结构中有`name`，那么让它有点用会很好，对吧？所以，正如标题所说，让我们实现`USER`命令。因为这个命令接受一个参数，所以我将再次通过命令实现步骤，这样你就有了一个接受参数的命令的例子。
- en: 'First, let''s update the `enum Command`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新`enum Command`：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we update the `as_ref` implementation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更新`as_ref`实现：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we update the `Command::new` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新`Command::new`方法：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Phew, all done! Now we just need to implement the function (which is quite
    simple, I promise):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼，一切都完成了！现在我们只需要实现这个函数（我保证它很简单）：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here's a little explanation just in case you need it; if we receive an empty
    username (or no username at all), we consider this as an invalid parameter and
    return `InvalidParameterOrArgument`. Otherwise, everything is fine and we return
    `UserLoggedIn`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的解释，以防你需要；如果我们收到一个空的用户名（或者完全没有用户名），我们将其视为无效参数并返回`InvalidParameterOrArgument`。否则，一切正常，我们返回`UserLoggedIn`。
- en: If you're wondering why we didn't return `ResultCode::Ok`, it's because the
    RFC states as such. Once again, every command, what it does, and what it should
    return is described there. If you feel lost, don't hesitate to read it again!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我们没有返回`ResultCode::Ok`，那是因为RFC是这样规定的。再次强调，每个命令、它做什么以及它应该返回什么都在那里描述。如果你感到困惑，不要犹豫，再读一遍！
- en: Implementing the NOOP command
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 NOOP 命令
- en: 'This topic is quite a simple one. `NOOP` stands for no operation. It takes
    no argument and does nothing. Just because I''m a nice person, here''s the code
    for the `NOOP` command in the `Client::handle_cmd` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题相当简单。`NOOP`代表无操作。它不接受任何参数也不做任何事情。因为我是个好人，所以这里提供了`Client::handle_cmd`方法中`NOOP`命令的代码：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Yes, I know, you're amazed by such wonderful code. But don't worry, you'll able
    to write something as good as this when you grow older!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道，你被这样的代码惊呆了。但别担心，当你长大的时候，你也能写出这样好的代码！
- en: It's now time to implement the next command!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现下一个命令了！
- en: Implementing the PWD command
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 PWD 命令
- en: This command is very simple as well. `PWD` stands for print working directory.
    Once again, it's not the one from your system but the one from your server (so
    again, `"/"` corresponds to the folder where you started the server).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令也很简单。`PWD`代表打印工作目录。再一次，它不是来自你的系统，而是来自你的服务器（所以，`"/"`对应于你启动服务器时的文件夹）。
- en: 'The command doesn''t take any argument, so there''s no need to show you everything
    again. Let''s just focus on the command handling:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令不接受任何参数，所以没有必要再次展示所有内容。让我们只关注命令处理：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Nothing complicated; we try to display the path, and if we fail, we return an
    error. The only strange thing is that if everything goes fine, we have to return
    `PATHNAMECreated`. This RFC is really strange...
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么复杂的；我们尝试显示路径，如果失败，我们返回一个错误。唯一奇怪的是，如果一切顺利，我们必须返回`PATHNAMECreated`。这个RFC真的很奇怪...
- en: Sorry, this was the last *simple* command. Now we'll go deeper into the FTP
    and its strange RFC. The following command is just a nice introduction to what's
    coming next. (I hope I didn't scare you!)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对不起，这是最后一个*简单*的命令。现在我们将更深入地探讨FTP及其奇怪的RFC。接下来的命令是对接下来要发生的事情的一个很好的介绍。（我希望我没有吓到你！）
- en: Implementing the TYPE command
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 TYPE 命令
- en: For now, we'll have an implementation of the `TYPE` command that does nothing.
    We'll come back to it in the following chapters. However, a bit of explanation
    will come in handy, I assume.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将实现一个不做什么的`TYPE`命令。我们将在接下来的章节中回到它。然而，一些解释可能会很有用，我想。
- en: '`TYPE` stands for the representation type. When you''re transferring data over
    the data connection (which is different from the command connection, which is
    the only one we''ve been using until now), you can transfer data differently.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`TYPE`代表表示类型。当你通过数据连接（与命令连接不同，我们直到现在只使用命令连接）传输数据时，你可以以不同的方式传输数据。'
- en: By default, the transfer type is ASCII (the main difference is that all `""`
    have to be transformed into `""`). We'll use the image one (where you send data
    as you have it) to make our lives easier.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，传输类型是ASCII（主要区别在于所有的`""`都必须转换为`""`）。我们将使用图像类型（其中你发送数据就像你拥有它一样）来简化我们的工作。
- en: Once again, we'll go back to this implementation in later chapters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将在后面的章节中回到这个实现。
- en: 'For now, let''s just add a `Type` command that doesn''t take any argument:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们只添加一个不接受任何参数的`Type`命令：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: OK, we're lying a bit, but we'll have to deal with it for the moment.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们有点撒谎，但我们现在不得不处理它。
- en: We're almost at the end of the basics, but there's one last command to implement
    before you can try accessing the server using an FTP client.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了基础知识，但在你能够尝试使用FTP客户端访问服务器之前，还有一个命令需要实现。
- en: Implementing the LIST command
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 LIST 命令
- en: The `LIST` command returns a list of the current files and folders of the current
    folder or at the given parameter path. This is already very difficult itself because
    you need to check that the *final* path is accessible to the user (for example,
    if you receive `foo/../../` when you're at `"/"`, there's an issue). But that's
    not all! When you're transferring the files and folders list, there is no official
    way to format it! Fun, right? Luckily, most of the FTP clients follow some kind
    of non-official RFC for this case, and we'll use it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIST` 命令返回当前文件夹或给定参数路径下的当前文件和文件夹列表。这本身就已经非常困难，因为你需要检查用户是否有权访问*最终*路径（例如，如果你在`"/"`时收到`foo/../../`，那么会有问题）。但这还不是全部！当你传输文件和文件夹列表时，没有官方的方式来格式化它！有趣，对吧？幸运的是，大多数FTP客户端都会遵循某种非官方的RFC来处理这种情况，我们将使用它。'
- en: 'In addition to all of this, this command is the first one that we''ll implement
    that uses the data connection. This requires you to add another command: `PASV`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些之外，这个命令是我们将实现的第一条使用数据连接的命令。这需要你添加另一个命令：`PASV`。
- en: Implementing the PASV command
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 PASV 命令
- en: 'To be able to make this command work, we need to add a few new fields in our
    `Client` struct:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个命令能够工作，我们需要在我们的`Client`结构体中添加一些新的字段：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We now need to update the `Client::new` method as well:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要更新`Client::new`方法：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `PASV` command doesn''t take arguments, so I''ll let you add it to the
    structures and everything. Let''s focus on the interesting part:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`PASV`命令不接受任何参数，所以我会让你把它添加到结构和所有内容中。让我们关注有趣的部分：'
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Phew... Let''s explain all this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 呼……让我们解释一下这一切：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we already have a data connection with this client, there''s no need to
    open a new one, so we don''t do anything else:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们与这个客户端已经有了数据连接，就没有必要打开一个新的，所以我们不做任何事情：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This part is a bit more tricky. First, we pick a port (the best way would be
    to check if the port is available first; we'll do this in later chapters). Then,
    we have to tell the client *where* it should connect to.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分有点棘手。首先，我们选择一个端口（最好的方式是先检查端口是否可用；我们将在后面的章节中这样做）。然后，我们必须告诉客户端*它应该连接到哪*。
- en: 'This is where things get a bit more complicated. We have to transfer the address
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里事情变得有点复杂。我们必须按照以下方式传输地址：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Every `ip` part has to be 8-bits long (so 1-byte long), whereas, each `port`
    part has to be 16-bits long (so, 2 bytes). The first part is easy; we just print
    localhost. However, the second part requires you to perform some binary operation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`ip`部分都必须是8位长（所以是1字节长），而每个`port`部分都必须是16位长（所以是2字节）。第一部分很简单；我们只需要打印localhost。然而，第二部分需要你执行一些二进制操作。
- en: 'To get the first byte only is simple; we just have to move 8 bits to the right.
    To sum this up, take a look at this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 只获取第一个字节很简单；我们只需要将8位向右移动。总结一下，看看这个：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is our `u16`. We now shift 8 bits to the right:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`u16`。我们现在将8位向右移动：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Tadaa!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！
- en: 'For the second part, we could move 8 bits to the left and then 8 bits to the
    right, or we could just use the `and` binary operator. Here''s a little scheme
    to explain this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二部分，我们可以将8位向左移动然后向右移动8位，或者我们可以直接使用`and`二进制运算符。这里有一个小方案来解释这一点：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now let''s take a nice binary to the hexadecimal converter and check the result:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用一个漂亮的二进制到十六进制的转换器来检查结果：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now if we perform this operation, we get the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们执行这个操作，会得到以下结果：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we have the last 8 bits only. Great! The last part of the command handling
    is very easy:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有最后8位。太好了！命令处理的最后一部分非常简单：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We bind the address and port, wait for a client to connect, and then assign
    it to our data writer. There's nothing problematic in this.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绑定地址和端口，等待客户端连接，然后将它分配给我们的数据写入器。这里没有问题。
- en: Back to the LIST command
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到`LIST`命令
- en: 'Now that we can handle a data connection, let''s implement the `LIST`! For
    now, let''s implement it without parameters (once again, we''ll see in later chapters
    how to handle the `LIST` parameter). As usual, I''ll let you add everything where
    it''s needed and we''ll just focus on the command handling:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够处理数据连接了，让我们来实现`LIST`命令！目前，我们先不添加参数来实现它（就像之前一样，我们将在后面的章节中看到如何处理`LIST`参数）。像往常一样，我会让你在需要的地方添加所有内容，我们只关注命令处理：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'There''s nothing complicated here either too. Once the transfer is over, we
    close the client socket and move on. What remains to be added are the `send_data`
    and the `add_file_info` functions. Let''s start with the first one:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也没有什么复杂的。一旦传输完成，我们就关闭客户端套接字并继续。需要添加的是`send_data`和`add_file_info`函数。让我们从第一个开始：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Easy, there''s no error handling, so it just stands on one line. Now let''s
    see the `add_file_info` function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，没有错误处理，所以它只占一行。现在让我们看看`add_file_info`函数：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To make this code work, you''ll also need the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这段代码工作，你还需要以下内容：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Don''t forget to add `cfg_if` in your `Cargo.toml`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在你的`Cargo.toml`中添加`cfg_if`：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`cfg-if` is really good at help you do conditional compilation in a more easily
    readable way. A point to note about the `get_file_info` function now—this is one
    of the rare things that can''t be performed in the same way on all systems.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`cfg-if`非常擅长以更易于阅读的方式帮助你进行条件编译。现在要注意关于`get_file_info`函数的一个点——这是在所有系统上都不能以相同方式执行的一件稀少的事情。'
- en: 'Here, Windows has its own version and Unix has another. However, the two functions
    take the same argument (the import), and one function call changes. Let''s go
    back to the `add_file_info` function now:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，Windows有自己的版本，Unix有另一个。然而，这两个函数接受相同的参数（导入），一个函数调用就改变了。现在让我们回到`add_file_info`函数：
- en: 'I suppose you recognized the output of the `ls` command, right? Apparently,
    the non-official RFC is working as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你已经认出了`ls`命令的输出，对吧？显然，非官方的RFC是这样工作的：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'First, `d` if it''s a directory or `-` if it isn''t. Then, the rights (just
    like on Unix platforms):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果是目录则用`d`表示，如果不是则用`-`表示。然后是权限（就像在Unix平台上一样）：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first `rwx` is for the owner, the second is about the group, and the last
    one is about everyone. Here, `r` stands for read access, `w` stands for write
    access, and `x` stands for execution access.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`rwx`是关于所有者的，第二个是关于组的，最后一个是关于所有人的。在这里，`r`代表读取权限，`w`代表写入权限，`x`代表执行权限。
- en: The rest seems explicit enough on its own, so there's no need to explain it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的部分似乎已经很明确了，所以没有必要解释它。
- en: Implementing the CWD command
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`CWD`命令
- en: The `CWD` command allows the user to change its current folder location. However,
    it's far from easy to do.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`CWD`命令允许用户更改其当前文件夹位置。然而，这并不容易做到。'
- en: 'Before going into the implementation of this command, we''ll need to discuss
    a potential security issue: paths.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入这个命令的实现之前，我们需要讨论一个潜在的安全问题：路径。
- en: Imagine the user is at the `"/"` location (which will corresponds to, say, `/home/someone/somewhere`)
    and requests `foo/../../`. If we just accept the path and move the user to this
    location, it'll end up at `/home/someone`. This means that the users could access
    all of your computer without issue. You see the problem now?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下用户在`"/"`位置（这相当于，比如说，`/home/someone/somewhere`）并请求`foo/../../`。如果我们只是接受路径并将用户移动到这个位置，它将结束在`/home/someone`。这意味着用户可以无障碍地访问你的电脑的所有内容。你现在看到问题了吗？
- en: Luckily for us, `Rust` has a nice method on `Path` that allows us to fix this
    huge security issue. I'm talking about `Path::canonicalize` (which is an alias
    of the `fs::canonicalize` function).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`Rust`在`Path`上有一个很好的方法，允许我们修复这个巨大的安全问题。我说的就是`Path::canonicalize`（它是`fs::canonicalize`函数的别名）。
- en: 'So, what does this function do? Let''s take an example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个函数做什么呢？让我们举一个例子：
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, it interprets the path, normalizes everything (`..` removes
    the folder component), and resolves symbolic links as well. Quite magical, right?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它解释了路径，规范化了一切（`..`移除了文件夹组件），并且还解析了符号链接。相当神奇，对吧？
- en: 'Of course, all good things have a downside, and so does `canonicalize`.: it
    can only work on *real* paths. If a part of the path doesn''t exist, the function
    will just fail. It''s pretty easy to get through it when you know it, but it can
    sound surprising at first.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有美好的事物都有其缺点，`canonicalize`也不例外：它只能作用于*真实*路径。如果路径的一部分不存在，函数将直接失败。当你了解这一点时，处理起来很简单，但一开始可能会感到惊讶。
- en: So, how do we fix this? Well, we need to play with a real path. So first, we
    need to append the user's server path to the real server path (the one it has
    on the computer). Once this is done, we just append the path requested by the
    user and call `canonicalize`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解决这个问题呢？嗯，我们需要处理一个真实路径。所以首先，我们需要将用户的服务器路径追加到真实服务器路径（它在计算机上的那个路径）。一旦完成，我们只需追加用户请求的路径并调用`canonicalize`。
- en: That's not very complicated, but is a bit annoying to play with at first. Don't
    worry, though, the code is coming!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不复杂，但一开始操作起来有点烦人。不过，别担心，代码马上就来！
- en: If you wonder why we're not just using the `chroot` function (which would solve
    all problems), remember that this FTP server is supposed to work on every platform.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我们不直接使用`chroot`函数（这将解决所有问题），请记住，这个FTP服务器应该在每个平台上都能工作。
- en: 'So first, let''s add a new command entry to the `enum Command` :'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所以首先，让我们向`enum Command`添加一个新的命令条目：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Good, now let''s add it to the `Command::new` method matching:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们将其添加到`Command::new`方法的匹配中：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Perfect! I''ll let you add it into the `AsRef` implementation as well. Now
    it''s time to go into the *real* implementation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我将让你也把它添加到`AsRef`实现中。现在是我们进入*真正*实现的时候了：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For once, to make our life easier, we''ll create a new method in our `Client`,
    so all the code from the `CWD` command won''t fill the `enum`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一次，为了使我们的工作更简单，我们将在我们的`Client`中创建一个新的方法，这样`CWD`命令的所有代码就不会填充`enum`：
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'OK, that''s a lot of code. Let''s now go through the execution flow:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，代码有点多。现在让我们看看执行流程：
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For now, you can''t set which folder the server is running on; it''ll be changed
    later on:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你无法设置服务器运行在哪个文件夹；这将在以后更改：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'First, we join the requested directory to the current directory of the user:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将请求的目录与用户的当前目录连接起来：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Things start to get funny in here. The whole canonicalization process is in
    there.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里开始变得有趣。整个规范化过程都在这里。
- en: 'Now let''s append the user path to the (real) server path:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将用户路径追加到（真实）服务器路径上：
- en: '[PRE64]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So, if the path is an absolute one (starting with `"/"` on Unix or a prefix
    on Windows such as `c:`), we need to remove the first component of the path, otherwise,
    we just append it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果路径是绝对路径（在Unix中以`"/"`开头或在Windows中以如`c:`这样的前缀开头），我们需要移除路径的第一个组件，否则我们只需追加它。
- en: 'We now have a full and potentially existent path. Let''s canonicalize it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个完整且可能存在的路径。让我们将其规范化：
- en: '[PRE65]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now we have one more thing to check—if the path doesn''t start with the server
    root, then it means that the user tried to cheat on us and tried to access non-accessible
    folders. Here is how we do it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还有一件事要检查——如果路径不以服务器根目录开头，那么这意味着用户试图欺骗我们，试图访问不可访问的文件夹。下面是我们的做法：
- en: '[PRE66]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the case that `canonicalize` returned an error, there's no need to check
    if it did (since it's already an error). If it succeeded but doesn't start with
    `server_root`, then we return an error.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`canonicalize`返回了错误，没有必要检查它是否已经是一个错误（因为它已经是一个错误了）。如果它成功了但不是以`server_root`开头，那么我们返回一个错误。
- en: 'That''s it for this function. Now, we''ll return the result to the caller and
    can go back to the `cwd` method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数就到这里。现在，我们将结果返回给调用者，并可以回到`cwd`方法：
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Once we get the full directory path and have confirmed it was okay, we need
    to remove the `server_root` prefix to get the path from our server root:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了完整的目录路径并确认它是正确的，我们需要移除`server_root`前缀以从我们的服务器根目录获取路径：
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Finally, once this is done, we can just set the path to the user and send back
    a message that the command succeeded (and return to avoid sending back that we
    failed!).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦完成这些，我们只需将路径设置给用户，并发送一条消息表示命令成功（并返回以避免发送失败的消息！）。
- en: 'If anything goes wrong, we send back the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何问题发生，我们发送以下内容：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: That's it for this command! You now know how to avoid a security issue by checking
    received paths provided by the clients.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令就到这里了！你现在知道如何通过检查客户端提供的接收路径来避免安全问题。
- en: Implementing the CDUP command
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CDUP命令
- en: '`CDUP` is used to go up to the parent directory. In comparison to the `CWD`
    command implementation, it''ll be a piece of cake! The `CDUP` command doesn''t
    take arguments, so I''ll let you add it to `enums`. Now, let''s focus on the command
    implementation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`CDUP`用于进入父目录。与`CWD`命令实现相比，这将是一件轻而易举的事情！`CDUP`命令不需要参数，所以我会让你将它添加到`enums`中。现在，让我们专注于命令实现：'
- en: '[PRE70]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: And that's it. There's need to check if the parent folder exists, as it does.
    And if we're already at the root, then there's no need to do anything. Isn't it
    wonderful?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。没有必要检查父文件夹是否存在，因为它确实需要。如果我们已经在根目录，那么就没有必要做任何事情。这不是很棒吗？
- en: Full implementation of the LIST command
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LIST命令的完整实现
- en: Now that we know how to play with paths nicely, it'd be a shame not fully implement
    the `LIST` command, right?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何优雅地处理路径，不完整实现`LIST`命令真是太遗憾了，对吧？
- en: To complete it, you'll need to update the `Command::List` variant in order to
    make it accept `PathBuf` as an argument.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成它，你需要更新`Command::List`变体，以便它能够接受`PathBuf`作为参数。
- en: 'So, we currently have the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在有以下代码：
- en: '[PRE71]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s update it as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式更新它：
- en: '[PRE72]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To put it simply, we just added the following line:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们只是添加了以下这一行：
- en: '[PRE73]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Thanks to the `Client::complete_path` method, things were pretty easy with
    the path manipulation. So, what happens if the given path is a file? We don''t
    check such a case but we should! Let''s replace the following lines:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`Client::complete_path`方法，路径操作变得相当简单。那么，如果给定的路径是一个文件会发生什么呢？我们没有检查这种情况，但我们应该检查！让我们替换以下这些行：
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'With:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用：
- en: '[PRE75]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: And that's it! Luckily for us, we did things correctly the first time, so *it
    just works*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！幸运的是，我们第一次就做对了，所以*它就是那么简单有效*。
- en: Implementing the MKD command
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现MKD命令
- en: 'The `MKD` stands for make directory (yes, exactly like the Unix command but
    shorter). Just like `LIST` and `CWD`, it takes `PathBuf` as an argument. I''ll
    let you handle the other adds as usual and focus on the command implementation:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`MKD`代表创建目录（是的，确实就像Unix命令一样，但更短）。就像`LIST`和`CWD`一样，它需要一个`PathBuf`作为参数。我会让你像往常一样处理其他添加，并专注于命令实现：'
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Just like last time, we''ll create a new method:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上次一样，我们将创建一个新的方法：
- en: '[PRE77]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Once again, a few things have to be done before even actually trying to make
    the directory.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在真正尝试创建目录之前，还有一些事情要做。
- en: First, we need to check whether all the elements of the given path are folders
    (well, only the last one in fact since otherwise, the `Client::complete_path`
    method will fail otherwise).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查给定路径的所有元素是否都是文件夹（实际上，只有最后一个元素是，否则`Client::complete_path`方法将失败）。
- en: Then we need to once again, canonicalize this path (by calling the `Client::complete_path`
    method). Finally, we push the filename to the received path.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要再次，通过调用`Client::complete_path`方法来规范化这个路径。最后，我们将文件名推送到接收到的路径。
- en: The main difference here is that we don't strip the `server_root` path from
    the path returned by `Client::complete_path`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别是我们没有从`Client::complete_path`返回的路径中去除`server_root`路径。
- en: Once all of this is done, we can try to create the folder by using the `create_dir`
    function. If it goes well, we then return `ResultCode::PATHNAMECreated` (and for
    once it makes sense!).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成所有这些，我们就可以尝试使用`create_dir`函数来创建文件夹。如果一切顺利，我们就返回`ResultCode::PATHNAMECreated`（而且这一次它确实有道理！）。
- en: If any error occurs at any level, we just send that the path was incorrect.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何级别发生错误，我们只需发送路径不正确的信息。
- en: That's it for this command!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令就到这里了！
- en: Implementing the RMD command
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现RMD命令
- en: Now that we can create folders, it'd be nice to be able to remove them, right?
    That's what `RMD` (which stands for *remove directory*) is supposed to do!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建文件夹了，能够删除它们会更好，对吧？这就是`RMD`（代表*删除目录*）应该做的！
- en: 'Just like `MKD` (and the others), `RMD` takes `PathBuf` as an argument. Once
    again, and as usual, I''ll let you handle the `Command` part so we can focus on
    the command implementation:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`MKD`（和其他命令）一样，`RMD`需要一个`PathBuf`作为参数。再一次，像往常一样，我会让你处理`Command`部分，这样我们就可以专注于命令实现：
- en: '[PRE78]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Yep, it's a new method once again. It becomes a habit at this point I suppose?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这又是一个新方法。我想这已经变成了一种习惯？
- en: '[PRE79]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: And that's it! This is even easier than `MKD` since we don't need to check if
    the last potential parent is a folder. Once we have confirmed that the path was
    an authorized one, we can just remove it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这比`MKD`还要简单，因为我们不需要检查最后一个可能的父文件夹是否是文件夹。一旦我们确认路径是授权的，我们就可以直接删除它。
- en: With all these commands, I think we can say that we have a very fine base to
    build upon in order to make a complete FTP server.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有这些命令，我认为我们可以这样说，我们有一个非常好的基础来构建一个完整的 FTP 服务器。
- en: Testing it
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试它
- en: You now have a (very) basic FTP server implementation. You can connect to the
    server and list the files and folders in the current folder.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个（非常）基本的 FTP 服务器实现。您可以连接到服务器并列出当前文件夹中的文件和文件夹。
- en: 'Start it with  `cargo run` and give it a try! I recommend that you use `FileZilla`.
    This is a great FTP client. Connect to `localhost` on the port `1234` and use
    the `anonymous` username (or none), and you should be able to have a bit of fun
    already:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cargo run` 启动它并尝试一下！我建议您使用 `FileZilla`。这是一个优秀的 FTP 客户端。在端口 `1234` 上连接到 `localhost`，并使用
    `anonymous` 用户名（或无），你应该已经可以有点乐趣了：
- en: '![](img/00042.jpeg)*Figure 8.1*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1](img/00042.jpeg)*图 8.1*'
- en: Information on the file transfers and additional commands will be covered in
    later chapters.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 文件传输和附加命令的信息将在后续章节中介绍。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the basics of the FTP. We now have a simple (synchronous)
    server implementation, and you should have a good idea about how all of this is
    working. We also looked at a potential security issue and how to fix it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 FTP 的基础知识。我们现在有一个简单的（同步）服务器实现，你应该对这一切是如何工作的有一个很好的了解。我们还探讨了一个潜在的安全问题以及如何修复它。
- en: The following chapters will introduce you to asynchronous programming in Rust.
    Thanks to this chapter, it'll go a lot quicker on the FTP RFC side so we can focus
    on the asynchronous part.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将向您介绍 Rust 中的异步编程。多亏了本章，FTP RFC 方面的学习将会更快，这样我们就可以专注于异步部分。
