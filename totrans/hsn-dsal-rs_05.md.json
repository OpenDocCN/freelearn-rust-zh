["```rs\ntype Tree = Option<Box<Node>>;\n\nstruct Node {\n    pub value: u64,\n    left: Tree,\n    right: Tree,\n}\n```", "```rs\npub struct BinarySearchTree {\n    root: Tree,\n    pub length: u64,\n}\n```", "```rs\n#[derive(Clone, Debug)]\npub struct IoTDevice {\n    pub numerical_id: u64,\n    pub address: String,\n}\n```", "```rs\ntype Tree = Option<Box<Node>>;\nstruct Node {\n    pub dev: IoTDevice,\n    left: Tree,\n    right: Tree,\n}\n```", "```rs\n  1\n/  \\ \n     2\n   /   \\\n         3\n       /   \\ \n             4 \n```", "```rs\npub fn add(&mut self, device: IoTDevice) {\n    self.length += 1;\n    let root = mem::replace(&mut self.root, None);\n    self.root = self.add_rec(root, device);\n}\n\nfn add_rec(&mut self, node: Tree, device: IoTDevice) -> Tree {\n    match node {\n        Some(mut n) => {\n            if n.dev.numerical_id <= device.numerical_id {\n                n.left = self.add_rec(n.left, device);\n                Some(n)\n            } else {\n                n.right = self.add_rec(n.right, device);\n                Some(n)\n            }\n        }\n        _ => Node::new(device),\n    }\n}\n```", "```rs\npub fn find(&self, numerical_id: u64) -> Option<IoTDevice> {\n    self.find_r(&self.root, numerical_id)\n}\n\nfn find_r(&self, node: &Tree, numerical_id: u64) -> Option<IoTDevice> {\n    match node {\n        Some(n) => {\n            if n.dev.numerical_id == numerical_id {\n                Some(n.dev.clone())\n            } else if n.dev.numerical_id < numerical_id {\n                self.find_r(&n.left, numerical_id)\n            } else {\n                self.find_r(&n.right, numerical_id)\n            }\n        }\n        _ => None,\n    }\n}\n```", "```rs\npub fn walk(&self, callback: impl Fn(&IoTDevice) -> ()) {   \n    self.walk_in_order(&self.root, &callback);\n}\n\nfn walk_in_order(&self, node: &Tree, callback: &impl Fn(&IoTDevice) -> ()) {\n    if let Some(n) = node {\n        self.walk_in_order(&n.left, callback);\n        callback(&n.dev);\n        self.walk_in_order(&n.right, callback);\n    }\n}\n```", "```rs\nlet my_devices: RefCell<Vec<IoTDevice>> = RefCell::new(vec![]); tree.walk(|n| my_devices.borrow_mut().push(n.clone()));\n```", "```rs\ntest tests::bench_sorted_insert_bst_find ... bench: 16,376 ns/iter (+/- 6,525)\ntest tests::bench_unsorted_insert_bst_find ... bench: 398 ns/iter (+/- 182)\n```", "```rs\n\npub fn is_a_valid_red_black_tree(&self) -> bool {\n    let result = self.validate(&self.root, Color::Red, 0);\n    let red_red = result.0;\n    let black_height_min = result.1;\n    let black_height_max = result.2;\n    red_red == 0 && black_height_min == black_height_max\n}\n\n// red-red violations, min black-height, max-black-height\nfn validate(\n    &self,\n    node: &Tree,\n    parent_color: Color,\n    black_height: usize,\n) -> (usize, usize, usize) {\n    if let Some(n) = node {\n        let n = n.borrow();\n        let red_red = if parent_color == Color::Red && n.color == Color::Red {\n            1\n        } else {\n            0\n        };\n        let black_height = black_height + match n.color {\n            Color::Black => 1,\n            _ => 0,\n        };\n        let l = self.validate(&n.left, n.color.clone(), black_height);\n        let r = self.validate(&n.right, n.color.clone(), black_height);\n        (red_red + l.0 + r.0, cmp::min(l.1, r.1), cmp::max(l.2, r.2))\n    } else {\n        (0, black_height, black_height)\n    }\n}\n```", "```rs\ntype BareTree = Rc<RefCell<Node>>;\ntype Tree = Option<BareTree>;\n\nstruct Node {\n    pub color: Color,\n    pub key: u32,\n    pub parent: Tree,\n    left: Tree,\n    right: Tree,\n}\n```", "```rs\ntype BareTree = Rc<RefCell<Node>>;\ntype Tree = Option<BareTree>;\n\nstruct Node {\n    pub color: Color,\n    pub dev: IoTDevice,\n    pub parent: Tree,\n    left: Tree,\n    right: Tree,\n}\n\nimpl Node {\n    pub fn new(dev: IoTDevice) -> Tree {\n        Some(Rc::new(RefCell::new(Node {\n            color: Color::Red,\n            dev: dev,\n            parent: None,\n            left: None,\n            right: None,\n        })))\n    }\n}\n```", "```rs\n#[derive(Clone, Debug, PartialEq)]\nenum Color {\n    Red,\n    Black,\n}\n\n#[derive(PartialEq)]\nenum RBOperation {\n    LeftNode,\n    RightNode,\n}\n```", "```rs\npub fn add(&mut self, device: IoTDevice) {\n    self.length += 1;\n    let root = mem::replace(&mut self.root, None);\n    let new_tree = self.add_r(root, device);\n    self.root = self.fix_tree(new_tree.1);\n}\n\nfn add_r(&mut self, mut node: Tree, device: IoTDevice) -> (Tree, BareTree) {\n    if let Some(n) = node.take() {\n        let new: BareTree;\n        let current_device = n.borrow().dev.clone();\n\n        match self.check(&current_device, &device) {\n            RBOperation::LeftNode => {\n                let left = n.borrow().left.clone();\n                let new_tree = self.add_r(left, device);\n                new = new_tree.1;\n                let new_tree = new_tree.0.unwrap();\n                new_tree.borrow_mut().parent = Some(n.clone());\n                n.borrow_mut().left = Some(new_tree);\n            }\n\n            RBOperation::RightNode => {\n                let right = n.borrow().right.clone();\n                let new_tree = self.add_r(right, device);\n                new = new_tree.1;\n                let new_tree = new_tree.0.unwrap();\n\n                new_tree.borrow_mut().parent = Some(n.clone());\n                n.borrow_mut().right = Some(new_tree);\n            }\n        }\n        (Some(n), new)\n    } else {\n        let new = Node::new(device);\n        (new.clone(), new.unwrap())\n    }\n}\n```", "```rs\nfn check(&self, a: &IoTDevice, b: &IoTDevice) -> RBOperation {\n    if a.numerical_id <= b.numerical_id {\n        RBOperation::LeftNode\n    } else {\n        RBOperation::RightNode\n    }\n}\n```", "```rs\nfn fix_tree(&mut self, inserted: BareTree) -> Tree {\n    let mut not_root = inserted.borrow().parent.is_some();\n\n    let root = if not_root {\n        let mut parent_is_red = self.parent_color(&inserted) == Color::Red;\n        let mut n = inserted.clone();\n        while parent_is_red && not_root {\n            if let Some(uncle) = self.uncle(n.clone()) {\n```", "```rs\n           if let Some(uncle) = self.uncle(n.clone()) {\n                let which = uncle.1;\n                let uncle = uncle.0;\n\n                match which {\n                    RBOperation::LeftNode => {\n                        // uncle is on the left\n                        // ...\n\n                    RBOperation::RightNode => {\n                        // uncle is on the right\n                        // ...\n```", "```rs\n                        // uncle is on the left\n                        let mut parent = n.borrow().parent\n                                         .as_ref().unwrap().clone();\n                        if uncle.is_some()\n                            && uncle.as_ref().unwrap().borrow()\n                               .color == Color::Red\n                        {\n                            let uncle = uncle.unwrap();\n                            parent.borrow_mut().color = Color::Black;\n                            uncle.borrow_mut().color = Color::Black;\n                            parent.borrow().parent.as_ref()\n                              .unwrap().borrow_mut().color =\n                                                        Color::Red;\n\n                            n = parent.borrow().parent.as_ref()\n                                 .unwrap().clone();\n                        } else {\n                            if self.check(&parent.borrow().dev, \n                                          &n.borrow().dev)\n                                            == RBOperation::LeftNode\n                            {\n                                // do only if it's a right child\n                                let tmp = n.borrow().parent.as_ref()\n                                          .unwrap().clone();\n                                n = tmp;\n                                self.rotate(n.clone(), \n                                Rotation::Right);\n                                parent = n.borrow().parent.as_ref()\n                                         .unwrap().clone();\n                            }\n                            // until here. then for all black uncles\n                            parent.borrow_mut().color = Color::Black;\n                            parent.borrow().parent.as_ref()\n                              .unwrap().borrow_mut().color =\n                                                     Color::Red;\n                            let grandparent = n\n                                .borrow()\n                                .parent\n                                .as_ref()\n                                .unwrap()\n                                .borrow()\n                                .parent\n                                .as_ref()\n                                .unwrap()\n                                .clone();\n                            self.rotate(grandparent, Rotation::Left);\n                        }\n```", "```rs\n            not_root = n.borrow().parent.is_some();\n            if not_root {\n                parent_is_red = self.parent_color(&n) == Color::Red;\n            }\n        }\n        while n.borrow().parent.is_some() {\n            let t = n.borrow().parent.as_ref().unwrap().clone();\n            n = t;\n        }\n        Some(n)\n    } else {\n        Some(inserted)\n    };\n    root.map(|r| {\n        r.borrow_mut().color = Color::Black;\n        r\n    })\n```", "```rs\npub fn find(&self, numerical_id: u64) -> Option<IoTDevice> {\n    self.find_r(\n        &self.root,\n        &IoTDevice::new(numerical_id, \"\".to_owned(), \"\".to_owned()),\n    )\n}\n\nfn find_r(&self, node: &Tree, dev: &IoTDevice) -> Option<IoTDevice> {\n    match node {\n        Some(n) => {\n            let n = n.borrow();\n            if n.dev.numerical_id == dev.numerical_id {\n                Some(n.dev.clone())\n            } else {\n                match self.check(&n.dev, &dev) {\n                    RBOperation::LeftNode => self.find_r(&n.left, dev),\n                    RBOperation::RightNode => self.find_r(&n.right, dev),\n                }\n            }\n        }\n        _ => None,\n    }\n}\n```", "```rs\npub fn walk(&self, callback: impl Fn(&IoTDevice) -> ()) {\n    self.walk_in_order(&self.root, &callback);\n}\n\nfn walk_in_order(&self, node: &Tree, callback: &impl Fn(&IoTDevice) -> ()) {\n    if let Some(n) = node {\n        let n = n.borrow();\n\n        self.walk_in_order(&n.left, callback);\n        callback(&n.dev);\n        self.walk_in_order(&n.right, callback);\n    }\n}\n```", "```rs\ntest tests::bench_sorted_insert_bst_find ... bench: 370,185 ns/iter (+/- 265,997)\ntest tests::bench_sorted_insert_rbt_find ... bench: 900 ns/iter (+/- 423)\n```", "```rs\n#[derive(Clone, Debug)]\npub struct MessageNotification {\n    pub no_messages: u64,\n    pub device: IoTDevice,\n}\n```", "```rs\npub struct MessageChecker {\n    pub length: usize,\n    heap: Vec<Box<MessageNotification>>,\n}\n```", "```rs\npub fn add(&mut self, notification: MessageNotification) {\n    self.heap.push(Box::new(notification));\n    self.length = self.heap.len();\n    if self.length > 1 {\n        let mut i = self.length;\n        while i / 2 > 0 && self.has_more_messages(i, i / 2) {\n            self.swap(i, i / 2);\n            i /= 2;\n        }\n    }\n}\n```", "```rs\nfn has_more_messages(&self, pos1: usize, pos2: usize) -> bool {\n    let a = &self.heap[pos1 - 1];\n    let b = &self.heap[pos2 - 1];\n    a.no_messages >= b.no_messages\n}\n```", "```rs\npub fn pop(&mut self) -> Option<MessageNotification> {\n    if self.length > 0 {\n        let elem = self.heap.swap_remove(0);\n        self.length = self.heap.len();\n        let mut i = 1;\n        while i * 2 < self.length {\n            let children = (i * 2, i * 2 + 1);\n            i = if self.has_more_messages(children.0, children.1) {\n                if self.has_more_messages(children.0, i) {\n                    self.swap(i, children.0);\n                    children.0\n                } else {\n                    break;\n                }\n            } else {\n                if self.has_more_messages(children.1, i) {\n                self.swap(i, children.1);\n                children.1\n                } else {\n                    break;\n                }    \n            }\n        }\n        Some(*elem)\n    } else {\n        None\n    }\n}\n```", "```rs\nstruct Node {\n    pub key: char,\n    next: HashMap<char, Link>,\n    pub value: Option<IoTDevice>,\n}\n```", "```rs\npub struct BestDeviceRegistry {\n    pub length: u64,\n    root: HashMap<char, Link>,\n}\n```", "```rs\npub fn add(&mut self, device: IoTDevice) {\n    let p = device.path.clone();\n    let mut path = p.chars();\n    if let Some(start) = path.next() {\n        self.length += 1;\n        let mut n = self.root\n                .entry(start)\n                .or_insert(Node::new(start, None));\n        for c in path {\n            let tmp = n.next\n                    .entry(c)\n                    .or_insert(Node::new(c, None));\n            n = tmp;\n        }\n        n.value = Some(device);\n    }\n}\n```", "```rs\npub fn find(&mut self, path: &str) -> Option<IoTDevice> {\n    let mut path = path.chars();\n    if let Some(start) = path.next() {\n        self.root.get(&start).map_or(None, |mut n| {\n            for c in path {\n                match n.next.get(&c) {\n                    Some(ref tmp) => n = tmp,\n                    None => break,\n                }\n            }    \n            n.value.clone()\n        })\n    } else {\n        None\n    }\n}\n```", "```rs\npub fn walk(&self, callback: impl Fn(&IoTDevice) -> ()) {\n    for r in self.root.values() {\n        self.walk_r(&r, &callback);\n    }\n}\n\nfn walk_r(&self, node: &Link, callback: &impl Fn(&IoTDevice) -> ()) {\n    for n in node.next.values() {\n        self.walk_r(&n, callback);\n    }\n    if let Some(ref dev) = node.value {\n        callback(dev);\n    }\n}\n```", "```rs\ntype Tree = Box<Node>;\n\n#[derive(Clone, PartialEq, Debug)]\nenum NodeType {\n    Leaf,\n    Regular,\n}\n\n#[derive(Clone)]\nstruct Node {\n    keys: Vec<Option<(u64, String, Option<Tree>)>>,\n    left_child: Option<Tree>,\n    pub node_type: NodeType,\n}\n```", "```rs\ntype Tree = Box<Node>;\ntype KeyType = u64;\n\ntype Data = (Option<IoTDevice>, Option<Tree>);\n\n#[derive(Clone, PartialEq, Debug)]\nenum NodeType {\n    Leaf,\n    Regular,\n}\n\n#[derive(Clone, PartialEq)]\nenum Direction {\n    Left,\n    Right(usize),\n}\n\n#[derive(Clone)]\nstruct Node {\n    devices: Vec<Option<IoTDevice>>,\n    children: Vec<Option<Tree>>,\n    left_child: Option<Tree>,\n    pub node_type: NodeType,\n}\n```", "```rs\npub struct DeviceDatabase {\n    root: Option<Tree>,\n    order: usize,\n    pub length: u64,\n}\n```", "```rs\npub fn is_a_valid_btree(&self) -> bool {\n    if let Some(tree) = self.root.as_ref() {\n        let total = self.validate(tree, 0);\n        total.0 && total.1 == total.2\n    } else {\n        false // there is no tree\n    }\n}\n\nfn validate(&self, node: &Tree, level: usize) -> (bool, usize, usize) {\n    match node.node_type {\n        NodeType::Leaf => (node.len() <= self.order, level, level),\n        NodeType::Regular => {\n            // Root node only requires two children, \n            //  every other node at least half the\n            // order\n            let min_children = if level > 0 { \n                self.order / 2usize } else { 2 };\n            let key_rules = node.len() <= self.order && \n                 node.len() >= min_children;\n\n            let mut total = (key_rules, usize::max_value(), level);\n            for n in node.children.iter().chain(vec![&node.left_child]) {\n                if let Some(ref tree) = n {\n                    let stats = self.validate(tree, level + 1);\n                    total = (\n                        total.0 && stats.0,\n                        cmp::min(stats.1, total.1),\n                        cmp::max(stats.2, total.2),\n                    );\n                }\n            }\n            total\n        }\n    }\n}\n```", "```rs\ntype Data = (Option<IoTDevice>, Option<Tree>);\n\npub fn add(&mut self, device: IoTDevice) {\n    let node = if self.root.is_some() {\n        mem::replace(&mut self.root, None).unwrap()\n    } else {\n        Node::new_leaf()\n    };\n\n    let (root, _) = self.add_r(node, device, true);\n    self.root = Some(root);\n}\n```", "```rs\n\nfn add_r(&mut self, node: Tree, device: IoTDevice, is_root: bool) -> (Tree, Option<Data>) {\n    let mut node = node;\n    let id = device.numerical_id;\n\n    match node.node_type {\n        NodeType::Leaf => {                 // 1\n            if node.add_key(id, (Some(device), None)) {\n                self.length += 1;           // 2\n            }\n        }\n        NodeType::Regular => {\n            let (key, (dev, tree)) = node.remove_key(id).unwrap();\n            let new = self.add_r(tree.unwrap(), device, false);\n            if dev.is_none() {              // 5\n                node.add_left_child(Some(new.0));\n            } else {\n                node.add_key(key, (dev, Some(new.0)));\n            }\n                                            // 6\n            if let Some(split_result) = new.1 {\n                let new_id = &split_result.0.clone().unwrap();\n                node.add_key(new_id.numerical_id, split_result);\n            }\n        }\n    }\n\n    if node.len() > self.order {             // 3\n        let (new_parent, sibling) = node.split();\n\n        // Check if the root node is \"full\" and add a new level\n        if is_root {\n            let mut parent = Node::new_regular();\n            // Add the former root to the left\n            parent.add_left_child(Some(node));\n            // Add the new right part as well\n            parent.add_key(new_parent.numerical_id, \n                           (Some(new_parent), Some(sibling)));\n            (parent, None)\n        } else {\n                                            // 4\n            (node, Some((Some(new_parent), Some(sibling))))\n        }\n    } else {\n        (node, None)\n    }\n}\n```", "```rs\npub fn split(&mut self) -> (IoTDevice, Tree) {\n    let mut sibling = Node::new(self.node_type.clone());\n\n    let no_of_devices = self.devices.len();\n    let split_at = no_of_devices / 2usize;\n\n    let dev = self.devices.remove(split_at);\n    let node = self.children.remove(split_at);\n\n    for _ in split_at..self.devices.len() {\n        let device = self.devices.pop().unwrap();\n        let child = self.children.pop().unwrap();\n        sibling.add_key(device.as_ref().unwrap()\n                        .numerical_id, (device, child));\n    }\n\n    sibling.add_left_child(node);\n    (dev.unwrap(), sibling)\n}\n```", "```rs\npub fn get_device(&self, key: KeyType) -> Option<&IoTDevice> {\n    let mut result = None;\n    for d in self.devices.iter() {\n        if let Some(device) = d {\n            if device.numerical_id == key {\n                result = Some(device);\n                break;\n            }\n        }\n    }\n    result\n}\n```", "```rs\npub fn find(&self, id: KeyType) -> Option<IoTDevice> {\n    match self.root.as_ref() {\n        Some(tree) => self.find_r(tree, id),\n        _ => None,\n    }\n}\n\nfn find_r(&self, node: &Tree, id: KeyType) -> Option<IoTDevice> {\n    match node.get_device(id) {\n        Some(device) => Some(device.clone()),\n        None if node.node_type != NodeType::Leaf => {\n            if let Some(tree) = node.get_child(id) {\n                self.find_r(tree, id)\n            } else {\n                None\n            }\n        }\n        _ => None,\n    }\n}\n```", "```rs\npub fn walk(&self, callback: impl Fn(&IoTDevice) -> ()) {\n    if let Some(ref root) = self.root {\n        self.walk_in_order(root, &callback);\n    }\n}\n\nfn walk_in_order(&self, node: &Tree, callback: &impl Fn(&IoTDevice) -> ()) {\n    if let Some(ref left) = node.left_child {\n        self.walk_in_order(left, callback);\n    }\n\n    for i in 0..node.devices.len() {\n        if let Some(ref k) = node.devices[i] {\n            callback(k);\n        }\n\n        if let Some(ref c) = node.children[i] {\n            self.walk_in_order(&c, callback);\n        }\n    }\n}\n```", "```rs\nstruct ASimpleGraph {\n    adjacency_list: Vec<Vec<usize>>,\n}\n```", "```rs\npub struct InternetOfThings {\n    adjacency_list: Vec<Vec<Edge>>,\n    nodes: Vec<KeyType>,\n}\n```", "```rs\n#[derive(Clone, Debug)]\nstruct Edge {\n   weight: u32,\n    node: usize,\n}\n```", "```rs\nfn get_node_index(&self, node: KeyType) -> Option<usize> {\n    self.nodes.iter().position(|n| n == &node)\n}\n\npub fn set_edges(&mut self, from: KeyType, edges: Vec<(u32, KeyType)>) {\n    let edges: Vec<Edge> = edges.into_iter().filter_map(|e| {\n        if let Some(to) = self.get_node_index(e.1) {\n            Some(Edge { weight: e.0, node: to }) \n            } else {\n                None\n            }}).collect();\n    match self.nodes.iter().position(|n| n == &from) {\n        Some(i) => self.adjacency_list[i] = edges,\n        None => {\n            self.nodes.push(from);\n            self.adjacency_list.push(edges)\n        }\n    }\n}\n```", "```rs\npub fn set_nodes(&mut self, nodes: Vec<KeyType>) {\n    self.nodes = nodes;\n    self.adjacency_list = vec![vec![]; self.nodes.len()]\n}\n```", "```rs\npub fn connected(&self, from: KeyType, degree: usize) -> Option<HashSet<KeyType>> {\n    self.nodes.iter().position(|n| n == &from).map(|i| {\n        self.connected_r(i, degree).into_iter().map(|n| \n        self.nodes[n].clone()).collect()\n    })\n}\n```", "```rs\nfn connected_r(&self, from: usize, degree: usize) -> HashSet<usize> {\n    if degree > 0 {\n        self.adjacency_list[from]\n            .iter()\n            .flat_map(|e| {\n                let mut set = self.connected_r(e.node, degree - 1);\n                set.insert(e.node);\n                set\n            }).collect()\n    } else {\n        HashSet::new()\n    }\n}\n```", "```rs\npub fn shortest_path(&self, from: KeyType, to: KeyType) -> Option<(u32, Vec<KeyType>)> {\n    let mut src = None;\n    let mut dest = None;\n\n    for (i, n) in self.nodes.iter().enumerate() {\n        if n == &from {\n            src = Some(i);\n        }\n        if n == &to {\n            dest = Some(i);\n        }\n        if src.is_some() && dest.is_some() {\n            break;\n        }\n    }\n    if src.is_some() && dest.is_some() {\n        let (src, dest) = (src.unwrap(), dest.unwrap());\n\n        let mut distance: Vec<TentativeWeight> =\n            vec![TentativeWeight::Infinite; self.nodes.len()];\n        distance[src] = TentativeWeight::Number(0);\n\n        let mut open: Vec<usize> = \n                  (0..self.nodes.len()).into_iter().collect();\n        let mut parent = vec![None; self.nodes.len()];\n        let mut found = false;\n        while !open.is_empty() {\n            let u = min_index(&distance, &open);\n            let u = open.remove(u);\n\n            if u == dest {\n                found = true;\n                break;\n            }\n\n            let dist = distance[u].clone();\n\n            for e in &self.adjacency_list[u] {\n                let new_distance = match dist {\n                    TentativeWeight::Number(n) => \n                       TentativeWeight::Number(n + e.weight),\n                    _ => TentativeWeight::Infinite,\n                };\n\n                let old_distance = distance[e.node].clone();\n\n                if new_distance < old_distance {\n                    distance[e.node] = new_distance;\n                    parent[e.node] = Some(u);\n                }\n            }\n        }\n        if found {\n            let mut path = vec![];\n            let mut p = parent[dest].unwrap();\n            path.push(self.nodes[dest].clone());\n            while p != src {\n                path.push(self.nodes[p].clone());\n                p = parent[p].unwrap();\n            }\n            path.push(self.nodes[src].clone());\n\n            path.reverse();\n            let cost = match distance[dest] {\n                TentativeWeight::Number(n) => n,\n                _ => 0,\n            };\n            Some((cost, path))\n        } else {\n            None\n        }\n    } else {\n        None\n    }\n}\n```", "```rs\npub fn shortest_path(&self, from: KeyType, to: KeyType) -> Option<(u32, Vec<KeyType>)> {\n    let mut src = None;\n    let mut dest = None;\n\n    for (i, n) in self.nodes.iter().enumerate() {\n        if n == &from {\n            src = Some(i);\n        }\n        if n == &to {\n            dest = Some(i);\n        }\n        if src.is_some() && dest.is_some() {\n            break;\n        }\n    }\n    if src.is_some() && dest.is_some() {\n        let (src, dest) = (src.unwrap(), dest.unwrap());\n```", "```rs\n        let mut distance: Vec<TentativeWeight> =\n            vec![TentativeWeight::Infinite; self.nodes.len()];\n        distance[src] = TentativeWeight::Number(0);\n\n        let mut open: Vec<usize> = \n                     (0..self.nodes.len()).into_iter().collect();\n        let mut parent = vec![None; self.nodes.len()];\n        let mut found = false;\n```", "```rs\n        while !open.is_empty() {\n            let u = min_index(&distance, &open);\n            let u = open.remove(u);\n\n            if u == dest {\n                found = true;\n                break;\n            }\n\n            let dist = distance[u].clone();\n\n            for e in &self.adjacency_list[u] {\n                let new_distance = match dist {\n                    TentativeWeight::Number(n) => \n                        TentativeWeight::Number(n + e.weight),\n                    _ => TentativeWeight::Infinite,\n                };\n\n                let old_distance = distance[e.node].clone();\n\n                if new_distance < old_distance {\n                    distance[e.node] = new_distance;\n                    parent[e.node] = Some(u);\n                }\n            }\n        }\n```", "```rs\n        if found {\n            let mut path = vec![];\n            let mut p = parent[dest].unwrap();  \n            path.push(self.nodes[dest].clone());\n            while p != src {\n                path.push(self.nodes[p].clone());\n                p = parent[p].unwrap();\n            }\n            path.push(self.nodes[src].clone());\n            path.reverse();\n            let cost = match distance[dest] {     \n                TentativeWeight::Number(n) => n,\n                _ => 0,\n            };\n            Some((cost, path))\n        } else {\n            None\n        }\n    } else {\n        None\n    }\n}\n```"]