- en: '*Chapter 10*: Injecting Rust into a Python Flask App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B17720_09_Final_SK_ePub.xhtml#_idTextAnchor158), *Structuring
    a Python Flask App for Rust*, we set up a basic Python web application in Flask
    that could be deployed using Docker. In this chapter, we are going to fuse Rust
    into every aspect of that web application. This means polishing our skills of
    defining Rust packages that can be installed using `pip`. With these packages,
    we are going to plug Rust code into our Flask and Celery containers. We are also
    going to directly interact with an existing database using Rust, without having
    to worry about migrations. This is because our Rust package is going to mirror
    the schema of the existing database. We will need a Rust `nightly` version to
    compile our package, so we will also learn how to manage Rust `nightly` when building
    our Flask image. We will also learn how to use Rust packages from private GitHub
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fusing Rust into Flask and Celery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Flask and Celery with Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying with a private GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fusing Rust with data access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Rust `nightly` in Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about these topics will enable us to use our Rust packages in a Python
    web application so that it can be deployed in Docker. This will bring our Rust
    skills directly in line with the real world, enabling us to speed up Python web
    applications without having to rewrite our entire infrastructure. If you are a
    Python web developer, you will be able to turn up to work after reading this chapter
    and start injecting Rust into web applications to introduce fast, safe code without
    much risk.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The code and data for this chapter can be found at [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_ten](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_ten).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will be building a Docker-contained Flask application.
    This is available via the following GitHub repository: [https://github.com/maxwellflitton/fib-flask](https://github.com/maxwellflitton/fib-flask).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fusing Rust into Flask and Celery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will fuse Rust into our Flask application by installing our Rust Fibonacci
    calculation library using `pip`. We will then use it in our views and Celery tasks.
    This will speed up our Flask application without us having to make big changes
    to our infrastructure. To achieve this, we will carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define our dependency on the Rust Fibonacci number calculation package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build our calculation module with Rust.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a calculation view using Rust in our Flask application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert Rust into our Celery task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we will have a Flask application that has a speedup due to Rust.
    Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Defining our dependency on the Rust Fibonacci number calculation package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to our Rust dependency, it would be tempting to just put our
    Rust dependency in our `requirements.txt` file. However, this can become confusing.
    Also, we are using an automated process to update our `requirements.txt` file.
    This runs the risk of wiping our GitHub repositories from the `requirements.txt`
    file. We must remember that our `requirements.txt` file is just a text file. Therefore,
    nothing is stopping us from just adding another text file that lists our GitHub
    repositories and using it to install the GitHub repositories that our application
    is dependent on. To do this, we will populate our `src/git_repos.txt` file with
    the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can install our GitHub repository dependencies with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will result in our Python system downloading the GitHub repository and
    compiling it in our Python packages. We now know which GitHub repositories are
    powering our application, so we can start using automation tools to update our
    `requirements.txt` file. Now that we have installed our Rust package, we can start
    building a calculation module that will use Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Building our calculation model with Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our calculation module will have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We already have our Python calculation in the `fib_calculation.py` file from
    the previous chapter. However, we are now supporting both Rust and Python implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will start by defining an enum in our `enums.py` file with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With this enum, we can keep adding methods. For instance, if we were to develop
    microservices later on and have a separate server for calculating our Fibonacci
    numbers, we can add an API call to our enum and support it in our calculation
    interface. Depending on the configuration file, we can switch between all of them.
    Now that we have defined our enums, we can build our interface in the `src/fib_calcs/__init__.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to import what we need with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we used the `time` module to time how long a process takes to run. We
    also imported our Python and Rust implementations for our calculations. Finally,
    we imported our enum to map which method we used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With all of this, we can start building the time process function in our `src/fib_calcs/__init__.py`
    file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we took in a calculation function under the `processor` parameter name
    and passed the `input_number` parameter into the function. We also timed this
    process and returned it with the Fibonacci number. Now that we've done this, we
    can build a function that processes an input string and convert that into our
    enum. We will not always pass a string into our interface, but if we can load
    a string signaling what process type we want from a configuration file, this will
    be important.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our processing method can be defined with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that our string is stored in the key values of the `_value2member_map_`
    map. If it is not in the keys, then our enum will not support it, and the method
    will throw an error. However, if it exists, we return the enum associated with
    the key value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can define the two helper functions for our interface with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, if we pass in a string for our method, we can convert it into an enum.
    If the enum points to Python, we can pass our Python calculation object, along
    with the input number, into our `_time_process` function. Then, we can return
    the Fibonacci number and time taken. If our enum points to Rust, we can perform
    the same operations but with the Rust function. With this approach, we can add
    and take away functionality. For instance, we can switch the timing process with
    another parameter that's pointing to another calculation function that does not
    time the process, resulting in a process that just performs the calculation without
    timing it if we want. However, for this example, we will be using the timing process
    to compare speeds. Now that we have built our interface, we can create our calculation
    view with this interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a calculation view using Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are hosting our view in the `src/app.py` file. First, we will import our
    interface with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this new interface and enum, we can make changes to our standard calculation
    view with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the new interface. Because of this, we can also return the
    time taken to perform the calculation. Now, we can build our Rust calculation
    view. It will take the same form as the standard calculation view, meaning that
    you can refactor it to have the Rust and Python calculation methods in the same
    view based on the parameter that''s passed into the URL. If not, our Rust calculation
    view will take the form of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The dots in the aforementioned code show that this is the same code that's used
    in the standard calculation function. Now that our Rust package has been fused
    with our Flask application, we can insert Rust into our Celery task.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Rust into our Celery task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to our background task in Celery, we do not have to worry about
    the timing. Because of the interface and configuration, we have to import the
    parameters and interface into the `src/task_queue/fib_calc_task.py` file with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can now refactor our Celery task with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we get the global parameters. We pass the `CELERY_METHOD`
    global parameter into the `params`. Considering that the parameters are inherited
    from the dictionary class, we can use the built-in `get` method. We can set the
    default calculation method to `rust` if we have not defined `CELERY_METHOD` in
    the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application is now fully integrated, which means we can test our application.
    We must remember to run our development `docker-compose` environment, Flask application,
    and Celery worker. Accessing our two views will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17720_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Flask, Python, and Rust requests
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see that our Rust call is four times faster,
    even though the Rust request number is higher. We now have a working Python application
    that uses Rust to speed up the calculations. However, this is not very useful
    if we cannot deploy it. The internet is full of half-baked tutorials that teach
    you how to do something superficially in a development environment, while not
    being able to use or configure it in a production environment. In the next section,
    we will configure our Docker environment so that we can deploy our application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Flask and Celery with Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our Flask application''s Docker image to support our Rust packages, we
    need to make some changes to the `src/Dockerfile` file. Looking at this file,
    we can see that our image is built on `python:3.6.13-stretch`. This is essentially
    a Linux environment with Python installed. When we see this, we realize that we
    can be confident in manipulating our Docker image environment. If we can do this
    in Linux, there is a high chance we can do this in our Docker image. Considering
    this, what we must do in our `src/Dockerfile` file is install Rust and register
    `cargo` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily for us, Rust is very easy to install. Remember that the `apt-get install
    -y python3-dev python-dev gcc` command allows us to use compiled extensions when
    using Python. Now that we''ve done this, we can pull and compile our Rust package
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything else is the same. Our image is now ready to be built with the following
    command while our terminal is in the root of the `src/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This will rebuild our Docker image for our Flask application. Some bits might
    be skipped over in this build. Don''t worry – Docker caches the layers in the
    image build that have not been changed. This is denoted with the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Once a step has been changed, every step following it will be rerun since the
    interrupted step might change the outcome of the steps following it. Note that
    the build might hang when `pip` installs our Rust package. This is because the
    package is being compiled. You may have noticed that we have to do this every
    time we install the Rust package. A more optimal distribution strategy will be
    explored in the next chapter. Now, if we run `docker-compose` in our deployment
    directory, we will see that we can use our Rust Flask container without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying with a private GitHub repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are coding for a side project, company, or paid feature, you will be
    working with private GitHub repositories. This makes sense as we do not want people
    accessing a repository for free that you or your company plans on charging them
    for. However, if we set our Rust Fibonacci package''s GitHub repository to private,
    delete all of our Flask images using the `docker image rm YOUR_IMAGE_ID_HERE`
    command, and run our `docker build . -t flask-fib` command again, we would get
    the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because our isolated Linux-based Docker image that is being built is
    not logged into GitHub, even though we are. As a result, the image that''s being
    built could not pull the package from the GitHub repository. We could pass our
    GitHub credentials into the build via arguments, but this will show up in the
    image build layers. Therefore, anyone who has access to our image could look and
    see our GitHub credentials. This is a security hazard. Docker does have some documentation
    on passing in secrets. However, at the time of writing this book, the documentation
    is sparse and convoluted. A more straightforward approach is to clone our `flitton-fib-rs`
    package outside the image and pass it into the Docker image build, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17720_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Private repository image build flow
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are going to use a continuous integration tool such as GitHub Actions
    or Travis, then we can run the process laid out in the preceding diagram with
    GitHub credentials passed in as secrets. GitHub Actions and Travis handle secrets
    with efficiency and simplicity. If we are building it locally, as we are doing
    in this example, then we should already be logged into GitHub as we are directly
    working on the Flask project in this project. To carry out the process laid out
    in the preceding diagram, we must carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a Bash script that orchestrates the process depicted in the preceding
    diagram.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reconfigure our Rust Fib package installment in our Dockerfile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the most straightforward approach to using private GitHub repositories
    in our web application builds. We will start by looking at the Bash script.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Bash script that orchestrates the whole process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our script is housed in `src/build_image.sh`. First, we must declare that this
    is a Bash script and that the code should run in the directory of the Flask application.
    To do so, we must change to the directory that contains the script with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to clone our package and remove our `.git` file from the repository
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our package is just a directory. We are ready to build our Docker image.
    However, if we do so, it might not work because our files might be cached. To
    prevent this from happening, we can run our build with no cache and then remove
    our cloned package after the build with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We will have to run this script to run a build of our Flask application. However,
    if we were to run a build now, it would not work as our Dockerfile will still
    be trying to pull the directory from GitHub. To fix this, we will move on to the
    second step.
  prefs: []
  type: TYPE_NORMAL
- en: Reconfiguring the Rust Fib package installment in our Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our `src/Dockerfile` file, we must remove the `RUN pip install -r git_repos.txt`
    line as this will stop our image build from trying to pull from the GitHub repository.
    Now, we can `pip` `install` the local directory that has been passed in, and then
    remove it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can build our Flask image by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in a long printout that will eventually tell us that the image
    was successfully built. Running our deployment `docker-compose` file will confirm
    this. You may want to install our package from a different Git branch. This can
    be done by adding three more lines to our `src/build_image.sh` file, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Here, we cloned the repository containing the branch, whose name is based on
    the argument that's passed into the script. Once we've done this, we can remove
    the Git history by removing the `.git` file.
  prefs: []
  type: TYPE_NORMAL
- en: Our Rust package is now fully fused with our Python web application in Docker.
    One bonus of installing our Rust package when building an image is that it does
    not have to be compiled every time we use the image.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can go one step further when it comes to reducing our build, though this
    is optional. You do not have to do this to complete this chapter. Right now, we
    are installing Rust and then compiling our Rust Python package for the Fibonacci
    calculations. We can avoid the need to install Rust and compile every time by
    building wheels for a range of Linux distributions and Python versions. This can
    be done by pulling the ManyLinux Docker images and using them to compile our package
    into multiple distributions.
  prefs: []
  type: TYPE_NORMAL
- en: The detailed steps on how to do this to your Python `pip` package coded in Rust
    are laid out in the Rust setup tools documentation (see the *Further reading*
    section). Once those steps are completed, you will end up with a range of wheels
    in your `dist` directory. Copy and paste the 3.6 version into your Flask `src`
    directory and instruct your Dockerfile to copy it into the image when it is being
    built. Once you've done this, you can point the `pip install` command directly
    to the wheel file you copied into the image build. The installation will be nearly
    instant.
  prefs: []
  type: TYPE_NORMAL
- en: While fusing Rust with our Flask application is certainly useful, since we now
    have a real-world example of how our Rust code can be used in a deployment setting,
    we can go even further. In the next section, we will have our Rust code interact
    with our database.
  prefs: []
  type: TYPE_NORMAL
- en: Fusing Rust with data access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In web applications, accessing a database is a big part of the process. We could
    import the `dal` object that we created in the `src/data_access.py` file and pass
    it into our Rust function, executing database operations through Python. While
    this will technically work, it is not ideal as we will have to waste time and
    effort extracting objects from the database queries, inspecting them, and converting
    them into Rust structs. We would then have to convert the Rust structs into Python
    objects before inserting them into the database. This is a lot of excess code
    that has a lot of interaction with Python, reducing its speed gain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because a database is external from the Python web application, and it contains
    information about its schema, we can completely bypass Python''s implementations
    by using the `diesel` Rust crate to automatically write our schema and database
    models in Rust based on the live database. We can also use `diesel` to manage
    the connection to the database. As a result, we can directly interact with the
    database, reducing our reliance on Python, speeding up our code, and reducing
    the amount of code that we have to write. To achieve this, we have to carry out
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up our database cloning package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up our `diesel` environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Autogenerate and configure our database models and schema.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define our database connection in Rust.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Rust function that gets all the Fibonacci records and returns them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have completed these steps, we will have a Rust package that interacts
    with the database that can be added to our Flask application build and used if
    needed. We will start by setting up our database cloning package.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our database cloning package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should now be familiar with setting up a standard Rust package for Python.
    For our database package, we will have the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'You should know the role of some of these files by now. The new files have
    the following purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`database.rs`: Houses the function that returns a database connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.rs`: Houses the structs that define the database models, fields, and
    the behavior of the individual rows of a table in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema.rs`: Houses the schema of the tables of the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.env`: Houses the database URL for our **command-line interface** (**CLI**)
    interactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Diesel.toml`: Houses the configuration for our `diesel` CLI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can turn our attention to the `setup.py` file. Looking at the package
    layout, you should be able to define this file yourself, and I encourage you to
    give it a try. Here is an example of the barebones `setup.py` file that is needed
    to enable this package to be installed with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, our `rust_db_cloning/__init__.py` file contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can move onto our `Cargo.toml` file, which will list some dependencies
    that you are familiar with, as well as the new `diesel` dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have defined the basics for our package to be installed via `pip`.
    It will not be installed yet as we have nothing in our `src/lib.rs` file, but
    we will fill that file out in the final step. Now, we can move on to the next
    step, which is setting up our `diesel` environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the diesel environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be cloning our schema from our development database so that we can
    hardcode the URL into our `.env` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this database configuration will never end up in a production environment
    and is merely used to generate the schema and models from a development database,
    it is OK if this URL gets into the wrong hands. Having this hardcoded into your
    GitHub repository is not the end of the world. With this in mind, we can define
    where we want our schema to be printed in our `diesel.toml` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have written everything we need, we can start installing and running
    the `diesel` CLI. You may get compilation errors when installing and compiling
    `diesel`. If this is the case while you are reading this, you can get around these
    compilation errors by switching to Rust `nightly`. Rust `nightly` provides the
    latest releases of Rust; however, it is less stable. Therefore, you should try
    and follow these steps without switching to `nightly` but if you find that you
    need to, then you can switch to `nightly` by installing it with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it has been installed, we can switch to `nightly` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Your Rust compilations will be running in `nightly` now. Going back to setting
    up our `diesel` environment, we have to install the `diesel` CLI with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can now use the CLI combined with the URL in the `.env` file to
    interact with our database.
  prefs: []
  type: TYPE_NORMAL
- en: Autogenerating and configuring our database models and schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this step, we will be interacting with the development database in Docker.
    Considering this, before moving on, you need to open another terminal and run
    the development `docker-compose` environment in the `flask-fib` repository. Running
    this will run the database that we will connect to so that we can access the database
    schema and models. Now that the CLI has been installed, we can print the schema
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'There will be no printouts in the terminal but if we open our `src/schema.rs`
    file, we will see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that our `alembic` version is in the schema as a separate table.
    This is how `alembic` keeps track of the migrations. We can also see that our
    `fib_entries` table has been mapped. While we could have done this ourselves without
    the `diesel` CLI, it is a lifesaver, ensuring that the schema is always up to
    date with the database. This also saves time in big, complex databases and reduces
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our schema has been defined, we can define our models with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not completely perfect, and we have to make some changes. The models
    do not have the tables defined. `diesel` assumes that the table name is just the
    plural of the model''s name. For instance, if we have a data model called *test*,
    then `diesel` would assume that the table is called *tests*. However, for us,
    this is not the case as we specifically defined our tables in our Flask application
    when running migrations in the previous chapter. We can also remove the two `allow`
    macros as we will not be using this functionality. Instead, we will import our
    schemas and define them in the `table` macro. After this rearrangement, our `src/models.rs`
    file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Our models and schema are now ready to be used in our Rust package. Considering
    this, we can move on to the next step, which is defining our database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our database connection in Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our database connection would traditionally take the database URL from the
    environment and use this to make a connection. However, this is a Rust package
    that is an appendage to our Flask application. There is no point in having another
    sensitive piece of information that has to be loaded. Therefore, to avoid extra
    complications and another point of security failure, we will merely pass the database
    URL from the Flask application to make the connection, since the Flask application
    is managing the configuration and loading the sensitive data anyway. The entirety
    of our database connection can be handled in our `src/database.rs` file. First,
    we must import what we need with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '`prelude` helps us use the `diesel` macros, and `PgConnection` is what we will
    return to get a database connection. With this, we can build our database connection
    function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: This can be imported anywhere where we need a database connection. At this point,
    we can start creating a function that gets all the records and returns them in
    dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Rust function that gets all the Fibonacci records and returns them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid excessive complexity in this example, we will be doing everything
    in the `src/lib.rs` file. However, it is advised that you build some modules and
    import them into the `src/lib.rs` file for more complex packages. First of all,
    we will import everything we need to build the function and bind it with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'The order of the imports matters here. We import the `diesel` crate with macro
    use straightaway. Therefore, files such as `database` and `schema` will not error
    out because they are using `diesel` macros. `dotenv` is not being used in our
    example as we are passing in the database URL from the Python system. However,
    it''s useful to know about this if you want to get database URLs from the environment.
    Then, we can import the `pyo3` macros and structs that we need, and the structs
    and functions that we defined. With these imports, we can define our `get_fib_entries`
    function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Python to build a list of dictionaries is not new, and neither is the
    definition of the function. What is new, however, is establishing a connection,
    ordering it using the schema columns, and loading it as a list of `FibEntry` structs.
    We pass a reference to the connection into our query and unwrap it as it returns
    a result. We can chain more functions to it, such as `.filter`, if needed. The
    `diesel` documentation does a good job of covering the different types of queries
    and inserts you can perform. Once we''ve done this, we can add it to our `rust_db_cloning`
    module with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: With this, our code is ready to be uploaded to the GitHub repository and used
    in our Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can quickly test whether our package works before defining it in our
    Dockerfile. First of all, we need to `pip` `install` it in our Flask application
    virtual environment. This is another point where you might have compilation issues.
    To get around this, you might have to switch to Rust `nightly` to `pip` `install`
    the package you just built. Once our package has been installed, we can check
    it out by adding a simple `get` view to our Flask application. In the `src/app.py`
    file of our Flask application, we can import our function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define our `get` view with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that in the previous chapter, we defined the `url` attribute of `dal`
    with the URL from `GlobalParams`, which was loaded from the `.yml` config file.
    We have to turn it into a string; otherwise, the Flask serialization will not
    be able to process it. Running this in the development `docker-compose` environment
    will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Simple get view from our Flask application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17720_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Simple get view from our Flask application
  prefs: []
  type: TYPE_NORMAL
- en: You may have different numbers, depending on what you have in your database.
    However, what we have here is a Rust package that keeps up with the changes in
    the database that can interact directly with the database. Now that this is working
    in our development setup, we can start packaging our Rust `nightly` package for
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Rust nightly in Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To package our `nightly` database Rust package so that it can be deployed, we
    have to add another clone of our GitHub repository to our build Bash script, install
    `nightly`, and switch to it when we are installing our database package with `pip`.
    You can probably guess what we are going to achieve by cloning our database GitHub
    repository in our Bash script.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, our `src/build_image.sh` file will take the form of the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have merely added the code for cloning the `rust-db-cloning`
    repository, removed the `.git` file in that `rust-db-cloning` repository, and
    then removed the `rust-db-cloning` repository once the image build has finished.
    When it comes to our Dockerfile, these steps will remain the same. The only difference
    is that after installing our normal Rust package, we install `nightly`, switch
    to it, and then install our database package. This can be achieved with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Even though one is compiled with normal Rust, while the other is compiled with
    Rust `nightly`, they will both run fine when the application is running. Building
    this image and running it in the deployment `docker-compose` environment will
    show us that the container will process the Rust computation view and get it from
    the database view without any problems. With this, we now have all the tools we
    need to fuse Rust into Python web applications and deploy them in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have put all our Rust fusing skills to work to build packages
    that are baked into Docker images for a Python web application. We attached Rust
    packages directly to the web application, and then to the Celery worker, resulting
    in a significant speedup when we asked our web application to calculate the Fibonacci
    number.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we altered our build process to take Rust packages from private GitHub
    repositories when building our Python web application image. Finally, we connected
    directly to the database with Rust and used Rust `nightly` to compile it. We managed
    to include this in our Python web application Docker build. This resulted in us
    not only being able to fuse Rust into a deployable web application but also use
    Rust `nightly` and databases to solve our problems
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we can now use what we have learned in this book for production
    web applications. You can now start coding in Rust and plug your Rust packages
    into existing Python web applications that can be deployed in Docker, without
    having to make major changes to the Python web application build process.
  prefs: []
  type: TYPE_NORMAL
- en: Reaching for Rust to solve a speed bottleneck or to ensure that the code is
    consistent and safe in a live Python web application is something you can do in
    your day job tomorrow. You can now bring forward the fastest memory-safe programming
    language into your Python projects without having to overhaul your existing system.
    You are now capable of bridging the gap between practically maintaining an existing
    tried and tested system and a cutting-edge language. In the next and final chapter,
    we will cover some best practices. But right now, you know the key concepts to
    go and change your project or organization.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does directly connecting to a database in Rust reduce code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can't we just pass login credentials into our Docker image build Dockerfile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We did not make any migrations in this chapter. How did we map our models and
    schema of a database to our Rust module, and how do we continue to keep up with
    database changes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we pass the database URL into our database Rust package as opposed to
    loading it from a config file or environment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we have to do anything extra if we were going to fuse Rust with a Django,
    bottle, or FastAPI Python web application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Directly connecting to a database with Rust reduces the amount of code we must
    write as we do not have to inspect the Python objects that are returned from the
    Python database call. We also do not have to package data into Python objects
    before inserting them into the database. This essentially removes a whole layer
    of code that we must write when interacting with the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If someone gets hold of our image, they can access the layers of the build.
    As a result, they can access the arguments that have been passed into the build.
    This will mean that they can see the credentials we use to log in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used the `diesel` crate to connect to the database and automatically print
    the schemas and models based on the database it connects to. We can do this repeatedly
    to keep up to date with new database migrations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must remember that our Rust database package is an appendage to our Python
    web application. Our Python web application has already loaded the database URL.
    Loading credentials into our package just adds another possibility for a security
    breach with no advantages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No – our fusing method is completely detached from the `pip` installation process
    and the database mapping process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Diesel documentation for Rust (2021): Crate Diesel: [https://diesel.rs](https://diesel.rs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setup tools Rust documentation (2021): Distributing a Rust Python package with
    wheels: [https://pypi.org/project/setuptools-rust/](https://pypi.org/project/setuptools-rust/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ManyLinux GitHub (2021): [https://github.com/pypa/manylinux](https://github.com/pypa/manylinux%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
