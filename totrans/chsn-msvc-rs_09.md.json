["```rs\nfn main() {\n     env_logger::init();\n     let manager = ConnectionManager::<SqliteConnection>::new(\"test.db\");\n     let pool = Pool::builder().build(manager).expect(\"Failed to create pool.\");\n     rouille::start_server(\"127.0.0.1:8001\", move |request| {\n         match handler(&request, &pool) {\n             Ok(response) => { response },\n             Err(err) => {\n                 Response::text(err.to_string())\n                     .with_status_code(500)\n             }\n         }\n     })\n }\n```", "```rs\n(GET) (/) => {\n    Response::text(\"Users Microservice\")\n},\n```", "```rs\n(POST) (/signup) => {\n    let data = post_input!(request, {\n        email: String,\n        password: String,\n    })?;\n    let user_email = data.email.trim().to_lowercase();\n    let user_password = pbkdf2_simple(&data.password, 12345)?;\n    {\n        use self::schema::users::dsl::*;\n        let conn = pool.get()?;\n        let user_exists: bool = select(exists(users.filter(email.eq(user_email.clone()))))\n            .get_result(&conn)?;\n        if !user_exists {\n            let uuid = format!(\"{}\", uuid::Uuid::new_v4());\n            let new_user = models::NewUser {\n                id: &uuid,\n                email: &user_email,\n                password: &user_password,\n            };\n            diesel::insert_into(schema::users::table).values(&new_user).execute(&conn)?;\n            Response::json(&())\n        } else {\n            Response::text(format!(\"user {} exists\", data.email))\n                .with_status_code(400)\n        }\n    }\n}\n```", "```rs\n(POST) (/signin) => {\n    let data = post_input!(request, {\n        email: String,\n        password: String,\n    })?;\n    let user_email = data.email;\n    let user_password = data.password;\n    {\n        use self::schema::users::dsl::*;\n        let conn = pool.get()?;\n        let user = users.filter(email.eq(user_email))\n            .first::<models::User>(&conn)?;\n        let valid = pbkdf2_check(&user_password, &user.password)\n            .map_err(|err| format_err!(\"pass check error: {}\", err))?;\n        if valid {\n            let user_id = UserId {\n                id: user.id,\n            };\n            Response::json(&user_id)\n                .with_status_code(200)\n        } else {\n            Response::text(\"access denied\")\n                .with_status_code(403)\n        }\n    }\n}\n```", "```rs\n_ => {\n    Response::empty_404()\n}\n```", "```rs\nDATABASE_URL=test.db diesel migration run\ncargo run\n```", "```rs\ncurl -d \"email=user@example.com&password=password\" -X POST http://localhost:8001/signup\ncurl -d \"email=user@example.com&password=password\" -X POST http://localhost:8001/signin\n```", "```rs\n{\"id\":\"08a023d6-be15-46c1-a6d6-56f0e2a04aae\"}\n```", "```rs\nfailure = \"0.1\"\nlettre = { git = \"https://github.com/lettre/lettre\" }\nlettre_email = { git = \"https://github.com/lettre/lettre\" }\nnickel = \"0.10\"\n```", "```rs\nuse lettre::{ClientSecurity, SendableEmail, EmailAddress, Envelope, SmtpClient, SmtpTransport, Transport};\nuse lettre::smtp::authentication::IntoCredentials;\nuse nickel::{Nickel, HttpRouter, FormBody, Request, Response, MiddlewareResult};\nuse nickel::status::StatusCode;\nuse nickel::template_cache::{ReloadPolicy, TemplateCache};\n```", "```rs\nstruct Data {\n    sender: Mutex<Sender<SendableEmail>>,\n    cache: TemplateCache,\n}\n```", "```rs\nfn main() {\n    let tx = spawn_sender();\n\n    let data = Data {\n        sender: Mutex::new(tx),\n        cache: TemplateCache::with_policy(ReloadPolicy::Always),\n    };\n\n    let mut server = Nickel::with_data(data);\n    server.get(\"/\", middleware!(\"Mailer Microservice\"));\n    server.post(\"/send\", send);\n    server.listen(\"127.0.0.1:8002\").unwrap();\n}\n```", "```rs\nfn send<'mw>(req: &mut Request<Data>, res: Response<'mw, Data>) -> MiddlewareResult<'mw, Data> {\n    try_with!(res, send_impl(req).map_err(|_| StatusCode::BadRequest));\n    res.send(\"true\")\n}\n```", "```rs\nfn send_impl(req: &mut Request<Data>) -> Result<(), Error> {\n    let (to, code) = {\n        let params = req.form_body().map_err(|_| format_err!(\"\"))?;\n        let to = params.get(\"to\").ok_or(format_err!(\"to field not set\"))?.to_owned();\n        let code = params.get(\"code\").ok_or(format_err!(\"code field not set\"))?.to_owned();\n        (to, code)\n    };\n    let data = req.server_data();\n    let to = EmailAddress::new(to.to_owned())?;\n    let envelope = Envelope::new(None, vec![to])?;\n    let mut params: HashMap<&str, &str> = HashMap::new();\n    params.insert(\"code\", &code);\n    let mut body: Vec<u8> = Vec::new();\n    data.cache.render(\"templates/confirm.tpl\", &mut body, &params)?;\n    let email = SendableEmail::new(envelope, \"Confirm email\".to_string(), Vec::new());\n    let sender = data.sender.lock().unwrap().clone();\n    sender.send(email).map_err(|_| format_err!(\"can't send email\"))?;\n    Ok(())\n}\n```", "```rs\nfn spawn_sender() -> Sender<SendableEmail> {\n    let (tx, rx) = channel();\n    let smtp = SmtpClient::new(\"localhost:2525\", ClientSecurity::None)\n        .expect(\"can't start smtp client\");\n    let credentials = (\"admin@example.com\", \"password\").into_credentials();\n    let client = smtp.credentials(credentials);\n    thread::spawn(move || {\n        let mut mailer = SmtpTransport::new(client);\n        for email in rx.iter() {\n            let result = mailer.send(email);\n            if let Err(err) = result {\n                println!(\"Can't send mail: {}\", err);\n            }\n        }\n        mailer.close();\n    });\n    tx\n}\n```", "```rs\ndocker run -it --rm --name test-smtp -p 2525:25  \\\n -e SMTP_SERVER=smtp.example.com \\\n -e SMTP_USERNAME=admin@example.com \\\n -e SMTP_PASSWORD=password \\\n -e SERVER_HOSTNAME=smtp.example.com \\\n juanluisbaptiste/postfix\n```", "```rs\ncurl -d \"to=email@example.com&code=passcode\" -X POST http://localhost:8002/send\n```", "```rs\nrocket = \"0.4.0-rc.1\"\nrocket_contrib = { version = \"0.4.0-rc.1\", features = [\"diesel_sqlite_pool\"] }\nserde = \"1.0\"\nserde_json = \"1.0\"\nserde_derive = \"1.0\"\ndiesel = { version = \"1.3\", features = [\"sqlite\", \"r2d2\"] }\ndiesel_migrations = \"1.3\"\nlog = \"0.4\"\n```", "```rs\n#![feature(proc_macro_hygiene, decl_macro)]\n\n#[macro_use]\nextern crate rocket;\n#[macro_use]\nextern crate diesel;\n#[macro_use]\nextern crate diesel_migrations;\n#[macro_use]\nextern crate log;\n#[macro_use]\nextern crate serde_derive;\n#[macro_use]\nextern crate rocket_contrib;\n\nmod comment;\n\nuse rocket::fairing::AdHoc;\nuse rocket::request::Form;\nuse rocket_contrib::json::Json;\nuse diesel::SqliteConnection;\nuse comment::{Comment, NewComment};\n```", "```rs\n#[database(\"sqlite_database\")]\npub struct Db(SqliteConnection);\n```", "```rs\nembed_migrations!();\n```", "```rs\nfn main() {\n    rocket::ignite()\n        .attach(Db::fairing())\n        .attach(AdHoc::on_attach(\"Database Migrations\", |rocket| {\n            let conn = Db::get_one(&rocket).expect(\"no database connection\");\n            match embedded_migrations::run(&*conn) {\n                Ok(_) => Ok(rocket),\n                Err(err) => {\n                    error!(\"Failed to run database migrations: {:?}\", err);\n                    Err(rocket)\n                },\n            }\n        }))\n        .mount(\"/\", routes![list, add_new])\n        .launch();\n}\n```", "```rs\n#[get(\"/list\")]\nfn list(conn: Db) -> Json<Vec<Comment>> {\n    Json(Comment::all(&conn))\n}\n```", "```rs\n#[post(\"/new_comment\", data = \"<comment_form>\")]\nfn add_new(comment_form: Form<NewComment>, conn: Db) {\n    let comment = comment_form.into_inner();\n    Comment::insert(comment, &conn);\n}\n```", "```rs\nmod schema {\n    table! {\n        comments {\n            id -> Nullable<Integer>,\n            uid -> Text,\n            text -> Text,\n        }\n    }\n}\n```", "```rs\n#[table_name=\"comments\"]\n#[derive(Serialize, Queryable, Insertable, Debug, Clone)]\npub struct Comment {\n    pub id: Option<i32>,\n    pub uid: String,\n    pub text: String,\n}\n```", "```rs\n#[derive(FromForm)]\npub struct NewComment {\n    pub uid: String,\n    pub text: String,\n}\n```", "```rs\nimpl Comment {\n    pub fn all(conn: &SqliteConnection) -> Vec<Comment> {\n        all_comments.order(comments::id.desc()).load::<Comment>(conn).unwrap()\n    }\n\n    pub fn insert(comment: NewComment, conn: &SqliteConnection) -> bool {\n        let t = Comment { id: None, uid: comment.uid, text: comment.text };\n        diesel::insert_into(comments::table).values(&t).execute(conn).is_ok()\n    }\n}\n```", "```rs\n[global]\ntemplate_dir = \"static\"\naddress = \"127.0.0.1\"\nport = 8003\n\n[global.databases.sqlite_database]\nurl = \"test.db\"\n```", "```rs\nROCKET_PORT=3721 cargo run\n```", "```rs\nROCKET_ENV=staging cargo run\n```", "```rs\ncurl -d 'uid=user_id&text=\"this is a comment\"' -X POST http://localhost:8003/new_comment\ncurl http://localhost:8003/list\n```", "```rs\nfailure = \"0.1\"\nfutures = \"0.1\"\ngotham = \"0.3\"\ngotham_derive = \"0.3\"\nhyper = \"0.12\"\nmime = \"0.3\"\ntokio = \"0.1\"\ntokio-postgres = { git = \"https://github.com/sfackler/rust-postgres\" }\n```", "```rs\nuse failure::{Error, format_err};\nuse futures::{Future, Stream, future};\nuse gotham::handler::HandlerFuture;\nuse gotham::middleware::state::StateMiddleware;\nuse gotham::pipeline::single::single_pipeline;\nuse gotham::pipeline::single_middleware;\nuse gotham::router::Router;\nuse gotham::router::builder::{DefineSingleRoute, DrawRoutes, build_router};\nuse gotham::state::{FromState, State};\nuse gotham_derive::StateData;\nuse hyper::Response;\nuse hyper::header::{HeaderMap, USER_AGENT};\nuse std::sync::{Arc, Mutex};\nuse tokio::runtime::Runtime;\nuse tokio_postgres::{Client, NoTls};\n```", "```rs\ntype HandlerFuture = dyn Future<\n    Item = (State, Response<Body>),\n    Error = (State, HandlerError)\n    > + Send;\n```", "```rs\npub fn main() -> Result<(), Error> {\n    let mut runtime = Runtime::new()?;\n\n    let handshake = tokio_postgres::connect(\"postgres://postgres@localhost:5432\", NoTls);\n    let (mut client, connection) = runtime.block_on(handshake)?;\n    runtime.spawn(connection.map_err(drop));\n\n    // ...\n}\n```", "```rs\nlet execute = client.batch_execute(\n     \"CREATE TABLE IF NOT EXISTS agents (\n         agent TEXT NOT NULL,\n         timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()\n     );\");\n runtime.block_on(execute)?;\n```", "```rs\n#[derive(Clone, StateData)]\nstruct ConnState {\n    client: Arc<Mutex<Client>>,\n}\n```", "```rs\nimpl ConnState {\n    fn new(client: Client) -> Self {\n        Self {\n            client: Arc::new(Mutex::new(client)),\n        }\n    }\n}\n```", "```rs\nlet state = ConnState::new(client);\nlet router = router(state);\n\nlet addr = \"127.0.0.1:7878\";\nprintln!(\"Listening for requests at http://{}\", addr);\ngotham::start_on_executor(addr, router, runtime.executor());\nruntime\n    .shutdown_on_idle()\n    .wait()\n    .map_err(|()| format_err!(\"can't wait for the runtime\"))\n```", "```rs\nfn router(state: ConnState) -> Router {\n    let middleware = StateMiddleware::new(state);\n    let pipeline = single_middleware(middleware);\n    let (chain, pipelines) = single_pipeline(pipeline);\n    build_router(chain, pipelines, |route| {\n        route.get(\"/\").to(register_user_agent);\n    })\n}\n```", "```rs\nroute.scope(\"/checkout\", |route| {\n    route.get(\"/view\").to(checkout::view);\n    route.post(\"/item\").to(checkout::item::create);\n    route.get(\"/item\").to(checkout::item::read);\n    route.put(\"/item\").to(checkout::item::update);\n    route.patch(\"/item\").to(checkout::item::update);\n    route.delete(\"/item\").to(checkout::item::delete);\n}\n```", "```rs\nfn register_user_agent(state: State) -> Box<HandlerFuture> {\n    // Implementation\n}\n```", "```rs\nlet user_agent = HeaderMap::borrow_from(&state)\n    .get(USER_AGENT)\n    .map(|value| value.to_str().unwrap().to_string())\n    .unwrap_or_else(|| \"<undefined>\".into());\n```", "```rs\nlet conn = ConnState::borrow_from(&state);\nlet client_1 = conn.client.clone();\nlet client_2 = conn.client.clone();\n\nlet res = future::ok(())\n    .and_then(move |_| {\n        let mut client = client_1.lock().unwrap();\n        client.prepare(\"INSERT INTO agents (agent) VALUES ($1)\n                        RETURNING agent\")\n    })\n    .and_then(move |statement| {\n        let mut client = client_2.lock().unwrap();\n        client.query(&statement, &[&user_agent]).collect().map(|rows| {\n            rows[0].get::<_, String>(0)\n        })\n    })\n    .then(|res| {\n        let mut builder = Response::builder();\n        let body = {\n            match res {\n                Ok(value) => {\n                    let value = format!(\"User-Agent: {}\", value);\n                    builder.status(StatusCode::OK);\n                    value.into()\n                }\n                Err(err) => {\n                    builder.status(StatusCode::INTERNAL_SERVER_ERROR);\n                    err.to_string().into()\n                }\n            }\n        };\n        let response = builder.body(body).unwrap();\n        Ok((state, response))\n    });\nBox::new(res)\n```", "```rs\ndocker run -it --rm --name test-pg -p 5432:5432 postgres\n```", "```rs\nListening for requests at http://127.0.0.1:7878\n```", "```rs\npostgres=# SELECT * FROM agents;\n                                                      agent                                      | timestamp           \n-------------------------------------------+-------------------------------\n Mozilla/5.0 Gecko/20100101 Firefox/64.0   | 2019-01-10 19:43:59.064265+00\n Chrome/71.0.3578.98 Safari/537.36         | 2019-01-10 19:44:08.264106+00\n(2 rows)\n```"]