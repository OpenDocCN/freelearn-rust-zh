["```rs\n[dependencies]\ntermion = \"1.5.5\"\n```", "```rs\n    termion::terminal_size()\n    ```", "```rs\n    println!(\"{}\", color::Fg(color::Blue));\n    ```", "```rs\n        println!(\n            \"{}Background{} \",\n            color::Bg(color::Cyan),\n            color::Bg(color::Reset)\n        );\n    ```", "```rs\n      println!(\n            \"{}You can see me in bold?\",\n            style::Bold\n        );\n    ```", "```rs\n    termion::cursor::Goto(5, 10)\n    ```", "```rs\n    print!(\"{}\", termion::clear::All);\n    ```", "```rs\n    tui stands for text-viewer1.rs under src/bin.\n    ```", "```rs\n    [dependencies]\n    termion = \"1.5.5\"\n    ```", "```rs\n    use std::env::args;\n    use std::fs;\n    use std::io::{stdin, stdout, Write};\n    use termion::event::Key;\n    use termion::input::TermRead;\n    use termion::raw::IntoRawMode;\n    use termion::{color, style};\n    ```", "```rs\n    struct Doc {\n        lines: Vec<String>,\n    }\n    #[derive(Debug)]\n    struct Coordinates {\n        pub x: usize,\n        pub y: usize,\n    }\n    struct TextViewer {\n        doc: Doc,\n        doc_length: usize,\n        cur_pos: Coordinates,\n        terminal_size: Coordinates,\n        file_name: String,\n    }\n    ```", "```rs\n    fn main() {\n        //Get arguments from command line\n        let args: Vec<String> = args().collect();\n        if args.len() < 2 {\n            println!(\"Please provide file name \n                as argument\");\n            std::process::exit(0);\n        }\n        //Check if file exists. If not, print error \n        // message and exit process\n        if !std::path::Path::new(&args[1]).exists() {\n            println!(\"File does not exist\");\n            std::process::exit(0);\n        }\n        // Open file & load into struct\n        println!(\"{}\", termion::cursor::Show);\n        // Initialize viewer\n        let mut viewer = TextViewer::init(&args[1]);\n        viewer.show_document();\n        viewer.run();\n    }\n    ```", "```rs\n    impl TextViewer {\n        fn init(file_name: &str) -> Self {\n            //...\n        }\n        fn show_document(&mut self) {\n            // ...\n        }\n        fn run(&mut self) {\n            // ...\n        }\n    }\n    ```", "```rs\nfn init(file_name: &str) -> Self {\n    let mut doc_file = Doc { lines: vec![] };           <1>\n    let file_handle = fs::read_to_string(file_name)\n        .unwrap();                                      <2>\n\n    for doc_line in file_handle.lines() {               <3>\n        doc_file.lines.push(doc_line.to_string());\n    }\n    let mut doc_length = file_handle.lines().count();   <4>\n\n    let size = termion::terminal_size().unwrap();       <5>\n    Self {                                              <6>\n        doc: doc_file,\n        cur_pos: Coordinates {\n            x: 1,\n            y: doc_length,\n        },\n        doc_length: doc_length,\n        terminal_size: Coordinates {\n            x: size.0 as usize,\n            y: size.1 as usize,\n        },\n        file_name: file_name.into(),\n    }\n}\n```", "```rs\nfn show_document(&mut self) {\n    let pos = &self.cur_pos;\n    let (old_x, old_y) = (pos.x, pos.y);\n    print!(\"{}{}\", termion::clear::All,         termion::cursor::Goto(1, 1));\n    println!(\n        \"{}{}Welcome to Super text viewer\\r{}\",\n        color::Bg(color::Black),\n        color::Fg(color::White),\n        style::Reset\n    );\n    for line in 0..self.doc_length {\n        println!(\"{}\\r\", self.doc.lines[line as usize]);\n    }\n    println!(\n        \"{}\",\n        termion::cursor::Goto(0, (self.terminal_size.y - 2) as             u16),\n    );\n    println!(\n        \"{}{} line-count={} Filename: {}{}\",\n        color::Fg(color::Red),\n        style::Bold,\n        self.doc_length,\n        self.file_name,\n        style::Reset\n    );\n    self.set_pos(old_x, old_y);\n}\n```", "```rs\nfn set_pos(&mut self, x: usize, y: usize) {\n    self.cur_pos.x = x;\n    self.cur_pos.y = y;\n    println!(\n        \"{}\",\n        termion::cursor::Goto(self.cur_pos.x as u16, \n            (self.cur_pos.y) as u16)\n    );\n}\n```", "```rs\nfn run(&mut self) {\n    let mut stdout = stdout().into_raw_mode().unwrap();\n    let stdin = stdin();\n    for c in stdin.keys() {\n        match c.unwrap() {\n            Key::Ctrl('q') => {\n                break;\n            }\n            _ => {}\n        }\n        stdout.flush().unwrap();\n    }\n}\n```", "```rs\ncargo run --bin text-viewer1 <file-name-with-full-path>\n```", "```rs\ncp src/bin/text-viewer1.rs src/bin/text-viewer2.rs\n```", "```rs\nfn run(&mut self) {\n    let mut stdout = stdout().into_raw_mode().unwrap();\n    let stdin = stdin();\n    for c in stdin.keys() {\n        match c.unwrap() {\n            Key::Ctrl('q') => {\n                break;\n            }\n            Key::Left => {\n                self.dec_x();\n                self.show_document();\n            }\n            Key::Right => {\n                self.inc_x();\n                self.show_document();\n            }\n            Key::Up => {\n                self.dec_y();\n                self.show_document();\n            }\n            Key::Down => {\n                self.inc_y();\n                self.show_document();\n            }\n            Key::Backspace => {\n                self.dec_x();\n            }\n            _ => {}\n        }\n        stdout.flush().unwrap();\n    }\n}\n```", "```rs\nfn inc_x(&mut self) {\n    if self.cur_pos.x < self.terminal_size.x {\n        self.cur_pos.x += 1;\n    }\n    println!(\n        \"{}\",\n        termion::cursor::Goto(self.cur_pos.x as u16, \n            self.cur_pos.y as u16)\n    );\n}\nfn dec_x(&mut self) {\n    if self.cur_pos.x > 1 {\n        self.cur_pos.x -= 1;\n    }\n    println!(\n        \"{}\",\n        termion::cursor::Goto(self.cur_pos.x as u16,     \n            self.cur_pos.y as u16)\n    );\n}\nfn inc_y(&mut self) {\n    if self.cur_pos.y < self.doc_length {\n        self.cur_pos.y += 1;\n    }\n\n    println!(\n        \"{}\",\n        termion::cursor::Goto(self.cur_pos.x as u16, \n            self.cur_pos.y as u16)\n    );\n}\nfn dec_y(&mut self) {\n    if self.cur_pos.y > 1 {\n        self.cur_pos.y -= 1;\n    }\n    println!(\n        \"{}\",\n        termion::cursor::Goto(self.cur_pos.x as u16,     \n            self.cur_pos.y as u16)\n    );\n}\n```", "```rs\n  for line in 0..self.doc_length {\n            println!(\"{}\\r\", self.doc.lines[line as \n                usize]);\n        }\n```", "```rs\n        if self.doc_length < self.terminal_size.y {  <1>                                                                                                                           \n            for line in 0..self.doc_length {\n                println!(\"{}\\r\", self.doc.lines[line as    \n                    usize]);\n            }\n        } else {                                                \n\n            if pos.y <= self.terminal_size.y {       <2>  \n                for line in 0..self.terminal_size.y - 3 {\n                    println!(\"{}\\r\", self.doc.lines[line as \n                        usize]);\n                }\n            } else {\n                for line in pos.y - (self.terminal_size.y – \n                    3)..pos.y {\n                    println!(\"{}\\r\", self.doc.lines[line as     \n                        usize]);\n                }\n            }\n        }\n```", "```rs\ncargo run –-bin text-viewer2 <file-name-with-full-path>\n```", "```rs\n    use std::io::{self, Write};\n    use termion::cursor::{self, DetectCursorPos};\n    use termion::event::*;\n    use termion::input::{MouseTerminal, TermRead};\n    use termion::raw::IntoRawMode;\n    ```", "```rs\n    fn main() {\n        let stdin = io::stdin();\n        let mut stdout = MouseTerminal::from(io::stdout().\n            into_raw_mode().unwrap());   \n        // ...Other code not shown\n     }\n    ```", "```rs\n        writeln!(\n            stdout,\n            \"{}{} Type q to exit.\",\n            termion::clear::All,\n            termion::cursor::Goto(1, 1)\n        )\n        .unwrap();                                                                                                                        \n    ```", "```rs\n        for c in stdin.events() {                                                                                                         \n            let evt = c.unwrap(); \n            match evt { \n                Event::Key(Key::Char('q')) => break, \n                Event::Mouse(m) => match m { \n                    MouseEvent::Press(_, a, b) |     \n                        MouseEvent::Release(a, b) |    \n                        MouseEvent::Hold(a, b) => {                                                                                                                                                                \n                            write!(stdout, \"{}\",    \n                            cursor::Goto(a, b))\n                            .unwrap(); \n                            let (x, y) = stdout.cursor_pos\n                                ().unwrap();\n                            write!( \n                                stdout, \n                                \"{}{}Cursor is at:    \n                                ({},{}){}\", \n                                cursor::Goto(5, 5), \n                                termion::clear::\n                                    UntilNewline, \n                                 x, \n                                 y, \n                                cursor::Goto(a, b) \n                            ) \n                            .unwrap(); \n                    } \n                }, \n                _ => {} \n            } \n\n            stdout.flush().unwrap(); \n        }\n    ```", "```rs\n    cargo run --bin mouse-events\n    ```"]