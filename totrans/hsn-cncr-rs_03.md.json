["```rs\nstruct AGC {\n  elapsed_time2: u16,\n  elapsed_time1: u16,\n  wait_list_upper: u32,\n  wait_list_lower: u16,\n  digital_autopilot: u16,\n  fine_scale: u16\n}\n```", "```rs\nenum AGCInstruction {\n  TC,\n  TCF,\n  CCS(u8),\n  B(u16),\n  BZF,\n}\n```", "```rs\nstruct AGCInstructionRepr {\n  data: u16,\n  tag: u8,\n}\n```", "```rs\nfn project_flights() -> Vec<(u16, u8)> {\n    let mut t = Vec::new();\n    t.push((1968, 2));\n    t.push((1969, 4));\n    t.push((1970, 1));\n    t.push((1971, 2));\n    t.push((1972, 2));\n    t\n}\n\nfn main() {\n    let mut total: u8 = 0;\n    let flights = project_flights();\n    for &(_, flights) in flights.iter() {\n        total += flights;\n    }\n    println!(\"{}\", total);\n}\n```", "```rs\n#[derive(Clone, Copy, PartialEq, Eq)]\nenum Project {\n    Apollo,\n    Gemini,\n    Mercury,\n}\n\n#[derive(Clone, Copy)]\nstruct Mission {\n    project: Project,\n    number: u8,\n    duration_days: u8,\n}\n\nfn flight() -> Mission {\n    Mission {\n        project: Project::Apollo,\n        number: 8,\n        duration_days: 6,\n    }\n}\n\nfn main() {\n    assert_eq!(::std::mem::size_of::<Mission>(), 3);\n    let mission = flight();\n    if mission.project == Project::Apollo && mission.number == 8 {\n        assert_eq!(mission.duration_days, 6);\n    }\n}\n```", "```rs\nfn main() {\n    let mut x: u8 = 5;\n    let y: &mut u8 = &mut x;\n\n    *y += 1;\n\n    println!(\"{}\", x);\n}\n```", "```rs\nuse std::fmt;\n\nenum Project {\n    Apollo,\n    Gemini,\n    Mercury,\n}\n\nimpl fmt::Display for Project {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Project::Apollo => write!(f, \"Apollo\"),\n            Project::Mercury => write!(f, \"Mercury\"),\n            Project::Gemini => write!(f, \"Gemini\"),\n        }\n    }\n}\n\nstruct Mission {\n    project: Project,\n    number: u8,\n    duration_days: u8,\n}\n\nfn main() {\n    let mut mission = Mission {\n        project: Project::Gemini,\n        number: 2,\n        duration_days: 0,\n    };\n    let proj: &Project = &mission.project;\n    let num: &mut u8 = &mut mission.number;\n    let dur: &mut u8 = &mut mission.duration_days;\n\n    *num = 12;\n    *dur = 3;\n\n    println!(\"{} {} flew for {} days\", proj, num, dur);\n}\n```", "```rs\nuse std::fmt;\n\nenum Project {\n    Apollo,\n    Gemini,\n    Mercury,\n}\n\nimpl fmt::Display for Project {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Project::Apollo => write!(f, \"Apollo\"),\n            Project::Mercury => write!(f, \"Mercury\"),\n            Project::Gemini => write!(f, \"Gemini\"),\n        }\n    }\n}\n\nstruct Mission {\n    project: Project,\n    number: u8,\n    duration_days: u8,\n}\n\nfn main() {\n    let mut missions: [Mission; 2] = [\n        Mission {\n            project: Project::Gemini,\n            number: 2,\n            duration_days: 0,\n        },\n        Mission {\n            project: Project::Gemini,\n            number: 12,\n            duration_days: 2,\n        },\n    ];\n\n    let gemini_2 = &mut missions[0];\n    let _gemini_12 = &mut missions[1];\n\n    println!(\n        \"{} {} flew for {} days\",\n        gemini_2.project, gemini_2.number, gemini_2.duration_days\n    );\n}\n```", "```rs\n> rustc borrow_split_array.rs\nerror[E0499]: cannot borrow `missions[..]` as mutable more than once at a time\n  --> borrow_split_array.rs:40:27\n   |\n39 |     let gemini_2 = &mut missions[0];\n   |                         ----------- first mutable borrow occurs here\n40 |     let _gemini_12 = &mut missions[1];\n   |                           ^^^^^^^^^^^ second mutable borrow occurs here\n...\n46 | }\n   | - first borrow ends here\n\nerror: aborting due to previous error\n```", "```rs\nuse std::fmt;\n\nenum Project {\n    Apollo,\n    Gemini,\n    Mercury,\n}\n\nimpl fmt::Display for Project {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Project::Apollo => write!(f, \"Apollo\"),\n            Project::Mercury => write!(f, \"Mercury\"),\n            Project::Gemini => write!(f, \"Gemini\"),\n        }\n    }\n}\n\nstruct Mission {\n    project: Project,\n    number: u8,\n    duration_days: u8,\n}\n\nfn main() {\n    let gemini_2 = Mission {\n        project: Project::Gemini,\n        number: 2,\n        duration_days: 0,\n    };\n\n    let mut missions: [&Mission; 2] = [&gemini_2, &gemini_2];\n\n    let m0 = &mut missions[0];\n    let _m1 = &mut missions[1];\n\n    println!(\n        \"{} {} flew for {} days\",\n        m0.project, m0.number, m0.duration_days\n    );\n}\n```", "```rs\nfn drop<T>(_x: T) { }\n```", "```rs\npub struct Box<T: ?Sized>(Unique<T>);\n```", "```rs\nuse std::mem;\n\n#[allow(dead_code)]\nenum Project {\n    Mercury { mission: u8 },\n    Gemini { mission: u8 },\n    Apollo { mission: u8 },\n    Shuttle { mission: u8 },\n}\n\nfn main() {\n    assert_eq!(1, mem::size_of::<u8>());\n    assert_eq!(2, mem::size_of::<Project>());\n\n    let ptr_sz = mem::size_of::<usize>();\n    assert_eq!(ptr_sz, mem::size_of::<&Project>());\n\n    let vec_sz = mem::size_of::<usize>() * 2 + ptr_sz;\n    assert_eq!(vec_sz, mem::size_of::<Vec<Project>>());\n}\n```", "```rs\nuse std::time::{SystemTime, UNIX_EPOCH};\n\nfn main() {\n    let values = vec![0, 1, 2, 3, 4, 5, 7, 8, 9, 10];\n    let cur: usize = SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .unwrap()\n        .as_secs() as usize;\n    let cap: usize = cur % values.len();\n\n    let slc: &[u8] = &values[0..cap];\n\n    println!(\"{:?}\", slc);\n}\n```", "```rs\nfn main() {\n    let values = vec![0, 1, 2, 3, 4, 5, 7, 8, 9, 10];\n    let slc: &[u8] = &values[0..10_000];\n\n    println!(\"{:?}\", slc);\n}\n```", "```rs\n> ./past_the_end thread \n'main' panicked at 'index 10000 out of range for slice of length 10', libcore/slice/mod.rs:785:5 note: Run with `RUST_BACKTRACE=1` for a backtrace.\n```", "```rs\nstruct ImportantThing {\n  tag: u8,\n  data: [u8],\n}\n```", "```rs\nuse std::ops::Add;\n\nfn sd_add<T: Add<Output=T>>(x: T, y: T) -> T {\n    x + y\n}\n\nfn main() {\n    assert_eq!(48, sd_add(16 as u8, 32 as u8));\n    assert_eq!(48, sd_add(16 as u64, 32 as u64));\n}\n```", "```rs\npub struct Unique<T: ?Sized> {\n    pointer: NonZero<*const T>,\n    // NOTE: this marker has no consequences for variance, but is\n    // necessary for dropck to understand that we logically \n    // own a `T`.\n    _marker: PhantomData<T>,\n}\n```", "```rs\n#![feature(box_leak)]\n\nfn main() {\n    let x = Box::new(41);\n    let static_ref: &'static mut usize = Box::leak(x);\n    *static_ref += 1;\n    assert_eq!(*static_ref, 42);\n}\n```", "```rs\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Option<T> {\n    /// No value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    None,\n    /// Some value `T`\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n}\n```", "```rs\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\npub enum Option<T> {\n    None,\n    Some(T),\n}\n```", "```rs\n    pub fn as_mut(&mut self) -> Option<&mut T> {\n        match *self {\n            Some(ref mut x) => Some(x),\n            None => None,\n        }\n    }\n```", "```rs\n    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }\n```", "```rs\npub trait Fn<Args>: FnMut<Args> {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n}\n```", "```rs\nextern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n```", "```rs\nimpl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n    type Output = R;\n\n    extern \"rust-call\" fn call_once(self, args: A) -> R {\n        self.call_box(args)\n    }\n}\n```", "```rs\npub trait FnMut<Args>: FnOnce<Args> {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_mut(&mut self, args: Args) \n        -> Self::Output;\n}\n```", "```rs\npub trait FnOnce<Args> {\n    /// The returned type after the call operator is used.\n    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n    type Output;\n\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n}\n```", "```rs\nfn mlen(input: &str) -> usize {\n    input.len()\n}\n\nfn main() {\n    let v: Option<&str> = Some(\"hope\");\n\n    assert_eq!(v.map(|s| s.len()), v.map(mlen));\n}\n```", "```rs\npub enum Result<T, E> {\n    /// Contains the success value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n\n    /// Contains the error value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n}\n```", "```rs\nuse std::cell::Cell;\n\nenum Project {\n    Apollo,\n    Gemini,\n    Mercury,\n}\n\nstruct Mission {\n    project: Project,\n    number: u8,\n    duration_days: Cell<u8>,\n}\n\nfn main() {\n    let mission = Mission {\n        project: Project::Mercury,\n        number: 7,\n        duration_days: Cell::new(255),\n    };\n\n    mission.duration_days.set(0);\n    assert_eq!(0, mission.duration_days.get());\n}\n```", "```rs\npub struct Cell<T> {\n    value: UnsafeCell<T>,\n}\n```", "```rs\npub struct UnsafeCell<T: ?Sized> {\n    value: T,\n}\n```", "```rs\nimpl<T: ?Sized> !Sync for UnsafeCell<T> {}\n```", "```rs\nimpl<T> UnsafeCell<T> {\n    pub const fn new(value: T) -> UnsafeCell<T> {\n        UnsafeCell { value: value }\n    }\n\n    pub unsafe fn into_inner(self) -> T {\n        self.value\n    }\n}\n\nimpl<T: ?Sized> UnsafeCell<T> {\n    pub fn get(&self) -> *mut T {\n        &self.value as *const T as *mut T\n    }\n}\n```", "```rs\nimpl<T> Cell<T> {\n    pub const fn new(value: T) -> Cell<T> {\n        Cell {\n            value: UnsafeCell::new(value),\n        }\n    }\n```", "```rs\n    pub fn as_ptr(&self) -> *mut T {\n        self.value.get()\n    }\n\n    pub fn get_mut(&mut self) -> &mut T {\n        unsafe {\n            &mut *self.value.get()\n        }\n    }\n\n    pub fn into_inner(self) -> T {\n        unsafe { self.value.into_inner() }\n    }\n```", "```rs\n    pub fn set(&self, val: T) {\n        let old = self.replace(val);\n        drop(old);\n    }\n```", "```rs\n    pub fn swap(&self, other: &Self) {\n        if ptr::eq(self, other) {\n            return;\n        }\n        unsafe {\n            ptr::swap(self.value.get(), other.value.get());\n        }\n    }\n```", "```rs\npub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n    // Give ourselves some scratch space to work with\n    let mut tmp: T = mem::uninitialized();\n\n    // Perform the swap\n    copy_nonoverlapping(x, &mut tmp, 1);\n    copy(y, x, 1); // `x` and `y` may overlap\n    copy_nonoverlapping(&tmp, y, 1);\n\n    // y and t now point to the same thing, but we need to completely \n    forget `tmp`\n    // because it's no longer relevant.\n    mem::forget(tmp);\n}\n```", "```rs\n    pub fn replace(&self, val: T) -> T {\n        mem::replace(unsafe { &mut *self.value.get() }, val)\n    }\n}\n```", "```rs\npub fn replace<T>(dest: &mut T, mut src: T) -> T {\n    swap(dest, &mut src);\n    src\n}\n```", "```rs\npub fn swap<T>(x: &mut T, y: &mut T) {\n    unsafe {\n        ptr::swap_nonoverlapping(x, y, 1);\n    }\n}\n```", "```rs\npub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n    let x = x as *mut u8;\n    let y = y as *mut u8;\n    let len = mem::size_of::<T>() * count;\n    swap_nonoverlapping_bytes(x, y, len)\n}\n```", "```rs\nunsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n    // The approach here is to utilize simd to swap x & y efficiently. \n    // Testing reveals that swapping either 32 bytes or 64 bytes at\n    // a time is most efficient for intel Haswell E processors. \n    // LLVM is more able to optimize if we give a struct a \n    // #[repr(simd)], even if we don't actually use this struct\n    // directly.\n    //\n    // FIXME repr(simd) broken on emscripten and redox\n    // It's also broken on big-endian powerpc64 and s390x.  #42778\n    #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\",\n                       target_endian = \"big\")),\n               repr(simd))]\n    struct Block(u64, u64, u64, u64);\n    struct UnalignedBlock(u64, u64, u64, u64);\n\n    let block_size = mem::size_of::<Block>();\n\n    // Loop through x & y, copying them `Block` at a time\n    // The optimizer should unroll the loop fully for most types\n    // N.B. We can't use a for loop as the `range` impl calls \n    // `mem::swap` recursively\n    let mut i = 0;\n    while i + block_size <= len {\n        // Create some uninitialized memory as scratch space\n\n        // Declaring `t` here avoids aligning the stack when this loop \n        // is unused\n        let mut t: Block = mem::uninitialized();\n        let t = &mut t as *mut _ as *mut u8;\n        let x = x.offset(i as isize);\n        let y = y.offset(i as isize);\n\n        // Swap a block of bytes of x & y, using t as a temporary \n        // buffer. This should be optimized into efficient SIMD \n        // operations where available\n        copy_nonoverlapping(x, t, block_size);\n        copy_nonoverlapping(y, x, block_size);\n        copy_nonoverlapping(t, y, block_size);\n        i += block_size;\n    }\n\n    if i < len {\n        // Swap any remaining bytes\n        let mut t: UnalignedBlock = mem::uninitialized();\n        let rem = len - i;\n\n        let t = &mut t as *mut _ as *mut u8;\n        let x = x.offset(i as isize);\n        let y = y.offset(i as isize);\n\n        copy_nonoverlapping(x, t, rem);\n        copy_nonoverlapping(y, x, rem);\n        copy_nonoverlapping(t, y, rem);\n    }\n}\n```", "```rs\npub struct RefCell<T: ?Sized> {\n    borrow: Cell<BorrowFlag>,\n    value: UnsafeCell<T>,\n}\n```", "```rs\n// Values [1, MAX-1] represent the number of `Ref` active\n// (will not outgrow its range since `usize` is the size \n// of the address space)\ntype BorrowFlag = usize;\nconst UNUSED: BorrowFlag = 0;\nconst WRITING: BorrowFlag = !0;\n```", "```rs\n    pub fn try_borrow(&self) -> Result<Ref<T>, BorrowError> {\n        match BorrowRef::new(&self.borrow) {\n            Some(b) => Ok(Ref {\n                value: unsafe { &*self.value.get() },\n                borrow: b,\n            }),\n            None => Err(BorrowError { _private: () }),\n        }\n    }\n```", "```rs\nstruct BorrowRef<'b> {\n    borrow: &'b Cell<BorrowFlag>,\n}\n\nimpl<'b> BorrowRef<'b> {\n    #[inline]\n    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRef<'b>> {\n        match borrow.get() {\n            WRITING => None,\n            b => {\n                borrow.set(b + 1);\n                Some(BorrowRef { borrow: borrow })\n            },\n        }\n    }\n}\n\nimpl<'b> Drop for BorrowRef<'b> {\n    #[inline]\n    fn drop(&mut self) {\n        let borrow = self.borrow.get();\n        debug_assert!(borrow != WRITING && borrow != UNUSED);\n        self.borrow.set(borrow - 1);\n    }\n}\n```", "```rs\n    pub fn try_borrow_mut(&self) -> Result<RefMut<T>, BorrowMutError> {\n        match BorrowRefMut::new(&self.borrow) {\n            Some(b) => Ok(RefMut {\n                value: unsafe { &mut *self.value.get() },\n                borrow: b,\n            }),\n            None => Err(BorrowMutError { _private: () }),\n        }\n    }\n```", "```rs\nstruct BorrowRefMut<'b> {\n    borrow: &'b Cell<BorrowFlag>,\n}\n\nimpl<'b> Drop for BorrowRefMut<'b> {\n    #[inline]\n    fn drop(&mut self) {\n        let borrow = self.borrow.get();\n        debug_assert!(borrow == WRITING);\n        self.borrow.set(UNUSED);\n    }\n}\n\nimpl<'b> BorrowRefMut<'b> {\n    #[inline]\n    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRefMut<'b>> {\n        match borrow.get() {\n            UNUSED => {\n                borrow.set(WRITING);\n                Some(BorrowRefMut { borrow: borrow })\n            },\n            _ => None,\n        }\n    }\n}\n```", "```rs\npub struct Rc<T: ?Sized> {\n    ptr: Shared<RcBox<T>>,\n    phantom: PhantomData<T>,\n}\n```", "```rs\n    pub fn new(ptr: *mut T) -> Option<Self> {\n        NonZero::new(ptr as *const T).map(|nz| Shared { pointer: nz })\n    }\n```", "```rs\npub struct NonZero<T: Zeroable>(T);\n\nimpl<T: Zeroable> NonZero<T> {\n    /// Creates an instance of NonZero with the provided value.\n    /// You must indeed ensure that the value is actually \"non-zero\".\n    #[unstable(feature = \"nonzero\",\n               reason = \"needs an RFC to flesh out the design\",\n               issue = \"27730\")]\n    #[inline]\n    pub const unsafe fn new_unchecked(inner: T) -> Self {\n        NonZero(inner)\n    }\n\n    /// Creates an instance of NonZero with the provided value.\n    #[inline]\n    pub fn new(inner: T) -> Option<Self> {\n        if inner.is_zero() {\n            None\n        } else {\n            Some(NonZero(inner))\n        }\n    }\n\n    /// Gets the inner value.\n    pub fn get(self) -> T {\n        self.0\n    }\n}\n```", "```rs\npub unsafe trait Zeroable {\n    fn is_zero(&self) -> bool;\n}\n```", "```rs\npub fn new(value: T) -> Rc<T> {\n    Rc {\n        // there is an implicit weak pointer owned by all the strong\n        // pointers, which ensures that the weak destructor never frees\n        // the allocation while the strong destructor is running, even\n        // if the weak pointer is stored inside the strong one.\n        ptr: Shared::from(Box::into_unique(box RcBox {\n            strong: Cell::new(1),\n            weak: Cell::new(1),\n            value,\n        })),\n        phantom: PhantomData,\n    }\n}\n```", "```rs\nunsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n    fn drop(&mut self) {\n        unsafe {\n            let ptr = self.ptr.as_ptr();\n\n            self.dec_strong();\n            if self.strong() == 0 {\n                // destroy the contained object\n                ptr::drop_in_place(self.ptr.as_mut());\n\n                // remove the implicit \"strong weak\" pointer\n                // now that we've destroyed the contents.\n                self.dec_weak();\n\n                if self.weak() == 0 {\n                    Heap.dealloc(ptr as *mut u8, \n                    Layout::for_value(&*ptr));\n                }\n            }\n        }\n    }\n}\n```", "```rs\nimpl<T: ?Sized> Drop for Weak<T> {\n    fn drop(&mut self) {\n        unsafe {\n            let ptr = self.ptr.as_ptr();\n\n            self.dec_weak();\n            // the weak count starts at 1, and will only go to\n            // zero if all the strong pointers have disappeared.\n            if self.weak() == 0 {\n                Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n            }\n        }\n    }\n}\n```", "```rs\npub struct Vec<T> {\n    buf: RawVec<T>,\n    len: usize,\n}\n```", "```rs\npub struct RawVec<T, A: Alloc = Heap> {\n    ptr: Unique<T>,\n    cap: usize,\n    a: A,\n}\n```", "```rs\n    pub fn new() -> Vec<T> {\n        Vec {\n            buf: RawVec::new(),\n            len: 0,\n        }\n    }\n```", "```rs\n    pub fn new() -> Self {\n        Self::new_in(Heap)\n    }\n```", "```rs\n    pub fn new_in(a: A) -> Self {\n        // !0 is usize::MAX. This branch should be stripped \n        // at compile time.\n        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n\n        // Unique::empty() doubles as \"unallocated\" and \"zero-sized\n        // allocation\"\n        RawVec {\n            ptr: Unique::empty(),\n            cap,\n            a,\n        }\n    }\n```", "```rs\n    fn allocate_in(cap: usize, zeroed: bool, mut a: A) -> Self {\n        unsafe {\n            let elem_size = mem::size_of::<T>();\n\n            let alloc_size = \n            cap.checked_mul(elem_size).expect(\"capacity overflow\");\n            alloc_guard(alloc_size);\n\n            // handles ZSTs and `cap = 0` alike\n            let ptr = if alloc_size == 0 {\n                mem::align_of::<T>() as *mut u8\n            } else {\n                let align = mem::align_of::<T>();\n                let result = if zeroed {\n                    a.alloc_zeroed(Layout::from_size_align(\n                        alloc_size, align).unwrap())\n                } else {\n                    a.alloc(Layout::from_size_align(\n                        alloc_size, align).unwrap())\n                };\n                match result {\n                    Ok(ptr) => ptr,\n                    Err(err) => a.oom(err),\n                }\n            };\n\n            RawVec {\n                ptr: Unique::new_unchecked(ptr as *mut _),\n                cap,\n                a,\n            }\n        }\n    }\n```", "```rs\n            let elem_size = mem::size_of::<T>();\n\n            let alloc_size = \n            cap.checked_mul(elem_size).expect(\"capacity overflow\");\n            alloc_guard(alloc_size);\n```", "```rs\nfn alloc_guard(alloc_size: usize) {\n    if mem::size_of::<usize>() < 8 {\n        assert!(\n            alloc_size <= ::core::isize::MAX as usize,\n            \"capacity overflow\"\n        );\n    }\n}\n```", "```rs\n            let ptr = if alloc_size == 0 {\n                mem::align_of::<T>() as *mut u8\n            } else {\n```", "```rs\n            } else {\n                let align = mem::align_of::<T>();\n                let result = if zeroed {\n                    a.alloc_zeroed(Layout::from_size_align(alloc_size, \n                        align).unwrap())\n                } else {\n                    a.alloc(Layout::from_size_align(alloc_size, \n                        align).unwrap())\n                };\n                match result {\n                    Ok(ptr) => ptr,\n                    Err(err) => a.oom(err),\n                }\n            };\n```", "```rs\n            RawVec {\n                ptr: Unique::new_unchecked(ptr as *mut _),\n                cap,\n                a,\n            }\n        }\n    }\n```", "```rs\nuse std::io;\nuse std::io::prelude::*;\nuse std::fs::File;\n\nlet mut f = File::open(\"foo.txt\")?;\nlet mut buffer = Vec:with_capacity(1024);\n\nf.read_exact(&mut buffer)?;\n```", "```rs\npub trait Deref {\n    type Target: ?Sized;\n    fn deref(&self) -> &Self::Target;\n}\n```", "```rs\nimpl<T> ops::DerefMut for Vec<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe {\n            let ptr = self.buf.ptr();\n            assume(!ptr.is_null());\n            slice::from_raw_parts_mut(ptr, self.len)\n        }\n    }\n}\n```", "```rs\nlet mut buffer: Vec<u8> = Vec::with_capacity(1024);\nfor _ in 0..1024 {\n  buffer.push(0);\n}\nassert_eq!(1024, buffer.len());\n```", "```rs\nlet buffer = [0; 1024];\nlet buffer = &mut buffer.to_vec();\nassert_eq!(1024, buffer.len());\n}\n```", "```rs\n    pub fn push(&mut self, value: T) {\n        // This will panic or abort if we would allocate > isize::MAX bytes\n        // or if the length increment would overflow for zero-sized types.\n        if self.len == self.buf.cap() {\n            self.buf.double();\n        }\n        unsafe {\n            let end = self.as_mut_ptr().offset(self.len as isize);\n            ptr::write(end, value);\n            self.len += 1;\n        }\n    }\n```", "```rs\n                None => {\n                    // skip to 4 because tiny Vec's are dumb; \n                    // but not if that would cause overflow\n                    let new_cap = if elem_size > (!0) / 8 { \n                                      1 \n                                  } else { \n                                      4 \n                                  };\n                    match self.a.alloc_array::<T>(new_cap) {\n                        Ok(ptr) => (new_cap, ptr),\n                        Err(e) => self.a.oom(e),\n                    }\n                }\n```", "```rs\n        unsafe {\n            let end = self.as_mut_ptr().offset(self.len as isize);\n            ptr::write(end, value);\n            self.len += 1;\n        }\n```", "```rs\n    pub fn insert(&mut self, index: usize, element: T) {\n        let len = self.len();\n        assert!(index <= len);\n\n        // space for the new element\n        if len == self.buf.cap() {\n            self.buf.double();\n        }\n\n        unsafe {\n            // infallible\n            // The spot to put the new value\n            {\n                let p = self.as_mut_ptr().offset(index as isize);\n                // Shift everything over to make space. (Duplicating the\n                // `index`th element into two consecutive places.)\n                ptr::copy(p, p.offset(1), len - index);\n                // Write it in, overwriting the first copy of the `index`th\n                // element.\n                ptr::write(p, element);\n            }\n            self.set_len(len + 1);\n        }\n    }\n```", "```rs\nptr::copy(p, p.offset(1), len - index);\nptr::write(p, element);\n```"]