- en: '*Chapter 5*: Memory Management in Rust'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：Rust中的内存管理'
- en: In *Section 1*, *Getting Started with Systems Programming in Rust*, we covered
    Cargo (the Rust development toolkit), a tour of the Rust language, an introduction
    to the Rust Standard Library, and standard library modules for managing process
    environment, command-line, and time-related functions. While the focus of *Section
    1*, *Getting Started with Systems Programming in Rust*, was to provide an overview
    of the landscape and the foundation for system programming in Rust, *Section 2*,
    *Manage and Control System Resources in Rust*, gets into the details of how to
    manage and control system resources in Rust, including memory, files, terminals,
    processes, and threads.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1节*，*Rust系统编程入门*中，我们介绍了Cargo（Rust开发工具包），Rust语言的概述，Rust标准库的介绍，以及用于管理进程环境、命令行和时间相关函数的标准库模块。虽然*第1节*，*Rust系统编程入门*的重点是提供对系统编程领域的概述和Rust系统编程的基础，但*第2节*，*在Rust中管理和控制系统资源*，将深入探讨如何在Rust中管理和控制系统资源，包括内存、文件、终端、进程和线程。
- en: 'We are now entering *Section 2*, *Manage and Control System Resources in Rust*,
    of the book. *Figure 5.1* provides the context for this section:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在进入本书的*第2节*，*在Rust中管理和控制系统资源*。*图5.1*提供了本节的背景信息：
- en: '![Figure 5.1 – Managing system resources](img/Figure_5.1_B16405.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 管理系统资源](img/Figure_5.1_B16405.jpg)'
- en: Figure 5.1 – Managing system resources
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 管理系统资源
- en: 'In this chapter, we will focus on memory management. The following are the
    key learning outcomes for this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注内存管理。以下是本章的关键学习成果：
- en: The basics of **operating system (OS)** memory management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统（OS）内存管理的基础
- en: Understanding the memory layout of Rust programs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Rust程序的内存布局
- en: The Rust memory management lifecycle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust内存管理生命周期
- en: Adding a dynamic data structure to a template engine
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向模板引擎添加动态数据结构
- en: We will begin the chapter with an overview (or a refresher for those already
    familiar with the topic) of the general principles of memory management in OSes,
    including the memory management lifecycle and the layout of a process in memory.
    We will then cover the memory layout of a running Rust program. This will cover
    how a Rust program is laid out in memory and the characteristics of the heap,
    stack, and static data segments. In the third section, we learn about the Rust
    memory management lifecycle, how it differs from other programming languages,
    and how memory is allocated, manipulated, and released in Rust programs. Lastly,
    we will enhance the template engine that we started to build in [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library and Key Crates for Systems Programming*,
    with a dynamic data structure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章以概述（或对已经熟悉该主题的人进行复习）开始，概述操作系统中的内存管理一般原则，包括内存管理生命周期和进程在内存中的布局。然后，我们将介绍正在运行的Rust程序的内存布局。这包括Rust程序在内存中的布局以及堆、栈和静态数据段的特点。在第三部分，我们将学习Rust内存管理生命周期，它与其他编程语言的不同之处，以及如何在Rust程序中分配、操作和释放内存。最后，我们将增强我们在[*第3章*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057)，*Rust标准库和系统编程关键crate介绍*中开始构建的模板引擎，添加一个动态数据结构。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Rustup and Cargo must be installed in a local development environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rustup和Cargo必须在本地开发环境中安装。
- en: The complete code for this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter05](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter05).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在[https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter05](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter05)找到。
- en: The basics of OS memory management
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统（OS）内存管理的基础
- en: In this section, we will go into the fundamentals of memory management in modern
    OSes. Those already familiar with this topic can skim through this section quickly
    as a refresher.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨现代操作系统中的内存管理基础。那些已经熟悉这个主题的人可以快速浏览本节以进行复习。
- en: Memory is among the most fundamental and critical resources available to a running
    program (process). Memory management deals with the allocation, use, manipulation,
    ownership transfer, and eventual release of memory used by a process. Without
    memory management, executing a program is not possible. Memory management is performed
    by a combination of components, such as the kernel, program instructions, memory
    allocators, and garbage collectors, but the exact mechanism varies across programming
    languages and OSes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是运行程序（进程）可用的最基本和最重要的资源之一。内存管理涉及处理进程使用的内存的分配、使用、操作、所有权转移和最终释放。没有内存管理，无法执行程序。内存管理由内核、程序指令、内存分配器和垃圾收集器等组件的组合执行，但具体机制因编程语言和操作系统而异。
- en: In this section, we will look at the memory management lifecycle and then learn
    the details of how memory is laid out for a process by the operating system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨内存管理生命周期，然后了解操作系统如何为进程布局内存的细节。
- en: The memory management lifecycle
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理生命周期
- en: 'In this section, we will cover the different activities associated with memory
    management:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与内存管理相关的不同活动：
- en: The memory management lifecycle *begins* when a binary executable is run. The
    operating system allocates a virtual memory address space for the program and
    initializes various segments of memory based on the instructions in the binary
    executable.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个可执行二进制文件运行时，内存管理生命周期*开始*。操作系统为程序分配一个虚拟内存地址空间，并根据二进制可执行文件中的指令初始化内存的各个部分。
- en: Memory management activities *continue* as the program processes various inputs
    coming in from I/O devices such as files, networks, and standard input (from the
    command line).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序处理来自I/O设备（如文件、网络和标准输入（来自命令行））的各种输入时，内存管理活动*继续*。
- en: The memory management lifecycle *ends* when the program is terminated (or if
    the program ends abnormally due to error).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序终止（或由于错误异常终止程序）时，内存管理生命周期*结束*。
- en: '*Figure 5.2* shows a typical memory management cycle:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.2* 展示了一个典型的内存管理周期：'
- en: '![Figure 5.2 – Memory lifecycle](img/Figure_5.2_B16405.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 内存生命周期](img/Figure_5.2_B16405.jpg)'
- en: Figure 5.2 – Memory lifecycle
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 内存生命周期
- en: 'Memory management essentially involves four components—**allocation**, **use
    and manipulation**, **deallocation/release**, and **tracking usage**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理本质上涉及四个组件——**分配**、**使用和操作**、**释放/释放**和**跟踪使用**：
- en: '**Memory allocation**: This is explicitly done in low-level programming languages
    by programmers, but is performed transparently in high-level languages. Memory
    allocated can either be of a *fixed-size* (where the size of a data type is determined
    at compilation time, such as integers, Booleans, or fixed-size arrays) or *dynamically-sized*
    (where the memory is increased or decreased or relocated dynamically at runtime,
    for example, resizable arrays).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存分配**：这是在低级编程语言中由程序员显式完成的，但在高级语言中是透明执行的。分配的内存可以是*固定大小*（例如，数据类型的大小在编译时确定，如整数、布尔值或固定大小的数组）或*动态大小*（在运行时动态增加、减少或重新定位内存，例如可调整大小的数组）。'
- en: '**Memory use and manipulation**: The following steps are typical activities
    performed in a program:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存使用和操作**：以下是在程序中执行的典型活动：'
- en: 1\. Defining a named memory area of a particular type (for example, declaring
    a new variable *x* of type integer)
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1. 定义特定类型的命名内存区域（例如，声明一个类型为整数的新的变量 *x*）
- en: 2\. Initializing a variable
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 初始化一个变量
- en: 3\. Modifying the value of the variable
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 修改变量的值
- en: 4\. Copying or moving values to another variable
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4. 将值复制或移动到另一个变量
- en: 5\. Creating and manipulating references to values
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5. 创建和操作值引用
- en: '**Memory release**: This is explicitly performed by the programmer in low-level
    languages, but is handled automatically in high-level languages such as Java,
    Python, JavaScript, and Ruby using a component called the **garbage collector**.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存释放**：在低级语言中由程序员显式执行，但在Java、Python、JavaScript和Ruby等高级语言中，通过名为**垃圾收集器**的组件自动处理。'
- en: '**Memory tracking**: This is done at the kernel level. A program invokes *system
    calls* to allocate and deallocate memory. System calls are executed by the *kernel*,
    which keeps track of memory allocations and releases per process.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存跟踪**：这是在内核级别进行的。程序通过*系统调用*来分配和释放内存。系统调用由*内核*执行，它跟踪每个进程的内存分配和释放。'
- en: '**Swapping/paging**: This is also done by the *kernel*. Modern OSes virtualize
    physical memory resources. Processes do not directly interact with actual physical
    memory addresses. The kernel assigns virtual address space to each process. The
    total sum of virtual address space allocated to all processes in a system can
    be more than the amount of physical memory available in the system, but the processes
    don''t know (or care) about this. The OS manages this using virtual memory management,
    which ensures that the processes are insulated from each other, and programs have
    access to the committed memory over their lifetime. Swapping and paging are techniques
    in **virtual memory management**.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换/分页**：这也由**内核**完成。现代操作系统虚拟化物理内存资源。进程不会直接与实际的物理内存地址交互。内核为每个进程分配虚拟地址空间。系统中所有进程分配的虚拟地址空间总和可能超过系统中可用的物理内存量，但进程并不知道（或不在乎）这一点。操作系统通过虚拟内存管理来管理这一点，确保进程彼此隔离，并且程序在其生命周期内可以访问已提交的内存。交换和分页是**虚拟内存管理**中的技术。'
- en: Paging and swapping
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分页和交换
- en: How does the operating system map the virtual memory address space to physical
    memory? To achieve this, the virtual address space allocated to programs is split
    into fixed-size pages (for example 4 KB or 8 KB chunks). A **page** is a fixed-length
    contiguous block of virtual memory. Thus the virtual memory allocated to a program
    is divided into multiple fixed-length pages. The corresponding unit on the physical
    RAM is a **page frame**, which is a fixed-length block of RAM. Multiple page-frames
    add up to the total physical memory on a system.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 操作系统如何将虚拟内存地址空间映射到物理内存？为了实现这一点，分配给程序的虚拟地址空间被分成固定大小的页面（例如4 KB或8 KB块）。**页面**是虚拟内存中固定长度的连续块。因此，分配给程序的虚拟内存被分成多个固定长度的页面。物理RAM上的对应单位是**页面帧**，它是一个固定长度的RAM块。多个页面帧加起来构成了系统上的总物理内存。
- en: At any point in time, only some of the *virtual pages* of a program need to
    be present in the *physical page frames*. The rest are stored on disk in the *swap
    area*, which is a reserved area of the disk. The kernel maintains a page table
    to track the location of each page in the virtual memory space allocated to a
    program. When a program tries to access a memory location on a page, and if the
    page is not on the page frame, the page is located on disk and is then swapped
    into the main memory. Likewise, unused pages in RAM are swapped back into the
    disk (secondary storage) to make space for active processes. This process is called
    **paging**.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在任何时刻，程序的一些**虚拟页面**需要存在于**物理页面帧**中。其余的存储在磁盘上的**交换区**中，这是磁盘上预留的区域。内核维护一个页面表来跟踪程序分配的虚拟内存空间中每个页面的位置。当程序尝试访问页面上的内存位置，如果页面不在页面帧上，页面就在磁盘上，然后被交换到主内存中。同样，未使用的页面在RAM中也会被交换回磁盘（二级存储）以腾出空间供活动进程使用。这个过程称为**分页**。
- en: If the same technique is applied at the process level (rather than the page
    level), it is called **swapping**, where the pages of one process are swapped
    from memory to disk to make way for another process to be loaded into memory.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在进程级别（而不是页面级别）应用相同的技巧，则称为**交换**，其中将一个进程的页面从内存交换到磁盘，为另一个进程加载到内存腾出空间。
- en: This aspect of memory management that deals with mapping physical RAM to virtual
    address space is called **virtual memory management**. This ensures that processes
    have access to adequate memory as needed, and are also isolated from each other
    and from the kernel. This way, a program cannot accidentally (or deliberately)
    write to the memory space of the kernel or another process, protecting against
    memory corruption, undefined behavior, and security issues.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这方面的内存管理涉及将物理RAM映射到虚拟地址空间，被称为**虚拟内存管理**。这确保了进程在需要时可以访问足够的内存，并且彼此以及与内核隔离。这样，程序就不能意外（或故意）写入内核或另一个进程的内存空间，从而防止内存损坏、未定义行为和安全问题。
- en: We have learned about the memory management lifecycle of a process. Let's now
    understand how a program is laid out in memory by the operating system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了进程的内存管理生命周期。现在让我们了解操作系统如何布局程序在内存中的情况。
- en: The process memory layout
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程内存布局
- en: 'We will now look at the structure of the virtual address space allocated by
    the kernel to a single process. *Figure 5.3* shows the memory layout for a process
    on **Linux**, but similar mechanisms exist for **Unix** and **Windows** OS variants:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看内核为单个进程分配的虚拟地址空间的结构。*图5.3*显示了**Linux**上进程的内存布局，但类似的机制也存在于**Unix**和**Windows**操作系统变体中：
- en: '![Figure 5.3 – Process memory layout](img/Figure_5.3_B16405.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 进程内存布局](img/Figure_5.3_B16405.jpg)'
- en: Figure 5.3 – Process memory layout
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 进程内存布局
- en: A **process** is a running program. When a program is started up, the operating
    system loads it into memory, gives it access to the command-line parameters and
    environment variables, and starts executing the program instructions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程**是一个正在运行的程序。当程序启动时，操作系统将其加载到内存中，给它访问命令行参数和环境变量的权限，并开始执行程序指令。'
- en: The operating system allocates the process some amount of memory. Such allocated
    memory has a structure associated with it, which is called the **memory layout**
    of the process. The memory layout of a process contains several **memory regions**
    (also called **segments**), which are nothing but blocks of *memory pages* (which
    was described in the previous subsection). These segments are shown in *Figure
    5.3*, and described next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统为进程分配一定量的内存。这种分配的内存有一个与之相关的结构，称为进程的**内存布局**。进程的内存布局包含几个**内存区域**（也称为**段**），这些区域不过是*内存页*（在上一小节中已描述）的块。这些段在*图5.3*中显示，并将在下面进行描述。
- en: The portion of *Figure 5.3* marked **A** shows that the overall virtual memory
    space allocated to a process is split into **Kernel space** and **User space**.
    Kernel space is the area of memory where the portion of the kernel is loaded that
    assists the program in managing and communicating with hardware resources. This
    includes kernel code, the kernel's own memory area, and space marked **Reserved**.
    In this chapter, we will focus only on the **User space**, as that is the area
    that is actually used by the program. The kernel space of virtual memory is not
    accessible to the program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.3*中标记为**A**的部分显示，分配给进程的总虚拟内存空间被分割成**内核空间**和**用户空间**。内核空间是内存区域，其中加载了内核的一部分，帮助程序管理和与硬件资源通信。这包括内核代码、内核自己的内存区域和标记为**保留**的空间。在本章中，我们将仅关注**用户空间**，因为这是程序实际使用的区域。虚拟内存的内核空间对程序不可访问。'
- en: 'The user space is segregated into several memory segments, which are described
    here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间被分割成几个内存段，下面将进行描述：
- en: '**Text segment** contains the program''s code and other read-only data such
    as *string literals* and *const parameters*. This portion is directly loaded from
    the program binary (executable or library).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本段**包含程序的代码和其他只读数据，如*字符串字面量*和*常量参数*。这部分直接从程序二进制（可执行文件或库）加载。'
- en: '**Data segment** stores global and static variables that are initialized with
    non-zero values.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据段**存储初始化为非零值的全局和静态变量。'
- en: '**BSS segment** contains uninitialized variables.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BSS段**包含未初始化的变量。'
- en: '**Heap** is used for dynamic memory allocation. The address space of the process
    continues to grow as memory gets allocated on the heap. The heap grows upward,
    which means new items are added at addresses greater than previous items.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆**用于动态内存分配。随着在堆上分配内存，进程的地址空间继续增长。堆向上增长，这意味着新项目被添加到比前一项地址更高的地址。'
- en: '**Stack** is used for *local variables*, and also *function parameters* (in
    some platform architectures). Stacks grow downwards, which means that items put
    earlier in the stack occupy lower address spaces.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈**用于*局部变量*，也用于*函数参数*（在某些平台架构中）。栈向下增长，这意味着较早放入栈中的项目占据较低的地址空间。'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that the stack and the heap are allocated at opposite ends of the process
    address space. As the *stack size* increases, it grows downwards, and as the *heap
    size* increases, it grows upwards. In the event that they meet, a stack overflow
    error occurs or a memory allocation call on the heap will fail.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，栈和堆在进程地址空间的相反端分配。随着*栈大小*的增加，它向下增长，而随着*堆大小*的增加，它向上增长。如果它们相遇，将发生栈溢出错误或堆上的内存分配调用将失败。
- en: In between the stack and the heap, there is also the area where any **shared
    memory** (memory shared across processes), **shared libraries** used by the program,
    or **memory-mapped** areas (areas of memory that reflect a file on a disk) are
    located.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在栈和堆之间，还有一个区域，用于存放任何**共享内存**（跨进程共享的内存）、程序使用的**共享库**或**内存映射**区域（反映磁盘上文件的内存区域）。
- en: Above the stack, there is a segment where **command-line arguments** passed
    to the program and the **environment variables** set for the process are stored.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在栈的上方，有一个区域用于存储传递给程序的**命令行参数**和为进程设置的**环境变量**。
- en: Memory management is a complex topic and a lot of details have been left out
    in the interest of keeping the discussion focused on memory management in Rust.
    However, the basics of virtual memory management and virtual memory addresses
    described earlier are critical for understanding the next section on how Rust
    performs memory management.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理是一个复杂的话题，为了使讨论集中于Rust中的内存管理，省略了很多细节。然而，前面描述的虚拟内存管理和虚拟内存地址的基本原理对于理解下一节中Rust如何执行内存管理是至关重要的。
- en: Understanding the memory layout of Rust programs
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Rust程序的内存布局
- en: In the previous section, we discussed the fundamentals of memory management
    in modern OSes. In this section, we will discuss how a running Rust program is
    laid out in memory by the operating system, and the characteristics of the different
    parts of the virtual memory are used by Rust programs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了现代操作系统中的内存管理基础。在本节中，我们将讨论运行中的Rust程序是如何由操作系统在内存中布局的，以及Rust程序使用虚拟内存不同部分的特点。
- en: Rust program memory layout
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust程序内存布局
- en: In order to understand how Rust achieves the combination of low-memory footprint,
    memory safety, and performance, it is necessary to understand how Rust programs
    are laid out in memory and how they can be controlled programmatically.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Rust如何实现低内存占用、内存安全和性能的结合，有必要了解Rust程序在内存中的布局以及它们如何被程序控制。
- en: A low-memory footprint depends on the efficient management of memory allocations,
    the copying of values, and deallocations. Memory safety deals with ensuring that
    there is no unsafe access to values stored in memory. Performance depends on understanding
    the implications of storing a value in the stack versus the heap versus the static
    data segment. Where Rust shines is that all these tasks are not fully left to
    the programmer like in C/C++. The Rust compiler and its ownership system does
    a lot of the heavy-lifting, preventing entire classes of memory bugs. Let's now
    look at the topic in detail.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 低内存占用依赖于内存分配、值复制和释放的高效管理。内存安全涉及确保对存储在内存中的值的访问是安全的。性能取决于理解将值存储在栈、堆或静态数据段中的影响。Rust的亮点在于，所有这些任务并非完全留给程序员，如C/C++中那样。Rust编译器和它的所有权系统做了很多繁重的工作，防止了整个类别的内存错误。现在让我们详细探讨这个话题。
- en: 'The memory layout of a Rust program is shown in *Figure 5.4*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Rust程序的内存布局如图5.4所示：
- en: '![Figure 5.4 – Rust program memory layout](img/Figure_5.4_B16405.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – Rust程序内存布局](img/Figure_5.4_B16405.jpg)'
- en: Figure 5.4 – Rust program memory layout
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – Rust程序内存布局
- en: 'Let''s walk through this figure to understand the memory layout of a Rust program:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这张图来了解Rust程序的内存布局：
- en: '`cargo build`) is read into system memory by the kernel and executed, it becomes
    a process. The operating system assigns each process its own private user space
    so that different Rust processes don''t interfere with each other accidentally.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`cargo build`)被内核读入系统内存并执行时，它成为一个进程。操作系统为每个进程分配其自己的私有用户空间，以确保不同的Rust进程不会意外地相互干扰。
- en: '**Text segment**: Executable instructions of the Rust program are placed here.
    This is placed below the stack and heap to prevent any overflows from overwriting
    it. This segment is *read-only* so that its contents are not accidentally overwritten.
    However, multiple processes can *share* the text segment. Let''s take the example
    of a text editor written in Rust running in *process 1*. If a second copy of the
    editor is to be executed, then the system will create a new process with its own
    private memory space (let''s call it *process 2*), but will not reload the program
    instruction of the editor. Instead, it will create a reference to the text instructions
    of *process 1*. But the rest of the memory (the data, stack, and so on) is not
    shared across processes.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本段**: Rust程序的可执行指令放置于此。此部分位于栈和堆之下，以防止任何溢出覆盖它。此段是*只读*的，因此其内容不会意外被覆盖。然而，多个进程可以*共享*文本段。让我们以一个用Rust编写的文本编辑器为例，它在*进程1*中运行。如果需要执行编辑器的第二个副本，那么系统将创建一个新的进程，并为其分配自己的私有内存空间（让我们称其为*进程2*），但不会重新加载编辑器的程序指令。相反，它将创建对*进程1*的文本指令的引用。但其余的内存（数据、栈等）不会在进程间共享。'
- en: '`Rc` (single-threaded reference-counting pointer) and `Arc` (thread-safe reference
    counting pointer).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rc`（单线程引用计数指针）和`Arc`（线程安全引用计数指针）。'
- en: Examples of types in Rust with a *dynamic size* are `Vectors`, `Strings`, and
    other `collection` types, and these are heap-allocated.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rust中具有*动态大小*的类型示例有`Vectors`、`Strings`和其他`集合`类型，这些都是在堆上分配的。
- en: 'Primitive types such as integers are stack-allocated by default, but the programmer
    can allocate memory in the heap by using a `Box<T>` type (for example, `let y
    =3` allocates memory for integer `y` on the stack and initializes it to `3`, whereas
    `let x: Box<i32> = Box::new(3)` allocates a value for integer `x` on the heap
    and initializes it to `3`).'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '原始类型，如整数，默认情况下是栈分配的，但程序员可以使用`Box<T>`类型（例如，`let y =3`在栈上为整数`y`分配内存并初始化为`3`，而`let
    x: Box<i32> = Box::new(3)`在堆上为整数`x`分配内存并初始化为`3`）在堆上分配内存。'
- en: '**Stack segment**: The stack is the region of the process memory that stores
    *temporary (local) variables*, *function parameters*, and the *return address*
    of the instruction (which is to be executed after the function call is over).
    By default, all memory allocations in Rust are on the stack. Whenever a function
    is called, its variables get memory-allocated on the stack. Memory allocation
    happens in contiguous memory locations one above the other, in a *stack data structure*.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈段**: 栈是进程内存中存储*临时（局部）变量*、*函数参数*和指令的*返回地址*（在函数调用结束后执行）的区域。默认情况下，Rust中的所有内存分配都在栈上。每当调用一个函数时，其变量就会在栈上分配内存。内存分配在连续的内存位置中逐个发生，形成一个*栈数据结构*。'
- en: 'To summarize, here is how the virtual memory allocated to a running Rust program
    looks:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是运行中的Rust程序分配的虚拟内存的视图：
- en: The *code instructions* of a Rust program go into the *text segment* area.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust程序的*代码指令*放入*文本段*区域。
- en: The *primitive data types* are allocated on the *stack*.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原始数据类型*在*栈*上分配。'
- en: The static variables are located in the *data segment*.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态变量位于*数据段*。
- en: The *heap-allocated values* (values whose size is not known at compilation time,
    such as vectors and strings) are stored in the *heap area of the data segment*.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*堆分配的值*（在编译时不知道大小的值，如向量字符串）存储在数据段的*堆区域*。'
- en: The *uninitialized variables* are in the *BSS segment*.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*未初始化的变量*位于*BSS段*。'
- en: Of these, the Rust programmer does not have much control over the *text* segment
    and *BSS* segments, and only primarily works with the *stack*, *heap*, and *static*
    areas of memory. In the next section, we will delve into the characteristics of
    these three memory areas.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些中，Rust程序员对*文本*段和*BSS*段的控制不多，并且主要与内存的*栈*、*堆*和*静态*区域工作。在下文中，我们将深入探讨这三个内存区域的特点。
- en: The characteristics of stack, heap, and static memory
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈、堆和静态内存的特性
- en: We have seen how the different types of variables declared in a Rust program
    are allocated in different regions of the process space. Of the three memory segments,
    we have discussed – **text**, **data**, and **stack** – the text area is not under
    the control of the Rust programmer, but the programmer has the flexibility to
    decide whether to place a value (that is, allocate memory) on the stack, heap,
    or as a static variable. However, there are strong implications of this decision
    because the stack, static variables, and the heap are managed quite differently,
    and their lifetimes are also different. Understanding these trade-offs is an important
    part of writing any Rust program. Let's look at them more closely.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在 Rust 程序中声明的不同类型的变量是如何分配到进程空间的不同区域的。在讨论的三个内存段——**文本**、**数据**和**栈**中，文本区域不受
    Rust 程序员的控制，但程序员有灵活性来决定是否将一个值（即分配内存）放在栈上、堆上或作为静态变量。然而，这个决定有很强的含义，因为栈、静态变量和堆的管理方式截然不同，它们的生命周期也不同。理解这些权衡是编写任何
    Rust 程序的重要部分。让我们更仔细地看看它们。
- en: '*Table 5.1* summarizes the characteristics of stack-allocated versus heap-allocated
    versus static-segment memory. Recall from *Figure 5.4* that stack-allocated memory
    belongs to the *stack segment*, and heap and static variables belong to the *data
    segment* of virtual memory address space:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 5.1* 总结了栈分配、堆分配和静态段内存的特点。回想一下 *图 5.4*，栈分配的内存属于 *栈段*，而堆和静态变量属于虚拟内存地址空间的 *数据段*：'
- en: '![Table 5.1 – Characteristics of the stack, heap, and static memory areas](img/B16405_05_Table_01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![表 5.1 – 栈、堆和静态内存区域的特点](img/B16405_05_Table_01.jpg)'
- en: '![Table 5.1 – Characteristics of the stack, heap, and static memory areas](img/B16405_05_Table_02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![表 5.1 – 栈、堆和静态内存区域的特点](img/B16405_05_Table_02.png)'
- en: Table 5.1 – Characteristics of the stack, heap, and static memory areas
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 – 栈、堆和静态内存区域的特点
- en: Is it important to understand the memory locations of values?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 理解值的内存位置是否重要？
- en: For people who have worked with other high-level programming languages, understanding
    whether a variable was stored in the stack, heap, or static data segments won't
    have really been necessary, as the language compiler, runtime, and garbage collector
    will have abstracted away these details and made it easy for the programmer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些使用过其他高级编程语言的人来说，理解一个变量是存储在栈上、堆上还是静态数据段中，实际上并不是必需的，因为语言的编译器、运行时和垃圾回收器已经抽象了这些细节，使得程序员的工作变得简单。
- en: But in Rust, especially for writing system-oriented programs, awareness of the
    memory layout and the memory model is necessary to select appropriate and efficient
    data structures for various parts of the system design. And in many cases, this
    knowledge is necessary even to get the Rust program to compile!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 Rust 中，尤其是在编写面向系统的程序时，了解内存布局和内存模型对于选择适合和高效的数据结构来设计系统的各个部分是必要的。在很多情况下，这种知识甚至对于使
    Rust 程序编译成功也是必要的！
- en: In this section, we have covered the memory layout of Rust programs and understood
    the characteristics of the stack and data segment memory areas. In the next section,
    we will provide an overview of the Rust memory management lifecycle and a comparison
    with other programming languages. We will also look at the three steps of the
    Rust memory management lifecycle in detail.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 Rust 程序的内存布局，并了解了栈和数据段内存区域的特点。在下一节中，我们将概述 Rust 的内存管理生命周期，并与其他编程语言进行比较。我们还将详细探讨
    Rust 内存管理生命周期的三个步骤。
- en: The Rust memory management lifecycle
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 内存管理生命周期
- en: 'Computer programs can be modeled as finite state machines. A running program
    accepts different forms of inputs (for example, file inputs, command-line arguments,
    network calls, interrupts, and so on) and transitions from one state to another.
    Take the case of a device driver. It can be in either of the following states:
    *uninitialized*, *active*, or *inactive*. When a device driver is just booted
    up (loaded into memory), it is in the *uninitialized* state. When the device registers
    are initialized and ready to accept events, it goes into the *active* state. It
    can be put in suspended mode and not ready to accept inputs, in which case it
    goes into the *inactive* state. You can extend this concept further. For a communications
    device like a serial port, the device driver can be in the *sending* or *receiving*
    state. Interrupts can trigger the transitions from one state to another. Likewise,
    every kind of program, whether it is a kernel component, command-line tool, network
    server, or an e-commerce application, can be modeled in terms of states and transitions.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序可以被建模为有限状态机。一个运行的程序接受不同形式的输入（例如，文件输入、命令行参数、网络调用、中断等）并从一个状态转换到另一个状态。以设备驱动程序为例。它可以处于以下状态之一：*未初始化*、*活动*或*非活动*。当设备驱动程序刚刚启动（加载到内存中）时，它处于*未初始化*状态。当设备寄存器初始化并准备好接受事件时，它进入*活动*状态。它可以被置于挂起模式，此时它不接受输入，在这种情况下，它进入*非活动*状态。你可以进一步扩展这个概念。对于像串行端口这样的通信设备，设备驱动程序可以处于*发送*或*接收*状态。中断可以触发从一个状态到另一个状态的转换。同样，任何类型的程序，无论是内核组件、命令行工具、网络服务器还是电子商务应用，都可以用状态和转换来建模。
- en: Why is the discussion around state important for memory management? Because,
    state is represented in a program by the programmer as a set of variables with
    values, and these values are stored in the virtual memory of a running program
    (process). Since a program goes through numerous state transitions (top social
    media site programs handle several hundred million state transitions per day),
    all this state and these transitions are represented in memory and then persisted
    to disk. Every component of the modern layered application stack (including frontend
    apps, backend servers, the network stack, other system programs, and operating
    system kernel utilities) needs to be able to efficiently allocate, use, and release
    memory. Hence, it is important to understand how the memory layout of a program
    changes over its lifetime, and what the programmer can do to make it efficient.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么围绕状态讨论对内存管理很重要？因为，程序员在程序中以一组具有值的变量的形式表示状态，这些值存储在运行程序的虚拟内存中（进程）。由于程序会经历无数的状态转换（例如，顶级社交媒体网站程序每天处理数亿个状态转换），所有这些状态和转换都表示在内存中，然后持久化到磁盘。现代分层应用程序堆栈的每个组件（包括前端应用、后端服务器、网络堆栈、其他系统程序和操作系统内核工具）都需要能够高效地分配、使用和释放内存。因此，了解程序在其生命周期内内存布局如何变化，以及程序员可以做什么来使其高效，是很重要的。
- en: With this background, let's move on to an overview of the Rust memory management
    lifecycle.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，让我们继续概述Rust内存管理生命周期。
- en: Overview of the Rust memory management lifecycle
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust内存管理生命周期的概述
- en: 'Let''s now compare the memory management lifecycle for other programming languages
    with Rust. Let''s also take a look at *Figure 5.5*, which shows how memory management
    in Rust works, in comparison with other programming languages:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来比较其他编程语言与Rust的内存管理生命周期。让我们也看看*图5.5*，它展示了与其他编程语言相比，Rust中内存管理是如何工作的：
- en: '![Figure 5.5 – Memory management in other programming languages](img/Figure_5.5_B16405.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 其他编程语言中的内存管理](img/Figure_5.5_B16405.jpg)'
- en: Figure 5.5 – Memory management in other programming languages
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 其他编程语言中的内存管理
- en: In order to appreciate the Rust memory model, it is important to understand
    how memory management is done in other programming languages. *Figure 5.5* shows
    how two sets of programming languages—high-level and low-level—manage memory and
    compare it with Rust.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了欣赏Rust内存模型，了解其他编程语言中的内存管理方式是很重要的。*图5.5*展示了两组编程语言——高级和低级——如何管理内存，并将其与Rust进行比较。
- en: 'There are three main steps in the memory management lifecycle:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理生命周期中有三个主要步骤：
- en: Memory allocation
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存分配
- en: Memory use and manipulation
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存使用和操作
- en: Memory release (deallocation)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存释放（解除分配）
- en: The way these three steps are performed varies across programming languages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个步骤的执行方式在不同编程语言中各不相同。
- en: High-level languages (such as Java, JavaScript, and Python) hide a lot of the
    details of memory management from the programmer (who has limited control), automate
    memory deallocation using a garbage collector component, and do not provide direct
    access to memory pointers to the programmer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言（如 Java、JavaScript 和 Python）从程序员（控制力有限）那里隐藏了内存管理的许多细节，使用垃圾回收组件自动执行内存释放，并且不向程序员提供对内存指针的直接访问。
- en: Low-level (also known as system) programming languages such as C/C++ provide
    a complete degree of control to the programmer but do not provide any safety nets.
    Managing memory efficiently is left solely to the skills and meticulousness of
    the developer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 低级（也称为系统）编程语言如 C/C++ 提供给程序员完全的控制权，但不提供任何安全网。高效地管理内存完全取决于开发人员的技能和细致程度。
- en: Rust combines the best of both worlds. A Rust programmer has full control over
    memory allocation, being able to manipulate and move around values and references
    in memory, but is subjected to strict Rust ownership rules. Memory deallocation
    is automated by the compiler-generated code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 结合了两者之长。Rust 程序员对内存分配拥有完全的控制权，能够操纵和移动内存中的值和引用，但受到严格的 Rust 所有权规则的约束。内存释放由编译器生成的代码自动化完成。
- en: High-level versus low-level programming languages
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 高级编程语言与低级编程语言
- en: Note that the terms **high-level** and **low-level** are used to classify programming
    languages based on the level of abstraction provided to the programmer. Languages
    that provide higher-level programming abstractions are easier to program in and
    take away many of the hard responsibilities around memory management, at the cost
    of lack of control for the programmer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，术语**高级**和**低级**是用来根据提供给程序员的抽象级别对编程语言进行分类的。提供更高层次编程抽象的语言更容易编程，并从内存管理周围的许多困难责任中解脱出来，但以程序员控制力不足为代价。
- en: On the other hand, system languages such as C and C++ provide full control and
    responsibility to the programmer to manage memory and other system resources.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，系统语言如 C 和 C++ 提供给程序员完全的控制权和责任来管理内存和其他系统资源。
- en: We have seen an overview of the memory management approaches of Rust versus
    other programming languages. Let's now see them in more detail in the following
    subsections.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Rust 与其他编程语言在内存管理方法上的概述。现在让我们在以下小节中更详细地了解它们。
- en: Memory allocation
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分配
- en: Memory allocation is the process of storing a value (it can be an integer, string,
    vector, or higher-level data structures such as network ports, parsers, or e-commerce
    orders) to a location in memory. As part of memory allocation, a programmer instantiates
    a data type (primitive or user-defined) and assigns an initial value to it. The
    Rust program invokes system calls to allocate memory.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配是将一个值（它可以是一个整数、字符串、向量或更高层次的数据结构，如网络端口、解析器或电子商务订单）存储到内存中的过程。作为内存分配的一部分，程序员实例化一个数据类型（原始或用户定义）并为其分配一个初始值。Rust
    程序通过系统调用分配内存。
- en: In higher-level languages, the programmer declares variables using the specified
    syntax. The language compiler (in conjunction with the language runtime) handles
    the allocation and exact location of the various data types in virtual memory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级语言中，程序员使用指定的语法声明变量。语言编译器（与语言运行时一起）处理各种数据类型在虚拟内存中的分配和确切位置。
- en: In C/C++, the programmer controls memory allocation (and reallocation) through
    the system call interfaces provided. The language (compiler, runtime) does not
    intervene in the programmer's decision.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 中，程序员通过系统调用接口控制内存分配（和重新分配），语言（编译器、运行时）不会干预程序员的决策。
- en: In Rust, by default, when the programmer initializes a data type and assigns
    it a value, the operating system allocates memory on the stack. This applies to
    all primitive types (integers, floating points, char, Boolean, fixed-length arrays),
    function local variables, function parameters, and other fixed-length data types
    (such as smart pointers). But the programmer has the option to explicitly place
    a primitive data type on the heap by using `Box<T>` smart pointers. Secondly,
    all dynamic values (for example, strings and vectors whose size changes at runtime)
    are stored on the heap, and the smart pointer to this heap data is placed on the
    stack. To summarize, for fixed-length variables, values are stored on the stack,
    variables with a dynamic length are allocated memory on the heap segment, and
    a pointer to the starting location of heap-allocated memory is stored on the stack.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，默认情况下，当程序员初始化一个数据类型并为其赋值时，操作系统会在栈上分配内存。这适用于所有原始类型（整数、浮点数、字符、布尔值、固定长度数组）、函数局部变量、函数参数以及其他固定长度数据类型（例如智能指针）。但是，程序员可以选择使用
    `Box<T>` 智能指针显式地将原始数据类型放置在堆上。其次，所有动态值（例如，大小在运行时变化的字符串和向量）都存储在堆上，而指向这些堆数据的智能指针则存储在栈上。总结一下，对于固定长度变量，值存储在栈上，具有动态长度的变量在堆段上分配内存，而指向堆分配内存起始位置的指针存储在栈上。
- en: Let's now look at some additional information about memory allocation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些关于内存分配的附加信息。
- en: All data types declared in a Rust program have their size calculated at compile
    time; they are not dynamically allocated or freed. So what, then, is dynamic?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 程序中声明的所有数据类型在编译时都会计算其大小；它们不是动态分配或释放的。那么，动态分配是什么呢？
- en: When there are values that change over time (for example, a `String` whose value
    is not known at compile time or a collection where the number of elements is not
    known upfront), these are allocated at runtime on the heap, but a reference to
    such data is stored as a pointer (which has a fixed size) on the stack.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在随时间变化而变化的值（例如，编译时不知道值的 `String` 或元素数量事先不知道的集合）时，这些值在运行时在堆上分配，但此类数据的引用作为指针（具有固定大小）存储在栈上。
- en: 'For example, run the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行以下代码：
- en: '[PRE0]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you run this program on a 64-bit system, the size of `String` will be printed
    as `String` without even creating a string variable or assigning a value to it?
    This is because Rust does not care how long a string is, in order to compute its
    size. Sound strange? This is how it works.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 64 位系统上运行此程序时，即使没有创建字符串变量或为其赋值，也会打印出 `String` 的大小？这是因为 Rust 不关心字符串有多长，为了计算其大小。听起来很奇怪？这就是它的工作方式。
- en: 'In Rust, `String` is a smart pointer. This is illustrated in *Figure 5.6*.
    It has three components: a `String` smart pointer occupies 64 bits (or 8 bytes),
    hence the total size occupied by a variable of the `String` type is 24 bytes.
    This is regardless of the actual value contained in the string, which is stored
    in the heap, while the smart pointer (24 bytes) is stored on the stack. Note that
    even though the size of the `String` smart pointer is fixed, the actual size of
    the memory allocated on the heap may vary as the value of string changes during
    program runtime.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，`String` 是一个智能指针。这可以在 *图 5.6* 中体现出来。它有三个组成部分：一个 `String` 智能指针占用 64
    位（或 8 字节），因此 `String` 类型变量的总大小为 24 字节。这不受字符串中实际值的影响，实际值存储在堆上，而智能指针（24 字节）存储在栈上。请注意，尽管
    `String` 智能指针的大小是固定的，但堆上分配的实际内存大小可能会随着程序运行时字符串值的改变而变化。
- en: '![Figure 5.6 – Structure of a String smart pointer in Rust](img/Figure_5.6_B16405.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – Rust 中 String 智能指针的结构](img/Figure_5.6_B16405.jpg)'
- en: Figure 5.6 – Structure of a String smart pointer in Rust
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – Rust 中 String 智能指针的结构
- en: In this subsection, we have discussed various aspects of memory allocation in
    a Rust program. In the next subsection, we will look at the second step of the
    memory management lifecycle, which is about memory manipulation and use within
    the Rust program.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们讨论了 Rust 程序中内存分配的各个方面。在下一小节中，我们将探讨内存管理生命周期的第二步，即 Rust 程序中的内存操作和使用。
- en: Memory use and manipulation
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存使用和操作
- en: Memory use and manipulation refer to program instructions such as modifying
    the value assigned to a variable, copying a value to another variable, moving
    the ownership of a value from one variable to another, and creating new references
    to an existing value. In Rust, `copy`, `move`, and `clone` are three fundamental
    memory manipulation operations. The `move` operation transfers ownership of data
    from one variable to another. The `copy` operation allows a value associated with
    a variable to be duplicated with a bit-wise copy. Implementing the `clone` trait
    on a data type allows the duplication of values instead of move semantics.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 内存使用和操作指的是程序指令，例如修改分配给变量的值、将值复制到另一个变量、将值的所有权从一个变量移动到另一个变量，以及创建对现有值的新的引用。在Rust中，`copy`、`move`和`clone`是三种基本的内存操作。`move`操作将数据的所有权从另一个变量转移到另一个变量。`copy`操作允许与变量关联的值通过位复制进行复制。在数据类型上实现`clone`特性允许复制值而不是移动语义。
- en: All primitive data types (such as integers, bools, and chars) implement the
    `copy` trait by default. This means assigning a variable of the primitive data
    type to another variable of same type copies the value (duplicates). User-defined
    data types such as structs can implement `copy` if all their data members also
    implement the `copy` trait.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原始数据类型（例如整数、布尔值和字符）默认实现`copy`特性。这意味着将原始数据类型的变量赋值给另一个同类型的变量时，会复制值（副本）。用户定义的数据类型，如结构体，如果它们的所有数据成员也实现了`copy`特性，则可以自己实现`copy`。
- en: Anything that does not implement `copy` is moved by default. For example, for
    the `Vec` data type, all operations (for example, passing a `Vec` value as a function
    argument, returning a `Vec` from a function, assignment, pattern matching) are
    *move* operations. Rust does not have a `Move` trait explicitly because it is
    the default.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 任何没有实现`copy`的东西默认都是移动的。例如，对于`Vec`数据类型，所有操作（例如，将`Vec`值作为函数参数传递、从函数返回`Vec`、赋值、模式匹配）都是*移动*操作。Rust没有显式地有`Move`特性，因为它默认就是这样的。
- en: For non-copy data types, `move` is the default behavior. To implement arbitrary
    `copy` operations on non-copy types, the `clone` trait can be implemented on the
    type.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非复制数据类型，`move`是默认行为。为了在非复制类型上实现任意的`copy`操作，可以在该类型上实现`clone`特性。
- en: More details can be found in the Rust book at [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/).
    In high-level languages, the programmer can initialize a variable, assign values
    to variables, and copy values to other variables. Generally, high-level languages
    do not have explicit pointer semantics or arithmetic but use references. The difference
    is that a pointer refers to the exact memory address of a value, but references
    are aliases for another variable. While the programmer uses reference semantics,
    the language internally implements pointer operations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息可以在Rust书籍中找到，请参阅[https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)。在高级语言中，程序员可以初始化变量，将值赋给变量，并将值复制到其他变量。通常，高级语言没有显式的指针语义或算术，而是使用引用。区别在于指针指向值的精确内存地址，而引用是另一个变量的别名。当程序员使用引用语义时，语言内部实现指针操作。
- en: In C/C++, the programmer can also initialize variables, and assign and copy
    values. In addition, pointer operations are possible. Pointers allow you to write
    directly to any memory allocated by the process. The problem with this model is
    that this gives rise to several types of memory safety issues, such as free-after-use,
    double-free, and buffer overflows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在C/C++中，程序员也可以初始化变量，分配和复制值。此外，还可能进行指针操作。指针允许你直接写入进程分配的任何内存。这种模型的问题在于，这会导致几种内存安全问题，例如使用后释放、双重释放和缓冲区溢出。
- en: 'In Rust, memory use and manipulation are governed by certain rules:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，内存的使用和操作遵循某些规则：
- en: First, all variables in Rust are immutable by default. If a value contained
    in a variable needs to be altered, the variable has to be declared explicitly
    as mutable (with the `mut` keyword).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，Rust中的所有变量默认是不可变的。如果变量中的值需要更改，则必须显式地将变量声明为可变的（使用`mut`关键字）。
- en: Secondly, there are ownership rules that apply to data access, which are listed
    in a later subsection.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，有一些适用于数据访问的所有权规则，这些规则将在后面的子节中列出。
- en: Third, there are rules of references (borrowing) that apply when it comes to
    sharing a value with one or more variables, which is also covered later.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，当涉及到与一个或多个变量共享值时，有一些引用（借用）规则适用，这些规则也将在后面进行说明。
- en: Fourth, there are lifetimes, which give information to the compiler about how
    two or more references relate to each other. This helps the compiler prevent memory
    safety issues by checking if the references are valid.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四，有生命周期，它向编译器提供有关两个或多个引用如何相互关联的信息。这有助于编译器通过检查引用是否有效来防止内存安全问题。
- en: These concepts and rules make programming in Rust very different (and more difficult
    at times) from other programming languages. But it is also these very concepts
    that impart super-powers to Rust in areas of memory and thread-safety. Importantly,
    Rust provides these benefits without runtime costs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念和规则使得在Rust中编程与其他编程语言非常不同（有时也更为困难）。但正是这些概念赋予了Rust在内存和线程安全性方面的超级能力。重要的是，Rust提供了这些好处而不产生运行时成本。
- en: Let's now recap the Rust rules for ownership and for borrowing and references
    in the subsections that follow.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下Rust的拥有性以及接下来的子节中关于借用和引用的规则。
- en: Rust ownership rules
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rust拥有性规则
- en: 'Ownership is arguably Rust''s most unique feature. It gives memory safety to
    Rust programs without an external garbage collector or relying entirely on the
    programmer''s skillset. There are three ownership rules in Rust, which are listed
    here. More details can be found at the following link: [https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有性可以说是Rust最独特的特性。它通过没有外部垃圾回收器或完全依赖程序员的技能集，为Rust程序提供了内存安全性。Rust中有三条拥有性规则，这里列出了。更多详情可以在以下链接中找到：[https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)。
- en: The rules governing Rust ownership
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Rust拥有性的规则
- en: 'In Rust, every value has an owner. At any point in time, for a given value,
    there can be only one owner. A value is dropped (the memory associated with it
    is deallocated) when its owner goes out of scope. Some examples of the scope of
    a variable are a function, a `for` loop, a statement, or an arm of a match expression.
    More details on scope can be found here: [https://doc.rust-lang.org/reference/destructors.html#drop-scopes](https://doc.rust-lang.org/reference/destructors.html#drop-scopes).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，每个值都有一个所有者。在任何时刻，对于给定的值，只能有一个所有者。当所有者的作用域结束时，值将被丢弃（与其相关的内存将被释放）。变量的作用域的例子包括函数、`for`循环、语句或`match`表达式的分支。更多关于作用域的详情可以在这里找到：[https://doc.rust-lang.org/reference/destructors.html#drop-scopes](https://doc.rust-lang.org/reference/destructors.html#drop-scopes)。
- en: The really interesting aspect of Rust is that these ownership rules are not
    meant for the programmer to memorize, but the Rust compiler enforces these rules.
    Another significant implication of these ownership rules is that the same rules
    also ensure thready safety, in addition to memory safety.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Rust真正有趣的一面是，这些拥有性规则并不是为了让程序员去记忆，而是Rust编译器强制执行这些规则。这些拥有性规则的另一个重要含义是，除了内存安全性外，相同的规则还确保了线程安全性。
- en: Rust borrowing and references
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rust的借用和引用
- en: In Rust, references simply borrow a value and are indicated by the `&` symbol.
    They basically allow you to refer to a value without taking ownership of the value.
    This is unlike smart pointers such as `String`, `Vector`, `Box`, and `Rc`, which
    own the value they point to.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，引用只是借用一个值，并由`&`符号表示。它们基本上允许你引用一个值而不拥有该值。这与拥有它们所指向的值的智能指针（如`String`、`Vector`、`Box`和`Rc`）不同。
- en: Taking a reference to a value is called **borrowing**, which is a temporary
    reference to an object, but it has to be returned and cannot be destroyed by the
    borrower (only the owner can deallocate memory). If there are multiple borrows
    of a value, the compiler ensures that all borrows end before the object is destroyed.
    This eliminates memory errors such as **use-after-free** and **double-free** errors.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个值的引用称为**借用**，它是对对象的临时引用，但必须返回，不能被借用者（只有所有者才能释放内存）销毁。如果一个值有多个借用，编译器将确保在对象被销毁之前所有借用都结束。这消除了如**使用后释放**和**双重释放**等内存错误。
- en: More details on Rust borrowing and references can be found at [https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Rust借用和引用的详情可以在以下链接中找到：[https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)。
- en: The rules governing Rust references
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Rust引用的规则
- en: A value stored in memory can either have one mutable reference to it or any
    number of immutable references (but not both).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在内存中的值可以有一个可变引用或任意数量的不可变引用（但不能同时两者都有）。
- en: References must always be valid. The borrow checker portion of the Rust compiler
    stops compilation if invalid references are found in code. When it's ambiguous,
    the Rust compiler also asks the programmer to explicitly specify the lifetime
    of references.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 引用必须始终有效。Rust编译器的借用检查部分如果在代码中发现无效引用，将停止编译。当情况不明确时，Rust编译器也会要求程序员显式指定引用的生存期。
- en: In this subsection, we have covered several rules governing the manipulation
    of variables and values in memory and the rules governing them. In the next subsection,
    we will look at the last aspect of the memory management lifecycle, which is about
    deallocating memory after use.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们讨论了管理内存中变量和值以及它们的规则的几个规则。在下一个小节中，我们将探讨内存管理生命周期的最后一个方面，即使用后释放内存。
- en: Memory deallocation
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存释放
- en: Memory deallocation deals with the question of how to release memory back to
    the operating system from the Rust program. Stack-allocated values are automatically
    released, as this is a managed-memory area. Static variables have a lifetime until
    the end of the program, so they get released automatically when the program terminates.
    The real question around memory release applies to heap-allocated memory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 内存释放处理的是如何从Rust程序中将内存释放回操作系统的问题。栈分配的值会自动释放，因为这是一个受管理的内存区域。静态变量有程序结束的生存期，因此当程序结束时它们会自动释放。真正的问题在于如何释放堆分配的内存。
- en: 'Some of these values may not be required to be held in memory until the end
    of the program, in which case they can be released. But the mechanism of such
    memory release varies widely across different programming language groups:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些值可能不需要保留在内存中直到程序结束，在这种情况下，它们可以被释放。但是，这种内存释放的机制在不同编程语言组之间差异很大：
- en: Higher-level languages do not require the programmers to explicitly release
    memory when they are no longer needed. Instead, they use a mechanism called **garbage
    collection**. In this model, a runtime component called **garbage collector**
    analyzes the *heap-allocated* memory of the process, determines the unused objects
    using specialized algorithms, and deallocates them. This helps improve memory
    safety, prevents memory leaks, and makes programming easier for developers.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级语言在不再需要时不需要程序员显式释放内存。相反，它们使用一种称为**垃圾回收**的机制。在这个模型中，一个称为**垃圾收集器**的运行时组件分析进程的**堆分配**内存，使用专门的算法确定未使用的对象，并释放它们。这有助于提高内存安全性，防止内存泄漏，并使开发者的编程更容易。
- en: In C/C++, the deallocation of memory is the responsibility of the programmer.
    Forgetting to release memory causes **memory leaks**. Accessing values after memory
    has been released causes memory safety issues. In large, complex code bases, or
    in code maintained by multiple people, this causes serious issues.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C/C++中，内存释放是程序员的职责。忘记释放内存会导致**内存泄漏**。在内存已释放后访问值会导致内存安全问题。在大型、复杂的代码库中，或者由多人维护的代码中，这会导致严重问题。
- en: Rust takes a very different approach to memory deallocation. Rust neither has
    a `Drop` trait) for a type, and that will be called by the compiler-generated
    code. The benefit of this approach is that it gives fine-grained memory control
    (like C/C++) while freeing the Rust programmer from having to manually deallocate
    memory (like high-level languages), without the drawbacks of the garbage collector
    (latency and unpredictable GC pauses).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust在内存释放方面采取了非常不同的方法。Rust没有为类型提供`Drop`特质，它将由编译器生成的代码调用。这种方法的优点是它提供了细粒度的内存控制（类似于C/C++），同时让Rust程序员免于手动释放内存（类似于高级语言），而没有垃圾收集器的缺点（延迟和不可预测的GC暂停）。
- en: Note that in Rust, only the owner of a value can release the memory associated
    with it. References do not own the data they point to, so cannot deallocate memory.
    But smart pointers own the data they point to. The compiler generates code that
    calls the `drop` method from the `Drop` trait associated with the smart pointer
    when the smart pointer goes out of scope.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，在Rust中，只有值的拥有者才能释放与其相关的内存。引用不拥有它们指向的数据，因此不能释放内存。但是智能指针拥有它们指向的数据。当智能指针超出作用域时，编译器生成的代码会调用与智能指针关联的`Drop`特质的`drop`方法。
- en: Also, these memory deallocation rules apply only to heap-allocated memory as
    the other two types of memory segments (stack and statics) are managed directly
    by the operating system.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，这些内存释放规则仅适用于堆分配内存，因为其他两种内存段（栈和静态）是由操作系统直接管理的。
- en: We have so far seen the rules governing memory allocation, manipulation, and
    release in Rust programs. All these collectively aim to achieve the primary goal
    of memory safety without an external garbage collector, which is truly one of
    the highlights of the Rust programming language. The following callout section
    describes the various types of memory vulnerabilities and how Rust prevents them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 Rust 程序中内存分配、操作和释放的规则。所有这些共同的目标是在没有外部垃圾收集器的情况下实现内存安全的主要目标，这是 Rust
    编程语言的一个真正亮点。以下的小节描述了各种类型的内存漏洞以及 Rust 如何防止它们。
- en: What is memory safety?
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是内存安全？
- en: '**Memory safety** simply means that in any possible execution path of a program,
    there is no access to invalid memory. The following are some of the prominent
    categories of memory safety bugs:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存安全**简单来说，就是在一个程序的任何可能的执行路径中，都不会访问无效的内存。以下是一些突出的内存安全漏洞类别：'
- en: '**Double-free**: Attempting to release the same memory location(s) more than
    once. This can result in undefined behavior or memory corruption. Rust ownership
    rules allow the release of memory only by the owner of a value, and at any point,
    there can be only one owner of a value allocated in the heap. Rust thus prevents
    this class of memory safety bugs.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双重释放**：尝试多次释放相同的内存位置。这可能导致未定义的行为或内存损坏。Rust 的所有权规则允许只有值的拥有者才能释放内存，并且在任何时候，堆中分配的值只能有一个所有者。因此，Rust
    防止这类内存安全漏洞。'
- en: '**Use-after-free**: A memory location is accessed after it has been released
    by the program. The memory being accessed may have been allocated to another pointer,
    so the original pointer to this memory may inadvertently corrupt the value at
    the memory location causing undefined behavior or security issues through arbitrary
    code execution. Rust reference and lifetime rules enforced by the borrow checker
    in the compiler always ensure that a reference is valid before use. Rust borrow
    checker prevents a situation where a reference outlives the value it points to.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用后释放**：在程序释放内存之后访问内存位置。被访问的内存可能已被分配给另一个指针，因此原始指针可能会意外地破坏内存位置中的值，导致未定义的行为或通过任意代码执行引发安全问题。Rust
    引用和生命周期规则由编译器中的借用检查器强制执行，始终确保在使用之前引用是有效的。Rust 借用检查器防止引用比它指向的值存活时间更长的情况发生。'
- en: '**Buffer overflow**: The program attempts to store a value in memory beyond
    the allocated range. This can corrupt data, cause a program to crash, or result
    in the execution of malicious code. Rust associates capacity with a buffer and
    performs bounds check on access. So, in safe Rust code, it is not possible to
    overflow a buffer. Rust will panic if you attempt to write out of bounds.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区溢出**：程序试图在分配范围之外存储值。这可能会破坏数据，导致程序崩溃，或导致恶意代码的执行。Rust 将容量与缓冲区关联，并在访问时执行边界检查。因此，在安全的
    Rust 代码中，不可能溢出缓冲区。如果你尝试越界写入，Rust 将引发恐慌。'
- en: '**Uninitialized memory use**: The program reads data from a buffer that was
    allocated but not initialized with values. This causes undefined behavior because
    the memory location can hold indeterminate values. Rust prevents reading from
    uninitialized memory.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未初始化内存使用**：程序从一个已分配但未初始化为值的缓冲区读取数据。这会导致未定义的行为，因为内存位置可以持有不确定的值。Rust 阻止从未初始化的内存中读取。'
- en: '**Null pointer dereference**: The program writes to memory with a null pointer,
    causing segmentation faults. A null pointer is not possible in safe Rust because
    Rust ensures that a reference does not outlive the value it refers to, and Rust''s
    lifetime rules require functions manipulating references to declare how the references
    from input and output are linked, using lifetime annotations.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空指针解引用**：程序使用空指针写入内存，导致段错误。在安全的 Rust 中不可能有空指针，因为 Rust 确保引用不会比它引用的值存活时间更长，并且
    Rust 的生命周期规则要求操作引用的函数声明输入和输出引用之间的链接方式，使用生命周期注解。'
- en: We have thus seen how Rust achieves memory safety through its unique system
    of immutable-by-default variables, ownership rules, lifetimes, reference rules,
    and borrow-checker.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Rust 如何通过其独特的默认不可变变量、所有权规则、生命周期、引用规则和借用检查器系统实现内存安全。
- en: With this, we conclude this section on the Rust memory management lifecycle.
    In the next section, we will implement a dynamic data structure in Rust.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们总结了这个关于 Rust 内存管理生命周期的章节。在下一节中，我们将使用 Rust 实现一个动态数据结构。
- en: Implementing a dynamic data structure
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现动态数据结构
- en: In this section, we will enhance the template engine from [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library and Key Crates for Systems Programming*,
    to add support for multiple template variables in one statement. We will achieve
    this by converting a static data structure into a dynamic data structure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将增强[*第3章*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057)，*系统编程的Rust标准库和关键crate介绍*中的模板引擎，以添加对单个语句中多个模板变量的支持。我们将通过将静态数据结构转换为动态数据结构来实现这一点。
- en: 'We will refresh our memory with the model of the template engine shown in *Figure
    5.7*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用*图5.7*中显示的模板引擎模型来刷新我们的记忆：
- en: '![Figure 5.7 – Conceptual model of the template engine (from Chapter 3, Introduction
    to the Rust Standard Library and Key Crates for Systems Programming)](img/Figure_5.7_B16405.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 模板引擎的概念模型（来自第3章，系统编程的Rust标准库和关键crate介绍）](img/Figure_5.7_B16405.jpg)'
- en: Figure 5.7 – Conceptual model of the template engine (from [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    Introduction to the Rust Standard Library and Key Crates for Systems Programming)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 模板引擎的概念模型（来自[*第3章*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057)，系统编程的Rust标准库和关键crate介绍）
- en: You will recall that we implemented a template engine in [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library and Key Crates for Systems Programming*,
    to parse an input statement with a template variable and convert it into a dynamic
    HTML statement using context data provided. We will enhance the template variable
    feature in this section. We will first discuss the design changes and then implement
    the code changes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得我们在[*第3章*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057)，*系统编程的Rust标准库和关键crate介绍*中实现了一个模板引擎，用于解析带有模板变量的输入语句并将其转换为使用上下文数据提供的动态HTML语句。在本节中，我们将增强模板变量功能。我们首先将讨论设计变更，然后实现代码变更。
- en: Changes to the design of the template engine
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板引擎设计的变化
- en: 'In [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057), *Introduction
    to the Rust Standard Library and Key Crates for Systems Programming*, we implemented
    the **template variable** content type, wherein the following was input at the
    command line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057)，*系统编程的Rust标准库和关键crate介绍*中，我们实现了**模板变量**内容类型，其中在命令行中输入了以下内容：
- en: '[PRE1]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will generate the following HTML statement:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下HTML语句：
- en: '[PRE2]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We provided the value of `name=Bob` as context data in the `main()` program.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main()`程序中提供了`name=Bob`的值作为上下文数据。
- en: Let's enhance the feature for the `template variable` content type in this chapter.
    So far, our implementation works if there is *one* template variable. But if there
    is more than one template variable (as provided in the following example), it
    does not yet work.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增强本章中`template variable`内容类型的特性。到目前为止，我们的实现如果只有一个模板变量是可行的。但如果有多于一个模板变量（如以下示例所示），则尚不可行。
- en: 'Our expectation is that the following code should work, assuming we provide
    the values of `city=Boston` and `name=Bob` as context data in the `main()` program:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的预期是以下代码应该可以工作，假设我们在`main()`程序中提供了`city=Boston`和`name=Bob`作为上下文数据：
- en: '[PRE3]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will generate the following HTML statement:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下HTML语句：
- en: '[PRE4]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will notice that there are two template variables in the input statement
    here—`name` and `city`. We will have to enhance our design to support this, starting
    with the `ExpressionData` struct, which stores the result of the parsing of the
    template-variable statement.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在输入语句中这里有两个模板变量——`name`和`city`。我们将不得不增强我们的设计以支持这一点，从`ExpressionData`结构开始，它存储模板变量语句解析的结果。
- en: 'Let''s look at the data structure `ExpressionData`. We can start with the code
    from `Chapter03` located at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03](https://github.com/PacktPublishing/Practical-System-programming-for-Rust-developers/tree/master/Chapter03):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ExpressionData`数据结构。我们可以从位于[https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03](https://github.com/PacktPublishing/Practical-System-programming-for-Rust-developers/tree/master/Chapter03)的`Chapter03`中的代码开始：
- en: '[PRE5]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our implementation, the input value of `<p> Hello {{name}}. How are you?
    </p>` will be tokenized into the `ExpressionData` struct as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，`<p> Hello {{name}}. How are you? </p>`的输入值将被标记为`ExpressionData`结构，如下所示：
- en: '[PRE6]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding design, we allowed the following format:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的设计中，我们允许以下格式：
- en: '[PRE7]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The string literal before the `template variable` was mapped to the `Head` field
    in `ExpressionData`, and the string literal after the `template variable` was
    mapped to the `Tail` field of `ExpressionData`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `template variable` 之前的字符串字面量映射到 `ExpressionData` 中的 `Head` 字段，而 `template
    variable` 之后的字符串字面量映射到 `ExpressionData` 的 `Tail` 字段。
- en: As you can see, we have made provision for only one `template variable` in the
    data structure (the `variable` field is of type `String`). In order to accommodate
    multiple `template variable` in a statement, we must alter the struct, to allow
    the `variable` field to store more than one `template variable` entry.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在数据结构中仅提供了对一个 `template variable` 的支持（`variable` 字段为 `String` 类型）。为了在语句中容纳多个
    `template variable`，我们必须修改结构，以允许 `variable` 字段存储多个 `template variable` 条目。
- en: 'In addition to allowing multiple template variables, we also need to accommodate
    a more flexible structure of input statements. In our current implementation,
    we accommodate one string literal before `template variable`, and one literal
    after it. But in the real world, an input statement can have any number of string
    literals, as shown in the following example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许多个模板变量外，我们还需要适应输入语句的更灵活的结构。在我们的当前实现中，我们适应了在 `template variable` 前后各有一个字符串字面量。但在现实世界中，输入语句可以有任意数量的字符串字面量，如下例所示：
- en: '[PRE8]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, we have the following changes to make to our template engine:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要对模板引擎进行以下更改：
- en: Allow for the parsing of more than one template variable per statement
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许每个语句解析超过一个模板变量
- en: Allow for the parsing of more than two string literals in the input statement
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在输入语句中解析超过两个字符串字面量
- en: To allow for these changes, we have to redesign the `ExpressionData` struct.
    We also need to modify the methods that deal with `ExpressionData` to implement
    the parsing functionality for these two changes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许这些更改，我们必须重新设计 `ExpressionData` 结构。我们还需要修改处理 `ExpressionData` 的方法，以实现这两个更改的解析功能。
- en: 'Let''s review the summary of changes to be made to the design, which is shown
    in *Figure 5.8*. This figure is from [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library and Key Crates for Systems Programming*,
    but the components to be changed are highlighted in the figure:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下需要设计变更的总结，如图 *5.8* 所示。此图来自 [*第3章*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057)，*Rust标准库和系统编程关键crate的介绍*，但图中突出显示了需要更改的组件：
- en: '![Figure 5.8 – Changes to the design of the template engine](img/Figure_5.8_B16405.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 *5.8* – 模板引擎设计变更](img/Figure_5.8_B16405.jpg)'
- en: Figure 5.8 – Changes to the design of the template engine
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 *5.8* – 模板引擎设计变更
- en: In this subsection, we designed a dynamic data structure for the template engine
    we are building throughout several chapters of the book. In the next subsection,
    we will write the code to implement this.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们为书中所构建的模板引擎设计了一个动态数据结构。在下一小节中，我们将编写代码来实现这一功能。
- en: Coding the dynamic data structure
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码动态数据结构
- en: 'As indicated in *Figure 5.7*, we will be modifying the following components
    of the template engine in this chapter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图5.7* 所示，在本章中，我们将修改以下模板引擎组件：
- en: The `ExpressionData` struct
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExpressionData` 结构'
- en: The `get_expression_data()` function
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_expression_data()` 函数'
- en: The `generate_html_template_var()` function
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_html_template_var()` 函数'
- en: The `main()` function
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()` 函数'
- en: 'We will start with the changes to the `ExpressionData` struct:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对 `ExpressionData` 结构的更改开始：
- en: src/lib.rs
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE9]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have fully revamped the structure of `ExpressionData`. It now has three
    fields. The descriptions of the fields are provided here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完全重构了 `ExpressionData` 的结构。现在它有三个字段。字段的描述如下：
- en: '`expression`: The expression input by the user is stored here.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expression`：用户输入的表达式存储在这里。'
- en: '`var_map`: Instead of a single `String` field as earlier, we now have a vector
    of strings to store *multiple template variables* in a statement. We have used
    a vector instead of the array because we do not know at compile time how many
    template variables there will be in the user input. For vectors, memory is allocated
    dynamically on the heap.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var_map`：与之前的单个 `String` 字段不同，我们现在有一个字符串向量来存储语句中的 *多个模板变量*。我们使用向量而不是数组，因为我们不知道在编译时用户输入中会有多少模板变量。对于向量，内存是在堆上动态分配的。'
- en: '`gen_html`: The generated HTML statement corresponding to the input is stored
    here.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gen_html`：将对应于输入的生成的HTML语句存储在这里。'
- en: What are dynamic data structures?
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 什么是动态数据结构？
- en: '`ExpressionData` is an example of a dynamic data structure. It is dynamic because
    the memory allocation for the field `var_map` changes dynamically at runtime depending
    on how many *template variables* are present in the input, and the total length
    of the *expression* field (which is based on the count and length of the string
    literals in the input statement). Expression data is an example of a user-defined
    data structure that is associated with smart pointers as its field members contain
    dynamic values.'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ExpressionData`是一个动态数据结构的示例。它是动态的，因为`var_map`字段的内存分配在运行时动态变化，取决于输入中存在的模板变量的数量以及`expression`字段的总长度（基于输入语句中字符串字面量的数量和长度）。表达式数据是用户定义的数据结构的示例，它与智能指针相关联，因为其字段成员包含动态值。'
- en: 'Due to this change to the structure of `ExpressionData`, we have to alter the
    following two functions: `get_expression_data()` and `generate_html_template_var()`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对`ExpressionData`结构体的结构进行了更改，我们不得不修改以下两个函数：`get_expression_data()`和`generate_html_template_var()`：
- en: src/lib.rs
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE10]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we are doing the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们执行以下操作：
- en: Splitting the input statement into words separated by whitespace (`expression_iter`)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入语句分割成由空格分隔的单词（`expression_iter`）
- en: Iterating through the words to parse only the template variables
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历单词以解析仅模板变量
- en: Adding the template variables to a vector of strings `template_var_map.push(word.to_string());`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模板变量添加到字符串向量`template_var_map.push(word.to_string());`
- en: Constructing the `ExpressionData` struct and returning from the function
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建结构体`ExpressionData`并从函数返回
- en: Dynamic memory allocation
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: 'In the preceding function, the following statement shows dynamic memory allocation:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的函数中，以下语句显示了动态内存分配：
- en: '`template_var_map.push(word.to_string());`'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`template_var_map.push(word.to_string());`'
- en: This statement adds each template variable found in the input statement to a
    collection of vectors, which is then stored in the `ExpressionData` struct. Each
    `push()` statement on the vector is translated by the Rust Standard Library into
    a memory allocation—`ExpressionData` is a dynamic data structure. Likewise, when
    the variable of type `ExpressionData` goes out of scope, memory is deallocated
    for all the elements of the struct (including the vector of strings).
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此语句将输入语句中找到的每个模板变量添加到向量集合中，然后将其存储在`ExpressionData`结构体中。向量上的每个`push()`语句都被Rust标准库转换为内存分配——`ExpressionData`是一个动态数据结构。同样，当`ExpressionData`类型的变量超出作用域时，结构体中所有元素（包括字符串向量）的内存都会被释放。
- en: 'We will now modify the function that generates HTML output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将修改生成HTML输出的函数：
- en: src/lib.rs
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib.rs
- en: '[PRE11]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This function accepts two inputs—the `ExpressionData` type and the `context`
    HashMap. Let''s understand the logic through an example. Let''s also assume the
    following input values are passed to the function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个输入——`ExpressionData`类型和`context` HashMap。让我们通过一个示例来理解其逻辑。同时，假设以下输入值传递给该函数：
- en: The expression field of `content` has `<p> {{name}} {{city}} </p>`.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`的表达式字段为`<p> {{name}} {{city}} </p>`。'
- en: 'The following values are contained in the `var_map` field of `content`: `[{{name}},{{city}}]`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下值包含在`content`字段的`var_map`中：`[{{name}},{{city}}]`
- en: 'The following context data is passed to the function in the `content` HashMap:
    `name=Bob` and `city=Boston`.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下上下文数据作为`content` HashMap传递给函数：`name=Bob`和`city=Boston`。
- en: 'Here is the processing that we perform in the function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们函数中执行的处理：
- en: We iterate through the list of template variables contained in the `var_map`
    field of `content`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历`content`字段的`var_map`中包含的模板变量列表。
- en: For each iteration, we first strip out the leading and trailing curly braces
    from the template variable values stored in the `var_map` field of `content`.
    So `{{name}}` becomes `name` and `{{city}}` becomes `city`. We then look them
    up in the `context` HashMap and retrieve the value (yielding `Bob` and `Boston`).
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每次迭代，我们首先从存储在`content`字段的`var_map`中的模板变量值中去除前导和尾随的花括号。因此`{{name}}`变为`name`，`{{city}}`变为`city`。然后我们在`context`
    HashMap中查找它们并检索值（得到`Bob`和`Boston`）。
- en: The last step is to replace all instances of `{{name}}` in the input string
    with `Bob` and all instances of `{{city}}` with `Boston`. The resultant string
    is stored in the `gen_html` field of the `content` struct, which is of type `ExpressionData`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将输入字符串中的所有`{{name}}`实例替换为`Bob`，将所有`{{city}}`实例替换为`Boston`。结果字符串存储在`content`结构体的`gen_html`字段中，该字段的数据类型为`ExpressionData`。
- en: 'And finally, we will modify the `main()` function as follows. The main change
    in the `main()` function, compared to [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library and Key Crates for Systems Programming*,
    is the change in the parameters to be passed to the `generate_hml_template_var()`
    function:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将修改`main()`函数如下。与[*第3章*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057)中相比，`main()`函数的主要变化是传递给`generate_hml_template_var()`函数的参数变化：
- en: src/main.rs
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: src/main.rs
- en: '[PRE12]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With these changes, we can run the program with `cargo run`, and enter the
    following in the command line:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们可以使用`cargo run`运行程序，并在命令行中输入以下内容：
- en: '[PRE13]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will see the following generated HTML statement displayed on your terminal:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在终端上看到以下生成的HTML语句：
- en: '[PRE14]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this section, we converted the `ExpressionData` struct from a static to
    a dynamic data structure, and modified the associated functions to add the following
    features to the template engine:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将`ExpressionData`结构从静态数据结构转换为动态数据结构，并修改了相关函数，为模板引擎添加了以下功能：
- en: Allow for the parsing of more than one template variable per statement
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许每个语句解析多个模板变量
- en: Allow for the parsing of more than two string literals in the input statement
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在输入语句中解析超过两个字符串字面量
- en: Now, let's end the chapter with a summary.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以总结结束本章。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we looked in depth at the memory layout of a standard process
    in the Linux environment, and then the memory layout of a Rust program. We compared
    the memory management lifecycle in different programming languages and how Rust
    takes a different approach to memory management. We learned how memory is allocated,
    manipulated, and released in a Rust program, and looked at the rules governing
    memory management in Rust, including ownership and reference rules. We looked
    at the different types of memory safety issues and how Rust prevents them from
    using its ownership model, lifetimes, reference rules, and borrow checker.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了Linux环境中标准进程的内存布局，然后是Rust程序的内存布局。我们比较了不同编程语言中的内存管理生命周期，以及Rust在内存管理方面采取的不同方法。我们学习了在Rust程序中如何分配、操作和释放内存，并探讨了Rust内存管理的规则，包括所有权和引用规则。我们探讨了不同类型的内存安全问题以及Rust如何通过其所有权模型、生命周期、引用规则和借用检查器来防止这些问题。
- en: We then returned to our template engine implementation example from `Chapter03`
    and added a couple of features to the template engine. We achieved this by converting
    a static data structure into a dynamic data structure and learned how memory is
    allocated dynamically. Dynamic data structures are very useful in programs that
    deal with external inputs, for example, in programs that accept incoming data
    from network sockets or file descriptors, where it is not known in advance what
    the size of incoming data will be, which is likely to be the case for most real-world
    complex programs that you will be writing using Rust over the course of your professional
    career.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回到了`Chapter03`中的模板引擎实现示例，并为模板引擎添加了一些功能。我们通过将静态数据结构转换为动态数据结构来实现这一点，并学习了如何动态分配内存。动态数据结构在处理外部输入的程序中非常有用，例如，在接收来自网络套接字或文件描述符的传入数据的程序中，事先不知道传入数据的大小，这在您使用Rust编写的大多数现实世界复杂程序中很可能是这种情况。
- en: This concludes the memory management topic. In the next chapter, we will take
    a closer look at the Rust Standard Library modules that deal with file and directory
    operations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了内存管理主题。在下一章中，我们将更深入地探讨处理文件和目录操作的Rust标准库模块。
- en: Further reading
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Understanding Ownership in Rust**: [https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解Rust中的所有权**：[https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)'
