- en: '*Chapter 5*: Memory Management in Rust'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Section 1*, *Getting Started with Systems Programming in Rust*, we covered
    Cargo (the Rust development toolkit), a tour of the Rust language, an introduction
    to the Rust Standard Library, and standard library modules for managing process
    environment, command-line, and time-related functions. While the focus of *Section
    1*, *Getting Started with Systems Programming in Rust*, was to provide an overview
    of the landscape and the foundation for system programming in Rust, *Section 2*,
    *Manage and Control System Resources in Rust*, gets into the details of how to
    manage and control system resources in Rust, including memory, files, terminals,
    processes, and threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now entering *Section 2*, *Manage and Control System Resources in Rust*,
    of the book. *Figure 5.1* provides the context for this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Managing system resources](img/Figure_5.1_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Managing system resources
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on memory management. The following are the
    key learning outcomes for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of **operating system (OS)** memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the memory layout of Rust programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Rust memory management lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a dynamic data structure to a template engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will begin the chapter with an overview (or a refresher for those already
    familiar with the topic) of the general principles of memory management in OSes,
    including the memory management lifecycle and the layout of a process in memory.
    We will then cover the memory layout of a running Rust program. This will cover
    how a Rust program is laid out in memory and the characteristics of the heap,
    stack, and static data segments. In the third section, we learn about the Rust
    memory management lifecycle, how it differs from other programming languages,
    and how memory is allocated, manipulated, and released in Rust programs. Lastly,
    we will enhance the template engine that we started to build in [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library and Key Crates for Systems Programming*,
    with a dynamic data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rustup and Cargo must be installed in a local development environment.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter05](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: The basics of OS memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go into the fundamentals of memory management in modern
    OSes. Those already familiar with this topic can skim through this section quickly
    as a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: Memory is among the most fundamental and critical resources available to a running
    program (process). Memory management deals with the allocation, use, manipulation,
    ownership transfer, and eventual release of memory used by a process. Without
    memory management, executing a program is not possible. Memory management is performed
    by a combination of components, such as the kernel, program instructions, memory
    allocators, and garbage collectors, but the exact mechanism varies across programming
    languages and OSes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the memory management lifecycle and then learn
    the details of how memory is laid out for a process by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The memory management lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will cover the different activities associated with memory
    management:'
  prefs: []
  type: TYPE_NORMAL
- en: The memory management lifecycle *begins* when a binary executable is run. The
    operating system allocates a virtual memory address space for the program and
    initializes various segments of memory based on the instructions in the binary
    executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Memory management activities *continue* as the program processes various inputs
    coming in from I/O devices such as files, networks, and standard input (from the
    command line).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The memory management lifecycle *ends* when the program is terminated (or if
    the program ends abnormally due to error).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 5.2* shows a typical memory management cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Memory lifecycle](img/Figure_5.2_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Memory lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory management essentially involves four components—**allocation**, **use
    and manipulation**, **deallocation/release**, and **tracking usage**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory allocation**: This is explicitly done in low-level programming languages
    by programmers, but is performed transparently in high-level languages. Memory
    allocated can either be of a *fixed-size* (where the size of a data type is determined
    at compilation time, such as integers, Booleans, or fixed-size arrays) or *dynamically-sized*
    (where the memory is increased or decreased or relocated dynamically at runtime,
    for example, resizable arrays).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory use and manipulation**: The following steps are typical activities
    performed in a program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1\. Defining a named memory area of a particular type (for example, declaring
    a new variable *x* of type integer)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2\. Initializing a variable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3\. Modifying the value of the variable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4\. Copying or moving values to another variable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 5\. Creating and manipulating references to values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Memory release**: This is explicitly performed by the programmer in low-level
    languages, but is handled automatically in high-level languages such as Java,
    Python, JavaScript, and Ruby using a component called the **garbage collector**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory tracking**: This is done at the kernel level. A program invokes *system
    calls* to allocate and deallocate memory. System calls are executed by the *kernel*,
    which keeps track of memory allocations and releases per process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swapping/paging**: This is also done by the *kernel*. Modern OSes virtualize
    physical memory resources. Processes do not directly interact with actual physical
    memory addresses. The kernel assigns virtual address space to each process. The
    total sum of virtual address space allocated to all processes in a system can
    be more than the amount of physical memory available in the system, but the processes
    don''t know (or care) about this. The OS manages this using virtual memory management,
    which ensures that the processes are insulated from each other, and programs have
    access to the committed memory over their lifetime. Swapping and paging are techniques
    in **virtual memory management**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paging and swapping
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How does the operating system map the virtual memory address space to physical
    memory? To achieve this, the virtual address space allocated to programs is split
    into fixed-size pages (for example 4 KB or 8 KB chunks). A **page** is a fixed-length
    contiguous block of virtual memory. Thus the virtual memory allocated to a program
    is divided into multiple fixed-length pages. The corresponding unit on the physical
    RAM is a **page frame**, which is a fixed-length block of RAM. Multiple page-frames
    add up to the total physical memory on a system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At any point in time, only some of the *virtual pages* of a program need to
    be present in the *physical page frames*. The rest are stored on disk in the *swap
    area*, which is a reserved area of the disk. The kernel maintains a page table
    to track the location of each page in the virtual memory space allocated to a
    program. When a program tries to access a memory location on a page, and if the
    page is not on the page frame, the page is located on disk and is then swapped
    into the main memory. Likewise, unused pages in RAM are swapped back into the
    disk (secondary storage) to make space for active processes. This process is called
    **paging**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the same technique is applied at the process level (rather than the page
    level), it is called **swapping**, where the pages of one process are swapped
    from memory to disk to make way for another process to be loaded into memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This aspect of memory management that deals with mapping physical RAM to virtual
    address space is called **virtual memory management**. This ensures that processes
    have access to adequate memory as needed, and are also isolated from each other
    and from the kernel. This way, a program cannot accidentally (or deliberately)
    write to the memory space of the kernel or another process, protecting against
    memory corruption, undefined behavior, and security issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have learned about the memory management lifecycle of a process. Let's now
    understand how a program is laid out in memory by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The process memory layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now look at the structure of the virtual address space allocated by
    the kernel to a single process. *Figure 5.3* shows the memory layout for a process
    on **Linux**, but similar mechanisms exist for **Unix** and **Windows** OS variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Process memory layout](img/Figure_5.3_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Process memory layout
  prefs: []
  type: TYPE_NORMAL
- en: A **process** is a running program. When a program is started up, the operating
    system loads it into memory, gives it access to the command-line parameters and
    environment variables, and starts executing the program instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The operating system allocates the process some amount of memory. Such allocated
    memory has a structure associated with it, which is called the **memory layout**
    of the process. The memory layout of a process contains several **memory regions**
    (also called **segments**), which are nothing but blocks of *memory pages* (which
    was described in the previous subsection). These segments are shown in *Figure
    5.3*, and described next.
  prefs: []
  type: TYPE_NORMAL
- en: The portion of *Figure 5.3* marked **A** shows that the overall virtual memory
    space allocated to a process is split into **Kernel space** and **User space**.
    Kernel space is the area of memory where the portion of the kernel is loaded that
    assists the program in managing and communicating with hardware resources. This
    includes kernel code, the kernel's own memory area, and space marked **Reserved**.
    In this chapter, we will focus only on the **User space**, as that is the area
    that is actually used by the program. The kernel space of virtual memory is not
    accessible to the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user space is segregated into several memory segments, which are described
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text segment** contains the program''s code and other read-only data such
    as *string literals* and *const parameters*. This portion is directly loaded from
    the program binary (executable or library).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data segment** stores global and static variables that are initialized with
    non-zero values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BSS segment** contains uninitialized variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap** is used for dynamic memory allocation. The address space of the process
    continues to grow as memory gets allocated on the heap. The heap grows upward,
    which means new items are added at addresses greater than previous items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stack** is used for *local variables*, and also *function parameters* (in
    some platform architectures). Stacks grow downwards, which means that items put
    earlier in the stack occupy lower address spaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the stack and the heap are allocated at opposite ends of the process
    address space. As the *stack size* increases, it grows downwards, and as the *heap
    size* increases, it grows upwards. In the event that they meet, a stack overflow
    error occurs or a memory allocation call on the heap will fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In between the stack and the heap, there is also the area where any **shared
    memory** (memory shared across processes), **shared libraries** used by the program,
    or **memory-mapped** areas (areas of memory that reflect a file on a disk) are
    located.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Above the stack, there is a segment where **command-line arguments** passed
    to the program and the **environment variables** set for the process are stored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management is a complex topic and a lot of details have been left out
    in the interest of keeping the discussion focused on memory management in Rust.
    However, the basics of virtual memory management and virtual memory addresses
    described earlier are critical for understanding the next section on how Rust
    performs memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the memory layout of Rust programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed the fundamentals of memory management
    in modern OSes. In this section, we will discuss how a running Rust program is
    laid out in memory by the operating system, and the characteristics of the different
    parts of the virtual memory are used by Rust programs.
  prefs: []
  type: TYPE_NORMAL
- en: Rust program memory layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to understand how Rust achieves the combination of low-memory footprint,
    memory safety, and performance, it is necessary to understand how Rust programs
    are laid out in memory and how they can be controlled programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: A low-memory footprint depends on the efficient management of memory allocations,
    the copying of values, and deallocations. Memory safety deals with ensuring that
    there is no unsafe access to values stored in memory. Performance depends on understanding
    the implications of storing a value in the stack versus the heap versus the static
    data segment. Where Rust shines is that all these tasks are not fully left to
    the programmer like in C/C++. The Rust compiler and its ownership system does
    a lot of the heavy-lifting, preventing entire classes of memory bugs. Let's now
    look at the topic in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory layout of a Rust program is shown in *Figure 5.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Rust program memory layout](img/Figure_5.4_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Rust program memory layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through this figure to understand the memory layout of a Rust program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cargo build`) is read into system memory by the kernel and executed, it becomes
    a process. The operating system assigns each process its own private user space
    so that different Rust processes don''t interfere with each other accidentally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text segment**: Executable instructions of the Rust program are placed here.
    This is placed below the stack and heap to prevent any overflows from overwriting
    it. This segment is *read-only* so that its contents are not accidentally overwritten.
    However, multiple processes can *share* the text segment. Let''s take the example
    of a text editor written in Rust running in *process 1*. If a second copy of the
    editor is to be executed, then the system will create a new process with its own
    private memory space (let''s call it *process 2*), but will not reload the program
    instruction of the editor. Instead, it will create a reference to the text instructions
    of *process 1*. But the rest of the memory (the data, stack, and so on) is not
    shared across processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rc` (single-threaded reference-counting pointer) and `Arc` (thread-safe reference
    counting pointer).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of types in Rust with a *dynamic size* are `Vectors`, `Strings`, and
    other `collection` types, and these are heap-allocated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Primitive types such as integers are stack-allocated by default, but the programmer
    can allocate memory in the heap by using a `Box<T>` type (for example, `let y
    =3` allocates memory for integer `y` on the stack and initializes it to `3`, whereas
    `let x: Box<i32> = Box::new(3)` allocates a value for integer `x` on the heap
    and initializes it to `3`).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Stack segment**: The stack is the region of the process memory that stores
    *temporary (local) variables*, *function parameters*, and the *return address*
    of the instruction (which is to be executed after the function call is over).
    By default, all memory allocations in Rust are on the stack. Whenever a function
    is called, its variables get memory-allocated on the stack. Memory allocation
    happens in contiguous memory locations one above the other, in a *stack data structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To summarize, here is how the virtual memory allocated to a running Rust program
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: The *code instructions* of a Rust program go into the *text segment* area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *primitive data types* are allocated on the *stack*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static variables are located in the *data segment*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *heap-allocated values* (values whose size is not known at compilation time,
    such as vectors and strings) are stored in the *heap area of the data segment*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *uninitialized variables* are in the *BSS segment*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these, the Rust programmer does not have much control over the *text* segment
    and *BSS* segments, and only primarily works with the *stack*, *heap*, and *static*
    areas of memory. In the next section, we will delve into the characteristics of
    these three memory areas.
  prefs: []
  type: TYPE_NORMAL
- en: The characteristics of stack, heap, and static memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how the different types of variables declared in a Rust program
    are allocated in different regions of the process space. Of the three memory segments,
    we have discussed – **text**, **data**, and **stack** – the text area is not under
    the control of the Rust programmer, but the programmer has the flexibility to
    decide whether to place a value (that is, allocate memory) on the stack, heap,
    or as a static variable. However, there are strong implications of this decision
    because the stack, static variables, and the heap are managed quite differently,
    and their lifetimes are also different. Understanding these trade-offs is an important
    part of writing any Rust program. Let's look at them more closely.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 5.1* summarizes the characteristics of stack-allocated versus heap-allocated
    versus static-segment memory. Recall from *Figure 5.4* that stack-allocated memory
    belongs to the *stack segment*, and heap and static variables belong to the *data
    segment* of virtual memory address space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.1 – Characteristics of the stack, heap, and static memory areas](img/B16405_05_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Table 5.1 – Characteristics of the stack, heap, and static memory areas](img/B16405_05_Table_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Table 5.1 – Characteristics of the stack, heap, and static memory areas
  prefs: []
  type: TYPE_NORMAL
- en: Is it important to understand the memory locations of values?
  prefs: []
  type: TYPE_NORMAL
- en: For people who have worked with other high-level programming languages, understanding
    whether a variable was stored in the stack, heap, or static data segments won't
    have really been necessary, as the language compiler, runtime, and garbage collector
    will have abstracted away these details and made it easy for the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: But in Rust, especially for writing system-oriented programs, awareness of the
    memory layout and the memory model is necessary to select appropriate and efficient
    data structures for various parts of the system design. And in many cases, this
    knowledge is necessary even to get the Rust program to compile!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have covered the memory layout of Rust programs and understood
    the characteristics of the stack and data segment memory areas. In the next section,
    we will provide an overview of the Rust memory management lifecycle and a comparison
    with other programming languages. We will also look at the three steps of the
    Rust memory management lifecycle in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust memory management lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Computer programs can be modeled as finite state machines. A running program
    accepts different forms of inputs (for example, file inputs, command-line arguments,
    network calls, interrupts, and so on) and transitions from one state to another.
    Take the case of a device driver. It can be in either of the following states:
    *uninitialized*, *active*, or *inactive*. When a device driver is just booted
    up (loaded into memory), it is in the *uninitialized* state. When the device registers
    are initialized and ready to accept events, it goes into the *active* state. It
    can be put in suspended mode and not ready to accept inputs, in which case it
    goes into the *inactive* state. You can extend this concept further. For a communications
    device like a serial port, the device driver can be in the *sending* or *receiving*
    state. Interrupts can trigger the transitions from one state to another. Likewise,
    every kind of program, whether it is a kernel component, command-line tool, network
    server, or an e-commerce application, can be modeled in terms of states and transitions.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is the discussion around state important for memory management? Because,
    state is represented in a program by the programmer as a set of variables with
    values, and these values are stored in the virtual memory of a running program
    (process). Since a program goes through numerous state transitions (top social
    media site programs handle several hundred million state transitions per day),
    all this state and these transitions are represented in memory and then persisted
    to disk. Every component of the modern layered application stack (including frontend
    apps, backend servers, the network stack, other system programs, and operating
    system kernel utilities) needs to be able to efficiently allocate, use, and release
    memory. Hence, it is important to understand how the memory layout of a program
    changes over its lifetime, and what the programmer can do to make it efficient.
  prefs: []
  type: TYPE_NORMAL
- en: With this background, let's move on to an overview of the Rust memory management
    lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Rust memory management lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now compare the memory management lifecycle for other programming languages
    with Rust. Let''s also take a look at *Figure 5.5*, which shows how memory management
    in Rust works, in comparison with other programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Memory management in other programming languages](img/Figure_5.5_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Memory management in other programming languages
  prefs: []
  type: TYPE_NORMAL
- en: In order to appreciate the Rust memory model, it is important to understand
    how memory management is done in other programming languages. *Figure 5.5* shows
    how two sets of programming languages—high-level and low-level—manage memory and
    compare it with Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main steps in the memory management lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Memory use and manipulation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Memory release (deallocation)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The way these three steps are performed varies across programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: High-level languages (such as Java, JavaScript, and Python) hide a lot of the
    details of memory management from the programmer (who has limited control), automate
    memory deallocation using a garbage collector component, and do not provide direct
    access to memory pointers to the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level (also known as system) programming languages such as C/C++ provide
    a complete degree of control to the programmer but do not provide any safety nets.
    Managing memory efficiently is left solely to the skills and meticulousness of
    the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Rust combines the best of both worlds. A Rust programmer has full control over
    memory allocation, being able to manipulate and move around values and references
    in memory, but is subjected to strict Rust ownership rules. Memory deallocation
    is automated by the compiler-generated code.
  prefs: []
  type: TYPE_NORMAL
- en: High-level versus low-level programming languages
  prefs: []
  type: TYPE_NORMAL
- en: Note that the terms **high-level** and **low-level** are used to classify programming
    languages based on the level of abstraction provided to the programmer. Languages
    that provide higher-level programming abstractions are easier to program in and
    take away many of the hard responsibilities around memory management, at the cost
    of lack of control for the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, system languages such as C and C++ provide full control and
    responsibility to the programmer to manage memory and other system resources.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen an overview of the memory management approaches of Rust versus
    other programming languages. Let's now see them in more detail in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory allocation is the process of storing a value (it can be an integer, string,
    vector, or higher-level data structures such as network ports, parsers, or e-commerce
    orders) to a location in memory. As part of memory allocation, a programmer instantiates
    a data type (primitive or user-defined) and assigns an initial value to it. The
    Rust program invokes system calls to allocate memory.
  prefs: []
  type: TYPE_NORMAL
- en: In higher-level languages, the programmer declares variables using the specified
    syntax. The language compiler (in conjunction with the language runtime) handles
    the allocation and exact location of the various data types in virtual memory.
  prefs: []
  type: TYPE_NORMAL
- en: In C/C++, the programmer controls memory allocation (and reallocation) through
    the system call interfaces provided. The language (compiler, runtime) does not
    intervene in the programmer's decision.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, by default, when the programmer initializes a data type and assigns
    it a value, the operating system allocates memory on the stack. This applies to
    all primitive types (integers, floating points, char, Boolean, fixed-length arrays),
    function local variables, function parameters, and other fixed-length data types
    (such as smart pointers). But the programmer has the option to explicitly place
    a primitive data type on the heap by using `Box<T>` smart pointers. Secondly,
    all dynamic values (for example, strings and vectors whose size changes at runtime)
    are stored on the heap, and the smart pointer to this heap data is placed on the
    stack. To summarize, for fixed-length variables, values are stored on the stack,
    variables with a dynamic length are allocated memory on the heap segment, and
    a pointer to the starting location of heap-allocated memory is stored on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at some additional information about memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: All data types declared in a Rust program have their size calculated at compile
    time; they are not dynamically allocated or freed. So what, then, is dynamic?
  prefs: []
  type: TYPE_NORMAL
- en: When there are values that change over time (for example, a `String` whose value
    is not known at compile time or a collection where the number of elements is not
    known upfront), these are allocated at runtime on the heap, but a reference to
    such data is stored as a pointer (which has a fixed size) on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you run this program on a 64-bit system, the size of `String` will be printed
    as `String` without even creating a string variable or assigning a value to it?
    This is because Rust does not care how long a string is, in order to compute its
    size. Sound strange? This is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, `String` is a smart pointer. This is illustrated in *Figure 5.6*.
    It has three components: a `String` smart pointer occupies 64 bits (or 8 bytes),
    hence the total size occupied by a variable of the `String` type is 24 bytes.
    This is regardless of the actual value contained in the string, which is stored
    in the heap, while the smart pointer (24 bytes) is stored on the stack. Note that
    even though the size of the `String` smart pointer is fixed, the actual size of
    the memory allocated on the heap may vary as the value of string changes during
    program runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Structure of a String smart pointer in Rust](img/Figure_5.6_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Structure of a String smart pointer in Rust
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we have discussed various aspects of memory allocation in
    a Rust program. In the next subsection, we will look at the second step of the
    memory management lifecycle, which is about memory manipulation and use within
    the Rust program.
  prefs: []
  type: TYPE_NORMAL
- en: Memory use and manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory use and manipulation refer to program instructions such as modifying
    the value assigned to a variable, copying a value to another variable, moving
    the ownership of a value from one variable to another, and creating new references
    to an existing value. In Rust, `copy`, `move`, and `clone` are three fundamental
    memory manipulation operations. The `move` operation transfers ownership of data
    from one variable to another. The `copy` operation allows a value associated with
    a variable to be duplicated with a bit-wise copy. Implementing the `clone` trait
    on a data type allows the duplication of values instead of move semantics.
  prefs: []
  type: TYPE_NORMAL
- en: All primitive data types (such as integers, bools, and chars) implement the
    `copy` trait by default. This means assigning a variable of the primitive data
    type to another variable of same type copies the value (duplicates). User-defined
    data types such as structs can implement `copy` if all their data members also
    implement the `copy` trait.
  prefs: []
  type: TYPE_NORMAL
- en: Anything that does not implement `copy` is moved by default. For example, for
    the `Vec` data type, all operations (for example, passing a `Vec` value as a function
    argument, returning a `Vec` from a function, assignment, pattern matching) are
    *move* operations. Rust does not have a `Move` trait explicitly because it is
    the default.
  prefs: []
  type: TYPE_NORMAL
- en: For non-copy data types, `move` is the default behavior. To implement arbitrary
    `copy` operations on non-copy types, the `clone` trait can be implemented on the
    type.
  prefs: []
  type: TYPE_NORMAL
- en: More details can be found in the Rust book at [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/).
    In high-level languages, the programmer can initialize a variable, assign values
    to variables, and copy values to other variables. Generally, high-level languages
    do not have explicit pointer semantics or arithmetic but use references. The difference
    is that a pointer refers to the exact memory address of a value, but references
    are aliases for another variable. While the programmer uses reference semantics,
    the language internally implements pointer operations.
  prefs: []
  type: TYPE_NORMAL
- en: In C/C++, the programmer can also initialize variables, and assign and copy
    values. In addition, pointer operations are possible. Pointers allow you to write
    directly to any memory allocated by the process. The problem with this model is
    that this gives rise to several types of memory safety issues, such as free-after-use,
    double-free, and buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, memory use and manipulation are governed by certain rules:'
  prefs: []
  type: TYPE_NORMAL
- en: First, all variables in Rust are immutable by default. If a value contained
    in a variable needs to be altered, the variable has to be declared explicitly
    as mutable (with the `mut` keyword).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, there are ownership rules that apply to data access, which are listed
    in a later subsection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, there are rules of references (borrowing) that apply when it comes to
    sharing a value with one or more variables, which is also covered later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fourth, there are lifetimes, which give information to the compiler about how
    two or more references relate to each other. This helps the compiler prevent memory
    safety issues by checking if the references are valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These concepts and rules make programming in Rust very different (and more difficult
    at times) from other programming languages. But it is also these very concepts
    that impart super-powers to Rust in areas of memory and thread-safety. Importantly,
    Rust provides these benefits without runtime costs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now recap the Rust rules for ownership and for borrowing and references
    in the subsections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Rust ownership rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ownership is arguably Rust''s most unique feature. It gives memory safety to
    Rust programs without an external garbage collector or relying entirely on the
    programmer''s skillset. There are three ownership rules in Rust, which are listed
    here. More details can be found at the following link: [https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The rules governing Rust ownership
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, every value has an owner. At any point in time, for a given value,
    there can be only one owner. A value is dropped (the memory associated with it
    is deallocated) when its owner goes out of scope. Some examples of the scope of
    a variable are a function, a `for` loop, a statement, or an arm of a match expression.
    More details on scope can be found here: [https://doc.rust-lang.org/reference/destructors.html#drop-scopes](https://doc.rust-lang.org/reference/destructors.html#drop-scopes).'
  prefs: []
  type: TYPE_NORMAL
- en: The really interesting aspect of Rust is that these ownership rules are not
    meant for the programmer to memorize, but the Rust compiler enforces these rules.
    Another significant implication of these ownership rules is that the same rules
    also ensure thready safety, in addition to memory safety.
  prefs: []
  type: TYPE_NORMAL
- en: Rust borrowing and references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Rust, references simply borrow a value and are indicated by the `&` symbol.
    They basically allow you to refer to a value without taking ownership of the value.
    This is unlike smart pointers such as `String`, `Vector`, `Box`, and `Rc`, which
    own the value they point to.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a reference to a value is called **borrowing**, which is a temporary
    reference to an object, but it has to be returned and cannot be destroyed by the
    borrower (only the owner can deallocate memory). If there are multiple borrows
    of a value, the compiler ensures that all borrows end before the object is destroyed.
    This eliminates memory errors such as **use-after-free** and **double-free** errors.
  prefs: []
  type: TYPE_NORMAL
- en: More details on Rust borrowing and references can be found at [https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html).
  prefs: []
  type: TYPE_NORMAL
- en: The rules governing Rust references
  prefs: []
  type: TYPE_NORMAL
- en: A value stored in memory can either have one mutable reference to it or any
    number of immutable references (but not both).
  prefs: []
  type: TYPE_NORMAL
- en: References must always be valid. The borrow checker portion of the Rust compiler
    stops compilation if invalid references are found in code. When it's ambiguous,
    the Rust compiler also asks the programmer to explicitly specify the lifetime
    of references.
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we have covered several rules governing the manipulation
    of variables and values in memory and the rules governing them. In the next subsection,
    we will look at the last aspect of the memory management lifecycle, which is about
    deallocating memory after use.
  prefs: []
  type: TYPE_NORMAL
- en: Memory deallocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory deallocation deals with the question of how to release memory back to
    the operating system from the Rust program. Stack-allocated values are automatically
    released, as this is a managed-memory area. Static variables have a lifetime until
    the end of the program, so they get released automatically when the program terminates.
    The real question around memory release applies to heap-allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these values may not be required to be held in memory until the end
    of the program, in which case they can be released. But the mechanism of such
    memory release varies widely across different programming language groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Higher-level languages do not require the programmers to explicitly release
    memory when they are no longer needed. Instead, they use a mechanism called **garbage
    collection**. In this model, a runtime component called **garbage collector**
    analyzes the *heap-allocated* memory of the process, determines the unused objects
    using specialized algorithms, and deallocates them. This helps improve memory
    safety, prevents memory leaks, and makes programming easier for developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In C/C++, the deallocation of memory is the responsibility of the programmer.
    Forgetting to release memory causes **memory leaks**. Accessing values after memory
    has been released causes memory safety issues. In large, complex code bases, or
    in code maintained by multiple people, this causes serious issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust takes a very different approach to memory deallocation. Rust neither has
    a `Drop` trait) for a type, and that will be called by the compiler-generated
    code. The benefit of this approach is that it gives fine-grained memory control
    (like C/C++) while freeing the Rust programmer from having to manually deallocate
    memory (like high-level languages), without the drawbacks of the garbage collector
    (latency and unpredictable GC pauses).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that in Rust, only the owner of a value can release the memory associated
    with it. References do not own the data they point to, so cannot deallocate memory.
    But smart pointers own the data they point to. The compiler generates code that
    calls the `drop` method from the `Drop` trait associated with the smart pointer
    when the smart pointer goes out of scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, these memory deallocation rules apply only to heap-allocated memory as
    the other two types of memory segments (stack and statics) are managed directly
    by the operating system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have so far seen the rules governing memory allocation, manipulation, and
    release in Rust programs. All these collectively aim to achieve the primary goal
    of memory safety without an external garbage collector, which is truly one of
    the highlights of the Rust programming language. The following callout section
    describes the various types of memory vulnerabilities and how Rust prevents them.
  prefs: []
  type: TYPE_NORMAL
- en: What is memory safety?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Memory safety** simply means that in any possible execution path of a program,
    there is no access to invalid memory. The following are some of the prominent
    categories of memory safety bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Double-free**: Attempting to release the same memory location(s) more than
    once. This can result in undefined behavior or memory corruption. Rust ownership
    rules allow the release of memory only by the owner of a value, and at any point,
    there can be only one owner of a value allocated in the heap. Rust thus prevents
    this class of memory safety bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use-after-free**: A memory location is accessed after it has been released
    by the program. The memory being accessed may have been allocated to another pointer,
    so the original pointer to this memory may inadvertently corrupt the value at
    the memory location causing undefined behavior or security issues through arbitrary
    code execution. Rust reference and lifetime rules enforced by the borrow checker
    in the compiler always ensure that a reference is valid before use. Rust borrow
    checker prevents a situation where a reference outlives the value it points to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer overflow**: The program attempts to store a value in memory beyond
    the allocated range. This can corrupt data, cause a program to crash, or result
    in the execution of malicious code. Rust associates capacity with a buffer and
    performs bounds check on access. So, in safe Rust code, it is not possible to
    overflow a buffer. Rust will panic if you attempt to write out of bounds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uninitialized memory use**: The program reads data from a buffer that was
    allocated but not initialized with values. This causes undefined behavior because
    the memory location can hold indeterminate values. Rust prevents reading from
    uninitialized memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Null pointer dereference**: The program writes to memory with a null pointer,
    causing segmentation faults. A null pointer is not possible in safe Rust because
    Rust ensures that a reference does not outlive the value it refers to, and Rust''s
    lifetime rules require functions manipulating references to declare how the references
    from input and output are linked, using lifetime annotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have thus seen how Rust achieves memory safety through its unique system
    of immutable-by-default variables, ownership rules, lifetimes, reference rules,
    and borrow-checker.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we conclude this section on the Rust memory management lifecycle.
    In the next section, we will implement a dynamic data structure in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a dynamic data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will enhance the template engine from [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library and Key Crates for Systems Programming*,
    to add support for multiple template variables in one statement. We will achieve
    this by converting a static data structure into a dynamic data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will refresh our memory with the model of the template engine shown in *Figure
    5.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Conceptual model of the template engine (from Chapter 3, Introduction
    to the Rust Standard Library and Key Crates for Systems Programming)](img/Figure_5.7_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Conceptual model of the template engine (from [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    Introduction to the Rust Standard Library and Key Crates for Systems Programming)
  prefs: []
  type: TYPE_NORMAL
- en: You will recall that we implemented a template engine in [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library and Key Crates for Systems Programming*,
    to parse an input statement with a template variable and convert it into a dynamic
    HTML statement using context data provided. We will enhance the template variable
    feature in this section. We will first discuss the design changes and then implement
    the code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the design of the template engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057), *Introduction
    to the Rust Standard Library and Key Crates for Systems Programming*, we implemented
    the **template variable** content type, wherein the following was input at the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following HTML statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We provided the value of `name=Bob` as context data in the `main()` program.
  prefs: []
  type: TYPE_NORMAL
- en: Let's enhance the feature for the `template variable` content type in this chapter.
    So far, our implementation works if there is *one* template variable. But if there
    is more than one template variable (as provided in the following example), it
    does not yet work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our expectation is that the following code should work, assuming we provide
    the values of `city=Boston` and `name=Bob` as context data in the `main()` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following HTML statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that there are two template variables in the input statement
    here—`name` and `city`. We will have to enhance our design to support this, starting
    with the `ExpressionData` struct, which stores the result of the parsing of the
    template-variable statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the data structure `ExpressionData`. We can start with the code
    from `Chapter03` located at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03](https://github.com/PacktPublishing/Practical-System-programming-for-Rust-developers/tree/master/Chapter03):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our implementation, the input value of `<p> Hello {{name}}. How are you?
    </p>` will be tokenized into the `ExpressionData` struct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding design, we allowed the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The string literal before the `template variable` was mapped to the `Head` field
    in `ExpressionData`, and the string literal after the `template variable` was
    mapped to the `Tail` field of `ExpressionData`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have made provision for only one `template variable` in the
    data structure (the `variable` field is of type `String`). In order to accommodate
    multiple `template variable` in a statement, we must alter the struct, to allow
    the `variable` field to store more than one `template variable` entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to allowing multiple template variables, we also need to accommodate
    a more flexible structure of input statements. In our current implementation,
    we accommodate one string literal before `template variable`, and one literal
    after it. But in the real world, an input statement can have any number of string
    literals, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have the following changes to make to our template engine:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow for the parsing of more than one template variable per statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow for the parsing of more than two string literals in the input statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow for these changes, we have to redesign the `ExpressionData` struct.
    We also need to modify the methods that deal with `ExpressionData` to implement
    the parsing functionality for these two changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the summary of changes to be made to the design, which is shown
    in *Figure 5.8*. This figure is from [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library and Key Crates for Systems Programming*,
    but the components to be changed are highlighted in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Changes to the design of the template engine](img/Figure_5.8_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Changes to the design of the template engine
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we designed a dynamic data structure for the template engine
    we are building throughout several chapters of the book. In the next subsection,
    we will write the code to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the dynamic data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As indicated in *Figure 5.7*, we will be modifying the following components
    of the template engine in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ExpressionData` struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get_expression_data()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `generate_html_template_var()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start with the changes to the `ExpressionData` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have fully revamped the structure of `ExpressionData`. It now has three
    fields. The descriptions of the fields are provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expression`: The expression input by the user is stored here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var_map`: Instead of a single `String` field as earlier, we now have a vector
    of strings to store *multiple template variables* in a statement. We have used
    a vector instead of the array because we do not know at compile time how many
    template variables there will be in the user input. For vectors, memory is allocated
    dynamically on the heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gen_html`: The generated HTML statement corresponding to the input is stored
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are dynamic data structures?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ExpressionData` is an example of a dynamic data structure. It is dynamic because
    the memory allocation for the field `var_map` changes dynamically at runtime depending
    on how many *template variables* are present in the input, and the total length
    of the *expression* field (which is based on the count and length of the string
    literals in the input statement). Expression data is an example of a user-defined
    data structure that is associated with smart pointers as its field members contain
    dynamic values.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Due to this change to the structure of `ExpressionData`, we have to alter the
    following two functions: `get_expression_data()` and `generate_html_template_var()`:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the input statement into words separated by whitespace (`expression_iter`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through the words to parse only the template variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the template variables to a vector of strings `template_var_map.push(word.to_string());`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing the `ExpressionData` struct and returning from the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic memory allocation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the preceding function, the following statement shows dynamic memory allocation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`template_var_map.push(word.to_string());`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This statement adds each template variable found in the input statement to a
    collection of vectors, which is then stored in the `ExpressionData` struct. Each
    `push()` statement on the vector is translated by the Rust Standard Library into
    a memory allocation—`ExpressionData` is a dynamic data structure. Likewise, when
    the variable of type `ExpressionData` goes out of scope, memory is deallocated
    for all the elements of the struct (including the vector of strings).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will now modify the function that generates HTML output:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accepts two inputs—the `ExpressionData` type and the `context`
    HashMap. Let''s understand the logic through an example. Let''s also assume the
    following input values are passed to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: The expression field of `content` has `<p> {{name}} {{city}} </p>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following values are contained in the `var_map` field of `content`: `[{{name}},{{city}}]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following context data is passed to the function in the `content` HashMap:
    `name=Bob` and `city=Boston`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the processing that we perform in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: We iterate through the list of template variables contained in the `var_map`
    field of `content`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each iteration, we first strip out the leading and trailing curly braces
    from the template variable values stored in the `var_map` field of `content`.
    So `{{name}}` becomes `name` and `{{city}}` becomes `city`. We then look them
    up in the `context` HashMap and retrieve the value (yielding `Bob` and `Boston`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step is to replace all instances of `{{name}}` in the input string
    with `Bob` and all instances of `{{city}}` with `Boston`. The resultant string
    is stored in the `gen_html` field of the `content` struct, which is of type `ExpressionData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And finally, we will modify the `main()` function as follows. The main change
    in the `main()` function, compared to [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library and Key Crates for Systems Programming*,
    is the change in the parameters to be passed to the `generate_hml_template_var()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: src/main.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes, we can run the program with `cargo run`, and enter the
    following in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following generated HTML statement displayed on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we converted the `ExpressionData` struct from a static to
    a dynamic data structure, and modified the associated functions to add the following
    features to the template engine:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow for the parsing of more than one template variable per statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow for the parsing of more than two string literals in the input statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's end the chapter with a summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked in depth at the memory layout of a standard process
    in the Linux environment, and then the memory layout of a Rust program. We compared
    the memory management lifecycle in different programming languages and how Rust
    takes a different approach to memory management. We learned how memory is allocated,
    manipulated, and released in a Rust program, and looked at the rules governing
    memory management in Rust, including ownership and reference rules. We looked
    at the different types of memory safety issues and how Rust prevents them from
    using its ownership model, lifetimes, reference rules, and borrow checker.
  prefs: []
  type: TYPE_NORMAL
- en: We then returned to our template engine implementation example from `Chapter03`
    and added a couple of features to the template engine. We achieved this by converting
    a static data structure into a dynamic data structure and learned how memory is
    allocated dynamically. Dynamic data structures are very useful in programs that
    deal with external inputs, for example, in programs that accept incoming data
    from network sockets or file descriptors, where it is not known in advance what
    the size of incoming data will be, which is likely to be the case for most real-world
    complex programs that you will be writing using Rust over the course of your professional
    career.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the memory management topic. In the next chapter, we will take
    a closer look at the Rust Standard Library modules that deal with file and directory
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Understanding Ownership in Rust**: [https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)'
  prefs: []
  type: TYPE_NORMAL
