<html><head></head><body>
        

                            
                    <h1 class="header-title">Functional Data Structures</h1>
                
            
            
                
<p>Data structures are the second most basic building blocks of programming, following control flow. After early languages developed control flow structures, it quickly became apparent that simple variable labels were insufficient for developing complex programs. Data structures have evolved from the basic concept of a sized datum stored at an address to the concept of strings and arrays, followed by mixed structures, and finally collections.</p>
<p>In this chapter, we will revisit the project introduced in <a href="bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml" target="_blank">Chapter 2</a>, <em>Functional Control Flow</em>. The project requirements have expanded to accommodate feedback from the potential client. There are also specific performance targets that must be met due to competition from a rival developer. To help our business succeed, we must now improve the previous simulation and ensure that it meets customer demand and performance targets.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Adjusting to changing the scope of the project</li>
<li>Reformatting code to support multiple use cases</li>
<li>Using appropriate data structures to gather, store, and process data</li>
<li>Organizing code into traits and data classes</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>A recent version of Rust is necessary to run the examples provided:</p>
<p><a href="https://www.rust-lang.org/en-US/install.html">https://www.rust-lang.org/en-US/install.html</a></p>
<p>This chapter's code is also available on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST">https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST</a></p>
<p>Specific installation and build instructions are also included in each chapter's <kbd>README.md</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adjusting to changing the scope of the project</h1>
                
            
            
                
<p>You can't plan for everything. You also probably don't want to try to plan for everything. Flexible software development and emphasizing robust, logically independent components will reduce work when a requirement or dependency inevitably changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gathering new project requirements</h1>
                
            
            
                
<p>After an initial demonstration, your team has received comments and feedback from the potential client. Watching the simulation, the elevator seems to often pass and go back up to floors before stopping. The client expressed concern that this would be not only inefficient, but also uncomfortable or irritable for passengers. To win the contract, the client wants to see improvements and evidence showing that:</p>
<ul>
<li>The ride is comfortable and reliably direct</li>
<li>The ride moves efficiently from each source to each destination floor</li>
</ul>
<p>Additionally, you have learned that a competitor has submitted a separate proposal. The competitor specifically claims that its elevator control system maintains acceleration within comfortable levels, velocity within safe bounds, and reaches destinations accurately within 20% of physical theoretical limits. No specific numbers were provided, and no simulation was demonstrated, but the client seemed very convinced, along with the assurance that the project will cost 10% less.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Architecting a change map from requirements</h1>
                
            
            
                
<p>After receiving feedback and new expectations, we must convert these demands into a plan of action. The simulation needs to be updated and additional tools will need to be built. Let's review the new information and architect a solution to meet the new requirements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Translating expectations into requirements</h1>
                
            
            
                
<p>Reviewing the feedback, it is clear that there are two perspectives that need to be addressed:</p>
<ul>
<li>A competitor has made specific claims that our company will need to outperform </li>
<li>The client has explicit expectations to address concerns from the first demonstration</li>
</ul>
<p>The specific claims from the competitor can be listed as follows:</p>
<ul>
<li>Acceleration is within comfortable bounds</li>
<li>Velocity is within safe bounds</li>
<li>Trip time from any floor to any other floor is within 20% of physical theoretical limits</li>
<li>The software is 10% cheaper</li>
</ul>
<p>We will delegate the price negotiation to our sales team, but otherwise we need to adjust our software to outperform the other three claims. If we can meet these requirements and provide adequate supporting evidence, then this should also address most of the client's explicit concerns.</p>
<p>Additionally, the client was specifically concerned about the elevator passing the destination floor and needing to back up. We should address this behavior and confirm that it does not occur in simulations.</p>
<p>It is clear at this point that the previous motor control logic is inadequate. After brainstorming, your team develops two possible improvements:</p>
<ul>
<li>Use a variable acceleration/deceleration calculation, rather than on/off adjustment</li>
<li>Reduce the update interval to permit faster and, thus, more precise decisions</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Translating requirements into a change map</h1>
                
            
            
                
<p>Given the various new requirements, it seems appropriate to split the previous simulation code into different libraries and executables. We will create a separate module for each of the following:</p>
<ul>
<li>A physics simulator</li>
<li>A motor control</li>
<li>An executable to run the simulation for demonstration</li>
<li>An executable to further analyze the simulation</li>
</ul>
<p>The physics simulator should accept a generic motor controller and a measurement accumulator. The measurement accumulator provided will accept readings of velocity, acceleration, and all other information available to the simulator. The motor controller provided will accept similar readings of velocity and so on, and produce an output of the desired voltage to motors. The resulting function will be responsible for accurately simulating the physical operation of any specified elevator and building.</p>
<p>The motor control will couple with the simulator, or eventually the actual elevator, to use available information to decide how to operate the elevator.</p>
<p>The simulation executable will wrap the physics simulator and motor control to create a program equivalent to the simulation from <a href="bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml" target="_blank">Chapter 2</a>, <em>Functional Control Flow</em>. Additionally, all recorded information from the simulation should be saved to a file for further detailed analysis.</p>
<p>The analysis executable should accept the simulator trace file and check that all performance requirements have been met. Additionally, any analysis that would be useful for development purposes will be added here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mapping requirements directly to code</h1>
                
            
            
                
<p>It is not always desirable to go through the full process of creating a dependency graph and pseudo code for each project or change. Here, we will transition directly from the preceding plan to the following code stubs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the physics simulator</h1>
                
            
            
                
<p>The physics simulator in <kbd>src/physics.rs</kbd> is responsible for modeling the physics and layout of the building and elevator operations. The simulator will be provided with one object to handle motor control and another to handle data collection. The physics simulator module will define traits for each of those interfaces, and the motor control and data collection objects should implement each <kbd>trait</kbd>, respectively.</p>
<p>Let's start by defining some of the type declarations for the <kbd>physics</kbd> module. First, let's look at a key interface—the direct motor input. Until this point, we have assumed that motor input will have simple voltage control that we can represent as a positive or negative floating point integer. This definition is problematic, mainly in the sense that all references to this type will reference <kbd>f64</kbd>. This type specifies a very specific data representation with no room for adjustment. If we litter our code with references to this type, then any changes will require us to go back and edit every one of the references. </p>
<p>Instead, for the motor input type, let's provide a name for the type. This could be an alias for the <kbd>f64</kbd> type, which would solve the immediate concern. Though this is acceptable, we will choose to be even more explicit with the type definition and provide <kbd>enum</kbd> cases for up and down. The <kbd>enum</kbd> type, also known as a <strong>tagged union</strong>, is useful to define data that may have multiple structures or use cases. Here, the constructors are identical, but the meaning of each voltage field is opposite. </p>
<p>Furthermore, when interacting with the <kbd>MotorInput</kbd> type, we should avoid assuming any internal structure. This minimizes our exposure to future interface changes that may change because <kbd>MotorInput</kbd> defines an interface with a currently unknown physical component. We will be responsible for software compatibility with that interface. So, to abstract any interaction with <kbd>MotorInput</kbd>, we will use traits instead. Traits that do not define intrinsic behavior of a type, but rather associated behavior, are sometimes called <strong>data classes</strong>.</p>
<p>Here is the <kbd>enum</kbd> and a data class defining the calculation of force derived from an input:</p>
<pre class="p1" style="padding-left: 30px">#[derive(Clone,Serialize,Deserialize,Debug)]<br/>pub enum MotorInput<br/>{<br/>   Up { voltage: f64 },<br/>   Down { voltage: f64 }<br/>}<br/><br/>pub trait MotorForce {<br/>   fn calculate_force(&amp;self) -&gt; f64;<br/>}<br/><br/>impl MotorForce for MotorInput {<br/>   fn calculate_force(&amp;self) -&gt; f64<br/>   {<br/>      match *self {<br/>         MotorInput::Up { voltage: v } =&gt; { v * 8.0 }<br/>         MotorInput::Down { voltage: v } =&gt; { v * -8.0 }<br/>      }<br/>   }<br/>}<br/><br/>pub trait MotorVoltage {<br/>   fn voltage(&amp;self) -&gt; f64;<br/>}<br/><br/>impl MotorVoltage for MotorInput {<br/>   fn voltage(&amp;self) -&gt; f64<br/>   {<br/>      match *self {<br/>         MotorInput::Up { voltage: v } =&gt; { v }<br/>         MotorInput::Down { voltage: v } =&gt; { -v }<br/>      }<br/>   }<br/>} </pre>
<p>Next, let's define the elevator information. We will create an <kbd>ElevatorSpecification</kbd>, which describes the structure of the building and elevator. We also require an <kbd>ElevatorState</kbd> to hold information regarding the current elevator status. To clarify usage of floor requests, we will also create an alias for <kbd>FloorRequests</kbd> vectors to make the meaning explicit. We will choose to use a <kbd>struct</kbd> instead of tuples here to create explicit field names. Otherwise, structs and tuples are interchangeable for storing miscellaneous data. The definitions are as follows:</p>
<pre class="p1" style="padding-left: 30px">#[derive(Clone,Serialize,Deserialize,Debug)]<br/>pub struct ElevatorSpecification<br/>{<br/>   pub floor_count: u64,<br/>   pub floor_height: f64,<br/>   pub carriage_weight: f64<br/>}<br/><br/>#[derive(Clone,Serialize,Deserialize,Debug)]<br/>pub struct ElevatorState<br/>{<br/>   pub timestamp: f64,<br/>   pub location: f64,<br/>   pub velocity: f64,<br/>   pub acceleration: f64,<br/>   pub motor_input: MotorInput<br/>}<br/><br/>pub type FloorRequests = Vec&lt;u64&gt;;</pre>
<p>The traits for <kbd>MotorController</kbd> and <kbd>DataRecorder</kbd> are almost identical. The only difference is that polling a <kbd>MotorController</kbd> expects a <kbd>MotorInput</kbd> to be returned. Here, we choose to use <kbd>init</kbd> methods instead of constructors to permit additional external initialization of each resource. For example, it may be necessary for <kbd>DataRecorder</kbd> to open files or other resources to be accessed during simulation. Here are the <kbd>trait</kbd> definitions:</p>
<pre class="p1" style="padding-left: 30px">pub trait MotorController<br/>{<br/>   fn init(&amp;mut self, esp: ElevatorSpecification, est: ElevatorState);<br/>   fn poll(&amp;mut self, est: ElevatorState, dst: u64) -&gt; MotorInput;<br/>}<br/><br/>pub trait DataRecorder<br/>{<br/>   fn init(&amp;mut self, esp: ElevatorSpecification, est: ElevatorState);<br/>   fn poll(&amp;mut self, est: ElevatorState, dst: u64);<br/>   fn summary(&amp;mut self);<br/>}</pre>
<p class="mce-root">To simulate the physics of the elevator, we will reproduce the central loop of the simulation from <a href="bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml" target="_blank">Chapter 2</a>, <em>Functional Control Flow</em>. Some of the state has been organized into structures instead of loose variables. Motor control decisions have been delegated to the <kbd>MotorController</kbd> object. Output and data recording has been delegated to the <kbd>DataRecorder</kbd>. There is also a new parameter field to specify the elevator's carriage weight. With all of these generalizations, the code becomes as follows:</p>
<pre class="p1">pub fn simulate_elevator&lt;MC: MotorController, DR: DataRecorder&gt;(esp: ElevatorSpecification, est: ElevatorState, req: FloorRequests,<br/>                         mc: &amp;mut MC, dr: &amp;mut DR) {<br/><br/>   //immutable input becomes mutable local state<br/>   let mut esp = esp.clone();<br/>   let mut est = est.clone();<br/>   let mut req = req.clone();<br/><br/>   //initialize MotorController and DataController<br/>   mc.init(esp.clone(), est.clone());<br/>   dr.init(esp.clone(), est.clone());<br/><br/>   //5. Loop while there are remaining floor requests<br/>   let original_ts = Instant::now();<br/>   thread::sleep(time::Duration::from_millis(1));<br/>   while req.len() &gt; 0<br/>   {<br/>      //5.1. Update location, velocity, and acceleration<br/>      let now = Instant::now();<br/>      let ts = now.duration_since(original_ts)<br/>                  .as_fractional_secs();<br/>      let dt = ts - est.timestamp;<br/>      est.timestamp = ts;<br/><br/>      est.location = est.location + est.velocity * dt;<br/>      est.velocity = est.velocity + est.acceleration * dt;<br/>      est.acceleration = {<br/>         let F = est.motor_input.calculate_force();<br/>         let m = esp.carriage_weight;<br/>         -9.8 + F/m<br/>      };</pre>
<p>After declaring the state and calculating time-dependent variables, we add the elevator control logic:</p>
<pre class="p1">      //5.2. If next floor request in queue is satisfied, <br/>          then remove from queue<br/>      let next_floor = req[0];<br/>      if (est.location - (next_floor as f64)*esp.floor_height).abs() <br/>         &lt; 0.01 &amp;&amp;<br/>         est.velocity.abs() &lt; 0.01<br/>      {<br/>         est.velocity = 0.0;<br/>         req.remove(0);<br/>        //remove is an O(n) operation<br/>        //Vec should not be used like this for large data<br/>      }<br/><br/>      //5.4. Print realtime statistics<br/>      dr.poll(est.clone(), next_floor);<br/><br/>      //5.3. Adjust motor control to process next floor request<br/>      est.motor_input = mc.poll(est.clone(), next_floor);<br/><br/>      thread::sleep(time::Duration::from_millis(1));<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the motor controller</h1>
                
            
            
                
<p>The motor controllers in <kbd>src/motor.rs</kbd> will be responsible for making decisions regarding how much force to generate from the motor. The physics driver will supply current state information regarding all known measurements of location, velocity, and so on. Currently, the motor controller uses only the most current information to make control decisions. However, this may change in the future, in which case the controller may store past measurements.</p>
<p>Extracting the same control algorithm from the previous chapter, the new <kbd>MotorController</kbd> definition becomes as follows:</p>
<pre class="p1" style="padding-left: 30px">pub struct SimpleMotorController<br/>{<br/>   pub esp: ElevatorSpecification<br/>}<br/><br/>impl MotorController for SimpleMotorController<br/>{<br/>   fn init(&amp;mut self, esp: ElevatorSpecification, est: ElevatorState)<br/>   {<br/>      self.esp = esp;<br/>   }<br/><br/>   fn poll(&amp;mut self, est: ElevatorState, dst: u64) -&gt; MotorInput<br/>   {<br/>      //5.3. Adjust motor control to process next floor request<br/><br/>      //it will take t seconds to decelerate from velocity v <br/>        at -1 m/s^2<br/>      let t = est.velocity.abs() / 1.0;<br/><br/>      //during which time, the carriage will travel d=t * v/2 meters<br/>      //at an average velocity of v/2 before stopping<br/>      let d = t * (est.velocity/2.0);<br/><br/>      //l = distance to next floor<br/>      let l = (est.location - (dst as <br/>          f64)*self.esp.floor_height).abs();     </pre>
<p>After establishing basic constants and values, we need to determine the target acceleration:</p>
<pre class="p1" style="padding-left: 30px">      let target_acceleration = {<br/>         //are we going up?<br/>         let going_up = est.location &lt; (dst as <br/>            f64)*self.esp.floor_height;<br/><br/>         //Do not exceed maximum velocity<br/>         if est.velocity.abs() &gt;= 5.0 {<br/>            if going_up==(est.velocity&gt;0.0) {<br/>               0.0<br/>            //decelerate if going in wrong direction<br/>            } else if going_up {<br/>               1.0<br/>            } else {<br/>               -1.0<br/>            }<br/><br/>         //if within comfortable deceleration range and moving <br/>             in right direction, decelerate<br/>         } else if l &lt; d &amp;&amp; going_up==(est.velocity&gt;0.0) {<br/>            if going_up {<br/>               -1.0<br/>            } else {<br/>               1.0<br/>            }<br/><br/>         //else if not at peak velocity, accelerate<br/>         } else {<br/>            if going_up {<br/>               1.0<br/>            } else {<br/>               -1.0<br/>            }<br/>         }<br/>      };      </pre>
<p>After determining the target acceleration, it should be converted into a <kbd>MotorInput</kbd> value:</p>
<pre class="p1" style="padding-left: 30px">      let gravity_adjusted_acceleration = target_acceleration + 9.8;<br/>      let target_force = gravity_adjusted_acceleration * <br/>             self.esp.carriage_weight;<br/>      let target_voltage = target_force / 8.0;<br/>      if target_voltage &gt; 0.0 {<br/>         MotorInput::Up { voltage: target_voltage }<br/>      } else {<br/>         MotorInput::Down { voltage: target_voltage.abs() }<br/>      }<br/>   }<br/>}</pre>
<p>Now, let's write a second controller, implementing the proposed improvements. We will compare the two controllers later in the simulation. The first suggestion was to reduce the polling interval. This change must be made in the physics simulator, so we will measure its effect, but we will not tie it to the motor controller. The second suggestion was to smooth the acceleration curve.</p>
<p>After consideration, we realized that the change in acceleration (also called <strong>jerk</strong>) is what made people uncomfortable, more so than small acceleration forces. Understanding this, we will permit faster acceleration so long as the jerk remains small. We will replace the current target acceleration calculation with the following constraints and objectives:</p>
<ul>
<li>Maximum jerk = <kbd>0.2</kbd> m/s<sup>3</sup></li>
<li>Maximum acceleration = <kbd>2.0</kbd> m/s<sup>2</sup></li>
<li>Maximum velocity = <kbd>5.0</kbd> m/s</li>
<li>Target change in acceleration:
<ul>
<li>0.2 if accelerating up</li>
<li>-0.2 if accelerating down</li>
<li>0.0 if at stable velocity</li>
</ul>
</li>
</ul>
<p>The resulting controller becomes as follows:</p>
<pre style="padding-left: 30px">const MAX_JERK: f64 = 0.2;<br/>const MAX_ACCELERATION: f64 = 2.0;<br/>const MAX_VELOCITY: f64 = 5.0;<br/><br/>pub struct SmoothMotorController<br/>{<br/>   pub esp: ElevatorSpecification,<br/>   pub timestamp: f64<br/>}<br/><br/>impl MotorController for SmoothMotorController<br/>{<br/>   fn init(&amp;mut self, esp: ElevatorSpecification, est: ElevatorState)<br/>   {<br/>      self.esp = esp;<br/>      self.timestamp = est.timestamp;<br/>   }<br/><br/>   fn poll(&amp;mut self, est: ElevatorState, dst: u64) -&gt; MotorInput<br/>   {<br/>      //5.3. Adjust motor control to process next floor request<br/><br/>      //it will take t seconds to reach max from max<br/>      let t_accel = MAX_ACCELERATION / MAX_JERK;<br/>      let t_veloc = MAX_VELOCITY / MAX_ACCELERATION;<br/><br/>      //it may take up to d meters to decelerate from current<br/>      let decel_t = if (est.velocity&gt;0.0) == (est.acceleration&gt;0.0) {<br/>         //this case deliberately overestimates d to prevent "back up"<br/>         (est.acceleration.abs() / MAX_JERK) +<br/>         (est.velocity.abs() / (MAX_ACCELERATION / 2.0)) +<br/>         2.0 * (MAX_ACCELERATION / MAX_JERK)<br/>      } else {<br/>         //without the MAX_JERK, this approaches infinity and <br/>            decelerates way too soon<br/>         //MAX_JERK * 1s = acceleration in m/s^2<br/>         est.velocity.abs() / (MAX_JERK + est.acceleration.abs())<br/>      };<br/>      let d = est.velocity.abs() * decel_t;<br/><br/>      //l = distance to next floor<br/>      let l = (est.location - (dst as <br/>              f64)*self.esp.floor_height).abs();</pre>
<p>After determining basic constants and values, we can calculate a target acceleration:</p>
<pre style="padding-left: 30px">      let target_acceleration = {<br/>         //are we going up?<br/>         let going_up = est.location &lt; (dst as <br/>             f64)*self.esp.floor_height;<br/><br/>         //time elapsed since last poll<br/>         let dt = est.timestamp - self.timestamp;<br/>         self.timestamp = est.timestamp;<br/><br/>         //Do not exceed maximum acceleration<br/>         if est.acceleration.abs() &gt;= MAX_ACCELERATION {<br/>            if est.acceleration &gt; 0.0 {<br/>               est.acceleration - (dt * MAX_JERK)<br/>            } else {<br/>               est.acceleration + (dt * MAX_JERK)<br/>            }<br/><br/>         //Do not exceed maximum velocity<br/>         } else if est.velocity.abs() &gt;= MAX_VELOCITY<br/>            || (est.velocity + est.acceleration * <br/>               (est.acceleration.abs() / MAX_JERK)).abs() &gt;= <br/>                          MAX_VELOCITY {<br/>            if est.velocity &gt; 0.0 {<br/>               est.acceleration - (dt * MAX_JERK)<br/>            } else {<br/>               est.acceleration + (dt * MAX_JERK)<br/>            }<br/><br/>         //if within comfortable deceleration range and <br/>             moving in right direction, decelerate<br/>         } else if l &lt; d &amp;&amp; (est.velocity&gt;0.0) == going_up {<br/>            if going_up {<br/>               est.acceleration - (dt * MAX_JERK)<br/>            } else {<br/>               est.acceleration + (dt * MAX_JERK)<br/>            }<br/><br/>         //else if not at peak velocity, accelerate smoothly<br/>         } else {<br/>            if going_up {<br/>               est.acceleration + (dt * MAX_JERK)<br/>            } else {<br/>               est.acceleration - (dt * MAX_JERK)<br/>            }<br/>         }<br/>      };</pre>
<p>After determining a target acceleration, we should calculate a target force:</p>
<pre style="padding-left: 30px">      let gravity_adjusted_acceleration = target_acceleration + 9.8;<br/>      let target_force = gravity_adjusted_acceleration<br/>            * self.esp.carriage_weight;<br/>      let target_voltage = target_force / 8.0;<br/>      if !target_voltage.is_finite() {<br/>         //divide by zero etc.<br/>         //may happen if time delta underflows<br/>         MotorInput::Up { voltage: 0.0 }<br/>      } else if target_voltage &gt; 0.0 {<br/>         MotorInput::Up { voltage: target_voltage }<br/>      } else {<br/>         MotorInput::Down { voltage: target_voltage.abs() }<br/>      }<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the executable to run a simulation</h1>
                
            
            
                
<p>The executable to run a simulation, contained in <kbd>src/lib.rs</kbd>, consists of all input and configuration from the previous chapter's simulation. Here is the harness used to configure and run a simulation:</p>
<pre style="padding-left: 30px">pub fn run_simulation()<br/>{<br/><br/>   //1. Store location, velocity, and acceleration state<br/>   //2. Store motor input voltage<br/>   let mut est = ElevatorState {<br/>      timestamp: 0.0,<br/>      location: 0.0,<br/>      velocity: 0.0,<br/>      acceleration: 0.0,<br/>      motor_input: MotorInput::Up {<br/>         //a positive force is required to counter gravity and<br/>         voltage: 9.8 * (120000.0 / 8.0)<br/>      }<br/>   };<br/><br/>   //3. Store input building description and floor requests<br/>   let mut esp = ElevatorSpecification {<br/>      floor_count: 0,<br/>      floor_height: 0.0,<br/>      carriage_weight: 120000.0<br/>   };<br/>   let mut floor_requests = Vec::new();<br/><br/>   //4. Parse input and store as building description<br/>           and floor requests<br/>   let buffer = match env::args().nth(1) {<br/>      Some(ref fp) if *fp == "-".to_string()  =&gt; {<br/>         let mut buffer = String::new();<br/>         io::stdin().read_to_string(&amp;mut buffer)<br/>                    .expect("read_to_string failed");<br/>         buffer<br/>      },<br/>      None =&gt; {<br/>         let fp = "test1.txt";<br/>         let mut buffer = String::new();<br/>         File::open(fp)<br/>              .expect("File::open failed")<br/>              .read_to_string(&amp;mut buffer)<br/>              .expect("read_to_string failed");<br/>         buffer<br/>      },<br/>      Some(fp) =&gt; {<br/>         let mut buffer = String::new();<br/>         File::open(fp)<br/>              .expect("File::open failed")<br/>              .read_to_string(&amp;mut buffer)<br/>              .expect("read_to_string failed");<br/>         buffer<br/>      }<br/>   };<br/>   for (li,l) in buffer.lines().enumerate() {<br/>      if li==0 {<br/>         esp.floor_count = l.parse::&lt;u64&gt;().unwrap();<br/>      } else if li==1 {<br/>         esp.floor_height = l.parse::&lt;f64&gt;().unwrap();<br/>      } else {<br/>         floor_requests.push(l.parse::&lt;u64&gt;().unwrap());<br/>      }<br/>   }  </pre>
<p>After establishing the simulation state and reading the input configuration, we run the simulation:</p>
<pre style="padding-left: 30px">   let termsize = termion::terminal_size().ok();<br/>   let mut dr = SimpleDataRecorder {<br/>      esp: esp.clone(),<br/>      termwidth: termsize.map(|(w,_)| w-2).expect("termwidth") <br/>         as u64,<br/>      termheight: termsize.map(|(_,h)| h-2).expect("termheight")<br/>         as u64,<br/>      stdout: &amp;mut io::stdout().into_raw_mode().unwrap(),<br/>      log: File::create("simulation.log").expect("log file"),<br/>      record_location: Vec::new(),<br/>      record_velocity: Vec::new(),<br/>      record_acceleration: Vec::new(),<br/>      record_voltage: Vec::new()<br/>   };<br/>   /*<br/>   let mut mc = SimpleMotorController {<br/>      esp: esp.clone()<br/>   };<br/>   */<br/>   let mut mc = SmoothMotorController {<br/>      timestamp: 0.0,<br/>      esp: esp.clone()<br/>   };<br/><br/>   simulate_elevator(esp, est, floor_requests, &amp;mut mc, &amp;mut dr);<br/>   dr.summary();<br/><br/>}</pre>
<p>The <kbd>DataRecorder</kbd> implementation, also in <kbd>src/lib.rs</kbd>, is responsible for outputting real-time information as well as summary information. Additionally, we will serialize and store the simulation data in a log file. Notice the use of the <kbd>lifetime</kbd> parameter along with the parameterized <kbd>trait</kbd>:</p>
<pre style="padding-left: 30px">struct SimpleDataRecorder&lt;'a, W: 'a + Write&gt;<br/>{<br/>   esp: ElevatorSpecification,<br/>   termwidth: u64,<br/>   termheight: u64,<br/>   stdout: &amp;'a mut raw::RawTerminal&lt;W&gt;,<br/>   log: File,<br/>   record_location: Vec&lt;f64&gt;,<br/>   record_velocity: Vec&lt;f64&gt;,<br/>   record_acceleration: Vec&lt;f64&gt;,<br/>   record_voltage: Vec&lt;f64&gt;,<br/>}<br/>impl&lt;'a, W: Write&gt; DataRecorder for SimpleDataRecorder&lt;'a, W&gt;<br/>{<br/>   fn init(&amp;mut self, esp: ElevatorSpecification, est: ElevatorState)<br/>   {<br/>      self.esp = esp.clone();<br/>      self.log.write_all(serde_json::to_string(&amp;esp).unwrap().as_bytes()).expect("write spec to log");<br/>      self.log.write_all(b"\r\n").expect("write spec to log");<br/>   }<br/>   fn poll(&amp;mut self, est: ElevatorState, dst: u64)<br/>   {<br/>      let datum = (est.clone(), dst);<br/>      self.log.write_all(serde_json::to_string(&amp;datum).unwrap().as_bytes()).expect("write state to log");<br/>      self.log.write_all(b"\r\n").expect("write state to log");<br/><br/>      self.record_location.push(est.location);<br/>      self.record_velocity.push(est.velocity);<br/>      self.record_acceleration.push(est.acceleration);<br/>      self.record_voltage.push(est.motor_input.voltage());</pre>
<p>The <kbd>DataRecorder</kbd> is responsible for not only recording simulation data to logs, but also for printing statistics to the Terminal:</p>
<pre style="padding-left: 30px">      //5.4. Print realtime statistics<br/>      print!("{}{}{}", clear::All, cursor::Goto(1, 1), cursor::Hide);<br/>      let carriage_floor = (est.location / self.esp.floor_height).floor();<br/>      let carriage_floor = if carriage_floor &lt; 1.0 { 0 } else { carriage_floor as u64 };<br/>      let carriage_floor = cmp::min(carriage_floor, self.esp.floor_count-1);<br/>      let mut terminal_buffer = vec![' ' as u8; (self.termwidth*self.termheight) as usize];<br/>      for ty in 0..self.esp.floor_count<br/>      {<br/>         terminal_buffer[ (ty*self.termwidth + 0) as usize ] = '[' as u8;<br/>         terminal_buffer[ (ty*self.termwidth + 1) as usize ] =<br/>            if (ty as u64)==((self.esp.floor_count-1)-carriage_floor) { 'X' as u8 }<br/>            else { ' ' as u8 };<br/>         terminal_buffer[ (ty*self.termwidth + 2) as usize ] = ']' as u8;<br/>         terminal_buffer[ (ty*self.termwidth + self.termwidth-2) as usize ] = '\r' as u8;<br/>         terminal_buffer[ (ty*self.termwidth + self.termwidth-1) as usize ] = '\n' as u8;<br/>      }<br/>      let stats = vec![<br/>         format!("Carriage at floor {}", carriage_floor+1),<br/>         format!("Location {:.06}", est.location),<br/>         format!("Velocity {:.06}", est.velocity),<br/>         format!("Acceleration {:.06}", est.acceleration),<br/>         format!("Voltage [up-down] {:.06}", est.motor_input.voltage()),<br/>      ];<br/>      for sy in 0..stats.len()<br/>      {<br/>         for (sx,sc) in stats[sy].chars().enumerate()<br/>         {<br/>            terminal_buffer[ sy*(self.termwidth as usize) + 6 + sx ] = sc as u8;<br/>         }<br/>      }<br/>      write!(self.stdout, "{}",</pre>
<pre style="padding-left: 30px">String::from_utf8(terminal_buffer).ok().unwrap());<br/>      self.stdout.flush().unwrap();<br/>   }</pre>
<p>The <kbd>DataRecorder</kbd> is also responsible for printing a summary at the end of the simulation:</p>
<pre style="padding-left: 30px">   fn summary(&amp;mut self)<br/>   {<br/>      //6 Calculate and print summary statistics<br/>      write!(self.stdout, "{}{}{}", clear::All, cursor::Goto(1, 1), cursor::Show).unwrap();<br/>      variable_summary(&amp;mut self.stdout, "location".to_string(), &amp;self.record_location);<br/>      variable_summary(&amp;mut self.stdout, "velocity".to_string(), &amp;self.record_velocity);<br/>      variable_summary(&amp;mut self.stdout, "acceleration".to_string(), &amp;self.record_acceleration);<br/>      variable_summary(&amp;mut self.stdout, "voltage".to_string(), &amp;self.record_voltage);<br/>      self.stdout.flush().unwrap();<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the executable to analyze a simulation</h1>
                
            
            
                
<p>The analysis executable in <kbd>src/analyze.rs</kbd> should look at the log file and confirm that all requirements are satisfied—namely the following:</p>
<ul>
<li>Jerk is under <kbd>0.2</kbd> m/s<sup>3</sup></li>
<li>Acceleration is under <kbd>2.0</kbd> m/s<sup>2</sup></li>
<li>Velocity is under <kbd>5.0</kbd> m/s</li>
<li>The elevator does not back up during trips</li>
<li>All trips are completed within 20% of the physical theoretical limit</li>
</ul>
<p>The program design here will be to pass through the log file and check that all values are within the specified limits. There also needs to be a directional flag to alert us to backup events. When a trip completes, we will then compare the elapsed time to the theoretical limit. If any requirement is not satisfied, we will fail immediately and print some basic information. The code is as follows:</p>
<pre style="padding-left: 30px">#[derive(Clone)]<br/>struct Trip {<br/>   dst: u64,<br/>   up: f64,<br/>   down: f64<br/>}<br/><br/>const MAX_JERK: f64 = 0.2;<br/>const MAX_ACCELERATION: f64 = 2.0;<br/>const MAX_VELOCITY: f64 = 5.0;<br/><br/>fn main()<br/>{<br/>   let simlog = File::open("simulation.log").expect("read simulation log");<br/>   let mut simlog = BufReader::new(&amp;simlog);<br/>   let mut jerk = 0.0;<br/>   let mut prev_est: Option&lt;ElevatorState&gt; = None;<br/>   let mut dst_timing: Vec&lt;Trip&gt; = Vec::new();<br/>   let mut start_location = 0.0;</pre>
<p>After initializing the analysis state, we will go through the lines in the log to calculate the statistics:</p>
<pre style="padding-left: 30px">   let mut first_line = String::new();<br/>   let len = simlog.read_line(&amp;mut first_line).unwrap();<br/>   let esp: ElevatorSpecification = serde_json::from_str(&amp;first_line).unwrap();<br/><br/>   for line in simlog.lines() {<br/>      let l = line.unwrap();<br/>      let (est, dst): (ElevatorState,u64) = serde_json::from_str(&amp;l).unwrap();<br/>      let dl = dst_timing.len();<br/>      if dst_timing.len()==0 || dst_timing[dl-1].dst != dst {<br/>         dst_timing.push(Trip { dst:dst, up:0.0, down:0.0 });<br/>      }<br/><br/>      if let Some(prev_est) = prev_est {<br/>         let dt = est.timestamp - prev_est.timestamp;<br/>         if est.velocity &gt; 0.0 {<br/>            dst_timing[dl-1].up += dt;<br/>         } else {<br/>            dst_timing[dl-1].down += dt;<br/>         }<br/>         let da = (est.acceleration - prev_est.acceleration).abs();<br/>         jerk = (jerk * (1.0 - dt)) + (da * dt);<br/>         if jerk.abs() &gt; 0.22 {<br/>            panic!("jerk is outside of acceptable limits: {} {:?}", jerk, est)<br/>         }<br/>      } else {<br/>         start_location = est.location;<br/>      }<br/>      if est.acceleration.abs() &gt; 2.2 {<br/>         panic!("acceleration is outside of acceptable limits: {:?}", est)<br/>      }<br/>      if est.velocity.abs() &gt; 5.5 {<br/>         panic!("velocity is outside of acceptable limits: {:?}", est)<br/>      }<br/>      prev_est = Some(est);<br/>   }</pre>
<p>The analysis validates some requirements as it is processing the file; other requirements must be validated only after the entire log has been processed:</p>
<pre style="padding-left: 30px">   //elevator should not backup<br/>   let mut total_time = 0.0;<br/>   let mut total_direct = 0.0;<br/>   for trip in dst_timing.clone()<br/>   {<br/>      total_time += (trip.up + trip.down);<br/>      if trip.up &gt; trip.down {<br/>         total_direct += trip.up;<br/>      } else {<br/>         total_direct += trip.down;<br/>      }<br/>   }<br/>   if (total_direct / total_time) &lt; 0.9 {<br/>      panic!("elevator back up is too common: {}", total_direct / total_time)<br/>   }<br/><br/>   //trips should finish within 20% of theoretical limit<br/>   let mut trip_start_location = start_location;<br/>   let mut theoretical_time = 0.0;<br/>   let floor_height = esp.floor_height;<br/>   for trip in dst_timing.clone()<br/>   {<br/>      let next_floor = (trip.dst as f64) * floor_height;<br/>      let d = (trip_start_location - next_floor).abs();<br/>      theoretical_time += (<br/>         2.0*(MAX_ACCELERATION / MAX_JERK) +<br/>         2.0*(MAX_JERK / MAX_ACCELERATION) +<br/>         d / MAX_VELOCITY<br/>      );<br/>      trip_start_location = next_floor;<br/>   }<br/>   if total_time &gt; (theoretical_time * 1.2) {<br/>      panic!("elevator moves to slow {} {}", total_time, theoretical_time * 1.2)<br/>   }<br/><br/>   println!("All simulation checks passing.");<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Running simulations and analyzing data</h1>
                
            
            
                
<p>After running a simulation with <kbd>SimpleMotorController</kbd>, we gather an initial simulation log. A simulation log will be saved in JSON form thanks to the handy SerDe library. There should be an initial elevator specification, followed by an elevator state, for each iteration of the simulator. The <kbd>simulation.log</kbd> will end up looking something like the following:</p>
<pre class="p2" style="padding-left: 30px">{"floor_count":5,"floor_height":5.67,"carriage_weight":120000.0}[{"timestamp":0.001288587,"location":0.0,"velocity":0.0,"acceleration":0.0,"motor_input":{"Up":{"voltage":147000.0}}},2][{"timestamp":0.002877568,"location":0.0,"velocity":0.0,"acceleration":0.0002577174000002458,"motor_input":{"Up":{"voltage":147003.86576100003}}},2][{"timestamp":0.004389254,"location":0.0,"velocity":3.8958778553677168e-7,"acceleration":0.000575513599999411,"motor_input":{"Up":{"voltage":147008.632704}}},2][{"timestamp":0.005886777,"location":5.834166693603828e-10,"velocity":0.0000012514326383486894,"acceleration":0.0008778508000002461,"motor_input":{"Up":{"voltage":147013.16776200004}}},2][{"timestamp":0.007377939,"location":2.449505465225691e-9,"velocity":0.0000025604503929786564,"acceleration":0.0011773553999994136,"motor_input":{"Up":{"voltage":147017.660331}}},2][{"timestamp":0.008929299,"location":6.421685786877059e-9,"velocity":0.000004386952466321746,"acceleration":0.0014755878000016765,"motor_input":{"Up":{"voltage":147022.13381700003}}},2]</pre>
<p>This serialized output was created by our SerDe serialization library. There are several steps for implementing serialization using SerDe and it is very informative of how complex libraries work. To use SerDe for JSON serialization and deserialization, we must do the following:</p>
<ol>
<li>Add SerDe to dependencies in <kbd>Cargo.toml</kbd> as follows:</li>
</ol>
<pre class="p1" style="padding-left: 60px">[dependencies]<br/>serde = "1.0"<br/>serde_json = "1.0"<br/>serde_derive = "1.0"</pre>
<ol start="2">
<li>Add <kbd>macro_use</kbd> directives and <kbd>extern crate</kbd> imports to the project root:</li>
</ol>
<pre class="p1" style="padding-left: 60px">#[macro_use] extern crate serde_derive;<br/>extern crate serde;<br/>extern crate serde_json;</pre>
<ol start="3">
<li>Derive <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> traits for data that will be serialized. To derive traits with macro manipulations on declarations, the <kbd>derive</kbd> directive is used. For each macro in the directive, a corresponding procedural macro is expected. Consider the following code:</li>
</ol>
<pre class="p1" style="padding-left: 60px">#[derive(Clone,Serialize,Deserialize,Debug)]<br/>pub enum MotorInput<br/>{<br/>   Up { voltage: f64 },<br/>   Down { voltage: f64 }<br/>}<br/><br/>#[derive(Clone,Serialize,Deserialize,Debug)]<br/>pub struct ElevatorSpecification<br/>{<br/>   pub floor_count: u64,<br/>   pub floor_height: f64,<br/>   pub carriage_weight: f64<br/>}<br/><br/>#[derive(Clone,Serialize,Deserialize,Debug)]<br/>pub struct ElevatorState<br/>{<br/>   pub timestamp: f64,<br/>   pub location: f64,<br/>   pub velocity: f64,<br/></pre>
<pre class="p1" style="padding-left: 60px">   pub acceleration: f64,<br/>   pub motor_input: MotorInput<br/>}</pre>
<ol start="4">
<li>Serialize data as needed. In <kbd>lib.rs</kbd>, we serialize <kbd>ElevatorSpecification</kbd> and <kbd>ElevatorState structs</kbd>. Type hints are often necessary, as the type system doesn't like guessing:</li>
</ol>
<pre class="p1" style="padding-left: 60px">serde_json::to_string(&amp;datum).unwrap().as_bytes()</pre>
<ol start="5">
<li>Deserialize data as needed. In <kbd>analyze.rs</kbd>, we deserialize lines into <kbd>ElevatorSpecification</kbd> and <kbd>ElevatorState</kbd> structs. Type hints are often necessary, as the type system doesn't like guessing:</li>
</ol>
<pre class="p1" style="padding-left: 60px">serde_json::from_str(&amp;l).unwrap()</pre>
<p>SerDe supports many built-in types to serialize and deserialize. These roughly correspond to all types that JSON permits, with additional structs permitted through type hints.</p>
<p>Looking through <kbd>simulation.log</kbd>, we can find most of the built-in types:</p>
<ul>
<li><strong>Integer types</strong>: Integer types become direct JSON integers: </li>
</ul>
<pre style="padding-left: 60px">5</pre>
<ul>
<li><strong>Floating point types</strong>: Floating point integers become direct JSON floats:</li>
</ul>
<pre style="padding-left: 60px">6.54321</pre>
<ul>
<li><strong>Strings</strong>: Rust strings are also translated directly into JSON equivalents:</li>
</ul>
<pre style="padding-left: 60px">"timestamp"</pre>
<ul>
<li><strong>Vectors and arrays</strong>: Rust collections are sometimes serialized in unexpected ways. For the most part, vector types are translated directly into JSON arrays; containing the serialized version of whatever the vector contains:</li>
</ul>
<pre style="padding-left: 60px">[1,2,3,4,5,6,0]</pre>
<ul>
<li><strong>Tuples</strong>: Tuples are serialized into JSON arrays, however, the compiler typically requires a type hint to understand how to serialize/deserialize these types:</li>
</ul>
<pre class="p1" style="padding-left: 60px">[{"timestamp":0.007377939,"location":2.449505465225691e-9,"velocity":0.0000025604503929786564,"acceleration":0.0011773553999994136,"motor_input":{"Up":{"voltage":147017.660331}}},2][{"timestamp":0.008929299,"location":6.421685786877059e-9,"velocity":0.000004386952466321746,"acceleration":0.0014755878000016765,"motor_input":{"Up":{"voltage":147022.13381700003}}},2]</pre>
<ul>
<li><strong>Structs</strong>: Rust structs are translated directly into JSON objects. This always succeeds because Rust field names are valid object keys, as follows:</li>
</ul>
<pre class="p1" style="padding-left: 60px">{"floor_count":5,"floor_height":5.67,"carriage_weight":120000.0}</pre>
<ul>
<li><strong>Tagged unions</strong>: Tagged unions are a slightly strange case. The <kbd>union</kbd> constructor is converted into a JSON object like any other struct. The <kbd>union</kbd> tag, however, is also given its own struct, wrapping the <kbd>union</kbd> constructor in a separate object. Type hints are very much necessary for the compiler to serialize/deserialize correctly here: </li>
</ul>
<pre class="p1" style="padding-left: 60px">{"Up":{"voltage":147003.86576100003}}</pre>
<ul>
<li><strong>HashMap</strong>: Rust HashMaps are an odd case for serialization. The library attempts to convert them to JSON objects. However, not all HashMap keys can be serialized. Therefore, some serialization may fail and require custom serializers:</li>
</ul>
<pre style="padding-left: 60px">{"a":5,"b":6,"c":7}</pre>
<p>Some types are difficult to serialize, including time structures such as <kbd>Instant</kbd>. Despite this difficulty in processing certain datatypes, the SerDe library is very stable, fast, and indispensable when storing and loading data.</p>
<p>Running the analysis program, we can confirm that this motor controller is insufficient for meeting current project requirements:</p>
<pre class="p1" style="padding-left: 30px">jerk is outside of acceptable limits: ElevatorState {<br/>   timestamp: 0.023739637,<br/>   location: 0,<br/>   velocity: 0,<br/>   acceleration: 1,<br/>   motor_input: Up { voltage: 162000 }<br/>}</pre>
<p>Switching to <kbd>SmoothMotorController</kbd>, we can see that all specifications are met:</p>
<pre class="p1" style="padding-left: 30px">All simulation checks passing.</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we outlined the steps to address changes to the project scope and new specifications. We focused on how to write robust code that will encourage reuse in further additional projects or refinements.</p>
<p>Using a wide variety of data structures helps to organize our project and data. The code should be self-documenting whenever possible. Additionally, typesafe code can enforce some assumptions about code to block incorrect input and inappropriate usage. Through the use of data classes, we also learned how to extend existing data structures to support new uses. We also used data classes as an interface to defer assumptions about project elements that were uncertain.</p>
<p>In the next chapter, we will learn about parameterization and generics. We will perform an in-depth code review along with case analysis.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is a good library to serialize and deserialize data?</li>
<li>What do the hashtag derive lines in front of the struct declarations in <kbd>physics.rs</kbd> do?</li>
<li>Which comes first in parameterized declarations—lifetimes or traits?</li>
<li>In a <kbd>trait</kbd> implementation, what is the difference between parameters on the <kbd>impl</kbd>, <kbd>trait</kbd>, or type?</li>
<li>What is the difference between a <kbd>trait</kbd> and a data class?</li>
<li>How should you declare that a package has multiple binaries?</li>
<li>How do you declare a structure field as private?</li>
</ol>


            

            
        
    </body></html>