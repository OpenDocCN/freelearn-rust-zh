- en: '*Chapter 12*: Testing Your Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*: 测试您的应用程序'
- en: Ensuring that a program runs correctly is an important part of programming.
    In this chapter, we are going to learn about testing the Rust application. We
    are going to implement a simple unit test for a function, and a functional test
    for creating a user in our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 确保程序正确运行是编程的一个重要部分。在本章中，我们将学习如何测试Rust应用程序。我们将为函数实现一个简单的单元测试，并为创建用户实现一个功能测试。
- en: We are going to learn a simple technique to debug and find where a problem occurs
    in our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习一种简单的技术来调试并找到代码中问题发生的位置。
- en: After learning the information in this chapter, you will be able to create a
    unit test and functional test for Rust and Rocket applications to ensure the applications
    work as expected. You will also learn how to use a debugger such as `gdb` or `lldb`
    to debug Rust programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习本章信息后，您将能够为Rust和Rocket应用程序创建单元测试和功能测试，以确保应用程序按预期工作。您还将学习如何使用`gdb`或`lldb`等调试器调试Rust程序。
- en: 'In this chapter, we are going to cover these main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Testing the Rust program
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Rust程序
- en: Testing the Rocket application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Rocket应用程序
- en: Debugging the Rust application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Rust应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we are going to do a test and debug, so we need a debugger.
    Please install `gdb`, the GNU Debugger ([https://www.sourceware.org/gdb/download/](https://www.sourceware.org/gdb/download/)),
    for your operating system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行测试和调试，因此我们需要一个调试器。请为您的操作系统安装`gdb`，GNU调试器（[https://www.sourceware.org/gdb/download/](https://www.sourceware.org/gdb/download/))）。
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter12](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter12).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此章节的源代码中找到[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter12](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter12)。
- en: Testing the Rust program
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Rust程序
- en: One important part of programming is testing the application. There are many
    kinds of tests, such as unit tests (to test a single function or method), functional
    tests (to test the function of an application), and integration testing (to test
    various units and functions as a single combined entity). Various tests should
    be conducted in order to make the application as correct as intended.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一个重要部分是测试应用程序。有许多种测试，例如单元测试（用于测试单个函数或方法）、功能测试（用于测试应用程序的功能）和集成测试（用于测试各种单元和函数作为一个单一的组合实体）。为了使应用程序尽可能正确，应进行各种测试。
- en: 'In the Rust standard library, there are three macros to use in testing: `assert!`,
    `assert_eq!`, and `assert_ne!`. The `assert!` macro accepts one or more parameters.
    The first parameter is any statement that evaluates to Boolean, and the rest is
    for debugging if the result is not what is expected.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust标准库中，有三个宏用于测试：`assert!`、`assert_eq!`和`assert_ne!`。`assert!`宏接受一个或多个参数。第一个参数是任何评估为布尔值的语句，其余的是如果结果不是预期的调试信息。
- en: The `assert_eq!` macro compares equality between the first parameter and second
    parameter, and the rest is for debugging if the result is not what is expected.
    The `assert_ne!` macro is the opposite of `assert_eq!`; this macro tests the inequality
    between the first and the second parameters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_eq!`宏比较第一个参数和第二个参数之间的相等性，其余的是如果结果不是预期的调试信息。`assert_ne!`宏是`assert_eq!`的对立面；此宏测试第一个和第二个参数之间的不等性。'
- en: 'Let''s see those macros in action. We want to test the `raw_html()` method
    of the `TextPost` model in `src/models/text_post.rs`. We want to ensure that the
    result of the method is the string we want to have. Follow these steps to test
    the method:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那些宏在实际中的应用。我们想要测试`src/models/text_post.rs`中`TextPost`模型的`raw_html()`方法。我们想要确保该方法的结果是我们想要的字符串。按照以下步骤测试该方法：
- en: 'In `src/models/text_post.rs`, add the following `use` declarations:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/text_post.rs`中添加以下`use`声明：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the same `src/models/text_post.rs` file, we want to have a function for
    testing. To make a function a test function, annotate the function with the `#[test]`
    attribute. Add the function declaration:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`src/models/text_post.rs`文件中，我们想要有一个测试函数。为了使函数成为测试函数，使用`#[test]`属性注释该函数。添加函数声明：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the function, initialize a `TextPost` instance as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，初始化一个`TextPost`实例如下：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the `assert!` macro to ensure the resulting string is what we want:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`assert!`宏添加到确保结果字符串是我们想要的：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save the file and run the test by running `cargo test` on the Terminal. As
    we made a mistake in our test code, `"<p>hel1lo</p>"`, the test should fail, as
    in the following example:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，通过在终端上运行 `cargo test` 来运行测试。由于我们在测试代码中犯了一个错误 `"<p>hel1lo</p>"`，测试应该失败，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Fix `"<p>hel1lo</p>"` by replacing it with `"<p>hello</p>"`. Save the file
    and run the test again. The test should work fine now:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `"<p>hel1lo</p>"` 替换为 `"<p>hello</p>"` 来修复 `"<p>hel1lo</p>"`。保存文件并再次运行测试。现在测试应该可以正常工作：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We want to use the `assert_eq!` and `assert_ne!` macros. The `assert_eq!` macro
    is used to check that the first parameter is equal to the second parameter. The
    `assert_ne!` macro is used to make sure that the first parameter is not equal
    to the second parameter. Add the macros in the `test_raw_html()` function to see
    them in action:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想使用 `assert_eq!` 和 `assert_ne!` 宏。`assert_eq!` 宏用于检查第一个参数是否等于第二个参数。`assert_ne!`
    宏用于确保第一个参数不等于第二个参数。在 `test_raw_html()` 函数中添加这些宏以查看它们的作用：
- en: '[PRE6]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the test again; it should pass. But, if we look at the test output, there
    are warnings, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试；它应该通过。但是，如果我们查看测试输出，会有警告，如下所示：
- en: '[PRE7]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One of the conventions for unit testing is to create a test module and mark
    the module as a test so it will not be compiled. In `src/models/text_post.rs`,
    add a new module:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试的一个约定是创建一个测试模块并将模块标记为测试，这样它就不会被编译。在 `src/models/text_post.rs` 中添加一个新的模块：
- en: '[PRE8]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In `src/models/text_post.rs`, remove these unused `use` declarations:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/models/text_post.rs` 文件中，删除这些未使用的 `use` 声明：
- en: '[PRE9]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Vice versa, add the required `use` declarations in `src/models/text_post.rs`
    in the `tests` module:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反之，在 `tests` 模块中的 `src/models/text_post.rs` 中添加所需的 `use` 声明：
- en: '[PRE10]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Move the `test_raw_html()` function into the `tests` module. Run `cargo test`
    again in the Terminal. The tests should pass with no warnings, as in the following
    example:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `test_raw_html()` 函数移动到 `tests` 模块中。在终端中再次运行 `cargo test`。测试应该没有警告通过，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have learned how to perform unit tests in Rust, we can continue
    by testing the application with functional testing in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在 Rust 中执行单元测试，我们可以继续在下一节中通过功能测试来测试应用程序。
- en: Testing the Rocket application
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Rocket 应用程序
- en: Besides putting the test in the `src` directory, we can create a test in Rust
    files in the `tests` directory inside the root directory of the application. When
    we run `cargo test`, the command line will look into the `tests` directory and
    run any test found there. People usually use tests in the `src` directory for
    unit testing and write functional tests in the `tests` directory.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 `src` 目录中放置测试外，我们还可以在应用程序根目录下的 `tests` 目录中的 Rust 文件中创建测试。当我们运行 `cargo test`
    时，命令行会查找 `tests` 目录并运行那里找到的任何测试。人们通常在 `src` 目录中使用测试进行单元测试，并在 `tests` 目录中编写功能测试。
- en: The Rocket framework provides a `rocket::local` module, which contains modules,
    structs, and methods to send requests to the local Rocket application. The main
    purpose of sending a non-networked request to the local Rocket application is
    to inspect the response and ensure that the response is what we expected, mainly
    for testing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket 框架提供了一个 `rocket::local` 模块，它包含用于向本地 Rocket 应用程序发送请求的模块、结构和方法。向本地 Rocket
    应用程序发送非网络请求的主要目的是检查响应并确保响应是我们预期的，主要是为了测试。
- en: 'Let''s try implementing integration testing for our application by following
    these steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过以下步骤实现应用程序的集成测试：
- en: In the root directory of the application, add a new directory named `tests`.
    Inside the `tests` directory, create a file named `functional_tests.rs`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的根目录下，添加一个名为 `tests` 的新目录。在 `tests` 目录内，创建一个名为 `functional_tests.rs` 的文件。
- en: 'Inside `tests/functional_tests.rs`, add a new test function as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tests/functional_tests.rs` 内部，添加一个新的测试函数，如下所示：
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After that, save and run `cargo test` from the command line. The tests should
    pass, and the `cargo test` output should show that it was running the test inside
    the `tests` directory, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，从命令行保存并运行 `cargo test`。测试应该通过，`cargo test` 的输出应该显示它在 `tests` 目录内运行测试，如下所示：
- en: '[PRE13]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s continue with testing the Rocket application. Create a test function
    named `test_rocket`, but since the application is `async`, we need a different
    test annotation, as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续测试 Rocket 应用程序。创建一个名为 `test_rocket` 的测试函数，但由于应用程序是 `async` 的，我们需要不同的测试注解，如下所示：
- en: '[PRE14]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are going to put the Rocket instance in the `rocket::local::asynchronous::Client`
    instance. Later, we can use the `Client` instance to send a request and verify
    the response. But, one problem is that the Rocket initialization is in `src/main.rs`,
    not in the `our_application` library. We can work around this problem by moving
    the Rocket initialization from `src/main.rs` to `src/lib.rs`. Move the code from
    `src/main.rs` to `src/lib.rs` under the `pub mod` declaration, then change any
    `use our_application::` to `use crate::`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把Rocket实例放入`rocket::local::asynchronous::Client`实例中。稍后，我们可以使用`Client`实例发送请求并验证响应。但，一个问题在于Rocket初始化在`src/main.rs`中，而不是在`our_application`库中。我们可以通过将Rocket初始化从`src/main.rs`移动到`src/lib.rs`来解决这个问题。将`src/main.rs`中的代码移动到`src/lib.rs`下的`pub
    mod`声明下，然后更改任何`use our_application::`到`use crate::`。
- en: After that, rename the `rocket()` function to `setup_rocket()`. Also, add `pub`
    in front of the function and remove `#[launch]` from the top of the `setup_rocket()`
    function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将`rocket()`函数重命名为`setup_rocket()`。此外，在`setup_rocket()`函数前面添加`pub`并从`setup_rocket()`函数的顶部移除`#[launch]`。
- en: 'We want a method to get the database URL, so implement the `get_database_url`
    method for `Config` in `src/lib.rs`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个方法来获取数据库URL，因此实现`Config`在`src/lib.rs`中的`get_database_url`方法：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `src/main.rs`, change the application to use `setup_rocket()`, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main.rs`中，将应用程序更改为使用`setup_rocket()`，如下所示：
- en: '[PRE16]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Going back to `tests/functional_test.rs`, add the `our_application` library:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`tests/functional_test.rs`，添加`our_application`库：
- en: '[PRE17]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, initialize a Rocket instance in `test_rocket()` as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`test_rocket()`函数中初始化一个Rocket实例，如下所示：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We want to get a database connection to truncate the database table to ensure
    a clean state for the testing. Add the required `use` declarations:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望获取数据库连接以截断数据库表，确保测试的干净状态。添加所需的`use`声明：
- en: '[PRE19]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, add the following lines inside the `test_rocket()` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`test_rocket()`函数内部添加以下行：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We want to truncate the content of the `users` table. We want a method for
    `User` to remove all data, but the method should only be available for tests.
    Let''s add a trait to extend the `User` model. Add the `use` declaration:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望截断`users`表的内容。我们希望为`User`创建一个删除所有数据的方法，但该方法应仅适用于测试。让我们添加一个trait来扩展`User`模型。添加`use`声明：
- en: '[PRE21]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the `ModelCleaner` trait and implement `ModelCleaner` for `User` as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`ModelCleaner` trait并为`User`实现`ModelCleaner`，如下所示：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Continuing in the `test_rocket()` function, append the following lines:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test_rocket()`函数中继续，添加以下行：
- en: '[PRE23]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `tests/functional_tests.rs` file, add the `use` declaration:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests/functional_tests.rs`文件中添加`use`声明：
- en: '[PRE24]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, create a `Client` instance inside the `test_rocket()` function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`test_rocket()`函数内部创建一个`Client`实例：
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Right now, the number of users in the database is `0`. We want to make a test
    by getting `"/users"` and parsing the HTML. One crate to parse HTML is `scraper`.
    Because we only want to use the `scraper` crate for testing, add a new part in
    `Cargo.toml` called `[dev-dependencies]`, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，数据库中的用户数量是`0`。我们希望通过获取`"/users"`并解析HTML来进行测试。一个用于解析HTML的crate是`scraper`。因为我们只想在测试中使用`scraper`
    crate，所以请在`Cargo.toml`中添加一个新的部分，称为`[dev-dependencies]`，如下所示：
- en: '[PRE26]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Going back to `tests/functional_test.rs`, we want to get the `"/users"` response.
    Add the `use` declaration:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`tests/functional_test.rs`，我们想要获取`"/users"`响应。添加`use`声明：
- en: '[PRE27]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, append the following lines inside the `test_rocket()` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`test_rocket()`函数内部追加以下行：
- en: '[PRE28]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We want to verify that the response body does not contain any users. If we
    look at the `src/views/users/index.html.tera` template, we see there''s a `mark`
    HTML tag for each user. Let''s use `scraper` to verify the response by adding
    the `use` declaration:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望验证响应体不包含任何用户。如果我们查看`src/views/users/index.html.tera`模板，我们会看到每个用户都有一个`mark`
    HTML标签。让我们使用`scraper`通过添加`use`声明来验证响应：
- en: '[PRE29]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, append the following lines inside the `test_rocket()` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`test_rocket()`函数内部追加以下行：
- en: '[PRE30]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We want to create a `post` request to create a new user, but one problem is
    that the application will do an token authenticity check, so we need to get the
    value from the `"/users/new"` page first. Append the following lines to get the
    token from the response body:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望创建一个`post`请求来创建新用户，但一个问题在于应用程序将执行token真实性检查，因此我们需要首先从`"/users/new"`页面获取值。将以下行追加以从响应体中获取token：
- en: '[PRE31]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use `authenticity_token` to send the `post` request. Add the `use` declaration:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`authenticity_token`发送`post`请求。添加`use`声明：
- en: '[PRE32]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, append the following lines to the `test_rocket()` function:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下行追加到`test_rocket()`函数中：
- en: '[PRE33]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally check the `"/users"` page again; you should see one user. Append the
    following lines:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后再次检查 `"/users"` 页面；您应该看到一个用户。追加以下行：
- en: '[PRE34]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Try running the test again. Sometimes the test works:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试运行测试。有时测试会成功：
- en: '[PRE35]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'But, sometimes, the test doesn''t work:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有时测试不会成功：
- en: '[PRE36]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Why did the test fail? We will learn how to debug the Rust program in the next
    section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 测试为什么失败？我们将在下一节中学习如何调试 Rust 程序。
- en: Debugging the Rust application
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Rust 应用程序
- en: In the previous section, we learned about writing functional tests, but sometimes,
    the test fails. We want to know why the test failed. There are two possible places
    where the error might occur. One is in the user creation process, and the other
    is in finding users after creating the user.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何编写功能测试，但有时测试会失败。我们想知道为什么测试失败了。错误可能发生的两个可能位置是用户创建过程和创建用户后的用户查找过程。
- en: 'One way to debug is by logging where the error might occur. If we log all the
    possible errors in the user creation process (for example, in `src/routes/user.rs`
    in the `create_user()` function), we will find out that the authenticity token
    verification sometimes produces an error. An example of logging the error is as
    follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一种调试方法是记录错误可能发生的位置。如果我们记录用户创建过程中所有可能发生的错误（例如，在 `src/routes/user.rs` 的 `create_user()`
    函数中），我们会发现身份验证令牌验证有时会产生错误。记录错误的示例如下：
- en: '[PRE37]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we continue logging the `verify()` method and continue tracing the source
    of the problem, we will eventually find out that the `from_request()` method of
    the token is not producing the correct result. We can fix the problem by changing
    the `from_request()` method in `src/fairings/csrf.rs` with the following lines:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续记录 `verify()` 方法并继续追踪问题的来源，我们最终会发现令牌的 `from_request()` 方法没有产生正确的结果。我们可以通过更改
    `src/fairings/csrf.rs` 中的 `from_request()` 方法来修复问题，如下所示：
- en: '[PRE47]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Obviously, logging the code and finding the problem is not efficient. We can
    also use a debugger such as `gdb` (GNU Debugger) or `lldb` to debug Rust programs.
    `gdb` can be used on the Linux operating system, and `lldb` (Debugger of LLVM
    Project) can be used on macOS and Linux operating systems. Please install one
    of those debuggers if you want to use a debugger for the Rust programming language.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，记录代码并查找问题并不高效。我们还可以使用调试器，如 `gdb`（GNU 调试器）或 `lldb` 来调试 Rust 程序。`gdb` 可用于 Linux
    操作系统，而 `lldb`（LLVM 项目的调试器）可用于 macOS 和 Linux 操作系统。如果您想为 Rust 编程语言使用调试器，请安装这些调试器之一。
- en: 'Rust provides `rust-gdb` (a wrapper to `gdb`) and `rust-lldb` (a wrapper to
    `lldb`). Those programs should be installed with the Rust compiler. Let''s see
    an example of how to use `rust-gdb` by following these steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 提供了 `rust-gdb`（`gdb` 的包装器）和 `rust-lldb`（`lldb` 的包装器）。这些程序应与 Rust 编译器一起安装。让我们通过以下步骤看看如何使用
    `rust-gdb` 的示例：
- en: First, build the application by using the `cargo build` command on the Terminal.
    Since we are not building the release version, debugging symbols should be in
    the resulting binary.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用终端上的 `cargo build` 命令构建应用程序。由于我们不是构建发布版本，调试符号应该包含在生成的二进制文件中。
- en: Check the location of the generated binary in the source directory target directory;
    for example, if the source code for the application is in `/workspace/rocketbook/Chapter12/03RocketTesting/`,
    we can find the generated binary in `/workspace/rocketbook/Chapter12/03RocketTesting/target/debug/our_application`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查生成的二进制文件在源目录目标目录中的位置；例如，如果应用程序的源代码在 `/workspace/rocketbook/Chapter12/03RocketTesting/`，我们可以在
    `/workspace/rocketbook/Chapter12/03RocketTesting/target/debug/our_application`
    中找到生成的二进制文件。
- en: 'Run `rust-gdb` on the Terminal just like you would run `gdb`. Here is an example:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上像运行 `gdb` 一样运行 `rust-gdb`。以下是一个示例：
- en: '[PRE54]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You''ll see a `gdb` prompt as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个 `gdb` 提示符，如下所示：
- en: '[PRE55]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Set the breakpoint of the application, as in this example:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置应用程序的断点，例如：
- en: '[PRE56]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You''ll see a prompt to set a breakpoint on the `our_application` library as
    follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个提示设置 `our_application` 库的断点，如下所示：
- en: '[PRE57]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Reply with `y` and notice `Breakpoint 1` set as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回复 `y` 并注意以下设置的 `Breakpoint 1`：
- en: '[PRE58]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the application by writing the `r` command and pressing the *Enter* key
    on the `gdb` prompt:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `gdb` 提示符下编写 `r` 命令并按 *Enter* 键运行应用程序：
- en: '[PRE59]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The application should run and because it hit the breakpoint, the execution
    stopped. We can use the `gdb` prompt again to inspect final_rocket, as in the
    following example:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序应该运行，因为它触发了断点，执行停止。我们可以再次使用 `gdb` 提示符来检查 final_rocket，如下例所示：
- en: '[PRE60]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Try printing some variables in the debugger prompt:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调试器提示符中尝试打印一些变量：
- en: '[PRE61]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can see the result printed as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到以下打印的结果：
- en: '[PRE62]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To quit from `gdb`, just type `quit` on prompt and confirm quitting the debugger
    as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出`gdb`，只需在提示符下输入`quit`并确认退出调试器，如下所示：
- en: '[PRE63]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There are many more functionalities in these debuggers, such as setting multiple
    breakpoints and stepping through the breakpoints. You can find more information
    about `gdb` at [https://www.sourceware.org/gdb/](https://www.sourceware.org/gdb/),
    and about `lldb` at [https://lldb.llvm.org/](https://lldb.llvm.org/).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调试器有许多更多功能，例如设置多个断点和通过断点逐步执行。您可以在[https://www.sourceware.org/gdb/](https://www.sourceware.org/gdb/)找到有关`gdb`的更多信息，以及[https://lldb.llvm.org/](https://lldb.llvm.org/)有关`lldb`的更多信息。
- en: 'There are also debuggers for IDEs or code editors, for example, users of Visual
    Studio Code can use CodeLLDB ([https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb))
    to conveniently click on the line and mark the breakpoints from the editor and
    inspect the variables through a dedicated panel:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有适用于IDE或代码编辑器的调试器，例如，Visual Studio Code的用户可以使用CodeLLDB ([https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb))
    从编辑器方便地单击行并标记断点，并通过专用面板检查变量：
- en: '![Figure 12.1 – CodeLLDB inspecting our application'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – CodeLLDB检查我们的应用程序'
- en: '](img/Figure_12.1_B16825.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.1_B16825.jpg)'
- en: Figure 12.1 – CodeLLDB inspecting our application
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – CodeLLDB检查我们的应用程序
- en: In any case, using a debugger is an indispensable tool for programming. Learning
    to use debuggers properly can help in working with the Rust programming language.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，使用调试器是编程不可或缺的工具。学会正确使用调试器可以帮助我们更好地使用Rust编程语言。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about testing the Rust program and Rocket application.
    We learned about using macros such as `assert!` to do the testing. We also learned
    the difference between unit testing and functional testing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了测试Rust程序和Rocket应用程序。我们学习了使用如`assert!`这样的宏进行测试。我们还学习了单元测试和功能测试之间的区别。
- en: We created a functional test and learned about modules to do functional testing
    on a Rocket application. Finally, we learned a little bit about the technique
    to debug a Rust application to help fix it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个功能测试，并了解了在Rocket应用程序上进行功能测试的模块。最后，我们学习了一些调试Rust应用程序的技术，以帮助修复它。
- en: Testing and debugging are important parts of programming, as these techniques
    can improve the correctness of the application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和调试是编程的重要组成部分，因为这些技术可以提高应用程序的正确性。
- en: After all the development is done, in the next chapter, we are going to learn
    several ways to set the Rocket application available to serve real-world users.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有开发完成后，在下一章中，我们将学习几种将Rocket应用程序设置为可供现实世界用户使用的方法。
