<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-85"><em class="italic"><a id="_idTextAnchor084"/>Chapter 5</em>: Creating a Rust Interface for Our pip Module</h1>&#13;
			<p>In <a href="B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Building pip Modules in Python</em>, we built a <code>pip</code> module in Python. Now, we will build the same <code>pip</code> module in Rust and manage the interface. Some people might prefer Python for some tasks; others will state that Rust is better. In this chapter, we will simply utilize both as and when we want. To achieve this, we will build a <code>pip</code> module in Rust that can be installed and directly imported into our Python code. We will also build Python entry points that talk directly to our compiled Rust code, and Python adapters/interfaces to make the user experience of our module easy, safe, and locked down with <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>) that have all features that we want our user to use. </p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Packaging Rust with <code>pip</code></li>&#13;
				<li>Building a Rust interface with the <code>pyO3</code> crate </li>&#13;
				<li>Building tests for our Rust package</li>&#13;
				<li>Comparing speed with Python, Rust, and Numba</li>&#13;
			</ul>&#13;
			<p>Covering these topics will enable us to build Rust modules and use them in our Python systems. This is a major advantage as a Python developer; you can use faster, safer, and less resource-intensive code seamlessly in your Python programs. </p>&#13;
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Technical requirements</h1>&#13;
			<p>We will need to have <strong class="bold">Python 3</strong> installed. To get the most out of this chapter, we will also need to have a GitHub account, as we will be using GitHub to package our code, which can be accessed via this link: <a href="https://github.com/maxwellflitton/flitton-fib-rs">https://github.com/maxwellflitton/flitton-fib-rs</a>.</p>&#13;
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_five">https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_five</a>.</p>&#13;
			<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Packaging Rust with pip</h1>&#13;
			<p>In this section, we will be setting up our <code>pip</code> package so that it can utilize Rust code. This will enable us <a id="_idIndexMarker320"/>to use Python setup tools to import our Rust <code>pip</code> package, compile <a id="_idIndexMarker321"/>it for our system, and use it within our Python code. For this chapter, we are essentially building the same Fibonacci module that we built in <a href="B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Building pip Modules in Python</em>. It is advised to create another GitHub repository for our Rust module; however, nothing is stopping you from refactoring your existing Python <code>pip</code> module. To build our Rust <code>pip</code> module, we are going to <a id="_idIndexMarker322"/>have to carry out the following steps:</p>&#13;
			<ol>&#13;
				<li>Define <code>gitignore</code> and <code>Cargo</code> for our package.</li>&#13;
				<li>Configure a Python setup process for our package.</li>&#13;
				<li>Create a Rust library for our package.</li>&#13;
			</ol>&#13;
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Define gitignore and Cargo for our package</h2>&#13;
			<p>To get started, we <a id="_idIndexMarker323"/>must make sure that <a id="_idIndexMarker324"/>our Git does not track files that we do not want to upload and that our <code>Cargo</code> has the right dependencies with <em class="italic">step 1</em>.</p>&#13;
			<ol>&#13;
				<li value="1">First, we can start with <code>gitignore</code>. If you are choosing to use the same GitHub repository as the one that we defined in the previous chapter, then all the files for Python are already defined in the <code>.gitignore</code> file at the root of the GitHub repository. If not, then when you are creating your new GitHub repository, we have to select the Python template in the <code>Add .gitignore</code> section. Either way, once we have the Python <code>gitignore</code> template in our <code>.gitignore</code> file, we must add our <code>gitignore</code> requirements for the Rust part of our package. To do this, we add the following code in the <code>.gitignore</code> file:<pre> /target/</pre><p>Yes, that is it for our Rust code. That is a lot less than the Python files that we need to ignore. </p></li>&#13;
				<li>Now that we have defined <code>gitignore</code>, we can move on to defining our <code>Cargo.toml</code> file in the root of our package, initially defining the metadata of our package with the following code:<pre>[package]
name = "flitton_fib_rs"
version = "0.1.0"
authors = ["Maxwell Flitton 
  &lt;maxwellflitton@gmail.com&gt;"]
edition = "2018"</pre><p>This is nothing new; all we are doing here is defining the name and generic information of our package.</p></li>&#13;
				<li>We then go on to define the dependencies with the following code:<pre>[dependencies]
[dependencies.pyo3]
version = "0.13.2"
features = ["extension-module"]</pre><p>We can <a id="_idIndexMarker325"/>see that we have <a id="_idIndexMarker326"/>not defined any dependencies in the <code>dependencies</code> section. We will be depending on the <code>pyo3</code> crate to enable our Rust code to interact with our Python code. We declare the latest version of the crate at the point of writing this book, and the fact that we want to enable the <code>extension-module</code> feature because we will be using <code>pyo3</code> to make our Rust module. </p></li>&#13;
				<li>We then define our library data with the following code:<pre>[lib]
name = "flitton_fib_rs"
crate-type = ["cdylib"]</pre><p>It must be noted that we have defined a <code>crate-type</code> variable. Crate types provide information to the compiler on how to link Rust crates together. This can either be static or dynamic. For instance, if we were to define the <code>crate-type</code> variable as <code>bin</code>, this would compile our Rust code as a runnable executable. The main file would have to be present in our module, as this would be the entry point. We could also define the <code>crate-type</code> variable as <code>lib</code>, which compiles it as a library that can be used by other Rust programs. We can go further with this, defining either a static or dynamic library. Defining the <code>crate-type</code> variable as <code>cdylib</code> tells the compiler that we want a dynamic system library to be loaded by another language. If we do not put this in, we will not be able <a id="_idIndexMarker327"/>to compile <a id="_idIndexMarker328"/>our code when installing our library via <code>pip</code>. Our library should be able to compile for Linux and Windows. However, we require some link arguments to ensure that our library also works on macOS.</p></li>&#13;
				<li>In order to do this, we need to define the configuration in the <code>.cargo/config</code> file:<pre>[target.x86_64-apple-darwin]
rustflags = [
    "-C", "link-arg=-undefined",
    "-C", "link-arg=dynamic_lookup",
]
[target.aarch64-apple-darwin]
rustflags = [
    "-C", "link-arg=-undefined",
    "-C", "link-arg=dynamic_lookup",
]</pre></li>&#13;
			</ol>&#13;
			<p>With this, we have <a id="_idIndexMarker329"/>defined all that we need <a id="_idIndexMarker330"/>for our Rust library. Now, we move on to the next step, configuring the Python part of our module.</p>&#13;
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Configuring the Python setup process for our package </h2>&#13;
			<p>When it comes to <a id="_idIndexMarker331"/>setting up the Python section, we will be defining this in the <code>setup.py</code> file at the root of our module. Initially, we are going to import all the requirements that we need with the following code:</p>&#13;
			<pre>#!/usr/bin/env python</pre>&#13;
			<pre>from setuptools import dist</pre>&#13;
			<pre>dist.Distribution().fetch_build_eggs(['setuptools_rust'])</pre>&#13;
			<pre>from setuptools import setup</pre>&#13;
			<pre>from setuptools_rust import Binding, RustExtension</pre>&#13;
			<p>We are going to use the <code>setuptools_rust</code> module for managing our Rust code. However, we cannot be sure that the user will have installed <code>setuptools_rust</code> and we need it for running our setup code. Because of this, we cannot rely on the requirements list, as installing the requirements happens after we have imported <code>setuptools_rust</code>. To get around this, we use the <code>dist</code> module to get the required <code>setuptools_rust</code> module for this script. The user does not permanently install <code>setuptools_rust</code> but uses it for the script. Now that this is done, we can define our setup with the following code:</p>&#13;
			<pre>setup(</pre>&#13;
			<pre>    name="flitton-fib-rs",</pre>&#13;
			<pre>    version="0.1",</pre>&#13;
			<pre>    rust_extensions=[RustExtension(</pre>&#13;
			<pre>        ".flitton_fib_rs.flitton_fib_rs",</pre>&#13;
			<pre>        path="Cargo.toml", binding=Binding.PyO3)],</pre>&#13;
			<pre>    packages=["flitton_fib_rs"],</pre>&#13;
			<pre>    classifiers=[</pre>&#13;
			<pre>            "License :: OSI Approved :: MIT License",</pre>&#13;
			<pre>            "Development Status :: 3 - Alpha",</pre>&#13;
			<pre>            "Intended Audience :: Developers",</pre>&#13;
			<pre>            "Programming Language :: Python",</pre>&#13;
			<pre>            "Programming Language :: Rust",</pre>&#13;
			<pre>            "Operating System :: POSIX",</pre>&#13;
			<pre>            "Operating System :: MacOS :: MacOS X",</pre>&#13;
			<pre>        ],</pre>&#13;
			<pre>    zip_safe=False,</pre>&#13;
			<pre>)</pre>&#13;
			<p>Here, we can see that we define the metadata of the module as we did in the previous chapter. We <a id="_idIndexMarker332"/>can also see that we define a <code>rust_extensions</code> parameter, pointing to the actual Rust module that we will define in a Rust file, as we can see in the following figure:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/Figure_5.1_B17720.jpg" alt="Figure 5.1 – Our module flow for setup&#13;&#10;" width="858" height="458"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 5.1 – Our module flow for setup</p>&#13;
			<p>We also point to our <code>Cargo.toml</code> file, as we will have to compile other Rust crates that are in our dependencies when we are installing our Rust module. We also must state that our module is not zipped safely. This is also standard for C modules. Now that we <a id="_idIndexMarker333"/>have done all the setup configurations, we can now move on to the next step of building our basic Rust module that will get us installing Rust code using <code>pip install</code> that we can use in our Python code:</p>&#13;
			<ol>&#13;
				<li value="1">For our Rust code, we have to initially import all of the <code>pyo3</code> requirements in the <code>src/lib.rs</code> file with the following code:<pre>use pyo3::prelude::*;
use pyo3::wrap_pyfunction;</pre><p>What this does is enable our Rust code to utilize all the macros that the <code>pyo3</code> crate has. We will also be wrapping the Rust functions into the module. </p></li>&#13;
				<li>We then define a basic <em class="italic">hello world</em> function with the following code:<pre>#[pyfunction]
fn say_hello() {
    println!("saying hello from Rust!");
}</pre><p>We can see that we have applied a Python function macro from <code>pyo3</code> to the <code>say_hello</code> function.</p></li>&#13;
				<li>Now that we have the function, we can define our module in the same file with the following code:<pre>#[pymodule]
fn flitton_fib_rs(_py: Python, m: &amp;PyModule) -&gt; \
  PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pyfunction!(say_hello));
    Ok(())
}</pre><p>Here, we can see that we have defined the module as <code>flitton_fib_rs</code>. This will <a id="_idIndexMarker334"/>have to be imported as <code>flitton_fib_rs</code> when using it. We then use the <code>pymodule</code> macro. This function is loading the module. We must define a result at the end. Seeing as we do not have any complex logic, we will define the end result as an <code>Ok</code> result. We don't need to do anything to Python; however, we add our wrapped <code>say_hello</code> function to our module. The <code>wrap_pyfunction</code> macro essentially takes a Python instance and returns a Python function. Now that we have our Rust code defined, we must build our Python entry point. </p></li>&#13;
				<li>This is fairly simple; all we have to do is import our functions from the Rust module in the <code>flitton_fib_rs/__init__.py</code> file with the following code:<pre>from .flitton_fib_rs import *</pre><p>We will go through how this works later in this chapter, as we will be installing this package and running it.</p></li>&#13;
			</ol>&#13;
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Installing our Rust library for our package</h2>&#13;
			<p>Right now, we <a id="_idIndexMarker335"/>have everything we need to deploy our package and install it via <code>pip</code>. Considering this, we upload our package to our GitHub repository, which is covered in the <em class="italic">Configuring setup tools for a Python pip module</em> section of the <a href="B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Building pip Modules in Python</em>. </p>&#13;
			<p>Once we have done this, we can install our <code>pip</code> package with the following command, all in one line:</p>&#13;
			<pre>pip install git+https://github.com/maxwellflitton/flitton-</pre>&#13;
			<pre>  fib-rs@main</pre>&#13;
			<p>The URL to your GitHub repository might be different. When this is being installed, the process will hang for a while. The result should give the following printout: </p>&#13;
			<pre>Collecting git+https://github.com/maxwellflitton</pre>&#13;
			<pre>/flitton-fib-rs@main</pre>&#13;
			<pre>Cloning https://github.com/maxwellflitton/</pre>&#13;
			<pre>flitton-fib-rs (to revision main) to /private</pre>&#13;
			<pre>/var/folders/8n/</pre>&#13;
			<pre>7295fgp11dncqv9n0sk6j_cw0000gn/T/pip-req-build-kcmv4ldt</pre>&#13;
			<pre>Running command git clone -q https:</pre>&#13;
			<pre>//github.com/maxwellflitton/flitton-fib-rs </pre>&#13;
			<pre>/private/var/folders/8n</pre>&#13;
			<pre>/7295fgp11dncqv9n0sk6j_cw0000gn/T/pip-req-build-kcmv4ldt</pre>&#13;
			<pre>Installing collected packages: flitton-fib-rs</pre>&#13;
			<pre>  Running setup.py install for flitton-fib-rs ... done</pre>&#13;
			<pre>Successfully installed flitton-fib-rs-0.1</pre>&#13;
			<p>This is because we are compiling the package based on our system. Here, we can see that we collect the code from the <code>main</code> branch of the repository and run the <code>setup.py</code> file. What we have essentially done is compile the Rust code into a binary file and put it next to our <code>__init__.py</code> entry point file with the following file layout:</p>&#13;
			<pre>├── flitton_fib_rs</pre>&#13;
			<pre>│   ├── __init__.py</pre>&#13;
			<pre>│   └── flitton_fib_rs.cpython-38-darwin.so</pre>&#13;
			<p>This is why our <code>from .flitton_fib_rs import *</code> code works in the entry point. </p>&#13;
			<p>Now that <a id="_idIndexMarker336"/>this is all installed in our Python packages, we can run our Python console and type in the following commands:</p>&#13;
			<pre>&gt;&gt;&gt; from flitton_fib_rs import say_hello</pre>&#13;
			<pre>&gt;&gt;&gt; say_hello()</pre>&#13;
			<pre>saying hello from Rust!</pre>&#13;
			<p>Here we have it! We have got Rust working with Python and we have managed to package our Rust code as a <code>pip</code> module. This is a complete game changer. We can now utilize Rust code without having to rewrite our Python systems. However, we only have one file in Rust code. We need to learn how to build bigger Rust systems if we want to fully take advantage of our ability to fuse Rust with Python.</p>&#13;
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Building a Rust interface with the pyO3 crate</h1>&#13;
			<p>Building an interface does not just mean adding more functions to our module in Rust and wrapping <a id="_idIndexMarker337"/>them. In a sense, we do have to do <a id="_idIndexMarker338"/>some of this; however, exploring how to import them from other Rust files is important. We also must explore and understand the relationship that we can have between Rust and Python when we are building up our module. To achieve this, we will carry out these steps:</p>&#13;
			<ol>&#13;
				<li value="1">Build our Fibonacci module in our Rust package.</li>&#13;
				<li>Create command-line tools for our package. </li>&#13;
				<li>Create adapters for our package.</li>&#13;
			</ol>&#13;
			<p>With <em class="italic">step one</em>, we can <a id="_idIndexMarker339"/>just build out our module with <a id="_idIndexMarker340"/>Rust code. <em class="italic">Steps two</em> and <em class="italic">three</em> are more Python-focused, wrapping our Rust code in Python code to ease the interaction of our Rust module with external Python code. In <a href="B17720_06_Final_SK_ePub.xhtml#_idTextAnchor100"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Python Objects in Rust</em>, we will interact directly with Python objects in our Rust code. With all this in mind, let's our Python interface by initially building our Fibonacci code in Rust with <em class="italic">step one</em>. </p>&#13;
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Building our Fibonacci Rust code</h2>&#13;
			<p>In this step, we are <a id="_idIndexMarker341"/>going to build our Fibonacci module, spanning multiple Rust files. To achieve this, the file structure of our module takes the following form:</p>&#13;
			<pre>├── Cargo.toml</pre>&#13;
			<pre>├── README.md</pre>&#13;
			<pre>├── flitton_fib_rs</pre>&#13;
			<pre>│   ├── __init__.py</pre>&#13;
			<pre>├── setup.py</pre>&#13;
			<pre>├── src</pre>&#13;
			<pre>│   ├── fib_calcs</pre>&#13;
			<pre>│   │   ├── fib_number.rs</pre>&#13;
			<pre>│   │   ├── fib_numbers.rs</pre>&#13;
			<pre>│   │   └── mod.rs</pre>&#13;
			<pre>│   ├── lib.rs</pre>&#13;
			<p>Here, we can see that we have added our Fibonacci code under the <code>src/fib_calcs</code> directory, as we remember that <code>fib_numbers.rs</code> relies on <code>fib_number.rs</code>.</p>&#13;
			<p>Now, let's follow these steps:</p>&#13;
			<ol>&#13;
				<li value="1">We can initially define our Fibonacci number function in the <code>fib_number.rs</code> file with the following code:<pre>use pyo3::prelude::pyfunction;
#[pyfunction]
pub fn fibonacci_number(n: i32) -&gt; u64 {
    if n &lt; 0 {
         panic!("{} is negative!", n);
    }
     match n {
          0     =&gt; panic!("zero is not a right \
                   argument to fibonacci_number!"),
          1 | 2 =&gt; 1,
          _     =&gt; fibonacci_number(n - 1) + 
                   fibonacci_number(n - 2)
    }
}</pre><p>Here, we can see that we have imported the <code>pyfunction</code> macro to apply to our function. By now, we are familiar with calculating a Fibonacci number; however, unlike previous examples, it must be noted that we have removed the <code>if the input Fibonacci number to be calculated is 3</code> match statement. This is because that match statement significantly speeds up the code, and we want a fair speed comparison for the final section of this chapter.</p></li>&#13;
				<li>Now that we have <a id="_idIndexMarker342"/>defined our Fibonacci number function, we can define our <code>fibonacci_numbers</code> function in the <code>fib_numbers.rs</code> file with the following code:<pre>use std::vec::Vec;
use pyo3::prelude::pyfunction;
use super::fib_number::fibonacci_number;
#[pyfunction]
pub fn fibonacci_numbers(numbers: Vec&lt;i32&gt;) -&gt; \
  Vec&lt;u64&gt; {
    let mut vec: Vec&lt;u64&gt; = Vec::new();
    for n in numbers.iter() {
        vec.push(fibonacci_number(*n));
    }
    return vec
}</pre><p>Here, we can see that we accepted a vector of integers, looped through them, and appended <a id="_idIndexMarker343"/>them to an empty vector, returning the vector with all the calculated Fibonacci numbers. Here, we have imported the <code>fibonacci_number</code> function.</p></li>&#13;
				<li>However, we remember that we will not be able to import it, and neither of these functions will be available outside of the immediate directory if we do not define them in the <code>src/mod.rs</code> file with the following code:<pre>pub mod fib_number;
pub mod fib_numbers;</pre></li>&#13;
				<li>Now that we have defined both of our functions and declared them in our <code>src/mod.rs</code> file, we are now able to import them into our <code>lib.rs</code> file. We do this by initially declaring the <code>fib_calcs</code> module, and then importing the functions with the following code:<pre>mod fib_calcs;
use fib_calcs::fib_number::__pyo3_get_function \
  _fibonacci_number;
use fib_calcs::fib_numbers::__pyo3_get_function \
  _fibonacci_numbers;
pub mod fib_numbers;</pre><p>Here, it must be noted that our functions have the prefix of <code>__pyo3_get_function_</code>. This enables us to retain the macros applied to the functions. If we <a id="_idIndexMarker344"/>just directly import the functions, we will not be able to add them to the module, which will result in compilation errors when we are installing our package.</p></li>&#13;
				<li>Now that our functions are imported and ready, we can import-wrap them and add them to the module with the following code:<pre>#[pymodule]
fn flitton_fib_rs(_py: Python, m: &amp;PyModule) -&gt; \
  PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pyfunction!(say_hello));
    m.add_wrapped(wrap_pyfunction!(fibonacci_number));
    m.add_wrapped(wrap_pyfunction!(fibonacci_numbers);
    Ok(())
}</pre></li>&#13;
				<li>Now that we have built our modules, we can test them. We do this by uploading our changes to the GitHub repository, and using <code>pip uninstall</code> to uninstall our <code>pip</code> module and <code>pip install</code> to install our new package. Once our new package is installed, we can import and use our new functions in the Python terminal as follows:<pre><strong class="bold">&gt;&gt;&gt; from flitton_fib_rs import fibonacci_number, </strong>
<strong class="bold">fibonacci_numbers</strong>
<strong class="bold">&gt;&gt;&gt; fibonacci_number(20)</strong>
<strong class="bold">6765</strong>
<strong class="bold">&gt;&gt;&gt; fibonacci_numbers([20, 21, 22])</strong>
<strong class="bold">[6765, 10946, 17711]</strong>
<strong class="bold">&gt;&gt;&gt;</strong></pre></li>&#13;
			</ol>&#13;
			<p>Here, we can see that we can import and use the Fibonacci numbers that we have coded in Rust that span multiple files! We are now at the stage where nothing is stopping <a id="_idIndexMarker345"/>us from building our own Rust Python <code>pip</code> packages. If you have a specific problem in mind to solve in Rust, such as an expensive computation that your Python program is struggling to calculate, nothing is stopping you from solving that now. </p>&#13;
			<p>Now that we have gone to the trouble of packaging our Python package written in Rust, we can further utilize our package with command-line functionality. Packages installed with <code>pip</code> are convenient, powerful tools for command-line functionality. In the next section, we will access the Rust code in our package directly from the command line.</p>&#13;
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Creating command-line tools for our package</h2>&#13;
			<p>You may have noticed that to use our Fibonacci functions, we must start a Python console, import <a id="_idIndexMarker346"/>the functions, and use them. This is not very efficient if we just want to calculate a Fibonacci number in the console. We can remove these unnecessary procedures needed for calculating a Fibonacci number in the terminal by defining our entry points.</p>&#13;
			<p>Considering that we define our command-line entry points in the <code>setup.py</code> file, it makes sense to define our entry point in a Python file that acts as a wrapper to our Rust function (as we still want the speed benefits of Rust), as shown in the following figure:</p>&#13;
			<p class="figure-caption"> </p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_5.2_B17720.jpg" alt="Figure 5.2 – Flow for module entry point&#13;&#10;" width="338" height="410"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 5.2 – Flow for module entry point</p>&#13;
			<p>This wrapper can be done by importing <code>argparse</code> and the <code>fibonacci_number</code> function we made <a id="_idIndexMarker347"/>in the Rust module to create a simple Python function that gets user input and then passes it into the Rust function, printing out the result. We can achieve this by carrying out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">We can build the Python function that collects the arguments and calls the Rust code by adding the following code to the <code>flitton_fib_rs/fib_number_command.py</code> file we create:<pre>import argparse
from .flitton_fib_rs import fibonacci_number
def fib_number_command() -&gt; None:
    parser = argparse.ArgumentParser(
        description='Calculate Fibonacci numbers')
    parser.add_argument('--number', action='store', \
      type=int, required=True,help="Fibonacci \
        number to becalculated")
    args = parser.parse_args()
    print(f"Your Fibonacci number is: "
          f"{fibonacci_number(n=args.number)}")
}</pre><p>We must remember that when our Rust binary is compiled, it will be in the <code>flitton_fib_rs</code> directory, right next to the file we just created. </p></li>&#13;
				<li>Next, we define the entry point in the <code>setup.py</code> file. Now that we have our function, we can point to this in the <code>setup.py</code> file by declaring the path to this file and function for the <code>entry_points</code> parameter with the following code:<pre>entry_points={
    'console_scripts': [
        'fib-number = flitton_fib_rs.'
        'fib_number_command:'
        'fib_number_command',
    ],
},</pre></li>&#13;
				<li>Once this is done, we have fully plumbed up the Python entry point in our package. Finally, we can test our command line by passing in arguments to the entry point. Now, if we update our GitHub repository and reinstall our package in the <a id="_idIndexMarker348"/>Python environment, we can test our command line by typing in the following command:<pre>fib-number --number 20</pre><p>This will give us the following output:</p><pre>Your Fibonacci number is: 6765</pre></li>&#13;
			</ol>&#13;
			<p>We can see that our command-line tools work. Now we are at the stage where we have replicated the same functionality as our Python <code>pip</code> package previously in <a href="B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a><em class="italic">, Building pip Modules in Python</em>. However, we must go further now. We are fusing two different <a id="_idIndexMarker349"/>languages in our package. To gain full command of our <code>pip</code> package, we need to explore how to command and refine the interaction between Rust and Python. </p>&#13;
			<p>In our next step, we will build adapters that enable us to do this.</p>&#13;
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Creating adapters for our package</h2>&#13;
			<p>Before we try and build adapter interfaces, we need to understand what an <strong class="bold">adapter</strong> is. An adapter is a design <a id="_idIndexMarker350"/>pattern that manages the interface between two different modules, applications, languages, and so on. The title of the design pattern is descriptive of what we are doing. For instance, if you buy one of the new MacBook Pros, you will realize that you only have USB-C ports. Instead of opening your MacBook and rewiring it so that it can accept your standard USB memory stick, you buy an adapter. Adapters have multiple advantages. When it comes to modular software engineering, this gives us an advantage.</p>&#13;
			<p>For instance, let's say that module A relies on module B. Instead of importing aspects of module B throughout module A, we can create adapters that manage the interface between both modules. This, in turn, gives us a lot of flexibility. For instance, module C could be built as an improvement on module B. Instead of working through module A looking for, and trying to root out, the uses of module B, we know that they are all utilized in the adapter. We can even produce a second adapter slowly moving over to module C in time. If we want to delete a module or move it out, again, our connection to another module can be severed instantly by just deleting the adapters. Adapters are simple and give us ultimate flexibility. </p>&#13;
			<p>Considering what we have discussed about adapters, it makes sense that we create adapters between our Rust code and Python. Seeing as Python systems are essentially using our Rust code, it makes sense to build our adapters in Python.</p>&#13;
			<p>To demonstrate how to do this, we will create an adapter that accepts either a list or an integer. It then selects the right Rust function and implements it. However, for our purposes with this adapter, we can make up a scenario where there is a lot of incorrect data being fed into the module. We do not want it to error every time incorrect data is passed in, but we do want to categorize whether the calculation is a failure, and we want to count the number of correct calculations we do. This seems specific, and we must remember that, like the MacBook, we can have multiple adapters. Nothing is stopping us from chopping, changing, and deleting in the future if we need to. </p>&#13;
			<p>However, before we start writing code, we need to understand the layers involved for the adapter, as described here:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_5.3_B17720.jpg" alt="Figure 5.3 – The layers of a Python adapter for a Rust module&#13;&#10;" width="638" height="618"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 5.3 – The layers of a Python adapter for a Rust module</p>&#13;
			<p>In the preceding figure, we can see that Python objects come from types. However, we can interject how these objects are called from types with <strong class="bold">metaclasses</strong>. When it comes to metaclasses, we must <a id="_idIndexMarker351"/>build a metaclass that will define how our counter is called. Our counter is going to be universal. We do not know how the users will use our interface. They might loop through a list of data points, calling our adapter for each one. We need to ensure that no matter how many adapters are being called, they are <a id="_idIndexMarker352"/>all pointing to the same counter. This might be a little confusing. This will become clearer when we build it. </p>&#13;
			<h3>Using a singleton design pattern to build an adapter interface</h3>&#13;
			<p>First, we must define <a id="_idIndexMarker353"/>our <a id="_idIndexMarker354"/><code>Singleton</code> metaclass: </p>&#13;
			<ol>&#13;
				<li value="1">This can be done with the following code in the <code>flitton_fib_rs/singleton.py</code> file we create:<pre>class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, \
              cls).__call__(*args, **kwargs)
        return cls._instances[cls]</pre></li>&#13;
				<li>Here, we can see that our <code>Singleton</code> class inherits directly from <code>type</code>. Here, what is happening is that we have a dictionary called <code>_instances</code>, where the keys to this <a id="_idIndexMarker355"/>dictionary are <a id="_idIndexMarker356"/>the class types. When a class that has <code>Singleton</code> as a metaclass is called, the type of that class is checked in the dictionary. If the type is not in the dictionary, then it is constructed and put into the dictionary. The instance in the dictionary is then returned. What this essentially means is that we cannot have two instances of a class. This process is laid out in the following figure:<div><img src="img/Figure_5.4_B17720.jpg" alt="Figure 5.4 – The logic flow for a Singleton metaclass&#13;&#10;" width="738" height="948"/></div><p class="figure-caption">Figure 5.4 – The logic flow for a Singleton metaclass</p></li>&#13;
				<li>Now, we will use our <code>Singleton</code> class to construct our counter. This can be done with <a id="_idIndexMarker357"/>the following <a id="_idIndexMarker358"/>code in the <code>flitton_fib_rs/counter.py</code> file that we create:<pre>from .singleton import Singleton
class Counter(metaclass=Singleton):
    def __init__(self, initial_value: int = 0) -&gt; \
      None:
        self._value: int = initial_value
    def increase_count(self) -&gt; None:
        self._value += 1
    @property
    def value(self) -&gt; int:
        return self._value</pre><p>Now, our <code>Counter</code> class cannot be constructed twice in the same program. Therefore, we <a id="_idIndexMarker359"/>can ensure <a id="_idIndexMarker360"/>that there will only be one <code>Counter</code> class, no matter how many times we call it. </p></li>&#13;
				<li>We can now use it on our main adapter. We will house our main adapter in the <code>flitton_fib_rs/fib_number_adapter.py</code> file that we create. First of all, we import all of the functions and objects that we need with the following code:<pre>from typing import Union, List, Optional
from .flitton_fib_rs import fibonacci_number, \
    fibonacci_numbers
from .counter import Counter</pre><p>Here, we can see that we have imported the typing that we need. We have also imported the Rust Fibonacci numbers that we will be using and our counter. Now that we have imported what we need, we can build our interface constructor. </p></li>&#13;
				<li>For our adapter, we will need to have a number input, a status of whether the process is <a id="_idIndexMarker361"/>successful <a id="_idIndexMarker362"/>or not, along with the actual result, which will be the calculated Fibonacci number, or an error message if there is a failure. We will also have a counter, and we will have to process the input during the construction of the object. This can be denoted with the following code:<pre>class FlittonFibNumberAdapter:
    def __init__(self,
        number_input: Union[int, List[int]]) -&gt; None:
        self.input: Union[int, List[int]] = \
          number_input
        self.success: bool = False
        self.result: Optional[Union[int, List[int]]] \
          = None
        self.error_message: Optional[str] = None
        self._counter: Counter = Counter()
        self._process_input()</pre><p>Remember, even though we call the counter, it is a singleton pattern; therefore, the counter will be the same instance across all instances of the adapter. Now that all of the correct attributes have been defined, we have to define what is an actual success. </p></li>&#13;
				<li>This is where we state that success is <code>True</code>, and we increase the counter by one. This can be denoted by the <code>FlittonFibNumberAdapter</code> instance function, as shown here:<pre>    def _define_success(self) -&gt; None:
        self.success = True
        self._counter.increase_count()</pre><p>This is smooth; because we have defined a clean interface for the counter, there is little explanation needed. Now that we have our success defined, we need to process the input because there are two different functions, one that takes a list and one that takes an integer.</p></li>&#13;
				<li>We can pass in the correct input to the correct function with the <code>FlittonFibNumberAdapter</code> instance function, as shown here:<pre>    def _process_input(self) -&gt; None:
        if isinstance(self.input, int):
            self.result = fibonacci_number( \
                n=self.input)
            self._define_success()
        elif isinstance(self.input, list):
            self.result = fibonacci_numbers( \
                numbers=self.input)
            self._define_success()
        else:
            self.error_message = "input needs to be \
              a list of ints or an int"</pre><p>Here, we can see that we define an error message if there isn't a list of integers passed in. If we <a id="_idIndexMarker363"/>do pass in the <a id="_idIndexMarker364"/>correct input, we define the result as the result of the function and call the <code>_define_success</code> function.</p></li>&#13;
				<li>The only thing left is to expose the count for the outside user. This can be done with the following <code>FlittonFibNumberAdapter</code> property:<pre>    @property
    def count(self) -&gt; int:
        return self._counter.value</pre></li>&#13;
				<li>Again, the <a id="_idIndexMarker365"/>counter interface <a id="_idIndexMarker366"/>is clean, so no explanation is needed. Our adapter interface is now completed. All we need to do is expose it to the user by importing it into the <code>src/__init__.py</code> file with the following code:<pre>from .fib_number_adapter import \
  FlittonFibNumberAdapter</pre></li>&#13;
			</ol>&#13;
			<p>Everything is done. We can now update our GitHub repository and reinstall our package in the Python environment. </p>&#13;
			<h3>Testing our adapter interface in the Python console</h3>&#13;
			<p>We can now test <a id="_idIndexMarker367"/>our adapter with the Python <a id="_idIndexMarker368"/>console commands, as shown here:</p>&#13;
			<pre>&gt;&gt;&gt; from flitton_fib_rs import FlittonFibNumberAdapter</pre>&#13;
			<pre>&gt;&gt;&gt; test = FlittonFibNumberAdapter(10)</pre>&#13;
			<pre>&gt;&gt;&gt; test_two = FlittonFibNumberAdapter(15)</pre>&#13;
			<pre>&gt;&gt;&gt; test_two.count</pre>&#13;
			<pre>2</pre>&#13;
			<pre>&gt;&gt;&gt; test.count</pre>&#13;
			<pre>2</pre>&#13;
			<pre>&gt;&gt;&gt; test_two.success</pre>&#13;
			<pre>True</pre>&#13;
			<pre>&gt;&gt;&gt; test_two.result</pre>&#13;
			<pre>610</pre>&#13;
			<p>Here, we can see that we can import our adapter from the module. We can then define two <a id="_idIndexMarker369"/>different adapters. We can see that the <a id="_idIndexMarker370"/>count is consistent across both adapters, which means that our singleton pattern works! Both adapters are pointing to the same <code>Counter</code> instance! All of our adapters will point to that same <code>Counter</code> instance. We can also see that the success is <code>True</code>, and we can access the result of the calculation: </p>&#13;
			<ol>&#13;
				<li value="1">Now, in the same Python console, we can test to see whether an incorrect input results in a failure and doesn't increase the count with the Python console commands shown next:<pre><strong class="bold">&gt;&gt;&gt; test_three = FlittonFibNumberAdapter(</strong>
<strong class="bold">                               "should fail"</strong>
<strong class="bold">                             )</strong>
<strong class="bold">&gt;&gt;&gt; test_three.count</strong>
<strong class="bold">2</strong>
<strong class="bold">&gt;&gt;&gt; test_three.result</strong>
<strong class="bold">&gt;&gt;&gt; test_three.success</strong>
<strong class="bold">False</strong>
<strong class="bold">&gt;&gt;&gt; test_three.error_message</strong>
<strong class="bold">'input needs to be a list of ints or an int'</strong>
<strong class="bold">&gt;&gt;&gt;</strong></pre></li>&#13;
				<li>Here, we can see that the count hasn't increased, the success is <code>False</code>, and that there is an error message. The final input test can be done by inputting a list of integers with the Python console command shown next:<pre><code>3</code>, as they are all pointing to the same <code>Counter</code> instance and there was one failure out of the four. </p></li>&#13;
				<li>Calling them in the same Python console command reveals whether this is true, as shown next:<pre><strong class="bold">&gt;&gt;&gt; test.count</strong>
<strong class="bold">3</strong>
<strong class="bold">&gt;&gt;&gt; test_two.count</strong>
<strong class="bold">3</strong>
<strong class="bold">&gt;&gt;&gt; test_three.count</strong>
<strong class="bold">3</strong>
<strong class="bold">&gt;&gt;&gt; test_four.count</strong>
<strong class="bold">3</strong></pre></li>&#13;
			</ol>&#13;
			<p>There we have it. We have fully configured the Python interface of our module. </p>&#13;
			<p>In this section, we built our Rust <code>pip</code> package with a Python interface. You might be tempted to add extra directories and flesh out entire Python modules in the <code>flitton_fib_rs</code> directory. However, extra directories in the <code>flitton_fib_rs</code> directory do not get copied over when the package is being installed. This is fine as well. We are essentially building Rust <code>pip</code> packages. Rust is fast and safe, and we should be leaning on this as much as we can. The Python adapters and command in the <code>flitton_fib_rs</code> directory should be there to smooth over the interface. For instance, if we want the memory of our interface to be managed in a particular way, it makes sense to do this in the interface of Python as a wrapper, as Python will be the system that <a id="_idIndexMarker373"/>is importing and using the <code>pip</code> package. If you <a id="_idIndexMarker374"/>find yourself putting anything other than adapters and command-line functions in the <code>flitton_fib_rs</code> module, that is a warning sign that you should try and consider putting it in the Rust module itself. We have tested our package manually; however, we need to ensure that our Rust Fibonacci calculation functions do as we expect.</p>&#13;
			<p>In the next section, we will be creating unit tests for our Rust code. </p>&#13;
			<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Building tests for our Rust package</h1>&#13;
			<p>Previously, in <a href="B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Building pip Modules in Python</em>, we built unit tests for our Python code. In this section, we will build unit tests for our Fibonacci functions. These tests do <a id="_idIndexMarker375"/>not need any extra packages or dependencies. We can <a id="_idIndexMarker376"/>use Cargo to manage our testing. This can be done by adding our testing code in the <code>src/fib_calcs/fib_number.rs</code> file. The steps are as follows:</p>&#13;
			<ol>&#13;
				<li value="1">We do this by creating a module in the <code>src/fib_calcs/fib_number.rs</code> file with the following code:<pre>#[cfg(test)]
mod fibonacci_number_tests {
      use super::fibonacci_number;
}</pre><p>Here, we can see that we have defined a module in the same file and decorated the module with the <code>#[cfg(test)]</code> macro. </p></li>&#13;
				<li>We can also see that we must import the function, as it is super to the module. Inside this module, we can run standard tests that check to see whether the integers we pass in calculate the Fibonacci number we expect with the following code:<pre>     #[test]
     fn test_one() {
          assert_eq!(fibonacci_number(1), 1);
     }
     #[test]
     fn test_two() {
          assert_eq!(fibonacci_number(2), 1);
     }
     #[test]
     fn test_three() {
           assert_eq!(fibonacci_number(3), 2);
     }
     #[test]
     fn test_twenty() {
           assert_eq!(fibonacci_number(20), 6765);
     }</pre><p>Here, we can see that we have decorated our test functions with the <code>#[test]</code> macro. If they <a id="_idIndexMarker377"/>do not produce the results that <a id="_idIndexMarker378"/>we expect, then <code>assert_eq!</code> and the test will fail. We also must note that our function will panic if we pass in zero or a negative value. </p></li>&#13;
				<li>These can be tested with the test functions, as shown next:<pre>      #[test]
      #[should_panic]
      fn test_0() {
          fibonacci_number(0);
      }
      #[test]
      #[should_panic]
      fn test_negative() {
          fibonacci_number(-20);
      }</pre><p>Here, we <a id="_idIndexMarker379"/>pass in the failing inputs. If they do <a id="_idIndexMarker380"/>not panic, then the test will fail because we decorated it with the <code>#[should_panic]</code> macro. </p></li>&#13;
				<li>Now that we have created our tests for the <code>fibonacci_number</code> function, we can build our test for our <code>fibonacci_numbers</code> function in the <code>src/fib_calcs/fib_numbers.rs</code> file with the following code:<pre>#[cfg(test)]
mod fibonacci_numbers_tests {
      use super::fibonacci_numbers;
      #[test]
      fn test_run() {
      let outcome = fibonacci_numbers([1, 2, 3, \
        4].to_vec());
        assert_eq!(outcome, [1, 1, 2, 3]);
      }
}</pre></li>&#13;
				<li>Here, we can see that this has the same layout as our other tests. If we want to run our tests, we can run them with the following command:<pre>cargo test</pre><p>This <a id="_idIndexMarker381"/>gives <a id="_idIndexMarker382"/>us the following printout:</p><pre><strong class="bold">running 7 tests</strong>
<strong class="bold">test fib_calcs::fib_number::fibonacci_number_tests::test_th</strong>
<strong class="bold">ree ... ok</strong>
<strong class="bold">test fib_calcs::fib_numbers::fibonacci_numbers_tests::test_</strong>
<strong class="bold">run ... ok</strong>
<strong class="bold">test fib_calcs::fib_number::fibonacci_number_tests::</strong>
<strong class="bold">test_two ... ok</strong>
<strong class="bold">test fib_calcs::fib_number::fibonacci_number_tests::test_on</strong>
<strong class="bold">e ... ok</strong>
<strong class="bold">test fib_calcs::fib_number::fibonacci_number_tests::</strong>
<strong class="bold">test_twenty ... ok</strong>
<strong class="bold">test fib_calcs::fib_number::fibonacci_number_tests::</strong>
<strong class="bold">test_negative ... ok</strong>
<strong class="bold">test fib_calcs::fib_number::fibonacci_number_tests::</strong>
<strong class="bold">test_0 ... ok</strong>
<strong class="bold">test result: ok. 7 passed; 0 failed; 0 ignored; 0 </strong>
<strong class="bold">measured; 0 </strong>
<strong class="bold">filtered out; finished in 0.00s</strong>
<strong class="bold">     Running target/debug/deps/flitton_fib_rs-</strong>
<strong class="bold">07e3ba4b0bc8cc1e</strong>
<strong class="bold">running 0 tests</strong>
<strong class="bold">test result: ok. 0 passed; 0 failed; 0 ignored; 0 </strong>
<strong class="bold">measured; 0 </strong>
<strong class="bold">filtered out; finished in 0.00s</strong>
<strong class="bold">   Doc-tests flitton_fib_rs</strong>
<strong class="bold">running 0 tests</strong>
<strong class="bold">test result: ok. 0 passed; 0 failed; 0 ignored; 0 </strong>
<strong class="bold">measured; 0 </strong>
<strong class="bold">filtered out; finished in 0.00s</strong></pre></li>&#13;
			</ol>&#13;
			<p>Here, we can <a id="_idIndexMarker383"/>see that all of our tests have run and <a id="_idIndexMarker384"/>passed. If we recall <a href="B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Building pip Modules in Python</em>, we'll remember that we used mocking.</p>&#13;
			<p>Rust is still developing <code>mockall</code>, enables mocking and can be found <a id="_idIndexMarker385"/>at this URL: https://docs.rs/mockall/0.10.0/mockall/. Another cleaner crate that can be utilized for mocking can be found at this URL: <a href="https://docs.rs/mocktopus/0.7.11/mocktopus/">https://docs.rs/mocktopus/0.7.11/mocktopus/</a>.</p>&#13;
			<p>We have now covered how to build our module and test it. We are at the end of building a Rust <code>pip</code> module with tests and a Python interface. We can now test the speed of our Rust module to see what will happen and how powerful Rust modules as a tool are.</p>&#13;
			<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Comparing speed with Python, Rust, and Numba</h1>&#13;
			<p>We have now built a <code>pip</code> module in Rust with command-line tools, Python interfaces, and unit tests. This <a id="_idIndexMarker386"/>is a shiny new tool that we have. Let's put it to the test. We know that Rust by itself is faster than Python. However, do we know that the <code>pyo3</code> bindings slow us down? Also, there is another way to speed up our Python code and this is with Numba, a Python package that compiles Python code to speed it up. Should we go through all of the haste of creating the Rust package if we can achieve the same speed with Numba? In this section, we will run our Fibonacci function several times, in Python, Numba, and our Rust module. It has to be noted that Numba can be a headache to install. For instance, I could not <a id="_idIndexMarker387"/>install it on my MacBook Pro M1. I had to install Numba on a Linux laptop to run this section. You don't have to run the code in this section; it is more for demonstrative purposes. If you do want to try and run the test script, then all of the steps are provided:</p>&#13;
			<ol>&#13;
				<li value="1">First of all, we have to install the Rust <code>pip</code> module that we have built. We then install Numba with the following command:<pre>pip install numba</pre></li>&#13;
				<li>Once this is done, we have everything we need. In any Python script, we import the packages required with the following code:<pre>from time import time
from flitton_fib_rs.flitton_fib_rs import \
  fibonacci_number
from numba import jit</pre><p>We are using the <code>time</code> module to time how long it takes for each run to happen. We also use the Fibonacci function from our Rust <code>pip</code> module, and we also require the <code>jit</code> decorator from Numba. <strong class="bold">jit</strong> stands for <strong class="bold">just in time</strong>. This is because Numba compiles the function when it loads it. </p></li>&#13;
				<li>We now define our standard Python function with the following code:<pre>def python_fib_number(number: int) -&gt; int:
    if number &lt; 0:
        raise ValueError(
            "Fibonacci has to be equal or above zero"
        )
    elif number in [1, 2]:
        return 1
    else:
        return numba_fib_number(number - 1) + \
               numba_fib_number(number - 2)</pre></li>&#13;
				<li>We can see that this is the same logic that the Rust code is built with. We want to ensure that our tests are reputable comparisons. We then define the Python function that is compiled with <code>jit</code> with the following code:<pre>@jit(nopython=True)
def numba_fib_number(number: int) -&gt; int:
    if number &lt; 0:
        raise ValueError("Fibonacci has to be equal \
          or above zero")
    elif number in [1, 2]:
        return 1
    else:
        return numba_fib_number(number - 1) + \
               numba_fib_number(number - 2)</pre></li>&#13;
				<li>We can see <a id="_idIndexMarker388"/>that it is the same. The only difference is that we have decorated it with <code>jit</code> and set <code>nopython</code> to <code>True</code> to obtain optimal performance. We then run all of them with the following code:<pre>t0 = time()
for i in range(0, 30):
    numba_fib_number(35)
t1 = time()
print(f"the time taken for numba is: {t1-t0}")
t0 = time()
for i in range(0, 30):
    numba_fib_number(35)
t1 = time()
print(f"the time taken for numba is: {t1 - t0}")</pre><p>Here, we can see that we loop through a range from <code>0</code> to <code>30</code> and hit our function <code>30</code> times with the number <code>35</code>. We then print the time elapsed for this to happen. We notice that we have done this twice. This is because the first run will involve compiling the function. </p></li>&#13;
				<li>When we run this, we get the following console printout:<pre><strong class="bold">the time taken for numba is: 2.6187334060668945</strong>
<strong class="bold">the time taken for numba is: 2.4959869384765625</strong></pre></li>&#13;
				<li>Here, we can see that some time is shaved off in the second run because it is not <a id="_idIndexMarker389"/>compiling. Running this several times shows that this reduction is standard. Now, we set up our standard Python test with the following code:<pre>t0 = time()
for i in range(0, 30):
    python_fib_number(35)
t1 = time()
print(f"the time taken for python is: {t1 - t0}")</pre></li>&#13;
				<li>Running this test will get the following console printout:<pre><strong class="bold">the time taken for python is: 2.889884853363037</strong></pre></li>&#13;
				<li>We can see that there is a significant speed decrease when it comes to running pure Python code as opposed to our Numba function. Now, we can move on to the final test, which is our Rust test, defined with the following code:<pre>t0 = time()
for i in range(0, 30):
    fibonacci_number(35)
t1 = time()
print(f"the time taken for rust is: {t1 - t0}")</pre></li>&#13;
				<li>Running this test gives us the following console printout:<pre><strong class="bold">the time taken for rust is: 0.9373788833618164</strong></pre></li>&#13;
			</ol>&#13;
			<p>Here, we can see that the Rust function is a lot faster. This does not mean that <code>Numba</code> is a waste of time. When it <a id="_idIndexMarker390"/>comes to Python optimizations, Numba can perform well in certain situations. In other situations, the Python optimizations will not affect them at all. Considering how easy they are to apply, it is always worth checking to see whether there is a speed-up. However, we also now know that Rust will always be faster than pure Python code.  </p>&#13;
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Summary</h1>&#13;
			<p>In this chapter, we have built a fully fleshed-out Python <code>pip</code> module with command-line tools, interfaces, and Rust code. We managed <code>gitignore</code> for both Rust and Python development. We then defined our setup tools for packaging our Python code and module with the compilation of Rust code that has Python bindings. Once these were defined, we learned how to build Rust functions that spanned multiple Rust files that could be wrapped in <code>pyo3</code> bindings. </p>&#13;
			<p>Our development did not just stop at Rust. We also explored Python's singleton and adapter design patterns to build more advanced Python interfaces for our users. We then tested our code with unit tests and speed checking. It must be noted that we did not cover GitHub actions in this chapter. GitHub actions are defined in the same way as they were in the previous chapter. Instead of running tests using the Python unit test, we run our tests using Cargo and so on. However, uploading to PyPI is a little more complicated. To cover this, examples on how to pre-compile and upload Rust <code>pip</code> modules are provided in the <em class="italic">Further reading</em> section. </p>&#13;
			<p>We now have a powerful skill, which is building Python <code>pip</code> modules that utilize Rust. However, we leaned on our Python to build our interfaces. In the next chapter, we will work with Python objects within our Rust code. Therefore, we will be able to pass in more advanced Python data objects into our Rust code. We will also enable our Rust code to return fully fledged Python objects.</p>&#13;
			<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">How do you define a <code>setup.py</code> file for a <code>pyo3</code> Rust Python <code>pip</code> module?</li>&#13;
				<li>What is the layout of our <code>pip</code> module in the Python environment after it has been installed? Also, why can we not build Python modules spanning multiple directories?</li>&#13;
				<li>What is a singleton design pattern?</li>&#13;
				<li>What is an adapter design pattern and what are the advantages of using the design pattern?</li>&#13;
				<li>What is a metaclass and how do we use it?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Answers</h1>&#13;
			<ol>&#13;
				<li value="1">Here, we must use the <code>dist</code> package to install <code>setuptools_rust</code> before we do anything else in the <code>setup.py</code> file. We define the parameters for the setup and use the <code>RustExtension</code> object from <code>setuptools_rust</code>, pointing to where the compiled Rust module will be once installed.  </li>&#13;
				<li>When the <code>pip</code> module is installed, the binary Rust file is in the same directory where the Python files are defined for the module. However, directories in that directory are not copied over and, therefore, they will be lost during the installation. </li>&#13;
				<li>A singleton design pattern ensures that all references to a particular class all point to one instance of that class.</li>&#13;
				<li>The adapter pattern is an interface that manages the interaction between two modules. The advantage is the flexibility between the modules. We know where all the interactions are, and if we want to sever the modules, all we need to do is delete the adapter. This enables us to switch modules as and when we need them.</li>&#13;
				<li>A metaclass is a class that lies between a type and an object. Because of this, we can use this to see how we manage calling our objects. </li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Further reading</h1>&#13;
			<ul>&#13;
				<li><em class="italic">Mre</em> – an example of GitHub actions for deploying Rust packages on PyPI (2021): <a href="https://github.com/mre/hyperjson/blob/master/.github/workflows/ci.yml%0D">https://github.com/mre/hyperjson/blob/master/.github/workflows/ci.yml</a></li>&#13;
				<li><em class="italic">Mastering Object-Oriented Python</em>, <em class="italic">Steven F. Lott</em>, <em class="italic">Packt Publishing </em>(2019)</li>&#13;
				<li><em class="italic">The PyO3 user guide</em>: <a href="https://pyo3.rs/v0.13.2/">https://pyo3.rs/v0.13.2/</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>