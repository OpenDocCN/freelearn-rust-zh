- en: Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: In this chapter, we'll take a look at how fallible and unexpected situations
    are handled in Rust, gain an understanding of the error handling with errors as
    types, and look at how to design interfaces that compose well with error types.
    We aim to cover the first two error scenarios as they are under our control and
    languages generally provide mechanisms for handling these errors. If fatal errors
    occur, our program gets aborted by the operating system kernel and so we don't
    have much control over them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Rust中如何处理可能性和意外情况，了解将错误作为类型的错误处理，并查看如何设计与错误类型良好组合的接口。我们的目标是涵盖前两种错误场景，因为它们在我们控制之下，并且语言通常提供处理这些错误的机制。如果发生致命错误，我们的程序将被操作系统内核终止，因此我们对此没有太多控制权。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Error handling prelude
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理序言
- en: Recovering from errors using the `Option` and `Result` types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Option`和`Result`类型从错误中恢复
- en: Combinator methods for `Option` and `Result`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`和`Result`的组合方法'
- en: Propagating errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误传播
- en: Non-recoverable errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非恢复性错误
- en: Custom errors and the `Error` trait
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义错误和`Error`特质
- en: Error handling prelude
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理序言
- en: '"From then on, when anything went wrong with a computer, we said it had bugs
    in it."'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '"从那时起，当计算机出现问题时，我们就说它里面有虫子（bugs）。"'
- en: '- *Grace Hopper*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '- *Grace Hopper*'
- en: 'Writing programs that behave well under expected conditions is a good start.
    It''s when a program encounters unexpected situations where it gets really challenging.
    Proper error handling is an important but often overlooked practice in software
    development. Most error handling, in general, falls into three categories:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编写在预期条件下表现良好的程序是一个好的开始。当程序遇到意外情况时，它才会真正具有挑战性。适当的错误处理是软件开发中一个重要但常常被忽视的实践。一般来说，大多数错误处理都分为三类：
- en: Recoverable errors that are expected to happen due to the user and the environment
    interacting with the program, for example, a file not found error or a number
    parse error.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可恢复性错误，由于用户和环境与程序交互而预期会发生，例如，找不到文件错误或数字解析错误。
- en: Non-recoverable errors that violate the contracts or invariants of the program,
    for example, index out of bounds or divide by zero.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非恢复性错误，违反了程序的合约或不变性，例如，索引越界或除以零。
- en: Fatal errors that abort the program immediately. Such situations include running
    out of memory, and stack overflow.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即终止程序的致命错误。这种情况包括内存耗尽和栈溢出。
- en: Programming in the real world often entails dealing with errors. Examples include
    malicious input to a web application, connection failures in network clients,
    filesystem corruption, and integer overflow errors in numerical applications.
    In the event of there being no error handling, the program just crashes or is
    aborted by the OS when it hits an unexpected situation. Most of the time, this
    is not the behavior we want our programs to exhibit in unexpected situation. Consider,
    for example, a real-time stream processing service that fails to receive messages
    from clients at some point in time due to a failure in parsing messages from a
    client who is sending malformed messages. If we have no way to handle this, our
    service will abort every time we have parsing errors. This is not good from a
    usability perspective and is definitely not a characteristic of network applications.
    The ideal way for the service to handle this situation is to catch the error,
    act upon it, pass the error log to a log-aggregation service for later analysis
    and continue receiving messages from other clients. That's when a recoverable
    way of handling errors comes into the picture, and is often the practical way
    to model error handling. In this case, the language's error handling constructs
    enable programmers to intercept errors and take action against them, which saves
    the program from being aborted.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中编程往往意味着处理错误。例如，包括网络应用程序中的恶意输入、网络客户端的连接失败、文件系统损坏以及数值应用程序中的整数溢出错误。如果没有错误处理，程序在遇到意外情况时会崩溃或被操作系统终止。大多数情况下，这不是我们希望程序在意外情况下表现出的行为。例如，考虑一个实时流处理服务，由于解析发送畸形消息的客户端的消息失败，在某个时间点无法从客户端接收消息。如果我们没有处理这种错误的方法，我们的服务每次遇到解析错误时都会终止。从可用性的角度来看，这并不好，这绝对不是网络应用程序的特征。服务处理这种情况的理想方式是捕获错误，采取行动，将错误日志传递给日志聚合服务以供后续分析，并继续从其他客户端接收消息。这就是可恢复的错误处理方式出现的时候，这通常是建模错误处理的实际方法。在这种情况下，语言的错误处理结构使程序员能够拦截错误并采取行动，从而避免程序被终止。
- en: Two paradigms that are quite popular when approaching error handling are return
    codes and exceptions. The C language embraces the return code model. This is a
    very trivial form of error handling, where functions use integers as return values
    to signify whether an operation succeeded or failed. A lot of C functions return
    a `-1` or `NULL` in the event of an error. For errors when invoking system calls,
    C sets the global `errno` variable upon failure. But, being a global variable,
    nothing stops you from modifying the `errno` variable from anywhere in the program.
    It's then for the programmer to check for this error value and handle it. Often,
    this gets really cryptic, error-prone, and is not a very flexible solution. The
    compiler does not warn us if we forget to check the return value either, unless
    you use a static analysis tool.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理错误时，两种相当流行的范式是返回码和异常。C语言采用了返回码模型。这是一种非常简单的错误处理形式，其中函数使用整数作为返回值来表示操作是否成功或失败。许多C函数在发生错误时返回`-1`或`NULL`。对于系统调用的错误，C语言在失败时设置全局`errno`变量。但是，作为一个全局变量，没有任何东西可以阻止你在程序的任何地方修改`errno`变量。然后程序员需要检查这个错误值并处理它。通常，这会变得非常晦涩难懂，容易出错，并且不是一个非常灵活的解决方案。编译器也不会警告我们忘记检查返回值，除非你使用静态分析工具。
- en: Another approach to handling errors is via exceptions. Higher-level programming
    languages such as Java and C# use this form of error handling. In this paradigm,
    code that might fail should be wrapped in a `try {}` block and any failure within
    the `try{}` block must be caught in a `catch {}` block (ideally, with the `catch`
    block immediately after the `try` block). But, exceptions also have their downsides.
    Throwing an exception is expensive, as the program has to unwind the stack, find
    the appropriate exception handler, and run the associated code. To avoid this
    overhead, programmers often adopt the defensive code style of checking for exception-throwing
    code and then proceeding forward. Also, the implementation of exceptions is flawed
    in many languages, because it allows ignorant programmers to swallow exceptions
    with a catch all block with a base exception class such as a throwable in Java,
    thereby resulting in a possibly inconsistent state in the program if they just
    log and ignore the exception. Also, in these languages, there is no way for a
    programmer to know by looking at the code whether a method could throw an exception,
    unless they are using methods with checked exceptions. This makes it hard for
    programmers to write safe code. Due to this, programmers often need to rely on
    the documentation (if it exists at all) of methods to figure out whether they
    could throw an exception.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误的另一种方法是使用异常。高级编程语言，如Java和C#，都使用这种错误处理形式。在这种范式下，可能失败的代码应该被包裹在一个`try {}`块中，并且`try{}`块内的任何失败都必须在`catch
    {}`块中捕获（理想情况下，`catch`块紧随`try`块之后）。但是，异常也有其缺点。抛出异常代价高昂，因为程序必须回滚堆栈，找到适当的异常处理器，并运行相关的代码。为了避免这种开销，程序员通常会采用防御性代码风格，检查可能抛出异常的代码，然后继续前进。此外，许多语言中异常的实现存在缺陷，因为它允许无知的程序员使用基类异常（如Java中的`throwable`）的捕获所有块来吞没异常，如果他们只是记录并忽略异常，这可能导致程序状态的不一致性。在这些语言中，程序员无法通过查看代码来判断一个方法是否可能抛出异常，除非他们使用带有已检查异常的方法。这使得程序员编写安全代码变得困难。因此，程序员通常需要依赖方法的文档（如果有的话）来确定它们是否可能抛出异常。
- en: Rust, on the other hand, embraces type-based error handling, which is seen in
    functional languages such as OCaml and Haskell, and at the same time also appears
    similar to C's returning error code model. But in RUST, the return values are
    proper error types and can be user-defined, The language's type system mandates
    handling error states at compile time. If you know Haskell, it is quite similar
    to its `Maybe` and `Either` types; Rust just has different names for them, that
    is, `Option` and `Result` for recoverable errors. For non-recoverable errors,
    there's a mechanism called **panic**, which is a fail-hard error handling strategy
    and it is advisable to use it as a last resort when there is a bug or violation
    of an invariant in the program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Rust拥抱基于类型的错误处理，这在函数式语言如OCaml和Haskell中可以看到，同时它也类似于C的错误代码返回模型。但在RUST中，返回值是正确的错误类型，并且可以由用户定义。该语言类型系统强制在编译时处理错误状态。如果你了解Haskell，它与其`Maybe`和`Either`类型非常相似；Rust只是给它们起了不同的名字，即对于可恢复错误，有`Option`和`Result`；对于不可恢复错误，有一个称为**panic**的机制，它是一种严格的错误处理策略，建议在程序中存在错误或违反不变性时将其作为最后的手段使用。
- en: Why did Rust choose this form of error handling? Well, as we have already said,
    exceptions and their associated stack unwinding have an overhead. This goes against
    Rust's central philosophy of zero runtime costs. Secondly, exception-style error
    handling, as it is typically implemented, allows ignoring these errors via catch-all
    exception handlers. This creates the potential for program state inconsistency,
    which goes against Rust's safety tenet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Rust选择了这种错误处理形式？正如我们之前所说，异常及其相关的堆栈回滚具有开销。这与Rust的核心哲学——零运行时成本相悖。其次，异常风格的错误处理，如通常实现的那样，允许通过捕获所有异常处理器来忽略这些错误。这可能导致程序状态的不一致性，这与Rust的安全性原则相违背。
- en: With the prelude aside, let's dig into some recoverable error handling strategies!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除去前言，让我们深入探讨一些可恢复的错误处理策略！
- en: Recoverable errors
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可恢复的错误
- en: As we have already said, the majority of error handling in Rust is done via
    two generic types, `Option` and `Result`. They act as wrapper types in the sense
    that it is recommended that APIs that can fail return the actual values by putting
    them inside these types. These types are built with a combination of enums and
    generics. As an enum, they get the ability to store a success state and an error
    state, while generics allow them to specialize at compile time so that they store
    any value in either state. These types also come with a lot of convenient methods
    (commonly known as **combinators***)* implemented on them, allowing you to consume,
    compose, or transform the inner values easily. One thing to note about the `Option`
    and `Result` types is that they are ordinary types from the standard library in
    the sense that they aren't compiler built-ins that are treated differently by
    the compiler. Anyone can create a similar error abstraction using the power of
    enums and generics. Let's start exploring them by first looking at the simplest
    one, that is, `Option`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，Rust 中的错误处理大部分是通过两种泛型类型 `Option` 和 `Result` 来完成的。它们作为包装类型，意味着建议那些可能失败的
    API 通过将这些值放入这些类型中来返回实际值。这些类型是通过枚举和泛型的组合构建的。作为枚举，它们能够存储成功状态和错误状态，而泛型允许它们在编译时进行特殊化，以便在任一状态下存储任何值。这些类型还附带了许多方便的方法（通常称为
    **组合子**）*，允许你轻松地消费、组合或转换内部值。关于 `Option` 和 `Result` 类型的一件事是，它们是标准库中的普通类型，这意味着它们不是编译器内置的，编译器会以不同的方式处理它们。任何人都可以利用枚举和泛型的力量创建类似的错误抽象。让我们通过首先查看最简单的一个来开始探索它们，那就是
    `Option`。
- en: Option
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Option
- en: 'In languages that have the notion of nullable values, there is a defensive
    code style that programmers adopt to perform operations on any value that can
    possibly be null. Taking an example from Kotlin/Java, it appears something like
    this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有空值概念的语言中，程序员会采用一种防御性代码风格来对任何可能为空的值执行操作。以 Kotlin/Java 为例，它看起来像这样：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we check that `container` is not `null` and then call `process_item`
    on it. If we forget the null safety check, we'll get the infamous `NullPointerException`
    when we try to invoke `container.process_item()` – you only get to know this at
    runtime when it throws the exception. Another downside is the fact that we can't
    deduce right away whether `container` is `null` just by looking at the code. To
    save against that, the code base needs to be sprinkled with these null checks,
    which hinder its readability to a great extent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查 `container` 是否不是 `null`，然后调用其上的 `process_item`。如果我们忘记进行空安全检查，当我们尝试调用
    `container.process_item()` 时，将会遇到臭名昭著的 `NullPointerException` - 你只有在运行时抛出异常时才会知道这一点。另一个缺点是，仅通过查看代码，我们无法立即推断出
    `container` 是否为 `null`。为了防止这种情况，代码库需要撒上这些空检查，这在很大程度上阻碍了其可读性。
- en: Rust does not have the notion of null values, which is infamously quoted as
    being the billion-dollar mistake by *Tony Hoare*, who introduced `null` references
    in the ALGOL W language back in 1965\. In Rust, APIs that might fail and want
    to indicate a missing value are meant to return `Option`. This error type is suitable
    when any of our APIs, along with a succeeding value, want to signify the absence
    of a value. To put it simply, it's quite analogous to nullable values, but here,
    the `null` check is explicit and is enforced by the type system at compile time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 没有空值的概念，这被著名地引用为 *Tony Hoare* 的十亿美元错误，他在 1965 年的 ALGOL W 语言中引入了 `null`
    引用。在 Rust 中，可能失败并希望表示缺失值的 API 应返回 `Option`。这种错误类型适用于任何我们的 API，除了成功值外，还想要表示值的缺失。简单来说，它与可空值非常相似，但在这里，`null`
    检查是显式的，并且由类型系统在编译时强制执行。
- en: '`Option` has the following type signature:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option` 具有以下类型签名：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It''s an enum with two variants and is generic over `T`. We create an `Option`
    value by using either `let wrapped_i32 = Some(2);` or `let empty: Option<i32>
    = None;`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个具有两种变体的枚举，并且对 `T` 是泛型的。我们通过使用 `let wrapped_i32 = Some(2);` 或 `let empty:
    Option<i32> = None;` 来创建一个 `Option` 值。'
- en: Operations that succeed can use the `Some(T)` variable to store any value, `T`,
    or use the `None` variable to signify that the value is `null` in the case of
    a failed state. Though we are less likely to create `None` values explicitly,
    when we need to create a `None` value, we need to specify the type on the left,
    as Rust is unable to infer the type from the right-hand side. We could have also
    initialized it on the right, as `None::<i32>;` using the `turbofish` operator,
    but specifying the type on the left is identified as idiomatic Rust code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的操作可以使用`Some(T)`变量存储任何值`T`，或者使用`None`变量表示在失败状态下值是`null`。尽管我们不太可能显式地创建`None`值，但当我们需要创建一个`None`值时，我们需要在左侧指定类型，因为Rust无法从右侧推断类型。我们也可以使用`turbofish`操作符在右侧初始化它，例如`None::<i32>;`，但指定左侧的类型被认为是Rust的惯用代码。
- en: As you may have noticed, we didn't create the `Option` values through the full
    syntax, that is, `Option::Some(2)`, but directly as `Some(2)`. This is because
    both of its variants are automatically re-exported from the `std` crate (Rust's
    standard library crate) as part of the prelude module ([https://doc.rust-lang.org/std/prelude/](https://doc.rust-lang.org/std/prelude/)).
    The prelude module contains re-exports of most commonly used types, functions,
    and any modules from the standard library. These re-exports are just a convenience
    that's provided by the `std` crate. Without them, we would have to write the full
    syntax every time we needed to use these frequently used types. As a result, this
    allows us to instantiate `Option` values directly through the variants. This is
    also the case with the `Result` type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，我们没有通过完整的语法创建`Option`值，即不是`Option::Some(2)`，而是直接作为`Some(2)`。这是因为它的两个变体都被自动从`std`包（Rust的标准库包）作为预导入模块的一部分重新导出（[https://doc.rust-lang.org/std/prelude/](https://doc.rust-lang.org/std/prelude/))。预导入模块包含从标准库中重新导出的大多数常用类型、函数和任何模块。这些重新导出是`std`包提供的一个便利。没有它们，我们每次需要使用这些常用类型时都必须编写完整的语法。因此，这允许我们直接通过变体实例化`Option`值。这也适用于`Result`类型。
- en: 'So, creating them is easy, but what does it look like when you are interacting
    with an `Option` value? From the standard library, we have the `get` method on
    the `HashMap` type, which returns an `Option`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建它们很容易，但当你与`Option`值交互时，它们看起来是什么样子呢？从标准库中，我们有`HashMap`类型的`get`方法，它返回一个`Option`：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we create a new `HashMap` `map` of `&str` as the key and `i32` as the
    value, and later, we retrieve the value for the `"one"` key and assign it to the `value` .
    After compiling, we get the following error message:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的`HashMap` `map`，其键为`&str`类型，值为`i32`类型，并且稍后我们检索了`"one"`键对应的值并将其赋值给`value`。编译后，我们得到了以下错误信息：
- en: '![](img/c2e0f097-9a67-4fa3-8ce1-b971da33f80c.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2e0f097-9a67-4fa3-8ce1-b971da33f80c.png)'
- en: Why can't we add `1` to our `value`? As someone familiar with imperative languages,
    we expect `map.get()` to return an `i32` value if the key exists or a null otherwise.
    But here, `value` is an `Option<&i32>`. The `get()` method returns an `Option<&T>`,
    and not the inner value (a `&i32`) because there is also the possibility that
    we might not have the key we are looking for and so `get` can return `None` in
    that case. It gives a misleading error message, though, because Rust doesn't know
    how to add an `i32` to a `Option<&i32>`, as no such implementation of the `Add`
    trait exists for these two types. However, it indeed exists for two i32's or two
    &i32's.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么不能给我们的`value`加上`1`呢？作为一个熟悉命令式语言的开发者，我们期望`map.get()`在键存在时返回一个`i32`类型的值，否则返回`null`。但在这里，`value`是一个`Option<&i32>`。`get()`方法返回一个`Option<&T>`，而不是内部值（一个`&i32`），因为也有可能我们找不到我们想要的键，所以`get`在这种情况下可以返回`None`。然而，它给出的是一个误导性的错误信息，因为Rust不知道如何将一个`i32`加到一个`Option<&i32>`上，因为这两个类型之间不存在`Add`特质的实现。然而，对于两个`i32`或者两个`&i32`，这种实现确实存在。
- en: So, to add `1` to our `value`, we need to extract `i32` from `Option`. Here,
    we can see Rust's explicit error handling behavior spring into action. We can
    only interact with the inner `i32` value after we check whether `map.get()` is
    a `Some` variant or a `None` variant.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要给我们的`value`加上`1`，我们需要从`Option`中提取`i32`。在这里，我们可以看到Rust的显式错误处理行为开始发挥作用。我们只能在检查`map.get()`是`Some`变体还是`None`变体之后与内部的`i32`值交互。
- en: 'To check for the variants, we have two approaches; one of which is pattern
    matching or `if let`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查变体，我们有两种方法；其中一种是模式匹配或`if let`：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this approach, we match against the return value of `map.get()` and take
    actions based on the variant. In the case of `None`, we simply assign `0` to `incremented_value`.
    Another way we could have done this is by using `if let`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们匹配 `map.get()` 的返回值，并根据变体采取行动。在 `None` 的情况下，我们简单地给 `incremented_value`
    赋值为 `0`。另一种我们可以这样做的方式是使用 `if let`：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is recommended for cases where we are only interested in one variant of
    our value and want to do a common operation for other variants. In those cases,
    `if let` is much cleaner.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于我们只对值的某个变体感兴趣，并希望对其他变体执行常见操作的情况。在这种情况下，`if let` 表达式会更加简洁。
- en: '**Unwrapping:** The other, less safe, approach is to use unwrapping methods
    on `Option`, that is, the `unwrap()` and the `expect()` methods. Calling these
    methods will extract the inner value if it''s a `Some`, but will panic if it''s
    a `None`. These methods are recommended only when we are really sure that the
    `Option` value is indeed a `Some` value:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**解包：** 另一种不那么安全的方法是在 `Option` 上使用解包方法，即 `unwrap()` 和 `expect()` 方法。调用这些方法如果
    `Option` 是 `Some`，则会提取内部值；但如果它是 `None`，则会引发恐慌。这些方法只有在我们确实确定 `Option` 值确实是 `Some`
    值时才推荐使用：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running the preceding code panics, showing the following message because we
    unwrapped a `None` value as we don''t have any value for the `three` key:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会导致恐慌，显示以下消息，因为我们没有为 `three` 键提供任何值，所以解包了一个 `None` 值：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Between the two, `expect()` is preferred because it allows you to pass a string
    as a message to be printed upon panic, and shows the exact line number in your
    source file where the panic happened, whereas `unwrap()` does not allow you to
    pass debug messages as arguments and shows a line number in the standard library
    source file where the `unwrap()` method of `Option` is defined, which is not very
    helpful. These methods are also present on the `Result` type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种方法中，`expect()` 更受欢迎，因为它允许你传递一个字符串作为消息在恐慌时打印，并显示源文件中恐慌发生的确切行号，而 `unwrap()`
    不允许你将调试消息作为参数传递，并显示 `Option` 的 `unwrap()` 方法在标准库源文件中定义的行号，这并不太有帮助。这些方法也存在于 `Result`
    类型上。
- en: Next, let's look at the `Result` type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `Result` 类型。
- en: Result
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果
- en: '`Result` is similar to `Option`, but with the added advantage of storing arbitrary
    error values with more context on the error, instead of just `None`. This type
    is suitable when we want the user to know why an operation failed. Here''s the
    type signature of `Result`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 与 `Option` 类似，但增加了存储任意错误值并带有更多错误上下文的优势，而不是仅仅存储 `None`。当我们需要让用户知道操作失败的原因时，这种类型是合适的。以下是
    `Result` 的类型签名：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It has two variants, both of which are generic. `Ok(T)` is the variant we use
    for the success state putting in any value, `T`, while `Err(E)` is what we use
    in the error state putting in any error value, `E`. We can create them like so:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个变体，两者都是泛型的。`Ok(T)` 是我们在成功状态下使用的变体，可以放入任何值 `T`；而 `Err(E)` 是我们在错误状态下使用的变体，可以放入任何错误值
    `E`。我们可以这样创建它们：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, this does not compile, and we receive the following error message:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会编译，并且我们收到以下错误消息：
- en: '![](img/09947ae7-e662-4651-9d33-96684ecc8016.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09947ae7-e662-4651-9d33-96684ecc8016.png)'
- en: 'As `Result` has two generic variants and we gave the concrete type for only
    the `Ok` variant for `my_result`; it doesn''t know the concrete type of `E`. This
    is similar for the `my_err` value. We need to specify concrete types for both,
    like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Result` 有两个泛型变体，而我们只为 `my_result` 的 `Ok` 变体提供了具体的类型；它不知道 `E` 的具体类型。对于 `my_err`
    值也是类似的。我们需要为两者都指定具体的类型，如下所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the first case of creating values of the rgw `Ok` variant, we used `()` to
    specify the type, `E`, of the `Err` variant. In the second part of the snippet,
    we created values of the `Err` variant in a similar way, this time specifying
    a concrete type for the `Ok` variant. We can use underscores to ask Rust to infer
    types for us in obvious cases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `rgw Ok` 变体值的第一个例子中，我们使用 `()` 来指定 `Err` 变体的类型 `E`。在代码片段的第二部分，我们以类似的方式创建了
    `Err` 变体的值，这次指定了 `Ok` 变体的具体类型。在明显的情况下，我们可以使用下划线让 Rust 为我们推断类型。
- en: 'Next, we''ll see how we can interact with `Result` values. Many file manipulation
    APIs in the standard library return a `Result` type, because there can be different
    reasons for failure such as file not found, directory does not exists, and permission
    errors. These can be put into the `Err` variant to let the user know of the exact
    cause. For the demo, we''ll try to open a file, read its contents into a `String`,
    and print the contents, as shown in the following snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何与 `Result` 值进行交互。标准库中的许多文件操作API返回 `Result` 类型，因为可能存在不同的失败原因，如文件未找到、目录不存在和权限错误。这些可以放入
    `Err` 变体中，让用户知道确切的原因。对于演示，我们将尝试打开一个文件，将其内容读入一个 `String`，并打印内容，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is how the compiler responds:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是编译器做出的响应：
- en: '![](img/cd85fcd2-2e08-4cb5-a062-cb40bb2c7943.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd85fcd2-2e08-4cb5-a062-cb40bb2c7943.png)'
- en: 'We created a new file by calling `open` from `File`, providing our path to
    `data.txt`, which doesn''t exist. When we call `read_to_string` on `file`, and
    try to read it into `s`, we get the preceding error. Examining the error message,
    it appears that `file` has a type of `Result<File, Error>`. From its documentation,
    the `open` method is defined like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从 `File` 调用 `open` 并提供我们的路径到 `data.txt`（一个不存在的文件）来创建一个新的文件。当我们对 `file` 调用
    `read_to_string` 并尝试将其读入 `s` 时，我们得到前面的错误。检查错误信息，看起来 `file` 的类型是 `Result<File,
    Error>`。根据其文档，`open` 方法定义如下：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To astute observers, there may be a source of confusion, as it looks like `Result`
    is missing the generic `E` type for the error variant, but it''s simply hidden
    away by a type alias. If we look at the `type` alias definition in the `std::io`
    module, it is defined as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于敏锐的观察者来说，可能存在一个混淆的来源，因为它看起来 `Result` 缺少错误变体的泛型 `E` 类型，但它只是被类型别名隐藏了。如果我们查看
    `std::io` 模块中的 `type` 别名定义，它定义如下：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, it is type aliased with a common error type of `std::io::Error.` This is
    because a lot of APIs in the standard library use this as an error type. This
    is another benefit of type aliases, where we can extract common parts from our
    type signature. Putting that tip aside, to be able to call the `read_to_string`
    method on our `file`, we need to extract the inner `File` instance, that is, perform
    pattern matching on variants. By doing this, the preceding code changes, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它被与一个常见的错误类型 `std::io::Error.` 进行了类型别名。这是因为标准库中的许多API都使用这个作为错误类型。这是类型别名的一个好处，我们可以从我们的类型签名中提取出公共部分。把那个技巧放在一边，为了能够在我们的
    `file` 上调用 `read_to_string` 方法，我们需要提取内部的 `File` 实例，即对变体进行模式匹配。通过这样做，前面的代码会发生变化，如下所示：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we made two changes. First, we made the `file` variable mutable. Why?
    Because the function signature of `read_to_string` is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做了两个更改。首先，我们使 `file` 变量可变。为什么？因为 `read_to_string` 函数的签名如下：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first parameter being `&mut self` means that the instance we are calling
    this method on needs to be mutable because reading the file changes, internal
    pointers of the file handle. Secondly, we handled both the variants, where, in
    the `Ok` case, we return the actual `File` object if everything was good, but
    crash when we get an `Err` value and display an error message.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是 `&mut self`，这意味着我们调用此方法的实例需要是可变的，因为读取文件会改变文件句柄的内部指针。其次，我们处理了两种变体，在 `Ok`
    情况下，如果一切顺利，我们返回实际的 `File` 对象，但在得到 `Err` 值时崩溃并显示错误信息。
- en: 'With this change, let''s compile and run this program:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，让我们编译并运行这个程序：
- en: '![](img/862acb83-a83c-4579-929a-5e0a3d752c2e.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/862acb83-a83c-4579-929a-5e0a3d752c2e.png)'
- en: This panics because we don't have a file named `data.txt` in our directory.
    Try creating a file with the same name with any arbitrary text in it and run this
    program again to see it succeed. First, though, let's do something about that
    warning. Warnings are always a sign of poor code quality, and we ideally want
    to have none of them. The warning is there because `File::read_to_string` (a method
    from the `Read` trait) returns a value of type `Result<usize>`. Rust warns you
    whenever a return value from a function call is ignored. Here, the `usize` value
    in `Result<usize>` tells us how many bytes were read into the string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致恐慌，因为我们目录中没有名为 `data.txt` 的文件。尝试创建一个具有相同名称的文件，并在其中放入任意文本，然后再次运行此程序以查看它成功。不过，首先，让我们处理那个警告。警告总是代码质量差的标志，我们理想情况下希望没有警告。警告存在是因为
    `File::read_to_string`（来自 `Read` 特质的函数）返回一个 `Result<usize>` 类型的值。Rust 会在函数调用的返回值被忽略时警告你。在这里，`Result<usize>`
    中的 `usize` 值告诉我们有多少字节被读入字符串。
- en: 'We have two ways of handling this warning:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种处理这个警告的方法：
- en: Handle both the `Ok` and `Err` cases as before for the `Result` value returned
    by the `read_to_string` method
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `read_to_string` 方法返回的 `Result` 值，像以前一样处理 `Ok` 和 `Err` 两种情况。
- en: Assign the return value to a special variable `_` (**underscore**), which lets
    the compiler know that we want to ignore the value
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将返回值赋给一个特殊变量 `_`（**下划线**），这样编译器就知道我们想要忽略这个值。
- en: 'For cases where we don''t care about the value, we can use the second approach
    and so the `read_to_string` line changes as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们不在乎值的情况，我们可以使用第二种方法，因此 `read_to_string` 行的更改如下：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With that change, the code compiles without warnings. However, you should handle
    the return value and try not to use the catch all underscore variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这次修改，代码编译时没有警告。然而，你应该处理返回值，并尽量不使用通配符下划线变量。
- en: Combinators on Option/Result
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Option/Result 上的组合子
- en: As `Option` and `Result` are wrapper types, the only way to safely interact
    with their inner values is either through pattern matching or `if let`. This paradigm
    of using matching and then acting on the inner values is a very common operation
    and, as such, it becomes very tedious having to write them every time. Fortunately,
    these wrapper types come with lots of helper methods, also known as combinators,
    implemented on them that allow you to manipulate the inner values easily.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Option` 和 `Result` 是包装类型，唯一安全地与其内部值交互的方式是通过模式匹配或 `if let`。这种使用匹配然后对内部值进行操作的范式是一个非常常见的操作，因此每次都必须编写它们变得非常繁琐。幸运的是，这些包装类型自带了许多辅助方法，也称为组合子，允许你轻松地操作内部值。
- en: These are generic methods and there are many kinds depending on the use case.
    Some methods act on success values, such as `Ok(T)`/`Some(T)`, while some of them
    act on failed values, such as `Err(E)`/`None`. Some methods unwrap and extract
    the inner value, while some preserve the structure of the wrapper type modifying
    just the inner values.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是泛型方法，根据使用情况有很多种。一些方法作用于成功值，例如 `Ok(T)`/`Some(T)`，而另一些方法作用于失败值，例如 `Err(E)`/`None`。一些方法会展开并提取内部值，而另一些方法则只修改内部值，保留包装类型的结构。
- en: '**Note**: In this section, when we talk about success values, we are commonly
    referring to `Ok(T)`/`Some(T)` variants and when we talk about failed values,
    we are referring to `Err(T)`/`None` variants.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在本节中，当我们谈论成功值时，通常指的是 `Ok(T)`/`Some(T)` 变体，当我们谈论失败值时，通常指的是 `Err(T)`/`None`
    变体。'
- en: Common combinators
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见组合子
- en: 'Let''s look at some of the useful combinators that are available for both the `Option`
    and `Result` types:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Option` 和 `Result` 类型都可用的一些有用的组合子：
- en: '`map`: This method allows you to transform the success value, `T`, to another
    value, `U`. The following is the type signature of `map` for the `Option` type:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`：此方法允许你将成功值 `T` 转换为另一个值 `U`。以下是对 `Option` 类型的 `map` 方法的类型签名：'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the signature for the `Result` type:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `Result` 类型的签名：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method's type signature can be read as follows: `map` is a generic method
    over `U` and `F`, and takes `self` by value. It then takes a parameter, `f`, of
    type `F` and returns an `Option<U>`, where `F` is constrained by the `FnOnce`
    trait, which has an input parameter, `T`, and a return type of `U`. Phew! That
    was quite a mouthful.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的类型签名可以读作如下：`map` 是一个在 `U` 和 `F` 上的泛型方法，并且按值接收 `self`。然后它接收一个参数 `f`，其类型为
    `F`，并返回一个 `Option<U>`，其中 `F` 被限制在 `FnOnce` 特性中，该特性有一个输入参数 `T` 和一个返回类型 `U`。哇！这真是一大堆话。
- en: Let's make this simpler to understand. There are two parts to understand about
    the `map` method. First, it takes a parameter as `self`, which means the value
    on which this method is called is consumed after the call. Second, it takes in
    a parameter, `f`, of type `F`. This is a closure that's provided to `map`, which
    tells it how to do the conversion from `T` to `U`. The closure is generically
    represented as `F` and the `where` clause says that `F` is `FnOnce(T) -> U`. This
    is a special type of trait that is only applicable to closures and hence has a
    function like the signature of `(T) -> U` . The `FnOnce` prefix just means that
    this closure takes ownership of the input parameter, `T`, signifying that we can
    only call this closure once with `T` as `T` will be consumed upon invocation.
    We'll look into closures in more depth in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts.* The `map` method does nothing if the value is a failed value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Using combinators
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `map` method is simple:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, we have a method called `get_nth` that gives us the
    `nth` element from `Vec<usize>` and returns `None` if it couldn''t find one. We
    then have a use case where we want to double the value. We can use the `map` method
    on the return value of `get_nth`, passing in the `double` function we defined
    previously. Alternatively, we could have provided a closure written inline, like
    the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is quite a concise way to chain operations! This is less verbose than using
    `match` or `if let`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding explanation of the `map` method is very much applicable to the
    next set of methods that we''ll look at, so we''ll skip explaining their type
    signature as it would be too noisy for us to go through every one of them. Instead,
    we''ll just explain briefly the functionality that''s provided by these methods.
    You are encouraged to read and become familiar with their type signature by referring
    to their documentation:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '`map_err`: This method acts only on `Result` types and allows transforming
    the failed value from `E` to some other type, `H`, but only if the value is an
    `Err` value. `map_err` is not defined for `Option` types, as doing anything with
    `None` would be pointless.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`and_then`: In the case of a failed value, this returns the value as is, but
    in the case of a successful value, this takes in a closure as the second argument,
    which acts on the wrapped value and returns the wrapped type. This is useful when
    you need to perform transformations on the inner values, one after another.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unwrap_or`: This method extracts the inner success value, or returns a default
    one if it''s a failed value. You provide the default value to it as a second argument.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unwrap_or_else`: This method acts the same as the preceding method but computes
    a different value when it is a failed value by taking a closure as the second
    argument.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as_ref`: This method converts the inner value to a reference and returns the
    wrapped value, that is, an `Option<&T>` or a `Result<&T, &E>`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or/ or_else`: These methods return the value as is if it''s a success value,
    or returns an alternative `Ok`/`Some` value, which is provided as the second argument.
    `or_else` accepts a closure within which you need to return a success value.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as_mut`: This method converts the inner value into a mutable reference and
    returns the wrapped value, that is, an `Option<&mut T>` or a `Result<&mut T, &mut
    E>`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more that are unique to the `Option` and `Result` types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Converting between Option and Result
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We also have methods where one wrapper type can be converted into another,
    depending on how you want to compose those values with your APIs. They become
    really handy in situations where we are interacting with third-party crates, where
    we have a value as an `Option`, but the crate''s method we are using accepts a
    `Result` as a type, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '`ok_or`: This method converts an `Option` value to a `Result` value, by taking
    in an error value as a second parameter. A similar variant to this is the `ok_or_else`
    method, which should be preferred over this, as it computes the value lazily by
    taking in a closure.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ok`: This method converts a `Result` into an `Option` consuming `self`, and
    discards the `Err` value.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Early returns and the ? operator
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another pattern that is quite common when we interact with `Result`
    types. The pattern goes as follows: when we have a success value, we immediately
    want to extract it, but when we have an error value, we want to make an early
    return and propagate the error to the caller. To illustrate this pattern, we will
    use the following snippet, which uses the usual match expression to act on the
    `Result` type:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `?` operator abstracts this pattern, making it possible to write the `bytes_to_str`
    method in a more concise way:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This operator becomes even nicer if you have a sequence of `Result`/`Option`
    returning method calls, where a failure in each operator should mean a failure
    of the whole. For instance, we could write the whole operation of creating a file
    and writing to it as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It works pretty much as a replacement for the `try!` macro, which does the same
    thing as before `?` was implemented in the compiler. Now, `?` is a replacement
    for that, but there are some plans to make it more generic and usable for other
    cases, too.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**Bonus tip**: The `main` function also allows you to return `Result` types.
    Specifically, it allows you to return types that implement the `Termination` trait.
    This means that we can also write `main` as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, let's move on to dealing with non-recoverable errors.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Non-recoverable errors
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When code that's in the execution phase encounters a bug, or one of its variants
    is violated, it has the potential to corrupt the program state in unexpected ways
    if it's ignored. These situations are deemed non-recoverable because of their
    inconsistent program state, which may lead to faulty outputs or unexpected behavior
    later. This means that a fail-stop approach is the best way to recover from them
    so as to not harm other parts or systems indirectly. For these kinds of cases,
    Rust provides us with a mechanism called **panic**, which aborts the thread on
    which it is invoked and does not affect any other threads. If the main thread
    is the one facing the panic, then the program aborts with a non-zero exit code
    of `101`. If it's a child thread, the panic does not propagate to the parent thread
    and halts at the thread boundary. A panic in one thread does not affect the other
    threads and is isolated, except in cases where they corrupt a mutex lock on some
    shared data; it is implemented as a macro by the same `panic!` mechanism.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: When `panic!` is called, the panicking thread starts unwinding the function
    call stack, starting from the place at which it was invoked, all the way until
    the entry point in the thread. It also generates a stack trace or a backtrace
    for all functions that are invoked in this process, just like exceptions. But
    in this case, it does not have to look for any exception handlers, as they don't
    exist in Rust. Unwinding is the process of moving up the function call chain while
    cleaning up or freeing resource, from each function call stack. These resources
    can be stack allocated or heap allocated. Stack allocated resources automatically
    get released once the function ends. For variables pointing to heap allocated
    resources, Rust calls the `drop` method on them, which frees up the memory used
    by the resource. This cleanup is necessary to avoid memory leaks. Apart from code
    calling `panic` explicitly, `Result`/`Option` error types also call `panic` if
    any code does unwrap on failed values, that is, `Err`/`None`. `panic` is also
    the choice that's used for failing assertions in unit tests, and it's encouraged
    to fail tests with panics by using the `#[should_panic]` attribute.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In the case of single-threaded code having panics on the main thread, unwinding
    doesn't provide much of a benefit, as the operating system reclaims all the memory
    after the process aborts. Fortunately, there are options to turn off unwinding
    in `panic`, which may be required on platforms such as embedded systems, where
    we have a single main thread doing all the work and where unwinding is an expensive
    operation that isn't of much use.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'To figure out the sequence of calls that led to the panic, we can view the
    backtrace from the thread by running any panicking program and setting the `RUST_BACKTRACE=1`
    environment variable from our command-line shell. Here''s an example where we
    have two threads, where both of them panic:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`alice` spawns a new thread using `thread::spawn` and calls `bob` within the
    closure. `bob` calls `malice`, which in turn panics. `main` also calls `bob`,
    which panics.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the output of running this program:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5de47cc-5038-42f9-be7a-3893269e6dbb.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: We join the thread by calling `join()` and expect everything to go fine in our
    child thread, which is definitely not the case. We get two backtraces, one for
    the panic that happened in the child thread and the other from calling `bob` in
    the main thread.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: If you need more control over how unwinding in panics is handled in a thread,
    you can use the `std::panic::catch_unwind` function. Even though it's recommended
    to handle errors via the `Option`/`Result` mechanism, you can use this method
    to handle fatal errors in worker threads; you can do this by restoring any violated
    invariants, letting the workers die, and restarting them. However, `catch_unwind`
    doesn't prevent the panic – it only allows you to customize the unwind behavior
    associated with panic. `panic` with `catch_unwind` is not recommended as a general
    error handling method for Rust programs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The `catch_unwind` function takes a closure and handles any panics that happen
    inside it. Here''s its type signature:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the return value of `catch_unwind` has an additional constraint,
    `UnwindSafe`. This means that the variables in the closure must be exception-safe,
    which most types are, but notable exceptions are mutable references (`&mut T`).
    A value is exception safe if exception-throwing code cannot lead to the value
    being left in an inconsistent state. This means that the code inside the closure
    must not `panic!()` itself.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple example that uses `catch_unwind`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here''s the output after running the preceding program:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0479182e-a4a9-4297-b1d2-18df52426b4a.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: As you can see, `catch_unwind` does not prevent the panic from happening; it
    just stops the unwinding associated with the panicking thread. Note again that
    `catch_unwind` is not the recommended method for error management in Rust. It
    is not guaranteed to catch all panics, such as panics that abort the program.
    Catching panic unwinding is necessary in situations where Rust code is communicating
    with other languages such as C, where unwinding to C code is an undefined behavior.
    In those cases, the programmer has to handle the unwind and do what C expects
    by returning an error code. The program can then resume the unwind by using the
    `resume_unwind` function from the same `panic` module.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'For rare cases where the default unwinding behavior of panic can get too expensive,
    such as when writing programs for microcontrollers, there''s a compiler flag that
    can be configured to turn all panics into aborts. To do that, your project''s
    `Cargo.toml` needs to have the following attribute under the `profile.release` section:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: User-friendly panics
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the preceding code, panic messages and backtraces can be very
    cryptic, but it does not have to be like that. If you are an author of a command-line
    tool, `human_panic` is a crate from the community that replaces verbose, cryptic
    panic messages with human-readable messages. It also writes the backtrace to a
    file to allow it to be reported to the tool author by users. More information
    about `human_panic` can be found on the project repository page: [https://github.com/rust-clique/human-panic](https://github.com/rust-clique/human-panic).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Custom errors and the Error trait
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A non-trivial project that has varied functionality is often spread across modules.
    With an organization, it's more informative to provide module-specific error messages
    and information for the user. Rust allows us to create custom error types that
    can help us achieve more granular error reports from our application. Without
    custom errors that are specific to our project, we might have to use existing
    error types in the standard library, which may not be relevant to our API's operations
    and will not give precise information to users if things go wrong with an operation
    in our module.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'In languages that have exceptions, such as Java, the way you create custom
    exceptions is by inheriting from the base `Exception` class and overriding its
    methods and member variables. While Rust doesn''t have type-level inheritance,
    it has trait inheritance and provides us with the `Error` trait that any type
    can implement, making the type a custom error type. This type can now be composed
    with existing standard library error types when using a trait object such as `Box<dyn
    Error>` as the return type of functions returning `Result` for the `Err` variant.
    Here''s the type signature of the `Error` trait:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To create our own error type, the type must implement the `Error` trait. If
    we look at the trait''s definition, it also requires that we implement the `Debug`
    and `Display` traits for our type. The `description` method returns a string slice
    reference, which is a human-readable form describing what the error is about.
    The `cause` method returns an optional reference to another `Error` trait object,
    representing a possible lower-level reason for the error. The cause method from
    custom error types allows you to get information on the chain of errors right
    from the source, making precise logging of the error possible. For instance, let''s
    take an HTTP query as an example of a fallible operation. Our hypothetical library
    has a `get` method that can perform `GET` requests. The query might fail due to
    a lot of different reasons:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The DNS query might fail because of networking failures or because of an incorrect
    address
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual transfer of packets might fail
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data might be received correctly, but there could be something wrong with
    the received HTTP headers, and so on and so forth
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If it were the first case, we might imagine three levels of errors, chained
    together by the `cause` fields:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The UDP connection failing due to the network being down (`cause = None`)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DNS lookup failing due to a UDP connection failure (`cause = UDPError`)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GET` query failing due to a DNS lookup failure (`cause = DNSError`)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cause` method comes in handy when the developer wants to know the root
    cause of a failure.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to demonstrate integrating a custom error type in to a project, we have
    created a crate called `todolist_parser` using cargo, which exposes an API to
    parse a list of todos from a text file. The parsing of todos can fail in different
    ways, such as file not found, an empty todo, or because it contains non-text characters.
    We''ll use a custom error type to model these situations. Under `src/error.rs`,
    we have defined the following error types:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As of now, we are modelling two errors, which are very basic:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Failing to read the list of todos modeled as `ReadErr`
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing to parse the todos modeled as `ParseErr`, which has two variants, where
    it can fail either due to the file being `Empty` or the file containing non-text/binary
    symbols, which means that it's `Malformed`
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following that, we implement the `Error` trait and the required super traits,
    `Display` and `Debug`. `lib.rs` contains the required parsing methods, as well
    as the declaration of the `TodoList` struct, as shown in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have two top-level functions, `read_todos` and `parse_todos`, which are invoked
    by the `get_todos` method of `TodoList`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'We have an example usage of `TodoList` under `examples/basics.rs`, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we run our `basics.rs` example via the `cargo run --example basics` command,
    we get the following output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4067e12-740d-405f-a483-678cf1708524.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: If you look at the error value being printed, it wraps the actual cause of error
    within the `ReadErr` value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Rust has decent built-ins for defining custom error types. If you're writing
    your own crates, you should define your own error types to make debugging easier.
    However, implementing the `Error` trait for all of your types can often become
    redundant and time-consuming. Fortunately, we have a crate from the Rust community
    called **failure** ([https://github.com/rust-lang-nursery/failure](https://github.com/rust-lang-nursery/failure)),
    which automates the creation of custom error types, along with the necessary implementation
    of traits that are auto-derived through the use of procedural macros. If you are
    feeling more ambitious, you are encouraged to refactor this library to use the
    `failure` crate.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned that,  error handling in Rust is explicit:
    operations that can fail have a two-part return value via the `Result` or `Option`
    generic types. You must handle errors in some way, either by unpacking the `Result`/`Option`
    values with a `match` statement, or by using combinator methods. Unwrapping should
    be avoided on error types. Instead, use combinators or match expressions to take
    appropriate action or propagate the error to the caller by using the `?` operator. It
    is okay to panic when programming errors are so fatal that recovery would be impossible.
    Panics are mostly non-recoverable, which means that they crash your thread. Their
    default behavior is unwinding, which can be expensive and can be turned off if
    programs don''t want this overhead. It is advised to be as descriptive as possible
    when communicating errors, and authors are encouraged to use custom error types
    in their crates.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到，Rust 中的错误处理是显式的：可能失败的运算通过 `Result` 或 `Option` 泛型类型返回两个部分的结果。你必须以某种方式处理错误，要么通过使用
    `match` 语句解包 `Result`/`Option` 值，要么使用组合方法。应避免在错误类型上解包。相反，使用组合器或 `match` 表达式采取适当的行动，或者通过使用
    `?` 操作符将错误传播给调用者。当编程错误如此致命以至于恢复成为不可能时，进行恐慌是可以接受的。恐慌大多是不可恢复的，这意味着它们会崩溃你的线程。它们的默认行为是回溯，这可能很昂贵，如果程序不想有这种开销，可以将其关闭。建议在传达错误时尽可能详细，并鼓励作者在他们的
    crate 中使用自定义错误类型。
- en: In the next chapter, we'll cover some of the advanced aspects of the language
    and explore more of the guts of the type system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍语言的一些高级特性，并探索类型系统的更多内部机制。
