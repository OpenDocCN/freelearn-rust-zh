["```rs\n# curl https://sh.rustup.rs -sSf | sh\n# source $HOME/.cargo/env\n# rustup install nightly beta\n```", "```rs\n$ echo \"export PATH=$HOME/.cargo/bin:$PATH\" >> ~/.bashrc\n```", "```rs\n# rustup doc\n```", "```rs\n# cargo new --bin hello-rust\n```", "```rs\n# tree hello-rust/\nhello-rust/\n├── Cargo.toml\n└── src\n    └── main.rs\n\n1 directory, 2 files\n```", "```rs\n# cargo run\n```", "```rs\n# tree hello-rust/\nhello-rust/\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── main.rs\n└── target\n    └── debug\n        ├── build\n        ├── deps\n        │   └── hello_rust-392ba379262c5523\n        ├── examples\n        ├── hello-rust\n        ├── hello-rust.d\n        ├── incremental\n        └── native\n\n8 directories, 6 files\ncrates.io:\n```", "```rs\n# cargo search term\n    Updating registry `https://github.com/rust-lang/crates.io-index`\nterm = \"0.4.6\" # A terminal formatting library\nansi_term = \"0.9.0\" # Library for ANSI terminal colours and styles (bold, underline)\nterm-painter = \"0.2.4\" # Coloring and formatting terminal output\nterm_size = \"0.3.0\" # functions for determining terminal sizes and dimensions\nrust_erl_ext = \"0.2.1\" # Erlang external term format codec.\nslog-term = \"2.2.0\" # Unix terminal drain and formatter for slog-rs\ncolored = \"1.5.2\" # The most simple way to add colors in your terminal\nterm_grid = \"0.1.6\" # Library for formatting strings into a grid layout\nrust-tfidf = \"1.0.4\" # Library to calculate TF-IDF (Term Frequency - Inverse Document Frequency) for generic documents\naterm = \"0.20.0\" # Implementation of the Annotated Terms data structure\n... and 1147 crates more (use --limit N to see more)\nhello and world in green and red, respectively:\n```", "```rs\n[package]\nname = \"hello-rust\"\nversion = \"0.1.0\"\nauthors = [\"Foo Bar <foo.bar@foobar.com>\"]\n\n[dependencies]\nterm = \"0.4.6\"\nhello world! on the screen. Further, it prints hello in green and world! in red:\n```", "```rs\n// chapter2/hello-rust/src/main.rs\n\nextern crate term;\n\nfn main() {\n    let mut t = term::stdout().unwrap();\n    t.fg(term::color::GREEN).unwrap();\n    write!(t, \"hello, \").unwrap();\n\n    t.fg(term::color::RED).unwrap();\n    writeln!(t, \"world!\").unwrap();\n\n    t.reset().unwrap();\n}\n```", "```rs\n$ cargo run\n    Updating registry `https://github.com/rust-lang/crates.io-index`\n   Compiling term v0.4.6\n   Compiling hello-rust v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/chapter2/hello-rust)\n    Finished dev [unoptimized + debuginfo] target(s) in 3.20 secs\n     Running `target/debug/hello-rust`\nhello, world!\n```", "```rs\n// chapter2/ownership-heap.rs\n\nfn main() {\n    let s = String::from(\"Test\");\n    heap_example(s);\n}\n\nfn heap_example(input: String) {\n    let mystr = input;\n    let _otherstr = mystr;\n    println!(\"{}\", mystr);\n}\n```", "```rs\n# rustc ownership-heap.rs\nerror[E0382]: use of moved value: `mystr`\n --> ownership-heap.rs:9:20\n  |\n8 | let _otherstr = mystr;\n  | --------- value moved here\n9 | println!(\"{}\", mystr);\n  | ^^^^^ value used here after move\n  |\n  = note: move occurs because `mystr` has type `std::string::String`, which does not implement the `Copy` trait\n\nerror: aborting due to previous error\n```", "```rs\n// chapter2/ownership-heap-fixed.rs\n\nfn main() {\n    let s = String::from(\"Test\");\n    heap_example(s);\n}\n\nfn heap_example(input: String) {\n    let mystr = input;\n    let _otherstr = mystr.clone();\n    println!(\"{}\", mystr);\n}\n```", "```rs\n$ rustc ownership-heap-fixed.rs && ./ownership-heap-fixed\nTest\n```", "```rs\n// chapter2/ownership-stack.rs\n\nfn main() {\n    let i = 42;\n    stack_example(i);\n}\n\nfn stack_example(input: i32) {\n    let x = input;\n    let _y = x;\n    println!(\"{}\", x);\n}\n```", "```rs\n# rustc ownership-stack.rs && ./ownership-stack\n42\n```", "```rs\n// chapter2/ownership-borrow.rs\n\nfn main() {\n    let s = String::from(\"Test\");\n    heap_example(&s);\n}\n\nfn heap_example(input: &String) {\n    let mystr = input;\n    let _otherstr = mystr;\n    println!(\"{}\", mystr);\n}\n```", "```rs\n// chapter2/ownership-mut-borrow.rs\n\nfn main() {\n    let mut s = String::from(\"Test\");\n    heap_example(&mut s);\n}\n\nfn heap_example(input: &mut String) {\n    let mystr = input;\n    let _otherstr = mystr;\n    println!(\"{}\", mystr);\n}\n```", "```rs\n// chapter2/lifetime.rs\n\nfn main() {\n    let v1 = vec![1, 2, 3, 4, 5];\n    let v2 = vec![1, 2];\n\n    println!(\"{:?}\", longer_vector(&v1, &v2));\n}\n\nfn longer_vector(x: &[i32], y: &[i32]) -> &[i32] {\n    if x.len() > y.len() { x } else { y }\n}\n```", "```rs\n# rustc lifetime.rs\nerror[E0106]: missing lifetime specifier\n --> lifetime.rs:8:43\n  |\n8 | fn longer_vector(x: &[i32], y: &[i32]) -> &[i32] {\n  | ^ expected lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\n\nerror: aborting due to previous error\n```", "```rs\nfn longer_vector<'a>(x: &'a[i32], y: &'a[i32]) -> &'a[i32] {\n    if x.len() > y.len() { x } else { y }\n}\n```", "```rs\n// chapter2/generic-function.rs\n\nstruct Tuple<T> {\n    first: T,\n    second: T,\n}\n\nfn main() {\n    let tuple_u32: Tuple<u32> = Tuple {first: 4u32, second: 2u32 };\n    let tuple_u64: Tuple<u64> = Tuple {first: 5u64, second: 6u64 };\n    println!(\"{}\", sum(tuple_u32));\n    println!(\"{}\", sum(tuple_u64));\n\n    let tuple: Tuple<String> = Tuple {first: \"One\".to_owned(), second: \"Two\".to_owned() };\n    println!(\"{}\", sum(tuple));\n}\n\nfn sum<T>(tuple: Tuple<T>) -> T\n{\n    tuple.first + tuple.second\n}\n```", "```rs\n$ rustc generic-function.rs\nerror[E0369]: binary operation `+` cannot be applied to type `T`\n  --> generic-function-error.rs:18:5\n   |\n18 | tuple.first + tuple.second\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `T` might need a bound for `std::ops::Add`\n\nerror: aborting due to previous error\n```", "```rs\n// chapter2/generic-function-fixed.rs\n\nuse std::ops::Add;\n\nstruct Tuple<T> {\n    first: T,\n    second: T,\n}\n\nfn main() {\n    let tuple_u32: Tuple<u32> = Tuple {first: 4u32, second: 2u32 };\n    let tuple_u64: Tuple<u64> = Tuple {first: 5u64, second: 6u64 };\n    println!(\"{}\", sum(tuple_u32));\n    println!(\"{}\", sum(tuple_u64));\n\n    // These lines fail to compile\n    let tuple: Tuple<String> = Tuple {first: \"One\".to_owned(), second: \"Two\".to_owned() };\n    println!(\"{}\", sum(tuple));\n}\n\n// We constrain the possible types of T to those which implement the Add trait\nfn sum<T: Add<Output = T>>(tuple: Tuple<T>) -> T\n{\n    tuple.first + tuple.second\n}\n```", "```rs\n// chapter2/traits.rs\n\ntrait Max<T> {\n    fn max(&self) -> T;\n}\n\nstruct ThreeTuple<T> {\n    first: T,\n    second: T,\n    third: T,\n}\n\n// PartialOrd enables comparing\nimpl<T: PartialOrd + Copy> Max<T> for ThreeTuple<T> {\n    fn max(&self) -> T {\n        if self.first >= self.second && self.first >= self.third {\n            self.first\n        }\n        else if self.second >= self.first && self.second >= self.third {\n            self.second\n        }\n        else {\n            self.third\n        }\n    }\n}\n\nstruct TwoTuple<T> {\n    first: T,\n    second: T,\n}\n\nimpl<T: PartialOrd + Copy> Max<T> for TwoTuple<T> {\n    fn max(&self) -> T {\n        if self.first >= self.second {\n            self.first\n        } else { self.second }\n    }\n}\n\nfn main() {\n    let two_tuple: TwoTuple<u32> = TwoTuple {first: 4u32, second: 2u32 };\n    let three_tuple: ThreeTuple<u64> = ThreeTuple {first: 6u64,\n                                       second: 5u64, third: 10u64 };\n\n    println!(\"{}\", two_tuple.max());\n    println!(\"{}\", three_tuple.max());\n}\n```", "```rs\n// chapter2/extending-types.rs\n\n// Trait for our behavior\ntrait Sawtooth {\n    fn sawtooth(&self) -> Self;\n}\n\n// Extending the builtin f64 type\nimpl Sawtooth for f64 {\n    fn sawtooth(&self) -> f64 {\n        self - self.floor()\n    }\n}\n\nfn main() {\n    println!(\"{}\", 2.34f64.sawtooth());\n}\n```", "```rs\n// chapter2/derive.rs\n\nuse std::fmt;\nuse std::fmt::Display;\n\n#[derive(Debug, Hash)]\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> fmt::Display for Point<T> where T: Display {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\n\nfn main() {\n    let p: Point<u32> = Point { x: 4u32, y: 2u32 };\n\n    // uses Display\n    println!(\"{}\", p);\n\n    // uses Debug\n    println!(\"{:?}\", p);\n}\n```", "```rs\n# rustc derive.rs && ./derive\n(4, 2)\nPoint { x: 4, y: 2 }\n```", "```rs\nenum Result<T, E> {\n    Ok(T),     \n    Err(E), \n}\n```", "```rs\n// chapter2/custom-errors.rs\n\nuse std::fmt;\nuse std::error::Error;\n\n#[derive(Debug)]\nenum OperationsError {\n    DivideByZeroError,\n}\n\n// Useful for displaying the error nicely\nimpl fmt::Display for OperationsError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n        OperationsError::DivideByZeroError => f.write_str(\"Cannot divide by zero\"),\n        }\n    }\n}\n\n// Registers the custom error as an error\nimpl Error for OperationsError {\n    fn description(&self) -> &str {\n        match *self {\n            OperationsError::DivideByZeroError => \"Cannot divide by zero\",\n        }\n    }\n}\n\n// Divides the dividend by the divisor and returns the result. Returns\n// an error if the divisor is zero\nfn divide(dividend: u32, divisor: u32) -> Result<u32, OperationsError> {\n    if divisor == 0u32 {\n        Err(OperationsError::DivideByZeroError)\n    } else {\n        Ok(dividend / divisor)\n    }\n}\n\nfn main() {\n    let result1 = divide(100, 0);\n    println!(\"{:?}\", result1);\n\n    let result2 = divide(100, 2);\n    println!(\"{:?}\", result2.unwrap());\n}\n```", "```rs\n$ rustc custom-errors.rs && ./custom-errors\nErr(DivideByZeroError)\n50\nNone variant. The Some variant handles the case where it holds the actual value of the type T:\n```", "```rs\npub enum Option<T> {\n    None,\n    Some(T),\n}\n```", "```rs\n// chapter2/options.rs\n\nfn divide(dividend: u32, divisor: u32) -> Option<u32> {\n    if divisor == 0u32 {\n        None\n    } else {\n        Some(dividend / divisor)\n    }\n}\n\nfn main() {\n    let result1 = divide(100, 0);\n\n    match result1 {\n        None => println!(\"Error occurred\"),\n        Some(result) => println!(\"The result is {}\", result),\n    }\n\n    let result2 = divide(100, 2);\n    println!(\"{:?}\", result2.unwrap());\n}\n```", "```rs\n// chapter2/panic.rs\n\nfn parse_int(s: String) -> u64 {\n    return s.parse::<u64>().expect(\"Could not parse as integer\")\n}\n\nfn main() {\n    // works fine\n    let _ = parse_int(\"1\".to_owned());\n\n    // panics\n    let _ = parse_int(\"abcd\".to_owned());\n}\n```", "```rs\n# ./panic\nthread 'main' panicked at 'Could not parse as integer: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:906:4\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n```", "```rs\n// chapter2/syntactic-macro.rs\n\nmacro_rules! factorial {\n    ($x:expr) => {\n        {\n            let mut result = 1;\n            for i in 1..($x+1) {\n                result = result * i;\n            }\n            result\n        }\n    };\n}\n\nfn main() {\n    let arg = std::env::args().nth(1).expect(\"Please provide only one argument\");\n    println!(\"{:?}\", factorial!(arg.parse::<u64>().expect(\"Could not parse to an integer\")));\n}\n```", "```rs\n# rustc syntactic-macro.rs && ./syntactic-macro 5\n120\n```", "```rs\n#![feature(trace_macros)]\ntrace_macros!(true);\n```", "```rs\n// chapter2/closure-borrow.rs\n\nfn main() {\n    // closure with two parameters\n    let add = |a, b| a + b;\n    assert_eq!(add(2, 3), 5);\n\n    // common use cases are on iterators\n    println!(\"{:?}\", (1..10).filter(|x| x % 2 == 0).collect::<Vec<u32>>());\n\n    // using a variable from enclosing scope\n    let times = 2;\n    println!(\"{:?}\", (1..10).map(|x| x * times).collect::<Vec<i32>>());\n}\n```", "```rs\n// chapter2/closure-move.rs\n\nfn main() {\n    let mut times = 2;\n    {\n        // This is in a new scope\n        let mut borrow = |x| times += x;\n        borrow(5);\n    }\n    assert_eq!(times, 7);\n\n    let mut own = move |x| times += x;\n    own(5);\n    assert_eq!(times, 7);\n\n}\n```", "```rs\n// chapter2/range.rs\n\n#![feature(inclusive_range_syntax)]\n\nfn main() {\n    let numbers = 1..5;\n    for number in numbers {\n        println!(\"{}\", number);\n    }\n    println!(\"------------------\");\n    let inclusive = 1..=5;\n    for number in inclusive {\n        println!(\"{}\", number);\n    }\n}\n```", "```rs\n// chapter2/collatz.rs\n\n// This struct holds state while iterating\nstruct Collatz {\n    current: u64,\n    end: u64,\n}\n\n// Iterator implementation\nimpl Iterator for Collatz {\n    type Item = u64;\n\n    fn next(&mut self) -> Option<u64> {\n        if self.current % 2 == 0 {\n            self.current = self.current / 2;\n        } else {\n            self.current = 3 * self.current + 1;\n        }\n\n        if self.current == self.end {\n            None\n        } else {\n            Some(self.current)\n        }\n    }\n}\n\n// Utility function to start iteration\nfn collatz(start: u64) -> Collatz {\n    Collatz { current: start, end: 1u64 }\n}\n\nfn main() {\n    let input = 10;\n\n    // First 2 items\n    for n in collatz(input).take(2) {\n        println!(\"{}\", n);\n    }\n\n    // Dropping first 2 items\n    for n in collatz(input).skip(2) {\n        println!(\"{}\", n);\n    }\n}\n```", "```rs\n$ rustc collatz.rs && ./collatz\n5\n16\n8\n4\n2\n```", "```rs\n// chapter2/threads.rs\n\nuse std::thread;\n\nfn main() {\n    for i in 1..10 {\n        let handle = thread::spawn(move || {\n            println!(\"Hello from thread number {}\", i);\n        });\n        let _ = handle.join();\n    }\n}\n```", "```rs\n# rustc threads.rs && ./threads\nHello from thread number 1\nHello from thread number 2\nHello from thread number 3\nHello from thread number 4\nHello from thread number 5\nHello from thread number 6\nHello from thread number 7\nHello from thread number 8\nHello from thread number 9\n```", "```rs\n// chapter2/channels.rs\n\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let rhs = vec![10, 20, 30, 40, 50, 60, 70];\n    let lhs = vec![1, 2, 3, 4, 5, 6, 7];\n    let (tx, rx) = mpsc::channel();\n\n    assert_eq!(rhs.len(), lhs.len());\n    for i in 1..rhs.len() {\n        let rhs = rhs.clone();\n        let lhs = lhs.clone();\n        let tx = tx.clone();\n        let handle = thread::spawn(move || {\n            let s = format!(\"Thread {} added {} and {}, result {}\", i,\n            rhs[i], lhs[i], rhs[i] + lhs[i]);\n            tx.clone().send(s).unwrap();\n        });\n        let _ = handle.join().unwrap();\n    }\n\n    drop(tx);\n    for result in rx {\n        println!(\"{}\", result);\n    }\n}\n```", "```rs\n# rustc channels.rs && ./channels\nThread 1 added 20 and 2, result 22\nThread 2 added 30 and 3, result 33\nThread 3 added 40 and 4, result 44\nThread 4 added 50 and 5, result 55\nThread 5 added 60 and 6, result 66\nThread 6 added 70 and 7, result 77\n```", "```rs\n// chapter2/unsafe.rs\n\nfn main() {\n    let num: u32 = 42;\n    let p: *const u32 = &num;\n\n    unsafe {\n        assert_eq!(*p, num);\n    }\n}\n```", "```rs\n# cargo new factorial --lib\n# cargo test\n   Compiling factorial v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/ch2/factorial)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.6 secs\n     Running target/debug/deps/factorial-364286f171614349\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests factorial\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n// chapter2/factorial/src/lib.rs\n\n#[allow(unused_macros)]\n#[macro_export]\nmacro_rules! factorial {\n    ($x:expr) => {\n        {\n            let mut result = 1;\n            for i in 1..($x+1) {\n                result = result * i;\n            }\n            result\n        }\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_factorial() {\n        assert_eq!(factorial!(5), 120);\n    }\n}\n```", "```rs\n    #[test]\n    fn test_factorial_fail() {\n        assert_eq!(factorial!(5), 121);\n    }\n```", "```rs\n// chapter2/factorial/src/lib.rs\n\n/// The factorial crate provides a macro to compute factorial of a given\n/// integer\n/// # Examples\n///\n/// ```", "```rs\n///\n\n#[macro_export]\nmacro_rules! factorial {\n    ($x:expr) => {\n        {\n            let mut result = 1;\n            for i in 1..($x+1) {\n                result = result * i;\n            }\n            result\n        }\n    };\n}\n```"]