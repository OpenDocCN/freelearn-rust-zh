<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Heap Memory and Smart Pointers</h1>
                </header>
            
            <article>
                
<p class="mce-root">We've talked about the stack, and how it is the place where Rust stores data and keeps track of what needs to be kept around and what needs to be cleaned up. It's a powerful, useful mechanism, but it's not right for everything.</p>
<p>Imagine we have a variable that contains an image. It takes up several megabytes of memory, and we need to transfer ownership of it between various parts of our program at different times. If we just put it on the stack, and allow Rust to move it into new scopes as needed, everything will work, but it will be slowed down by the need to copy those megabytes of data every time it moves the value to a new owner.</p>
<p>That's not the only scenario where storing information on the stack isn't ideal, but it's a good illustration.</p>
<p>On the other hand, the last thing we want to do is to break the stack and scope-based ownership model, which gives Rust so much of its power.</p>
<p>Fortunately, there's a way to store data outside of the stack, and still have it act as though it were part of a scope: smart pointers.</p>
<p>The Rust standard library includes several different kinds of smart pointer, meant to address different needs. Smart pointer values themselves are stored in the stack, just like other data values are, but they include the necessary instrumentation to allocate a chunk of <em>heap</em> memory when they are created, and release it back to the system when their lifetimes end. A data value stored in that heap memory can be accessed through the smart pointer, as if it was stored inside the smart pointer.</p>
<p class="mce-root"/>
<div class="packt_infobox">The <strong>heap</strong> is the counterpoint to the stack. Where the stack has a specific structure that helps Rust keep track of which operations are safe and which are not at any given time, the heap can be thought of as unorganized memory. In general, a program can ask for a section of heap memory to be reserved for use at any time, and can release it back to the system at any time. Now imagine what happens when a section of heap memory is allocated too late, or released too soon, or not released when it should be. Mistakes with memory allocation and deallocation are one of the main reasons programs crash.</div>
<p>Thanks to smart pointers, the lifetime of values stored in heap memory mirror the lifetimes of values that follow Rust's normal rules, but with the big advantage that the section of heap memory does not have to be copied when the smart pointer is moved to a new scope. Our multi-megabyte image can be moved around between scopes for the cost of moving a few bytes, because the image itself does not have to move, just the smart pointer that controls it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Box</h1>
                </header>
            
            <article>
                
<p>The most straightforward of the standard smart pointers is the <kbd>Box</kbd>. A <kbd>Box</kbd> does what we've been discussing so far: it stores a data value on the heap, while ensuring that it still follows the lifetime rules as if it were actually part of the <kbd>Box</kbd> value itself.</p>
<p>Here's an example. First, we'll create a data type for the data we want to store on the heap:</p>
<pre>pub struct Person {<br/>    pub name: String,<br/>    pub validated: bool,<br/>}</pre>
<p>Now, creating and using the <kbd>Box</kbd> itself is easy:</p>
<pre>let jack = Box::new(Person { name: "Jack".to_string(), validated: true });<br/>let x = &amp;jack.name;<br/>println!("The person in the box is {}", x);</pre>
<p>The first line creates a <kbd>Box</kbd>. We have to give it a data value to store, because one thing Rust is not okay with is an empty <kbd>Box</kbd>, so we initialize a <kbd>Person</kbd> object and pass it to the function, which creates a new <kbd>Box</kbd> to be used as its internal value.</p>
<p class="mce-root"/>
<div class="packt_infobox">Why does Rust not allow an empty <kbd>Box</kbd>, or any other kind of smart pointer, for that matter? Because if it did, then it would have to worry about whether a given smart pointer referred to initialized memory or not whenever that smart pointer's contents were accessed. Requiring that as long as the smart pointer exists the memory it manages must contain a valid data value simplifies many things and makes a common kind of error impossible.</div>
<p class="mce-root">Once we have an initialized the <kbd>Box</kbd>, we can mostly treat it as if it was a normal borrow of the contained data. We can move the data back out onto the stack by dereferencing it:</p>
<pre>let x = *jack;</pre>
<p>This moves the <kbd>Person</kbd> value from inside the <kbd>Box</kbd> named <kbd>jack</kbd> to the <kbd>x</kbd> variable, and renders <kbd>jack</kbd> unusable.</p>
<p>We can also access the contained data value's data and functions through the <kbd>Box</kbd>, again as if it were a borrow of the contained data:</p>
<pre>let x = &amp;jack.name;<br/>println!("The person in the box is {}", x);</pre>
<p>Here, we're asking to borrow <kbd>jack.name</kbd> into <kbd>x</kbd>, then printing out that name. We could have also gotten the same result by doing the following:</p>
<pre>println!("The person in the box is {}", jack.name);</pre>
<p>But that actually works in a very different way. The first example borrows the name, and then prints out that borrowed <kbd>String</kbd> value. The second one actually calls a function called <kbd>jack.name.fmt</kbd>, which has an immutable borrow as its <kbd>self</kbd> parameter. This works out because Rust is smart about dereferencing and function calls.</p>
<div class="packt_tip">Where did <kbd>fmt</kbd> get called? The answer is that <kbd>println!</kbd> is a <em>macro</em>, which means that it's not actually a function, but instead is kind of like pasting some code right into the program here. The pasted code calls <kbd>fmt</kbd>, so it's as if we called <kbd>fmt</kbd> ourselves. In Rust, we can recognize macros because their names always end with <kbd>!</kbd>, and function names never do.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Box and variable size</h1>
                </header>
            
            <article>
                
<p>We've previously bumped into the need for Rust to know exactly how many bytes a particular data value can occupy. Most of the time, Rust can figure that out, and most of the time, it's not a problem, but there are a few cases where it's impossible to define a fixed size for a data value.</p>
<p>One fundamental example is a data structure, <span><span>such as the following one, </span></span>where an instance contains other instances of itself:</p>
<pre>pub struct TreeNode {<br/>    pub value: i32,<br/>    pub left: TreeNode,<br/>    pub right: TreeNode,<br/>}</pre>
<p>That looks reasonable at first glance, but Rust quite rightly points out that the calculated size is infinite (because the size of a <kbd>TreeNode</kbd> is the size of two <kbd>TreeNodes</kbd> plus <kbd>32</kbd> bits):</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b2cba01a-667a-40e2-ba7b-61bb6c478338.png" width="1135" height="240"/></p>
<p>Just as the compiler suggests, we can fix this with a <kbd>Box</kbd>:</p>
<pre>pub struct TreeNode {<br/>    pub value: i32,<br/>    pub left: Box&lt;TreeNode&gt;,<br/>    pub right: Box&lt;TreeNode&gt;,<br/>}</pre>
<p>Now, the size of a <kbd>TreeNode</kbd> is the size of two Boxes plus 32 bits, which is entirely reasonable.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Box and Any</h1>
                </header>
            
            <article>
                
<p>When a variable's type is <kbd>Box&lt;dyn Any&gt;</kbd>, it acts much like an <kbd>&amp;dyn Any</kbd>, but gains a new feature. A normal <kbd>&amp;dyn Any</kbd> has a <kbd>downcast_ref</kbd> function that we can use to get a reference to the contained value, if we know what type to use to extract it. Now, <kbd>&amp;dyn mut Any</kbd> adds a <kbd>downcast_mut</kbd> that we can use to get a mutable reference. When we have a <kbd>Box&lt;dyn Any&gt;</kbd>, we have access to both of those functions, but we can also call a plain <kbd>downcast</kbd> function to move the contained value out of the <kbd>Any</kbd> and into a variable of the correct type. This consumes the <kbd>Box</kbd> and the <kbd>Any</kbd>, and gives us back a new <kbd>Box</kbd> containing the data value with its correct data type.</p>
<div class="packt_tip">Don't forget that we need to have <kbd>use std::any::Any;</kbd> in our code if we're going to use the <kbd>Any</kbd> trait.</div>
<p>We can create a boxed <kbd>Any</kbd> almost the same way we created a boxed <kbd>Person</kbd>:</p>
<pre>let jill: Box&lt;dyn Any&gt; = Box::new(Person { name: "Jill".to_string(), validated: false });</pre>
<p>The only difference here is that we're telling Rust that we want the <kbd>jill</kbd> variable to contain a <kbd>Box&lt;dyn Any&gt;</kbd> instead of letting it decide for itself that the variable contains a <kbd>Box&lt;Person&gt;</kbd>.</p>
<p>Now, to access the contained <kbd>Person</kbd>, we can do this:</p>
<pre>let real_jill = jill.downcast::&lt;Person&gt;().unwrap();<br/>println!("{}", real_jill.name);</pre>
<p>Like the other downcast functions, we need to specify which concrete data type we're downcasting for. The downcast function returns a <kbd>Result</kbd>, which contains a <kbd>Box&lt;Person&gt;</kbd> if it's successful. Once we have a <kbd>Box&lt;Person&gt;</kbd>, we can do whatever we like with the <kbd>Person</kbd> value it contains.</p>
<div class="packt_tip">The <kbd>unwrap</kbd> function we're calling here consumes a <kbd>Result</kbd> and returns its contained value if it's a success, or terminates the program with an error message if it's a failure. We use <kbd>unwrap</kbd> to handle a <kbd>Result</kbd> when we're very sure that it's going to be a success.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Vec and String</h1>
                </header>
            
            <article>
                
<p>When a data value might <em>change</em> size, it pretty much has to be stored on the heap. For this reason, the Rust prelude includes the <kbd>String</kbd> and <kbd>Vec</kbd> types, which are smart pointers specialized for storing text and variable-length arrays, respectively.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">String</h1>
                </header>
            
            <article>
                
<p>We've already seen <kbd>String</kbd> several times, when we used it to simplify the ownership of text strings. There are other things we can do with it, though, because the text stored in a <kbd>String</kbd> can be changed.</p>
<p>Here, we're changing a <kbd>String</kbd> several times, as shown in the following code:</p>
<pre>let mut text = String::new();<br/>text.push('W');<br/>text.push_str("elcome to mutable strings");<br/>text.insert_str(11, "exciting ");<br/>text.replace_range(28.., "text");<br/>println!("{}", text);</pre>
<p>Let's take a look at that step by step:</p>
<ol>
<li>On the first line, we're creating an empty <kbd>String</kbd>, and storing it in a mutable variable. It has to be mutable, because we're going to change the stored value.</li>
<li>On the second line, we're appending a single character to the <kbd>String</kbd><span>.</span></li>
<li>On the third line, we're appending the whole contents of an <kbd>&amp;str</kbd> <span>to the</span> <kbd>String</kbd><span>.</span></li>
<li>On the fourth line, we're inserting the whole contents of an <kbd>&amp;str</kbd> at byte offset <kbd>11</kbd> in the string. Remember that Rust starts counting from zero, so the offset of the <kbd>W</kbd> in the string is <kbd>0</kbd>.</li>
<li>On the fifth line, we're replacing the characters in a range of offsets with a new sequence of characters. The specific range we're using is <kbd>28..</kbd>, which means the range beginning at <kbd>28</kbd> and going on to infinity (or the end of the <kbd>String</kbd>, whichever comes first).</li>
<li>Last, we print out the final result of all our manipulations.</li>
</ol>
<div class="packt_tip">We have to be careful about using byte offsets with <kbd>String</kbd>, because the <kbd>String</kbd> type always stores text encoded with the <kbd>UTF-8</kbd> encoding. That means that the number of bytes any single character might use can be as little as one, and as large as four bytes. If we try to use an offset that is in the middle of a character, the program will terminate with an error message. <kbd>String</kbd> and <kbd>&amp;str</kbd> have an assortment of functions that let us find valid byte offsets within a <kbd>String</kbd>, or manipulate it without using offsets at all, such as <kbd>find</kbd>, <kbd>lines</kbd>, <kbd>split_whitespace</kbd>, <kbd>contains</kbd>, <kbd>starts_with</kbd>, <kbd>ends_with</kbd>, <kbd>split</kbd>, <kbd>trim</kbd>, and <kbd>char_indices</kbd>.</div>
<p>Using our <kbd>text</kbd> variable, the data type of <kbd>&amp;text</kbd> can be <kbd>&amp;String</kbd> <em>or</em> <kbd>&amp;str</kbd>. Rust's type inference system makes that decision, based on the data type of the variable where the value will be stored, or the function parameter that it will be assigned to, and so on. That also means that any functions that are implemented for <kbd>&amp;str</kbd> or that take an <kbd>&amp;str</kbd> parameter can be used on a <kbd>String</kbd> as well. For example, <kbd>str</kbd> has a <kbd>lines(&amp;self)</kbd> function, so we can call <kbd>text.lines()</kbd>. Further, we can pass a <kbd>String</kbd> as the text parameter to the <kbd>push_str</kbd>, <kbd>insert_str</kbd>, and <kbd>replace_range</kbd> functions we saw in this example, just as if it was a real <kbd>&amp;str</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Vec</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>Vec</kbd> data type stores a <em>vector</em>, which is a word commonly used in programming to indicate a one-dimensional, variable-size array. Like actual arrays, they can store multiple data values, as long as those data values all have the same data type. Like <kbd>Strings</kbd>, <kbd>Vecs</kbd> can change size, and so they are specialized smart pointers that store their contained values on the heap.</p>
<p>To create an empty <kbd>Vec</kbd>, we can use <kbd>Vec::new()</kbd>, like so:</p>
<pre>let mut vector = Vec::new();</pre>
<p>Then we can append a data value to it using <kbd>push</kbd>:</p>
<pre>vector.push(1.5);</pre>
<p>Now, so far, we haven't said a word about what type of data the vector can contain, and Rust is perfectly happy because we didn't <em>need</em> to. Everything we wrote is consistent with the vector containing one of the floating point primitive data types, so that's what Rust figures it contains.</p>
<p class="mce-root"/>
<p>What happens if we do something that isn't consistent, such as try to store an <kbd>&amp;str</kbd> in the vector?</p>
<pre>vector.push("nope");</pre>
<p>Now Rust can't figure out what data type the vector is supposed to contain, so it refuses to compile:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1eecb891-377b-426c-b184-815c363aabfd.png" width="768" height="248"/></p>
<p class="mce-root">However, we can do something like this:</p>
<pre>let x: f64 = 99.9;<br/>vector.push(x);</pre>
<p>Here, we've got a variable named <kbd>x</kbd> that has <kbd>f64</kbd> for its data type. That's compatible with the "some kind of floating point number" that Rust was able to figure out before, so adding it to the vector doesn't cause any problems. In fact, it tells Rust that our earlier <kbd>1.5</kbd> should be treated as an <kbd>f64</kbd> too, and that the vector contains <kbd>f64</kbd> values, specifically.</p>
<p>We used numbers for that example, but Rust can store any data type in a <kbd>Vec</kbd>, as long is we follow the rule of only one data type per vector.</p>
<p>Adding an <kbd>&amp;str</kbd> to our vector of numbers was a problem, but we can create a vector of <kbd>&amp;str</kbd> without any trouble:</p>
<pre>let mut second_vector = Vec::new();<br/>second_vector.push("This");<br/>second_vector.push("works");<br/>second_vector.push("fine");</pre>
<p>We can access elements contained in a vector using the same syntax we would use for an array:</p>
<pre>    println!("{} {} {}.", second_vector[0], second_vector[1], second_vector[2]);</pre>
<p class="mce-root"><kbd>Vec</kbd> implements a number of functions for accessing the stored data values, such as the following:</p>
<ul>
<li><kbd>pop</kbd>, which removes and returns the last item in the vector</li>
<li><kbd>remove</kbd>, which removes the item at a specific index</li>
<li><kbd>insert</kbd>, which adds an item at a specific index, pushing the item that was at that index and everything after it back one</li>
<li><kbd>append</kbd>, which moves values out of another vector and adds them at the end</li>
<li><kbd>len</kbd>, which just tells us how many items are in the vector</li>
<li><kbd>iter</kbd>, which returns an iterator for the contained data</li>
</ul>
<p>Creating an empty vector and then pushing a bunch of values to it can get a little bit tedious, so there's a macro to make things easier:</p>
<pre>let third_vector = vec!["This", "works", "too"];</pre>
<p>We recognize the macro by its <kbd>!</kbd> as always, but this time it's not really pretending to be a function. Instead, it almost looks like a prefixed array expression. Macros have a lot of flexibility about how they look, and for this one, looking similar to an array expression makes sense. The end result of this is just like we'd created a vector with <kbd>new</kbd> and then added information to it with <kbd>push</kbd>. It's just a more convenient way of writing the same thing.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rc</h1>
                </header>
            
            <article>
                
<p>There are times when Rust's insistence that each data value has only one owner just doesn't fit our program's data model. What if we're writing a word processing engine, and we wanted people to be able to include the same image in multiple places without wasting memory on duplicates; or what if we were modeling an organization where one person might be referenced by multiple roles?</p>
<p class="mce-root"/>
<p>We could have one definitive owner of the shared information, and use borrows everywhere else, and if that works, it's probably the way to go. There are two situations where it doesn't work, though:</p>
<ul>
<li>We don't know how long the lifetimes of each of the users of the shared data value will be</li>
<li>We need write access to the shared data in at least one of the users</li>
</ul>
<p>A word processing engine is a good example of problem number one: An image may be used more than once in the same document, but we never know when the user might decide to delete one of them, nor do we know which one will be deleted. Maybe all of them will be deleted, and who knows what order that will happen in or what the timing will be like.</p>
<p>To fully address problem number two, we'll need both the <kbd>Rc</kbd> and <kbd>RefCell</kbd> data types, so we'll talk about that later in this chapter.</p>
<p>When we find ourselves in a situation where we need to share information without knowing about the relative lifetimes of the various borrows of that information, we can use the <kbd>Rc</kbd> smart pointer to make everything work. <kbd>Rc</kbd> stands for "reference counted," and what it does is keep track of how many copies of itself exist. When that number reaches zero, the lifetime of the contained data value ends.</p>
<p>Let's look at creating some reference-counted smart pointers:</p>
<pre>pub fn make_vector_of_rcs() -&gt; Vec&lt;Rc&lt;String&gt;&gt; {<br/>    let ada = Rc::new("Ada".to_string());<br/>    let mel = Rc::new("Mel".to_string());<br/><br/>    return vec![<br/>        Rc::clone(&amp;ada),<br/>        Rc::clone(&amp;mel),<br/>        Rc::clone(&amp;ada),<br/>        Rc::clone(&amp;ada),<br/>        Rc::clone(&amp;mel),<br/>        Rc::clone(&amp;ada),<br/>        Rc::clone(&amp;mel),<br/>    ];<br/>}</pre>
<p>We created the first <kbd>Rc</kbd> values using <kbd>Rc::new</kbd>, on the first two lines of the function body. Both of them contain a <kbd>String</kbd> value.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>After that, we used <kbd>Rc::clone</kbd> to create several duplicates of each <kbd>Rc</kbd>. Keep in mind that the <kbd>String</kbd> values are <em>not</em> being duplicated, just the <kbd>Rc</kbd> smart pointer. The returned vector contains four <kbd>Rc</kbd>s that share access to the same <kbd>ada</kbd> string, and three that share access to the same <kbd>mel</kbd> string.</p>
<p>Then the function's scope ends, and so does the lifetime of the original <kbd>ada</kbd> and <kbd>mel</kbd> reference-counted smart pointers. However, the various copies are part of the return value, so their lifetimes do not end, and as a consequence the reference counts of the two string values are still greater than zero, and their lifetimes also do not end.</p>
<div class="packt_tip">We used <kbd>Rc::clone</kbd> here, but if we'd written <kbd>ada.clone()</kbd> or <kbd>mel.clone()</kbd>, it would have produced the same result. People usually prefer to write it as <kbd>Rc::clone</kbd> to make it plain that we're cloning the <kbd>Rc</kbd>, and not the data value the <kbd>Rc</kbd> contains.</div>
<p>Now we'll write a short program that relies on user input to determine when the lifetime of each of the <kbd>Rc</kbd> copies ends. There's no fixed order in which the <kbd>Rc</kbd>s are to be removed, so the compiler can't know ahead of time when it's safe to clean up their shared data values, but thanks to the reference counting mechanism, the <kbd>String</kbd> values are retained as long as they are needed, and then their lifetime ends.</p>
<p>Here, we remove elements from the vector based on the user input:</p>
<pre>let mut ada_and_mel = make_vector_of_rcs();<br/><br/>while ada_and_mel.len() &gt; 0 {<br/> println!("{:?}", ada_and_mel);<br/><br/> print!("Remove which: ");<br/> io::stdout().flush().unwrap();<br/><br/> let mut line = String::new();<br/> io::stdin().read_line(&amp;mut line).unwrap();<br/><br/> let idx: usize = line.trim().parse().unwrap();<br/> ada_and_mel.remove(idx);<br/>}</pre>
<p>First, we call our <kbd>make_vector_of_rcs</kbd> function to create the initial vector of reference-counted smart pointers to the shared data.</p>
<p>Then, we loop as long as there are any values still stored in the vector. Within the loop, we first print out the current vector (the <kbd>{:?}</kbd> code tells Rust to print out the <kbd>'debug'</kbd> representation of the vector, which looks like a Rust array expression). Then we print out a prompt, and flush the output stream to make sure the prompt is actually displayed. Then we read a line from the input stream, parse it into an integer, and use that integer as an index to remove an element from the vector.</p>
<p>When we run that program, it looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8602814b-242b-41a5-b7cd-57772c25200c.png" style="width:30.25em;height:16.67em;" width="506" height="279"/></p>
<p>When the last <kbd>Rc</kbd> that references the <kbd>"Mel"</kbd> value is removed, the lifetime of that <kbd>String</kbd> finally ends, and the same goes for the <kbd>String</kbd> containing <kbd>"Ada"</kbd>.</p>
<div class="packt_tip">We used <kbd>unwrap</kbd> a lot in that code, and really, we overused it. Unwrapping the results of <kbd>flush</kbd> and <kbd>read_line</kbd> makes sense; if those return a failed <kbd>Result</kbd>, the program should probably terminate because something has gone wrong on the operating system level. However, unwrapping the result of <kbd>parse</kbd> is not such a good idea, because a failed result there just means that the user entered something unexpected. We really should have used <kbd>match</kbd> to respond by printing out a message when the input doesn't parse properly. We also should have checked that the number was the index of a value that was actually within the vector, and not off beyond one of the ends. Rust won't let us access an invalid index, but trying to do so will terminate the program with an error message, which isn't great.</div>
<div class="packt_infobox">Parsing means taking information encoded as a text string, and turning it into a data value we can actually work with; for example, turning <kbd>"5"</kbd> into the number <kbd>5</kbd>. The <kbd>parse</kbd> function is pretty wild, because it figures out what kind of information we want based on the data type of the variable we're assigning its return value to, and then figures out which function to use to turn a string into that kind of data value. Of course, it can't write that function for us, so it only works for data types that have such a function in the first place. Also, it's really the Rust compiler doing all of the figuring out. The <kbd>parse</kbd> function just takes advantage of the compiler's rules and inference system.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Weak references</h1>
                </header>
            
            <article>
                
<p>Reference counting has one fatal flaw, which is the reason why it's not used by default for all variables in every programming language: cycles. If two or more reference counted values somehow refer to each other, their lifetimes would never end. They form what is called a <em>cycle</em>.</p>
<div class="packt_tip">It isn't always obvious when a cycle happens. If A refers to B, which refers to C, which refers to D, which refers to A, we still have a cycle.</div>
<p>We can break cycles by using <em>weak references</em>, which are an ancillary data type for <kbd>Rc</kbd>. When we have an <kbd>Rc</kbd>, we can call its <kbd>downgrade</kbd> function (for example, <kbd>let weak_mel = Rc::downgrade(&amp;mel)</kbd>) to retrieve a <kbd>Weak</kbd> data value.</p>
<p>We can't actually do anything with a <kbd>Weak</kbd> except retrieve an <kbd>Rc</kbd> by calling its <kbd>upgrade</kbd> function (for example <kbd>weak_mel.upgrade()</kbd>), but using a <kbd>Weak</kbd> lets us keep track of a reference-counted value without actually referencing it, which means we can avoid creating cycles while still organizing our information in the way that seems natural.</p>
<p>If the number of <kbd>Rcs</kbd> that reference a data value is zero, that data value's lifetime ends, <em>even if there are still</em> <kbd>Weaks</kbd> <em>that reference the value</em>.</p>
<p>Because the referenced value might not exist anymore, the <kbd>upgrade</kbd> function returns an <kbd>Option</kbd>. When we call <kbd>upgrade</kbd>, we'll either get a <kbd>Some</kbd> containing our <kbd>Rc</kbd>, or we'll get <kbd>None</kbd>.</p>
<p class="mce-root"/>
<p>So, the pattern here is that we use <kbd>Rc</kbd> when we want to make sure that the data value sticks around as long as we need it, and <kbd>Weak</kbd> when we <em>know</em> it's going to stick around (for example, when it's referring to the parent node in a tree structure) or when we <em>don't care</em> whether it sticks around (for example, when it's a cached value that we can regenerate if it's missing).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cell and RefCell</h1>
                </header>
            
            <article>
                
<p>Rust's rule that only one block of code can have write access to a data value at any one time is a good one, but sometimes the restrictions that are needed to be sure <em>when the compiler is running</em> that this rule will always be followed are too tight. Sometimes, we need the extra freedom that comes from having the rule checked <em>while the program is running</em>, instead.</p>
<p>The compiler checks would ensure that the program <em>can't</em> break the rule, while the runtime checks ensure that the program <em>doesn't</em> break the rule, giving us more flexibility at the cost of some overhead.</p>
<p>To support this option, Rust provides us with the <kbd>Cell</kbd> and <kbd>RefCell</kbd> data types, which are smart pointers that allow us to change their contents, even if they are not stored in a mutable variable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cell</h1>
                </header>
            
            <article>
                
<p>The <kbd>Cell</kbd> type stores a single data value, which we can move in and out of the <kbd>Cell</kbd> even if the <kbd>Cell</kbd> is not marked as mutable. To move a value into the <kbd>Cell</kbd>, we can use the following:</p>
<ul>
<li><kbd>Cell::new</kbd>, because the initial value was moved into the cell when the cell is created</li>
<li><kbd>set</kbd>, to move a new value into the cell, and end the lifetime of the value already stored there</li>
<li><kbd>replace</kbd>, to move a new value into the cell, and move the old value into the current scope</li>
</ul>
<p class="mce-root"/>
<p>To move a value out of the <kbd>Cell</kbd>, we can use the following:</p>
<ul>
<li><kbd>replace</kbd>, to move a new value into the cell, and move the old value into the current scope</li>
<li><kbd>into_inner</kbd>, to consume the cell, and return the value it contained</li>
</ul>
<p><kbd>Cell</kbd>s don't support any operations that would allow us to have an empty <kbd>Cell</kbd>: they always have to contain something, just like the other smart pointer types.</p>
<p>Let's take a look at a cell in action:</p>
<pre>let cell = Cell::new("Let me out!".to_string());<br/>println!("{}", cell.replace("Don't put me in there.".to_string()));<br/>println!("{}", cell.replace("I didn't do anything.".to_string()));<br/>cell.set("You'll never hold me, copper!".to_string());<br/>println!("{}", cell.into_inner());</pre>
<p>Notice that the <kbd>cell</kbd> variable <em>is not mutable</em>. Here, we're setting up a cell, using <kbd>replace</kbd> a couple of times to retrieve the old value from the <kbd>cell</kbd> at the same time that we set a new one, and then using <kbd>set</kbd> to set a new value while discarding the old one, and finally using <kbd>into_inner</kbd> to get rid of the <kbd>cell</kbd> while extracting its contained value.</p>
<p>The <kbd>into_inner</kbd> function moves the contained value out of the <kbd>cell</kbd>, but that doesn't create an empty <kbd>cell</kbd> because the <kbd>cell</kbd> no longer exists. If we tried to access it after calling <kbd>into_inner</kbd>, we'd get an error from the compiler, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8a5ccd98-2829-485e-aed6-421c44daa6a7.png" width="1282" height="187"/></p>
<p>There's one more function that we can use to access the data value contained in a <kbd>Cell</kbd>, but only if the contained data type has the <kbd>Copy</kbd> trait: <kbd>get</kbd>. We could do something like <kbd>println!("{}", cell.get())</kbd> to leave the content of the <kbd>cell</kbd> in place while retrieving a copy of it, but only if copying the data value is actually possible.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What's the point?</h1>
                </header>
            
            <article>
                
<p>Okay, so what's this actually good for? We could have just used a mutable variable, and produced the same result with less overhead. <kbd>Cell</kbd> (and <kbd>RefCell</kbd>) are mostly for use with <kbd>Rc</kbd> and similar data types. The <kbd>Rc</kbd> type follows Rust's normal rules about mutability, and since it's meant to be a mechanism for accessing a shared data value in many places, that means that the shared value must be immutable.</p>
<p>Unless that value is a <kbd>Cell</kbd> or <kbd>RefCell</kbd> containing the <em>real</em> shared value.</p>
<p>The <kbd>Cell</kbd> or <kbd>RefCell</kbd> ensures that only one block of code at a time <em>actually</em> modifies the shared value, but any of the blocks that have access to it through a clone of the <kbd>Rc</kbd> have the <em>ability</em> to do so.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">RefCell</h1>
                </header>
            
            <article>
                
<p><kbd>Cell</kbd>'s semantics of moving the stored data value in and out of the <kbd>cell</kbd> are not always convenient to work with, and for large data values, moving them can be an expensive operation that we don't want to keep repeating over and over without need. <kbd>RefCell</kbd> to the rescue!</p>
<p>The <kbd>RefCell</kbd> type supports <kbd>RefCell::new</kbd>, <kbd>replace</kbd>, and <kbd>into_inner</kbd>, just as <kbd>Cell</kbd> does, but it also has functions that allow us to borrow the contained value, either mutably or immutably.</p>
<p>Let's give <kbd>RefCell</kbd> a whirl:</p>
<pre> let refcell = RefCell::new("It's a string".to_string());<br/><br/> match refcell.try_borrow() {<br/> Ok(x) =&gt; { println!("Borrowed: {}", x); }<br/> Err(_) =&gt; { println!("Couldn't borrow first try"); }<br/> };<br/><br/> let borrowed_mutably = refcell.try_borrow_mut()?;<br/><br/> match refcell.try_borrow() {<br/> Ok(x) =&gt; { println!("Borrowed: {}", x); }<br/> Err(_) =&gt; { println!("Couldn't borrow second try"); }<br/> };<br/><br/> println!("Mutable borrow is still alive: {}", borrowed_mutably);</pre>
<p class="mce-root"/>
<p>First, we created a new <kbd>RefCell</kbd>, containing a text string. After that, we used the <kbd>try_borrow</kbd> function to retrieve an immutable borrow of the contained data value. The rules about borrowing are still enforced, meaning we can't borrow a value if it's mutably borrowed, and we can't mutably borrow a value if the value is already borrowed at all, which means that <kbd>try_borrow</kbd> might not actually succeed. Therefore, we have to handle the possibility that it fails, which we're doing here by using a <kbd>match</kbd> expression.</p>
<p>Next, we retrieve a mutable borrow and store it in a local variable. The previous borrow's lifetime ended at the end of the chosen block in the <kbd>match</kbd> expression, so there are no live borrows and we expect the <kbd>try_borrow_mut</kbd> to succeed, but we still need to handle the possibility of failure. In this case, we're using <kbd>?</kbd> to handle the returned <kbd>Result</kbd>, which will extract the value of a success, or return a failure to the function that called our current function. If the <kbd>try_borrow_mut</kbd> succeeds as expected, that leaves the <kbd>borrowed_mutably</kbd> variable containing a mutable reference to <kbd>refcell</kbd>'s contained data value.</p>
<p>Then we again try to borrow the contained data value, immutably. Since immutable borrows are not compatible with mutable borrows, and our mutable borrow is still around, we expect this attempt to fail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Arc</h1>
                </header>
            
            <article>
                
<p>There's another layer of complexity when it comes to sharing data between multiple code blocks: threads and multithreading. <kbd>Rc</kbd>, <kbd>Cell</kbd>, and <kbd>RefCell</kbd> are all impossible to share between threads, but the ideas they represent would be useful for enabling communication between threads.</p>
<p>There's a direct equivalent of <kbd>Rc</kbd> for use with threads: <kbd>Arc</kbd>. An <kbd>Arc</kbd> is an <em>atomic reference-counted smart pointer</em>, which is valid for sharing between threads thanks to that <em>atomic</em>, which basically means that even if two threads try to use it at the same time, it's not going to get messed up or confused.</p>
<p><kbd>Arc</kbd> has a different name and works differently inside, but on the surface it's just like <kbd>Rc</kbd>. The things we've learned about how to use an <kbd>Rc</kbd> apply to an <kbd>Arc</kbd> as well.</p>
<p>It's hard to demonstrate the special features of <kbd>Arc</kbd> without using <kbd>Mutex</kbd> or <kbd>RwLock</kbd> as well, so see the next section for some example code.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mutex and RwLock</h1>
                </header>
            
            <article>
                
<p><kbd>Mutex</kbd> and <kbd>RwLock</kbd> are both similar to <kbd>RefCell</kbd> in some ways, but not as closely related as <kbd>Arc</kbd> is to <kbd>Rc</kbd>.</p>
<p>It's <kbd>Mutex's</kbd> job to make sure that only one thread has access to the contained data at a time. Since it guarantees that only one block of code has access at all at any given time, a <kbd>Mutex</kbd> can safely provide both read and write access without breaking Rust's rules.</p>
<p>In the following example, we have <kbd>Mutex</kbd> and <kbd>Arc</kbd> in action, and some very basic multithreading:</p>
<pre>let counter = Arc::new(Mutex::new(0));<br/><br/>for _ in 0..10 {<br/> let local_counter = Arc::clone(&amp;counter);<br/> thread::spawn(move || {<br/> let wait = time::Duration::new(random::&lt;u64&gt;() % 8, 0);<br/> thread::sleep(wait);<br/> let mut shared = local_counter.lock().unwrap();<br/> *shared += 1;<br/> });<br/>}<br/><br/>loop {<br/>    {<br/>        let shared = counter.lock().unwrap();<br/>        println!("{} threads have completed", *shared);<br/><br/>        if *shared &gt;= 10 {<br/>            break;<br/>        };<br/>    };<br/>    thread::sleep(time::Duration::new(1, 0));<br/>}</pre>
<p>The first thing we're doing is creating a new <kbd>Arc</kbd> containing a <kbd>Mutex</kbd>, which in turn contains an integer. So, our integer can only be accessed by one thread at a time, but it can be shared among many and its lifetime will not end until all of them are done with it.</p>
<p class="mce-root"/>
<p>Next, we have a <kbd>for</kbd> loop, which goes through 10 cycles, and launches a thread on each cycle. Notice how we're creating a clone of the <kbd>Arc</kbd> <em>before</em> we call <kbd>thread::spawn</kbd>. That's because we're using a <em>closure</em> to define what the threads should do. A closure is like a function in a lot of ways, but it can borrow or move local variables into its own scope when it's defined. We need to create the <kbd>Arc</kbd> value that it's going to move into its own scope, before asking it to perform the move.</p>
<div class="packt_tip">This closure is moving local variables into its own scope because we used the <kbd>move</kbd> keyword when we defined it, and it's moving the <kbd>local_counter</kbd> variable specifically simply because we referred to it within the closure.</div>
<p><span>Within each thread's closure, we ask it to wait for a random duration less than 8 seconds, and then add 1 to the counter. In order to add 1 to the counter, we first have to lock the <kbd>Mutex</kbd>, so that we can be sure no other thread has access. We do that by calling the <kbd>Mutex</kbd>'s <kbd>lock()</kbd> function via the <kbd>Arc</kbd> (because an <kbd>Arc</kbd> can pretend to be a normal borrow of the thing inside it). The value that the <kbd>lock</kbd> function returns both provides us with access to the contained data when we dereference it, and keeps track of how long the <kbd>Mutex</kbd> should remain locked. When the lifetime of that returned value ends, the <kbd>Mutex</kbd> is unlocked so that other threads can access the contained data value. If another thread tries to lock the value while it's still locked, <kbd>Mutex</kbd> makes that other thread wait until it's unlocked before continuing.</span></p>
<div class="packt_infobox">The <kbd>lock</kbd> function actually returns a <kbd>Result</kbd>, but we're just unwrapping that here. If the call to <kbd>lock</kbd> fails, it's because one of the other threads had a bad error while it had the <kbd>Mutex</kbd> locked, and ending the program is probably the smart thing to do.</div>
<p>Finally, we can just do a <kbd>*shared +=1</kbd> to actually add <kbd>1</kbd> to the shared counter.</p>
<p>After that, we have a loop, which locks the <kbd>Mutex</kbd>, then prints out the current value of the counter, and ends the loop (using the <kbd>break</kbd> keyword) if it is greater than or equal to 10. If the loop hasn't ended, it then waits one second and does it again.</p>
<p>Notice that within that loop, we have another block expression, and that the <kbd>thread::sleep</kbd> call is outside of it. That's because of the way <kbd>Mutex</kbd> works: as long as the returned value's lifetime hasn't ended, the <kbd>Mutex</kbd> remains locked. We don't want the <kbd>Mutex</kbd> to be locked while this code is sleeping, so we put the return value into a shorter scope, so that its lifetime would end before we called <kbd>thread::sleep</kbd>, and the <kbd>Mutex</kbd> would be unlocked.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>An <kbd>RwLock</kbd> is similar to a <kbd>Mutex</kbd>, but it has different rules about how access to the contained data value is managed. Instead of a single lock function, <kbd>RwLock</kbd> has two: <kbd>read</kbd> and <kbd>write</kbd>. Any number of threads can call <kbd>read</kbd> to access the contained information at the same time, but only one thread can use <kbd>write</kbd> to access it at any given moment, and while a thread has write access, no other threads are allowed to read it. If a thread tries to read or write at a time when it's not allowed, <kbd>RwLock</kbd> makes the thread wait until what it wants to do is allowed again.</p>
<div class="packt_tip">We don't need to use <kbd>read</kbd> and <kbd>write</kbd> together to have both kinds of access. Using <kbd>write</kbd> implies that we have read access as well.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we've learned about the following:</p>
<ul>
<li>The differences between heap and stack memory</li>
<li>How to use <kbd>Box</kbd> to simply store something on the heap, when we wish to do so</li>
<li>How to use <kbd>Rc</kbd> to manage the lifetime of a data value that is needed in many scopes with varying lifetimes</li>
<li>How to use <kbd>Cell</kbd> and <kbd>RefCell</kbd> to allow write access to data stored in an <kbd>Rc</kbd></li>
<li>How to use <kbd>Arc</kbd>, <kbd>Mutex</kbd>, and <kbd>RwLock</kbd> to manage sharing information between threads</li>
</ul>
<p>In the next chapter, we're going to be looking at generic types, and how to use generic type parameters for our own data types.</p>


            </article>

            
        </section>
    </div>



  </body></html>