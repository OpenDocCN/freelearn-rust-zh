["```rs\nfrom threading import Thread \n```", "```rs\nfrom time import sleep\n```", "```rs\nfrom typing import Optional\n```", "```rs\nclass ExampleThread(Thread):\n```", "```rs\n    def __init__(self, seconds: int, name: str) -> None:\n```", "```rs\n        super().__init__()\n```", "```rs\n        self.seconds: int = seconds\n```", "```rs\n        self.name: str = name\n```", "```rs\n        self._return: Optional[int] = None\n```", "```rs\n    def run(self) -> None:\n```", "```rs\n        print(f\"thread {self.name} is running\")\n```", "```rs\n        sleep(self.seconds)\n```", "```rs\n        print(f\"thread {self.name} has finished\")\n```", "```rs\n        self._return = self.seconds\n```", "```rs\n    def join(self) -> int:\n```", "```rs\n        Thread.join(self)\n```", "```rs\n        return self._return\n```", "```rs\none: ExampleThread = ExampleThread(seconds=5, name=\"one\")\n```", "```rs\ntwo: ExampleThread = ExampleThread(seconds=5, name=\"two\")\n```", "```rs\nthree: ExampleThread = ExampleThread(seconds=5, \n```", "```rs\n  name=\"three\")\n```", "```rs\nimport time\n```", "```rs\nstart = time.time()\n```", "```rs\none.start()\n```", "```rs\ntwo.start()\n```", "```rs\nthree.start()\n```", "```rs\nprint(\"we have started all of our threads\")\n```", "```rs\none_result = one.join()\n```", "```rs\ntwo_result = two.join()\n```", "```rs\nthree_result = three.join()\n```", "```rs\nfinish = time.time()\n```", "```rs\nprint(f\"{finish - start} has elapsed\")\n```", "```rs\nprint(one_result)\n```", "```rs\nprint(two_result)\n```", "```rs\nprint(three_result)\n```", "```rs\nthread one is running\n```", "```rs\nthread two is running\n```", "```rs\nthread three is running\n```", "```rs\nwe have started all of our threads\n```", "```rs\nthread one has finished\n```", "```rs\nthread three has finished\n```", "```rs\nthread two has finished\n```", "```rs\n5.005641937255859 has elapsed\n```", "```rs\n5\n```", "```rs\n5\n```", "```rs\n5\n```", "```rs\nfn main() {\n```", "```rs\n    let example_closure: fn(&str) = |string_input: &str| {\n```", "```rs\n        println!(\"{}\", string_input);\n```", "```rs\n    };\n```", "```rs\n    example_closure(\"this is a closure\");\n```", "```rs\n}\n```", "```rs\nfn main() {\n```", "```rs\n        let base_rate: f32 = 0.03;\n```", "```rs\n        let calculate_interest = |loan_amount: &f32| {\n```", "```rs\n            return loan_amount * &base_rate\n```", "```rs\n        };\n```", "```rs\n        println!(\"the total interest to be paid is: {}\", \n```", "```rs\n          calculate_interest(&32567.6));\n```", "```rs\n}\n```", "```rs\nthe total interest to be paid is: 977.02795\n```", "```rs\nuse std::{thread, time};\n```", "```rs\nuse std::thread::JoinHandle;\n```", "```rs\nfn simple_thread(seconds: i8, name: &str) -> i8 {\n```", "```rs\n    println!(\"thread {} is running\", name);\n```", "```rs\n    let total_seconds = time::Duration::new(seconds as \\\n```", "```rs\n      u64, 0);\n```", "```rs\n    thread::sleep(total_seconds);\n```", "```rs\n    println!(\"thread {} has finished\", name);\n```", "```rs\n    return seconds\n```", "```rs\n}\n```", "```rs\nlet now = time::Instant::now();\n```", "```rs\nlet thread_one: JoinHandle<i8> = thread::spawn(|| {\n```", "```rs\n    simple_thread(5, \"one\")});\n```", "```rs\nlet thread_two: JoinHandle<i8> = thread::spawn(|| {\n```", "```rs\n    simple_thread(5, \"two\")});\n```", "```rs\nlet thread_three: JoinHandle<i8> = thread::spawn(|| {\n```", "```rs\n    simple_thread(5, \"three\")});\n```", "```rs\nlet result_one = thread_one.join();\n```", "```rs\nlet result_two = thread_two.join();\n```", "```rs\nlet result_three = thread_three.join();\n```", "```rs\n    use std::any::Any;\n    use std::marker::Send;\n    ```", "```rs\n    fn process_thread(thread_result: Result<i8, Box<dyn \\\n      Any + Send>>, name: &str) {\n        match thread_result {\n            Ok(result) => {\n                println!(\"the result for {} is {}\", \\\n                  result, name);\n            }\n            Err(result) => {\n                if let Some(string) = result.downcast \\\n                  _ref::<String>() {\n                    println!(\"the error for {} is: {}\", \\\n                      name, string);\n                } else {\n                    println!(\"there error for {} does \\\n                      not have a message\", name);\n                }\n            }\n        }\n    }\n    ```", "```rs\n    println!(\"time elapsed {:?}\", now.elapsed());\n    process_thread(result_one, \"one\");\n    process_thread(result_two, \"two\");\n    process_thread(result_three, \"three\");\n    ```", "```rs\n    thread one is running\n    thread three is running\n    thread two is running\n    thread one has finished\n    thread three has finished\n    thread two has finished\n    time elapsed 5.00525725s\n    the result for 5 is one\n    the result for 5 is two\n    the result for 5 is three\n    ```", "```rs\nfrom multiprocessing import Process\n```", "```rs\nfrom typing import Optional\n```", "```rs\nclass ExampleProcess(Process):\n```", "```rs\n    def __init__(self, seconds: int, name: str) -> None:\n```", "```rs\n        super().__init__()\n```", "```rs\n        self.seconds: int = seconds\n```", "```rs\n        self.name: str = name\n```", "```rs\n        self._return: Optional[int] = None\n```", "```rs\n    def run(self) -> None:\n```", "```rs\n        # do something demanding of the CPU\n```", "```rs\n        pass\n```", "```rs\n    def join(self) -> int:\n```", "```rs\n        Process.join(self)\n```", "```rs\n        return self._return\n```", "```rs\ndef recur_fibo(n: int) -> int:\n```", "```rs\n    if n <= 1:\n```", "```rs\n        return n\n```", "```rs\n    else:\n```", "```rs\n        return (recur_fibo(n-1) + recur_fibo(n-2))\n```", "```rs\nimport time\n```", "```rs\nstart = time.time()\n```", "```rs\nrecur_fibo(n=8)\n```", "```rs\nrecur_fibo(n=12)\n```", "```rs\nrecur_fibo(n=12)\n```", "```rs\nrecur_fibo(n=20)\n```", "```rs\nrecur_fibo(n=20)\n```", "```rs\nrecur_fibo(n=20)\n```", "```rs\nrecur_fibo(n=20)\n```", "```rs\nrecur_fibo(n=28)\n```", "```rs\nrecur_fibo(n=28)\n```", "```rs\nrecur_fibo(n=28)\n```", "```rs\nrecur_fibo(n=28)\n```", "```rs\nrecur_fibo(n=36)\n```", "```rs\nfinish = time.time()\n```", "```rs\nprint(f\"{finish - start} has elapsed\")\n```", "```rs\nif __name__ == '__main__':\n```", "```rs\n    from multiprocessing import Pool\n```", "```rs\n    start = time.time()\n```", "```rs\n    with Pool(4) as p:\n```", "```rs\n        print(p.starmap(recur_fibo, [(8,), (12,), (12,), \\\n```", "```rs\n         (20,), (20,), (20,), (20,), (28,), (28,), (28,), \\\n```", "```rs\n           (28,),(36,)]))\n```", "```rs\n    finish = time.time()\n```", "```rs\n    print(f\"{finish - start} has elapsed\")\n```", "```rs\n3.2531330585479736 has elapsed\n```", "```rs\n[21, 144, 144, 6765, 6765, 6765, 6765, 317811, \n```", "```rs\n317811, 317811, 317811, 14930352]\n```", "```rs\n3.100019931793213 has elapsed\n```", "```rs\n    pub fn fibonacci_recursive(n: i32) -> u64 {\n         if n < 0 {\n              panic!(\"{} is negative!\", n);\n         }\n         match n {\n               0     => panic!(\n               \"zero is not a right argument to \n               fibonacci_reccursive()!\"),\n               1 | 2 => 1,\n               _     => fibonacci_reccursive(n - 1) + \n                        fibonacci_reccursive(n - 2)\n    }\n    }\n    ```", "```rs\n    use std::time;\n    ```", "```rs\n    fn main() {\n        let now = time::Instant::now();\n        fibonacci_reccursive(8);\n        fibonacci_reccursive(12);\n        fibonacci_reccursive(12);\n        fibonacci_reccursive(20);\n        fibonacci_reccursive(20);\n        fibonacci_reccursive(20);\n        fibonacci_reccursive(20);\n        fibonacci_reccursive(28);\n        fibonacci_reccursive(28);\n        fibonacci_reccursive(28);\n        fibonacci_reccursive(28);\n        fibonacci_reccursive(36);\n        println!(\"time elapsed {:?}\", now.elapsed());\n    }\n    ```", "```rs\n    cargo run –release \n    ```", "```rs\n    time elapsed 40.754875ms\n    ```", "```rs\n    [dependencies]\n    rayon=\"1.5.0\"\n    ```", "```rs\n    use rayon::prelude::*;\n    ```", "```rs\n    rayon::ThreadPoolBuilder::new().num_threads(4) \\\n      .build_global().unwrap();\n    let now = time::Instant::now();\n    let numbers: Vec<i32> = vec![8, 12, 12, 20, 20, 20, \\\n      20, 28, 28, 28, 28, 36];\n    let outcomes: Vec<u64> = numbers.into_par_iter() \\\n      .map(|n| fibonacci_reccursive(n)).collect();\n    println!(\"{:?}\", outcomes);\n    println!(\"time elapsed {:?}\", now.elapsed());\n    ```", "```rs\n    time elapsed 38.993791ms\n    [21, 144, 144, 6765, 6765, 6765, 6765, 317811, \n    317811, 317811, 317811, 14930352]\n    time elapsed 31.493291ms\n    ```", "```rs\n    time elapsed 12.5856675s\n    [21, 144, 144, 6765, 6765, 6765, 6765, 317811, 317811, \n    317811, 317811, 14930352, 1836311903, 1836311903, \n    1836311903]\n    time elapsed 4.0485755s\n    ```", "```rs\n    1105.5351197719574 has elapsed\n    [21, 144, 144, 6765, 6765, 6765, 6765, 317811, 317811, \n    317811, 317811, 14930352, 1836311903, 1836311903, \n    1836311903]\n    387.0687129497528 has elapsed\n    ```", "```rs\nuse std::env;\n```", "```rs\nuse std::vec::Vec;\n```", "```rs\npub fn fibonacci_number(n: i32) -> u64 {\n```", "```rs\n      if n < 0 {\n```", "```rs\n           panic!(\"{} is negative!\", n);\n```", "```rs\n      }\n```", "```rs\n      match n {\n```", "```rs\n           0     => panic!(\"zero is not a right argument \\\n```", "```rs\n                             to fibonacci_number!\"),\n```", "```rs\n           1 | 2 => 1,\n```", "```rs\n           _     => fibonacci_number(n - 1) +\n```", "```rs\n                    fibonacci_number(n - 2)\n```", "```rs\n      }\n```", "```rs\n}\n```", "```rs\npub fn fibonacci_numbers(numbers: Vec<i32>) -> Vec<u64> {\n```", "```rs\n    let mut vec: Vec<u64> = Vec::new();\n```", "```rs\n    for n in numbers.iter() {\n```", "```rs\n        vec.push(fibonacci_number(*n));\n```", "```rs\n    }\n```", "```rs\n    return vec\n```", "```rs\n}\n```", "```rs\nfn main() {\n```", "```rs\n    let mut inputs: Vec<i32> = Vec::new(); \n```", "```rs\n    let args: Vec<String> = env::args().collect();\n```", "```rs\n    for i in args {\n```", "```rs\n        match i.parse::<i32>() {\n```", "```rs\n            Ok(result) => inputs.push(result),\n```", "```rs\n            Err(_) => (),\n```", "```rs\n        }\n```", "```rs\n    }\n```", "```rs\n    let results = fibonacci_numbers(inputs);\n```", "```rs\n    for i in results {\n```", "```rs\n        println!(\"{}\", i);\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nrustc fib_process.rs\n```", "```rs\nuse std::process::{Command, Stdio, Child};\n```", "```rs\nuse std::io::{BufReader, BufRead};\n```", "```rs\nfn spawn_process(inputs: &[&str]) -> Child {\n```", "```rs\n    return Command::new(\"./fib_process\").args(inputs)\n```", "```rs\n    .stdout(Stdio::piped())\n```", "```rs\n    .spawn().expect(\"failed to execute process\")\n```", "```rs\n}\n```", "```rs\nfn main() {\n```", "```rs\n    let mut one = spawn_process(&[\"5\", \"6\", \"7\", \"8\"]);\n```", "```rs\n    let mut two = spawn_process(&[\"9\", \"10\", \"11\", \"12\"]);\n```", "```rs\n    let mut three = spawn_process(&[\"13\", \"14\", \"15\", \\\n```", "```rs\n      \"16\"]);\n```", "```rs\n    one.wait();\n```", "```rs\n    two.wait();\n```", "```rs\n    three.wait();\n```", "```rs\n}\n```", "```rs\n    let one_stdout = one.stdout.as_mut().expect(\n```", "```rs\n        \"unable to open stdout of child\");\n```", "```rs\n    let two_stdout = two.stdout.as_mut().expect(\n```", "```rs\n        \"unable to open stdout of child\");\n```", "```rs\n    let three_stdout = three.stdout.as_mut().expect\n```", "```rs\n    (\"unable to open stdout of child\");\n```", "```rs\n    let one_data = BufReader::new(one_stdout);\n```", "```rs\n    let two_data = BufReader::new(two_stdout);\n```", "```rs\n    let three_data = BufReader::new(three_stdout);\n```", "```rs\n    let mut results = Vec::new(); \n```", "```rs\n    for i in three_data.lines() {\n```", "```rs\n        results.push(i.unwrap().parse::<i32>().unwrap());\n```", "```rs\n    }\n```", "```rs\n    for i in one_data.lines() {\n```", "```rs\n        results.push(i.unwrap().parse::<i32>().unwrap());\n```", "```rs\n    }\n```", "```rs\n    for i in two_data.lines() {\n```", "```rs\n        results.push(i.unwrap().parse::<i32>().unwrap());\n```", "```rs\n    }\n```", "```rs\n    println!(\"{:?}\", results);\n```", "```rs\nrustc fib_multiprocessing.rs     \n```", "```rs\n./multiprocessing\n```", "```rs\n[233, 377, 610, 987, 5, 8, 13, 21, 34, 55, 89, 144] we have \n```", "```rs\n  it, our multiprocessing code in Rust works.\n```"]