<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Deep Dive into Parallelism</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deep Dive into Parallelism</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating a thread in Rust</li>
<li>Spawning multiple threads</li>
<li>Holding threads in a vector</li>
<li>Sharing data between threads using channels</li>
<li>Implementing safe mutable access</li>
<li>Creating child processes</li>
<li>Waiting for a child process</li>
<li>Making sequential code parallel</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Concurrency and parallelism are very important topics for creating a high-performance application that can completely utilize system resources, especially considering the fact that hardware is getting better with its offering of multiple cores.</p>
<p>Rust is a great programming language for performing parallel operations in your application. It ensures memory safety and freedom from data races, which is one of the major reasons for the list of various concurrency bugs. Rust utilizes the standard system APIs to perform concurrency operations.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a thread in Rust</h1>
                </header>
            
            <article>
                
<p>Rust's standard library provides various functionality for spawning threads, which allow the developer to develop and run Rust code in parallel. In this recipe, we will learn how to use <kbd>std::thread</kbd> for spawning multiple threads.</p>
<p>You will learn how to create a new thread from the parent, pass a value to the newly created child thread, and retrieve the value.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following steps will walk you through this implementation:</p>
<ol>
<li>Create a file named <kbd>sample_move.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Passing values to a thread in rust<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 19 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard <kbd>thread</kbd> library using the <kbd>use</kbd> keyword:</li>
</ol>
<pre>        use std::thread;
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function and declare two variables: <kbd>x</kbd> and <kbd>handle</kbd>. <span>Assign <kbd>x</kbd></span> with the integer value <kbd>1</kbd> and assign <kbd>handle</kbd> to the new <kbd>thread</kbd>, using the <kbd>thread::spawn</kbd> command. Here's the code for this:</li>
</ol>
<pre>        fn main() { <br/>          let x = 1;  let handle = thread::spawn(move || {(x)}); <br/>    <br/>          println!("{:?}", handle.join().unwrap()); <br/>        }
</pre>
<p style="padding-left: 60px">You will get the following screenshot as an output upon successful execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="40" width="529" src="images/9bdc4ae8-7dca-45d9-a377-fa5ad3bc57fa.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we use Rust's standard library, namely <kbd>std::thread</kbd>, for creating a <kbd>thread</kbd> that would allow your Rust code to run in parallel.</p>
<p>We created a variable named <kbd>x</kbd> using the <kbd>let</kbd> keyword and assigned it the value <kbd>1</kbd>, which we passed to the <kbd>thread</kbd> created by the <kbd>thread::spawn()</kbd> method. This method accepts a closure and it will be executed as a different <kbd>thread</kbd>; the result that it returns is collected in the <kbd>handle</kbd> variable of the main or parent <kbd>thread</kbd>, which is the originator of the <kbd>child</kbd> thread. The parent or main <kbd>thread</kbd> waits until the <kbd>child</kbd> <kbd>thread</kbd> completes the task, and by assigning it to a variable, we collect the information from the <kbd>child</kbd> <kbd>thread</kbd> in the <kbd>handle</kbd> variable.</p>
<p><span>As closures have the ability to capture variables from their environment, we brought the data from the <kbd>child</kbd> <kbd>thread</kbd> to the parent <kbd>thread</kbd>, but we have to do this carefully using the <kbd>move</kbd> closure. If you don't use <kbd>move</kbd></span>, <span>you will get a compile-time error as,</span> by default closures capture variables by reference, and we only have the reference to <kbd>x</kbd>. This is a problem of dangling pointers. The <kbd>move</kbd> closure prevents this by moving the variable from other environments to themselves.</p>
<p>At last, we called the <kbd>join()</kbd> and <kbd>unwrap()</kbd> methods to print the result from the <kbd>child</kbd> <kbd>thread</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spawning multiple threads</h1>
                </header>
            
            <article>
                
<p>The aim of this recipe is to spawn multiple threads in Rust and perform simple actions that will help you understand how threads are generated in Rust. <span>We will extensively use the standard <kbd>thread</kbd> module with the <kbd>move</kbd> closure, which we learned in the previous recipe.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following steps will walk you through this implementation:</p>
<ol>
<li>Create a file named <kbd>sample_multiple_threads.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Passing values to a thread in rust<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 19 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard <kbd>thread</kbd> library using the <kbd>use</kbd> keyword:</li>
</ol>
<pre>        use std::thread;
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function and declare two variables: <kbd>x</kbd> and <kbd>handle</kbd>. Assign <kbd>x</kbd> as an integer value of <kbd>1</kbd> and assign <kbd>handle</kbd> to the new <kbd>thread</kbd>, using the <kbd>thread::spawn</kbd> command. Here's the code for this:</li>
</ol>
<pre>        fn main() {<br/>          thread::spawn(move || {<br/>          println!("Hello from spawned thread");<br/>          });<br/><br/>          let join_handle = thread::spawn(move || {<br/>          println!("Hello from second spawned thread");<br/>          17<br/>          });<br/><br/>          println!("Hello from the main thread");<br/> <br/>          match join_handle.join() {<br/>            Ok(x) =&gt; println!("Second spawned thread returned {}", x),<br/>            Err(_) =&gt; println!("Second spawned thread panicked")<br/>          }<br/>        }
</pre>
<p style="padding-left: 60px"><span>We will get the following screenshot as output upon successful execution of the code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="138" width="583" src="images/c43ddd38-d86f-4f3a-86f7-5845ea460381.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created two threads using the <kbd>spawn</kbd> module of the <kbd>thread</kbd> crate. The first <kbd>thread</kbd> just prints a statement, but the second <kbd>thread</kbd>, apart from printing, also passes and returns a value to the main <kbd>thread</kbd>. The main <kbd>thread</kbd> is the user-created Rust process that creates the other two threads.</p>
<p>The most important point to learn from this recipe is that the main <kbd>thread</kbd> will not wait for the spawned <kbd>thread</kbd> to complete, which means that the next <kbd>println</kbd> macro won't be executed before the program exits. To ensure that the program waits for the threads to finish, we called the <kbd>join()</kbd> module on the <kbd>join_handle</kbd> variable of the <kbd>thread</kbd>.</p>
<p>We even send a value <kbd>17</kbd> to a different <kbd>thread</kbd> through <kbd>join_handle</kbd>, as we sent to the second <kbd>thread</kbd> in this case. In the last few lines of the code, we had the <kbd>match</kbd> statement, where we check whether the value <kbd>x</kbd> has returned from the second <kbd>thread</kbd> using <kbd>join_handle .join()</kbd>.</p>
<div class="packt_infobox">The preceding three <kbd>println</kbd> statements can be observed in any order.</div>
<p>The reason why these statements could be observed in a different order in every execution is that they are scheduled by the OS.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Holding threads in a vector</h1>
                </header>
            
            <article>
                
<p>We are going to create a train of 10 threads in this recipe and declare a vector where we will hold all the <kbd>thread</kbd> handles. We will join the main <kbd>thread</kbd> later to ensure the handles are executed and return the value that we would send while spawning the <kbd>thread</kbd>. We will extensively use the concepts learned from the previous two recipes.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>The following steps will walk you through this implementation</span>:</p>
<ol>
<li>Create a file named <kbd>sample_thread_expt.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Spawning 10 threads in rust<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 19 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard <kbd>thread</kbd> library using the <kbd>use</kbd> keyword and create a <kbd>static</kbd> variable called <kbd>NO_THREADS</kbd> using the 32-bit integer value <kbd>10</kbd>:</li>
</ol>
<pre>        // Using the standard thread crate<br/>        use std::thread;<br/><br/>        // static value NO_THREADS<br/>        static NO_THREADS: i32 = 10;
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function and declare an empty <kbd>thread_holder</kbd> vector. Then create the corresponding loops for pushing the threads spawned to the vector with the iterator value <kbd>i</kbd> and return them later:</li>
</ol>
<pre>        // Main thread starts here<br/>        fn main() {<br/>          // Make a mutable vector named thread_holder to hold the<br/>          threads spawned<br/>          let mut thread_holder = vec![];<br/><br/>          for i in 0..NO_THREADS {<br/>            // Spin up another thread<br/>            thread_holder.push(thread::spawn(move || {<br/>            println!("Thread number is {}", i);<br/>            i<br/>            }));<br/>          }<br/><br/>        println!("***************************");<br/><br/>        for thread_elements in thread_holder {<br/>          // Wait for the thread to finish. Returns a result.<br/>          println!("Thread returned {:?}",<br/>          thread_elements.join().unwrap()); <br/>        }<br/>      }
</pre>
<p style="padding-left: 90px"><span>We will get the following screenshot as output upon successful execution of the code:</span></p>
<div style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><img height="534" width="517" src="images/17d2ddd5-dcd9-457a-aa45-21cd456b26ae.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We declared a static variable named <kbd>NO_THREADS</kbd> to which we assigned the 32-bit integer value <kbd>10</kbd>; we also created an empty mutable vector named <kbd>thread_holder</kbd>.</p>
<p>Using a <kbd>for</kbd> loop, we iterated over the value, starting from <kbd>0</kbd> to the upper limit value of the static variable, that is, <kbd>NO_THREADS</kbd>. Inside the <kbd>for</kbd> loop, we pushed the spawned threads to the <kbd>thread_holder</kbd> vector using the <kbd>push</kbd> functionality. While creating the <kbd>thread</kbd>, we used the <kbd>move</kbd> closure and sent the iterator value <kbd>i</kbd> to the newly spawned <kbd>thread</kbd>.</p>
<p>Once all the thread-spawning commands are completed by the compiler, we start to iterate over the <kbd>thread_holder</kbd> vector elements using a <kbd>for</kbd> loop. In this case, the iterator variable was <kbd>thread_elements</kbd>; we called the <kbd>join</kbd> and <kbd>unwrap</kbd> function to the <kbd>thread</kbd> through this variable. With this, we ensured that all the threads are completed and they return to the main <kbd>thread</kbd>, where we print the value that was sent earlier to the <kbd>thread</kbd> when it was spawned.</p>
<p>Since all the threads are scheduled by the OS, we can't predict the order in which threads will be spawned and the values returned.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sharing data between threads using channels</h1>
                </header>
            
            <article>
                
<p>The idea is to send a piece of information or data of the type <kbd>T</kbd> between threads via a channel. Here, <kbd>T</kbd> implements the <kbd>Send</kbd> trait, which indicates that variables or resources of the type <kbd>T</kbd> have the ability to transfer their ownership safely between threads. This particular feature of Rust helps in safe sharing of data between threads. This helps achieve safer concurrency and data-race freedom. The catch here is that the type <kbd>T</kbd>, which we want to send across the threads via the channel, must support and implement the <kbd>Send</kbd> trait. The second important trait is <kbd>Sync</kbd>. When <kbd>T</kbd> implements <kbd>Sync</kbd>, it means that something of this type has no possibility of introducing memory unsafety when used from multiple threads concurrently through shared references. These two traits allow you to use the Rust type system for making concurrent code.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>The following steps will walk you through this implementation</span><span>:</span></p>
<ol>
<li>Create a file named <kbd>sample_channel.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Using channels to perform safe pass of data between<br/>        threads<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 19 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard <kbd>thread</kbd> library using the <kbd>use</kbd> keyword:</li>
</ol>
<pre>        // Using standard libraries<br/>        use std::sync::mpsc::{Sender, Receiver};<br/>        use std::sync::mpsc;<br/>        use std::thread;
</pre>
<ol start="4">
<li>Create a <kbd>static</kbd> variable called <kbd>NO_THREADS</kbd> with a 32-bit integer value of 3:</li>
</ol>
<pre>        // Declaring number of threads<br/>        static NO_THREADS: i32 = 3;
</pre>
<ol start="5">
<li>Define the <kbd>main</kbd> function and declare the <kbd>tx</kbd> and <kbd>rx</kbd> endpoints of the channel:</li>
</ol>
<pre>        // Main thread starts<br/>        fn main() {<br/>          // Creating endpoints of the channel<br/>          let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();
</pre>
<ol start="6">
<li>Create a <kbd>for</kbd> loop to create threads and send them across the channel:</li>
</ol>
<pre>        for thread_no in 0..NO_THREADS {<br/>          // Cloing the Sender<br/>          let thread_tx = tx.clone();<br/><br/>          // Sending threads via the channel<br/>          thread::spawn(move || {<br/>          // thread sends the message to the channel<br/>          thread_tx.send(thread_no).unwrap();<br/>          println!("thread {} finished", thread_id);<br/>          });<br/>        }
</pre>
<ol start="7">
<li>Similarly, create another <kbd>for</kbd> loop to iterate and collect all the values passed to the channel:</li>
</ol>
<pre>        // Collecting all the threads<br/>        let mut thread_holder = Vec::with_capacity(NO_THREADS as<br/>        usize);<br/>        for i in 0..NO_THREADS {<br/>        // Get the message from channel<br/>        thread_holder.push(rx.recv());<br/>        }<br/><br/>        // Print the execution order<br/>        println!("{:?}", thread_holder);<br/>        }
</pre>
<p style="padding-left: 60px" class="mce-root">You will get the following output upon successful execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><span><img height="224" width="442" src="images/421f8943-9555-4279-9287-a1cf1b54ab97.png"/><br/></span></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we discussed how to use the channel feature of Rust to send data of the type <kbd>T</kbd>, which implements the traits required for safely sending data across threads.</p>
<p>First, to start off with developing channels, we used the <kbd>mpsc::channel()</kbd> method to create a new channel; post this, we sent simple data, such as the <kbd>thread_id</kbd>, from the endpoints. The endpoints in our case were <kbd>tx</kbd> and <kbd>rx</kbd>, which were the transmitter and receiver endpoints of the channel. The channel now had two endpoints, namely <kbd>Sender&lt;T&gt;</kbd> and <kbd>Receiver&lt;T&gt;</kbd>, where <kbd>T</kbd> was the type of the message that had to be transferred.</p>
<p>In the first <kbd>for</kbd> loop, where our focus was on sending the data to the channel, we iterated with a variable named <kbd>thread_id</kbd> from <kbd>0</kbd> to the static <kbd>NO_THREADS</kbd> variable value. The sender endpoint is copied by the <kbd>clone</kbd> method and assigned to <kbd>thread_id</kbd>. Each <kbd>thread</kbd> sends its <kbd>thread_no</kbd> via the channel by spawning new threads in which the <kbd>thread_id</kbd> value is passed to the <kbd>send(data).unwrap()</kbd> methods. The <kbd>thread</kbd> takes ownership of the <kbd>thread_tx</kbd> value. Each <kbd>thread</kbd> queues a message in the channel, sending a non-blocking operation, and continues immediately after sending the message.</p>
<p>In the second <kbd>for</kbd> loop, all the messages are collected from the channel. We declare a vector named <kbd>thread_holder</kbd> with the capacity of the number of threads spawned, which is a prefixed static value called <kbd>NO_THREADS</kbd>. The <kbd>recv</kbd> method of <kbd>rx</kbd> collects the messages from the channel, and <kbd>recv</kbd> blocks the current <kbd>thread</kbd> if there are no messages available. All these messages are pushed to the <kbd>thread_holder</kbd> vector using the <kbd>push</kbd> method of the vector. In the last <kbd>println</kbd> statement, we showed the order in which the messages were sent by printing the <kbd>thread_holder</kbd> vector.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing safe mutable access</h1>
                </header>
            
            <article>
                
<p>We want to ensure safe and mutable access of data, which will allow multiple threads to access the resource without having data races. The ownership model of Rust enables this functionality. You will learn about locks that will help you keep track of your data when you have multiple threads making modifications to it. We have the atomic reference count <kbd>Arc&lt;T&gt;</kbd> in Rust, which at runtime will keep track of the count and allow the developer to share the ownership of the data across threads.</p>
<p>In this recipe, we will use <kbd>mutex&lt;T&gt;</kbd>. This allows us to safely mutate a shared data value across multiple threads. For example, we have data where <kbd>mutex</kbd> will ensure only one <kbd>thread</kbd> would be able to mutate the value inside it at a time.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following steps will walk you through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_lock.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Safe Mutable access across threads for preventing<br/>        data races<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 19 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard libraries:</li>
</ol>
<pre>        // Call the standard library<br/>        use std::sync::{Arc, Mutex};<br/>        use std::thread;<br/>        use std::time::Duration;
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function and declare the <kbd>data</kbd> variable with an <kbd>Arc</kbd> type data with <kbd>Mutex</kbd>:</li>
</ol>
<pre>        // Main thread<br/>        fn main() {<br/>        // Declaring a Arc type data<br/>        let data = Arc::new(Mutex::new(vec![1, 2, 3]));
</pre>
<ol start="5">
<li>Spawn multiple threads using the <kbd>for</kbd> loop, which will mutate the data using <kbd>lock</kbd>:</li>
</ol>
<pre>        // Creating 3 threads and implementing lock<br/>        for i in 0..3 {<br/>          let data = data.clone();<br/>          thread::spawn(move || {<br/>          let mut data = data.lock().unwrap();<br/>          data[0] += i;<br/>          println!("Thread id :{:?}",i );<br/>          println!("Data value :{:?}", data[0]);<br/>          });<br/>        }<br/><br/>        thread::sleep(Duration::from_millis(10));<br/>        }
</pre>
<p style="padding-left: 90px"><span>You will get the following output upon successful execution of the code:</span></p>
<div style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><span><br/>
<img height="325" width="477" src="images/8bda868f-76ee-47ae-bc69-8e0b109b4bcd.png"/><br/></span></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We created a new variable <kbd>data</kbd> of the <kbd>Mutex</kbd> type, which we implemented from the standard sync library. Using the <kbd>for</kbd> loop, we planned to spawn three threads. Inside the scope of the <kbd>for</kbd> loop, we cloned <kbd>data</kbd> to the same variable name: <kbd>data</kbd>. Next, using the standard threads library, we spawned three threads where we locked the <kbd>Mutex</kbd>.<br/>
The <kbd>Mutex</kbd> (short form of mutual exclusion) allows one <kbd>thread</kbd> to access a value at a time. If you wish to access the value, you have to use the <kbd>lock()</kbd> method on the type. This will lock the <kbd>Mutex</kbd>, and no other <kbd>thread</kbd> will be able to unlock it; therefore, no one will be able to modify the data. If a <kbd>thread</kbd> attempts to lock a <kbd>mutex</kbd> that is already locked, it will wait until the other <kbd>thread</kbd> releases the lock.</p>
<div class="packt_infobox">Note that the value of <kbd>i</kbd> is copied only to the closure and not shared among the threads.</div>
<p>The releasing of the lock is automatic as when the variable goes out of scope, it is automatically released, which makes it available to other threads.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating child processes</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will call a <kbd>child</kbd> process from the Rust code to the outside world and record its output values. A <kbd>child</kbd> process is created via the <kbd>Command</kbd> struct, which configures the spawning process. The <kbd>child</kbd> process, in general, is any other tool or application that you would run or start using specific shell commands. In Rust, we spawn these <kbd>child</kbd> processes from the main process, which is the main Rust application, and control them according to the need of the Rust application using the built-in methods that let us read errors, pass arguments, wait for the process to complete, parse the output, and more.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following steps will walk you through the implementation:</p>
<ol>
<li>Create a file named <kbd>sample_child_process.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To call a child process<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 19 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard library:</li>
</ol>
<pre>        // Call the standard library<br/>        use std::process::Command;
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function and declare the <kbd>output</kbd> variable, which is the <kbd>Command</kbd> implementation to execute the <kbd>child</kbd> process and get <kbd>std:output</kbd>:</li>
</ol>
<pre>        // Main execution of the code<br/>        fn main() {<br/>          // Command to be executed<br/>          let output = Command::new("rustc")<br/>          .arg("--version")<br/>          .output().unwrap_or_else(|e| {<br/>          panic!("failed to execute process: {}", e)<br/>          });
</pre>
<ol start="5">
<li>Print out the string value of <kbd>s</kbd> variable based on the <kbd>output</kbd> response using <kbd>if...else</kbd> statements:</li>
</ol>
<pre>        // printing the output values<br/>        if output.status.success() {<br/>          let s = String::from_utf8_lossy(&amp;output.stdout);<br/><br/>          print!("rustc succeeded and stdout was:n{}", s);<br/>        } <br/>        else {<br/>          let s = String::from_utf8_lossy(&amp;output.stderr);<br/><br/>          print!("rustc failed and stderr was:n{}", s);<br/>        }<br/>        }
</pre>
<p style="padding-left: 60px"><span>You will get the following output upon successful execution of the code:</span></p>
<div class="CDPAlignCenter CDPAlign"><span><br/>
<img height="54" width="564" src="images/ef27c0c5-dbd0-4290-8d7f-87f810ccd75a.png"/><br/></span></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A <kbd>child</kbd> process is created via the <kbd>Command</kbd> struct, which is responsible for the spawning process. Here, we declared a variable output where we called the <kbd>new</kbd> method. This is the place where we entered the main command to run. Next, we had <kbd>arg</kbd>, which contained the options of a particular system command. The <kbd>output</kbd> response was responsible for getting the output and the other commands used for error handling.</p>
<p>The <kbd>struct</kbd> <kbd>child</kbd> basically has three fields: <kbd>pub stdin: Option&lt;ChildStdin&gt;</kbd>, <kbd>pub stdout: Option&lt;ChildStdout&gt;</kbd>, and <kbd>pub stderr: Option&lt;ChildStderr&gt;</kbd>. These fields handle represent functionalities such as standard input, output, and error, respectively.</p>
<p>In the <kbd>if...else</kbd> statement, we basically checked whether the <kbd>Command</kbd> had executed properly using the <kbd>status</kbd> module's <kbd>success</kbd> method, which returns <kbd>True</kbd> in case of success and <kbd>False</kbd> otherwise. In both the cases, we captured the error and output, which we printed by <kbd>&amp;output.stdout</kbd> and <kbd>&amp;output.stderr</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Waiting for a child process</h1>
                </header>
            
            <article>
                
<p>Often, we want the main thread to wait for the <kbd>child</kbd> process to complete before continuing with the main <kbd>thread</kbd> execution.<br/>
In this recipe, we will learn how to use the wait method to get the status of a <kbd>child</kbd> process.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following steps will walk you through the recipe:</p>
<ol>
<li>Create a file named <kbd>sample_wait.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Waiting for a child process<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 19 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard library:</li>
</ol>
<pre>        // Calling the standard libraries<br/>        use std::process::Command;
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function and create a <kbd>child</kbd> process using the <kbd>Command</kbd> struct:</li>
</ol>
<pre>        // Main execution starts here<br/>        fn main() {<br/>          // Creating a child process<br/>          let mut child =<br/>          Command::new("sleep").arg("5").spawn().unwrap();
</pre>
<ol start="5">
<li>Create a variable named <kbd>_result</kbd> and call the <kbd>wait</kbd> method, the last print statement, marking the end of the program:</li>
</ol>
<pre>        // Waiting for the child process to complete<br/>        let _result = child.wait().unwrap();<br/><br/>        // printing the status of child process<br/>        print!("Status if child process {} \n", _result);<br/>        // Marking the end of the main function <br/>        println!("reached end of main");<br/>        }
</pre>
<p style="padding-left: 60px"><span>You will get the following output upon successful execution of the code:</span></p>
<div class="CDPAlignCenter CDPAlign"><span><br/>
<img height="57" width="573" src="images/7890e2f2-e44d-4ebf-98d0-61fe12a62639.png"/><br/></span></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a variable named <kbd>child</kbd> in which we called the <kbd>Command</kbd> struct to create the <kbd>child</kbd> process, which is the <kbd>sleep</kbd> statement with an argument with <kbd>5</kbd>. This makes the program sleep or waits for five seconds.</p>
<p>Calling the <kbd>wait</kbd> function will make the parent or the main process wait until the <kbd>child</kbd> process has actually exited before continuing with the other statements of the main process. The mutable <kbd>child</kbd> wait function waits for the command to exit completely and returns the status that it exited with to the <kbd>_result</kbd> variable.</p>
<p>Last, we printed the status of the <kbd>child</kbd> process and marked the end of the main <kbd>thread</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making sequential code parallel</h1>
                </header>
            
            <article>
                
<p>Here, you'll learn about <kbd>rayon</kbd>, an external crate in Rust, whose main aim is to make your sequential code parallel. The best part about <kbd>rayon</kbd> is that it guarantees you that the APIs of <kbd>rayon</kbd> will not introduce any concurrency bugs, such as data race. In this recipe, you will learn about rayon's parallel iterators, which execute iterative statements in parallel.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Follow these steps to download and set up a <kbd><span><span>r</span></span>ayon</kbd> crate in your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor for developing the Rust code <kbd>snippet.<span>cargo</span></kbd>.</li>
<li>Create a new Cargo project named <kbd>sample_rayon</kbd> using:</li>
</ol>
<pre><strong>      cargo new sample_rayon --bin</strong>
</pre>
<p style="padding-left: 90px">You will get the following screenshot as output:</p>
<div style="padding-left: 60px" class="CDPAlignCenter CDPAlign"><img height="36" width="643" src="images/abd0d09f-975d-4c91-85a5-90c957caa665.png"/></div>
<ol start="3">
<li>Enter the newly created <kbd>sample_rayon</kbd> project and check whether the structure is created properly:</li>
</ol>
<pre><strong>        cd sample_rayon/ &amp;&amp; tree .</strong>
</pre>
<p style="padding-left: 90px">You will get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="101" width="431" src="images/e2f0cfe7-4b13-44e8-94c2-5893abc963ad.png"/></div>
<ol start="4">
<li>Open the <kbd>Cargo.toml</kbd> file to download the <kbd>rayon</kbd> crate using:</li>
</ol>
<pre><strong>      nano Cargo.toml</strong>
</pre>
<ol start="5">
<li>Enter the following values in the dependencies tag:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="105" width="496" src="images/b101d263-b840-4f97-a691-acf61207cf6e.png"/></div>
<ol start="6">
<li>Build the project again to download the <kbd>rayon</kbd> crate:</li>
</ol>
<pre><strong>        cargo build</strong>
</pre>
<p style="padding-left: 60px">You will get the following screenshot as output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="206" width="609" src="images/4349ae5a-f680-4c5b-9e59-d5082d809f7c.png"/></div>
<ol start="7">
<li>Check the file structure to see the dependencies installed:</li>
</ol>
<pre><strong>      ls &amp;&amp; tree .</strong>
</pre>
<p style="padding-left: 60px">You will get the following screenshot as output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="252" width="442" src="images/d66506ab-0c53-4263-b480-9ffbe686cdec.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following steps will walk you through the implementation:</p>
<ol>
<li>Create a file named <kbd>sample_rayon.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Making sequential code parallel<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 19 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the external library, named <kbd>rayon</kbd>, which we developed in the <em>Getting ready</em> section:</li>
</ol>
<pre>        // Calling the rayon crate<br/>        extern crate rayon;<br/>        use rayon::prelude::*;
</pre>
<ol start="4">
<li>Define the <kbd>sum_of_squares</kbd> function and accept a variable <kbd>input</kbd> of the type <kbd>i32</kbd>:</li>
</ol>
<pre>        // Sum of squares function<br/>        fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {<br/>          input.par_iter()<br/>          .map(|&amp;i| i * i)<br/>          .sum()<br/>        }
</pre>
<ol start="5">
<li>Define the <kbd>main</kbd> function where we will create <kbd>rand_val</kbd> and assign it the value <kbd>10</kbd>, which we will pass to the <kbd>sum_of_square</kbd> function:</li>
</ol>
<pre>        // Main execution of code<br/>        fn main() {<br/>          // Declaring a random variable of 10<br/>          let rand_val = 10;<br/>          // Calling the method to get sum_of_squares<br/>          let sum_sq = sum_of_squares(&amp;[rand_val]);<br/>          // Printing the result<br/>          println!("Sum of squares of {0} is {1}",rand_val,sum_sq);<br/>        }
</pre>
<p style="padding-left: 60px"><span>You will get the following screenshot as output upon successful execution of the code:</span></p>
<div class="CDPAlignCenter CDPAlign"><span><span><br/>
<img height="30" width="675" src="images/0539ae70-daf0-4903-9c4a-04151e232490.png"/></span></span></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>Since <kbd>rayon</kbd> is an external crate, we first downloaded it using the Cargo tool from the <a href="http://crates.io">crates.io</a> repo site. We used the latest version of <kbd>rayon</kbd>, which is <kbd>0.6.0</kbd>. <kbd>rayon</kbd> currently requires rustc 1.12.0 and is available in <a href="http://crates.io">crates.io</a>. And note, <kbd>rayon</kbd> is an experimental crate.<br/>
<br/>
<kbd>rayon</kbd> has an API called parallel iterators that lets us write iterator processes and execute them in parallel. We implemented the <kbd>sum_of_squares</kbd> function using parallel iterators.</span> To use parallel iterators, we first imported the traits by calling <kbd>use rayon::prelude::*</kbd> to our Rust module. We then called <kbd>par_iter</kbd> to get a parallel iterator, which is similar to a regular iterator. Parallel iterators work by first constructing a computation and then executing it; <kbd>input</kbd> is the parameter of the <span><kbd>sum_of_squares</kbd> function that returns an integer output. We performed the mathematical operation using the <kbd>map</kbd> and <kbd>sum</kbd> methods.</span><br/>
<br/>
In the <kbd>main</kbd> function, we created a variable named <kbd>rand_var</kbd> and assigned it the value <kbd>10</kbd>, which we passed as an argument to the <kbd>sum_of_squares</kbd> function. The return value is stored in the <kbd>sum_sq</kbd> variable and printed.</p>


            </article>

            
        </section>
    </div>
</body>
</html>