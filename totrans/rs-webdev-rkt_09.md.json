["```rs\n    use std::env;\n    ```", "```rs\n    let secret_file_path = env::current_dir().unwrap().join(\"secret_file\");\n    if !secret_file_path.exists() {\n        panic!(\"secret does not exists\");\n    }\n    ```", "```rs\n    thread 'main' panicked at 'secret does not exists', src/main.rs:15:9\n    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n    ```", "```rs\n    RUST_BACKTRACE=1 cargo run \n    Finished dev [unoptimized + debuginfo] target(s) \n        in 0.18s\n         Running `target/debug/our_application`\n    thread 'main' panicked at 'secret does not exists', src/main.rs:15:9\n    stack backtrace:\n    ...\n      14: our_application::main\n                 at ./src/main.rs:12:36\n      15: core::ops::function::FnOnce::call_once\n                 at /rustc/59eed8a2aac0230a8b5\n                 3e89d4e99d55912ba6b35/library/core/\n                 src/ops/function.rs:227:5\n    note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n    ```", "```rs\n    [profile.dev]\n    panic = \"abort\"\n    ```", "```rs\nlet fut = std::panic::catch_unwind(move || run())\n```", "```rs\n         .map_err(|e| panic_info!(name, e))\n```", "```rs\n         .ok()?;\n```", "```rs\nuse rocket::Shutdown;\n```", "```rs\n...\n```", "```rs\n#[get(\"/shutdown\")]\n```", "```rs\npub async fn shutdown(shutdown: Shutdown) -> &'static str {\n```", "```rs\n    // suppose this variable is from function which \n```", "```rs\n    // produces irrecoverable error\n```", "```rs\n    let result: Result<&str, &str> = Err(\"err\");\n```", "```rs\n    if result.is_err() {\n```", "```rs\n        shutdown.notify();\n```", "```rs\n        return \"Shutting down the application.\";\n```", "```rs\n    }\n```", "```rs\n    return \"Not doing anything.\";\n```", "```rs\n}\n```", "```rs\nenum Shapes {\n```", "```rs\n    None,\n```", "```rs\n    Point(i8),\n```", "```rs\n    Line(i8, i8),\n```", "```rs\n    Rectangle {\n```", "```rs\n        top: (i8, i8),\n```", "```rs\n        length: u8,\n```", "```rs\n        height: u8,\n```", "```rs\n    },\n```", "```rs\n}\n```", "```rs\nenum Color {\n```", "```rs\n    Red,         // 0\n```", "```rs\n    Green = 127, // 127\n```", "```rs\n    Blue,        // 128\n```", "```rs\n}\n```", "```rs\nfn do_something(color: Color) -> Shapes {\n```", "```rs\n    let rectangle = Shapes::Rectangle {\n```", "```rs\n        top: (0, 2),\n```", "```rs\n        length: 10,\n```", "```rs\n        height: 8,\n```", "```rs\n    };\n```", "```rs\n    match color {\n```", "```rs\n        Color::Red => Shapes::None,\n```", "```rs\n        Color::Green => Shapes::Point(10),\n```", "```rs\n        _ => rectangle,\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nenum Maybe {\n```", "```rs\n    WeCannotDoIt,\n```", "```rs\n    WeCanDoIt(i8),\n```", "```rs\n}\n```", "```rs\nfn check_divisible(input: i8) -> Maybe {\n```", "```rs\n    if input == 0 {\n```", "```rs\n        return Maybe::WeCannotDoIt;\n```", "```rs\n    }\n```", "```rs\n    Maybe::WeCanDoIt(input)\n```", "```rs\n}\n```", "```rs\npub enum Option<T> {\n```", "```rs\n    None,\n```", "```rs\n    Some(T),\n```", "```rs\n}\n```", "```rs\nstruct User {\n```", "```rs\n    ...\n```", "```rs\n    description: Option<String>,\n```", "```rs\n    ...\n```", "```rs\n}\n```", "```rs\nfind_all(..., pagination: Option<Pagination>) -> (..., Option<Pagination>), ... {}\n```", "```rs\nlet we_have_it: Option<usize> = Some(1);\n```", "```rs\nlet we_do_not_have_it: Option<usize> = None;\n```", "```rs\n    match we_have_it {\n        Some(t) => println!(\"The value = {}\", t),\n        None => println!(\"We don't have it\"),\n    };\n    ```", "```rs\n    if let Some(t) = we_have_it {\n        println!(\"The value = {}\", t);\n    }\n    ```", "```rs\n    assert!(we_have_it != we_do_not_have_it);\n    ```", "```rs\n    assert!(we_have_it.is_some());\n    assert!(we_do_not_have_it.is_none());\n    ```", "```rs\n    assert_eq!(we_have_it.unwrap(), 1);\n    // assert_eq!(we_do_not_have_it.unwrap(), 1); \n    // will panic\n    ```", "```rs\n    assert_eq!(we_have_it.expect(\"Oh no!\"), 1);\n    // assert_eq!(we_do_not_have_it.expect(\"Oh no!\"), 1); // will panic\n    ```", "```rs\n    assert_eq!(we_have_it.unwrap_or(42), 1);\n    assert_eq!(we_do_not_have_it.unwrap_or(42), 42);\n    ```", "```rs\n    let x = 42;\n    assert_eq!(we_have_it.unwrap_or_else(|| x), 1);\n    assert_eq!(we_do_not_have_it.unwrap_or_else(|| x), 42);\n    ```", "```rs\n    assert_eq!(we_have_it.map(|v| format!(\"The value = {}\", v)), Some(\"The value = 1\".to_string()));\n    assert_eq!(we_do_not_have_it.map(|v| format!(\"The value = {}\", v)), None);\n    assert_eq!(we_have_it.map_or(\"Oh no!\".to_string(), |v| format!(\"The value = {}\", v)), \"The value = 1\".to_string());\n    assert_eq!(we_do_not_have_it.map_or(\"Oh no!\".to_string(), |v| format!(\"The value = {}\", v)), \"Oh no!\".to_string());\n    assert_eq!(we_have_it.map_or_else(|| \"Oh no!\".to_string(), |v| format!(\"The value = {}\", v)), \"The value = 1\".to_string());\n    assert_eq!(we_do_not_have_it.map_or_else(|| \"Oh no!\".to_string(), |v| format!(\"The value = {}\", v)), \"Oh no!\".to_string());\n    ```", "```rs\nenum Result<T, E> {\n```", "```rs\n   Ok(T),\n```", "```rs\n   Err(E),\n```", "```rs\n}\n```", "```rs\nfn division(a: usize, b: usize) -> Result<f64, String> {\n```", "```rs\n    if b == 0 {\n```", "```rs\n        return Err(String::from(\"division by zero\"));\n```", "```rs\n    }\n```", "```rs\n    return Ok(a as f64 / b as f64);\n```", "```rs\n}\n```", "```rs\nlet we_have_it: Result<usize, &'static str> = Ok(1);\n```", "```rs\nlet we_have_error: Result<usize, &'static str> = Err(\"Oh no!\");\n```", "```rs\n    match we_have_it {\n        Ok(v) => println!(\"The value = {}\", v),\n        Err(e) => println!(\"The error = {}\", e),\n    };\n    ```", "```rs\n    if let Ok(v) = we_have_it {\n        println!(\"The value = {}\", v);\n    }\n    if let Err(e) = we_have_error {\n        println!(\"The error = {}\", e);\n    }\n    ```", "```rs\n    assert!(we_have_it != we_have_error);\n    ```", "```rs\n    assert!(we_have_it.is_ok());\n    assert!(we_have_error.is_err());\n    ```", "```rs\n    assert_eq!(we_have_it.ok(), Some(1));\n    assert_eq!(we_have_error.ok(), None);\n    assert_eq!(we_have_it.err(), None);\n    assert_eq!(we_have_error.err(), Some(\"Oh no!\"));\n    ```", "```rs\n    assert_eq!(we_have_it.unwrap(), 1);\n    // assert_eq!(we_have_error.unwrap(), 1); \n    // panic\n    assert_eq!(we_have_it.expect(\"Oh no!\"), 1);\n    // assert_eq!(we_have_error.expect(\"Oh no!\"), 1);\n    // panic\n    assert_eq!(we_have_it.unwrap_or(0), 1);\n    assert_eq!(we_have_error.unwrap_or(0), 0);\n    assert_eq!(we_have_it.unwrap_or_else(|_| 0), 1);\n    assert_eq!(we_have_error.unwrap_or_else(|_| 0), 0);\n    ```", "```rs\n    assert_eq!(we_have_it.map(|v| format!(\"The value = {}\", v)), Ok(\"The value = 1\".to_string()));\n    assert_eq!(\n        we_have_error.map(|v| format!(\"The error = {}\", \n        v)),\n        Err(\"Oh no!\")\n    );\n    assert_eq!(we_have_it.map_err(|s| s.len()), Ok(1));\n    assert_eq!(we_have_error.map_err(|s| s.len()), Err(6));\n    assert_eq!(we_have_it.map_or(\"Default value\".to_string(), |v| format!(\"The value = {}\", v)), \"The value = 1\".to_string());\n    assert_eq!(we_have_error.map_or(\"Default value\".to_string(), |v| format!(\"The value = {}\", v)), \"Default value\".to_string());\n    assert_eq!(we_have_it.map_or_else(|_| \"Default value\".to_string(), |v| format!(\"The value = {}\", v)), \"The value = 1\".to_string());\n    assert_eq!(we_have_error.map_or_else(|_| \"Default value\".to_string(), |v| format!(\"The value = {}\", v)), \"Default value\".to_string());\n    ```", "```rs\n    pub mod errors;\n    ```", "```rs\n    pub mod our_error;\n    ```", "```rs\n    use rocket::http::Status;\n    use std::error::Error;\n    use std::fmt;\n    #[derive(Debug)]\n    pub struct OurError {\n        pub status: Status,\n        pub message: String,\n        debug: Option<Box<dyn Error>>,\n    }\n    impl fmt::Display for OurError {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> \n        fmt::Result {\n            write!(f, \"{}\", &self.message)\n        }\n    }\n    ```", "```rs\n    impl Error for OurError {\n        fn source(&self) -> Option<&(dyn Error + 'static)> {\n            if self.debug.is_some() {\n                self.debug.as_ref().unwrap().source();\n            }\n            None\n        }\n    }\n    ```", "```rs\n    impl OurError {\n        fn new_error_with_status(status: Status, message: \n        String, debug: Option<Box<dyn Error>>) -> Self {\n            OurError {\n                status,\n                message,\n                debug,\n            }\n        }\n        pub fn new_bad_request_error(message: String, \n        debug: Option<Box<dyn Error>>) -> Self {\n            Self::new_error_with_status(Status::\n            BadRequest, message, debug)\n        }\n        pub fn new_not_found_error(message: String,\n        debug: Option<Box<dyn Error>>) -> Self {\n            Self::new_error_with_status(Status::NotFound, \n            message, debug)\n        }\n        pub fn new_internal_server_error(\n            message: String,\n            debug: Option<Box<dyn Error>>,\n        ) -> Self {\n            Self::new_error_with_status(Status::\n            InternalServerError, message, debug)\n        }\n    }\n    ```", "```rs\n    use sqlx::Error as sqlxError;\n    use uuid::Error as uuidError;\n    ```", "```rs\n    impl OurError {\n        ...\n        pub fn from_uuid_error(e: uuidError) -> Self {\n            OurError::new_bad_request_error(\n                String::from(\"Something went wrong\"),\n                Some(Box::new(e)))\n        }\n    }\n    ```", "```rs\n    use std::borrow::Cow;\n    ....\n    impl OurError {\n        ....\n        pub fn from_sqlx_error(e: sqlxError) -> Self {\n            match e {\n                sqlxError::RowNotFound => {\n                    OurError::new_not_found_error(\n                        String::from(\"Not found\"),\n                        Some(Box::new(e)))\n                }\n                sqlxError::Database(db) => {\n                    if db.code().unwrap_or(Cow::\n                    Borrowed(\"2300\")).starts_with(\"23\") {\n                        return OurError::new_bad_\n                        request_error(\n                            String::from(\"Cannot create or \n                            update resource\"),\n                            Some(Box::new(db)),\n                        );\n                    }\n                    OurError::new_internal_server_error(\n                        String::from(\"Something went \n                        wrong\"),\n                        Some(Box::new(db)),\n                    )\n                }\n                _ => OurError::new_internal_server_error(\n                    String::from(\"Something went wrong\"),\n                    Some(Box::new(e)),\n                ),\n            }\n        }\n    }\n    ```", "```rs\n    argon2 = {version = \"0.3\", features = [\"std\"]}\n    ```", "```rs\n    pub async fn find(connection: &mut PgConnection, uuid: &str) -> Result<Self, OurError> {\n        let parsed_uuid = Uuid::parse_str(\n        uuid).map_err(OurError::from_uuid_error)?;\n        let query_str = \"SELECT * FROM users WHERE uuid = \n        $1\";\n        Ok(sqlx::query_as::<_, Self>(query_str)\n            .bind(parsed_uuid)\n            .fetch_one(connection)\n            .await\n            .map_err(OurError::from_sqlx_error)?)\n    }\n    ```", "```rs\n    let password_hash = argon2\n        .hash_password(new_user.password.as_bytes(), \n         &salt)\n        .map_err(|e| {\n            OurError::new_internal_server_error(\n                String::from(\"Something went wrong\"),\n                Some(Box::new(e)),\n            )\n        })?;\n    ```", "```rs\n    pub async fn get_user(...) -> HtmlResponse {\n    ...\n        let user = User::find(connection, \n        uuid).await.map_err(|e| e.status)?;\n    ...\n    }\n    ...\n    pub async fn delete_user(...) -> Result<Flash<Redirect>, Flash<Redirect>> {\n    ...\n        User::destroy(connection, uuid)\n            .await\n            .map_err(|e| Flash::error(Redirect::to(\"/\n             users\"), format!(\"<div>{}</div>\", e)))?;\n    ...\n    }\n    ```", "```rs\n    async-log = \"2.0.0\"\n    fern = \"0.6\"\n    log = \"0.4\"\n    ```", "```rs\n    log_level = \"normal\"\n    ```", "```rs\n    fn setup_logger() {}\n    ```", "```rs\n    use log::LevelFilter;\n    ...\n    let (level, logger) = fern::Dispatch::new()\n        .format(move |out, message, record| {\n            out.finish(format_args!(\n                \"[{date}] [{level}][{target}] [{\n                 message}]\",\n                date = chrono::Local::now().format(\"[\n                %Y-%m-%d][%H:%M:%S%.3f]\"),\n                target = record.target(),\n                level = record.level(),\n                message = message\n            ))\n        })\n        .level(LevelFilter::Info)\n        .chain(std::io::stdout())\n        .chain(\n            fern::log_file(\"logs/application.log\")\n                .unwrap_or_else(|_| panic!(\"Cannot open \n                logs/application.log\")),\n        )\n        .into_log();\n    ```", "```rs\n    async_log::Logger::wrap(logger, || 0).start(level).unwrap();\n    ```", "```rs\n    impl OurError {\n        fn new_error_with_status(...) ... {\n            if debug.is_some() {\n                log::error!(\"Error: {:?}\", &debug);\n            }\n            ...\n        }\n    }\n    ```", "```rs\n    async fn rocket() -> Rocket<Build> {\n        setup_logger();\n    ...\n    }\n    ```", "```rs\n    [[2021-11-21][17:50:49.366]] [ERROR][our_application::errors::our_error]\n    [Error: Some(PgDatabaseError { severity: Error, code: \"23505\", message:\n    \"duplicate key value violates unique constraint \\\"users_username_key\\\"\"\n    , detail: Some(\"Key (username)=(karuna) already exists.\"), hint: None, p\n    osition: None, where: None, schema: Some(\"public\"), table: Some(\"users\")\n    , column: None, data_type: None, constraint: Some(\"users_username_key\"),\n    file: Some(\"nbtinsert.c\"), line: Some(649), routine: Some(\"_bt_check_un\n    ique\") })]\n    ```"]