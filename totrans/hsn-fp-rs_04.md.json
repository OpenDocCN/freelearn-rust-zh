["```rs\nstruct Cat\n{\n   weight: f64,\n   speed: f64\n}\n\nstruct Dog\n{\n   weight: f64,\n   speed: f64\n}\n```", "```rs\ntrait Animal\n{\n   fn max_speed(&self) -> f64;\n}\n\nimpl Animal for Cat\n{\n   fn max_speed(&self) -> f64\n   {\n      self.speed\n   }\n}\n\nimpl Animal for Dog\n{\n   fn max_speed(&self) -> f64\n   {\n      self.speed\n   }\n}\n```", "```rs\nstruct SqueakyToy\n{\n   weight: f64\n}\n\nstruct Stick\n{\n   weight: f64\n}\n\ntrait Toy\n{\n   fn weight(&self) -> f64;\n}\n\nimpl Toy for SqueakyToy\n{\n   fn weight(&self) -> f64\n   {\n      self.weight\n   }\n}\n\nimpl Toy for Stick\n{\n   fn weight(&self) -> f64\n   {\n      self.weight\n   }\n}\n```", "```rs\nstruct AnimalChasingToy<A: Animal, T: Toy>\n{\n   animal: A,\n   toy: T\n}\n\ntrait AnimalChasesToy<A: Animal, T: Toy>\n{\n   fn chase(&self);\n}\n\nimpl<A: Animal, T: Toy> AnimalChasesToy<A, T> for AnimalChasingToy<A, T>\n{\n   fn chase(&self)\n   {\n      println!(\"chase\")\n   }\n}\n```", "```rs\nfn raise_by_three<T: Mul + Copy>(x: T) -> T\nwhere T: std::ops::Mul<Output=T>\n{\n   x * x * x\n}\n```", "```rs\nraise_by_three(10);\n(10 as u64).pow(3);\n\nraise_by_three(3.0);\n(3.0 as f64).powi(3);\n```", "```rs\n#[derive(Copy,Clone)]\nstruct Raiseable<T: Mul + Copy>\n{\n   x: T\n}\n\nimpl<T: Mul + Copy> std::ops::Mul for Raiseable<T>\nwhere T: std::ops::Mul<Output=T>\n{\n   type Output = Raiseable<T>;\n   fn mul(self, rhs: Self) -> Self::Output\n   {\n      Raiseable { x: self.x * rhs.x }\n   }\n}\n\nlet x = Raiseable { x: 10 as u64 };\nraise_by_three(x);\n//no method named pow\n//x.pow(3);\n\n```", "```rs\n\nlet x = Raiseable { x: 3.0 as f64 };\nraise_by_three(x);\n//no method named powi\n//x.powi(3); \n```", "```rs\nimpl<K: Hash + Eq, V> HashMap<K, V, RandomState>\n```", "```rs\nfn foo<X>(x: X) -> X\n{\n   x\n}\n\nfn bar<X>(f: fn(X) -> X, x: X) -> X\n{\n   f(x)\n}\n\nfoo(1);\nbar(foo,1);\n```", "```rs\nfn baz<X,F>(f: F, x: X) -> X\nwhere F: Fn(X) -> X\n{\n   f(x)\n}\n\nbaz(|x| x, 1);\nbaz(foo, 1);\n```", "```rs\nstruct JSJIT(u64);\n\nenum JSJITorExpr {\n   Jit { label: Box<JSJIT> },\n   Expr { expr: Box<JSExpr> }\n}\n\nenum JSExpr {\n   Integer { value: u64 },\n   String { value: String },\n   OperatorAdd { lexpr: Box<JSJITorExpr>, rexpr: Box<JSJITorExpr> },\n   OperatorMul { lexpr: Box<JSJITorExpr>, rexpr: Box<JSJITorExpr> }\n}\n```", "```rs\nfn jump(l: JSJIT) -> JSJITorExpr\n{\n   //jump to compiled code\n   //this depends on implementation\n   //so we will just leave this as a stub\n   JSJITorExpr::Jit { label: JSJIT(0) }\n}\n\nfn eval(e: JSJITorExpr) -> JSJITorExpr\n{\n   match e\n   {\n      JSJITorExpr::Jit { label: label } => jump(label),\n      JSJITorExpr::Expr { expr: expr } => {\n         let rawexpr = *expr;\n         match rawexpr\n         {\n            JSExpr::Integer {..} => JSJITorExpr::Expr { expr: Box::new(rawexpr) },\n            JSExpr::String {..} => JSJITorExpr::Expr { expr: Box::new(rawexpr) },\n            JSExpr::OperatorAdd { lexpr: l, rexpr: r } => {\n               let l = eval(*l);\n               let r = eval(*r);\n               //call add op codes for possible l,r representations\n               //should return wrapped value from above\n               JSJITorExpr::Jit { label: JSJIT(0) }\n            }\n            JSExpr::OperatorMul { lexpr: l, rexpr: r } => {\n               let l = eval(*l);\n               let r = eval(*r);\n               //call mul op codes for possible l,r representations\n               //should return wrapped value from above\n               JSJITorExpr::Jit { label: JSJIT(0) }\n            }\n         }\n      }\n   }\n}\n```", "```rs\npub trait HList: Sized {}\n\npub struct HNil;\nimpl HList for HNil {}\n\npub struct HCons<H, T> {\n   pub head: H,\n   pub tail: T,\n}\nimpl<H, T: HList> HList for HCons<H, T> {}\nimpl<H, T> HCons<H, T> {\n   pub fn pop(self) -> (H, T) {\n      (self.head, self.tail)\n   }\n}\n```", "```rs\nlet hl = HCons {\n   head: 2,\n   tail: HCons {\n      head: \"abcd\".to_string(),\n      tail: HNil\n   }\n};\n\nlet (h1,t1) = hl.pop();\nlet (h2,t2) = t1.pop();\n//this would fail\n//HNil has no .pop method\n//t2.pop();\n```", "```rs\nfn ground_lifetime<'a>(x: &'a u64) -> &'a u64\n{\n   x\n}\n\nlet x = 3;\nground_lifetime(&x);\n```", "```rs\nstruct Ref<'a, T>(&'a T);\n```", "```rs\nstruct Ref<'a, T: 'a>(&'a T);\n```", "```rs\ntrait Red { }\n\nstruct Ball<'a> {\n   diameter: &'a i32,\n}\n\nimpl<'a> Red for Ball<'a> { }\n\nstatic num: i32 = 5;\nlet obj = Box::new(Ball { diameter: &num }) as Box<Red + 'static>;\n```", "```rs\nstruct Context<'s>(&'s mut String);\n\nimpl<'s> Context<'s>\n{\n   fn mutate<'c>(&mut self, cs: &'c mut String) -> &'c mut String\n```", "```rs\n\n   {\n      let swap_a = self.0.pop().unwrap();\n      let swap_b = cs.pop().unwrap();\n      self.0.push(swap_b);\n      cs.push(swap_a);\n      cs\n   }\n}\n\nfn main() {\n   let mut s = \"outside string context abc\".to_string();\n   {\n      //temporary context\n      let mut c = Context(&mut s);\n      {\n         //further temporary context\n         let mut s2 = \"inside string context def\".to_string();\n         c.mutate(&mut s2);\n         println!(\"s2 {}\", s2);\n      }\n   }\n   println!(\"s {}\", s);\n}\n```", "```rs\ntype TFoo<'a, A: 'a> = (&'a A, u64);\n\nstruct SFoo<'a, A: 'a>(&'a A);\n\nstruct SBar<'a, A: 'a>\n{\n   x: &'a A\n}\n\nenum EFoo<'a, A: 'a>\n{\n   X { x: &'a A },\n   Y { y: &'a A },\n```", "```rs\n\n}\n```", "```rs\nstruct SBaz<'a, 'b, A: 'a, B: 'b>\n{\n   a: &'a A,\n   b: &'b B,\n}\n\ntrait TBaz<'a, 'b, A: 'a, B: 'b>\n{\n   fn baz(&self);\n}\n\nimpl<'a, 'b, A: 'a, B: 'b>\nTBaz<'a, 'b, A, B>\nfor SBaz<'a, 'b, A, B>\n{\n   fn baz(&self){}\n}\n```", "```rs\ntrait Foo {\n   fn f(&self);\n}\n\ntrait Bar {\n   fn f(&self);\n}\n\nstruct Baz;\n\nimpl Foo for Baz {\n   fn f(&self) { println!(\"Baz’s impl of Foo\"); }\n}\n\nimpl Bar for Baz {\n   fn f(&self) { println!(\"Baz’s impl of Bar\"); }\n}\n```", "```rs\n\nlet b = Baz;\n```", "```rs\nFoo::f(&b);\nBar::f(&b);\n\n<Baz as Foo>::f(&b);\n<Baz as Bar>::f(&b);\n```", "```rs\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub enum MotorInput\n{\n   Up { voltage: f64 },\n   Down { voltage: f64 }\n}\n\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub struct ElevatorSpecification\n{\n   pub floor_count: u64,\n   pub floor_height: f64,\n```", "```rs\n\n   pub carriage_weight: f64\n}\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub struct ElevatorState\n{\n   pub timestamp: f64,\n   pub location: f64,\n   pub velocity: f64,\n   pub acceleration: f64,\n   pub motor_input: MotorInput\n}\n\npub type FloorRequests = Vec<u64>;\n```", "```rs\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub struct ElevatorState<MI: MotorForce + MotorVoltage + Clone, 'a serde::Serialize, 'a serde::Deserialize + Debug>\n{\n   pub timestamp: f64,\n   pub location: f64,\n   pub velocity: f64,\n   pub acceleration: f64,\n   pub motor_input: MI\n}\n```", "```rs\npub trait MotorController\n<MI: MotorForce + MotorVoltage + Clone, 'a serde::Serialize, 'a serde::Deserialize + Debug>\n{\n   fn init(&mut self, esp: ElevatorSpecification, est: ElevatorState<MI>);\n   fn poll(&mut self, est: ElevatorState<MI>, dst: u64) -> MI;\n```", "```rs\n\n}\n\npub trait DataRecorder\n<MI: MotorForce + MotorVoltage + Clone, 'a serde::Serialize, 'a serde::Deserialize + Debug>\n{\n   fn init(&mut self, esp: ElevatorSpecification, est: ElevatorState<MI>);\n   fn poll(&mut self, est: ElevatorState<MI>, dst: u64);\n}\n\nimpl MotorController\n<MI: MotorForce + MotorVoltage + Clone, 'a serde::Serialize, 'a serde::Deserialize + Debug>\nfor SimpleMotorController\n<MI: MotorForce + MotorVoltage + Clone, 'a serde::Serialize, 'a serde::Deserialize + Debug>\n{\n   ...\n} \n```", "```rs\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub enum SimpleMotorInput\n{\n   Up { voltage: f64 },\n   Down { voltage: f64 }\n}\n\npub trait MotorInput: MotorForce + MotorVoltage\n{\n}\n\n```", "```rs\n\nimpl MotorInput for SimpleMotorInput {}\npub struct ElevatorState\n{\n   pub timestamp: f64,\n   pub location: f64,\n   pub velocity: f64,\n   pub acceleration: f64,\n   pub motor_input: Box<MotorInput>\n}\n```", "```rs\nlet target_voltage = target_force / 8.0;\n```", "```rs\npub fn force_of_voltage(v: f64) -> f64\n{\n   8.0 * v\n}\n\npub fn voltage_of_force(v: f64) -> f64\n{\n   v / 8.0\n}\n```", "```rs\npub trait Motor\n{\n   fn force_of_voltage(&self, v: f64) -> f64;\n   fn voltage_of_force(&self, v: f64) -> f64;\n}\n\npub struct SimpleMotor;\nimpl Motor for SimpleMotor\n{\n   fn force_of_voltage(&self, v: f64) -> f64\n   {\n      8.0 * v\n   }\n   fn voltage_of_force(&self, v: f64) -> f64\n   {\n      v / 8.0\n   }\n}\n```", "```rs\npub struct ElevatorSpecification\n{\n   pub floor_count: u64,\n   pub floor_height: f64,\n   pub carriage_weight: f64,\n   pub motor: Box<Motor>\n}\n```", "```rs\nlet target_voltage = self.esp.motor.voltage_of_force(target_force);\n```", "```rs\npub trait ElevatorStateClone\n{\n   fn clone(&self) -> ElevatorState;\n   fn dump(&self) -> (f64,f64,f64,f64,f64);\n   fn load((f64,f64,f64,f64,f64)) -> ElevatorState;\n}\n\npub trait ElevatorSpecificationClone\n{\n   fn clone(&self) -> ElevatorSpecification;\n   fn dump(&self) -> (u64,f64,f64,u64);\n   fn load((u64,f64,f64,u64)) -> ElevatorSpecification;\n}\n\nimpl ElevatorStateClone for ElevatorState {\n   ...\n}\n```", "```rs\n#[derive(Serialize,Deserialize)]\nstruct Foo\n{\n   bar: Box<u64>\n}\n```", "```rs\ntrait T {}\n\n#[derive(Serialize,Deserialize)]\nstruct S1;\nimpl T for S1 {}\n\n#[derive(Serialize,Deserialize)]\nstruct S2;\nimpl T for S2 {}\n\n#[derive(Serialize,Deserialize)]\nstruct Container\n{\n   field: Box<T>\n}\n```", "```rs\nimpl Serialize for Box<T>\n{\n   fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n   where S: Serializer\n   {\n      serializer.serialize_unit_struct(\"S1\")\n   }\n}\n\nstruct S1Visitor;\nimpl<'de> Visitor<'de> for S1Visitor {\n   type Value = Box<T>;\n\n   fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result\n   {\n      formatter.write_str(\"an S1 structure\")\n   }\n   fn visit_unit<E>(self) -> Result<Self::Value, E>\n   where E: de::Error\n```", "```rs\n\n   {\n      Result::Ok(Box::new(S1))\n   }\n}\n\nimpl<'de> Deserialize<'de> for Box<T> {\n   fn deserialize<D>(deserializer: D) -> Result<Box<T>, D::Error>\n   where D: Deserializer<'de>\n   {\n      deserializer.deserialize_unit_struct(\"S1\", S1Visitor)\n   }\n}\n\nlet bt: Box<T> = Box::new(S1);\nlet s = serde_json::to_string(&bt).unwrap();\nlet bt: Box<T> = serde_json::from_str(s.as_str()).unwrap();\n```", "```rs\n#[derive(Clone,Serialize,Deserialize)]\nenum T_Enum\n{\n   S1(S1),\n   S2(S2),\n}\n\ntrait T\n{\n   fn as_enum(&self) -> T_Enum;\n}\n\n#[derive(Clone,Serialize,Deserialize)]\nstruct S1;\nimpl T for S1\n{\n   fn as_enum(&self) -> T_Enum\n   {\n      T_Enum::S1(self.clone())\n   }\n```", "```rs\n\n}\n#[derive(Clone,Serialize,Deserialize)]\nstruct S2;\nimpl T for S2\n{\n   fn as_enum(&self) -> T_Enum\n   {\n      T_Enum::S2(self.clone())\n   }\n}\n```", "```rs\nimpl Serialize for Box<T>\n{\n   fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n   where S: Serializer\n   {\n      self.as_enum().serialize(serializer)\n   }\n}\n\nimpl<'de> Deserialize<'de> for Box<T>\n{\n   fn deserialize<D>(deserializer: D) -> Result<Box<T>, D::Error>\n   where D: Deserializer<'de>\n   {\n      let result = T_Enum::deserialize(deserializer);\n      match result\n      {\n         Result::Ok(te) => {\n            match te {\n               T_Enum::S1(s1) => Result::Ok(Box::new(s1.clone())),\n               T_Enum::S2(s2) => Result::Ok(Box::new(s2.clone()))\n            }\n         }\n         Result::Err(err) => Result::Err(err)\n      }\n   }\n}\n```"]