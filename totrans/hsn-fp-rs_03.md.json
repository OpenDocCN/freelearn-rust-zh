["```rs\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub enum MotorInput\n{\n   Up { voltage: f64 },\n   Down { voltage: f64 }\n}\n\npub trait MotorForce {\n   fn calculate_force(&self) -> f64;\n}\n\nimpl MotorForce for MotorInput {\n   fn calculate_force(&self) -> f64\n   {\n      match *self {\n         MotorInput::Up { voltage: v } => { v * 8.0 }\n         MotorInput::Down { voltage: v } => { v * -8.0 }\n      }\n   }\n}\n\npub trait MotorVoltage {\n   fn voltage(&self) -> f64;\n}\n\nimpl MotorVoltage for MotorInput {\n   fn voltage(&self) -> f64\n   {\n      match *self {\n         MotorInput::Up { voltage: v } => { v }\n         MotorInput::Down { voltage: v } => { -v }\n      }\n   }\n} \n```", "```rs\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub struct ElevatorSpecification\n{\n   pub floor_count: u64,\n   pub floor_height: f64,\n   pub carriage_weight: f64\n}\n\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub struct ElevatorState\n{\n   pub timestamp: f64,\n   pub location: f64,\n   pub velocity: f64,\n   pub acceleration: f64,\n   pub motor_input: MotorInput\n}\n\npub type FloorRequests = Vec<u64>;\n```", "```rs\npub trait MotorController\n{\n   fn init(&mut self, esp: ElevatorSpecification, est: ElevatorState);\n   fn poll(&mut self, est: ElevatorState, dst: u64) -> MotorInput;\n}\n\npub trait DataRecorder\n{\n   fn init(&mut self, esp: ElevatorSpecification, est: ElevatorState);\n   fn poll(&mut self, est: ElevatorState, dst: u64);\n   fn summary(&mut self);\n}\n```", "```rs\npub fn simulate_elevator<MC: MotorController, DR: DataRecorder>(esp: ElevatorSpecification, est: ElevatorState, req: FloorRequests,\n                         mc: &mut MC, dr: &mut DR) {\n\n   //immutable input becomes mutable local state\n   let mut esp = esp.clone();\n   let mut est = est.clone();\n   let mut req = req.clone();\n\n   //initialize MotorController and DataController\n   mc.init(esp.clone(), est.clone());\n   dr.init(esp.clone(), est.clone());\n\n   //5\\. Loop while there are remaining floor requests\n   let original_ts = Instant::now();\n   thread::sleep(time::Duration::from_millis(1));\n   while req.len() > 0\n   {\n      //5.1\\. Update location, velocity, and acceleration\n      let now = Instant::now();\n      let ts = now.duration_since(original_ts)\n                  .as_fractional_secs();\n      let dt = ts - est.timestamp;\n      est.timestamp = ts;\n\n      est.location = est.location + est.velocity * dt;\n      est.velocity = est.velocity + est.acceleration * dt;\n      est.acceleration = {\n         let F = est.motor_input.calculate_force();\n         let m = esp.carriage_weight;\n         -9.8 + F/m\n      };\n```", "```rs\n      //5.2\\. If next floor request in queue is satisfied, \n          then remove from queue\n      let next_floor = req[0];\n      if (est.location - (next_floor as f64)*esp.floor_height).abs() \n         < 0.01 &&\n         est.velocity.abs() < 0.01\n      {\n         est.velocity = 0.0;\n         req.remove(0);\n        //remove is an O(n) operation\n        //Vec should not be used like this for large data\n      }\n\n      //5.4\\. Print realtime statistics\n      dr.poll(est.clone(), next_floor);\n\n      //5.3\\. Adjust motor control to process next floor request\n      est.motor_input = mc.poll(est.clone(), next_floor);\n\n      thread::sleep(time::Duration::from_millis(1));\n   }\n}\n```", "```rs\npub struct SimpleMotorController\n{\n   pub esp: ElevatorSpecification\n}\n\nimpl MotorController for SimpleMotorController\n{\n   fn init(&mut self, esp: ElevatorSpecification, est: ElevatorState)\n   {\n      self.esp = esp;\n   }\n\n   fn poll(&mut self, est: ElevatorState, dst: u64) -> MotorInput\n   {\n      //5.3\\. Adjust motor control to process next floor request\n\n      //it will take t seconds to decelerate from velocity v \n        at -1 m/s^2\n      let t = est.velocity.abs() / 1.0;\n\n      //during which time, the carriage will travel d=t * v/2 meters\n      //at an average velocity of v/2 before stopping\n      let d = t * (est.velocity/2.0);\n\n      //l = distance to next floor\n      let l = (est.location - (dst as \n          f64)*self.esp.floor_height).abs();     \n```", "```rs\n      let target_acceleration = {\n         //are we going up?\n         let going_up = est.location < (dst as \n            f64)*self.esp.floor_height;\n\n         //Do not exceed maximum velocity\n         if est.velocity.abs() >= 5.0 {\n            if going_up==(est.velocity>0.0) {\n               0.0\n            //decelerate if going in wrong direction\n            } else if going_up {\n               1.0\n            } else {\n               -1.0\n            }\n\n         //if within comfortable deceleration range and moving \n             in right direction, decelerate\n         } else if l < d && going_up==(est.velocity>0.0) {\n            if going_up {\n               -1.0\n            } else {\n               1.0\n            }\n\n         //else if not at peak velocity, accelerate\n         } else {\n            if going_up {\n               1.0\n            } else {\n               -1.0\n            }\n         }\n      };      \n```", "```rs\n      let gravity_adjusted_acceleration = target_acceleration + 9.8;\n      let target_force = gravity_adjusted_acceleration * \n             self.esp.carriage_weight;\n      let target_voltage = target_force / 8.0;\n      if target_voltage > 0.0 {\n         MotorInput::Up { voltage: target_voltage }\n      } else {\n         MotorInput::Down { voltage: target_voltage.abs() }\n      }\n   }\n}\n```", "```rs\nconst MAX_JERK: f64 = 0.2;\nconst MAX_ACCELERATION: f64 = 2.0;\nconst MAX_VELOCITY: f64 = 5.0;\n\npub struct SmoothMotorController\n{\n   pub esp: ElevatorSpecification,\n   pub timestamp: f64\n}\n\nimpl MotorController for SmoothMotorController\n{\n   fn init(&mut self, esp: ElevatorSpecification, est: ElevatorState)\n   {\n      self.esp = esp;\n      self.timestamp = est.timestamp;\n   }\n\n   fn poll(&mut self, est: ElevatorState, dst: u64) -> MotorInput\n   {\n      //5.3\\. Adjust motor control to process next floor request\n\n      //it will take t seconds to reach max from max\n      let t_accel = MAX_ACCELERATION / MAX_JERK;\n      let t_veloc = MAX_VELOCITY / MAX_ACCELERATION;\n\n      //it may take up to d meters to decelerate from current\n      let decel_t = if (est.velocity>0.0) == (est.acceleration>0.0) {\n         //this case deliberately overestimates d to prevent \"back up\"\n         (est.acceleration.abs() / MAX_JERK) +\n         (est.velocity.abs() / (MAX_ACCELERATION / 2.0)) +\n         2.0 * (MAX_ACCELERATION / MAX_JERK)\n      } else {\n         //without the MAX_JERK, this approaches infinity and \n            decelerates way too soon\n         //MAX_JERK * 1s = acceleration in m/s^2\n         est.velocity.abs() / (MAX_JERK + est.acceleration.abs())\n      };\n      let d = est.velocity.abs() * decel_t;\n\n      //l = distance to next floor\n      let l = (est.location - (dst as \n              f64)*self.esp.floor_height).abs();\n```", "```rs\n      let target_acceleration = {\n         //are we going up?\n         let going_up = est.location < (dst as \n             f64)*self.esp.floor_height;\n\n         //time elapsed since last poll\n         let dt = est.timestamp - self.timestamp;\n         self.timestamp = est.timestamp;\n\n         //Do not exceed maximum acceleration\n         if est.acceleration.abs() >= MAX_ACCELERATION {\n            if est.acceleration > 0.0 {\n               est.acceleration - (dt * MAX_JERK)\n            } else {\n               est.acceleration + (dt * MAX_JERK)\n            }\n\n         //Do not exceed maximum velocity\n         } else if est.velocity.abs() >= MAX_VELOCITY\n            || (est.velocity + est.acceleration * \n               (est.acceleration.abs() / MAX_JERK)).abs() >= \n                          MAX_VELOCITY {\n            if est.velocity > 0.0 {\n               est.acceleration - (dt * MAX_JERK)\n            } else {\n               est.acceleration + (dt * MAX_JERK)\n            }\n\n         //if within comfortable deceleration range and \n             moving in right direction, decelerate\n         } else if l < d && (est.velocity>0.0) == going_up {\n            if going_up {\n               est.acceleration - (dt * MAX_JERK)\n            } else {\n               est.acceleration + (dt * MAX_JERK)\n            }\n\n         //else if not at peak velocity, accelerate smoothly\n         } else {\n            if going_up {\n               est.acceleration + (dt * MAX_JERK)\n            } else {\n               est.acceleration - (dt * MAX_JERK)\n            }\n         }\n      };\n```", "```rs\n      let gravity_adjusted_acceleration = target_acceleration + 9.8;\n      let target_force = gravity_adjusted_acceleration\n            * self.esp.carriage_weight;\n      let target_voltage = target_force / 8.0;\n      if !target_voltage.is_finite() {\n         //divide by zero etc.\n         //may happen if time delta underflows\n         MotorInput::Up { voltage: 0.0 }\n      } else if target_voltage > 0.0 {\n         MotorInput::Up { voltage: target_voltage }\n      } else {\n         MotorInput::Down { voltage: target_voltage.abs() }\n      }\n   }\n}\n```", "```rs\npub fn run_simulation()\n{\n\n   //1\\. Store location, velocity, and acceleration state\n   //2\\. Store motor input voltage\n   let mut est = ElevatorState {\n      timestamp: 0.0,\n      location: 0.0,\n      velocity: 0.0,\n      acceleration: 0.0,\n      motor_input: MotorInput::Up {\n         //a positive force is required to counter gravity and\n         voltage: 9.8 * (120000.0 / 8.0)\n      }\n   };\n\n   //3\\. Store input building description and floor requests\n   let mut esp = ElevatorSpecification {\n      floor_count: 0,\n      floor_height: 0.0,\n      carriage_weight: 120000.0\n   };\n   let mut floor_requests = Vec::new();\n\n   //4\\. Parse input and store as building description\n           and floor requests\n   let buffer = match env::args().nth(1) {\n      Some(ref fp) if *fp == \"-\".to_string()  => {\n         let mut buffer = String::new();\n         io::stdin().read_to_string(&mut buffer)\n                    .expect(\"read_to_string failed\");\n         buffer\n      },\n      None => {\n         let fp = \"test1.txt\";\n         let mut buffer = String::new();\n         File::open(fp)\n              .expect(\"File::open failed\")\n              .read_to_string(&mut buffer)\n              .expect(\"read_to_string failed\");\n         buffer\n      },\n      Some(fp) => {\n         let mut buffer = String::new();\n         File::open(fp)\n              .expect(\"File::open failed\")\n              .read_to_string(&mut buffer)\n              .expect(\"read_to_string failed\");\n         buffer\n      }\n   };\n   for (li,l) in buffer.lines().enumerate() {\n      if li==0 {\n         esp.floor_count = l.parse::<u64>().unwrap();\n      } else if li==1 {\n         esp.floor_height = l.parse::<f64>().unwrap();\n      } else {\n         floor_requests.push(l.parse::<u64>().unwrap());\n      }\n   }  \n```", "```rs\n   let termsize = termion::terminal_size().ok();\n   let mut dr = SimpleDataRecorder {\n      esp: esp.clone(),\n      termwidth: termsize.map(|(w,_)| w-2).expect(\"termwidth\") \n         as u64,\n      termheight: termsize.map(|(_,h)| h-2).expect(\"termheight\")\n         as u64,\n      stdout: &mut io::stdout().into_raw_mode().unwrap(),\n      log: File::create(\"simulation.log\").expect(\"log file\"),\n      record_location: Vec::new(),\n      record_velocity: Vec::new(),\n      record_acceleration: Vec::new(),\n      record_voltage: Vec::new()\n   };\n   /*\n   let mut mc = SimpleMotorController {\n      esp: esp.clone()\n   };\n   */\n   let mut mc = SmoothMotorController {\n      timestamp: 0.0,\n      esp: esp.clone()\n   };\n\n   simulate_elevator(esp, est, floor_requests, &mut mc, &mut dr);\n   dr.summary();\n\n}\n```", "```rs\nstruct SimpleDataRecorder<'a, W: 'a + Write>\n{\n   esp: ElevatorSpecification,\n   termwidth: u64,\n   termheight: u64,\n   stdout: &'a mut raw::RawTerminal<W>,\n   log: File,\n   record_location: Vec<f64>,\n   record_velocity: Vec<f64>,\n   record_acceleration: Vec<f64>,\n   record_voltage: Vec<f64>,\n}\nimpl<'a, W: Write> DataRecorder for SimpleDataRecorder<'a, W>\n{\n   fn init(&mut self, esp: ElevatorSpecification, est: ElevatorState)\n   {\n      self.esp = esp.clone();\n      self.log.write_all(serde_json::to_string(&esp).unwrap().as_bytes()).expect(\"write spec to log\");\n      self.log.write_all(b\"\\r\\n\").expect(\"write spec to log\");\n   }\n   fn poll(&mut self, est: ElevatorState, dst: u64)\n   {\n      let datum = (est.clone(), dst);\n      self.log.write_all(serde_json::to_string(&datum).unwrap().as_bytes()).expect(\"write state to log\");\n      self.log.write_all(b\"\\r\\n\").expect(\"write state to log\");\n\n      self.record_location.push(est.location);\n      self.record_velocity.push(est.velocity);\n      self.record_acceleration.push(est.acceleration);\n      self.record_voltage.push(est.motor_input.voltage());\n```", "```rs\n      //5.4\\. Print realtime statistics\n      print!(\"{}{}{}\", clear::All, cursor::Goto(1, 1), cursor::Hide);\n      let carriage_floor = (est.location / self.esp.floor_height).floor();\n      let carriage_floor = if carriage_floor < 1.0 { 0 } else { carriage_floor as u64 };\n      let carriage_floor = cmp::min(carriage_floor, self.esp.floor_count-1);\n      let mut terminal_buffer = vec![' ' as u8; (self.termwidth*self.termheight) as usize];\n      for ty in 0..self.esp.floor_count\n      {\n         terminal_buffer[ (ty*self.termwidth + 0) as usize ] = '[' as u8;\n         terminal_buffer[ (ty*self.termwidth + 1) as usize ] =\n            if (ty as u64)==((self.esp.floor_count-1)-carriage_floor) { 'X' as u8 }\n            else { ' ' as u8 };\n         terminal_buffer[ (ty*self.termwidth + 2) as usize ] = ']' as u8;\n         terminal_buffer[ (ty*self.termwidth + self.termwidth-2) as usize ] = '\\r' as u8;\n         terminal_buffer[ (ty*self.termwidth + self.termwidth-1) as usize ] = '\\n' as u8;\n      }\n      let stats = vec![\n         format!(\"Carriage at floor {}\", carriage_floor+1),\n         format!(\"Location {:.06}\", est.location),\n         format!(\"Velocity {:.06}\", est.velocity),\n         format!(\"Acceleration {:.06}\", est.acceleration),\n         format!(\"Voltage [up-down] {:.06}\", est.motor_input.voltage()),\n      ];\n      for sy in 0..stats.len()\n      {\n         for (sx,sc) in stats[sy].chars().enumerate()\n         {\n            terminal_buffer[ sy*(self.termwidth as usize) + 6 + sx ] = sc as u8;\n         }\n      }\n      write!(self.stdout, \"{}\",\n```", "```rs\nString::from_utf8(terminal_buffer).ok().unwrap());\n      self.stdout.flush().unwrap();\n   }\n```", "```rs\n   fn summary(&mut self)\n   {\n      //6 Calculate and print summary statistics\n      write!(self.stdout, \"{}{}{}\", clear::All, cursor::Goto(1, 1), cursor::Show).unwrap();\n      variable_summary(&mut self.stdout, \"location\".to_string(), &self.record_location);\n      variable_summary(&mut self.stdout, \"velocity\".to_string(), &self.record_velocity);\n      variable_summary(&mut self.stdout, \"acceleration\".to_string(), &self.record_acceleration);\n      variable_summary(&mut self.stdout, \"voltage\".to_string(), &self.record_voltage);\n      self.stdout.flush().unwrap();\n   }\n}\n```", "```rs\n#[derive(Clone)]\nstruct Trip {\n   dst: u64,\n   up: f64,\n   down: f64\n}\n\nconst MAX_JERK: f64 = 0.2;\nconst MAX_ACCELERATION: f64 = 2.0;\nconst MAX_VELOCITY: f64 = 5.0;\n\nfn main()\n{\n   let simlog = File::open(\"simulation.log\").expect(\"read simulation log\");\n   let mut simlog = BufReader::new(&simlog);\n   let mut jerk = 0.0;\n   let mut prev_est: Option<ElevatorState> = None;\n   let mut dst_timing: Vec<Trip> = Vec::new();\n   let mut start_location = 0.0;\n```", "```rs\n   let mut first_line = String::new();\n   let len = simlog.read_line(&mut first_line).unwrap();\n   let esp: ElevatorSpecification = serde_json::from_str(&first_line).unwrap();\n\n   for line in simlog.lines() {\n      let l = line.unwrap();\n      let (est, dst): (ElevatorState,u64) = serde_json::from_str(&l).unwrap();\n      let dl = dst_timing.len();\n      if dst_timing.len()==0 || dst_timing[dl-1].dst != dst {\n         dst_timing.push(Trip { dst:dst, up:0.0, down:0.0 });\n      }\n\n      if let Some(prev_est) = prev_est {\n         let dt = est.timestamp - prev_est.timestamp;\n         if est.velocity > 0.0 {\n            dst_timing[dl-1].up += dt;\n         } else {\n            dst_timing[dl-1].down += dt;\n         }\n         let da = (est.acceleration - prev_est.acceleration).abs();\n         jerk = (jerk * (1.0 - dt)) + (da * dt);\n         if jerk.abs() > 0.22 {\n            panic!(\"jerk is outside of acceptable limits: {} {:?}\", jerk, est)\n         }\n      } else {\n         start_location = est.location;\n      }\n      if est.acceleration.abs() > 2.2 {\n         panic!(\"acceleration is outside of acceptable limits: {:?}\", est)\n      }\n      if est.velocity.abs() > 5.5 {\n         panic!(\"velocity is outside of acceptable limits: {:?}\", est)\n      }\n      prev_est = Some(est);\n   }\n```", "```rs\n   //elevator should not backup\n   let mut total_time = 0.0;\n   let mut total_direct = 0.0;\n   for trip in dst_timing.clone()\n   {\n      total_time += (trip.up + trip.down);\n      if trip.up > trip.down {\n         total_direct += trip.up;\n      } else {\n         total_direct += trip.down;\n      }\n   }\n   if (total_direct / total_time) < 0.9 {\n      panic!(\"elevator back up is too common: {}\", total_direct / total_time)\n   }\n\n   //trips should finish within 20% of theoretical limit\n   let mut trip_start_location = start_location;\n   let mut theoretical_time = 0.0;\n   let floor_height = esp.floor_height;\n   for trip in dst_timing.clone()\n   {\n      let next_floor = (trip.dst as f64) * floor_height;\n      let d = (trip_start_location - next_floor).abs();\n      theoretical_time += (\n         2.0*(MAX_ACCELERATION / MAX_JERK) +\n         2.0*(MAX_JERK / MAX_ACCELERATION) +\n         d / MAX_VELOCITY\n      );\n      trip_start_location = next_floor;\n   }\n   if total_time > (theoretical_time * 1.2) {\n      panic!(\"elevator moves to slow {} {}\", total_time, theoretical_time * 1.2)\n   }\n\n   println!(\"All simulation checks passing.\");\n}\n```", "```rs\n{\"floor_count\":5,\"floor_height\":5.67,\"carriage_weight\":120000.0}[{\"timestamp\":0.001288587,\"location\":0.0,\"velocity\":0.0,\"acceleration\":0.0,\"motor_input\":{\"Up\":{\"voltage\":147000.0}}},2][{\"timestamp\":0.002877568,\"location\":0.0,\"velocity\":0.0,\"acceleration\":0.0002577174000002458,\"motor_input\":{\"Up\":{\"voltage\":147003.86576100003}}},2][{\"timestamp\":0.004389254,\"location\":0.0,\"velocity\":3.8958778553677168e-7,\"acceleration\":0.000575513599999411,\"motor_input\":{\"Up\":{\"voltage\":147008.632704}}},2][{\"timestamp\":0.005886777,\"location\":5.834166693603828e-10,\"velocity\":0.0000012514326383486894,\"acceleration\":0.0008778508000002461,\"motor_input\":{\"Up\":{\"voltage\":147013.16776200004}}},2][{\"timestamp\":0.007377939,\"location\":2.449505465225691e-9,\"velocity\":0.0000025604503929786564,\"acceleration\":0.0011773553999994136,\"motor_input\":{\"Up\":{\"voltage\":147017.660331}}},2][{\"timestamp\":0.008929299,\"location\":6.421685786877059e-9,\"velocity\":0.000004386952466321746,\"acceleration\":0.0014755878000016765,\"motor_input\":{\"Up\":{\"voltage\":147022.13381700003}}},2]\n```", "```rs\n[dependencies]\nserde = \"1.0\"\nserde_json = \"1.0\"\nserde_derive = \"1.0\"\n```", "```rs\n#[macro_use] extern crate serde_derive;\nextern crate serde;\nextern crate serde_json;\n```", "```rs\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub enum MotorInput\n{\n   Up { voltage: f64 },\n   Down { voltage: f64 }\n}\n\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub struct ElevatorSpecification\n{\n   pub floor_count: u64,\n   pub floor_height: f64,\n   pub carriage_weight: f64\n}\n\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub struct ElevatorState\n{\n   pub timestamp: f64,\n   pub location: f64,\n   pub velocity: f64,\n\n```", "```rs\n   pub acceleration: f64,\n   pub motor_input: MotorInput\n}\n```", "```rs\nserde_json::to_string(&datum).unwrap().as_bytes()\n```", "```rs\nserde_json::from_str(&l).unwrap()\n```", "```rs\n5\n```", "```rs\n6.54321\n```", "```rs\n\"timestamp\"\n```", "```rs\n[1,2,3,4,5,6,0]\n```", "```rs\n[{\"timestamp\":0.007377939,\"location\":2.449505465225691e-9,\"velocity\":0.0000025604503929786564,\"acceleration\":0.0011773553999994136,\"motor_input\":{\"Up\":{\"voltage\":147017.660331}}},2][{\"timestamp\":0.008929299,\"location\":6.421685786877059e-9,\"velocity\":0.000004386952466321746,\"acceleration\":0.0014755878000016765,\"motor_input\":{\"Up\":{\"voltage\":147022.13381700003}}},2]\n```", "```rs\n{\"floor_count\":5,\"floor_height\":5.67,\"carriage_weight\":120000.0}\n```", "```rs\n{\"Up\":{\"voltage\":147003.86576100003}}\n```", "```rs\n{\"a\":5,\"b\":6,\"c\":7}\n```", "```rs\njerk is outside of acceptable limits: ElevatorState {\n   timestamp: 0.023739637,\n   location: 0,\n   velocity: 0,\n   acceleration: 1,\n   motor_input: Up { voltage: 162000 }\n}\n```", "```rs\nAll simulation checks passing.\n```"]