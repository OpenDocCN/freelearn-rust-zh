["```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn reserve(&mut self, additional: usize) {\n    self.buf.reserve(self.len, additional);\n}\n```", "```rs\nfn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize)\n    -> Result<usize, CollectionAllocErr> {\n\n    // Nothing we can really do about these checks :(\n    let required_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n    // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n    let double_cap = self.cap * 2;\n    // `double_cap` guarantees exponential growth.\n    Ok(cmp::max(double_cap, required_cap))\n}\n```", "```rs\n#[inline]\nfn is_full(&self) -> bool {\n    self.cap() - self.len() == 1\n}\n\n#[inline]\nfn grow_if_necessary(&mut self) {\n    if self.is_full() {\n        let old_cap = self.cap();\n        self.buf.double();\n        unsafe {\n            self.handle_cap_increase(old_cap);\n        }\n        debug_assert!(!self.is_full());\n    }\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn insert(&mut self, index: usize, element: T) {\n    let len = self.len();\n    assert!(index <= len);\n\n    // space for the new element\n    if len == self.buf.cap() {\n        self.reserve(1);\n    }\n\n    unsafe {\n        // infallible\n        // The spot to put the new value\n        {\n            let p = self.as_mut_ptr().add(index);\n            // Shift everything over to make space. (Duplicating the\n            // `index`th element into two consecutive places.)\n            ptr::copy(p, p.offset(1), len - index);\n            // Write it in, overwriting the first copy of the `index`th\n            // element.\n            ptr::write(p, element);\n        }\n        self.set_len(len + 1);\n    }\n}\n```", "```rs\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn push(&mut self, value: T) {\n    // This will panic or abort if we would allocate > isize::MAX bytes\n    // or if the length increment would overflow for zero-sized types.\n    if self.len == self.buf.cap() {\n        self.reserve(1);\n    }\n    unsafe {\n        let end = self.as_mut_ptr().offset(self.len as isize);\n        ptr::write(end, value);\n        self.len += 1;\n    }\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn push_front(&mut self, value: T) {\n    self.grow_if_necessary();\n\n    self.tail = self.wrap_sub(self.tail, 1);\n    let tail = self.tail;\n    unsafe {\n        self.buffer_write(tail, value);\n    }\n}\n```", "```rs\npub struct IntoIter<T> {\n    buf: NonNull<T>,\n    phantom: PhantomData<T>,\n    cap: usize,\n    ptr: *const T,\n    end: *const T,\n}\n// ...\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        unsafe {\n            if self.ptr as *const _ == self.end {\n                None\n            } else {\n                if mem::size_of::<T>() == 0 {\n                    // purposefully don't use 'ptr.offset' because for\n                    // vectors with 0-size elements this would return the\n                    // same pointer.\n                    self.ptr = arith_offset(self.ptr as *const i8, 1) as *mut T;\n\n                    // Make up a value of this ZST.\n                    Some(mem::zeroed())\n                } else {\n                    let old = self.ptr;\n                    self.ptr = self.ptr.offset(1);\n\n                    Some(ptr::read(old))\n                }\n            }\n        }\n    }\n// ...\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    ring: &'a [T],\n    tail: usize,\n    head: usize,\n}\n// ...\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n        if self.tail == self.head {\n            return None;\n        }\n        let tail = self.tail;\n        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n        unsafe { Some(self.ring.get_unchecked(tail)) }\n    }\n//...\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn remove(&mut self, index: usize) -> T {\n    let len = self.len();\n    assert!(index < len);\n    unsafe {\n        // infallible\n        let ret;\n        {\n            // the place we are taking from.\n            let ptr = self.as_mut_ptr().add(index);\n            // copy it out, unsafely having a copy of the value on\n            // the stack and in the vector at the same time.\n            ret = ptr::read(ptr);\n\n            // Shift everything down to fill in that spot.\n            ptr::copy(ptr.offset(1), ptr, len - index - 1);\n        }\n        self.set_len(len - 1);\n        ret\n    }\n} \n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct LinkedList<T> {\n    head: Option<NonNull<Node<T>>>,\n    tail: Option<NonNull<Node<T>>>,\n    len: usize,\n    marker: PhantomData<Box<Node<T>>>,\n}\n\nstruct Node<T> {\n    next: Option<NonNull<Node<T>>>,\n    prev: Option<NonNull<Node<T>>>,\n    element: T,\n}\n```", "```rs\nfn push_front_node(&mut self, mut node: Box<Node<T>>) {\n    unsafe {\n        node.next = self.head;\n        node.prev = None;\n        let node = Some(Box::into_raw_non_null(node));\n\n        match self.head {\n            None => self.tail = node,\n            Some(mut head) => head.as_mut().prev = node,\n        }\n\n        self.head = node;\n        self.len += 1;\n    }\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn push_front(&mut self, elt: T) {\n    self.push_front_node(box Node::new(elt));\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn append(&mut self, other: &mut Self) {\n    match self.tail {\n        None => mem::swap(self, other),\n        Some(mut tail) => {\n            if let Some(mut other_head) = other.head.take() {\n                unsafe {\n                    tail.as_mut().next = Some(other_head);\n                    other_head.as_mut().prev = Some(tail);\n                }\n\n                self.tail = other.tail.take();\n                self.len += mem::replace(&mut other.len, 0);\n            }\n        }\n    }\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    head: Option<NonNull<Node<T>>>,\n    tail: Option<NonNull<Node<T>>>,\n    len: usize,\n    marker: PhantomData<&'a Node<T>>,\n}\n```", "```rs\n#[inline]\nfn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n    self.head.map(|node| unsafe {\n        let node = Box::from_raw(node.as_ptr());\n        self.head = node.next;\n\n        match self.head {\n            None => self.tail = None,\n            Some(mut head) => head.as_mut().prev = None,\n        }\n\n        self.len -= 1;\n        node\n    })\n}\n```", "```rs\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct HashSet<T, S = RandomState> {\n    map: HashMap<T, (), S>,\n}\n```", "```rs\npub fn insert(&mut self, k: K, v: V) -> Option<V> {\n    let hash = self.make_hash(&k);\n    self.reserve(1);\n    self.insert_hashed_nocheck(hash, k, v)\n}\n```", "```rs\npub fn insert(self, value: V) -> &'a mut V {\n    let b = match self.elem {\n        NeqElem(mut bucket, disp) => {\n            if disp >= DISPLACEMENT_THRESHOLD {\n                bucket.table_mut().set_tag(true);\n            }\n            robin_hood(bucket, disp, self.hash, self.key, value)\n        },\n        NoElem(mut bucket, disp) => {\n            if disp >= DISPLACEMENT_THRESHOLD {\n                bucket.table_mut().set_tag(true);\n            }\n            bucket.put(self.hash, self.key, value)\n        },\n    };\n    b.into_mut_refs().1\n}\n```", "```rs\n// The threshold of 128 is chosen to minimize the chance of exceeding it.\n // In particular, we want that chance to be less than 10^-8 with a load of 90%.\n // For displacement, the smallest constant that fits our needs is 90, // so we round that up to 128.\n //\n// At a load factor of α, the odds of finding the target bucket after exactly n\n // unsuccessful probes[1] are\n //\n // Pr_α{displacement = n} =\n //       (1 - α) / α * ∑_{k≥1} e^(-kα) * (kα)^(k+n) / (k + n)! * (1 - kα / (k + n + 1))\n //\n // We use this formula to find the probability of triggering the adaptive behavior\n //\n // Pr_0.909{displacement > 128} = 1.601 * 10^-11\n //\n // 1\\. Alfredo Viola (2005). Distributional analysis of Robin Hood linear probing // hashing with buckets.\n```", "```rs\npub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n    where K: Borrow<Q>,\n            Q: Hash + Eq\n{\n    self.search(k).map(|bucket| bucket.into_refs().1)\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n    where K: Borrow<Q>,\n            Q: Hash + Eq\n{\n    self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn insert(&mut self, key: K, value: V) -> Option<V> {\n    match self.entry(key) {\n        Occupied(mut entry) => Some(entry.insert(value)),\n        Vacant(entry) => {\n            entry.insert(value);\n            None\n        }\n    }\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn entry(&mut self, key: K) -> Entry<K, V> {\n    // FIXME(@porglezomp) Avoid allocating if we don't insert\n    self.ensure_root_is_owned();\n    match search::search_tree(self.root.as_mut(), &key) {\n        Found(handle) => {\n            Occupied(OccupiedEntry {\n                handle,\n                length: &mut self.length,\n                _marker: PhantomData,\n            })\n        }\n        GoDown(handle) => {\n            Vacant(VacantEntry {\n                key,\n                handle,\n                length: &mut self.length,\n                _marker: PhantomData,\n            })\n        }\n    }\n}\n```", "```rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn insert(self, value: V) -> &'a mut V {\n    *self.length += 1;\n\n    let out_ptr;\n\n    let mut ins_k;\n    let mut ins_v;\n    let mut ins_edge;\n\n    let mut cur_parent = match self.handle.insert(self.key, value) {\n        (Fit(handle), _) => return handle.into_kv_mut().1,\n        (Split(left, k, v, right), ptr) => {\n            ins_k = k;\n            ins_v = v;\n            ins_edge = right;\n            out_ptr = ptr;\n            left.ascend().map_err(|n| n.into_root_mut())\n        }\n    };\n\n    loop {\n        match cur_parent {\n            Ok(parent) => {\n                match parent.insert(ins_k, ins_v, ins_edge) {\n                    Fit(_) => return unsafe { &mut *out_ptr },\n                    Split(left, k, v, right) => {\n                        ins_k = k;\n                        ins_v = v;\n                        ins_edge = right;\n                        cur_parent = left.ascend().map_err(|n| n.into_root_mut());\n                    }\n                }\n            }\n            Err(root) => {\n                root.push_level().push(ins_k, ins_v, ins_edge);\n                return unsafe { &mut *out_ptr };\n            }\n        }\n    }\n}\n```", "```rs\npub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n    key: &Q\n) -> SearchResult<BorrowType, K, V, marker::LeafOrInternal, marker::Leaf>\n        where Q: Ord, K: Borrow<Q> {\n\n    loop {\n        match search_node(node, key) {\n            Found(handle) => return Found(handle),\n            GoDown(handle) => match handle.force() {\n                Leaf(leaf) => return GoDown(leaf),\n                Internal(internal) => {\n                    node = internal.descend();\n                    continue;\n                }\n            }\n        }\n    }\n}\n\npub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n    node: NodeRef<BorrowType, K, V, Type>,\n    key: &Q\n) -> SearchResult<BorrowType, K, V, Type, Type>\n        where Q: Ord, K: Borrow<Q> {\n\n    match search_linear(&node, key) {\n        (idx, true) => Found(\n            Handle::new_kv(node, idx)\n        ),\n        (idx, false) => SearchResult::GoDown(\n            Handle::new_edge(node, idx)\n        )\n    }\n}\n```"]