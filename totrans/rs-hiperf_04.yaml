- en: Lints and Clippy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we needed to check all the details of the code by ourselves. This
    can often get out of control, since we cannot be checking each line of code. In
    this chapter, you will learn about the lints Rust brings us, both the ones enabled
    by default and the ones you can enable yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you will learn about a great tool, Clippy, that will give you many
    more lints you can use, and that can help you write much better code. In many
    cases, it will lint about performance pitfalls. In other cases, they will be potential
    errors or idiomatic conventions. It will also help you clean your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Linting in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default lints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using and configuring Clippy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra Clippy lints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Rust compiler lints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust compiler, at the time of writing, has 70 lints. We will not check all
    70, but we will take a look at the most relevant ones. Let's first start by learning
    how to configure a lint. We will take `unused_imports` as an example. The compiler
    will warn you for this lint by default. The compilation will continue, but it
    will show a warning in the command line, or in the editor if it's configured to
    show Rust compilation warnings.
  prefs: []
  type: TYPE_NORMAL
- en: We can change this behavior, and we can change it for each scope. The options
    are `allow`, `warn`, `deny`, and `forbid` the lint. If we allow the lint, no more
    warnings will appear. If we warn, compilation warnings will appear, and if we
    deny or forbid, the program won't compile if it finds something that triggers
    the lint. The difference between `deny` and `forbid` is that the former can be
    overridden down the line, while the latter can't. So we can have a module that
    denies one behavior, but in one particular function, we want to allow it.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration can be applied at crate level, by putting  `#![deny(unused_imports)]`,
    for example, at the top of the `lib.rs` or `main.rs` file. It can also be applied
    to any scope, even scopes you might create inside functions. If it has an exclamation
    mark (`!`) after the hash, it will affect the current scope; if not, it will affect
    the scope just next to it. Let's see what lints the Rust compiler gives us.
  prefs: []
  type: TYPE_NORMAL
- en: Lints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will check the lints that allow the behavior by default,
    and that you will probably want to add at least a warning for in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding anonymous parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Anonymous parameters have been deprecated. This allowed you to specify traits
    without requiring binding names in traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a deprecated legacy feature that might get removed in future versions,
    so you should probably avoid using this syntax. In order to warn or deny this
    syntax in your code base, you will need to use this syntax: `#![warn(anonymous_parameters)]`.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding heap allocated box pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust allocates space in the stack by default, since it's much faster than using
    the heap. Nevertheless, sometimes, when we do not know the size of objects at
    compile time, we need to use the heap to allocate new structures. Rust makes this
    explicit by using the `Vec`, `String`, and `Box` types, for example. The last
    one allows us to put in the heap any kind of object, which is usually a bad idea,
    but sometimes it's a must.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out, for example, the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code compiles perfectly, and it tells us that the integer is `10 (5 + 5)`.
    The main issue with this is that it does a heap allocation, doing a system call
    that needs to find the space in the heap and so on. But we already know that an
    integer has a fixed size at compile time, so we should be using the stack for
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'These kinds of errors can be avoided by warning every `Box` usage using `#![warn(box_pointers)]`.
    But beware: this will warn every usage of a boxed type, so you probably want to
    allow this in many places explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding missing implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of traits we probably want many of our types to implement.
    The first of them is the `Debug` trait. The `Debug` trait should probably be implemented
    by all of our types, since it enables a developer to print debug information about
    our structures, enumerations, and so on. Moreover, it allows a user of our API
    to derive the `Debug` trait in structures using our API types by only adding an
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: We can enforce the implementation of this trait for all of our types by adding
    `#![warn(missing_debug_implementations)]`. The only detail is that this trait
    will only check for types exposed in our API. So, it will only work for `pub`
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting trait is the `Copy` trait. Sometimes, we create a small
    structure with a couple of integers that would work best if copied in certain
    cases, as we saw in the previous chapters. The problem is that if we forget about
    implementing it, we might end up doing excessive referencing, making our code
    slower. We can solve this by adding this lint: `#![warn(missing_copy_implementations)]`.'
  prefs: []
  type: TYPE_NORMAL
- en: This lint has a couple of caveats though. It will only work for `pub` types,
    as in the case for the `Debug` implementation lint, and it will lint all structures
    that all of its members are `Copy` types. This means that if we have a really
    big structure that we wouldn't like to copy around, we will need to allow the
    lint for that particular structure.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is arguably the most important lint of all, and it's a pity that it's `allow`
    by default. Whenever we create an API, we must document what the API does. This
    will make it much, much easier for new developers to use it. The `#![warn(missing_docs)]`
    lint will make sure that at least all of your public API has some documentation.
    I personally usually have this as a warning during the development and change
    it to `deny` or even `forbid` once the project enters into production.
  prefs: []
  type: TYPE_NORMAL
- en: Pointing out trivial casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we might explicitly cast an element to a type that the compiler
    should cast automatically. This sometimes happens when we use traits, but it can
    also happen because we changed the type of an element to a new type and we didn''t
    change the castings. To clean these kinds of behavior, we have the `trivial_casts`
    and `trivial_numeric_casts` lints. Let''s see it as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we first cast `test` as a `MyStruct`, but it's already a `MyStruct`,
    so this is redundant and makes the code much less readable, and in consequence,
    more error-prone. Then we cast its `a` attribute as an `i32`, but it's already
    an `i32`, so once again, redundant information. The first is not common, but the
    second could be found if we use this parameter for a function that only accepts
    an `i32`, and our structure had `i16` in a previous implementation, for example.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, these kinds of castings are not good practice, since it could be
    that we had changed the `a` attribute for an `i64`, and we would be silently losing
    precision. We should use `i32::from()` so that if we change it for an `i64`, it
    will simply stop compiling. This gets automatically linted with the Clippy tool
    we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to enable these two lints anyway, since it will help us find
    these kinds of errors. The `trivial_casts` lint will lint us for non-numeric type/trait
    casts, while `trivial_numeric_casts` will lint the numeric casts.
  prefs: []
  type: TYPE_NORMAL
- en: Linting unsafe code blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some situations, especially if we are using extremely low-level programming,
    sometimes used for high-performance computing, we will need to perform some pointer
    arithmetics or even **Single Instruction, Multiple Data** (**SIMD**) intrinsics
    that will require unsafe scopes. This might be the case in some specific functions
    or pieces of code, but in general, we should avoid unsafe scopes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A rule of thumb is this: if you are not working on performance-critical code,
    do not use them. If you are, use them very carefully and only in places where
    there is no other option to improve performance. This means that usually intrinsic
    code can be wrapped in one module or function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure nobody uses unsafe code outside the scope where we want it to
    be shown, we can lint all unsafe scopes by using the `unsafe_code` lint. Let''s
    see it as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you remember from [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml),
    *Common Performance Pitfalls*, the `get_unchecked()` function in a slice will
    get the element at the given index without checking the bounds of the slice, making
    it go faster. This also means that if the index is out of bounds, you could get
    from a memory leak to a segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, when compiling this piece of code, a warning will tell us
    that we are using unsafe code. We can allow it for this particular function if
    it''s 100% required, or we can change the code. An example fixing the issue above
    while still using unsafe code can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the crate won't compile if we add an unsafe scope outside the
    `get_second()` function. In any case, this function is not safe, as it will not
    check any bounds of the slice being sent to it; we should probably add an `assert!()`,
    or at least a `debug_assert!()`, to the length of the slice at the beginning of
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: Unused lints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's face it, we sometimes forget to remove a dependency we are no longer using,
    or we forget that the `write()` method returns the number of bytes written. This
    usually is not a big deal. The first will simply make our compilation slower,
    while the second, in most cases, will simply not change our code.
  prefs: []
  type: TYPE_NORMAL
- en: But since we do not want to have unused dependencies, or we don't want to forget
    that we might not have written the whole buffer to a file, that's where the next
    lints come to help us. Let's start with the first one, the `unused_extern_crates`
    lint. This lint will mark the external crates that are not being used in our code.
    This can be useful to remove dependencies we are no longer using, so I usually
    configure it to `warn` while I'm starting the development and change it to `forbid`
    once my crates go to production or the dependencies are not changing in every
    commit.
  prefs: []
  type: TYPE_NORMAL
- en: The second lint you should know about is the `unused_results` lint. By default,
    the compiler will warn about unused results for `Result<T, E>` return values.
    That is an important detail because it could be that an I/O operation failed,
    for example, and you should act accordingly. There are other cases, though, where
    the Rust compiler won't warn, but that can be almost as dangerous as the previous
    ones. The `Write` and `Read` traits, for example, will return the number of bytes
    written and read, respectively, and you should probably be aware of that number.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lint will make sure you always take into account any return value, except
    for the empty tuple `()`. This can sometimes be annoying, but you can explicitly
    discard a result by using the underscore binding, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also a couple of lints that will make your code much more readable:
    `unused_qualifications` and `unused_import_braces`. The first will detect places
    where you are using extra qualifications for some elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example of code will warn us that in the first `println!()` we do not need
    to use the `Test::` qualification, as we are already importing all values inside
    the `Test` enumeration. The second `println!()` will not warn us since we are
    not specifying any extra qualifications. This will make the code more readable,
    potentially reducing errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second lint, the `unused_import_braces` lint, will check for places where
    we are importing only one element with import braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Even though the Rust formatter will automatically remove the braces around the
    C variant of the `Test2` import, if we do not use the formatter, this is an interesting
    lint that will alert that we do not require those braces and that removing them
    we will make the code cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Variant size differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the previous chapters, the size of an enumeration will be the
    size of the biggest element plus the tag, but, as we discussed, this can be troublesome
    if we have many small variants and one has a bigger size: all variants will occupy
    the whole space for the biggest one. We saw that an option would be to move the
    big variant to a heap allocation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can detect enumerations with variants significantly bigger than the rest
    with the `variant_size_differences` lint. It will check for enumerations where
    a variant is at least three times bigger than the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that it will not work for unions and that if we have middle-sized variants,
    even if the difference between the biggest one and the smallest one is more than
    three times, the lint will not alert us.
  prefs: []
  type: TYPE_NORMAL
- en: Lint groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust compiler lets us configure some of the aforementioned lints in groups.
    For example, the `unused` group will contain many of the `unused_` kind of lints.
    The `warnings` group will contain all the lints that have been configured to warn,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lint groups can be used the same way as lints, by specifying what you want
    to happen when the compiler catches that behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can check out the rest of the built-in lints by running `rustc -W help`.
    It will show the ones we have talked about and the other lints that are `warn`
    or `deny` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Clippy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is a tool that will help you sanitize your code the most, it is Clippy.
    At the time of writing, Clippy provides 208 extra lints, most of them really useful
    to avoid interesting pitfalls such as the `unwrap_or()` usage that we discussed
    in [Chapter 2](da2d0480-3314-408b-9cad-60987754f45d.xhtml), *Extra Performance
    Enhancements*, or to avoid non-idiomatic code. Of course, we will not see all
    of them here, and you will find a comprehensive list of all of them in the Clippy
    lint documentation at [https://rust-lang-nursery.github.io/rust-clippy/master/.](https://rust-lang-nursery.github.io/rust-clippy/master/)
  prefs: []
  type: TYPE_NORMAL
- en: Since many of them already warn or even deny by default, we will check some
    of the ones that are allowed by default but that could be really useful to improve
    the code quality of your application and even its performance.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing Clippy is pretty easy: you will need to install Rust nightly by
    running `rustup toolchain install nightly`, then you can install Clippy by running
    `cargo +nightly install clippy`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that since Clippy requires a nightly compiler to build, and since it uses
    compiler intrinsics, some Rust nightly compiler updates make it unusable. Those
    issues are usually fixed in a couple of days and a new Clippy version gets released,
    but meanwhile, you can select a previous nightly version by appending a previous
    date to the nightly toolchain: `rustup toolchain install nightly-YYYY-MM-DD`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the correct toolchain is installed, Clippy will be installed perfectly.
    To use it, you will need to go to your project and run `cargo clippy` instead
    of the usual `cargo check` or `cargo build` commands. This will run all Clippy
    lints and show you the results.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if we will check individual lints in the next section, we will now see
    how we can configure the whole Clippy execution. Clippy will read the `clippy.toml`
    file at the same level as the `Cargo.toml` file and act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Some lints have configuration parameters. For instance, the cyclomatic complexity
    lint will alert you whenever a function has more than 25 branches. As we saw in
    [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml), *Common Performance Pitfalls*,
    this is bad practice, since it will make the optimizations of the code much harder
    for the compiler, creating less performant code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can change the threshold that creates the warning. 25 is a fair
    amount of branches, but depending on your product, you would prefer not to have
    more than 20 branches or to be able to have up to 30, for example. The setting
    that changes this behavior in the `clippy.toml` is the `cyclomatic-complexity-threshold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Clippy will also warn you, for example, when it finds names that could be the
    name of a structure or enumeration in the documentation without the proper (``
    ` ``) characters showing that they are code. This can have false positives in
    cases such as your software being called `MyCompanyInc`, for example, where Clippy
    will think it's a `struct` or an `enum`. There is a configuration parameter for
    this case too. You can check all of them in the Clippy wiki at [https://rust-lang-nursery.github.io/rust-clippy/master/](https://rust-lang-nursery.github.io/rust-clippy/master/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to add Clippy lints to our project, when we compile without Clippy,
    Rust will warn us that those lints are unknown. Of course, those have been defined
    by Clippy, but the compiler does not know this. Clippy sets a `cargo-clippy` feature
    by default, and when configuring the lints, we can use it to remove the unknown
    lints warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This way, when we run `cargo clippy`, the lint will be taken into account, but
    when running `cargo check`, it won't.
  prefs: []
  type: TYPE_NORMAL
- en: Lints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From those 208 lints currently available in Clippy, we will analyze only some
    of them that are configured as `allow` by default. The rest can be checked at
    the Clippy wiki at [https://rust-lang-nursery.github.io/rust-clippy/master/](https://rust-lang-nursery.github.io/rust-clippy/master/),
    but you should take note of these ones, since they will not show an alert by default.
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting numbers is sometimes a dangerous operation. We could lose precision,
    lose sign, truncate numbers, and so on. Clippy gives us some very useful lints
    that can avoid these situations. Of course, often you do not care about these
    behaviors since you might know they won't happen or they could be intended behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, I have found these lints useful even if you only activate them
    on one occasion to check the places where these casts take place and set them
    to allow by default when usual testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lints are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cast_possible_truncation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cast_possible_wrap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cast_precision_loss`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cast_sign_loss`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clippy also gives us lints that will detect bad coding practices. You should,
    for example, not import enumeration variants, since enumeration variants should
    always be prefixed with the actual enumeration. To lint against this practice,
    you can use the `enum_glob_use` lint.
  prefs: []
  type: TYPE_NORMAL
- en: Other code practices that might create issues are the panicking `From` and `Into`
    trait implementations. By definition, these traits must never fail, and using
    `unwrap()`, `expect()`, `panic!()`, or `assert!()` functions and macros can panic
    the function. This can be the desired behavior in an application, even though
    it's bad practice (you should use `TryInto` and `TryFrom` traits, or create a
    new function if developing with the stable compiler).
  prefs: []
  type: TYPE_NORMAL
- en: But the main issue is when developing software such as kernels that could cause
    the whole OS to panic. You can detect these issues by using the `fallible_impl_from`
    lint.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about iterators in [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml), *Common
    Performance Pitfalls*, and as we saw, we sometimes have useful functions to wrap
    `filter()` and `map()`. This improves readability, and concatenations of these
    functions can be detected by using the `filter_map` lint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we write conditionals that might not be straightforward to understand,
    sometimes because we do negations in conditions with `else` branches or because
    we add lots of conditions that mess up our comparisons. We have two Clippy lints
    that will point out these situations: `if_not_else` and `nonminimal_bool`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first will detect a negation in a conditional, and suggest changing the
    condition to a positive one and changing the `else` and the `if` code sections.
    The second will check for Booleans that can be simplified to remove redundancy
    and clean up the code.
  prefs: []
  type: TYPE_NORMAL
- en: Some `match` statements can also be improved when there are only two branches
    and one of them does not require any parameters, such as when dealing with `Option`
    types. In this case, it's cleaner to change them for an `if let` expression with
    an `else` that will also reduce the indenting of the comparison. These points
    of failure can be shown by using the `single_match_else` lint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting couple of lints will check for places where you might be
    adding `1` to an integer just to make comparisons or ranges inclusive. Let''s
    see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That code only adds `1` to be able to print the `10` too. You can create an
    inclusive range of nightly Rust by using an equals symbol after the two range
    periods (`..=`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The lint that will point out this error is called `range_plus_one`, while the
    one that will detect comparisons such as `a < b+1`, that can be replaced by `a
    <= b`, is called `int_plus_one`.
  prefs: []
  type: TYPE_NORMAL
- en: There are also times where we might change the name of a variable or misspell
    it and break our code, even if it seems to compile. Other times, we might create
    variables with too similar names and end up mixing them up. This can be avoided
    by using the `similar_names` lint.
  prefs: []
  type: TYPE_NORMAL
- en: Another bad practice is to include the name of an enumeration in a variant of
    the enumeration, or a structure containing the name of the current module. Since
    names can be qualified, repetition is not required and adds a lot of text. This
    will be warned by default, but not in public APIs. You can control that with the
    `stutter` and the `pub_enum_variant_names` lints.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the same way the Rust compiler gave us a `missing_docs` lint that would
    point out missing public documentation, the `missing_docs_in_private_items` Clippy
    lint will do the same for private items. This is great to enforce documentation
    of the whole code base.
  prefs: []
  type: TYPE_NORMAL
- en: Performance lints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are reading this book, these two lints will probably be the ones you
    will find more important than the ones Clippy does not warn by default. The first
    is pretty simple: if you want to share an integer between threads, using a `Mutex`
    is a really bad idea if you do not need to use it as a synchronization variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, things such as counters will be much faster by using atomic types.
    Only pointer-sized atomics and booleans are stable at the time of writing, but
    the rest are also coming and can now be used in nightly Rust. You can spot this
    issue with the `mutex_integer` lint.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you might be tempted to use `std::mem::forget()` to enable sending data
    to C APIs, or to be able to do some strange memory tricks. This can be fine (even
    though it can lead to memory leaks), but can sometimes prevent running destructors.
    If you want to make sure that your `Drop` types never get forgotten, use the `mem_forget`
    lint.
  prefs: []
  type: TYPE_NORMAL
- en: If you are worried about infinite iterators that could hang your applications,
    you should use the `maybe_infinite_iter` lint, which will find those. It will
    not detect stopping conditions, so it could show too many false positives.
  prefs: []
  type: TYPE_NORMAL
- en: We might also find ourselves adding debug information when developing by using
    `print!()` macros and debug formatting. Once the application goes into production,
    a good way to avoid these logs staying in the code base is to use the `print_stdout`
    and `use_debug` lints.
  prefs: []
  type: TYPE_NORMAL
- en: Unwraps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust allows you to unwrap `Result`s and `Option`s, at the cost of panicking
    if they are `Err(_)` or `None` respectively. This should be avoided in any production
    code, and either use `expect()` to add an information message or use error chaining
    with the `?` operator, for example. You can also match them and control the error.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid those unnecessary panics, you can use the `result_unwrap_used`, `option_unwrap_used`,
    `option_map_unwrap_or_else`, `option_map_unwrap_or`, and `result_map_unwrap_or_else`
    lints.
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Rust, you can shadow a variable by creating another `let` binding with the
    same name. This is usually okay, except when we maybe only wanted to mutate a
    variable, for example. In general, you should avoid this practice and only use
    it where it helps readability.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `shadow_unrelated`, `shadow_same`, and `shadow_reuse` lints
    and warn this behavior by default, then allow it for specific situations.
  prefs: []
  type: TYPE_NORMAL
- en: Integer overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, when we do operations with integers, we do not take overflows, underflows,
    and wrappings into account. C will let you do this by default, while Rust will
    panic when running in debug mode. In release mode, though, these integer overflows
    can be a big problem.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `integer_arithmetic` lint that will suggest using one of the
    `wrapping_...()` or `saturating_...()` methods of the integer to make sure you
    know what the outcomes of the operation are.
  prefs: []
  type: TYPE_NORMAL
- en: Lint groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two lint groups in Clippy. The `clippy` lint group will control all
    the lints that warn by default, and you can, for example, deny all of them. The
    `clippy_pedantic` group will control the rest of the lints as a group, but making
    all of them warn, for example, will make your compilation results full of warnings,
    due to false positives.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use them, you simply need to use the group of lints as a lint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can check the rest of the lints and configuration options in the Clippy
    wiki at [https://rust-lang-nursery.github.io/rust-clippy/master/](https://rust-lang-nursery.github.io/rust-clippy/master/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to configure the different lints that Rust
    and the Clippy tool give us. With them, you can get warnings of much more specific
    grain options that affect performance and code quality.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the lints that you will not see by default, making your exploration
    journey much easier. In [Chapter 5](f8df2811-838d-40e2-970d-f50b909252f1.xhtml), *Profiling
    Your Rust Application*, we will learn about other tools; in this case, to profile
    your application and find performance bottlenecks that are not straightforward
    to see.
  prefs: []
  type: TYPE_NORMAL
