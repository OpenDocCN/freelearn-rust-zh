<html><head></head><body>
		<div id="_idContainer021">
			<h1 id="_idParaDest-89"><em class="italic"><a id="_idTextAnchor102"/>Chapter 8</em>: Bundling WebAssembly Using wasm-pack</h1>
			<p>JavaScript is omnipresent, but being everywhere is both an advantage and a disadvantage. There are many different ecosystems that have various standards and purposes. Building a unique solution for all ecosystems is not practical.</p>
			<p>Despite all this, the JavaScript community is doing a wonderful job here. The effort from the community makes JavaScript one of the go-to languages. For a language as versatile as JavaScript, there will be some weird corners (which of course every language has). When you are writing JavaScript, these need extra care and attention.</p>
			<p>JavaScript is dynamically typed. This makes it difficult (almost impossible) to avoid runtime exceptions. While TypeScript, Flow, and Elm try to provide a (typed) superset on JavaScript's dynamic types, they cannot completely fix the underlying problem.</p>
			<p>For any language to grow, it has to evolve fast, which JavaScript does. Evolving fast without breaking the existing usage is also important and JavaScript provides polyfills to make it backward compatible.</p>
			<p>But creating polyfills is a mundane task. There are various other mundane steps, such as bundling and packaging libraries, minifying bundles, and lazy-loading libraries, to name a few. Bundlers provide a solution to most of them. They act as a compiler for the frontend.</p>
			<p>So far, we have seen how Rust makes it easy to create and run WebAssembly modules. In this chapter, we will explore <strong class="source-inline">wasm-pack</strong>, a tool that makes it easier to pack and publish WebAssembly modules. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Bundling WebAssembly modules with webpack</li>
				<li>Bundling WebAssembly modules with Parcel</li>
				<li>Introducing <strong class="source-inline">wasm-pack</strong></li>
				<li>Packing and publishing using <strong class="source-inline">wasm-pack</strong></li>
			</ul>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor103"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor104"/>Bundling WebAssembly modules with webpack </h1>
			<p>webpack is a static module bundler for modern JavaScript applications. So, what does it do?</p>
			<p>You can <a id="_idIndexMarker334"/>consider webpack as an informal compiler for the frontend. webpack takes in an entry point of an application, slowly <a id="_idIndexMarker335"/>runs through the modules, and builds a dependency graph. The dependency graph holds all the modules. These modules are necessary for the application to run.</p>
			<p>Once the dependency graph is built, webpack outputs one or more bundles. Webpack is very flexible, helping us to bundle or package JavaScript as we need it and the options are provided in the webpack configuration. Based on the provided options, webpack creates the output.</p>
			<p><em class="italic">Well, that sounds simple, right?</em></p>
			<p>It was that simple a few years ago when the only library that we needed was jQuery.</p>
			<p>But due to JavaScript's rapid evolution, there are a lot of different things happening now. The underlying runtime is not the same. There are three different browser engines and various targets.</p>
			<p>Browser engines evolve at different speeds and browsers support various versions of JavaScript. In some workplace machines, upgrading browsers to the latest version is prohibited. This means the running JavaScript application needs tweaking and polyfills at various times.</p>
			<p>The underlying target system needs a certain tweak to make your JavaScript code run. Doing all this by hand will take a long time to complete and will be error-prone.</p>
			<p>There are various flavors of JavaScript, including TypeScript and CoffeeScript. They are different, but they will compile down to JavaScript before running. Browser-based development needs CSS, SCSS, SASS, and LESS. Supporting all those variations and compiling them manually after every change is not an easy deal.</p>
			<p>JavaScript's answer to all this is bundlers. Whether you hate them or love them, bundlers reduce the overload and remove the clutter when developing with JavaScript.</p>
			<p>webpack provides a solution to all these problems and more.</p>
			<p>webpack is a tool built for bundling JavaScript applications. It comes with loaders and plugins that will help to convert, add, remove, and manipulate the output bundles. The most interesting part of webpack is its loaders and plugins, which propel the ability of webpack to the fullest.</p>
			<p>Loaders <a id="_idIndexMarker336"/>allow us to load or import a Rust, CSS, or TypeScript file like any other module inside JavaScript. webpack then takes care of producing the bundle that will support the target environment as specified.</p>
			<p>Plugins <a id="_idIndexMarker337"/>allow us to optimize and manage the bundles produced. It is important to note that webpack is built entirely on top of this plugin system.</p>
			<p><em class="italic">How does webpack help with WebAssembly?</em></p>
			<p>webpack internally depends on <a id="_idTextAnchor105"/>the <strong class="source-inline">webassemblyjs</strong> library. So, all the applications that use webpack are already WebAssembly-ready. All you have to do is start loading the WebAssembly file as normal JavaScript and webpack will take care of the rest.</p>
			<p>In the webpack configuration, we will define the entry point. webpack then loads the entry file. The <strong class="source-inline">import</strong> statements in the entry file are loaded as a module based on JavaScript's module resolution algorithm. If the imported module is a WebAssembly module, it gets the module's content and hands it over to the <strong class="source-inline">webassemblyjs</strong> compiler.</p>
			<p>The compiler is responsible for parsing and mutating the WebAssembly modules.</p>
			<p class="callout-heading">Did You Know? </p>
			<p class="callout"><strong class="source-inline">webassemblyjs</strong> can parse <a id="_idIndexMarker338"/>the WebAssembly text format and WebAssembly binary format out of the box.</p>
			<p>The compiler generates the <strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>). The generated AST is then validated. Once the validation is successful, any custom sections in the WebAssembly module are removed.</p>
			<p>The custom section is a section inside the WebAssembly module where users can store custom information about the WebAssembly module. This information may include names of the function and local variables. Browsers may then use this information to have a better debugging process.</p>
			<p>webpack <a id="_idIndexMarker339"/>also does not support the <a id="_idIndexMarker340"/>start section. The start section is a section in a WebAssembly module that will be called as soon as the WebAssembly module is loaded.</p>
			<p>Instead, webpack creates a function and calls it after the WebAssembly module is loaded. <strong class="source-inline">webassemblyjs</strong> removes the start section and converts the start function into a normal function on the WebAssembly module. Then, webpack takes care of generating the wrapper that calls the function as soon as the module is loaded.</p>
			<p>Finally, <strong class="source-inline">webassemblyjs</strong> is also responsible for optimizing the binary and eliminating dead code from the WebAssembly module.</p>
			<p><strong class="source-inline">webassemblyjs</strong> comes with an interpreter and CLI, which makes it easy to experiment with the WebAssembly modules.</p>
			<p class="author-quote"><strong class="bold">Code, refresh, and repeat.</strong></p>
			<p>This was the workflow for web development for a long time. Live reloading provides an extra pair of hands to web developers. Live reloading can automatically compile and reload the changes once the code is saved. The code can be shared across multiple devices, factors, and orientations. Interactions in one place can automatically be synchronized with other devices. While the web provides a medium to deliver software easily, it comes in various forms. These forms are feature phones, smartphones, tablets, laptops, computers, ultra-wide monitors, 360-degree virtual worlds, and so on. Supporting all or some of them is an uphill task. Live reloading works like an extra pair of hands.</p>
			<p>webpack provides multiple options to add live reloading to your application. It provides plugins for live reloading tools, such as BrowserSync. The webpack ecosystem also provides a watch mode in its configuration.</p>
			<p>The watch mode, once enabled, looks for any changes that happen in the source file and its directory. Once the changes are detected, it will recompile automatically. But watch mode is for recompiling input into output.</p>
			<p>The automatic reloading of web pages is provided by a library <a id="_idTextAnchor106"/>called webpack-dev-server. webpack-dev-server is an in-memory web server. The contents are generated and are placed in memory rather than in actual files in the filesystem.</p>
			<p>In addition <a id="_idIndexMarker341"/>to that, webpack-dev-server also supports Hot Module Replacement. This allows the server to patch only the <a id="_idIndexMarker342"/>changes in the browser rather than doing a full page refresh.</p>
			<p>Let's see how we can enable live reloading in a WebAssembly project:</p>
			<ol>
				<li>First, we will create a new Rust project:<p class="source-code">$ cargo new --lib live_reload</p><p class="source-code">  Created library `live_reload` package</p></li>
				<li>Once the project is created, open it in your favorite editor. To define the <strong class="source-inline">wasm-bindgen</strong> dependency for the project, open the <strong class="source-inline">Cargo.toml</strong> file:<p class="source-code">[package]</p><p class="source-code">name = "live_reload"</p><p class="source-code">version = "0.1.0"</p><p class="source-code">authors = ["Sendil Kumar"]</p><p class="source-code">edition = "2018"</p><p class="source-code"> </p><p class="source-code">[lib]</p><p class="source-code">crate-type = ["cdylib"]</p><p class="source-code"> </p><p class="source-code">[dependencies]</p><p class="source-code">wasm-bindgen = "0.2.38"</p></li>
			</ol>
			<p>First, add the <strong class="source-inline">[lib]</strong> section and add <strong class="source-inline">crate-type = ["cdylib"]</strong>. With the <strong class="source-inline">crate-type</strong> option, we are instructing the compiler that the library is dynamic. After that, add the <strong class="source-inline">wasm-bindgen</strong> dependency to the <strong class="source-inline">[dependencies]</strong> tag.</p>
			<ol>
				<li value="3">Then, open the <strong class="source-inline">src/lib.rs</strong> file and replace the contents with the following:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn hello_world() -&gt; String {</p><p class="source-code">"Hello World".to_string()</p><p class="source-code">}</p></li>
				<li>We will <a id="_idIndexMarker343"/>reuse the simple Hello <a id="_idIndexMarker344"/>World example from previous chapters here. Build the WASM module using the following:<p class="source-code">$ cargo build --target wasm32-unknown-unknown</p><p class="source-code">$ wasm-bindgen target/wasm32-unknown-</p><p class="source-code">  unknown/debug/live_reload.wasm --out-dir .</p></li>
				<li>Then create a <strong class="source-inline">webpack.config.js</strong> file to instruct webpack on how to handle and compile the files:<p class="source-code">const path = require('path');</p><p class="source-code">const HtmlWebpackPlugin = require('html-webpack-</p><p class="source-code">  plugin');</p><p class="source-code"> </p><p class="source-code">module.exports = {</p><p class="source-code">    entry: './index.js',</p><p class="source-code">    output: {</p><p class="source-code">        path: path.resolve(__dirname, 'dist'),</p><p class="source-code">        filename: 'bundle.js',</p><p class="source-code">    },</p><p class="source-code">    plugins: [</p><p class="source-code">        new HtmlWebpackPlugin(),</p><p class="source-code">    ],</p><p class="source-code">    experiments: {</p><p class="source-code">       syncWebAssembly: true,</p><p class="source-code">    },</p><p class="source-code">    mode: 'development'</p><p class="source-code">};</p></li>
				<li>Add <a id="_idIndexMarker345"/>a <strong class="source-inline">package.json</strong> file <a id="_idIndexMarker346"/>to download the webpack dependencies:<p class="source-code">{</p><p class="source-code">    "scripts": {</p><p class="source-code">        "build": "webpack",</p><p class="source-code">        "serve": "webpack-dev-server"</p><p class="source-code">    },</p><p class="source-code">    "devDependencies": {</p><p class="source-code">        "html-webpack-plugin": "^5.5.0",</p><p class="source-code">        "webpack": "^5.64.1",</p><p class="source-code">        "webpack-cli": "^4.9.1",</p><p class="source-code">        "webpack-dev-server": "^4.5.0"</p><p class="source-code">    }</p><p class="source-code">}</p><p class="callout-heading">Note </p><p class="callout">Please use the latest version of the dependencies applicable here. </p></li>
				<li>Create an <strong class="source-inline">index.js</strong> file to load the binding JavaScript that in turn loads the WebAssembly module generated:<p class="source-code">import("./live_reload").then(module =&gt; {</p><p class="source-code">    console.log(module.hello_world());</p><p class="source-code">});</p></li>
				<li>Now, head over to the terminal and install the npm dependencies using the following:<p class="source-code"><strong class="bold">$ npm install</strong></p></li>
			</ol>
			<p>Run webpack-dev-server using the following:</p>
			<p class="source-code"><strong class="bold">$ npm run serve </strong></p>
			<p>We have <a id="_idIndexMarker347"/>already used webpack-dev-server <a id="_idIndexMarker348"/>to enable automatic recompiling. We can now go and change the HTML, CSS, or JavaScript file. Once we save the changes, the webpack server will compile everything. Once compiled, the changes are reflected in the browser.</p>
			<p>But wait, what will happen if you change the Rust file? Let's try changing it:</p>
			<p class="source-code">use wasm_bindgen::prelude::*;</p>
			<p class="source-code"> </p>
			<p class="source-code">#[wasm_bindgen]</p>
			<p class="source-code">pub fn hello_world() -&gt; String {</p>
			<p class="source-code">"Hello Universe".to_string()</p>
			<p class="source-code">}</p>
			<p>We made a huge change in our <strong class="source-inline">main.rs</strong> file. Yeah, we changed from <em class="italic">world</em> to <em class="italic">universe</em>; isn't that huge? But once you save the file, you will not see any changes in the browser. In fact, even the webpack compiler is not recompiling things.</p>
			<p>The webpack compiler by default looks for the changes that will happen in the HTML, CSS, and JavaScript files (things that are defined in the configuration file and those that are included inside the dependency graph). But it has no idea about the Rust code.</p>
			<p>We need <a id="_idIndexMarker349"/>to somehow tell webpack to look for the code changes in Rust. We can use a plugin for that, one that will look at <a id="_idIndexMarker350"/>any changes in the specified location of the specified file type. Then, it will retrigger the build process. We will use <strong class="source-inline">wasm-pack-plugin</strong> for this.</p>
			<p>Add the <strong class="source-inline">wasm-pack-plugin</strong> dependency to the application using the following command:</p>
			<p class="source-code">$ npm i @wasm-tool/wasm-pack-plugin -D</p>
			<p>Then, hook this plugin into webpack's plugin system via the <strong class="source-inline">webpack.config.js</strong> file:</p>
			<p class="source-code">const path = require('path');</p>
			<p class="source-code">const HtmlWebpackPlugin = require('html-webpack-plugin');</p>
			<p class="source-code">const WasmPackPlugin = require('@wasm-tool/wasm-pack-</p>
			<p class="source-code">  plugin');</p>
			<p class="source-code"> </p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">    entry: './index.js',</p>
			<p class="source-code">    output: {</p>
			<p class="source-code">        path: path.resolve(__dirname, 'dist'),</p>
			<p class="source-code">        filename: 'bundle.js',</p>
			<p class="source-code">    },</p>
			<p class="source-code">    plugins: [</p>
			<p class="source-code">        new HtmlWebpackPlugin(),</p>
			<p class="source-code">        new WasmPackPlugin({</p>
			<p class="source-code">                crateDirectory: path.resolve(__dirname)</p>
			<p class="source-code">        }),</p>
			<p class="source-code">    ],</p>
			<p class="source-code">    experiments: {</p>
			<p class="source-code">       syncWebAssembly: true,</p>
			<p class="source-code">    },</p>
			<p class="source-code">    mode: 'development'</p>
			<p class="source-code">};</p>
			<p>We import <strong class="source-inline">wasm-pack-plugin</strong>. We specify the crate directory in which the <strong class="source-inline">Cargo.toml</strong> file is present and then the plugin will take care of the auto-reloading part. To see it in action, let's stop and start the webpack server using <strong class="source-inline">npm run serve</strong>.</p>
			<p>Now, let's <a id="_idIndexMarker351"/>edit the <strong class="source-inline">src/main.rs</strong> file with Hello Galaxy. Open the browser to see the console log changed to <strong class="bold">Hello Galaxy</strong> already.</p>
			<p>So, what <a id="_idIndexMarker352"/>happens here?</p>
			<p><strong class="source-inline">wasm-pack-plugin</strong> is hooked into webpack using webpack's plugin system. This will run along with the webpack compiler. If any changes are made in the <strong class="source-inline">src</strong> directory, <strong class="source-inline">wasm-pack-plugin</strong> will then run the <strong class="source-inline">wasm-pack</strong> compilation to compile the Rust code into WebAssembly modules automatically. This will trigger a recompilation in the webpack compiler. Once the webpack compiler recompiles, it will notify <strong class="source-inline">webpack-dev-server</strong> to reload the changes in the browser. The browser then reloads the changes automatically.</p>
			<p><strong class="source-inline">wasm-pack-plugin</strong> makes it easy to run Rust and WebAssembly along with webpack. Now, let's check how we can run Rust and WebAssembly with Parcel.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor107"/>Bundling WebAssembly modules with Parcel</h1>
			<p><em class="italic">Parcel is a blazing-fast, zero-configuration web application bundler.</em><strong class="bold"> </strong>Parcel is <a id="_idIndexMarker353"/>the new kid in the web application <a id="_idIndexMarker354"/>bundler space. It is built from scratch to be fast and needs zero configuration. The main pain point of webpack is its configuration. Although it looks simpler to start with, it gradually becomes more complex and unmanageable when the application grows. But the configuration will give a complete overview of what is happening and how it is bundling. With zero configuration, Parcel will infer the bundle from the initial point (that is, <strong class="source-inline">index.html</strong>) and then build the entire graph from there.</p>
			<p>While webpack has a plugin-based architecture, Parcel has a worker-based architecture. This enables Parcel to be faster than webpack as it uses multicore compilation and cache.</p>
			<p>Parcel also has inbuilt configuration to support JavaScript, CSS, and HTML files. Just like webpack, it also has various plugins that we can use to configure the bundler to produce the required output.</p>
			<p>It also has inbuilt transformation support using standard Babel, PostCSS, and PostHTML when it is required. We can extend them and change them via plugins if needed.</p>
			<p>Parcel also has automatic, out-of-the-box hot module replacement to track and record changes to files (that are recorded by the dependency graph). Let's build WebAssembly modules using parcel as a bundler:</p>
			<ol>
				<li value="1">We will start by creating a new Rust project:<p class="source-code">$ cargo new --lib live_reload_parcel</p><p class="source-code">  Created library `live_reload_parcel` package</p></li>
			</ol>
			<p>Once the project is created, open the project in your favorite editor.</p>
			<ol>
				<li value="2">To define the <strong class="source-inline">wasm-bindgen</strong> dependency for the project, open the <strong class="source-inline">Cargo.toml</strong> file:<p class="source-code">[package]</p><p class="source-code">name = "live_reload_parcel"</p><p class="source-code">version = "0.1.0"</p><p class="source-code">authors = ["Sendil Kumar"]</p><p class="source-code">edition = "2018"</p><p class="source-code"> </p><p class="source-code">[lib]</p><p class="source-code">crate-type = ["cdylib"]</p><p class="source-code"> </p><p class="source-code">[dependencies]</p><p class="source-code"><strong class="bold">wasm-bindgen = "0.2.38"</strong></p></li>
			</ol>
			<p>First, remove the <strong class="source-inline">[dependencies]</strong> tag and replace it with the bold lines above. We are telling the compiler that the library that is getting generated will be dynamic and it has a dependency on the <strong class="source-inline">wasm-bindgen</strong> library.</p>
			<ol>
				<li value="3">Then, we <a id="_idIndexMarker355"/>open the <strong class="source-inline">src/lib.rs</strong> file <a id="_idIndexMarker356"/>and replace the contents with the following:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn hello_world() -&gt; String {</p><p class="source-code">"Hello World".to_string()</p><p class="source-code">}</p></li>
				<li>We will reuse the simple Hello World example here. Build the <strong class="source-inline">wasm</strong> module using the following:<p class="source-code"><strong class="bold">$ cargo build --target wasm32-unknown-unknown</strong></p><p class="source-code"><strong class="bold">$ wasm-bindgen target/wasm32-unknown-</strong></p><p class="source-code"><strong class="bold">  unknown/debug/live_reload_parcel.wasm --out-dir .</strong></p></li>
				<li>Since Parcel supports zero configuration, all we need to do is add Parcel dependencies to <strong class="source-inline">package.json</strong>:<p class="source-code">{</p><p class="source-code">    "scripts": {</p><p class="source-code">        "build": "parcel index.html",</p><p class="source-code">        "serve": "parcel build index.html"</p><p class="source-code">    },</p><p class="source-code">    "devDependencies": {</p><p class="source-code">        "parcel-bundler": "^1.12.3"</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Since <a id="_idIndexMarker357"/>Parcel is a zero-configuration bundler, we just have to define the entry point to it. We define the <a id="_idIndexMarker358"/>entry point in the <strong class="source-inline">scripts</strong> section. The <strong class="source-inline">serve</strong> command is the command that we use to run the code for development purposes. When we define <strong class="source-inline">parcel build index.html</strong>, we are informing Parcel that the entry point is <strong class="source-inline">index.html</strong>.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Please use the latest version applicable here. </p>
			<ol>
				<li value="6">Then, we will create the entry point. We will create an <strong class="source-inline">index.html</strong> file as specified in the <strong class="source-inline">package.json</strong> script:<p class="source-code">&lt;html&gt;</p><p class="source-code">    &lt;head&gt;</p><p class="source-code">        ...</p><p class="source-code">        &lt;script src="./index.js"&gt; &lt;/script&gt;</p><p class="source-code">    &lt;/head&gt;</p><p class="source-code">    &lt;body&gt; ... &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>Create an <strong class="source-inline">index.js</strong> file to load the binding JavaScript, which in turn loads the WebAssembly module generated:<p class="source-code">import { module } from './live_reload_parcel.js';</p><p class="source-code">module.hello_world();</p></li>
				<li>Now, head <a id="_idIndexMarker359"/>over to the terminal. Run <a id="_idIndexMarker360"/>the following command to install the dependencies:<p class="source-code">$ npm install</p></li>
			</ol>
			<p>Run the Parcel application using the following:</p>
			<p class="source-code">$ npm run serve</p>
			<p>Parcel's zero-configuration nature makes it extremely easy to get started with WebAssembly. By default, Parcel supports <strong class="source-inline">.wasm</strong> files. We can even import <strong class="source-inline">.wasm</strong> files just like any other <strong class="source-inline">.js</strong> file.</p>
			<p>It is important to note that synchronously importing WebAssembly modules is still not supported. But we can write an import as a synchronous import. Internally, Parcel will generate the necessary extra code to preload the file before JavaScript execution starts.</p>
			<p>This implies the WebAssembly file will be a separate bundle rather than in line with the bundled JavaScript file.</p>
			<ol>
				<li value="9">Let's change the Rust file and see what happens:<p class="source-code"> use wasm_bindgen::prelude::*;</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn hello_world() -&gt; String {</p><p class="source-code">"Hello Universe".to_string()</p><p class="source-code">}</p></li>
				<li>Once you save the file, you will not see any changes. Parcel has no clue that you have changed the source and the compiler will not react.</li>
			</ol>
			<p>To make Parcel react to the Rust source changes, we need to add a plugin. The plugin is <strong class="source-inline">parcel-plugin-wasm.rs</strong>.</p>
			<ol>
				<li value="11">To install <a id="_idIndexMarker361"/>the plugin, we can run the following:<p class="source-code"><strong class="bold">npm install -D parcel-plugin-wasm.rs</strong></p></li>
			</ol>
			<p>This will <a id="_idIndexMarker362"/>download the plugin to <strong class="source-inline">node_modules</strong>. This will also save the plugin in <strong class="source-inline">package.json</strong>'s <strong class="source-inline">devDependencies</strong>.</p>
			<ol>
				<li value="12">Once installed, we need to change <strong class="source-inline">index.js</strong> such that it looks at the source code directly instead of referencing from the <strong class="source-inline">Cargo.toml</strong> file:<p class="source-code"><strong class="bold">import { hello_world } from './src/lib.rs';</strong></p><p class="source-code"><strong class="bold">// import { hello_world } from './Cargo.toml'; </strong></p><p class="source-code"><strong class="bold">hello_world();</strong></p></li>
			</ol>
			<p>Here, instead of importing from the WebAssembly module, we specify the entry Rust file. We can even specify the location of the <strong class="source-inline">Cargo.toml</strong> file to make Parcel look for changes in the respective places.</p>
			<ol>
				<li value="13">Now, let's edit the <strong class="source-inline">src/main.rs</strong> file with Hello Galaxy. Open the browser to see how the console log has changed to <strong class="bold">Hello Galaxy.</strong></li>
			</ol>
			<p>So, what happens here?</p>
			<p>Parcel just requires the starting point of our application. It will generate the dependency graph from there. The parcel plugin keeps looking for any changes in the folder to happen. It basically looks in the folder that contains the <strong class="source-inline">Cargo.toml</strong> file. The <strong class="source-inline">Cargo.toml</strong> location is given to the Parcel bundler and its plugin via <strong class="source-inline">index.js</strong>.</p>
			<p>So, any changes that happen to the Rust file will lead to the following process.</p>
			<p>When the Rust file is saved, the watchers inside <strong class="source-inline">parcel-plugin-wasm.rs</strong> are triggered. Then, <strong class="source-inline">parcel-plugin-wasm.rs</strong> will initiate the compilation process of the Rust code into WebAssembly via <strong class="source-inline">wasm-pack</strong>. Once <strong class="source-inline">wasm-pack</strong> compiles and produces new WebAssembly code, the plugin will notify the Parcel compiler that something in the dependency graph has been changed.</p>
			<p>The Parcel <a id="_idIndexMarker363"/>compiler then recompiles, which will result in the browser being refreshed. The browser now displays the changed message.</p>
			<p>Note that <a id="_idIndexMarker364"/>for Parcel, we actually used a synchronous module import, while for webpack, we were relying on asynchronous import.</p>
			<p>The <strong class="source-inline">parcel-plugin-wasm.rs</strong> plugin makes it easy to run Rust and WebAssembly along with Parcel. Now, let's check how we can install and use <strong class="source-inline">wasm-pack</strong> to pack and publish WebAssembly modules.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor108"/>Introducing wasm-pack</h1>
			<p>To be compatible with JavaScript, Rust-based WebAssembly applications should be completely <a id="_idIndexMarker365"/>interoperable with the JavaScript world. Without that, it will be difficult for developers to bootstrap their WebAssembly projects in JavaScript.</p>
			<p>The node modules completely changed the perspective of the JavaScript world. They make it easier to develop and share the modules between Browser and Node environments. Developers around the world can use these libraries wherever and whenever they want.</p>
			<p class="author-quote">The <strong class="source-inline">wasm-pack</strong> tool seeks to be a one-stop shop for building and working with Rust-generated WebAssembly that you would like to interoperate with JavaScript, in the browser or with Node.js. <strong class="source-inline">- wasm-pack</strong> website. <a href="https://github.com/rustwasm/wasm-pack">https://github.com/rustwasm/wasm-pack</a></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor109"/>Why do you need wasm-pack?</h2>
			<p><strong class="source-inline">wasm-pack</strong> makes it <a id="_idIndexMarker366"/>easy to build and pack Rust- and WebAssembly-based projects. Once packed, the module is ready to be shared with the world via the npm registry – just like millions (or even billions) of JavaScript libraries out there.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor110"/>How to use wasm-pack</h2>
			<p><strong class="source-inline">wasm-pack</strong> is available <a id="_idIndexMarker367"/>as a Cargo library. If you are following along with this book, then you might have already installed Cargo. To install <strong class="source-inline">wasm-pack</strong>, run the following command:</p>
			<p class="source-code">$ cargo install wasm-pack</p>
			<p>The preceding command will download, compile, and install the <strong class="source-inline">wasm-pack</strong> library. Once installed, the <strong class="source-inline">wasm-pack</strong> command will be available.</p>
			<p>To check whether <strong class="source-inline">wasm-pack</strong> is installed correctly, run the following:</p>
			<p class="source-code">$ wasm-pack --version</p>
			<p class="source-code">wasm-pack 0.6.0</p>
			<p>Once you have <strong class="source-inline">wasm-pack</strong> installed, let's see how to use <strong class="source-inline">wasm-pack</strong> to build and pack Rust and WebAssembly projects:</p>
			<ol>
				<li value="1">We will first generate a new project with Cargo. To generate the project, use the following:<p class="source-code">$ cargo new --lib wasm_pack_world</p><p class="source-code">  Created library `wasm_pack_world` package</p></li>
			</ol>
			<p>Once the project is created, open it in your favorite editor.</p>
			<ol>
				<li value="2">To define the <strong class="source-inline">wasm-bindgen</strong> dependency for the project, open the <strong class="source-inline">cargo.toml</strong> file:<p class="source-code">[package]</p><p class="source-code">name = "wasm_pack_world"</p><p class="source-code">version = "0.1.0"</p><p class="source-code">authors = ["Sendil Kumar"]</p><p class="source-code">edition = "2018"</p><p class="source-code"> </p><p class="source-code">[lib]</p><p class="source-code">crate-type = ["cdylib"]</p><p class="source-code"> </p><p class="source-code">[dependencies]</p><p class="source-code">wasm-bindgen = "0.2.38"</p></li>
			</ol>
			<p>First, remove the <strong class="source-inline">[dependencies]</strong> tag and replace that with the <strong class="source-inline">wasm-bindgen</strong> library. We are telling the compiler that the library that is getting generated will be dynamic and it has a dependency to the <strong class="source-inline">wasm-bindgen</strong> library.</p>
			<ol>
				<li value="3">Then, we <a id="_idIndexMarker368"/>open the <strong class="source-inline">src/lib.rs</strong> file and replace the contents with the following:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn get_me_universe_answer() -&gt; i32 {</p><p class="source-code">    42</p><p class="source-code">}</p></li>
			</ol>
			<p>Again, this is a simple function that returns a number (which is the universal answer).</p>
			<p>Previously, we used to build the Rust and WebAssembly application with <strong class="source-inline">rustc</strong> or Cargo. This produced a WebAssembly binary. But the binary is not useful by itself; it needs a binding file. With <strong class="source-inline">wasm-bindgen</strong>, we will generate the binding file along with the WebAssembly binary.</p>
			<p>These two steps are mandatory, but they are mundane. We can replace them with <strong class="source-inline">wasm-pack</strong>.</p>
			<ol>
				<li value="4">To build <a id="_idIndexMarker369"/>the WebAssembly application with <strong class="source-inline">wasm-pack</strong>, run the following command:<p class="source-code">$ wasm-pack build</p></li>
			</ol>
			<p>When we run <strong class="source-inline">wasm-pack build</strong>, this is what happens:</p>
			<ol>
				<li><strong class="source-inline">wasm-pack</strong> first checks whether the Rust compiler is installed. If it's installed, then it checks whether the Rust compiler is greater than version 1.30.</li>
				<li><strong class="source-inline">wasm-pack</strong> checks for the crate configuration and whether the library indicates that we are generating a dynamic library.</li>
				<li><strong class="source-inline">wasm-pack</strong> validates whether there is any <strong class="source-inline">wasm-target</strong> available for building. If the <strong class="source-inline">wasm32-unknown-unknown</strong> target is not available, <strong class="source-inline">wasm-pack</strong> will download and add the target.</li>
				<li>Once the environment is ready, <strong class="source-inline">wasm-pack</strong> then starts compiling the module and build the WebAssembly Module and binding JavaScript files.</li>
			</ol>
			<p>Note that the <strong class="source-inline">wasm-pack</strong> command also generates the <strong class="source-inline">package.json</strong> file. The <strong class="source-inline">package.json</strong> file looks similar to this:</p>
			<p class="source-code">{</p>
			<p class="source-code">"name": "wasm_pack_world",</p>
			<p class="source-code">"collaborators": [</p>
			<p class="source-code">"Sendil Kumar"</p>
			<p class="source-code">],</p>
			<p class="source-code">"version": "0.1.0",</p>
			<p class="source-code">"files": [</p>
			<p class="source-code">     "wasm_pack_world_bg.wasm",</p>
			<p class="source-code">     "wasm_pack_world.js",</p>
			<p class="source-code">     "wasm_pack_world.d.ts"</p>
			<p class="source-code">],</p>
			<p class="source-code">"module": "wasm_pack_world.js",</p>
			<p class="source-code">"types": "wasm_pack_world.d.ts",</p>
			<p class="source-code">"sideEffects"<a id="_idTextAnchor111"/>: "false"</p>
			<p class="source-code">}</p>
			<ol>
				<li value="5">Finally, it copies over the Readme and LICENSE file if we have one, to ensure there is shared <a id="_idIndexMarker370"/>documentation between the Rust and WebAssembly versions.</li>
			</ol>
			<p><strong class="source-inline">wasm-pack</strong> also checks for the presence of <strong class="source-inline">wasm-bindgen-cli</strong>, which, if not present, will be installed using Cargo.</p>
			<ol>
				<li value="6">When the build has successfully finished, it will create a <strong class="source-inline">pkg</strong> directory. Inside <strong class="source-inline">pkg</strong>, it will pipe the output of <strong class="source-inline">wasm-bindgen</strong>:<p class="source-code">pkg</p><p class="source-code">├── package.json</p><p class="source-code">├── wasm_pack_world.d.ts</p><p class="source-code">├── wasm_pack_world.js</p><p class="source-code">├── wasm_pack_world_bg.d.ts</p><p class="source-code">└── wasm_pack_world_bg.wasm</p></li>
			</ol>
			<p>Now, this <strong class="source-inline">pkg</strong> folder can be bundled and shared like any other JavaScript module. We'll see how to achieve that in the future recipes.</p>
			<p><strong class="source-inline">wasm-pack</strong> is a great tool to pack and publish WebAssembly modules. Now, let's check out how to use it.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor112"/>Packing and publishing using wasm-pack</h1>
			<p>The most amazing (and, of course, the most important) thing for a library developer to do is to <a id="_idIndexMarker371"/>pack and publish artifacts. That is why we spend our <a id="_idIndexMarker372"/>days and nights carefully crafting the application, publishing it to the world, receiving feedback (either negative or positive), and then enhancing the application based on that.</p>
			<p>The critical point for any project is its first release, which defines the fate of the project. Even though it is simply an MVP, it will give the world a glimpse of what we are working on and gives us a glimpse of what we have to work on in the future.</p>
			<p><strong class="source-inline">wasm-pack</strong> helps us to build, pack, and publish Rust- and WebAssembly-based projects into the npm registry. We have already seen how <strong class="source-inline">wasm-pack</strong> makes it simpler to build Rust into the WebAssembly binary along with the binding JavaScript file using <strong class="source-inline">wasm-bindgen</strong> underneath. Let's further explore what we can do with its <strong class="source-inline">pack</strong> and <strong class="source-inline">publish</strong> flags. </p>
			<p><strong class="source-inline">wasm-pack</strong> provides a <strong class="source-inline">pack</strong> flag to pack the artifacts that were generated using the <strong class="source-inline">wasm-pack</strong> build command. Although it is not necessary to use <strong class="source-inline">wasm-pack</strong> to build binaries, it generates all the boilerplate that we will need to pack the artifacts into a Node module. </p>
			<p>In order to pack the built artifacts using <strong class="source-inline">wasm-pack</strong>, we have to run the following command with reference to <strong class="source-inline">pkg</strong> (or the directory with which we generated our build artifacts):</p>
			<p class="source-code">$ wasm-pack pack pkg</p>
			<p>We can also run the command by passing in <strong class="source-inline">project_folder/pkg</strong> as its argument. Without any argument, the <strong class="source-inline">wasm-pack pack</strong> command will search for the <strong class="source-inline">pkg</strong> directory in the current working directory where it is running.</p>
			<p>The <strong class="source-inline">wasm-pack pack</strong> command first identifies whether the folder provided is a <strong class="source-inline">pkg</strong> directory or contains a <strong class="source-inline">pkg</strong> directory as its immediate child. If the check passes, then <strong class="source-inline">wasm-pack</strong> will invoke the npm pack command underneath, to pack the library into an npm package.</p>
			<p>To bundle the npm package, all we need is a valid <strong class="source-inline">package.json</strong> file. That file is generated by the <strong class="source-inline">wasm-pack</strong> build command.</p>
			<p>We can <a id="_idIndexMarker373"/>run the <strong class="source-inline">pack</strong> command inside the <strong class="source-inline">cg-array-world</strong> example <a id="_idIndexMarker374"/>from our previous recipe and check what happens:</p>
			<p class="source-code">$ wasm-pack pack</p>
			<p class="source-code">npm notice</p>
			<p class="source-code">npm notice 📦 cg-array-world@0.1.0</p>
			<p class="source-code">npm notice === Tarball Contents ===</p>
			<p class="source-code">npm notice 313B package.json</p>
			<p class="source-code">npm notice 32.7kB cg_array_world_bg.wasm</p>
			<p class="source-code">npm notice 135B cg_array_world.d.ts</p>
			<p class="source-code">npm notice 1.6kB cg_array_world.js</p>
			<p class="source-code">npm notice 1.5kB README.md</p>
			<p class="source-code">npm notice === Tarball Details ===</p>
			<p class="source-code">npm notice name: cg-array-world</p>
			<p class="source-code">npm notice version: 0.1.0</p>
			<p class="source-code">npm notice filename: cg-array-world-0.1.0.tgz</p>
			<p class="source-code">npm notice package size: 16.0 kB</p>
			<p class="source-code">npm notice unpacked size: 36.4 kB</p>
			<p class="source-code">npm notice shasum: 243488f1f5a859b60bb34f39146b35ba720dd8ea</p>
			<p class="source-code">npm notice integrity: sha512-9SFuObzEpi254[...]/lkHq6RKSgnNw==</p>
			<p class="source-code">npm notice total files: 5</p>
			<p class="source-code">npm notice</p>
			<p class="source-code">cg-array-world-0.1.0.tgz</p>
			<p class="source-code">| 🎒 packed up your package!</p>
			<p>As you can see here, the <strong class="source-inline">pack</strong> command creates a tarball package with the contents inside the <strong class="source-inline">pkg</strong> folder with the help of the <strong class="source-inline">npm pack</strong> command.</p>
			<p>Once we have packed our application, the obvious next step will be to publish it. In order to publish the tarball generated, <strong class="source-inline">wasm-pack</strong> has a <strong class="source-inline">publish</strong> option.</p>
			<p>In order <a id="_idIndexMarker375"/>to publish the package, we have to run the following command:</p>
			<p class="source-code">$ wasm-pack publish</p>
			<p>The <strong class="source-inline">wasm-pack publish</strong> command will first check whether the <strong class="source-inline">pkg</strong> directory is already <a id="_idIndexMarker376"/>present in the directory provided.</p>
			<p>If the <strong class="source-inline">pkg</strong> directory is not present, then it will ask whether you want to create the package first:</p>
			<p class="source-code">$ wasm-pack publish</p>
			<p class="source-code">Your package hasn't been built, build it? [Y/n]</p>
			<p>If you answer <strong class="source-inline">Y</strong> to the question, then it asks for you to input the folder in which you want to generate the build artifacts. We can give any folder name or use the default:</p>
			<p class="source-code">$ wasm-pack publish</p>
			<p class="source-code">Your package hasn't been built, build it? yes</p>
			<p class="source-code">out_dir[default: pkg]:</p>
			<p>Then, it asks for your target, that is, the target in which the build should be generated. You can choose between the various options here, as discussed in the build recipe:</p>
			<p class="source-code">$ wasm-pack publish</p>
			<p class="source-code">Your package hasn't been built, build it? yes</p>
			<p class="source-code">out_dir[default: pkg]: .</p>
			<p class="source-code">target[default: browser]:</p>
			<p class="source-code">&gt; browser</p>
			<p class="source-code">nodejs</p>
			<p class="source-code">no-modules</p>
			<p>Based on the option provided, it will generate the artifact in the specified folder.</p>
			<p>Once the artifacts are produced, they are then ready to be published using npm publish. For npm <a id="_idIndexMarker377"/>publish to work correctly, we need to be authenticated. You <a id="_idIndexMarker378"/>can authenticate to npm by using either npm login or <strong class="source-inline">wasm-pack</strong> login.</p>
			<p>The <strong class="source-inline">wasm-pack login</strong> command will invoke the underlying npm login command and then create a session:</p>
			<p class="source-code">$ wasm-pack login</p>
			<p class="source-code">Username: sendilkumarn</p>
			<p class="source-code">Password: *************</p>
			<p class="source-code">login succeeded.</p>
			<p>The <strong class="source-inline">wasm-pack publish</strong> command also supports two options, namely the following:</p>
			<ul>
				<li><strong class="source-inline">-a</strong> or <strong class="source-inline">--access</strong> to determine <a id="_idIndexMarker379"/>the access level of the package to be deployed.</li>
			</ul>
			<p>This accepts either <strong class="source-inline">public</strong> or <strong class="source-inline">restricted</strong>:</p>
			<ul>
				<li><strong class="source-inline">public</strong> – Makes the package public </li>
				<li><strong class="source-inline">restricted</strong> – Makes the package internal</li>
			</ul>
			<ul>
				<li><strong class="source-inline">-t</strong> or <strong class="source-inline">--target</strong> to support <a id="_idIndexMarker380"/>various targets in which the build is produced.</li>
			</ul>
			<p>Thus, <strong class="source-inline">wasm-pack</strong> makes it easy to pack and publish WebAssembly binaries. </p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor113"/>Summary</h1>
			<p>In this chapter, we saw how to run a WebAssembly project with bundlers such as webpack and Parcel. Parcel and webpack make it easy for JavaScript developers to run and develop Rust and WebAssembly projects. Then, we installed <strong class="source-inline">wasm-pack</strong> and used it to run the project. Finally, we used <strong class="source-inline">wasm-pack</strong> to pack and publish the WebAssembly module to npm.  </p>
			<p>In the next chapter, we will explore how to share complex objects between Rust and WebAssembly with <strong class="source-inline">wasm-bindgen</strong>.</p>
		</div>
	</body></html>