<html><head></head><body>
		<div><h1 id="_idParaDest-89"><em class="italic"><a id="_idTextAnchor102"/>Chapter 8</em>: Bundling WebAssembly Using wasm-pack</h1>
			<p>JavaScript is omnipresent, but being everywhere is both an advantage and a disadvantage. There are many different ecosystems that have various standards and purposes. Building a unique solution for all ecosystems is not practical.</p>
			<p>Despite all this, the JavaScript community is doing a wonderful job here. The effort from the community makes JavaScript one of the go-to languages. For a language as versatile as JavaScript, there will be some weird corners (which of course every language has). When you are writing JavaScript, these need extra care and attention.</p>
			<p>JavaScript is dynamically typed. This makes it difficult (almost impossible) to avoid runtime exceptions. While TypeScript, Flow, and Elm try to provide a (typed) superset on JavaScript's dynamic types, they cannot completely fix the underlying problem.</p>
			<p>For any language to grow, it has to evolve fast, which JavaScript does. Evolving fast without breaking the existing usage is also important and JavaScript provides polyfills to make it backward compatible.</p>
			<p>But creating polyfills is a mundane task. There are various other mundane steps, such as bundling and packaging libraries, minifying bundles, and lazy-loading libraries, to name a few. Bundlers provide a solution to most of them. They act as a compiler for the frontend.</p>
			<p>So far, we have seen how Rust makes it easy to create and run WebAssembly modules. In this chapter, we will explore <code>wasm-pack</code>, a tool that makes it easier to pack and publish WebAssembly modules. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Bundling WebAssembly modules with webpack</li>
				<li>Bundling WebAssembly modules with Parcel</li>
				<li>Introducing <code>wasm-pack</code></li>
				<li>Packing and publishing using <code>wasm-pack</code></li>
			</ul>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor103"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor104"/>Bundling WebAssembly modules with webpack </h1>
			<p>webpack is a static module bundler for modern JavaScript applications. So, what does it do?</p>
			<p>You can <a id="_idIndexMarker334"/>consider webpack as an informal compiler for the frontend. webpack takes in an entry point of an application, slowly <a id="_idIndexMarker335"/>runs through the modules, and builds a dependency graph. The dependency graph holds all the modules. These modules are necessary for the application to run.</p>
			<p>Once the dependency graph is built, webpack outputs one or more bundles. Webpack is very flexible, helping us to bundle or package JavaScript as we need it and the options are provided in the webpack configuration. Based on the provided options, webpack creates the output.</p>
			<p><em class="italic">Well, that sounds simple, right?</em></p>
			<p>It was that simple a few years ago when the only library that we needed was jQuery.</p>
			<p>But due to JavaScript's rapid evolution, there are a lot of different things happening now. The underlying runtime is not the same. There are three different browser engines and various targets.</p>
			<p>Browser engines evolve at different speeds and browsers support various versions of JavaScript. In some workplace machines, upgrading browsers to the latest version is prohibited. This means the running JavaScript application needs tweaking and polyfills at various times.</p>
			<p>The underlying target system needs a certain tweak to make your JavaScript code run. Doing all this by hand will take a long time to complete and will be error-prone.</p>
			<p>There are various flavors of JavaScript, including TypeScript and CoffeeScript. They are different, but they will compile down to JavaScript before running. Browser-based development needs CSS, SCSS, SASS, and LESS. Supporting all those variations and compiling them manually after every change is not an easy deal.</p>
			<p>JavaScript's answer to all this is bundlers. Whether you hate them or love them, bundlers reduce the overload and remove the clutter when developing with JavaScript.</p>
			<p>webpack provides a solution to all these problems and more.</p>
			<p>webpack is a tool built for bundling JavaScript applications. It comes with loaders and plugins that will help to convert, add, remove, and manipulate the output bundles. The most interesting part of webpack is its loaders and plugins, which propel the ability of webpack to the fullest.</p>
			<p>Loaders <a id="_idIndexMarker336"/>allow us to load or import a Rust, CSS, or TypeScript file like any other module inside JavaScript. webpack then takes care of producing the bundle that will support the target environment as specified.</p>
			<p>Plugins <a id="_idIndexMarker337"/>allow us to optimize and manage the bundles produced. It is important to note that webpack is built entirely on top of this plugin system.</p>
			<p><em class="italic">How does webpack help with WebAssembly?</em></p>
			<p>webpack internally depends on <a id="_idTextAnchor105"/>the <code>webassemblyjs</code> library. So, all the applications that use webpack are already WebAssembly-ready. All you have to do is start loading the WebAssembly file as normal JavaScript and webpack will take care of the rest.</p>
			<p>In the webpack configuration, we will define the entry point. webpack then loads the entry file. The <code>import</code> statements in the entry file are loaded as a module based on JavaScript's module resolution algorithm. If the imported module is a WebAssembly module, it gets the module's content and hands it over to the <code>webassemblyjs</code> compiler.</p>
			<p>The compiler is responsible for parsing and mutating the WebAssembly modules.</p>
			<p class="callout-heading">Did You Know? </p>
			<p class="callout"><code>webassemblyjs</code> can parse <a id="_idIndexMarker338"/>the WebAssembly text format and WebAssembly binary format out of the box.</p>
			<p>The compiler generates the <strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>). The generated AST is then validated. Once the validation is successful, any custom sections in the WebAssembly module are removed.</p>
			<p>The custom section is a section inside the WebAssembly module where users can store custom information about the WebAssembly module. This information may include names of the function and local variables. Browsers may then use this information to have a better debugging process.</p>
			<p>webpack <a id="_idIndexMarker339"/>also does not support the <a id="_idIndexMarker340"/>start section. The start section is a section in a WebAssembly module that will be called as soon as the WebAssembly module is loaded.</p>
			<p>Instead, webpack creates a function and calls it after the WebAssembly module is loaded. <code>webassemblyjs</code> removes the start section and converts the start function into a normal function on the WebAssembly module. Then, webpack takes care of generating the wrapper that calls the function as soon as the module is loaded.</p>
			<p>Finally, <code>webassemblyjs</code> is also responsible for optimizing the binary and eliminating dead code from the WebAssembly module.</p>
			<p><code>webassemblyjs</code> comes with an interpreter and CLI, which makes it easy to experiment with the WebAssembly modules.</p>
			<p class="author-quote"><strong class="bold">Code, refresh, and repeat.</strong></p>
			<p>This was the workflow for web development for a long time. Live reloading provides an extra pair of hands to web developers. Live reloading can automatically compile and reload the changes once the code is saved. The code can be shared across multiple devices, factors, and orientations. Interactions in one place can automatically be synchronized with other devices. While the web provides a medium to deliver software easily, it comes in various forms. These forms are feature phones, smartphones, tablets, laptops, computers, ultra-wide monitors, 360-degree virtual worlds, and so on. Supporting all or some of them is an uphill task. Live reloading works like an extra pair of hands.</p>
			<p>webpack provides multiple options to add live reloading to your application. It provides plugins for live reloading tools, such as BrowserSync. The webpack ecosystem also provides a watch mode in its configuration.</p>
			<p>The watch mode, once enabled, looks for any changes that happen in the source file and its directory. Once the changes are detected, it will recompile automatically. But watch mode is for recompiling input into output.</p>
			<p>The automatic reloading of web pages is provided by a library <a id="_idTextAnchor106"/>called webpack-dev-server. webpack-dev-server is an in-memory web server. The contents are generated and are placed in memory rather than in actual files in the filesystem.</p>
			<p>In addition <a id="_idIndexMarker341"/>to that, webpack-dev-server also supports Hot Module Replacement. This allows the server to patch only the <a id="_idIndexMarker342"/>changes in the browser rather than doing a full page refresh.</p>
			<p>Let's see how we can enable live reloading in a WebAssembly project:</p>
			<ol>
				<li>First, we will create a new Rust project:<pre>$ cargo new --lib live_reload
Â Â Created library `live_reload` package</pre></li>
				<li>Once the project is created, open it in your favorite editor. To define the <code>wasm-bindgen</code> dependency for the project, open the <code>Cargo.toml</code> file:<pre>[package]
name = "live_reload"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
 
[lib]
crate-type = ["cdylib"]
 
[dependencies]
wasm-bindgen = "0.2.38"</pre></li>
			</ol>
			<p>First, add the <code>[lib]</code> section and add <code>crate-type = ["cdylib"]</code>. With the <code>crate-type</code> option, we are instructing the compiler that the library is dynamic. After that, add the <code>wasm-bindgen</code> dependency to the <code>[dependencies]</code> tag.</p>
			<ol>
				<li value="3">Then, open the <code>src/lib.rs</code> file and replace the contents with the following:<pre>use wasm_bindgen::prelude::*;
 
#[wasm_bindgen]
pub fn hello_world() -&gt; String {
"Hello World".to_string()
}</pre></li>
				<li>We will <a id="_idIndexMarker343"/>reuse the simple Hello <a id="_idIndexMarker344"/>World example from previous chapters here. Build the WASM module using the following:<pre>$ cargo build --target wasm32-unknown-unknown
$ wasm-bindgen target/wasm32-unknown-
Â Â unknown/debug/live_reload.wasm --out-dir .</pre></li>
				<li>Then create a <code>webpack.config.js</code> file to instruct webpack on how to handle and compile the files:<pre>const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-
Â Â plugin');
 
module.exports = {
Â Â Â Â entry: './index.js',
Â Â Â Â output: {
Â Â Â Â Â Â Â Â path: path.resolve(__dirname, 'dist'),
Â Â Â Â Â Â Â Â filename: 'bundle.js',
Â Â Â Â },
Â Â Â Â plugins: [
Â Â Â Â Â Â Â Â new HtmlWebpackPlugin(),
Â Â Â Â ],
Â Â Â Â experiments: {
Â Â Â Â Â Â Â syncWebAssembly: true,
Â Â Â Â },
Â Â Â Â mode: 'development'
};</pre></li>
				<li>Add <a id="_idIndexMarker345"/>a <code>package.json</code> file <a id="_idIndexMarker346"/>to download the webpack dependencies:<pre>{
Â Â Â Â "scripts": {
Â Â Â Â Â Â Â Â "build": "webpack",
Â Â Â Â Â Â Â Â "serve": "webpack-dev-server"
Â Â Â Â },
Â Â Â Â "devDependencies": {
Â Â Â Â Â Â Â Â "html-webpack-plugin": "^5.5.0",
Â Â Â Â Â Â Â Â "webpack": "^5.64.1",
Â Â Â Â Â Â Â Â "webpack-cli": "^4.9.1",
Â Â Â Â Â Â Â Â "webpack-dev-server": "^4.5.0"
Â Â Â Â }
}</pre><p class="callout-heading">Note </p><p class="callout">Please use the latest version of the dependencies applicable here. </p></li>
				<li>Create an <code>index.js</code> file to load the binding JavaScript that in turn loads the WebAssembly module generated:<pre>import("./live_reload").then(module =&gt; {
Â Â Â Â console.log(module.hello_world());
});</pre></li>
				<li>Now, head over to the terminal and install the npm dependencies using the following:<pre><strong class="bold">$ npm install</strong></pre></li>
			</ol>
			<p>Run webpack-dev-server using the following:</p>
			<pre><strong class="bold">$ npm run serve </strong></pre>
			<p>We have <a id="_idIndexMarker347"/>already used webpack-dev-server <a id="_idIndexMarker348"/>to enable automatic recompiling. We can now go and change the HTML, CSS, or JavaScript file. Once we save the changes, the webpack server will compile everything. Once compiled, the changes are reflected in the browser.</p>
			<p>But wait, what will happen if you change the Rust file? Let's try changing it:</p>
			<pre>use wasm_bindgen::prelude::*;
 
#[wasm_bindgen]
pub fn hello_world() -&gt; String {
"Hello Universe".to_string()
}</pre>
			<p>We made a huge change in our <code>main.rs</code> file. Yeah, we changed from <em class="italic">world</em> to <em class="italic">universe</em>; isn't that huge? But once you save the file, you will not see any changes in the browser. In fact, even the webpack compiler is not recompiling things.</p>
			<p>The webpack compiler by default looks for the changes that will happen in the HTML, CSS, and JavaScript files (things that are defined in the configuration file and those that are included inside the dependency graph). But it has no idea about the Rust code.</p>
			<p>We need <a id="_idIndexMarker349"/>to somehow tell webpack to look for the code changes in Rust. We can use a plugin for that, one that will look at <a id="_idIndexMarker350"/>any changes in the specified location of the specified file type. Then, it will retrigger the build process. We will use <code>wasm-pack-plugin</code> for this.</p>
			<p>Add the <code>wasm-pack-plugin</code> dependency to the application using the following command:</p>
			<pre>$ npm i @wasm-tool/wasm-pack-plugin -D</pre>
			<p>Then, hook this plugin into webpack's plugin system via the <code>webpack.config.js</code> file:</p>
			<pre>const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const WasmPackPlugin = require('@wasm-tool/wasm-pack-
Â Â plugin');
 
module.exports = {
Â Â Â Â entry: './index.js',
Â Â Â Â output: {
Â Â Â Â Â Â Â Â path: path.resolve(__dirname, 'dist'),
Â Â Â Â Â Â Â Â filename: 'bundle.js',
Â Â Â Â },
Â Â Â Â plugins: [
Â Â Â Â Â Â Â Â new HtmlWebpackPlugin(),
Â Â Â Â Â Â Â Â new WasmPackPlugin({
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â crateDirectory: path.resolve(__dirname)
Â Â Â Â Â Â Â Â }),
Â Â Â Â ],
Â Â Â Â experiments: {
Â Â Â Â Â Â Â syncWebAssembly: true,
Â Â Â Â },
Â Â Â Â mode: 'development'
};</pre>
			<p>We import <code>wasm-pack-plugin</code>. We specify the crate directory in which the <code>Cargo.toml</code> file is present and then the plugin will take care of the auto-reloading part. To see it in action, let's stop and start the webpack server using <code>npm run serve</code>.</p>
			<p>Now, let's <a id="_idIndexMarker351"/>edit the <code>src/main.rs</code> file with Hello Galaxy. Open the browser to see the console log changed to <strong class="bold">Hello Galaxy</strong> already.</p>
			<p>So, what <a id="_idIndexMarker352"/>happens here?</p>
			<p><code>wasm-pack-plugin</code> is hooked into webpack using webpack's plugin system. This will run along with the webpack compiler. If any changes are made in the <code>src</code> directory, <code>wasm-pack-plugin</code> will then run the <code>wasm-pack</code> compilation to compile the Rust code into WebAssembly modules automatically. This will trigger a recompilation in the webpack compiler. Once the webpack compiler recompiles, it will notify <code>webpack-dev-server</code> to reload the changes in the browser. The browser then reloads the changes automatically.</p>
			<p><code>wasm-pack-plugin</code> makes it easy to run Rust and WebAssembly along with webpack. Now, let's check how we can run Rust and WebAssembly with Parcel.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor107"/>Bundling WebAssembly modules with Parcel</h1>
			<p><em class="italic">Parcel is a blazing-fast, zero-configuration web application bundler.</em><code>index.html</code>) and then build the entire graph from there.</p>
			<p>While webpack has a plugin-based architecture, Parcel has a worker-based architecture. This enables Parcel to be faster than webpack as it uses multicore compilation and cache.</p>
			<p>Parcel also has inbuilt configuration to support JavaScript, CSS, and HTML files. Just like webpack, it also has various plugins that we can use to configure the bundler to produce the required output.</p>
			<p>It also has inbuilt transformation support using standard Babel, PostCSS, and PostHTML when it is required. We can extend them and change them via plugins if needed.</p>
			<p>Parcel also has automatic, out-of-the-box hot module replacement to track and record changes to files (that are recorded by the dependency graph). Let's build WebAssembly modules using parcel as a bundler:</p>
			<ol>
				<li value="1">We will start by creating a new Rust project:<pre>$ cargo new --lib live_reload_parcel
Â Â Created library `live_reload_parcel` package</pre></li>
			</ol>
			<p>Once the project is created, open the project in your favorite editor.</p>
			<ol>
				<li value="2">To define the <code>wasm-bindgen</code> dependency for the project, open the <code>Cargo.toml</code> file:<pre>[package]
name = "live_reload_parcel"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
 
[lib]
crate-type = ["cdylib"]
 
[dependencies]
<strong class="bold">wasm-bindgen = "0.2.38"</strong></pre></li>
			</ol>
			<p>First, remove the <code>[dependencies]</code> tag and replace it with the bold lines above. We are telling the compiler that the library that is getting generated will be dynamic and it has a dependency on the <code>wasm-bindgen</code> library.</p>
			<ol>
				<li value="3">Then, we <a id="_idIndexMarker355"/>open the <code>src/lib.rs</code> file <a id="_idIndexMarker356"/>and replace the contents with the following:<pre>use wasm_bindgen::prelude::*;
 
#[wasm_bindgen]
pub fn hello_world() -&gt; String {
"Hello World".to_string()
}</pre></li>
				<li>We will reuse the simple Hello World example here. Build the <code>wasm</code> module using the following:<pre><strong class="bold">$ cargo build --target wasm32-unknown-unknown</strong>
<strong class="bold">$ wasm-bindgen target/wasm32-unknown-</strong>
<strong class="bold">Â Â unknown/debug/live_reload_parcel.wasm --out-dir .</strong></pre></li>
				<li>Since Parcel supports zero configuration, all we need to do is add Parcel dependencies to <code>package.json</code>:<pre>{
Â Â Â Â "scripts": {
Â Â Â Â Â Â Â Â "build": "parcel index.html",
Â Â Â Â Â Â Â Â "serve": "parcel build index.html"
Â Â Â Â },
Â Â Â Â "devDependencies": {
Â Â Â Â Â Â Â Â "parcel-bundler": "^1.12.3"
Â Â Â Â }
}</pre></li>
			</ol>
			<p>Since <a id="_idIndexMarker357"/>Parcel is a zero-configuration bundler, we just have to define the entry point to it. We define the <a id="_idIndexMarker358"/>entry point in the <code>scripts</code> section. The <code>serve</code> command is the command that we use to run the code for development purposes. When we define <code>parcel build index.html</code>, we are informing Parcel that the entry point is <code>index.html</code>.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Please use the latest version applicable here. </p>
			<ol>
				<li value="6">Then, we will create the entry point. We will create an <code>index.html</code> file as specified in the <code>package.json</code> script:<pre>&lt;html&gt;
Â Â Â Â &lt;head&gt;
Â Â Â Â Â Â Â Â ...
Â Â Â Â Â Â Â Â &lt;script src="img/index.js"&gt; &lt;/script&gt;
Â Â Â Â &lt;/head&gt;
Â Â Â Â &lt;body&gt; ... &lt;/body&gt;
&lt;/html&gt;</pre></li>
				<li>Create an <code>index.js</code> file to load the binding JavaScript, which in turn loads the WebAssembly module generated:<pre>import { module } from './live_reload_parcel.js';
module.hello_world();</pre></li>
				<li>Now, head <a id="_idIndexMarker359"/>over to the terminal. Run <a id="_idIndexMarker360"/>the following command to install the dependencies:<pre>$ npm install</pre></li>
			</ol>
			<p>Run the Parcel application using the following:</p>
			<pre>$ npm run serve</pre>
			<p>Parcel's zero-configuration nature makes it extremely easy to get started with WebAssembly. By default, Parcel supports <code>.wasm</code> files. We can even import <code>.wasm</code> files just like any other <code>.js</code> file.</p>
			<p>It is important to note that synchronously importing WebAssembly modules is still not supported. But we can write an import as a synchronous import. Internally, Parcel will generate the necessary extra code to preload the file before JavaScript execution starts.</p>
			<p>This implies the WebAssembly file will be a separate bundle rather than in line with the bundled JavaScript file.</p>
			<ol>
				<li value="9">Let's change the Rust file and see what happens:<pre> use wasm_bindgen::prelude::*;
 
#[wasm_bindgen]
pub fn hello_world() -&gt; String {
"Hello Universe".to_string()
}</pre></li>
				<li>Once you save the file, you will not see any changes. Parcel has no clue that you have changed the source and the compiler will not react.</li>
			</ol>
			<p>To make Parcel react to the Rust source changes, we need to add a plugin. The plugin is <code>parcel-plugin-wasm.rs</code>.</p>
			<ol>
				<li value="11">To install <a id="_idIndexMarker361"/>the plugin, we can run the following:<pre><strong class="bold">npm install -D parcel-plugin-wasm.rs</strong></pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker362"/>download the plugin to <code>node_modules</code>. This will also save the plugin in <code>package.json</code>'s <code>devDependencies</code>.</p>
			<ol>
				<li value="12">Once installed, we need to change <code>index.js</code> such that it looks at the source code directly instead of referencing from the <code>Cargo.toml</code> file:<pre><strong class="bold">import { hello_world } from './src/lib.rs';</strong>
<strong class="bold">// import { hello_world } from './Cargo.toml'; </strong>
<strong class="bold">hello_world();</strong></pre></li>
			</ol>
			<p>Here, instead of importing from the WebAssembly module, we specify the entry Rust file. We can even specify the location of the <code>Cargo.toml</code> file to make Parcel look for changes in the respective places.</p>
			<ol>
				<li value="13">Now, let's edit the <code>src/main.rs</code> file with Hello Galaxy. Open the browser to see how the console log has changed to <strong class="bold">Hello Galaxy.</strong></li>
			</ol>
			<p>So, what happens here?</p>
			<p>Parcel just requires the starting point of our application. It will generate the dependency graph from there. The parcel plugin keeps looking for any changes in the folder to happen. It basically looks in the folder that contains the <code>Cargo.toml</code> file. The <code>Cargo.toml</code> location is given to the Parcel bundler and its plugin via <code>index.js</code>.</p>
			<p>So, any changes that happen to the Rust file will lead to the following process.</p>
			<p>When the Rust file is saved, the watchers inside <code>parcel-plugin-wasm.rs</code> are triggered. Then, <code>parcel-plugin-wasm.rs</code> will initiate the compilation process of the Rust code into WebAssembly via <code>wasm-pack</code>. Once <code>wasm-pack</code> compiles and produces new WebAssembly code, the plugin will notify the Parcel compiler that something in the dependency graph has been changed.</p>
			<p>The Parcel <a id="_idIndexMarker363"/>compiler then recompiles, which will result in the browser being refreshed. The browser now displays the changed message.</p>
			<p>Note that <a id="_idIndexMarker364"/>for Parcel, we actually used a synchronous module import, while for webpack, we were relying on asynchronous import.</p>
			<p>The <code>parcel-plugin-wasm.rs</code> plugin makes it easy to run Rust and WebAssembly along with Parcel. Now, let's check how we can install and use <code>wasm-pack</code> to pack and publish WebAssembly modules.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor108"/>Introducing wasm-pack</h1>
			<p>To be compatible with JavaScript, Rust-based WebAssembly applications should be completely <a id="_idIndexMarker365"/>interoperable with the JavaScript world. Without that, it will be difficult for developers to bootstrap their WebAssembly projects in JavaScript.</p>
			<p>The node modules completely changed the perspective of the JavaScript world. They make it easier to develop and share the modules between Browser and Node environments. Developers around the world can use these libraries wherever and whenever they want.</p>
			<p class="author-quote">The <code>wasm-pack</code> tool seeks to be a one-stop shop for building and working with Rust-generated WebAssembly that you would like to interoperate with JavaScript, in the browser or with Node.js. <code>- wasm-pack</code> website. <a href="https://github.com/rustwasm/wasm-pack">https://github.com/rustwasm/wasm-pack</a></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor109"/>Why do you need wasm-pack?</h2>
			<p><code>wasm-pack</code> makes it <a id="_idIndexMarker366"/>easy to build and pack Rust- and WebAssembly-based projects. Once packed, the module is ready to be shared with the world via the npm registry â€“ just like millions (or even billions) of JavaScript libraries out there.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor110"/>How to use wasm-pack</h2>
			<p><code>wasm-pack</code> is available <a id="_idIndexMarker367"/>as a Cargo library. If you are following along with this book, then you might have already installed Cargo. To install <code>wasm-pack</code>, run the following command:</p>
			<pre>$ cargo install wasm-pack</pre>
			<p>The preceding command will download, compile, and install the <code>wasm-pack</code> library. Once installed, the <code>wasm-pack</code> command will be available.</p>
			<p>To check whether <code>wasm-pack</code> is installed correctly, run the following:</p>
			<pre>$ wasm-pack --version
wasm-pack 0.6.0</pre>
			<p>Once you have <code>wasm-pack</code> installed, let's see how to use <code>wasm-pack</code> to build and pack Rust and WebAssembly projects:</p>
			<ol>
				<li value="1">We will first generate a new project with Cargo. To generate the project, use the following:<pre>$ cargo new --lib wasm_pack_world
Â Â Created library `wasm_pack_world` package</pre></li>
			</ol>
			<p>Once the project is created, open it in your favorite editor.</p>
			<ol>
				<li value="2">To define the <code>wasm-bindgen</code> dependency for the project, open the <code>cargo.toml</code> file:<pre>[package]
name = "wasm_pack_world"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
 
[lib]
crate-type = ["cdylib"]
 
[dependencies]
wasm-bindgen = "0.2.38"</pre></li>
			</ol>
			<p>First, remove the <code>[dependencies]</code> tag and replace that with the <code>wasm-bindgen</code> library. We are telling the compiler that the library that is getting generated will be dynamic and it has a dependency to the <code>wasm-bindgen</code> library.</p>
			<ol>
				<li value="3">Then, we <a id="_idIndexMarker368"/>open the <code>src/lib.rs</code> file and replace the contents with the following:<pre>use wasm_bindgen::prelude::*;
 
#[wasm_bindgen]
pub fn get_me_universe_answer() -&gt; i32 {
Â Â Â Â 42
}</pre></li>
			</ol>
			<p>Again, this is a simple function that returns a number (which is the universal answer).</p>
			<p>Previously, we used to build the Rust and WebAssembly application with <code>rustc</code> or Cargo. This produced a WebAssembly binary. But the binary is not useful by itself; it needs a binding file. With <code>wasm-bindgen</code>, we will generate the binding file along with the WebAssembly binary.</p>
			<p>These two steps are mandatory, but they are mundane. We can replace them with <code>wasm-pack</code>.</p>
			<ol>
				<li value="4">To build <a id="_idIndexMarker369"/>the WebAssembly application with <code>wasm-pack</code>, run the following command:<pre>$ wasm-pack build</pre></li>
			</ol>
			<p>When we run <code>wasm-pack build</code>, this is what happens:</p>
			<ol>
				<li><code>wasm-pack</code> first checks whether the Rust compiler is installed. If it's installed, then it checks whether the Rust compiler is greater than version 1.30.</li>
				<li><code>wasm-pack</code> checks for the crate configuration and whether the library indicates that we are generating a dynamic library.</li>
				<li><code>wasm-pack</code> validates whether there is any <code>wasm-target</code> available for building. If the <code>wasm32-unknown-unknown</code> target is not available, <code>wasm-pack</code> will download and add the target.</li>
				<li>Once the environment is ready, <code>wasm-pack</code> then starts compiling the module and build the WebAssembly Module and binding JavaScript files.</li>
			</ol>
			<p>Note that the <code>wasm-pack</code> command also generates the <code>package.json</code> file. The <code>package.json</code> file looks similar to this:</p>
			<pre>{
"name": "wasm_pack_world",
"collaborators": [
"Sendil Kumar"
],
"version": "0.1.0",
"files": [
Â Â Â Â Â "wasm_pack_world_bg.wasm",
Â Â Â Â Â "wasm_pack_world.js",
Â Â Â Â Â "wasm_pack_world.d.ts"
],
"module": "wasm_pack_world.js",
"types": "wasm_pack_world.d.ts",
"sideEffects"<a id="_idTextAnchor111"/>: "false"
}</pre>
			<ol>
				<li value="5">Finally, it copies over the Readme and LICENSE file if we have one, to ensure there is shared <a id="_idIndexMarker370"/>documentation between the Rust and WebAssembly versions.</li>
			</ol>
			<p><code>wasm-pack</code> also checks for the presence of <code>wasm-bindgen-cli</code>, which, if not present, will be installed using Cargo.</p>
			<ol>
				<li value="6">When the build has successfully finished, it will create a <code>pkg</code> directory. Inside <code>pkg</code>, it will pipe the output of <code>wasm-bindgen</code>:<pre>pkg
â”œâ”€â”€ package.json
â”œâ”€â”€ wasm_pack_world.d.ts
â”œâ”€â”€ wasm_pack_world.js
â”œâ”€â”€ wasm_pack_world_bg.d.ts
â””â”€â”€ wasm_pack_world_bg.wasm</pre></li>
			</ol>
			<p>Now, this <code>pkg</code> folder can be bundled and shared like any other JavaScript module. We'll see how to achieve that in the future recipes.</p>
			<p><code>wasm-pack</code> is a great tool to pack and publish WebAssembly modules. Now, let's check out how to use it.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor112"/>Packing and publishing using wasm-pack</h1>
			<p>The most amazing (and, of course, the most important) thing for a library developer to do is to <a id="_idIndexMarker371"/>pack and publish artifacts. That is why we spend our <a id="_idIndexMarker372"/>days and nights carefully crafting the application, publishing it to the world, receiving feedback (either negative or positive), and then enhancing the application based on that.</p>
			<p>The critical point for any project is its first release, which defines the fate of the project. Even though it is simply an MVP, it will give the world a glimpse of what we are working on and gives us a glimpse of what we have to work on in the future.</p>
			<p><code>wasm-pack</code> helps us to build, pack, and publish Rust- and WebAssembly-based projects into the npm registry. We have already seen how <code>wasm-pack</code> makes it simpler to build Rust into the WebAssembly binary along with the binding JavaScript file using <code>wasm-bindgen</code> underneath. Let's further explore what we can do with its <code>pack</code> and <code>publish</code> flags. </p>
			<p><code>wasm-pack</code> provides a <code>pack</code> flag to pack the artifacts that were generated using the <code>wasm-pack</code> build command. Although it is not necessary to use <code>wasm-pack</code> to build binaries, it generates all the boilerplate that we will need to pack the artifacts into a Node module. </p>
			<p>In order to pack the built artifacts using <code>wasm-pack</code>, we have to run the following command with reference to <code>pkg</code> (or the directory with which we generated our build artifacts):</p>
			<pre>$ wasm-pack pack pkg</pre>
			<p>We can also run the command by passing in <code>project_folder/pkg</code> as its argument. Without any argument, the <code>wasm-pack pack</code> command will search for the <code>pkg</code> directory in the current working directory where it is running.</p>
			<p>The <code>wasm-pack pack</code> command first identifies whether the folder provided is a <code>pkg</code> directory or contains a <code>pkg</code> directory as its immediate child. If the check passes, then <code>wasm-pack</code> will invoke the npm pack command underneath, to pack the library into an npm package.</p>
			<p>To bundle the npm package, all we need is a valid <code>package.json</code> file. That file is generated by the <code>wasm-pack</code> build command.</p>
			<p>We can <a id="_idIndexMarker373"/>run the <code>pack</code> command inside the <code>cg-array-world</code> example <a id="_idIndexMarker374"/>from our previous recipe and check what happens:</p>
			<pre>$ wasm-pack pack
npm notice
npm notice ðŸ“¦ cg-array-world@0.1.0
npm notice === Tarball Contents ===
npm notice 313B package.json
npm notice 32.7kB cg_array_world_bg.wasm
npm notice 135B cg_array_world.d.ts
npm notice 1.6kB cg_array_world.js
npm notice 1.5kB README.md
npm notice === Tarball Details ===
npm notice name: cg-array-world
npm notice version: 0.1.0
npm notice filename: cg-array-world-0.1.0.tgz
npm notice package size: 16.0 kB
npm notice unpacked size: 36.4 kB
npm notice shasum: 243488f1f5a859b60bb34f39146b35ba720dd8ea
npm notice integrity: sha512-9SFuObzEpi254[...]/lkHq6RKSgnNw==
npm notice total files: 5
npm notice
cg-array-world-0.1.0.tgz
| ðŸŽ’ packed up your package!</pre>
			<p>As you can see here, the <code>pack</code> command creates a tarball package with the contents inside the <code>pkg</code> folder with the help of the <code>npm pack</code> command.</p>
			<p>Once we have packed our application, the obvious next step will be to publish it. In order to publish the tarball generated, <code>wasm-pack</code> has a <code>publish</code> option.</p>
			<p>In order <a id="_idIndexMarker375"/>to publish the package, we have to run the following command:</p>
			<pre>$ wasm-pack publish</pre>
			<p>The <code>wasm-pack publish</code> command will first check whether the <code>pkg</code> directory is already <a id="_idIndexMarker376"/>present in the directory provided.</p>
			<p>If the <code>pkg</code> directory is not present, then it will ask whether you want to create the package first:</p>
			<pre>$ wasm-pack publish
Your package hasn't been built, build it? [Y/n]</pre>
			<p>If you answer <code>Y</code> to the question, then it asks for you to input the folder in which you want to generate the build artifacts. We can give any folder name or use the default:</p>
			<pre>$ wasm-pack publish
Your package hasn't been built, build it? yes
out_dir[default: pkg]:</pre>
			<p>Then, it asks for your target, that is, the target in which the build should be generated. You can choose between the various options here, as discussed in the build recipe:</p>
			<pre>$ wasm-pack publish
Your package hasn't been built, build it? yes
out_dir[default: pkg]: .
target[default: browser]:
&gt; browser
nodejs
no-modules</pre>
			<p>Based on the option provided, it will generate the artifact in the specified folder.</p>
			<p>Once the artifacts are produced, they are then ready to be published using npm publish. For npm <a id="_idIndexMarker377"/>publish to work correctly, we need to be authenticated. You <a id="_idIndexMarker378"/>can authenticate to npm by using either npm login or <code>wasm-pack</code> login.</p>
			<p>The <code>wasm-pack login</code> command will invoke the underlying npm login command and then create a session:</p>
			<pre>$ wasm-pack login
Username: sendilkumarn
Password: *************
login succeeded.</pre>
			<p>The <code>wasm-pack publish</code> command also supports two options, namely the following:</p>
			<ul>
				<li><code>-a</code> or <code>--access</code> to determine <a id="_idIndexMarker379"/>the access level of the package to be deployed.</li>
			</ul>
			<p>This accepts either <code>public</code> or <code>restricted</code>:</p>
			<ul>
				<li><code>public</code> â€“ Makes the package public </li>
				<li><code>restricted</code> â€“ Makes the package internal</li>
			</ul>
			<ul>
				<li><code>-t</code> or <code>--target</code> to support <a id="_idIndexMarker380"/>various targets in which the build is produced.</li>
			</ul>
			<p>Thus, <code>wasm-pack</code> makes it easy to pack and publish WebAssembly binaries. </p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor113"/>Summary</h1>
			<p>In this chapter, we saw how to run a WebAssembly project with bundlers such as webpack and Parcel. Parcel and webpack make it easy for JavaScript developers to run and develop Rust and WebAssembly projects. Then, we installed <code>wasm-pack</code> and used it to run the project. Finally, we used <code>wasm-pack</code> to pack and publish the WebAssembly module to npm.  </p>
			<p>In the next chapter, we will explore how to share complex objects between Rust and WebAssembly with <code>wasm-bindgen</code>.</p>
		</div>
	</body></html>