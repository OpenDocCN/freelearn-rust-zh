- en: '*Chapter 1*: Introducing the Rust Language'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every programmer has heard about the **Rust** programming language or
    even tried or used it. Saying "the Rust programming language" every time is a
    little bit cumbersome, so let's just call it Rust, or the Rust language from this
    point forward.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk a little bit about Rust to help you if you are
    new to this language or as a refresher if you have tried it already. This chapter
    might also help seasoned Rust language programmers a bit. Later in the chapter,
    we will learn how to install the Rust toolchain and create a simple program to
    introduce the features of the Rust language. We will then use third-party libraries
    to enhance one of our programs, and finally, we will see how we can get help for
    the Rust language and its libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Rust language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Rust compiler and toolchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Hello World
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Rust crates and Cargo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring other tools and where to get help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the content of this book, you will need a computer running a Unix-like
    operating system such as Linux, macOS, or Windows with Windows Subsystem for Linux
    (WSLv1 or WSLv2) installed. Don't worry about the Rust compiler and toolchain;
    we will install it in this chapter if you don't have it installed already.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter01](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Rust language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build web applications using the **Rocket** framework, we must first learn
    a bit about the Rust language since Rocket is built using that language. According
    to [https://www.rust-lang.org](https://www.rust-lang.org), the Rust language is
    "*a language empowering everyone to build reliable and efficient software*." It
    began as a personal project for a programmer named Graydon Hoare, an employee
    at Mozilla, around 2006\. The Mozilla Foundation saw the potential of the language
    for their product; they started sponsoring the project in 2009 before announcing
    it to the public in 2010.
  prefs: []
  type: TYPE_NORMAL
- en: Since its inception, the focus of Rust has always been on performance and safety.
    Building a web browser is not an easy job; an unsafe language can have very fast
    performance, but programmers working with system languages without adequate safety
    measures in place can make a lot of mistakes, such as missing pointer references.
    Rust was designed as a system language and learned many mistakes from older languages.
    In older languages, you can easily shoot yourself in the foot with a null pointer,
    and nothing in the language prevents you from compiling such mistakes. In contrast,
    in the Rust language, you cannot write a code that resulted in null pointer because
    it will be detected during compile time, and you must fix the implementation to
    make it compile.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the Rust language design is borrowed from the functional programming
    paradigm, as well as from the object-oriented programming paradigm. For example,
    it has elements of a functional language such as closures and iterators. You can
    easily make a pure function and use the function as a parameter in another function;
    there are syntaxes to easily make closures and data types such as `Option` or
    `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are no class definitions, but you can easily define
    a data type, for example, a **struct**. After defining that data type, you can
    create a block to implement its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Even though there is no inheritance, you can easily group objects by using `MakeSound`
    trait. Then, you can determine what methods should be in that trait by writing
    the method signatures. If you define a data type, for example, a struct named
    `Cow`, you can tell the compiler that it implements a `MakeSound` trait. Because
    you say the `Cow` struct implements the `MakeSound` trait, you have to implement
    the methods defined in the trait for the `Cow` struct. Sounds like an object-oriented
    language, right?
  prefs: []
  type: TYPE_NORMAL
- en: The Rust language went through several iterations before a stable version was
    released (Rust 1.0) on May 15, 2015\. Some of the early language design was scrapped
    before releasing the stable release. At one point, Rust had a class feature but
    this was scrapped before the stable release because Rust design was changed to
    have data and behavior separation. You write data (for example, in the form of
    a `struct` or `enum` type), and then you write a behavior (for example, `impl`)
    separately. To categorize those `impl` in the same group, we can make a **trait**.
    So, all the functionality you would want from an object-oriented language can
    be had thanks to that design. Also, Rust used to have garbage collection, but
    it was then scrapped because another design pattern was used. When objects get
    out of scope, such as exiting a function, they are deallocated automatically.
    This type of automatic memory management made garbage collection unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: After the first stable release, people added more functionalities to make Rust
    more ergonomic and usable. One of the biggest changes was **async/await**, which
    was released in version 1.39\. This feature is very useful for developing applications
    that handle I/O, and web application programming handles a lot of I/O. Web applications
    have to handle database and network connections, reading from files, and so on.
    People agree that async/await was one of the most needed features to make the
    language suitable for web programming, because in async/await, the program doesn't
    need to make a new thread, but it's also not blocking like a conventional function.
  prefs: []
  type: TYPE_NORMAL
- en: Another important feature is `const fn`, a function that will be evaluated at
    compile-time instead of runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, many large companies have started to build a talent pool of
    Rust developers, which highlights its significance in business.
  prefs: []
  type: TYPE_NORMAL
- en: Why use the Rust language?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, why should we use the Rust language for web application development? Aren''t
    existing established languages good enough for web development? Here are a few
    reasons why people would want to use the Rust language for creating web applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading and asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statically typed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safety
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although writing applications using a system programming language is advantageous
    because it's powerful (a programmer can access the fundamental building block
    of a program such as allocating computer memory to store important data and then
    deallocating that memory as soon as it is not in use), it's very easy to make
    mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: There's nothing in a traditional system language to prevent a program from storing
    data in memory, creating a pointer to that data, deallocating the data stored
    in memory, and trying to access the data again through that pointer. The data
    is already gone but the pointer is still pointing to that part of the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Seasoned programmers might easily spot such mistakes in a simple program. Some
    companies force their programmers to use a static analysis tool to check the code
    for such mistakes. But, as programming techniques become more sophisticated, the
    complexity of the application grows, and these kinds of bugs can still be found
    in many applications. High-profile bugs and hacks found in recent years, such
    as *Heartbleed*, can be prevented if we use a memory-safe language.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a memory-safe language because it has certain rules regarding how a
    programmer can write their code. For example, when the code is compiled, it checks
    the lifetime of a variable, and the compiler will show an error if another variable
    still tries to access the already out-of-scope data. Ralf Jung, a postdoctoral
    researcher, already made the first formal verification in 2020 that the Rust language
    is indeed a safe language. Built-in data types, such as `Option` or `Result`,
    handle null-like behavior in a safe manner.
  prefs: []
  type: TYPE_NORMAL
- en: No garbage collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many programmers create and use different techniques for memory management
    due to safety problems. One of these techniques is garbage collection. The idea
    is simple: memory management is done automatically during runtime so that a programmer
    doesn''t have to think about memory management. A programmer just needs to create
    a variable, and when the variable is not used anymore, the runtime will automatically
    remove it from memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection is an interesting and important part of computing. There
    are many techniques such as reference counting and tracing. Java, for example,
    even has several third-party garbage collectors besides the official garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this language design choice is that garbage collection usually
    takes significant computing resources. For example, a part of the memory is still
    not usable for a while because the garbage collector has not recycled that memory
    yet. Or, even worse, the garbage collector is not able to remove used memory from
    the heap, so it will accumulate, and most of the computer memory will become unusable,
    or what we usually call a **memory leak**. In the **stop-the-world** garbage collection
    mechanism, the whole program execution is paused to allow the garbage collector
    to recycle the memory, after which the program execution is resumed. As such,
    some people find it hard to develop real-time applications with this kind of language.
  prefs: []
  type: TYPE_NORMAL
- en: Rust takes a different approach called **resource acquisition is initialization**
    (**RAII**), which means an object is deallocated automatically as soon as it's
    out of scope. For example, if you write a function, an object created in the function
    will be deallocated as soon as the function exits. But obviously, this makes Rust
    very different compared to programming languages that deallocate memory manually
    or programming languages with garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are used to doing web development with an interpreted language or a language
    with garbage collection, you might say that we don't need to worry about computing
    performance as web development is I/O bound; in other words, the bottleneck is
    when the application accesses the database, disk, or another network, as they
    are slower than a CPU or memory.
  prefs: []
  type: TYPE_NORMAL
- en: The adage might be primarily true but it all depends on application usage. If
    your application processes a lot of JSON, the processing is CPU-bound, which means
    it is limited by the speed of your CPU and not the speed of disk access or the
    speed of network connection. If you care about the security of your application,
    you might need to work with hashing and encryption, which are CPU-bound. If you
    are writing a backend application for an online streaming service, you want the
    application to work as optimally as possible. If you are writing an application
    serving millions of users, you want the application to be very optimized and return
    the response as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust language is a compiled language, so the compiler will convert the program
    into machine code, which a computer processor can execute. A compiled language
    usually runs faster than an interpreted language because, in an interpreted language,
    there is an overhead when the runtime binary interprets the program into native
    machine code. In modern interpreters, the speed gap is reduced by using modern
    techniques such as a **just-in-time** (**JIT**) compiler to speed up the program
    execution, but in dynamic languages such as Ruby, it's still slower than using
    a compiled language.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading and asynchronous programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In traditional programming, synchronous programming means the application has
    to wait until CPU has processed a task. In a web application, the server waits
    until an HTTP request is processed and responded to; only then does it go on to
    handle another HTTP request. This is not a problem if the application just directly
    creates responses such as simple text. It becomes a problem when the web application
    has to take some time to do the processing; it has to wait for the database server
    to respond, it has to wait until the file is fully written on the server, and
    it has to wait until the API call to the third-party API service is done successfully.
  prefs: []
  type: TYPE_NORMAL
- en: One way to overcome the problem of waiting is multithreading. A single process
    can create multiple threads that share some resources. The Rust language has been
    designed to make it easy to create safe multithreaded applications. It's designed
    with multiple containers such as `Arc` to make it easy to pass data between threads.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with multithreading is that spawning a thread means allocating significant
    CPU, memory, and OS resources, or what is colloquially known as being *expensive*.
    The solution is to use a different technique called **asynchronous programming**,
    where a single thread is reused by different tasks without waiting for the first
    task to finish. People can easily write an async program in Rust because it's
    been incorporated into the language since November 7, 2019.
  prefs: []
  type: TYPE_NORMAL
- en: Statically-typed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In programming languages, a dynamically-typed language is one where a variable
    type is checked at runtime, while a statically-typed language checks the data
    type at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic typing means it's easier to write code, but it's also easier to make
    mistakes. Usually, a programmer has to write more unit tests in dynamically-typed
    languages to compensate for not checking the type at compile time. A dynamically-typed
    language is also considered more expensive because every time a function is called,
    the routine has to check the passed parameters. As a result, it's difficult to
    optimize a dynamically-typed language.
  prefs: []
  type: TYPE_NORMAL
- en: Rust, on the other hand, is statically-typed, so it's very hard to make mistakes
    such as passing a string as a number. The compiler can optimize the resulting
    machine code and reduce programming bugs significantly before the application
    is released.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have provided an overview of the Rust language and its strengths
    compared to other languages, let's learn how to install the Rust compiler toolchain,
    which will be used to compile Rust programs. We'll be using this toolchain throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Rust compiler toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by installing the Rust compiler toolchain. Rust has three official
    channels: *stable*, *beta*, and *nightly*. The Rust language uses Git as its version
    control system. People add new features and bug fixes to the master branch. Every
    night, the source code from the master branch is compiled and released to the
    nightly channel. After six weeks, the code will be branched off to the beta branch,
    compiled, and released to the beta channel. People will then run various tests
    in the beta release, most often in their CI (Continuous Integration) installation.
    If a bug is found, the fix will be committed to the master branch and then backported
    to the beta branch. Six weeks after the first beta branch-off, the stable release
    will be created from the beta branch.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the compiler from the stable channel throughout the book, but if
    you feel adventurous, you can use the other channels as well. There's no guarantee
    the program we're going to create will compile if you use another channel though
    because people add new features and there might be regression introduced in the
    new version.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to install the Rust toolchain in your system, such as
    bootstrapping and compiling it from scratch or using your OS package manager.
    But, the recommended way to install the Rust toolchain in your system is by using
    `rustup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition on its website ([https://rustup.rs](https://rustup.rs)) is very
    simple: "*rustup is an installer for the systems programming language Rust*."
    Now, let''s try following these instructions to install `rustup`.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing rustup on the Linux OS or macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These instructions apply if you are using a Debian 10 Linux distribution, but
    if you are already using another Linux distribution, we''re going to assume you
    are already proficient with the Linux OS and can adapt these instructions suitable
    to your Linux distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your terminal of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you have cURL installed by typing this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If cURL is not installed, let''s install it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are using macOS, you will most likely already have cURL installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, follow the instructions on [https://rustup.rs](https://rustup.rs):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It will then show a greeting and information, which you can customize; for
    now, we''re just going to use the default setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Type `1` to use the default installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, reload your terminal or type this in the current terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can confirm whether the installation was successful or not by typing `rustup`
    in the Terminal and you should see the usage instruction for rustup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s install the stable Rust toolchain. Type the following in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the toolchain has been installed into your OS, let's confirm whether we
    can run the Rust compiler. Type `rustc` in the terminal and you should see the
    instructions on how to use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing a different toolchain and components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, we have the stable toolchain installed, but there are two other
    default channels that we can install: *nightly* and *beta*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you might want to use a different toolchain for various reasons.
    Maybe you want to try a new feature, or maybe you want to test regression in your
    application against an upcoming version of Rust. You can simply install it by
    using `rustup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Each toolchain has components, some of which are required by the toolchain,
    such as `rustc`, which is the Rust compiler. Other components are not installed
    by default, for example, `clippy`, which provides more checks not provided by
    the `rustc` compiler and gives code style suggestions as well. To install it is
    also very easy; you can use `rustup component add <component>` as shown in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Updating the toolchain, rustup, and components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Rust toolchain has a regular release schedule of around every three months
    (six weeks plus six weeks), but sometimes there''s an emergency release for a
    major bug fix or a fix for a security problem. As a result, you sometimes need
    to update your toolchain. Updating is very easy. This command will also update
    the components installed in the toolchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the toolchain, `rustup` itself might also be updated. You can update
    it by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the Rust compiler toolchain installed in our system, let's
    write our first Rust program!
  prefs: []
  type: TYPE_NORMAL
- en: Writing Hello World!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to write a very basic program, *Hello World!*.
    After we successfully compile that, we are going to write a more complex program
    to see the basic capabilities of the Rust language. Let''s do it by following
    these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new folder, for example, `01HelloWorld`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file inside the folder and give it the name `main.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s write our first code in Rust:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, save your file, and in the same folder, open your terminal, and
    compile the code using the `rustc` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see there''s a file inside the folder called `main`; run that file
    from your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations! You just wrote your first `Hello World` program in the Rust
    language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we're going to step up our Rust language game; we will showcase basic
    Rust applications with control flow, modules, and other functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a more complex program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, after making the `Hello World` program, we should try to write a
    more complex program to see what we can do with the language. We want to make
    a program that captures what the user inputted, encrypts it with the selected
    algorithm, and returns the output to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a new folder, for example, `02ComplexProgram`. After that, create
    the `main.rs` file again and add the `main` function again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, use the `std::io` module and write the part of the program to tell the
    user to input the string they want to encrypt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s explore what we have written line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line, `use std::io;`, is telling our program that we are going to
    use the `std::io` module in our program. `std` should be included by default on
    a program unless we specifically say not to use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `let...` line is a variable declaration. When we define a variable in Rust,
    the variable is immutable by default, so we must add the `mut` keyword to make
    it mutable. `user_input` is the variable name, and the right hand of this statement
    is initializing a new empty `String` instance. Notice how we initialize the variable
    directly. Rust allows the separation of declaration and initialization, but that
    form is not idiomatic, as a programmer might try to use an uninitialized variable
    and Rust disallows the use of uninitialized variables. As a result, the code will
    not compile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next piece of code, that is, the `stdin()` function, initializes the `std::io::Stdin`
    struct. It reads the input from the terminal and puts it in the `user_input` variable.
    Notice that the signature for `read_line()` accepts `&mut String`. We have to
    explicitly tell the compiler we are passing a mutable reference because of the
    Rust borrow checker, which we will discuss later in [*Chapter 9*](B16825_09_ePub.xhtml#_idTextAnchor109)*,*
    *Displaying User's Post*. The `read_line()` output is `std::result::Result`, an
    enum with two variants, `Ok(T)` and `Err(E)`. One of the `Result` methods is `expect()`,
    which returns a generic type `T`, or if it's an `Err` variant, then it will cause
    panic with a generic error `E` combined with the passed message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two Rust enums (`std::result::Result` and `std::option::Option`) are very ubiquitous
    and important in the Rust language, so by default, we can use them in the program
    without specifying `use`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we want to be able to encrypt the input, but right now, we don''t know
    what encryption we want to use. The first thing we want to do is make a **trait**,
    a particular code in the Rust language that tells the compiler what functionality
    a type can have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to create a module: create `module_name.rs` or create a
    folder with `module_name` and add a `mod.rs` file inside that folder. Let''s create
    a folder named `encryptor` and create a new file named `mod.rs`. Since we want
    to add a type and implementation later, let''s use the second way. Let''s write
    this in `mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, a type or trait is private, but we want to use it in `main.rs` and
    implement the encryptor on a different file, so we should denote the trait as
    public by adding the `pub` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That trait has one function, `encrypt()`, which has self-reference as a parameter
    and returns `String`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we should define this new module in `main.rs`. Put this line before the
    `fn` main block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let''s make a simple type that implements the `Encryptable` trait. Remember
    the Caesar cipher, where the cipher substitutes a letter with another letter?
    Let''s implement the simplest one called `ROT13`, where it converts `''a''` to
    `''n''` and `''n''` to `''a''`, `''b''` to `''o''` and `''o''` to `''b''`, and
    so on. Write the following in the `mod.rs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's make another file named `rot13.rs` inside the `encryptor` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to define a simple struct that only has one piece of data, a string,
    and tell the compiler that the struct is implementing the `Encryptable` trait.
    Put this code inside the `rot13.rs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might notice we put `pub` in everything from the module declaration, to
    the trait declaration, struct declaration, and field declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s try compiling our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is going on here? Clearly, the compiler found an error in our code. One
    of Rust's strengths is helpful compiler messages. You can see the line where the
    error occurs, the reason why our code is wrong, and sometimes, it even suggests
    the fix for our code. We know that we have to implement the `super::Encryptable`
    trait for the `Rot13` type.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see more information, run the command shown in the preceding
    error, `rustc --explain E0046`, and the compiler will show more information about
    that particular error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now can continue implementing our `Rot13` encryption. First, let''s put
    the signature from the trait into our implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The strategy for this encryption is to iterate each character in the string
    and add 13 to the char value if it has a character before `'n'` or `'N'`, and
    remove 13 if it has `'n'` or `'N'` or characters after it. The Rust language handles
    Unicode strings by default, so the program should have a restriction to operate
    only on the Latin alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: 'On our first iteration, we want to allocate a new string, get the original
    `String` length, start from the zeroeth index, apply a transformation, push to
    a new string, and repeat until the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s try compiling that program. You will quickly find it is not working,
    with all errors being `` `String` cannot be indexed by `usize` ``. Remember that
    Rust handles Unicode by default? Indexing a string will create all sorts of complications,
    as Unicode characters have different sizes: some are 1 byte but others can be
    2, 3, or 4 bytes. With regard to index, what exactly are we saying? Is index means
    the byte position in a `String`, grapheme, or Unicode scalar values?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Rust language, we have primitive types such as `u8`, `char`, `fn`, `str`,
    and many more. In addition to those primitive types, Rust also defines a lot of
    modules in the standard library, such as `string`, `io`, `os`, `fmt`, and `thread`.
    These modules contain many building blocks for programming. For example, the `std::string::String`
    struct deals with `String`. Important programming concepts such as comparison
    and iteration are also defined in these modules, for example, `std::cmp::Eq` to
    compare an instance of a type with another instance. The Rust language also has
    `std::iter::Iterator` to make a type iterable. Fortunately, for `String`, we already
    have a method to do iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our code a little bit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are two ways of returning; the first one is using the `return` keyword
    such as `return new_string;`, or we can write just the variable without a semicolon
    in the last line of a function. You will see that it's more common to use the
    second form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding code works just fine, but we can make it more idiomatic. First,
    let''s process the iterator without the `for` loop. Let''s remove the new string
    initialization and use the `map()` method instead. Any type implementing `std::iter::Iterator`
    will have a `map()` method that accepts a closure as the parameter and returns
    `std::iter::Map`. We can then use the `collect()` method to collect the result
    of the closure into its own `String`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `map()` method accepts a closure in the form of `|x|...`. We then use the
    captured individual items that we get from `chars()` and process them.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the closure, you'll see we don't use the `return` keyword either.
    If we don't put the semicolon in a branch and it's the last item, it will be considered
    as a `return` value.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `if` block is good, but we can also make it more idiomatic. One of
    the Rust language's strengths is the powerful `match` control flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the code again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That looks a lot cleaner. The pipe (`|`) operator is a separator to match items
    in an arm. The Rust matcher is exhaustive, which means that the compiler will
    check whether all possible values of the matcher are included in the matcher or
    not. In this case, it means all characters in Unicode. Try removing the last arm
    and compiling it to see what happens if you don't include an item in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: You can define a range by using `..` or `..=`. The former means we are excluding
    the last element, and the latter means we are including the last element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have implemented our simple encryptor, let''s use it in our main
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right now, when we try to compile it, the compiler will show an error. Basically,
    the compiler is saying you cannot use a trait function if the trait is not in
    the scope, and the help from the compiler is showing what we need to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the following line above the `main()` function and the compiler should
    produce a binary without any error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s try running the executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have finished our program and we improved it with real-world encryption.
    In the next section, we're going to learn how to search for and use third-party
    libraries and incorporate them into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Packages and Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to create a simple program in Rust, let's explore **Cargo**,
    the Rust package manager. Cargo is a **command-line application** that manages
    your application dependencies and compiles your code.
  prefs: []
  type: TYPE_NORMAL
- en: Rust has a community package registry at [https://crates.io](https://crates.io).
    You can use that website to search for a library that you can use in your application.
    Don't forget to check the license of the library or application that you want
    to use. If you register on that website, you can use Cargo to publicly distribute
    your library or binary.
  prefs: []
  type: TYPE_NORMAL
- en: How do we install Cargo into our system? The good news is Cargo is already installed
    if you install the Rust toolchain in the stable channel using `rustup`.
  prefs: []
  type: TYPE_NORMAL
- en: Cargo package layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s try using Cargo in our application. First, let''s copy the application
    that we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have an existing application, we can initialize our existing
    application with `cargo init`. Notice we add the `--name` option because we are
    prefixing our folder name with a number, and a Rust package name cannot start
    with a number.
  prefs: []
  type: TYPE_NORMAL
- en: If we are creating a new application, we can use the `cargo new package_name`
    command. To create a library-only package instead of a binary package, you can
    pass the `--lib` option to `cargo new`.
  prefs: []
  type: TYPE_NORMAL
- en: You will see two new files, `Cargo.toml` and `Cargo.lock`, inside the folder.
    The `.toml` file is a file format commonly used as a configuration file. The `lock`
    file is generated automatically by Cargo, and we don't usually change the content
    manually. It's also common to add `Cargo.lock` to your source code versioning
    application ignore list, such as `.gitignore`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the content of the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can define basic things for our application such as `name`
    and `version`. We can also add important information such as authors, homepage,
    repository, and much more. We can also add dependencies that we want to use in
    the Cargo application.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that stands out is the edition configuration. The Rust edition is
    an optional marker to group various Rust language releases that have the same
    compatibility. When Rust 1.0 was released, the compiler did not have the capability
    to know the `async` and `await` keywords. After `async` and `await` were added,
    it created all sorts of problems with older compilers. The solution to that problem
    was to introduce Rust editions. Three editions have been defined: 2015, 2018,
    and 2021.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, the Rust compiler can compile our package perfectly fine, but it
    is not very idiomatic because a Cargo project has conventions on file and folder
    names and structures. Let''s change the files and directory structure a little
    bit:'
  prefs: []
  type: TYPE_NORMAL
- en: A package is expected to reside in the `src` directory. Let's change the `Cargo.toml`
    file `[[bin]]` path from `"main.rs"` to `"src/main.rs"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `src` directory inside our application folder. Then, move the `main.rs`
    file and the `encryptor` folder to the `src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add these lines to `Cargo.toml` after `[[bin]]`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create the `src/lib.rs` file and move this line from `src/main.rs` to
    `src/lib.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then simplify using both the `rot13` and `Encryptable` modules in our
    `main.rs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check whether there''s an error that prevents the code from being compiled
    by typing `cargo check` in the command line. It should produce something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we can build the binary using the `cargo build` command. Since
    we didn''t specify any option in our command, the default binary should be unoptimized
    and contain debugging symbols. The default location for the generated binary is
    in the `target` folder at the root of the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then run the binary in the `target` folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`debug` is enabled by the default dev profile, and `our_package` is the name
    that we specify in `Cargo.toml`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create a release binary, you can specify the `--release` option,
    `cargo build --release`. You can find the release binary in `./target/release/our_package`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also type `cargo run`, which will compile and run the application for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have arranged our application structure, let's add real-world encryption
    to our application by using a third-party crate.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party crates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we implement another encryptor using a third-party module, let''s modify
    our application a little bit. Copy the previous `03Packages` folder to the new
    folder, `04Crates`, and use the folder for the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will rename our Encryptor trait as a Cipher trait and modify the functions.
    The reason is that we only need to think about the output of the type, not the
    encrypt process itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's change the content of `src/lib.rs` to `pub mod cipher;`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, rename the `encryptor` folder as `cipher`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, modify the Encryptable trait into the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The reality is we only need functions to show the original string and the encrypted
    string. We don't need to expose the encryption in the type itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, let''s also change `src/cipher/rot13.rs` to use the renamed trait:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s also modify `main.rs` to use the new trait and function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to determine what encryption and library we want to use for
    our new type. We can go to [https://crates.io](https://crates.io) and search for
    an available crate. After searching for a real-world encryption algorithm on the
    website, we found [https://crates.io/crates/rsa](https://crates.io/crates/rsa).
    We found that the RSA algorithm is a secure algorithm, the crate has good documentation
    and has been audited by security researchers, the license is compatible with what
    we need, and there's a huge number of downloads. Aside from checking the source
    code of this library, all indications show that this is a good crate to use. Luckily,
    there's an install section on the right side of that page. Besides the `rsa` crate,
    we are also going to use the `rand` crate, since the RSA algorithm requires a
    random number generator. Since the generated encryption is in bytes, we must encode
    it somehow to `string`. One of the common ways is to use `base64`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these lines in our `Cargo.toml` file, under the `[dependencies]` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step should be adding a new module and typing using the `rsa` crate.
    But, for this type, we want to modify it a little bit. First, we want to create
    an **associated function**, which might be called a constructor in other languages.
    We want to then encrypt the input string in this function and store the encrypted
    string in a field. There's a saying that all data not in processing should be
    encrypted by default, but the fact is that we as programmers rarely do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since RSA encryption is dealing with byte manipulation, there's a possibility
    of errors, so the return value of the associated function should be wrapped in
    the `Result` type. There's no compiler rule, but if a function cannot fail, the
    return should be straightforward. Regardless of whether or not a function can
    produce a result, the `return` value should be `Option`, but if a function can
    produce an error, it's better to use `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: The `encrypted_string()` method should return the stored encrypted string, and
    the `original_string()` method should decrypt the stored string and return the
    plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/cipher/mod.rs`, change the code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we changed the definition of the trait, we have to change the code in
    `src/cipher/rot13.rs` as well. Change the code to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s add the following line in the `src/cipher/mod.rs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, create `rsa.rs` inside the `cipher` folder and create the `Rsa`
    struct inside it. Notice that we use `Rsa` instead of `RSA` as the type name.
    The convention is to use `CamelCase` for type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are a couple of things we can observe. The first one is the `data` field
    does not have the `pub` keyword since we want to make it private. You can see
    that we have two `impl` blocks: one is for defining the methods of the `Rsa` type
    itself, and the other is for implementing the `Cipher` trait.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `new()` function does not have `self`, `mut self`, `&self`, or `&mut
    self` as the first parameter. Consider it as a static method in other languages.
    This method is returning `Result`, which is either `Ok(Self)` or `Box<dyn Error>`.
    The `Self` instance is the instance of the `Rsa` struct, but we'll discuss `Box<dyn
    Error>` later when we talk about error handling in [*Chapter 7*](B16825_07_ePub.xhtml#_idTextAnchor091),
    *Handling Errors in Rust and Rocket*. Right now, we haven't implemented this method,
    hence the usage of the `unimplemented!()` macro. Macros in Rust look like a function
    but with an extra bang (!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the associated function. Modify `src/cipher/rsa.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing we do is declare the various types we are going to use. After
    that, we define a constant to denote what size key we are going to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you understand the RSA algorithm, you already know that it''s an asymmetric
    algorithm, meaning we have two keys: a public key and a private key. We use the
    public key to encrypt data and use the private key to decrypt the data. We can
    generate and give the public key to the other party, but we don''t want to give
    the private key to the other party. That means we must store the private key inside
    the struct as well.'
  prefs: []
  type: TYPE_NORMAL
- en: The `new()` implementation is pretty straightforward. The first thing we do
    is declare a random number generator, `rng`. We then generate the RSA private
    key. But, pay attention to the question mark operator (`?`) on the initialization
    of the private key. If a function returns `Result`, we can quickly return the
    error generated by calling any method or function inside it by using (`?`) after
    that function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we generate the RSA public key from a private key, encode the input string
    as bytes, and encrypt the data. Since encrypting the data might have resulted
    in an error, we use the question mark operator again. We then encode the encrypted
    bytes as a `base64` string and initialize `Self`, which means the `Rsa` struct
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `original_string()` method. We should do the opposite
    of what we do when we create the struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we decode the `base64` encoded string in the `data` field. Then, we decrypt
    the decoded bytes and convert them back to a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have finished our `Rsa` type, let''s use it in our `main.rs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Some of you might wonder why we redeclared the `user_input` variable. The simple
    explanation is that Rust already moved the resource to the new `Rot13` type, and
    Rust does not allow the reuse of the moved value. You can try commenting on the
    second variable declaration and compile the application to see the explanation.
    We will discuss the Rust borrow checker and moving in more detail in [*Chapter
    9*](B16825_09_ePub.xhtml#_idTextAnchor109)*, Displaying Users' Post*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try running the program by typing `cargo run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You will see that Cargo automatically downloaded the dependencies and builds
    them one by one. Also, you might notice that encrypting using the `Rsa` type took
    a while. Isn't Rust supposed to be a fast system language? The RSA algorithm itself
    is a slow algorithm, but that's not the real cause of the slowness. Because we
    are running the program in a development profile, the Rust compiler generates
    an application binary with all the debugging information and does not optimize
    the resulting binary. On the other hand, if you build the application using the
    `--release` flag, the compiler generates an optimized application binary and strips
    the debugging symbols. The resulting binary compiled with the release flag should
    execute faster than the debug binary. Try doing it yourself so you'll remember
    how to build a release binary.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about Cargo and third-party packages, so next,
    let's find out where to find help and documentation for the tools that we have
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Tools and getting help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a pretty simple application, you might be wondering
    what tools we can use for development, and how to find out more about Rust and
    get help.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides Cargo, there are a couple more tools we can use for Rust application
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rustfmt**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This program is for formatting your source code so it follows the Rust style
    guide. You can install it by using `rustup` (`rustup component add rustfmt`).
    Then, you can integrate it with your favorite text editor or use it from the command
    line. You can read more about `rustfmt` at [https://github.com/rust-lang/rustfmt](https://github.com/rust-lang/rustfmt).
  prefs: []
  type: TYPE_NORMAL
- en: '**clippy**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Does the name remind you of something? `clippy` is useful for linting your
    Cargo application using various lint rules. Right now, there are more than 450
    lint rules you can use. You can install it using this command: `rustup component
    add clippy`. Afterward, you can use it in the Cargo application by running `cargo
    clippy`. Can you try it in the Cargo application that we wrote earlier? You can
    read more about `clippy` at [https://github.com/rust-lang/rust-clippy](https://github.com/rust-lang/rust-clippy).'
  prefs: []
  type: TYPE_NORMAL
- en: Text editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most likely, the text editor of your choice already supports the Rust language,
    or at least syntax highlighting Rust. You can install the Rust language server
    if you want to add important functionalities such as go to definition, go to implementation,
    symbol search, and code completion. Most popular text editors already support
    the language server, so you can just install an extension or other integration
    method to your text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Rust language server**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can install it using the `rustup` command: `rustup component add rls rust-analysis
    rust-src`. Then, you can integrate it into your text editor. For example, if you
    are using `rls`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about it at [https://github.com/rust-lang/rls](https://github.com/rust-lang/rls).
  prefs: []
  type: TYPE_NORMAL
- en: '**Rust analyzer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This application is poised to be the Rust language server 2.0\. It's still considered
    to be in alpha as of the writing of this book, but in my experience, this application
    works well with regular updates. You can find the executable for this one at [https://github.com/rust-analyzer/rust-analyzer/releases](https://github.com/rust-analyzer/rust-analyzer/releases),
    and then configure your editor language server to use this application. You can
    read more about it at [https://rust-analyzer.github.io](https://rust-analyzer.github.io).
  prefs: []
  type: TYPE_NORMAL
- en: Getting help and documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few important documents that you might want to read to find help
    or references:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Rust programming language book**: This is the book that you want to read
    if you want to understand more about the Rust programming language. You can find
    it online at [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rust by Example**: This documentation is a collection of small examples that
    show the concepts of the Rust language and its standard library''s capabilities.
    You can read it online at [https://doc.rust-lang.org/rust-by-example/index.html](https://doc.rust-lang.org/rust-by-example/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard library documentation**: As a programmer, you will refer to this
    standard library documentation. You can read more about standard libraries, their
    modules, the function signatures, what standard libraries'' functions do, read
    the examples, and more. Find it at [https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cargo.toml` manifest format, you can read more about it at [https://doc.rust-lang.org/cargo/index.html](https://doc.rust-lang.org/cargo/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rust style guidelines**: The Rust language, like other programming languages,
    has style guidelines. These guidelines tell a programmer what the convention for
    naming is, about whitespaces, how to use constants, and other idiomatic conventions
    for a Rust program. Read more about it at [https://doc.rust-lang.org/1.0.0/style/](https://doc.rust-lang.org/1.0.0/style/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rsa` crate that we used earlier. To find documentation for that library, you
    can go to [https://crates.io](https://crates.io) and search for the crate''s page,
    then go to the right pane and go to the documentation section. Or, you can go
    to [https://docs.rs](https://docs.rs) and search for the crate name and find the
    documentation for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rustup` (`rustup component add rust-docs`). Then, you can open documentation
    in your browser while offline using the `rustup doc` command. If you want to open
    standard library documentation offline, you can type `rustup doc --std`. There
    are other documents you can open; try and see what they are by using `rustup doc
    --help`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Rust user forum**: If you want to get help or help other Rust programmers,
    you can find it all over the internet. There''s a dedicated forum to discuss Rust-related
    topics at [https://users.rust-lang.org/](https://users.rust-lang.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a brief overview of the Rust language. We learned about
    the Rust toolchain and how to install it as well as the tools required for Rust
    development. After that, we created two simple programs, used Cargo, and imported
    third-party modules to improve our program. Now that you can write a small program
    in the Rust language, explore! Try creating more programs or experimenting with
    the language. You can try *Rust by Example* to see what features we can use in
    our programs. In subsequent chapters, we will learn more about Rocket, a web framework
    written in the Rust language.
  prefs: []
  type: TYPE_NORMAL
