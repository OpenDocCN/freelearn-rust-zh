["```rs\nfn bd_hash(p: &Person) -> u64 {\n    format!(\"{}{}\", p.day, p.month) as u64\n} \n```", "```rs\npub fn hashcode(bytes: &[u8]) -> u32 {\n    let mut a = 0_u32;\n    for (i, b) in bytes.iter().enumerate() {\n        a ^= *b as u32;\n        a <<= i % 4;\n    }\n    a\n}\n```", "```rs\nconst MOD_ADLER: u32 = 65521;\n\npub fn adler32(bytes: &[u8]) -> u32 {\n    let mut a = 1_u32;\n    let mut b = 0_u32;\n\n    for byte in bytes {\n        a = (a + byte as u32) % MOD_ADLER;\n        b = (b + a) % MOD_ADLER;\n    }\n\n    (b << 16) | a\n}\n```", "```rs\ntype Entry<K, V> = Vec<(K, V)>;\n\npub struct HashMap<K, V>\nwhere\n K: PartialEq + Clone,\n V: Clone,\n{\n   hash_fn: Box<dyn (Fn(&K) -> usize)>,\n   store: Box<[Entry<K, V>]>,\n   pub length: usize,\n}\n```", "```rs\npub type LocationCache = HashMap<String, LocationInformation>;\n```", "```rs\npub fn hashcode(bytes: &[u8]) -> u32 {\n    let mut a = 0_u32;\n    for (i, b) in bytes.iter().enumerate() {\n        a ^= *b as u32;\n        a <<= i % 4;\n    }\n    a\n}\n```", "```rs\npub fn insert(&mut self, key: K, value: V) {\n    let h = (self.hash_fn)(&key);\n    let idx = h & (self.store.len() - 1);\n    match self.store[idx].iter().position(|e| e.0 == key) {\n        Some(pos) => self.store[idx][pos] = (key, value),\n        None => {\n            self.store[idx].push((key, value));\n            self.length += 1\n        }\n    }\n}\n```", "```rs\npub fn get(&self, key: &K) -> Option<V> {\n    let h = (self.hash_fn)(key);\n    let idx = h & (self.store.len() - 1);\n    self.store[idx]\n        .iter()\n        .find(|e| e.0 == *key)\n        .map(|e| e.1.clone())\n}\n\npub fn remove(&mut self, key: K) -> Option<V> {\n    let h = (self.hash_fn)(&key);\n    let idx = h & (self.store.len() - 1);\n    match self.store[idx].iter().position(|e| e.0 == key) {\n        Some(pos) => {\n            self.length -= 1;\n            Some(self.store[idx].remove(pos).1)\n        }\n        _ => None,\n    }\n}\n```", "```rs\ntype Link<K> = Box<Node<K>>;\n\nstruct Node<K>\nwhere\n    K: PartialEq + Clone + Ord,\n{\n    pub key: K,\n    next: BTreeMap<K, Link<K>>,\n    ends_here: bool,\n}\n\npub struct TrieSet<K>\nwhere\n    K: PartialEq + Clone + Ord,\n{\n    pub length: u64,\n    root: BTreeMap<K, Link<K>>,\n}\n```", "```rs\npub type NetworkDeviceStore = TrieSet<u8>;\n```", "```rs\npub fn insert(&mut self, elements: &[K]) {\n    let mut path = elements.into_iter();\n\n    if let Some(start) = path.next() {\n        let mut n = self\n            .root\n            .entry(start.clone())\n            .or_insert(Node::new(start.clone(), false));\n        for c in path {\n            let tmp = n\n                .next\n                .entry(c.clone())\n                .or_insert(Node::new(c.clone(), false));\n            n = tmp;\n        }\n        if !n.ends_here {\n            self.length += 1;\n        }\n        n.ends_here = true;\n    }\n}\n```", "```rs\n// [...] trie set implementation\n    pub fn into_iter(self) -> SetIterator<K> {\n        let v: RefCell<Vec<Vec<K>>> = RefCell::new(vec![]);\n        self.walk(|n| v.borrow_mut().push(n.to_vec()));\n        SetIterator::new(v.into_inner(), 0)\n    }\n}\n\npub struct SetIterator<K>\nwhere\n    K: PartialEq + Clone + Ord,\n{\n    data: Vec<Vec<K>>,\n    last_index: usize,\n}\n\nimpl<K> SetIterator<K>\nwhere\n    K: PartialEq + Clone + Ord,\n{\n    fn new(data: Vec<Vec<K>>, start_at: usize) -> SetIterator<K> {\n        SetIterator {\n            data: data,\n            last_index: start_at,\n        }\n    }\n}\n\nimpl<K> Iterator for SetIterator<K>\nwhere\n    K: PartialEq + Clone + Ord,\n{\n    type Item = Vec<K>;\n\n    fn next(&mut self) -> Option<Vec<K>> {\n        let result = self.data.get(self.last_index);\n        self.last_index += 1;\n        result.cloned()\n    }\n}\n\n```", "```rs\npub fn union(self, other: TrieSet<K>) -> TrieSet<K> {\n    let new = RefCell::new(TrieSet::new_empty());\n    self.walk(|k| new.borrow_mut().insert(k));\n    other.walk(|k| new.borrow_mut().insert(k));\n    new.into_inner()\n}\n```", "```rs\npub fn intersection(self, other: TrieSet<K>) -> TrieSet<K> {\n    let new = RefCell::new(TrieSet::new_empty());\n    if self.length < other.length {\n        self.walk(|k| {\n            if other.contains(k) {\n                new.borrow_mut().insert(k)\n            }\n        });\n    } else {\n        other.walk(|k| {\n            if self.contains(k) {\n                new.borrow_mut().insert(k)\n            }\n        });\n    }\n    new.into_inner()\n}\n```", "```rs\npub fn difference(self, other: TrieSet<K>) -> TrieSet<K> {\n    let new = RefCell::new(TrieSet::new_empty());\n    self.walk(|k| {\n        if !other.contains(k) {\n            new.borrow_mut().insert(k)\n        }\n    });\n    new.into_inner()\n}\n```"]