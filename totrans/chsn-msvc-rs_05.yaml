- en: Understanding Asynchronous Operations with Futures Crate
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Futures Crate理解异步操作
- en: Rust is a modern language and has many approaches and crates that we can use
    to implement microservices. We can split these into two categories—synchronous
    frameworks and asynchronous frameworks. If you want to write synchronous microservices,
    you can implement a handler as a sequence of expressions and methods calls. But
    writing asynchronous code is hard in Rust, because it doesn't use a garbage collector
    and you have to take into account the lifetimes of all objects, including callbacks.
    This is not a simple task, because you can't stop the execution at any line of
    the code. Instead, you have to write code that won't block the execution for a
    long period of time. This challenge can be elegantly solved with the `futures`
    crate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust是一种现代语言，有许多我们可以用来实现微服务的途径和crate。我们可以将这些分为两类——同步框架和异步框架。如果你想编写同步微服务，你可以将处理程序实现为一系列表达式和方法调用。但在Rust中编写异步代码很困难，因为它不使用垃圾回收器，你必须考虑所有对象的生命周期，包括回调。这不是一个简单的任务，因为你不能在任何代码行上停止执行。相反，你必须编写不会长时间阻塞执行的代码。这个挑战可以通过`futures`
    crate优雅地解决。
- en: In this chapter, you will learn about how the  `futures` crate works. We will
    study two basic types—`Future` and `Stream`. We will also explore the **Multi-Producer
    Single-Consumer** (**MPSC**) module, which is an alternative to a similar module
    of the `std` crate, but supports asynchronous access to channels. At the end of
    the сhapter, we will create a microservice that uses `Future` and `Stream` traits
    to process incoming data and return a processed result to a client.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解`futures` crate的工作原理。我们将研究两种基本类型——`Future`和`Stream`。我们还将探索**多生产者单消费者**（**MPSC**）模块，它是`std`
    crate中类似模块的替代品，但支持异步访问通道。在本章结束时，我们将创建一个使用`Future`和`Stream`特质来处理传入数据并将处理结果返回给客户端的微服务。
- en: The `futures` crate contains asynchronous primitives only. We will also use
    the `tokio` crate, which provides asynchronous input and output capabilities to
    read and write image files for our microservice.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`futures` crate只包含异步原语。我们还将使用`tokio` crate，它为我们提供异步输入和输出能力，以读取和写入图像文件。'
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Basic asynchronous types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本异步类型
- en: Creating an image service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像服务
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Rust installation. We will develop microservices using
    the `futures` and `tokio` crates.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装Rust。我们将使用`futures`和`tokio` crate来开发微服务。
- en: You can find the source code of the projects of this chapters on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter04).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章项目的源代码：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter04)。
- en: Basic asynchronous types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本异步类型
- en: Microservices can be implemented in two different ways—synchronously and asynchronously.
    The approach refers to when the next task has to wait for the completion of the
    current task. To run tasks in parallel using code, we have to run a pool of threads
    and run tasks in the threads of the pool. The asynchronous approach is when you
    use non-blocking operations and a single thread performs multiple tasks. If an
    operation can't be completed, it returns a flag that means the task has not yet
    completed and we have to try to run it again later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以以两种不同的方式实现——同步和异步。这种方法指的是下一个任务必须在当前任务完成时等待。为了使用代码并行运行任务，我们必须运行一个线程池并在池中的线程中运行任务。异步方法是指使用非阻塞操作，单线程执行多个任务。如果操作无法完成，它将返回一个标志，表示任务尚未完成，我们稍后必须尝试再次运行它。
- en: In the past, Rust developers used synchronous operations only, which meant that
    if we wanted to read data from a socket, we would have to block an executing thread.
    Modern operating systems have two approaches to avoid blocking—non-blocking input/output
    functions, and a scalable I/O event notification system, such as **epoll**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，Rust开发者仅使用同步操作，这意味着如果我们想从套接字读取数据，我们必须阻塞一个正在执行的线程。现代操作系统有两种避免阻塞的方法——非阻塞输入/输出函数，以及可扩展的I/O事件通知系统，如**epoll**。
- en: Asynchronous activity refers to the ability to use the resources of the working
    for multiple concurrent activities. In contrast to synchronous handlers, asynchronous
    handlers use non-blocking operations. If resources are not available to finish
    the handler, it will be suspended until the next attempt to get access to resources.
    There is a well-established approach that involves a reactor and promises. A reactor
    allows a developer to run multiple activities in the same thread, while a promise
    represents a delayed result that will be available later. A reactor keeps a set
    of promises and continues to poll until it is completed and the result is returned.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 异步活动指的是使用工作资源执行多个并发活动的能力。与同步处理程序相比，异步处理程序使用非阻塞操作。如果资源不可用以完成处理程序，它将被挂起，直到下一次尝试获取资源。有一个涉及反应器和承诺的成熟方法。反应器允许开发者在同一线程中运行多个活动，而承诺代表一个稍后可用的延迟结果。反应器保持一组承诺，并继续轮询，直到完成并返回结果。
- en: Since the standard Rust library doesn't contain useful modules to write asynchronous
    applications and to work with reactors and promises, you need a third-party crate.
    An example of this type of crate is the `futures` crate, which we have used indirectly
    by using the `hyper` crate. It's now time to explore this crate in detail. In
    this section, we will discuss the different types of the `futures` crate that
    are available, how to use channels to pass messages between tasks, and how to
    use reactors, which are needed to run tasks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标准 Rust 库不包含用于编写异步应用程序以及与反应器和承诺一起工作的有用模块，您需要一个第三方 crate。这类 crate 的一个例子是 `futures`
    crate，我们通过使用 `hyper` crate 间接使用了这个 crate。现在是时候详细探索这个 crate 了。在本节中，我们将讨论 `futures`
    crate 中可用的不同类型，如何使用通道在任务之间传递消息，以及如何使用反应器，这是运行任务所需的。
- en: Basic types of future crate
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Future crate 的基本类型
- en: The `futures` crate was created to provide Rust developers zero-cost abstractions
    for asynchronous programming. The crate fits the borrowing system of Rust and
    helps to create types that poll resources and return results when they are available.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`futures` crate 的创建是为了为 Rust 开发者提供异步编程的无成本抽象。这个 crate 适应 Rust 的借用系统，并有助于创建在资源可用时轮询资源并返回结果的类型。'
- en: For everyday use, you need only a few types of the `futures` crate. The three
    basic types are `Future`, `Stream`, and `Sink`. Let's explore all of these types
    in detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日常使用，您只需要 `futures` crate 中的一小部分类型。三个基本类型是 `Future`、`Stream` 和 `Sink`。让我们详细探讨这些类型。
- en: Using the Future trait
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Future 特质
- en: '`Future` is a trait that returns a result in the future and represents an operation
    that can''t be completed immediately. Like the `Result` enumeration, `Future`
    has two outcome variants that are represented by the associated types `Item` and
    `Error`. The trait has a `poll` method, which is what retrieves the result. This
    method will be called by a reactor until it returns `Error` or an `Async::Ready`
    value. `Async` is an enumeration that has both `Ready` and `Pending` variants,
    which are used to represent a result of an asynchronous operation. `Ready` means
    the value is ready to use, while `Pending` means the value is not yet available
    and will be ready later.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 是一个特质，它会在未来返回一个结果，并代表一个不能立即完成的操作。与 `Result` 枚举类似，`Future` 有两个结果变体，分别由关联类型
    `Item` 和 `Error` 表示。这个特质有一个 `poll` 方法，用于检索结果。这个方法将由一个反应器调用，直到它返回 `Error` 或 `Async::Ready`
    值。`Async` 是一个枚举，它有 `Ready` 和 `Pending` 两种变体，用于表示异步操作的结果。`Ready` 表示值已准备好使用，而 `Pending`
    表示值尚未可用，将在稍后准备好。'
- en: 'As you can see, `Future` is used for a similar purpose to `Result`. Unlike
    `Result`, however, `Future` is a trait, which means the implementation is not
    specified and many types can implement it. A useful feature is the `FutureExt`
    trait which can be implemented for all the  `Future` instances. This has multiple
    methods to process the result in a delayed manner. For example, if we want to
    convert an obtained value to another type, the trait has a `map` method for this
    purpose. Take a look at the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Future` 用于与 `Result` 类似的目的。然而，与 `Result` 不同，`Future` 是一个特质，这意味着实现未指定，许多类型都可以实现它。一个有用的特性是
    `FutureExt` 特质，它可以应用于所有 `Future` 实例。这个特质提供了多种方法以延迟方式处理结果。例如，如果我们想将获取到的值转换为另一种类型，这个特质提供了一个
    `map` 方法来完成这个目的。让我们看一下以下内容：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we created a `FutureResult` struct from a constant. This type
    implements the `Future` trait and represents a value that is immediately ready.
    Afterward, we called the `map` method from `FutureExt` for `FutureResult`, which
    expects a closure and returns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从一个常量创建了一个`FutureResult`结构体。此类型实现了`Future`特质，并代表一个立即准备好的值。之后，我们为`FutureResult`调用了`FutureExt`中的`map`方法，它期望一个闭包并返回。
- en: You have to use a reactor to get the result for types that implement the `Future`
    trait. We will discuss reactors later in this section. Remember that you can't
    get the result immediately and use it in the next expression; instead, you have
    to create chains of futures or streams to get the appropriate result. Keep reading!
    We will now look into the `Stream` trait.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现`Future`特质的类型，你必须使用反应器来获取结果。我们将在本节后面讨论反应器。记住，你不能立即获取结果并在下一个表达式中使用它；相反，你必须创建未来或流的链来获取适当的结果。继续阅读！我们现在将探讨`Stream`特质。
- en: Using the Stream trait
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Stream特质
- en: '`Stream` is a trait that represents a sequence of deferred items. It works
    in a similar way to the `Iterator` trait, but it uses the poll method to get the
    next `Item` or to return `Error` in the case of failure. The stream can either
    be incoming data from a socket or data that can be read from a file. `Stream`
    can be converted to `Future` and vice versa if the `Future` instance returns a
    `Stream`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`是一个特质，它表示一系列延迟的项目。它的工作方式与`Iterator`特质类似，但它使用`poll`方法来获取下一个`Item`或在失败的情况下返回`Error`。流可以是来自套接字的数据或可以从文件中读取的数据。如果`Future`实例返回一个`Stream`，则可以将`Stream`转换为`Future`，反之亦然。'
- en: 'To use streams effectively, you should learn the methods of the `StreamExt`
    trait. This lets you make a chain to process every item of the stream or even
    join multiple streams into one. For example, you can filter some elements from
    `Stream` using the `filter` method with a predicate:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用流，你应该学习`StreamExt`特质的用法。这让你可以创建一个链来处理流中的每个项目，甚至可以将多个流合并为一个。例如，你可以使用带有谓词的`filter`方法从`Stream`中过滤一些元素：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `iter_ok` method creates a `Stream` from the `Iterator`. It is useful if
    you want to provide your own values from a `Vec` instance.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter_ok`方法从`Iterator`创建一个`Stream`。如果你想从一个`Vec`实例提供自己的值，这很有用。'
- en: A useful feature is the conversion of a `Future` instance that contains a `Stream` as
    a result to just a `Stream`. For example, when you try to connect by TCP using
    the `TcpStream::connect` method of the `tokio` crate, it will return `ConnectFuture`,
    which implements the `Future` trait and returns a `TcpStream` instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的特性是将包含`Stream`结果的`Future`实例转换为仅`Stream`。例如，当你尝试使用`tokio`包中的`TcpStream::connect`方法通过TCP连接时，它将返回`ConnectFuture`，该实例实现了`Future`特质并返回一个`TcpStream`实例。
- en: Using Sink to send data back
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sink发送数据
- en: '`Future` and `Stream` objects supply data from a source, but if you want to
    send a piece of data to the source, you have to use `Sink` objects. `Sink` is
    a trait that is similar to `Stream`, but works in the opposite direction. It contains
    two associated types—`SinkItem` and `SinkError`. The first determines the type
    of item that can be sent using a specific sink. The second represents an error
    if the sending process goes wrong. To interact with a `Sink`, you should use the
    methods of the `SinkExt` trait, which contains `send` methods to send an item
    to a recipient. The `send` method returns a `Send` struct that implements the `Future`
    trait, which means you can''t send an item immediately. The call of the `send`
    methods returns a future that has to be executed with a reactor. If you are not
    concerned about the result of the sending process, you can use the `spawn` method
    to send the future in a separate task.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`和`Stream`对象从源提供数据，但如果你想向源发送数据，你必须使用`Sink`对象。`Sink`是一个与`Stream`类似的特质，但工作方向相反。它包含两个关联类型——`SinkItem`和`SinkError`。第一个确定可以使用特定`Sink`发送的项目类型。第二个表示发送过程出错时的错误。要与`Sink`交互，你应该使用`SinkExt`特质的`send`方法，它包含将项目发送给接收者的`send`方法。`send`方法返回一个实现`Future`特质的`Send`结构体，这意味着你不能立即发送项目。`send`方法的调用返回一个必须由反应器执行的`Future`。如果你不关心发送过程的结果，你可以使用`spawn`方法在单独的任务中发送该`Future`。'
- en: The `Sink` object comes with `Stream` and you have to call the split method
    of `StreamExt` to get an instance of `Sink` attached to a stream. This call returns
    a tuple with both `SplitSink` and  `SplitStream` objects. These are necessary
    to let you read an input and write an output concurrently. Later, both of these
    can be reunited using the `reunite` method of any of these objects. If you are
    writing a complex interaction, you have to use a `Sink` trait many times. It's
    hard to do this using `split` every time, but there are two alternative approaches
    that you can use. The first is to implement all interactions in a separate implementation
    of the `Stream` trait and work with a `Stream` and a `Sink` using the `poll` method.
    The second approach is to `split` a sink and `join` it with a `Receiver` object
    of a channel. You can then use a `Sender` of this channel to send an item without
    splitting the stream every time. We will implement an example of this kind of
    interaction in the next section, in which we will discuss channels.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sink` 对象与 `Stream` 一起提供，您必须调用 `StreamExt` 的 split 方法来获取一个连接到流的 `Sink` 实例。这个调用返回一个包含
    `SplitSink` 和 `SplitStream` 对象的元组。这些是让您能够同时读取输入和写入输出的必要条件。稍后，这些都可以通过这些对象中的任何一个的
    `reunite` 方法重新组合。如果您正在编写复杂的交互，您可能需要多次使用 `Sink` 特性。每次都使用 `split` 来做这件事很难，但有两种替代方法可以使用。第一种是在单独实现的
    `Stream` 特性中实现所有交互，并使用 `poll` 方法与 `Stream` 和 `Sink` 一起工作。第二种方法是将 `Sink` `split`
    并与通道的 `Receiver` 对象 `join`。然后您可以使用这个通道的 `Sender` 发送项目，而无需每次都分割流。我们将在下一节中实现这种交互的示例，其中我们将讨论通道。'
- en: The channel module
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道模块
- en: Concurrent activities often need to interact with each other. It's likely that
    you are already familiar with the `mpsc` module of the standard library, which
    uses blocking operations to send in channels, but this is not suitable for a sophisticated
    reactor that blocks completely if any operation blocks the working thread. Fortunately,
    however, there is the `channel` module in the `futures` crate which is capable
    of carrying out cross-task communication. The `channel` module contains two modules—`mpsc`
    and `oneshot`. Let's look at both.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 并发活动通常需要相互交互。您可能已经熟悉标准库中的 `mpsc` 模块，它使用阻塞操作在通道中发送，但这不适合任何操作阻塞工作线程时完全阻塞的复杂反应器。然而，幸运的是，`futures`
    包中有一个 `channel` 模块，它能够执行跨任务通信。`channel` 模块包含两个模块——`mpsc` 和 `oneshot`。让我们看看这两个模块。
- en: Channels for sending multiple messages
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送多个消息的通道
- en: As a rule, channels are a one-way interaction primitive. A channel has a sender
    to send messages and a receiver to extract messages. Internally, a channel works
    as an array or list that is protected from data races (when two or more threads
    try to write the same memory cell) using an atomic flag or lock-free data types.
    Channels implement one of the queue access patterns we will discuss in the following
    sections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通道是一种单向交互原语。通道有一个发送消息的发送者和一个提取消息的接收者。内部，通道作为一个受原子标志或无锁数据类型保护免受数据竞争（当两个或多个线程尝试写入相同的内存单元格时）的数组或列表。通道实现了我们在以下章节中将要讨论的队列访问模式之一。
- en: Single-Producer Single-Consumer
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单生产者单消费者
- en: This approach means that only one producer can send messages and only one consumer
    can read them. In Rust, this means we have a single `Sender` and a single `Receiver`,
    neither of which can be cloned. The standard library has an internal implementation
    of a **Single-Produce Single-Consumer** (**SPSC**) queue, but this type is not
    available for users. If you need this type of queue, try the `bounded-spsc-queue`
    crate.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法意味着只有一个生产者可以发送消息，只有一个消费者可以读取它们。在 Rust 中，这意味着我们有一个单一的 `Sender` 和一个单一的 `Receiver`，它们都不能被克隆。标准库有一个内部实现的
    **单生产者单消费者**（**SPSC**）队列，但这种类型对用户不可用。如果您需要这种类型的队列，请尝试 `bounded-spsc-queue` 包。
- en: Multi-Producer Single-Consumer
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多生产者单消费者
- en: This is the most popular queue type in Rust. Both the standard library and the
    `futures` crate provide this kind of channel. It's popular because channels are
    often used to provide access to a resource that lives in a single thread for other
    multiple threads. For this type of queue, the `Sender` can be cloned, but the `Receiver`
    can't.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Rust 中最受欢迎的队列类型。标准库和 `futures` 包都提供了这种类型的通道。它之所以受欢迎，是因为通道通常用于为其他多个线程提供访问单个线程中存在的资源的权限。对于这种类型的队列，`Sender`
    可以被克隆，但 `Receiver` 不能。
- en: Multi-Producer Multi-Consumer
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多生产者多消费者
- en: This type of queue allows us to use a `Sender` and a `Receiver` with any amount
    of threads. Both the `Sender` and the `Receiver` can be cloned and used in multiple
    threads. If multiple threads read messages from `Receiver`, you can't predict
    which thread will get a specific message. You can find this functionality in the `crossbeam-channel`
    crate.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的队列允许我们使用任何数量的线程的 `Sender` 和 `Receiver`。`Sender` 和 `Receiver` 都可以被克隆并在多个线程中使用。如果有多个线程从
    `Receiver` 读取消息，你无法预测哪个线程将获得特定的消息。你可以在 `crossbeam-channel` crate 中找到这个功能。
- en: Example of usage
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'To send a message from one thread to another, you are likely to use the `mpsc`
    module of the standard library. The `mpsc` module of the `futures` crate works
    in a similar way, but the `Sender` returns the `Sink` instance when you call the `send`
    method to send an item to the message stream. The `Receiver` implements the `Stream`
    trait, which means you have to use a reactor to poll the stream for new messages:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个线程向另一个线程发送消息，你可能会使用标准库中的 `mpsc` 模块。`futures` crate 中的 `mpsc` 模块以类似的方式工作，但当你调用
    `send` 方法向消息流发送一个项目时，`Sender` 返回 `Sink` 实例。`Receiver` 实现了 `Stream` 特性，这意味着你必须使用一个反应器来轮询流以获取新消息：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, we created a channel that delivers messages of the `u8` type.
    We used the `fold` method of the `Receiver` to add all the values and print the
    result when the channel is closed. We used the `Sender` to `send` values to the
    `Receiver`. At the end, we combined all the futures to a single future with the `future::join_all`
    method and passed the resultant future to an executor of the `tokio` crate. The `join_all`
    function expects a `Vec` of specific types that implements the `Future` trait.
    We added the `to_box` function which converts a type into a `Future` with the `IntoFuture`
    trait, drops the result and an error, and boxes it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个传递 `u8` 类型消息的通道。我们使用了 `Receiver` 的 `fold` 方法来添加所有值，并在通道关闭时打印结果。我们使用
    `Sender` 将值发送到 `Receiver`。最后，我们使用 `future::join_all` 方法将所有 futures 组合到一个单独的未来中，并将结果未来传递给
    `tokio` crate 的执行器。`join_all` 函数期望一个实现了 `Future` 特性的特定类型的 `Vec`。我们添加了 `to_box`
    函数，该函数将类型转换为具有 `IntoFuture` 特性的 `Future`，丢弃结果和错误，并将其装箱：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To close the `Sender`, all we need to do is drop it. If we don't drop the `Sender`,
    the channel remains open and `tokio::run` will never finish.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭 `Sender`，我们只需要将其丢弃。如果我们不丢弃 `Sender`，通道将保持打开状态，`tokio::run` 将永远不会完成。
- en: One-shot
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单次发送
- en: The `oneshot` module implements a channel of a single message. It also has its
    own `Sender` and `Receiver` types, but these work in a different way. The `Sender`
    has a `send` method that completes `oneshot` and consumes an instance completely.
    `Sender` doesn't need to implement the `Sink` trait, because we can't send multiple
    items. It has a preallocated cell for an item that will be put into the cell immediately
    and we don't have any queue.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`oneshot` 模块实现了一个单条消息的通道。它也有自己的 `Sender` 和 `Receiver` 类型，但它们的工作方式不同。`Sender`
    有一个 `send` 方法，它完成 `oneshot` 并完全消耗一个实例。`Sender` 不需要实现 `Sink` 特性，因为我们不能发送多个项目。它有一个预分配的单元格用于放置一个项目，该项目将立即放入单元格中，我们没有任何队列。'
- en: 'The `Receiver` implements the `Future` trait, which means you have to use a
    reactor to get an item from it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Receiver` 实现了 `Future` 特性，这意味着你必须使用一个反应器来从它获取一个项目：'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we created a `Sender` and a `Receiver` for a `oneshot` channel.
    The sender is an object that will be consumed with the `send` method call. The `Receiver`
    implements the `Future` trait and we can use the `map` method to get access to
    a value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为 `oneshot` 通道创建了一个 `Sender` 和一个 `Receiver`。发送者是一个将被 `send` 方法调用消耗的对象。`Receiver`
    实现了 `Future` 特性，我们可以使用 `map` 方法来访问一个值。
- en: Previously, we mentioned that we can send messages to `Sink` from multiple sources.
    Let's implement this example using channels.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到我们可以从多个来源向 `Sink` 发送消息。让我们使用通道实现这个示例。
- en: Using channels to use Sink in multiple places
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个地方使用通道来使用 Sink
- en: 'As mentioned previously, you can use a channel to send data with `Sink` from
    different places and at any time. Look at the following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以使用通道从不同的地方和任何时间发送带有 `Sink` 的数据。看看以下示例：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example creates a `UdpSocket` instance that represents a UDP socket and
    binds it to the `0.0.0.0:12345` address. After that, we wrap a socket with the `UdpFramed`
    type, which implements a `Stream` of data that is generated with the provided
    codec. We will use `LinesCodec` from the `tokio::codec` module. This reads an
    input and uses a line delimiter to split the data into pieces that represent lines
    of text.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例创建了一个`UdpSocket`实例，它代表一个UDP套接字，并将其绑定到`0.0.0.0:12345`地址。之后，我们使用`UdpFramed`类型包装套接字，该类型实现了一个由提供的编解码器生成数据的`Stream`。我们将使用来自`tokio::codec`模块的`LinesCodec`。它读取输入并使用行分隔符将数据分割成代表文本行的片段。
- en: We will split the framed stream and create a channel to send the UDP datagrams
    from different places. We will get familiar with the channel module in the next
    section and learn how tasks can interact with each other asynchronously using
    the `Sender` and `Receiver` objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拆分封装的流并创建一个通道，以便从不同的地方发送UDP数据报。我们将在下一节熟悉通道模块，并学习任务如何通过`Sender`和`Receiver`对象异步交互。
- en: The `channel` method returns the `Sender` and `Receiver` objects. We use the `Receiver`
    to forward all incoming messages to a `Sink` of the UDP connection and we read
    all data from the stream and send it back with the channel. This echo server can
    be implemented more effectively without channels, but we have used them here for
    demonstrative purposes. To send a message, we used a `Sender` of the created channel.
    The advantage of this approach is that you can clone and use a sender instance
    everywhere to send messages to a channel at any time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`channel`方法返回`Sender`和`Receiver`对象。我们使用`Receiver`将所有传入的消息转发到UDP连接的`Sink`，并从流中读取所有数据，然后通过通道将其发送回去。这个回声服务器可以不使用通道更有效地实现，但我们在这里使用它们是为了演示目的。要发送消息，我们使用了创建的通道的`Sender`。这种方法的优势在于您可以在任何地方克隆并使用发送器实例，在任何时候向通道发送消息。'
- en: 'Sometimes, `Future` and `Stream` differ with regard to their `Item`  or  `Error`
    type parameters. To counteract this, we add an  `other` method that wraps any
    error instance with the `io::Error`  type. We use this function to convert one
    error type to another:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`Future`和`Stream`在它们的`Item`或`Error`类型参数方面有所不同。为了解决这个问题，我们添加了一个`other`方法，该方法将任何错误实例包装为`io::Error`类型。我们使用此函数将一个错误类型转换为另一个类型：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can compile this echo server and check how it works using the netcat utility.
    You should install this if your operating system doesn''t contain it already.
    Type the `nc` command with the `--verbose` (short form: `-v`), `--udp` (short
    form: `-u`), and `--no-dns` (short form: `-n`) arguments and enter any text. As
    an example, we have typed *"*Text Message*"*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编译这个回声服务器，并使用netcat实用程序检查其工作情况。如果您操作系统中尚未包含它，您应该安装它。使用带有`--verbose`（简称：`-v`）、`--udp`（简称：`-u`）和`--no-dns`（简称：`-n`）参数的`nc`命令并输入任何文本。例如，我们输入了`"*Text
    Message*"`：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the server has sent us back the provided string. All these examples
    used an executor to run the tasks concurrently. Before we start to implement a
    server, let's learn how executors work.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，服务器已将提供的字符串发送回我们。所有这些示例都使用执行器来并发运行任务。在我们开始实现服务器之前，让我们先了解执行器是如何工作的。
- en: Executors
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行器
- en: 'Since asynchronous tasks can be executed in a single thread, we need a way
    to execute all tasks, even if some tasks generate new tasks during execution.
    There are two approaches to run all tasks:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异步任务可以在单个线程中执行，我们需要一种方法来执行所有任务，即使某些任务在执行过程中生成新的任务。运行所有任务有两种方法：
- en: Run futures and collect streams directly with blocking
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阻塞直接运行未来和收集流
- en: Use an executor to run futures and streams
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器运行未来和流
- en: Let's explore them both in the following sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下部分中探索它们。
- en: Running futures and streams with blocking
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阻塞运行未来和流
- en: 'The first approach is to use the `block_on` or `block_on_stream` functions
    of the `executor` module. Both functions block the current thread to wait for
    the result. It is a naive approach that is not very flexible, but it is great
    in the following circumstances:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用`executor`模块的`block_on`或`block_on_stream`函数。这两个函数都会阻塞当前线程以等待结果。这是一个简单但不太灵活的方法，但在以下情况下非常出色：
- en: If you have only one task
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您只有一个任务
- en: If none of your tasks read or write streams
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的任务中没有读取或写入流
- en: If you want to complete the task from a separate thread that can be blocked
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望从可以阻塞的单独线程中完成任务
- en: You should remember that you must not call this function in asynchronous code,
    because the call will block the executor and your program will stop working.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住，不要在异步代码中调用此函数，因为调用将阻塞执行器，你的程序将停止工作。
- en: Using an executor
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用执行器
- en: The second approach is to execute all tasks with an `Executor`  instance. This
    allows you to run multiple tasks in a single thread, even if some tasks can't
    be completed immediately. To use an `Executor`, you have to create and run it,
    but it will block the current thread and you should add all the necessary tasks
    to be executed at the start.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用 `Executor` 实例执行所有任务。这允许你在单个线程中运行多个任务，即使某些任务不能立即完成。要使用 `Executor`，你必须创建并运行它，但它将阻塞当前线程，你应该在开始时添加所有要执行的任务。
- en: 'For example, if you want to open a socket and process the stream of every incoming
    connection, you have to create a main `Future` that will read the `Stream` of
    incoming connections and spawn a handler for processing the `Stream` of the data
    of the connection using the `tokio::spawn` method. After you have created it,
    you have to `spawn` the whole processing future with the executor. Take a look
    at the following example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想打开一个套接字并处理每个传入连接的流，你必须创建一个主要的 `Future`，它将读取传入连接的 `Stream`，并使用 `tokio::spawn`
    方法为处理连接数据的 `Stream` 创建一个处理器。创建后，你必须使用执行器 `spawn` 整个处理 `Future`。请看以下示例：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we have created a channel. We have also created a stream from
    a sequence of integers using the `stream::iter_ok` method. We send all items of
    the stream to the channel, which reads all the incoming values and prints them
    to a console. We have already dealt with a similar example. In the current version,
    we use the `tokio::spawn` function to spawn a task in an executor of the current
    thread.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个通道。我们还使用 `stream::iter_ok` 方法从一个整数序列创建了一个流。我们将流的所有项目发送到通道，该通道读取所有传入的值并将它们打印到控制台。我们已处理了一个类似的例子。在当前版本中，我们使用
    `tokio::spawn` 函数在当前线程的执行器中创建任务。
- en: As you can see, to use the `futures` crate, you have to build chains of handlers.
    The resultant code is hard to maintain and improve. To simplify asynchronous code,
    the Rust compiler has started to support the `async`/`await` syntax.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，要使用 `futures` crate，你必须构建处理器的链。生成的代码难以维护和改进。为了简化异步代码，Rust 编译器已经开始支持 `async`/`await`
    语法。
- en: The async/await syntax
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async/await 语法
- en: 'Some programming languages, such as JavaScript and C#, have `async` and `await`
    operators which help to write asynchronous code that looks like synchronous code.
    The nightly version of the Rust compiler supports a new syntax and adds `async`
    and `await` (actually, this is a macro) keywords to the language to simplify the
    writing of asynchronous applications. The new code might look as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言，如 JavaScript 和 C#，有 `async` 和 `await` 操作符，可以帮助编写看起来像同步代码的异步代码。Rust 编译器的夜间版本支持一种新语法，并为语言添加了
    `async` 和 `await`（实际上，这是一个宏）关键字，以简化异步应用程序的编写。新代码可能如下所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is not stable yet and may be changed before release. `async` is a new keyword
    that converts a standard function to asynchronous. `await!` is a macro that is
    built in in unstable Rust versions. It suspends the execution of a function and
    waits for the result from a `Future` instance provided to `await!` as argument.
    This macro uses the generators feature to interrupt execution until the `Future`
    under `await!` has been completed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是稳定的，发布前可能会更改。`async` 是一个新关键字，它将标准函数转换为异步。`await!` 是一个在不稳定 Rust 版本中内置的宏。它暂停函数的执行，并等待作为
    `await!` 参数提供的 `Future` 实例的结果。此宏使用生成器功能来中断执行，直到 `await!` 下的 `Future` 完成。
- en: In the remaining part of this chapter, we are going to look at a proxy that
    uses streams to process incoming and outgoing data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将查看一个使用流来处理传入和传出数据的代理。
- en: Creating an image service
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像服务
- en: In this section, we will create a microservice that allows clients to upload
    images and then download them. At first, we implement a handler to upload images
    and save them to a filesystem asynchronously using the `tokio` crate. After that,
    we will implement a downloading handler that allows the user to download original
    images from files that were uploaded before.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个微服务，允许客户端上传图像，然后下载它们。首先，我们实现一个处理程序来异步上传图像并将它们保存到文件系统中，使用 `tokio`
    crate。之后，我们将实现一个下载处理程序，允许用户从之前上传的文件中下载原始图像。
- en: Uploading images
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传图像
- en: 'Let''s start implementing a microservice to store and serve images with an
    uploading files feature. To get incoming files, we have to read an incoming `Stream`
    of a `Request`. The `Stream` might be huge, so we shouldn''t hold the whole file
    in memory. We will read the incoming data in chunks and write them immediately
    to a file. Let''s create the `main` function of our microservice:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现一个微服务，该服务可以存储和提供具有上传文件功能的图像。为了获取传入的文件，我们必须读取 `Request` 的一个传入 `Stream`。`Stream`
    可能非常大，所以我们不应该将整个文件保留在内存中。我们将分块读取传入的数据，并立即将它们写入文件。让我们创建微服务的 `main` 函数：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This looks like the other examples that we've created but here we set a `std::path::Path`
    to a directory that will keep all incoming files. We will create the directory
    with the path we set before using the `create_dir` function of the `std::fs` module.
    If the creation of the directory fails, we will ignore it, but for production
    code it's better to stop creating a server and return an `Error` or print the
    necessary information. This is suitable for demonstrative purposes, but it's not
    reliable, because locally stored files can be lost in the server and your service
    will be corrupted. In real microservices, you may prefer to use a third-party
    service, such as AWS S3, to store and deliver files to clients.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像我们创建的其他示例，但在这里我们将 `std::path::Path` 设置为一个将保留所有传入文件的目录。我们将使用 `std::fs` 模块的
    `create_dir` 函数使用我们之前设置的路径创建目录。如果目录创建失败，我们将忽略它，但对于生产代码来说，最好停止创建服务器并返回一个 `Error`
    或打印必要的信息。 这适用于演示目的，但不可靠，因为本地存储的文件可能会在服务器中丢失，并且您的服务可能会损坏。在现实中的微服务中，您可能更喜欢使用第三方服务，例如
    AWS S3，来存储和向客户端提供文件。
- en: After we create a directory to store files, we will start a `Server` with a
    `microservice_handler` that we will define later. Pay attention to when we pass
    a reference to a `Path`. Providing a path as a parameter is useful if you want
    to set another folder using command-line arguments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建一个目录来存储文件后，我们将启动一个 `Server`，它将使用我们稍后定义的 `microservice_handler`。请注意，当我们传递一个
    `Path` 的引用时。如果想要使用命令行参数设置另一个文件夹，将路径作为参数提供是有用的。
- en: 'We can now define the `microservice_handler` function that will handle four
    cases:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义将处理四个情况的 `microservice_handler` 函数：
- en: Returning an index page on the `/` path
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `/` 路径上返回索引页面
- en: Storing a file to the `/upload` path
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件存储到 `/upload` 路径
- en: Returning the uploaded file with the `/download` path
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `/download` 路径返回上传的文件
- en: Returning 404 errors for other requests
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其他请求返回 404 错误
- en: 'The function has the following definition:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的定义如下：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a similar handler definition to that we used in [Chapter 2](621dffeb-7f43-4c11-9ac5-00a366dc8d9f.xhtml), *Developing
    a Microservice with Hyper Crate*, and [Chapter 3](751f86d9-59ce-4966-beb8-cd743b521373.xhtml), *Logging
    and Configuring Your Microservices*, but we use `std::io::Error` instead of `hyper::Error`.
    This is because we are not only working with requests and responses, but we are
    also using a filesystem that can cause errors of other types. We also expect an
    argument of the `Path` type to determine a directory in which we will store files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在 [第 2 章](621dffeb-7f43-4c11-9ac5-00a366dc8d9f.xhtml) 中使用的处理程序定义相似，*使用 Hyper
    Crate 开发微服务*，以及 [第 3 章](751f86d9-59ce-4966-beb8-cd743b521373.xhtml) 中使用的，*记录和配置您的微服务*，但我们使用
    `std::io::Error` 而不是 `hyper::Error`。这是因为我们不仅与请求和响应一起工作，我们还使用一个可能会引起其他类型错误的文件系统。我们还期望一个
    `Path` 类型的参数来确定我们将存储文件的目录。
- en: 'Lets add a `match` expression to match the parameters of an incoming request.
    We will consider only two branches here—the first is when a client sends a GET
    request to the root path, and the second is for all other requests. We will add
    other branches later:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个 `match` 表达式来匹配传入请求的参数。在这里，我们将考虑两个分支——第一个是当客户端向根路径发送 GET 请求时，第二个是对于所有其他请求。我们稍后会添加其他分支：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We used similar pattern matching in [Chapter 2](621dffeb-7f43-4c11-9ac5-00a366dc8d9f.xhtml),
    *Developing a Microservice with Hyper Crate*. Previously, we had a `match` expression
    to check the method and the path of incoming requests. This time, we need a copy
    of `Uri::path`, because we will need to use a path copy in regular expressions
    of other branches later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 2 章](621dffeb-7f43-4c11-9ac5-00a366dc8d9f.xhtml) 中使用了类似的模式匹配，*使用 Hyper
    Crate 开发微服务*。之前，我们有一个 `match` 表达式来检查传入请求的方法和路径。这次，我们需要 `Uri::path` 的一个副本，因为我们稍后需要在其他分支的正则表达式中使用路径副本。
- en: 'The `response_with_code` function returns a `Future` instance now, instead
    of `Request`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`response_with_code` 函数现在返回一个 `Future` 实例，而不是 `Request`：'
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s add the remaining branches to the `match` expression. Let''s add one
    to handle the uploading of files:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将剩余的分支添加到`match`表达式中。让我们添加一个来处理文件的上传：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This request-handling branch expects the `POST` method and the `"/upload"` path.
    We don't check the user credentials and we allow everyone to upload a file, but
    in a real microservice, you should filter incoming traffic to avoid spam or malicious
    use.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求处理分支期望的是`POST`方法和`"/upload"`路径。我们不检查用户凭证，并允许每个人上传文件，但在实际的微服务中，你应该过滤传入流量以避免垃圾邮件或恶意使用。
- en: In the first line of the branch, we generate a random name for the incoming
    file. We can provide the client with an opportunity to set the name of the file,
    but this is a dangerous practice. If you don't check the paths of incoming requests,
    a client can request a file from any folder in the server. We take an instance
    of random number generator that implements the `Rng` trait with `thread_rng` function
    call of the `rand` crate. Afterward, we use the generator to get an `Iterator`
    of samples by the `sample_iter` method call of the `Rng` trait and provide an `Alphanumeric`
    distribution to it that generates random characters and digits. We take 20 items
    from the iterator and collect them in a `String`. Then, we convert the `files`
    variable to `PathBuf` using the `to_path_buf` method and add the generated filename
    to the path.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在分支的第一行，我们为传入的文件生成一个随机名称。我们可以给客户端提供设置文件名称的机会，但这是一种危险的做法。如果你不检查传入请求的路径，客户端可以从服务器上的任何文件夹请求一个文件。我们使用`rand`
    crate中的`thread_rng`函数调用获取一个实现了`Rng`特质的随机数生成器实例。之后，我们使用生成器通过`Rng`特质的`sample_iter`方法调用获取一个样本的`Iterator`，并向它提供一个生成随机字符和数字的`Alphanumeric`分布。我们从迭代器中取出20个项并将它们收集到一个`String`中。然后，我们使用`to_path_buf`方法将`files`变量转换为`PathBuf`，并将生成的文件名添加到路径中。
- en: In the next line, we create a `File` with the generated name. Here lies the
    most important difference of asynchronous applications—we use the `tokio::fs::File`
    type instead of the `std::fs::File` type, so we return a `Future` instance instead
    of a file reference. The future will be completed when the file is created. After
    that, we use the created file to write some data to this file asynchronously.
    The `tokio::fs::File` type wraps `std::fs::File`, but implements the `AsyncRead`
    and `AsyncWrite` traits. At any time, you can call the `into_std` method to unwrap
    the standard `File` type. Before we do this, however, we will write an incoming
    stream to the created file. Let's take a closer look at the `tokio` crate and
    some important issues to do with the asynchronous reading and writing of files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们使用生成的名称创建一个`File`。这里隐藏了异步应用程序最重要的区别——我们使用`tokio::fs::File`类型而不是`std::fs::File`类型，因此我们返回一个`Future`实例而不是文件引用。当文件创建完成后，这个`Future`将被完成。之后，我们使用创建的文件异步地向该文件写入一些数据。`tokio::fs::File`类型封装了`std::fs::File`，但实现了`AsyncRead`和`AsyncWrite`特质。在任何时候，你都可以调用`into_std`方法来解包标准的`File`类型。然而，在我们这样做之前，我们将传入的流写入创建的文件。让我们更仔细地看看`tokio`
    crate以及与文件异步读写相关的一些重要问题。
- en: The tokio crate
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`tokio` crate'
- en: The `tokio` crate provides the functionality to work with the network connections
    of files in an asynchronous manner. It includes wrappers for the TCP and UDP sockets—`TcpStream`
    and `UdpSocket`. It also includes types to access a filesystem through the `Future`
    and `Stream` traits. There is no cross-platform approach to work with files asynchronously,
    because operating systems have their own implementations of non-blocking APIs.
    Some operating systems, however, don't have good asynchronous APIs at all. To
    provide cross-platform asynchronous access to filesystems, `tokio` uses the `tokio_threadpool`
    crate, which has a `blocking` method that runs a task in a separate thread. This
    helps to implement asynchronous interaction for types that can block the thread
    using input/output operations. It isn't the most effective way to interact with
    a filesystem, but it does allow us to convert synchronous APIs to asynchronous. The `tokio`
    crate also contains an `Executor` trait and a `Timer` module. We've considered
    executors before. The `timer` module contains the `Timeout` and `Interval` types
    to create a `Future` and a `Stream` that generate values whenever a specified
    time period has elapsed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokio` crate提供了以异步方式处理文件网络连接的功能。它包括TCP和UDP套接字的包装器——`TcpStream`和`UdpSocket`。它还包括通过`Future`和`Stream`特质访问文件系统的类型。没有跨平台的异步文件处理方法，因为操作系统有自己的非阻塞API实现。然而，一些操作系统根本就没有好的异步API。为了提供跨平台的文件系统异步访问，`tokio`使用`tokio_threadpool`
    crate，它有一个`blocking`方法，在单独的线程中运行任务。这有助于实现可以使用输入/输出操作阻塞线程的类型异步交互。这不是与文件系统交互最有效的方法，但它确实允许我们将同步API转换为异步。`tokio`
    crate还包含一个`Executor`特质和一个`Timer`模块。我们之前已经考虑过执行器。`timer`模块包含`Timeout`和`Interval`类型，用于创建在指定时间间隔过去时产生值的`Future`和`Stream`。'
- en: Asynchronous input/output of files
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件的异步输入/输出
- en: 'We now have to create a chain to read all incoming chunks and write them to
    the created file. As you might remember, `File::create` returns a `Future` that
    returns a `File` instance. We won''t take the result immediately, because I/O
    operations take some time and can cause the current running thread to be blocked.
    We have to use the `Future::and_then` method to move the result (when it is ready)
    to other `Future` instance that will send all chunks to the file. To do that,
    we will use a `Body` instance that we get with the `into_body` method call of
    the `Request` that is stored in the `req` variable. The `Body` implements a `Stream`
    of the `Chunk` instances, but it can produce a `hyper::Error`. Since `File::create`
    can produce an `io::Error`, we have to convert the `hyper::Error` to an `io::Error`
    using the `other` function call as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须创建一个链来读取所有传入的块并将它们写入创建的文件。正如你可能记得的，`File::create`返回一个返回`File`实例的`Future`。我们不会立即获取结果，因为I/O操作需要一些时间，可能会阻塞当前运行的线程。我们必须使用`Future::and_then`方法将结果（当它准备好时）移动到其他`Future`实例，该实例将所有块发送到文件。为此，我们将使用通过`req`变量中存储的`Request`的`into_body`方法调用获得的`Body`实例。`Body`实现了`Chunk`实例的`Stream`，但它可以产生一个`hyper::Error`。由于`File::create`可以产生一个`io::Error`，我们必须使用`other`函数调用将`hyper::Error`转换为`io::Error`，如下所示：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding function creates an `io::Error` with `ErrorKind::Other` based
    on any `Error` provided with the single argument. We use the `other` function
    with the `map_err` of the `StreamExt` to convert failures of the stream to `io::Error`. When
    the `Stream` of the `Body` is compatible with the type of error, we can create
    a `Future` that will move incoming binary data to the file. To do that, we can
    use a `fold` method of a `StreamExt` trait. If you are familiar with functional
    programming, you might know how this works already. The `fold` function takes
    two arguments—an initial value, which will be reused in every iteration, and a
    function, which carries out some processing with the initial value. Processing
    functions have to return a `Future` instance on every call, with one condition—the
    `Future` has to return the same type as the type of the initial value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能根据提供的单个参数中的任何`Error`创建一个带有`ErrorKind::Other`的`io::Error`。我们使用`StreamExt`的`map_err`函数与`other`函数一起将流的失败转换为`io::Error`。当`Body`的`Stream`与错误类型兼容时，我们可以创建一个`Future`，它将传入的二进制数据移动到文件中。为此，我们可以使用`StreamExt`特质的`fold`方法。如果你熟悉函数式编程，你可能已经知道它是如何工作的。`fold`函数接受两个参数——一个初始值，它将在每次迭代中重复使用，以及一个函数，该函数使用初始值执行一些处理。处理函数必须在每次调用时返回一个`Future`实例，有一个条件——`Future`必须返回与初始值相同类型的类型。
- en: We will provide a `File` instance as an initial value and we will call `tokio::io::write_all`
    to write an incoming chunk of the request's body to a file. The `write_all` function
    expects an output stream and a binary slice. It returns a `Future`, which returns
    a tuple with an output stream and a provided slice on success. We have to use
    the `map` method of the returned `Future` to drop the slice and keep the file. The
    resultant chain will `fold` the whole `Stream` to a `Future`, which will return
    a filled `File` instance when all chunks are written to the file. We store this
    `Future` to write a variable and use the map method of `FutureExt` to drop the
    file instance (the real file with the written data will remain on the drive),
    and return a `Response` with the name of the stored file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供一个 `File` 实例作为初始值，并将调用 `tokio::io::write_all` 将请求体的一个数据块写入文件。`write_all`
    函数期望一个输出流和一个二进制切片。它在成功时返回一个 `Future`，该 `Future` 返回一个包含输出流和提供的切片的元组。我们必须使用返回的 `Future`
    的 `map` 方法来丢弃切片并保留文件。结果链将 `fold` 整个 `Stream` 到一个 `Future`，当所有数据块都写入文件时，它将返回一个填充的
    `File` 实例。我们将这个 `Future` 存储到一个变量中，并使用 `FutureExt` 的 `map` 方法来丢弃文件实例（带有写入数据的真实文件将保留在驱动器上），并返回一个带有存储文件名的
    `Response`。
- en: We have now successfully implemented file uploading. We should now discuss how
    to upload files using HTML forms and add a downloading feature to our service.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功实现了文件上传。现在我们应该讨论如何使用 HTML 表单上传文件，并为我们服务添加下载功能。
- en: Multipart form requests
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多部分表单请求
- en: 'So far in this chapter, we have used requests with binary bodies. This is suitable
    for microservices, but if you want to send files with an HTML form, you should
    use a request with a `multipart/form-data` type of content. This allows a client
    to include multiple files in a single request, but it also needs a parser to split
    files from the body of a request. The `hyper` crate doesn''t include a parser
    for multipart requests, and you can use other crates such as the `multipart` crate
    to parse requests instead. This, however, doesn''t work asynchronously, so you
    should use the `multipart-async` crate with the latest versions of the `hyper`
    crate. You can also implement multipart requests yourself. To implement this,
    you can create a struct that implements the `Stream` trait and parses incoming
    chunks of data. Multipart requests have the `multipart/form-data` content type
    with a boundary value such as `boundary=53164434ae464234f`. Its body contains
    a separator and the embedded files:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们使用了具有二进制体的请求。这对于微服务来说很合适，但如果你想要通过 HTML 表单发送文件，你应该使用具有 `multipart/form-data`
    内容类型的请求。这允许客户端在单个请求中包含多个文件，但它也需要一个解析器来从请求体中分割文件。`hyper` 包不包含多部分请求的解析器，你可以使用其他包，例如
    `multipart` 包来解析请求。然而，这并不支持异步操作，所以你应该使用与 `hyper` 包最新版本兼容的 `multipart-async` 包。你也可以自己实现多部分请求。要实现这一点，你可以创建一个实现
    `Stream` 特性的结构体，并解析传入的数据块。多部分请求具有 `multipart/form-data` 内容类型，边界值例如 `boundary=53164434ae464234f`。其体包含一个分隔符和嵌入的文件：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Your stream has to implement **`Stream<Item=FileEntry>`**, which reads a request
    and extracts files using the provided boundary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您的流必须实现 **`Stream<Item=FileEntry>`**，它读取请求并使用提供的边界提取文件。
- en: Downloading images
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载图片
- en: 'Let''s implement a branch to download images. The handler can download files
    using the  `/download/filename` path. To extract the name of the file, we use
    a regular expression:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个分支来下载图片。处理程序可以使用 `/download/filename` 路径下载文件。为了提取文件名，我们使用正则表达式：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will use `startwith` to detect the `/download` part of the path. Take a
    look at the implementation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `startwith` 来检测路径中的 `/download` 部分。看看实现方式：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we expect a `GET` method and check that the paths match with
    the `DOWNLOAD_FILE` regular expression. We use the name `"filename"` to extract
    a string with the name of the file. Since we have the filepath variable with a
    path to a folder, we convert the `Path` value to the `PathBuf`  type using the `to_path_buf`
    method of the `Path` instance and push a filename to it. After that, we use the
    file type of the `tokio` crate to open a file, which has asynchronous reading
    and writing capabilities to work with the file's content. The `open` method of
    the file returns an `OpenFuture` instance that resolves to a `File` instance when
    it is successful.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们期望一个`GET`方法，并检查路径是否与`DOWNLOAD_FILE`正则表达式匹配。我们使用名称`"filename"`来提取文件名称的字符串。由于我们有一个包含文件夹路径的`filepath`变量，我们使用`Path`实例的`to_path_buf`方法将`Path`值转换为`PathBuf`类型，并将一个文件名推送到它。之后，我们使用`tokio`
    crate的文件类型来打开一个文件，它具有异步读写能力以处理文件内容。文件的`open`方法返回一个`OpenFuture`实例，当成功时解析为一个`File`实例。
- en: We wrap a file with `FileChunkStream`, imported from the `hyper_staticfile`
    crate. This stream reads a `File` and returns chunks of bytes. The body has a
    `wrap_stream` method and we can send the whole stream as a response. When the
    stream is forwarded to a client, the opened `File` will be closed when the stream
    is dropped.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用从`hyper_staticfile` crate导入的`FileChunkStream`包装文件。这个流读取一个`File`并返回字节数据块。主体有一个`wrap_stream`方法，我们可以将整个流作为响应发送。当流被转发到客户端时，打开的`File`将在流被丢弃时关闭。
- en: The last thing we should do is return a `Body` instance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后应该做的是返回一个`Body`实例。
- en: sendfile for sending files
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于发送文件的sendfile
- en: Forwarding files from one file to another is not effective, because this approach
    copies every chunk of data to the memory before sending it. Popular servers such
    as **NGINX** use the `sendfile` system call to send files from one file descriptor
    to another. This helps to save a lot of resources, because `sendfile` allows for
    zero copy, which means that we can write the buffer directly to the necessary
    device. To use `sendfile` with `tokio`, you have to implement a wrapper for it,
    but I don't think it's a good idea to serve static files with a microservice.
    You may prefer to use NGINX for this task or use object storage such as **AWS
    S3**, which can provide static files to a client.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个文件转发文件到另一个文件并不有效，因为这种方法在发送之前会将每个数据块复制到内存中。流行的服务器如**NGINX**使用`sendfile`系统调用来从一个文件描述符发送文件到另一个。这有助于节省大量资源，因为`sendfile`允许零拷贝，这意味着我们可以直接将缓冲区写入必要的设备。要使用`tokio`的`sendfile`，你必须为其实现一个包装器，但我不认为用微服务来提供静态文件是一个好主意。你可能更喜欢使用NGINX来完成这项任务，或者使用对象存储如**AWS
    S3**，它可以为客户端提供静态文件。
- en: Testing the service
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试服务
- en: 'The image service is now ready for testing. Compile it, download any image
    from the internet, and use `curl` to upload it to our service:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图像服务现在已准备好进行测试。编译它，从互联网下载任何图片，并使用`curl`将其上传到我们的服务：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This request downloads the Rust logo and uploads it to our microservice. It
    will return the name of the uploaded image with a response. Put it after the `/download/`
    path and try to download it with your browser:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求下载Rust标志并将其上传到我们的微服务。它将以响应返回上传的图像名称。将其放在`/download/`路径之后，并尝试用你的浏览器下载它：
- en: '![](img/3ce9c8aa-0ed8-44bf-95ca-45091bfeef1d.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ce9c8aa-0ed8-44bf-95ca-45091bfeef1d.png)'
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have examined the `futures` and `tokio` crates. The `futures`
    crate contains types to work with delayed results and streams. We have compared
    the `Future` and `Result` types and the `Stream` and `Iterator` types. After that,
    we implemented a microservice that stores images and sends them back to the client.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了`futures`和`tokio` crate。`futures` crate包含用于处理延迟结果和流的类型。我们比较了`Future`和`Result`类型以及`Stream`和`Iterator`类型。之后，我们实现了一个存储图像并将其发送回客户端的微服务。
- en: We will improve microservice of this chapter using threads and background tasks
    in [Chapter 10](ba240208-414e-4dd4-bba8-8bd2658949cd.xhtml), *Background Tasks
    and Thread Pools in Microservices*. But in the next chapter, we will take a look
    at reactive microservices and using remote procedure calls as an alternative way
    to implement of microservices.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第10章[背景任务和线程池在微服务中](ba240208-414e-4dd4-bba8-8bd2658949cd.xhtml)中改进本章的微服务，使用线程和后台任务。但在下一章，我们将探讨反应式微服务和使用远程过程调用作为实现微服务的替代方法。
