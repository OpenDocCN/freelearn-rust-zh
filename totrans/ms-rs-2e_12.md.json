["```rs\n*2\\r\\n$3\\r\\nget\\r\\n$3\\r\\nfoo\\r\\n\n```", "```rs\nrudis_sync/Cargo.toml\n\n[dependencies]\nlazy_static = \"1.2.0\"\nresp = { git = \"https://github.com/creativcoder/resp\" }\n```", "```rs\n// rudis_sync/src/main.rs\n\nuse lazy_static::lazy_static;\nuse resp::Decoder;\nuse std::collections::HashMap;\nuse std::env;\nuse std::io::{BufReader, Write};\nuse std::net::Shutdown;\nuse std::net::{TcpListener, TcpStream};\nuse std::sync::Mutex;\nuse std::thread;\n\nmod commands;\nuse crate::commands::process_client_request;\n\ntype STORE = Mutex<HashMap<String, String>>;\n\nlazy_static! {\n    static ref RUDIS_DB: STORE = Mutex::new(HashMap::new());\n}\n\nfn main() {\n    let addr = env::args()\n        .skip(1)\n        .next()\n        .unwrap_or(\"127.0.0.1:6378\".to_owned());\n\n    let listener = TcpListener::bind(&addr).unwrap();\n    println!(\"rudis_sync listening on {} ...\", addr);\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n        println!(\"New connection from: {:?}\", stream);\n        handle_client(stream);\n    }\n}\n```", "```rs\n// rudis_sync/src/main.rs\n\nfn handle_client(stream: TcpStream) {\n    let mut stream = BufReader::new(stream);\n    let decoder = Decoder::new(&mut stream).decode();\n    match decoder {\n        Ok(v) => {\n            let reply = process_client_request(v);\n            stream.get_mut().write_all(&reply).unwrap();\n        }\n        Err(e) => {\n            println!(\"Invalid command: {:?}\", e);\n            let _ = stream.get_mut().shutdown(Shutdown::Both);\n        }\n    };\n}\n```", "```rs\n// rudis_sync/src/commands.rs\n\nuse crate::RUDIS_DB;\nuse resp::Value;\n\npub fn process_client_request(decoded_msg: Value) -> Vec<u8> {\n    let reply = if let Value::Array(v) = decoded_msg {\n        match &v[0] {\n            Value::Bulk(ref s) if s == \"GET\" || s == \"get\" => handle_get(v),\n            Value::Bulk(ref s) if s == \"SET\" || s == \"set\" => handle_set(v),\n            other => unimplemented!(\"{:?} is not supported as of now\", other),\n        }\n    } else {\n        Err(Value::Error(\"Invalid Command\".to_string()))\n    };\n\n    match reply {\n        Ok(r) | Err(r) => r.encode(),\n    }\n}\n\n```", "```rs\n// rudis_sync/src/commands.rs\n\nuse crate::RUDIS_DB;\nuse resp::Value;\n\npub fn handle_get(v: Vec<Value>) -> Result<Value, Value> {\n    let v = v.iter().skip(1).collect::<Vec<_>>();\n    if v.is_empty() {\n        return Err(Value::Error(\"Expected 1 argument for GET command\".to_string()))\n    }\n    let db_ref = RUDIS_DB.lock().unwrap();\n    let reply = if let Value::Bulk(ref s) = &v[0] {\n        db_ref.get(s).map(|e| Value::Bulk(e.to_string())).unwrap_or(Value::Null)\n    } else {\n        Value::Null\n    };\n    Ok(reply)\n}\n\npub fn handle_set(v: Vec<Value>) -> Result<Value, Value> {\n    let v = v.iter().skip(1).collect::<Vec<_>>();\n    if v.is_empty() || v.len() < 2 {\n        return Err(Value::Error(\"Expected 2 arguments for SET command\".to_string()))\n    }\n    match (&v[0], &v[1]) {\n        (Value::Bulk(k), Value::Bulk(v)) => {\n            let _ = RUDIS_DB\n                .lock()\n                .unwrap()\n                .insert(k.to_string(), v.to_string());\n        }\n        _ => unimplemented!(\"SET not implemented for {:?}\", v),\n    }\n\n    Ok(Value::String(\"OK\".to_string()))\n}\n```", "```rs\ndb_ref.get(s).map(|e| Value::Bulk(e.to_string())).unwrap_or(Value::Null)\n```", "```rs\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n        println!(\"New connection from: {:?}\", stream);\n        handle_client(stream);\n        thread::sleep(Duration::from_millis(3000));\n    }\n```", "```rs\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n        println!(\"New connection from: {:?}\", stream); thread::spawn(|| handle_client(stream));\n    }\n```", "```rs\npub trait Future {\n    type Item;\n    type Error;\n    fn poll(&mut self) -> Poll<Self::Item, Self::Error>;\n}\n```", "```rs\n# rudis_async/Cargo.toml\n\n[dependencies]\ntokio = \"0.1.13\"\nfutures = \"0.1.25\"\nlazy_static = \"1.2.0\"\nresp = { git = \"https://github.com/creativcoder/resp\" }\ntokio-codec = \"0.1.1\"\nbytes = \"0.4.11\"\n```", "```rs\n// rudis_async/src/main.rs\n\nmod codec;\nuse crate::codec::RespCodec;\n\nuse lazy_static::lazy_static;\nuse std::collections::HashMap;\nuse std::net::SocketAddr;\nuse std::sync::Mutex;\nuse tokio::net::TcpListener;\nuse tokio::net::TcpStream;\nuse tokio::prelude::*;\nuse tokio_codec::Decoder;\nuse std::env;\n\nmod commands;\nuse crate::commands::process_client_request;\n\nlazy_static! {\n    static ref RUDIS_DB: Mutex<HashMap<String, String>> = Mutex::new(HashMap::new());\n}\n```", "```rs\n// rudis_async/main.rs\n\nfn main() -> Result<(), Box<std::error::Error>> {\n    let addr = env::args()\n        .skip(1)\n        .next()\n        .unwrap_or(\"127.0.0.1:6378\".to_owned());\n    let addr = addr.parse::<SocketAddr>()?;\n\n    let listener = TcpListener::bind(&addr)?;\n    println!(\"rudis_async listening on: {}\", addr);\n\n    let server_future = listener\n        .incoming()\n        .map_err(|e| println!(\"failed to accept socket; error = {:?}\", e))\n        .for_each(handle_client);\n\n    tokio::run(server_future);\n    Ok(())\n}\n```", "```rs\n// rudis_async/src/main.rs\n\nfn handle_client(client: TcpStream) -> Result<(), ()> {\n    let (tx, rx) = RespCodec.framed(client).split();\n    let reply = rx.and_then(process_client_request);\n    let task = tx.send_all(reply).then(|res| {\n        if let Err(e) = res {\n            eprintln!(\"failed to process connection; error = {:?}\", e);\n        }\n        Ok(())\n    });\n\n    tokio::spawn(task);\n    Ok(())\n}\n```", "```rs\n// rudis_async/src/codec.rs\n\nuse std::io;\nuse bytes::BytesMut;\nuse tokio_codec::{Decoder, Encoder};\nuse resp::{Value, Decoder as RespDecoder};\nuse std::io::BufReader;\nuse std::str;\n\npub struct RespCodec;\n\nimpl Encoder for RespCodec {\n    type Item = Vec<u8>;\n    type Error = io::Error;\n\n    fn encode(&mut self, msg: Vec<u8>, buf: &mut BytesMut) -> io::Result<()> {\n        buf.reserve(msg.len());\n        buf.extend(msg);\n        Ok(())\n    }\n}\n\nimpl Decoder for RespCodec {\n    type Item = Value;\n    type Error = io::Error;\n\n    fn decode(&mut self, buf: &mut BytesMut) -> io::Result<Option<Value>> {\n        let s = if let Some(n) = buf.iter().rposition(|b| *b == b'\\n') {\n            let client_query = buf.split_to(n + 1);\n\n            match str::from_utf8(&client_query.as_ref()) {\n                Ok(s) => s.to_string(),\n                Err(_) => return Err(io::Error::new(io::ErrorKind::Other, \"invalid string\")),\n            }\n        } else {\n            return Ok(None);\n        };\n\n        if let Ok(v) = RespDecoder::new(&mut BufReader::new(s.as_bytes())).decode() {\n            Ok(Some(v))\n        } else {\n            Ok(None)\n        }\n    }\n}\n```", "```rs\n$ redis-cli -p 6378\n```"]