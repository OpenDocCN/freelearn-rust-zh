- en: Handling Files and the Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件和文件系统
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Working with text files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文本文件
- en: Handling bytes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理字节
- en: Working with binary files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理二进制文件
- en: Compressing and decompressing data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩和解压缩数据
- en: Traversing the filesystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历文件系统
- en: Finding files with glob patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用glob模式查找文件
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In these times of big data, machine learning, and cloud services, you cannot
    rely on having all of your data always in memory. Rather, you need to be able
    to effectively inspect and traverse the filesystem and manipulate its content
    at your leisure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在大数据、机器学习和云服务时代，你不能依赖你的所有数据始终在内存中。相反，你需要能够有效地检查和遍历文件系统，并在你方便的时候操作其内容。
- en: Examples of things you will be able to do after reading this chapter include
    configuring files in subdirectories with different naming variations, saving your
    data in efficient binary formats, reading protocols generated by other programs,
    and compressing your data in order to send it over the internet at fast speeds.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了这一章之后，你将能够做到的事情包括在子目录中配置具有不同命名变体的文件、以高效的二进制格式保存你的数据、读取其他程序生成的协议，以及压缩你的数据以便以快速的速度通过互联网发送。
- en: Working with text files
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文本文件
- en: In this recipe, we will learn how to read, write, create, truncate, and append
    text files. Armed with this knowledge, you will be able to apply all other recipes
    to files instead of in-memory strings.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何读取、写入、创建、截断和追加文本文件。掌握了这些知识，你将能够将所有其他菜谱应用于文件，而不是内存中的字符串。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何去做...
- en: Create a Rust project to work on during this chapter with `cargo new chapter-three`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new chapter-three` 创建一个在本章中工作的Rust项目。
- en: Navigate into the newly created `chapter-three` folder. For the rest of this
    chapter, we will assume that your command line is currently in this directory.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的 `chapter-three` 文件夹。在本章的其余部分，我们将假设你的命令行当前位于这个目录。
- en: Inside the `src` folder, create a new folder called `bin`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 文件夹内，创建一个名为 `bin` 的新文件夹。
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除生成的 `lib.rs` 文件，因为我们不是创建一个库。
- en: In the `src/bin` folder, create a file called `text_files.rs`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中，创建一个名为 `text_files.rs` 的文件。
- en: 'Add the following code and run it with `cargo run --bin text_files`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用 `cargo run --bin text_files` 运行它：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These are the functions called by the `main()` function:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是 `main()` 函数调用的函数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Reading and writing on the same handle:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个句柄上进行读取和写入：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Our `main` function is split into three parts:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `main` 函数分为三个部分：
- en: Creating a file.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件。
- en: Overwriting a file, which in this context is called *truncating.*
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖文件，在这个上下文中被称为 *截断*。
- en: Appending to a file.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向文件中追加。
- en: In the first two parts, we load the entire content of the file into a single
    `String` and display it [11 and 18]. In the last one, we iterate over the individual
    lines in the file and print them [28].
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两部分中，我们将整个文件内容加载到一个单独的 `String` 中并显示它 [11 和 18]。在最后一部分中，我们遍历文件中的单个行并打印它们 [28]。
- en: '`File::open()` opens a file in read-only mode and returns you a handle to it
    [39]. Because this handle implements the `Read` trait, we could now just directly
    read it into a string with `read_to_string`. However, in our examples, we wrap
    it first in a `BufReader`[42]. This is because a dedicated reader can greatly
    improve the performance of their resource access by collecting read instructions,
    which is called *buffering*, and executing them in big batches. For the first
    reading example, `read_file`[37], this doesn''t make any difference whatsoever,
    as we read it all in one go anyway. We still use it because it is a good practice,
    as it allows us to flexibly change the exact reading mechanisms of our function
    later on without worrying about performance. If you want to see a function where
    a `BufReader` actually does something, look a little further down, to `read_file_iterator`[48].
    It appears to read the file line by line. This would be a very inefficient operation
    when dealing with a large file, which is why a `BufReader` actually reads a large
    chunk of the file in one go and then returns that segment line by line. The result
    is optimized file reading without us even noticing or caring what is going on
    in the background, which is pretty convenient.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`File::open()` 以只读模式打开文件，并返回对该文件的句柄 [39]。因为这个句柄实现了 `Read` 特性，我们现在可以直接使用 `read_to_string`
    将其读入字符串。然而，在我们的示例中，我们首先将其包装在一个 `BufReader` [42] 中。这是因为专门的读取器可以通过收集读取指令来大大提高其资源访问的性能，这被称为
    *缓冲*，并且可以批量执行它们。对于第一个读取示例 `read_file` [37]，这根本没有任何区别，因为我们无论如何都是一次性读取的。我们仍然使用它，因为这是一种良好的实践，它允许我们在不担心性能的情况下，灵活地更改函数的精确读取机制。如果你想看到一个
    `BufReader` 确实做了些事情的函数，可以向下看一点，到 `read_file_iterator` [48]。它看起来是逐行读取文件的。当处理大文件时，这将是一个非常低效的操作，这就是为什么
    `BufReader` 实际上是一次性读取大块文件，然后逐行返回该段的原因。结果是优化了文件读取，我们甚至没有注意到或关心后台发生了什么，这非常方便。'
- en: '`File::create()` creates a new file if it doesn''t exist, otherwise it truncates
    the file. In any case, it returns the same kind of `File` handle like `File::open()` did
    before. Another similarity is the `BufWriter` we wrap around it. Just like with
    the `BufReader`, we would be able to access our underlying file without it, but
    use it to optimize future accesses as well.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`File::create()` 如果文件不存在则创建新文件，否则截断文件。在任何情况下，它都返回与 `File::open()` 之前相同的 `File`
    处理符。另一个相似之处在于我们围绕它包装的 `BufWriter`。就像 `BufReader` 一样，即使没有它我们也能访问底层文件，但使用它来优化未来的访问也是有益的。'
- en: There are more options than just opening a file in read-only or truncation mode.
    We can use them by creating our file handle with  `OpenOptions`[69], which use
    the builder pattern we explored in the *Using the builder pattern* section in [Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*. In our
    example, we are interested in the `append` mode, which lets us add content to
    a file instead of overwriting it on every access.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以只读或截断模式打开文件之外，还有更多选项。我们可以通过使用 `OpenOptions` [69] 创建文件句柄来使用它们，这使用了我们在第 1 章
    *学习基础知识* 中探索的 *使用构建器模式* 部分中的构建器模式。在我们的示例中，我们对 `append` 模式感兴趣，它允许我们在每次访问时而不是覆盖它来向文件添加内容。
- en: 'For a full list of all available options, see the OpenOption documentation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用选项的完整列表，请参阅 OpenOption 文档：
- en: '[https://doc.rust-lang.org/std/fs/struct.OpenOptions.html](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.rust-lang.org/std/fs/struct.OpenOptions.html](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html)。'
- en: 'We can read and write on the same file handle. For this, when creating the
    `ReadBuf` and `WriteBuf`, we pass a reference to the file instead of moving it,
    as the buffers would otherwise consume the handle, making sharing impossible:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一个文件处理符上进行读写操作。为此，在创建 `ReadBuf` 和 `WriteBuf` 时，我们传递文件的一个引用而不是移动它，因为否则缓冲区会消耗处理符，使得共享变得不可能：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When doing this, be careful when appending and reading the same handle. The
    internal pointer that stored the current reading position might get shifted when
    appending. If you want to first read, then append, and then continue reading,
    you should save the current position before writing and then restore it afterward.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此操作时，请注意在同一个句柄上进行追加和读取。当追加时，存储当前读取位置的内部指针可能会偏移。如果你想先读取，然后追加，然后继续读取，你应该在写入之前保存当前位置，然后在之后恢复它。
- en: We can access our current position in the file by calling `seek(SeekFrom::Current(0))`[89].
    `seek` moves our pointer by a certain amount of bytes and returns its new position.
    `SeekFrom::Current(0)` means that the distance we want to move is exactly zero
    bytes away from where we are right now. Because of this, as we don't move at all,
    `seek` will return our current position.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`seek(SeekFrom::Current(0))`[89]来访问文件中的当前位置。`seek`通过一定数量的字节移动我们的指针并返回其新位置。`SeekFrom::Current(0)`意味着我们想要移动的距离正好是当前位置的零字节远。由于这个原因，因为我们根本不移动，所以`seek`将返回我们的当前位置。
- en: Then, we append our data using `flush`[92]. We have to call this method, as
    a `BufWriter` would normally wait for the actual writing until it is dropped,
    that is, it is no longer in scope. As we want to read before that happens, we
    use `flush` to force a write.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`flush`[92]来追加我们的数据。我们必须调用这个方法，因为`BufWriter`通常会等待实际写入直到它被丢弃，也就是说，它不再在作用域内。由于我们想在发生之前读取，我们使用`flush`来强制写入。
- en: 'Finally, we get ready to read again by restoring our position from before,
    seeking it again:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过从之前的位置恢复，再次进行定位，准备好再次读取：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I invite you to run the code, look at the results, and then compare them with
    the output after commenting this line out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我邀请您运行代码，查看结果，然后与注释掉此行后的输出进行比较。
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Instead of opening up a new file handle in every function, we could open one
    single handle at the beginning of the program and pass it around to every function
    that needs it. This is a trade-off—we get more performance if we don't repeatedly
    lock and unlock a file. In turn, we disallow other processes to access our file
    while our program is running.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在程序开始时打开一个单独的文件句柄，并将其传递给需要它的每个函数，而不是在每个函数中打开一个新的文件句柄。这是一个权衡——如果我们不反复锁定和解锁文件，我们会获得更好的性能。反过来，我们不允许其他进程在我们程序运行时访问我们的文件。
- en: See also
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using the builder pattern* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning
    the Basics*'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用构建者模式*的配方在[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*'
- en: Handling bytes
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字节
- en: When designing your own protocol or using existing ones, you have to be able
    to comfortably move around and manipulate binary buffers. Luckily, the extended
    standard library ecosystem provides the `byteorder` crate to fulfill all your
    binary needs with various bits and pieces of reading and writing functionality.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设计自己的协议或使用现有的协议时，您必须能够舒适地移动和操作二进制缓冲区。幸运的是，扩展的标准库生态系统提供了`byteorder`包，以满足您所有二进制需求的各种读写功能。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this chapter, we are going to talk about *endianness*. It is a way of describing
    how the values in a buffer are ordered. There are two ways to order them:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论*端序性*。这是描述缓冲区中值排列顺序的一种方式。有两种方式来排列它们：
- en: Put the smallest one first (*Little Endian*)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先放最小的数字（*小端序*）
- en: Put the biggest one first (*Big Endian*)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先放最大的一个（*大端序*）
- en: Let's try an example. Suppose we wanted to save the hexadecimal value `0x90AB12CD`.
    We first have to split it into bits of `0x90`, `0xAB`, `0x12`, and `0xCD`. We
    now can either store them with the biggest value first (Big Endian), `0x90 - 0xAB
    - 0x12 - 0xCD`, or we could write the smallest number first (Little Endian), `0xCD
    - 0x12 - 0xAB - 0x90`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个例子。假设我们想要保存十六进制值`0x90AB12CD`。我们首先必须将其分成`0x90`、`0xAB`、`0x12`和`0xCD`的位。现在我们可以按最大的值首先存储它们（大端序），`0x90
    - 0xAB - 0x12 - 0xCD`，或者我们可以先写最小的数字（小端序），`0xCD - 0x12 - 0xAB - 0x90`。
- en: 'As you can see, it''s the exact same set of values, but flipped. If this short
    explanation left you confused, I advise you to look at this excellent explanation
    by the University of Maryland''s Department of Computer Science: [https://web.archive.org/web/20170808042522/http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html.](https://web.archive.org/web/20170808042522/http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一组完全相同的值，但顺序相反。如果这个简短的说明让您感到困惑，我建议您查看马里兰大学计算机科学系的这篇优秀解释：[https://web.archive.org/web/20170808042522/http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html.](https://web.archive.org/web/20170808042522/http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html)
- en: 'There is no *better* endianness. Both are used in different domains: microprocessors,
    such as Intel, use Little Endian, and internet protocols, such as TCP, IPv4, IPv6,
    and UDP, use Big Endian. This is not a rule but rather a convention maintained
    to be backward compatible. As such, there are exceptions.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更好的字节序。它们在不同的领域中被使用：例如，Intel 这样的微处理器使用 Little Endian，而 TCP、IPv4、IPv6 和 UDP
    这样的互联网协议使用 Big Endian。这不是规则，而是一种为了保持向后兼容而维护的约定。因此，存在例外。
- en: When designing your own protocol, orient yourself on the endianness of similar
    protocols, choose one and simply stick to it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计您自己的协议时，请根据类似协议的字节序来定位，选择一个并简单地坚持使用它。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤：
- en: Open the `Cargo.toml` file that was generated earlier for you.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为您生成的 `Cargo.toml` 文件。
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下，添加以下行：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you want, you can go to `byteorder`'s crates.io page ([https://crates.io/crates/byteorder](https://crates.io/crates/byteorder))
    to check for the newest version and use that one instead.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您愿意，可以访问 `byteorder` 的 crates.io 页面 ([https://crates.io/crates/byteorder](https://crates.io/crates/byteorder))
    检查最新版本，并使用该版本。
- en: In the `bin` folder, create a file called `bytes.rs`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `bytes.rs` 的文件。
- en: 'Add the following code and run it with `cargo run --bin bytes`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin bytes` 运行它：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First things first, we need a binary source. In our example, we simply use a
    vector. Then, we wrap it into a `Cursor`, as it provides us with a `Seek` implementation
    and some methods for our convenience.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个二进制源。在我们的例子中，我们简单地使用一个向量。然后，我们将它包装到一个 `Cursor` 中，因为它为我们提供了一个 `Seek`
    实现和一些方便的方法。
- en: The `Cursor` has an internal position count that keeps track of which byte we
    are accessing at the moment. As expected, it starts at zero. With `read_u8` and
    `read_i8`, we can read the current byte as an unsigned or signed number. This
    will advance the position by one. Both do the same thing, but return a different
    type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cursor` 有一个内部位置计数器，用于跟踪我们此刻正在访问的字节。正如预期的那样，它从零开始。使用 `read_u8` 和 `read_i8`，我们可以将当前字节读取为无符号或带符号的数字。这将使位置前进一个字节。这两个函数做的是同一件事，但返回的类型不同。'
- en: Did you notice that we printed the returned byte by using `{:b}` as the formatting
    parameter [11]?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到我们没有使用 `{:b}` 作为格式化参数 [11] 来打印返回的字节吗？
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By doing so, we tell the underlying `format!` macro to interpret our byte as
    binary, which is why it will print `10` instead of `2`. If you want to, try replacing
    `{}` in our other printing calls with  `{:b}` and compare the results.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们告诉底层的 `format!` 宏将我们的字节解释为二进制，这就是为什么它会打印 `10` 而不是 `2`。如果您愿意，尝试在我们的其他打印调用中将
    `{}` 替换为 `{:b}` 并比较结果。
- en: The current position can be read with `position()` [25] and set with `set_position()`.
    You can also manipulate your position with the more verbose `Seek` API we introduced
    in the last recipe [30]. When using `SeekFrom::End`, keep in mind that this will
    *not* count backward from the end. For example, `SeekFrom::End(1)` will point
    to one byte *after* the end of the buffer and not before. The behavior is defined
    in this way because, maybe somewhat surprisingly, it is legal to seek past a buffer.
    This can be useful when writing, as it will simply pad the space between the end
    of the buffer and the cursor position with zeros.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当前位置可以通过 `position()` [25] 读取，并通过 `set_position()` 设置。您还可以使用我们在上一道菜谱中介绍的更详细的
    `Seek` API 来操作您的位置 [30]。当使用 `SeekFrom::End` 时，请记住这不会从末尾开始倒计数。例如，`SeekFrom::End(1)`
    将指向缓冲区末尾之后的一个字节，而不是之前。这种行为是这样定义的，因为，也许有些令人惊讶，越过缓冲区是合法的。这在写入时可能很有用，因为它将简单地用零填充缓冲区末尾和光标位置之间的空间。
- en: When dealing with more then one byte, you will need to specify the endianness
    of the bytes via type annotation. Reading or writing will then advance the position
    by the number of bytes read or written, which is why, in our example code, we
    need to frequently reset the position with `set_position(0)`. Note that when you
    write past the end, you will always simply extend the buffer [48].
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多个字节时，您需要通过类型注解指定字节序。读取或写入将根据读取或写入的字节数前进位置，这就是为什么在我们的示例代码中，我们需要频繁地使用 `set_position(0)`
    重置位置。请注意，当您写入到末尾时，您总是会简单地扩展缓冲区 [48]。
- en: 'If you know that you want to read a very specific amount of bytes, like when
    parsing a well-defined protocol,  you can do so by providing a fixed-size array
    and filling it by post-fixing your `read` with `_into`, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道您想要读取一个非常特定的字节数，比如在解析一个定义良好的协议时，您可以通过提供一个固定大小的数组并通过在 `read` 后添加 `_into`
    来填充它来实现这一点，如下所示：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When doing so, the read will return an error if the buffer was not filled completely,
    in which case its contents are undefined.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做的时候，如果缓冲区没有完全填满，读取将返回一个错误，在这种情况下，其内容是未定义的。
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are various aliases in the byte order crate to ease your endianness annotation.
    The `BE` alias, for Big Endian, and the `LE` alias, for Little Endian, are useful
    if you don't want to type as much. On the other hand, if you keep forgetting which
    endianness is used where, you can use `NativeEndian`, which sets itself to the
    default endianness of your operating system, and `NetworkEndian`, for Big Endian.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节序crate中有各种别名，可以简化您的字节序注释。`BE`别名，表示大端，和`LE`别名，表示小端，如果您不想输入太多，它们很有用。另一方面，如果您经常忘记在哪里使用哪种字节序，您可以使用`NativeEndian`，它会设置为操作系统的默认字节序，以及`NetworkEndian`，用于大端。
- en: 'To use them, you will have to drag them into scope like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它们，您必须像这样将它们拖入作用域：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Working with binary files
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理二进制文件
- en: We are now going to combine what we learned in the last two chapters in order
    to parse and write binary files. This will prove essential when you plan on implementing
    custom, manual processing of file types such as PDFs, torrents, and ZIPs. It will
    also come in handy when designing custom file types for your own use cases.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将结合在前两章中学到的知识，以便解析和编写二进制文件。当你计划实现自定义、手动处理文件类型，如PDF、种子文件和ZIP文件时，这将变得至关重要。在设计适用于您自己用例的自定义文件类型时，它也会派上用场。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: If you haven't done it already in the last chapter, open the `Cargo.toml` file
    that was generated earlier for you.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在上一个章节中还没有做，请打开之前为您生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`部分下，添加以下行：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you want, you can go to byteorder's crates.io page ([https://crates.io/crates/byteorder](https://crates.io/crates/byteorder))
    to check for the newest version and use that one instead.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以访问byteorder的crates.io页面([https://crates.io/crates/byteorder](https://crates.io/crates/byteorder))，检查最新版本，并使用那个版本。
- en: In the `bin` folder, create a file called `binary_files.rs`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`binary_files.rs`的文件。
- en: 'Add the following code and run it with `cargo run --bin binary_files`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用`cargo run --bin binary_files`运行它：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a binary file:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个二进制文件：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Read and parse the file:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取和解析文件：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To demonstrate how to read and write a binary file, we will create a little
    custom binary protocol. It will start with what is called a *magic number*, that
    is, a certain hardcoded value. Our magic number will be the binary representation
    of the `MyProtocol` string. We can put a `b` before the string to tell Rust that
    we want the text to be represented as a binary slice (`&[u8]`) instead of a string
    slice(`&str`) [26].
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何读取和写入二进制文件，我们将创建一个简单的自定义二进制协议。它将以所谓的*魔数*开始，即某个硬编码的值。我们的魔数将是`MyProtocol`字符串的二进制表示。我们可以在字符串前加上`b`来告诉Rust，我们希望文本以二进制切片(`&[u8]`)的形式表示，而不是字符串切片(`&str`)
    [26]。
- en: Many protocols and files start with magic numbers to indicate what they are.
    For example, the internal headers of `.zip` files start with the magic hex numbers
    `0x50` and `0x4B`. These represent the initials *PH* in ASCII, which is short
    for the name of its creator Phil Katz. Another example would be PDF; it starts
    with `0x25`, `0x50`, `0x44`, and `0x46`, which stands for `PDF%`, followed by
    a version number.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 许多协议和文件以魔数开始，以指示它们是什么。例如，`.zip`文件的内部头以魔数十六进制数`0x50`和`0x4B`开始。这些代表ASCII中的首字母*PH*，是创建者Phil
    Katz名字的缩写。另一个例子是PDF；它以`0x25`、`0x50`、`0x44`和`0x46`开始，代表`PDF%`，后面跟着版本号。
- en: Afterward, we follow it by the binary representation of either `LE` or `BE`
    to tell the reader the endianness of the rest of the data [31]. Finally, we have
    the payload, which is just an arbitrary amount of `u32` numbers, encoded in the
    aforementioned endianness [35 and 36]. By putting `0x` in front of our number,
    we tell Rust to treat it as a hexadecimal number and convert it into decimal for
    us. As such, Rust treats `0xDEAD` as the same value as `57005`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们接着使用`LE`或`BE`的二元表示来告诉读取者其余数据的字节序 [31]。最后，我们有有效载荷，它只是任意数量的`u32`数字，按照上述字节序编码
    [35和36]。通过在我们的数字前加上`0x`，我们告诉Rust将其视为十六进制数，并将其转换为十进制。因此，Rust将`0xDEAD`视为与`57005`相同的值。
- en: Let's put it all together and write a binary file containing `MyProtocolLE5700548879`.
    Other files we could have created in accordance with our protocol would be `MyProtocolBE92341739241842518425`
    or `MyProtocolLE0000`, and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些都放在一起，并写入一个包含`MyProtocolLE5700548879`的二进制文件。根据我们的协议，我们还可以创建其他文件，例如`MyProtocolBE92341739241842518425`或`MyProtocolLE0000`等。
- en: If you read the previous recipes, `write_dummy_protocol` should be easy to understand.
    We use a combination of good old `write_all` from the standard library to write
    our binary texts and `write_u32` from `byteorder` to write the values that require
    an endianness.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了之前的食谱，`write_dummy_protocol`应该很容易理解。我们使用标准库中的古老的好`write_all`来写入我们的二进制文本，以及`byteorder`中的`write_u32`来写入需要端序的值。
- en: The reading of the protocol is split into the  `read_protocol` and `read_protocol_payload` functions.
    The first verifies the validity of the protocol by reading the magic numbers and
    then calls the latter, which reads the remaining numbers as the payload.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的读取被分为`read_protocol`和`read_protocol_payload`函数。第一个通过读取魔数来验证协议的有效性，然后调用后者，后者读取剩余的数字作为有效载荷。
- en: 'We validate the magic numbers as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下验证魔数：
- en: As we know the exact size of the magic numbers used, prepare buffers of those
    exact sizes.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们所知，我们知道了用于魔数的确切大小，因此准备相应大小的缓冲区。
- en: Fill them with just as many bytes.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用同样数量的字节填充它们。
- en: Compare the bytes with the expected magic number.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字节与预期的魔数进行比较。
- en: If they don't match, return an error.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它们不匹配，则返回错误。
- en: After parsing both magic numbers, we can parse the actual *data* contained in
    the payload. Remember, we defined it as an arbitrary amount of `32` bit (`= 4`
    bytes) long, unsigned numbers. To parse them, we are going to repeatedly read
    up to four bytes into a buffer called `raw_payload`. We are then going to examine
    the amount of bytes that were actually read. This number can have three forms
    in our case, as demonstrated nicely by our `match`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 解析完两个魔数后，我们可以解析有效载荷中包含的实际*数据*。记住，我们将其定义为任意数量的`32`位（`= 4`字节）长，无符号数。为了解析它们，我们将反复读取最多四个字节到名为`raw_payload`的缓冲区中。然后我们将检查实际读取的字节数。在我们的情况下，这个数字可以有以下三种形式，正如我们的`match`所优雅地展示的那样。
- en: 'The first value we are interested in is zero, which means that there are no
    more bytes to read, that is, we have reached the end. In this case, we can return
    our payload:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的第一个值是零，这意味着没有更多的字节可以读取，也就是说，我们已经到达了末尾。在这种情况下，我们可以返回我们的有效载荷：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second value is `SIZE_OF_U32`, which we have previously defined as four.
    Receiving this value means that our reader has successfully read four bytes into
    a four-byte-long buffer. This means that we have successfully read a value! Let''s
    parse it into a `u32` and push it into our `payload` vector:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个值是`SIZE_OF_U32`，我们之前将其定义为四。接收到这个值意味着我们的读取器已经成功地将四个字节读入一个四字节长的缓冲区中。这意味着我们已经成功读取了一个值！让我们将其解析为`u32`并将其推送到我们的`payload`向量中：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have to call `as_ref()` on our buffer because a fixed-size array doesn't
    implement `Read`. Since a slice does implement said trait and a reference to an
    array is implicitly convertible into a slice, we work on a reference to `raw_payload`
    instead.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在我们的缓冲区上调用`as_ref()`，因为固定大小的数组没有实现`Read`。由于切片实现了该特性和数组引用隐式可转换为切片，我们工作在`raw_payload`的引用上。
- en: 'The third and last value we can expect is everything other than zero or four.
    In this case, the reader was not able to read four bytes, which means that our
    buffer ended in something other than a `u32` and is malformed. We can react to
    this by returning an error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以预期的第三个和最后一个值是除了零或四之外的所有值。在这种情况下，读取器无法读取四个字节，这意味着我们的缓冲区在`u32`之外结束，并且格式不正确。我们可以通过返回错误来对此做出反应：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's more...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When reading a malformed protocol, we reuse `io::ErrorKind` to show what exactly
    went wrong. In the recipes of [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml),
    *Handling Errors*, you will learn how to provide your own error to better separate
    your areas of failure. If you want, you could read them now and then return here
    to improve our code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取格式不正确的协议时，我们重用`io::ErrorKind`来显示到底出了什么问题。在[第6章](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml)的食谱中，*处理错误*，你将学习如何提供自己的错误以更好地分离你的失败区域。如果你想，你可以现在阅读它们，然后返回这里来改进我们的代码。
- en: 'The errors that need to be pushed into an own variant are:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 需要推送到自己的变体的错误是：
- en: '`InvalidStart`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvalidStart`'
- en: '`InvalidEndianness`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvalidEndianness`'
- en: '`UnexpectedEndOfPayload`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnexpectedEndOfPayload`'
- en: 'Another improvement to the code would be to put all of our strings, namely
    `MyProtocol`, `LE`, and `BE`, into their own constants, as in the following line:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的另一个改进是将我们所有的字符串，即`MyProtocol`、`LE`和`BE`，放入它们自己的常量中，如下行所示：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The provided code in this recipe and some others doesn't use many constants,
    as they proved to be somewhat harder to understand in printed form. In real code
    bases, however, be sure to always put strings that you find yourself copy-pasting
    into own constants!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方和某些其他配方中提供的代码不使用很多常量，因为它们在打印形式中证明是有些难以理解的。然而，在实际代码库中，务必始终将你发现自己复制粘贴的字符串放入自己的常量中！
- en: See also
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Providing user-defined error types* recipes in  [Chapter 6](https://cdp.packtpub.com/rust_standard_library_cookbook/wp-admin/post.php?post=81&action=edit#post_151),
    *Handling Errors*'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](https://cdp.packtpub.com/rust_standard_library_cookbook/wp-admin/post.php?post=81&action=edit#post_151)中提供用户定义的错误类型*配方*，*处理错误*
- en: Compressing and decompressing data
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩和解压缩数据
- en: In today's age of bloated websites and daily new web frameworks, many sites
    feel way more sluggish than they used (and ought) to. One way to mitigate this
    is by compressing your resources before sending them and then decompressing them
    when received. This has become the (often ignored) standard on the web. For this
    purpose, this recipe will teach you how to compress and decompress any kind of
    data with different algorithms.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天这个网站臃肿和每天出现新的Web框架的时代，许多网站感觉比它们实际使用（和应该使用）的要慢得多。减轻这种情况的一种方法是在发送资源之前压缩它们，然后在收到时解压缩。这已经成为（通常被忽视的）网络标准。为此，这个配方将教你如何使用不同的算法压缩和解压缩任何类型的数据。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Open the `Cargo.toml` file that was generated earlier for you.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`下添加以下行：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you want, you can go to `flate2`'s crates.io page ([https://crates.io/crates/flate2](https://crates.io/crates/flate2))
    to check for the newest version and use that one instead.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想，你可以去`flate2`的crates.io页面([https://crates.io/crates/flate2](https://crates.io/crates/flate2))查看最新版本，并使用那个版本。
- en: In the `bin` folder, create a file called `compression.rs`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`compression.rs`的文件。
- en: 'Add the following code and run it with `cargo run --bin compression`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用`cargo run --bin compression`运行它：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These are the functions doing the actual encoding and decoding:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是执行实际编码和解码的函数：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A lot of the `main` function work is just repetition for you from the last few
    chapters. The real deal happens below it. In `encode_bytes`, you can see how to
    use *encoders*. You can write to it as much as you want and call `finish` when
    you're done.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`main`函数的工作只是重复你从上一章学到的内容。真正的操作发生在下面。在`encode_bytes`中，你可以看到如何使用*编码器*。你可以尽可能多地写入它，并在完成后调用`finish`。
- en: '`flate2` gives you several compression options. You can choose your compression
    strength through the passed `Compression` instance:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`flate2`为你提供了几个压缩选项。你可以通过传递的`Compression`实例来选择你的压缩强度：'
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`Default` is a compromise between speed and size. Your other options are `Best`,
    `Fast`, and `None`. Additionally, you can specify the encoding algorithm used.
    `flate2` supports zlib, which we use in this recipe, gzip, and plain deflate.
    If you want to use an algorithm other than zlib, simply replace every mention
    of it with another supported algorithm. For instance, if you wanted to rewrite
    the preceding code to use gzip instead, it would look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Default`是在速度和大小之间的折衷。你的其他选项是`Best`、`Fast`和`None`。此外，你可以指定使用的编码算法。`flate2`支持zlib，我们在本配方中使用，gzip和平滑的deflate。如果你想使用除zlib之外的算法，只需将所有提及它的地方替换为另一个支持的算法。例如，如果你想将前面的代码重写为使用gzip，它看起来会像这样：'
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For a full list of how the specific encoders are called, visit `flate2`'s documentation
    at [https://docs.rs/flate2/.](https://docs.rs/flate2/)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有关特定编码器如何调用的完整列表，请访问`flate2`的文档[https://docs.rs/flate2/](https://docs.rs/flate2/)。
- en: 'Because people would often prefer to compress or decompress whole files instead
    of byte buffers, there are some convenient methods for that. In fact, they are
    implemented on every type that implements `Read`, which means that you can also
    use them on a `BufReader` and many other types. `encode_file` and `decode_file`
    use them with `zlib` in the form of the following lines:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于人们通常会倾向于压缩或解压缩整个文件而不是字节缓冲区，因此有一些方便的方法可以做到这一点。实际上，它们是在实现了`Read`接口的每个类型上实现的，这意味着你也可以在`BufReader`和许多其他类型上使用它们。`encode_file`和`decode_file`使用以下行中的`zlib`：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The same applies to the `gzip` and `deflate` algorithms.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于 `gzip` 和 `deflate` 算法。
- en: 'In our example, we are compressing and decompressing `ferris.png`, which is
    an image of Rust''s mascot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们正在压缩和解压缩 `ferris.png`，这是 Rust 面具的图片：
- en: '![](img/11ce3c14-a708-46ef-b5d4-7250ea181f6b.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11ce3c14-a708-46ef-b5d4-7250ea181f6b.jpg)'
- en: You can find it in the GitHub repository at [https://github.com/SirRade/rust-standard-library-cookbook](https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_three)
    or you can use any other file you want. If you feel like verifying the compression,
    you can take a look at the original, compressed, and decompressed files to check
    how much smaller the compressed one is, and that the original and decompressed
    ones are identical.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库 [https://github.com/SirRade/rust-standard-library-cookbook](https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_three)
    中找到它，或者你可以使用任何你想要的文件。如果你想要验证压缩效果，你可以查看原始文件、压缩文件和解压缩文件，以检查压缩文件有多小，以及原始文件和解压缩文件是否相同。
- en: There's more...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The current `encode_something` and `decode_something` functions are designed
    to be as simple to use as possible. However, they waste some performance by allocating
    `Vec<u8>` even though we could pipe the data directly into a writer. When writing
    a library, it would be nice to give the user both possibilities by adding methods
    in this way:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 `encode_something` 和 `decode_something` 函数被设计得尽可能简单易用。然而，尽管我们可以直接将数据管道输入到写入器中，它们仍然通过分配
    `Vec<u8>` 来浪费一些性能。当编写库时，通过这种方式添加方法，为用户提供两种可能性会很好：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The user could call them like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以像这样调用它们：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Traversing the filesystem
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历文件系统
- en: Up until now, we always provided our code with the static location of a certain
    file. Alas, the real world is seldom so predictable, and some digging is going
    to be necessary when dealing with data scattered throughout different folders.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们总是为我们的代码提供某个文件的静态位置。然而，现实世界很少如此可预测，当处理散布在不同文件夹中的数据时，需要进行一些挖掘。
- en: '`walkdir` helps us with this by abstracting away the intricacies and inconsistencies
    of operating systems'' representation of the filesystem by unifying them under
    one common API, which we are going to learn about in this recipe.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`walkdir` 通过将操作系统的文件系统表示的复杂性和不一致性统一到一个公共 API 下，帮助我们抽象化这些问题，我们将在本配方中学习这个 API。'
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe makes heavy use of iterators to manipulate streams of data. If you
    are not yet familiar with them or need a quick refresher,  you should read the
    *Access collections as Iterators* section in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*, before continuing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方大量使用了迭代器来操作数据流。如果你还不熟悉它们或需要快速复习，你应该在继续之前阅读第 2 章 *使用集合* 中的 *将集合作为迭代器访问* 部分。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the `Cargo.toml` file that was generated earlier for you.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开为你生成的 `Cargo.toml` 文件。
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下，添加以下行：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you want, you can go to `walkdir`'s crates.io page ([https://crates.io/crates/walkdir](https://crates.io/crates/walkdir))
    to check for the newest version and use that one instead.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想，你可以去 `walkdir` 的 crates.io 页面（[https://crates.io/crates/walkdir](https://crates.io/crates/walkdir)）查看最新版本，并使用那个版本。
- en: In the `bin` folder, create a file called `traverse_files.rs`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `traverse_files.rs` 的文件。
- en: 'Add the following code and run it with `cargo run --bin traverse_files`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin traverse_files` 运行它：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, come to the predicates used in this recipe:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看看这个配方中使用的谓词：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`walkdir` consists of three important types:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`walkdir` 由三个重要的类型组成：'
- en: '`WalkDir`: A builder (see the *Using the builder pattern* section in [Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*) for your
    directory walker'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WalkDir`：一个构建器（参见第 1 章 *使用构建器模式* 部分，*学习基础知识*），用于你的目录遍历器'
- en: '`IntoIter`: The iterator created by the builder'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntoIter`：由构建器创建的迭代器'
- en: '`DirEntry`: Represents a single folder or file'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DirEntry`：表示单个文件夹或文件'
- en: 'If you just want to operate on a list of all entries under a root folder, such
    as in the first example in line [6], you can implicitly use `WalkDir` directly
    as an iterator over different instances of `DirEntry`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想操作根文件夹下的所有条目列表，例如在行 [6] 的第一个例子中，你可以隐式地直接将 `WalkDir` 作为 `DirEntry` 不同实例的迭代器使用：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the iterator doesn't directly give you a `DirEntry`, but a `Result`.
    This is because there are some cases where accessing a file or folder might prove
    difficult. For instance, the OS could prohibit you from reading the contents of
    a folder, hiding the files in it. Or a symlink, which you could enable by calling `follow_links(true)`
    on the `WalkDir` instance, could point back to a parent directory, potentially
    resulting in an endless loop.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，迭代器并不直接给你一个 `DirEntry`，而是一个 `Result`。这是因为有些情况下访问文件或文件夹可能会很困难。例如，操作系统可能禁止你读取文件夹的内容，隐藏其中的文件。或者一个符号链接，你可以通过在
    `WalkDir` 实例上调用 `follow_links(true)` 来启用它，它可能指向父目录，这可能导致无限循环。
- en: Our solution strategy for the errors in this recipe is simple—we just ignore
    them and carry on with the rest of the entries that didn't report any issues.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方中的错误，我们的解决方案策略很简单——我们只是忽略它们，并继续处理没有报告任何问题的其他条目。
- en: When you extract the actual entry, it can tell you a lot about itself. One of
    those things is its path. Keep in mind, though, that `.path()` [8] doesn't just
    return the path as a string. Actually, it returns a native Rust `Path` struct
    that could be used for further analysis. You could, for example, read a file path's
    extension by calling `.extension()` on it. Or you could get its parent directory
    by calling `.parent()`. Feel free to explore the possibilities by exploring the `Path` documentation
    at [https://doc.rust-lang.org/std/path/struct.Path.html](https://doc.rust-lang.org/std/path/struct.Path.html).
    In our case, we are only going to display it as a simple string by calling `.display()`
    on it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提取实际的条目时，它可以告诉你很多关于它自己的信息。其中之一就是它的路径。记住，尽管 `.path()` [8] 并不仅仅返回路径作为一个字符串。实际上，它返回一个本地的
    Rust `Path` 结构体，可以用于进一步分析。例如，你可以通过在它上面调用 `.extension()` 来读取文件路径的扩展名。或者你可以通过调用
    `.parent()` 来获取它的父目录。你可以通过探索 [https://doc.rust-lang.org/std/path/struct.Path.html](https://doc.rust-lang.org/std/path/struct.Path.html)
    上的 `Path` 文档来自由探索可能性。在我们的案例中，我们只是通过调用 `.display()` 来将其显示为一个简单的字符串。
- en: When we explicitly convert `WalkDir` into an iterator with `into_iter()`, we
    can access a special method that no other iterator has: `filter_entry`. It is
    an optimization over `filter` in that it gets called during the traversal. When
    its predicate returns `false` on a directory, the walker won't go into the directory
    at all! This way, you can gain a lot of performance when traversing big filesystems.
    In the recipe, we use it while looking for non-hidden files [15]. If you need
    to operate only on files and never on directories, you should use plain old `filter`
    instead.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `into_iter()` 显式地将 `WalkDir` 转换为迭代器时，我们可以访问一个其他迭代器没有的特殊方法：`filter_entry`。它是对
    `filter` 的优化，因为它在遍历期间被调用。当它的谓词对一个目录返回 `false` 时，遍历者根本不会进入该目录！这样，在遍历大型文件系统时，你可以获得很多性能提升。在配方中，我们在寻找非隐藏文件
    [15] 时使用了它。如果你只需要操作文件而永远不操作目录，你应该使用普通的 `filter`。
- en: We define *hidden files*, by Unix convention, as all directories and files that
    start with a dot. For this reason, they are sometimes also called *dotfiles.*
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据 Unix 习惯定义 *隐藏文件* 为所有以点开头的目录和文件。因此，它们有时也被称为 *点文件*。
- en: In both cases, your filtering requires a predicate. They are usually put in
    their own function for simplicity and reusability.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你的过滤都需要一个谓词。它们通常被放在自己的函数中，以保持简单性和可重用性。
- en: Note that `walkdir` doesn't just give us the filename as a normal string. Instead,
    it returns an `OsStr`. This is a special kind of string that Rust uses when talking
    directly to the operating system. The type exists because some operating systems
    allow invalid UTF-8 in their filenames. When looking at such files in Rust, you
    have two choices—let Rust try to convert them into UTF-8 and replace all invalid
    characters with the Unicode Replacement Character (�), or instead handle the error
    yourself. You can go the first route by calling `to_string_lossy` on an `OsStr`
    [20]. The second route is accessible by calling `to_str` and checking the returned
    `Option`, like we did in `has_file_name`, where we simply discard invalid names.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`walkdir` 并不仅仅给我们一个普通的字符串形式的文件名。相反，它返回一个 `OsStr`。这是一种特殊的字符串，当 Rust 直接与操作系统交互时，Rust
    会使用这种字符串。这种类型的存在是因为一些操作系统允许文件名中包含无效的 UTF-8。在 Rust 中查看这类文件时，你有两种选择——让 Rust 尝试将它们转换为
    UTF-8，并用 Unicode 替换字符（�）替换所有无效字符，或者自行处理错误。你可以通过在 `OsStr` 上调用 `to_string_lossy`
    来选择第一种方法 [20]。第二种方法可以通过调用 `to_str` 并检查返回的 `Option` 来访问，就像我们在 `has_file_name` 中做的那样，我们只是简单地丢弃无效的名称。
- en: In this recipe, you can see a splendid example of when to choose a `for_each`
    method call (discussed in the *Access collections as Iterators* section in [Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*, *Working
    with collections*) over a `for` loop—most of our iterator calls are chained together,
    and so a `for_each` call can naturally be chained into the iterator as well.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这道菜谱中，你可以看到一个精彩的例子，说明何时选择`for_each`方法调用（在第1章的*将集合作为迭代器访问*部分讨论过，*学习基础知识*，*处理集合*）而不是`for`循环——我们的大部分迭代器调用都是链在一起的，因此`for_each`调用可以自然地链接到迭代器中。
- en: There's more...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you plan on publishing your application on Unix and Unix only, you can access
    additional permissions on an entry over its `.metadata().unwrap().permissions()`
    call. Namely, you can see the exact `st_mode` bits by calling `.mode()` and change
    them by calling `set_mode()` with a new set of bits.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划仅在Unix上发布你的应用程序，你可以通过`.metadata().unwrap().permissions()`调用在条目上访问额外的权限。具体来说，你可以通过调用`.mode()`来查看确切的`st_mode`位，并通过调用`set_mode()`使用一组新的位来更改它们。
- en: See also
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Using the builder pattern* recipe in [Chapter 1](https://cdp.packtpub.com/rust_standard_library_cookbook/wp-admin/post.php?post=81&action=edit#post_24),
    *Learning the Basics*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](https://cdp.packtpub.com/rust_standard_library_cookbook/wp-admin/post.php?post=81&action=edit#post_24)的*使用构建器模式*菜谱，*学习基础知识*'
- en: '*Access collections as iterators* recipe in [Chapter 2](https://cdp.packtpub.com/rust_standard_library_cookbook/wp-admin/post.php?post=81&action=edit#post_47),
    *Working with Collections*'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](https://cdp.packtpub.com/rust_standard_library_cookbook/wp-admin/post.php?post=81&action=edit#post_47)的*将集合作为迭代器访问*菜谱，*处理集合*'
- en: Finding files with glob patterns
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用glob模式查找文件
- en: As you may have noticed, using `walkdir` to filter files based on their name
    can be a bit clunky at times. Luckily, you can greatly simplify this by using
    the `glob` crate, which brings you its titular patterns, known from Unix, right
    into Rust.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，使用`walkdir`根据文件名过滤文件有时可能有点笨拙。幸运的是，你可以通过使用`glob`crate来大大简化这一点，它将Unix中的标题模式直接带入Rust。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤操作：
- en: Open the `Cargo.toml` file that was generated earlier for you.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`下添加以下行：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you want, you can go to glob's crates.io page ([https://crates.io/crates/glob](https://crates.io/crates/glob))
    to check for the newest version and use that one instead.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以访问glob的crates.io页面([https://crates.io/crates/glob](https://crates.io/crates/glob))，查看最新版本并使用它。
- en: In the `bin` folder, create a file called `glob.rs`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`glob.rs`的文件。
- en: 'Add the following code and run it with `cargo run --bin glob`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin glob`运行它：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This crate is pretty small and simple. With `glob(...)`, you can create an iterator
    over all matching files by specifying a `glob` pattern. If you aren't familiar
    with them but remember the regex recipe from earlier (in the *Querying with regexes*
    section in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning
    the Basics*), think of them as very simplified regexes used primarily for filenames.
    Its syntax is nicely described on Wikipedia: [https://en.wikipedia.org/wiki/Glob_(programming)](https://en.wikipedia.org/wiki/Glob_%28programming%29).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个crate相当小且简单。使用`glob(...)`，你可以通过指定一个`glob`模式来创建一个迭代器，遍历所有匹配的文件。如果你不熟悉它们，但记得之前（在[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)的*使用正则表达式查询*部分中）的regex菜谱（*学习基础知识*），可以将它们视为非常简化的正则表达式，主要用于文件名。其语法在维基百科上有很好的描述：[https://en.wikipedia.org/wiki/Glob_(programming)](https://en.wikipedia.org/wiki/Glob_%28programming%29)。
- en: As with `WalkDir` before, the `glob` iterator returns a `Result` because the
    program might not have the permissions to read a filesystem entry. Inside the
    `Result` sits a `Path`, which we also touched on in the last recipe. If you want
    to read the contents of the file, refer to the first recipe in this chapter, which
    deals with file manipulation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的`WalkDir`一样，`glob`迭代器返回一个`Result`，因为程序可能没有权限读取文件系统条目。在`Result`中包含一个`Path`，我们也在上一道菜谱中提到了它。如果你想读取文件内容，请参考本章的第一道菜谱，它涉及文件操作。
- en: 'With `glob_with`, you can specify a `MatchOptions` instance to change the way
    `glob` searches for files. The most useful options you can toggle are:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glob_with`，你可以指定一个`MatchOptions`实例来更改`glob`搜索文件的方式。你可以切换的最有用的选项是：
- en: '`case_sensitive`: This is enabled per default and controls whether lowercase
    letters (abcd) and uppercase letters (ABCD) should be treated differently or not.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case_sensitive`：默认情况下是启用的，它控制是否应该将小写字母（abcd）和大写字母（ABCD）视为不同或相同。'
- en: '`require_literal_leading_dot`: This is disabled per default and, when set,
    prohibits wildcards from matching a leading dot in a filename. This is used when
    you want to ignore a user''s hidden files.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require_literal_leading_dot`：默认情况下是禁用的，当设置时，禁止通配符匹配文件名中的前导点。这用于您想忽略用户的隐藏文件时。'
- en: You can view the rest of the options in the documentation of `MatchOption`: [https://doc.rust-lang.org/glob/glob/struct.MatchOptions.html](https://doc.rust-lang.org/glob/glob/struct.MatchOptions.html).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`MatchOption`的文档中查看其余选项：[https://doc.rust-lang.org/glob/glob/struct.MatchOptions.html](https://doc.rust-lang.org/glob/glob/struct.MatchOptions.html).
- en: If you have set the options you care about, you can leave the rest at their
    default by using the `..Default::default()` *update syntax* discussed in the *Providing
    a default implementation* section in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)*,
    Learning the Basics*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经设置了您关心的选项，您可以通过使用在[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)*学习基础知识*中*提供默认实现*部分讨论的`..Default::default()`更新语法，将剩余的选项保留为默认值。
- en: See also
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Querying with Regexes* and *Providing a default implementation* recipes in [Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)*学习基础知识*中的*使用正则表达式查询*和*提供默认实现*食谱
