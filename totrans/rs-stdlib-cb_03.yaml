- en: Handling Files and the Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with binary files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing and decompressing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversing the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files with glob patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In these times of big data, machine learning, and cloud services, you cannot
    rely on having all of your data always in memory. Rather, you need to be able
    to effectively inspect and traverse the filesystem and manipulate its content
    at your leisure.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of things you will be able to do after reading this chapter include
    configuring files in subdirectories with different naming variations, saving your
    data in efficient binary formats, reading protocols generated by other programs,
    and compressing your data in order to send it over the internet at fast speeds.
  prefs: []
  type: TYPE_NORMAL
- en: Working with text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to read, write, create, truncate, and append
    text files. Armed with this knowledge, you will be able to apply all other recipes
    to files instead of in-memory strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Rust project to work on during this chapter with `cargo new chapter-three`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate into the newly created `chapter-three` folder. For the rest of this
    chapter, we will assume that your command line is currently in this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `src` folder, create a new folder called `bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `text_files.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin text_files`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the functions called by the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading and writing on the same handle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `main` function is split into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwriting a file, which in this context is called *truncating.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Appending to a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first two parts, we load the entire content of the file into a single
    `String` and display it [11 and 18]. In the last one, we iterate over the individual
    lines in the file and print them [28].
  prefs: []
  type: TYPE_NORMAL
- en: '`File::open()` opens a file in read-only mode and returns you a handle to it
    [39]. Because this handle implements the `Read` trait, we could now just directly
    read it into a string with `read_to_string`. However, in our examples, we wrap
    it first in a `BufReader`[42]. This is because a dedicated reader can greatly
    improve the performance of their resource access by collecting read instructions,
    which is called *buffering*, and executing them in big batches. For the first
    reading example, `read_file`[37], this doesn''t make any difference whatsoever,
    as we read it all in one go anyway. We still use it because it is a good practice,
    as it allows us to flexibly change the exact reading mechanisms of our function
    later on without worrying about performance. If you want to see a function where
    a `BufReader` actually does something, look a little further down, to `read_file_iterator`[48].
    It appears to read the file line by line. This would be a very inefficient operation
    when dealing with a large file, which is why a `BufReader` actually reads a large
    chunk of the file in one go and then returns that segment line by line. The result
    is optimized file reading without us even noticing or caring what is going on
    in the background, which is pretty convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: '`File::create()` creates a new file if it doesn''t exist, otherwise it truncates
    the file. In any case, it returns the same kind of `File` handle like `File::open()` did
    before. Another similarity is the `BufWriter` we wrap around it. Just like with
    the `BufReader`, we would be able to access our underlying file without it, but
    use it to optimize future accesses as well.'
  prefs: []
  type: TYPE_NORMAL
- en: There are more options than just opening a file in read-only or truncation mode.
    We can use them by creating our file handle with  `OpenOptions`[69], which use
    the builder pattern we explored in the *Using the builder pattern* section in [Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*. In our
    example, we are interested in the `append` mode, which lets us add content to
    a file instead of overwriting it on every access.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a full list of all available options, see the OpenOption documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.rust-lang.org/std/fs/struct.OpenOptions.html](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read and write on the same file handle. For this, when creating the
    `ReadBuf` and `WriteBuf`, we pass a reference to the file instead of moving it,
    as the buffers would otherwise consume the handle, making sharing impossible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When doing this, be careful when appending and reading the same handle. The
    internal pointer that stored the current reading position might get shifted when
    appending. If you want to first read, then append, and then continue reading,
    you should save the current position before writing and then restore it afterward.
  prefs: []
  type: TYPE_NORMAL
- en: We can access our current position in the file by calling `seek(SeekFrom::Current(0))`[89].
    `seek` moves our pointer by a certain amount of bytes and returns its new position.
    `SeekFrom::Current(0)` means that the distance we want to move is exactly zero
    bytes away from where we are right now. Because of this, as we don't move at all,
    `seek` will return our current position.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we append our data using `flush`[92]. We have to call this method, as
    a `BufWriter` would normally wait for the actual writing until it is dropped,
    that is, it is no longer in scope. As we want to read before that happens, we
    use `flush` to force a write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we get ready to read again by restoring our position from before,
    seeking it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I invite you to run the code, look at the results, and then compare them with
    the output after commenting this line out.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of opening up a new file handle in every function, we could open one
    single handle at the beginning of the program and pass it around to every function
    that needs it. This is a trade-off—we get more performance if we don't repeatedly
    lock and unlock a file. In turn, we disallow other processes to access our file
    while our program is running.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using the builder pattern* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning
    the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing your own protocol or using existing ones, you have to be able
    to comfortably move around and manipulate binary buffers. Luckily, the extended
    standard library ecosystem provides the `byteorder` crate to fulfill all your
    binary needs with various bits and pieces of reading and writing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to talk about *endianness*. It is a way of describing
    how the values in a buffer are ordered. There are two ways to order them:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the smallest one first (*Little Endian*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put the biggest one first (*Big Endian*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's try an example. Suppose we wanted to save the hexadecimal value `0x90AB12CD`.
    We first have to split it into bits of `0x90`, `0xAB`, `0x12`, and `0xCD`. We
    now can either store them with the biggest value first (Big Endian), `0x90 - 0xAB
    - 0x12 - 0xCD`, or we could write the smallest number first (Little Endian), `0xCD
    - 0x12 - 0xAB - 0x90`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it''s the exact same set of values, but flipped. If this short
    explanation left you confused, I advise you to look at this excellent explanation
    by the University of Maryland''s Department of Computer Science: [https://web.archive.org/web/20170808042522/http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html.](https://web.archive.org/web/20170808042522/http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no *better* endianness. Both are used in different domains: microprocessors,
    such as Intel, use Little Endian, and internet protocols, such as TCP, IPv4, IPv6,
    and UDP, use Big Endian. This is not a rule but rather a convention maintained
    to be backward compatible. As such, there are exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: When designing your own protocol, orient yourself on the endianness of similar
    protocols, choose one and simply stick to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to `byteorder`'s crates.io page ([https://crates.io/crates/byteorder](https://crates.io/crates/byteorder))
    to check for the newest version and use that one instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `bytes.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin bytes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First things first, we need a binary source. In our example, we simply use a
    vector. Then, we wrap it into a `Cursor`, as it provides us with a `Seek` implementation
    and some methods for our convenience.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cursor` has an internal position count that keeps track of which byte we
    are accessing at the moment. As expected, it starts at zero. With `read_u8` and
    `read_i8`, we can read the current byte as an unsigned or signed number. This
    will advance the position by one. Both do the same thing, but return a different
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice that we printed the returned byte by using `{:b}` as the formatting
    parameter [11]?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By doing so, we tell the underlying `format!` macro to interpret our byte as
    binary, which is why it will print `10` instead of `2`. If you want to, try replacing
    `{}` in our other printing calls with  `{:b}` and compare the results.
  prefs: []
  type: TYPE_NORMAL
- en: The current position can be read with `position()` [25] and set with `set_position()`.
    You can also manipulate your position with the more verbose `Seek` API we introduced
    in the last recipe [30]. When using `SeekFrom::End`, keep in mind that this will
    *not* count backward from the end. For example, `SeekFrom::End(1)` will point
    to one byte *after* the end of the buffer and not before. The behavior is defined
    in this way because, maybe somewhat surprisingly, it is legal to seek past a buffer.
    This can be useful when writing, as it will simply pad the space between the end
    of the buffer and the cursor position with zeros.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with more then one byte, you will need to specify the endianness
    of the bytes via type annotation. Reading or writing will then advance the position
    by the number of bytes read or written, which is why, in our example code, we
    need to frequently reset the position with `set_position(0)`. Note that when you
    write past the end, you will always simply extend the buffer [48].
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know that you want to read a very specific amount of bytes, like when
    parsing a well-defined protocol,  you can do so by providing a fixed-size array
    and filling it by post-fixing your `read` with `_into`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When doing so, the read will return an error if the buffer was not filled completely,
    in which case its contents are undefined.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various aliases in the byte order crate to ease your endianness annotation.
    The `BE` alias, for Big Endian, and the `LE` alias, for Little Endian, are useful
    if you don't want to type as much. On the other hand, if you keep forgetting which
    endianness is used where, you can use `NativeEndian`, which sets itself to the
    default endianness of your operating system, and `NetworkEndian`, for Big Endian.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use them, you will have to drag them into scope like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Working with binary files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to combine what we learned in the last two chapters in order
    to parse and write binary files. This will prove essential when you plan on implementing
    custom, manual processing of file types such as PDFs, torrents, and ZIPs. It will
    also come in handy when designing custom file types for your own use cases.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't done it already in the last chapter, open the `Cargo.toml` file
    that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to byteorder's crates.io page ([https://crates.io/crates/byteorder](https://crates.io/crates/byteorder))
    to check for the newest version and use that one instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `binary_files.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin binary_files`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a binary file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Read and parse the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate how to read and write a binary file, we will create a little
    custom binary protocol. It will start with what is called a *magic number*, that
    is, a certain hardcoded value. Our magic number will be the binary representation
    of the `MyProtocol` string. We can put a `b` before the string to tell Rust that
    we want the text to be represented as a binary slice (`&[u8]`) instead of a string
    slice(`&str`) [26].
  prefs: []
  type: TYPE_NORMAL
- en: Many protocols and files start with magic numbers to indicate what they are.
    For example, the internal headers of `.zip` files start with the magic hex numbers
    `0x50` and `0x4B`. These represent the initials *PH* in ASCII, which is short
    for the name of its creator Phil Katz. Another example would be PDF; it starts
    with `0x25`, `0x50`, `0x44`, and `0x46`, which stands for `PDF%`, followed by
    a version number.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, we follow it by the binary representation of either `LE` or `BE`
    to tell the reader the endianness of the rest of the data [31]. Finally, we have
    the payload, which is just an arbitrary amount of `u32` numbers, encoded in the
    aforementioned endianness [35 and 36]. By putting `0x` in front of our number,
    we tell Rust to treat it as a hexadecimal number and convert it into decimal for
    us. As such, Rust treats `0xDEAD` as the same value as `57005`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put it all together and write a binary file containing `MyProtocolLE5700548879`.
    Other files we could have created in accordance with our protocol would be `MyProtocolBE92341739241842518425`
    or `MyProtocolLE0000`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you read the previous recipes, `write_dummy_protocol` should be easy to understand.
    We use a combination of good old `write_all` from the standard library to write
    our binary texts and `write_u32` from `byteorder` to write the values that require
    an endianness.
  prefs: []
  type: TYPE_NORMAL
- en: The reading of the protocol is split into the  `read_protocol` and `read_protocol_payload` functions.
    The first verifies the validity of the protocol by reading the magic numbers and
    then calls the latter, which reads the remaining numbers as the payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'We validate the magic numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As we know the exact size of the magic numbers used, prepare buffers of those
    exact sizes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill them with just as many bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the bytes with the expected magic number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If they don't match, return an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After parsing both magic numbers, we can parse the actual *data* contained in
    the payload. Remember, we defined it as an arbitrary amount of `32` bit (`= 4`
    bytes) long, unsigned numbers. To parse them, we are going to repeatedly read
    up to four bytes into a buffer called `raw_payload`. We are then going to examine
    the amount of bytes that were actually read. This number can have three forms
    in our case, as demonstrated nicely by our `match`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first value we are interested in is zero, which means that there are no
    more bytes to read, that is, we have reached the end. In this case, we can return
    our payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The second value is `SIZE_OF_U32`, which we have previously defined as four.
    Receiving this value means that our reader has successfully read four bytes into
    a four-byte-long buffer. This means that we have successfully read a value! Let''s
    parse it into a `u32` and push it into our `payload` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have to call `as_ref()` on our buffer because a fixed-size array doesn't
    implement `Read`. Since a slice does implement said trait and a reference to an
    array is implicitly convertible into a slice, we work on a reference to `raw_payload`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third and last value we can expect is everything other than zero or four.
    In this case, the reader was not able to read four bytes, which means that our
    buffer ended in something other than a `u32` and is malformed. We can react to
    this by returning an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When reading a malformed protocol, we reuse `io::ErrorKind` to show what exactly
    went wrong. In the recipes of [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml),
    *Handling Errors*, you will learn how to provide your own error to better separate
    your areas of failure. If you want, you could read them now and then return here
    to improve our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The errors that need to be pushed into an own variant are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InvalidStart`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvalidEndianness`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnexpectedEndOfPayload`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another improvement to the code would be to put all of our strings, namely
    `MyProtocol`, `LE`, and `BE`, into their own constants, as in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The provided code in this recipe and some others doesn't use many constants,
    as they proved to be somewhat harder to understand in printed form. In real code
    bases, however, be sure to always put strings that you find yourself copy-pasting
    into own constants!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Providing user-defined error types* recipes in  [Chapter 6](https://cdp.packtpub.com/rust_standard_library_cookbook/wp-admin/post.php?post=81&action=edit#post_151),
    *Handling Errors*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing and decompressing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's age of bloated websites and daily new web frameworks, many sites
    feel way more sluggish than they used (and ought) to. One way to mitigate this
    is by compressing your resources before sending them and then decompressing them
    when received. This has become the (often ignored) standard on the web. For this
    purpose, this recipe will teach you how to compress and decompress any kind of
    data with different algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want, you can go to `flate2`'s crates.io page ([https://crates.io/crates/flate2](https://crates.io/crates/flate2))
    to check for the newest version and use that one instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `compression.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin compression`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the functions doing the actual encoding and decoding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of the `main` function work is just repetition for you from the last few
    chapters. The real deal happens below it. In `encode_bytes`, you can see how to
    use *encoders*. You can write to it as much as you want and call `finish` when
    you're done.
  prefs: []
  type: TYPE_NORMAL
- en: '`flate2` gives you several compression options. You can choose your compression
    strength through the passed `Compression` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`Default` is a compromise between speed and size. Your other options are `Best`,
    `Fast`, and `None`. Additionally, you can specify the encoding algorithm used.
    `flate2` supports zlib, which we use in this recipe, gzip, and plain deflate.
    If you want to use an algorithm other than zlib, simply replace every mention
    of it with another supported algorithm. For instance, if you wanted to rewrite
    the preceding code to use gzip instead, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For a full list of how the specific encoders are called, visit `flate2`'s documentation
    at [https://docs.rs/flate2/.](https://docs.rs/flate2/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Because people would often prefer to compress or decompress whole files instead
    of byte buffers, there are some convenient methods for that. In fact, they are
    implemented on every type that implements `Read`, which means that you can also
    use them on a `BufReader` and many other types. `encode_file` and `decode_file`
    use them with `zlib` in the form of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The same applies to the `gzip` and `deflate` algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we are compressing and decompressing `ferris.png`, which is
    an image of Rust''s mascot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11ce3c14-a708-46ef-b5d4-7250ea181f6b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can find it in the GitHub repository at [https://github.com/SirRade/rust-standard-library-cookbook](https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_three)
    or you can use any other file you want. If you feel like verifying the compression,
    you can take a look at the original, compressed, and decompressed files to check
    how much smaller the compressed one is, and that the original and decompressed
    ones are identical.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current `encode_something` and `decode_something` functions are designed
    to be as simple to use as possible. However, they waste some performance by allocating
    `Vec<u8>` even though we could pipe the data directly into a writer. When writing
    a library, it would be nice to give the user both possibilities by adding methods
    in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The user could call them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Traversing the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we always provided our code with the static location of a certain
    file. Alas, the real world is seldom so predictable, and some digging is going
    to be necessary when dealing with data scattered throughout different folders.
  prefs: []
  type: TYPE_NORMAL
- en: '`walkdir` helps us with this by abstracting away the intricacies and inconsistencies
    of operating systems'' representation of the filesystem by unifying them under
    one common API, which we are going to learn about in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe makes heavy use of iterators to manipulate streams of data. If you
    are not yet familiar with them or need a quick refresher,  you should read the
    *Access collections as Iterators* section in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*, before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to `walkdir`'s crates.io page ([https://crates.io/crates/walkdir](https://crates.io/crates/walkdir))
    to check for the newest version and use that one instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `traverse_files.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin traverse_files`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, come to the predicates used in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`walkdir` consists of three important types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WalkDir`: A builder (see the *Using the builder pattern* section in [Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*) for your
    directory walker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntoIter`: The iterator created by the builder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DirEntry`: Represents a single folder or file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you just want to operate on a list of all entries under a root folder, such
    as in the first example in line [6], you can implicitly use `WalkDir` directly
    as an iterator over different instances of `DirEntry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the iterator doesn't directly give you a `DirEntry`, but a `Result`.
    This is because there are some cases where accessing a file or folder might prove
    difficult. For instance, the OS could prohibit you from reading the contents of
    a folder, hiding the files in it. Or a symlink, which you could enable by calling `follow_links(true)`
    on the `WalkDir` instance, could point back to a parent directory, potentially
    resulting in an endless loop.
  prefs: []
  type: TYPE_NORMAL
- en: Our solution strategy for the errors in this recipe is simple—we just ignore
    them and carry on with the rest of the entries that didn't report any issues.
  prefs: []
  type: TYPE_NORMAL
- en: When you extract the actual entry, it can tell you a lot about itself. One of
    those things is its path. Keep in mind, though, that `.path()` [8] doesn't just
    return the path as a string. Actually, it returns a native Rust `Path` struct
    that could be used for further analysis. You could, for example, read a file path's
    extension by calling `.extension()` on it. Or you could get its parent directory
    by calling `.parent()`. Feel free to explore the possibilities by exploring the `Path` documentation
    at [https://doc.rust-lang.org/std/path/struct.Path.html](https://doc.rust-lang.org/std/path/struct.Path.html).
    In our case, we are only going to display it as a simple string by calling `.display()`
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: When we explicitly convert `WalkDir` into an iterator with `into_iter()`, we
    can access a special method that no other iterator has: `filter_entry`. It is
    an optimization over `filter` in that it gets called during the traversal. When
    its predicate returns `false` on a directory, the walker won't go into the directory
    at all! This way, you can gain a lot of performance when traversing big filesystems.
    In the recipe, we use it while looking for non-hidden files [15]. If you need
    to operate only on files and never on directories, you should use plain old `filter`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: We define *hidden files*, by Unix convention, as all directories and files that
    start with a dot. For this reason, they are sometimes also called *dotfiles.*
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, your filtering requires a predicate. They are usually put in
    their own function for simplicity and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `walkdir` doesn't just give us the filename as a normal string. Instead,
    it returns an `OsStr`. This is a special kind of string that Rust uses when talking
    directly to the operating system. The type exists because some operating systems
    allow invalid UTF-8 in their filenames. When looking at such files in Rust, you
    have two choices—let Rust try to convert them into UTF-8 and replace all invalid
    characters with the Unicode Replacement Character (�), or instead handle the error
    yourself. You can go the first route by calling `to_string_lossy` on an `OsStr`
    [20]. The second route is accessible by calling `to_str` and checking the returned
    `Option`, like we did in `has_file_name`, where we simply discard invalid names.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you can see a splendid example of when to choose a `for_each`
    method call (discussed in the *Access collections as Iterators* section in [Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*, *Working
    with collections*) over a `for` loop—most of our iterator calls are chained together,
    and so a `for_each` call can naturally be chained into the iterator as well.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you plan on publishing your application on Unix and Unix only, you can access
    additional permissions on an entry over its `.metadata().unwrap().permissions()`
    call. Namely, you can see the exact `st_mode` bits by calling `.mode()` and change
    them by calling `set_mode()` with a new set of bits.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using the builder pattern* recipe in [Chapter 1](https://cdp.packtpub.com/rust_standard_library_cookbook/wp-admin/post.php?post=81&action=edit#post_24),
    *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Access collections as iterators* recipe in [Chapter 2](https://cdp.packtpub.com/rust_standard_library_cookbook/wp-admin/post.php?post=81&action=edit#post_47),
    *Working with Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files with glob patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have noticed, using `walkdir` to filter files based on their name
    can be a bit clunky at times. Luckily, you can greatly simplify this by using
    the `glob` crate, which brings you its titular patterns, known from Unix, right
    into Rust.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to glob's crates.io page ([https://crates.io/crates/glob](https://crates.io/crates/glob))
    to check for the newest version and use that one instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `glob.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin glob`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This crate is pretty small and simple. With `glob(...)`, you can create an iterator
    over all matching files by specifying a `glob` pattern. If you aren't familiar
    with them but remember the regex recipe from earlier (in the *Querying with regexes*
    section in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning
    the Basics*), think of them as very simplified regexes used primarily for filenames.
    Its syntax is nicely described on Wikipedia: [https://en.wikipedia.org/wiki/Glob_(programming)](https://en.wikipedia.org/wiki/Glob_%28programming%29).
  prefs: []
  type: TYPE_NORMAL
- en: As with `WalkDir` before, the `glob` iterator returns a `Result` because the
    program might not have the permissions to read a filesystem entry. Inside the
    `Result` sits a `Path`, which we also touched on in the last recipe. If you want
    to read the contents of the file, refer to the first recipe in this chapter, which
    deals with file manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `glob_with`, you can specify a `MatchOptions` instance to change the way
    `glob` searches for files. The most useful options you can toggle are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`case_sensitive`: This is enabled per default and controls whether lowercase
    letters (abcd) and uppercase letters (ABCD) should be treated differently or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require_literal_leading_dot`: This is disabled per default and, when set,
    prohibits wildcards from matching a leading dot in a filename. This is used when
    you want to ignore a user''s hidden files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can view the rest of the options in the documentation of `MatchOption`: [https://doc.rust-lang.org/glob/glob/struct.MatchOptions.html](https://doc.rust-lang.org/glob/glob/struct.MatchOptions.html).
  prefs: []
  type: TYPE_NORMAL
- en: If you have set the options you care about, you can leave the rest at their
    default by using the `..Default::default()` *update syntax* discussed in the *Providing
    a default implementation* section in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)*,
    Learning the Basics*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Querying with Regexes* and *Providing a default implementation* recipes in [Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
