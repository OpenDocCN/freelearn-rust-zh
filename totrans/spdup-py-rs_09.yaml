- en: '*Chapter 9*: Structuring a Python Flask App for Rust'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we managed to solve a real-world problem with Rust.
    However, we also learned an important lesson, that is, the good implementation
    of code, such as adding vectors or merging dataframes, along with third-party
    modules, such as `NumPy`, can outperform badly implemented self-coded Rust solutions.
    However, we know that comparing implementation to implementation, Rust is a lot
    faster than Python. We already understand how to fuse Rust with a standard Python
    script. However, Python is used for more than just running scripts. A popular
    use for Python is in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build a Flask web application with NGINX, a database,
    and a message bus implemented by the `Celery` package. This message bus will allow
    our application to process heavy tasks in the background while we return a web
    HTTP request. The web application and message bus will be wrapped in Docker containers
    and deployed to `docker-compose`. However, nothing is preventing us from deploying
    the application onto a cloud platform if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic Flask application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a database access layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a message bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will enable us to build a foundation for deployable Python web
    applications that have a range of features and services. This foundation allows
    us to discover how to fuse Rust with Python web applications that are wrapped
    in Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code and data for this chapter can be found at [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_nine](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_nine).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we will be using `docker-compose` on top of Docker to orchestrate
    our Docker containers. This can be installed by following the instructions at
    [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be building a Docker-contained Flask application, which
    is available via the GitHub repository at [https://github.com/maxwellflitton/fib-flask](https://github.com/maxwellflitton/fib-flask).
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic Flask application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin adding any additional features such as a database to an application,
    we have to ensure that that we can get a basic Flask application up and running
    with everything that we need. This application will take in a number and return
    a Fibonacci number. Additionally, we will need to make sure that this application
    can run in its own Docker container if we were to deploy it. By the end of this
    section, our application should have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that the application is housed in the `src` directory. When
    running our application, we must ensure that the `PYTHONPATH` path is set to `src`.
    The code required for our deployment exists in the `deployment` directory. To
    build an application so that it can run in Docker, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build an entry point for our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a Fibonacci number calculation module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a Docker image for our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build our NGINX service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have completed all of these steps, we will have a basic Flask application
    that can be run on a server. Now, let's explore each of these steps in detail
    in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Building an entry point for our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can build our entry point, we need to install the Flask module using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, we have all we need to create a basic Flask application
    by defining the entry point in the `src/app.py` file using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, observe that we can define a basic route with the decorator. We can run
    our application by running the `src/app.py` script; this will run our server locally,
    enabling us to access all of the routes that we have defined. Passing the `http://127.0.0.1:5002`
    URL into our browser will give us the following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The main view of our local Flask server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.01_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – The main view of our local Flask server
  prefs: []
  type: TYPE_NORMAL
- en: Now that our basic server is running, we can move on to build a Fibonacci number
    calculator module.
  prefs: []
  type: TYPE_NORMAL
- en: Building our Fibonacci number calculator module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, our application is simple. As a result, we can define our
    module''s functionality within one file in one class. We define it within the
    `src/fib_calcs/fib_calculation.py` file using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, notice that our class merely takes in an input number and automatically
    populates the `self.fib_number` attribute with the calculated Fibonacci number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once that is done, we can define a view that accepts an integer through the
    URL, passes it to our `FibCalculation` class, and returns the calculated Fibonacci
    number as a string to the user in our `src/app.py` file using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rerunning our server and passing the `http://127.0.0.1:5002/calculate/10` URL
    into our browser will give us the following view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Calculating the view of our local Flask server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.02_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Calculating the view of our local Flask server
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our application performs its intended purpose: it calculates a Fibonacci
    number based on the input. There is more to views with Flask; however, this book
    is not a web development textbook. If you want to learn how to build more comprehensive
    API endpoints, we advise that you look into the Flask API and `Marshmallow` packages.
    References to both are available in the *Further reading* section. Now, we need
    to make our application deployable so that we can use it in a range of settings
    for our next step.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image for our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our application to be usable, we must build a Docker image of our application
    that accepts requests. Then, we must protect it with another container call that
    acts as an ingress. NGINX performs load balancing, caching, streaming, and the
    redirecting of traffic. Our application will be run using the Gunicorn package,
    which, essentially, runs multiple workers of our application at the same time.
    For each request, NGINX asks which Gunicorn worker the request should go to and
    redirects it, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The flow of requests for our application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.03_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – The flow of requests for our application
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve the layout defined in the preceding diagram by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we build a Docker image, we must make sure the requirements for our
    application are handled. Therefore, we must install Gunicorn using `pip` with
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must make sure that we are in the `src` directory because we are going to
    dump all of our application dependencies into a file called `requirements.txt`
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This gives us a text file with a list of all the dependencies that our application
    needs in order to run. Right now, all we need is Flask and Gunicorn.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this, we can start coding our Docker file so that we can build application
    images of our application. First, in our `src/Dockerfile` file, we should define
    the operating system that is required with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that our image is running a stripped-down version of Linux with Python
    installed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have the correct operating system, we should define our app''s
    directory and copy all of our application files into the image using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that all of our application files are in the image, we install system updates
    and then install the `python-dev` package. This is so that we can include extensions
    with the code given here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will enable us to compile our Rust code in our application and use database
    binaries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our system has now been set up, so we can move on to install our requirements
    using the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Everything is in place to define our system. Nothing is stopping us from running
    our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To do this, we expose the port and run our application using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that when we create a container from the image, we run `CMD` with the parameters
    defined in the list. We state that we have four workers with the `-w 4` parameter.
    Then, we define the URL and port that we are listening to. Our final parameter
    is `app:app`. This states that our application is housed in the `app.py` file,
    and our application in that file is the `Flask` object under the variable name
    of `app`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now build our application image using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then inspect our images using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command gives us an image that has been created in the following
    form:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is important. We will need to reference our image later when we are running
    our application with NGINX, which we will define next.
  prefs: []
  type: TYPE_NORMAL
- en: Building our NGINX service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to Docker and NGINX, we are lucky in that we do not have to build
    a Dockerfile that defines our NGINX image. NGINX has released an official image
    that we can download and use for free. However, we do have to alter its configuration.
    NGINX is fairly important; this is because it gives us the ability to control
    how incoming requests are processed. We can redirect the requests to different
    services depending on parts of the URL. Additionally, we can control the size
    of the data, the duration of the connection, and configure HTTPS traffic. NGINX
    can also act as a load balancer. In this example, we are going to configure NGINX
    in the simplest format to get it running. However, it must be noted that NGINX
    is a vast topic in itself; a reference to a useful NGINX book is provided in the
    *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build our NGINX service and connect it to our Flask application by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will configure our NGINX container with what we code in the `deployment/nginx/nginx.conf`
    file. In this file, we declare our worker processes and error log, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have defined `worker_processes` as `auto`. This is where we automatically
    detect the number of CPU cores available, setting the number of processes to the
    number of CPU cores.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we have to define the maximum number of connections that a worker can
    entertain at a time using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It must be noted that the number that is chosen here is the default number for
    NGINX.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All that is now left for us to do is to define our HTTP listener. This can
    be achieved with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, observe that we listen to port `80`, which is the standard outside listening
    port. Then, we state that if there is any pattern to our URL, we pass it to our
    `flask_app` container at port `5002`. We can stack multiple locations in the `http`
    section if we wish. For instance, if we have another app, we can route the request
    to the other application if the URL tail starts with `/another_app/` using the
    following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our configuration file for our NGINX is complete. Again, there are many more
    configuration parameters; we are just running the bare minimum. More resources
    on these parameters are signposted in the *Further reading* section. Considering
    that our NGINX configuration file is complete, for the next step, we have to run
    it alongside our Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting and running our Nginx service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run our application and NGINX together, we will be using `docker-compose`.
    This allows us to define multiple Docker containers at the same time that can
    talk to each other. Nothing is stopping us from running `docker-compose` on a
    server to achieve a basic setup. However, more advanced systems such as Kubernetes
    can help with the orchestration of Docker containers across multiple servers if
    needed. In addition to this, different cloud platforms offer out-of-the-box load
    balancers. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `deployment/docker-compose.yml` file, we state what version of `docker-compose`
    we are using with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that this has been implemented, we can define our services along with our
    first service, which is our Flask application. This is defined with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we reference the image that we built with the latest
    release. For instance, if we changed the image and rebuilt it, then our `docker-compose`
    setup would use this. We also give it a container name, so we know the container
    status when checking the running containers. Additionally, we state that we accept
    traffic through port `5002`, and we route it to our container's port `5002`. Because
    we have chosen this path, we also expose port `5002`. If we run our `docker-compose`
    setup now, we could access our application with the `http://localhost:5002` URL.
    However, if this was running on a server and port `5002` was not accessible to
    outside traffic, then we would not be able to access it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Considering this, we can define our NGINX in our `deployment/docker-compose.yml`
    file using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you can see that we rely on the third-party NGINX image and that we route
    the outside port of `80` to port `80`. Also, we link to our Flask application,
    and we depend on it, meaning that `docker-compose` will ensure that our Flask
    application is up and running before we run our NGINX service. In the `volumes`
    section, we replace the standard configuration file with the configuration file
    that we defined in the previous step. As a result, our NGINX service will run
    the configuration that we defined. It must be noted that this configuration switch
    will happen every time we run `docker-compose`. This means that if we change our
    configuration file and then run `docker-compose` again, we will see the changes.
    So, we have done everything to get our application up and running. Now we can
    test it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Testing our application is as easy as running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 9.4 – Interacting with our fully containerized Flask application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.04_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Interacting with our fully containerized Flask application
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a fully containerized application that runs. This is at a ready
    state, so in the next chapter, we can test to see whether our Rust integration
    with our application will actually work in a real-life scenario. Now that we have
    gotten our application running, we can move on to build our data access layer.
    This will allow us to store and get data from a database.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our data access layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have an application that takes in a number and calculates a Fibonacci
    number based on it. However, a database lookup is quicker than a calculation.
    We will use this fact to optimize our application by initially performing a database
    lookup when a number is submitted. If it is not there, we calculate the number,
    store it in the database, and then return it to the user. Before we start building,
    we will have to install the following packages using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pyml`: This package helps in loading parameters for our application from a
    `.yml` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlalchemy`: This package enables our application to map Python objects to
    databases for storing and querying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alembic`: This package helps in tracking and applying changes to the database
    from the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`psycopg2-binary`: This is the binary that will enable our application to connect
    to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have installed all that we need, we can enable our application
    to store and get Fibonacci numbers by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a PostgreSQL database in `docker-compose`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a config loading system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a data access layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build database models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the application database migration system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the database access layer to the fib calculation view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have completed these steps, our application will take the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Our deployment file structure has not changed. We have added a `docker-compose.yml`
    file to our root as it will enable us to access the database when we are developing
    our application. In addition to this, we have added a data access file to enable
    us to connect to the database along with a `models` module to enable mapping objects
    to the database. This structure will result in a containerized Flask application
    that has access to a database. Next, we will begin defining our Docker container
    for our database.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a PostgreSQL database in docker-compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define our database container, we apply the following code to both the `deployment/docker-compose.yml`
    file and the `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can observe that we are relying on the official third-party Postgres
    image. Instead of defining a configuration file, as we did with the NGINX service,
    we define the password, database name, and user using the environment variables.
    When we are running our local environment and developing our application, we will
    run our `docker-compose` file in the root. Now we have defined our database; in
    the next section, we can build our config system.
  prefs: []
  type: TYPE_NORMAL
- en: Building a config loading system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Essentially, our configuration system loads parameters from a `.yml` file inside
    the Flask application by performing these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application might require different parameters depending on the system.
    Because of this, we must build an object that loads parameters from a `.yml` file
    and serves them as a dictionary throughout the application. In our `src/config.py`
    file, first, we import what we need with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will be using the `sys` module to take in the arguments that were passed
    into our application while running it. We use the `os` module to check whether
    the config file that we have specified in the arguments exists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our global parameters object can be built using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you can observe that our `GlobalParams` class directly inherits from the
    dictionary class. This means that we have all the functionality of a dictionary.
    In addition to this, note that we do not pass any arguments into our Python program
    specifying which `.yml` file to load; instead, we simply revert to the standard
    `config.yml` file. This is because we will use our configuration file for migrations
    to the database. It will be difficult to pass in our parameters when performing
    database migrations. If we want to change the configuration, it is best to get
    the new data and write it to the config file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that our config parameters class has been defined, we can add the database
    URL to our `src/config.yml` file using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have access to our database URL, in the next step, we can build
    our database access layer.
  prefs: []
  type: TYPE_NORMAL
- en: Building our data access layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our database access will be defined in the `src/data_access.py` file. Once
    this is done, we can import the data access layer from the `src/data_access.py`
    file anywhere in the Flask application. This is so that we can access the database
    anywhere inside the Flask application. We can build this by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to import what we need using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we will use the `_app_ctx_stack` object to ensure that our session is
    in the context of the Flask request. Following this, we import all of the other
    `sqlalchemy` dependencies to ensure that our access has a session maker and an
    engine. We have to avoid going into excessive detail with database management
    as this book focuses on fusing Rust with Python and we are merely using SQLAlchemy
    to explore database integration with Rust. However, we should be able to get a
    feel for what the session, engine, and base do.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have imported everything we need, we can build our database engine
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have a class that can give us database sessions, a database connection,
    and a base. However, it must be noted that we initiated the `DbEngine` class and
    assigned it to the `dal` variable; however, we didn't import the `DbEngine` class
    outside of this file. Instead, we import the `dal` variable to be used for interactions
    with the database. If we import the `DbEngine` class outside of this file during
    initiation and use it whenever we want to interact with the database, we will
    create multiple database sessions per request and these sessions will struggle
    to close. Even something as small as a couple of users will grind your database
    to a halt with too many hanging connections. Now that our database connection
    has been defined, in the next step, we can move on to build our database models.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our database model, we can have a unique ID, input number, and fib number.
    Our model is defined in the `src/models/database/fib_entry.py` file with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you can see that the code is straightforward. We pass `dal.base` through
    our model to add the model to the metadata. Then, we define the table name that
    will be in the database and model fields, which are `id`, `input_number`, and
    `calculated_number`. Our database model has now been defined, so we can import
    and use it throughout our application. Additionally, we will use this in the next
    step to manage the database migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the application database migration system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Migrations are a useful tool for keeping track of all the changes made to our
    database. If we make a change in a database model or define one, we need to translate
    those changes to our database. We can achieve this by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our database management, we are going to lean on the `alembic` package.
    Once we have navigated inside the `src/` directory, we run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must import the `os` and `sys` modules, as we will be using them to
    import our models and load our configuration file. We import the modules using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Following this, we use the `os` module to append the path that is in the `src/`
    directory with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have configured our import path, we can import our parameters and
    database engine. Then, we add our database URL to our `alembic` database URL using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this, you can observe that the autogenerated function gets our config,
    which then executes the migrations with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have our configuration system linked up to our database migrations,
    we have to make sure `docker-compose` is running because our database has to be
    live. We can generate a migration using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: revision identifiers, used by Alembic.
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Revision = '40b83d85c278'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: down_revision = None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: branch_labels = None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: depends_on = None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def upgrade():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: op.create_table('fib_entries',
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sa.Column('id', sa.Integer(), nullable=False),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sa.Column('input_number', sa.Integer(),\
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nullable=True),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sa.Column('calculated_number', sa.Integer(), \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nullable=True),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sa.PrimaryKeyConstraint('id')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def downgrade():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: op.drop_table('fib_entries')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: alembic upgrade head
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: INFO  [alembic.runtime.migration] Context impl
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PostgresqlImpl.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: INFO  [alembic.runtime.migration] Will assume
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: transactional DDL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: INFO  [alembic.runtime.migration] Running upgrade  ->
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 40b83d85c278, create-fib-entry
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our migration has worked. In the next step, we will interact with the database
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Building database models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a database that has our application models applied to it,
    we can interact with our database in the application. This can be done by importing
    our data access layer and data model into the view that is using them and, well,
    use them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we will be implementing our view inside the `src/app/app.py`
    file. First, we import the data access layer and model using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these imports, we can alter our calculation view to check whether the number
    exists in the database and return the number from the database if it does.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If it is not available in the database, then we calculate it, save the result
    in the database, and return the result using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you can observe that our interactions with the database are straightforward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we have to make sure that when our request has finished, our database sessions
    are expired, closed, and removed using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, we have a safe and fully functioning interaction with our database. You
    are now aware of the fundamentals of interacting with a database using our application.
    You can achieve other, more complex database queries by reading the SQLAlchemy
    documentation about the specifics of the database, other database queries, and
    insertions as a way to map syntax. If we run our application locally and hit our
    calculation view twice, we will get the first and second results, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The top part is the first request (calculated), and the'
  prefs: []
  type: TYPE_NORMAL
- en: bottom part is the second request (database call)
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.05_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – The top part is the first request (calculated), and the bottom
    part is the second request (database call)
  prefs: []
  type: TYPE_NORMAL
- en: Our database is working the way we expect it to. Now the application is fully
    functioning, and you can move on to the next section if you wish, as this is enough
    to test Rust code in a Flask application, which we will do in the next chapter.
    However, if you want to understand how we apply the database in our deployment
    section, we will cover this next.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the database access layer to the fib calculation view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a database to our deployment is a matter of adding it to our `docker-compose`
    deployment and updating our configuration file to map to the database service
    in the `docker-compose` deployment. We can achieve this by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to refactor our `deployment/docker-compose.yml` file using the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can observe that we have a slightly different name for our database container.
    This is to ensure that there are no clashes with our development database. Additionally,
    we have declared that our Flask application is dependent on and linked to our
    database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also have to point our Flask application to the Docker database. To do this,
    we have to have a different configuration file for our Flask application. We can
    manage the configuration file switch in `src/Dockerfile` for the Flask application.
    This can be done using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we remove the `config.yml` file and then change the filename of the `live_config.yml`
    file to `config.yml`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we have to make our `src/live_config.yml` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have changed `@localhost` to `@postgres` because the classification
    of our service is called `postgres`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Following this, we can rebuild our Flask image using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can run our `docker-compose` deployment, but we will have to run our
    migrations while our `docker-compose` deployment is running. This is because our
    Flask application will not cause an error if it is out of sync with the database
    until we try and make a query to the database, so running `docker-compose` before
    migrating is fine if we make no requests. When we make the migration, we must
    do this while the database in `docker-compose` is running; otherwise, the migration
    will not be able to connect to the database. We can run the migration while `docker-compose`
    is running using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This runs the migrations on our Flask container. It is not advised that you
    only have your live configuration files within your application code. A favorite
    method of mine is to upload an encrypted configuration file in AWS S3 and pull
    it in Kubernetes as it starts up a pod. This is beyond the scope of this book,
    as this is not a web development book. However, it is important to keep methods
    such as this in mind for further reading if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, there is not much to complain about when it comes to calculating
    Fibonacci numbers with our Flask application. However, when we try and calculate
    a large number, we will be waiting for a long time, and this will keep the request
    hanging. To prevent this from occurring, in the next section, we are going to
    implement a message bus. This is so that while our application is processing large
    numbers in the background, we can return a message telling the users to be patient.
  prefs: []
  type: TYPE_NORMAL
- en: Building a message bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this section, we will be using the `Celery` and `Redis` packages to build
    and run our message bus. Once we have completed this section, our mechanism will
    take a form that is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – A message bus with Flask and Celery'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.06_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – A message bus with Flask and `Celery`
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding diagram, we have two processes running. One is running
    our Flask application, while the other is running `Celery`, which handles queuing
    and processing tasks. To make this work, we are going to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a `Celery` broker for Flask.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a Fibonacci calculation task for **Celery**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update our calculation view with `Celery`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define our `Celery` service in Docker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we embark on these steps, we have to install the following packages
    using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Celery`: This is the message bus broker that we are going to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Redis`: This is the storage system that `Celery` is going to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have installed the requirements, we have to remember to update the
    `src/requirements.txt` file with `Celery` and Redis for our Docker builds. Now
    that we have all of our dependencies installed, we can start building our `Celery`
    broker, as demonstrated next.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Celery broker for Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Essentially, our `Celery` broker is a storage system that will store data concerning
    the tasks we have sent to it. We can set up our storage system and connect it
    to our `Celery` system using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to build our own module when building our task queue. Inside the
    `src/` directory, our task queue module will take the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `engine.py` file will host a constructor for `Celery` that considers the
    context of the Flask application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will build our Fibonacci calculation `Celery` task in the `fib_calc_task.py`
    file. In our `engine.py` file, we can build our constructor using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `backend` and `broker` parameters will point to the storage; we will define
    them later. Here, you can observe that we must pass the Flask application into
    the function, construct the `Celery` class, and fuse a `Celery` task object with
    the Flask application context and then return it. When it comes to defining an
    entry point for running our `Celery` process, we should place it in the same file
    as our Flask application. This is because we want to use the same Docker build
    and, thus, image for the Flask application and `Celery` process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To achieve this, we import our `Celery` constructor and pass the Flask application
    through it, in the `src/app.py` file, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when we run our `Celery` broker, we will point it at our `src/app.py`
    file and the `Celery` object inside it. Additionally, we must define our backend
    storage system. Because we are using Redis, we can define these parameters in
    our `src/config.yml` file using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have defined our `Celery` broker, in the next step, we can build
    our Fibonacci calculation task.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Fibonacci calculation task for Celery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to running our `Celery` task, we need to build another constructor.
    However, instead of passing in our Flask application, we pass in our `Celery`
    broker. We can achieve this in the `src/task_queue/fib_calc_task.py` file using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding logic is like our standard calculation view. We can import it
    into our `src/app.py` file and pass our `Celery` broker to it using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our task defined and fused with our `Celery` broker and Flask
    application, in the next step, we can add our `Celery` task to the calculation
    view if the number is too large.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our calculation view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our view, we must check to see whether our input number is less than `31`
    and not in the database. If it is, we run our standard existing code. However,
    if the input number is `30` or above, we will send the calculation to the `Celery`
    broker and return a message telling the user that it has been sent to the queue.
    We can do this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Now our `Celery` process with our task has been fully built. In the next step,
    we will define our Redis service in `docker-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our Celery service in Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to our `Celery` service, remember that we used Redis as a storage
    mechanism. Considering this, we define our Redis service in our developed `docker-compose.yml`
    file using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Now running our whole system in develop mode requires running our developed
    `docker-compose` file at the root of our project. Additionally, we run the Flask
    application by running our `app.py` file with Python, where `PYTHONPATH` is set
    to `src`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, we open another Terminal window, navigate the Terminal inside
    the `src` directory, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where we point `Celery` to the `app.py` file. We state that the object
    is called `Celery`, that it is a worker, and that the logging is at the `info`
    level. Running this gives us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding printout shows us that our task has been registered and that
    four processes have been spun up. Hitting the calculation view with our `Celery`
    processes using a number higher than `30` gives us the following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The bottom shows the first request with Celery, and the top
    shows the'
  prefs: []
  type: TYPE_NORMAL
- en: second request with Celery
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.07_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – The bottom shows the first request with `Celery,` and the top shows
    the second request with `Celery`
  prefs: []
  type: TYPE_NORMAL
- en: Our Flask application with a database and `Celery` message bus is now fully
    working locally. You can stop here if you wish, as this is enough to test Rust
    code in `Celery` in the next chapter. However, if you want to learn how to apply
    `Celery` to the deployment section, continue with this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying `Celery` to our `docker-compose` deployment is straightforward. Remember
    that we have the same entry point, so there is no need for a new image. Instead,
    all we have to do is change the command that we run when spinning up our `Celery`
    container. This can be done in our `deployment/docker-compose.yml` file using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can observe that we pull the same image for our `queue_worker` service.
    However, we change the `CMD` tag in our Docker build using the `entrypoint` tag
    in `docker-compose`. So, when our `queue_worker` service is built, it will run
    the `Celery` command running the `Celery` workers, as opposed to running the Flask
    web application. Following this, we need to add some more parameters to our `live_config.yml`
    file using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have named our Redis service as opposed to the localhost. This is so
    that our packaged `Celery` worker and Flask application will connect to our Redis
    service in the `docker-compose` deployment. After running the `docker-compose`
    deployment, we can repeat the requests demonstrated in *Figure 9.6* with `localhost`
    as opposed to `127.0.0.1:5002`. With this, our Flask application is ready to deploy
    with a database and task queue. Technically, our setup can be deployed and used
    on a server. I have done this, and it works just fine. However, for more advanced
    systems and control, it is advised that you carry out some further reading. Additional
    references about deploying Flask applications in Docker to cloud services such
    as Amazon Web Services are listed in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a Python Flask application that had access to a database
    and message bus to allow the queuing of heavy tasks in the background. Following
    this, we wrapped our services in Docker containers and deployed them in a simple
    `docker-compose` file with NGINX. Additionally, we learned how to build our `Celery`
    worker and Flask application in the same Dockerfile using the same build. This
    made our code easier to maintain and deploy. We also managed our migrations for
    our database using `alembic` and a configuration file, which was then switched
    to another configuration file when we were deploying our application. While this
    is not a web development textbook, we have covered all of the essentials when
    it comes to structuring a Flask web application.
  prefs: []
  type: TYPE_NORMAL
- en: Further details regarding database queries, data serialization, or HTML and
    CSS rendering are covered, in a straightforward manner, in the Flask documentation.
    We have covered all of the difficult stuff. Now, we can experiment with Rust and
    how it can be fused with a Python web application, not just in a development setting
    but a live setting where the application is running in a Docker container while
    communicating with other Docker containers. In the next chapter, we will fuse
    Rust with our Flask application. This is so that it can work with the development
    and deployment settings.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we change in the URI when we switch from development to deployment on
    `docker-compose` to communicate with another service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we use configuration files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we really need `alembic` to manage the database?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do we have to do to our database engine to ensure our database does not
    get flooded with hanging sessions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we need Redis for our `Celery` worker process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We switch the `localhost` part of the URI to the tag of the `docker-compose`
    service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuration files enable us to switch contexts easily; for instance, switching
    from development to live. Additionally, if our `Celery` service needs to talk
    to a different database for some reason, this can be done with minimal effort;
    simply changing the configuration file will work. It is also a security issue.
    Hardcoding database URIs will expose these credentials to anyone who has access
    to the code and will be in the GitHub repository history. Store the configuration
    file in a different space such as AWS S3, which gets pulled when the service is
    deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Technically, no. We can simply write SQL scripts and run them in sequence. When
    I was working in financial technology, this was actually a thing that we had to
    do. While this can give you more freedom, it does take more time and is more error-prone.
    Using `alembic` will save you time, errors, and work for pretty much most of your
    needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We initiate our database engine once in the same file where our engine is defined.
    We never initiate it again, and we import this initiated engine anywhere we need.
    Not doing so will lead to our database to a grinding halt with dangling sessions
    and not very helpful error messages that will have you running around in circles
    on the internet with vague half-baked answers. Additionally, we have to close
    our sessions in the Flask teardown function for all requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes and no. We require a storage mechanism such as Redis; however, we can also
    use RabbitMQ or MongoDB instead of Redis if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Nginx HTTP Server – Fourth Edition: Harness the power of Nginx* by Fjordvald
    M. and Nedelcu C. (2018) (Packt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official Flask documentation – Pallets (2021): [https://flask.palletsprojects.com/en/2.0.x/](https://flask.palletsprojects.com/en/2.0.x/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Docker for Microservices with Python* by Jaime Buelta (2019) (Packt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AWS Certified Developer – Associate Guide – Second Edition* by Vipul Tankariya
    and Bhavin Parmar (2019) (Packt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SQLAlchemy query reference documentation (2021): [https://docs.sqlalchemy.org/en/14/orm/loading_objects.html](https://docs.sqlalchemy.org/en/14/orm/loading_objects.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
