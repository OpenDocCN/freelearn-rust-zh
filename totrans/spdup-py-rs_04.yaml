- en: '*Chapter 5*: Creating a Rust Interface for Our pip Module'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：为我们的pip模块创建Rust接口'
- en: In [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062), *Building
    pip Modules in Python*, we built a `pip` module in Python. Now, we will build
    the same `pip` module in Rust and manage the interface. Some people might prefer
    Python for some tasks; others will state that Rust is better. In this chapter,
    we will simply utilize both as and when we want. To achieve this, we will build
    a `pip` module in Rust that can be installed and directly imported into our Python
    code. We will also build Python entry points that talk directly to our compiled
    Rust code, and Python adapters/interfaces to make the user experience of our module
    easy, safe, and locked down with **user interfaces** (**UIs**) that have all features
    that we want our user to use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062)，“在Python中构建pip模块”，我们构建了一个Python的`pip`模块。现在，我们将构建相同的`pip`模块在Rust中，并管理接口。有些人可能更喜欢Python来完成某些任务；其他人可能会说Rust更好。在本章中，我们将简单地根据需要使用两者。为了实现这一点，我们将构建一个Rust的`pip`模块，它可以被安装并直接导入到我们的Python代码中。我们还将构建Python入口点，它们直接与我们的编译后的Rust代码通信，以及Python适配器/接口，以使我们的模块的用户体验变得简单、安全，并通过具有所有我们希望用户使用的功能的**用户界面**（**UIs**）来锁定。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Packaging Rust with `pip`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pip`打包Rust
- en: Building a Rust interface with the `pyO3` crate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pyO3`crate构建Rust接口
- en: Building tests for our Rust package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的Rust包构建测试
- en: Comparing speed with Python, Rust, and Numba
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Python、Rust和Numba比较速度
- en: Covering these topics will enable us to build Rust modules and use them in our
    Python systems. This is a major advantage as a Python developer; you can use faster,
    safer, and less resource-intensive code seamlessly in your Python programs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖这些主题将使我们能够构建Rust模块并在我们的Python系统中使用它们。这对于Python开发者来说是一个主要优势；你可以在Python程序中无缝地使用更快、更安全、资源消耗更少的代码。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will need to have **Python 3** installed. To get the most out of this chapter,
    we will also need to have a GitHub account, as we will be using GitHub to package
    our code, which can be accessed via this link: [https://github.com/maxwellflitton/flitton-fib-rs](https://github.com/maxwellflitton/flitton-fib-rs).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装**Python 3**。为了充分利用本章内容，我们还需要拥有一个GitHub账户，因为我们将会使用GitHub来打包我们的代码，可以通过此链接访问：[https://github.com/maxwellflitton/flitton-fib-rs](https://github.com/maxwellflitton/flitton-fib-rs)。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_five](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_five).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_five](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_five)找到。
- en: Packaging Rust with pip
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pip打包Rust
- en: 'In this section, we will be setting up our `pip` package so that it can utilize
    Rust code. This will enable us to use Python setup tools to import our Rust `pip`
    package, compile it for our system, and use it within our Python code. For this
    chapter, we are essentially building the same Fibonacci module that we built in
    [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062), *Building pip Modules
    in Python*. It is advised to create another GitHub repository for our Rust module;
    however, nothing is stopping you from refactoring your existing Python `pip` module.
    To build our Rust `pip` module, we are going to have to carry out the following
    steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置我们的`pip`包，使其能够利用Rust代码。这将使我们能够使用Python设置工具导入我们的Rust `pip`包，为我们的系统编译它，并在Python代码中使用它。对于本章，我们实际上是在构建与[*第4章*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062)，“在Python中构建pip模块”中构建的相同的斐波那契模块。建议为我们的Rust模块创建另一个GitHub仓库；然而，没有任何阻止你重构现有的Python
    `pip`模块。为了构建我们的Rust `pip`模块，我们必须执行以下步骤：
- en: Define `gitignore` and `Cargo` for our package.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的包的`gitignore`和`Cargo`。
- en: Configure a Python setup process for our package.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的包配置Python设置过程。
- en: Create a Rust library for our package.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的包创建一个Rust库。
- en: Define gitignore and Cargo for our package
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们的包的gitignore和Cargo
- en: To get started, we must make sure that our Git does not track files that we
    do not want to upload and that our `Cargo` has the right dependencies with *step
    1*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们必须确保我们的Git不会跟踪我们不希望上传的文件，并且我们的`Cargo`具有正确的依赖项，*步骤1*。
- en: 'First, we can start with `gitignore`. If you are choosing to use the same GitHub
    repository as the one that we defined in the previous chapter, then all the files
    for Python are already defined in the `.gitignore` file at the root of the GitHub
    repository. If not, then when you are creating your new GitHub repository, we
    have to select the Python template in the `Add .gitignore` section. Either way,
    once we have the Python `gitignore` template in our `.gitignore` file, we must
    add our `gitignore` requirements for the Rust part of our package. To do this,
    we add the following code in the `.gitignore` file:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以从`gitignore`开始。如果你选择使用与我们在上一章中定义的相同的GitHub仓库，那么Python的所有文件已经定义在GitHub仓库根目录下的`.gitignore`文件中。如果不是这样，那么在你创建新的GitHub仓库时，我们必须在`Add
    .gitignore`部分选择Python模板。无论如何，一旦我们在`.gitignore`文件中有Python的`gitignore`模板，我们必须添加我们包Rust部分的`gitignore`要求。为此，我们在`.gitignore`文件中添加以下代码：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Yes, that is it for our Rust code. That is a lot less than the Python files
    that we need to ignore.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的，这就是我们Rust代码的全部内容。这比我们需要忽略的Python文件要少得多。
- en: 'Now that we have defined `gitignore`, we can move on to defining our `Cargo.toml`
    file in the root of our package, initially defining the metadata of our package
    with the following code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`gitignore`，我们可以继续定义我们包根目录下的`Cargo.toml`文件，最初用以下代码定义我们包的元数据：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is nothing new; all we are doing here is defining the name and generic
    information of our package.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这没有什么新东西；我们在这里所做的只是定义我们包的名称和通用信息。
- en: 'We then go on to define the dependencies with the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们继续用以下代码定义依赖项：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see that we have not defined any dependencies in the `dependencies` section.
    We will be depending on the `pyo3` crate to enable our Rust code to interact with
    our Python code. We declare the latest version of the crate at the point of writing
    this book, and the fact that we want to enable the `extension-module` feature
    because we will be using `pyo3` to make our Rust module.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，我们在`dependencies`部分没有定义任何依赖项。我们将依赖于`pyo3`crate来使我们的Rust代码能够与我们的Python代码交互。我们在撰写本书时声明了crate的最新版本，以及我们想要启用`extension-module`功能，因为我们将会使用`pyo3`来创建我们的Rust模块。
- en: 'We then define our library data with the following code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们用以下代码定义我们的库数据：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It must be noted that we have defined a `crate-type` variable. Crate types provide
    information to the compiler on how to link Rust crates together. This can either
    be static or dynamic. For instance, if we were to define the `crate-type` variable
    as `bin`, this would compile our Rust code as a runnable executable. The main
    file would have to be present in our module, as this would be the entry point.
    We could also define the `crate-type` variable as `lib`, which compiles it as
    a library that can be used by other Rust programs. We can go further with this,
    defining either a static or dynamic library. Defining the `crate-type` variable
    as `cdylib` tells the compiler that we want a dynamic system library to be loaded
    by another language. If we do not put this in, we will not be able to compile
    our code when installing our library via `pip`. Our library should be able to
    compile for Linux and Windows. However, we require some link arguments to ensure
    that our library also works on macOS.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须注意，我们已经定义了一个`crate-type`变量。Crate类型为编译器提供如何链接Rust crates的信息。这可以是静态的或动态的。例如，如果我们将`crate-type`变量定义为`bin`，这将把我们的Rust代码编译成一个可运行的执行文件。主文件必须存在于我们的模块中，因为这将作为入口点。我们也可以将`crate-type`变量定义为`lib`，这样它就会被编译成一个可以被其他Rust程序使用的库。我们可以进一步定义，要么是静态库要么是动态库。将`crate-type`变量定义为`cdylib`告诉编译器我们想要一个由其他语言加载的动态系统库。如果我们不添加这个，我们将在通过`pip`安装我们的库时无法编译我们的代码。我们的库应该能够为Linux和Windows编译。然而，我们需要一些链接参数来确保我们的库也能在macOS上工作。
- en: 'In order to do this, we need to define the configuration in the `.cargo/config`
    file:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要在`.cargo/config`文件中定义配置：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this, we have defined all that we need for our Rust library. Now, we move
    on to the next step, configuring the Python part of our module.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经为我们的Rust库定义了所有需要的内容。现在，我们继续下一步，配置我们模块的Python部分。
- en: Configuring the Python setup process for our package
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置我们的包的Python设置过程
- en: 'When it comes to setting up the Python section, we will be defining this in
    the `setup.py` file at the root of our module. Initially, we are going to import
    all the requirements that we need with the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到设置Python部分时，我们将在模块根目录的`setup.py`文件中定义这个。最初，我们将用以下代码导入我们需要的所有需求：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are going to use the `setuptools_rust` module for managing our Rust code.
    However, we cannot be sure that the user will have installed `setuptools_rust`
    and we need it for running our setup code. Because of this, we cannot rely on
    the requirements list, as installing the requirements happens after we have imported
    `setuptools_rust`. To get around this, we use the `dist` module to get the required
    `setuptools_rust` module for this script. The user does not permanently install
    `setuptools_rust` but uses it for the script. Now that this is done, we can define
    our setup with the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`setuptools_rust`模块来管理我们的Rust代码。然而，我们无法确定用户是否已经安装了`setuptools_rust`，我们需要它来运行我们的设置代码。由于这个原因，我们不能依赖于需求列表，因为安装需求发生在我们导入`setuptools_rust`之后。为了解决这个问题，我们使用`dist`模块来获取这个脚本所需的`setuptools_rust`模块。用户不会永久安装`setuptools_rust`，而是为了脚本使用它。现在这已经完成，我们可以用以下代码定义我们的设置：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we can see that we define the metadata of the module as we did in the
    previous chapter. We can also see that we define a `rust_extensions` parameter,
    pointing to the actual Rust module that we will define in a Rust file, as we can
    see in the following figure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们定义了模块的元数据，就像我们在上一章中所做的那样。我们还可以看到我们定义了一个`rust_extensions`参数，指向我们将在Rust文件中定义的实际Rust模块，正如我们在以下图中可以看到的那样：
- en: '![Figure 5.1 – Our module flow for setup'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 我们设置模块的流程'
- en: '](img/Figure_5.1_B17720.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 我们设置模块的流程'
- en: Figure 5.1 – Our module flow for setup
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 我们设置模块的流程
- en: 'We also point to our `Cargo.toml` file, as we will have to compile other Rust
    crates that are in our dependencies when we are installing our Rust module. We
    also must state that our module is not zipped safely. This is also standard for
    C modules. Now that we have done all the setup configurations, we can now move
    on to the next step of building our basic Rust module that will get us installing
    Rust code using `pip install` that we can use in our Python code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指向我们的`Cargo.toml`文件，因为当我们安装我们的Rust模块时，我们必须编译我们依赖项中的其他Rustcrate。我们还必须声明我们的模块不是安全压缩的。这同样是C模块的标准做法。现在我们已经完成了所有设置配置，我们可以继续到下一步，构建我们的基本Rust模块，这将使我们能够使用`pip
    install`安装Rust代码，并在我们的Python代码中使用它：
- en: 'For our Rust code, we have to initially import all of the `pyo3` requirements
    in the `src/lib.rs` file with the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的Rust代码，我们最初需要在`src/lib.rs`文件中导入所有的`pyo3`需求，以下代码为示例：
- en: '[PRE28]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What this does is enable our Rust code to utilize all the macros that the `pyo3`
    crate has. We will also be wrapping the Rust functions into the module.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这所做的是使我们的Rust代码能够利用`pyo3`crate中所有的宏。我们还将把Rust函数封装到模块中。
- en: 'We then define a basic *hello world* function with the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们用以下代码定义一个基本的*hello world*函数：
- en: '[PRE29]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can see that we have applied a Python function macro from `pyo3` to the `say_hello`
    function.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，我们已经将`pyo3`的Python函数宏应用到`say_hello`函数上。
- en: 'Now that we have the function, we can define our module in the same file with
    the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了函数，我们可以用以下代码在同一个文件中定义我们的模块：
- en: '[PRE30]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we can see that we have defined the module as `flitton_fib_rs`. This will
    have to be imported as `flitton_fib_rs` when using it. We then use the `pymodule`
    macro. This function is loading the module. We must define a result at the end.
    Seeing as we do not have any complex logic, we will define the end result as an
    `Ok` result. We don't need to do anything to Python; however, we add our wrapped
    `say_hello` function to our module. The `wrap_pyfunction` macro essentially takes
    a Python instance and returns a Python function. Now that we have our Rust code
    defined, we must build our Python entry point.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们定义了模块为`flitton_fib_rs`。在使用时，这将必须以`flitton_fib_rs`的形式导入。然后我们使用`pymodule`宏。这个函数正在加载模块。我们必须在最后定义一个结果。鉴于我们没有任何复杂的逻辑，我们将定义结果为`Ok`。我们不需要对Python做任何事情；然而，我们将我们的封装`say_hello`函数添加到我们的模块中。`wrap_pyfunction`宏本质上接受一个Python实例并返回一个Python函数。现在我们已经定义了Rust代码，我们必须构建我们的Python入口点。
- en: 'This is fairly simple; all we have to do is import our functions from the Rust
    module in the `flitton_fib_rs/__init__.py` file with the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这相当简单；我们只需要用以下代码在`flitton_fib_rs/__init__.py`文件中导入我们的函数：
- en: '[PRE31]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will go through how this works later in this chapter, as we will be installing
    this package and running it.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本章后面详细介绍这是如何工作的，因为我们将会安装这个包并运行它。
- en: Installing our Rust library for our package
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装我们的包的 Rust 库
- en: Right now, we have everything we need to deploy our package and install it via
    `pip`. Considering this, we upload our package to our GitHub repository, which
    is covered in the *Configuring setup tools for a Python pip module* section of
    the [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062), *Building pip
    Modules in Python*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们拥有部署我们的包并通过 `pip` 安装所需的一切。考虑到这一点，我们将我们的包上传到我们的 GitHub 仓库，这在 [*第 4 章*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062)
    的 *配置 Python pip 模块的设置工具* 部分有所介绍，即 *在 Python 中构建 pip 模块*。
- en: 'Once we have done this, we can install our `pip` package with the following
    command, all in one line:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这些，我们就可以使用以下命令安装我们的 `pip` 包，所有操作都在一行中完成：
- en: '[PRE32]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The URL to your GitHub repository might be different. When this is being installed,
    the process will hang for a while. The result should give the following printout:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 GitHub 仓库的 URL 可能不同。在安装过程中，这个过程可能会挂起一段时间。结果应该给出以下输出：
- en: '[PRE34]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is because we are compiling the package based on our system. Here, we
    can see that we collect the code from the `main` branch of the repository and
    run the `setup.py` file. What we have essentially done is compile the Rust code
    into a binary file and put it next to our `__init__.py` entry point file with
    the following file layout:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们是在基于我们的系统编译这个包。在这里，我们可以看到我们从仓库的 `main` 分支收集代码并运行 `setup.py` 文件。我们实际上所做的是将
    Rust 代码编译成二进制文件，并将其放置在我们 `__init__.py` 入口点文件旁边，以下是我们模块的文件布局：
- en: '[PRE47]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is why our `from .flitton_fib_rs import *` code works in the entry point.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们的 `from .flitton_fib_rs import *` 代码在入口点中可以工作。
- en: 'Now that this is all installed in our Python packages, we can run our Python
    console and type in the following commands:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有这些都已经安装到我们的 Python 包中，我们可以运行我们的 Python 控制台并输入以下命令：
- en: '[PRE50]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here we have it! We have got Rust working with Python and we have managed to
    package our Rust code as a `pip` module. This is a complete game changer. We can
    now utilize Rust code without having to rewrite our Python systems. However, we
    only have one file in Rust code. We need to learn how to build bigger Rust systems
    if we want to fully take advantage of our ability to fuse Rust with Python.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '这里就是它了！我们已经让 Rust 与 Python 一起工作，并且我们已经成功地将我们的 Rust 代码打包成 `pip` 模块。这是一个彻底的变革。我们现在可以不重写我们的
    Python 系统，就可以利用 Rust 代码。然而，我们只有一个 Rust 代码文件。如果我们想充分利用将 Rust 与 Python 融合的能力，我们需要学习如何构建更大的
    Rust 系统。 '
- en: Building a Rust interface with the pyO3 crate
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pyO3 crate 构建 Rust 接口
- en: 'Building an interface does not just mean adding more functions to our module
    in Rust and wrapping them. In a sense, we do have to do some of this; however,
    exploring how to import them from other Rust files is important. We also must
    explore and understand the relationship that we can have between Rust and Python
    when we are building up our module. To achieve this, we will carry out these steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 构建接口不仅仅意味着向我们的 Rust 模块中添加更多函数并将它们包装起来。在某种程度上，我们确实需要做这些；然而，探索如何从其他 Rust 文件中导入它们是很重要的。我们还必须探索和了解我们在构建模块时
    Rust 和 Python 之间可以建立的关系。为了实现这一点，我们将执行以下步骤：
- en: Build our Fibonacci module in our Rust package.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 Rust 包中构建我们的 Fibonacci 模块。
- en: Create command-line tools for our package.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的包创建命令行工具。
- en: Create adapters for our package.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的包创建适配器。
- en: With *step one*, we can just build out our module with Rust code. *Steps two*
    and *three* are more Python-focused, wrapping our Rust code in Python code to
    ease the interaction of our Rust module with external Python code. In [*Chapter
    6*](B17720_06_Final_SK_ePub.xhtml#_idTextAnchor100), *Working with Python Objects
    in Rust*, we will interact directly with Python objects in our Rust code. With
    all this in mind, let's our Python interface by initially building our Fibonacci
    code in Rust with *step one*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第一步* 中，我们只需使用 Rust 代码构建我们的模块。*第二步* 和 *第三步* 更侧重于 Python，用 Python 代码包装我们的 Rust
    代码，以便简化 Rust 模块与外部 Python 代码的交互。在 [*第 6 章*](B17720_06_Final_SK_ePub.xhtml#_idTextAnchor100)
    的 *在 Rust 中与 Python 对象协同工作* 中，我们将直接在我们的 Rust 代码中与 Python 对象交互。考虑到所有这些，让我们通过首先在
    Rust 中使用 *第一步* 构建 Fibonacci 代码来构建我们的 Python 接口。
- en: Building our Fibonacci Rust code
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Fibonacci 的 Rust 代码
- en: 'In this step, we are going to build our Fibonacci module, spanning multiple
    Rust files. To achieve this, the file structure of our module takes the following
    form:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们将构建我们的 Fibonacci 模块，跨越多个 Rust 文件。为了实现这一点，我们的模块的文件结构如下所示：
- en: '[PRE53]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, we can see that we have added our Fibonacci code under the `src/fib_calcs`
    directory, as we remember that `fib_numbers.rs` relies on `fib_number.rs`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经将我们的斐波那契代码添加到了`src/fib_calcs`目录下，因为我们记得`fib_numbers.rs`依赖于`fib_number.rs`。
- en: 'Now, let''s follow these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤进行：
- en: 'We can initially define our Fibonacci number function in the `fib_number.rs`
    file with the following code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`fib_number.rs`文件中用以下代码最初定义我们的斐波那契数函数：
- en: '[PRE64]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we can see that we have imported the `pyfunction` macro to apply to our
    function. By now, we are familiar with calculating a Fibonacci number; however,
    unlike previous examples, it must be noted that we have removed the `if the input
    Fibonacci number to be calculated is 3` match statement. This is because that
    match statement significantly speeds up the code, and we want a fair speed comparison
    for the final section of this chapter.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们导入了`pyfunction`宏来应用于我们的函数。到目前为止，我们已经熟悉了计算斐波那契数；然而，与之前的示例不同，我们必须注意我们移除了`如果输入的斐波那契数要计算的值为3`的匹配语句。这是因为该匹配语句显著加快了代码的执行速度，而我们希望在本章的最后部分进行公平的速度比较。
- en: 'Now that we have defined our Fibonacci number function, we can define our `fibonacci_numbers`
    function in the `fib_numbers.rs` file with the following code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的斐波那契数函数，我们可以在`fib_numbers.rs`文件中定义我们的`fibonacci_numbers`函数，代码如下：
- en: '[PRE65]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, we can see that we accepted a vector of integers, looped through them,
    and appended them to an empty vector, returning the vector with all the calculated
    Fibonacci numbers. Here, we have imported the `fibonacci_number` function.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们接受了一个整数向量，遍历它们，并将它们追加到一个空向量中，返回包含所有计算出的斐波那契数的向量。在这里，我们导入了`fibonacci_number`函数。
- en: 'However, we remember that we will not be able to import it, and neither of
    these functions will be available outside of the immediate directory if we do
    not define them in the `src/mod.rs` file with the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们记得如果我们不在`src/mod.rs`文件中用以下代码定义它们，我们就无法导入它们，并且这两个函数将不会在直接目录之外可用。
- en: '[PRE66]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now that we have defined both of our functions and declared them in our `src/mod.rs`
    file, we are now able to import them into our `lib.rs` file. We do this by initially
    declaring the `fib_calcs` module, and then importing the functions with the following
    code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了两个函数并在我们的`src/mod.rs`文件中声明了它们，我们现在能够将它们导入到我们的`lib.rs`文件中。我们通过首先声明`fib_calcs`模块，然后使用以下代码导入函数来完成这项工作：
- en: '[PRE67]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, it must be noted that our functions have the prefix of `__pyo3_get_function_`.
    This enables us to retain the macros applied to the functions. If we just directly
    import the functions, we will not be able to add them to the module, which will
    result in compilation errors when we are installing our package.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里需要注意的是，我们的函数前缀为`__pyo3_get_function_`。这使我们能够保留应用于函数的宏。如果我们直接导入函数，我们就无法将它们添加到模块中，这将导致在安装我们的包时出现编译错误。
- en: 'Now that our functions are imported and ready, we can import-wrap them and
    add them to the module with the following code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导入了函数并准备好了，我们可以导入包装它们并将它们添加到模块中，代码如下：
- en: '[PRE68]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now that we have built our modules, we can test them. We do this by uploading
    our changes to the GitHub repository, and using `pip uninstall` to uninstall our
    `pip` module and `pip install` to install our new package. Once our new package
    is installed, we can import and use our new functions in the Python terminal as
    follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经构建了我们的模块，我们可以测试它们。我们通过将我们的更改上传到GitHub仓库，使用`pip uninstall`来卸载我们的`pip`模块，并使用`pip
    install`来安装我们的新包来完成这项工作。一旦我们的新包安装完成，我们就可以在Python终端中导入并使用我们的新函数，如下所示：
- en: '[PRE69]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we can see that we can import and use the Fibonacci numbers that we have
    coded in Rust that span multiple files! We are now at the stage where nothing
    is stopping us from building our own Rust Python `pip` packages. If you have a
    specific problem in mind to solve in Rust, such as an expensive computation that
    your Python program is struggling to calculate, nothing is stopping you from solving
    that now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们可以导入并使用我们在Rust中编写的跨越多个文件的斐波那契数！我们现在已经到了一个阶段，没有任何事情阻止我们构建自己的Rust
    Python `pip`包。如果你在Rust中有特定的要解决的问题，比如你的Python程序难以计算的计算密集型任务，现在没有任何事情阻止你解决这个问题。
- en: Now that we have gone to the trouble of packaging our Python package written
    in Rust, we can further utilize our package with command-line functionality. Packages
    installed with `pip` are convenient, powerful tools for command-line functionality.
    In the next section, we will access the Rust code in our package directly from
    the command line.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经费尽周折地将用 Rust 编写的 Python 包打包，我们可以进一步利用我们的包，通过命令行功能。使用 `pip` 安装的包是方便、强大的命令行工具。在下一节中，我们将直接从命令行访问我们包中的
    Rust 代码。
- en: Creating command-line tools for our package
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的包创建命令行工具
- en: You may have noticed that to use our Fibonacci functions, we must start a Python
    console, import the functions, and use them. This is not very efficient if we
    just want to calculate a Fibonacci number in the console. We can remove these
    unnecessary procedures needed for calculating a Fibonacci number in the terminal
    by defining our entry points.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，为了使用我们的斐波那契函数，我们必须启动一个 Python 控制台，导入函数，然后使用它们。如果我们只想在控制台中计算一个斐波那契数，这并不很高效。我们可以通过定义入口点来删除计算斐波那契数在终端中所需的这些不必要的程序。
- en: 'Considering that we define our command-line entry points in the `setup.py`
    file, it makes sense to define our entry point in a Python file that acts as a
    wrapper to our Rust function (as we still want the speed benefits of Rust), as
    shown in the following figure:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们在 `setup.py` 文件中定义了我们的命令行入口点，在作为我们的 Rust 函数包装器的 Python 文件中定义我们的入口点是有意义的（因为我们仍然想要
    Rust 的速度优势），如下面的图所示：
- en: '![Figure 5.2 – Flow for module entry point'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 模块入口点流程](img/Figure_5.2_B17720.jpg)'
- en: '](img/Figure_5.2_B17720.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.2_B17720.jpg](img/Figure_5.2_B17720.jpg)'
- en: Figure 5.2 – Flow for module entry point
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 模块入口点流程
- en: 'This wrapper can be done by importing `argparse` and the `fibonacci_number`
    function we made in the Rust module to create a simple Python function that gets
    user input and then passes it into the Rust function, printing out the result.
    We can achieve this by carrying out the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包装可以通过导入 `argparse` 和我们在 Rust 模块中制作的 `fibonacci_number` 函数来创建一个简单的 Python
    函数，该函数获取用户输入，然后将它传递给 Rust 函数，并打印出结果。我们可以通过以下步骤实现这一点：
- en: 'We can build the Python function that collects the arguments and calls the
    Rust code by adding the following code to the `flitton_fib_rs/fib_number_command.py`
    file we create:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将以下代码添加到我们创建的 `flitton_fib_rs/fib_number_command.py` 文件中，来构建一个收集参数并调用
    Rust 代码的 Python 函数：
- en: '[PRE70]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We must remember that when our Rust binary is compiled, it will be in the `flitton_fib_rs`
    directory, right next to the file we just created.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们必须记住，当我们的 Rust 二进制文件编译时，它将在 `flitton_fib_rs` 目录中，就在我们刚刚创建的文件旁边。
- en: 'Next, we define the entry point in the `setup.py` file. Now that we have our
    function, we can point to this in the `setup.py` file by declaring the path to
    this file and function for the `entry_points` parameter with the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在 `setup.py` 文件中定义入口点。现在我们有了我们的函数，我们可以在 `setup.py` 文件中通过声明此文件和函数的路径来指向它，并使用以下代码为
    `entry_points` 参数指定路径：
- en: '[PRE71]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Once this is done, we have fully plumbed up the Python entry point in our package.
    Finally, we can test our command line by passing in arguments to the entry point.
    Now, if we update our GitHub repository and reinstall our package in the Python
    environment, we can test our command line by typing in the following command:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，我们就已经完全配置了我们包中的 Python 入口点。最后，我们可以通过传递参数到入口点来测试我们的命令行。现在，如果我们更新我们的 GitHub
    仓库并在 Python 环境中重新安装我们的包，我们可以通过输入以下命令来测试我们的命令行：
- en: '[PRE72]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This will give us the following output:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE73]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We can see that our command-line tools work. Now we are at the stage where we
    have replicated the same functionality as our Python `pip` package previously
    in [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062)*, Building pip
    Modules in Python*. However, we must go further now. We are fusing two different
    languages in our package. To gain full command of our `pip` package, we need to
    explore how to command and refine the interaction between Rust and Python.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的命令行工具正在工作。现在，我们已经复制了与我们在 *第 4 章* 中之前相同的函数，即 *在 Python 中构建 pip 模块*。然而，我们现在必须更进一步。我们在包中融合了两种不同的语言。为了完全掌握我们的
    `pip` 包，我们需要探索如何命令和细化 Rust 与 Python 之间的交互。
- en: In our next step, we will build adapters that enable us to do this.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一步中，我们将构建适配器，使我们能够做到这一点。
- en: Creating adapters for our package
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的包创建适配器
- en: Before we try and build adapter interfaces, we need to understand what an **adapter**
    is. An adapter is a design pattern that manages the interface between two different
    modules, applications, languages, and so on. The title of the design pattern is
    descriptive of what we are doing. For instance, if you buy one of the new MacBook
    Pros, you will realize that you only have USB-C ports. Instead of opening your
    MacBook and rewiring it so that it can accept your standard USB memory stick,
    you buy an adapter. Adapters have multiple advantages. When it comes to modular
    software engineering, this gives us an advantage.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试构建适配器接口之前，我们需要了解什么是**适配器**。适配器是一种设计模式，它管理两个不同模块、应用程序、语言等之间的接口。设计模式的标题描述了我们正在做的事情。例如，如果你购买了一款新的MacBook
    Pro，你会意识到你只有USB-C端口。而不是打开你的MacBook并重新布线，以便它可以接受你的标准USB闪存驱动器，你购买了一个适配器。适配器有多个优点。当涉及到模块化软件工程时，这给我们带来了优势。
- en: For instance, let's say that module A relies on module B. Instead of importing
    aspects of module B throughout module A, we can create adapters that manage the
    interface between both modules. This, in turn, gives us a lot of flexibility.
    For instance, module C could be built as an improvement on module B. Instead of
    working through module A looking for, and trying to root out, the uses of module
    B, we know that they are all utilized in the adapter. We can even produce a second
    adapter slowly moving over to module C in time. If we want to delete a module
    or move it out, again, our connection to another module can be severed instantly
    by just deleting the adapters. Adapters are simple and give us ultimate flexibility.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设模块A依赖于模块B。我们可以在模块A中创建适配器来管理这两个模块之间的接口，而不是在模块A中导入模块B的各个方面。这样，我们就能获得很多灵活性。例如，模块C可以构建为模块B的改进版。我们不需要通过模块A查找并尝试根除模块B的使用，我们知道它们都在适配器中得到了利用。我们甚至可以缓慢地创建一个转向模块C的第二个适配器。如果我们想删除一个模块或将其移除，再次，我们只需删除适配器就可以立即切断与其他模块的连接。适配器简单且给我们带来了极大的灵活性。
- en: Considering what we have discussed about adapters, it makes sense that we create
    adapters between our Rust code and Python. Seeing as Python systems are essentially
    using our Rust code, it makes sense to build our adapters in Python.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们关于适配器的讨论，我们创建Rust代码和Python之间的适配器是有意义的。鉴于Python系统本质上是在使用我们的Rust代码，因此在我们Python中构建适配器是有意义的。
- en: To demonstrate how to do this, we will create an adapter that accepts either
    a list or an integer. It then selects the right Rust function and implements it.
    However, for our purposes with this adapter, we can make up a scenario where there
    is a lot of incorrect data being fed into the module. We do not want it to error
    every time incorrect data is passed in, but we do want to categorize whether the
    calculation is a failure, and we want to count the number of correct calculations
    we do. This seems specific, and we must remember that, like the MacBook, we can
    have multiple adapters. Nothing is stopping us from chopping, changing, and deleting
    in the future if we need to.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何做到这一点，我们将创建一个接受列表或整数的适配器。然后它选择正确的Rust函数并实现它。然而，对于这个适配器的用途，我们可以设想一个有很多错误数据被输入到模块中的场景。我们不希望每次传递错误数据时都出错，但我们确实想分类计算是否失败，并统计我们完成的正确计算的数量。这似乎很具体，我们必须记住，就像MacBook一样，我们可以有多个适配器。如果我们未来需要修改或删除，没有什么可以阻止我们这样做。
- en: 'However, before we start writing code, we need to understand the layers involved
    for the adapter, as described here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始编写代码之前，我们需要理解适配器涉及的层级，如下所述：
- en: '![Figure 5.3 – The layers of a Python adapter for a Rust module'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.3 – Rust模块的Python适配器的层级'
- en: '](img/Figure_5.3_B17720.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.3_B17720.jpg]'
- en: Figure 5.3 – The layers of a Python adapter for a Rust module
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – Rust模块的Python适配器的层级
- en: In the preceding figure, we can see that Python objects come from types. However,
    we can interject how these objects are called from types with **metaclasses**.
    When it comes to metaclasses, we must build a metaclass that will define how our
    counter is called. Our counter is going to be universal. We do not know how the
    users will use our interface. They might loop through a list of data points, calling
    our adapter for each one. We need to ensure that no matter how many adapters are
    being called, they are all pointing to the same counter. This might be a little
    confusing. This will become clearer when we build it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到Python对象来自类型。然而，我们可以通过**元类**来介入这些对象是如何从类型中调用的。当涉及到元类时，我们必须构建一个元类来定义我们的计数器是如何被调用的。我们的计数器将是通用的。我们不知道用户将如何使用我们的接口。他们可能会遍历一系列数据点，为每个数据点调用我们的适配器。我们需要确保无论调用多少适配器，它们都指向同一个计数器。这可能会有些令人困惑。这将在我们构建时变得更加清晰。
- en: Using a singleton design pattern to build an adapter interface
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用单例设计模式构建适配器接口
- en: 'First, we must define our `Singleton` metaclass:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义我们的`Singleton`元类：
- en: 'This can be done with the following code in the `flitton_fib_rs/singleton.py`
    file we create:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以在我们创建的`flitton_fib_rs/singleton.py`文件中使用以下代码完成：
- en: '[PRE74]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, we can see that our `Singleton` class inherits directly from `type`. Here,
    what is happening is that we have a dictionary called `_instances`, where the
    keys to this dictionary are the class types. When a class that has `Singleton`
    as a metaclass is called, the type of that class is checked in the dictionary.
    If the type is not in the dictionary, then it is constructed and put into the
    dictionary. The instance in the dictionary is then returned. What this essentially
    means is that we cannot have two instances of a class. This process is laid out
    in the following figure:![Figure 5.4 – The logic flow for a Singleton metaclass
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的`Singleton`类直接继承自`type`。在这里，发生的事情是我们有一个名为`_instances`的字典，这个字典的键是类类型。当一个具有`Singleton`作为元类的类被调用时，该类的类型会在字典中进行检查。如果该类型不在字典中，则它将被构造并放入字典中。然后，字典中的实例被返回。这本质上意味着我们无法有两个类的实例。这个过程在以下图中展示：![图5.4
    – Singleton元类的逻辑流程]
- en: '](img/Figure_5.4_B17720.jpg)'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_5.4_B17720.jpg]'
- en: Figure 5.4 – The logic flow for a Singleton metaclass
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.4 – Singleton元类的逻辑流程
- en: 'Now, we will use our `Singleton` class to construct our counter. This can be
    done with the following code in the `flitton_fib_rs/counter.py` file that we create:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用我们的`Singleton`类来构建我们的计数器。这可以在我们创建的`flitton_fib_rs/counter.py`文件中使用以下代码完成：
- en: '[PRE75]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now, our `Counter` class cannot be constructed twice in the same program. Therefore,
    we can ensure that there will only be one `Counter` class, no matter how many
    times we call it.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们的`Counter`类不能在同一个程序中构造两次。因此，我们可以确保无论我们调用多少次，都只有一个`Counter`类。
- en: 'We can now use it on our main adapter. We will house our main adapter in the
    `flitton_fib_rs/fib_number_adapter.py` file that we create. First of all, we import
    all of the functions and objects that we need with the following code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的主要适配器上使用它。我们将把我们的主要适配器放在我们创建的`flitton_fib_rs/fib_number_adapter.py`文件中。首先，我们使用以下代码导入所有需要的函数和对象：
- en: '[PRE76]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, we can see that we have imported the typing that we need. We have also
    imported the Rust Fibonacci numbers that we will be using and our counter. Now
    that we have imported what we need, we can build our interface constructor.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们导入了所需的`typing`。我们还导入了我们将使用的Rust斐波那契数和我们的计数器。现在我们已经导入了所需的内容，我们可以构建我们的接口构造器。
- en: 'For our adapter, we will need to have a number input, a status of whether the
    process is successful or not, along with the actual result, which will be the
    calculated Fibonacci number, or an error message if there is a failure. We will
    also have a counter, and we will have to process the input during the construction
    of the object. This can be denoted with the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的适配器，我们需要一个数字输入，一个表示过程是否成功的状态，以及实际的结果，这将是我们计算出的斐波那契数，或者如果失败，将是一个错误信息。我们还将有一个计数器，并且我们将在对象的构建过程中处理输入。这可以用以下代码表示：
- en: '[PRE77]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Remember, even though we call the counter, it is a singleton pattern; therefore,
    the counter will be the same instance across all instances of the adapter. Now
    that all of the correct attributes have been defined, we have to define what is
    an actual success.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，尽管我们调用了计数器，但它是一个单例模式；因此，计数器将是所有适配器实例中的相同实例。现在我们已经定义了所有正确的属性，我们必须定义什么是实际的成功。
- en: 'This is where we state that success is `True`, and we increase the counter
    by one. This can be denoted by the `FlittonFibNumberAdapter` instance function,
    as shown here:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们声明成功状态为`True`并增加计数器的地方。这可以通过以下`FlittonFibNumberAdapter`实例函数表示，如下所示：
- en: '[PRE78]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This is smooth; because we have defined a clean interface for the counter, there
    is little explanation needed. Now that we have our success defined, we need to
    process the input because there are two different functions, one that takes a
    list and one that takes an integer.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这很顺畅；因为我们已经为计数器定义了一个干净的接口，所以不需要太多解释。现在我们已经定义了成功，我们需要处理输入，因为有两个不同的函数，一个接受列表，另一个接受整数。
- en: 'We can pass in the correct input to the correct function with the `FlittonFibNumberAdapter`
    instance function, as shown here:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过`FlittonFibNumberAdapter`实例函数将正确的输入传递给正确的函数，如下所示：
- en: '[PRE79]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, we can see that we define an error message if there isn't a list of integers
    passed in. If we do pass in the correct input, we define the result as the result
    of the function and call the `_define_success` function.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到如果没有传递整数列表，我们定义一个错误信息。如果我们传递了正确的输入，我们定义结果为函数的结果并调用`_define_success`函数。
- en: 'The only thing left is to expose the count for the outside user. This can be
    done with the following `FlittonFibNumberAdapter` property:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的唯一事情是将计数器暴露给外部用户。这可以通过以下`FlittonFibNumberAdapter`属性来完成：
- en: '[PRE80]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Again, the counter interface is clean, so no explanation is needed. Our adapter
    interface is now completed. All we need to do is expose it to the user by importing
    it into the `src/__init__.py` file with the following code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，计数器界面简洁，因此无需解释。我们的适配器接口现已完成。我们所需做的就是通过以下代码将其导入到`src/__init__.py`文件中，以便向用户暴露：
- en: '[PRE81]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Everything is done. We can now update our GitHub repository and reinstall our
    package in the Python environment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都已完成。我们现在可以更新我们的GitHub仓库，并在Python环境中重新安装我们的包。
- en: Testing our adapter interface in the Python console
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python控制台中测试适配器接口
- en: 'We can now test our adapter with the Python console commands, as shown here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下Python控制台命令测试我们的适配器，如下所示：
- en: '[PRE82]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here, we can see that we can import our adapter from the module. We can then
    define two different adapters. We can see that the count is consistent across
    both adapters, which means that our singleton pattern works! Both adapters are
    pointing to the same `Counter` instance! All of our adapters will point to that
    same `Counter` instance. We can also see that the success is `True`, and we can
    access the result of the calculation:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们可以从模块中导入我们的适配器。然后我们可以定义两个不同的适配器。我们可以看到两个适配器之间的计数器是一致的，这意味着我们的单例模式工作得很好！两个适配器都指向同一个`Counter`实例！所有我们的适配器都将指向那个相同的`Counter`实例。我们还可以看到成功状态为`True`，并且我们可以访问计算结果：
- en: 'Now, in the same Python console, we can test to see whether an incorrect input
    results in a failure and doesn''t increase the count with the Python console commands
    shown next:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在同一个Python控制台，我们可以通过以下Python控制台命令测试一个不正确的输入是否会导致失败并且不会增加计数：
- en: '[PRE93]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Here, we can see that the count hasn''t increased, the success is `False`,
    and that there is an error message. The final input test can be done by inputting
    a list of integers with the Python console command shown next:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到计数器没有增加，成功状态为`False`，并且出现了一个错误信息。最终的输入测试可以通过输入一个整数列表，使用下面的Python控制台命令来完成：
- en: '[PRE94]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Calling them in the same Python console command reveals whether this is true,
    as shown next:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个Python控制台命令中调用它们，可以揭示这是否为真，如下所示：
- en: '[PRE95]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: There we have it. We have fully configured the Python interface of our module.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，我们已经完全配置了我们的模块的Python接口。
- en: In this section, we built our Rust `pip` package with a Python interface. You
    might be tempted to add extra directories and flesh out entire Python modules
    in the `flitton_fib_rs` directory. However, extra directories in the `flitton_fib_rs`
    directory do not get copied over when the package is being installed. This is
    fine as well. We are essentially building Rust `pip` packages. Rust is fast and
    safe, and we should be leaning on this as much as we can. The Python adapters
    and command in the `flitton_fib_rs` directory should be there to smooth over the
    interface. For instance, if we want the memory of our interface to be managed
    in a particular way, it makes sense to do this in the interface of Python as a
    wrapper, as Python will be the system that is importing and using the `pip` package.
    If you find yourself putting anything other than adapters and command-line functions
    in the `flitton_fib_rs` module, that is a warning sign that you should try and
    consider putting it in the Rust module itself. We have tested our package manually;
    however, we need to ensure that our Rust Fibonacci calculation functions do as
    we expect.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为我们的Rust `pip`包添加了Python接口。你可能会想向`flitton_fib_rs`目录中添加额外的目录并填充整个Python模块。然而，当包被安装时，`flitton_fib_rs`目录中的额外目录不会被复制。这也是可以的。我们本质上是在构建Rust
    `pip`包。Rust既快又安全，我们应该尽可能多地依赖它。`flitton_fib_rs`目录中的Python适配器和命令应该在那里平滑接口。例如，如果我们想以特定的方式管理我们接口的内存，那么在Python接口作为包装器中这样做是有意义的，因为Python将是导入和使用`pip`包的系统。如果你发现自己将适配器和命令行函数以外的任何东西放入`flitton_fib_rs`模块，那是一个警告信号，你应该尝试将其放入Rust模块本身。我们已经手动测试了我们的包；然而，我们需要确保我们的Rust斐波那契计算函数按预期工作。
- en: In the next section, we will be creating unit tests for our Rust code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为我们的Rust代码创建单元测试。
- en: Building tests for our Rust package
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的Rust包构建测试
- en: 'Previously, in [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062),
    *Building pip Modules in Python*, we built unit tests for our Python code. In
    this section, we will build unit tests for our Fibonacci functions. These tests
    do not need any extra packages or dependencies. We can use Cargo to manage our
    testing. This can be done by adding our testing code in the `src/fib_calcs/fib_number.rs`
    file. The steps are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在[*第4章*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062)，*在Python中构建pip模块*，为我们Python代码构建了单元测试。在本节中，我们将为我们的斐波那契函数构建单元测试。这些测试不需要任何额外的包或依赖项。我们可以使用Cargo来管理我们的测试。这可以通过在`src/fib_calcs/fib_number.rs`文件中添加我们的测试代码来完成。步骤如下：
- en: 'We do this by creating a module in the `src/fib_calcs/fib_number.rs` file with
    the following code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在`src/fib_calcs/fib_number.rs`文件中创建一个模块来实现这一点，以下代码如下：
- en: '[PRE96]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Here, we can see that we have defined a module in the same file and decorated
    the module with the `#[cfg(test)]` macro.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们在同一文件中定义了一个模块，并用`#[cfg(test)]`宏装饰了这个模块。
- en: 'We can also see that we must import the function, as it is super to the module.
    Inside this module, we can run standard tests that check to see whether the integers
    we pass in calculate the Fibonacci number we expect with the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以看到我们必须导入这个函数，因为它在模块之上。在这个模块内部，我们可以运行标准测试，检查我们传入的整数是否使用以下代码计算出我们期望的斐波那契数：
- en: '[PRE97]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Here, we can see that we have decorated our test functions with the `#[test]`
    macro. If they do not produce the results that we expect, then `assert_eq!` and
    the test will fail. We also must note that our function will panic if we pass
    in zero or a negative value.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们用`#[test]`宏装饰了我们的测试函数。如果它们没有产生我们期望的结果，那么`assert_eq!`和测试将失败。我们还必须注意，如果我们传入零或负值，我们的函数将引发panic。
- en: 'These can be tested with the test functions, as shown next:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些可以通过测试函数进行测试，如下所示：
- en: '[PRE98]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Here, we pass in the failing inputs. If they do not panic, then the test will
    fail because we decorated it with the `#[should_panic]` macro.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们传入失败的输入。如果它们没有panic，那么测试将失败，因为我们用`#[should_panic]`宏装饰了它。
- en: 'Now that we have created our tests for the `fibonacci_number` function, we
    can build our test for our `fibonacci_numbers` function in the `src/fib_calcs/fib_numbers.rs`
    file with the following code:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为`fibonacci_number`函数创建了测试，我们可以在`src/fib_calcs/fib_numbers.rs`文件中构建我们的`fibonacci_numbers`函数测试，以下代码如下：
- en: '[PRE99]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Here, we can see that this has the same layout as our other tests. If we want
    to run our tests, we can run them with the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这与我们的其他测试有相同的布局。如果我们想运行我们的测试，我们可以使用以下命令来运行它们：
- en: '[PRE100]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This gives us the following printout:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '[PRE101]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Here, we can see that all of our tests have run and passed. If we recall [*Chapter
    4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062), *Building pip Modules in
    Python*, we'll remember that we used mocking.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到所有测试都已运行并通过。如果我们回想一下[*第4章*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062)，*在Python中构建pip模块*，我们会记得我们使用了模拟。
- en: 'Rust is still developing `mockall`, enables mocking and can be found at this
    URL: https://docs.rs/mockall/0.10.0/mockall/. Another cleaner crate that can be
    utilized for mocking can be found at this URL: [https://docs.rs/mocktopus/0.7.11/mocktopus/](https://docs.rs/mocktopus/0.7.11/mocktopus/).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Rust仍在开发`mockall`，支持模拟，可以在以下URL找到：[https://docs.rs/mockall/0.10.0/mockall/](https://docs.rs/mockall/0.10.0/mockall/)。另一个可以用于模拟的更干净的crate可以在以下URL找到：[https://docs.rs/mocktopus/0.7.11/mocktopus/](https://docs.rs/mocktopus/0.7.11/mocktopus/)。
- en: We have now covered how to build our module and test it. We are at the end of
    building a Rust `pip` module with tests and a Python interface. We can now test
    the speed of our Rust module to see what will happen and how powerful Rust modules
    as a tool are.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了如何构建我们的模块并对其进行测试。我们现在已经完成了带有测试和Python界面的Rust `pip`模块的构建。现在我们可以测试我们Rust模块的速度，看看会发生什么，以及Rust模块作为工具有多强大。
- en: Comparing speed with Python, Rust, and Numba
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较Python、Rust和Numba的速度
- en: 'We have now built a `pip` module in Rust with command-line tools, Python interfaces,
    and unit tests. This is a shiny new tool that we have. Let''s put it to the test.
    We know that Rust by itself is faster than Python. However, do we know that the
    `pyo3` bindings slow us down? Also, there is another way to speed up our Python
    code and this is with Numba, a Python package that compiles Python code to speed
    it up. Should we go through all of the haste of creating the Rust package if we
    can achieve the same speed with Numba? In this section, we will run our Fibonacci
    function several times, in Python, Numba, and our Rust module. It has to be noted
    that Numba can be a headache to install. For instance, I could not install it
    on my MacBook Pro M1\. I had to install Numba on a Linux laptop to run this section.
    You don''t have to run the code in this section; it is more for demonstrative
    purposes. If you do want to try and run the test script, then all of the steps
    are provided:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用命令行工具、Python接口和单元测试在Rust中构建了一个`pip`模块。这是我们拥有的一个闪亮的新工具。让我们对其进行测试。我们知道Rust本身比Python快。然而，我们知道`pyo3`绑定会减慢我们的速度吗？还有另一种加快Python代码速度的方法，那就是使用Numba，这是一个将Python代码编译以加快速度的Python包。如果我们可以用Numba达到同样的速度，我们还需要经历创建Rust包的所有匆忙吗？在本节中，我们将多次运行我们的Fibonacci函数，在Python、Numba和我们的Rust模块中。需要注意的是，Numba的安装可能会很头疼。例如，我无法在我的MacBook
    Pro M1上安装它。我不得不在一个Linux笔记本电脑上安装Numba来运行这一节。你不需要运行本节中的代码；这更多的是为了演示目的。如果你想尝试运行测试脚本，所有步骤都提供如下：
- en: 'First of all, we have to install the Rust `pip` module that we have built.
    We then install Numba with the following command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须安装我们构建的Rust `pip`模块。然后我们使用以下命令安装Numba：
- en: '[PRE102]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Once this is done, we have everything we need. In any Python script, we import
    the packages required with the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成这些，我们就有了所需的一切。在任何Python脚本中，我们使用以下代码导入所需的包：
- en: '[PRE103]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We are using the `time` module to time how long it takes for each run to happen.
    We also use the Fibonacci function from our Rust `pip` module, and we also require
    the `jit` decorator from Numba. **jit** stands for **just in time**. This is because
    Numba compiles the function when it loads it.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在使用`time`模块来计时每次运行所需的时间。我们还使用了来自我们的Rust `pip`模块的Fibonacci函数，并且还需要Numba的`jit`装饰器。**jit**代表**即时**。这是因为Numba在加载函数时对其进行编译。
- en: 'We now define our standard Python function with the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在使用以下代码定义我们的标准Python函数：
- en: '[PRE104]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We can see that this is the same logic that the Rust code is built with. We
    want to ensure that our tests are reputable comparisons. We then define the Python
    function that is compiled with `jit` with the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到，这是与Rust代码构建相同的逻辑。我们想要确保我们的测试是可靠的比较。然后我们使用以下代码定义用`jit`编译的Python函数：
- en: '[PRE105]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We can see that it is the same. The only difference is that we have decorated
    it with `jit` and set `nopython` to `True` to obtain optimal performance. We then
    run all of them with the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到，这是相同的。唯一的区别是我们用`jit`进行了装饰，并将`nopython`设置为`True`以获得最佳性能。然后我们使用以下代码运行所有这些：
- en: '[PRE106]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Here, we can see that we loop through a range from `0` to `30` and hit our function
    `30` times with the number `35`. We then print the time elapsed for this to happen.
    We notice that we have done this twice. This is because the first run will involve
    compiling the function.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们循环从 `0` 到 `30` 的范围，并使用数字 `35` 调用我们的函数 `30` 次。然后我们打印出完成这一过程所需的时间。我们注意到我们做了两次。这是因为第一次运行将涉及编译函数。
- en: 'When we run this, we get the following console printout:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，我们得到以下控制台输出：
- en: '[PRE107]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Here, we can see that some time is shaved off in the second run because it
    is not compiling. Running this several times shows that this reduction is standard.
    Now, we set up our standard Python test with the following code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到第二次运行时节省了一些时间，因为它没有进行编译。多次运行此测试表明这种减少是标准的。现在，我们使用以下代码设置我们的标准 Python
    测试：
- en: '[PRE108]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Running this test will get the following console printout:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此测试将得到以下控制台输出：
- en: '[PRE109]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We can see that there is a significant speed decrease when it comes to running
    pure Python code as opposed to our Numba function. Now, we can move on to the
    final test, which is our Rust test, defined with the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到，与我们的 Numba 函数相比，运行纯 Python 代码时速度会显著降低。现在，我们可以继续进行最后的测试，即我们的 Rust 测试，该测试由以下代码定义：
- en: '[PRE110]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Running this test gives us the following console printout:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此测试将给我们以下控制台输出：
- en: '[PRE111]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Here, we can see that the Rust function is a lot faster. This does not mean
    that `Numba` is a waste of time. When it comes to Python optimizations, Numba
    can perform well in certain situations. In other situations, the Python optimizations
    will not affect them at all. Considering how easy they are to apply, it is always
    worth checking to see whether there is a speed-up. However, we also now know that
    Rust will always be faster than pure Python code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 Rust 函数要快得多。这并不意味着 `Numba` 是浪费时间。当涉及到 Python 优化时，Numba 在某些情况下可以表现得很好。在其他情况下，Python
    优化根本不会影响它们。考虑到它们应用起来有多容易，始终值得检查是否可以加快速度。然而，我们现在也知道 Rust 总是比纯 Python 代码快。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have built a fully fleshed-out Python `pip` module with
    command-line tools, interfaces, and Rust code. We managed `gitignore` for both
    Rust and Python development. We then defined our setup tools for packaging our
    Python code and module with the compilation of Rust code that has Python bindings.
    Once these were defined, we learned how to build Rust functions that spanned multiple
    Rust files that could be wrapped in `pyo3` bindings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个完整的 Python `pip` 模块，其中包含命令行工具、接口和 Rust 代码。我们管理了 Rust 和 Python 开发的
    `gitignore`。然后我们定义了我们的设置工具，用于打包我们的 Python 代码和模块，以及具有 Python 绑定的 Rust 代码的编译。一旦这些定义完成，我们就学习了如何构建跨多个
    Rust 文件的 Rust 函数，这些函数可以用 `pyo3` 绑定包装。
- en: Our development did not just stop at Rust. We also explored Python's singleton
    and adapter design patterns to build more advanced Python interfaces for our users.
    We then tested our code with unit tests and speed checking. It must be noted that
    we did not cover GitHub actions in this chapter. GitHub actions are defined in
    the same way as they were in the previous chapter. Instead of running tests using
    the Python unit test, we run our tests using Cargo and so on. However, uploading
    to PyPI is a little more complicated. To cover this, examples on how to pre-compile
    and upload Rust `pip` modules are provided in the *Further reading* section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发并没有仅仅停留在 Rust 上。我们还探索了 Python 的单例和适配器设计模式，为我们的用户提供更高级的 Python 接口。然后我们使用单元测试和速度检查测试我们的代码。必须指出的是，我们本章没有涵盖
    GitHub actions。GitHub actions 与前一章中的定义方式相同。我们不是使用 Python 单元测试来运行测试，而是使用 Cargo
    等工具来运行我们的测试。然而，上传到 PyPI 要复杂一些。为了涵盖这一点，在 *进一步阅读* 部分提供了如何预编译和上传 Rust `pip` 模块的示例。
- en: We now have a powerful skill, which is building Python `pip` modules that utilize
    Rust. However, we leaned on our Python to build our interfaces. In the next chapter,
    we will work with Python objects within our Rust code. Therefore, we will be able
    to pass in more advanced Python data objects into our Rust code. We will also
    enable our Rust code to return fully fledged Python objects.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有一种强大的技能，那就是构建利用 Rust 的 Python `pip` 模块。然而，我们依赖 Python 来构建我们的接口。在下一章中，我们将在
    Rust 代码中处理 Python 对象。因此，我们将能够将更高级的 Python 数据对象传递到我们的 Rust 代码中。我们还将使我们的 Rust 代码能够返回完整的
    Python 对象。
- en: Questions
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you define a `setup.py` file for a `pyo3` Rust Python `pip` module?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何为 `pyo3` Rust Python `pip` 模块定义 `setup.py` 文件？
- en: What is the layout of our `pip` module in the Python environment after it has
    been installed? Also, why can we not build Python modules spanning multiple directories?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装后，我们的 `pip` 模块在 Python 环境中的布局是什么？为什么我们不能构建跨越多个目录的 Python 模块？
- en: What is a singleton design pattern?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是单例设计模式？
- en: What is an adapter design pattern and what are the advantages of using the design
    pattern?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器设计模式是什么？使用设计模式的优势是什么？
- en: What is a metaclass and how do we use it?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元类是什么？我们如何使用它？
- en: Answers
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Here, we must use the `dist` package to install `setuptools_rust` before we
    do anything else in the `setup.py` file. We define the parameters for the setup
    and use the `RustExtension` object from `setuptools_rust`, pointing to where the
    compiled Rust module will be once installed.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们进行 `setup.py` 文件中的任何其他操作之前，我们必须使用 `dist` 包来安装 `setuptools_rust`。我们定义设置参数并使用来自
    `setuptools_rust` 的 `RustExtension` 对象，指向编译好的 Rust 模块安装后的位置。
- en: When the `pip` module is installed, the binary Rust file is in the same directory
    where the Python files are defined for the module. However, directories in that
    directory are not copied over and, therefore, they will be lost during the installation.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `pip` 模块安装时，二进制的 Rust 文件位于定义模块 Python 文件的同一目录中。然而，该目录中的目录不会被复制，因此它们将在安装过程中丢失。
- en: A singleton design pattern ensures that all references to a particular class
    all point to one instance of that class.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单例设计模式确保所有对特定类的引用都指向该类的一个实例。
- en: The adapter pattern is an interface that manages the interaction between two
    modules. The advantage is the flexibility between the modules. We know where all
    the interactions are, and if we want to sever the modules, all we need to do is
    delete the adapter. This enables us to switch modules as and when we need them.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器模式是一种管理两个模块之间交互的接口。其优势在于模块之间的灵活性。我们知道所有交互的位置，如果我们想切断模块，我们只需要删除适配器。这使我们能够根据需要切换模块。
- en: A metaclass is a class that lies between a type and an object. Because of this,
    we can use this to see how we manage calling our objects.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元类位于类型和对象之间的一种类。正因为如此，我们可以用它来查看我们如何管理调用我们的对象。
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mre* – an example of GitHub actions for deploying Rust packages on PyPI (2021):
    [https://github.com/mre/hyperjson/blob/master/.github/workflows/ci.yml](https://github.com/mre/hyperjson/blob/master/.github/workflows/ci.yml%0D)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mre* – 在 PyPI 上部署 Rust 包的 GitHub Actions 示例（2021）: [https://github.com/mre/hyperjson/blob/master/.github/workflows/ci.yml](https://github.com/mre/hyperjson/blob/master/.github/workflows/ci.yml%0D)'
- en: '*Mastering Object-Oriented Python*, *Steven F. Lott*, *Packt Publishing* (2019)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《精通面向对象 Python》*，*Steven F. Lott*，*Packt Publishing*（2019）'
- en: '*The PyO3 user guide*: [https://pyo3.rs/v0.13.2/](https://pyo3.rs/v0.13.2/)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《PyO3 用户指南》*: [https://pyo3.rs/v0.13.2/](https://pyo3.rs/v0.13.2/)'
