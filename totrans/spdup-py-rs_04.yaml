- en: '*Chapter 5*: Creating a Rust Interface for Our pip Module'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062), *Building
    pip Modules in Python*, we built a `pip` module in Python. Now, we will build
    the same `pip` module in Rust and manage the interface. Some people might prefer
    Python for some tasks; others will state that Rust is better. In this chapter,
    we will simply utilize both as and when we want. To achieve this, we will build
    a `pip` module in Rust that can be installed and directly imported into our Python
    code. We will also build Python entry points that talk directly to our compiled
    Rust code, and Python adapters/interfaces to make the user experience of our module
    easy, safe, and locked down with **user interfaces** (**UIs**) that have all features
    that we want our user to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging Rust with `pip`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Rust interface with the `pyO3` crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building tests for our Rust package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing speed with Python, Rust, and Numba
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering these topics will enable us to build Rust modules and use them in our
    Python systems. This is a major advantage as a Python developer; you can use faster,
    safer, and less resource-intensive code seamlessly in your Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to have **Python 3** installed. To get the most out of this chapter,
    we will also need to have a GitHub account, as we will be using GitHub to package
    our code, which can be accessed via this link: [https://github.com/maxwellflitton/flitton-fib-rs](https://github.com/maxwellflitton/flitton-fib-rs).'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_five](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_five).
  prefs: []
  type: TYPE_NORMAL
- en: Packaging Rust with pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be setting up our `pip` package so that it can utilize
    Rust code. This will enable us to use Python setup tools to import our Rust `pip`
    package, compile it for our system, and use it within our Python code. For this
    chapter, we are essentially building the same Fibonacci module that we built in
    [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062), *Building pip Modules
    in Python*. It is advised to create another GitHub repository for our Rust module;
    however, nothing is stopping you from refactoring your existing Python `pip` module.
    To build our Rust `pip` module, we are going to have to carry out the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define `gitignore` and `Cargo` for our package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure a Python setup process for our package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Rust library for our package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define gitignore and Cargo for our package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we must make sure that our Git does not track files that we
    do not want to upload and that our `Cargo` has the right dependencies with *step
    1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can start with `gitignore`. If you are choosing to use the same GitHub
    repository as the one that we defined in the previous chapter, then all the files
    for Python are already defined in the `.gitignore` file at the root of the GitHub
    repository. If not, then when you are creating your new GitHub repository, we
    have to select the Python template in the `Add .gitignore` section. Either way,
    once we have the Python `gitignore` template in our `.gitignore` file, we must
    add our `gitignore` requirements for the Rust part of our package. To do this,
    we add the following code in the `.gitignore` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Yes, that is it for our Rust code. That is a lot less than the Python files
    that we need to ignore.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have defined `gitignore`, we can move on to defining our `Cargo.toml`
    file in the root of our package, initially defining the metadata of our package
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is nothing new; all we are doing here is defining the name and generic
    information of our package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then go on to define the dependencies with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that we have not defined any dependencies in the `dependencies` section.
    We will be depending on the `pyo3` crate to enable our Rust code to interact with
    our Python code. We declare the latest version of the crate at the point of writing
    this book, and the fact that we want to enable the `extension-module` feature
    because we will be using `pyo3` to make our Rust module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then define our library data with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It must be noted that we have defined a `crate-type` variable. Crate types provide
    information to the compiler on how to link Rust crates together. This can either
    be static or dynamic. For instance, if we were to define the `crate-type` variable
    as `bin`, this would compile our Rust code as a runnable executable. The main
    file would have to be present in our module, as this would be the entry point.
    We could also define the `crate-type` variable as `lib`, which compiles it as
    a library that can be used by other Rust programs. We can go further with this,
    defining either a static or dynamic library. Defining the `crate-type` variable
    as `cdylib` tells the compiler that we want a dynamic system library to be loaded
    by another language. If we do not put this in, we will not be able to compile
    our code when installing our library via `pip`. Our library should be able to
    compile for Linux and Windows. However, we require some link arguments to ensure
    that our library also works on macOS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to do this, we need to define the configuration in the `.cargo/config`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, we have defined all that we need for our Rust library. Now, we move
    on to the next step, configuring the Python part of our module.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Python setup process for our package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to setting up the Python section, we will be defining this in
    the `setup.py` file at the root of our module. Initially, we are going to import
    all the requirements that we need with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use the `setuptools_rust` module for managing our Rust code.
    However, we cannot be sure that the user will have installed `setuptools_rust`
    and we need it for running our setup code. Because of this, we cannot rely on
    the requirements list, as installing the requirements happens after we have imported
    `setuptools_rust`. To get around this, we use the `dist` module to get the required
    `setuptools_rust` module for this script. The user does not permanently install
    `setuptools_rust` but uses it for the script. Now that this is done, we can define
    our setup with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we define the metadata of the module as we did in the
    previous chapter. We can also see that we define a `rust_extensions` parameter,
    pointing to the actual Rust module that we will define in a Rust file, as we can
    see in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Our module flow for setup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Our module flow for setup
  prefs: []
  type: TYPE_NORMAL
- en: 'We also point to our `Cargo.toml` file, as we will have to compile other Rust
    crates that are in our dependencies when we are installing our Rust module. We
    also must state that our module is not zipped safely. This is also standard for
    C modules. Now that we have done all the setup configurations, we can now move
    on to the next step of building our basic Rust module that will get us installing
    Rust code using `pip install` that we can use in our Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our Rust code, we have to initially import all of the `pyo3` requirements
    in the `src/lib.rs` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What this does is enable our Rust code to utilize all the macros that the `pyo3`
    crate has. We will also be wrapping the Rust functions into the module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then define a basic *hello world* function with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that we have applied a Python function macro from `pyo3` to the `say_hello`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have the function, we can define our module in the same file with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we have defined the module as `flitton_fib_rs`. This will
    have to be imported as `flitton_fib_rs` when using it. We then use the `pymodule`
    macro. This function is loading the module. We must define a result at the end.
    Seeing as we do not have any complex logic, we will define the end result as an
    `Ok` result. We don't need to do anything to Python; however, we add our wrapped
    `say_hello` function to our module. The `wrap_pyfunction` macro essentially takes
    a Python instance and returns a Python function. Now that we have our Rust code
    defined, we must build our Python entry point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is fairly simple; all we have to do is import our functions from the Rust
    module in the `flitton_fib_rs/__init__.py` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will go through how this works later in this chapter, as we will be installing
    this package and running it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installing our Rust library for our package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, we have everything we need to deploy our package and install it via
    `pip`. Considering this, we upload our package to our GitHub repository, which
    is covered in the *Configuring setup tools for a Python pip module* section of
    the [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062), *Building pip
    Modules in Python*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have done this, we can install our `pip` package with the following
    command, all in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The URL to your GitHub repository might be different. When this is being installed,
    the process will hang for a while. The result should give the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because we are compiling the package based on our system. Here, we
    can see that we collect the code from the `main` branch of the repository and
    run the `setup.py` file. What we have essentially done is compile the Rust code
    into a binary file and put it next to our `__init__.py` entry point file with
    the following file layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is why our `from .flitton_fib_rs import *` code works in the entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that this is all installed in our Python packages, we can run our Python
    console and type in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here we have it! We have got Rust working with Python and we have managed to
    package our Rust code as a `pip` module. This is a complete game changer. We can
    now utilize Rust code without having to rewrite our Python systems. However, we
    only have one file in Rust code. We need to learn how to build bigger Rust systems
    if we want to fully take advantage of our ability to fuse Rust with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Rust interface with the pyO3 crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building an interface does not just mean adding more functions to our module
    in Rust and wrapping them. In a sense, we do have to do some of this; however,
    exploring how to import them from other Rust files is important. We also must
    explore and understand the relationship that we can have between Rust and Python
    when we are building up our module. To achieve this, we will carry out these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build our Fibonacci module in our Rust package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create command-line tools for our package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create adapters for our package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With *step one*, we can just build out our module with Rust code. *Steps two*
    and *three* are more Python-focused, wrapping our Rust code in Python code to
    ease the interaction of our Rust module with external Python code. In [*Chapter
    6*](B17720_06_Final_SK_ePub.xhtml#_idTextAnchor100), *Working with Python Objects
    in Rust*, we will interact directly with Python objects in our Rust code. With
    all this in mind, let's our Python interface by initially building our Fibonacci
    code in Rust with *step one*.
  prefs: []
  type: TYPE_NORMAL
- en: Building our Fibonacci Rust code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this step, we are going to build our Fibonacci module, spanning multiple
    Rust files. To achieve this, the file structure of our module takes the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we have added our Fibonacci code under the `src/fib_calcs`
    directory, as we remember that `fib_numbers.rs` relies on `fib_number.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can initially define our Fibonacci number function in the `fib_number.rs`
    file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we have imported the `pyfunction` macro to apply to our
    function. By now, we are familiar with calculating a Fibonacci number; however,
    unlike previous examples, it must be noted that we have removed the `if the input
    Fibonacci number to be calculated is 3` match statement. This is because that
    match statement significantly speeds up the code, and we want a fair speed comparison
    for the final section of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have defined our Fibonacci number function, we can define our `fibonacci_numbers`
    function in the `fib_numbers.rs` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we accepted a vector of integers, looped through them,
    and appended them to an empty vector, returning the vector with all the calculated
    Fibonacci numbers. Here, we have imported the `fibonacci_number` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, we remember that we will not be able to import it, and neither of
    these functions will be available outside of the immediate directory if we do
    not define them in the `src/mod.rs` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have defined both of our functions and declared them in our `src/mod.rs`
    file, we are now able to import them into our `lib.rs` file. We do this by initially
    declaring the `fib_calcs` module, and then importing the functions with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, it must be noted that our functions have the prefix of `__pyo3_get_function_`.
    This enables us to retain the macros applied to the functions. If we just directly
    import the functions, we will not be able to add them to the module, which will
    result in compilation errors when we are installing our package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that our functions are imported and ready, we can import-wrap them and
    add them to the module with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have built our modules, we can test them. We do this by uploading
    our changes to the GitHub repository, and using `pip uninstall` to uninstall our
    `pip` module and `pip install` to install our new package. Once our new package
    is installed, we can import and use our new functions in the Python terminal as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we can import and use the Fibonacci numbers that we have
    coded in Rust that span multiple files! We are now at the stage where nothing
    is stopping us from building our own Rust Python `pip` packages. If you have a
    specific problem in mind to solve in Rust, such as an expensive computation that
    your Python program is struggling to calculate, nothing is stopping you from solving
    that now.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone to the trouble of packaging our Python package written
    in Rust, we can further utilize our package with command-line functionality. Packages
    installed with `pip` are convenient, powerful tools for command-line functionality.
    In the next section, we will access the Rust code in our package directly from
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Creating command-line tools for our package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that to use our Fibonacci functions, we must start a Python
    console, import the functions, and use them. This is not very efficient if we
    just want to calculate a Fibonacci number in the console. We can remove these
    unnecessary procedures needed for calculating a Fibonacci number in the terminal
    by defining our entry points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering that we define our command-line entry points in the `setup.py`
    file, it makes sense to define our entry point in a Python file that acts as a
    wrapper to our Rust function (as we still want the speed benefits of Rust), as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Flow for module entry point'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Flow for module entry point
  prefs: []
  type: TYPE_NORMAL
- en: 'This wrapper can be done by importing `argparse` and the `fibonacci_number`
    function we made in the Rust module to create a simple Python function that gets
    user input and then passes it into the Rust function, printing out the result.
    We can achieve this by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build the Python function that collects the arguments and calls the
    Rust code by adding the following code to the `flitton_fib_rs/fib_number_command.py`
    file we create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We must remember that when our Rust binary is compiled, it will be in the `flitton_fib_rs`
    directory, right next to the file we just created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we define the entry point in the `setup.py` file. Now that we have our
    function, we can point to this in the `setup.py` file by declaring the path to
    this file and function for the `entry_points` parameter with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, we have fully plumbed up the Python entry point in our package.
    Finally, we can test our command line by passing in arguments to the entry point.
    Now, if we update our GitHub repository and reinstall our package in the Python
    environment, we can test our command line by typing in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that our command-line tools work. Now we are at the stage where we
    have replicated the same functionality as our Python `pip` package previously
    in [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062)*, Building pip
    Modules in Python*. However, we must go further now. We are fusing two different
    languages in our package. To gain full command of our `pip` package, we need to
    explore how to command and refine the interaction between Rust and Python.
  prefs: []
  type: TYPE_NORMAL
- en: In our next step, we will build adapters that enable us to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating adapters for our package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we try and build adapter interfaces, we need to understand what an **adapter**
    is. An adapter is a design pattern that manages the interface between two different
    modules, applications, languages, and so on. The title of the design pattern is
    descriptive of what we are doing. For instance, if you buy one of the new MacBook
    Pros, you will realize that you only have USB-C ports. Instead of opening your
    MacBook and rewiring it so that it can accept your standard USB memory stick,
    you buy an adapter. Adapters have multiple advantages. When it comes to modular
    software engineering, this gives us an advantage.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let's say that module A relies on module B. Instead of importing
    aspects of module B throughout module A, we can create adapters that manage the
    interface between both modules. This, in turn, gives us a lot of flexibility.
    For instance, module C could be built as an improvement on module B. Instead of
    working through module A looking for, and trying to root out, the uses of module
    B, we know that they are all utilized in the adapter. We can even produce a second
    adapter slowly moving over to module C in time. If we want to delete a module
    or move it out, again, our connection to another module can be severed instantly
    by just deleting the adapters. Adapters are simple and give us ultimate flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Considering what we have discussed about adapters, it makes sense that we create
    adapters between our Rust code and Python. Seeing as Python systems are essentially
    using our Rust code, it makes sense to build our adapters in Python.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to do this, we will create an adapter that accepts either
    a list or an integer. It then selects the right Rust function and implements it.
    However, for our purposes with this adapter, we can make up a scenario where there
    is a lot of incorrect data being fed into the module. We do not want it to error
    every time incorrect data is passed in, but we do want to categorize whether the
    calculation is a failure, and we want to count the number of correct calculations
    we do. This seems specific, and we must remember that, like the MacBook, we can
    have multiple adapters. Nothing is stopping us from chopping, changing, and deleting
    in the future if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we start writing code, we need to understand the layers involved
    for the adapter, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The layers of a Python adapter for a Rust module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – The layers of a Python adapter for a Rust module
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that Python objects come from types. However,
    we can interject how these objects are called from types with **metaclasses**.
    When it comes to metaclasses, we must build a metaclass that will define how our
    counter is called. Our counter is going to be universal. We do not know how the
    users will use our interface. They might loop through a list of data points, calling
    our adapter for each one. We need to ensure that no matter how many adapters are
    being called, they are all pointing to the same counter. This might be a little
    confusing. This will become clearer when we build it.
  prefs: []
  type: TYPE_NORMAL
- en: Using a singleton design pattern to build an adapter interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we must define our `Singleton` metaclass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done with the following code in the `flitton_fib_rs/singleton.py`
    file we create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that our `Singleton` class inherits directly from `type`. Here,
    what is happening is that we have a dictionary called `_instances`, where the
    keys to this dictionary are the class types. When a class that has `Singleton`
    as a metaclass is called, the type of that class is checked in the dictionary.
    If the type is not in the dictionary, then it is constructed and put into the
    dictionary. The instance in the dictionary is then returned. What this essentially
    means is that we cannot have two instances of a class. This process is laid out
    in the following figure:![Figure 5.4 – The logic flow for a Singleton metaclass
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B17720.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.4 – The logic flow for a Singleton metaclass
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will use our `Singleton` class to construct our counter. This can be
    done with the following code in the `flitton_fib_rs/counter.py` file that we create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, our `Counter` class cannot be constructed twice in the same program. Therefore,
    we can ensure that there will only be one `Counter` class, no matter how many
    times we call it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now use it on our main adapter. We will house our main adapter in the
    `flitton_fib_rs/fib_number_adapter.py` file that we create. First of all, we import
    all of the functions and objects that we need with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we have imported the typing that we need. We have also
    imported the Rust Fibonacci numbers that we will be using and our counter. Now
    that we have imported what we need, we can build our interface constructor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For our adapter, we will need to have a number input, a status of whether the
    process is successful or not, along with the actual result, which will be the
    calculated Fibonacci number, or an error message if there is a failure. We will
    also have a counter, and we will have to process the input during the construction
    of the object. This can be denoted with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember, even though we call the counter, it is a singleton pattern; therefore,
    the counter will be the same instance across all instances of the adapter. Now
    that all of the correct attributes have been defined, we have to define what is
    an actual success.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is where we state that success is `True`, and we increase the counter
    by one. This can be denoted by the `FlittonFibNumberAdapter` instance function,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is smooth; because we have defined a clean interface for the counter, there
    is little explanation needed. Now that we have our success defined, we need to
    process the input because there are two different functions, one that takes a
    list and one that takes an integer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can pass in the correct input to the correct function with the `FlittonFibNumberAdapter`
    instance function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we define an error message if there isn't a list of integers
    passed in. If we do pass in the correct input, we define the result as the result
    of the function and call the `_define_success` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The only thing left is to expose the count for the outside user. This can be
    done with the following `FlittonFibNumberAdapter` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, the counter interface is clean, so no explanation is needed. Our adapter
    interface is now completed. All we need to do is expose it to the user by importing
    it into the `src/__init__.py` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Everything is done. We can now update our GitHub repository and reinstall our
    package in the Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our adapter interface in the Python console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can now test our adapter with the Python console commands, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we can import our adapter from the module. We can then
    define two different adapters. We can see that the count is consistent across
    both adapters, which means that our singleton pattern works! Both adapters are
    pointing to the same `Counter` instance! All of our adapters will point to that
    same `Counter` instance. We can also see that the success is `True`, and we can
    access the result of the calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the same Python console, we can test to see whether an incorrect input
    results in a failure and doesn''t increase the count with the Python console commands
    shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can see that the count hasn''t increased, the success is `False`,
    and that there is an error message. The final input test can be done by inputting
    a list of integers with the Python console command shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling them in the same Python console command reveals whether this is true,
    as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There we have it. We have fully configured the Python interface of our module.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we built our Rust `pip` package with a Python interface. You
    might be tempted to add extra directories and flesh out entire Python modules
    in the `flitton_fib_rs` directory. However, extra directories in the `flitton_fib_rs`
    directory do not get copied over when the package is being installed. This is
    fine as well. We are essentially building Rust `pip` packages. Rust is fast and
    safe, and we should be leaning on this as much as we can. The Python adapters
    and command in the `flitton_fib_rs` directory should be there to smooth over the
    interface. For instance, if we want the memory of our interface to be managed
    in a particular way, it makes sense to do this in the interface of Python as a
    wrapper, as Python will be the system that is importing and using the `pip` package.
    If you find yourself putting anything other than adapters and command-line functions
    in the `flitton_fib_rs` module, that is a warning sign that you should try and
    consider putting it in the Rust module itself. We have tested our package manually;
    however, we need to ensure that our Rust Fibonacci calculation functions do as
    we expect.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be creating unit tests for our Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: Building tests for our Rust package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, in [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062),
    *Building pip Modules in Python*, we built unit tests for our Python code. In
    this section, we will build unit tests for our Fibonacci functions. These tests
    do not need any extra packages or dependencies. We can use Cargo to manage our
    testing. This can be done by adding our testing code in the `src/fib_calcs/fib_number.rs`
    file. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this by creating a module in the `src/fib_calcs/fib_number.rs` file with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we have defined a module in the same file and decorated
    the module with the `#[cfg(test)]` macro.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also see that we must import the function, as it is super to the module.
    Inside this module, we can run standard tests that check to see whether the integers
    we pass in calculate the Fibonacci number we expect with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we have decorated our test functions with the `#[test]`
    macro. If they do not produce the results that we expect, then `assert_eq!` and
    the test will fail. We also must note that our function will panic if we pass
    in zero or a negative value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These can be tested with the test functions, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we pass in the failing inputs. If they do not panic, then the test will
    fail because we decorated it with the `#[should_panic]` macro.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have created our tests for the `fibonacci_number` function, we
    can build our test for our `fibonacci_numbers` function in the `src/fib_calcs/fib_numbers.rs`
    file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can see that this has the same layout as our other tests. If we want
    to run our tests, we can run them with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us the following printout:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that all of our tests have run and passed. If we recall [*Chapter
    4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062), *Building pip Modules in
    Python*, we'll remember that we used mocking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust is still developing `mockall`, enables mocking and can be found at this
    URL: https://docs.rs/mockall/0.10.0/mockall/. Another cleaner crate that can be
    utilized for mocking can be found at this URL: [https://docs.rs/mocktopus/0.7.11/mocktopus/](https://docs.rs/mocktopus/0.7.11/mocktopus/).'
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered how to build our module and test it. We are at the end of
    building a Rust `pip` module with tests and a Python interface. We can now test
    the speed of our Rust module to see what will happen and how powerful Rust modules
    as a tool are.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing speed with Python, Rust, and Numba
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now built a `pip` module in Rust with command-line tools, Python interfaces,
    and unit tests. This is a shiny new tool that we have. Let''s put it to the test.
    We know that Rust by itself is faster than Python. However, do we know that the
    `pyo3` bindings slow us down? Also, there is another way to speed up our Python
    code and this is with Numba, a Python package that compiles Python code to speed
    it up. Should we go through all of the haste of creating the Rust package if we
    can achieve the same speed with Numba? In this section, we will run our Fibonacci
    function several times, in Python, Numba, and our Rust module. It has to be noted
    that Numba can be a headache to install. For instance, I could not install it
    on my MacBook Pro M1\. I had to install Numba on a Linux laptop to run this section.
    You don''t have to run the code in this section; it is more for demonstrative
    purposes. If you do want to try and run the test script, then all of the steps
    are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to install the Rust `pip` module that we have built.
    We then install Numba with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, we have everything we need. In any Python script, we import
    the packages required with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using the `time` module to time how long it takes for each run to happen.
    We also use the Fibonacci function from our Rust `pip` module, and we also require
    the `jit` decorator from Numba. **jit** stands for **just in time**. This is because
    Numba compiles the function when it loads it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now define our standard Python function with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see that this is the same logic that the Rust code is built with. We
    want to ensure that our tests are reputable comparisons. We then define the Python
    function that is compiled with `jit` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see that it is the same. The only difference is that we have decorated
    it with `jit` and set `nopython` to `True` to obtain optimal performance. We then
    run all of them with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we loop through a range from `0` to `30` and hit our function
    `30` times with the number `35`. We then print the time elapsed for this to happen.
    We notice that we have done this twice. This is because the first run will involve
    compiling the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we run this, we get the following console printout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can see that some time is shaved off in the second run because it
    is not compiling. Running this several times shows that this reduction is standard.
    Now, we set up our standard Python test with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this test will get the following console printout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see that there is a significant speed decrease when it comes to running
    pure Python code as opposed to our Numba function. Now, we can move on to the
    final test, which is our Rust test, defined with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this test gives us the following console printout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that the Rust function is a lot faster. This does not mean
    that `Numba` is a waste of time. When it comes to Python optimizations, Numba
    can perform well in certain situations. In other situations, the Python optimizations
    will not affect them at all. Considering how easy they are to apply, it is always
    worth checking to see whether there is a speed-up. However, we also now know that
    Rust will always be faster than pure Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have built a fully fleshed-out Python `pip` module with
    command-line tools, interfaces, and Rust code. We managed `gitignore` for both
    Rust and Python development. We then defined our setup tools for packaging our
    Python code and module with the compilation of Rust code that has Python bindings.
    Once these were defined, we learned how to build Rust functions that spanned multiple
    Rust files that could be wrapped in `pyo3` bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Our development did not just stop at Rust. We also explored Python's singleton
    and adapter design patterns to build more advanced Python interfaces for our users.
    We then tested our code with unit tests and speed checking. It must be noted that
    we did not cover GitHub actions in this chapter. GitHub actions are defined in
    the same way as they were in the previous chapter. Instead of running tests using
    the Python unit test, we run our tests using Cargo and so on. However, uploading
    to PyPI is a little more complicated. To cover this, examples on how to pre-compile
    and upload Rust `pip` modules are provided in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a powerful skill, which is building Python `pip` modules that utilize
    Rust. However, we leaned on our Python to build our interfaces. In the next chapter,
    we will work with Python objects within our Rust code. Therefore, we will be able
    to pass in more advanced Python data objects into our Rust code. We will also
    enable our Rust code to return fully fledged Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you define a `setup.py` file for a `pyo3` Rust Python `pip` module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the layout of our `pip` module in the Python environment after it has
    been installed? Also, why can we not build Python modules spanning multiple directories?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a singleton design pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an adapter design pattern and what are the advantages of using the design
    pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a metaclass and how do we use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we must use the `dist` package to install `setuptools_rust` before we
    do anything else in the `setup.py` file. We define the parameters for the setup
    and use the `RustExtension` object from `setuptools_rust`, pointing to where the
    compiled Rust module will be once installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `pip` module is installed, the binary Rust file is in the same directory
    where the Python files are defined for the module. However, directories in that
    directory are not copied over and, therefore, they will be lost during the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A singleton design pattern ensures that all references to a particular class
    all point to one instance of that class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The adapter pattern is an interface that manages the interaction between two
    modules. The advantage is the flexibility between the modules. We know where all
    the interactions are, and if we want to sever the modules, all we need to do is
    delete the adapter. This enables us to switch modules as and when we need them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A metaclass is a class that lies between a type and an object. Because of this,
    we can use this to see how we manage calling our objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mre* – an example of GitHub actions for deploying Rust packages on PyPI (2021):
    [https://github.com/mre/hyperjson/blob/master/.github/workflows/ci.yml](https://github.com/mre/hyperjson/blob/master/.github/workflows/ci.yml%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Object-Oriented Python*, *Steven F. Lott*, *Packt Publishing* (2019)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The PyO3 user guide*: [https://pyo3.rs/v0.13.2/](https://pyo3.rs/v0.13.2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
