["```rs\n// see code in Chapter 6/code/lifetimes.rs\t\nfn main() {\nlet n = 42u32;\nlet n2 = n; // a copy of the value from n to n2\nlife(n);\nprintln!(\"{}\", m);  // error: unresolved name `m`.\nprintln!(\"{}\", o);  // error: unresolved name `o`.\n}\n\nfn life(m: u32) -> u32 {\n    let o = m;\n    o\n}\n```", "```rs\n{\n    let phi = 1.618;\n}\nprintln!(\"The value of phi is {}\", phi); // is error\n```", "```rs\nfn transform<'a>(s: &'a str) { /* ... */ }\n\n```", "```rs\nfn transform_without_lifetime(s: &str) { /* ... */ }\n```", "```rs\nstruct Magician {\n  name: &'static str,\n  power: u32\n}\n```", "```rs\nfn return_magician<'a>() -> &'a Magician {\n  let mag = Magician { name: \"Gandalf\", power: 4625};\n  &mag \n}\n```", "```rs\nstruct MagicNumbers {\n  magn1: &u32,\n  magn2: &u32\n}\n```", "```rs\nstruct MagicNumbers<'a> {\n  magn1: &'a u32,\n  magn2: &'a u32\n}\n```", "```rs\n// see code in Chapter 6/exercises/dangling_pointer.rs:\nfn main() {\n    let m: &u32 = { \n        let n = &5u32; \n        &*n\n    }; \n    let o = *m;\n}\n```", "```rs\nlet mut x = &3;\n{\n  let mut y = 4;\n  x = &y; \n}\n```", "```rs\nlet n = 42u32;\n// no move, only a copy of the value:\nlet n2 = n;\nlife(n);\nfn life(m: u32) -> u32 {\n    let o = m;\n    o\n}\n```", "```rs\n    struct MagicNumber {\n        value: u64\n    }\n    impl Copy for MagicNumber {}\n    ```", "```rs\n    #[derive(Copy)]\n    struct MagicNumber {\n        value: u64\n    }\n    ```", "```rs\nlet mag = MagicNumber {value: 42};\nlet mag2 = mag;\n```", "```rs\nprintln!(\"{:?}\", &mag as *const MagicNumber); // address is 0x23fa88\nprintln!(\"{:?}\", &mag2 as *const MagicNumber); // address is 0x23fa80\n```", "```rs\n#[derive(Clone)]\nstruct MagicNumber {\n    value: u64\n}\n```", "```rs\nlet mag3 = mag.clone();\nprintln!(\"{:?}\", &mag3 as *const MagicNumber); // address is 0x23fa78\n```", "```rs\n// see code in Chapter 6/code/references.rs:\nlet m = &n;\nprintln!(\"The address of n is {:p}\", m);\nprintln!(\"The value of n is {}\", *m);\nprintln!(\"The value of n is {}\", m);\n```", "```rs\nThe address of n is 0x23fb34 \nThe value of n is 42\nThe value of n is 42\n```", "```rs\n  let q = &42;\n  println!(\"{}\", square(q)); // 1764\nfn square(k: &i32) -> i32 {\n    *k * *k\n}\n```", "```rs\nlet o = &n;\nprintln!(\"The address of n is {:p}\", o);\nprintln!(\"The value of n is {}\", *o); \n```", "```rs\nThe address of n is 0x23fb34\nThe value of n is 42\n```", "```rs\n let mut u = 3.14f64;\n let v = &mut u;\n  *v = 3.15;\n  println!(\"The value of u is now {}\", *v);\n```", "```rs\nlet mut m = 7;\nadd_three_to_magic(&mut m);\nprintln!(\"{}\", m);  // prints out 10\n```", "```rs\nfn add_three_to_magic(num: &mut i32) {\n    *num += 3;  // value is changed in place through +=\n}\n```", "```rs\n// see code in Chapter 6/code/ref.rs\t\nfn main() {\n  let n = 42;\n  match n {\n ref r => println!(\"Got a reference to {}\", r),\n  }\n  let mut m = 42;\n  match m {\n ref mut mr => {\n        println!(\"Got a mutable reference to {}\", mr);\n        *mr = 43;\n      },\n  }\n  println!(\"m has changed to {}!\", m);\n}\n```", "```rs\nGot a reference to 42\nGot a mutable reference to 42\nm has changed to 43!\n```", "```rs\nlet mag = Magician { name: \"Gandalf\", power: 4625};\nlet name = {\n    let Magician { name: ref ref_to_name, power: _ } = mag;\n    *ref_to_name\n};\nprintln!(\"The magician's name is {}\", name);\n```", "```rs\n// see code in Chapter 6/code/ownership1.rs\nstruct Alien {\n  planet: String,\n  n_tentacles: u32\n}\n\nfn main() {\n  let mut klaatu = Alien{ planet: \"Venus\".to_string(),\n  n_tentacles: 15 };\n}\n```", "```rs\nlet kl2 = klaatu;\n```", "```rs\nprintln!(\"{}\", klaatu.planet); \n```", "```rs\n  kl2.n_tentacles = 14;\n  println!(\"{} - {}\", kl2.planet, kl2.n_tentacles);\n```", "```rs\n  klaatu.planet = \"Pluto\".to_string();\n```", "```rs\n  println!(\"{} - {}\", klaatu.planet, klaatu.n_tentacles);\n```", "```rs\n// see code in Chapter 6/code/ownership2.rs\nfn main() {\n  let mut klaatu = Alien{ planet: \"Venus\".to_string(), n_tentacles: 15 };\n  {\n    let kl2 = &mut klaatu;\n    kl2).n_tentacles = 14;\n    println!(\"{} - {}\", kl2.planet, kl2.n_tentacles); \n// prints: Venus - 14\n  }\n}\n```", "```rs\n  println!(\"{} - {}\", klaatu.planet, klaatu.n_tentacles);  klaatu.planet = \"Pluto\".to_string();\n  println!(\"{} - {}\", klaatu.planet, klaatu.n_tentacles); \n```", "```rs\nVenus – 10\nPluto – 10.\n```", "```rs\n// see code in Chapter 6/code/boxes1.rs\t\nlet mut a1 = Box::new(Alien{ planet: \"Mars\".to_string(), n_tentacles: 4 });\nprintln!(\"{}\", a1.n_tentacles); // 4\n```", "```rs\nlet a2 = &mut a1;\nprintln!(\"{}\", a2.planet ); // Mars\na2.n_tentacles = 5;\n```", "```rs\n// error: cannot borrow `a1.n_tentacles` as immutable because `a1` is also borrowed as mutable\n// println!(\"{}\", a1.n_tentacles); // is error!\n// error: cannot assign to `a1.planet` because it is borrowed\na1.planet = \"Pluto\".to_string();  // is error!\n```", "```rs\n  let n = Box::new(42);\n```", "```rs\n      *n = 67; \n```", "```rs\nlet q = &*n;\nprintln!(\"{}\", q); // 42\n```", "```rs\n// see code in Chapter 6/code/boxes2.rs\t\nlet n = Box::new(42);\nlet mut m = n;\n*m = 67;\n// println!(\"{}\", n); // error: use of moved value: `n`\nprintln!(\"{}\", m); // 67\n```", "```rs\nlet mut a1 = Box::new(Alien{ planet: \"Mars\".to_string(), n_tentacles: 4 });\nlet a2 = a1;\nprintln!(\"{}\", a2.n_tentacles); // 4\n```", "```rs\nuse_alien(a2);\n// Following line gives the error: use of moved value: `a2.n_tentacles`\n// println!(\"{}\", a2.n_tentacles); \n} // end of main() function\n\nfn use_alien(a: Box<Alien>) {\n  println!(\"An alien from planet {} is freed after the closing brace\", a.planet);\n}\n```", "```rs\nfn use_alien2(a: &Alien) {\n  println!(\"An alien from planet {} is freed\", a.planet);\n}\n```", "```rs\nstruct Recurs {\n    list: Vec<u8>,\n    rec_list: Option<Box<Recurs>>\n}\n```", "```rs\nstruct Alien {\n    name: String,\n    n_tentacles: u8\n}\n\nstruct Tentacle {\n    poison: u8,\n    owner: Alien\n}\n\nfn main() {\nlet dhark = Alien { name: \"Dharkalen\".to_string(), n_tentacles: 7 };\n   // defining dhark's tentacles:\n    for i in 1u8..dhark.n_tentacles {\n        Tentacle { poison: i * 3, owner: dhark }; // <- error!\n    }\n}\n```", "```rs\n// see code in Chapter 6/code/refcount.rs\nuse std::rc::Rc;\n#[derive(Debug)]\nstruct Alien {\n    name: String,\n    n_tentacles: u8\n}\n#[derive(Debug)]\nstruct Tentacle {\n    poison: u8,\n owner: Rc<Alien>\n}\n\nfn main() {\n  let dhark = Alien { name: \"Dharkalen\".to_string(), no_tentacles: 7 };\n let dhark_master = Rc::new(dhark);\n  for i in 1u8..dhark_master.n_tentacles {\n let t = Tentacle { poison: i * 3, owner: dhark_master.clone() };\n println!(\"{:?}\", t);\n  }\n}\n```", "```rs\nTentacle { poison: 3, owner: Alien { name: \"Dharkalen\", n_tentacles: 7 } }\nTentacle { poison: 6, owner: Alien { name: \"Dharkalen\", n_tentacles: 7 } }\n…\nTentacle { poison: 18, owner: Alien { name: \"Dharkalen\", n_tentacles: 7 } }\n```"]