- en: Advanced Rust Tools and Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Rust 工具和库
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Setting up rustup
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 rustup
- en: Setting up rustfmt
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 rustfmt
- en: Setting up rust-clippy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 rust-clippy
- en: Setting up and testing with Servo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和测试 Servo
- en: Generating random numbers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数
- en: Writing lines to a file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将行写入文件
- en: Parsing unstructured JSON
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析无结构 JSON
- en: Parsing URL from a string
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串中解析 URL
- en: Decompressing a tarball
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解压 tarball
- en: Compressing a directory to a tarball
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将目录压缩成 tarball
- en: Finding file extensions recursively
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归查找文件扩展名
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, you will learn about the various Rust tools, such as rustfmt
    and rustup, that help us write better production level Rust code, catch errors,
    and also provide us with the equipment to do extreme experimentation with different
    versions of the Rust compiler. Apart from these tools, we will set up and understand
    the Servo project, which is a state-of-the-art browsing engine that contributes
    a lot to the design of the Rust language. The last few recipes of this chapter
    will take the readers through the different ground-level libraries in Rust that
    contribute a lot to faster project development, by providing the developer with
    various common operations and functionalities out of the box.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解各种 Rust 工具，如 rustfmt 和 rustup，这些工具帮助我们编写更好的生产级 Rust 代码，捕获错误，并提供进行 Rust
    编译器不同版本极端实验的设备。除了这些工具，我们还将设置并理解 Servo 项目，这是一个最先进的浏览器引擎，对 Rust 语言的许多设计做出了贡献。本章的最后几个菜谱将引导读者了解
    Rust 中对项目开发速度有很大贡献的不同底层库，这些库为开发者提供了各种开箱即用的常见操作和功能。
- en: Setting up rustup
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 rustup
- en: In this recipe, you will learn the different options available with the rustup
    tool that enable us to run the Rust applications in different versions and many
    more related functionalities.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解 rustup 工具的不同选项，这些选项使我们能够在不同版本中运行 Rust 应用程序，以及更多相关功能。
- en: The rustup tool is the official Rust language installer for rustc, Cargo, and
    other standard tools to Cargo's `bin` directory. On Unix, it is located at `$HOME/.cargo/bin`
    and on Windows at `%USERPROFILE%\.cargo\bin`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: rustup 工具是 rustc、Cargo 以及其他标准工具的官方 Rust 语言安装程序，用于将它们安装到 Cargo 的 `bin` 目录。在 Unix
    上，它位于 `$HOME/.cargo/bin`，在 Windows 上位于 `%USERPROFILE%\.cargo\bin`。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need to set up the rustup tool in order to perform the different activities
    of this recipe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个菜谱的不同活动，我们需要设置 rustup 工具。
- en: 'Follow the steps to install the rustup tool:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤安装 rustup 工具：
- en: 'Check for the version of the Rust compiler:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 Rust 编译器的版本：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we are able to get an output such as `rustc 1.18.0 (03fc9d622 2017-06-06)`,
    this means that the rustup tool is set up. The version number may change according
    to the stable version last downloaded in the system.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们能够得到类似 `rustc 1.18.0 (03fc9d622 2017-06-06)` 的输出，这意味着 rustup 工具已设置好。版本号可能会根据系统最后下载的稳定版本而改变。
- en: 'If you are not able to get the compiler version, follow the installation recipes
    from [Chapter 1](rs-cb_ch01.html), *Let''s Make System Programming Great Again*,
    or run the following command in the Terminal:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你无法获取编译器版本，请遵循 [第 1 章](rs-cb_ch01.html) 的安装菜谱，“让我们再次让系统编程变得伟大”，或在终端中运行以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the steps to implement this recipe:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个菜谱：
- en: 'Update the stable version of Rust to the latest version:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Rust 的稳定版本更新到最新版本：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Update the `rustup` tool to the latest version:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `rustup` 工具更新到最新版本：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install the `nightly` toolkit version of the Rust compiler:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Rust 编译器的 `nightly` 工具包版本：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the `nightly` version of Rust without changing the default version of Rust:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Rust 的 `nightly` 版本而不更改 Rust 的默认版本：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Change the `default` version of the Rust compiler to the `nightly` version:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Rust 编译器的 `default` 版本更改为 `nightly` 版本：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update the `nightly` version of Rust:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 Rust 的 `nightly` 版本：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will update both the stable and nightly versions of the Rust compiler.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将更新 Rust 编译器的稳定和 `nightly` 版本。
- en: 'We should get the following output on execution of the rustup tool:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 rustup 工具时，我们应该得到以下输出：
- en: 'On installation of the nightly version:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安装 `nightly` 版本时：
- en: '![](img/a3a9d203-88ab-41ae-b234-c3b59abda0ad.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3a9d203-88ab-41ae-b234-c3b59abda0ad.png)'
- en: 'Setting nightly as the default version:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `nightly` 设置为默认版本：
- en: '![](img/b37e7382-d0bf-4f7b-b9a2-5046a88c437e.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b37e7382-d0bf-4f7b-b9a2-5046a88c437e.png)'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`rustup` is a toolchain multiplexer that installs and manages many Rust toolchains,
    and all of them are present in a single set of tools located at `~/.cargo/bin`.
    As we run examples, `rustup` provides mechanisms to easily change the active toolchain,
    such as `rustc` and `cargo` at `~/.cargo/bin`, by reconfiguring the locations
    in the background.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustup`是一个工具链多路复用器，它安装并管理许多Rust工具链，并且所有这些工具链都位于单个工具集中，位于`~/.cargo/bin`。当我们运行示例时，`rustup`提供机制以轻松更改活动工具链，例如`rustc`和`cargo`位于`~/.cargo/bin`，通过在后台重新配置位置。'
- en: When `rustup` is installed for the first time, the compiler rustc will be present
    in `$HOME/.cargo/bin/rustc`, which, by default, is the stable version. If you
    later change the default toolchain to nightly with commands such as `rustup install
    nightly` and `rustup default nightly`, the location will change and the nightly
    compiler will run instead of the stable one.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当`rustup`首次安装时，编译器`rustc`将位于`$HOME/.cargo/bin/rustc`，默认情况下是稳定版本。如果你后来使用如`rustup
    install nightly`和`rustup default nightly`等命令将默认工具链更改为夜间版，位置将改变，并将运行夜间编译器而不是稳定版本。
- en: 'The `rustup update` command basically helps us fetch the latest version of
    the compiler. Rust is distributed on three different release channels: stable,
    beta, and nightly. rustup is configured to use the stable channel by default,
    which represents the latest release of Rust and is released every six weeks.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustup update`命令基本上帮助我们获取编译器的最新版本。Rust分布在三个不同的发布渠道：稳定版、测试版和夜间版。`rustup`默认配置为使用稳定渠道，它代表了Rust的最新发布版本，每六周发布一次。'
- en: Setting up rustfmt
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置`rustfmt`
- en: In this recipe, you will learn the steps by which one can set up and use the
    `rustfmt` tool in their day-to-day Rust project development. `rustfmt` is a tool
    for formatting the Rust code according to standard style guidelines of the Rust
    language. It is an open source project and welcomes contribution from the Rust
    community members. The style guides are decided by the Rust **request for comments**
    (**RFC**) procedure, which is an open discussion about the Rust language changes,
    such as feature requests, bug fixes, and documentation. This is a very important
    character trait for a programming language as it gives more authority to the developer
    community than the company that originated the language.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何设置和使用`rustfmt`工具，以便在日常Rust项目开发中使用。`rustfmt`是一个根据Rust语言的标准样式指南格式化Rust代码的工具。它是一个开源项目，欢迎Rust社区成员的贡献。样式指南由Rust**请求评论**（**RFC**）程序决定，这是一个关于Rust语言变化的开放讨论，例如功能请求、错误修复和文档。这对于编程语言来说是一个非常重要的特性，因为它赋予了开发者社区比语言起源公司更多的权威。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will follow the steps to set up the tool:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下步骤设置工具：
- en: 'Install the nightly version of the Rust compiler:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Rust编译器的夜间版：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Set up the Rust compiler version to the nightly toolchain:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Rust编译器版本设置为夜间工具链：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new Rust project using Cargo and install the `rustfmt` tool:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Cargo创建一个新的Rust项目并安装`rustfmt`工具：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should get the following output on installing the `rustfmt` tool if everything
    works fine without any errors:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利且没有错误，安装`rustfmt`工具时应得到以下输出：
- en: '![](img/ca353f50-a1ad-468b-9b99-2a5fc7164b39.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca353f50-a1ad-468b-9b99-2a5fc7164b39.png)'
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the steps to implement this recipe:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实施此食谱：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你首选的文本编辑器中打开`src`目录下的`main.rs`文件。
- en: 'Write the code header with the relevant information, but the catch here is
    that we purposefully impose incorrect indentations:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头，但这里的难点在于我们故意使用了错误的缩进：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the `main` function with some random spacing and style:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义带有一些随机间距和样式的`main`函数：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, run `rustfmt` to fix the style issues of the code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行`rustfmt`以修复代码的样式问题：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should get the following output on successfully executing the preceding
    code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行前面的代码后，你应该得到以下输出：
- en: '![](img/fbc45fd6-f502-4718-9d7f-231ffce4253d.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbc45fd6-f502-4718-9d7f-231ffce4253d.png)'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we basically introduce the `rustfmt` tool that helps us follow
    the correct style guide implied by the Rust programming language in an automated
    manner, where the developer can freely use the tool to follow style standards.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们主要介绍了`rustfmt`工具，该工具以自动化的方式帮助我们遵循Rust编程语言隐含的正确样式指南，其中开发者可以自由使用该工具来遵循样式标准。
- en: From the output of the `main.rs` file, we can see that the wrong indentation
    in the code was automatically corrected and overwritten in the `main.rs` file
    with the `cargo fmt` command, and that a backup of the previous code was saved
    in the `main.rs.bk` file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `main.rs` 文件的输出中，我们可以看到代码中的错误缩进被自动纠正并覆盖，使用 `cargo fmt` 命令在 `main.rs` 文件中，并且之前的代码备份保存在
    `main.rs.bk` 文件中。
- en: 'There are various modes in which we can run the `rustfmt` tool, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以各种方式运行 `rustfmt` 工具，如下所示：
- en: '`replace`: This is the default selection that overwrites the original files
    and creates backup files after formatting; `cargo fmt` uses `--write-mode=replace`
    by default.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`：这是默认选择，它会覆盖原始文件并在格式化后创建备份文件；`cargo fmt` 默认使用 `--write-mode=replace`。'
- en: '`overwrite`: This option basically changes the original files without creating
    a backup of the previous code.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overwrite`：此选项基本上会更改原始文件，而不会创建先前代码的备份。'
- en: '`display`: This option basically prints the formatted files to `stdout`, that
    shows the changes made in the terminal screen.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display`：此选项基本上将格式化后的文件打印到 `stdout`，在终端屏幕上显示所做的更改。'
- en: '`diff`: This option prints the difference between the original files and formatted
    files to `stdout`. This will also exit with an error code if there are any differences.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`diff`：此选项将原始文件和格式化文件之间的差异打印到 `stdout`。如果存在任何差异，它还将以错误代码退出。'
- en: '`checkstyle`: This option will output the lines that need to be corrected as
    a checkstyle XML file that can be used with tools such as Jenkins.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkstyle`：此选项将以 checkstyle XML 文件的形式输出需要纠正的行，该文件可用于 Jenkins 等工具。'
- en: 'In order to use these write modes, we need to install the `rustfmt` tool by
    source, where we clone the main GitHub repository and install from the source
    with the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这些写入模式，我们需要通过源代码安装 `rustfmt` 工具，即克隆主 GitHub 仓库并使用以下代码从源代码安装：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This enables us to run formatting commands on any Rust files with various modes,
    such as the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够以各种模式运行格式化命令，例如以下示例：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is a good practice to run the `rustfmt` tool before building the project
    so that we can maintain code standards without much effort. The ideal way to do
    this is to configure the `rustfmt` tool in your favorite text editor and have
    the `rustfmt` commands as a part of the build process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建项目之前运行 `rustfmt` 工具是一种良好的做法，这样我们就可以在不费太多力气的情况下维护代码标准。理想的做法是在您喜欢的文本编辑器中配置
    `rustfmt` 工具，并将 `rustfmt` 命令作为构建过程的一部分。
- en: Setting up rust-clippy
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 rust-clippy
- en: In this recipe, you will learn the steps to use the rust-clippy tool. The tool
    basically helps the developer to catch common mistakes and improves your Rust
    project code by having a collection of lints. The Clippy tool currently works
    with the latest Rust nightly for now. Since this is a tool for helping the developer
    of a library or an application to write better code, it is recommended not to
    include Clippy as a hard dependency and it is mostly used as an optional dependency.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，您将学习使用 rust-clippy 工具的步骤。该工具基本上帮助开发者捕获常见错误，并通过一组 lint 提高您的 Rust 项目代码。Clippy
    工具目前与最新的 Rust 夜间版本一起使用。由于这是一个帮助库或应用程序开发者编写更好代码的工具，建议不要将 Clippy 作为硬依赖项，它通常用作可选依赖项。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow the steps to install the rust-clippy tool:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤安装 rust-clippy 工具：
- en: 'Change the default compiler to the nightly version:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认编译器更改为夜间版本：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Set up rust-clippy as an optional dependency by making a modification in the
    `Cargo.toml` file:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改 `Cargo.toml` 文件将 rust-clippy 设置为可选依赖项：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Cargo.toml` file will look similar to the following screenshot:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Cargo.toml` 文件将类似于以下截图：'
- en: '![](img/29a1e415-d742-42a5-918b-36ccf82ec62a.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29a1e415-d742-42a5-918b-36ccf82ec62a.png)'
- en: 'Install Clippy from the Cargo tool:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Cargo 工具安装 Clippy：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Set up Clippy as a compiler plugin, by adding Clippy as a dependency to the
    `Cargo.toml` file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 Clippy 添加到 `Cargo.toml` 文件中作为依赖项来设置 Clippy 为编译器插件：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Cargo.toml` file will look similar to the following screenshot:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Cargo.toml` 文件将类似于以下截图：'
- en: '![](img/075f4f4e-05bc-44aa-aaac-f8b61a350f2d.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/075f4f4e-05bc-44aa-aaac-f8b61a350f2d.png)'
- en: 'Set up a new project for experimenting with the rust-clippy tool:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为实验 rust-clippy 工具设置一个新的项目：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the steps to implement this recipe:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此配方：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的文本编辑器中打开 `src` 目录下的 `main.rs` 文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息编写代码头：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a `main` function, and copy and paste the code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main`函数，并将代码复制粘贴：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Copy and paste the code snippet above the `main` function at the beginning
    of the code to use rust-clippy as an optional dependency:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上面的代码片段复制并粘贴到代码中`main`函数的开始部分，以将rust-clippy作为可选依赖项使用：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run Clippy with the command `cargo build --features "clippy"`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令`cargo build --features "clippy"`运行Clippy。
- en: 'For running Clippy as a subcommand, run the following command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将Clippy作为子命令运行，请运行以下命令：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Copy paste the code snippet above the `main` function at the beginning of the
    code to use rust-clippy as a compiler plugin:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码片段复制粘贴到代码中`main`函数的开始部分，以将rust-clippy作为编译器插件使用：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we run the `cargo run` command, Cargo will install Clippy and show a warning.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行`cargo run`命令时，Cargo将安装Clippy并显示警告。
- en: 'We will get the following output for the preceding three different methods:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到前面三种不同方法的前三个输出：
- en: 'Running Clippy as an optional dependency:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Clippy作为可选依赖项运行：
- en: '![](img/31a85060-fade-4988-b54c-1f6d59edd0bd.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31a85060-fade-4988-b54c-1f6d59edd0bd.png)'
- en: 'Running Clippy as a Cargo subcommand:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Clippy作为Cargo子命令运行：
- en: '![](img/fc17f038-c23f-496d-8ae8-41c5fb123394.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc17f038-c23f-496d-8ae8-41c5fb123394.png)'
- en: 'Running Clippy as a compiler plugin:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Clippy作为编译器插件运行：
- en: '![](img/235b2653-561c-4474-b65d-0ac7a3929134.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/235b2653-561c-4474-b65d-0ac7a3929134.png)'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you learned the methods by which you can use the Clippy tool
    to catch the different lints in the code and get suggestions to improve them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你学习了使用Clippy工具捕获代码中的不同lints并获取改进建议的方法。
- en: When we use Clippy as an optional dependency, we set the optional flag as `true`
    when mentioning Clippy as a dependency in the `Cargo.toml` file. In the feature
    section, we have a default set of optional packages. Most of the time, developers
    will want to use these packages, but they are strictly optional. In addition to
    manipulations in the configuration file, we have to enable the `#[cfg_attr]` attribute
    that generally works with `#[cfg_attr(condition, attribute)]`, where it allows
    us to compile the Rust script `main.rs` if the condition is true; that is, if
    the condition is `true`, it's equivalent to `#[attribute]`, and if the condition
    is `false`, it does not proceed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将Clippy作为可选依赖项使用时，在`Cargo.toml`文件中提及Clippy作为依赖项时，我们将可选标志设置为`true`。在功能部分，我们有一个默认的可选包集合。大多数时候，开发者会想要使用这些包，但它们是严格可选的。除了在配置文件中的操作外，我们还需要启用`#[cfg_attr]`属性，它通常与`#[cfg_attr(condition,
    attribute)]`一起使用，它允许我们在条件为真时编译Rust脚本`main.rs`；也就是说，如果条件为`true`，则相当于`#[attribute]`，如果条件为`false`，则不进行操作。
- en: The `cargo clippy` command is the easiest way to run the Clippy tool as it does
    not require any manipulations in the configuration or code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo clippy`命令是运行Clippy工具的最简单方法，因为它不需要在配置或代码中进行任何操作。'
- en: In the third way, we add the `clippy` dependency in the `Cargo.toml` file without
    mentioning it as a feature and loading it as a compiler plugin. We do syntax extension
    by calling `#![feature(plugin)]` and `#![plugin(clippy)]`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三种方法中，我们在`Cargo.toml`文件中添加了`clippy`依赖项，但没有将其作为功能提及，而是将其作为编译器插件加载。我们通过调用`#![feature(plugin)]`和`#![plugin(clippy)]`来实现语法扩展。
- en: rustc can load compiler plugins, which are user-provided libraries that extend
    the compiler's behavior with new syntax extensions, lint checks, and so on. There
    are around 200 lints and this is a growing number configured with the rust-clippy
    tool that helps developers write better Rust code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: rustc可以加载编译器插件，这些插件是用户提供的库，通过新的语法扩展、lint检查等扩展编译器的行为。大约有200个lints，这是通过rust-clippy工具配置的，它帮助开发者编写更好的Rust代码。
- en: A good place to use the tool would be to have the `cargo clippy` command in
    the CI script processes for the project before building the projects, similar
    to the `rustfmt` tool.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此工具的好地方是在构建项目之前，在CI脚本的流程中包含`cargo clippy`命令，类似于`rustfmt`工具。
- en: Setting up and testing with Servo
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和测试Servo
- en: In this recipe, we will set up the Servo browser in our systems and test the
    performance of a website in it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将设置系统中的Servo浏览器并测试其中的网站性能。
- en: Servo is a parallel browser engine project sponsored by Mozilla and written
    in Rust. The Servo project aims to achieve better parallelism, security, modularity,
    and performance. In short, Servo is a modern, high-performance browser engine
    designed for both application and embedded use.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Servo是由Mozilla赞助的并行浏览器引擎项目，使用Rust编写。Servo项目旨在实现更好的并行性、安全性、模块化和性能。简而言之，Servo是一个现代、高性能的浏览器引擎，适用于应用程序和嵌入式使用。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will need to install the following dependencies in our systems to run the
    Servo browser:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行Servo浏览器，我们需要在我们的系统中安装以下依赖项：
- en: 'Open the Terminal and install the following packages:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并安装以下包：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the steps to implement the build of the Servo project:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现Servo项目的构建：
- en: 'Open the Terminal, and clone the Servo project from GitHub:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，从GitHub克隆Servo项目：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Enter the project, and build the browser in the development mode:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入项目，以开发模式构建浏览器：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To ensure that the project is built correctly, run a small test:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保项目正确构建，运行一个小测试：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For benchmarking, performance testing, and other real-world scenarios, add
    the `--release` flag to create an optimized build:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于基准测试、性能测试和其他实际场景，添加`--release`标志以创建一个优化构建：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For running a website in the Servo project, use the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Servo项目中运行网站，请使用以下代码：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you learned to set up the Servo browser engine and run websites
    in the engine. Servo is a prototype web browser engine written in the Rust language.
    It is currently developed on 64-bit macOS, 64-bit Linux, and Android.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你学会了如何设置Servo浏览器引擎并在此引擎中运行网站。Servo是一个用Rust语言编写的原型网络浏览器引擎。它目前支持64位macOS、64位Linux和Android。
- en: Servo is built with Cargo and it uses Mozilla's Mach tools to orchestrate the
    build and other tasks. We run a URL in Servo with `./mach run https://www.google.com`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Servo是用Cargo构建的，它使用Mozilla的Mach工具来协调构建和其他任务。我们在Servo中使用`./mach run https://www.google.com`来运行一个URL。
- en: There are lots of Mach commands we can use for building and hacking. You can
    list them with `./mach --help`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用很多Mach命令来构建和修改。你可以使用`./mach --help`列出它们。
- en: Generating random numbers
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机数
- en: In this recipe, we will use the `rand` crate to generate random numbers within
    a range provided, which in this recipe is 1 to 10\. The rand crate is a very important
    library used in various scientific operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`rand`crate在提供的范围内生成随机数，在这个菜谱中是1到10。`rand`crate是一个在多种科学操作中非常重要的库。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow the following steps to set up the project and install the dependencies:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置项目和安装依赖项：
- en: 'Create a new binary project named `sample_rand`, and enter the directory:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_rand`的新二进制项目，并进入该目录：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Install the cargo-edit tool that allows you to add and remove dependencies
    by modifying your `Cargo.toml`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装cargo-edit工具，该工具允许你通过修改`Cargo.toml`来添加和删除依赖项：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Install the `rand` dependency:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`rand`依赖项：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo add crate_name`会自动将依赖项的最新版本添加到`Cargo.toml`文件中。'
- en: 'Install the dependency by running the following command:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令安装依赖项：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This step will print `hello world` as output, as we have not yet made any modifications
    to the source code.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤将输出`hello world`，因为我们还没有对源代码进行任何修改。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the steps to implement this recipe:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个菜谱：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的首选文本编辑器中打开`src`目录下的`main.rs`文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头编写代码：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Copy paste the following code snippet to the `main.rs` file after the code
    header:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段复制粘贴到代码头后面的`main.rs`文件中：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Save the file and run the project by following the next command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并按照以下命令运行项目：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We should get the following output on execution of the code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后，我们应该得到以下输出：
- en: '![](img/ea8dc213-2434-4a28-bfe1-2f05c0e4f201.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea8dc213-2434-4a28-bfe1-2f05c0e4f201.png)'
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: In this recipe, we print a random number from a range provided by the developer,
    which in our case is a value between 0 and 10; we use the `rand` library for performing
    this option.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们打印出开发者提供的范围内的随机数，在我们的例子中是0到10之间的一个值；我们使用`rand`库来执行这个选项。
- en: We import the `rand` library with the `extern crate` command and use the `rand::rng`
    module that provides us with the `gen_range` method. The `gen_range` method takes
    two arguments as input that are lower and higher bound values of the range in
    which it is supposed to predict a random number. In the case of interchanging
    the position, it would panic.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`extern crate`命令导入`rand`库，并使用提供`gen_range`方法的`rand::rng`模块。`gen_range`方法接受两个输入参数，即它应该预测随机数的范围的上下限值。如果交换位置，它将引发恐慌。
- en: Writing lines to a file
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将行写入文件
- en: In this recipe, we will use the `std` crate, which is the Rust standard library
    providing various modules and functionalities. We will use the filesystem capabilities
    of the crate to write a three-line message to a file, and then read it back, one
    line at a time.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `std` crate，它是 Rust 的标准库，提供各种模块和功能。我们将使用该 crate 的文件系统功能将三行消息写入文件，然后逐行读取它。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow the steps to set up the project and install the dependencies:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置项目和安装依赖项：
- en: 'Create a new binary project named `sample_file`, and enter the directory:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_file` 的新二进制项目，并进入该目录：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Install the `error_chain` crate dependency:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `error_chain` crate 依赖项：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo add crate_name` 会自动将依赖项的最新版本添加到 `Cargo.toml` 文件中。'
- en: 'Install the dependency by running the following command:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装依赖项：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This step will print a `hello world` as output, as we have not yet made any
    modifications to the source code.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们尚未对源代码进行任何修改，这一步将输出 `hello world`。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the steps to implement this recipe:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个菜谱：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你首选的文本编辑器中打开 `src` 目录下的 `main.rs` 文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头编写代码：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types, after
    the code header:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码头之后创建 `error_chain!` 宏来定义自定义的 `Error` 和 `Result` 类型，以及从标准库错误类型自动转换：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define the `run` method and the `quick_main!` macro by copying and pasting
    the following code snippet with the `error_chain!` macro:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制并粘贴以下代码片段并使用 `error_chain!` 宏来定义 `run` 方法以及 `quick_main!` 宏：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save the file and run the project by running the command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并运行项目，通过运行以下命令：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We should get the following output on execution of the code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后，我们应该得到以下输出：
- en: '![](img/6c836a9f-9a97-4b57-91f0-5ba19124f5b5.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c836a9f-9a97-4b57-91f0-5ba19124f5b5.png)'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we write a three-line message to a file, `lines.txt`. We assign
    the string `lines.txt` to a variable named path, which we pass as an argument
    to `File::create(path)` that creates the file, and we assign it to a variable
    `output`. Using the `write!` macro, we write a string `"Rust\n\nFun"` to the mutable
    `output` variable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将三行消息写入文件 `lines.txt`。我们将字符串 `lines.txt` 分配给一个名为 path 的变量，将其作为参数传递给
    `File::create(path)` 以创建文件，并将其分配给变量 `output`。使用 `write!` 宏，我们将字符串 `"Rust\n\nFun"`
    写入可变的 `output` 变量。
- en: We read the file, then read back with `File::open(path)` and assign it to the
    `input` variable. We create a variable named `buffered` that stores the content
    of the file; we then read each line of the file with the `Lines` iterator created
    by `BufRead::lines` using a `for` loop and print it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取文件，然后使用 `File::open(path)` 读取并分配给 `input` 变量。我们创建一个名为 `buffered` 的变量来存储文件内容；然后使用
    `BufRead::lines` 创建的 `Lines` 迭代器通过 `for` 循环逐行读取文件并打印它。
- en: BufRead is a trait, and the most common way to get one is from a BufReader that
    is constructed from some type that implements `Read`; here, a file. The file is
    opened for writing with `File::create` and for reading with `File::open`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: BufRead 是一个特质，获取一个 BufRead 的最常见方式是从一个实现了 `Read` 特质的类型（这里是一个文件）构建的 BufReader。文件使用
    `File::create` 打开用于写入，使用 `File::open` 打开用于读取。
- en: The `error-chain` crate is a library for consistent and reliable error-handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`error-chain` crate 是一个用于一致和可靠的错误处理的库，它使得充分利用 Rust 强大的错误处理功能变得更容易，而不需要维护样板错误类型和转换的开销。它实现了一种定义你自己的错误类型以及从其他错误类型转换的策略。'
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    type that acts like a *real* `main` function. We use the `error-chain` crate to
    make `?` work within `run`. This is using the `error_chain!` macro from the `error-chain`
    crate to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的基本模式有一个名为`run()`的函数，它产生一个`Result`类型，该类型类似于真正的`main`函数。我们使用`error-chain`crate来使`?`在`run`中工作。这是使用来自`error-chain`crate的`error_chain!`宏来定义自定义的`Error`和`Result`类型，以及从crate错误类型到自动转换。自动转换使`?`运算符工作。`quick_main!`宏生成实际的`main`函数，并在执行过程中发生错误时打印出错误。
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program executed
    successfully without any errors.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Ok(())`返回给`quick_run!`宏以确保程序成功执行且没有错误。
- en: Parsing unstructured JSON
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析非结构化JSON
- en: In this recipe, we will use the `serde_json` crate that provides various modules
    and functionalities for serializing and deserializing unstructured JSON. We will
    use the encoding capabilities to parse JSON to a type of the caller's choice.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用提供各种模块和功能以序列化和反序列化非结构化JSON的`serde_json`crate。我们将使用编码功能将JSON解析为调用者选择的类型。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow the steps to set up the project and install the dependencies:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置项目和安装依赖项：
- en: 'Create a new binary project named `sample_json`, and enter the directory:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_json`的新二进制项目，并进入该目录：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Install the `error_chain` and `serde_json` crates dependencies:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`error_chain`和`serde_json`crate依赖项：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo add crate_name`自动将依赖项的最新版本添加到`Cargo.toml`文件。'
- en: 'Install the dependency by running the following command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装依赖项：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This step will print `hello world` as output, as we have not yet made any modifications
    to the source code.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤将输出`hello world`，因为我们尚未对源代码进行任何修改。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the steps to implement this recipe:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此菜谱：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你首选的文本编辑器中打开`src`目录下的`main.rs`文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types, after
    the code header:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码头之后创建`error_chain!`宏来定义自定义的`Error`和`Result`类型，以及从标准库错误类型到自动转换：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define the `run` method and the `quick_main!` macro by copying and pasting
    the following code snippet with the `error_chain!` macro:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制并粘贴以下代码片段并使用`error_chain!`宏来定义`run`方法和`quick_main!`宏：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Save the file and run the project by running the following next command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并运行项目，通过运行以下命令：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We should get the following output on execution of the code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码执行时，我们应该得到以下输出：
- en: '![](img/f175f09e-35b4-4ee1-9778-5ce78d7504ee.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f175f09e-35b4-4ee1-9778-5ce78d7504ee.png)'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we use the `serde_json` crate that provides us with a `from_str`
    function that allows the developer to parse `&str` of JSON into a type of the
    caller's choice. We assign a string format of JSON to the `j` variable, after
    which we call `serde_json::from_str(j)` and assign the output to a variable named
    `parsed`. The unstructured JSON is parsed into a universal `serde_json::Value`
    type that represents any valid JSON data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用提供`from_str`函数的`serde_json`crate，该函数允许开发者将JSON的`&str`解析为调用者选择的类型。我们将JSON的字符串格式赋值给`j`变量，之后调用`serde_json::from_str(j)`并将输出赋值给名为`parsed`的变量。非结构化JSON被解析为表示任何有效JSON数据的通用`serde_json::Value`类型。
- en: We then compare, with the `assert_eq!` macro, the value of the parsed `&str`
    of JSON with what we expect the parsed value to be. The expected value is declared
    using the `json!` macro.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`assert_eq!`宏比较解析的JSON的`&str`值与我们期望的解析值。期望的值使用`json!`宏声明。
- en: The `error-chain` crate is a library for consistent and reliable error handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`error-chain`crate是一个用于一致和可靠错误处理的库，它使得充分利用Rust强大的错误处理功能变得更容易，而不需要维护样板错误类型和转换的开销。它实现了一种定义你自己的错误类型以及从其他错误类型转换的策略。'
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    that acts like a *real* `main` function. We use the `error-chain` crate to make
    `?` work within `run`. This is using the `error_chain!` macro from the `error-chain`
    to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的基本模式有一个名为`run()`的函数，它产生一个`Result`，类似于真正的`main`函数。我们使用`error-chain`crate来使`?`在`run`中工作。这是使用`error-chain`的`error_chain!`宏来定义自定义的`Error`和`Result`类型，以及从crate错误类型到自动转换。自动转换使`?`操作符工作。`quick_main!`宏生成实际的`main`函数，并在执行过程中发生错误时打印出错误。
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program executed
    successfully without any errors.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`quick_run!`宏返回`Ok(())`以确保程序成功执行且没有错误。
- en: Parsing URL from a string
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字符串解析URL
- en: In this recipe, we will use the `url` crate that provides various modules and
    functionalities for networking capabilities. We will use the `parse` functionality
    of the crate to take a string input and convert it into the URL format after validation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用提供各种模块和功能以实现网络功能的`url`crate。我们将使用crate的`parse`功能将字符串输入转换为URL格式，并在验证后。
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow the following steps to set up the project and install the dependencies:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置项目和安装依赖项：
- en: 'Create a new binary project named `sample_url`, and enter the directory:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_url`的新二进制项目，并进入该目录：
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Install the `error_chain` and `url` crates dependencies:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`error_chain`和`url`的crate依赖项：
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo add crate_name`自动将依赖项的最新版本添加到`Cargo.toml`文件中。'
- en: 'Install the dependency by running the following command:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装依赖项：
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This step will print `hello world` as output, as we have not yet made any modifications
    to the source code.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步将打印出`hello world`作为输出，因为我们还没有对源代码进行任何修改。
- en: How to do it...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the steps to implement this recipe:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个菜谱：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你偏好的文本编辑器中打开`src`目录下的`main.rs`文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头编写代码：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types, after
    the code header:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码头之后创建`error_chain!`宏来定义自定义的`Error`和`Result`类型，以及从标准库错误类型到自动转换：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Define the `run` method and the `quick_main!` macro by copying and pasting
    the following code snippet with the `error_chain!` macro:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制和粘贴以下代码片段并使用`error_chain!`宏来定义`run`方法和`quick_main!`宏：
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Save the file and run the project by running the following command:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并运行项目，运行以下命令：
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We should get the following output on execution of the code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行代码后，我们应该得到以下输出：
- en: '![](img/84994bd7-9ce6-4dbb-affb-42be6f0790a2.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84994bd7-9ce6-4dbb-affb-42be6f0790a2.png)'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we use the `parse` method of the `url` crate to validate and
    parse a `&str` from the data into a `Url` struct. The input string will be transformed
    into `Result<Url, ParseError>` on the method's return value.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用`url`crate的`parse`方法验证和解析从数据中提取的`&str`到`Url`结构体。输入字符串将在方法的返回值上转换为`Result<Url,
    ParseError>`。
- en: We create a variable named `s` and assign it to the URL that we want to parse;
    the value is sent to the method with `Url::parse(s)`. Once the URL has been parsed,
    it can be used with all methods on the URL type. Finally we print the path part
    of the `parsed` variable that stores the return value of the `parse` method.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为 `s` 的变量，并将其赋值为我们想要解析的 URL；该值通过 `Url::parse(s)` 方法发送。一旦 URL 被解析，它就可以与
    URL 类型的所有方法一起使用。最后，我们打印出存储 `parse` 方法返回值的 `parsed` 变量的路径部分。
- en: The URL in this code parses successfully, but swapping it out for a malformed
    URL will print a message containing an explanation of what went wrong.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中的 URL 解析成功，但如果将其替换为格式错误的 URL，则会打印出包含错误解释的消息。
- en: The `error-chain` crate is a library for consistent and reliable error handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`error-chain` crate 是一个用于一致和可靠的错误处理的库，它使得充分利用 Rust 强大的错误处理功能变得更容易，而不需要维护样板错误类型和转换的开销。它实现了一种定义您自己的错误类型以及从其他错误类型转换的策略。'
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    that acts like a *real* `main` function. We use the `error-chain` crate to make
    `?` work within `run`. This is using the `error_chain!` macro from `error-chain`
    to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的基本模式有一个名为 `run()` 的函数，它产生一个 `Result`，类似于真正的 `main` 函数。我们使用 `error-chain`
    crate 来使 `?` 在 `run` 中工作。这是使用 `error-chain` 中的 `error_chain!` 宏来定义自定义的 `Error`
    和 `Result` 类型，以及从 crate 错误类型到自动转换。自动转换使 `?` 操作符工作。`quick_main!` 宏生成实际的 `main`
    函数，并在执行过程中发生错误时打印出错误。
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program executed
    successfully without any errors.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Ok(())` 返回给 `quick_run!` 宏，以确保程序成功执行且没有错误。
- en: Decompressing a tarball
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解压 tar 包
- en: In this recipe, we will use the `tar` and `flate2` crates that provide various
    modules and functionalities for compression capabilities. We will extract the
    contents of a tar file named `archive.tar.gz` in the current working directory.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将使用 `tar` 和 `flate2` crate，它们提供各种模块和功能以实现压缩能力。我们将从当前工作目录中提取名为 `archive.tar.gz`
    的 tar 文件的文件内容。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow the following steps to set up the project and install the dependencies:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置项目和安装依赖项：
- en: 'Create a new binary project named `sample_decom`, and enter the directory:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_decom` 的新二进制项目，并进入该目录：
- en: '[PRE60]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Install the `error_chain`, `tar`, and `flate2` crates dependencies:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `error_chain`、`tar` 和 `flate2` 依赖项：
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo add crate_name` 自动将依赖项的最新版本添加到 `Cargo.toml` 文件中。'
- en: 'Install the dependency by running the following command:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装依赖项：
- en: '[PRE62]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This step will print `hello world` as output, as we have not yet made any modifications
    to the source code.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤将打印出 `hello world` 作为输出，因为我们尚未对源代码进行任何修改。
- en: 'Create a sample file, TAR it, and delete it for using it in the recipe:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个示例文件，将其打包为 TAR，然后删除它以用于配方：
- en: '[PRE63]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How to do it...
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the steps to implement this recipe:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此配方：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的文本编辑器中打开 `src` 目录下的 `main.rs` 文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头编写代码：
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types, after
    the code header:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码头之后创建 `error_chain!` 宏来定义自定义的 `Error` 和 `Result` 类型，以及从标准库错误类型到自动转换：
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Define the `run` method and the `quick_main!` macro by copying and pasting
    the following code snippet with the `error_chain!` macro:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制和粘贴以下代码片段并使用 `error_chain!` 宏来定义 `run` 方法和 `quick_main!` 宏：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Save the file and run the project by running the following command:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并运行项目，运行以下命令：
- en: '[PRE67]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We should get the following output on execution of the code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行代码时，我们应该得到以下输出：
- en: '![](img/4e020f5e-eee5-4e96-8e27-957f5a469150.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e020f5e-eee5-4e96-8e27-957f5a469150.png)'
- en: How it works...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we open the file using the `File::open(path)` method and assign
    it to the `tar_gz` variable; the `path` variable contains the string value, which
    is the location of the `archive.tar.gz` file. We then decompress the `tar_gz`
    file using the `flate2` crate with the `flate2::read::GzDecoder::new(tar_gz)`
    command, and assign its return value to the `tar` variable. We extract the files
    with the `tar::Archive::unpack` method by first creating a variable `archive`
    by calling `Archive::new(tar)` which loads the archive, and then we get all the
    files from a compressed tarball named `archive.tar.gz` located in the current
    working directory by calling `archive.unpack(".")`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用 `File::open(path)` 方法打开文件，并将其分配给 `tar_gz` 变量；`path` 变量包含字符串值，它是
    `archive.tar.gz` 文件的位置。然后，我们使用 `flate2` crate 的 `flate2::read::GzDecoder::new(tar_gz)`
    命令解压缩 `tar_gz` 文件，并将返回值分配给 `tar` 变量。我们通过首先调用 `Archive::new(tar)` 创建变量 `archive`
    来加载存档，然后通过调用 `archive.unpack(".")` 从当前工作目录中名为 `archive.tar.gz` 的压缩 tar 文件中提取所有文件。
- en: The `error-chain` crate is a library for consistent and reliable error handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`error-chain` crate 是一个用于一致和可靠的错误处理的库，它使得充分利用 Rust 强大的错误处理功能变得更容易，而不需要维护样板错误类型和转换的开销。它实现了一种定义自己的错误类型以及从其他错误类型转换的策略。'
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    that acts like a *real* `main` function. We use `error-chain` crate to make `?`
    work within `run`. This is using the `error_chain!` macro from the `error-chain`
    to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的基本模式有一个名为 `run()` 的函数，它产生一个 `Result`，类似于真正的 `main` 函数。我们使用 `error-chain`
    crate 使 `?` 在 `run` 中工作。这是使用 `error-chain` 的 `error_chain!` 宏来定义自定义的 `Error` 和
    `Result` 类型，以及从 crate 错误类型自动转换。自动转换使 `?` 操作符工作。`quick_main!` 宏生成实际的 `main` 函数，并在执行过程中发生错误时打印出来。
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program executed
    successfully without any errors.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Ok(())` 返回给 `quick_run!` 宏，以确保程序成功执行而没有错误。
- en: Compressing a directory to a tarball
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将目录压缩成 tar 文件
- en: In this recipe, we will use the `tar` and `flate2` crates that provide various
    modules and functionalities for compression capabilities. We will compress the
    contents of a directory which, in this recipe, is the current directory to a TAR
    file named `archive.tar.gz` in the same directory.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用 `tar` 和 `flate2` crate，它们提供了各种模块和功能，用于压缩功能。我们将压缩目录的内容，在这个食谱中是当前目录，将其压缩成同一目录下的
    `archive.tar.gz` TAR 文件。
- en: Getting ready
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow the following steps to set up the project and install the dependencies:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置项目和安装依赖项：
- en: 'Create a new binary project named `sample_com`, and enter the directory:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_com` 的新二进制项目，并进入该目录：
- en: '[PRE68]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Install the `error_chain`, `tar`, and `flate2` crates dependencies:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `error_chain`、`tar` 和 `flate2` crate 的依赖项：
- en: '[PRE69]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo add crate_name` 自动将依赖项的最新版本添加到 `Cargo.toml` 文件中。'
- en: 'Install the dependency by running the following command:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装依赖项：
- en: '[PRE70]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This step will print `hello world` as output as we have not yet made any modification
    to the source code.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们尚未对源代码进行任何修改，这一步将输出 `hello world`。
- en: How to do it...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow the steps to implement this recipe:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个食谱：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的文本编辑器中打开 `src` 目录下的 `main.rs` 文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头部，包含相关信息：
- en: '[PRE71]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types after the
    code header:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `error_chain!` 宏来定义一个自定义的 `Error` 和 `Result` 类型，以及代码头部之后的自动从标准库错误类型转换：
- en: '[PRE72]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Define the `run` method and the `quick_main!` macro by copy pasting the following
    code snippet the `error_chain!` macro:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制粘贴以下代码片段到 `error_chain!` 宏来定义 `run` 方法和 `quick_main!` 宏：
- en: '[PRE73]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Save the file and run the project by following the command:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并按照以下命令运行项目：
- en: '[PRE74]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We should get the following output on execution of the code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行代码后，我们应该得到以下输出：
- en: '![](img/667f1c43-f74c-4e56-b504-84a5f7397c7a.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/667f1c43-f74c-4e56-b504-84a5f7397c7a.png)'
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we compress the source code directory into `archive.tar.gz`.
    We create a file with `File::create("archive.tar.gz")` and assign it to the `tar_gz`
    variable. We then wrap it using `flate2::write::GzEncoder` and `tar::Builder`.
    Lastly, we add the contents of the `../sample_com` directory recursively into
    the archive under `./backup` with `Builder::append_dir_all`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，我们将源代码目录压缩成 `archive.tar.gz`。我们使用 `File::create("archive.tar.gz")` 创建一个文件，并将其分配给
    `tar_gz` 变量。然后我们使用 `flate2::write::GzEncoder` 和 `tar::Builder` 来包装它。最后，我们使用 `Builder::append_dir_all`
    将 `../sample_com` 目录的内容递归地添加到 `./backup` 下的归档中。
- en: '`flate2::write::GzEncoder` is responsible for transparently compressing the
    data prior to writing it to `archive.tar.gz`.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`flate2::write::GzEncoder` 负责在写入 `archive.tar.gz` 之前透明地压缩数据。'
- en: The `error-chain` crate is a library for consistent and reliable error handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`error-chain` 依赖包是一个用于一致和可靠的错误处理的库，它使得充分利用 Rust 强大的错误处理功能变得更容易，而不需要维护样板错误类型和转换的开销。它实现了一种定义自己的错误类型以及从其他错误类型转换的策略。'
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    that acts like a *real* `main` function. We use the `error-chain` crate to make
    `?` work within `run`. This is using the `error_chain!` macro from the `error-chain`
    to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的基本模式有一个名为 `run()` 的函数，它产生一个 `Result`，其行为类似于真正的 `main` 函数。我们使用 `error-chain`
    依赖包使 `?` 在 `run` 中工作。这是使用 `error-chain` 中的 `error_chain!` 宏来定义自定义的 `Error` 和 `Result`
    类型，以及从其他错误类型到这些类型的自动转换。自动转换使 `?` 操作符工作。`quick_main!` 宏生成实际的 `main` 函数，并在执行过程中发生错误时打印出来。
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program executed
    successfully without any errors.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `quick_run!` 宏返回 `Ok(())` 以确保程序成功执行且没有错误。
- en: Finding file extensions recursively
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归查找文件扩展名
- en: In this recipe, we will use the `glob` crate that provides various modules and
    functionalities for filesystem capabilities. We will recursively find all PNG
    files in the current directory.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，我们将使用提供各种模块和功能以实现文件系统能力的 `glob` 依赖包。我们将递归地查找当前目录下的所有 PNG 文件。
- en: Getting ready
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow the following steps to set up the project and install the dependencies:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置项目和安装依赖：
- en: 'Create a new binary project named `sample_ext`, and enter the directory:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_ext` 的新二进制项目，并进入该目录：
- en: '[PRE75]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Install the `error_chain` and `glob` crates dependencies:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `error_chain` 和 `glob` 依赖包：
- en: '[PRE76]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo add crate_name` 自动将依赖的最新版本添加到 `Cargo.toml` 文件中。'
- en: 'Install the dependency by running the following command:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装依赖：
- en: '[PRE77]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This step will print `hello world` as outputs, as we have not yet made any modifications
    to the source code.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤将打印 `hello world` 作为输出，因为我们尚未对源代码进行任何修改。
- en: How to do it...
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the steps to implement this recipe:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此菜谱：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的文本编辑器中打开 `src` 目录下的 `main.rs` 文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头编写代码：
- en: '[PRE78]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types, after
    the code header:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码头之后创建 `error_chain!` 宏来定义自定义的 `Error` 和 `Result` 类型，以及从标准库错误类型到这些类型的自动转换：
- en: '[PRE79]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Define the `run` method and the `quick_main!` macro by copying and pasting
    the following code snippet with the `error_chain!` macro:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`run`方法和`quick_main!`宏，通过复制粘贴以下代码片段并使用`error_chain!`宏来完成：
- en: '[PRE80]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Save the file and run the project by running the following command:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并通过运行以下命令来运行项目：
- en: '[PRE81]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We should get the following output on execution of the code:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行代码后，我们应该得到以下输出：
- en: '![](img/94f80ece-72d7-4a70-a9bb-bf39077ce598.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94f80ece-72d7-4a70-a9bb-bf39077ce598.png)'
- en: How it works...
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we will recursively find all PNG files in the current directory.
    We use the iteration with a `for` loop with different entries of the `glob("**/*.png")`
    method that returns us all the `.png` file extensions in the current directory.
    We have a `**` pattern that matches the current directory and all subdirectories.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将递归地查找当前目录下的所有PNG文件。我们使用`for`循环和`glob("**/*.png")`方法的多个条目进行迭代，该方法返回当前目录下的所有`.png`文件扩展名。我们有一个`**`模式，它可以匹配当前目录及其所有子目录。
- en: We can also use the `**` pattern for any directory, not just the current one.
    For example, `/media/**/*.png` will match all PNGs in media and its subdirectories.
    For other file extensions, change `.png` to the desired one.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为任何目录使用`**`模式，而不仅仅是当前目录。例如，`/media/**/*.png`将匹配媒体及其子目录中的所有PNG文件。对于其他文件扩展名，将`.png`更改为所需的扩展名。
- en: The `error-chain` crate is a library for consistent and reliable error handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`error-chain` crate是一个用于一致和可靠的错误处理的库，它使得充分利用Rust强大的错误处理功能变得更容易，而不需要维护样板错误类型和转换的开销。它实现了一种定义你自己的错误类型以及从其他错误类型转换的策略。'
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    that acts like a *real* `main` function. We use the `error-chain` crate to make
    `?` work within `run`. This is using the `error_chain!` macro from the `error-chain`
    to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的基本模式有一个名为`run()`的函数，它产生一个`Result`，其行为类似于一个真正的`main`函数。我们使用`error-chain`
    crate来使`?`在`run`中工作。这是使用`error-chain`中的`error_chain!`宏来定义自定义的`Error`和`Result`类型，以及从crate错误类型到自动转换。自动转换使得`?`运算符工作。`quick_main!`宏生成实际的`main`函数，并在执行过程中发生错误时打印出错误。
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program is executed
    successfully without any errors.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Ok(())`返回给`quick_run!`宏，以确保程序成功执行且没有任何错误。
