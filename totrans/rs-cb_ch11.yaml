- en: Advanced Rust Tools and Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up rustup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up rustfmt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up rust-clippy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and testing with Servo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing lines to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing unstructured JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing URL from a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompressing a tarball
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing a directory to a tarball
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding file extensions recursively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the various Rust tools, such as rustfmt
    and rustup, that help us write better production level Rust code, catch errors,
    and also provide us with the equipment to do extreme experimentation with different
    versions of the Rust compiler. Apart from these tools, we will set up and understand
    the Servo project, which is a state-of-the-art browsing engine that contributes
    a lot to the design of the Rust language. The last few recipes of this chapter
    will take the readers through the different ground-level libraries in Rust that
    contribute a lot to faster project development, by providing the developer with
    various common operations and functionalities out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up rustup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn the different options available with the rustup
    tool that enable us to run the Rust applications in different versions and many
    more related functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The rustup tool is the official Rust language installer for rustc, Cargo, and
    other standard tools to Cargo's `bin` directory. On Unix, it is located at `$HOME/.cargo/bin`
    and on Windows at `%USERPROFILE%\.cargo\bin`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need to set up the rustup tool in order to perform the different activities
    of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the steps to install the rustup tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check for the version of the Rust compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we are able to get an output such as `rustc 1.18.0 (03fc9d622 2017-06-06)`,
    this means that the rustup tool is set up. The version number may change according
    to the stable version last downloaded in the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are not able to get the compiler version, follow the installation recipes
    from [Chapter 1](rs-cb_ch01.html), *Let''s Make System Programming Great Again*,
    or run the following command in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the stable version of Rust to the latest version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `rustup` tool to the latest version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `nightly` toolkit version of the Rust compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `nightly` version of Rust without changing the default version of Rust:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `default` version of the Rust compiler to the `nightly` version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `nightly` version of Rust:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will update both the stable and nightly versions of the Rust compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should get the following output on execution of the rustup tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On installation of the nightly version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a3a9d203-88ab-41ae-b234-c3b59abda0ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Setting nightly as the default version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b37e7382-d0bf-4f7b-b9a2-5046a88c437e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`rustup` is a toolchain multiplexer that installs and manages many Rust toolchains,
    and all of them are present in a single set of tools located at `~/.cargo/bin`.
    As we run examples, `rustup` provides mechanisms to easily change the active toolchain,
    such as `rustc` and `cargo` at `~/.cargo/bin`, by reconfiguring the locations
    in the background.'
  prefs: []
  type: TYPE_NORMAL
- en: When `rustup` is installed for the first time, the compiler rustc will be present
    in `$HOME/.cargo/bin/rustc`, which, by default, is the stable version. If you
    later change the default toolchain to nightly with commands such as `rustup install
    nightly` and `rustup default nightly`, the location will change and the nightly
    compiler will run instead of the stable one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rustup update` command basically helps us fetch the latest version of
    the compiler. Rust is distributed on three different release channels: stable,
    beta, and nightly. rustup is configured to use the stable channel by default,
    which represents the latest release of Rust and is released every six weeks.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up rustfmt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn the steps by which one can set up and use the
    `rustfmt` tool in their day-to-day Rust project development. `rustfmt` is a tool
    for formatting the Rust code according to standard style guidelines of the Rust
    language. It is an open source project and welcomes contribution from the Rust
    community members. The style guides are decided by the Rust **request for comments**
    (**RFC**) procedure, which is an open discussion about the Rust language changes,
    such as feature requests, bug fixes, and documentation. This is a very important
    character trait for a programming language as it gives more authority to the developer
    community than the company that originated the language.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will follow the steps to set up the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the nightly version of the Rust compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the Rust compiler version to the nightly toolchain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Rust project using Cargo and install the `rustfmt` tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output on installing the `rustfmt` tool if everything
    works fine without any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca353f50-a1ad-468b-9b99-2a5fc7164b39.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information, but the catch here is
    that we purposefully impose incorrect indentations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function with some random spacing and style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run `rustfmt` to fix the style issues of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output on successfully executing the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbc45fd6-f502-4718-9d7f-231ffce4253d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we basically introduce the `rustfmt` tool that helps us follow
    the correct style guide implied by the Rust programming language in an automated
    manner, where the developer can freely use the tool to follow style standards.
  prefs: []
  type: TYPE_NORMAL
- en: From the output of the `main.rs` file, we can see that the wrong indentation
    in the code was automatically corrected and overwritten in the `main.rs` file
    with the `cargo fmt` command, and that a backup of the previous code was saved
    in the `main.rs.bk` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various modes in which we can run the `rustfmt` tool, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`replace`: This is the default selection that overwrites the original files
    and creates backup files after formatting; `cargo fmt` uses `--write-mode=replace`
    by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`overwrite`: This option basically changes the original files without creating
    a backup of the previous code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`display`: This option basically prints the formatted files to `stdout`, that
    shows the changes made in the terminal screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`diff`: This option prints the difference between the original files and formatted
    files to `stdout`. This will also exit with an error code if there are any differences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkstyle`: This option will output the lines that need to be corrected as
    a checkstyle XML file that can be used with tools such as Jenkins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to use these write modes, we need to install the `rustfmt` tool by
    source, where we clone the main GitHub repository and install from the source
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables us to run formatting commands on any Rust files with various modes,
    such as the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is a good practice to run the `rustfmt` tool before building the project
    so that we can maintain code standards without much effort. The ideal way to do
    this is to configure the `rustfmt` tool in your favorite text editor and have
    the `rustfmt` commands as a part of the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up rust-clippy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn the steps to use the rust-clippy tool. The tool
    basically helps the developer to catch common mistakes and improves your Rust
    project code by having a collection of lints. The Clippy tool currently works
    with the latest Rust nightly for now. Since this is a tool for helping the developer
    of a library or an application to write better code, it is recommended not to
    include Clippy as a hard dependency and it is mostly used as an optional dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to install the rust-clippy tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the default compiler to the nightly version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up rust-clippy as an optional dependency by making a modification in the
    `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Cargo.toml` file will look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29a1e415-d742-42a5-918b-36ccf82ec62a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Install Clippy from the Cargo tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up Clippy as a compiler plugin, by adding Clippy as a dependency to the
    `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Cargo.toml` file will look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/075f4f4e-05bc-44aa-aaac-f8b61a350f2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set up a new project for experimenting with the rust-clippy tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `main` function, and copy and paste the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy and paste the code snippet above the `main` function at the beginning
    of the code to use rust-clippy as an optional dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run Clippy with the command `cargo build --features "clippy"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For running Clippy as a subcommand, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy paste the code snippet above the `main` function at the beginning of the
    code to use rust-clippy as a compiler plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When we run the `cargo run` command, Cargo will install Clippy and show a warning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will get the following output for the preceding three different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running Clippy as an optional dependency:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/31a85060-fade-4988-b54c-1f6d59edd0bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running Clippy as a Cargo subcommand:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/fc17f038-c23f-496d-8ae8-41c5fb123394.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running Clippy as a compiler plugin:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/235b2653-561c-4474-b65d-0ac7a3929134.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you learned the methods by which you can use the Clippy tool
    to catch the different lints in the code and get suggestions to improve them.
  prefs: []
  type: TYPE_NORMAL
- en: When we use Clippy as an optional dependency, we set the optional flag as `true`
    when mentioning Clippy as a dependency in the `Cargo.toml` file. In the feature
    section, we have a default set of optional packages. Most of the time, developers
    will want to use these packages, but they are strictly optional. In addition to
    manipulations in the configuration file, we have to enable the `#[cfg_attr]` attribute
    that generally works with `#[cfg_attr(condition, attribute)]`, where it allows
    us to compile the Rust script `main.rs` if the condition is true; that is, if
    the condition is `true`, it's equivalent to `#[attribute]`, and if the condition
    is `false`, it does not proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The `cargo clippy` command is the easiest way to run the Clippy tool as it does
    not require any manipulations in the configuration or code.
  prefs: []
  type: TYPE_NORMAL
- en: In the third way, we add the `clippy` dependency in the `Cargo.toml` file without
    mentioning it as a feature and loading it as a compiler plugin. We do syntax extension
    by calling `#![feature(plugin)]` and `#![plugin(clippy)]`.
  prefs: []
  type: TYPE_NORMAL
- en: rustc can load compiler plugins, which are user-provided libraries that extend
    the compiler's behavior with new syntax extensions, lint checks, and so on. There
    are around 200 lints and this is a growing number configured with the rust-clippy
    tool that helps developers write better Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: A good place to use the tool would be to have the `cargo clippy` command in
    the CI script processes for the project before building the projects, similar
    to the `rustfmt` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and testing with Servo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will set up the Servo browser in our systems and test the
    performance of a website in it.
  prefs: []
  type: TYPE_NORMAL
- en: Servo is a parallel browser engine project sponsored by Mozilla and written
    in Rust. The Servo project aims to achieve better parallelism, security, modularity,
    and performance. In short, Servo is a modern, high-performance browser engine
    designed for both application and embedded use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to install the following dependencies in our systems to run the
    Servo browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Terminal and install the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement the build of the Servo project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Terminal, and clone the Servo project from GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the project, and build the browser in the development mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that the project is built correctly, run a small test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For benchmarking, performance testing, and other real-world scenarios, add
    the `--release` flag to create an optimized build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For running a website in the Servo project, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you learned to set up the Servo browser engine and run websites
    in the engine. Servo is a prototype web browser engine written in the Rust language.
    It is currently developed on 64-bit macOS, 64-bit Linux, and Android.
  prefs: []
  type: TYPE_NORMAL
- en: Servo is built with Cargo and it uses Mozilla's Mach tools to orchestrate the
    build and other tasks. We run a URL in Servo with `./mach run https://www.google.com`.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of Mach commands we can use for building and hacking. You can
    list them with `./mach --help`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `rand` crate to generate random numbers within
    a range provided, which in this recipe is 1 to 10\. The rand crate is a very important
    library used in various scientific operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the following steps to set up the project and install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new binary project named `sample_rand`, and enter the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the cargo-edit tool that allows you to add and remove dependencies
    by modifying your `Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `rand` dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the dependency by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This step will print `hello world` as output, as we have not yet made any modifications
    to the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy paste the following code snippet to the `main.rs` file after the code
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run the project by following the next command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following output on execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea8dc213-2434-4a28-bfe1-2f05c0e4f201.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we print a random number from a range provided by the developer,
    which in our case is a value between 0 and 10; we use the `rand` library for performing
    this option.
  prefs: []
  type: TYPE_NORMAL
- en: We import the `rand` library with the `extern crate` command and use the `rand::rng`
    module that provides us with the `gen_range` method. The `gen_range` method takes
    two arguments as input that are lower and higher bound values of the range in
    which it is supposed to predict a random number. In the case of interchanging
    the position, it would panic.
  prefs: []
  type: TYPE_NORMAL
- en: Writing lines to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `std` crate, which is the Rust standard library
    providing various modules and functionalities. We will use the filesystem capabilities
    of the crate to write a three-line message to a file, and then read it back, one
    line at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to set up the project and install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new binary project named `sample_file`, and enter the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `error_chain` crate dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the dependency by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This step will print a `hello world` as output, as we have not yet made any
    modifications to the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types, after
    the code header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `run` method and the `quick_main!` macro by copying and pasting
    the following code snippet with the `error_chain!` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run the project by running the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following output on execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c836a9f-9a97-4b57-91f0-5ba19124f5b5.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we write a three-line message to a file, `lines.txt`. We assign
    the string `lines.txt` to a variable named path, which we pass as an argument
    to `File::create(path)` that creates the file, and we assign it to a variable
    `output`. Using the `write!` macro, we write a string `"Rust\n\nFun"` to the mutable
    `output` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We read the file, then read back with `File::open(path)` and assign it to the
    `input` variable. We create a variable named `buffered` that stores the content
    of the file; we then read each line of the file with the `Lines` iterator created
    by `BufRead::lines` using a `for` loop and print it.
  prefs: []
  type: TYPE_NORMAL
- en: BufRead is a trait, and the most common way to get one is from a BufReader that
    is constructed from some type that implements `Read`; here, a file. The file is
    opened for writing with `File::create` and for reading with `File::open`.
  prefs: []
  type: TYPE_NORMAL
- en: The `error-chain` crate is a library for consistent and reliable error-handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  prefs: []
  type: TYPE_NORMAL
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    type that acts like a *real* `main` function. We use the `error-chain` crate to
    make `?` work within `run`. This is using the `error_chain!` macro from the `error-chain`
    crate to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  prefs: []
  type: TYPE_NORMAL
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program executed
    successfully without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing unstructured JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `serde_json` crate that provides various modules
    and functionalities for serializing and deserializing unstructured JSON. We will
    use the encoding capabilities to parse JSON to a type of the caller's choice.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to set up the project and install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new binary project named `sample_json`, and enter the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `error_chain` and `serde_json` crates dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the dependency by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This step will print `hello world` as output, as we have not yet made any modifications
    to the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types, after
    the code header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `run` method and the `quick_main!` macro by copying and pasting
    the following code snippet with the `error_chain!` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run the project by running the following next command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following output on execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f175f09e-35b4-4ee1-9778-5ce78d7504ee.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we use the `serde_json` crate that provides us with a `from_str`
    function that allows the developer to parse `&str` of JSON into a type of the
    caller's choice. We assign a string format of JSON to the `j` variable, after
    which we call `serde_json::from_str(j)` and assign the output to a variable named
    `parsed`. The unstructured JSON is parsed into a universal `serde_json::Value`
    type that represents any valid JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: We then compare, with the `assert_eq!` macro, the value of the parsed `&str`
    of JSON with what we expect the parsed value to be. The expected value is declared
    using the `json!` macro.
  prefs: []
  type: TYPE_NORMAL
- en: The `error-chain` crate is a library for consistent and reliable error handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  prefs: []
  type: TYPE_NORMAL
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    that acts like a *real* `main` function. We use the `error-chain` crate to make
    `?` work within `run`. This is using the `error_chain!` macro from the `error-chain`
    to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  prefs: []
  type: TYPE_NORMAL
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program executed
    successfully without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing URL from a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `url` crate that provides various modules and
    functionalities for networking capabilities. We will use the `parse` functionality
    of the crate to take a string input and convert it into the URL format after validation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the following steps to set up the project and install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new binary project named `sample_url`, and enter the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `error_chain` and `url` crates dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the dependency by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This step will print `hello world` as output, as we have not yet made any modifications
    to the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types, after
    the code header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `run` method and the `quick_main!` macro by copying and pasting
    the following code snippet with the `error_chain!` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run the project by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following output on execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84994bd7-9ce6-4dbb-affb-42be6f0790a2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we use the `parse` method of the `url` crate to validate and
    parse a `&str` from the data into a `Url` struct. The input string will be transformed
    into `Result<Url, ParseError>` on the method's return value.
  prefs: []
  type: TYPE_NORMAL
- en: We create a variable named `s` and assign it to the URL that we want to parse;
    the value is sent to the method with `Url::parse(s)`. Once the URL has been parsed,
    it can be used with all methods on the URL type. Finally we print the path part
    of the `parsed` variable that stores the return value of the `parse` method.
  prefs: []
  type: TYPE_NORMAL
- en: The URL in this code parses successfully, but swapping it out for a malformed
    URL will print a message containing an explanation of what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The `error-chain` crate is a library for consistent and reliable error handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  prefs: []
  type: TYPE_NORMAL
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    that acts like a *real* `main` function. We use the `error-chain` crate to make
    `?` work within `run`. This is using the `error_chain!` macro from `error-chain`
    to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  prefs: []
  type: TYPE_NORMAL
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program executed
    successfully without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Decompressing a tarball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `tar` and `flate2` crates that provide various
    modules and functionalities for compression capabilities. We will extract the
    contents of a tar file named `archive.tar.gz` in the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the following steps to set up the project and install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new binary project named `sample_decom`, and enter the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `error_chain`, `tar`, and `flate2` crates dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the dependency by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This step will print `hello world` as output, as we have not yet made any modifications
    to the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a sample file, TAR it, and delete it for using it in the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types, after
    the code header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `run` method and the `quick_main!` macro by copying and pasting
    the following code snippet with the `error_chain!` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run the project by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following output on execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e020f5e-eee5-4e96-8e27-957f5a469150.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we open the file using the `File::open(path)` method and assign
    it to the `tar_gz` variable; the `path` variable contains the string value, which
    is the location of the `archive.tar.gz` file. We then decompress the `tar_gz`
    file using the `flate2` crate with the `flate2::read::GzDecoder::new(tar_gz)`
    command, and assign its return value to the `tar` variable. We extract the files
    with the `tar::Archive::unpack` method by first creating a variable `archive`
    by calling `Archive::new(tar)` which loads the archive, and then we get all the
    files from a compressed tarball named `archive.tar.gz` located in the current
    working directory by calling `archive.unpack(".")`.
  prefs: []
  type: TYPE_NORMAL
- en: The `error-chain` crate is a library for consistent and reliable error handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  prefs: []
  type: TYPE_NORMAL
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    that acts like a *real* `main` function. We use `error-chain` crate to make `?`
    work within `run`. This is using the `error_chain!` macro from the `error-chain`
    to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  prefs: []
  type: TYPE_NORMAL
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program executed
    successfully without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing a directory to a tarball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `tar` and `flate2` crates that provide various
    modules and functionalities for compression capabilities. We will compress the
    contents of a directory which, in this recipe, is the current directory to a TAR
    file named `archive.tar.gz` in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the following steps to set up the project and install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new binary project named `sample_com`, and enter the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `error_chain`, `tar`, and `flate2` crates dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the dependency by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This step will print `hello world` as output as we have not yet made any modification
    to the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types after the
    code header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `run` method and the `quick_main!` macro by copy pasting the following
    code snippet the `error_chain!` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run the project by following the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following output on execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/667f1c43-f74c-4e56-b504-84a5f7397c7a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we compress the source code directory into `archive.tar.gz`.
    We create a file with `File::create("archive.tar.gz")` and assign it to the `tar_gz`
    variable. We then wrap it using `flate2::write::GzEncoder` and `tar::Builder`.
    Lastly, we add the contents of the `../sample_com` directory recursively into
    the archive under `./backup` with `Builder::append_dir_all`.
  prefs: []
  type: TYPE_NORMAL
- en: '`flate2::write::GzEncoder` is responsible for transparently compressing the
    data prior to writing it to `archive.tar.gz`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `error-chain` crate is a library for consistent and reliable error handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  prefs: []
  type: TYPE_NORMAL
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    that acts like a *real* `main` function. We use the `error-chain` crate to make
    `?` work within `run`. This is using the `error_chain!` macro from the `error-chain`
    to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  prefs: []
  type: TYPE_NORMAL
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program executed
    successfully without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Finding file extensions recursively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `glob` crate that provides various modules and
    functionalities for filesystem capabilities. We will recursively find all PNG
    files in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the following steps to set up the project and install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new binary project named `sample_ext`, and enter the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `error_chain` and `glob` crates dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '`cargo add crate_name` automatically adds the latest version of the dependency
    to the `Cargo.toml` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the dependency by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This step will print `hello world` as outputs, as we have not yet made any modifications
    to the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `error_chain!` macro to define a custom `Error` and `Result` type,
    along with automatic conversions from the standard library error types, after
    the code header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `run` method and the `quick_main!` macro by copying and pasting
    the following code snippet with the `error_chain!` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run the project by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following output on execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94f80ece-72d7-4a70-a9bb-bf39077ce598.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will recursively find all PNG files in the current directory.
    We use the iteration with a `for` loop with different entries of the `glob("**/*.png")`
    method that returns us all the `.png` file extensions in the current directory.
    We have a `**` pattern that matches the current directory and all subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the `**` pattern for any directory, not just the current one.
    For example, `/media/**/*.png` will match all PNGs in media and its subdirectories.
    For other file extensions, change `.png` to the desired one.
  prefs: []
  type: TYPE_NORMAL
- en: The `error-chain` crate is a library for consistent and reliable error handling
    that makes it easier to take full advantage of Rust's powerful error-handling
    features, without the overhead of maintaining boilerplate error types and conversions.
    It implements a strategy for defining your own error types, as well as conversions
    from others' error types.
  prefs: []
  type: TYPE_NORMAL
- en: The basic pattern we use here has a function named `run()` that produces a `Result`
    that acts like a *real* `main` function. We use the `error-chain` crate to make
    `?` work within `run`. This is using the `error_chain!` macro from the `error-chain`
    to define a custom `Error` and `Result` type, along with automatic conversions
    from the crate error types. The automatic conversions make the `?` operator work.
    The `quick_main!` macro generates the actual `main` function and prints out the
    error if it occurs during the course of execution.
  prefs: []
  type: TYPE_NORMAL
- en: We return `Ok(())` to the `quick_run!` macro to ensure that the program is executed
    successfully without any errors.
  prefs: []
  type: TYPE_NORMAL
