<html><head></head><body>
        

                            
                    <h1 class="header-title">Code Organization and Application Architecture</h1>
                
            
            
                
<p>Previously, we outlined some basic concepts of project planning and code architecture. The strategy we recommended specifically called for gathering and listing requirements before adapting them into pseudocode, stub code, and eventually a completed project. This process is still very applicable to larger projects, but we have not covered the aspect of file and module organization. How should code be grouped into files and modules?</p>
<p>To answer this question, we recommend something called <strong>the workshop model</strong>. Imagine a physical workshop with pegboards, shelves, jars, toolboxes, and larger equipment on the floor. When speaking about code architecture, experts often talk about different organizational strategies. It is possible to group code by type, by purpose, by project layer, or by convenience. There are infinite possible strategies, and these are just four common ones. None of these are wrong, though we recommend against choosing any one specifically. Our reason is simple—choose all of them. Nuts and bolts can be organized into jars (by type). Hand tools can be placed in a toolbox (by purpose). Large tools can be placed on the floor (by project layer). Common tools can be hung on a pegboard (by convenience). None of these strategies are invalid, and all of them can be used in the same workshop (project).</p>
<p>In this chapter, we will reorganize the project as it grows. We will combine the principles of planning and architecture that we previously introduced with new concepts of code organization to develop a large software project that is navigable and maintainable.</p>
<p>The learning outcomes of this chapter are as follows:</p>
<ul>
<li>Recognizing and applying by type organization</li>
<li>Recognizing and applying by purpose organization</li>
<li>Recognizing and applying by layer organization</li>
<li>Recognizing and applying by convenience organization</li>
<li>Minimizing code waste during project reorganization</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>A recent version of Rust is necessary to run the examples provided:</p>
<p><a href="https://www.rust-lang.org/en-US/install.html">https://www.rust-lang.org/en-US/install.html</a></p>
<p>This chapter's code is also available on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST">https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST</a></p>
<p>Specific installation and build instructions are also included in each chapter's <kbd>README.md</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shipping a product without sacrificing quality</h1>
                
            
            
                
<p>The client has finished negotiating with your sales team—you won the contract. Now that the contract is signed, your team is on task to bring the simulation up to specification to run all of the elevator systems. The client has provided specifications for each of the three buildings, elevators, motor control, and braking systems. You also learn that the elevator motors have intelligent motor control software that regulates internal voltage and current dynamically. To control the motor, you will only be expected to supply the desired force output. The full specifications are as follows:</p>
<ul>
<li>For building 1, there are the following:
<ul>
<li><strong>Floor heights</strong>: 8m, 4m, 4m, 4m, 4m</li>
<li><strong>Elevator weight</strong>: 1,200 kg</li>
<li><strong>Elevator motor</strong>: Maximum 50,000 N</li>
<li><strong>Elevator driver</strong>: Software interface supplied</li>
</ul>
</li>
<li>For building 2, there are the following:
<ul>
<li><strong>Floor heights</strong>: 5m, 5m, 5m, 5m, 5m, 5m, 5m, 5m</li>
<li><strong>Elevator weight</strong>: 1,350 kg</li>
<li><strong>Elevator motor</strong>: maximum 1,00,000 N</li>
<li><strong>Elevator driver</strong>: Software interface supplied</li>
</ul>
</li>
<li>For building 3, there are the following:
<ul>
<li><strong>Floor heights</strong>: 6m, 4m, 4m, 4m</li>
<li><strong>Elevator weight</strong>: 1,400 kg</li>
<li><strong>Elevator motor</strong>: Maximum 90,000 N</li>
<li><strong>Elevator driver</strong>: Software interface supplied</li>
</ul>
</li>
</ul>
<p>The program now needs to work in operational mode, where new floor requests are accepted and added to the queue. The simulation should also continue to work, now with all three building specifications. The simulation should verify that promised performance and quality metrics are all satisfied. Other than that, your team is free to develop the project as you see fit.</p>
<p>You decide that now is a good time to rethink the organization of the project, with significant new changes required. Using good architecture and project organization practices, you will move code around accordingly to group components orderly and conveniently.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reorganizing the project</h1>
                
            
            
                
<p>Now that we have some ideas of good project architecture, let's plan the project's reorganization. Let's list the possible workshop organization methods:</p>
<ul>
<li>By type</li>
<li>By purpose</li>
<li>By layer</li>
<li>By convenience</li>
</ul>
<p>The by type organization should be used for workshop nuts and bolts type components. Nuts and bolts are highly uniform components that have a different diameter, length, grade, and so on. We have a few good matches here, so let's list objects and interfaces that could be grouped this way:</p>
<ul>
<li>Motors</li>
<li>Buildings</li>
<li>Elevator controllers/drivers</li>
</ul>
<p>The by purpose organization should be used for miscellaneous tools that have a common purpose. We have some good candidates for this style of organization, too:</p>
<ul>
<li>Transport planning (static/dynamic)</li>
<li>The physical interface to an elevator</li>
</ul>
<p>The by layer organization should be used for distinct architectural components that fit well within normal program logic. An example of this would be our physics layer, which is logically independent of other modules. The physics layer exists solely to store constants, formulas, and modeling procedures. Here, we group this by layer:</p>
<ul>
<li>Physics modeling</li>
</ul>
<p>The by convenience organization should be used for common or difficult components. Executables are a good fit for this type of organization because they are always an endpoint, not a library, and don't typically fit into any other organization well:</p>
<ul>
<li>Simulation executable</li>
<li>Analyze executable</li>
<li>Physical elevator driver executable</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Planning content of files by type</h1>
                
            
            
                
<p>These files will be organized using the by type method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the motor_controllers.rs module</h1>
                
            
            
                
<p>All motors will be grouped by type in the <kbd>motor_controller.rs</kbd> module. There will be three motors with varying properties. This module should provide a trait interface to all motors as well as each implementation. The trait should define a method to generate a motor input from the desired force output and also a method to accept a motor input to generate a force. The module must also link in the binary drivers for each motor controller. The old motor controller logic to dynamically control the elevator motor will be moved into a new file called <kbd>motion_controllers.rs</kbd>. The following should be defined in this module:</p>
<ul>
<li>Motor input trait</li>
<li>Motor controller trait</li>
<li>Motor input 1 implementation</li>
<li>Motor controller 1 implementation</li>
<li>Motor input 2 implementation</li>
<li>Motor controller 2 implementation</li>
<li>Motor input 3 implementation</li>
<li>Motor controller 3 implementation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the buildings.rs module</h1>
                
            
            
                
<p>All building specifications will be grouped by type in the <kbd>building.rs</kbd> module. There will be three building specifications. The building should encapsulate all aspects of elevator behavior and control, as well as a specification for the building itself. The module should contain the following:</p>
<ul>
<li>Building trait</li>
<li>Building 1 implementation</li>
<li>Building 2 implementation</li>
<li>Building 3 implementation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Planning content of files by purpose</h1>
                
            
            
                
<p>These files will be organized using the by purpose method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the motion_controllers.rs module</h1>
                
            
            
                
<p>Motion controllers will be organized by purpose. The motion controllers will be responsible for tracking elevator state to control the motor's dynamics. The motion controllers module should contain the following:</p>
<ul>
<li>Motion Controller trait</li>
<li>Smooth Motion Controller implementation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the trip_planning.rs module</h1>
                
            
            
                
<p>Trip planning will be organized by purpose. The planner should work in two modes: static and dynamic. For static mode, the planner should accept a list of floor requests to process. For dynamic mode, the planner should accept floor requests as they come dynamically and add them to the queue. The planner module should contain the following:</p>
<ul>
<li>Planner trait</li>
<li>Static planner implementation</li>
<li>Dynamic planner implementation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the elevator_drivers.rs module</h1>
                
            
            
                
<p>All elevator drivers will be organized by purpose in the <kbd>elevator_driver.rs</kbd> module. There are three elevator drivers that provide binary interfaces to be linked. The <kbd>elevator driver</kbd> module should contain a trait to define an interface to elevator drivers as well as the three implementations. The <kbd>planner</kbd> module should contain the following:</p>
<ul>
<li>Elevator driver trait</li>
<li>Elevator driver 1 implementation</li>
<li>Elevator driver 2 implementation</li>
<li>Elevator driver 3 implementation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Planning content of files by layer</h1>
                
            
            
                
<p>These files will be organized using the by layer method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the physics.rs module</h1>
                
            
            
                
<p>The <kbd>physics</kbd> module will group all physics-related code by layer. There will be miscellaneous code here, though it should all fit in the form of some sort of simulation or prediction. The module should contain the following:</p>
<ul>
<li>Unit conversions</li>
<li>Formula implementations</li>
<li>Any other logic required for the simulation or operation of elevators</li>
<li>Physics simulation loop</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the data_recorder.rs module</h1>
                
            
            
                
<p>The data recorder module will move the <kbd>DataRecorder</kbd> trait and implementation into its own module. It should contain the following:</p>
<ul>
<li>The <kbd>DataRecorder</kbd> trait</li>
<li>Simple data recorder implementation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Planning the content of files by convenience</h1>
                
            
            
                
<p>These files will be organized using the by convenience method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the simulate_trip.rs executable</h1>
                
            
            
                
<p>The <kbd>simulate_trip.rs</kbd> executable will be organized by convenience. The scope of the trip simulation executable has not changed significantly. This file should contain the following:</p>
<ul>
<li>Argument and input parsing</li>
<li>Data logger definition</li>
<li>Simulation setup</li>
<li>Run simulation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the analyze_trip.rs executable</h1>
                
            
            
                
<p>The <kbd>analyze_trip.rs</kbd> executable will be organized by convenience. The scope of the analyze trip executable has not changed significantly. This file should contain the following:</p>
<ul>
<li>Argument and input parsing</li>
<li>Check specifications for acceptance or rejection</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the operate_elevator.rs executable</h1>
                
            
            
                
<p>The <kbd>operate_elevator.rs</kbd> executable will be organized by convenience. The operate elevator executable should closely resemble the simulate elevator executable logic. This file should contain the following:</p>
<ul>
<li>Argument and input parsing</li>
<li>Setup elevator drivers to match specified building code</li>
<li>Run the elevator with dynamic planning</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Mapping code changes and additions</h1>
                
            
            
                
<p>Now that we have organized our concepts, data structures, and logic into files, we can now proceed with the normal process to transform requirements into code. For each module, we will look at the required elements and produce code to satisfy those requirements.</p>
<p>Here, we break down all code development steps by module. Different modules have different organizations, so pay attention for patterns regarding organization and code development.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing code by type</h1>
                
            
            
                
<p>These files will be organized using the by type method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the motor_controllers.rs module</h1>
                
            
            
                
<p>The new <kbd>motor_controller</kbd> module serves as an adapter to all of the linked motor drivers and their interfaces, and provides a single uniform interface. Let's see how:</p>
<ol>
<li>First, let's link all the drivers from the software provided into our program:</li>
</ol>
<pre class="p1" style="padding-left: 60px">use libc::c_int;<br/><br/>#[link(name = "motor1")]<br/>extern {<br/>   pub fn motor1_adjust_motor(target_force: c_int) -&gt; c_int;<br/>}<br/><br/>#[link(name = "motor2")]<br/>extern {<br/>   pub fn motor2_adjust_motor(target_force: c_int) -&gt; c_int;<br/>}<br/><br/>#[link(name = "motor3")]<br/>extern {<br/>   pub fn motor3_adjust_motor(target_force: c_int) -&gt; c_int;<br/>}</pre>
<p style="padding-left: 60px">This section tells our program to link to statically compiled libraries named something like <kbd>libmotor1.a</kbd>, <kbd>libmotor2.a</kbd>, and <kbd>libmotor3.a</kbd>. Our example chapter also contains the source and build script for these libraries, so you can inspect each one. In a full project, there are many ways to link to an external binary library, this being only one of many options.</p>
<ol start="2">
<li>Next, we should make a trait for <kbd>MotorInput</kbd> and a generic <kbd>MotorDriver</kbd> interface, including implementations for each motor. The code is as follows:</li>
</ol>
<pre class="p1" style="padding-left: 60px">#[derive(Clone,Serialize,Deserialize,Debug)]<br/>pub enum MotorInput<br/>{<br/>   Motor1 { target_force: f64 },<br/>   Motor2 { target_force: f64 },<br/>   Motor3 { target_force: f64 },<br/>}<br/><br/>pub trait MotorDriver<br/>{<br/>   fn adjust_motor(&amp;self, input: MotorInput);<br/>}<br/><br/>struct Motor1;<br/>impl MotorDriver for Motor1 { ... }<br/><br/>//Motor 2<br/><br/>//Motor 3</pre>
<ol start="3">
<li>Next, we should implement the motor controller trait and implementations. The motor controller should wrap motor information and drivers into a uniform interface. The <kbd>MotorDriver</kbd> and <kbd>MotorController</kbd> trait here are coerced into a simple upward/downward force model. Therefore, the relation between driver and controller is one-to-one and cannot be completely abstracted into a common trait. The code for it is as follows:</li>
</ol>
<pre class="p1" style="padding-left: 60px">pub trait MotorController<br/>{<br/>   fn adjust_motor(&amp;self, f: f64);<br/>   fn max_force(&amp;self) -&gt; f64;<br/>}<br/><br/>pub struct MotorController1<br/>{<br/>   motor: Motor1<br/>}<br/><br/>impl MotorController for MotorController1 { ... }<br/><br/>//Motor Controller 2 ...<br/><br/>//Motor Controller 3 ...</pre>
<p>The entire code for these is present in the GitHub repository at: <a href="https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST">https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the buildings.rs module</h1>
                
            
            
                
<p>The building module is again grouped by type. There should be a common trait interface that is implemented by the three buildings. The building traits and structures should additionally wrap and expose interfaces to appropriate elevator drivers and motor controllers. The code is as follows:</p>
<ol>
<li>First, we define the <kbd>Building</kbd> trait:</li>
</ol>
<pre class="p1" style="padding-left: 30px">pub trait Building<br/>{<br/>   fn get_elevator_driver(&amp;self) -&gt; Box&lt;ElevatorDriver&gt;;<br/>   fn get_motor_controller(&amp;self) -&gt; Box&lt;MotorController&gt;;<br/>   fn get_floor_heights(&amp;self) -&gt; Vec&lt;f64&gt;;<br/>   fn get_carriage_weight(&amp;self) -&gt; f64;<br/>   fn clone(&amp;self) -&gt; Box&lt;Building&gt;;<br/>   fn serialize(&amp;self) -&gt; u64;<br/>}</pre>
<ol start="2">
<li>Then, we define a <kbd>deserialize</kbd> helper function:</li>
</ol>
<pre class="p1" style="padding-left: 30px">pub fn deserialize(n: u64) -&gt; Box&lt;Building&gt;<br/>{<br/>   if n==1 {<br/>      Box::new(Building1)<br/>   } else if n==2 {<br/>      Box::new(Building2)<br/>   } else {<br/>      Box::new(Building3)<br/>   }<br/>}</pre>
<ol start="3">
<li>Then, we define some miscellaneous helper functions:</li>
</ol>
<pre class="p1" style="padding-left: 30px">pub fn getCarriageFloor(floorHeights: Vec&lt;f64&gt;, height: f64) -&gt; u64<br/>{<br/>   let mut c = 0.0;<br/>   for (fi, fht) in floorHeights.iter().enumerate() {<br/>      c += fht;<br/>      if height &lt;= c {<br/>         return (fi as u64)<br/>      }<br/>   }<br/>   (floorHeights.len()-1) as u64<br/>}<br/><br/>pub fn getCumulativeFloorHeight(heights: Vec&lt;f64&gt;, floor: u64) -&gt; f64<br/>{<br/>   heights.iter().take(floor as usize).sum()<br/>}</pre>
<ol start="4">
<li>Finally, we define the buildings and their trait implementations:</li>
</ol>
<pre class="p1" style="padding-left: 30px">pub struct Building1;<br/>impl Building for Building1 { ... }<br/><br/>//Building 2<br/><br/>//Building 3</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing code by purpose</h1>
                
            
            
                
<p>These files will be organized using the by purpose method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the motion_controllers.rs module</h1>
                
            
            
                
<p>The old logic from <kbd>motor_controllers.rs</kbd> for dynamically adjusting motor force will be moved to this module. The <kbd>SmoothMotionController</kbd> does not change much and the code becomes as follows:</p>
<pre class="p1" style="padding-left: 30px">pub trait MotionController<br/>{<br/>   fn init(&amp;mut self, esp: Box&lt;Building&gt;, est: ElevatorState);<br/>   fn adjust(&amp;mut self, est: &amp;ElevatorState, dst: u64) -&gt; f64;<br/>}<br/><br/>pub struct SmoothMotionController<br/>{<br/>   pub esp: Box&lt;Building&gt;,<br/>   pub timestamp: f64<br/>}<br/><br/>impl MotionController for SmoothMotionController<br/>{<br/>   ...<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the trip_planning.rs module</h1>
                
            
            
                
<p>The trip planner should work in static and dynamic modes. The basic structure is a FIFO queue, pushing requests into the queue, and popping the oldest element. We may be able to unify both static and dynamic modes into a single implementation, which would look like the following.</p>
<p>Trip planning will be organized by purpose. The planner should work in two modes—static and dynamic. For static mode, the planner should accept a list of floor requests to process. For dynamic mode, the planner should accept floor requests as they come dynamically and add them to the queue. The planner module should contain the following:</p>
<pre style="padding-left: 30px">use std::collections::VecDeque;<br/><br/>pub struct FloorRequests<br/>{<br/>   pub requests: VecDeque&lt;u64&gt;<br/>}<br/><br/>pub trait RequestQueue<br/>{<br/>   fn add_request(&amp;mut self, req: u64);<br/>   fn add_requests(&amp;mut self, reqs: &amp;Vec&lt;u64&gt;);<br/>   fn pop_request(&amp;mut self) -&gt; Option&lt;u64&gt;;<br/>}<br/><br/>impl RequestQueue for FloorRequests<br/>{<br/>   fn add_request(&amp;mut self, req: u64)<br/>   {<br/>      self.requests.push_back(req);<br/>   }<br/>   fn add_requests(&amp;mut self, reqs: &amp;Vec&lt;u64&gt;)<br/>   {<br/>      for req in reqs<br/>      {<br/>         self.requests.push_back(*req);<br/>      }<br/>   }<br/>   fn pop_request(&amp;mut self) -&gt; Option&lt;u64&gt;<br/>   {<br/>      self.requests.pop_front()<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the elevator_drivers.rs module</h1>
                
            
            
                
<p>The elevator drivers module should interface with the static libraries provided and additionally provide a common interface to all elevator drivers. The code looks like the following:</p>
<pre class="p1" style="padding-left: 30px">use libc::c_int;<br/><br/>#[link(name = "elevator1")]<br/>extern {<br/>   pub fn elevator1_poll_floor_request() -&gt; c_int;<br/>}<br/><br/>#[link(name = "elevator2")]<br/>extern {<br/>   pub fn elevator2_poll_floor_request() -&gt; c_int;<br/>}<br/><br/>#[link(name = "elevator3")]<br/>extern {<br/>   pub fn elevator3_poll_floor_request() -&gt; c_int;<br/>}<br/><br/>pub trait ElevatorDriver<br/>{<br/>   fn poll_floor_request(&amp;self) -&gt; Option&lt;u64&gt;;<br/>}<br/><br/>pub struct ElevatorDriver1;<br/>impl ElevatorDriver for ElevatorDriver1<br/>{<br/>   fn poll_floor_request(&amp;self) -&gt; Option&lt;u64&gt;<br/>   {<br/>      unsafe {<br/>         let req = elevator1_poll_floor_request();<br/>         if req &gt; 0 {<br/>            Some(req as u64)<br/>         } else {<br/>            None<br/>         }<br/>      }<br/>   }<br/>}<br/><br/>//Elevator Driver 2<br/><br/>//Elevator Driver 3</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing code by layer</h1>
                
            
            
                
<p>These files will be organized using the by layer method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the physics.rs module</h1>
                
            
            
                
<p>The physics module has become much smaller. It now contains a few struct definitions and constants and the central <kbd>simulate_elevator</kbd> method. The result is as follows:</p>
<pre style="padding-left: 30px">#[derive(Clone,Debug,Serialize,Deserialize)]<br/>pub struct ElevatorState {<br/>   pub timestamp: f64,<br/>   pub location: f64,<br/>   pub velocity: f64,<br/>   pub acceleration: f64,<br/>   pub motor_input: f64<br/>}<br/><br/>pub const MAX_JERK: f64 = 0.2;<br/>pub const MAX_ACCELERATION: f64 = 2.0;<br/>pub const MAX_VELOCITY: f64 = 5.0;<br/><br/>pub fn simulate_elevator(esp: Box&lt;Building&gt;, est: ElevatorState, floor_requests: &amp;mut Box&lt;RequestQueue&gt;,<br/>                         mc: &amp;mut Box&lt;MotionController&gt;, dr: &amp;mut Box&lt;DataRecorder&gt;)<br/>{<br/>   //immutable input becomes mutable local state<br/>   let mut esp = esp.clone();<br/>   let mut est = est.clone();<br/><br/>   //initialize MotorController and DataController<br/>   mc.init(esp.clone(), est.clone());<br/>   dr.init(esp.clone(), est.clone());<br/><br/>   //5. Loop while there are remaining floor requests<br/>   let original_ts = Instant::now();<br/>   thread::sleep(time::Duration::from_millis(1));<br/>   let mut next_floor = floor_requests.pop_request();<br/>   while let Some(dst) = next_floor<br/>   {<br/>      //5.1. Update location, velocity, and acceleration<br/>      let now = Instant::now();<br/>      let ts = now.duration_since(original_ts)<br/>                  .as_fractional_secs();<br/>      let dt = ts - est.timestamp;<br/>      est.timestamp = ts;<br/><br/>      est.location = est.location + est.velocity * dt;<br/>      est.velocity = est.velocity + est.acceleration * dt;<br/>      est.acceleration = {<br/>         let F = est.motor_input;<br/>         let m = esp.get_carriage_weight();<br/>         -9.8 + F/m<br/>      };<br/><br/>      //5.2. If next floor request in queue is satisfied, then remove from queue<br/>      if (est.location - getCumulativeFloorHeight(esp.get_floor_heights(), dst)).abs() &lt; 0.01 &amp;&amp;<br/>         est.velocity.abs() &lt; 0.01<br/>      {<br/>         est.velocity = 0.0;<br/>         next_floor = floor_requests.pop_request();<br/>      }<br/><br/>      //5.4. Print realtime statistics<br/>      dr.poll(est.clone(), dst);<br/><br/>      //5.3. Adjust motor control to process next floor request<br/>      est.motor_input = mc.poll(est.clone(), dst);<br/><br/>      thread::sleep(time::Duration::from_millis(1));<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the data_recorders.rs module</h1>
                
            
            
                
<p>To separate responsibilities and not let individual modules get too big, we should move the data recorder implementation out of the simulation and into its own module. The result is as follows:</p>
<ol>
<li>Define the <kbd>DataRecorder</kbd> trait:</li>
</ol>
<pre style="padding-left: 30px">pub trait DataRecorder<br/>{<br/>   fn init(&amp;mut self, esp: Box&lt;Building&gt;, est: ElevatorState);<br/>   fn record(&amp;mut self, est: ElevatorState, dst: u64);<br/>   fn summary(&amp;mut self);<br/>}<br/></pre>
<ol start="2">
<li>Define the <kbd>SimpleDataRecorder</kbd> struct:</li>
</ol>
<pre style="padding-left: 30px">struct SimpleDataRecorder&lt;W: Write&gt;<br/>{<br/>   esp: Box&lt;Building&gt;,<br/>   termwidth: u64,<br/>   termheight: u64,<br/>   stdout: raw::RawTerminal&lt;W&gt;,<br/>   log: File,<br/>   record_location: Vec&lt;f64&gt;,<br/>   record_velocity: Vec&lt;f64&gt;,<br/>   record_acceleration: Vec&lt;f64&gt;,<br/>   record_force: Vec&lt;f64&gt;,<br/>}</pre>
<ol start="3">
<li>Define the <kbd>SimpleDataRecorder</kbd> constructor:</li>
</ol>
<pre style="padding-left: 30px">pub fn newSimpleDataRecorder(esp: Box&lt;Building&gt;) -&gt; Box&lt;DataRecorder&gt;<br/>{<br/>   let termsize = termion::terminal_size().ok();<br/>   Box::new(SimpleDataRecorder {<br/>      esp: esp.clone(),<br/>      termwidth: termsize.map(|(w,_)| w-2).expect("termwidth") as u64,<br/>      termheight: termsize.map(|(_,h)| h-2).expect("termheight") as u64,<br/>      stdout: io::stdout().into_raw_mode().unwrap(),<br/>      log: File::create("simulation.log").expect("log file"),<br/>      record_location: Vec::new(),<br/>      record_velocity: Vec::new(),<br/>      record_acceleration: Vec::new(),<br/>      record_force: Vec::new()<br/>   })<br/>}</pre>
<ol start="4">
<li>Define the <kbd>SimpleDataRecorder</kbd> implementation of the <kbd>DataRecorder</kbd> trait:</li>
</ol>
<pre style="padding-left: 30px">impl&lt;W: Write&gt; DataRecorder for SimpleDataRecorder&lt;W&gt;<br/>{<br/>   fn init(&amp;mut self, esp: Box&lt;Building&gt;, est: ElevatorState)<br/>   {<br/>      ...<br/>   }<br/>   fn record(&amp;mut self, est: ElevatorState, dst: u64)<br/>      ...<br/>   }<br/>   fn summary(&amp;mut self)<br/>   {<br/>      ...<br/>   }<br/>}</pre>
<ol start="5">
<li>Define the miscellaneous helper functions:</li>
</ol>
<pre style="padding-left: 30px">fn variable_summary&lt;W: Write&gt;(stdout: &amp;mut raw::RawTerminal&lt;W&gt;, vname: String, data: &amp;Vec&lt;f64&gt;) {<br/>   let (avg, dev) = variable_summary_stats(data);<br/>   variable_summary_print(stdout, vname, avg, dev);<br/>}<br/><br/>fn variable_summary_stats(data: &amp;Vec&lt;f64&gt;) -&gt; (f64, f64)<br/>{<br/>   //calculate statistics<br/>   let N = data.len();<br/>   let sum = data.iter().sum::&lt;f64&gt;();<br/>   let avg = sum / (N as f64);<br/>   let dev = (<br/>       data.clone().into_iter()<br/>       .map(|v| (v - avg).powi(2))<br/>       .sum::&lt;f64&gt;()<br/>       / (N as f64)<br/>   ).sqrt();<br/>   (avg, dev)<br/>}<br/><br/>fn variable_summary_print&lt;W: Write&gt;(stdout: &amp;mut raw::RawTerminal&lt;W&gt;, vname: String, avg: f64, dev: f64)<br/>{<br/>   //print formatted output<br/>   writeln!(stdout, "Average of {:25}{:.6}", vname, avg);<br/>   writeln!(stdout, "Standard deviation of {:14}{:.6}", vname, dev);<br/>   writeln!(stdout, "");<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing code by convenience</h1>
                
            
            
                
<p>These files will be organized using the by convenience method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the simulate_trip.rs executable</h1>
                
            
            
                
<p>The simulate trip changes quite a bit because the <kbd>DataRecorder</kbd> logic has been removed. The initialization of the simulation is also very different from before. The end result is as follows:</p>
<ol>
<li>Initialize <kbd>ElevatorState</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 30px">//1. Store location, velocity, and acceleration state<br/>//2. Store motor input target force<br/>let mut est = ElevatorState {<br/>   timestamp: 0.0,<br/>   location: 0.0,<br/>   velocity: 0.0,<br/>   acceleration: 0.0,<br/>   motor_input: 0.0<br/>};</pre>
<ol start="2">
<li>Initialize the building description and floor requests:</li>
</ol>
<pre style="padding-left: 30px">//3. Store input building description and floor requests<br/>let mut esp: Box&lt;Building&gt; = Box::new(Building1);<br/>let mut floor_requests: Box&lt;RequestQueue&gt; = Box::new(FloorRequests {<br/>   requests: Vec::new()<br/>});</pre>
<ol start="3">
<li>Parse the input and store it as building description and floor requests:</li>
</ol>
<pre class="p1" style="padding-left: 30px">//4. Parse input and store as building description and floor requests<br/>match env::args().nth(1) {<br/>   Some(ref fp) if *fp == "-".to_string()  =&gt; {<br/>      ...<br/>   },<br/>   None =&gt; {<br/>      ...<br/>   },<br/>   Some(fp) =&gt; {<br/>      ...<br/>   }<br/>}</pre>
<ol start="4">
<li>Initialize the data recorder and motion controller:</li>
</ol>
<pre style="padding-left: 30px">let mut dr: Box&lt;DataRecorder&gt; = newSimpleDataRecorder(esp.clone());<br/>let mut mc: Box&lt;MotionController&gt; = Box::new(SmoothMotionController {<br/>  timestamp: 0.0,<br/>  esp: esp.clone()<br/>});</pre>
<ol start="5">
<li>Run the elevator simulation:</li>
</ol>
<pre class="mce-root" style="padding-left: 30px">simulate_elevator(esp, est, &amp;mut floor_requests, &amp;mut mc, &amp;mut dr);</pre>
<ol start="6">
<li>Print the simulation summary:</li>
</ol>
<pre style="padding-left: 30px">dr.summary();</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the analyze_trip.rs executable</h1>
                
            
            
                
<p>The analyze trip executable will only change a little bit, but only to accommodate symbols that have been moved and types that are now serializable with SerDe. The result is as follows:</p>
<ol>
<li>Define the <kbd>Trip</kbd> data structure:</li>
</ol>
<pre style="padding-left: 30px">#[derive(Clone)]<br/>struct Trip {<br/>   dst: u64,<br/>   up: f64,<br/>   down: f64<br/>}</pre>
<ol start="2">
<li>Initialize the variables:</li>
</ol>
<pre style="padding-left: 30px">let simlog = File::open("simulation.log").expect("read simulation log");<br/>let mut simlog = BufReader::new(&amp;simlog);<br/>let mut jerk = 0.0;<br/>let mut prev_est: Option&lt;ElevatorState&gt; = None;<br/>let mut dst_timing: Vec&lt;Trip&gt; = Vec::new();<br/>let mut start_location = 0.0;</pre>
<ol start="3">
<li>Iterate over log lines and initialize the elevator specification:</li>
</ol>
<pre style="padding-left: 30px">let mut first_line = String::new();<br/>let len = simlog.read_line(&amp;mut first_line).unwrap();<br/>let spec: u64 = serde_json::from_str(&amp;first_line).unwrap();<br/>let esp: Box&lt;Building&gt; = buildings::deserialize(spec);<br/><br/>for line in simlog.lines() {<br/>   let l = line.unwrap();<br/>   //Check elevator state records<br/>}</pre>
<ol start="4">
<li>Check the elevator state records:</li>
</ol>
<pre style="padding-left: 30px">let (est, dst): (ElevatorState,u64) = serde_json::from_str(&amp;l).unwrap();<br/>let dl = dst_timing.len();<br/>if dst_timing.len()==0 || dst_timing[dl-1].dst != dst {<br/>   dst_timing.push(Trip { dst:dst, up:0.0, down:0.0 });<br/>}<br/><br/>if let Some(prev_est) = prev_est {<br/>   let dt = est.timestamp - prev_est.timestamp;<br/>   if est.velocity &gt; 0.0 {<br/>      dst_timing[dl-1].up += dt;<br/>   } else {<br/>      dst_timing[dl-1].down += dt;<br/>   }<br/>   let da = (est.acceleration - prev_est.acceleration).abs();<br/>   jerk = (jerk * (1.0 - dt)) + (da * dt);<br/>   if jerk.abs() &gt; 0.22 {<br/>      panic!("jerk is outside of acceptable limits: {} {:?}", jerk, est)<br/>   }<br/>} else {<br/>   start_location = est.location;<br/>}<br/><br/>if est.acceleration.abs() &gt; 2.2 {<br/>   panic!("acceleration is outside of acceptable limits: {:?}", est)<br/>}<br/><br/>if est.velocity.abs() &gt; 5.5 {<br/>   panic!("velocity is outside of acceptable limits: {:?}", est)<br/>}<br/><br/>prev_est = Some(est);</pre>
<ol start="5">
<li>Check that the elevator does not backup:</li>
</ol>
<pre style="padding-left: 30px">//elevator should not backup<br/>let mut total_time = 0.0;<br/>let mut total_direct = 0.0;<br/>for trip in dst_timing.clone()<br/>{<br/>   total_time += (trip.up + trip.down);<br/>   if trip.up &gt; trip.down {<br/>      total_direct += trip.up;<br/>   } else {<br/>      total_direct += trip.down;<br/>   }<br/>}<br/><br/>if (total_direct / total_time) &lt; 0.9 {<br/>   panic!("elevator back up is too common: {}", total_direct / total_time)<br/>}</pre>
<ol start="6">
<li>Check that the trips finish within 20% of their theoretical limit:</li>
</ol>
<pre style="padding-left: 30px">let mut trip_start_location = start_location;<br/>let mut theoretical_time = 0.0;<br/>let floor_heights = esp.get_floor_heights();<br/>for trip in dst_timing.clone()<br/>{<br/>   let next_floor = getCumulativeFloorHeight(floor_heights.clone(), trip.dst);<br/>   let d = (trip_start_location - next_floor).abs();<br/>   theoretical_time += (<br/>      2.0*(MAX_ACCELERATION / MAX_JERK) +<br/>      2.0*(MAX_JERK / MAX_ACCELERATION) +<br/>      d / MAX_VELOCITY<br/>   );<br/>   trip_start_location = next_floor;<br/>}<br/><br/>if total_time &gt; (theoretical_time * 1.2) {<br/>   panic!("elevator moves to slow {} {}", total_time, theoretical_time * 1.2)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the operate_elevator.rs executable</h1>
                
            
            
                
<p>The operate elevator is very similar to the <kbd>simulate_trip.rs</kbd> and physics <kbd>run_simulation</kbd> code. The most significant difference is the ability to continue running while dynamically accepting new requests and adjusting motor control using the linked libraries. In the main executable, we follow the same logical process as before, adjusted for new names and type signatures:</p>
<ol>
<li>Initialize <kbd>ElevatorState</kbd>:</li>
</ol>
<pre style="padding-left: 30px">//1. Store location, velocity, and acceleration state<br/>//2. Store motor input target force<br/>let mut est = ElevatorState {<br/>   timestamp: 0.0,<br/>   location: 0.0,<br/>   velocity: 0.0,<br/>   acceleration: 0.0,<br/>   motor_input: 0.0<br/>};</pre>
<ol start="2">
<li>Initialize <kbd>MotionController</kbd>:</li>
</ol>
<pre style="padding-left: 30px">let mut mc: Box&lt;MotionController&gt; = Box::new(SmoothMotionController {<br/>   timestamp: 0.0,<br/>   esp: esp.clone()<br/>});<br/>mc.init(esp.clone(), est.clone());</pre>
<ol start="3">
<li>Start the operating loop to process incoming floor requests:</li>
</ol>
<pre style="padding-left: 30px">//5. Loop continuously checking for new floor requests<br/>let original_ts = Instant::now();<br/>thread::sleep(time::Duration::from_millis(1));<br/>let mut next_floor = floor_requests.pop_request();<br/>while true<br/>{<br/>   if let Some(dst) = next_floor {<br/>      //process floor request<br/>   }</pre>
<pre style="padding-left: 30px"><br/>   //check for dynamic floor requests<br/>   if let Some(dst) = esp.get_elevator_driver().poll_floor_request()<br/>   {<br/>      floor_requests.add_request(dst);<br/>   }<br/>}</pre>
<ol start="4">
<li>In the processing loop, update the physics approximations:</li>
</ol>
<pre style="padding-left: 30px">//5.1. Update location, velocity, and acceleration<br/>let now = Instant::now();<br/>let ts = now.duration_since(original_ts)<br/>            .as_fractional_secs();<br/>let dt = ts - est.timestamp;<br/>est.timestamp = ts;<br/><br/>est.location = est.location + est.velocity * dt;<br/>est.velocity = est.velocity + est.acceleration * dt;<br/>est.acceleration = {<br/>   let F = est.motor_input;<br/>   let m = esp.get_carriage_weight();<br/>   -9.8 + F/m<br/>};</pre>
<ol start="5">
<li>If the current floor request is satisfied, remove it from the queue:</li>
</ol>
<pre style="padding-left: 30px">//5.2. If next floor request in queue is satisfied, then remove from queue<br/>if (est.location - getCumulativeFloorHeight(esp.get_floor_heights(), dst)).abs() &lt; 0.01 &amp;&amp; est.velocity.abs() &lt; 0.01<br/>{<br/>   est.velocity = 0.0;<br/>   next_floor = floor_requests.pop_request();<br/>}</pre>
<ol start="6">
<li>Adjust the motor control:</li>
</ol>
<pre style="padding-left: 30px">//5.3. Adjust motor control to process next floor request<br/>est.motor_input = mc.poll(est.clone(), dst);<br/><br/>//Adjust motor<br/>esp.get_motor_controller().adjust_motor(est.motor_input);</pre>
<ol start="2"/>
<ol start="3"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Reflecting on the project structure</h1>
                
            
            
                
<p>Now that we have developed code to organize and connect different elevator functions, as well as three executables to simulate, analyze, and operate the elevators, let's ask ourselves this—how does it all fit together, and have we done a good job architecting this project thus far?</p>
<p>Reviewing this chapter, we can quickly see that we have made use of four different code organization techniques. At a more casual level, the code seems to fall into categories, as follows:</p>
<ul>
<li><strong>Luggage</strong>: Like drivers that need to be connected, but may be difficult to work with</li>
<li><strong>Nuts</strong>, <strong>bolts</strong>, and <strong>gears</strong>: Like structs and traits, we have a lot of control of how to design</li>
<li><strong>Deliverables</strong>: Like executables, these must fulfill a specific requirement</li>
</ul>
<p>We have organized all deliverables by convenience; all luggage by type or by purpose; and nuts, bolts, and gears have been organized by type, by purpose, or by layer. The result could be worse, and organizing by a different standard does not imply that the code will change significantly. Overall, the deliverables are supported by fairly maintainable code and the project is going in a good direction.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we examined four code organization principles that can be used alone or in combination to develop well-structured projects. The four principles of organization by type, by purpose, by layer, and by convenience are helpful perspectives for inspiring good architecture choices when structuring larger projects. The larger and more complex a project becomes, the more important these decisions become, though simultaneously more difficult to change.</p>
<p>Applying these concepts, we restructured the entire project using each principle to a varying degree. We also incorporated significant changes to allow interfacing with external libraries and applied operations of the elevator, as opposed to a closed simulation. Now, the elevators of three buildings should be capable of running entirely on the software developed here.</p>
<p>In the next chapter, we will learn about mutability and ownership. We have covered these concepts to a certain degree already, but the next chapter will demand a much more in-depth understanding of specific details and limitations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What are four ways of grouping code into modules?</li>
<li>What does FFI stand for?</li>
<li>Why are unsafe blocks necessary?</li>
<li>Is it ever safe to use unsafe blocks?</li>
<li>What is the difference between a <kbd>libc::c_int</kbd> and an <kbd>int32</kbd>?</li>
<li>Can linked libraries define functions with the same name?</li>
<li>What type of files can be linked into a Rust project?</li>
</ol>


            

            
        
    </body></html>