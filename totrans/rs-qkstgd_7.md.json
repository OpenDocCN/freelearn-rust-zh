["```rs\npub enum Option<T> {\n    None,\n    Some(T),\n}\n```", "```rs\nlet x: Option = None;\n```", "```rs\nstruct TreeNode<K, V> where K: PartialOrd + PartialEq {\n    key: K,\n    value: V,\n    lesser: Option<Box<TreeNode<K, V>>>,\n    greater: Option<Box<TreeNode<K, V>>>,\n}\n```", "```rs\npub struct Tree<K, V> where K: PartialOrd + PartialEq {\n    root: Option<Box<TreeNode<K, V>>>,\n}\n```", "```rs\nimpl<K, V> TreeNode<K, V> where K: PartialOrd + PartialEq {\n```", "```rs\n    fn set(&mut self, key: K, value: V) {\n        if key == self.key {\n            self.value = value;\n        }\n        else if key < self.key {\n            match self.lesser {\n                None => {\n                    self.lesser = Some(\n                        Box::new(TreeNode {key, value, lesser: None, \n                        greater: None })\n                    );\n                },\n                Some(ref mut lesser) => {\n                    lesser.set(key, value);\n                }\n            }\n        }\n        else {\n            match self.greater {\n                None => {\n                    self.greater = Some(\n                        Box::new(TreeNode {key, value, lesser: None, \n                        greater: None })\n                    );\n                }\n                Some(ref mut greater) => {\n                    greater.set(key, value);\n                }\n            }\n        }\n    }\n```", "```rs\n    fn get_ref(&self, key: K) -> Result<&V, String> {\n        if key == self.key {\n            return Ok(&self.value);\n        }\n        else if key < self.key {\n            match self.lesser {\n                None => {\n                    return Err(\"No such key\".to_string());\n                }\n                Some(ref lesser) => {\n                    return lesser.get_ref(key);\n                }\n            }\n        }\n        else {\n            match self.greater {\n                None => {\n                    return Err(\"No such key\".to_string());\n                }\n                Some(ref greater) => {\n                    return greater.get_ref(key);\n                }\n            }\n        }\n    }\n```", "```rs\nlet mut tree: Tree<&'static str, f32> = Tree::new();\n\ntree.set(\"first key\", 12.65);\ntree.set(\"second key\", 99.999);\ntree.set(\"third key\", -128.5);\ntree.set(\"fourth key\", 67.21);\n\nprintln!(\"tree.get_ref(\\\"third key\\\") is {}\", match tree.get_ref(\"third key\") {\n    Err(_) => {println!(\"Invalid!\"); &0.0},\n    Ok(x) => x,\n});\n```", "```rs\npub enum NotOrdered {\n    A,\n    B,\n    C,\n}\n```", "```rs\nfn print_generic<T>(value: T) where T: Display {\n    println!(\"{}\", value);\n}\n```", "```rs\nprint_generic(12.7);\nprint_generic(\"Hello\");\nprint_generic(75);\n```", "```rs\nimpl<K: PartialOrd + PartialEq, V> TreeNode<K, V> {\n```", "```rs\nfn print_generic<T: Display>(value: T) {\n```", "```rs\nfn requires_trait(value: impl Display)  {\n```", "```rs\nfn requires_trait(value: impl Display) -> impl Display {\n```", "```rs\nfn faulty_return(sel: bool) -> impl Display {\n    if sel {\n        return 52;\n    } else {\n        return \"Oh no\";\n    }\n}\n```", "```rs\nfn print_generic<T>(value: T) where T: Display {\n    println!(\"{}\", value);\n}\n```", "```rs\nfn print_trait(value: &dyn Display) {\n    println!(\"{}\", value);\n}\n```", "```rs\nfn higher_order(f: impl FnOnce(u32) -> u32) {\n    f(5);\n}\n```", "```rs\nfn higher_order2<F>(f: F) where F: FnOnce(u32) -> u32 {\n    f(5);\n}\n```", "```rs\nfn higher_order3<F: FnOnce(u32) -> u32>(f: F) {\n    f(5);\n}\n```", "```rs\nlet mut y = \"y\".to_string();\nhigher_order(|x: u32| {\n    y.push('X');\n    println!(\"In the closure, y is now {}\", y);\n    x\n});\nprintln!(\"After higher_order, y is {}\", y);\n```", "```rs\nstruct TreeNode<K, V> where K: PartialOrd + PartialEq {\n    key: K,\n    value: V,\n    lesser: Option<Box<TreeNode<K, V>>>,\n    greater: Option<Box<TreeNode<K, V>>>,\n}\n```", "```rs\nimpl<K, V> TreeNode<K, V> where K: PartialOrd + PartialEq {\n    fn set(&mut self, key: K, value: V) {\n        if key == self.key {\n            self.value = value;\n        }\n        else if key < self.key {\n            match self.lesser {\n                None => {\n                    self.lesser = Some(Box::new(TreeNode {key, value, \n                     lesser: None, greater: None }));\n                },\n                Some(ref mut lesser) => {\n                    lesser.set(key, value);\n                }\n            }\n        }\n        else {\n            match self.greater {\n                None => {\n                    self.greater = Some(Box::new(TreeNode {key, value, \n                    lesser: None, greater: None }));\n                }\n                Some(ref mut greater) => {\n                    greater.set(key, value);\n                }\n            }\n        }\n    }\n\n```", "```rs\n    fn get_ref(&self, key: K) -> Result<&V, String> {\n        if key == self.key {\n            return Ok(&self.value);\n        }\n        else if key < self.key {\n            match self.lesser {\n                None => {\n                    return Err(\"No such key\".to_string());\n                }\n                Some(ref lesser) => {\n                    return lesser.get_ref(key);\n                }\n            }\n        }\n        else {\n            match self.greater {\n                None => {\n                    return Err(\"No such key\".to_string());\n                }\n                Some(ref greater) => {\n                    return greater.get_ref(key);\n                }\n            }\n        }\n    }\n\n    fn get_mut(&mut self, key: K) -> Result<&mut V, String> {\n        if key == self.key {\n            return Ok(&mut self.value);\n        }\n        else if key < self.key {\n            match self.lesser {\n                None => {\n                    return Err(\"No such key\".to_string());\n                }\n                Some(ref mut lesser) => {\n                    return lesser.get_mut(key);\n                }\n            }\n        }\n        else {\n            match self.greater {\n                None => {\n                    return Err(\"No such key\".to_string());\n                }\n                Some(ref mut greater) => {\n                    return greater.get_mut(key);\n                }\n            }\n        }\n    }\n}\n```", "```rs\npub struct Tree<K, V> where K: PartialOrd + PartialEq {\n    root: Option<Box<TreeNode<K, V>>>,\n}\n```", "```rs\nimpl<K, V> Tree<K, V> where K: PartialOrd + PartialEq {\n    pub fn new() -> Tree<K, V> {\n        Tree { root: None }\n    }\n\n    pub fn set(&mut self, key: K, value: V) {\n        match self.root {\n            None => {\n                self.root = Some(Box::new(TreeNode { key, value, \n                lesser: None, greater: None }));\n            }\n            Some(ref mut root) => {\n                root.set(key, value);\n            }\n        }\n    }\n\n    pub fn get_ref(&self, key: K) -> Result<&V, String> {\n        match self.root {\n            None => {\n                return Err(\"No such key\".to_string());\n            }\n            Some(ref root) => {\n                return root.get_ref(key);\n            }\n        }\n    }\n\n    pub fn get_mut(&mut self, key: K) -> Result<&mut V, String> {\n        match self.root {\n            None => {\n                return Err(\"No such key\".to_string());\n            }\n            Some(ref mut root) => {\n                return root.get_mut(key);\n            }\n        }\n    }\n}\n\n```", "```rs\nfn main() {\n    let mut tree: Tree<&'static str, f32> = Tree::new();\n\n    tree.set(\"first key\", 12.65);\n    tree.set(\"second key\", 99.999);\n    tree.set(\"third key\", -128.5);\n    tree.set(\"fourth key\", 67.21);\n\n    println!(\"tree.get_ref(\\\"third key\\\") is {}\", match \n     tree.get_ref(\"third key\") {\n        Err(_) => {println!(\"Invalid!\"); &0.0},\n        Ok(x) => x,\n    });\n}\n\n```"]