- en: '*Chapter 11*: Securing and Adding an API and JSON'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two of the most important aspects of a web application are authentication and
    authorization. In this chapter, we are going to learn how to implement simple
    authentication and authorization systems. After we have created these systems,
    we are going to learn how to create a simple **Application Programming Interface**
    (**API**) and how to protect the API endpoint using a **JSON Web Token** (**JWT**).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you will be able to create an authentication system,
    with functionality such as logging in and logging out and setting access rights
    for logged-in users. You will also be able to create an API server and know how
    to secure the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover these main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorizing users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting the API with a JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we have the usual requirements: a Rust compiler, a text editor,
    a web browser, and a PostgreSQL database server, along with the FFmpeg command
    line. We are going to learn about JSON and APIs in this chapter. Install cURL
    or any other HTTP testing client.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common tasks of a web application is handling registration and
    logging in. By logging in, users can tell the web server that they really are
    who they say they are.
  prefs: []
  type: TYPE_NORMAL
- en: We already created a sign-up system when we implemented CRUD for the user model.
    Now, let's implement a login system using the existing user model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea for login is simple: the user can fill in their username and password.
    The application then verifies that the username and password are valid. After
    that, the application can generate a cookie with the user''s information and return
    the cookie to the web browser. Every time there''s a request from the browser,
    the cookie is sent back from the browser to the server, and we validate the content
    of the cookie.'
  prefs: []
  type: TYPE_NORMAL
- en: To make sure we don't have to implement the cookie for every request, we can
    create a request guard that validates the cookie automatically if we use the request
    guard in a route handling function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start implementing a user login system by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a request guard to handle user authentication cookies. We can organize
    request guards in the same place to make it easier if we want to add new request
    guards. In `src/lib.rs`, add a new module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a folder called `src/guards`. Inside `src/guards`, add a file
    called `src/guards/mod.rs`. Add a new module in this new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, create a new file called `src/guards/auth.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a struct to handle user authentication cookies. Let''s name the struct
    `CurrentUser`. In `src/guards/auth.rs`, add a struct to store the `User` information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a constant that will be used as a key for the cookie to store the user''s
    **universally unique identifier** (**UUID**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `FromRequest` trait for `CurrentUser` to make the struct a request
    guard. Add the implementation skeleton as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `from_request` function, define an error that will be returned if
    something goes wrong:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the cookie from the request, and extract the UUID from the cookie as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to get a connection to the database to find the user information. We
    can obtain another request guard (such as `Connection<DBConnection>`) inside a
    request guard implementation. Add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find and return the user. Add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to implement the login itself. We will create a `like sessions/new`
    route to get the page for the login, a `sessions/create` route to send the username
    and password for login, and a `sessions/delete` route for logging out. Before
    implementing those routes, let''s create a template for the login. In `src/views`,
    add a new folder called `sessions`. Then, create a file called `src/views/sessions/new.html.tera`.
    Append the following lines into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/models/user.rs`, add a struct for the login information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Staying in the same file, we want to create a method for the `User` struct
    to be able to find the user from the database based on the login username information,
    and verify whether the login password is correct or not. After verifying that
    the password is correct by using the `update` method, it is time to refactor this.
    Create a new function to verify passwords:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `update` method from these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And, change it to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a method to find a user based on the login username. Inside the `impl
    User` block, add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, implement routes for handling login. Create a new `mod` in `src/routes/mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, create a new file called `src/routes/session.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/routes/session.rs`, create a route handling function called `new`.
    We want the function to serve the rendered template for the login that we created
    earlier. Add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a new function called `create`. In this function, we want to find
    the user and verify the password with the password hash in the database. If everything
    goes well, set the cookie with the user information. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a function called `delete`. We will use this function as a
    route for logging out. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `session::new`, `session::create`, and `session::delete` into `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use `CurrentUser` to ensure that only logged-in users can have
    access to some endpoints in our application. In `src/routes/user.rs`, remove the
    routine to find the user in the `edit` endpoint. Delete the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add `CurrentUser` to the route that requires a logged-in user as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, protect the endpoint in `src/routes/post.rs` as well. Only logged-in
    users can upload and delete the post, so modify the code into the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we implemented authentication, we could edit and delete any user or post.
    Now try editing or deleting something without logging in. Then, try logging in
    and deleting and editing.
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem still exists: after logging in, users can edit and delete other
    users'' information. We will learn how to prevent this problem by implementing
    authorization in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and authorization are two of the main concepts of information
    security. If authentication is a way to prove that an entity is who they say they
    are, then authorization is a way to give rights to the entity. One entity might
    be able to modify some resources, one entity might be able to modify all resources,
    one entity might only be able to see limited resources, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we implemented authentication concepts such as login
    and `CurrentUser`; now it's time to implement authorization. The idea is that
    we make sure logged-in users can only modify their own information and posts.
  prefs: []
  type: TYPE_NORMAL
- en: Please keep in mind that this example is very simple. In more advanced information
    security, there are more advanced concepts, such as role-based access control.
    For example, we can create a role called `admin`, we can set a certain user as
    `admin`, and `admin` can do everything without restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try implementing simple authorization by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a simple method for `CurrentUser` to compare its instance with a UUID.
    Append the following lines in `src/guards/auth.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new type of error as well. Add a `new` method in `src/errors/our_error.rs`
    in the `impl OurError {}` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check the `CurrentUser` instance on the templates to control the flow
    of the application. For example, if there''s no `CurrentUser` instance, we show
    the link to sign up and log in. If there is a `CurrentUser` instance, we show
    the link to log out. Let''s modify the Tera template. Edit `src/views/template.html.tera`
    and append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `src/views/users/index.html.tera` and remove the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify it into the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `src/views/users/show.html.tera` and find these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And, surround those lines with conditional checking as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to allow upload only for logged-in users. Find the form lines
    in `src/views/posts/index.html.tera`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Surround the form lines with the following conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the final modification for the template. We want only the owner of
    the post to be able to delete the post. Find these lines in `src/views/posts/show.html.tera`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Surround them with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Modify the route handling functions to get the value of `current_user`. Remember,
    we can wrap a request guard in `Option`, such as `Option<CurrentUser>`. When a
    route handling function fails to get a `CurrentUser` instance (for example, there
    is no logged-in user), it will generate a `None` variant of `Option`. We can then
    pass the instance to a template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s convert route handling functions, starting from `src/routes/post.rs`.
    Modify the `get_post()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do the same thing with the `get_posts()` function. Modify the function
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One thing we can do to secure the `create_post()` function is to check whether
    the user uploading the file has the same UUID as `user_uuid` on the URL. This
    check is to prevent logged-in attackers from doctoring the request and sending
    false requests. Put the check in the `create_post()` function before we do file
    manipulation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can do the same check for the `delete_post()` function in `src/routes/post.rs`.
    We want to prevent unauthorized users from being able to send doctored requests
    and delete other people''s posts. Modify `delete_post()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try restarting the application, logging in, and seeing whether you can delete
    other people''s posts. Try also modifying `src/routes/user.rs` by applying the
    same principle: getting the `CurrentUser` instance and applying the necessary
    check, or passing the `CurrentUser` instance to the template. You can find the
    full code, including protecting user-related routes, at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11/02Authorization](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11/02Authorization).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the most common tasks of a web server is providing APIs, and some APIs
    must be secured from unwanted usage. We will learn how to serve an API and protect
    the API endpoint in the next sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the common tasks of web applications is handling APIs. APIs can return
    a lot of different formats, but modern APIs have converged into two common formats:
    JSON and XML.'
  prefs: []
  type: TYPE_NORMAL
- en: Building an endpoint that returns JSON is pretty simple in the Rocket web framework.
    For handling the request body in JSON format, we can use `rocket::serde::json::Json<T>`
    as a data guard. The generic `T` type must implement the `serde::Deserialize`
    trait or else the Rust compiler will refuse to compile.
  prefs: []
  type: TYPE_NORMAL
- en: For responding, we can do the same thing by responding with `rocket::serde::json::Json<T>`.
    The generic `T` type must only implement the `serde::Serialize` trait when used
    as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of how to handle JSON requests and responses. We want
    to create a single API endpoint, `/api/users`. This endpoint can receive a JSON
    body similar to the structure of `our_application::models::pagination::Pagination`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow these steps to implement the API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement `serde::Serialize` for `OurError`. Append these lines into `src/errors/our_error.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want `Pagination` to derive `Deserialize` and to automatically implement
    the `Deserialize` trait, as `Pagination` will be used in the JSON data guard,
    `Json<Pagination>`. Because `Pagination` contains the `OurDateTime` member, `OurDateTime`
    has to implement the `Deserialize` trait as well. Modify `src/models/our_date_time.rs`
    and add the `Deserialize` derive macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Derive `Serialize` and `Deserialize` for `Pagination`. We also want to derive
    `Serialize` because we want to use `Pagination` as part of the response from the
    `/api/users` endpoint. Modify `src/models/pagination.rs` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `User` struct, it already derives `Serialize` automatically, so we
    can use it in a vector of `User`. One thing to be fixed is we don''t want the
    password to be included in the resulting JSON. Serde has many macros to control
    how to generate serialized data from a struct. Append a single macro that will
    skip the `password_hash` field. Modify `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to return the vector of `User` and `Pagination` as the resulting JSON.
    We can create a new struct to wrap those in a field. Append the following lines
    in `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we are skipping the `pagination` field if it's `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new module in `src/routes/mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, create a new file in `src/routes/api.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/routes/api.rs`, add the usual `use` declarations, models, errors, and
    database connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `use` declaration for `rocket::serde::json::Json` as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a route handling function definition to get users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the function. In the function, we can get the content of the JSON
    using the `into_inner()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the users. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we have implemented the `Serialize` trait for `OurError`, we can return
    the type automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to return `UsersWrapper`. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing to do is to add the route to `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try running the application and sending a request to `http://127.0.0.1:8000/api/users`.
    We can use any HTTP client, but if we''re using cURL, it will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The application should return something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have finished creating an API endpoint, let's try securing the endpoint
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the API with a JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common task we want to do is protect the API endpoints from unauthorized
    access. There are a lot of reasons why API endpoints have to be protected, such
    as wanting to protect sensitive data, conducting financial services, or offering
    subscription services.
  prefs: []
  type: TYPE_NORMAL
- en: In the web browser, we can protect server endpoints by making a session, assigning
    a cookie to the session, and returning the session to the web browser, but an
    API client is not always a web browser. API clients can be mobile applications,
    other web applications, hardware monitors, and many more. This raises the question,
    *how can we protect the API endpoint?*
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of ways to protect the API endpoint, but one industry standard
    is by using a JWT. According to *IETF RFC7519*, a JWT is a compact, URL-safe means
    of representing claims to be transferred between two parties. The claims in a
    JWT can be either JSON objects or special plaintext representations of said JSON
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'One flow to use a JWT is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends an authentication request to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server responds with a JWT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client stores the JWT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client uses the stored JWT to send an API request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server verifies the JWT and responds accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s try implementing API endpoint protection by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Append the required libraries in the `Cargo.toml` dependencies section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to use a secret token to sign the JWT token. Add a new entry in `Rocket.toml`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new state to store a secret for the token. We want to retrieve the secret
    when the application creates or verifies JWT. Add the following lines in `src/states/mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `src/main.rs` to make the application retrieve the secret from the configuration
    and manage the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make one struct to hold JSON data that is sent for authentication, and another
    struct to hold JSON data containing the token to be returned to the client. In
    `src/models/user.rs`, add the following `use` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method to verify the username and password for `JWTLogin`. Add
    the `impl` block and method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `authenticate()` method, add the `error` closure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, find the user according to the username and verify the password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `use` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue the following inside `authenticate` to generate a token from the user''s
    UUID and return the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function to authenticate. Let''s call this function `login()`. In
    `src/routes/api.rs`, add the required `use` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the `login()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have created login functionality, the next action is to create
    a request guard that handles the authorization token in the request header. In
    `src/guards/auth.rs`, add the following `use` declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new struct for a request guard called `APIUser`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `FromRequest` for `APIUser`. Add the following block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `from_request()`, add the closure to return an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the token from the request header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the secret from state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the token and get the user''s UUID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the user and return the user data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add a new protected API endpoint in `src/routes/api.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/main.rs`, add the routes to Rocket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, try accessing the new endpoint. Here is an example when using the cURL
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will be an error. Now try sending a request to get the access
    token. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a token returned, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the token to send the request, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Then, the correct response will be returned. JWT is a good way to protect API
    endpoints, so use the technique that we have learned when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about authenticating users and then creating a cookie
    to store logged-in user information. We also introduced `CurrentUser` as a request
    guard that works as authorization for certain parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: After creating authentication and authorization systems, we also learned about
    API endpoints. We parsed the incoming request body as a request guard in an API
    and then created an API response.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned a little bit about the JWT and how to use it to protect
    API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to test the code that we have
    created.
  prefs: []
  type: TYPE_NORMAL
