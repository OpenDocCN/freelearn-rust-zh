- en: '*Chapter 11*: Securing and Adding an API and JSON'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：安全性和添加API及JSON'
- en: Two of the most important aspects of a web application are authentication and
    authorization. In this chapter, we are going to learn how to implement simple
    authentication and authorization systems. After we have created these systems,
    we are going to learn how to create a simple **Application Programming Interface**
    (**API**) and how to protect the API endpoint using a **JSON Web Token** (**JWT**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用的两个最重要的方面是认证和授权。在本章中，我们将学习如何实现简单的认证和授权系统。在创建了这些系统之后，我们将学习如何创建一个简单的**应用程序编程接口**（**API**）以及如何使用**JSON
    Web Token**（**JWT**）保护API端点。
- en: At the end of this chapter, you will be able to create an authentication system,
    with functionality such as logging in and logging out and setting access rights
    for logged-in users. You will also be able to create an API server and know how
    to secure the API endpoints.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够创建一个认证系统，包括登录和登出以及为已登录用户设置访问权限的功能。你还将能够创建一个API服务器，并了解如何保护API端点。
- en: 'In this chapter, we are going to cover these main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Authenticating users
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户认证
- en: Authorizing users
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户授权
- en: Handling JSON
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理JSON
- en: Protecting the API with a JWT
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JWT保护API
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we have the usual requirements: a Rust compiler, a text editor,
    a web browser, and a PostgreSQL database server, along with the FFmpeg command
    line. We are going to learn about JSON and APIs in this chapter. Install cURL
    or any other HTTP testing client.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们有通常的要求：一个Rust编译器、一个文本编辑器、一个网络浏览器和一个PostgreSQL数据库服务器，以及FFmpeg命令行。在本章中，我们将学习关于JSON和API的知识。安装cURL或其他任何HTTP测试客户端。
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11)找到本章的源代码。
- en: Authenticating users
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户认证
- en: One of the most common tasks of a web application is handling registration and
    logging in. By logging in, users can tell the web server that they really are
    who they say they are.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用中最常见的任务之一是处理注册和登录。通过登录，用户可以向网络服务器表明他们确实是他们所说的那个人。
- en: We already created a sign-up system when we implemented CRUD for the user model.
    Now, let's implement a login system using the existing user model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为用户模型实现CRUD时，我们已经创建了一个注册系统。现在，让我们使用现有的用户模型来实现登录系统。
- en: 'The idea for login is simple: the user can fill in their username and password.
    The application then verifies that the username and password are valid. After
    that, the application can generate a cookie with the user''s information and return
    the cookie to the web browser. Every time there''s a request from the browser,
    the cookie is sent back from the browser to the server, and we validate the content
    of the cookie.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 登录的想法很简单：用户可以填写他们的用户名和密码。然后，应用程序会验证用户名和密码是否有效。之后，应用程序可以生成包含用户信息的cookie并将其返回给网络浏览器。每当浏览器有请求时，cookie都会从浏览器发送回服务器，我们验证cookie的内容。
- en: To make sure we don't have to implement the cookie for every request, we can
    create a request guard that validates the cookie automatically if we use the request
    guard in a route handling function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们不必为每个请求实现cookie，如果我们使用请求保护器在路由处理函数中自动验证cookie，我们可以创建一个请求保护器。
- en: 'Let''s start implementing a user login system by following these steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始实现用户登录系统：
- en: 'Create a request guard to handle user authentication cookies. We can organize
    request guards in the same place to make it easier if we want to add new request
    guards. In `src/lib.rs`, add a new module:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个请求保护器来处理用户认证cookie。如果我们想在路由处理函数中添加新的请求保护器，我们可以将请求保护器组织在同一个地方，这样会更方便。在`src/lib.rs`中添加一个新的模块：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, create a folder called `src/guards`. Inside `src/guards`, add a file
    called `src/guards/mod.rs`. Add a new module in this new file:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`src/guards`的文件夹。在`src/guards`内部，添加一个名为`src/guards/mod.rs`的文件。在这个新文件中添加一个新的模块：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After that, create a new file called `src/guards/auth.rs`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`src/guards/auth.rs`的新文件。
- en: 'Create a struct to handle user authentication cookies. Let''s name the struct
    `CurrentUser`. In `src/guards/auth.rs`, add a struct to store the `User` information:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个结构体来处理用户认证cookie。让我们将这个结构体命名为`CurrentUser`。在`src/guards/auth.rs`中，添加一个结构体来存储`User`信息：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define a constant that will be used as a key for the cookie to store the user''s
    **universally unique identifier** (**UUID**):'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个常量，该常量将用作cookie的键来存储用户的**全局唯一标识符**（**UUID**）：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement the `FromRequest` trait for `CurrentUser` to make the struct a request
    guard. Add the implementation skeleton as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`CurrentUser`实现`FromRequest`特质，使结构体成为一个请求守卫。添加以下实现框架：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the `from_request` function, define an error that will be returned if
    something goes wrong:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`from_request`函数内部，定义一个错误，如果发生错误则返回：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Get the cookie from the request, and extract the UUID from the cookie as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从请求中获取cookie，并按如下方式提取cookie中的UUID：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We want to get a connection to the database to find the user information. We
    can obtain another request guard (such as `Connection<DBConnection>`) inside a
    request guard implementation. Add the following lines:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要获取数据库的连接以查找用户信息。我们可以在请求守卫实现内部获取另一个请求守卫（例如`Connection<DBConnection>`）。添加以下行：
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Find and return the user. Add the following lines:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并返回用户。添加以下行：
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we want to implement the login itself. We will create a `like sessions/new`
    route to get the page for the login, a `sessions/create` route to send the username
    and password for login, and a `sessions/delete` route for logging out. Before
    implementing those routes, let''s create a template for the login. In `src/views`,
    add a new folder called `sessions`. Then, create a file called `src/views/sessions/new.html.tera`.
    Append the following lines into the file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要实现登录本身。我们将创建一个`like sessions/new`路由来获取登录页面，一个`sessions/create`路由来发送登录的用户名和密码，以及一个`sessions/delete`路由用于登出。在实现这些路由之前，让我们为登录创建一个模板。在`src/views`中添加一个名为`sessions`的新文件夹。然后，创建一个名为`src/views/sessions/new.html.tera`的文件。将以下行追加到该文件中：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `src/models/user.rs`, add a struct for the login information:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/user.rs`中，添加一个用于登录信息的结构体：
- en: '[PRE10]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Staying in the same file, we want to create a method for the `User` struct
    to be able to find the user from the database based on the login username information,
    and verify whether the login password is correct or not. After verifying that
    the password is correct by using the `update` method, it is time to refactor this.
    Create a new function to verify passwords:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，我们想要为`User`结构体创建一个方法，以便能够根据登录用户名信息从数据库中查找用户，并验证登录密码是否正确。在通过`update`方法验证密码正确后，是时候重构了。创建一个新的函数来验证密码：
- en: '[PRE11]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Change the `update` method from these lines:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`update`方法从以下行更改：
- en: '[PRE12]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And, change it to the following lines:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其更改为以下行：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a method to find a user based on the login username. Inside the `impl
    User` block, add the following method:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于登录用户名查找用户的方法。在`impl User`块中，添加以下方法：
- en: '[PRE14]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, implement routes for handling login. Create a new `mod` in `src/routes/mod.rs`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现处理登录的路由。在`src/routes/mod.rs`中创建一个新的`mod`：
- en: '[PRE15]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, create a new file called `src/routes/session.rs`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`src/routes/session.rs`的新文件。
- en: 'In `src/routes/session.rs`, create a route handling function called `new`.
    We want the function to serve the rendered template for the login that we created
    earlier. Add the following lines:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/routes/session.rs`中，创建一个名为`new`的路由处理函数。我们希望该函数为我们之前创建的登录模板提供渲染后的模板。添加以下行：
- en: '[PRE16]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, create a new function called `create`. In this function, we want to find
    the user and verify the password with the password hash in the database. If everything
    goes well, set the cookie with the user information. Append the following lines:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`create`的新函数。在这个函数中，我们想要找到用户并验证与数据库中的密码散列匹配的密码。如果一切顺利，设置包含用户信息的cookie。追加以下行：
- en: '[PRE17]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, create a function called `delete`. We will use this function as a
    route for logging out. Append the following lines:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`delete`的函数。我们将使用此函数作为登出路由。追加以下行：
- en: '[PRE18]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add `session::new`, `session::create`, and `session::delete` into `src/main.rs`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`session::new`、`session::create`和`session::delete`添加到`src/main.rs`中：
- en: '[PRE19]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can use `CurrentUser` to ensure that only logged-in users can have
    access to some endpoints in our application. In `src/routes/user.rs`, remove the
    routine to find the user in the `edit` endpoint. Delete the following lines:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`CurrentUser`来确保只有登录用户才能访问我们应用程序中的一些端点。在`src/routes/user.rs`中，删除`edit`端点中查找用户的例程。删除以下行：
- en: '[PRE20]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, add `CurrentUser` to the route that requires a logged-in user as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`CurrentUser`添加到需要登录用户的路由中，如下所示：
- en: '[PRE21]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, protect the endpoint in `src/routes/post.rs` as well. Only logged-in
    users can upload and delete the post, so modify the code into the following:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`src/routes/post.rs`的端点上也进行保护。只有已登录用户可以上传和删除帖子，因此将代码修改为以下内容：
- en: '[PRE22]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Before we implemented authentication, we could edit and delete any user or post.
    Now try editing or deleting something without logging in. Then, try logging in
    and deleting and editing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现认证之前，我们可以编辑和删除任何用户或帖子。现在尝试在不登录的情况下编辑或删除某些内容。然后，尝试登录并删除和编辑。
- en: 'One problem still exists: after logging in, users can edit and delete other
    users'' information. We will learn how to prevent this problem by implementing
    authorization in the next section.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然存在一个问题：登录后，用户可以编辑和删除其他用户的资料。我们将在下一节中通过实现授权来学习如何防止这个问题。
- en: Authorizing users
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权用户
- en: Authentication and authorization are two of the main concepts of information
    security. If authentication is a way to prove that an entity is who they say they
    are, then authorization is a way to give rights to the entity. One entity might
    be able to modify some resources, one entity might be able to modify all resources,
    one entity might only be able to see limited resources, and so on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权是信息安全中的两个主要概念。如果认证是一种证明实体是其所称实体的方式，那么授权就是一种赋予实体权利的方式。一个实体可能能够修改某些资源，一个实体可能能够修改所有资源，一个实体可能只能查看有限资源，等等。
- en: In the previous section, we implemented authentication concepts such as login
    and `CurrentUser`; now it's time to implement authorization. The idea is that
    we make sure logged-in users can only modify their own information and posts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们实现了登录和`CurrentUser`等认证概念；现在是时候实现授权了。想法是确保已登录用户只能修改他们自己的信息和帖子。
- en: Please keep in mind that this example is very simple. In more advanced information
    security, there are more advanced concepts, such as role-based access control.
    For example, we can create a role called `admin`, we can set a certain user as
    `admin`, and `admin` can do everything without restrictions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个例子非常简单。在更高级的信息安全中，有更高级的概念，例如基于角色的访问控制。例如，我们可以创建一个名为`admin`的角色，我们可以将某个用户设置为`admin`，而`admin`可以无限制地做任何事情。
- en: 'Let''s try implementing simple authorization by following these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤尝试实现简单的授权：
- en: 'Add a simple method for `CurrentUser` to compare its instance with a UUID.
    Append the following lines in `src/guards/auth.rs`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`CurrentUser`添加一个简单的方法来比较其实例与UUID。在`src/guards/auth.rs`中追加以下行：
- en: '[PRE23]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add a new type of error as well. Add a `new` method in `src/errors/our_error.rs`
    in the `impl OurError {}` block:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一种新的错误类型。在`src/errors/our_error.rs`文件中的`impl OurError {}`块中添加一个`new`方法：
- en: '[PRE24]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can check the `CurrentUser` instance on the templates to control the flow
    of the application. For example, if there''s no `CurrentUser` instance, we show
    the link to sign up and log in. If there is a `CurrentUser` instance, we show
    the link to log out. Let''s modify the Tera template. Edit `src/views/template.html.tera`
    and append the following lines:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在模板中检查`CurrentUser`实例来控制应用程序的流程。例如，如果没有`CurrentUser`实例，我们显示注册和登录的链接。如果有`CurrentUser`实例，我们显示注销的链接。让我们修改Tera模板。编辑`src/views/template.html.tera`文件并追加以下行：
- en: '[PRE25]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Edit `src/views/users/index.html.tera` and remove the following line:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/views/users/index.html.tera`文件并删除以下行：
- en: '[PRE26]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Find this line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 找到这一行：
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Modify it into the following lines:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将其修改为以下行：
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Edit `src/views/users/show.html.tera` and find these lines:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/views/users/show.html.tera`文件并找到这些行：
- en: '[PRE29]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And, surround those lines with conditional checking as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用以下条件检查包围这些行：
- en: '[PRE30]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we want to allow upload only for logged-in users. Find the form lines
    in `src/views/posts/index.html.tera`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望只允许已登录用户上传。在`src/views/posts/index.html.tera`文件中找到表单行：
- en: '[PRE31]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Surround the form lines with the following conditional:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下条件包围表单行：
- en: '[PRE32]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now for the final modification for the template. We want only the owner of
    the post to be able to delete the post. Find these lines in `src/views/posts/show.html.tera`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在对模板进行最后的修改。我们希望只有帖子的所有者才能删除帖子。在`src/views/posts/show.html.tera`文件中找到这些行：
- en: '[PRE33]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Surround them with the following lines:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下行包围它们：
- en: '[PRE34]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Modify the route handling functions to get the value of `current_user`. Remember,
    we can wrap a request guard in `Option`, such as `Option<CurrentUser>`. When a
    route handling function fails to get a `CurrentUser` instance (for example, there
    is no logged-in user), it will generate a `None` variant of `Option`. We can then
    pass the instance to a template.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改路由处理函数以获取 `current_user` 的值。记住，我们可以将请求保护器包装在 `Option` 中，例如 `Option<CurrentUser>`。当一个路由处理函数无法获取
    `CurrentUser` 实例（例如，没有已登录的用户）时，它将生成 `Option` 的 `None` 变体。然后我们可以将实例传递给模板。
- en: 'Let''s convert route handling functions, starting from `src/routes/post.rs`.
    Modify the `get_post()` function as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `src/routes/post.rs` 开始转换路由处理函数。按照以下方式修改 `get_post()` 函数：
- en: '[PRE35]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s do the same thing with the `get_posts()` function. Modify the function
    as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对 `get_posts()` 函数做同样的事情。按照以下方式修改函数：
- en: '[PRE36]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'One thing we can do to secure the `create_post()` function is to check whether
    the user uploading the file has the same UUID as `user_uuid` on the URL. This
    check is to prevent logged-in attackers from doctoring the request and sending
    false requests. Put the check in the `create_post()` function before we do file
    manipulation, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保 `create_post()` 函数的安全性，我们可以检查上传文件的用户的 UUID 是否与 URL 上的 `user_uuid` 相同。这个检查是为了防止已登录的攻击者篡改请求并发送虚假请求。在我们进行文件操作之前，将检查放入
    `create_post()` 函数中，如下所示：
- en: '[PRE37]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can do the same check for the `delete_post()` function in `src/routes/post.rs`.
    We want to prevent unauthorized users from being able to send doctored requests
    and delete other people''s posts. Modify `delete_post()` as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在 `src/routes/post.rs` 中的 `delete_post()` 函数进行相同的检查。我们希望阻止未经授权的用户发送篡改的请求并删除他人的帖子。按照以下方式修改
    `delete_post()` 函数：
- en: '[PRE38]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Try restarting the application, logging in, and seeing whether you can delete
    other people''s posts. Try also modifying `src/routes/user.rs` by applying the
    same principle: getting the `CurrentUser` instance and applying the necessary
    check, or passing the `CurrentUser` instance to the template. You can find the
    full code, including protecting user-related routes, at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11/02Authorization](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11/02Authorization).'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试重新启动应用程序，登录，并查看您是否可以删除他人的帖子。还尝试通过应用相同的原理修改 `src/routes/user.rs`：获取 `CurrentUser`
    实例并应用必要的检查，或将 `CurrentUser` 实例传递给模板。您可以在 [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11/02Authorization](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter11/02Authorization)
    找到完整的代码，包括保护用户相关路由。
- en: One of the most common tasks of a web server is providing APIs, and some APIs
    must be secured from unwanted usage. We will learn how to serve an API and protect
    the API endpoint in the next sections.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络服务器最常见的任务之一是提供 API，并且一些 API 必须防止不受欢迎的使用。在下一节中，我们将学习如何提供 API 并保护 API 端点。
- en: Handling JSON
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 JSON
- en: 'One of the common tasks of web applications is handling APIs. APIs can return
    a lot of different formats, but modern APIs have converged into two common formats:
    JSON and XML.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序的常见任务之一是处理 API。API 可以返回很多不同的格式，但现代 API 已经收敛为两种常见的格式：JSON 和 XML。
- en: Building an endpoint that returns JSON is pretty simple in the Rocket web framework.
    For handling the request body in JSON format, we can use `rocket::serde::json::Json<T>`
    as a data guard. The generic `T` type must implement the `serde::Deserialize`
    trait or else the Rust compiler will refuse to compile.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rocket 网络框架中，构建返回 JSON 的端点相当简单。对于处理 JSON 格式的请求体，我们可以使用 `rocket::serde::json::Json<T>`
    作为数据保护器。泛型 `T` 类型必须实现 `serde::Deserialize` 特性，否则 Rust 编译器将拒绝编译。
- en: For responding, we can do the same thing by responding with `rocket::serde::json::Json<T>`.
    The generic `T` type must only implement the `serde::Serialize` trait when used
    as a response.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于响应，我们可以通过返回 `rocket::serde::json::Json<T>` 来做同样的事情。泛型 `T` 类型在用作响应时必须仅实现 `serde::Serialize`
    特性。
- en: 'Let''s see an example of how to handle JSON requests and responses. We want
    to create a single API endpoint, `/api/users`. This endpoint can receive a JSON
    body similar to the structure of `our_application::models::pagination::Pagination`,
    as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何处理 JSON 请求和响应的示例。我们希望创建一个单独的 API 端点 `/api/users`。此端点可以接收类似于 `our_application::models::pagination::Pagination`
    结构的 JSON 主体，如下所示：
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Follow these steps to implement the API endpoint:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现 API 端点：
- en: 'Implement `serde::Serialize` for `OurError`. Append these lines into `src/errors/our_error.rs`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `OurError` 实现 `serde::Serialize`。将这些行添加到 `src/errors/our_error.rs`：
- en: '[PRE40]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We want `Pagination` to derive `Deserialize` and to automatically implement
    the `Deserialize` trait, as `Pagination` will be used in the JSON data guard,
    `Json<Pagination>`. Because `Pagination` contains the `OurDateTime` member, `OurDateTime`
    has to implement the `Deserialize` trait as well. Modify `src/models/our_date_time.rs`
    and add the `Deserialize` derive macro:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望 `Pagination` 继承 `Deserialize` 并自动实现 `Deserialize` 特性，因为 `Pagination` 将会在
    JSON 数据保护器 `Json<Pagination>` 中使用。由于 `Pagination` 包含 `OurDateTime` 成员，因此 `OurDateTime`
    也必须实现 `Deserialize` 特性。修改 `src/models/our_date_time.rs` 并添加 `Deserialize` derive
    宏：
- en: '[PRE41]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Derive `Serialize` and `Deserialize` for `Pagination`. We also want to derive
    `Serialize` because we want to use `Pagination` as part of the response from the
    `/api/users` endpoint. Modify `src/models/pagination.rs` as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Pagination` 实现 `Serialize` 和 `Deserialize`。我们还想实现 `Serialize`，因为我们想将 `Pagination`
    作为 `/api/users` 端点的响应的一部分使用。按照以下方式修改 `src/models/pagination.rs`：
- en: '[PRE42]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the `User` struct, it already derives `Serialize` automatically, so we
    can use it in a vector of `User`. One thing to be fixed is we don''t want the
    password to be included in the resulting JSON. Serde has many macros to control
    how to generate serialized data from a struct. Append a single macro that will
    skip the `password_hash` field. Modify `src/models/user.rs`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `User` 结构体，它已经自动继承了 `Serialize`，因此我们可以在 `User` 的向量中使用它。需要修复的一个问题是，我们不希望密码包含在生成的
    JSON 中。Serde 有许多宏可以控制如何从结构体生成序列化数据。添加一个宏来跳过 `password_hash` 字段。修改 `src/models/user.rs`：
- en: '[PRE43]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We want to return the vector of `User` and `Pagination` as the resulting JSON.
    We can create a new struct to wrap those in a field. Append the following lines
    in `src/models/user.rs`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望返回 `User` 和 `Pagination` 的向量作为生成的 JSON。我们可以创建一个新的结构体来将这些封装在一个字段中。在 `src/models/user.rs`
    中添加以下行：
- en: '[PRE44]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that we are skipping the `pagination` field if it's `None`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果 `pagination` 字段为 `None`，我们将跳过它。
- en: 'Add a new module in `src/routes/mod.rs`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/routes/mod.rs` 中添加一个新的模块：
- en: '[PRE45]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then, create a new file in `src/routes/api.rs`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `src/routes/api.rs` 中创建一个新文件。
- en: 'In `src/routes/api.rs`, add the usual `use` declarations, models, errors, and
    database connection:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/routes/api.rs` 中添加通常的 `use` 声明、模型、错误和数据库连接：
- en: '[PRE46]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add a `use` declaration for `rocket::serde::json::Json` as well:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `use` 声明 `rocket::serde::json::Json`：
- en: '[PRE47]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a route handling function definition to get users:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个处理函数定义以获取用户：
- en: '[PRE48]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the function. In the function, we can get the content of the JSON
    using the `into_inner()` method as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现函数。在函数中，我们可以使用 `into_inner()` 方法获取 JSON 的内容，如下所示：
- en: '[PRE49]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Find the users. Append the following lines:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找用户。添加以下行：
- en: '[PRE50]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Because we have implemented the `Serialize` trait for `OurError`, we can return
    the type automatically.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为 `OurError` 实现了 `Serialize` 特性，我们可以自动返回该类型。
- en: 'Now, it''s time to return `UsersWrapper`. Append the following lines:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候返回 `UsersWrapper`。添加以下行：
- en: '[PRE51]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The last thing to do is to add the route to `src/main.rs`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要做的事情是将路由添加到 `src/main.rs`：
- en: '[PRE52]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Try running the application and sending a request to `http://127.0.0.1:8000/api/users`.
    We can use any HTTP client, but if we''re using cURL, it will be as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行应用程序并向 `http://127.0.0.1:8000/api/users` 发送请求。我们可以使用任何 HTTP 客户端，但如果使用 cURL，它将如下所示：
- en: '[PRE53]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The application should return something similar to the following output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该返回类似以下输出的内容：
- en: '[PRE54]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that we have finished creating an API endpoint, let's try securing the endpoint
    in the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 API 端点的创建，接下来让我们在下一节尝试保护这个端点。
- en: Protecting the API with a JWT
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JWT 保护 API
- en: One common task we want to do is protect the API endpoints from unauthorized
    access. There are a lot of reasons why API endpoints have to be protected, such
    as wanting to protect sensitive data, conducting financial services, or offering
    subscription services.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要执行的一个常见任务是保护 API 端点免受未经授权的访问。有许多原因需要保护 API 端点，例如保护敏感数据、进行金融服务或提供订阅服务。
- en: In the web browser, we can protect server endpoints by making a session, assigning
    a cookie to the session, and returning the session to the web browser, but an
    API client is not always a web browser. API clients can be mobile applications,
    other web applications, hardware monitors, and many more. This raises the question,
    *how can we protect the API endpoint?*
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络浏览器中，我们可以通过创建会话、分配一个cookie给会话并将会话返回给网络浏览器来保护服务器端点，但API客户端不总是网络浏览器。API客户端可以是移动应用程序、其他Web应用程序、硬件监控器等等。这引发了一个问题，*我们如何保护API端点？*
- en: There are a lot of ways to protect the API endpoint, but one industry standard
    is by using a JWT. According to *IETF RFC7519*, a JWT is a compact, URL-safe means
    of representing claims to be transferred between two parties. The claims in a
    JWT can be either JSON objects or special plaintext representations of said JSON
    objects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 保护API端点有很多方法，但一个行业标准是使用JWT。根据*IETF RFC7519*，JWT是一种紧凑、URL安全的表示声明的方式，用于在双方之间传输。JWT中的声明可以是JSON对象或这些JSON对象的特殊纯文本表示。
- en: 'One flow to use a JWT is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JWT的一个流程如下：
- en: The client sends an authentication request to the server.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送认证请求。
- en: The server responds with a JWT.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器响应JWT。
- en: The client stores the JWT.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端存储JWT。
- en: The client uses the stored JWT to send an API request.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端使用存储的JWT发送API请求。
- en: The server verifies the JWT and responds accordingly.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器验证JWT并根据情况响应。
- en: 'Let''s try implementing API endpoint protection by following these steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试按照以下步骤实现API端点保护：
- en: 'Append the required libraries in the `Cargo.toml` dependencies section:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`依赖项部分添加所需的库：
- en: '[PRE55]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We want to use a secret token to sign the JWT token. Add a new entry in `Rocket.toml`
    as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要使用一个秘密令牌来签名JWT令牌。在`Rocket.toml`中添加一个新的条目如下：
- en: '[PRE56]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add a new state to store a secret for the token. We want to retrieve the secret
    when the application creates or verifies JWT. Add the following lines in `src/states/mod.rs`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的状态来存储令牌的秘密。当应用程序创建或验证JWT时，我们想要检索这个秘密。在`src/states/mod.rs`中添加以下行：
- en: '[PRE57]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Modify `src/main.rs` to make the application retrieve the secret from the configuration
    and manage the state:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`src/main.rs`以使应用程序从配置中检索秘密并管理状态：
- en: '[PRE58]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Make one struct to hold JSON data that is sent for authentication, and another
    struct to hold JSON data containing the token to be returned to the client. In
    `src/models/user.rs`, add the following `use` declaration:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个结构体来存储用于认证发送的JSON数据，另一个结构体来存储包含要返回给客户端的令牌的JSON数据。在`src/models/user.rs`中添加以下`use`声明：
- en: '[PRE59]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add the following structs:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下结构体：
- en: '[PRE60]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Implement a method to verify the username and password for `JWTLogin`. Add
    the `impl` block and method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`JWTLogin`实现一个验证用户名和密码的方法。添加`impl`块和方法：
- en: '[PRE61]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Inside the `authenticate()` method, add the `error` closure:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`authenticate()`方法内部，添加`error`闭包：
- en: '[PRE62]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, find the user according to the username and verify the password:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，根据用户名查找用户并验证密码：
- en: '[PRE63]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add the following `use` declaration:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`use`声明：
- en: '[PRE64]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Continue the following inside `authenticate` to generate a token from the user''s
    UUID and return the token:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`authenticate`中继续以下操作以从用户的UUID生成令牌并返回令牌：
- en: '[PRE65]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create a function to authenticate. Let''s call this function `login()`. In
    `src/routes/api.rs`, add the required `use` declaration:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于认证的函数。让我们称这个函数为`login()`。在`src/routes/api.rs`中添加所需的`use`声明：
- en: '[PRE66]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, add the `login()` function as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下方式添加`login()`函数：
- en: '[PRE67]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that we have created login functionality, the next action is to create
    a request guard that handles the authorization token in the request header. In
    `src/guards/auth.rs`, add the following `use` declarations:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了登录功能，下一步是创建一个请求保护器来处理请求头中的授权令牌。在`src/guards/auth.rs`中添加以下`use`声明：
- en: '[PRE68]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Add a new struct for a request guard called `APIUser`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为请求保护器添加一个新的结构体`APIUser`：
- en: '[PRE69]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Implement `FromRequest` for `APIUser`. Add the following block:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`APIUser`实现`FromRequest`。添加以下代码块：
- en: '[PRE70]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Inside `from_request()`, add the closure to return an error:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`from_request()`中，添加返回错误的闭包：
- en: '[PRE71]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Get the token from the request header:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从请求头中获取令牌：
- en: '[PRE72]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Get the secret from state:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从状态中获取秘密：
- en: '[PRE73]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Verify the token and get the user''s UUID:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证令牌并获取用户的UUID：
- en: '[PRE74]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Find the user and return the user data:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找用户并返回用户数据：
- en: '[PRE75]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, add a new protected API endpoint in `src/routes/api.rs`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`src/routes/api.rs`中添加一个新的受保护API端点：
- en: '[PRE76]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In `src/main.rs`, add the routes to Rocket:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main.rs`中添加到Rocket的路由：
- en: '[PRE77]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, try accessing the new endpoint. Here is an example when using the cURL
    command line:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试访问新的端点。以下是一个使用cURL命令行的示例：
- en: '[PRE78]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The response will be an error. Now try sending a request to get the access
    token. Here is an example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将会是一个错误。现在尝试发送一个请求来获取访问令牌。以下是一个示例：
- en: '[PRE79]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'There''s a token returned, as shown in this example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，返回了一个令牌：
- en: '[PRE80]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Use the token to send the request, as in this example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用令牌发送请求，如本示例所示：
- en: '[PRE81]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Then, the correct response will be returned. JWT is a good way to protect API
    endpoints, so use the technique that we have learned when necessary.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将返回正确的响应。JWT是保护API端点的好方法，所以当需要时使用我们学到的技术。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about authenticating users and then creating a cookie
    to store logged-in user information. We also introduced `CurrentUser` as a request
    guard that works as authorization for certain parts of the application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何验证用户并创建一个cookie来存储已登录用户的信息。我们还介绍了`CurrentUser`作为一个请求守卫，它在应用程序的某些部分充当授权。
- en: After creating authentication and authorization systems, we also learned about
    API endpoints. We parsed the incoming request body as a request guard in an API
    and then created an API response.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建认证和授权系统之后，我们还学习了关于API端点的内容。我们将传入的请求体解析为API中的请求守卫，然后创建了一个API响应。
- en: Finally, we learned a little bit about the JWT and how to use it to protect
    API endpoints.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了一些关于JWT以及如何用它来保护API端点的内容。
- en: In the next chapter, we are going to learn how to test the code that we have
    created.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何测试我们创建的代码。
