<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer067">&#13;
			<h1 id="_idParaDest-101"><em class="italic"><a id="_idTextAnchor100"/>Chapter 6</em>: Working with Python Objects in Rust</h1>&#13;
			<p>So far, we have managed to fuse Rust with Python to speed up our code. However, software programs written in Rust can get complicated. While we can get by with passing integers and strings into Rust functions from Python code, it would be useful to handle more complex data structures from Python and objects. In this chapter, we accept and process Python data structures such as a <strong class="bold">dictionary</strong>. We will go further by processing custom Python objects and even creating Python objects inside our Rust code. </p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Passing complex Python objects into Rust</li>&#13;
				<li>Inspecting and working with custom Python objects</li>&#13;
				<li>Constructing our own custom Python objects in Rust</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Technical requirements</h1>&#13;
			<p>The code for this chapter can be found via the following GitHub link:</p>&#13;
			<p><a href="https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_six">https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_six</a> </p>&#13;
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Passing complex Python objects into Rust</h1>&#13;
			<p>A key skill <a id="_idIndexMarker391"/>that enables us to take our Rust <strong class="source-inline">pip</strong> module <a id="_idIndexMarker392"/>development to the next level is taking in complex Python data structures/objects and using them. In <a href="B17720_05_Final_SK_ePub.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Creating a Rust Interface for Our pip Module</em>, we accepted integers. We noticed that these raw integers were just directly transferred to our Rust function. However, with Python objects, it is more complex than this. </p>&#13;
			<p>To explore this, we will create a new command-line function that reads a .<strong class="source-inline">yml</strong> file and passes a Python dictionary into our Rust function. The data in this dictionary will have the parameters needed for firing our <strong class="source-inline">fibonacci_numbers</strong> and <strong class="source-inline">fibonacci_number</strong> Rust functions, adding the results of those functions to the Python dictionary and passing it back to the Python system. </p>&#13;
			<p>To achieve this, we must carry out the following steps:</p>&#13;
			<ol>&#13;
				<li>Update our <strong class="source-inline">setup.py</strong> file to support .<strong class="source-inline">yml</strong> loading and a command-line function that reads it.</li>&#13;
				<li>Define a command-line function that reads the <strong class="source-inline">.yml</strong> file and feeds it into Rust. </li>&#13;
				<li>Process data from our Python dictionary for <strong class="source-inline">fibonacci_numbers</strong> in Rust.</li>&#13;
				<li>Extract data from our config file.</li>&#13;
				<li>Return our Python dictionary to our Python system.</li>&#13;
			</ol>&#13;
			<p>This approach <a id="_idIndexMarker393"/>will require us to write the whole <a id="_idIndexMarker394"/>process before we can run it. This can be frustrating because we cannot see it working until the end. However, it is laid out in this book this way so that we can see the data flow. We are exploring the concept of passing complex data structures into Rust for the first time. Once we understand how this works, we can then develop <strong class="source-inline">pip</strong> modules that work for us as individuals.</p>&#13;
			<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>Updating our setup.py file to support .yml loading</h2>&#13;
			<p> Let's <a id="_idIndexMarker395"/>start this journey by updating our <strong class="source-inline">setup.py</strong> file, as follows:</p>&#13;
			<ol>&#13;
				<li value="1">With our new command-line function, we read a .<strong class="source-inline">yml</strong> file and pass through that data to our Rust function. This requires our Python <strong class="source-inline">pip</strong> module to have the <strong class="source-inline">pyyaml</strong> Python module. This can be done by adding the <strong class="source-inline">requirements</strong> parameter to our <strong class="source-inline">setup</strong> initialization, as follows: <p class="source-code">    requirements=[</p><p class="source-code">        "pyyaml&gt;=3.13"</p><p class="source-code">    ]</p><p>We remember that we can keep adding more dependencies to our module by just adding them to our <strong class="source-inline">requirements</strong> list. If we want our module to be more flexible for multiple installs to different systems, it is advised that we can lower the version number for our <strong class="source-inline">pyyaml</strong> module requirement. </p></li>&#13;
				<li>Now <a id="_idIndexMarker396"/>that we have defined our requirements, we can define a new console script, resulting in the <strong class="source-inline">entry_points</strong> parameter in our <strong class="source-inline">setup</strong> initialization, which looks like this:<p class="source-code">    entry_points={</p><p class="source-code">        'console_scripts': [</p><p class="source-code">            'fib-number = flitton_fib_rs.'</p><p class="source-code">            'fib_number_command:'</p><p class="source-code">            'fib_number_command',</p><p class="source-code">            'config-fib = flitton_fib_rs.'</p><p class="source-code">            'config_number_command:'</p><p class="source-code">            'config_number_command',</p><p class="source-code">        ],</p><p class="source-code">    },</p><p>With this, we can see that our new console script will be in the <strong class="source-inline">flitton_fib_rs/config_number_command.py</strong> directory.</p></li>&#13;
				<li>In the <strong class="source-inline">flitton_fib_rs/config_number_command.py</strong> directory, we need to build a function called <strong class="source-inline">config_number_command</strong>. First, we need to import the required modules, as follows:<p class="source-code">import argparse</p><p class="source-code">import yaml</p><p class="source-code">import os</p><p class="source-code">from pprint import pprint</p><p class="source-code">from .flitton_fib_rs import run_config</p></li>&#13;
			</ol>&#13;
			<p><strong class="source-inline">os</strong> will <a id="_idIndexMarker397"/>help us with the path definition to the <strong class="source-inline">.yml</strong> file. The <strong class="source-inline">pprint</strong> function will just help us print the data in an easy-to-read format on the console. We have also defined a Rust function that will process our dictionary as <strong class="source-inline">run_config</strong>. </p>&#13;
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Defining our .yml loading command</h2>&#13;
			<p>Now that <a id="_idIndexMarker398"/>our imports have been done, we can define our function and collect the command-line arguments. Here's how we do this:</p>&#13;
			<ol>&#13;
				<li value="1">You can start with the following code:<p class="source-code">def config_number_command() -&gt; None:</p><p class="source-code">    parser = argparse.ArgumentParser(</p><p class="source-code">        description='Calculate Fibonacci numbers '</p><p class="source-code">                    'using a config file')</p><p class="source-code">    parser.add_argument('--path', action='store',</p><p class="source-code">                        type=str, required=True,</p><p class="source-code">                        help="path to config file")</p><p class="source-code">    args = parser.parse_args()</p></li>&#13;
				<li>Here, we can see that we take in a string, which is the path to the <strong class="source-inline">.yml</strong> file with the <strong class="source-inline">--path</strong> tag, and we parse it. Now that we have parsed the path, we can open our <strong class="source-inline">.yml</strong> file by running the following code:<p class="source-code">    with open(str(os.getcwd()) + "/" + args.path) as \</p><p class="source-code">      f:</p><p class="source-code">        config_data: dict = yaml.safe_load(f)</p><p>Here, we can see that we attach our path with the <strong class="source-inline">os.getcwd()</strong> function. This is because we must know where the user is calling the command. For instance, if we are in the <strong class="source-inline">x/y/</strong> directory and we want to point to the <strong class="source-inline">x/y/z.yml</strong> file, we will have to run the <strong class="source-inline">config-fib --path z.yml</strong> command. If the directory of the file were <strong class="source-inline">x/y/test/z.yml</strong>, we would have had to run the <strong class="source-inline">config-fib --path test/z.yml</strong> command.</p></li>&#13;
				<li>Now <a id="_idIndexMarker399"/>that we have our data loaded from the <strong class="source-inline">.yml</strong> file, we can print it out and print out the results of our Rust function by running the following code:<p class="source-code">    print("Here is the config data: ")</p><p class="source-code">    pprint(config_data)</p><p class="source-code">    print(f"Here is the result:")</p><p class="source-code">    pprint(run_config(config_data))</p></li>&#13;
			</ol>&#13;
			<p>With this, we have now completed all our Python code. </p>&#13;
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Processing data from our Python dictionary</h2>&#13;
			<p>We are <a id="_idIndexMarker400"/>now going to have to build Rust functions that process the Python dictionaries. Here's how we'll go about this:</p>&#13;
			<ol>&#13;
				<li value="1">When it comes to processing input dictionaries, we must agree on a format that we are going to accept. To keep this simple, our Python dictionaries will have two keys. The <strong class="source-inline">number</strong> key is for a list of integers that can call Fibonacci number calculations individually, while the <strong class="source-inline">numbers</strong> key is for a list of lists of integers. To ensure that our Rust code does not become disorganized, we are going to define our interfaces in our own interface directory, giving our Rust code the following structure:<p class="source-code">├── fib_calcs</p><p class="source-code">│   ├── fib_number.rs</p><p class="source-code">│   ├── fib_numbers.rs</p><p class="source-code">│   └── mod.rs</p><p class="source-code">├── interface</p><p class="source-code">│   ├── config.rs</p><p class="source-code">│   └── mod.rs</p><p class="source-code">├── lib.rs</p><p class="source-code">└── main.rs</p></li>&#13;
				<li>We <a id="_idIndexMarker401"/>will build our configuration interface in the <strong class="source-inline">src/interface/config.rs</strong> file. First, we are going to import all the functions and macros that we need, as follows:<p class="source-code">use pyo3::prelude::{pyfunction, PyResult};</p><p class="source-code">use pyo3::types::{PyDict, PyList};</p><p class="source-code">use pyo3::exceptions::PyTypeError;</p><p class="source-code">use crate::fib_calcs::fib_number::fibonacci_number;</p><p class="source-code">use crate::fib_calcs::fib_numbers::fibonacci_numbers;</p><p>We are going to use <strong class="source-inline">pyfunction</strong> to wrap our interface that takes in a Python dictionary. We will return the dictionary back to the Python program wrapped in a <strong class="source-inline">pyResult</strong> struct. Seeing as we are accepting a Python dictionary, we will be using a <strong class="source-inline">PyDict</strong> struct to describe the dictionary being passed in and returned. We will also be accessing the lists in the dictionary using a <strong class="source-inline">PyList</strong> struct. If there is an issue with our dictionary not housing lists, then we will have to throw an error that the Python system will understand. To do this, we will use a <strong class="source-inline">PyTypeError</strong> struct. Finally, we will be using our Fibonacci number functions to calculate the Fibonacci numbers. We can see that we are simply importing from another module in the Rust code with <strong class="source-inline">use crate::</strong>. Even though our Fibonacci number functions have the <strong class="source-inline">pyfunction</strong> macro applied to them, nothing is stopping us from using them as normal Rust functions elsewhere in our Rust code. </p></li>&#13;
				<li>Before we write our interface function, we need to build a private function that accepts our lists of lists, calculates the Fibonacci numbers, and returns them in a list of lists, as seen in the following code snippet:<p class="source-code">fn process_numbers(input_numbers: Vec&lt;Vec&lt;i32&gt;&gt;) \</p><p class="source-code">    -&gt; Vec&lt;Vec&lt;u64&gt;&gt; {</p><p class="source-code">    let mut buffer: Vec&lt;Vec&lt;u64&gt;&gt; = Vec::new();</p><p class="source-code">    for i in input_numbers {</p><p class="source-code">        buffer.push(fibonacci_numbers(i));</p><p class="source-code">    }</p><p class="source-code">    return buffer</p><p class="source-code">}</p></li>&#13;
				<li>This <a id="_idIndexMarker402"/>should be straightforward at this stage in the book. Considering this, we now have everything we need to build our interface. First, we need to define a <strong class="source-inline">pyfunction</strong> function that accepts and returns the same data by running the following code:<p class="source-code">#[pyfunction]</p><p class="source-code">pub fn run_config&lt;'a&gt;(config: &amp;'a PyDict) \</p><p class="source-code">    -&gt; PyResult&lt;&amp;'a PyDict&gt; {</p><p>Here, we can see that we tell the Rust compiler that the Python dictionary that we accept must have the same lifetime as the Python dictionary that we are returning. This makes sense as we are returning the same dictionary after adding the results to it. </p></li>&#13;
				<li>Our first process is to see if the <strong class="source-inline">number</strong> key is present in the dictionary by running the following code:<p class="source-code">    match config.get_item("number") {</p><p class="source-code">        Some(data) =&gt; {</p><p class="source-code">            . . .</p><p class="source-code">        },</p><p class="source-code">        None =&gt; println!(</p><p class="source-code">        "parameter number is not in the config"</p><p class="source-code">        )</p><p class="source-code">    }</p><p>Here, we <a id="_idIndexMarker403"/>can see that is the <strong class="source-inline">number</strong> key is not there, so we merely print that it is not there. We can change the rules to throw an error instead, but we are accepting a forgiving <strong class="source-inline">config</strong> file. If the user does not have any individual Fibonacci numbers to compute, only lists of them, then we should not throw errors, insisting that the user adds the field. The three dots in the code snippet shown in <em class="italic">Step 6</em> are where the code is going to be executed if the <strong class="source-inline">number</strong> key is present. </p></li>&#13;
				<li>We substitute the three dots in the following code snippet:<p class="source-code">            match data.downcast::&lt;PyList&gt;() {</p><p class="source-code">                Ok(raw_data) =&gt; {</p><p class="source-code">                    . . .</p><p class="source-code">                },</p><p class="source-code">                Err(_) =&gt; Err(PyTypeError::new_err(</p><p class="source-code">                    "parameter number is not a list </p><p class="source-code">                    of integers")).unwrap()</p><p class="source-code">            }</p><p>Here, we can see that we downcast the data we extracted belonging to the <strong class="source-inline">number</strong> key to the <strong class="source-inline">PyList</strong> struct. If this fails, then we actively throw a type error because the user has tried to configure the <strong class="source-inline">number</strong> key but failed. If it passes, we can run the Fibonacci function by substituting the three dots in the preceding code snippet with the following code:</p><p class="source-code">                    let processed_results: Vec&lt;i32&gt; = </p><p class="source-code">              raw_data.extract::&lt;Vec&lt;i32&gt;&gt;().unwrap();</p><p class="source-code">                    let fib_numbers: Vec&lt;u64&gt; = </p><p class="source-code">                    processed_results.iter().map(</p><p class="source-code">                        |x| fibonacci_number(*x)</p><p class="source-code">                    ).collect();</p><p class="source-code">                    config.set_item(</p><p class="source-code">                    "NUMBER RESULT", fib_numbers);</p></li>&#13;
			</ol>&#13;
			<p>Here, what <a id="_idIndexMarker404"/>we have done is create <strong class="source-inline">Vec&lt;i32&gt;</strong> by running the <strong class="source-inline">extract</strong> function on the <strong class="source-inline">PyList</strong> struct. We directly unwrap it so that if there is an error, it will be thrown straight away. We then create <strong class="source-inline">Vec&lt;u64&gt;</strong>, which houses the calculated Fibonacci numbers, by iterating through the vector with the <strong class="source-inline">iter()</strong> function. We then map each <strong class="source-inline">i32</strong> integer of that vector with the <strong class="source-inline">map</strong> function. Inside the <strong class="source-inline">map</strong> function, we define a closure that is mapped to each <strong class="source-inline">i32</strong> integer in the vector. It must be noted that we apply the <strong class="source-inline">fibonacci</strong> function where we dereference the <strong class="source-inline">i32</strong> integer being passed in because it is now a borrowed reference. We collect the results of this mapping with the <strong class="source-inline">.collect()</strong> function, which results in the <strong class="source-inline">processed_results</strong> variable being a collection of <strong class="source-inline">i32</strong> calculated Fibonacci numbers. We then add the calculated numbers to the dictionary under the <strong class="source-inline">NUMBER RESULT</strong> key. We can see the flow of what was just described in the following diagram:</p>&#13;
			<div>&#13;
				<div id="_idContainer063" class="IMG---Figure">&#13;
					<img src="Images/Figure_6.1_B17720.jpg" alt="" width="1519" height="1258"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 6.1 – Data extraction flow</p>&#13;
			<p>In the <a id="_idIndexMarker405"/>next step, we will carry out a similar process to the one displayed in <em class="italic">Figure 6.1</em> to process the list of lists under the <strong class="source-inline">numbers</strong> key.</p>&#13;
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Extracting data from our config file</h2>&#13;
			<p>At this <a id="_idIndexMarker406"/>point, it would be a good idea to try to implement the process for the <strong class="source-inline">numbers</strong> key by yourself. To make things easier, you can use the <strong class="source-inline">process_numbers</strong> function that we defined earlier in <em class="italic">Step 3</em> of the <em class="italic">Processing data from our Python dictionary</em> section. We will cover the solution to this in the next steps:</p>&#13;
			<ol>&#13;
				<li value="1">The <strong class="source-inline">numbers</strong> key can be processed by our <strong class="source-inline">run_config</strong> function with the code defined here:<p class="source-code">    match config.get_item("numbers") {</p><p class="source-code">        Some(data) =&gt; {</p><p class="source-code">            match data.downcast::&lt;PyList&gt;() {</p><p class="source-code">                Ok(raw_data) =&gt; {</p><p class="source-code">                    let processed_results_two: \</p><p class="source-code">                      Vec&lt;Vec&lt;i32&gt;&gt; = </p><p class="source-code">                    raw_data.extract::&lt;Vec&lt;Vec&lt;i32&gt;&gt;&gt;(</p><p class="source-code">                    ).unwrap();</p><p class="source-code">                    config.set_item("NUMBERS RESULT", </p><p class="source-code">                    process_numbers(processed \</p><p class="source-code">                      _results_two));</p><p class="source-code">                },</p><p class="source-code">                Err(_) =&gt; Err(PyTypeError::new_err(</p><p class="source-code">                "parameter numbers is not a list of \</p><p class="source-code">                   lists of integers")).unwrap()</p><p class="source-code">            }</p><p class="source-code">        },</p><p class="source-code">        None =&gt; println!(</p><p class="source-code">        "parameter numbers is not in the config")</p><p class="source-code">    }</p><p class="source-code">    return Ok(config)</p><p>Here, we <a id="_idIndexMarker407"/>can see that the <strong class="source-inline">process_numbers</strong> function actually makes this implementation simpler than the <strong class="source-inline">numbers</strong> key processing. If the complexity starts to grow, it is always worth breaking down the logic into smaller functions. It also must be noted that we return a result that wraps the config dictionary. Now that we have finished the logic behind processing our dictionary, we need to return our dictionary in the next step.</p></li>&#13;
				<li>Here, we must publicly define our <strong class="source-inline">src/interface/config.rs</strong> file in the <strong class="source-inline">src/interface/mod.rs</strong> file by running the following code:<p class="source-code">pub mod config;</p></li>&#13;
				<li>We <a id="_idIndexMarker408"/>then import it into our <strong class="source-inline">src/lib.rs</strong> file by running the following code:<p class="source-code">mod interface;</p><p class="source-code">use interface::config::__pyo3_get_function_run_config;</p></li>&#13;
				<li>We then add the function to our module in the <strong class="source-inline">src/lib.rs</strong> file by running the following code:<p class="source-code">m.add_wrapped(wrap_pyfunction!(run_config));</p></li>&#13;
			</ol>&#13;
			<p>We have now carried out all the steps. </p>&#13;
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Returning our Rust dictionary to our Python system</h2>&#13;
			<p>Our <strong class="source-inline">pip</strong> module can now take in a configuration file, convert it into a Python dictionary, pass <a id="_idIndexMarker409"/>the Python dictionary into the Rust function that calculates the Fibonacci numbers, and return the results in the form of a dictionary back to Python. This can be achieved by carrying out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Define a <strong class="source-inline">.yml</strong> file to be ingested by our program. An example <strong class="source-inline">.yml</strong> file that can run what we have just done can be defined via the following code:<p class="source-code">number:</p><p class="source-code">  - 4</p><p class="source-code">  - 7</p><p class="source-code">  - 2</p><p class="source-code">numbers:</p><p class="source-code">  -</p><p class="source-code">    - 12</p><p class="source-code">    - 15</p><p class="source-code">    - 20</p><p class="source-code">  -</p><p class="source-code">    - 15</p><p class="source-code">    - 19</p><p class="source-code">    - 18</p><p>I have saved the preceding .<strong class="source-inline">yml</strong> code on my desktop for demonstration purposes under the filename <strong class="source-inline">example.yml</strong>. Remember to update your GitHub repository and uninstall your current module in your Python environment, and install our new module instead.</p></li>&#13;
				<li>We <a id="_idIndexMarker410"/>can then pass in the <strong class="source-inline">.yml</strong> file into our module entry point with the following command:<p class="source-code">config-fib --path example.yml</p></li>&#13;
				<li>I ran this command from my desktop, where I stored the <strong class="source-inline">example.yml</strong> file. Running the previous command gives us the following output:<p class="source-code">Here is the config data: </p><p class="source-code">{'number': [4, 7, 2, 10, 15],</p><p class="source-code"> 'numbers': [[5, 8, 12, 15, 20], [12, 15, 19, 18, 8]]}</p><p class="source-code">Here is the result:</p><p class="source-code">{'NUMBER RESULT': [3, 13, 1, 55, 610],</p><p class="source-code"> 'NUMBERS RESULT': [[5, 21, 144, 610, 6765], </p><p class="source-code">                    [144, 610, 4181, 2584, 21]],</p><p class="source-code"> 'number': [4, 7, 2, 10, 15],</p><p class="source-code"> 'numbers': [[5, 8, 12, 15, 20], [12, 15, 19, 18, 8]]}</p><p>Here, we can see that our Python interface fed the Python dictionary into the Rust interface. We then got the results of the Fibonacci functions passed back in the same dictionary. </p></li>&#13;
				<li>Now, we <a id="_idIndexMarker411"/>introduce a breaking change in our <strong class="source-inline">.yml</strong> file. We can test our error by changing the <strong class="source-inline">number</strong> key to a dictionary as opposed to a list of integers in our <strong class="source-inline">example.yml</strong> file by running the following code:<p class="source-code">number:</p><p class="source-code">  one: 1</p></li>&#13;
				<li>Finally we run our code again, expecting the correct error message. This gives us the following error when running our command again:<p class="source-code"><strong class="bold">pyo3_runtime.PanicException: called 'Result::unwrap()' </strong></p><p class="source-code"><strong class="bold">on an 'Err' value: PyErr { type: &lt;class 'TypeError'&gt;, </strong></p><p class="source-code"><strong class="bold">value: TypeError('parameter number is not a list of </strong></p><p class="source-code"><strong class="bold">integers'), </strong></p><p class="source-code"><strong class="bold">traceback: None }</strong></p><p>Here, we can see that a <strong class="source-inline">TypeError</strong> exception was raised. This is not trivial. This means that we can try to accept type errors in our Python code when using our Rust module if we need to. Considering this, if a user did not know how our module was built, they would have no problem thinking that our module was built in pure Python. There is one more test that we can consider. We only manually threw an error when we were downcasting to <strong class="source-inline">PyList</strong>, highlighting that we need to have a list of integers. However, we just unwrapped the <strong class="source-inline">extract</strong> function being performed on <strong class="source-inline">PyList</strong>. </p></li>&#13;
				<li>We can see how the <strong class="source-inline">extract</strong> function handles a string being put in, thereby changing the <strong class="source-inline">number</strong> key to a list of strings as opposed to a list of integers in our <strong class="source-inline">example.yml</strong> file, by running the following code:<p class="source-code">number:</p><p class="source-code">  - "test"</p></li>&#13;
				<li>Running our command again gives us the following output:<p class="source-code">pyo3_runtime.PanicException: called 'Result:: \</p><p class="source-code">  unwrap()' on an </p><p class="source-code">'Err' value: PyErr { type: &lt;class 'TypeError'&gt;, </p><p class="source-code">value: TypeError(</p><p class="source-code">"'str' object cannot be interpreted as an integer"), </p><p class="source-code">traceback: None }</p></li>&#13;
			</ol>&#13;
			<p>Here, we <a id="_idIndexMarker412"/>can see that the error string is a little harder to interpret because we did not directly code an error telling the user what we want; however, it is still <strong class="source-inline">TypeError</strong>. We can also see here that errors raised by functions that are acted on Python objects are Python-friendly. </p>&#13;
			<p>We have now concluded how to interact with complex Python data structures. Nothing is stopping you from building Python <strong class="source-inline">pip</strong> modules in Rust that fuse seamlessly with a Python program. However, we can take our Rust <strong class="source-inline">pip</strong> modules to the next level by working with and inspecting custom Python objects in the next section. </p>&#13;
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Inspecting and working with custom Python objects</h1>&#13;
			<p>Technically, everything <a id="_idIndexMarker413"/>in Python is an object. The <a id="_idIndexMarker414"/>Python dictionary that we worked on within the previous section is an object, so we have already managed Python objects. However, as we know, Python enables us to build custom objects. In this section, we will get our Rust function to accept a custom Python class that will have <strong class="source-inline">number</strong> and <strong class="source-inline">numbers</strong> attributes. To achieve this, we must carry out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Create <a id="_idIndexMarker415"/>an object that passes itself into <a id="_idIndexMarker416"/>our Rust interface.</li>&#13;
				<li>Acquire <a id="_idIndexMarker417"/>the Python <strong class="bold">global interpreter lock</strong> (<strong class="bold">GIL</strong>) within our Rust code to create a <strong class="source-inline">PyDict</strong> struct.</li>&#13;
				<li>Add the custom object's attributes to our newly created <strong class="source-inline">PyDict</strong> struct.</li>&#13;
				<li>Set the attributes of the custom object to the results of our <strong class="source-inline">run_config</strong> function.</li>&#13;
			</ol>&#13;
			<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Creating an object for our Rust interface</h2>&#13;
			<p>We start <a id="_idIndexMarker418"/>our journey by setting up our interface object, as follows:</p>&#13;
			<ol>&#13;
				<li value="1">We house our object that will pass itself into our Rust code in the <strong class="source-inline">flitton_fib_rs/object_interface.py</strong> file. Initially, we import what we need by running the following code:<p class="source-code">from typing import List, Optional</p><p class="source-code">from .flitton_fib_rs import object_interface</p></li>&#13;
				<li>We then define the <strong class="source-inline">__init__</strong> method of our object by running the following code:<p class="source-code">class ObjectInterface:</p><p class="source-code">    def __init__(self, number: List[int], \ </p><p class="source-code">       numbers: List[List[int]]) -&gt; None:</p><p class="source-code">        self.number: List[int] = number</p><p class="source-code">        self.numbers: List[List[int]] = numbers</p><p class="source-code">        self.number_results: Optional[List[int]] = \</p><p class="source-code">          None</p><p class="source-code">        self.numbers_results:Optional[List[List \</p><p class="source-code">          [int]]] = None</p><p>Here, we can see that we can pass in the Fibonacci numbers that we want to be calculated in the parameters. We then just set our attributes to the parameters that we passed in. The result parameters defined here are of a <strong class="source-inline">None</strong> value. However, they will be populated by the Rust code when we pass this object into our Rust object interface.</p></li>&#13;
				<li>We <a id="_idIndexMarker419"/>then define a function that will pass our object into the Rust code by running the following code:<p class="source-code">    def process(self) -&gt; None:</p><p class="source-code">        object_interface(self)</p></li>&#13;
			</ol>&#13;
			<p>Here, we can see that this is done by merely passing the <strong class="source-inline">self</strong> reference into the function. Now that we have defined our object, we can move on to build our interface and interact with the Python GIL. </p>&#13;
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Acquiring the Python GIL in Rust</h2>&#13;
			<p>For our <a id="_idIndexMarker420"/>interface, we will house our function in the <strong class="source-inline">src/interface/object.rs</strong> file. We'll proceed as follows:</p>&#13;
			<ol>&#13;
				<li value="1">First, we must import all of what we need by running the following code:<p class="source-code">use pyo3::prelude::{pyfunction, PyResult, Python};</p><p class="source-code">use pyo3::types::{PyAny, PyDict};</p><p class="source-code">use pyo3::exceptions::PyLookupError;</p><p class="source-code">use super::config::run_config;</p><p>Most of these imports will be familiar by now. The new import that we must make note of is the <strong class="source-inline">Python</strong> import. <strong class="source-inline">Python</strong> is a struct that is essentially a marker that is required for the Python operations that we will be doing.</p></li>&#13;
				<li>Now <a id="_idIndexMarker421"/>that we have imported everything we need, we can build parameters for our interface and create a <strong class="source-inline">PyDict</strong> struct by running the following code:<p class="source-code">#[pyfunction]</p><p class="source-code">pub fn object_interface&lt;'a&gt;(input_object: &amp;'a PyAny) \</p><p class="source-code">    -&gt; PyResult&lt;&amp;'a PyAny&gt; {</p><p class="source-code">    let gil = Python::acquire_gil();</p><p class="source-code">    let py = gil.python();</p><p class="source-code">    let config_dict: &amp;PyDict = PyDict::new(py);</p></li>&#13;
			</ol>&#13;
			<p>Here, what we have essentially done is acquire the Python GIL, and then use this to create a <strong class="source-inline">PyDict</strong> struct. To fully understand what we are doing, it is best to explore what the Python GIL is. In <a href="B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Concurrency</em>, we covered the concept of thread blocking. This means that if another thread is executing, then all other threads are locked. The GIL ensures that this happens, as demonstrated in the following diagram: </p>&#13;
			<div>&#13;
				<div id="_idContainer064" class="IMG---Figure">&#13;
					<img src="Images/Figure_6.2_B17720.jpg" alt="Figure 6.2 – GIL flow&#13;&#10;" width="987" height="493"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 6.2 – GIL flow</p>&#13;
			<p>This is <a id="_idIndexMarker422"/>because Python does not have any concept of ownership. A Python object can be referenced as many times as we want. We can also mutate the variable from any of those references. When we acquire the <strong class="source-inline">gil</strong> variable, we ensure that only one thread can use the Python interpreter and the Python <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) at the same time. We must <a id="_idIndexMarker423"/>remember that processes behave differently and have their own memory. Our <strong class="source-inline">gil</strong> variable is a <strong class="source-inline">GILGuard</strong> struct that ensures that we acquire the GIL before we run any operations on Python objects. </p>&#13;
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Adding data to our newly created PyDict struct</h2>&#13;
			<p>Now that <a id="_idIndexMarker424"/>we have control over Python objects with the GIL, we can move on to our next step, where we add the data from the input object to our newly created <strong class="source-inline">PyDict</strong> struct, as follows:</p>&#13;
			<ol>&#13;
				<li value="1">Our approach in this step can be summarized in the following diagram:<p class="figure-caption"> </p><div id="_idContainer065" class="IMG---Figure"><img src="Images/Figure_6.3_B17720.jpg" alt="" width="776" height="1013"/></div><p class="figure-caption">Figure 6.3 – PyDict flow</p></li>&#13;
				<li>We can <a id="_idIndexMarker425"/>achieve the first cycle depicted in <em class="italic">Figure 6.3</em> by running the following code:<p class="source-code">    match input_object.getattr("number") {</p><p class="source-code">        Ok(data) =&gt; {</p><p class="source-code">            config_dict.set_item("number", data) \</p><p class="source-code">              .unwrap();</p><p class="source-code">        },</p><p class="source-code">        Err(_) =&gt; Err(PyLookupError::new_err(</p><p class="source-code">            "attribute number is missing")).unwrap()</p><p class="source-code">    }</p><p>Here, we can see that we match the <strong class="source-inline">getattr</strong> function, throwing an error if <strong class="source-inline">input_object</strong> does not have the <strong class="source-inline">number</strong> attribute. If we do have the attribute, we assign it to <strong class="source-inline">config_dict</strong>. </p></li>&#13;
				<li>We can do the second cycle by running the following code:<p class="source-code">    match input_object.getattr("numbers") {</p><p class="source-code">        Ok(data) =&gt; {</p><p class="source-code">            config_dict.set_item("numbers", data) \</p><p class="source-code">              .unwrap();</p><p class="source-code">        }</p><p class="source-code">        Err(_) =&gt; Err(PyLookupError::new_err(</p><p class="source-code">            "attribute numbers is missing")).unwrap()</p><p class="source-code">    }</p></li>&#13;
				<li>It must <a id="_idIndexMarker426"/>be noted that there is a fair amount of repetition, with only one change. We could refactor this into a single function with an <strong class="source-inline">attribute</strong> parameter by running the following code:<p class="source-code">fn extract_data&lt;'a&gt;(input_object: &amp;'a PyAny, \</p><p class="source-code">    attribute: &amp;'a str, config_dict: &amp;'a PyDict) \</p><p class="source-code">      -&gt; &amp;'a PyDict {</p><p class="source-code">    match input_object.getattr(attribute) {</p><p class="source-code">        Ok(data) =&gt; {</p><p class="source-code">            config_dict.set_item(attribute, \</p><p class="source-code">              data).unwrap();</p><p class="source-code">        },</p><p class="source-code">        Err(_) =&gt; Err(PyLookupError::new_err(</p><p class="source-code">            "attribute number is missing")).unwrap()</p><p class="source-code">    }</p><p class="source-code">    return config_dict</p><p class="source-code">}</p></li>&#13;
				<li>Here, we can see that we get a lot of flexibility with our Python objects. This function can be used multiple times with the refactored code in our <strong class="source-inline">object_interface</strong> function, as seen here:<p class="source-code">    let mut config_dict: &amp;PyDict = PyDict::new(py);</p><p class="source-code">    config_dict = extract_data(input_object, \</p><p class="source-code">      "number", config_dict);</p><p class="source-code">    config_dict = extract_data(input_object, </p><p class="source-code">      "numbers", config_dict);</p></li>&#13;
			</ol>&#13;
			<p>Here, we can <a id="_idIndexMarker427"/>see that we have changed <strong class="source-inline">config_dict</strong> to a mutable. Now that we have loaded our <strong class="source-inline">PyDict</strong> struct with all the data that we need, all we must do is run our <strong class="source-inline">run_config</strong> function, add it to the input object's attributes, and return it to the Python interface in the next step. </p>&#13;
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Setting the attributes of our custom object</h2>&#13;
			<p>We are <a id="_idIndexMarker428"/>now in the final stage of our interface module. Here are the steps:</p>&#13;
			<ol>&#13;
				<li value="1">We can pass the output from our <strong class="source-inline">run_config</strong> function to our Python object interface by running the following code:<p class="source-code">    let output_dict: &amp;PyDict = run_config( \</p><p class="source-code">      config_dict).unwrap();</p><p class="source-code">    input_object.setattr(</p><p class="source-code">        "number_results", </p><p class="source-code">        output_dict.get_item(</p><p class="source-code">            "NUMBER RESULT").unwrap()).unwrap();</p><p class="source-code">    input_object.setattr(</p><p class="source-code">        "numbers_results", </p><p class="source-code">        output_dict.get_item(</p><p class="source-code">            "NUMBERS RESULT").unwrap()).unwrap();</p><p class="source-code">    return Ok(input_object)</p><p>Here, we can see that we get the <strong class="source-inline">output_dict</strong> Python dictionary from the <strong class="source-inline">run_config</strong> function. Once we have got this, we set the <strong class="source-inline">input_object</strong> attribute based on the items from <strong class="source-inline">output_dict</strong>. </p></li>&#13;
				<li>We have <a id="_idIndexMarker429"/>now completed our interface and we must subsequently plug it into our Rust module. We publicly define our interface file in the <strong class="source-inline">src/interface/mod.rs</strong> file by running the following code:<p class="source-code">pub mod object;</p></li>&#13;
				<li>We can then define our interface function in our Rust module by importing it into our <strong class="source-inline">src/lib.rs</strong> file, as follows:<p class="source-code">use interface::object::__pyo3_get_function_object_ \</p><p class="source-code">  interface;</p></li>&#13;
				<li>We then add our function to our module, as follows: <p class="source-code">    m.add_wrapped(wrap_pyfunction!(object_interface));</p></li>&#13;
				<li>Our module is now fully functioning. As always, we must remember to update our GitHub repository, uninstall our old module in our Python environment, and reinstall it. Once this is done, we can test it by running a Python shell. In our shell, we can test our object by running the following code:<p class="source-code">&gt;&gt;&gt; from flitton_fib_rs.object_interface import </p><p class="source-code">ObjectInterface</p><p class="source-code">&gt;&gt;&gt; test = ObjectInterface([5, 6, 7, 8], [])</p><p class="source-code">&gt;&gt;&gt; test.process()</p><p class="source-code">&gt;&gt;&gt; test.number_results</p><p class="source-code">[5, 8, 13, 21]</p></li>&#13;
			</ol>&#13;
			<p>Here, we can see that we import the object that we are going to use. We then initialize it and run the <strong class="source-inline">process</strong> function. Once this is done, we can see that our Rust code accepted our object and interacted with it as we have the correct results for our <strong class="source-inline">number_results</strong> attribute. </p>&#13;
			<p>Now we can interact with Python custom objects, the problems we can solve and how we can <a id="_idIndexMarker430"/>interact with the Python system are powerful. Custom Python objects do not hold us back. However, it is important not to get too carried away with Python objects in our Rust code. While we should use them in our interface, we shouldn't have to rely on them to build the whole program. In this section, we did do this, as we were leaning on a function that we built in the previous section to avoid excessive code, to get a point across. However, in your projects, Python objects should leave your code after the interface. If you find yourself using Python objects in your Rust code throughout, then you must ask yourself why you are not just using pure Python. Coding in Python will be slower than coding in Rust, but the metaclass, dynamic attributes, and many other Python features will make coding in Python easier and more enjoyable than trying to force a Python style of coding into Rust. Rust offers structs, traits, enums, and strong typing with lifetimes that get cut after moving out of scope to keep resources low. </p>&#13;
			<p>So, lean into this style of coding to fully reap the benefits of building <strong class="source-inline">pip</strong> modules in Rust. Push past your comfort zone of the Python coding style. The next section is about building Python objects in Rust code. </p>&#13;
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Constructing our own custom Python objects in Rust</h1>&#13;
			<p>In this <a id="_idIndexMarker431"/>final section, we will build a Python <a id="_idIndexMarker432"/>module in Rust that can be interacted with in the Python system as if it were a native Python object. To do this, we must follow these steps:</p>&#13;
			<ol>&#13;
				<li value="1">Define a Python class with all our attributes.</li>&#13;
				<li>Define class static methods to process numbers.</li>&#13;
				<li>Define a class constructor.</li>&#13;
			</ol>&#13;
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Defining a Python class with the required attributes</h2>&#13;
			<p>To start <a id="_idIndexMarker433"/>our journey, we define our class in the <strong class="source-inline">src/class_module/fib_processor.rs</strong> file, as follows: </p>&#13;
			<ol>&#13;
				<li value="1">To build our class, we need to import the required macros by running the following code:<p class="source-code">use pyo3::prelude::{pyclass, pymethods, staticmethod};</p><p class="source-code">use crate::fib_calcs::fib_number::fibonacci_number;</p><p class="source-code">use crate::fib_calcs::fib_numbers::fibonacci_numbers;</p><p>Here, we are using the <strong class="source-inline">pyclass</strong> macro to define our Rust Python class. We then use <strong class="source-inline">pymethods</strong> and <strong class="source-inline">staticmethod</strong> to define methods attached to the class. We also use standard Fibonacci numbers to calculate the Fibonacci numbers. </p></li>&#13;
				<li>Now that we have imported everything we need, we can define the class and the attributes, as follows:<p class="source-code">#[pyclass]</p><p class="source-code">pub struct FibProcessor {</p><p class="source-code">    #[pyo3(get, set)]</p><p class="source-code">    pub number: Vec&lt;i32&gt;,</p><p class="source-code">    #[pyo3(get, set)]</p><p class="source-code">    pub numbers: Vec&lt;Vec&lt;i32&gt;&gt;,</p><p class="source-code">    #[pyo3(get)]</p><p class="source-code">    pub number_results: Vec&lt;u64&gt;,</p><p class="source-code">    #[pyo3(get)]</p><p class="source-code">    pub numbers_results: Vec&lt;Vec&lt;u64&gt;&gt;</p><p class="source-code">}</p></li>&#13;
			</ol>&#13;
			<p>Here, we can see that we use Rust typing for our attributes. We also use a macro to state <a id="_idIndexMarker434"/>what we can do with these attributes. For our <strong class="source-inline">number</strong> and <strong class="source-inline">numbers</strong> attributes, we can get and set data belonging to these attributes. However, with our <strong class="source-inline">results</strong> attributes, we can only get data as this is set by the calculations. </p>&#13;
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Defining class static methods to process input numbers </h2>&#13;
			<p>We can now use our attributes to implement class methods. </p>&#13;
			<p>Just <a id="_idIndexMarker435"/>as with standard structs, we can implement methods attached to the class with an <strong class="source-inline">impl</strong> block, as seen in the following code snippet:</p>&#13;
			<p class="source-code">#[pymethods]</p>&#13;
			<p class="source-code">impl FibProcessor {</p>&#13;
			<p class="source-code">    #[staticmethod]</p>&#13;
			<p class="source-code">    fn process_numbers(input_numbers: Vec&lt;Vec&lt;i32&gt;&gt;) \</p>&#13;
			<p class="source-code">      -&gt; Vec&lt;Vec&lt;u64&gt;&gt; {</p>&#13;
			<p class="source-code">        let mut buffer: Vec&lt;Vec&lt;u64&gt;&gt; = Vec::new();</p>&#13;
			<p class="source-code">        for i in input_numbers {</p>&#13;
			<p class="source-code">            buffer.push(fibonacci_numbers(i));</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">        return buffer</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, we can see that we have applied the <strong class="source-inline">pymethods</strong> macro to our <strong class="source-inline">impl</strong> block. We also <a id="_idIndexMarker436"/>apply the <strong class="source-inline">staticmethod</strong> macro to our <strong class="source-inline">process_numbers</strong> static method. This function was used before, in the previous section, to process lists of lists. Now that our static method is defined, we can use this in our constructor method in the next step. </p>&#13;
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Defining a class constructor</h2>&#13;
			<p>Here are <a id="_idIndexMarker437"/>the steps we need to take:</p>&#13;
			<ol>&#13;
				<li value="1">We can define our constructor method in our <strong class="source-inline">impl</strong> block by running the following code:<p class="source-code">    #[new]</p><p class="source-code">    fn new(number: Vec&lt;i32&gt;, numbers: Vec&lt;Vec&lt;i32&gt;&gt;) \</p><p class="source-code">      -&gt; Self {</p><p class="source-code">        let input_numbers: Vec&lt;Vec&lt;i32&gt;&gt; = \</p><p class="source-code">          numbers.clone();</p><p class="source-code">        let input_number: Vec&lt;i32&gt; = number.clone();</p><p class="source-code">        let number_results: Vec&lt;u64&gt; = </p><p class="source-code">          input_number.iter(</p><p class="source-code">                             ).map(</p><p class="source-code">            |x| fibonacci_number(*x)</p><p class="source-code">        ).collect();</p><p class="source-code">        let numbers_results: Vec&lt;Vec&lt;u64&gt;&gt; = Self::</p><p class="source-code">                 process_numbers(input_numbers);</p><p class="source-code">        return FibProcessor {number, numbers, </p><p class="source-code">                 number_results, numbers_results}</p><p class="source-code">    }</p><p>Here, we accept inputs for the calculations of the Fibonacci numbers. We then clone them because we are going to pass them through the Fibonacci number functions. Once this is done, we apply the <strong class="source-inline">fibonacci_number</strong> function by mapping the input and collecting the results. We also collect the results from our static method. Once all the data is calculated, we construct the class and return it. Once this is done, all we must do is connect our class to our module. </p></li>&#13;
				<li>This can <a id="_idIndexMarker438"/>be done by publicly declaring our class file in the <strong class="source-inline">src/class_module/mod.rs</strong> file, as follows:<p class="source-code">pub mod fib_processor;</p></li>&#13;
				<li>Now that this is done, we import it into our <strong class="source-inline">src/lib.rs</strong> file by running the following code:<p class="source-code">mod class_module;</p><p class="source-code">use class_module::fib_processor::FibProcessor;</p></li>&#13;
				<li>Once this is done, we can add our class to our module in the same file, as follows:<p class="source-code">m.add_class::&lt;FibProcessor&gt;()?;</p></li>&#13;
			</ol>&#13;
			<p>We have now fully integrated our class into the <strong class="source-inline">pip</strong> module. </p>&#13;
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Wrapping up and testing our module</h2>&#13;
			<p>As always, when <a id="_idIndexMarker439"/>we get to the end of a section, we <a id="_idIndexMarker440"/>must remember to do the following:</p>&#13;
			<ul>&#13;
				<li> Update the GitHub repository.</li>&#13;
				<li> Uninstall the current <strong class="source-inline">pip</strong> module.</li>&#13;
				<li> Reinstall it in our Python environment.</li>&#13;
			</ul>&#13;
			<p>Now that we have finished building our module and updated the installed version, we can manually test our module in the Python system by following these next steps:</p>&#13;
			<ol>&#13;
				<li value="1">We can open our Python shell and test our class by running the following code:<p class="source-code">&gt;&gt;&gt; from flitton_fib_rs.flitton_fib_rs import </p><p class="source-code">FibProcessor</p><p class="source-code">&gt;&gt;&gt; test = FibProcessor([11, 12, 13, 14], [[11, 12], </p><p class="source-code">                        [13, 14], [15, 16]])</p><p class="source-code">&gt;&gt;&gt; test.numbers_results</p><p class="source-code">[[89, 144], [233, 377], [610, 987]]</p></li>&#13;
				<li>We can <a id="_idIndexMarker441"/>see that our Rust object <a id="_idIndexMarker442"/>works seamlessly in our Python system with calculated results. We must remember that we have set rules around our attributes. To check this, we can try to assign our <strong class="source-inline">results</strong> attribute, which will give us the following output:<p class="source-code"><strong class="bold">&gt;&gt;&gt; test.numbers_results = "test"</strong></p><p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p><p class="source-code"><strong class="bold">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></p><p class="source-code"><strong class="bold">AttributeError: attribute 'numbers_results' of </strong></p><p class="source-code"><strong class="bold">'builtins.FibProcessor' objects is not writable</strong></p></li>&#13;
				<li>Here, we can see that our <strong class="source-inline">results</strong> attribute is not writable. We can also test typing. Although our <strong class="source-inline">number</strong> attribute is writable, it is supposed to be a vector of integers. If we try to assign a string to this attribute, we get the following printout:<p class="source-code"><strong class="bold">&gt;&gt;&gt; test.number = "test"</strong></p><p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p><p class="source-code"><strong class="bold">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></p><p class="source-code"><strong class="bold">TypeError: 'str' object cannot be interpreted as an </strong></p><p class="source-code"><strong class="bold">integer</strong></p></li>&#13;
				<li>Here, we can see that our typing is also enforced, even though it looks and acts like a <a id="_idIndexMarker443"/>native Python object. Finally, we <a id="_idIndexMarker444"/>can test to see if we can write a new value to the <strong class="source-inline">number</strong> attribute by running the following code:<p class="source-code">&gt;&gt;&gt; test.number = [1, 2, 3, 4, 5]</p><p class="source-code">&gt;&gt;&gt; test.number</p><p class="source-code">[1, 2, 3, 4, 5]</p><p>It seems that we can write when the type and permissions are correct. Considering all of this, what is the point of creating these classes? They make the interface for our module smoother, but how much faster is this class? </p></li>&#13;
			</ol>&#13;
			<p>To quantify this, we can create a simple testing Python script in our Python environment, as follows:</p>&#13;
			<ol>&#13;
				<li value="1">First, in our Python script, we import our Rust class and the <strong class="source-inline">time</strong> module by running the following code:<p class="source-code">from flitton_fib_rs.flitton_fib_rs import FibProcessor</p><p class="source-code">import time</p></li>&#13;
				<li>We must now create a pure Python object with the same functionality in this script, as follows: <p class="source-code">class PythonFibProcessor:</p><p class="source-code">     def __init__(self, number, numbers):</p><p class="source-code">           self.number = number</p><p class="source-code">           self.numbers = numbers</p><p class="source-code">           self.numbers_results = None</p><p class="source-code">           self.number_results = None</p><p class="source-code">           self._process()</p><p class="source-code">     def _process(self):</p><p class="source-code">           self.numbers_results = \</p><p class="source-code">             [self.calculate_numbers(i)\ </p><p class="source-code">               for i in self.numbers]</p><p class="source-code">           self.number_results = \</p><p class="source-code">             self.calculate_numbers(</p><p class="source-code">               self.number)</p><p class="source-code">     def fibonacci_number(self, number):</p><p class="source-code">         if number &lt; 0:</p><p class="source-code">             return None</p><p class="source-code">         elif number &lt;= 2:</p><p class="source-code">             return 1</p><p class="source-code">         else:</p><p class="source-code">          return self.fibonacci_number(number - 1) + \</p><p class="source-code">                    self.fibonacci_number(number - 2)</p><p class="source-code">     def calculate_numbers(self, numbers):</p><p class="source-code">          return [self.fibonacci_number(i) for i in \</p><p class="source-code">            numbers]</p></li>&#13;
				<li>Now that our benchmark pure Python object is defined, we are now at the timing stage <a id="_idIndexMarker445"/>of the script, where we <a id="_idIndexMarker446"/>put the same inputs into both classes and test them with the following code:<p class="source-code">t_one = time.time()</p><p class="source-code">test = FibProcessor([11, 12, 13, 14], [[11, 12], \</p><p class="source-code">    [13, 14], [15, 16]])</p><p class="source-code">t_two = time.time()</p><p class="source-code">print(t_two - t_one)</p><p class="source-code">t_one = time.time()</p><p class="source-code">test = PythonFibProcessor([11, 12, 13, 14], \</p><p class="source-code">  [[11, 12], [13, 14], [15, 16]])</p><p class="source-code">t_two = time.time()</p><p class="source-code">print(t_two - t_one)</p></li>&#13;
				<li>Running this gives us the following output:<p class="source-code"><strong class="bold">1.4781951904296875e-05</strong></p><p class="source-code"><strong class="bold">0.0007779598236083984</strong></p><p>This translates to the following:</p><p class="source-code">0.000017881393432617188</p><p class="source-code">0.0007779598236083984</p></li>&#13;
			</ol>&#13;
			<p>Remember, the Rust class is the top reading. This means that our Rust class is <em class="italic">43 times faster than our Python class!</em> To put this into perspective, we can see the difference in the following screenshot:</p>&#13;
			<div>&#13;
				<div id="_idContainer066" class="IMG---Figure">&#13;
					<img src="Images/Figure_6.4_B17720.jpg" alt="Figure 6.4 – Class speed difference between Rust and Python&#13;&#10;" width="1650" height="649"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 6.4 – Class speed difference between Rust and Python</p>&#13;
			<p>Here, we can <a id="_idIndexMarker447"/>see that our class interfaces <a id="_idIndexMarker448"/>built in Rust are faster than our Python classes. <strong class="source-inline">pyo3</strong> supports class inheritance and other features. More resources on this are supplied in the <em class="italic">Further reading</em> section. We now have a strong base when it comes to working with Python objects in Rust. There are always more features to read up on, and these can be built on top of the structures that we have built.</p>&#13;
			<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Summary</h1>&#13;
			<p>In this chapter, we added a third-party <strong class="source-inline">pip</strong> module into our <strong class="source-inline">setup.py</strong> file so that we could add another entry point that could read .<strong class="source-inline">yml</strong> files. We read the .<strong class="source-inline">yml</strong> file and passed the data from that file in the form of a dictionary into our Rust functions, handling the complex data structure under the <strong class="source-inline">PyDict</strong> struct. We then downcasted data from our complex data structure into other Python objects and Rust data types. This gave us the power to handle a range of Python data types passed into our Rust code, giving us extra flexibility in how our Python code interacts with our Rust code. </p>&#13;
			<p>We went one step further than complex Python data structures by accepting custom Python objects under the <strong class="source-inline">PyAny</strong> struct. Once we accepted custom Python objects, we could inspect attributes and set them as and when we wanted to. We even acquired the Python GIL to create our own Python data structures to help us work with the custom Python objects passed into our Rust code. To polish off our Python object skills, we built Python classes within our Rust code that not only can be imported into the Python system, acting just like a pure Python class, but are also 44 times faster. We now have a powerful tool that will not only speed up our Python code but will also enable us to interact with Python systems seamlessly. </p>&#13;
			<p>In the next chapter, we tackle the final hurdle that is stopping us from infusing Rust into every Python project we have. People reach for Python due to the extensive third-party modules that are built for it, such as statistical and <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) packages. We will work with the third-party <strong class="source-inline">numpy</strong> module and use it in our Rust code. This will enable us to utilize third-party Python modules in our Rust extension.  </p>&#13;
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">How do you extract a vector of <strong class="source-inline">i32</strong> integers from a <strong class="source-inline">PyDict</strong> struct?</li>&#13;
				<li>If we have a vector of strings but we apply a <strong class="source-inline">.extract::&lt;Vec&lt;i32&gt;&gt;()</strong>  function on it and we directly unwrap it, what will happen?</li>&#13;
				<li>How would you be able to loop through a <strong class="source-inline">Vec&lt;i32&gt;</strong> vector, doubling each item and packaging the results in another vector in one line of Rust code?</li>&#13;
				<li>If we acquire the Python GIL to create a <strong class="source-inline">PyDict</strong> struct, will this affect the Python system in any way? </li>&#13;
				<li>Although our Python classes built in our Rust code essentially run the same way as our pure Python classes, there are some core differences. What are they?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/>Answers</h1>&#13;
			<ol>&#13;
				<li value="1">First, we must get a list from the <strong class="source-inline">PyDict</strong> struct by applying the <strong class="source-inline">get_item</strong> function to <strong class="source-inline">PyDict</strong>. If there is data under the key that we use, we then perform <strong class="source-inline">.downcast::&lt;PyList&gt;()</strong> to convert our data into a <strong class="source-inline">PyList</strong> struct. If we achieve this, we then perform <strong class="source-inline">.extract::&lt;Vec&lt;i32&gt;&gt;()</strong> on the <strong class="source-inline">PyList</strong> struct, giving us a <strong class="source-inline">Vec&lt;i32&gt;</strong>.</li>&#13;
				<li>Our <strong class="source-inline">extract</strong> function will automatically throw a <strong class="source-inline">PyTypeError</strong> Python-friendly error.</li>&#13;
				<li>With this, we use the <strong class="source-inline">iter</strong>, <strong class="source-inline">map</strong>, and <strong class="source-inline">collect</strong> functions, as follows:<p class="source-code">let results: Vec&lt;i32&gt; = some_vector.iter().map(</p><p class="source-code">            |x| 2*x</p><p class="source-code">        ).collect();</p></li>&#13;
				<li>No—the Python system that is running the code has already acquired the GIL. If it does not have the GIL, it would just wait for another thread to finish before acquiring the GIL.</li>&#13;
				<li>The typing system is still enforced. If we try to set an attribute that is a list of integers to a string, an error will be thrown. Another difference is that <strong class="source-inline">set</strong> and <strong class="source-inline">get</strong> macros for each attribute must be defined. If they are not, then the attribute cannot be accessed or set. </li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Further reading</h1>&#13;
			<ul>&#13;
				<li><em class="italic">PyO3</em> (2021). <em class="italic">PyO3 user guide</em>—<em class="italic">Python Classes</em> <a href="https://pyo3.rs/v0.13.2/class.html">https://pyo3.rs/v0.13.2/class.html</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>