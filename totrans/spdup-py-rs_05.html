<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-101"><em class="italic"><a id="_idTextAnchor100"/>Chapter 6</em>: Working with Python Objects in Rust</h1>&#13;
			<p>So far, we have managed to fuse Rust with Python to speed up our code. However, software programs written in Rust can get complicated. While we can get by with passing integers and strings into Rust functions from Python code, it would be useful to handle more complex data structures from Python and objects. In this chapter, we accept and process Python data structures such as a <strong class="bold">dictionary</strong>. We will go further by processing custom Python objects and even creating Python objects inside our Rust code. </p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Passing complex Python objects into Rust</li>&#13;
				<li>Inspecting and working with custom Python objects</li>&#13;
				<li>Constructing our own custom Python objects in Rust</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Technical requirements</h1>&#13;
			<p>The code for this chapter can be found via the following GitHub link:</p>&#13;
			<p><a href="https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_six">https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_six</a> </p>&#13;
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Passing complex Python objects into Rust</h1>&#13;
			<p>A key skill <a id="_idIndexMarker391"/>that enables us to take our Rust <code>pip</code> module <a id="_idIndexMarker392"/>development to the next level is taking in complex Python data structures/objects and using them. In <a href="B17720_05_Final_SK_ePub.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Creating a Rust Interface for Our pip Module</em>, we accepted integers. We noticed that these raw integers were just directly transferred to our Rust function. However, with Python objects, it is more complex than this. </p>&#13;
			<p>To explore this, we will create a new command-line function that reads a .<code>yml</code> file and passes a Python dictionary into our Rust function. The data in this dictionary will have the parameters needed for firing our <code>fibonacci_numbers</code> and <code>fibonacci_number</code> Rust functions, adding the results of those functions to the Python dictionary and passing it back to the Python system. </p>&#13;
			<p>To achieve this, we must carry out the following steps:</p>&#13;
			<ol>&#13;
				<li>Update our <code>setup.py</code> file to support .<code>yml</code> loading and a command-line function that reads it.</li>&#13;
				<li>Define a command-line function that reads the <code>.yml</code> file and feeds it into Rust. </li>&#13;
				<li>Process data from our Python dictionary for <code>fibonacci_numbers</code> in Rust.</li>&#13;
				<li>Extract data from our config file.</li>&#13;
				<li>Return our Python dictionary to our Python system.</li>&#13;
			</ol>&#13;
			<p>This approach <a id="_idIndexMarker393"/>will require us to write the whole <a id="_idIndexMarker394"/>process before we can run it. This can be frustrating because we cannot see it working until the end. However, it is laid out in this book this way so that we can see the data flow. We are exploring the concept of passing complex data structures into Rust for the first time. Once we understand how this works, we can then develop <code>pip</code> modules that work for us as individuals.</p>&#13;
			<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>Updating our setup.py file to support .yml loading</h2>&#13;
			<p> Let's <a id="_idIndexMarker395"/>start this journey by updating our <code>setup.py</code> file, as follows:</p>&#13;
			<ol>&#13;
				<li value="1">With our new command-line function, we read a .<code>yml</code> file and pass through that data to our Rust function. This requires our Python <code>pip</code> module to have the <code>pyyaml</code> Python module. This can be done by adding the <code>requirements</code> parameter to our <code>setup</code> initialization, as follows: <pre>    requirements=[
        "pyyaml&gt;=3.13"
    ]</pre><p>We remember that we can keep adding more dependencies to our module by just adding them to our <code>requirements</code> list. If we want our module to be more flexible for multiple installs to different systems, it is advised that we can lower the version number for our <code>pyyaml</code> module requirement. </p></li>&#13;
				<li>Now <a id="_idIndexMarker396"/>that we have defined our requirements, we can define a new console script, resulting in the <code>entry_points</code> parameter in our <code>setup</code> initialization, which looks like this:<pre>    entry_points={
        'console_scripts': [
            'fib-number = flitton_fib_rs.'
            'fib_number_command:'
            'fib_number_command',
            'config-fib = flitton_fib_rs.'
            'config_number_command:'
            'config_number_command',
        ],
    },</pre><p>With this, we can see that our new console script will be in the <code>flitton_fib_rs/config_number_command.py</code> directory.</p></li>&#13;
				<li>In the <code>flitton_fib_rs/config_number_command.py</code> directory, we need to build a function called <code>config_number_command</code>. First, we need to import the required modules, as follows:<pre>import argparse
import yaml
import os
from pprint import pprint
from .flitton_fib_rs import run_config</pre></li>&#13;
			</ol>&#13;
			<p><code>os</code> will <a id="_idIndexMarker397"/>help us with the path definition to the <code>.yml</code> file. The <code>pprint</code> function will just help us print the data in an easy-to-read format on the console. We have also defined a Rust function that will process our dictionary as <code>run_config</code>. </p>&#13;
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Defining our .yml loading command</h2>&#13;
			<p>Now that <a id="_idIndexMarker398"/>our imports have been done, we can define our function and collect the command-line arguments. Here's how we do this:</p>&#13;
			<ol>&#13;
				<li value="1">You can start with the following code:<pre>def config_number_command() -&gt; None:
    parser = argparse.ArgumentParser(
        description='Calculate Fibonacci numbers '
                    'using a config file')
    parser.add_argument('--path', action='store',
                        type=str, required=True,
                        help="path to config file")
    args = parser.parse_args()</pre></li>&#13;
				<li>Here, we can see that we take in a string, which is the path to the <code>.yml</code> file with the <code>--path</code> tag, and we parse it. Now that we have parsed the path, we can open our <code>.yml</code> file by running the following code:<pre>    with open(str(os.getcwd()) + "/" + args.path) as \
      f:
        config_data: dict = yaml.safe_load(f)</pre><p>Here, we can see that we attach our path with the <code>os.getcwd()</code> function. This is because we must know where the user is calling the command. For instance, if we are in the <code>x/y/</code> directory and we want to point to the <code>x/y/z.yml</code> file, we will have to run the <code>config-fib --path z.yml</code> command. If the directory of the file were <code>x/y/test/z.yml</code>, we would have had to run the <code>config-fib --path test/z.yml</code> command.</p></li>&#13;
				<li>Now <a id="_idIndexMarker399"/>that we have our data loaded from the <code>.yml</code> file, we can print it out and print out the results of our Rust function by running the following code:<pre>    print("Here is the config data: ")
    pprint(config_data)
    print(f"Here is the result:")
    pprint(run_config(config_data))</pre></li>&#13;
			</ol>&#13;
			<p>With this, we have now completed all our Python code. </p>&#13;
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Processing data from our Python dictionary</h2>&#13;
			<p>We are <a id="_idIndexMarker400"/>now going to have to build Rust functions that process the Python dictionaries. Here's how we'll go about this:</p>&#13;
			<ol>&#13;
				<li value="1">When it comes to processing input dictionaries, we must agree on a format that we are going to accept. To keep this simple, our Python dictionaries will have two keys. The <code>number</code> key is for a list of integers that can call Fibonacci number calculations individually, while the <code>numbers</code> key is for a list of lists of integers. To ensure that our Rust code does not become disorganized, we are going to define our interfaces in our own interface directory, giving our Rust code the following structure:<pre>├── fib_calcs
│   ├── fib_number.rs
│   ├── fib_numbers.rs
│   └── mod.rs
├── interface
│   ├── config.rs
│   └── mod.rs
├── lib.rs
└── main.rs</pre></li>&#13;
				<li>We <a id="_idIndexMarker401"/>will build our configuration interface in the <code>src/interface/config.rs</code> file. First, we are going to import all the functions and macros that we need, as follows:<pre>use pyo3::prelude::{pyfunction, PyResult};
use pyo3::types::{PyDict, PyList};
use pyo3::exceptions::PyTypeError;
use crate::fib_calcs::fib_number::fibonacci_number;
use crate::fib_calcs::fib_numbers::fibonacci_numbers;</pre><p>We are going to use <code>pyfunction</code> to wrap our interface that takes in a Python dictionary. We will return the dictionary back to the Python program wrapped in a <code>pyResult</code> struct. Seeing as we are accepting a Python dictionary, we will be using a <code>PyDict</code> struct to describe the dictionary being passed in and returned. We will also be accessing the lists in the dictionary using a <code>PyList</code> struct. If there is an issue with our dictionary not housing lists, then we will have to throw an error that the Python system will understand. To do this, we will use a <code>PyTypeError</code> struct. Finally, we will be using our Fibonacci number functions to calculate the Fibonacci numbers. We can see that we are simply importing from another module in the Rust code with <code>use crate::</code>. Even though our Fibonacci number functions have the <code>pyfunction</code> macro applied to them, nothing is stopping us from using them as normal Rust functions elsewhere in our Rust code. </p></li>&#13;
				<li>Before we write our interface function, we need to build a private function that accepts our lists of lists, calculates the Fibonacci numbers, and returns them in a list of lists, as seen in the following code snippet:<pre>fn process_numbers(input_numbers: Vec&lt;Vec&lt;i32&gt;&gt;) \
    -&gt; Vec&lt;Vec&lt;u64&gt;&gt; {
    let mut buffer: Vec&lt;Vec&lt;u64&gt;&gt; = Vec::new();
    for i in input_numbers {
        buffer.push(fibonacci_numbers(i));
    }
    return buffer
}</pre></li>&#13;
				<li>This <a id="_idIndexMarker402"/>should be straightforward at this stage in the book. Considering this, we now have everything we need to build our interface. First, we need to define a <code>pyfunction</code> function that accepts and returns the same data by running the following code:<pre>#[pyfunction]
pub fn run_config&lt;'a&gt;(config: &amp;'a PyDict) \
    -&gt; PyResult&lt;&amp;'a PyDict&gt; {</pre><p>Here, we can see that we tell the Rust compiler that the Python dictionary that we accept must have the same lifetime as the Python dictionary that we are returning. This makes sense as we are returning the same dictionary after adding the results to it. </p></li>&#13;
				<li>Our first process is to see if the <code>number</code> key is present in the dictionary by running the following code:<pre>    match config.get_item("number") {
        Some(data) =&gt; {
            . . .
        },
        None =&gt; println!(
        "parameter number is not in the config"
        )
    }</pre><p>Here, we <a id="_idIndexMarker403"/>can see that is the <code>number</code> key is not there, so we merely print that it is not there. We can change the rules to throw an error instead, but we are accepting a forgiving <code>config</code> file. If the user does not have any individual Fibonacci numbers to compute, only lists of them, then we should not throw errors, insisting that the user adds the field. The three dots in the code snippet shown in <em class="italic">Step 6</em> are where the code is going to be executed if the <code>number</code> key is present. </p></li>&#13;
				<li>We substitute the three dots in the following code snippet:<pre>            match data.downcast::&lt;PyList&gt;() {
                Ok(raw_data) =&gt; {
                    . . .
                },
                Err(_) =&gt; Err(PyTypeError::new_err(
                    "parameter number is not a list 
                    of integers")).unwrap()
            }</pre><p>Here, we can see that we downcast the data we extracted belonging to the <code>number</code> key to the <code>PyList</code> struct. If this fails, then we actively throw a type error because the user has tried to configure the <code>number</code> key but failed. If it passes, we can run the Fibonacci function by substituting the three dots in the preceding code snippet with the following code:</p><pre>                    let processed_results: Vec&lt;i32&gt; = 
              raw_data.extract::&lt;Vec&lt;i32&gt;&gt;().unwrap();
                    let fib_numbers: Vec&lt;u64&gt; = 
                    processed_results.iter().map(
                        |x| fibonacci_number(*x)
                    ).collect();
                    config.set_item(
                    "NUMBER RESULT", fib_numbers);</pre></li>&#13;
			</ol>&#13;
			<p>Here, what <a id="_idIndexMarker404"/>we have done is create <code>Vec&lt;i32&gt;</code> by running the <code>extract</code> function on the <code>PyList</code> struct. We directly unwrap it so that if there is an error, it will be thrown straight away. We then create <code>Vec&lt;u64&gt;</code>, which houses the calculated Fibonacci numbers, by iterating through the vector with the <code>iter()</code> function. We then map each <code>i32</code> integer of that vector with the <code>map</code> function. Inside the <code>map</code> function, we define a closure that is mapped to each <code>i32</code> integer in the vector. It must be noted that we apply the <code>fibonacci</code> function where we dereference the <code>i32</code> integer being passed in because it is now a borrowed reference. We collect the results of this mapping with the <code>.collect()</code> function, which results in the <code>processed_results</code> variable being a collection of <code>i32</code> calculated Fibonacci numbers. We then add the calculated numbers to the dictionary under the <code>NUMBER RESULT</code> key. We can see the flow of what was just described in the following diagram:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/Figure_6.1_B17720.jpg" alt="" width="1519" height="1258"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 6.1 – Data extraction flow</p>&#13;
			<p>In the <a id="_idIndexMarker405"/>next step, we will carry out a similar process to the one displayed in <em class="italic">Figure 6.1</em> to process the list of lists under the <code>numbers</code> key.</p>&#13;
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Extracting data from our config file</h2>&#13;
			<p>At this <a id="_idIndexMarker406"/>point, it would be a good idea to try to implement the process for the <code>numbers</code> key by yourself. To make things easier, you can use the <code>process_numbers</code> function that we defined earlier in <em class="italic">Step 3</em> of the <em class="italic">Processing data from our Python dictionary</em> section. We will cover the solution to this in the next steps:</p>&#13;
			<ol>&#13;
				<li value="1">The <code>numbers</code> key can be processed by our <code>run_config</code> function with the code defined here:<pre>    match config.get_item("numbers") {
        Some(data) =&gt; {
            match data.downcast::&lt;PyList&gt;() {
                Ok(raw_data) =&gt; {
                    let processed_results_two: \
                      Vec&lt;Vec&lt;i32&gt;&gt; = 
                    raw_data.extract::&lt;Vec&lt;Vec&lt;i32&gt;&gt;&gt;(
                    ).unwrap();
                    config.set_item("NUMBERS RESULT", 
                    process_numbers(processed \
                      _results_two));
                },
                Err(_) =&gt; Err(PyTypeError::new_err(
                "parameter numbers is not a list of \
                   lists of integers")).unwrap()
            }
        },
        None =&gt; println!(
        "parameter numbers is not in the config")
    }
    return Ok(config)</pre><p>Here, we <a id="_idIndexMarker407"/>can see that the <code>process_numbers</code> function actually makes this implementation simpler than the <code>numbers</code> key processing. If the complexity starts to grow, it is always worth breaking down the logic into smaller functions. It also must be noted that we return a result that wraps the config dictionary. Now that we have finished the logic behind processing our dictionary, we need to return our dictionary in the next step.</p></li>&#13;
				<li>Here, we must publicly define our <code>src/interface/config.rs</code> file in the <code>src/interface/mod.rs</code> file by running the following code:<pre>pub mod config;</pre></li>&#13;
				<li>We <a id="_idIndexMarker408"/>then import it into our <code>src/lib.rs</code> file by running the following code:<pre>mod interface;
use interface::config::__pyo3_get_function_run_config;</pre></li>&#13;
				<li>We then add the function to our module in the <code>src/lib.rs</code> file by running the following code:<pre>m.add_wrapped(wrap_pyfunction!(run_config));</pre></li>&#13;
			</ol>&#13;
			<p>We have now carried out all the steps. </p>&#13;
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Returning our Rust dictionary to our Python system</h2>&#13;
			<p>Our <code>pip</code> module can now take in a configuration file, convert it into a Python dictionary, pass <a id="_idIndexMarker409"/>the Python dictionary into the Rust function that calculates the Fibonacci numbers, and return the results in the form of a dictionary back to Python. This can be achieved by carrying out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Define a <code>.yml</code> file to be ingested by our program. An example <code>.yml</code> file that can run what we have just done can be defined via the following code:<pre>number:
  - 4
  - 7
  - 2
numbers:
  -
    - 12
    - 15
    - 20
  -
    - 15
    - 19
    - 18</pre><p>I have saved the preceding .<code>yml</code> code on my desktop for demonstration purposes under the filename <code>example.yml</code>. Remember to update your GitHub repository and uninstall your current module in your Python environment, and install our new module instead.</p></li>&#13;
				<li>We <a id="_idIndexMarker410"/>can then pass in the <code>.yml</code> file into our module entry point with the following command:<pre>config-fib --path example.yml</pre></li>&#13;
				<li>I ran this command from my desktop, where I stored the <code>example.yml</code> file. Running the previous command gives us the following output:<pre>Here is the config data: 
{'number': [4, 7, 2, 10, 15],
 'numbers': [[5, 8, 12, 15, 20], [12, 15, 19, 18, 8]]}
Here is the result:
{'NUMBER RESULT': [3, 13, 1, 55, 610],
 'NUMBERS RESULT': [[5, 21, 144, 610, 6765], 
                    [144, 610, 4181, 2584, 21]],
 'number': [4, 7, 2, 10, 15],
 'numbers': [[5, 8, 12, 15, 20], [12, 15, 19, 18, 8]]}</pre><p>Here, we can see that our Python interface fed the Python dictionary into the Rust interface. We then got the results of the Fibonacci functions passed back in the same dictionary. </p></li>&#13;
				<li>Now, we <a id="_idIndexMarker411"/>introduce a breaking change in our <code>.yml</code> file. We can test our error by changing the <code>number</code> key to a dictionary as opposed to a list of integers in our <code>example.yml</code> file by running the following code:<pre>number:
  one: 1</pre></li>&#13;
				<li>Finally we run our code again, expecting the correct error message. This gives us the following error when running our command again:<pre><code>TypeError</code> exception was raised. This is not trivial. This means that we can try to accept type errors in our Python code when using our Rust module if we need to. Considering this, if a user did not know how our module was built, they would have no problem thinking that our module was built in pure Python. There is one more test that we can consider. We only manually threw an error when we were downcasting to <code>PyList</code>, highlighting that we need to have a list of integers. However, we just unwrapped the <code>extract</code> function being performed on <code>PyList</code>. </p></li>&#13;
				<li>We can see how the <code>extract</code> function handles a string being put in, thereby changing the <code>number</code> key to a list of strings as opposed to a list of integers in our <code>example.yml</code> file, by running the following code:<pre>number:
  - "test"</pre></li>&#13;
				<li>Running our command again gives us the following output:<pre>pyo3_runtime.PanicException: called 'Result:: \
  unwrap()' on an 
'Err' value: PyErr { type: &lt;class 'TypeError'&gt;, 
value: TypeError(
"'str' object cannot be interpreted as an integer"), 
traceback: None }</pre></li>&#13;
			</ol>&#13;
			<p>Here, we <a id="_idIndexMarker412"/>can see that the error string is a little harder to interpret because we did not directly code an error telling the user what we want; however, it is still <code>TypeError</code>. We can also see here that errors raised by functions that are acted on Python objects are Python-friendly. </p>&#13;
			<p>We have now concluded how to interact with complex Python data structures. Nothing is stopping you from building Python <code>pip</code> modules in Rust that fuse seamlessly with a Python program. However, we can take our Rust <code>pip</code> modules to the next level by working with and inspecting custom Python objects in the next section. </p>&#13;
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Inspecting and working with custom Python objects</h1>&#13;
			<p>Technically, everything <a id="_idIndexMarker413"/>in Python is an object. The <a id="_idIndexMarker414"/>Python dictionary that we worked on within the previous section is an object, so we have already managed Python objects. However, as we know, Python enables us to build custom objects. In this section, we will get our Rust function to accept a custom Python class that will have <code>number</code> and <code>numbers</code> attributes. To achieve this, we must carry out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Create <a id="_idIndexMarker415"/>an object that passes itself into <a id="_idIndexMarker416"/>our Rust interface.</li>&#13;
				<li>Acquire <a id="_idIndexMarker417"/>the Python <code>PyDict</code> struct.</li>&#13;
				<li>Add the custom object's attributes to our newly created <code>PyDict</code> struct.</li>&#13;
				<li>Set the attributes of the custom object to the results of our <code>run_config</code> function.</li>&#13;
			</ol>&#13;
			<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Creating an object for our Rust interface</h2>&#13;
			<p>We start <a id="_idIndexMarker418"/>our journey by setting up our interface object, as follows:</p>&#13;
			<ol>&#13;
				<li value="1">We house our object that will pass itself into our Rust code in the <code>flitton_fib_rs/object_interface.py</code> file. Initially, we import what we need by running the following code:<pre>from typing import List, Optional
from .flitton_fib_rs import object_interface</pre></li>&#13;
				<li>We then define the <code>__init__</code> method of our object by running the following code:<pre>class ObjectInterface:
    def __init__(self, number: List[int], \ 
       numbers: List[List[int]]) -&gt; None:
        self.number: List[int] = number
        self.numbers: List[List[int]] = numbers
        self.number_results: Optional[List[int]] = \
          None
        self.numbers_results:Optional[List[List \
          [int]]] = None</pre><p>Here, we can see that we can pass in the Fibonacci numbers that we want to be calculated in the parameters. We then just set our attributes to the parameters that we passed in. The result parameters defined here are of a <code>None</code> value. However, they will be populated by the Rust code when we pass this object into our Rust object interface.</p></li>&#13;
				<li>We <a id="_idIndexMarker419"/>then define a function that will pass our object into the Rust code by running the following code:<pre>    def process(self) -&gt; None:
        object_interface(self)</pre></li>&#13;
			</ol>&#13;
			<p>Here, we can see that this is done by merely passing the <code>self</code> reference into the function. Now that we have defined our object, we can move on to build our interface and interact with the Python GIL. </p>&#13;
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Acquiring the Python GIL in Rust</h2>&#13;
			<p>For our <a id="_idIndexMarker420"/>interface, we will house our function in the <code>src/interface/object.rs</code> file. We'll proceed as follows:</p>&#13;
			<ol>&#13;
				<li value="1">First, we must import all of what we need by running the following code:<pre>use pyo3::prelude::{pyfunction, PyResult, Python};
use pyo3::types::{PyAny, PyDict};
use pyo3::exceptions::PyLookupError;
use super::config::run_config;</pre><p>Most of these imports will be familiar by now. The new import that we must make note of is the <code>Python</code> import. <code>Python</code> is a struct that is essentially a marker that is required for the Python operations that we will be doing.</p></li>&#13;
				<li>Now <a id="_idIndexMarker421"/>that we have imported everything we need, we can build parameters for our interface and create a <code>PyDict</code> struct by running the following code:<pre>#[pyfunction]
pub fn object_interface&lt;'a&gt;(input_object: &amp;'a PyAny) \
    -&gt; PyResult&lt;&amp;'a PyAny&gt; {
    let gil = Python::acquire_gil();
    let py = gil.python();
    let config_dict: &amp;PyDict = PyDict::new(py);</pre></li>&#13;
			</ol>&#13;
			<p>Here, what we have essentially done is acquire the Python GIL, and then use this to create a <code>PyDict</code> struct. To fully understand what we are doing, it is best to explore what the Python GIL is. In <a href="B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Concurrency</em>, we covered the concept of thread blocking. This means that if another thread is executing, then all other threads are locked. The GIL ensures that this happens, as demonstrated in the following diagram: </p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_6.2_B17720.jpg" alt="Figure 6.2 – GIL flow&#13;&#10;" width="987" height="493"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 6.2 – GIL flow</p>&#13;
			<p>This is <a id="_idIndexMarker422"/>because Python does not have any concept of ownership. A Python object can be referenced as many times as we want. We can also mutate the variable from any of those references. When we acquire the <code>gil</code> variable, we ensure that only one thread can use the Python interpreter and the Python <code>gil</code> variable is a <code>GILGuard</code> struct that ensures that we acquire the GIL before we run any operations on Python objects. </p>&#13;
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Adding data to our newly created PyDict struct</h2>&#13;
			<p>Now that <a id="_idIndexMarker424"/>we have control over Python objects with the GIL, we can move on to our next step, where we add the data from the input object to our newly created <code>PyDict</code> struct, as follows:</p>&#13;
			<ol>&#13;
				<li value="1">Our approach in this step can be summarized in the following diagram:<p class="figure-caption"> </p><div><img src="img/Figure_6.3_B17720.jpg" alt="" width="776" height="1013"/></div><p class="figure-caption">Figure 6.3 – PyDict flow</p></li>&#13;
				<li>We can <a id="_idIndexMarker425"/>achieve the first cycle depicted in <em class="italic">Figure 6.3</em> by running the following code:<pre>    match input_object.getattr("number") {
        Ok(data) =&gt; {
            config_dict.set_item("number", data) \
              .unwrap();
        },
        Err(_) =&gt; Err(PyLookupError::new_err(
            "attribute number is missing")).unwrap()
    }</pre><p>Here, we can see that we match the <code>getattr</code> function, throwing an error if <code>input_object</code> does not have the <code>number</code> attribute. If we do have the attribute, we assign it to <code>config_dict</code>. </p></li>&#13;
				<li>We can do the second cycle by running the following code:<pre>    match input_object.getattr("numbers") {
        Ok(data) =&gt; {
            config_dict.set_item("numbers", data) \
              .unwrap();
        }
        Err(_) =&gt; Err(PyLookupError::new_err(
            "attribute numbers is missing")).unwrap()
    }</pre></li>&#13;
				<li>It must <a id="_idIndexMarker426"/>be noted that there is a fair amount of repetition, with only one change. We could refactor this into a single function with an <code>attribute</code> parameter by running the following code:<pre>fn extract_data&lt;'a&gt;(input_object: &amp;'a PyAny, \
    attribute: &amp;'a str, config_dict: &amp;'a PyDict) \
      -&gt; &amp;'a PyDict {
    match input_object.getattr(attribute) {
        Ok(data) =&gt; {
            config_dict.set_item(attribute, \
              data).unwrap();
        },
        Err(_) =&gt; Err(PyLookupError::new_err(
            "attribute number is missing")).unwrap()
    }
    return config_dict
}</pre></li>&#13;
				<li>Here, we can see that we get a lot of flexibility with our Python objects. This function can be used multiple times with the refactored code in our <code>object_interface</code> function, as seen here:<pre>    let mut config_dict: &amp;PyDict = PyDict::new(py);
    config_dict = extract_data(input_object, \
      "number", config_dict);
    config_dict = extract_data(input_object, 
      "numbers", config_dict);</pre></li>&#13;
			</ol>&#13;
			<p>Here, we can <a id="_idIndexMarker427"/>see that we have changed <code>config_dict</code> to a mutable. Now that we have loaded our <code>PyDict</code> struct with all the data that we need, all we must do is run our <code>run_config</code> function, add it to the input object's attributes, and return it to the Python interface in the next step. </p>&#13;
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Setting the attributes of our custom object</h2>&#13;
			<p>We are <a id="_idIndexMarker428"/>now in the final stage of our interface module. Here are the steps:</p>&#13;
			<ol>&#13;
				<li value="1">We can pass the output from our <code>run_config</code> function to our Python object interface by running the following code:<pre>    let output_dict: &amp;PyDict = run_config( \
      config_dict).unwrap();
    input_object.setattr(
        "number_results", 
        output_dict.get_item(
            "NUMBER RESULT").unwrap()).unwrap();
    input_object.setattr(
        "numbers_results", 
        output_dict.get_item(
            "NUMBERS RESULT").unwrap()).unwrap();
    return Ok(input_object)</pre><p>Here, we can see that we get the <code>output_dict</code> Python dictionary from the <code>run_config</code> function. Once we have got this, we set the <code>input_object</code> attribute based on the items from <code>output_dict</code>. </p></li>&#13;
				<li>We have <a id="_idIndexMarker429"/>now completed our interface and we must subsequently plug it into our Rust module. We publicly define our interface file in the <code>src/interface/mod.rs</code> file by running the following code:<pre>pub mod object;</pre></li>&#13;
				<li>We can then define our interface function in our Rust module by importing it into our <code>src/lib.rs</code> file, as follows:<pre>use interface::object::__pyo3_get_function_object_ \
  interface;</pre></li>&#13;
				<li>We then add our function to our module, as follows: <pre>    m.add_wrapped(wrap_pyfunction!(object_interface));</pre></li>&#13;
				<li>Our module is now fully functioning. As always, we must remember to update our GitHub repository, uninstall our old module in our Python environment, and reinstall it. Once this is done, we can test it by running a Python shell. In our shell, we can test our object by running the following code:<pre>&gt;&gt;&gt; from flitton_fib_rs.object_interface import 
ObjectInterface
&gt;&gt;&gt; test = ObjectInterface([5, 6, 7, 8], [])
&gt;&gt;&gt; test.process()
&gt;&gt;&gt; test.number_results
[5, 8, 13, 21]</pre></li>&#13;
			</ol>&#13;
			<p>Here, we can see that we import the object that we are going to use. We then initialize it and run the <code>process</code> function. Once this is done, we can see that our Rust code accepted our object and interacted with it as we have the correct results for our <code>number_results</code> attribute. </p>&#13;
			<p>Now we can interact with Python custom objects, the problems we can solve and how we can <a id="_idIndexMarker430"/>interact with the Python system are powerful. Custom Python objects do not hold us back. However, it is important not to get too carried away with Python objects in our Rust code. While we should use them in our interface, we shouldn't have to rely on them to build the whole program. In this section, we did do this, as we were leaning on a function that we built in the previous section to avoid excessive code, to get a point across. However, in your projects, Python objects should leave your code after the interface. If you find yourself using Python objects in your Rust code throughout, then you must ask yourself why you are not just using pure Python. Coding in Python will be slower than coding in Rust, but the metaclass, dynamic attributes, and many other Python features will make coding in Python easier and more enjoyable than trying to force a Python style of coding into Rust. Rust offers structs, traits, enums, and strong typing with lifetimes that get cut after moving out of scope to keep resources low. </p>&#13;
			<p>So, lean into this style of coding to fully reap the benefits of building <code>pip</code> modules in Rust. Push past your comfort zone of the Python coding style. The next section is about building Python objects in Rust code. </p>&#13;
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Constructing our own custom Python objects in Rust</h1>&#13;
			<p>In this <a id="_idIndexMarker431"/>final section, we will build a Python <a id="_idIndexMarker432"/>module in Rust that can be interacted with in the Python system as if it were a native Python object. To do this, we must follow these steps:</p>&#13;
			<ol>&#13;
				<li value="1">Define a Python class with all our attributes.</li>&#13;
				<li>Define class static methods to process numbers.</li>&#13;
				<li>Define a class constructor.</li>&#13;
			</ol>&#13;
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Defining a Python class with the required attributes</h2>&#13;
			<p>To start <a id="_idIndexMarker433"/>our journey, we define our class in the <code>src/class_module/fib_processor.rs</code> file, as follows: </p>&#13;
			<ol>&#13;
				<li value="1">To build our class, we need to import the required macros by running the following code:<pre>use pyo3::prelude::{pyclass, pymethods, staticmethod};
use crate::fib_calcs::fib_number::fibonacci_number;
use crate::fib_calcs::fib_numbers::fibonacci_numbers;</pre><p>Here, we are using the <code>pyclass</code> macro to define our Rust Python class. We then use <code>pymethods</code> and <code>staticmethod</code> to define methods attached to the class. We also use standard Fibonacci numbers to calculate the Fibonacci numbers. </p></li>&#13;
				<li>Now that we have imported everything we need, we can define the class and the attributes, as follows:<pre>#[pyclass]
pub struct FibProcessor {
    #[pyo3(get, set)]
    pub number: Vec&lt;i32&gt;,
    #[pyo3(get, set)]
    pub numbers: Vec&lt;Vec&lt;i32&gt;&gt;,
    #[pyo3(get)]
    pub number_results: Vec&lt;u64&gt;,
    #[pyo3(get)]
    pub numbers_results: Vec&lt;Vec&lt;u64&gt;&gt;
}</pre></li>&#13;
			</ol>&#13;
			<p>Here, we can see that we use Rust typing for our attributes. We also use a macro to state <a id="_idIndexMarker434"/>what we can do with these attributes. For our <code>number</code> and <code>numbers</code> attributes, we can get and set data belonging to these attributes. However, with our <code>results</code> attributes, we can only get data as this is set by the calculations. </p>&#13;
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Defining class static methods to process input numbers </h2>&#13;
			<p>We can now use our attributes to implement class methods. </p>&#13;
			<p>Just <a id="_idIndexMarker435"/>as with standard structs, we can implement methods attached to the class with an <code>impl</code> block, as seen in the following code snippet:</p>&#13;
			<pre>#[pymethods]</pre>&#13;
			<pre>impl FibProcessor {</pre>&#13;
			<pre>    #[staticmethod]</pre>&#13;
			<pre>    fn process_numbers(input_numbers: Vec&lt;Vec&lt;i32&gt;&gt;) \</pre>&#13;
			<pre>      -&gt; Vec&lt;Vec&lt;u64&gt;&gt; {</pre>&#13;
			<pre>        let mut buffer: Vec&lt;Vec&lt;u64&gt;&gt; = Vec::new();</pre>&#13;
			<pre>        for i in input_numbers {</pre>&#13;
			<pre>            buffer.push(fibonacci_numbers(i));</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        return buffer</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we can see that we have applied the <code>pymethods</code> macro to our <code>impl</code> block. We also <a id="_idIndexMarker436"/>apply the <code>staticmethod</code> macro to our <code>process_numbers</code> static method. This function was used before, in the previous section, to process lists of lists. Now that our static method is defined, we can use this in our constructor method in the next step. </p>&#13;
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Defining a class constructor</h2>&#13;
			<p>Here are <a id="_idIndexMarker437"/>the steps we need to take:</p>&#13;
			<ol>&#13;
				<li value="1">We can define our constructor method in our <code>impl</code> block by running the following code:<pre>    #[new]
    fn new(number: Vec&lt;i32&gt;, numbers: Vec&lt;Vec&lt;i32&gt;&gt;) \
      -&gt; Self {
        let input_numbers: Vec&lt;Vec&lt;i32&gt;&gt; = \
          numbers.clone();
        let input_number: Vec&lt;i32&gt; = number.clone();
        let number_results: Vec&lt;u64&gt; = 
          input_number.iter(
                             ).map(
            |x| fibonacci_number(*x)
        ).collect();
        let numbers_results: Vec&lt;Vec&lt;u64&gt;&gt; = Self::
                 process_numbers(input_numbers);
        return FibProcessor {number, numbers, 
                 number_results, numbers_results}
    }</pre><p>Here, we accept inputs for the calculations of the Fibonacci numbers. We then clone them because we are going to pass them through the Fibonacci number functions. Once this is done, we apply the <code>fibonacci_number</code> function by mapping the input and collecting the results. We also collect the results from our static method. Once all the data is calculated, we construct the class and return it. Once this is done, all we must do is connect our class to our module. </p></li>&#13;
				<li>This can <a id="_idIndexMarker438"/>be done by publicly declaring our class file in the <code>src/class_module/mod.rs</code> file, as follows:<pre>pub mod fib_processor;</pre></li>&#13;
				<li>Now that this is done, we import it into our <code>src/lib.rs</code> file by running the following code:<pre>mod class_module;
use class_module::fib_processor::FibProcessor;</pre></li>&#13;
				<li>Once this is done, we can add our class to our module in the same file, as follows:<pre>m.add_class::&lt;FibProcessor&gt;()?;</pre></li>&#13;
			</ol>&#13;
			<p>We have now fully integrated our class into the <code>pip</code> module. </p>&#13;
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Wrapping up and testing our module</h2>&#13;
			<p>As always, when <a id="_idIndexMarker439"/>we get to the end of a section, we <a id="_idIndexMarker440"/>must remember to do the following:</p>&#13;
			<ul>&#13;
				<li> Update the GitHub repository.</li>&#13;
				<li> Uninstall the current <code>pip</code> module.</li>&#13;
				<li> Reinstall it in our Python environment.</li>&#13;
			</ul>&#13;
			<p>Now that we have finished building our module and updated the installed version, we can manually test our module in the Python system by following these next steps:</p>&#13;
			<ol>&#13;
				<li value="1">We can open our Python shell and test our class by running the following code:<pre>&gt;&gt;&gt; from flitton_fib_rs.flitton_fib_rs import 
FibProcessor
&gt;&gt;&gt; test = FibProcessor([11, 12, 13, 14], [[11, 12], 
                        [13, 14], [15, 16]])
&gt;&gt;&gt; test.numbers_results
[[89, 144], [233, 377], [610, 987]]</pre></li>&#13;
				<li>We can <a id="_idIndexMarker441"/>see that our Rust object <a id="_idIndexMarker442"/>works seamlessly in our Python system with calculated results. We must remember that we have set rules around our attributes. To check this, we can try to assign our <code>results</code> attribute, which will give us the following output:<pre><strong class="bold">&gt;&gt;&gt; test.numbers_results = "test"</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong class="bold">AttributeError: attribute 'numbers_results' of </strong>
<strong class="bold">'builtins.FibProcessor' objects is not writable</strong></pre></li>&#13;
				<li>Here, we can see that our <code>results</code> attribute is not writable. We can also test typing. Although our <code>number</code> attribute is writable, it is supposed to be a vector of integers. If we try to assign a string to this attribute, we get the following printout:<pre><strong class="bold">&gt;&gt;&gt; test.number = "test"</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong class="bold">TypeError: 'str' object cannot be interpreted as an </strong>
<strong class="bold">integer</strong></pre></li>&#13;
				<li>Here, we can see that our typing is also enforced, even though it looks and acts like a <a id="_idIndexMarker443"/>native Python object. Finally, we <a id="_idIndexMarker444"/>can test to see if we can write a new value to the <code>number</code> attribute by running the following code:<pre>&gt;&gt;&gt; test.number = [1, 2, 3, 4, 5]
&gt;&gt;&gt; test.number
[1, 2, 3, 4, 5]</pre><p>It seems that we can write when the type and permissions are correct. Considering all of this, what is the point of creating these classes? They make the interface for our module smoother, but how much faster is this class? </p></li>&#13;
			</ol>&#13;
			<p>To quantify this, we can create a simple testing Python script in our Python environment, as follows:</p>&#13;
			<ol>&#13;
				<li value="1">First, in our Python script, we import our Rust class and the <code>time</code> module by running the following code:<pre>from flitton_fib_rs.flitton_fib_rs import FibProcessor
import time</pre></li>&#13;
				<li>We must now create a pure Python object with the same functionality in this script, as follows: <pre>class PythonFibProcessor:
     def __init__(self, number, numbers):
           self.number = number
           self.numbers = numbers
           self.numbers_results = None
           self.number_results = None
           self._process()
     def _process(self):
           self.numbers_results = \
             [self.calculate_numbers(i)\ 
               for i in self.numbers]
           self.number_results = \
             self.calculate_numbers(
               self.number)
     def fibonacci_number(self, number):
         if number &lt; 0:
             return None
         elif number &lt;= 2:
             return 1
         else:
          return self.fibonacci_number(number - 1) + \
                    self.fibonacci_number(number - 2)
     def calculate_numbers(self, numbers):
          return [self.fibonacci_number(i) for i in \
            numbers]</pre></li>&#13;
				<li>Now that our benchmark pure Python object is defined, we are now at the timing stage <a id="_idIndexMarker445"/>of the script, where we <a id="_idIndexMarker446"/>put the same inputs into both classes and test them with the following code:<pre>t_one = time.time()
test = FibProcessor([11, 12, 13, 14], [[11, 12], \
    [13, 14], [15, 16]])
t_two = time.time()
print(t_two - t_one)
t_one = time.time()
test = PythonFibProcessor([11, 12, 13, 14], \
  [[11, 12], [13, 14], [15, 16]])
t_two = time.time()
print(t_two - t_one)</pre></li>&#13;
				<li>Running this gives us the following output:<pre><strong class="bold">1.4781951904296875e-05</strong>
<strong class="bold">0.0007779598236083984</strong></pre><p>This translates to the following:</p><pre>0.000017881393432617188
0.0007779598236083984</pre></li>&#13;
			</ol>&#13;
			<p>Remember, the Rust class is the top reading. This means that our Rust class is <em class="italic">43 times faster than our Python class!</em> To put this into perspective, we can see the difference in the following screenshot:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_6.4_B17720.jpg" alt="Figure 6.4 – Class speed difference between Rust and Python&#13;&#10;" width="1650" height="649"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 6.4 – Class speed difference between Rust and Python</p>&#13;
			<p>Here, we can <a id="_idIndexMarker447"/>see that our class interfaces <a id="_idIndexMarker448"/>built in Rust are faster than our Python classes. <code>pyo3</code> supports class inheritance and other features. More resources on this are supplied in the <em class="italic">Further reading</em> section. We now have a strong base when it comes to working with Python objects in Rust. There are always more features to read up on, and these can be built on top of the structures that we have built.</p>&#13;
			<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Summary</h1>&#13;
			<p>In this chapter, we added a third-party <code>pip</code> module into our <code>setup.py</code> file so that we could add another entry point that could read .<code>yml</code> files. We read the .<code>yml</code> file and passed the data from that file in the form of a dictionary into our Rust functions, handling the complex data structure under the <code>PyDict</code> struct. We then downcasted data from our complex data structure into other Python objects and Rust data types. This gave us the power to handle a range of Python data types passed into our Rust code, giving us extra flexibility in how our Python code interacts with our Rust code. </p>&#13;
			<p>We went one step further than complex Python data structures by accepting custom Python objects under the <code>PyAny</code> struct. Once we accepted custom Python objects, we could inspect attributes and set them as and when we wanted to. We even acquired the Python GIL to create our own Python data structures to help us work with the custom Python objects passed into our Rust code. To polish off our Python object skills, we built Python classes within our Rust code that not only can be imported into the Python system, acting just like a pure Python class, but are also 44 times faster. We now have a powerful tool that will not only speed up our Python code but will also enable us to interact with Python systems seamlessly. </p>&#13;
			<p>In the next chapter, we tackle the final hurdle that is stopping us from infusing Rust into every Python project we have. People reach for Python due to the extensive third-party modules that are built for it, such as statistical and <code>numpy</code> module and use it in our Rust code. This will enable us to utilize third-party Python modules in our Rust extension.  </p>&#13;
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">How do you extract a vector of <code>i32</code> integers from a <code>PyDict</code> struct?</li>&#13;
				<li>If we have a vector of strings but we apply a <code>.extract::&lt;Vec&lt;i32&gt;&gt;()</code>  function on it and we directly unwrap it, what will happen?</li>&#13;
				<li>How would you be able to loop through a <code>Vec&lt;i32&gt;</code> vector, doubling each item and packaging the results in another vector in one line of Rust code?</li>&#13;
				<li>If we acquire the Python GIL to create a <code>PyDict</code> struct, will this affect the Python system in any way? </li>&#13;
				<li>Although our Python classes built in our Rust code essentially run the same way as our pure Python classes, there are some core differences. What are they?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/>Answers</h1>&#13;
			<ol>&#13;
				<li value="1">First, we must get a list from the <code>PyDict</code> struct by applying the <code>get_item</code> function to <code>PyDict</code>. If there is data under the key that we use, we then perform <code>.downcast::&lt;PyList&gt;()</code> to convert our data into a <code>PyList</code> struct. If we achieve this, we then perform <code>.extract::&lt;Vec&lt;i32&gt;&gt;()</code> on the <code>PyList</code> struct, giving us a <code>Vec&lt;i32&gt;</code>.</li>&#13;
				<li>Our <code>extract</code> function will automatically throw a <code>PyTypeError</code> Python-friendly error.</li>&#13;
				<li>With this, we use the <code>iter</code>, <code>map</code>, and <code>collect</code> functions, as follows:<pre>let results: Vec&lt;i32&gt; = some_vector.iter().map(
            |x| 2*x
        ).collect();</pre></li>&#13;
				<li>No—the Python system that is running the code has already acquired the GIL. If it does not have the GIL, it would just wait for another thread to finish before acquiring the GIL.</li>&#13;
				<li>The typing system is still enforced. If we try to set an attribute that is a list of integers to a string, an error will be thrown. Another difference is that <code>set</code> and <code>get</code> macros for each attribute must be defined. If they are not, then the attribute cannot be accessed or set. </li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Further reading</h1>&#13;
			<ul>&#13;
				<li><em class="italic">PyO3</em> (2021). <em class="italic">PyO3 user guide</em>—<em class="italic">Python Classes</em> <a href="https://pyo3.rs/v0.13.2/class.html">https://pyo3.rs/v0.13.2/class.html</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>