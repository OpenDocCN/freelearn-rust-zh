- en: Interacting with Databases in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll discuss on why databases are essential to modern applications.
    We'll cover a few crates that are available in the Rust ecosystem, which allows
    one to interact with databases. We'll then continue with our linksnap API server
    that we developed in the previous chapter and integrate database support into
    it through a convenient library. This will allow us to persist new bookmarks that
    are sent to our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite integration using `rusqlite`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with PostgreSQL with Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database connection pooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-relational mapping using the `diesel` crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating diesel with the linksnap API server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need data persistence?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Sometimes, elegant implementation is just a function. Not a method. Not a
    class. Not a framework. Just a function."                                     
                                                                                 
                                                                                 
                           - John Carmack'
  prefs: []
  type: TYPE_NORMAL
- en: Modern applications these days are data-heavy. Data is the new oil, as many
    say. Database-backed services are everywhere, from social gaming to cloud storage,
    to e-commerce, to healthcare, and so on. All of these services need to store and
    retrieve data correctly. The data that they store, must be easy to retrieve and
    must have guarantees regarding consistency and durability.
  prefs: []
  type: TYPE_NORMAL
- en: Databases are the go-to solution for providing a robust foundation for building
    applications that are data-backed and that support the expectations of their users.
    Before we build anything involving databases with Rust, we need to get an idea
    of the basics. A database, in general, is a collection of tables. Tables are units
    of data organization.
  prefs: []
  type: TYPE_NORMAL
- en: Data that's been organized into tables is only applicable to relational databases.
    Other databases, such as NoSQL and graph-based databases, use a more flexible
    document model to store and organize data.
  prefs: []
  type: TYPE_NORMAL
- en: Data is organized into logical bodies called tables. Tables are usually representations
    of entities from the real world. These entities can have various attributes that
    take the place of columns in these tables. These entities can also have relations
    with other entities. A column in one table can refer to another column. Changes
    to any database is performed using a specific DSL called **Structured Query Language
    (SQL)**. SQL queries also allow you to spread a query across multiple tables using
    query clauses such as JOIN. Those are the basics. A common pattern with a user
    interacting with database-backed applications is the **CRUD** pattern, which is
    short for **Create, Read, Update, and Delete**. These are the usual operations
    a user performs most of the time on a database through the application.
  prefs: []
  type: TYPE_NORMAL
- en: SQL is a declarative way to perform transactions on a database. A transaction
    is a group of modifications to a database that must happen atomically or not at
    all in case there are any failures midway. The naive way to write a database transaction
    in any application is through a raw SQL query. However, there's a better way to
    do this, and it's called **Object Relational Mapping (ORM)**. This is a technique
    that's used to access a database using native language abstractions and types
    that map almost one to one with the SQL syntax and semantics. Languages provide
    higher-level libraries for speaking SQL, which allow you to write queries in their
    native language, which is then translated into a raw SQL query. In traditional
    object-oriented languages, your objects become SQL-speaking objects. These libraries
    are called object-relational mappers. Many of these libraries exist in mainstream
    languages such as Hibernate for Java, Active Record for Ruby, SQLAlchemy for Python,
    and so on. Using ORMs reduces the possibility of any errors occurring when you're
    using raw SQL queries. However, ORMs also suffer from not being able to map themselves
    completely to the language's object model with the database model. As such, ORM
    libraries should try to limit the amount of abstraction they provide for interacting
    with a database and leave some of the parts to raw SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust ecosystem provides quite a few high-quality solutions to manage and
    build persistent applications. We'll look at a couple of them in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is a very lightweight embedded database. It does not require a special
    database management system for you to be able to use it. Databases created by
    SQLite are represented as files or as in memory database, and you don't need to
    connect to an external remote endpoint or a local socket connection to use a database.
    It serves a different target audience than traditional client-server database
    engines such as MySQL or PostgreSQL, and is the go-to solution for use cases where
    an application needs to store data locally but in a secure and efficiently retrievable
    manner. The Android platform is a heavy user of SQLite and allows mobile applications
    to store preferences or configurations for users within an application. It is
    also used by many desktop applications that need to store any kind of state with
    durability guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust community provides us with a couple of options for connecting to and
    interacting with a SQLite database. We'll go with the `rusqlite` crate, which
    is available on `crates.io` at [https://crates.io/crates/rusqlite](https://crates.io/crates/rusqlite).
    This crate supports SQLite version 3.6.8 and above. Its API cannot be considered
    an ORM, but can be considered a mid-level abstraction of what an ORM provides,
    as it helpfully hides many of the details of the actual SQLite API. In contrast
    to many other relational database systems, SQLite's type system is dynamic. This
    means that columns do not have types, but each individual value does. Technically,
    SQLite separates storage classes from data types, but this is mainly an implementation
    detail, and we can just think in terms of types without being too far from the
    truth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rusqlite` crate provides the `FromSql` and `ToSql` traits for converting
    objects between SQLite and Rust types. It also provides the following implementations
    out of the box for most standard library types and primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | **SQLite** | **Rust** |'
  prefs: []
  type: TYPE_TB
- en: '| The null value | `NULL` | `rusqlite::types::Null` |'
  prefs: []
  type: TYPE_TB
- en: '| 1, 2, 3, 4, 6, or 8-byte signed integers | `INTEGER` | `i32` (with possible
    truncation) and `i64` |'
  prefs: []
  type: TYPE_TB
- en: '| 8-byte IEEE floats | `REAL` | `f64` |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-8, UTF-16BE or UTF-16LE strings | `TEXT` | `String` and `&str` |'
  prefs: []
  type: TYPE_TB
- en: '| Bytestrings | `BLOB` | `Vec<u8>` and `&[u8]` |'
  prefs: []
  type: TYPE_TB
- en: With the basics of the `rusqlite` crate covered, let's see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a new project by running `cargo new rusqlite_demo`. Our program
    takes a properly formatted **Comma Separated Values** (**CSV**) list of book data
    from the standard input, stores it in SQLite, and then retrieves a subset of the
    data using a filter SQL query. First, let''s create our table creation and deletion
    QueryNStrings and our `Book` struct, which will store the data retrieved from
    the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two constants, `CREATE_TABLE` and `DROP_TABLE`, defined, which contain
    raw SQL queries for creating a `books` table and deleting it, respectively. We
    then have the book struct, which contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This acts as the primary key and can be used to distinguish books from
    one another when inserting a book into our books table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: The title of the book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author`: The author of the book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`year`: The year of publication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s look at our `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we open our connection to our SQLite database by calling `Connection::open`
    and providing a path, `"./books"`, to create the database in the current directory.
    Next, we call `init_database()`, passing a reference to `conn`, which is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We then call the `insert` method, passing our `conn`. Finally, we call the `query`
    method, which queries our `books` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our `insert` function method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In `insert`, we first get a lock on `stdout` and iterate over the lines. Each
    line is split with commas. Following that, we call `execute` on `conn`, passing
    in an insert query string. In the query string, we use the template variables
    `?1`, `?2`, and so on, whose corresponding values are taken from the `elems` vector.
    If the number of elements collected is up to `4`, we insert the book using the
    raw SQL query and provide the corresponding values from the `elems` `Vec` for
    template variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, our `query` function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The query function takes in `conn`, on which we call `prepare`, passing in
    the raw SQL query string. Here, we''re filtering books that are greater than a
    given year. We store this query in `stmt`. Next, we call `query_map` on this type,
    passing in a reference to an array that contains just the number `2013`, which
    represents the year we want to filter the books against. As you can see, the API
    is a bit uneasy here. The second argument to `query_map` is a closure that is
    a `Row` type. Within the closure, we extract the respective fields from the `row`
    instance and construct a `Book` instance out of it. This returns an iterator,
    which we store in `movie_iter`. Finally, we iterate over our `movie_iter`, filtering
    any failed values using the `extract_ok` helper method. This is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we print the books. The full code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a books.csv file in the same directory. We can run it by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of the program upon running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9605d0c0-ab0d-4296-b8fe-93a031b7a0f0.png)'
  prefs: []
  type: TYPE_IMG
- en: This is nowhere near a representative real-world database-backed application
    and is just for demonstrating the usage of the library. A real-world application
    wouldn't be reading from the standard input and the querying routines would have
    better error handling.
  prefs: []
  type: TYPE_NORMAL
- en: This was a brief demonstration of how to use a SQLite database with Rust by
    using the `rusqlite` crate. The API is not very strongly typed, but currently
    it's the only solution we've got. Next, we'll look at one of the big brothers
    of SQLite, which is the PostgreSQL database management system.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While SQLite is fine for prototyping and simpler use cases, a real relational
    database management system can make the life of a developer much easier. One such
    sophisticated database system is PostgreSQL. To integrate postgres in Rust, we
    have the `postgres` crate on *crates.io*. It's a native Rust client, meaning that
    it does not ride on a C library but implements the whole protocol in Rust. If
    the API looks familiar to the `rusqlite` crate, this is deliberate; the SQLite
    client's API is actually based on the postgres client.The `postgres` crate supports
    some of PostgreSQL's unique features, such as bit vectors, time fields, JSON support,
    and UUIDs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll explore interacting with postgres by creating a sample
    program that initializes the postgres database and does a few inserts and queries
    on the database. We assume that you have already set up the database on your system.
    The PostgreSQL version used for the example is 9.5.
  prefs: []
  type: TYPE_NORMAL
- en: To install the PostgreSQL database system, the following DigitalOcean article
    is recommended: [https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-16-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-16-04).
  prefs: []
  type: TYPE_NORMAL
- en: 'Postgres comes with its command line tool called `psql` which can be used to
    run queries, examine tables, manage roles, view system information and much more.
    You can view the postgres version running on your system by running the following
    commands inside the psql prompt. First we''ll launch `psql` by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are within the psql, we run the following command at the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the command above, gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this example simpler, we''ll reuse the same books data that we used
    in our `rusqlite` demo. We''ll use the default `"postgres"` user in the following
    examples, with the password as `"postgres"`. You''ll need to adapt the following
    examples to match your new user. Let''s fire up a new project by running `cargo
    new postgres_demo`. Here''s our dependencies in `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run through the code in `main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a bunch of string constants for connecting to the database and creating
    and deleting the books table. Next is our function `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we are not using an ORM here, and just a low-level interface, we''ll
    need to unpack the values into the database query manually. Let''s run this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21ff948c-f012-4cce-83bb-1f2f8a075cd5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s an output of the program, along with a `psql` query of the table to
    show the contents afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbef2889-a031-4572-a8e0-efeae1da3fd9.png)'
  prefs: []
  type: TYPE_IMG
- en: First, we list our database with the `\dt` command at the `psql` prompt. Following
    that, we use the query, that is, `"select * from books"`.
  prefs: []
  type: TYPE_NORMAL
- en: That's the basics o interacting with PostgreSQL with Rust. Next, let's explore
    how we can make our database queries efficient by using the concept of connection
    pooling.
  prefs: []
  type: TYPE_NORMAL
- en: Connection pooling with r2d2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Opening and closing a database connection every time new transactions take place
    becomes a bottleneck really quickly. Typically, opening a database connection
    is an expensive operation. This is mostly because of the associated TCP handshake
    that's required to create socket connections on both sides. The overhead is even
    more expensive if the database is hosted on a remote server, which is usually
    the case. If we could reuse the connection for every subsequent request that gets
    sent to our database, we might reduce the latency a great deal. An efficient way
    to mitigate this overhead is to employ database connection pooling. When a process
    needs a new connection, it is given an existing connection from the pool of connections.
    When the process has completed the required operation with the database, this
    connection handle goes back to the pool to be used later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, we have the `r2d2` crate, which leverages traits to provide a generic
    way of maintaining connection pools for various databases. It provides various
    backends as sub-crates, and supports PostgreSQL, Redis, MySQL, MongoDB, SQLite,
    and a few other known database systems. The architecture of `r2d2` consists of
    two parts: a generic part and a backend-specific part. The backend code attaches
    to the generic part by implementing r2d2''s `ManageConnection` trait and by adding
    a connection manager for the specific backend. The trait is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the trait definition, we need to specify a `Connection` type, which
    must be `Send` and `'static`, and an `Error` type. We also have three methods: `connect`,
    `is_valid`, and `has_broken`. The `connect` method returns the `Connection` type
    that comes from the underlying backend crate; for instance, it would be the `postgres::Connection`
    type for the postgres backend. The `Error` type is an enum that specifies all
    the possible `Error` cases that may happen during either the connection phase
    or while checking the validity of the connection.
  prefs: []
  type: TYPE_NORMAL
- en: For demonstration purposes, we'll look at how we can use the `r2d2` crate here
    by first checking out how to connect to PostgreSQL using a pool. We'll take the
    code from the previous section and modify it to use a connection pool, where we
    make SQL queries from `8` threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the full code of a pooled and threaded implementation using `r2d2-postgres`
    backend crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code is fairly straight forward from the last example, except that we now
    spawn 8 threads to do a select query on our database. The pool size is configured
    to a value of `8`, which means that the `SELECT` query threads get to do 8 queries
    concurrently by reusing the connections for any further requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now up until this point, we have been mostly using raw SQL queries for interacting
    with databases from Rust. But, there's a more convenient strongly typed approach
    to interacting with databases through an ORM library called diesel. Let's explore
    that next.
  prefs: []
  type: TYPE_NORMAL
- en: Postgres and the diesel ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a complex application using low-level database libraries with raw SQL
    queries is a recipe for a lot of mistakes. Diesel is an ORM (Object Relational
    Mapper) and a query builder for Rust. It makes heavy use of procedural macros.
    It detects most database interaction errors at compile time and is able to produce
    very efficient code in most cases, sometimes even beating low-level access with
    C. This is due to its ability to move checks that are typically made at runtime
    to compile time. At the time of writing, diesel supports PostgreSQL, MySQL, and
    SQLite out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be integrating database support to the linksnap server that we developed
    in [Chapter 13](ea972b20-1dc0-46d2-a0b8-d4186b0fe2c7.xhtml), *Building Web Applications
    with Rust*. We're going to use diesel to communicate with our postgres database
    in a type-safe manner. We'll copy the `linksnap` project from [Chapter 13](80838e60-3afc-4e3b-8ad4-493d7f9381af.xhtml),
    *Building Web Applications with Rust*, and rename it `linksnap_v2`. We won't be
    going over the full source code walk-through—only the parts that affect the integration
    of the database with diesel. The rest of the code base is exactly the same as
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The diesel project is built of many components. First, we have a command line
    tool called `diesel-cli` that automates the process of creation of database and
    performing any migration to the database if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we start implementing routines for talking to our database, we
    need to install the `diesel-cli` tool, which will set up our database and the
    tables inside it. We can install it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are only using the postgres feature from this CLI tool and so the `--features`
    flag. `Cargo` will fetch and build `diesel_cli` and its dependencies, and install
    the binary to Cargo's default binary location for your user, which is usually
    `~/.cargo/bin/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our `linksnap_v2` directory, we''ll then add the connection URL to our
    database in a `.env` file that''s located in the directory root with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our database in postgres is named `linksnap`, and both the username and password
    is `postgres`. This is in no way a secure way to access our database and it's
    recommended that you use the best security practices to set up your postgres database
    in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need to add `diesel` as a dependency in our `Cargo.toml` file,
    along with the `dotenv` library. The `dotenv` crate handles local configuration
    via *dotfiles*. Here''s our `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the features on the diesel crate where we use `"postgres"` and `"r2d2"`.
    Next, we''ll run `diesel setup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a diesel.toml file at the root directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Diesel uses macros quite heavily to give us great features, such as extra safety
    and performance at compile time. To be able to do this, it needs compile-time
    access to the database. This is why the `.env` file is important. The `diesel
    setup` command automatically generates model types by reading the database and
    writing it to a file called `schema.rs`. The models are generally split into query
    and insert structs. Both use derive macros to generate model code for different
    use cases. In addition to this, a diesel-based application needs code to connect
    to the database and a set of database migrations to build up and maintain the
    database tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a migration that creates our table by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates a new migration with two empty `up.sql` and `down.sql`
    migration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The migration files are just plain SQL, so we can just put in our earlier `CREATE
    TABLE` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `down.sql` file should contain a corresponding `DROP TABLE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we do that, we have to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a `schema.rs` file by reading from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `table!` macro generates code for the `linksnap` table with `id` as the
    primary key. It also specifies the column names with `id`, `title`, `url` and
    `added`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write a model for this table. In diesel, models can live in any
    visible module, but we''ll go with the convention of putting them in `src/models.rs`.
    Here''s its contents for our `Link` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have created a `Link` struct that can be used to query the database. It also
    has various methods that are invoked when we our server receives requests on the
    respective endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `state.rs` file contains diesel and postgres specific code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First we create a bunch of convenient aliases for our PostgreSQL connection
    pool. We have the same `Db` struct that wraps a PgPool type. The PgPool type is
    a `ConnectionManager` from the `r2d2` module in diesel. On the `Db` struct, we
    also define the `get_conn` method, which returns a reference to a pooled connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing down the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have the familiar State type, but the init method is different here. It first
    creates accesses the `DATABASE_URL` environment variable and tries to make a pooled
    connection using the `database_url` in `pool`.  We then start a `SyncArbiter`
    thread cloning the `pool`. Finally we return back the `state` instance to the
    caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from that, we don''t need to change much of our linksnap code base from
    the previous version. Let''s take our new server for a spin. We''ll insert a Link
    to our server using curl as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to confirm that this link made it to our postgres database, let''s query
    for this entry from the psql prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1acba38a-6390-427f-856b-61382f6c1174.png)'
  prefs: []
  type: TYPE_IMG
- en: Great ! our curl request made it to the postgres database.
  prefs: []
  type: TYPE_NORMAL
- en: Diesel's barrier to entry is a tad high though, but the situation should improve
    as more and more examples and literature come along.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a quick look at a few ways to perform basic database
    interaction using Rust by using the low-level SQLite and PostgreSQL library crates.
    We saw how to augment database connectivity with a connection pool using r2d2\.
    Finally, we made a small application with Diesel, a safe and performant ORM.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at how Rust can be made to run on the
    web by using a bleeding edge technology called WebAssembly.
  prefs: []
  type: TYPE_NORMAL
