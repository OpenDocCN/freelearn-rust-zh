["```rs\nCreating our own runtime with futures and async/await\n```", "```rs\nmod http;\nmod runtime;\nuse crate::http::Http;\nfn main() {\n    let mut executor = runtime::init();\n    executor.block_on(async_main());\n}\nasync fn async_main() {\n    println!(\"Program starting\");\n    let txt = Http::get(\"/600/HelloAsyncAwait\").await;\n    println!(\"{txt}\");\n    let txt = Http::get(\"/400/HelloAsyncAwait\").await;\n    println!(\"{txt}\");\n}\n```", "```rs\nuse crate::runtime::{self, reactor};\nuse mio::Interest;\nuse std::{\n    future::Future,\n    io::{ErrorKind, Read, Write},\n    pin::Pin,\n    task::{Context, Poll},\n};\n```", "```rs\nfn poll(mut self: Pin<&mut Self>, cx, we have to change what we pass in to set_waker with the following:\n\t\t\tch10/a-rust-futures/src/http.rs\n\n```", "```rs\nfn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>\n```", "```rs\nloop {\n            match self.stream.as_mut().unwrap().read(&mut buff) {\n                Ok(0) => {\n                    let s = String::from_utf8_lossy(&self.buffer).to_string();\n                    runtime::reactor().deregister(self.stream.as_mut().unwrap(), id);\n                    break Poll::Ready(s.to_string());\n                }\n                Ok(n) => {\n                    self.buffer.extend(&buff[0..n]);\n                    continue;\n                }\n                Err(e) if e.kind() == ErrorKind::WouldBlock => {\n                    // always store the last given Waker\n                    runtime::reactor().set_waker(cx, self.id);\n                    break Poll::Pending;\n                }\n                Err(e) => panic!(\"{e:?}\"),\n            }\n        }\n```", "```rs\nuse std::{\n    cell::{Cell, RefCell},\n    collections::HashMap,\n    future::Future,\n    pin::Pin,\n    sync::{Arc, Mutex},\n    task::{Poll, Context, Wake, Waker},\n    thread::{self, Thread},\n};\n```", "```rs\ntype Task = Pin<Box<dyn Future<Output = Waker since the changes we make here will result in several other changes to this file.\n\t\t\tCreating a waker in Rust can be quite a complex task since Rust wants to give us maximum flexibility on how we choose to implement wakers. The reason for this is twofold:\n\n\t\t\t\t*   Wakers must work just as well on a server as it does on a microcontroller\n\t\t\t\t*   A waker must be a zero-cost abstraction\n\n\t\t\tRealizing that most programmers never need to create their own wakers, the cost that the lack of ergonomics has was deemed acceptable.\n\t\t\tUntil quite recently, the only way to construct a waker in Rust was to create something very similar to a trait object without being a trait object. To do so, you had to go through quite a complex process of constructing a *v-table* (a set of function pointers), combining that with a pointer to the data that the waker stored, and creating  `RawWaker`.\n\t\t\tFortunately, we don’t actually have to go through this process anymore as Rust now has the `Wake` trait. The `Wake` trait works if the `Waker` type we create is placed in `Arc`.\n\t\t\tWrapping `Waker` in an `Arc` results in a heap allocation, but for most `Waker` implementations on the kind of systems we’re talking about in this book, that’s perfectly fine and what most production runtimes do. This simplifies things for us quite a bit.\n\t\t\tInfo\n\t\t\tThis is an example of Rust adopting what turns out to be best practices from the ecosystem. For a long time, a popular way to construct wakers was by implementing a trait called `ArcWake` provided by the `futures` crate ([https://github.com/rust-lang/futures-rs](https://github.com/rust-lang/futures-rs)). The `futures` crate is not a part of the language but it’s in the `rust-lang` repository and can be viewed much like a toolbox and nursery for abstractions that might end up in the language at some point in the future.\n\t\t\tTo avoid confusion by having multiple things with the same name, let’s rename our concrete `Waker` type to `MyWaker`:\n\t\t\tch10/a-rust-futures/src/runtime/executor.rs\n\n```", "```rs\n\n\t\t\tWe can keep the implementation of `wake` pretty much the same, but we put it in the implementation of the `Wake` trait instead of just having a `wake` function on `MyWaker`:\n\t\t\tch10/a-rust-futures/src/runtime/executor.rs\n\n```", "```rs\n\n\t\t\tYou’ll notice that the `wake` function takes a `self: Arc<Self>` argument, much like we saw when working with the `Pin` type. Writing the function signature this way means that `wake` is only callable on `MyWaker` instances that are wrapped in `Arc`.\n\t\t\tSince our `waker` has changed slightly, there are a few places we need to make some minor corrections. The first is in the `get_waker` function:\n\t\t\tch10/a-rust-futures/src/runtime/executor.rs\n\n```", "```rs\n\n\t\t\tSo, not a big change here. The only difference is that we heap-allocate the waker by placing it in `Arc`.\n\t\t\tThe next place we need to make a change is in the `block_on` function.\n\t\t\tFirst, we need to change its signature so that it matches our new definition of a top-level future:\n\t\t\tch10/a-rust-futures/src/runtime/executor.rs\n\n```", "```rs\n\n\t\t\tThe next step is to change how we create a waker and wrap it in a `Context` struct in the `block_on` function:\n\t\t\tch10/a-rust-futures/src/runtime/executor.rs\n\n```", "```rs\n\n\t\t\tThis change is a little bit complex, so we’ll go through it step by step:\n\n\t\t\t\t1.  First, we get `Arc<MyWaker>` by calling the `get_waker` function just like we did before.\n\t\t\t\t2.  We convert `MyWaker` into a simple `Waker` by specifying the type we expect with `let waker: Waker` and calling `into()` on `MyWaker`. Since every instance of `MyWaker` is also a kind of `Waker`, this will convert it into the `Waker` type that’s defined in the standard library, which is just what we need.\n\t\t\t\t3.  Since `Future::poll` expects  `Context` and not `Waker`, we create a new `Context` struct with a reference to the waker we just created.\n\n\t\t\tThe last place we need to make changes is to the signature of our `spawn` function so that it takes the new definition of top-level futures as well:\n\t\t\tch10/a-rust-futures/src/runtime/executor.rs\n\n```", "```rs\nuse mio::{net::TcpStream, Events, Interest, Poll, Registry, Token};\nuse std::{\n    collections::HashMap,\n    sync::{\n        atomic::{AtomicUsize, Ordering},\n        Arc, Mutex, OnceLock,\n    },\n    thread, task::{Context, Waker},\n};\n```", "```rs\npub fn set_waker(&self, cx: &Context, id: usize) {\n        let _ = self\n            .wakers\n            .lock()\n            .map(|mut w| w.insert(id, cx.waker().clone()).is_none())\n            .unwrap();\n    }\n```", "```rs\nif let Some(waker) = wakers.get(&id) {\n    waker.wake_by_ref();\n}\n```", "```rs\nProgram starting\nFIRST POLL - START OPERATION\nmain: 1 pending tasks. Sleep until notified.\nHTTP/1.1 200 OK\ncontent-length: 15\n[==== ABBREVIATED ====]\nHelloAsyncAwait\nmain: All tasks are finished\n```", "```rs\ncargo add reqwest@0.11\n```", "```rs\nasync fn async_main() {\n    println!(\"Program starting\");\n    let url = \"http://127.0.0.1:8080/600/HelloAsyncAwait1\";\n    let res = reqwest::get(url).await.unwrap();\n    let txt = res.text().await.unwrap();\n    println!(\"{txt}\");\n    let url = \"http://127.0.0.1:8080/400/HelloAsyncAwait2\";\n    let res = reqwest::get(url).await.unwrap();\n    let txt = res.text().await.unwrap();\n    println!(\"{txt}\");\n}\n```", "```rs\n     Running `target\\debug\\a-rust-futures.exe`\nProgram starting\nthread 'main' panicked at C:\\Users\\cf\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\tokio-1.35.0\\src\\net\\tcp\\stream.rs:160:18:\nthere is no reactor running, must be called from the context of a Tokio 1.x runtime\n```", "```rs\ncargo add tokio@1 --features full\n```", "```rs\nuse tokio::runtime::Runtime;\nasync fn async_main\n    let rt = Runtime::new().unwrap();\n    let _guard = rt.enter();\n    println!(\"Program starting\");\n    let url = \"http://127.0.0.1:8080/600/HelloAsyncAwait1\";\n    ...\n```", "```rs\nProgram starting\nmain: 1 pending tasks. Sleep until notified.\nmain: 1 pending tasks. Sleep until notified.\nmain: 1 pending tasks. Sleep until notified.\nHelloAsyncAwait1\nmain: 1 pending tasks. Sleep until notified.\nmain: 1 pending tasks. Sleep until notified.\nmain: 1 pending tasks. Sleep until notified.\nHelloAsyncAwait2\nmain: All tasks are finished\n```", "```rs\ncargo add isahc@1.7\n```", "```rs\nuse isahc::prelude::*;\nasync fn async_main() {\n    println!(\"Program starting\");\n    let url = \"http://127.0.0.1:8080/600/HelloAsyncAwait1\";\n    let mut res = isahc::get_async(url).await.unwrap();\n    let txt = res.text().await.unwrap();\n    println!(\"{txt}\");\n    let url = \"http://127.0.0.1:8080/400/HelloAsyncAwait2\";\n    let mut res = isahc::get_async(url).await.unwrap();\n    let txt = res.text().await.unwrap();\n    println!(\"{txt}\");\n}\n```", "```rs\nProgram starting\nmain: 1 pending tasks. Sleep until notified.\nmain: 1 pending tasks. Sleep until notified.\nmain: 1 pending tasks. Sleep until notified.\nHelloAsyncAwait1\nmain: 1 pending tasks. Sleep until notified.\nmain: 1 pending tasks. Sleep until notified.\nmain: 1 pending tasks. Sleep until notified.\nHelloAsyncAwait2\nmain: All tasks are finished\n```", "```rs\n\n```", "```rs\n\n```"]