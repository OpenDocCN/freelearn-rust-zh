- en: Expressing Yourself with Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous century, many languages featured a preprocessor (most prominently,
    C/C++) that often did unassuming text replacement. While this is handy for expressing
    constants (`#define MYCONST 1`), it also leads to potentially unexpected outcomes
    once the replacement gets more complex (for example, `#define MYCONST 1 + 1` and
    when applied as `5 * MYCONST` yields *5 * 1 + 1 = 6* instead of the expected 10
    (from *5 * (1 + 1))* ) .
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a preprocessor allows program programming (metaprogramming) and therefore
    makes things easier for the developer. Instead of copying and pasting expressions
    and excessive boilerplate code, a quick macro definition leads to a smaller code
    base and reusable calls and—as a consequence—fewer errors. In order to make the
    best use of Rust''s type system, macros cannot simply search and replace text;
    they have to work on a higher level: the abstract syntax tree. Not only does this
    require a different calling syntax (such as an exclamation mark at the end of
    a call; for example, `println!`) for the compiler to know what to do, the parameter
    *types* are different as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this level, we are talking about expressions, statements, identifiers, types,
    and many more that can be passed into a macro. Ultimately, however, the macro
    preprocessor still inserts the macro''s body into the calling scope before compilation,
    so the compiler catches type mismatches or borrowing violations. If you want to
    read more on macros, check out the blog post at [https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/](https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/),
    *The Little Book of Rust Macros* ([https://danielkeep.github.io/tlborm/book/index.html](https://danielkeep.github.io/tlborm/book/index.html)),
    and the Rust book ([https://doc.rust-lang.org/book/ch19-06-macros.html](https://doc.rust-lang.org/book/ch19-06-macros.html)).
    Macros are best tried out to get a feel for them—we''ll cover the following in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building custom macros in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing matching with macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using predefined Rust macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code generation using macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macro overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `repeat` for parameter ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't Repeat Yourself (DRY)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building custom macros in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we have mostly used predefined macros—it's now time to look at creating
    custom macros. There are several types of macros in Rust—derive-based, function-like,
    and attributes, all of which have their own respective use cases. In this recipe,
    we'll experiment with the function-like variety to get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are only a few steps from creating macros:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `cargo new custom-macros` in Terminal (or PowerShell on Windows) and open
    the directory with Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/main.rs` in the editor. Let''s create a new macro called `one_plus_one`
    at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call this simple macro inside the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This was a very simple macro, but macros can do so much more! How about one
    that lets us decide on the operation. Add a very simple macro to the top of the
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the words in the **matcher **part of the macro are required, we have
    to call the macro exactly like that. Add the following inside the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last part, we should think of keeping things in order; creating modules,
    structs, files, and so on. To group similar behavior is a common way to organize
    stuff, and if we want to use it outside of our module we need to make it publicly
    available. Just like the `pub` keyword, macros have to be exported explicitly—but
    with an attribute. Add this module to `src/main.rs` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the export, we can now also call this function in `main()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By issuing `cargo run` from Terminal inside the project''s directory, we will
    then find out whether it worked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In order to understand the code better, let's decipher these steps.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As appropriate, we use a macro—`macro_rules!`—to create a custom macro as we
    did in *step 3*. A single macro matches a pattern and consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A name (for example, `one_plus_one`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matcher (for example, `(plus) => ...`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transcriber (for example, `... => { 1 + 1 }`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a macro is always done using its name followed by an exclamation mark
    (*step 4*), and for specific patterns, with the required characters/words (*step
    6*). Note that `plus` and others are not variables, types, or otherwise defined—which
    gives you the power to create your own **domain-specific language** (**DSL**)!
    More on that in other recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: By calling a macro, the compiler takes note of the position in the **abstract
    syntax tree** (**AST**) and, instead of pure text replacement, inserts the macro's
    transcriber sub-tree right there. Afterward, the compiler tries to finish the
    compilation, leading to regular type-safety checks, borrowing rules enforcement,
    and so on, but with awareness for macros. This makes it easier for you, as the
    developer, to find errors and trace them back into the macros they originate from.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we create a module to export a macro from—something that will improve
    the code structure and maintainability, especially in larger code bases. However,
    the export step is required since macros are private by default. Try removing
    the `#[macro_export]` attribute to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 8* shows how to call every macro variation in the project as a comparison. For
    more information, you can also check out the blog post at [https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html](https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html),
    which goes into more detail about providing macro crates on `crates.io` ([https://crates.io](https://crates.io)).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to build custom macros in Rust, we can move on to the next
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing matching with macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we created custom macros, we had already seen pattern matching at play:
    a command was only executed if particular words were present *before compilation*.
    In other words, the macro system compares raw text as patterns before they become
    expressions or types. Consequently, creating a DSL is really easy. Defining a
    web request handler? Use method names in the pattern: `GET`, `POST`, `HEAD`. There
    is an endless variety, however, so let''s see how we can define some patterns
    in this recipe!'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By following these next few steps, you will be able to use macros:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `cargo new matching --lib` in Terminal (or PowerShell on Windows) and open
    the directory with Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `src/lib.rs`, we add a macro to work with specific types as inputs. Insert
    the following at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, this should be tested to see whether it works. Replace the `it_works()`
    test with a different test function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The patterns can also contain actual input parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple test to round it off is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling HTTP requests has always been an architectural challenge, with added
    layers and special routes for every business case. As some web frameworks ([https://github.com/seanmonstar/warp](https://github.com/seanmonstar/warp)) show,
    macros can provide useful support to enable composing handlers together. Add another
    macro and support functions to the file—the `register_handler()` function, which
    mocks registering a handler function for our hypothetical web framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make sure everything works, we should also add a test for the `web!`
    macro. When the function is empty, a macro that doesn''t match the pattern it
    holds leads to a compile-time error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As the final step, let''s run `cargo test` (note: add `#![allow(unused_variables,
    unused_macros)]`at the top of the file to remove warnings):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at what the code does.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2* of this recipe, we define a macro that explicitly provides the different
    patterns that the engine can match to. Specifically, the alphanumeric characters
    are limited to `,`, `;`, and `=>`. While this allows Ruby-style map initialization,
    it also limits the elements that a DSL can have. However, macros are still great
    for creating a more expressive way to deal with situations. In *step 6* and *step
    7*, we show a way to create a web request handler using a more expressive way
    than the usual chained function calls. *Step 4* and *step 5* show the usage of
    the arrow (`=>`) inside macros and *step 8* ties it all together by running the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created matching arms for the macro invocation to use, where
    the arms use a literal matching (instead of matching on the types, which will
    come later in this chapter) to decide on a replacement. This shows that not only
    can we use parameters and literals in one arm but we can also automate tasks without
    the constraints of regularly allowed names.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to implement matching in macros. Now let's move
    on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using predefined macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous recipes in this chapter, macros can save a lot of
    writing and provide convenience functions without having to rethink the entire
    application architecture. Consequently, the Rust standard library provides several
    macros for a range of features that might otherwise be surprisingly complex to
    implement. One example is cross-platform prints—how would that work? Is there
    an equivalent way to output console text for every platform? What about color
    support? What is the default encoding? There are a lot of questions, which is
    an indicator of how many things need to be configurable—yet in a typical program,
    we only call `print!("hello")` and it works. Let's see what else there is.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these few steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `cargo new std-macros` in Terminal (or PowerShell on Windows) and open
    the directory with Visual Studio Code. Then, create a `a.txt` file inside the
    project''s `src` directory with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the default implementation of `main()` (in `src/main.rs`) already provides
    us with a macro call to `println!`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extend the function by printing more. Insert the following after the
    `println!` macro call in the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition for `MyStruct` is also simple and involves a procedural macro
    that comes with the standard library. Insert this before the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The Rust standard library also includes macros to interact with the outside
    world. Let''s add a few more calls to the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step, let''s add two alternatives to the well-known `println!` and
    `assert!` macros to `main()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven''t already, we have to run the entire project using `cargo run`
    to see some output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We should now pull back the curtain to understand the code a bit better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `main` function, we now have a few macros that are more or less
    well known. Each of them is doing something we thought was useful. We''ll skip
    *step 2* since it only shows the `println!` macro—something that we are using
    constantly. In *step 3*, however, some more exotic macros turn up:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vec!` creates and initializes a vector and famously uses `[]` to do so. However,
    while this makes visual sense, the compiler will accept `vec!()` just as well
    as `vec!{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concat!` joins literals from left to right like a static string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stringify!` creates a string literal from the input tokens, regardless of
    whether they exist or not (see the word `helloworld`, which got translated to
    a string).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Step 4* includes working with a procedural macro in Rust. While the word *derive*
    and the syntax bring to mind inheritance in classic OOP fashion, they are not
    actually deriving anything but are providing an actual implementation. For us,
    `#[derive(Debug)]` has certainly been the most useful, but there is also `PartialEq`,
    `Eq`, and `Clone`, which are closely behind.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 5* of the recipe returns to function-like macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cfg!` is similar to the `#[cfg]` attribute, which makes it possible to determine
    conditions at compile time, which allows you—for example—to include platform-specific
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include_str!` is a very interesting one. There are other includes, but this
    is very useful to provide translation to your applications since it reads the
    provided file''s contents as a `''static str` (just like a literal).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`option_env!` reads environment variables at **compile time** to provide an
    `Option` result of their values. Be aware that, in order to reflect the changes
    to the variable, the program has to be re-compiled!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Step 6*''s macros are alternatives to other popular macros that we know:'
  prefs: []
  type: TYPE_NORMAL
- en: '`debug_assert!` is a variation of `assert!`, which is not included in `--release`
    builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eprintln!` outputs stuff on standard error instead of standard out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this is a pretty stable selection, future releases of the Rust Standard
    Library will include more macros to make working with Rust more convenient. The
    most popular example—at the time of writing—for unfinished macros is `await!`,
    which might never be stabilized due to a different approach to `async`/`await`.
    Check out the full list in the document at [https://doc.rust-lang.org/std/#macros](https://doc.rust-lang.org/std/#macros).
  prefs: []
  type: TYPE_NORMAL
- en: Now we've learned more about using predefined macros, we can move on to the
    next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Code generation using macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something derive-type macros already show us is that we can generate entire
    trait implementations using macros. Similarly, we can generate entire structs
    and functions using macros and avoid copy-and-paste programming, as well as tedious
    boilerplate code. Since macros are executed right before compilation, the generated
    code will be checked accordingly while avoiding the details of strictly typed
    languages. Let's see how!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code generation can be as easy as these few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `cargo new code-generation --lib` in Terminal (or PowerShell on Windows)
    and open the directory with Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/lib.rs` and add the first simple macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do another one, this time a bit more generative. Add this outside of
    the testing module (for example, underneath the previous macro):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of those macros are also very straightforward to use. Let''s replace the
    `tests` module with relevant tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the macros have not done a sophisticated code generation, however.
    In fact, the first one simply repeats a block several times—something that is
    already available through iterators ([https://doc.rust-lang.org/std/iter/fn.repeat_with.html](https://doc.rust-lang.org/std/iter/fn.repeat_with.html)).
    The second macro creates a function, but that''s available, too, via the closure
    syntax ([https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html](https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html)).
    Let''s add something more interesting then, such as `enum` with a `Default` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing can go untested, so here is a test to see whether it works as expected.
    Add this to the preceding tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are writing tests, we also want to see them running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In order to understand the code, let's talk about what's going on behind the
    scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to the compiler executing macros before the actual compilation, we can
    generate code that will show up in the final program but that was actually created
    via a macro invocation. This lets us reduce boilerplate code, enforce defaults
    (such as implementing certain traits, adding metadata, and many others), or simply
    provide a nicer interface for users of our crate.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we are creating a simple macro to repeat a block (these curly braces—`{
    }`—and their content are called a **block**) several times—using a `for` loop.
    The tests created in *step 4* show how this operates and what it can do—it executes
    as if we were to write a `for` loop right in the test.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* creates a more interesting thing: a function. Together with the tests
    in *step 4*, we can see how the macro operates and note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The provided block is evaluated lazily (the test only fails when the function
    is called).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler complains about an unused function if it is not called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a parameterized function in this way leads to a compiler error (it
    can't find the value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Step 5* creates a more complex macro that is able to create an entire `enum`.
    It lets the user define the variants (even using an arrow—`=>`—notation), and
    adds a default value. Let''s look at the pattern the macro expects: `($name: ident,
    $($variant: ident => $val:expr),+)`. The first parameter (`$name`) is an identifier,
    something that names something (that is, the rules of identifiers are enforced).
    The second parameter is a repeated parameter and it is required to be present
    at least once (indicated by `+`), but if you provide more instances, they have
    to be separated by `,`. The expected pattern for those repetitions is as follows:
    identifier, `=>`, and expression (for example, `bla => 1 + 1`, `Five => 5`, or 
    `blog => 0x5ff`, and many others).'
  prefs: []
  type: TYPE_NORMAL
- en: What follows inside the macro is a classic definition of `enum` with the repeated
    parameter inserted just as often as it occurs in the input. Then, we can add derive
    attributes on top of `enum` and implement the `std::default::Default` trait ([https://doc.rust-lang.org/std/default/trait.Default.html](https://doc.rust-lang.org/std/default/trait.Default.html))
    to provide something sensible for when a default value is required.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn some more about macros and parameters and move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Macro overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method/function overloading is a technique to have duplicate method/function
    names but different parameters for each. Many statically typed languages, such
    as C# and Java, support this in order to provide many ways to call a method without
    having to come up with a new name each time (or use generics). Rust, however,
    does not support that for functions—with good reason ([https://blog.rust-lang.org/2015/05/11/traits.html](https://blog.rust-lang.org/2015/05/11/traits.html)).
    Where Rust does support overloading is with macro patterns: you can create a macro
    and have multiple arms that only differ in their input parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement some overloaded macros in a few simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `cargo new macro-overloading --lib` in Terminal (or PowerShell on Windows)
    and open the directory with Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `src/lib.rs`, we add the following before the `mod tests` module declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how we apply this macro. Inside the `tests` module, let''s see if
    the printer macro serializes strings to a stream by adding the following unit
    test (replace the existing `it_works` test):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to facilitate testing in the future, we should add another macro inside
    the `tests` module. This time, the macro is mocking ([https://martinfowler.com/articles/mocksArentStubs.html](https://martinfowler.com/articles/mocksArentStubs.html))
    a function with a static return value. Write this after the previous test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should test the `mock!` macro as well. Add another test underneath:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step, we run `cargo test` to see if it works. However, this time,
    we pass `--nocapture` into the test harness to see what''s been printed (for *step
    3*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overloading is a very simple concept—so simple, in fact, that it's hard to find
    usable examples that can't be done using a sufficiently complex function. However,
    in this recipe, we think that we have come up with something useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 2*, we created a wrapper around `println!` and similar functions that
    allow writing to standard streams such as standard output and standard error,
    or any other arbitrary stream type, with only a token to make the difference.
    There are a few interesting details to this implementation outside of this as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: Each call to `print!` is followed by `;`—except for the last one, which is why
    there is an extra `;` after the `*`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pattern allows for an arbitrary number of expressions to be passed in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This macro can be useful to avoid repeating `println!("{:?}", "hello")` just
    to quickly see the current value of a variable. Additionally, it facilitates output
    redirection to standard error.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we create a test for this macro invocation. In a quick check, we
    print to `error`, `stdout`, and `vec!` (which is why we import `std::io::Write`).
    There, we can see the new line at the end and that it's written as a string (the
    numbers are bytes). In either call, it finds the required macro pattern and inserts
    its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* creates a macro for mocking functions on structs or entire structs.
    This is very useful for isolating the tests to really only test the target implementation
    without running the risk of adding more errors by trying to implement a supporting
    function. In this case, the macro''s arms are easy to distinguish. The first one
    creates a mock implementation of a function and matches the parameters it requires:
    the type it attaches to, the function''s identifier, which return type, and a
    block that returns that type. The second arm creates a struct and therefore only
    requires an identifier to name the struct and properties together with their data
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking—or creating a mock object—is a testing technique that allows the creation
    of shallow constructs to simulate the desired behavior. This is very useful for
    things that cannot be implemented otherwise (external hardware, third-party web
    services, and many more) or complex internal systems (database connection and
    logic).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to test these outcomes, which is done in *step 5*. There, we
    call the `mock!` macro and define its behavior along with a test to prove it works.
    We run the tests in *step 6* without the harness capturing the console outputs:
    it works!'
  prefs: []
  type: TYPE_NORMAL
- en: We are certain that overloading macros were a breeze to learn. Now let's move
    on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using repeat for parameter ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust''s `println!` macro has a curious characteristic: there is no upper limit
    on the number of parameters that you can pass into it. Since regular Rust does
    not support arbitrary parameter ranges, it has to be a macro feature—but which?
    In this recipe, find out how to handle and implement parameter ranges for macros.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll know how to use parameter ranges after these few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `cargo new parameter-ranges --lib` in Terminal (or PowerShell on Windows)
    and open the directory with Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `src/lib.rs`, add the following code to initialize a set in `vec!` style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add a simple macro to create a DTO—a data transmission object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This needs to be tested as well, so let''s add a test to use the new macro
    to create a set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With the set initializer tested, let''s also test creating a DTO. Add the following
    under the previous test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step, we also run `cargo test` to show that it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parameter ranges in Rust''s macro system work a little bit like regular expressions.
    There are several parts to the syntax: `$()` indicates repetition, the character
    that follows its separator (`,`, `;`, and `=>` are allowed), and lastly, the qualifier
    for how often the repetition is expected (`+` or `*`—just like regular expressions,
    one or more and zero or more respectively).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* shows the implementation of a set initializer macro akin to `vec!`.
    There, we expect a single expression to populate `std::collections::HashSet` and
    return the result in a sub-block from the transcriber. This is necessary to allow
    things such as variable assignments (which are not allowed directly within the
    transcriber block), but don''t hinder the expansion of the parameters that were
    passed into the macro. In a similar fashion to the declaration, the expansion
    is done using a `$()` area, but instead of a separator, the repetition qualifier
    follows directly. Whatever is contained in there will be run as many times as
    there are parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: The second macro is defined in *step 3* and is much more complex. The name `dto!`
    (data transmission object) indicates a business object such as a data container
    that is only used to pass data around the program without being sent outside the
    program. Since these DTOs contain a significant amount of boilerplate code, they
    can be initialized similarly to a key-value store. By using the `=>` sign in the
    parameter range specification, we can create identifier/type pairs that are used
    to create properties in `struct` and its constructor function. Note that the comma
    that separates the properties is located right before the `+` sign so it gets
    repeated as well.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* shows an invocation of the macro designed in *step 2* to populate
    a set and test to confirm it was populated properly. Similarly, *step 5* shows
    the creation and instantiation of a DTO instance (`struct` called `Sensordata`)
    along with a test to confirm that the properties were created as expected. The
    last step confirms this by running the tests.'
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to use repeat for parameter ranges. Now let's
    move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Don't Repeat Yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a previous recipe, we were using macros to generate almost arbitrary code,
    thereby reducing the amount of code to write. Let's dive deeper into this topic
    since this is a great way not only to reduce bugs but also to achieve consistent
    quality in code. One repetitive task that everyone should do is testing (especially
    if it's a public-facing API), and if we copy and paste those tests we expose ourselves
    to errors. Instead, let's see how we can generate boilerplate code with macros
    to stop repeating ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Automated testing with macros is only a few steps away:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `cargo new dry-macros --lib` in Terminal (or PowerShell on Windows) and
    open the directory with Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `src/lib.rs`, we want to create a helper macro and import the stuff we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a macro to auto-implement an operator. Let''s add this underneath
    the `assert_equal_len` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call the macro and actually generate the implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With these functions in place, we can now generate the test cases as well!
    Add the following instead of the `test` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step, let''s see the generated code in action by running `cargo
    test` to see the (positive) test results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In order to understand the code better, let's decipher the steps.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While design patterns, `if-else` constructs, and API design, in general, facilitate
    reusing code, it becomes tricky when it's time to hardcode tokens (for example,
    certain names) to remain loosely coupled. Rust's macros can help with that. As
    an example, we generate functions and tests for those functions in an effort to
    avoid copying and pasting test code around files.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we declare a macro that wraps around comparing the lengths of two
    sequences and provides a better error message. *Step 4* uses this macro right
    away and creates a function with the name provided, but only if the lengths of
    the multiple input `Vec` instances match.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 5*, we call the macros and provide them with the required input: a
    name (for the function) and types for the generic binding. This creates the functions
    using a provided interface without the need to copy and paste code.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 6* creates the associated tests by declaring the `test` module, a macro
    to generate the tests, and the call to finally create the test code as well. This
    allows you to generate the tests on the fly, right before compiling them, which
    significantly reduces the amount of static, repeated code—which has always been
    an issue in testing. The last step shows that these tests are actually created
    and executed when running `cargo test`.'
  prefs: []
  type: TYPE_NORMAL
