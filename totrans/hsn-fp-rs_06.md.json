["```rs\nfn issue_override_code(code: c_int)\n```", "```rs\nfn poll_override_code() -> c_int\n```", "```rs\nfn poll_override_input_floor()\n```", "```rs\nfn poll_override_error() -> c_int\n```", "```rs\nfn poll_override_session() -> *const c_void\n```", "```rs\nfn free_override_session(session: *const c_void)\n```", "```rs\nfn poll_physical_override_privileged_session() -> *const c_void\n```", "```rs\nfn poll_physical_override_admin_session() -> *const c_void\n```", "```rs\nfn override_manual_mode()\n```", "```rs\nfn override_normal_mode()\n```", "```rs\nfn override_reset_state()\n```", "```rs\n fn elevator_display_flash(pattern: c_int)\n```", "```rs\nfn elevator_display_toggle_light(light_id: c_int)\n```", "```rs\nfn elevator_display_set_light_color(light_id: c_int, color: int)\n```", "```rs\npub enum OverrideCode {\n   IssueOverride = 1,\n   IssuePrivileged = 2,\n   IssueAdmin = 3,\n   IssueInputFloor = 4,\n   IssueManualMode = 5,\n   IssueNormalMode = 6,\n   IssueFlash = 7,\n   IssueToggleLight = 8,\n   IssueSetLightColor = 9,\n}\n\npub fn toOverrideCode(i: i32) -> OverrideCode {\n   match i {\n      1 => OverrideCode::IssueOverride,\n      2 => OverrideCode::IssuePrivileged,\n      3 => OverrideCode::IssueAdmin,\n      4 => OverrideCode::IssueInputFloor,\n      5 => OverrideCode::IssueManualMode,\n      6 => OverrideCode::IssueNormalMode,\n      7 => OverrideCode::IssueFlash,\n      8 => OverrideCode::IssueToggleLight,\n      9 => OverrideCode::IssueSetLightColor,\n      _ => panic!(\"Unexpected override code: {}\", i)\n   }\n}\n```", "```rs\npub enum ErrorCode {\n   DoubleAuthorize = 1,\n   DoubleFree = 2,\n   AccessDenied = 3,\n}\n\npub fn toErrorCode(i: i32) -> ErrorCode {\n   match i {\n      1 => ErrorCode::DoubleAuthorize,\n      2 => ErrorCode::DoubleFree,\n      3 => ErrorCode::AccessDenied,\n      _ => panic!(\"Unexpected error code: {}\", i)\n   }\n}\n```", "```rs\n#[derive(Clone)]\npub struct AuthorizedSession\n{\n   session: *const c_void\n}\n\nimpl Drop for AuthorizedSession {\n   fn drop(&mut self) {\n      unsafe {\n         magic::free_override_session(self.session);\n      }\n   }\n}\n```", "```rs\npub fn authorize_override() -> Result<AuthorizedSession,ErrorCode>\n{\n   let session = unsafe {\n      magic::issue_override_code(OverrideCode::IssueOverride as i32);\n      magic::poll_override_session()\n   };\n   let session = AuthorizedSession {\n      session: session\n   };\n   check_error(session)\n}\n\npub fn authorize_privileged() -> Result<AuthorizedSession,ErrorCode>\n{ ... }\n\npub fn authorize_admin() -> Result<AuthorizedSession,ErrorCode>\n{ ... }\n```", "```rs\npub fn reset_state()\n{\n   unsafe {\n      magic::override_reset_state();\n   }\n}\n\npub fn check_error<T>(t: T) -> Result<T,ErrorCode>\n{\n   let err = unsafe {\n      magic::poll_override_error()\n   };\n   if err==0 {\n      Result::Ok(t)\n   } else {\n      Result::Err(toErrorCode(err))\n   }\n}\n```", "```rs\npub fn input_floor(floor: i32) -> Result<(),ErrorCode>\n{\n   unsafe {\n      magic::override_input_floor(floor);\n   }\n   check_error(())\n}\n\npub fn manual_mode() -> Result<(),ErrorCode>\n{\n   unsafe {\n      magic::override_manual_mode();\n   }\n   check_error(())\n}\n\npub fn normal_mode() -> Result<(),ErrorCode>\n{\n   unsafe {\n      magic::override_normal_mode();\n   }\n   check_error(())\n}\n```", "```rs\npub fn flash(pattern: i32) -> Result<(),ErrorCode>\n{\n   unsafe {\n      magic::elevator_display_flash(pattern);\n   }\n   check_error(())\n}\n\npub fn toggle_light(light_id: i32) -> Result<(),ErrorCode>\n{\n   unsafe {\n      magic::elevator_display_toggle_light(light_id);\n   }\n   check_error(())\n}\n\npub fn set_light_color(light_id: i32, color: i32) -> Result<(),ErrorCode>\n{\n   unsafe {\n      magic::elevator_display_set_light_color(light_id, color);\n   }\n   check_error(())\n}\n```", "```rs\npub fn is_override() -> bool\n{\n   unsafe {\n      magic::is_override() != 0\n   }\n}\n\npub fn is_privileged() -> bool\n{\n   unsafe {\n      magic::is_privileged() != 0\n   }\n}\n\npub fn is_admin() -> bool\n{\n   unsafe {\n      magic::is_admin() != 0\n   }\n}\n```", "```rs\n#[test]\nfn issue_override_code() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(1);\n      assert!(magic::poll_override_code() == 1);\n      assert!(magic::poll_override_error() == 0);\n   }\n}\n\n#[test]\nfn issue_privileged_code() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(2);\n      assert!(magic::poll_override_code() == 2);\n      assert!(magic::poll_override_error() == 0);\n   }\n}\n\n#[test]\nfn issue_admin_code() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(3);\n      assert!(magic::poll_override_code() == 3);\n      assert!(magic::poll_override_error() == 0);\n   }\n}\n```", "```rs\n#[test]\nfn authorize_override_success() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(1);\n      let session = magic::poll_override_session();\n      assert!(session != (0 as *const c_void));\n      magic::free_override_session(session);\n      assert!(magic::poll_override_error() == 0);\n   }\n}\n\n#[test]\nfn authorize_privileged_success() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(2);\n      let session = magic::poll_physical_override_privileged_session();\n      assert!(session != (0 as *const c_void));\n      magic::free_override_session(session);\n      assert!(magic::poll_override_error() == 0);\n   }\n}\n\n#[test]\nfn authorize_admin_success() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(3);\n      let session = magic::poll_physical_override_admin_session();\n      assert!(session != (0 as *const c_void));\n      magic::free_override_session(session);\n      assert!(magic::poll_override_error() == 0);\n   }\n}\n```", "```rs\n#[test]\nfn double_override_failure() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(1);\n      magic::issue_override_code(1);\n      assert!(magic::poll_override_session() == (0 as *const c_void));\n      assert!(magic::poll_override_error() == 1);\n   }\n}\n\n#[test]\nfn double_privileged_failure() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(2);\n      magic::issue_override_code(2);\n      assert!(magic::poll_physical_override_privileged_session() == (0 as *const c_void));\n      assert!(magic::poll_override_error() == 1);\n   }\n}\n\n#[test]\nfn double_admin_failure() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(3);\n      magic::issue_override_code(3);\n      assert!(magic::poll_physical_override_admin_session() == (0 as *const c_void));\n      assert!(magic::poll_override_error() == 1);\n   }\n}\n```", "```rs\n#[test]\nfn double_free_override_failure() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(1);\n      let session = magic::poll_override_session();\n      assert!(session != (0 as *const c_void));\n      magic::free_override_session(session);\n      magic::free_override_session(session);\n      assert!(magic::poll_override_error() == 2);\n   }\n}\n\n#[test]\nfn double_free_privileged_failure() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(2);\n      let session = magic::poll_physical_override_privileged_session();\n      assert!(session != (0 as *const c_void));\n      magic::free_override_session(session);\n      magic::free_override_session(session);\n      assert!(magic::poll_override_error() == 2);\n   }\n}\n\n#[test]\nfn double_free_admin_failure() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(3);\n      let session = magic::poll_physical_override_admin_session();\n      assert!(session != (0 as *const c_void));\n      magic::free_override_session(session);\n      magic::free_override_session(session);\n      assert!(magic::poll_override_error() == 2);\n   }\n}\n```", "```rs\n#[test]\nfn flash() {\n   unsafe {\n      magic::override_reset_state();\n      magic::elevator_display_flash(222);\n      assert!(magic::poll_override_code() == 7);\n      assert!(magic::poll_override_code() == 222);\n   }\n}\n\n#[test]\nfn toggle_light() {\n   unsafe {\n      magic::override_reset_state();\n      magic::elevator_display_toggle_light(33);\n      assert!(magic::poll_override_code() == 8);\n      assert!(magic::poll_override_code() == 33);\n      assert!(magic::poll_override_code() == 1);\n      magic::elevator_display_toggle_light(33);\n      assert!(magic::poll_override_code() == 8);\n      assert!(magic::poll_override_code() == 33);\n      assert!(magic::poll_override_code() == 0);\n   }\n}\n\n#[test]\nfn set_light_color() {\n   unsafe {\n      magic::override_reset_state();\n      magic::elevator_display_set_light_color(33, 222);\n      assert!(magic::poll_override_code() == 9);\n      assert!(magic::poll_override_code() == 33);\n      assert!(magic::poll_override_code() == 222);\n   }\n}\n```", "```rs\n#[test]\nfn input_floor() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(3);\n      magic::override_input_floor(2);\n      assert!(magic::poll_override_code() == 4);\n      assert!(magic::poll_override_code() == 2);\n      assert!(magic::poll_override_error() == 0);\n   }\n}\n\n#[test]\nfn manual_mode() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(3);\n      magic::override_manual_mode();\n      assert!(magic::poll_override_code() == 5);\n      assert!(magic::poll_override_error() == 0);\n   }\n}\n\n#[test]\nfn normal_mode() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(3);\n      magic::override_normal_mode();\n      assert!(magic::poll_override_code() == 6);\n      assert!(magic::poll_override_error() == 0);\n   }\n}\n```", "```rs\n#[test]\nfn deny_input_floor() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(4);\n      magic::issue_override_code(2);\n      assert!(magic::poll_override_error() == 3);\n   }\n}\n\n#[test]\nfn deny_manual_mode() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(5);\n      assert!(magic::poll_override_error() == 3);\n   }\n}\n\n#[test]\nfn deny_normal_mode() {\n   unsafe {\n      magic::override_reset_state();\n      magic::issue_override_code(6);\n      assert!(magic::poll_override_error() == 3);\n   }\n}\n```", "```rs\n#[test]\nfn authorize_override() {\n   admin::reset_state();\n   {\n      let session = admin::authorize_override().ok();\n      assert!(admin::is_override());\n   }\n   assert!(!admin::is_override());\n   assert!(admin::check_error(()).is_ok());\n}\n\n#[test]\nfn authorize_privileged() {\n   admin::reset_state();\n   {\n      let session = admin::authorize_privileged().ok();\n      assert(admin::is_privileged());\n   }\n   assert!(!admin::is_privileged());\n   assert!(admin::check_error(()).is_ok());\n}\n\n#[test]\nfn issue_admin_code() {\n   admin::reset_state();\n   {\n      let session = admin::authorize_admin().ok();\n      assert(admin::is_admin());\n   }\n   assert(!admin::is_admin());\n   assert!(admin::check_error(()).is_ok());\n}\n```", "```rs\n#[test]\nfn clone_override() {\n   admin::reset_state();\n   {\n      let session = admin::authorize_override().ok().unwrap();\n      let session2 = session.clone();\n      assert!(admin::is_override());\n   }\n   assert!(!admin::is_override());\n   assert!(admin::check_error(()).is_ok());\n}\n\n#[test]\nfn clone_privileged() {\n   admin::reset_state();\n   {\n      let session = admin::authorize_privileged().ok().unwrap();\n      let session2 = session.clone();\n      assert!(admin::is_privileged());\n   }\n   assert!(!admin::is_privileged());\n   assert!(admin::check_error(()).is_ok());\n}\n\n#[test]\nfn clone_admin() {\n   admin::reset_state();\n   {\n      let session = admin::authorize_admin().ok().unwrap();\n      let session2 = session.clone();\n      assert!(admin::is_admin());\n   }\n   assert!(!admin::is_admin());\n   assert!(admin::check_error(()).is_ok());\n}\n```", "```rs\n#[test]\nfn input_floor() {\n   admin::reset_state();\n   {\n      let session = admin::authorize_admin().ok();\n      admin::input_floor(2).ok();\n   }\n   assert!(!admin::is_admin());\n   assert!(admin::check_error(()).is_ok());\n}\n\n#[test]\nfn manual_mode() {\n   admin::reset_state();\n   {\n      let session = admin::authorize_admin().ok();\n      admin::manual_mode().ok();\n   }\n   assert!(!admin::is_admin());\n   assert!(admin::check_error(()).is_ok());\n}\n\n#[test]\nfn normal_mode() {\n   admin::reset_state();\n   {\n      let session = admin::authorize_admin().ok();\n      admin::normal_mode().ok();\n   }\n   assert!(!admin::is_admin());\n   assert!(admin::check_error(()).is_ok());\n} \n```", "```rs\n#[test]\nfn flash() {\n   admin::reset_state();\n   assert!(!admin::is_override());\n   assert!(!admin::is_privileged());\n   assert!(!admin::is_admin());\n   admin::flash(222).ok();\n   assert!(admin::check_error(()).is_ok());\n}\n\n#[test]\nfn toggle_light() {\n   admin::reset_state();\n   assert!(!admin::is_override());\n   assert!(!admin::is_privileged());\n   assert!(!admin::is_admin());\n   admin::toggle_light(7).ok();\n   assert!(admin::check_error(()).is_ok());\n}\n\n#[test]\nfn set_light_color() {\n   admin::reset_state();\n   assert!(!admin::is_override());\n   assert!(!admin::is_privileged());\n   assert!(!admin::is_admin());\n   admin::set_light_color(33, 123).ok();\n   assert!(admin::check_error(()).is_ok());\n}\n```", "```rs\n#[test]\nfn deny_input_floor() {\n   admin::reset_state();\n   admin::input_floor(2).err();\n   assert!(!admin::check_error(()).is_ok());\n}\n\n#[test]\nfn deny_manual_mode() {\n   admin::reset_state();\n   admin::manual_mode().err();\n   assert!(!admin::check_error(()).is_ok());\n}\n\n#[test]\nfn deny_normal_mode() {\n   admin::reset_state();\n   admin::normal_mode().err();\n   assert!(!admin::check_error(()).is_ok());\n}\n```", "```rs\nfn main()\n{\n   //variable x has not yet been defined\n   {\n      let x = 5;\n      //variable x is now defined and owned by this context\n\n      //variable x is going out of scope and will be dropped here\n   }\n   //variable x has gone out of scope and is no longer defined\n}\n```", "```rs\n#[test]\nfn clone_override() {\n   admin::reset_state();\n   {\n      let session = admin::authorize_override().ok().unwrap();\n      let session2 = session.clone();\n      assert!(admin::is_override());\n   }\n   assert!(!admin::is_override());\n   assert!(admin::check_error(()).is_ok());\n}\n```", "```rs\n#[derive(Clone)]\npub struct AuthorizedSession\n{\n   session: *const c_void\n}\nimpl Drop for AuthorizedSession {\n   fn drop(&mut self) {\n      unsafe {\n         magic::free_override_session(self.session);\n      }\n   }\n}\n```", "```rs\nstruct AuthorizedSessionInner(*const c_void);\n\n#[derive(Clone)]\npub struct AuthorizedSession\n{\n   session: Rc<AuthorizedSessionInner>\n}\n\nimpl Drop for AuthorizedSessionInner {\n   fn drop(&mut self) {\n      unsafe {\n         magic::free_override_session(self.0);\n      }\n   }\n}\n```", "```rs\nlet session = AuthorizedSession {\n   session: Rc::new(AuthorizedSessionInner(session))\n};\n```", "```rs\n#[test]\nfn invalid_deauthorization() {\n   admin::reset_state();\n   let session = admin::authorize_admin().ok();\n   assert!(admin::authorize_admin().is_err());\n   assert!(admin::is_admin());\n}\n```", "```rs\npub fn authorize_override() -> Result<AuthorizedSession,ErrorCode>\n{\n   if is_override() || is_privileged() || is_admin() {\n      return Result::Err(ErrorCode::DoubleAuthorize)\n   }\n   let session = unsafe {\n      magic::issue_override_code(OverrideCode::IssueOverride as i32);\n      magic::poll_override_session()\n   };\n   let session = AuthorizedSession {\n      session: Rc::new(AuthorizedSessionInner(session))\n   };\n   check_error(session)\n}\n\npub fn authorize_privileged() -> Result<AuthorizedSession,ErrorCode>\n{ ... }\n\npub fn authorize_admin() -> Result<AuthorizedSession,ErrorCode>\n{ ... }\n```", "```rs\n#[test]\nfn double_override_failure() {\n   admin::reset_state();\n   let session = admin::authorize_override().ok();\n   assert!(admin::authorize_override().err().is_some());\n}\n\n#[test]\nfn double_privileged_failure() {\n   admin::reset_state();\n   let session = admin::authorize_privileged().ok();\n   assert!(admin::authorize_privileged().err().is_some());\n}\n\n#[test]\nfn double_admin_failure() {\n   admin::reset_state();\n   let session = admin::authorize_admin().ok();\n   assert!(admin::authorize_admin().err().is_some());\n}\n```", "```rs\nfn main() {\n   let a = 5;\n   let mut b = 5;\n\n   //a = 4; not valid\n   b = 4;\n\n   //*(&mut a) = 3; not valid\n   *(&mut b) = 3;\n}\n```", "```rs\nfn f(x: &mut i32) {\n   *x = 2;\n}\n\nfn main() {\n   let a = 5;\n   let mut b = 5;\n\n   //f(&mut a); not valid\n   f(&mut b);\n}\n```", "```rs\nuse std::sync::{Mutex, Arc};\n\n#[derive(Clone)]\nstruct TimeBomb {\n   countdown: Arc<Mutex<i32>>\n}\nimpl Drop for TimeBomb\n{\n   fn drop(&mut self) {\n      let mut c = self.countdown.lock().unwrap();\n      *c -= 1;\n      if *c <= 0 {\n         panic!(\"BOOM!!\")\n      }\n   }\n}\n\nfn main()\n{\n   let t3 = TimeBomb {\n      countdown: Arc::new(Mutex::new(3))\n   };\n   let t2 = t3.clone();\n   let t1 = t2.clone();\n   let t0 = t1.clone();\n}\n```", "```rs\nfn p0() {}\n\nfn p1() -> u64 {\n   444\n}\n\nfn p2(x: u64) -> u64 {\n   x * 444\n}\n\nfn p3(x: u64, y: u64) -> u64 {\n   x * 444 + y\n}\n\nfn main()\n{\n   p0();\n   p1();\n   p2(3);\n   p3(3,4);\n}\n```", "```rs\nuse std::cell::Cell;\n\nstatic mut blah: u64 = 3;\nfn ip0() {\n   unsafe {\n      blah = 444;\n   }\n}\n\nfn ip1(c: &Cell<u64>) {\n   c.set(333);\n}\n\nfn main()\n{\n   ip0();\n   let r = Cell::new(3);\n   ip1(&r);\n   ip1(&r);\n}\n```", "```rs\n#[macro_use] extern crate cached;\n\ncached!{\n   FIB;\n   fn fib(n: u64) -> u64 = {\n      if n == 0 || n == 1 { return n }\n      fib(n-1) + fib(n-2)\n   }\n}\n\nfn main() {\n   fib(30); //call 1, generates correct value and returns it\n   fib(30); //call 2, finds correct value and returns it\n}\n```", "```rs\n#[macro_use] extern crate lazy_static;\n#[macro_use] extern crate cached;\nuse std::collections::HashMap;\nuse std::sync::Mutex;\n\nlazy_static! {\n   static ref BUCKET_COUNTER: Mutex<HashMap<u64, u64>> = {\n      Mutex::new(HashMap::new())\n   };\n}\n\ncached!{\n   BUCK;\n   fn bucket_count(n: u64) -> u64 = {\n      let mut counter = BUCKET_COUNTER.lock().unwrap();\n      let r = match counter.get(&n) {\n         Some(c) => { c+1 }\n         None => { 1 }\n      };\n      counter.insert(n, r);\n      r\n   }\n}\n\nfn main() {\n   bucket_count(30); //call 1, generates correct value and returns it\n   bucket_count(30); //call 2, finds stale value and returns it\n} \n```", "```rs\n#[macro_use] extern crate cached;\nuse std::sync::{Arc,Mutex};\n\n#[derive(Clone)]\npub struct TimeBomb {\n   countdown: Arc<Mutex<i32>>\n}\n\nimpl Drop for TimeBomb\n{\n   fn drop(&mut self) {\n      let mut c = self.countdown.lock().unwrap();\n      *c -= 1;\n      if *c <= 0 {\n         panic!(\"BOOM!!\")\n      }\n   }\n}\n\ncached!{\n   TICKING_BOX;\n   fn tick_tock(v: i32) -> TimeBomb = {\n      TimeBomb {\n         countdown: Arc::new(Mutex::new(v))\n      }\n   }\n}\n\nfn main() {\n   tick_tock(3);\n   tick_tock(3);\n   tick_tock(3);\n}\n```"]