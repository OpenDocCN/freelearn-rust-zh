["```rs\n1+2*3.2+(4/2-3/2)-2.11+2^4\n```", "```rs\n    pub mod ast;\n    pub mod parser;\n    pub mod token;\n    pub mod tokenizer;\n    ```", "```rs\npub struct Tokenizer {\nexpr: &str \n}\n```", "```rs\npub struct Tokenizer {\nexpr: std::str::Chars\n}\n```", "```rs\nlet expression = '1+2';\n```", "```rs\nuse std::iter::Peekable;\nuse std::str::Chars;\npub struct Tokenizer {\nexpr: Peekable<Chars> \n}\n```", "```rs\npub struct Tokenizer<'a> {\nexpr: Peekable<Chars<'a>> \n}\n```", "```rs\nimpl<'a> Tokenizer<'a> {\n    pub fn new(new_expr: &'a str) -> Self {\n        Tokenizer {\n            expr: new_expr.chars().peekable(),\n        }\n    }\n}\n```", "```rs\nfn next(&mut self) -> Option<Self::Item>\n```", "```rs\nimpl<'a> Iterator for Tokenizer<'a> {\n    type Item = Token;\n\n    fn next(&mut self) -> Option<Token> {\n        let next_char = self.expr.next();\n\n        match next_char {\n            Some('0'..='9') => {\n                let mut number = next_char?.to_string();\n\n                while let Some(next_char) = self.expr.peek() {\n                    if next_char.is_numeric() || next_char == \n                        &'.' {\n                        number.push(self.expr.next()?);\n                    } else if next_char == &'(' {\n                        return None;\n                    } else {\n                        break;\n                    }\n                }\n\n                Some(Token::Num(number.parse::<f64>().                    unwrap()))\n            },\n            Some('+') => Some(Token::Add),\n            Some('-') => Some(Token::Subtract),\n            Some('*') => Some(Token::Multiply),\n            Some('/') => Some(Token::Divide),\n            Some('^') => Some(Token::Caret),\n            Some('(') => Some(Token::LeftParen),\n            Some(')') => Some(Token::RightParen),\n            None => Some(Token::EOF),\n            Some(_) => None,\n        }\n    }\n}\n```", "```rs\n// Create a new instance of Parserpub fn new(expr: &'a str) -> Result<Self, ParseError> {\n    let mut lexer = Tokenizer::new(expr);\n    let cur_token = match lexer.next() {\n        Some(token) => token,\n        None => return Err(ParseError::InvalidOperator\n            (\"Invalid character\".into())),\n    };\n    Ok(Parser {\n        tokenizer: lexer,\n        current_token: cur_token,\n    })\n}\n```", "```rs\n// Take an arithmetic expression as input and return an AST\npub fn parse(&mut self) -> Result<Node, ParseError> {\n    let ast = self.generate_ast(OperPrec::DefaultZero);\n    match ast {\n        Ok(ast) => Ok(ast),\n        Err(e) => Err(e),\n    }\n}\n```", "```rs\nfn get_next_token(&mut self) -> Result<(), ParseError> {\n    let next_token = match self.tokenizer.next() {\n        Some(token) => token,\n        None => return Err(ParseError::InvalidOperator\n            (\"Invalid character\".into())),\n    };\n    self.current_token = next_token;\n    Ok(())\n}\n```", "```rs\nfn check_paren(&mut self, expected: Token) -> Result<(), ParseError> {\n    if expected == self.current_token {\n        self.get_next_token()?;\n        Ok(())\n    } else {\n        Err(ParseError::InvalidOperator(format!(\n            \"Expected {:?}, got {:?}\",\n            expected, self.current_token\n        )))\n    }\n}\n```", "```rs\n// Construct AST node for numbers, taking into account \n// negative prefixes while handling parenthesis\nfn parse_number(&mut self) -> Result<Node, ParseError> {\n    let token = self.current_token.clone();\n    match token {\n        Token::Subtract => {\n            self.get_next_token()?;\n            let expr = self.generate_ast(OperPrec::Negative)?;\n            Ok(Node::Negative(Box::new(expr)))\n        }\n        Token::Num(i) => {\n            self.get_next_token()?;\n            Ok(Node::Number(i))\n        }\n        Token::LeftParen => {\n            self.get_next_token()?;\n            let expr = self.generate_ast\n                (OperPrec::DefaultZero)?;\n            self.check_paren(Token::RightParen)?;\n            if self.current_token == Token::LeftParen {\n                let right = self.generate_ast\n                    (OperPrec::MulDiv)?;\n                return Ok(Node::Multiply(Box::new(expr), \n                    Box::new(right)));\n            }\n\n            Ok(expr)\n        }\n        _ => Err(ParseError::UnableToParse(\"Unable to \n            parse\".to_string())),\n    }\n}\n```", "```rs\nfn generate_ast(&mut self, oper_prec: OperPrec) -> Result<Node, ParseError> {\n    let mut left_expr = self.parse_number()?;\n\n    while oper_prec < self.current_token.get_oper_prec() {\n        if self.current_token == Token::EOF {\n            break;\n        }\n        let right_expr = self.convert_token_to_node\n            (left_expr.clone())?;\n        left_expr = right_expr;\n    }\n    Ok(left_expr)\n}\n```", "```rs\n#[derive(Debug, PartialEq, PartialOrd)]\n/// Defines all the OperPrec levels, from lowest to highest.\npub enum OperPrec {\n    DefaultZero,\n    AddSub,\n    MulDiv,\n    Power,\n    Negative,\n}\n```", "```rs\nimpl Token {\n    pub fn get_oper_prec(&self) -> OperPrec {\n        use self::OperPrec::*;\n        use self::Token::*;\n        match *self {\n            Add | Subtract => AddSub,\n            Multiply | Divide => MulDiv,\n            Caret => Power,\n\n            _ => DefaultZero,\n        }\n    }\n}\n```", "```rs\nfn convert_token_to_node(&mut self, left_expr: Node) -> Result<Node, ParseError> {\n    match self.current_token {\n        Token::Add => {\n            self.get_next_token()?;\n            //Get right-side expression\n            let right_expr = self.generate_ast\n                (OperPrec::AddSub)?;\n            Ok(Node::Add(Box::new(left_expr), \n                Box::new(right_expr)))\n        }\n        Token::Subtract => {\n            self.get_next_token()?;\n            //Get right-side expression\n            let right_expr = self.generate_ast\n                (OperPrec::AddSub)?;\n            Ok(Node::Subtract(Box::new(left_expr), \n                Box::new(right_expr)))\n        }\n        Token::Multiply => {\n            self.get_next_token()?;\n            //Get right-side expression\n            let right_expr = self.generate_ast\n                (OperPrec::MulDiv)?;\n            Ok(Node::Multiply(Box::new(left_expr), \n                Box::new(right_expr)))\n        }\n        Token::Divide => {\n            self.get_next_token()?;\n            //Get right-side expression\n            let right_expr = self.generate_ast\n                (OperPrec::MulDiv)?;\n            Ok(Node::Divide(Box::new(left_expr), \n                Box::new(right_expr)))\n        }\n        Token::Caret => {\n            self.get_next_token()?;\n            //Get right-side expression\n            let right_expr = self.generate_ast\n                (OperPrec::Power)?;\n            Ok(Node::Caret(Box::new(left_expr), \n                Box::new(right_expr)))\n        }\n        _ => Err(ParseError::InvalidOperator(format!(\n            \"Please enter valid operator {:?}\",\n            self.current_token\n        ))),\n    }\n}\n```", "```rs\npub fn eval(expr: Node) -> Result<f64, Box<dyn error::Error>> {\n    use self::Node::*;\n    match expr {\n        Number(i) => Ok(i),\n        Add(expr1, expr2) => Ok(eval(*expr1)? + \n            eval(*expr2)?),\n        Subtract(expr1, expr2) => Ok(eval(*expr1)? – \n            eval(*expr2)?),\n        Multiply(expr1, expr2) => Ok(eval(*expr1)? * \n            eval(*expr2)?),\n        Divide(expr1, expr2) => Ok(eval(*expr1)? / \n            eval(*expr2)?),\n        Negative(expr1) => Ok(-(eval(*expr1)?)),\n        Caret(expr1, expr2) => Ok(eval(*expr1)?\n            .powf(eval(*expr2)?)),\n    }\n}\n```", "```rs\nenum Result<T, E> {   Ok(T),   Err(E),}\n```", "```rs\npub enum Option<T> {    None,    Some(T),}\n```", "```rs\n#[derive(Debug)]\npub enum ParseError {\n    UnableToParse(String),\n    InvalidOperator(String),\n}\n```", "```rs\nimpl fmt::Display for ParseError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match &self {\n            self::ParseError::UnableToParse(e) => write!(f, \n                \"Error in evaluating {}\", e),\n            self::ParseError::InvalidOperator(e) => write!(f, \n                \"Error in evaluating {}\", e),\n        }\n    }\n}\n```", "```rs\nimpl std::convert::From<std::boxed::Box<dyn std::error::Error>> for ParseError {\n    fn from(_evalerr: std::boxed::Box<dyn std::error::Error>) \n        -> Self {\n        return ParseError::UnableToParse(\"Unable to \n            parse\".into());\n    }\n}\n```", "```rs\nlet num_value = eval(ast)?\n```", "```rs\nfn main() {\n    println!(\"Hello! Welcome to Arithmetic expression \n        evaluator.\");\n    println!(\"You can calculate value for expression such as \n        2*3+(4-5)+2^3/4\\. \");\n    println!(\"Allowed numbers: positive, negative and \n        decimals.\");\n    println!(\"Supported operations: Add, Subtract, Multiply, \n        Divide, PowerOf(^). \");\n    println!(\"Enter your arithmetic expression below:\");\n    loop {\n        let mut input = String::new();\n        match io::stdin().read_line(&mut input) {\n            Ok(_) => {\n                match evaluate(input) {\n                    Ok(val) => println!(\"The computed number \n                        is {}\\n\", val),\n                    Err(_) => {\n                        println!(\"Error in evaluating \n                            expression. Please enter valid \n                            expression\\n\");\n                    }\n                };\n            }\n\n            Err(error) => println!(\"error: {}\", error),\n        }\n    }\n}\n```", "```rs\nfn evaluate(expr: String) -> Result<f64, ParseError> {\n    let expr = expr.split_whitespace().collect::<String>();\n    // remove whitespace chars\n    let mut math_parser = Parser::new(&expr)?;\n    let ast = math_parser.parse()?;\n    println!(\"The generated AST is {:?}\", ast);\n\n    Ok(ast::eval(ast)?)\n}\n```", "```rs\ncargo run\n```"]