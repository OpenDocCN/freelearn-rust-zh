["```rs\nrustup --version\nrustc --version \ncargo --version\n```", "```rs\nuse std::fs::File;\nuse std::io::Read;\nfn main() {\n    // Open a file\n    let mut f = File::open(\"records.txt\").unwrap();\n    //Create a memory buffer to read from file\n    let mut buffer = [0; 1024];\n    // read from file into buffer\n    let _ = f.read(&mut buffer[..]).unwrap();\n}\n```", "```rs\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\nfn main() {\n    // Open a file\n    let f = File::open(\"records.txt\").unwrap();\n    // Create a BufReader, passing in the file handle\n    let mut buf_reader = BufReader::new(f);\n    //Create a memory buffer to read from file\n    let mut buffer = String::new();\n    // read a line into the buffer\n    buf_reader.read_line(&mut buffer).unwrap();\n    println!(\"Read the following: {}\", buffer);\n}\n```", "```rs\nuse std::fs::File;\nuse std::io::{BufWriter, Write};\nfn main() {\n    // Create a file\n    let f = File::create(\"file.txt\").unwrap();\n    // Create a BufWriter, passing in the file handle\n    let mut buf_writer = BufWriter::new(f);\n    //Create a memory buffer\n    let buffer = String::from(\"Hello, testing\");\n    // write into the buffer\n    buf_writer.write(buffer.as_bytes()).unwrap();\n    println!(\"wrote the following: {}\", buffer);\n}\n```", "```rs\nuse std::io::{self, Write};\nfn main() {\n    //Create a memory buffer to read from file\n    let mut buffer = String::new();\n    // read a line into the buffer\n    let _ = io::stdin().read_line(&mut buffer).unwrap();\n    // Write the buffer to standard output\n    io::stdout().write(&mut buffer.as_bytes()).unwrap();\n}\n```", "```rs\nuse std::io::{Read, Write};\nfn main() {\n    //Create a memory buffer\n    let mut buffer = [8; 1024];\n    // Get handle to input stream\n    let stdin_handle = std::io::stdin();\n    // Lock the handle to input stream\n    let mut locked_stdin_handle = stdin_handle.lock();\n    // read a line into the buffer\n    locked_stdin_handle.read(&mut buffer).unwrap();\n    // Get handle to output stream\n    let stdout_handle = std::io::stdout();\n    // Lock the handle to output stream\n    let mut locked_stdout_handle = stdout_handle.lock();\n    // Write the buffer to standard output\n    locked_stdout_handle.write(&mut buffer).unwrap();\n}\n```", "```rs\nuse std::io::Write;\nfn main() {\n    //Create a memory buffer\n    let buffer = b\"Hello, this is error message from \n        standard \n        error stream\\n\";\n    // Get handle to output error stream\n    let stderr_handle = std::io::stderr();\n    // Lock the handle to output error stream\n    let mut locked_stderr_handle = stderr_handle.lock();\n    // write into error stream from buffer\n    locked_stderr_handle.write(buffer).unwrap();\n}\n```", "```rs\nuse std::io::{BufRead, BufReader};\nfn main() {\n    // Create handle to standard input\n    let s = std::io::stdin();\n    //Create a BufReader instance to optimize sys calls\n    let file_reader = BufReader::new(s);\n    // Read from standard input line-by-line\n    for single_line in file_reader.lines() {\n        println!(\"You typed:{}\", single_line.unwrap());\n    }\n}\n```", "```rs\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn main() {\n    // Open a file for reading\n    let f = File::open(\"file.txt\").unwrap();\n    //Create a BufReader instance to optimize sys calls\n    let file_reader = BufReader::new(f);\n    // Read from standard input line-by-line\n    for single_line in file_reader.lines() {\n        println!(\"Line read from file :{}\", \n            single_line.unwrap());\n    }\n}\n```", "```rs\nuse std::fs::File;\nuse std::io::Read; \nfn main() {\n    // Open two file handles for reading\n    let f1 = File::open(\"file1.txt\").unwrap();\n    let f2 = File::open(\"file2.txt\").unwrap();\n    //Chain the two file handles\n    let mut chained_handle = f1.chain(f2);\n    // Create a buffer to read into\n    let mut buffer = String::new();\n    // Read from chained handle into buffer\n    chained_handle.read_to_string(&mut buffer).unwrap();\n    // Print out the value read into the buffer\n    println!(\"Read from chained handle:\\n{}\", buffer);\n}\n```", "```rs\nuse std::fs::File;\nuse std::io::Read;\nfn main() -> std::io::Result<()> {\n    // Open two file handles for reading\n    let f1 = File::open(\"file1.txt\")?;\n    let f2 = File::open(\"file3.txt\")?;\n    //Chain the two file handles\n    let mut chained_handle = f1.chain(f2);\n    // Create a buffer to read into\n    let mut buffer = String::new();\n    // Read from chained handle into buffer\n    chained_handle.read_to_string(&mut buffer)?;\n    println!(\"Read from chained handle: {}\", buffer);\n    Ok(())\n}\n```", "```rs\nuse std::fs::File;\nuse std::io::Read;\nfn read_files(handle: &mut impl Read) -> \nstd::io::Result<String> {\n    // Create a buffer to read into\n    let mut buffer = String::new();\n    // Read from chained handle into buffer\n    handle.read_to_string(&mut buffer)?;\n    Ok(buffer)\n}\nfn main() {\n    let mut chained_handle;\n    // Open two file handles for reading\n    let file1 = \"file1.txt\";\n    let file2 = \"file3.txt\";\n    if let Ok(f1) = File::open(file1) {\n        if let Ok(f2) = File::open(file2) {\n            //Chain the two file handles\n            chained_handle = f1.chain(f2);\n            let content = read_files(&mut chained_handle);\n            match content {\n                Ok(text) => println!(\"Read from chained \n                    handle:\\n{}\", text),\n                Err(e) => println!(\"Error occurred in \n                    reading files: {}\", e),\n            }\n        } else {\n            println!(\"Unable to read {}\", file2);\n        }\n    } else {\n        println!(\"Unable to read {}\", file1);\n    }\n}\n```", "```rs\n    cargo new usb && cd usb\n    ```", "```rs\n    [dependencies]\n    libusb = \"0.3.0\"\n    ```", "```rs\n    use libusb::{Context, Device, DeviceHandle};\n    use std::fs::File;\n    use std::io::Write;\n    use std::time::Duration;\n    use std::fmt;\n    ```", "```rs\n    #[derive(Debug)]\n    struct USBError {\n        err: String,\n    }\n\n    struct USBList {\n        list: Vec<USBDetails>,\n    }\n    #[derive(Debug)]\n    struct USBDetails {\n        manufacturer: String,\n        product: String,\n        serial_number: String,\n        bus_number: u8,\n        device_address: u8,\n        vendor_id: u16,\n        product_id: u16,\n        maj_device_version: u8,\n        min_device_version: u8,\n    }\n    ```", "```rs\n    impl fmt::Display for USBList {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> \n            fmt::Result {\n            Ok(for usb in &self.list {\n                writeln!(f, \"\\nUSB Device details\")?;\n                writeln!(f, \"Manufacturer: {}\", \n                    usb.manufacturer)?;\n                writeln!(f, \"Product: {}\", usb.product)?;\n                writeln!(f, \"Serial number: {}\", \n                    usb.serial_number)?;\n                writeln!(f, \"Bus number: {}\", \n                    usb.bus_number)?;\n                writeln!(f, \"Device address: {}\", \n                    usb.device_address)?;\n                writeln!(f, \"Vendor Id: {}\", \n                    usb.vendor_id)?;\n                writeln!(f, \"Product Id: {}\", \n                    usb.product_id)?;\n                writeln!(f, \"Major device version: {}\", \n                    usb.maj_device_version)?;\n                writeln!(f, \"Minor device version: {}\", \n                    usb.min_device_version)?;\n            })\n        }\n    }\n    ```", "```rs\n    impl From<libusb::Error> for USBError {\n        fn from(_e: libusb::Error) -> Self {\n            USBError {\n                err: \"Error in accessing USB \n                    device\".to_string(),\n            }\n        }\n    }\n    impl From<std::io::Error> for USBError {\n        fn from(e: std::io::Error) -> Self {\n            USBError { err: e.to_string() }\n        }\n    }\n    ```", "```rs\n    //Function to write details to output file\n    fn write_to_file(usb: USBList) -> Result<(), USBError> {\n        let mut file_handle = File::create\n            (\"usb_details.txt\")?;\n        write!(file_handle, \"{}\\n\", usb)?;\n        Ok(())\n    }\n    ```", "```rs\n    fn main() -> Result<(), USBError> {\n        // Get libusb context\n        let context = Context::new()?;\n\n        //Get list of devices\n        let mut device_list = USBList { list: vec![] };\n        for device in context.devices()?.iter() {\n            let device_desc = device.device_descriptor()?;\n            let device_handle = context\n                .open_device_with_vid_pid(\n                    device_desc.vendor_id(), \n                    device_desc.product_id())\n                .unwrap();\n\n            // For each USB device, get the information\n            let usb_details = get_device_information(\n                device, &device_handle)?;\n            device_list.list.push(usb_details);\n        }\n        println!(\"\\n{}\", device_list);\n        write_to_file(device_list)?;\n        Ok(())\n    }\n    ```", "```rs\n    // Function to print device information\n    fn get_device_information(device: Device, handle: \n        &DeviceHandle) -> Result<USBDetails, USBError> {\n        let device_descriptor = \n            device.device_descriptor()?;\n        let timeout = Duration::from_secs(1);\n        let languages = handle.read_languages(timeout)?;\n        let language = languages[0];\n        // Get device manufacturer name\n        let manufacturer = \n            handle.read_manufacturer_string(\n                language, &device_descriptor, timeout)?;\n        // Get device USB product name\n        let product = handle.read_product_string(\n            language, &device_descriptor, timeout)?;\n        //Get product serial number\n        let product_serial_number =\n            match handle.read_serial_number_string(\n                language, &device_descriptor, timeout) {\n                Ok(s) => s,\n                Err(_) => \"Not available\".into(),\n            };\n        // Populate the USBDetails struct\n        Ok(USBDetails {\n            manufacturer,\n            product,\n            serial_number: product_serial_number,\n            bus_number: device.bus_number(),\n            device_address: device.address(),\n            vendor_id: device_descriptor.vendor_id(),\n            product_id: device_descriptor.product_id(),\n            maj_device_version: \n                device_descriptor.device_version().0,\n            min_device_version: \n                device_descriptor.device_version().1,\n        })\n    }\n    ```"]