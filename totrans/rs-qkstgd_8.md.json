["```rs\n#[derive(Copy, Clone)]\npub enum CopyExample {\n    Good,\n    Bad,\n}\n```", "```rs\n#[derive(Clone)]\npub enum CloneExample {\n    Good,\n    Bad,\n}\n```", "```rs\n#[derive(Copy, Clone)]\npub enum CopyExample {\n    Good,\n    Bad,\n}\n```", "```rs\n#[derive(Debug)]\npub enum DebugExample {\n    Good,\n    Bad,\n}\n```", "```rs\n#[derive(PartialEq)]\npub enum PartialEqSelf {\n    Good,\n    Bad,\n}\n```", "```rs\npub enum PartialEqU32 {\n    Good,\n    Bad,\n}\n\nimpl PartialEq<u32> for PartialEqU32 {\n    fn eq(&self, other: &u32) -> bool {\n        match self {\n            PartialEqU32::Good => other % 2 == 0,\n            PartialEqU32::Bad => other % 2 == 1,\n        }\n    }\n}\n```", "```rs\n#[derive(Eq, PartialEq)]\npub enum EqExample {\n    Good,\n    Bad,\n}\n```", "```rs\n#[derive(PartialOrd, PartialEq)]\npub enum PartialOrdSelf {\n    Good,\n    Bad,\n}\n```", "```rs\npub enum PartialOrdU32 {\n Good,\n Bad,\n}\n\nimpl PartialEq<u32> for PartialOrdU32 {\n    fn eq(&self, _other: &u32) -> bool {\n        false\n    }\n}\n\nimpl PartialOrd<u32> for PartialOrdU32 {\n    fn partial_cmp(&self, _other: &u32) -> Option<Ordering> {\n        match self {\n            PartialOrdU32::Good => Some(Ordering::Greater),\n            PartialOrdU32::Bad => None,\n        }\n    }\n}\n```", "```rs\n#[derive(Ord, Eq, PartialOrd, PartialEq)]\npub enum OrdExample {\n    Good,\n    Bad,\n}\n```", "```rs\n#[derive(Hash)]\npub enum HashExample {\n    Good,\n    Bad,\n}\n```", "```rs\n#[derive(Default)]\npub struct DefaultExample {\n    name: String,\n    value: i32,\n}\n```", "```rs\nlet x: DefaultExample = Default::default();\nprintln!(\"Default String is {:?}, default i32 is {:?}\", x.name, x.value);\n```", "```rs\npub enum AddExample {\n    One,\n    Two,\n    Three,\n    Many,\n}\n\nimpl Add for AddExample {\n    type Output = AddExample;\n\n    fn add(self, other: AddExample) -> AddExample {\n        match (self, other) {\n            (AddExample::One, AddExample::One) => AddExample::Two,\n            (AddExample::One, AddExample::Two) => AddExample::Three,\n            (AddExample::Two, AddExample::One) => AddExample::Three,\n            _ => AddExample::Many,\n        }\n    }\n}\n```", "```rs\npub enum AddExample {\n One,\n Two,\n Three,\n Many,\n}\n\nimpl AddAssign for AddExample {\n    fn add_assign(&mut self, other: AddExample) {\n        *self = match (&self, other) {\n            (AddExample::One, AddExample::One) => AddExample::Two,\n            (AddExample::One, AddExample::Two) => AddExample::Three,\n            (AddExample::Two, AddExample::One) => AddExample::Three,\n            _ => AddExample::Many,\n        };\n    }\n}\n```", "```rs\npub enum BitExample {\n    Yes,\n    No,\n}\n\nimpl BitAnd for BitExample {\n    type Output = BitExample;\n\n fn bitand(self, other: BitExample) -> BitExample {\n match (self, other) {\n (BitExample::Yes, BitExample::Yes) => BitExample::Yes,\n            (BitExample::No, BitExample::Yes) => BitExample::No,\n            (BitExample::Yes, BitExample::No) => BitExample::No,\n            (BitExample::No, BitExample::No) => BitExample::No,\n        }\n    }\n}\n```", "```rs\npub enum BitExample {\n Yes,\n No,\n}\n\nimpl BitAndAssign for BitExample {\n    fn bitand_assign(&mut self, other: BitExample) {\n        *self = match (&self, other) {\n            (BitExample::Yes, BitExample::Yes) => BitExample::Yes,\n            (BitExample::No, BitExample::Yes) => BitExample::No,\n            (BitExample::Yes, BitExample::No) => BitExample::No,\n```", "```rs\n            (BitExample::No, BitExample::No) => BitExample::No,\n        };\n    }\n}\n```", "```rs\npub enum BitExample {\n    Yes,\n    No,\n}\nimpl BitOr for BitExample {\n type Output = BitExample;\n\n fn bitor(self, other: BitExample) -> BitExample {\n        match (self, other) {\n            (BitExample::Yes, BitExample::Yes) => BitExample::Yes,\n            (BitExample::No, BitExample::Yes) => BitExample::Yes,\n            (BitExample::Yes, BitExample::No) => BitExample::Yes,\n            (BitExample::No, BitExample::No) => BitExample::No,\n        }\n    }\n}\n```", "```rs\npub enum BitExample {\n Yes,\n No,\n}\n\nimpl BitOrAssign for BitExample {\n    fn bitor_assign(&mut self, other: BitExample) {\n        *self = match (&self, other) {\n            (BitExample::Yes, BitExample::Yes) => BitExample::Yes,\n            (BitExample::No, BitExample::Yes) => BitExample::Yes,\n            (BitExample::Yes, BitExample::No) => BitExample::Yes,\n            (BitExample::No, BitExample::No) => BitExample::No,\n        };\n    }\n}\n```", "```rs\npub enum BitExample {\n    Yes,\n    No,\n}\n\nimpl BitXor for BitExample {\n type Output = BitExample;\n\n    fn bitxor(self, other: BitExample) -> BitExample {\n        match (self, other) {\n            (BitExample::Yes, BitExample::Yes) => BitExample::No,\n            (BitExample::No, BitExample::Yes) => BitExample::Yes,\n            (BitExample::Yes, BitExample::No) => BitExample::Yes,\n            (BitExample::No, BitExample::No) => BitExample::No,\n        }\n    }\n}\n```", "```rs\npub enum BitExample {\n Yes,\n No,\n}\n\nimpl BitXorAssign for BitExample {\n    fn bitxor_assign(&mut self, other: BitExample) {\n        *self = match (&self, other) {\n            (BitExample::Yes, BitExample::Yes) => BitExample::No,\n            (BitExample::No, BitExample::Yes) => BitExample::Yes,\n            (BitExample::Yes, BitExample::No) => BitExample::Yes,\n            (BitExample::No, BitExample::No) => BitExample::No,\n        };\n    }\n}\n```", "```rs\npub struct DerefExample {\n val: u32,\n}\n\nimpl Deref for DerefExample {\n    type Target = u32;\n\n    fn deref(&self) -> &u32 {\n        return &self.val;\n    }\n}\n```", "```rs\npub struct DerefExample {\n    val: u32,\n}\n\nimpl DerefMut for DerefExample {\n    fn deref_mut(&mut self) -> &mut u32 {\n        return &mut self.val;\n    }\n}\n```", "```rs\npub enum DropExample {\n Good,\n Bad,\n}\n\nimpl Drop for DropExample {\n    fn drop(&mut self) {\n        match self {\n            DropExample::Good => println!(\"Good DropExample dropped\"),\n            DropExample::Bad => println!(\"Bad DropExample dropped\"),\n        };\n    }\n}\n```", "```rs\npub struct IndexExample {\n first: u32,\n second: u32,\n third: u32,\n}\n\nimpl<'a> Index<&'a str> for IndexExample {\n    type Output = u32;\n\n    fn index(&self, index: &'a str) -> &u32 {\n        match index {\n            \"first\" => &self.first,\n            \"second\" => &self.second,\n            \"third\" => &self.third,\n            _ => &0,\n        }\n    }\n}\n```", "```rs\npub struct IndexExample {\n first: u32,\n second: u32,\n third: u32,\n junk: u32,\n}\n\nimpl<'a> IndexMut<&'a str> for IndexExample {\n    fn index_mut(&mut self, index: &'a str) -> &mut u32 {\n        match index {\n            \"first\" => &mut self.first,\n            \"second\" => &mut self.second,\n            \"third\" => &mut self.third,\n            _ => &mut self.junk,\n        }\n    }\n}\n```", "```rs\npub enum NegExample {\n Yes,\n No,\n}\n\nimpl Neg for NegExample {\n type Output = NegExample;\n\n fn neg(self) -> NegExample {\n match self {\n NegExample::Yes => NegExample::No,\n NegExample::No => NegExample::Yes,\n }\n }\n}\n```", "```rs\npub enum NotExample {\n True,\n False,\n}\n\nimpl Not for NotExample {\n    type Output = NotExample;\n\n    fn not(self) -> NotExample {\n        match self {\n            NotExample::True => NotExample::False,\n            NotExample::False => NotExample::True,\n        }\n    }\n}\n```", "```rs\npub enum NotSyncExample {\n Good,\n Bad,\n}\n\nimpl !Sync for NotSyncExample {}\n```"]