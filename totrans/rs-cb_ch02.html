<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Advanced Programming with Rust</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advanced Programming with Rust</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following:</p>
<ul>
<li><span>Defining an e</span>xpression</li>
<li>Defining constants</li>
<li>Performing variable bindings</li>
<li>Performing type casting in Rust</li>
<li>Decision-making with Rust</li>
<li>Looping operations in Rust</li>
<li>Defining the enum type</li>
<li>Defining closures</li>
<li>Performing pointer operations in Rust</li>
<li>Defining your first user-defined data type</li>
<li>Adding functionality to the user-defined data type</li>
<li>Similar functionality for different data type</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>This chapter is focused on equipping you with all the recipes to implement expressions that will represent the state of the code, build logic using decision-making statements such as <kbd>if...else</kbd>, declare a custom complex data type to represent a real-world scenario using <kbd>struct</kbd>, add functionality to a complex data type using traits, and control code execution using the looping statement.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining an expression</h1>
                </header>
            
            <article>
                
<p>An expression, in simple words, is a statement in Rust by using which we can create logic and workflows in the program and applications. We will deep dive into understanding expressions and blocks in Rust.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Follow the ensuing steps:</span></p>
<ol>
<li>Create a file named <kbd>expression.rs</kbd> with the next code snippet.</li>
<li>Declare the <kbd>main</kbd> function and create the variables <kbd>x_val</kbd>, <kbd>y_val</kbd>, and <kbd>z_val</kbd>:</li>
</ol>
<p>&#160;</p>
<pre>        // main point of execution <br/>        fn main() {<br/><br/>          // expression<br/>          let x_val = 5u32;<br/><br/>          // y block <br/>          let y_val = {<br/>            let x_squared = x_val * x_val;<br/>            let x_cube = x_squared * x_val;<br/><br/>            // This expression will be assigned to `y_val`<br/>            x_cube + x_squared + x_val<br/>          };<br/><br/>          // z block<br/>          let z_val = {<br/>            // The semicolon suppresses this expression and `()` is<br/>            assigned to `z`<br/>            2 * x_val;<br/>          };<br/><br/>          // printing the final outcomes<br/>          println!("x is {:?}", x_val);<br/>          println!("y is {:?}", y_val);<br/>          println!("z is {:?}", z_val);<br/>        }
</pre>
<p style="padding-left: 60px"><span>You should get the ensuing output upon running the code. Please refer to the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="75" width="682" class="image-border" src="images/4a06ce81-0c14-41ec-8059-11313a8eee4f.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>All the statements that end in a semicolon (<kbd>;</kbd>) are expressions. A block is a statement that has a set of statements and variables inside the <kbd>{}</kbd> scope. The last statement of a block is the value that will be assigned to the variable. When we close the last statement with a semicolon, it returns <kbd>()</kbd> to the variable.</p>
<p>In the preceding recipe, the first statement which is a variable named <kbd>x_val</kbd> , is assigned to the value <kbd>5</kbd>. Second, <kbd>y_val</kbd> is a block that performs certain operations on the variable <kbd>x_val</kbd> and a few more variables, which are <kbd>x_squared</kbd> and <kbd>x_cube</kbd> that contain the squared and cubic values of the variable <kbd>x_val</kbd> , respectively. The variables <kbd>x_squared</kbd> and <kbd>x_cube</kbd> , will be deleted soon after the scope of the block.</p>
<p>The block where we declare the <kbd>z_val</kbd> variable has a semicolon at the last statement which assigns it to the value of <kbd>()</kbd>, suppressing the expression. We print out all the values in the end.</p>
<p>We print all the declared variables values in the end.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining constants</h1>
                </header>
            
            <article>
                
<p>Rust provides the ability to assign and maintain constant values across the code in Rust. These values are very useful when we want to maintain a global count, such as a timer threshold for example. Rust provides two <kbd>const</kbd> keywords to perform this activity. You will learn how to deliver constant values globally in this recipe.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Follow these steps:</span></p>
<ol>
<li>Create a file named <kbd>constant.rs</kbd> with the next code snippet.</li>
</ol>
<ol start="2">
<li>Declare the global <kbd>UPPERLIMIT</kbd> using <kbd>constant</kbd>:</li>
</ol>
<pre>        // Global variables are declared outside scopes of other <br/>        function<br/>        const UPPERLIMIT: i32 = 12;
</pre>
<ol start="3">
<li>Create the <kbd>is_big</kbd> function by accepting a single integer as input:</li>
</ol>
<pre>        // function to check if bunber <br/>        fn is_big(n: i32) -&gt; bool {<br/>          // Access constant in some function<br/>          n &gt; UPPERLIMIT<br/>        }
</pre>
<ol start="4">
<li>In the <kbd>main</kbd> function, call the <kbd>is_big</kbd> function and perform the decision-making statement:</li>
</ol>
<pre>        fn main() {<br/>          let random_number = 15;<br/><br/>          // Access constant in the main thread<br/>          println!("The threshold is {}", UPPERLIMIT);<br/>          println!("{} is {}", random_number, if<br/>          is_big(random_number) { "big" } else { "small"<br/>          });<br/><br/>          // Error! Cannot modify a `const`.<br/>          // UPPERLIMIT = 5;<br/><br/>        }
</pre>
<p style="padding-left: 60px"><span>You should get the following screenshot as output upon running the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="68" width="716" class="image-border" src="images/c60a17c8-d8fc-4ab2-8545-fa765521cbf9.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The workflow of the recipe is fairly simple, where we have a function to check whether an integer is greater than a fixed threshold or not. The <kbd>UPPERLIMIT</kbd> variable defines the fixed threshold for the function, which is a constant whose value will not change in the code and is accessible throughout the program.</p>
<p>We assigned <kbd>15</kbd> to <kbd>random_number</kbd> and passed it via <kbd>is_big (integer value);</kbd> and we then get a boolean output, either <kbd>true</kbd> or <kbd>false</kbd>, as the return type of the function is a <kbd>bool</kbd> type. The answer to our situation is <kbd>false</kbd> as <kbd>15</kbd> is not bigger than <kbd>12</kbd>, which the <kbd>UPPERLIMIT</kbd> value set as the constant. We performed this condition checking using the <kbd>if...else</kbd> statement in Rust.</p>
<p>We cannot change the <kbd>UPPERLIMIT</kbd> value; when attempted, it will throw an error, which is commented in the code section.</p>
<div class="packt_tip packt_infobox">Constants declare constant values. They represent a value, not a memory address: <kbd>type = value;</kbd></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performing variable bindings</h1>
                </header>
            
            <article>
                
<p>Variable binding refers to how a variable in the Rust code is bound to a type. We will cover pattern, mutability, scope, and shadow concepts in this recipe.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Perform the following step:</span></p>
<ol>
<li>Create a file named <kbd>binding.rs</kbd> and enter a code snippet that includes declaring the <kbd>main</kbd> function and different variables:</li>
</ol>
<pre>        fn main() {<br/>          // Simplest variable binding<br/>          let a = 5;<br/>          // pattern<br/>          let (b, c) = (1, 2);<br/>          // type annotation<br/>          let x_val: i32 = 5;<br/>          // shadow example<br/>          let y_val: i32 = 8;<br/>          {<br/>            println!("Value assigned when entering the <br/>            scope : {}", y_val); // Prints "8".<br/>            let y_val = 12;<br/>            println!("Value modified within scope :{}", y_val);<br/>            // Prints "12".<br/>          }<br/>          println!("Value which was assigned first : {}", y_val);<br/>          // Prints "8".<br/>          let y_val = 42;<br/>          println!("New value assigned : {}", y_val);<br/>          //Prints "42".<br/>        }
</pre>
<p style="padding-left: 60px"><span>You should get the following screenshot as output upon running the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="108" width="791" class="image-border" src="images/3ec9f244-b7ee-427e-910f-347cb826dc2b.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>let</kbd> statement is the simplest way to create a binding, where we bind a variable to a value, which is the case with variable <kbd>a</kbd>. To create a pattern with the <kbd>let</kbd> statement, we assign the pattern values to <kbd>b</kbd> and <kbd>c</kbd> values in the same pattern. Rust is a statically typed language. This means that we have to specify our types during an assignment, and at compile time, it is checked to see if it is compatible. Rust also has the type reference feature that identifies the variable type automatically at compile time. The <kbd>variable_name : type</kbd> is the format we use to explicitly mention the type in Rust. We read the assignment in the following format:</p>
<div class="packt_quote">x_val is a binding with the type i32 and the value 5.</div>
<p>Here, we declared <kbd>x_val</kbd> as a 32-bit signed integer. However, Rust has many different primitive integer types that begin with <kbd>i</kbd> for signed integers and <kbd>u</kbd> for unsigned integers, and the possible integer sizes are 8, 16, 32, and 64 bits.</p>
<p>Variable bindings have a scope that makes the variable alive only in the scope. Once it goes out of the scope, the resources are freed.</p>
<p>A block is a collection of statements enclosed by <kbd>{}</kbd>. Function definitions are also blocks! We use a block to illustrate the feature in Rust that allows variable bindings to be shadowed. This means that a later variable binding can be done with the same name, which in our case is <kbd>y_val</kbd>. This goes through a series of value changes, as a new binding that is currently in scope overrides the previous binding. Shadowing enables us to rebind a name to a value of a different type. This is the reason why we are able to assign new values to the immutable <kbd>y_val</kbd> variable in and out of the block.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performing type casting in Rust</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about casting between different data types in Rust. Rust does not provide an automatic type cast. The developer has to manually own it. Using as we will perform safe type casting in Rust.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Perform the f</span>ollowing steps:</p>
<ol>
<li>Create a file named <kbd>typecasting.rs</kbd> and enter the following code to the script:</li>
</ol>
<pre>        use std::{i32,f32};<br/><br/>        // Sample function for assigning values to<br/>        confusion matrix<br/>        fn main() {<br/> <br/>          // assigning random values to the confusion matrix<br/>          let(true_positive,true_negative,false_positive,<br/>          false_negative)=(100,50,10,5);<br/> <br/>          // define a total closure<br/>          let total = true_positive + true_negative +<br/>          false_positive + false_negative;<br/><br/>          println!("The total predictions {}",total);<br/> <br/>          // Calculating the accuracy of the model<br/>          println!("Accuracy of the model<br/>          {:.2}",percentage(accuracy(true_positive,<br/>          true_negative,total)));<br/><br/>        }
</pre>
<ol start="2">
<li>In the preceding code snippet, we created four variables: <kbd>true_positive</kbd>, <kbd>true_negative</kbd>, <kbd>false_positive</kbd>, and <kbd>false_negative</kbd>. These are basically the four measurement parameters of a confusion matrix.</li>
</ol>
<ol start="3">
<li>Call the <kbd>accuracy</kbd> and <kbd>percentage</kbd> function that returns the final accuracy percentage.</li>
<li>The <kbd>total</kbd> variable is the sum of all the measurements:</li>
</ol>
<pre>        // Accuracy Measures the overall performance of <br/>        the model<br/>        fn accuracy(tp:i32,tn:i32,total:i32) -&gt; f32 {<br/>          // if semi-colon is not put then that returns <br/>          // No automatic type cast in rust <br/>          (tp as f32 + tn as f32 )/(total as f32)<br/>        }<br/><br/>        // Converting to percentage <br/>        fn percentage(value:f32) -&gt; f32 {<br/>        value *100.0<br/>        }
</pre>
<ol start="5">
<li>The <kbd>accuracy</kbd> function accepts those which are all <kbd>int</kbd> data types that return a <kbd>float</kbd> data type.</li>
</ol>
<ol start="6">
<li>The value received from the <kbd>accuracy</kbd> function is passed to the <kbd>percentage</kbd> function and the <kbd>accuracy</kbd> is printed.</li>
</ol>
<p style="padding-left: 60px"><span>You should get the following screenshot as output upon running the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="62" width="673" class="image-border" src="images/84373cae-5155-4aff-a7bc-984bd5d2cbd2.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we have two functions, <kbd>accuracy</kbd> and <kbd>percentage</kbd>, which take in arguments from the <kbd>main</kbd> function and convert the type passed to the desired type, due to the nature of the arithmetic operations for which we use the <kbd>as</kbd> keywords in Rust which helps in type casting in Rust. In the case of the <kbd>accuracy</kbd> function, it takes three input arguments of type <kbd>i32</kbd> and returns a single <kbd>f32</kbd> type value.</p>
<p>In order to protect developers from accidental casts, Rust makes it mandatory for developers to convert data types manually. In the following example, we define an <kbd>int</kbd> variable named <kbd>a</kbd> and assign it the value <kbd>3</kbd>; after the assignment operation, we would see that a part of the code is commented. This implies that it won't be compiled by the Rust compiler. If we take a careful look at the code, we find that we are multiplying an <kbd>int</kbd> variable with a flat value, which will give us a type mismatch error during compilation:</p>
<div class="highlight">
<pre><span class="k">        let</span> <span class="n">a</span> <span class="o">=</span> 3<span class="p">;</span><br/><span class="cm">        /*</span><br/><span class="cm">        let b = a * 0.2; //Won't compile</span><br/><span class="cm">        */</span>
</pre>
</div>
<p>As we can see, we used the <kbd>as</kbd> keyword converting <kbd>int</kbd> to <kbd>float</kbd> (64-bit) in order to multiply an <kbd>int</kbd> value by a <kbd>float</kbd> variable. This step produced <kbd>b</kbd> without any error:</p>
<div class="highlight">
<pre><span class="k">        let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="k">as</span> <span class="k">f64</span> <span class="o">*</span> <span class="m">0.2</span><span class="p">;<br/></span>
</pre>
</div>
<div class="packt_infobox">Note that when we perform arithmetic operations in the same kind of data type, we don't have to worry about type conversion as the result of the operation produced is automatically typecasted.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Decision-making with Rust</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn about decision-making statements in Rust. Condition checking in Rust is similar to other dynamic programming languages and is very easy to use. Using <kbd>if...else</kbd> statements, we will perform condition checking in Rust.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Perform the f</span>ollowing steps:</p>
<ol>
<li>Create a file named <kbd>condition.rs</kbd> and enter the following code to the script:</li>
</ol>
<pre>        use std::{i32};<br/>        fn main() {<br/>          let age : i32= 10;<br/>          // If else statements<br/>          if age &lt;= 18{<br/>            println!("Go to School");<br/>          } else if (age &gt;18) &amp;&amp; (age &lt;= 28){<br/>          println!("Go to college");<br/>        } else {<br/>          println!("Do something with your life");<br/>        }<br/> <br/>        // if/ else statement in one line<br/>        let can_vote = if (age &gt;= 18) {true} else<br/>        {false};<br/>        println!("Can vote {}",can_vote );<br/>        }
</pre>
<ol start="2">
<li>Create a variable named <kbd>age</kbd> and assign it to an integer with the value <kbd>10</kbd>.</li>
<li>The preceding code has an <kbd>if...else</kbd> statement to make a decision about the <kbd>age</kbd> value. It performs print operations based on the conditions.</li>
</ol>
<p style="padding-left: 60px">You should get the following screenshot as output upon running the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/d86289f0-d256-4aaf-a32c-fc91cc7e3e28.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we implemented an <kbd>if...else</kbd> statement to perform conditional statements in Rust. The conditions are performed in the <kbd>age</kbd> variable. In this recipe, we assigned an immutable variable taking the value <kbd>10</kbd>; after this, we compared it with various rules and performed an action based on the qualifying rule.</p>
<p>These rules are the conditions that the developer generates in the form of a mathematical operation that yields a result of <kbd>true</kbd> or <kbd>false</kbd>. Based on the output of the operation, we select a particular set of actions inside the scope of the decision statement.</p>
<div class="packt_tip">The <kbd>if...else</kbd> statements are a great tool for developers to route the program logic. They are ideal for comparing thresholds at the end state of the application for making a logical decision.</div>
<p>In the preceding case, we checked three cases in the following flow:</p>
<ul>
<li>
<div class="CDPAlignLeft CDPAlign">The <kbd>if</kbd> statement checks whether the <kbd>age</kbd> variable is less than <kbd>18</kbd>. If the operation returns <kbd>true</kbd>, then we go ahead and print <kbd>Go to School</kbd>.</div>
</li>
<li>The next condition is checked in the <kbd>else...if</kbd> statement when the first condition returns <kbd>false</kbd>; here we check whether the age is between <kbd>18</kbd> and <kbd>28</kbd>, and if this condition returns <kbd>true</kbd>, we print <kbd>Go to college</kbd>.</li>
<li>Lastly, we have the <kbd>else</kbd> statement, which has no condition and is executed only when all the preceding conditions fail.</li>
</ul>
<p>It's often a very important skill to write in a very optimized manner. We should learn the ability to develop the skill of writing less and optimized code.</p>
<p>The preceding set of statements contains a lot of lines of code, but we can write it in an optimized way, where we would have the <kbd>if...else</kbd> statement along with the condition in a single line. The general syntax for this case is as follows:</p>
<pre>    let variable = if (condition 1 ) {true} else {false};
</pre>
<p>We have a variable to which we assign the <kbd>if</kbd> the <kbd>condition 1</kbd> operation produces <kbd>true</kbd>; alternatively, we assign the value from the <kbd>else</kbd> statement.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Looping operations in Rust</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, you will learn about looping</span> <span>statements</span> <span>in Rust. Looping statements that we are referring to in Rust provide interactive functionality. Using the <kbd>loop</kbd>, <kbd>while</kbd></span>, <span>and <kbd>for</kbd></span> <span>keywords, we can perform iterative operations in Rust.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Perform the f</span>ollowing steps:</p>
<ol>
<li>Create a file named <kbd>looping.rs</kbd> and enter the following code in the script.</li>
<li>In the <kbd>main</kbd> function, perform a looping operation on the mutable variable <span><span><kbd>x</kbd></span></span>, which is initially assigned to the integer value of <kbd>1</kbd>.</li>
<li>Define a <kbd>loop</kbd> statement, which is an infinite iterative statement, and check the various conditions inside its scope:</li>
</ol>
<pre>        fn main() {<br/> <br/>          // mutuable variable whose value can be changed<br/>          let mut x =1;<br/>          println!(" Loop even numbers ");<br/> <br/>          // Continously loops <br/>          loop {<br/>            // Check if x is an even number or not<br/>            if (x % 2 == 0){<br/>              println!("{}",x);<br/>              x += 1;<br/>              // goes to the loop again<br/>              continue;<br/>            }<br/>            // exit if the number is greater than 10<br/>            if (x &gt; 10) {<br/>            break;<br/>          }<br/>          // increment the number when not even<br/>          x+=1;<br/>        }
</pre>
<ol start="4">
<li>Create a mutable variable <kbd>y</kbd> and assign it to the integer value <kbd>1</kbd> , and define a <kbd>while</kbd> loop with the <kbd>y &lt; 10</kbd> condition:</li>
</ol>
<pre>        let mut y = 1;<br/>         // while loop<br/>         println!("while 1 to 9 ");<br/>         while y &lt; 10 {<br/>         println!("{}",y );<br/>         y +=1;<br/>         }
</pre>
<ol start="5">
<li>Perform a similar operation as for the <kbd>while</kbd> loop. Here, use the <kbd>for</kbd> loop to iterate over the 1 to 9 range on the mutable variable <kbd>z</kbd>, which is initially assigned to the value <kbd>1</kbd>:</li>
</ol>
<pre>        let mut z = 1;<br/>         //for loop <br/>         println!(" For 1 to 9");<br/>         for z in 1 .. 10 {<br/>         println!("{}",z );<br/>         }<br/>        }
</pre>
<p style="padding-left: 60px"><span>You should get the following screenshot as output upon running the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="458" width="716" class="image-border" src="images/8a27d1e7-4a2a-4ab8-b357-e5de211f1e5c.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>loop</kbd> is an iterative keyword in Rust where the statements inside its scope run forever, that is, indefinitely, unless they are explicitly stopped by the <kbd>break</kbd> statement. This is very useful when we want a process a particular task in an application until it reaches a particular state for further processing. Consider a video storage application where I want to continuously save the camera feeds until the users give a command to stop the application.</p>
<p>In this recipe, we declared a mutable <kbd>int</kbd> variable <kbd>x</kbd>, which we initialized with the value <kbd>1</kbd>. When it enters the <kbd>loop</kbd> statement, we had two conditions for it. The first condition prints the value of <kbd>x</kbd>. Only when it is an even number, we use the <kbd>%</kbd> operator to perform this divisibility operation, followed by an increase in the value.</p>
<p>Then we used the <kbd>continue</kbd> keyword, which goes back to the <kbd>loop</kbd>. The preceding statements of the keyword will not be executed. The second condition checks whether the value of <kbd>x</kbd> is greater than <kbd>10</kbd>. This condition will only be reached at runtime. When the value of <kbd>x</kbd> is odd in this case, we break the <kbd>loop</kbd>, which is the exit point of the infinite loop, which is similar to the case of the stop button in the video application discussed in the preceding example. Next, we increase the value of the next iteration.</p>
<p>While printing <kbd>1</kbd> to <kbd>9</kbd> in two different ways, the first method uses <kbd>while</kbd>, where we have a condition placed which is at first compared to the loop that does not have a condition. All the while, the loop checks the condition at every iteration. Only if it is <kbd>true</kbd>, it proceeds. In the preceding case, we had an immutable variable <kbd>y</kbd>, which was initialized with the value <kbd>1</kbd>. We had a condition which checks whether <kbd>y</kbd> is less than <kbd>10</kbd> at every iteration. In each iteration, we print the value of <kbd>y</kbd> and increase its value by <kbd>1</kbd>.</p>
<p>The second way to do the preceding activity is by using the <kbd>for</kbd> looping statement, where we specify a range of values in which we want to operate. We don't have any explicit condition checking, as in the case of other looping statements. We declared an immutable variable <kbd>z</kbd>, which was initialized to the value <kbd>1</kbd> and then iterated from <kbd>1</kbd> to <kbd>10</kbd> in the loop where we print the value in every step.</p>
<p>Looping statements are really handy to the developer when there is a requirement to perform a particular task repeatedly in the application.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining the enum type</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about using the <kbd>enum</kbd> type in Rust. In Rust, the <kbd>enum</kbd> type lets the developer represent data in multiple formats, and each format can optionally have specific data associated with it. Using <span><span><kbd>enum</kbd></span></span> keywords, we perform iterative operations in Rust.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Perform the f</span><span>ollowing steps:</span></p>
<ol>
<li>Create a file named <kbd>enum.rs</kbd> and enter the following code in the script:</li>
</ol>
<pre>        fn main() {<br/> <br/>         let hulk = Hero::Strong(100);<br/>         let fasty = Hero::Fast;<br/>         //converting from <br/>         let spiderman = Hero::Info<br/>        {name:"spiderman".to_owned(),secret:"peter<br/>        parker".to_owned()};<br/>        get_info(spiderman);<br/>        get_info(hulk);<br/>        get_info(fasty);<br/>        }
</pre>
<ol start="2">
<li>Declare an <kbd>enum</kbd> date type, namely <kbd>Hero</kbd>:</li>
</ol>
<pre>        // declaring the enum <br/>        enum Hero {<br/>        Fast,<br/>        Strong(i32),<br/>        Info {name : String, secret : String}<br/>        }
</pre>
<ol start="3">
<li>Create a function named <kbd>get_info</kbd> that will take the <kbd>enum</kbd> data type as an argument:</li>
</ol>
<pre>        // function to perform for each types<br/>        fn get_info(h:Hero){<br/>        match h {<br/>        Hero::Fast =&gt; println!("Fast"),<br/>        Hero::Strong(i) =&gt; println!("Lifts {} tons",i ),<br/>        Hero::Info {name,secret} =&gt; { println!(" name is: {0} secret is<br/>        : {1}", name,secret);} ,<br/>        }<br/>       }
</pre>
<p style="padding-left: 60px"><span>You should get the following screenshot as output upon running the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="86" width="710" class="image-border" src="images/a1c20210-9c79-42b3-b994-1c5b4250d9e0.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>enum</kbd> is a very important Rust type as it allows a particular data type to be associated with multiple data variants. A value of an <kbd>enum</kbd> type contains information about which data variant it is associated with.</p>
<p><span>Another important point to note about <kbd>enum</kbd> in Rust before moving to the code explanation is you can use the</span> <kbd>::</kbd> <span>syntax in order</span> to use the name of each data variant and assign values to the variables.</p>
<p>In the recipe, we created an <kbd>enum</kbd> type <kbd>Hero</kbd>, which has three types of data variants: <kbd>Fast</kbd>, which is not specified with explicit data requirements; <kbd>Strong(i32)</kbd>, which requires a 32-bit integer input; and <kbd>Info</kbd>, which supports two string data variables, <kbd>name</kbd> and <kbd>secret</kbd>.</p>
<p>Next up, let's check out the initialization of these data variants in the <kbd>main</kbd> function. Here, we have created three variables that represent the three data variants and initialized them with the required data requirement. We also called the <kbd>get_info()</kbd> function three times by passing different <kbd>enum</kbd> data variants to print the data values.</p>
<p>The is initialized with the <kbd>Hero::Strong(100)</kbd> <kbd>enum</kbd> type, <kbd>fasty</kbd> with <kbd>Hero::Fast</kbd>, and <kbd>spiderman</kbd> with <kbd>Hero::Info</kbd>, which requires two variables: <kbd>name:"spiderman".to_owned()</kbd> and <kbd>secret:"peter parker".to_owned()</kbd>.</p>
<div class="packt_infobox">Note that while declaring the values to <kbd>Hero</kbd> data variant <kbd>Info</kbd> , we assigned data variables with strings along with <kbd>.to_owned()</kbd> method, this is done in order to ensure the string is owned when borrowed, as <kbd>&amp;str</kbd> is an immutable reference to a string and using <kbd>to_owned()</kbd> turns it into a string that we own.</div>
<p>The <kbd>get_info(argument : enum type)</kbd> function takes the <kbd>enum</kbd> as the data type, and when we pass each of the different data variants, the arguments are assigned with those values. Then we used the <kbd>match</kbd> statement, which is a decision-making statement, to compare the argument with the different types of data variants mentioned as the different cases in the <kbd>match</kbd> statement.</p>
<p>We passed the fast variable, which is of the type <kbd>Fast</kbd>--variant of <kbd>Hero</kbd>--and it will print <kbd>Fast</kbd>, which is the first case of the <kbd>match</kbd> statement. Similarly, for the <kbd>spiderman</kbd> case and <kbd>hulk</kbd>, which are of the types <kbd>Info</kbd> and <kbd>Strong</kbd>, respectively, the corresponding statement in the match of the <kbd>get_info</kbd> function will be executed.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining closures</h1>
                </header>
            
            <article>
                
<p>At an uber level, closures are similar to functions, and calling a closure is exactly like a function. Closures are similar to <strong>lambdas</strong>, which are basically functions that operate over the variables in a closed scope.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Perform the f</span><span>ollowing steps:</span></p>
<ol>
<li>Create a file named <kbd>closures.rs</kbd> and enter the following code in the script:</li>
</ol>
<pre>        use std::{i32};<br/>        fn main() {
</pre>
<ol start="2">
<li>Define a closure and name it <kbd>sum_num</kbd>:</li>
</ol>
<pre>        // define a closure<br/>        let sum_num = |x:i32 , y:i32| x+y;<br/>        println!("7 + 8 ={}", sum_num(7,8));
</pre>
<ol start="3">
<li>Create another closure, namely <kbd>add_ten</kbd>:</li>
</ol>
<pre>        // example 2<br/>         let num_ten = 10;<br/>         let add_ten = |x:i32| x+num_ten;<br/>         println!("3 + 10 ={}", add_ten(3));<br/>        }
</pre>
<p style="padding-left: 60px"><span>We should get the following screenshot as output upon running the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="62" width="715" class="image-border" src="images/a0fb5d91-5cf4-456f-9a4a-f4c4b37f9058.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>An important thing about a closure is that it's bound or its operations are within a scope where it is defined. It is similar to a function that uses the free variable in the environment of its operation.</p>
<div class="packt_tip">Closures are great ways to write mathematical operations. If the developer is working on Rust to speed up the mathematical computation of the application, then the developer can maintain closures in his or her code for different equations for better optimization, code debugging, and benchmarking.</div>
<p>In this recipe, we created two closures in the <kbd>main</kbd> function. The basic way to create a simple closure is to have a variable assigned to an operation, before in which we could declare the variable types in the pipe symbol in a <kbd>let</kbd> statement. The first closure is named <kbd>sum_num</kbd>, which basically adds two numbers and returns an integer output as the two variables it uses, namely <kbd>x</kbd> and <kbd>y</kbd>, which are 32-bit integers. The second closure <kbd>add_ten</kbd> adds a fixed integer value of <kbd>10</kbd> to the integer that is passed to the closure. Calling a closure is similar to that of a function. The convention is to call the name of the closure followed by the parameters to be passed to the closure operation. In this recipe, we called <kbd>sum_num(7,8)</kbd>, which gave the output of <kbd>15</kbd> at runtime and <kbd>add_ten(3)</kbd>, which produced <kbd>13</kbd>.</p>
<p>&#160;</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performing pointer operations in Rust</h1>
                </header>
            
            <article>
                
<p>Rust provides different smart pointers. These are different types of pointers used in Rust for different use cases, but <kbd>&amp;mut T</kbd> is a mutable (exclusive) reference that is one of the operations.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Perform the f</span><span>ollowing steps:</span></p>
<ol>
<li>Create a file named <kbd>pointer.rs</kbd> and enter the following code in the script:</li>
</ol>
<pre>        use std::{i32};<br/>        fn main() {
</pre>
<ol start="2">
<li>Create a vector named <kbd>vect1</kbd> and assign it to <kbd>vec![1,2,3]</kbd>:</li>
</ol>
<pre>        let vect1 = vec![1,2,3];<br/> <br/>         // Error in case you are doing this in case of non primitive<br/>         value<br/>         // let vec2 = vec1<br/>         // println!("vec1[0] : {:?}", vec1[0]);<br/> <br/>         let prim_val = 1;<br/>         let prim_val2 = prim_val;<br/>         println!("primitive value :- {}", prim_val);
</pre>
<ol start="3">
<li>Pass <kbd>&amp;vect1</kbd> to the <kbd>sum_vects()</kbd> function:</li>
</ol>
<pre>         // passing the ownership to the function<br/>         println!("Sum of vects : {}", sum_vects(&amp;vect1));<br/>         // Able to pass the non primitive data type<br/>         println!("vector 1 {:?}", vect1);<br/>        }
</pre>
<ol start="4">
<li>Perform summation operations for each value of the vector:</li>
</ol>
<pre>         // Added a reference in the argument<br/>         fn sum_vects (v1: &amp;Vec&lt;i32&gt;) -&gt; i32 {<br/>         // apply a closure and iterator<br/>         let sum = v1.iter().fold(0, |mut sum, &amp;x | {sum += x; sum});<br/>         return sum;<br/>        }
</pre>
<p style="padding-left: 60px"><span>You should get the following screenshot as output upon running the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="84" width="702" class="image-border" src="images/9acfd557-9eb0-44fd-929f-794bcd5f3112.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Ownership and borrowing are the main concepts on which Rust is built, and the standard APIs given by Rust are based on this concept. In the preceding snippet, we created a vector, namely <kbd>vect1</kbd>, and assigned it <kbd>1,2,3</kbd> using the <kbd>vec!</kbd> keyword.</p>
<p>Note that a vector is a non-primitive value. Vectors cannot be reused after, as shown in the commented section of the code. The compiler will throw an error saying that <kbd>vect1</kbd> is a moved value and cannot be used. This is the case when we assign <kbd>vect1</kbd> to <kbd>vect2</kbd> and try to assign <kbd>vect1</kbd> to the print statement.</p>
<p>In the <kbd>sum_vects(&amp;vect1)</kbd> function, we passed the ownership of <kbd>vect1</kbd> to the <kbd>sum_vector</kbd> function, which iterates through each of the objects of the vector and produces the sum. Note that we passed <kbd>vect1</kbd> with a <kbd>&amp;</kbd> symbol. This way, we shared the vector as a reference or pointer, but if we had passed it as <kbd>&amp;mut vect1</kbd>, then the function would have had the ability to mutate or make changes in the values of the vector. We verify this by printing <kbd>vect1</kbd> after processing it from the <kbd>sum_vects</kbd> function, which still yields the same result.</p>
<p>In <kbd>sum_vects(&amp;vect1)</kbd>, we had <kbd>v1</kbd>, which is the argument to which <kbd>vect1</kbd> is moved to. The vector has a method from the standard APIs that allows the <kbd>iter</kbd> function to read one data object from the zero position.</p>
<div class="packt_infobox">The <kbd>fold()</kbd> function takes two arguments: an initial value and a closure. The closure again takes two arguments: an accumulator and an element. The closure returns the value that the accumulator should have for the next iteration.</div>
<p>Here the accumulator is <kbd>sum</kbd> and the element is <kbd>x</kbd>, which is added to <kbd>sum</kbd> in every iteration. Note that <kbd>x</kbd> being mutable in the definition of the closure can change the values in the scope of its operation. This is stored in the <kbd>sum</kbd> variable and returned to the <kbd>main</kbd> function.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining your first user-defined data type</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about structs, which is a way in which you can create complex data types in Rust. Using <kbd>struct</kbd>, we will define user-defined data types in Rust.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Perform the f</span><span>ollowing steps:</span></p>
<ol>
<li>Create a file named <kbd>struct.rs</kbd> and enter the following code in the script:</li>
</ol>
<pre>        use std::{f64};<br/>        fn main() {<br/> <br/>        // create a struct variable<br/>         let mut circle1 = Circle {<br/>         x:10.0,radius : 10.0<br/>         };<br/><br/>        // print radius and variable x<br/>        println!("x:{},radius : {}", circle1.x,<br/>        circle1.radius );<br/>        println!("Radius : {}", get_radius(&amp;circle1) );<br/>        }
</pre>
<ol start="2">
<li>Create a <kbd>struct</kbd> named <kbd>Circle</kbd> with two parameters, namely <kbd>x</kbd> and <kbd>radius</kbd>:</li>
</ol>
<pre>        // define your custom user data type<br/>        struct Circle {<br/>        x : f64,<br/>        radius : f64,<br/>        }
</pre>
<ol start="3">
<li>Define a function <kbd>get_radius</kbd> by accepting <kbd>Circle</kbd> as a user-defined data type:</li>
</ol>
<pre>        // get radius function <br/>        fn get_radius(c1 : &amp;Circle) -&gt; f64{ <br/>        c1.radius <br/>        }
</pre>
<p style="padding-left: 60px"><span>You should get the following screenshot as output upon running the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="65" width="705" class="image-border" src="images/47f4eac1-b057-433f-b3c0-5a7b344aeded.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>At some point of the product development life cycle, developers often have too many variables to handle and the code becomes really complex. This is where structs appear as a big savior. Structs enable developers to create complex data types, where they allow the unification of multiple data types under a single name.</p>
<p>In this recipe, we created a custom data type named <kbd>Circle</kbd>, which has two labels <kbd>radius</kbd> and <kbd>x</kbd> of the type <kbd>f64</kbd>, which is a 64-bit <kbd>float</kbd> type. Both the parameters here are related to the <kbd>Circle</kbd> data type and uniquely express their features.</p>
<div class="packt_infobox">Consider use cases such as database management, machine learning models, and so on, where the developer has to handle multiple variables conveying the property of a single task/entity. Structs, in these cases, are great tools to utilize for making the code more optimized and modular. This makes the life of a developer easy; we can debug errors easily and scale up features on requests of the application/product.</div>
<p>We use the <kbd>struct</kbd> keyword to create a user-defined data type, where the custom name is provided after the keyword but along with the types of the different labels or variables it uses.</p>
<p>In the <kbd>main</kbd> function, we initialized a mutable variable <kbd>circle1</kbd> of the user-defined data type <kbd>Circle</kbd> and populated it with its required values, which are <kbd>10.0</kbd> for <kbd>radius</kbd> and <kbd>10.0</kbd> for <kbd>x</kbd>. We did this to access the variable in the scope of the program. We get the value by calling the variable name label we require, that is, we get the value of the assigned values by calling <kbd>circle1.x</kbd> and <kbd>circle.radius</kbd>.</p>
<p>We pass the reference of <kbd>circle1</kbd> to <kbd>get_radius</kbd>, where we have an argument <kbd>c1</kbd> of the data type <kbd>Circle</kbd> from which we get the radius of <kbd>c1.radius</kbd>. Then, we call the function with <kbd>get_radius(&amp;circle1)</kbd> to get the value.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding functionality to the user-defined data type</h1>
                </header>
            
            <article>
                
<p>You will learn about performing method calls using the <kbd>impl</kbd> keyword in Rust, which helps in adding functionality to a user-defined data type. In this recipe, the <kbd>impl</kbd> block helps us create the methods.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Perform the f</span><span>ollowing steps:</span></p>
<ol>
<li>Create a file named <kbd>implement.rs</kbd> and enter the following code in the script:</li>
</ol>
<pre>        use std::{f64};<br/><br/>        fn main() {<br/>         // create a struct variable<br/>         let mut circle1 = Circle {<br/>         x:10.0,radius : 10.0<br/>         };<br/>        println!("x:{},radius : {}", circle1.x,<br/>        circle1.radius );<br/>        println!("x : {}", circle1.get_x());<br/>        }
</pre>
<ol start="2">
<li>Create a <kbd>struct</kbd> named <kbd>Circle</kbd> with two parameters, <kbd>x</kbd> and <kbd>radius</kbd>:</li>
</ol>
<pre>        // define your custom user data type<br/>        struct Circle {<br/>         x : f64,<br/>         radius : f64,<br/>        }
</pre>
<ol start="3">
<li>Create the <kbd>get_x</kbd> method for the user-defined <kbd>Circle</kbd> data type:</li>
</ol>
<pre>        // recommended way of creating structs<br/>         impl Circle {<br/>         // pub makes this function public which makes it <br/>         accessible outsite the scope {}<br/>         pub fn get_x(&amp;self) -&gt; f64 {<br/>         self.x<br/>         }<br/>        }
</pre>
<p style="padding-left: 60px"><span>You should get the following screenshot as output upon running the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/fa90b058-9448-4244-b5a4-bf1aaf568991.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, we created a custom data type named</span> <kbd>Circle</kbd>, <span>which has two labels:</span> <kbd>radius</kbd> <span>and</span> <kbd>x</kbd> <span>of the type</span> <kbd>f64</kbd>, <span>which is a 64-bit <kbd>float</kbd> type. Both the parameters here are related to the</span> <kbd>Circle</kbd> <span>data type and uniquely express its features.</span></p>
<p><span>In the</span> <kbd>main</kbd> <span>function, we initialized a mutable variable</span> <kbd>circle1</kbd> <span>of the user-defined data type</span> <kbd>Circle</kbd> <span>and populated it with its required values, which are</span> <kbd>10.0</kbd> <span>for</span> <kbd>radius</kbd> <span>and</span> <kbd>10.0</kbd> <span>for</span> <kbd>x</kbd><span>. To access the variable in the scope of the program, we get the value by calling the variable name label we require, that is, we get the value of the assigned values by calling</span> <kbd>circle1.x</kbd> <span>and</span> <kbd>circle.radius</kbd>.</p>
<p>But, we went ahead and created unique functionalities for each data type so that they can perform a unique operation on the labels associated with them; this eliminates the need to pass argument values to externally created functions. We used <kbd>impl</kbd> to achieve this method call, where we defined functionalities for the data type.</p>
<p>This feature allows the developer to call functions of the data type using <kbd>datatype_name.function1().function2()</kbd>, which reduces the function call complexity and delivers optimized code.</p>
<p>In the <kbd>main</kbd> function, we call <kbd>circle1.get_x()</kbd> to get the value of the <kbd>x</kbd> value. If you closely observe the <kbd>impl</kbd> code part of <kbd>Circle</kbd>, you'll notice we passed <kbd>&amp;self</kbd> to the <kbd>get_x()</kbd> method, which is a reference to the circle label's data type.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Similar functionality for different data type</h1>
                </header>
            
            <article>
                
<p>You will learn about the <kbd>trait</kbd> feature of Rust in this recipe is similar to <kbd>impl</kbd>, which helps the developer make a method call of the user-defined data type. However, <kbd>trait</kbd> provides many more features, such as inheritance and control, over the functionality that the user-defined data type provides.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Perform the f</span><span>ollowing steps:</span></p>
<ol>
<li>Create a file named <kbd>trait.rs</kbd> and enter the following code in the script:</li>
</ol>
<pre>        use std::{f64};<br/>        fn main() {<br/>        // variable of circle data type<br/>         let mut circle1 = Circle {<br/>         r : 10.0<br/>         };<br/>         println!("Area of circle {}", circle1.area() );<br/> <br/>         // variable of rectangle data type<br/>         let mut rect = Rectangle {<br/>         h:10.0,b : 10.0<br/>         };<br/>         println!("Area of rectangle {}", rect.area() );<br/>         }
</pre>
<ol start="2">
<li>Create a <kbd>struct</kbd> named <kbd>Rectangle</kbd> with the parameters <kbd>h</kbd> and <kbd>b</kbd>, both 64-bit <kbd>float</kbd> data types:</li>
</ol>
<pre>        // userdefined data type rectangle<br/>        struct Rectangle {<br/>         h: f64,<br/>         b: f64,<br/>        }
</pre>
<ol start="3">
<li>Create a <kbd>struct</kbd> named <kbd>Circle</kbd> with the parameter <kbd>r</kbd>, which is a 64-bit <kbd>float</kbd> data type:</li>
</ol>
<pre>        // userdefined data type circle<br/>        struct Circle {<br/>         r: f64,<br/>        }
</pre>
<ol start="4">
<li>Create a <kbd>trait</kbd> named <kbd>HasArea</kbd> with the <kbd>area</kbd> functionality:</li>
</ol>
<pre>        // create a functionality for the data types <br/>        trait HasArea {<br/>         fn area(&amp;self) -&gt; f64;<br/>        }
</pre>
<ol start="5">
<li>Define the <kbd>area</kbd> function for the <kbd>Circle</kbd> <span>user-defined</span> data type:</li>
</ol>
<pre>        // implement area for circle<br/>        impl HasArea for Circle {<br/>         fn area(&amp;self) -&gt; f64 {<br/>         3.14 * (self.r *self.r)<br/>         }<br/>        }
</pre>
<ol start="6">
<li>Define the <kbd>area</kbd> function for the <kbd>Rectangle</kbd> user-defined data type:</li>
</ol>
<pre>        // implement area for rectangle<br/>        impl HasArea for Rectangle {<br/>         fn area(&amp;self) -&gt; f64 {<br/>         self.h *self.b<br/>         }<br/>        }<br/><br/>
</pre>
<p style="padding-left: 60px"><span>You should get the following output upon running the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="62" width="644" class="image-border" src="images/721561fa-e66f-461c-8d4a-8583ec482b3e.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we applied all the concepts that we learned in the previous ones. We created two <kbd>struct</kbd> types: <kbd>Circle</kbd> with a <kbd>radius</kbd> of f64 and <kbd>Rectangle</kbd> with the parameters <kbd>h</kbd> and <kbd>b</kbd> of f64. Then, we created the <kbd>area</kbd> functionality for each <kbd>struct</kbd> data type that operates on the data of the labels, as they are referenced by <kbd>self</kbd>.</p>
<p>The function definition of both user-defined data types is different in terms of the mathematical operation. We defined the data type <kbd>Circle</kbd> and <kbd>Rectangle</kbd> in the <kbd>main</kbd> function. We called the functions in real time by <kbd>Circle.area()</kbd> and <kbd>Rectangle.area()</kbd>.</p>
<p>Here, we observe that both data types provide a similar kind of functionality; this is where the <kbd>trait</kbd> comes into place. It basically tells the compiler the functionality that a particular function would use, so we implement the <kbd>trait</kbd>. For the data type in this recipe, we have a <kbd>trait</kbd> named <kbd>HasArea</kbd>, which contains only the signature of the function that is inside the scope, which contains the output that is returned and the reference which was passed as the argument. In this recipe, we had a signature of <kbd>fn area(&amp;self) -&gt; f64;</kbd>, which indicated the output of the computation in a 64-bit <kbd>float</kbd> type. The function operates by taking a reference to the label and values of the data type.</p>


            </article>

            
        </section>
    </div>
</body>
</html>