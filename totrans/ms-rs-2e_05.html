<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Memory Management and Safety</h1>
                </header>
            
            <article>
                
<p>Memory management is a fundamental concept to understand for anyone working with a low-level programming language. Low-level languages don't come with automatic memory reclamation solutions like a built-in garbage collector, and it's the responsibility of the programmer to manage memory that's used by the program. Having knowledge of where and how memory gets used in a program enables programmers to build efficient and safe software systems. A lot of bugs in low-level software are due to improper handling of memory. At times, it's the programmer's mistake. The other times, it's the side effect of the programming language used, such as C and C++, which are infamous for a lot of memory vulnerability reports in software. Rust offers a better, compile-time solution to memory management. It makes it hard to write software that leaks memory unless you explicitly intend to! Programmers who have done a fair amount of development with Rust eventually come to the realization that it discourages bad programming practices and directs the programmer toward writing software that uses memory safely and efficiently.</p>
<p>In this chapter, we go into the nitty-gritty details of how Rust tames the memory that's used by resources in a program. We'll give a brief introduction to processes, memory allocation, memory management, and what we mean by memory safety. Then, we'll go through the memory safety model provided by Rust and understand the concepts that enable it to track memory usage at compile time. We'll see how traits are used to control where types reside in memory and when they get freed. We'll also delve into various smart pointer types that provide abstractions to manage resources in the program.</p>
<p>The topics that are covered in this chapter are as follows:</p>
<ul>
<li>Programs and memory</li>
<li>Memory allocations and safety</li>
<li>Memory management</li>
<li>Stack and Heap</li>
<li>Trifecta of safety—Ownership, borrowing, and lifetimes</li>
<li>Smart pointer types</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Programs and memory</h1>
                </header>
            
            <article>
                
<div class="packt_quote">"If you’re willing to restrict the flexibility of your approach, you can almost always do something better."</div>
<p class="CDPAlignRight CDPAlign"><span>– <em>John Carmack</em></span></p>
<p>As a motivation to understand memory and its management, it's important for us to have a general idea of how programs are run by the operating system and what mechanisms are in place that allow it to use memory for its requirements.</p>
<p>Every program needs memory to run, whether it's your favorite command-line tool or a complex stream processing service, and they have vastly different memory requirements. In major operating system implementations, a program in execution is implemented as a process. A process is a running instance of a program. When we execute <kbd>./my_program</kbd> in a shell in Linux or double-click on <kbd>my_program.exe</kbd> on Windows<em>,</em> the OS loads <kbd>my_program</kbd> as a process in memory and starts executing it, along with other processes, giving it a share of CPU and memory. It assigns the process with its own virtual address space, which is distinct from the virtual address space of other processes and has its own view of memory.</p>
<p>During the lifetime of a process, it uses many system resources. First, it needs memory to store its own instructions, then it needs space for resources that are demanded at runtime during instruction execution, then it needs a way to keep track of function calls, any local variables, and the address to return to after the last invoked function. Some of these memory requirements can be decided ahead at compile time, like storing a primitive type in a variable, while others can only be satisfied at runtime, like creating a dynamic data type such as <kbd>Vec&lt;String&gt;</kbd>. Due to the various tiers of memory requirements, and also for security purposes, a process's view of memory is divided into regions known as the memory layout.</p>
<p>Here, we have an approximate representation of the memory layout of a process in general:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3559bb5d-de6f-4448-8dd8-e2e9d4a4e2e7.png" style="width:35.25em;height:29.33em;"/></p>
<p class="mce-root"/>
<p>This layout is divided into various regions based on the kind of data they store and the functionality they provide. The major parts we are concerned with are as follows:</p>
<ul>
<li><strong>Text segment</strong>: This section contains the actual code to be executed in the compiled binary. The text segment is a read-only segment and any user code is forbidden to modify it. Doing so can result in a crash of the program.</li>
<li><strong>Data segment</strong>: This is further divided into subsections, that is, the initialized data segment and uninitialized data segment, which is historically known as <strong>Block Started by Symbol (BSS)</strong>, and holds all global and static values declared in the program. Uninitialized values are initialized to zero when they are loaded into memory.</li>
<li><strong>Stack segment</strong>: This segment is used to hold any local variables and the return addresses of functions. All resources whose sizes are known in advance and any temporary/intermediary variables that a program creates are implicitly stored on the stack.</li>
<li><strong>Heap segment</strong>: This segment is used to store any dynamically allocated data whose size is not known up front and can change at runtime depending on the needs of the program. This is the ideal allocation place when we want values to outlive their declaration within a function.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How do programs use memory?</h1>
                </header>
            
            <article>
                
<p>So, we know that a process has a chunk of memory dedicated for its execution. But, how does it access this memory to perform its task? For security purposes and fault isolation, a process is not allowed to access the physical memory directly. Instead, it uses a virtual memory, which is mapped to the actual physical memory by the OS using an in-memory data structure called <strong>pages</strong>, which are maintained in <strong>page tables</strong>. The process has to request memory from the OS for its use, and what it gets is a virtual address that is internally mapped to a physical address in the RAM. For performance reasons, this memory is requested and processed in chunks. When virtual memory is accessed by the process, the memory management unit does the actual conversion from virtual to physical memory.</p>
<p>The whole series of steps through which memory is acquired by a process from the OS is known as <strong>memory allocation</strong>. A process requests a chunk of memory from the OS by using <em>system calls</em>, and the OS marks that chunk of memory in use by that process. When the process is done using the memory, it has to mark the memory as free so other processes can use it. This is called <strong>de-allocation</strong> of memory. Major operating system implementations provide abstractions through system calls (such as <kbd>brk</kbd> and <kbd>sbrk</kbd> in Linux), which are functions that talk directly to the OS kernel and can allocate memory requested by the process. But these kernel-level functions are very low-level, so they are further abstracted by system libraries such as the <strong>glibc</strong> library, which is C's standard library in Linux including the implementation of the POSIX APIs, facilitating low-level interactions with the OS from the C language.</p>
<div class="packt_infobox">POSIX is an acronym for Portable Operating System Interface, a term coind by Richard Stallman. It is a set of standards that emerged with the need to standardize what functionality, a Unix-like operating system should provide, what low level APIs they should expose to languages such as C, what command-line utilities they should include, and many other aspects.</div>
<p>Glibc also provides a memory allocator API, exposing functions such as <kbd>malloc</kbd>, <kbd>calloc</kbd>, and <kbd>realloc</kbd> for allocating memory and the <kbd>free</kbd> function for de-allocating memory. Even though we have a fairly high-level API for allocating/de-allocating memory, we still have to manage memory ourselves when using low-level programming languages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory management and its kinds</h1>
                </header>
            
            <article>
                
<p>The RAM in your computer is a limited resource and is shared by all running programs. It's a necessity that when a program is done executing its instructions, it is expected to release any memory <span>used</span><span> </span><span>so that the OS can reclaim it and hand it to other processes. When we talk about memory management, a prominent aspect we care about is the reclamation of used memory and how that happens. The level of management required in deallocating used memory is different in different languages. Up until the mid-1990s, the majority of programming languages relied on manual memory management, which required the programmer to call memory allocator APIs such as</span> <kbd>malloc</kbd> <span>and</span> <kbd>free</kbd> <span>in code to allocate and deallocate memory, respectively. Around 1959,</span> <em>John McCarthy</em><span>, the creator of</span> <em>Lisp,</em> <span>invented</span> <strong>Garbage Collectors</strong> <span>(</span><strong>GC</strong><span>), a form of automatic memory management and Lisp was the first language to use one. A GC runs as a daemon thread as part of the running program</span> and analyzes the memory that <span>is no longer being referenced by any variable in the program and frees it automatically at certain points in time along with program execution.</span></p>
<p>However, low-level languages don't come with a GC as it introduces non-determinism and a runtime overhead due to the GC thread running in the background, which in some cases pauses the execution of the program. This pause sometimes reaches to a milisecond of latency. This might violate the hard time and space constraints of system software. Low-level languages put the programmer in control of managing memory manually. However, languages such as C++ and Rust take some of this burden off from programmers, through type system abstractions like smart pointers, which we'll cover later in the chapter.</p>
<p>Given the difference between languages, we can classify the memory management strategies that are used by them into three buckets:</p>
<ul>
<li><strong>Manual</strong>: <em>C</em> has this form of memory management, where it's completely the programmers responsibility to put <kbd>free</kbd> calls after the code is done using memory. C++ automates this to some extent using smart pointers where the <kbd>free</kbd> call is put in a class's deconstructor method definition. Rust also has smart pointers, which we will cover later in this chapter.</li>
<li><strong>Automatic</strong>: Languages with this form of memory management include an additional runtime thread,that is the Garbage Collector, that runs alongside the program as a daemon thread. Most dynamic languages based on a virtual machine such Python, Java, C# and Ruby rely on automatic memory management. Automatic memory management is one of the reasons that writing code in these languages is easy.</li>
<li><strong>Semi-automatic</strong>: Languages such as Swift fall into this category. They don't have a dedicated GC built in as part of the runtime, but offer a reference counting type, which does automatic management of memory at a granular level. Rust also provides <span>the </span>reference counting types <kbd>Rc&lt;T&gt;</kbd> and <kbd>Arc&lt;T&gt;</kbd>. We'll get to them when we explain about <em>smart pointers,</em> later in this chapter.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Approaches to memory allocation</h1>
                </header>
            
            <article>
                
<p>At runtime, memory allocations in a process happens either on the <em>stack</em> or on the <em>heap</em>. They are storage locations that are used to store values during the execution of the program. In this section, we'll take a look at both of these allocation approaches.</p>
<p>The stack is used for short-lived values whose sizes are known as compile time, and is the ideal storage location for function calls and their associated context, which needs to go away once the function returns. The heap is for anything that needs to live beyond function calls. As mentioned in <a href="d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml">Chapter 1</a>, <em>Getting Your Feet Wet</em>, Rust prefers stack allocation by default. Any value or instance of a type that you create and bind to a variable gets stored on the stack by default. Storing on the heap is explicit and is done by using smart pointer types, which are explained later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The stack</h1>
                </header>
            
            <article>
                
<p>Any time we call a function or a method, the stack is used for allocating space for values that are created within the function. All of the <kbd>let</kbd> bindings in your functions are stored in the stack, either as values themselves or as pointers to memory locations on the heap. These values constitute the <strong>stack frame</strong> for the active function. A stack frame is a logical block of memory in the stack that stores the context of a function call. This context may include function arguments, local variables, return addresses, and any saved register's values that need to be restored after returning from the function. As more and more functions get called, their corresponding stack frames are pushed onto the stack. Once a function returns, the stack frame corresponding to the function goes away, along with all values declared within that frame.</p>
<p>These values are removed in the reverse order of their declaration, following the <strong>Last In First Out</strong> (<strong>LIFO</strong>) order.</p>
<p>Allocation on the stack is fast because allocating and deallocating memory here requires just one CPU instruction: incrementing/decrementing the stack frame pointer. The stack frame pointer (<kbd>esp</kbd>) is a CPU register that always points to the top of the stack. The stack frame pointer keeps on updating as functions get called, or when they return. When a function returns, its stack frame is discarded by restoring the stack frame pointer to where it was before entering the function. Using stacks is a temporary memory allocation strategy, but it is reliable in terms of releasing used memory because of its simplicity. However, the same property of a stack makes it unsuitable for cases where we need longer living values beyond the current stack frame.</p>
<p>Here's a piece of code to roughly illustrate how the stack gets updated in a program during function calls:</p>
<pre>// stack_basics.rs<br/><br/>fn double_of(b: i32) -&gt; i32 {<br/>    let x = 2 * b;<br/>    x<br/>}<br/><br/>fn main() {<br/>    let a = 12;<br/>    let result = double_of(a);<br/>}</pre>
<p>We'll represent the state of the stack for this program by an empty array <kbd>[]</kbd>. Let's explore the stack contents by doing a dry run of this program. We'll use <kbd>[]</kbd> to also represent stack frames within our parent stack. When this program is run, the following are the sequence of steps that happens:</p>
<ol>
<li>When the <kbd>main</kbd> function is invoked, it creates the stack frame, which holds <kbd>a</kbd>  and <kbd>result</kbd> (initialized to zero). The stack is now <kbd>[[a=12, result=0]]</kbd>.</li>
<li>Next, the <kbd>double_of</kbd> function is called and a new stack frame is push onto the stack to hold its local values. The stack's contents is now <kbd>[[a=12, result=0], [b=12, temp_double=2*x, x=0]]</kbd>. <kbd>temp_double</kbd> is a temporary variable that's created by the compiler to store the result of <kbd>2 * x</kbd>, which is then assigned to the <kbd>x</kbd> that's variable declared within the <kbd>double_of</kbd> function. This <kbd>x</kbd> is then returned to the caller, which is our <kbd>main</kbd> function.<kbd><br/></kbd></li>
</ol>
<ol start="3">
<li>Once <kbd>double_of</kbd> returns, its stack frame is popped off the stack and the stack contents are now <kbd>[[a=12, result=24]</kbd>.</li>
<li>Following that, <kbd>main</kbd> ends and its stack frame is popped out, leaving the stack empty: <kbd>[]</kbd>.<kbd><br/></kbd></li>
</ol>
<p>There are more details to this, though. We just gave a very high level overview of a function call and its interaction with the stack memory. Now, if all we had were local values staying valid only for the lifetime of the function call, it would be very limiting. While the stack is simple and powerful, to be practical, a program also needs longer-living variables, and for that we need the heap.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The heap</h1>
                </header>
            
            <article>
                
<p>The heap is for the more complicated and dynamic memory allocation requirements. A program might allocate on the heap at some point and may release it at some other point, and there need not be a strict boundary between these points, as is the case with stack memory. In the case of stack allocation, you get deterministic allocation and deallocation of values. Also, a value in the heap may live beyond the function where it was allocated and it may later get deallocated by some other function. In that case, the code fails to call <kbd>free</kbd>, so it may not get deallocated at all, which is the worst case.</p>
<p>Different languages use the heap memory differently. In dynamic languages such as Python<em>,</em> everything is an object and they are allocated on the heap by default. In C, we allocate memory on the heap using manual <kbd>malloc</kbd> calls, while in C++, we allocate using the <kbd>new</kbd> keyword. To deallocate memory, we need to call free in C and delete in C++. In C++, to avoid manual <kbd>delete</kbd> calls, programmers often use smart pointer types such as <kbd>unique_ptr</kbd> or <kbd>shared_ptr</kbd>. These smart pointer types have deconstructor methods, which get invoked when they go out of scope internally, calling <kbd>delete</kbd>. This paradigm of managing memory is called the RAII principle, and was popularized by C++.</p>
<div class="packt_infobox">RAII stands for Resource Acquisition Is Initialization; a paradigm suggesting that resources must be acquired during initialization of objects and must be released when they are deallocated or their destructors are called.</div>
<p>Rust also has similar abstractions to how C++ manages heap memory. Here, the only way to allocate memory on the heap is through smart pointer types. Smart pointer types in Rust implement the <kbd>Drop</kbd> trait, which specifies how memory used by the value should be deallocated, and are semantically similar to deconstructor methods in C++. Unless someone writes their own custom smart pointer type, you never need to implement <kbd>Drop</kbd> on their types. More on the <kbd>Drop</kbd> trait in a separate section.</p>
<p>To allocate memory on the heap, languages rely on dedicated memory allocators, which hide all the low-level details like allocating memory on aligned memory, maintaining free chunks of memory to reduce system call overheads, and reducing fragmentation while allocating memory and other optimizations. For compiling programs, the compiler rustc itself uses the jemalloc allocator, whereas the libraries and binaries that are built from Rust use the system allocator. On Linux, it would be the glibc memory allocator APIs. Jemalloc is an efficient allocator library for use in multithreaded environments and it greatly reduces the build time of Rust programs. While jemalloc is used by the compiler, it's not used by any applications that are built with Rust because it increases the size of the binary. So, compiled binaries and libraries always use the system allocators by default.</p>
<p>Rust also has a pluggable allocator design, and can use the system allocator or any user implemented allocator that implements the <kbd>GlobalAlloc</kbd> trait from the <kbd>std::alloc</kbd> module. This is often implemented by the <kbd>#[global_allocator]</kbd> attribute, which can be put on any type to declare it as an allocator.</p>
<p><strong>Note</strong>: If you have a use case where you want to use the jemalloc crate for your programs too, you can use the <a href="https://crates.io/crates/jemallocator">https://crates.io/crates/jemallocator</a> crate.</p>
<p>In Rust, most dynamic types with sizes not known in advance are allocated on the heap. This excludes primitive types. For instance, creating a <kbd>String</kbd> internally allocates on the heap:</p>
<pre>let s = String::new("foo");</pre>
<p><kbd>String::new</kbd> allocates a <kbd>Vec&lt;u8&gt;</kbd> on the heap and returns a reference to it. This reference is bound to the <span>variable <kbd>s</kbd>,</span><span> </span><span>which is allocated on the stack. The string in the heap lives for as long as</span> <kbd>s</kbd> <span>is in scope. When</span> <kbd>s</kbd> <span>goes out of scope, the</span> <kbd>Vec&lt;u8&gt;</kbd> <span>is deallocated from the heap and its</span> <kbd>drop</kbd> <span>method is called as part of the </span><kbd>Drop</kbd> <span>implementation. For rare cases where you need to allocate a primitive type on <span>the </span>heap, you can use the</span> <kbd>Box&lt;T&gt;</kbd> <span>type, which is a generic smart pointer type.</span></p>
<p>In the next section, let's look at the pitfalls <span>when using a language such as C that doesn't have all the comforts of automatic memory management.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory management pitfalls</h1>
                </header>
            
            <article>
                
<p>In languages with a GC, dealing with memory is abstracted away from the programmer. You declare and use the variables in your code, and how they get deallocated is an implementation detail you don't have to worry about. A low-level system programming language such as C/C++, on the other hand, does nothing to hide these details from the programmer, and provides nearly no safety. Here, programmers are given the responsibility of deallocating memory via manual free calls. Now, if we look at the majority of  <strong>Common Vulnerabilities &amp; Exposure</strong> (<strong><span>CVEs</span></strong>) in software related to memory management, it shows that we humans are not very good at this! Programmers can easily create hard-to-debug errors by allocating and deallocating values in the wrong order, or may even forget to deallocate used memory, or cast pointers illegally. In C, nothing stops you from creating a pointer out of an integer and dereferencing it somewhere, only to see the program crash later. Also, it's quite easy to create vulnerabilities in C because of the minimal compiler checks.</p>
<p>The most concerning case is freeing heap allocated data. The heap memory is to be used with care. Values in the heap can possibly live forever during the lifetime of the program if not freed, and may eventually lead to the program being killed by the <strong>Out Of Memory</strong> (<strong><span>OOM</span></strong>) killer in the kernel. At runtime, a bug in the code or mistake from the developer can also cause the program to either forget to free the memory, or access a portion of memory that is outside the bounds of its memory layout, or dereference a memory address in the protected code segment. When this happens, the process receives a trap instruction from the kernel, which is what you see as a <kbd>segmentation fault</kbd> error message, followed by the process getting aborted. As such, we must ensure that processes and their interactions with memory need to be safe! Either we as programmers need to be critically aware of our <kbd>malloc</kbd> and <kbd>free</kbd> calls, or use a memory safe language to handle these details for us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory safety</h1>
                </header>
            
            <article>
                
<p>But what do we mean by a program being memory safe? Memory safety is the idea that your program never touches a memory location it is not supposed to, and that the variables declared in your program cannot point to invalid memory and remain valid in all code paths. In other words, safety basically boils down to pointers having valid references all of the time in your program, and that the operations with pointers do not lead to undefined behavior. Undefined behavior is the state of a program where it has entered a situation that has not been accounted for in the compiler's because the compiler specification does not clarify what happens in that situation.</p>
<p>An example of undefined behavior in C is accessing out of bound and uninitialized array elements:</p>
<pre>// uninitialized_reads.c<br/><br/>#include &lt;stdio.h&gt;<br/>int main() { <br/>    int values[5]; <br/>    for (int i = 0; i &lt; 5; i++) <br/>        printf("%d ", values[i]); <br/>}</pre>
<p>In the preceding code, we have an array of 5 elements and we loop and print the values in the array. Running this program with <kbd>gcc -o main uninitialized_reads.c &amp;&amp; ./main</kbd> gives me the following output:</p>
<pre>4195840 0 4195488 0 609963056</pre>
<p>On your machine, this could print any value, or might even print an address of an instruction, which can be exploited. This is an undefined behavior where anything can happen. Your program might crash immediately, which is the best case scenario as you get to know it then and there. It may also continue to work, clobbering any internal state of the program that might later give faulty outputs from the application.</p>
<p>Another example of memory safety violation is the iterator invalidation problem in C++:</p>
<pre>// iterator_invalidation.cpp<br/><br/>#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/><br/>int main() {   <br/>    std::vector &lt;int&gt; v{1, 5, 10, 15, 20}; <br/>    for (auto it=v.begin();it!=v.end();it++) <br/>        if ((*it) == 5) <br/>            v.push_back(-1); <br/>  <br/>    for (auto it=v.begin();it!=v.end();it++) <br/>        std::cout &lt;&lt; (*it) &lt;&lt; " "; <br/>          <br/>    return 0;     <br/>}</pre>
<p>In this C++ code, we create a vector of integers <kbd>v</kbd> and we are trying to iterate using an iterator called  <kbd>it</kbd> in the <kbd>for</kbd> loop. The problem with the preceding code, is that we have an <kbd>it</kbd><span> </span><span>iterator pointer</span> <span>to</span> <kbd>v</kbd><span>, while at the same time we iterate and push to</span> <kbd>v</kbd><span>.</span></p>
<p><span>Now, because of the way vectors are implemented, they internally reallocate to some other place in memory if their size reaches their capacity. When this happens, this would render the</span> <kbd>it</kbd> <span>pointer pointing to some garbage value, which is called the iterator invalidation problem, because the pointer is now pointing to invalid memory.</span></p>
<p>Another example of memory unsafety are buffer overflows in C. The following is a simple piece of code to demonstrate this idea:</p>
<pre>// buffer_overflow.c<br/><br/>int main() { <br/>     char buf[3]; <br/>     buf[0] = 'a'; <br/>     buf[1] = 'b'; <br/>     buf[2] = 'c'; <br/>     buf[3] = 'd'; <br/>}</pre>
<p>This compiles fine and even runs without errors, but the last assignment went over the allocated buffer and might have overwritten other data or instructions in the address. Also, <span>specially crafted malicious input values, adapted to the architecture and environment, could yield arbitrary code execution.</span> These kind of errors have happened in actual code in less obvious ways and has led to vulnerabilities affecting businesses worldwide. On recent versions of gcc compilers, this is detected as a stack smash attack where gcc halts the program by sending a <kbd>SIGABRT</kbd> (abort) signal. </p>
<p>Memory safety bugs lead to memory leaks, hard crashes in the form of segmentation faults, or in the worst case, security vulnerabilities. To create correct and safe programs in C, a programmer has to be discrete in correctly placing <kbd>free</kbd> calls when they are done using the memory. Modern C++ safeguards against some of the problems associated with manual memory management by providing smart pointer types, but this does not completely eliminate them. Languages based on virtual machines (Java's JVM being the most prominent example) use garbage collection to eliminate whole classes of memory safety issues. While Rust doesn't have a built-in GC, it relies on the same RAII built into the language and makes freeing used memory automatic for us based on the scope of variables and is much more safer than C or C++. It provides us with several fine-grained abstractions that you can choose according to your needs and pay only for what you use. To see how all of this works in Rust, let's explore the principles that helps Rust provide compile-time memory management to programmers.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trifecta of memory safety</h1>
                </header>
            
            <article>
                
<p>The concepts that we will explore next are the core tenets of Rust's memory safety and its zero cost abstraction principle. They enable Rust to detect memory safety violations in a program at compile time, provide automatic freeing of resources when their scope ends, and much more. We call these concepts ownership, borrowing, and lifetimes. Ownership is kind of like the core principle, while borrowing and lifetimes are type system extensions to the language, enforcing and sometimes relaxing the ownership principle in different contexts in code to ensure compile-time memory management. Let's elaborate on these ideas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ownership</h1>
                </header>
            
            <article>
                
<p>The notion of a true owner of a resource in a program differs across languages. Here, by resource, we collectively refer to any variable holding a value on the heap or the stack, or a variable holding an open file descriptor, a database connection socket, a network socket, and similar things. All of them occupy some memory from the time they exist until the time they are done being used by the program. An important responsibility of being the owner of a resource is to judiciously free the memory used by them, as not being able to perform deallocations at proper places and times can lead to memory leaks.</p>
<p>When programming in dynamic languages such as Python, it's fine to have multiple owners or aliases to a <kbd>list</kbd> object where you can add to or remove items from the list using one of the many variables pointing to the object. The variables don't need to care about freeing the memory used by the object because the GC takes care of this and will free the memory once all references to the object are gone.</p>
<p>For compiled languages such as C/C++, before smart pointers were a thing, libraries had an opinionated take on whether the callee or the caller of an API was responsible for deallocating the memory after the code is done with a resource. These opinions existed because ownership is not enforced by the compiler in these languages. There's still a possibility of goofing up by not using smart pointers in C++. It's totally fine in C++ to have more than one variable pointing to a value on the heap (though we advise against it), and that is called <em>aliasing</em>. The programmer runs into all sorts of ill effects with the flexibility of having multiple pointers or aliases to a resource, one being the iterator invalidation problem in C++, which we explained previously. Specifically, problems arise when there is at least one mutable alias to a resource among other immutable aliases in a given scope.</p>
<p class="mce-root"/>
<p>Rust, on the other hand, tries to bring proper semantics regarding the ownership of values in a program. The ownership rule of Rust states the following principles:</p>
<ul>
<li>When you create a value or a resource using the <kbd>let</kbd> statement and assign it to a variable, the variable becomes the owner of the resource</li>
<li>When the value is reassigned from one variable to another, the ownership of the value moves to the other variable and the older variable becomes invalid for further use</li>
<li>The value and the variable are deallocated at the end of their scope</li>
</ul>
<p class="mce-root">The takeaway is that values in Rust have a single owner, that is, the variables that created them. The principle is quite simple, but the implications of it are what surprises programmers coming from other languages. Consider the following code, which demonstrates the ownership principle in its most basic form:</p>
<pre>// ownership_basics.rs<br/><br/>#[derive(Debug)]<br/>struct Foo(u32);<br/><br/>fn main() {<br/>    let foo = Foo(2048);<br/>    let bar = foo;<br/>    println!("Foo is {:?}", foo);<br/>    println!("Bar is {:?}", bar);<br/>}</pre>
<p>We create two variables, <kbd>foo</kbd> and <kbd>bar</kbd>, that points to a <kbd>Foo</kbd> instance. As someone familiar with mainstream imperative languages that allow multiple owners to a value, we expect this program to compile just fine. But in Rust, we get the following error upon compilation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8bc1cf49-e912-4ef6-b405-b0c62ce4b96c.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here, we created a <kbd>Foo</kbd> instance and assigned it to the <kbd>foo</kbd><span> </span><span>variable</span><span>. According to the ownership rule, </span><kbd>foo</kbd> <span>is now the owner of the</span> <kbd>Foo</kbd> <span>instance. In the next line, we then assign</span> <kbd>foo</kbd> <span>to</span> <kbd>bar</kbd><span>. On executing the second line in</span> <kbd>main</kbd><span>, </span> <kbd>bar</kbd> <span>becomes the new owner of <span>the </span></span><kbd>Foo</kbd> <span>instance and the older</span> <kbd>foo</kbd> <span>is now an abandoned variable, which cannot be used anywhere after the move. This is evident from the</span> <kbd>println!</kbd> <span>call on the third line. Rust moves values pointed to by a variable by default any time we assign it to some other variable or read from the variable. The ownership rule prevents you from having multiple points of access for modifying the value, which can lead to use after free situations, even in single threaded contexts with languages that permit multiple mutable aliases for values. The classic example is the iterator invalidation problem in C++. Now, to analyze when a value goes out of scope, the ownership rule also takes into account the scope of variables. Let's understand scopes next.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A brief on scopes</h1>
                </header>
            
            <article>
                
<p>Before we go further into ownership, we need to get a brief idea of scopes, which might be familiar to you already if you know C, but we'll recap it here in <span>the </span>context of Rust, as ownership works in tandem with scopes. So, a scope is nothing but an environment where variables and values come into existence. Every variable you declare is associated with a scope. Scopes are represented in code by braces <kbd>{}</kbd>. A scope is created whenever you use a <em>block expression</em>, that is, any expression that starts and ends with braces <kbd>{}</kbd>. Also, scopes can nest within each other and can access items from the parent scope, but not the other way around.</p>
<p>Here's some code that demonstrates multiple scopes and values:</p>
<pre>// scopes.rs<br/><br/>fn main() { <br/>    let level_0_str = String::from("foo"); <br/>    {  <br/>        let level_1_number = 9; <br/>        { <br/>            let mut level_2_vector = vec![1, 2, 3];<br/>            level_2_vector.push(level_1_number);    // can access<br/>        } // level_2_vector goes out of scope here <br/><br/>        level_2_vector.push(4);    // no longer exists<br/>    } // level_1_number goes out of scope here<br/>} // level_0_str goes out of scope here</pre>
<p>To help with this explanation, will assume that our scopes are numbered, starting from <kbd>0</kbd>. With this assumption, we have created variables that have the <kbd>level_x</kbd> prefix in their name. Let's run through the preceding code, line by line. As functions can create new scopes, the <kbd>main</kbd> function introduces a root scope level 0 with a <kbd>level_0_str</kbd> defined within it. Inside the level 0 scope, we create a new scope, level 1<em>,</em> with a bare block <kbd>{}</kbd>, which contains the variable <kbd>level_1_number</kbd>. Within level 1, we create another block expression, which becomes level 2 scope. In level 2, we declare another variable, <kbd>level_2_vector</kbd>, to which we push <kbd>level_1<em>_</em>number</kbd>, which comes from the parent scope,that is, level 1. Finally, when the code reaches the end of <kbd>}</kbd>, all of the values get destructed and the respective scopes come to an end. Once the scope ends, we cannot use any values defined within them.</p>
<p>Scopes are an important property to keep in mind when reasoning about the ownership rule. They are also used to reason about borrowing and lifetimes, as we'll see later. When a scope ends, any variable that owns a value runs code to deallocate the value and itself becomes invalid for use outside the scope. In particular, for heap allocated values, a <kbd>drop</kbd> method is placed right before the end of <span>the </span>scope <kbd>}</kbd>. This is akin to calling <span>the </span><kbd>free</kbd> function in C, but here it's implicit and saves the programmer from forgetting to deallocate values. The <kbd>drop</kbd> method comes from the <kbd>Drop</kbd> trait, which is implemented for most heap allocated types in Rust and makes automatic freeing of resources a breeze.</p>
<p class="mce-root">Having learned about scopes, let's look at an example similar to the one we previously saw in <kbd>ownership_basics.rs</kbd>, but this time, let's use a primitive value:</p>
<pre>// ownership_primitives.rs<br/><br/>fn main() {<br/>    let foo = 4623;<br/>    let bar = foo;<br/>    println!("{:?} {:?}", foo, bar); <br/>}</pre>
<p>Try compiling and running this program. You might be in for a surprise as this program compiles and runs just fine. What gives? In the program, the ownership of <kbd>4623</kbd> does not move from <kbd>foo</kbd> to <kbd>bar</kbd>, but <kbd>bar</kbd> gets a separate copy of <kbd>4623</kbd>. It appears that primitive types are treated specially in Rust, where they get copied instead of moved. This means that there are different semantics of ownership depending on what types we use in Rust, which brings us to the concept of move and copy semantics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Move and copy semantics</h1>
                </header>
            
            <article>
                
<p>In Rust, variable bindings have move semantics by default. But what does this really mean? To understand that, we need to think about how variables are used in a program. We create values or resources and assign them to variables to easily refer to them later in our program. These variables are names that point to the memory location where the value resides. Now, operations with variables such as reading, assignment, addition, passing them to functions, and so on can have different semantics or meaning around how the value being pointed to by the variable is accessed. In statically typed languages, these semantics are broadly classified as move semantics and copy semantics. <span>Let's define both.</span></p>
<p><strong>Move semantics</strong>: A value that gets moved to the receiving item when accessed through a variable or reassigning to a variable exhibits move semantics. Rust has move semantics  by default due to its <strong>affine type system</strong>. A highlighting part of affine type systems is that values or resources can only be used once, and Rust exhibits this property with the ownership rule.</p>
<p><strong>Copy semantics</strong>: A value that gets copied (as in a bitwise copy) by default when assigned or accessed through a variable or passed to/returned from a function exhibits copy semantics. This means that the value can be used any number of times and each value is completely new.</p>
<p>These semantics are familiar to people from the C++ community. C++ has copy semantics by default. Move semantics were <span>added</span><span> </span><span>later with the C++11 release.</span></p>
<p>Move semantics in Rust can be limiting at times. Fortunately, a type's behavior can be changed to follow copy semantics by implementing the <kbd>Copy</kbd> trait. This is implemented by default for primitives and other stack-only data types and is the reason why the previous code using primitives works. Consider the following snippet that tries to make a type <kbd>Copy</kbd> explicitly:</p>
<pre>// making_copy_types.rs<br/><br/>#[derive(Copy, Debug)]<br/>struct Dummy;<br/><br/>fn main() {<br/>    let a = Dummy;<br/>    let b = a;<br/>    println!("{}", a);<br/>    println!("{}", b);<br/>}</pre>
<p>On compiling this, we get the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/328db879-eb70-45cd-9a36-380ac8399a6e.png" style="width:48.83em;height:12.42em;"/></p>
<p>Interesting! It appears that <kbd>Copy</kbd> depends on the <kbd>Clone</kbd> trait. This is because <kbd>Copy</kbd> is defined in the standard library as follows:</p>
<pre>pub trait Copy: Clone { }</pre>
<p><kbd>Clone</kbd> is a super trait of <kbd>Copy</kbd>, and any type implementing <kbd>Copy</kbd> must also implement <kbd>Clone</kbd>. We can make this example compile by adding the <kbd>Clone</kbd> trait beside <kbd>Copy</kbd> in the derive annotation:</p>
<pre>// making_copy_types_fixed.rs<br/><br/>#[derive(Copy, Clone, Debug)]<br/>struct Dummy;<br/><br/>fn main() {<br/>    let a = Dummy;<br/>    let b = a;<br/>    println!("{}", a);<br/>    println!("{}", b);<br/>}</pre>
<p>The program works now. But it's not quite clear of the differences between <kbd>Clone</kbd> and <kbd>Copy</kbd>. Let's differentiate them next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Duplicating types via traits</h1>
                </header>
            
            <article>
                
<p>The <kbd>Copy</kbd> and <kbd>Clone</kbd> traits convey the idea of how types gets duplicated when they are used in code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Copy</h1>
                </header>
            
            <article>
                
<p>The <kbd>Copy</kbd> trait is usually implemented for types that can be completely represented on the stack. This is to say that they don't have any part of themselves that lives on the heap. If that were the case, <kbd>Copy</kbd> would be a heavy operation as it would also have to go down the heap to copy the values. It directly affects how the <kbd>=</kbd> <span>assignment</span><span> </span><span>operator works. If a type implements</span> <kbd>Copy</kbd><span>, an assignment from one variable to another would copy the data implicitly.</span></p>
<p><kbd>Copy</kbd> is an auto trait that is implemented automatically on most stack data types such as primitives and immutable references, that is, <kbd>&amp;T</kbd>.  The way <kbd>Copy</kbd> duplicates types is very similar to how the  <kbd>memcpy</kbd> function works in C, which is used to copy values bitwise. <kbd>Copy</kbd> for user-defined types is not implemented by default as Rust wants to be explicit about copying and the developer has to opt in to implement the trait. <kbd>Copy</kbd> also depends on the <kbd>Clone</kbd> trait when anyone wants to implement <kbd>Copy</kbd> on their types.</p>
<p>Types that don't implement <kbd>Copy</kbd> are <kbd>Vec&lt;T&gt;</kbd>, <kbd>String</kbd>, and mutable references. To make copies of these values, we use the more explicit <kbd>Clone</kbd> trait.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clone</h1>
                </header>
            
            <article>
                
<p>The <kbd>Clone</kbd> trait is for explicit duplication and comes with a <kbd>clone</kbd> <span>method</span><span> </span><span>that a type can implement to obtain a copy of itself. The</span> <kbd>Clone</kbd> <span>trait is defined like so:</span></p>
<pre>pub trait Clone {<br/>    fn clone(&amp;self) -&gt; Self;<br/>}</pre>
<p>It has a method called <kbd>clone</kbd> that takes an immutable reference to the receiver, that is, <kbd>&amp;self</kbd>, and returns a new value of the same type. User defined types or any wrapper types that need to provide the ability to duplicate themselves should implement the <kbd>Clone</kbd> trait by implementing the <kbd>clone</kbd> method.</p>
<p>But unlike <kbd>Copy</kbd> types where assignment implicitly copies the value, to duplicate a <kbd>Clone</kbd> value, we have to explicitly call the <kbd>clone</kbd> method. The <kbd>clone</kbd> method is a more general duplication mechanism and <kbd>Copy</kbd> is a special case of it, which is always a bitwise copy. Items such as <kbd>String</kbd> and <kbd>Vec</kbd> that are heavy to copy, <span>only </span>implements  the <kbd>Clone</kbd> trait. Smart pointer types also implement the <kbd>Clone</kbd> trait where they just copy the pointer and extra metadata such as the reference count while pointing to the same heap data.</p>
<p>This is one of those examples of being able to decide how we want to copy types, and the <kbd>Clone</kbd> trait gives us that flexibility.</p>
<p>Here's a program that demonstrates using <kbd>Clone</kbd> to duplicate a type:</p>
<pre>// explicit_copy.rs<br/><br/>#[derive(Clone, Debug)]<br/>struct Dummy {<br/>    items: u32<br/>}<br/><br/>fn main() {<br/>    let a = Dummy { items: 54 };<br/>    let b = a.clone();<br/>    println!("a: {:?}, b: {:?}", a, b);<br/>}</pre>
<p>We added a <kbd>Clone</kbd> in the derive attribute. With that, we can call <kbd>clone</kbd> on <kbd>a</kbd>  to get a new copy of it.</p>
<p>Now, you are probably wondering when you should one implement either of these types. The following are a few guidelines.</p>
<p>When to implement <kbd>Copy</kbd> on a type:</p>
<p>Small values that can be represented solely in the stack as follows:</p>
<ul>
<li>If the type depends only on other types that have <kbd>Copy</kbd> implemented on them; the <kbd>Copy</kbd> trait is implicitly implemented for it.</li>
<li>The <kbd>Copy</kbd> trait implicitly affects how the assignment operator <kbd>=</kbd> works. The decision on whether to make your own externally visible types using the <kbd>Copy</kbd> trait requires some consideration due to how it affects the assignment operator. If at an early point of development your type is a <kbd>Copy</kbd> and you remove it afterwards, it affects every point where values of that type are assigned. You can easily break an API in that manner.</li>
</ul>
<p>When to implement <kbd>Clone</kbd> on a type:</p>
<ul>
<li>The <kbd>Clone</kbd> trait merely declares a <kbd>clone</kbd> method, which needs to be called explicitly.</li>
<li>If your type also contains a value on the heap as part of its representation, then opt for implementing <kbd>Clone</kbd>, which makes it explicit to users that will also be cloning the heap data.</li>
<li>If you are implementing a smart pointer type such as a reference counting type, you should implement <kbd>Clone</kbd> on your type to only copy the pointers on the stack.</li>
</ul>
<p>Now that we know the basics of <kbd>Copy</kbd> and <kbd>Clone</kbd>, let's move on to see how ownership affects various places in code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ownership in action</h1>
                </header>
            
            <article>
                
<p>Apart from the <kbd>let</kbd> binding example, there are other places where you will find ownership in effect, and it's important to recognize these and the errors the compiler gives us.</p>
<p><strong>Functions:</strong> If you pass parameters to functions, the same ownership rules are in effect:</p>
<pre>// ownership_functions.rs<br/><br/>fn take_the_n(n: u8) { }<br/><br/>fn take_the_s(s: String) { }<br/><br/>fn main() { <br/>    let n = 5; <br/>    let s = String::from("string"); <br/><br/>    take_the_n(n); <br/>    take_the_s(s); <br/><br/>    println!("n is {}", n); <br/>    println!("s is {}", s); <br/>} </pre>
<p>The compilation fails in a similar way:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ef35f1ee-f850-4a2a-962e-100f6db2e38b.png"/></p>
<p><kbd>String</kbd> does not implement the <kbd>Copy</kbd> trait, so the ownership of the value is moved inside the <kbd>take_the_s</kbd> function. When that function returns, the scope of the value comes to an end and <kbd>drop</kbd> is called on <kbd>s</kbd>, which frees the heap memory used by <kbd>s</kbd>. Therefore, <kbd>s</kbd> cannot be used after the function call anymore. However, since <kbd>String</kbd> implements <kbd>Clone</kbd>, we can make our code work by adding a <kbd>.clone()</kbd> call at the function call site:</p>
<pre>take_the_s(s.clone());</pre>
<p>Our <kbd>take_the_n</kbd> works fine as <kbd>u8</kbd> (a primitive type) implements <kbd>Copy</kbd>.</p>
<p>This is to say that, after passing move types to a function, we cannot use that value later. If you want to use the value, we must clone the type and send a copy to the function instead. Now, if we only need read access to variable <kbd>s</kbd>, another way we could have made this code work is by passing the string <kbd>s</kbd> back to main. This looks something like this:</p>
<pre>// ownership_functions_back.rs<br/><br/>fn take_the_n(n: u8) { }<br/><br/>fn take_the_s(s: String) -&gt; String {<br/>    println!("inside function {}", s);<br/>    s<br/>}<br/><br/>fn main() { <br/>    let n = 5; <br/>    let s = String::from("string"); <br/><br/>    take_the_n(n); <br/>    let s = take_the_s(s); <br/><br/>    println!("n is {}", n); <br/>    println!("s is {}", s); <br/>} </pre>
<p>We added a return type to our <kbd>take_the_s</kbd> function and return the passed string <kbd>s</kbd> back to the caller. In <kbd>main</kbd>, we receive it in <kbd>s</kbd>. With this, the last line of code in <kbd>main</kbd> works.</p>
<p><strong>Match expressions:</strong> Within a match expression, a move type is also moved by default, as shown in the following code:</p>
<pre>// ownership_match.rs<br/><br/>#[derive(Debug)]<br/>enum Food {<br/>    Cake,<br/>    Pizza,<br/>    Salad<br/>}<br/><br/>#[derive(Debug)]<br/>struct Bag {<br/>    food: Food<br/>}<br/><br/>fn main() {<br/>    let bag = Bag { food: Food::Cake };<br/>    match bag.food {<br/>        Food::Cake =&gt; println!("I got cake"),<br/>        a =&gt; println!("I got {:?}", a)<br/>    }<br/>    <br/>    println!("{:?}", bag);<br/>}</pre>
<p>In the preceding code, we create a <kbd>Bag</kbd> instance and assign it to <kbd>bag</kbd>. Next, we match on its <kbd>food</kbd> field and print some text. Later, we print the <kbd>bag</kbd> with <kbd>println!</kbd>. We get the following error upon compilation:</p>
<p><img src="assets/22d4bacb-d7c3-4ece-9f28-d984cd60b3c8.png"/></p>
<p>As you can clearly read, the error message says that <kbd>bag</kbd> has already been moved and consumed by the <kbd>a</kbd> <span>variable </span>in the match expression. This invalidates the variable <kbd>bag</kbd> for any further use. We'll see how to make this code work when we get to the concept of borrowing.</p>
<p><strong>Methods:</strong> Within an <kbd>impl</kbd> block, any method with <kbd>self</kbd> as the first parameter takes ownership of the value on which the method is called. This means that after you call the method on the value, you cannot use that value again. This is shown in the following code:</p>
<pre>// ownership_methods.rs<br/><br/>struct Item(u32);<br/><br/>impl Item {<br/>    fn new() -&gt; Self {<br/>        Item(1024)<br/>    }<br/><br/>    fn take_item(self) {<br/>        // does nothing<br/>    } <br/>}<br/><br/>fn main() {<br/>    let it = Item::new();<br/>    it.take_item();<br/>    println!("{}", it.0);<br/>}</pre>
<p>Upon compilation, we get the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b4710d33-9819-44e6-ac28-44a33bf4842d.png"/></p>
<p><kbd>take_item</kbd> is an instance method that takes <kbd>self</kbd> as the first parameter. After its invocation, <kbd>it</kbd> is moved inside the method and deallocated when the function scope ends. We cannot use <kbd>it</kbd> again later. We'll make this code work when we get to the borrowing concept.</p>
<p><strong>Ownership in closures</strong>: A similar thing happens with closures. Consider the following code snippet:</p>
<pre>// ownership_closures.rs<br/><br/>#[derive(Debug)]<br/>struct Foo;<br/><br/>fn main() {<br/>    let a = Foo;<br/><br/>    let closure = || {<br/>        let b = a;    <br/>    };<br/>    <br/>    println!("{:?}", a);<br/>}</pre>
<p>As you can already guess, the ownership of <kbd>Foo</kbd> is moved to <kbd>b</kbd> inside the closure by default on assignment, and we can't access <kbd>a</kbd> again. We get the following output when compiling the preceding code:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/a218189e-9151-48ee-a202-b56c3e09496c.png"/></p>
<p>To have a copy of <kbd>a</kbd>, we can call <kbd>a.clone()</kbd> inside the closure and assign it to <kbd>b</kbd> or place a move keyword before the closure, like so:</p>
<pre>    let closure = move || {<br/>        let b = a;    <br/>    };</pre>
<p>This will make our program compile.</p>
<div class="packt_infobox"><strong>Note</strong>: Closures take values differently depending on how a variable is used inside the closure.</div>
<p>With these observations, we can already see that the ownership rule can be quite restrictive as it allows us to use a type only once. If a function needs only read access to a value, then we either need to return the value back again from the function or clone it before passing it to the function. The latter might not be possible if the type does not implement <kbd>Clone</kbd>. Cloning the type might seem like an easy thing to get around <span>the </span>ownership principle, but it defeats the whole point of <span>the </span>zero-cost promise as <kbd>Clone</kbd>  always duplicates types always, possibly making a call to the memory allocator APIs, which is a costly operation involving system calls.</p>
<p>With move semantics and the ownership rule in effect, it soon gets unwieldy to write programs in Rust. Fortunately, we have the concept of borrowing and reference types that relax the restrictions imposed by the rules but still maintains the ownership guarantees at compile time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Borrowing</h1>
                </header>
            
            <article>
                
<p>The concept of borrowing is there to circumvent the restrictions with the ownership rule. Under borrowing, you don't take ownership of values, but only lend data for as long as you need. This is achieved by borrowing values, that is, taking a reference to a value. To borrow a value, we put the  <kbd>&amp;</kbd> operator before the variable <kbd>&amp;</kbd> is the <em>address of</em> operator . We can borrow values in Rust in two ways.</p>
<p><strong>Immutable borrows</strong>: When we use the <kbd>&amp;</kbd> operator before a type, we create an immutable reference to it. Our previous example from the ownership section can be re-written <span>using borrowing</span><span>:</span></p>
<pre>// borrowing_basics.rs<br/><br/>#[derive(Debug)]<br/>struct Foo(u32);<br/><br/>fn main() {<br/>    let foo = Foo;<br/>    let bar = &amp;foo;<br/>    println!("Foo is {:?}", foo);<br/>    println!("Bar is {:?}", bar);<br/>}</pre>
<p>This time, the program compiles, as the second line inside <kbd>main</kbd> has changed to this:</p>
<pre>    let bar = &amp;foo;</pre>
<p>Notice the <kbd>&amp;</kbd> before the variable <kbd>foo</kbd>. We are borrowing <kbd>foo</kbd> and assigning the borrow to <kbd>bar</kbd>. <kbd>bar</kbd> has a type of <kbd>&amp;Foo</kbd>, which is a reference type. Being an immutable reference, we cannot mutate the value inside <kbd>Foo</kbd> from <kbd>bar</kbd>.</p>
<p><strong>Mutable borrows</strong>: Mutable borrows to a value can be taken using the <kbd>&amp;mut</kbd> operator. With mutable borrows, you can mutate the value. Consider the following code:</p>
<pre>// mutable_borrow.rs<br/><br/>fn main() {<br/>    let a = String::from("Owned string");<br/>    let a_ref = &amp;mut a;<br/>    a_ref.push('!');<br/>}</pre>
<p>Here, we have a <kbd>String</kbd> instance declared as <span><kbd>a</kbd></span><span>. We also create a mutable reference to it with</span> <kbd>b</kbd> <span>using</span> <kbd>&amp;mut a</kbd><span>. This does not move</span> <kbd>a</kbd> <span>to</span> <kbd>b</kbd><span>,- only borrows it mutably. We then push a <kbd>'!'</kbd> character to the string. Let's compile this program:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2894603b-b6f4-4527-99ed-c0ca832245ee.png" style="width:39.42em;height:14.00em;"/></p>
<p>We have an error. The compiler says that we cannot borrow <kbd>a</kbd> mutably. This is because mutable borrows require the owning variable itself to be declared with the <kbd>mut</kbd> keyword. This should be obvious, as we can't mutate something that's behind an immutable binding. Accordingly, we'll change our declaration of <kbd>a</kbd> to this:</p>
<pre>let mut a = String::from("Owned string");</pre>
<p>This makes the program compile. Here, <kbd>a</kbd> is a stack variable that points to a heap allocated value, and <kbd>a_ref</kbd> is a mutable reference to the value owned by <kbd>a</kbd>. <kbd>a_ref</kbd> can mutate the <kbd>String</kbd> value but it cannot drop the value, as it's not the owner. The borrow becomes invalid if <kbd>a</kbd> is dropped before the line that takes a reference.</p>
<p>Now, we add a <kbd>println!</kbd> at the end of the previous program to print the modified <kbd>a</kbd>:</p>
<pre>// exclusive_borrow.rs<br/><br/>fn main() {<br/>    let mut a = String::from("Owned string");<br/>    let a_ref = &amp;mut a;<br/>    a_ref.push('!');<br/>    println!("{}", a);<br/>}</pre>
<p>Compiling this gives us the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/88e93618-facf-47bb-88c2-37a23ed6b831.png"/></p>
<p>Rust forbids this, thus borrowing the value immutably as a mutable borrow with <kbd>a_ref</kbd> already is present in the scope. This highlights another important rule with borrowing. Once a value is borrowed mutably, we cannot have any other borrows of it. Not even an immutable borrow. Having explored borrowing, let's highlight the exact borrowing rules in Rust.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Borrowing rules</h1>
                </header>
            
            <article>
                
<p>Similar to the ownership rule, we also have borrowing rules that maintain the single ownership semantics with references, too. These rules are as follows:</p>
<ul>
<li>A reference may not live longer than what it referred to. This is obvious, since if it did, it would be referring to a garbage value.</li>
<li>If there's a mutable reference to a value, no other references, either mutable or immutable references, are allowed to the same value in that scope. A mutable reference is an exclusive borrow.</li>
<li>If there is no mutable reference to a thing, any number of immutable references to the same value are allowed in the scope.</li>
</ul>
<div class="packt_infobox">The borrowing rules in Rust are analyzed by a component of the compiler called the borrow checker. The Rust community amusingly calls dealing with borrowing errors as fighting the borrow checker.</div>
<p>Now that we're familiar with the rules, let's see what happens if we go against the borrow checker by violating them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Borrowing in action</h1>
                </header>
            
            <article>
                
<p>Rust's error diagnostics around the borrowing rules are really helpful when we go against the borrow checker. In the following few examples, we'll see them in various contexts.</p>
<p><strong>Borrowing in functions</strong>: As you saw previously, moving ownership when making function calls does not make much sense if you are only reading the value, and is very limiting. You don't get to use the variable after you call the function. Instead of taking parameters by value, we can take them by references. We can fix the previous code example that was presented in the ownership section to pass the compiler without cloning, like so:</p>
<pre>// borrowing_functions.rs<br/><br/>fn take_the_n(n: &amp;mut u8) {<br/>    *n += 2;<br/>}<br/><br/>fn take_the_s(s: &amp;mut String) {<br/>    s.push_str("ing");<br/>}<br/><br/>fn main() {<br/>    let mut n = 5;<br/>    let mut s = String::from("Borrow");<br/><br/>    take_the_n(&amp;mut n);<br/>    take_the_s(&amp;mut s);<br/><br/>    println!("n changed to {}", n);<br/>    println!("s changed to {}", s);<br/>}</pre>
<p>In the preceding code, <kbd>take_the_s</kbd> and <kbd>take_the_n</kbd> now take mutable references. With this, we needed to modify three things in our code. First, the variable binding will have to be made mutable:</p>
<pre>let mut s = String::from("Borrow"); </pre>
<p>Second, our function changes to the following:</p>
<pre>fn take_the_s(n: &amp;mut String) { <br/>    s.push_str("ing"); <br/>} </pre>
<p> </p>
<p>Third, the call site would also need to change to this form:</p>
<pre>    take_the_s(&amp;mut s); </pre>
<p>Again, we can see that everything in Rust is explicit. Mutability is very visible in Rust code for obvious reasons, especially when multiple threads come into play.</p>
<p><strong>Borrowing in match</strong>: In match expressions, a value is moved by default in the match arms, unless it's a <kbd>Copy</kbd> type. The following code, which was presented in the previous section on ownership, compiles by borrowing in match arms:</p>
<pre>// borrowing_match.rs<br/><br/>#[derive(Debug)]<br/>enum Food {<br/>    Cake,<br/>    Pizza,<br/>    Salad<br/>}<br/><br/>#[derive(Debug)]<br/>struct Bag {<br/>    food: Food<br/>}<br/><br/>fn main() {<br/>    let bag = Bag { food: Food::Cake };<br/>    match bag.food {<br/>        Food::Cake =&gt; println!("I got cake"),<br/>        ref a =&gt; println!("I got {:?}", a)<br/>    }<br/>    <br/>    println!("{:?}", bag);<br/>}</pre>
<p>We made a slight change to the preceding code, which might be familiar to you from the ownership section. For the second match arm, we prefixed a with <kbd>ref</kbd>. The <kbd>ref</kbd> keyword is a keyword that can match items by taking a reference to them instead of capturing them by value. With this change, our code compiles.</p>
<p><strong>Returning a reference from a function</strong>: In the following code example, we have a function that tries to return a reference to a value declared within the function:</p>
<pre>// return_func_ref.rs<br/><br/>fn get_a_borrowed_value() -&gt; &amp;u8 { <br/>    let x = 1; <br/>    &amp;x <br/>}<br/><br/>fn main() {<br/>    let value = get_a_borrowed_value(); <br/>}</pre>
<p>This code fails to pass the borrow checker, and we are met with the following error:</p>
<p><img src="assets/6203aefd-4a8a-47c2-b7b3-3a9e0e5a95a1.png"/></p>
<p>The error message says that we are missing a lifetime specifier. That doesn't help much in regards to explaining what is wrong with our code. This is where we need to <span>acquaint</span> ourselves with the concept of lifetimes, which we will cover in the next section. Before that, let's expound on the kind of functions that we can can have based on borrowing rules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Method types based on borrowing</h1>
                </header>
            
            <article>
                
<p>The borrowing rules also dictate how inherent methods on types are defined and also instance methods from traits. The following are how they receive the instance, presented by least restrictive to most restrictive:</p>
<ul>
<li><kbd>&amp;self</kbd> methods: These methods only have immutable access to its members</li>
<li><kbd>&amp;mut self</kbd> methods: These methods borrows the self instance mutably<br/></li>
<li><kbd>self</kbd> methods: These methods takes ownership of the instance on which it is called and the type is not available to be called later<br/></li>
</ul>
<p>In the case of user defined types, the same kind of borrowing applies also to its field members.</p>
<div class="packt_infobox"><strong>Note</strong>: Unless you're deliberately writing a method that should move or drop <kbd>self</kbd> at the end, always prefer immutable borrowing methods that is, having <kbd>&amp;self</kbd> as the first parameter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lifetimes</h1>
                </header>
            
            <article>
                
<p>The third piece in Rust's compile time memory safety puzzle is the idea of lifetimes and the related syntactic annotation for specifying lifetimes in code. In this section, we'll explain lifetimes by stripping them down to the basics.</p>
<p>When we declare a variable by initializing it with a value, the variable has a certain lifetime, beyond which it is invalid to use it. In general programming parlance, the lifetime of a variable is the region in code in which the variable points to a valid memory. If you have ever programmed in C, you should be acutely aware of the case with lifetimes of variables: every time you allocate a variable with <kbd>malloc</kbd>, it should have an owner, and that owner should reliably decide when that variable's life ends and when the memory gets freed. But the worst thing is, it's not enforced by the C compiler; rather, it's the programmer's responsibility.</p>
<p>For data allocated on the stack, we can easily reason by looking at the code and figure out whether a variable is alive or not. For heap allocated values, though, this isn't clear. Lifetimes in Rust is a concrete construct and not a conceptual idea as in C. They do the same kind of analysis that a programmer does manually, that is, by examining the scope of value and any variable that references it.</p>
<p>When talking about lifetimes in Rust, you only need to deal with them when you have a reference. All references in Rust have an implicit lifetime information attached to them. A lifetime defines how long the reference lives in relation to the original owner of the value and also the extent of the scope of the reference. Most of the time, it is implicit and the compiler figures out the lifetime of the variables by looking at the code. But in some cases, the compiler cannot and then it needs our help, or better said, it asks you to specify your intent.</p>
<p>So far, we have been dealing with references and borrowing quite easily in the previous code examples, but let see what happens when we try to compile the following code:</p>
<pre>// lifetime_basics.rs<br/><br/>struct SomeRef&lt;T&gt; {<br/>    part: &amp;T<br/>}<br/><br/>fn main() {<br/>    let a = SomeRef { part: &amp;43 };<br/>}</pre>
<p>This code is very simple. We have a <kbd>SomeRef</kbd> <span>struct,</span><span> </span><span>which stores a reference to a generic type,</span> <kbd>T</kbd><span>. In <kbd>main</kbd>, we create an instance of the struct, initializing the</span> <kbd>part</kbd> <span>field </span><span>with a reference to an</span> <kbd>i32</kbd><span>, that is,</span> <kbd>&amp;43</kbd><span>.</span></p>
<p>It gives the following error upon compilation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/56b8516a-dd2d-4326-ba68-639034260caa.png" style="width:36.42em;height:10.17em;"/></p>
<p class="mce-root"/>
<p>In this case, the compiler asks us to put in something called a lifetime parameter. A lifetime parameter is very similar to a generic type parameter. Where a generic type <kbd>T</kbd> denotes any type, lifetime parameters denote the region or the span where the reference is valid to be used. It's just there for the compiler to fill in with the actual region information later when the code is analyzed by the borrow checker.</p>
<p>A lifetime is purely a compile time construct that helps the compiler to figure out the extent to which a reference can be used within a scope, and ensures that it follows the borrowing rules. It can keep track of things like the origin of references <span>and whether they outlive the borrowed value. Lifetimes in Rust ensure that a reference can't outlive the value it points to. Lifetimes are not something that you as a developer will use, but it's for the compiler to use and reason about validity of references.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lifetime parameters</h1>
                </header>
            
            <article>
                
<p>For cases where the compiler can't figure out the lifetime of values by examining the code, we need to tell Rust by using some annotations in code. To distinguish from identifiers, lifetime annotations are denoted by a quirky symbol of prefixing a letter with <kbd>'</kbd>. So, to make our previous example compile with a parameter, we have added a lifetime annotation on our <kbd>StructRef</kbd>, like so:</p>
<pre>// using_lifetimes.rs<br/><br/>struct SomeRef&lt;'a, T&gt; {<br/>    part: &amp;'a T<br/>}<br/><br/>fn main() {<br/>    let _a = SomeRef { part: &amp;43 };<br/>}</pre>
<p>A lifetime is denoted by a <kbd>'</kbd>, followed by any sequence of valid identifiers. But, by convention, most lifetimes used in <span>the </span>Rust code uses <kbd>'a</kbd>, <kbd>'b </kbd>and  <kbd>'c</kbd> as lifetime parameters. If you have multiple lifetimes on a type, you can use longer descriptive lifetime names such as <kbd>'ctx</kbd>, <kbd>'reader</kbd>, <kbd>'writer</kbd>, and so on. It is declared at the same place and in the same way as generic type parameters.</p>
<p>We saw examples where the lifetimes acted as a generic parameter for resolving valid references later, but there's a lifetime that has a concrete value. It is shown in the following code:</p>
<pre>// static_lifetime.rs<br/><br/>fn main() {<br/>    let _a: &amp;'static str = "I live forever";<br/>}</pre>
<p>The <kbd>static</kbd> lifetime means that these references are valid for the entire duration of the program. All literal strings in Rust have a lifetime of <kbd>'static</kbd> and they go to the data segment of the compiled object code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lifetime elision and the rules</h1>
                </header>
            
            <article>
                
<p>Any time there's a reference in a function or a type definition, there's a lifetime involved. Most of the time, you don't need to use explicit lifetime annotation is you code as the compiler is smart to infer them for you as a lot of information is already available at compile time about references.</p>
<p> In other words, these two function signatures are identical:</p>
<pre>fn func_one(x: &amp;u8) → &amp;u8 { .. }<br/><br/>fn func_two&lt;'a&gt;(x: &amp;'a u8) → &amp;'a u8 { .. }</pre>
<p>In the usual case, the compiler has elided the lifetime parameter for  <kbd>func_one</kbd> and we don't need to write it as <kbd>func_two</kbd>.</p>
<p>But the compiler can elide lifetimes only in restricted places and there are rules for elision. Before we talk about these rules, we need to talk about input and output lifetimes. These are only discussed when functions that take references are involved.</p>
<p><strong>Input lifetime</strong>: Lifetime annotations on function parameters that are references are referred to as input lifetimes.</p>
<p><strong>Output lifetimes</strong>: Lifetime annotations on function return values that are references are referred to as output lifetimes.</p>
<p>It's import to note that any output lifetime originates from input lifetimes. We cannot have a output lifetime that is independent and distinct from the input lifetime. It can only be a lifetime that is smaller than or equal to the output lifetime.</p>
<p>The following are the rules that are followed when eliding lifetimes:</p>
<ul>
<li>If the input lifetime contains only a single reference, the output lifetime is assumed to be the same</li>
<li>For methods involving <kbd>self</kbd> and <kbd>&amp;mut self</kbd>, the input lifetime is inferred for the  <kbd>&amp;self</kbd> parameter</li>
</ul>
<p>But sometimes in ambiguous situations, the compiler doesn't try to assume things. Consider the following code:</p>
<pre class="mce-root">// explicit_lifetimes.rs<br/><br/>fn foo(a: &amp;str, b: &amp;str) -&gt; &amp;str {<br/>    b<br/>}<br/><br/>fn main() {<br/>    let a = "Hello";<br/>    let b = "World";<br/>    let c = foo(a, b);<br/>}</pre>
<p>In the preceding code, <kbd>RefItem</kbd> stores a reference to any type,  <kbd>T</kbd>. In this case, the lifetime of the return value isn't obvious as there are two input references involved. But, sometimes, the compiler is not able to figure out the lifetimes of references, and then it needs our help and asks us to specify lifetime parameters. Consider the following code, which does not compile:</p>
<p><img src="assets/74eec68d-b419-4a41-9e54-fe1cf6d14ec5.png"/></p>
<p>The preceding program doesn't compile because Rust is unable to figure out the lifetime of the return value and it needs our help here.</p>
<p>Now, there are various places where we have to specify lifetimes when Rust cannot figure them out for us:</p>
<ul>
<li>Function signatures</li>
<li>Structs and struct fields</li>
<li>impl blocks</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lifetimes in user defined types</h1>
                </header>
            
            <article>
                
<p>If a struct definition has fields that are reference to any type, we need to explicitly <span>specify</span><span> </span><span>how long those references will live. The syntax is similar to that of function signatures: we first declare the lifetime names on the struct line, and then use them in the fields.</span></p>
<p>Here's what the syntax looks like in its simplest form:</p>
<pre>//  lifetime_struct.rs<br/><br/>struct Number&lt;'a&gt; { <br/>    num: &amp;'a u8 <br/>}<br/><br/>fn main() {<br/>    let _n = Number {num: &amp;545}; <br/>}</pre>
<p>The definition of <kbd>Number</kbd> lives as long as the reference for <kbd>num</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lifetime in impl blocks</h1>
                </header>
            
            <article>
                
<p>When we create <kbd>impl</kbd> blocks for structs with references, we need to repeat the lifetime declarations and definitions again. For instance, if we made an implementation for the struct <kbd>Foo</kbd> we defined previously, the syntax would look like this:</p>
<pre>// lifetime_impls.rs<br/><br/>#[derive(Debug)]<br/>struct Number&lt;'a&gt; { <br/>    num: &amp;'a u8 <br/>}<br/><br/>impl&lt;'a&gt; Number&lt;'a&gt; { <br/>    fn get_num(&amp;self) -&gt; &amp;'a u8 { <br/>        self.num <br/>    }  <br/>    fn set_num(&amp;mut self, new_number: &amp;'a u8) { <br/>        self.num = new_number <br/>    }<br/>}<br/><br/>fn main() {<br/>    let a = 10;<br/>    let mut num = Number { num: &amp;a };<br/>    num.set_num(&amp;23);<br/>    println!("{:?}", num.get_num());<br/>}</pre>
<p>In most of these cases, this is inferred from the types themselves and then, we can omit the signatures with <kbd>&lt;'_&gt;</kbd> syntax.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple lifetimes</h1>
                </header>
            
            <article>
                
<p>Just like generic type parameters, we can specify multiple lifetimes if we have more than one reference that has different lifetimes. However, it can quickly become hairy when you have to juggle with more than one lifetime in your code. Most of the time, we can get away with just one lifetime in our structs or any of our functions. But there are cases where we'll need more than one lifetime annotations. For example, say we are building a decoder library that can parse binary files according to a schema and a given encoded stream of bytes. We have a <kbd>Decoder</kbd> object, which has a reference to a <kbd>Schema</kbd> object and a reference to a <kbd>Reader</kbd> type. Our Decoder definition will then look something like this:</p>
<pre>// multiple_lifetimes.rs<br/><br/>struct Decoder&lt;'a, 'b, S, R&gt; {<br/>    schema: &amp;'a S,<br/>    reader: &amp;'b R<br/>}<br/><br/>fn main() {}</pre>
<p>In the preceding definition, it is quite possible that we get <kbd>Reader</kbd> from the network while the <kbd>Schema</kbd> is local, and so their lifetimes in code can be different. When we provide implementations for this <kbd>Decoder</kbd>, we can specify relations with it by lifetime subtyping, which we will explain next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lifetime subtyping</h1>
                </header>
            
            <article>
                
<p>We can specify relation between lifetimes that specifies whether two references can be used in the same place. Continuing with our <kbd>Decoder</kbd> struct example, we can specify the lifetimes' relations with each other in the <kbd>impl</kbd> block, like so:</p>
<pre>// lifetime_subtyping.rs<br/><br/>struct Decoder&lt;'a, 'b, S, R&gt; {<br/>    schema: &amp;'a S,<br/>    reader: &amp;'b R<br/>}<br/><br/>impl&lt;'a, 'b, S, R&gt; Decoder&lt;'a, 'b, S, R&gt;<br/>where 'a: 'b {<br/>    <br/>}<br/><br/>fn main() {<br/>    let a: Vec&lt;u8&gt; = vec![];<br/>    let b: Vec&lt;u8&gt; = vec![];<br/>    let decoder = Decoder {schema: &amp;a, reader: &amp;b};<br/>}</pre>
<p>We specified the relation in the impl block using the where clause as: 'a: 'b . This is read as the lifetime <kbd>'a</kbd> outlives <kbd>'b</kbd> or in other words <kbd>'b</kbd> should never live longer than <kbd>'a</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying lifetime bounds on generic types</h1>
                </header>
            
            <article>
                
<p>Apart from using traits to constrain the types that can be accepted by a generic function, we can also constrain generic type parameters using lifetime annotations. For instance, consider we have a logger library where the <kbd>Logger</kbd> object is defined as follows:</p>
<pre>// lifetime_bounds.rs<br/><br/>enum Level {<br/>    Error<br/>}<br/><br/>struct Logger&lt;'a&gt;(&amp;'a str, Level);<br/><br/>fn configure_logger&lt;T&gt;(_t: T) where T: Send + 'static {<br/>    // configure the logger here<br/>}<br/><br/>fn main() {<br/>    let name = "Global";<br/>    let log1 = Logger(name, Level::Error);<br/>    configure_logger(log1);<br/>}</pre>
<p>In the preceding code, we have a <kbd>Logger</kbd> struct with its name and a <kbd>Level</kbd> enum. We also have a generic function called <kbd>configure_logger</kbd> that takes a type <kbd>T</kbd> that is constrained with <kbd>Send + 'static</kbd>. In main, we create a logger with a <kbd>'static</kbd>, string <kbd>"Global"</kbd>, and call <kbd>configure_logger</kbd> passing it.</p>
<p>Along with the <kbd>Send</kbd> bound, which says that this thread can be sent to threads, we also say that the type must live as long as the <kbd>'static</kbd> lifetime. Let's say we were to use a Logger that references a string of shorter lifetimes, like so:</p>
<pre>// lifetime_bounds_short.rs<br/><br/>enum Level {<br/>    Error<br/>}<br/><br/>struct Logger&lt;'a&gt;(&amp;'a str, Level);<br/><br/>fn configure_logger&lt;T&gt;(_t: T) where T: Send + 'static {<br/>    // configure the logger here<br/>}<br/><br/>fn main() {<br/>    let other = String::from("Local");<br/>    let log2 = Logger(&amp;other, Level::Error);<br/>    configure_logger(&amp;log2);<br/>}</pre>
<p>This will fail with the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f39f3499-1ef1-4fdc-a1f1-dc3bb4b96ee6.png" style="width:41.00em;height:25.25em;"/></p>
<p>The error message clearly say, that the borrowed value must be valid for the static lifetime, but we have passed it a string, which has a lifetime called <kbd>'a</kbd> from main, which is a shorter lifetime than <kbd>'static</kbd>.</p>
<p>With the concept of lifetimes under our belt, let's revisit pointer types in Rust.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pointer types in Rust</h1>
                </header>
            
            <article>
                
<p>Our tale about memory management would be incomplete if we didn't include pointers in the discussion, which are the primary way to manipulate memory in any low level language. Pointers are simply variables that point to memory locations in the process's address space. In Rust, we deal with three kinds of pointers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">References – safe pointers</h1>
                </header>
            
            <article>
                
<p>These pointers are already familiar to you from the borrowing section. References are like pointers in C, but they are checked for correctness. They can never be null and always point to some data owned by any variable. The data they point to can either be on the stack or on the heap, or the data segment of the binary. They are created using the <kbd>&amp;</kbd> or the <kbd>&amp;mut</kbd> operator. These operators, when prefixed on a type <kbd>T</kbd>, create a reference type that is denoted by <kbd>&amp;T</kbd> for immutable references and <kbd>&amp;mut T</kbd> for mutable references. Let's recap on these again:</p>
<ul>
<li><kbd>&amp;T</kbd>: It's an immutable reference to a type <kbd>T</kbd>. A <kbd>&amp;T</kbd> pointer is a <kbd>Copy</kbd> type, which simply means you can have many immutable references to a value <kbd>T</kbd>. If you assign this to another variable, you get a copy of the pointer, which points to the same data. It is also fine to have a reference to a reference, such as <kbd>&amp;&amp;T</kbd>.</li>
<li><kbd>&amp;mut T</kbd>: It's an immutable pointer to a type <kbd>T</kbd>. Within any scope, you cannot have two mutable references to a value <kbd>T</kbd>, due to the borrowing rule. This means that <kbd>&amp;mut T</kbd> types do not implement the <kbd>Copy</kbd> trait. They also cannot be sent to threads.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Raw pointers</h1>
                </header>
            
            <article>
                
<p>These pointers have a quirky type signature of being prefixed with a <kbd>*</kbd>, which also happens to be the dereference operator. They are mostly used in unsafe code. One needs an unsafe block to dereference them. There are two kinds of raw pointers in Rust:</p>
<ul>
<li><kbd>*const T</kbd>: An immutable raw pointer to a type <kbd>T</kbd>. They are also <kbd>Copy</kbd> types. They are similar to <kbd>&amp;T</kbd>, it's just that <kbd>*const T</kbd> can also be null.</li>
<li><kbd>*mut T</kbd>: A mutable raw pointer to a value <kbd>T</kbd>, which is non-<kbd>Copy</kbd>.</li>
</ul>
<p>As an added note, a reference can be cast to a raw pointer, as shown in the following code:</p>
<pre>let a = &amp;56;<br/>let a_raw_ptr = a as *const u32;<br/>// or<br/>let b = &amp;mut 5634.3;<br/>let b_mut_ptr = b as *mut T;</pre>
<p>However, we can't cast a <kbd>&amp;T</kbd> to a <kbd>*mut T</kbd>, as it would violate the borrowing rules that allow only one mutable borrow.</p>
<p>For mutable references, we can cast them to <kbd>*mut T</kbd> or even <kbd>*const T</kbd>, which is called pointer weakening, as we go from a more capable pointer <kbd>&amp;mut T</kbd> to a less capable <kbd>*const T</kbd> pointer. For immutable references, we can only cast them to <kbd>*const T</kbd>.</p>
<p>However, dereferencing a raw pointer is an unsafe operation. We'll see how raw pointers are useful when we get to <a href="9e9ce701-5f35-4351-b76b-a5f2bd541059.xhtml">Chapter 10</a>, <em>Unsafe Rust and Foreign Function Interfaces</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Smart pointers</h1>
                </header>
            
            <article>
                
<p>Managing raw pointers is highly unsafe and developers need to be careful about a lot of details when using them. Uninformed usage may lead to issues such as memory leaks, dangling references, and double frees in large code bases in non-obvious ways. To alleviate from these issues, we can use smart pointers, which were popularized by C++.</p>
<p>Rust also has many kinds of smart pointers. They are called smart because they also have extra metadata and code associated with them that gets executed when they are created or destroyed. Being able to automatically free the underlying resource when a smart pointer goes out of scope is one of the major reasons to use smart pointers.</p>
<p>Much of <span>the </span>smartness in smart pointers comes from two traits, called the <kbd>Drop</kbd> trait and the <kbd>Deref</kbd> trait. Before we explore the available smart pointer types in Rust, let's understand these traits in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drop</h1>
                </header>
            
            <article>
                
<p>This is the trait we've been referring to quite a few times which does all the magic of automatically freeing up the resources that are used when a value goes out of scope. The <kbd>Drop</kbd> trait is akin to what you would call an <kbd>object destructor</kbd> method in other languages. It contains a single method, <kbd>drop</kbd>, which gets called when the object goes out of scope. The method takes in a <kbd>&amp;mut self</kbd> as parameter. Freeing of values with drop is done in <strong>last in, first out</strong>. That is, whatever was constructed the last, gets destructed first. The following code illustrates this:</p>
<pre>// drop.rs<br/><br/>struct Character {<br/>    name: String,<br/>}<br/><br/>impl Drop for Character {<br/>    fn drop(&amp;mut self) {<br/>        println!("{} went away", self.name)<br/>    }<br/>}<br/><br/>fn main() {<br/>    let steve = Character {<br/>        name: "Steve".into(),<br/>    };<br/>    let john = Character {<br/>        name: "John".into(),<br/>    };<br/>}</pre>
<p>The output is as follows: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b426f590-64c0-4736-aaa9-67c54eb60ad7.png" style="width:49.50em;height:23.67em;"/></div>
<p>The drop method is an ideal place for you to put any cleanup code for your own structs, if needed. It's especially handy for types where the cleanup is less clearly deterministic, such as when using reference counted values or garbage collectors. When we instantiate any <kbd>Drop</kbd> implementing value (any heap allocated type), the Rust compiler inserts <kbd>drop</kbd> method calls after every end of scope, after compilation. So, we don't need to manually call <kbd>drop</kbd> on these instances. This kind of automatic reclamation based on scope is inspired by the RAII principle of C++.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deref and DerefMut</h1>
                </header>
            
            <article>
                
<p>To provide similar behavior as normal pointers, that is, to be able to dereference the call methods on the underlying type being pointed to, smart pointer types often implement the <kbd>Deref</kbd> trait, which allows us to use the <kbd>*</kbd> dereferencing operator with these types. While <kbd>Deref</kbd> gives you read-<span>only</span><span> </span><span>access, there is also</span> <kbd>DerefMut</kbd><span>, which can give you a mutable reference to the underlying type. Deref has the following type signature:<br/></span></p>
<pre>pub trait Deref {<br/>    type Target: ?Sized;<br/>    fn deref(&amp;self) -&gt; &amp;Self::Target;<br/>}</pre>
<p>If defines a single method called <kbd>Deref</kbd> that takes <kbd>self</kbd> by reference and returns a immutable reference to the underlying type. This combined with the deref coercion feature of Rust, reduces a lot of code that you have to write. Deref coercion is when a type automatically gets converted from one type of reference to some other reference. We'll look at them in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of smart pointers</h1>
                </header>
            
            <article>
                
<p>Some of the smart pointer types from the standard library as follows:</p>
<ul>
<li><kbd>Box&lt;T&gt;</kbd>: This provides the simplest form of heap allocation. The <kbd>Box</kbd> type owns the value inside it, and can thus be used for holding values inside structs or for returning them from functions.</li>
<li><kbd>Rc&lt;T&gt;</kbd>: This is for reference counting. It increments a counter whenever somebody takes a new reference, and decrements it when someone releases a reference. When the counter hits zero, the value is dropped.</li>
<li><kbd>Arc&lt;T&gt;</kbd>: This is for atomic reference counting. This is like the previous type, but with atomicity to guarantee multithread safety.</li>
<li><kbd>Cell&lt;T&gt;</kbd>: This gives us internal mutability for types that implement the <kbd>Copy</kbd> trait. In other words, we gain the possibility to get multiple mutable references to something.</li>
<li><kbd>RefCell&lt;T&gt;</kbd>: This gives us internal mutability for types, without requiring the <kbd>Copy</kbd> trait. It uses runtime locking for safety.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Box&lt;T&gt;</h1>
                </header>
            
            <article>
                
<p>The generic type <kbd>Box</kbd> in the standard library gives us the simplest way to allocate values in the heap. It's simply declared as a tuple struct in the standard library, and wraps any type given to it and puts it on heap. If you're familiar with the concept of boxing and unboxing from other languages, such as Java where you have Boxed integers as the <em>Integer</em> class, this provides a similar abstraction. The ownership semantics with <kbd>Box</kbd> type depends on the wrapped type. If the underlying type is <kbd>Copy</kbd>, the Box instance becomes copy, otherwise it moves by default.</p>
<p>To create a heap allocated value of type <kbd>T</kbd> using a <kbd>Box</kbd>, we simply call the associated <kbd>new</kbd> method, passing in the value. Creating the <kbd>Box</kbd> value wrapping a type <kbd>T</kbd> gives back the <kbd>Box</kbd> instance, which is a pointer on the stack that points to <kbd>T</kbd>, which is allocated on the heap. The following example shows how to use B<kbd>ox</kbd>:</p>
<pre>// box_basics.rs<br/><br/>fn box_ref&lt;T&gt;(b: T) -&gt; Box&lt;T&gt; {<br/>    let a = b;<br/>    Box::new(a)<br/>}<br/><br/>struct Foo;<br/><br/>fn main() {<br/>    let boxed_one = Box::new(Foo);<br/>    let unboxed_one = *boxed_one;<br/>    box_ref(unboxed_one);<br/>}</pre>
<p>In our main function, we created a heap allocated value in boxed_one by calling <kbd>Box::new(Foo)</kbd>.</p>
<p>The <kbd>Box</kbd> type can be used in the following situations:</p>
<ul>
<li>It can be used to create recursive type definitions. For example, here is a Node type that represents a node in a singly linked list:</li>
</ul>
<pre>// recursive_type.rs<br/><br/>struct Node {<br/>    data: u32,<br/>    next: Option&lt;Node&gt;<br/>}<br/><br/>fn main() {<br/>    let a = Node { data: 33, next: None };<br/>}</pre>
<p>On compiling, we are presented with this error:</p>
<p><img src="assets/5dbf582f-cc29-436c-aadf-f6cfbb7eb64b.png"/></p>
<p>We cannot have this definition of the <kbd>Node</kbd> type because <kbd>next</kbd> has a type that refers to itself. If this definition is allowed, there is no end for the compiler to analyze our Node definition as it will keep evaluating it until it hits out of memory. This is better illustrated with the following snippet:</p>
<pre>struct Node {<br/>    data: u32,<br/>    next: Some(Node {<br/>              data: u32,<br/>              next: Node {<br/>                        data: u32,<br/>                        next: ...<br/>                    }<br/>          })<br/>}</pre>
<p>This evaluation of the Node definition will keep on continuing until the compiler runs out of memory. Also, as every piece of data needs to have a statically known size at compile time, this is a non-representable type in Rust. We need to make the <kbd>next</kbd> field something that has a fixed size. We can do this by putting <kbd>next</kbd> behind a pointer because pointers are always fixed size. If you see the error message, the compiler,  we'll use the Box type Our new <kbd>Node</kbd> definition changes like so:</p>
<pre>struct Node {<br/>    data: u32,<br/>    next: Option&lt;Box&lt;Node&gt;&gt;<br/>}</pre>
<p>The <kbd>Box</kbd> type is also used when defining recursive types that need to be hidden behind a <kbd>Sized</kbd> indirection. So, an enum consisting of a variant with a reference to itself could use the <kbd>Box</kbd> type to tuck away the variant in the following situations:</p>
<ul>
<li>When you need to store types as trait objects</li>
<li>When you need to store functions in a collection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reference counted smart pointers</h1>
                </header>
            
            <article>
                
<p>The ownership rule allows only one owner to exist at a time in a given scope. However, there are cases where you need to share the type with multiple variables. For instance, in a GUI library, each of the child widgets needs to have a reference to its parent container widget for things like communicating to layout the child widget based on resize events from the user. While lifetimes allow you to reference the parent node from the child nodes by storing the parent as a <kbd>&amp;'a Parent</kbd> (say), it's often limited by the lifetime <kbd>'a</kbd> of the value. Once the scope ends, your reference is invalid. In such cases, we need more flexible approaches, and that calls for using reference counting types. These smart pointer types provide shared ownership of values in the program.</p>
<p>Reference counting types enables garbage collection at a granular level. In this approach, a smart pointer type allows you to have multiple references to the wrapped value. Internally, the smart pointer keeps a count of how many references it has given out and are active using a reference counter (hereby refcount), which is just an integral value. As variables that reference the wrapped smart pointer value go out of scope, the refcount value decrements. Once all of the references to the object are gone and the refcount reaches <kbd>0</kbd>, the value is deallocated. This is how reference counted pointers work in general.</p>
<p>Rust provides us with two kinds of reference counting pointer types:</p>
<ul>
<li><kbd>Rc&lt;T&gt;</kbd> : This is mainly for use in single threaded environments</li>
<li><kbd>Arc&lt;T&gt;</kbd> is meant to be used in multi-threaded environments</li>
</ul>
<p>Let's explore the single threaded variant here. We'll take a visit to its multi-threaded counterparts in <a href="8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml">Chapter 8</a>, <em>Concurrency</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rc&lt;T&gt;</h1>
                </header>
            
            <article>
                
<p>When we interact with an <kbd>Rc</kbd> type, the following changes happen to it internally:</p>
<ul>
<li>When you take a new shared reference to <kbd>Rc</kbd> by calling <kbd>Clone()</kbd>, <kbd>Rc</kbd> increments its internal reference count. Rc internally uses the Cell type for its reference counts</li>
<li>When the reference goes out of scope, it decrements it</li>
<li>When all shared references go out of scope, the refcount becomes zero. At this point, the last drop call on <kbd>Rc</kbd> does its deallocation</li>
</ul>
<p>Using reference counted containers gives us more flexibility in the implementation: we can hand out copies of our value as if it were a new copy without having to keep exact track of when the references go out of scope. That doesn't mean that we can mutably alias the inner values.</p>
<p><kbd>Rc&lt;T&gt;</kbd> is mostly used via two methods:</p>
<ul>
<li>The static method <kbd>Rc::new</kbd> makes a new reference counted container.</li>
<li>The <kbd>clone</kbd> method increments the strong reference count and hands out a new <kbd>Rc&lt;T&gt;</kbd>.</li>
</ul>
<p><kbd>Rc</kbd> internally keeps two kinds of references: strong (<kbd>Rc&lt;T&gt;</kbd>) and weak (<kbd>Weak&lt;T&gt;</kbd>). Both keep a count of how many references of each type have been handed out, but only when the strong reference count reaches zero so that the values get deallocated. The motivation for this is that an implementation of a data structure may need to point to the same thing multiple times. For instance, an implementation of a tree might have references to both the child nodes and the parent, but incrementing the counter for each reference would not be correct and would lead to reference cycles. The following diagram illustrates the reference cycle situation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/67567bee-43a2-477a-a975-60f87cc00bc7.png" style="width:33.67em;height:14.92em;"/></p>
<p>In the preceding diagram, we have two variables, <kbd>var1</kbd> and <kbd>var2</kbd>, that reference two resources, <kbd>Obj1</kbd> and <kbd>Obj2</kbd>. Along with that, <kbd>Obj1</kbd> also has a reference to <kbd>Obj2</kbd> and <kbd>Obj2</kbd> has a reference to <kbd>Obj1</kbd>. Both <kbd>Obj1</kbd> and <kbd>Obj2</kbd> have reference count of <kbd>2</kbd> when <kbd>var1</kbd> and <kbd>var2</kbd> goes out of scope, the reference count of <kbd>Obj1</kbd> and <kbd>Obj2</kbd> reaches <kbd>1</kbd>. They won't get freed because they still refer to each other.</p>
<p>The reference cycle can be broken using weak references. As another example, a linked list might be implemented in such a way that it maintains links via reference counting to both the next item and to the previous. A better way to do this would be to use strong references to one direction and weak references to the other.</p>
<p>Let's see how that might work. Here's a minimal implementation of possibly the least practical but best learning data structure, the singly linked list:</p>
<pre>// linked_list.rs<br/><br/>use std::rc::Rc; <br/><br/>#[derive(Debug)] <br/>struct LinkedList&lt;T&gt; { <br/>    head: Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt; <br/>} <br/><br/>#[derive(Debug)] <br/>struct Node&lt;T&gt; { <br/>    next: Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;, <br/>    data: T <br/>} <br/><br/>impl&lt;T&gt; LinkedList&lt;T&gt; { <br/>    fn new() -&gt; Self { <br/>        LinkedList { head: None } <br/>    } <br/><br/>    fn append(&amp;self, data: T) -&gt; Self { <br/>        LinkedList { <br/>            head: Some(Rc::new(Node { <br/>                data: data, <br/>                next: self.head.clone() <br/>            })) <br/>        } <br/>    } <br/>} <br/><br/>fn main() { <br/>    let list_of_nums = LinkedList::new().append(1).append(2); <br/>    println!("nums: {:?}", list_of_nums); <br/><br/>    let list_of_strs = LinkedList::new().append("foo").append("bar"); <br/>    println!("strs: {:?}", list_of_strs); <br/>}</pre>
<p>The linked list is formed of two structs: <kbd>LinkedList</kbd> provides a reference to the first element of the list and the list's public API, and <kbd>Node</kbd> contains the actual elements. Notice how we're using <kbd>Rc</kbd> and cloning the next data pointer on every append. Let's walk through what happens in the append case:</p>
<ol>
<li><kbd>LinkedList::new()</kbd> gives us a new list. Head is <kbd>None</kbd>.</li>
<li>We append <kbd>1</kbd> to the list. Head is now the node that contains <kbd>1</kbd> as data, and next is the previous head: <kbd>None</kbd>.</li>
<li>We append <kbd>2</kbd> to the list. Head is now the node that contains <kbd>2</kbd> as data, and next is the previous head, the node that contains <kbd>1</kbd> as data.</li>
</ol>
<p>The debug output from <kbd>println!</kbd> confirms this:</p>
<pre>nums: LinkedList { head: Some(Node { next: Some(Node { next: None, data: 1 }), data: 2 }) }<br/>strs: LinkedList { head: Some(Node { next: Some(Node { next: None, data: "foo" }), data: "bar" }) }</pre>
<p>This is a rather functional form of this structure; every append works by just adding data at the head, which means that we don't have to play with references and actual list references can stay immutable. That changes a bit if we want to keep the structure this simple but still have a double-linked list, since then we actually have to change the existing structure.</p>
<p>You can downgrade an <kbd>Rc&lt;T&gt;</kbd> type into a <kbd>Weak&lt;T&gt;</kbd> type with the <kbd>downgrade</kbd> method, and similarly a <kbd>Weak&lt;T&gt;</kbd> type can be turned into <kbd>Rc&lt;T&gt;</kbd> using the <kbd>upgrade</kbd> method. The downgrade method will always work. In contrast, when calling upgrade on a weak reference, the actual value might have been dropped already, in which case you get a <kbd>None</kbd>.</p>
<p>So, let's add a weak pointer to the previous node:</p>
<pre>// rc_weak.rs<br/><br/>use std::rc::Rc; <br/>use std::rc::Weak; <br/><br/>#[derive(Debug)] <br/>struct LinkedList&lt;T&gt; { <br/>    head: Option&lt;Rc&lt;LinkedListNode&lt;T&gt;&gt;&gt; <br/>} <br/><br/>#[derive(Debug)] <br/>struct LinkedListNode&lt;T&gt; { <br/>    next: Option&lt;Rc&lt;LinkedListNode&lt;T&gt;&gt;&gt;, <br/>    prev: Option&lt;Weak&lt;LinkedListNode&lt;T&gt;&gt;&gt;, <br/>    data: T <br/>} <br/><br/>impl&lt;T&gt; LinkedList&lt;T&gt; { <br/>    fn new() -&gt; Self { <br/>        LinkedList { head: None } <br/>    } <br/><br/>    fn append(&amp;mut self, data: T) -&gt; Self { <br/>        let new_node = Rc::new(LinkedListNode { <br/>            data: data, <br/>            next: self.head.clone(), <br/>            prev: None <br/>        }); <br/><br/>        match self.head.clone() { <br/>            Some(node) =&gt; { <br/>                node.prev = Some(Rc::downgrade(&amp;new_node)); <br/>            }, <br/>            None =&gt; { <br/>            } <br/>        } <br/><br/>        LinkedList { <br/>            head: Some(new_node) <br/>        } <br/>    } <br/>} <br/><br/>fn main() { <br/>    let list_of_nums = LinkedList::new().append(1).append(2).append(3); <br/>    println!("nums: {:?}", list_of_nums); <br/>}</pre>
<p>The <kbd>append</kbd> method grew a bit; we now need to update the previous node of the current head before returning the newly created head. This is almost good enough, but not quite. The compiler doesn't let us do invalid operations:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e9ae95d0-501b-4926-bd2d-967faa48b547.png"/></div>
<p>We could make <kbd>append</kbd> take a mutable reference to <kbd>self</kbd>, but that would mean that we could only append to the list if all the nodes' bindings were mutable, forcing the whole structure to be mutable. What we really want is a way to make just one small part of the whole structure mutable, and fortunately we can do that with a single <kbd>RefCell</kbd>.</p>
<ol>
<li>Add a <kbd>use</kbd> for the <kbd>RefCell</kbd>:</li>
</ol>
<pre>        use std::cell::RefCell; </pre>
<ol start="2">
<li>Wrap the previous field in <kbd>LinkedListNode</kbd> in a <kbd>RefCell</kbd>:</li>
</ol>
<pre>        // rc_3.rs<br/>        #[derive(Debug)] <br/>        struct LinkedListNode&lt;T&gt; { <br/>            next: Option&lt;Rc&lt;LinkedListNode&lt;T&gt;&gt;&gt;, <br/>            prev: RefCell&lt;Option&lt;Weak&lt;LinkedListNode&lt;T&gt;&gt;&gt;&gt;, <br/>            data: T <br/>        }</pre>
<ol start="3">
<li>We change the <kbd>append</kbd> method to create a new <kbd>RefCell</kbd> and update the previous reference via the <kbd>RefCell</kbd> mutable borrow:</li>
</ol>
<pre>    // rc_3.rs<br/><br/>    fn append(&amp;mut self, data: T) -&gt; Self { <br/>        let new_node = Rc::new(LinkedListNode { <br/>            data: data, <br/>            next: self.head.Clone(), <br/>            prev: RefCell::new(None) <br/>        }); <br/><br/>        match self.head.Clone() { <br/>            Some(node) =&gt; { <br/>                let mut prev = node.prev.borrow_mut(); <br/>                *prev = Some(Rc::downgrade(&amp;new_node)); <br/>            }, <br/>            None =&gt; { <br/>            } <br/>        } <br/><br/>        LinkedList { <br/>            head: Some(new_node) <br/>        } <br/>    } <br/>} </pre>
<p>Whenever we're using <kbd>RefCell</kbd> borrows, it's a good practice to think carefully that we're using it in a safe way, since making mistakes there may lead to runtime panics. In this implementation, however, it's easy to see that we have just the single <kbd>borrow</kbd>, and that the closing block immediately discards it.</p>
<p>Apart from shared ownership, we can also get shared mutability at runtime with Rust's concept of interior mutability, which are modeled by special wrapper smart pointer types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interior mutability</h1>
                </header>
            
            <article>
                
<p>As we saw previously, Rust protects us at compile time from the pointer aliasing problem by allowing only a single mutable reference at any given scope. However, there are cases where it becomes too restrictive, making code that we know is safe not pass the compiler because of the strict borrow checking. For these situations, one of the solutions is to move the borrow checking from compile time to runtime, which is achieved with <em>interior mutability</em>. Before we talk about the types that enable interior mutability, we need to understand the concept of interior mutability and inherited mutability:</p>
<ul>
<li><strong>Inherited mutability</strong>: This is the default mutability you get when you take a <kbd>&amp;mut</kbd> reference to some struct. This also implies that you can modify any of the fields of the struct.</li>
<li><strong>Interior mutability</strong>: In this kind of mutability, even if you have a <kbd>&amp;SomeStruct</kbd> reference to some type, you can modify its fields if the fields have the type as  <kbd>Cell&lt;T&gt;</kbd> or <kbd>RefCell&lt;T&gt;</kbd>.</li>
</ul>
<p>Interior mutability allows for bending the borrowing rules a bit, but it also puts the burden on the programmer to ensure that no two mutable borrows are present at runtime. These types offload the detection of multiple mutable references from compile time to runtime and undergo a panic if two mutable references to a value exist. Interior mutability is often used when you want to expose an immutable API to users, despite having mutable parts to the API internally. The standard library has two generic smart pointer types that provide shared mutability: <kbd>Cell</kbd> and <kbd>RefCell</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cell&lt;T&gt;</h1>
                </header>
            
            <article>
                
<p>Consider this program, where we have a requirement to mutate <kbd>bag</kbd> with two mutable references to it:</p>
<pre>// without_cell.rs<br/> <br/>use std::cell::Cell; <br/><br/>#[derive(Debug)]<br/>struct Bag { <br/>    item: Box&lt;u32&gt;<br/>} <br/><br/>fn main() { <br/>    let mut bag = Cell::new(Bag { item: Box::new(1) }); <br/>    let hand1 = &amp;mut bag;<br/>    let hand2 = &amp;mut bag;<br/>    *hand1 = Cell::new(Bag {item: Box::new(2)});<br/>    *hand2 = Cell::new(Bag {item: Box::new(2)});<br/>}</pre>
<p>But, of course, this does not compile due to the borrow checking rules:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/33ba5351-d6a9-4987-866e-a6f114f2995c.png" style="width:38.25em;height:13.08em;"/></p>
<p>We can make this work by encapsulating the <kbd>bag</kbd> value inside a <kbd>Cell</kbd>. Our code is updated as follows:</p>
<pre>// cell.rs<br/> <br/>use std::cell::Cell; <br/><br/>#[derive(Debug)]<br/>struct Bag { <br/>    item: Box&lt;u32&gt;<br/>} <br/><br/>fn main() { <br/>    let bag = Cell::new(Bag { item: Box::new(1) }); <br/>    let hand1 = &amp;bag;<br/>    let hand2 = &amp;bag;<br/>    hand1.set(Bag { item: Box::new(2)}); <br/>    hand2.set(Bag { item: Box::new(3)});<br/>}</pre>
<p>This works as you would expect, and the only added cost is that you have to write a bit more. The additional runtime cost is zero, though, and the references to the mutable things remain immutable.</p>
<p>The <kbd>Cell&lt;T&gt;</kbd> type is a smart pointer type that enables mutability for values, even behind an immutable reference. It provides this capability with very minimal overhead and has a minimal API:</p>
<ul>
<li><kbd>Cell::new</kbd> method allows you to create new instances of the <kbd>Cell</kbd> type by passing it any type <kbd>T</kbd>.</li>
<li><kbd>get</kbd>: The <kbd>get</kbd> method allows you to copy of the value in the cell. This method is only available if the wrapped type <kbd>T</kbd> is <kbd>Copy</kbd>.</li>
<li><kbd>set</kbd>: Allows you to modify the inner value, even behind a immutable reference.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RefCell&lt;T&gt;</h1>
                </header>
            
            <article>
                
<p>If you need Cell-like features for non-Copy types, there is the <kbd>RefCell</kbd> type. It uses a read/write pattern similar to how borrowing works, but moves the checks to runtime, which is convenient but not zero-cost. RefCell hands out references to the value, instead of returning things by value as is the case with the <kbd>Cell</kbd> type. Here's a sample program that </p>
<pre>// refcell_basics.rs<br/> <br/>use std::cell::RefCell; <br/><br/>#[derive(Debug)]<br/>struct Bag { <br/>    item: Box&lt;u32&gt;<br/>} <br/><br/>fn main() { <br/>    let bag = RefCell::new(Bag { item: Box::new(1) }); <br/>    let hand1 = &amp;bag;<br/>    let hand2 = &amp;bag;<br/>    *hand1.borrow_mut() = Bag { item: Box::new(2)}; <br/>    *hand2.borrow_mut() = Bag { item: Box::new(3)};<br/>    let borrowed = hand1.borrow();<br/>    println!("{:?}", borrowed);<br/>}</pre>
<p>As you can see, we can borrow <kbd>bag</kbd>, mutably from <kbd>hand1</kbd> and <kbd>hand2</kbd> even though they are declared as immutable variables. To modify the items in bag, we called <kbd>borrow_mut</kbd> on <kbd>hand1</kbd> and <kbd>hand2</kbd>. Later, we borrow it immutably and print the contents.</p>
<p>The <kbd>RefCell</kbd> type provides us with the following two borrowing methods:</p>
<ul>
<li>The <kbd>borrow</kbd> method takes a new immutable reference</li>
<li>The <kbd>borrow_mut</kbd> method takes a new mutable reference</li>
</ul>
<p>Now, if we try to call both of the methods in the same scope: by changing the last line in the preceding code to this:</p>
<pre>println!("{:?} {:?}", hand1.borrow(), hand1.borrow_mut());</pre>
<p>We get to see the following upon running the program:</p>
<pre>thread 'main' panicked at 'already borrowed: BorrowMutError', src/libcore/result.rs:1009:5<br/>note: Run with `RUST_BACKTRACE=1` for a backtrace.</pre>
<p>A runtime panic ! This is because of the same ownership rule of having exclusive mutable access. But, for <kbd>RefCell</kbd> this is checked at runtime instead. For situations like this, one has to explicitly use bare blocks to separate the borrows or use the drop method to drop the reference.</p>
<div class="packt_infobox"><strong>Note</strong>: The Cell and RefCell types are not thread safe. This simply means that Rust won't allow you to share these types in multiple threads.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uses of interior mutability</h1>
                </header>
            
            <article>
                
<p>In the previous section, the examples on using <kbd>Cell</kbd> and <kbd>RefCell</kbd> were simplified, and you most probably won't need to use them in that form in real code. Let's take a look at some actual benefits that these types would give us.</p>
<p>As we mentioned previously, the mutability of a binding is not fine-grained; a value is either immutable or mutable, and that includes all of its fields if it's a struct or an enum. <kbd>Cell</kbd> and <kbd>RefCell</kbd> can turn an immutable thing into something that's<span> mutable, allowing us to define parts of an immutable struct as mutable.</span></p>
<p>The following piece of code augments a struct with two integers and a <kbd>sum</kbd> method to cache the answer of the <kbd>sum</kbd> and return the cached value if it exists:</p>
<pre>// cell_cache.rs<br/> <br/>use std::cell::Cell; <br/><br/>struct Point { <br/>    x: u8, <br/>    y: u8, <br/>    cached_sum: Cell&lt;Option&lt;u8&gt;&gt; <br/>} <br/><br/>impl Point { <br/>    fn sum(&amp;self) -&gt; u8 { <br/>        match self.cached_sum.get() { <br/>            Some(sum) =&gt; { <br/>                println!("Got from cache: {}", sum); <br/>                sum <br/>            }, <br/>            None =&gt; { <br/>                let new_sum = self.x + self.y; <br/>                self.cached_sum.set(Some(new_sum)); <br/>                println!("Set cache: {}", new_sum); <br/>                new_sum <br/>            } <br/>        } <br/>    } <br/>} <br/><br/>fn main() { <br/>    let p = Point { x: 8, y: 9, cached_sum: Cell::new(None) }; <br/>    println!("Summed result: {}", p.sum()); <br/>    println!("Summed result: {}", p.sum()); <br/>}<br/><br/></pre>
<p>The following is the output of this program:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f41687f3-2ef4-48b0-8059-b0f3b30d1ce3.png" style="width:29.75em;height:6.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Rust takes a low-level systems programming approach to memory management, promising C-like performance, sometimes even better. It does this without requiring a garbage collector through its use of ownership, lifetimes, and borrow semantics. We covered a whole lot of ground here in a subject that's probably the heaviest to grasp for a new Rustacean. That's what people familiar with Rust like to call themselves, and you are getting close to becoming one! Getting fluent in this shift of thinking of ownership at compile time takes a bit of time, but the investment in learning these concepts pays off in the form of reliable software with a small memory footprint.</p>
<p>Our next chapter will concern how fallible situations are handled in Rust. See you there!</p>


            </article>

            
        </section>
    </body></html>