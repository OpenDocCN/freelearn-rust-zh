["```rs\nextern crate futures;\n\nuse futures::prelude::*;\nuse futures::future::{self, FutureResult};\nuse futures::executor::block_on;\n\nfn main() {\n    let final_result = some_complex_computation().map(|res| (res - 10) / 7);\n\n    println!(\"Doing some other things while our result gets generated\");\n\n    match block_on(final_result) {\n        Ok(res) => println!(\"The result is {}\", res),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n\nfn some_complex_computation() -> FutureResult<u32, String> {\n    use std::thread;\n    use std::time::Duration;\n\n    thread::sleep(Duration::from_secs(5));\n\n    future::ok(150)\n}\n```", "```rs\n[dependencies]\nfutures = \"0.1\"\nfutures-timer = \"0.1\"\n```", "```rs\nextern crate futures;\nextern crate futures_timer;\n\nuse std::time::Duration;\n\nuse futures::prelude::*;\nuse futures_timer::Interval;\nuse futures::future::ok;\n\nfn main() {\n    Interval::new(Duration::from_secs(1))\n        .take(5)\n        .for_each(|_| {\n            println!(\"New interval\");\n            ok(())\n        })\n        .wait()\n        .unwrap();\n}\n```", "```rs\nextern crate tokio;\n\nuse tokio::prelude::*;\nuse tokio::net::TcpListener;\nuse tokio::io;\n\nfn main() {\n    let address = \"127.0.0.1:8000\".parse().unwrap();\n    let listener = TcpListener::bind(&address).unwrap();\n\n    let server = listener\n        .incoming()\n        .map_err(|e| eprintln!(\"Error accepting connection: {:?}\", e))\n        .for_each(|socket| {\n            let (reader, writer) = socket.split();\n            let copied = io::copy(reader, writer);\n\n            let handler = copied\n                .map(|(count, _reader, _writer)| println!(\"{} bytes \n                  received\", count))\n                .map_err(|e| eprintln!(\"Error: {:?}\", e));\n\n            tokio::spawn(handler)\n        });\n\n    tokio::run(server);\n}\n```", "```rs\nextern crate bytes;\nextern crate tokio;\nextern crate tokio_io;\n\nuse std::io;\n\nuse tokio_io::codec::{Decoder, Encoder};\nuse bytes::BytesMut;\n\n#[derive(Debug, Default)]\nstruct ADividerCodec {\n    next_index: usize,\n}\n\nimpl Decoder for ADividerCodec {\n    type Item = String;\n    type Error = io::Error;\n\n    fn decode(&mut self, buf: &mut BytesMut)\n    -> Result<Option<Self::Item>, Self::Error> {\n        if let Some(new_offset) = \n          buf[self.next_index..].iter().position(|b| *b == b'a') {\n            let new_index = new_offset + self.next_index;\n            let res = buf.split_to(new_index + 1);\n            let res = &res[..res.len() - 1];\n            let res: Vec<_> = res.into_iter()\n                .cloned()\n                .filter(|b| *b != b'\\r' && *b != b'\\n')\n                .collect();\n            let res = String::from_utf8(res).map_err(|_| {\n                io::Error::new(\n                    io::ErrorKind::InvalidData,\n                    \"Unable to decode input as UTF8\"\n                )\n            })?;\n            self.next_index = 0;\n            Ok(Some(res))\n        } else {\n            self.next_index = buf.len();\n            Ok(None)\n        }\n    }\n\n    fn decode_eof(&mut self, buf: &mut BytesMut)\n    -> Result<Option<String>, io::Error> {\n        Ok(match self.decode(buf)? {\n            Some(frame) => Some(frame),\n            None => {\n                // No terminating 'a' - return remaining data, if any\n                if buf.is_empty() {\n                    None\n                } else {\n                    let res = buf.take();\n                    let res: Vec<_> = res.into_iter()\n                        .filter(|b| *b != b'\\r' && *b != b'\\n')\n                        .collect();\n                    let res = String::from_utf8(res).map_err(|_| {\n                        io::Error::new(\n                            io::ErrorKind::InvalidData,\n                            \"Unable to decode input as UTF8\"\n                        )\n                    })?;\n                    self.next_index = 0;\n                    Some(res)\n                }\n            }\n        })\n    }\n}\n```", "```rs\nimpl Encoder for ADividerCodec {\n    type Item = String;\n    type Error = io::Error;\n\n    fn encode(&mut self, chunk: Self::Item, buf: &mut BytesMut)\n    -> Result<(), io::Error> {\n        use bytes::BufMut;\n\n        buf.reserve(chunk.len() + 1);\n        buf.put(chunk);\n        buf.put_u8(b'a');\n        Ok(())\n    }\n}\n```", "```rs\nuse tokio::prelude::*;\nuse tokio::net::TcpListener;\n\nfn main() {\n    let address = \"127.0.0.1:8000\".parse().unwrap();\n    let listener = TcpListener::bind(&address).unwrap();\n\n    let server = listener\n        .incoming()\n        .map_err(|e| eprintln!(\"Error accepting connection: {:?}\", e))\n        .for_each(|socket| {\n            tokio::spawn(\n                socket\n                    .framed(ADividerCodec::default())\n                    .for_each(|chunk| {\n                        println!(\"{}\", chunk);\n                        Ok(())\n                    })\n                    .map_err(|e| eprintln!(\"Error: {:?}\", e)),\n            )\n        });\n\n    println!(\"Running Tokio server...\");\n    tokio::run(server);\n}\n```", "```rs\nextern crate futures;\nextern crate tokio_core;\nextern crate websocket;\n\nuse websocket::message::OwnedMessage;\nuse websocket::server::InvalidConnection;\nuse websocket::async::Server;\n\nuse tokio_core::reactor::Core;\nuse futures::{Future, Sink, Stream};\n\nfn main() {\n    let mut core = Core::new().unwrap();\n    let handle = core.handle();\n    let server = Server::bind(\"127.0.0.1:2794\", &handle).unwrap();\n\n    let task = server\n        .incoming()\n        .map_err(|InvalidConnection { error, .. }| error)\n        .for_each(|(upgrade, addr)| {\n            println!(\"Got a connection from: {}\", addr);\n\n            if !upgrade.protocols().iter().any(|s| s == \"rust-websocket\") {\n                handle.spawn(\n                    upgrade\n                        .reject()\n                        .map_err(|e| println!(\"Error: '{:?}'\", e))\n                        .map(|_| {}),\n                );\n                return Ok(());\n            }\n\n            let fut = upgrade\n                .use_protocol(\"rust-websocket\")\n                .accept()\n                .and_then(|(client, _)| {\n                    let (sink, stream) = client.split();\n\n                    stream\n                        .take_while(|m| Ok(!m.is_close()))\n                        .filter_map(|m| match m {\n                            OwnedMessage::Ping(p) => {\n                                Some(OwnedMessage::Pong(p))\n                            }\n                            OwnedMessage::Pong(_) => None,\n                            _ => Some(m),\n                        })\n                        .forward(sink)\n                        .and_then(|(_, sink)| {\n                            sink.send(OwnedMessage::Close(None))\n                        })\n                });\n\n            handle.spawn(\n                fut.map_err(|e| {\n                    println!(\"Error: {:?}\", e)\n                }).map(|_| {}));\n            Ok(())\n        });\n\n    core.run(task).unwrap();\n}\n```", "```rs\n#![feature(generators, generator_trait)]\n\nuse std::ops::{Generator, GeneratorState};\n\nfn main() {\n    let mut generator = || {\n        for i in 0..10 {\n            yield i;\n        }\n        return \"Finished!\";\n    };\n\n    loop {\n        match generator.resume() {\n            GeneratorState::Yielded(num) => println!(\"Yielded {}\", num),\n            GeneratorState::Complete(text) => {\n                println!(\"{}\", text);\n                break;\n            }\n        }\n    }\n}\n```", "```rs\n#![feature(generators, generator_trait)]\n\nuse std::ops::Generator;\n\nfn main() {\n    let mut generator = || {\n        println!(\"Before yield\");\n        yield;\n        println!(\"After yield\");\n    };\n\n    println!(\"Starting generator...\");\n    generator.resume();\n    println!(\"Generator started\");\n    generator.resume();\n    println!(\"Generator finished\");\n}\n```", "```rs\n#![feature(proc_macro, conservative_impl_trait, generators)]\n\nextern crate futures_await as futures;\n\nuse futures::prelude::*;\nuse futures::executor::block_on;\n\n#[async]\nfn retrieve_data_1() -> Result<i32, i32> {\n    Ok(1)\n}\n\n#[async]\nfn retrieve_data_2() -> Result<i32, i32> {\n    Ok(2)\n}\n\n#[async_move]\nfn add_data() -> Result<i32, i32> {\n    Ok(await!(retrieve_data_1())? + await!(retrieve_data_2())?)\n}\n\nfn main() {\n    println!(\"Result: {:?}\", block_on(add_data()));\n}\n```"]