["```rs\nfn main() {\n   let m: Vec<u64> = vec![1, 2, 3];\n   let n: Vec<u64> = m.iter().map(|x| { x*x }).collect();\n   println!(\"{:?}\", m);\n   println!(\"{:?}\", n);\n}\n```", "```rs\nuse std::collections::{HashSet};\n\nfn main() {\n   let mut a: HashSet<u64> = HashSet::new();\n   a.insert(1);\n   a.insert(2);\n   a.insert(3);\n   a.insert(4);\n   let b: HashSet<u64> = a.iter().cloned().map(|x| x/2).collect();\n   println!(\"{:?}\", a);\n   println!(\"{:?}\", b);\n}\n```", "```rs\nfn main() {\n   let sentences = vec![\"this is a sentence\",\"paragraphs have many sentences\"];\n   let words:Vec<&str> = sentences.iter().flat_map(|&x| x.split(\" \")).collect();\n   println!(\"{:?}\", sentences);\n   println!(\"{:?}\", words);\n}\n```", "```rs\nuse std::collections::{HashSet};\n\nfn main() {\n   let v: Vec<u64> = vec![1, 2, 3];\n   let s: HashSet<u64> = v.iter().cloned().map(|x| x/2).collect();\n   println!(\"{:?}\", v);\n   println!(\"{:?}\", s);\n}\n```", "```rs\nstruct WebCamera;\n\n#[derive(Debug)]\nenum VisibleEmotion {\n   Anger,\n   Contempt,\n   Disgust,\n   Fear,\n   Happiness,\n   Neutral,\n   Sadness,\n   Surprise\n}\n\n#[derive(Debug,Clone)]\nstruct BoundingBox {\n   top: u64,\n   left: u64,\n   height: u64,\n   width: u64\n}\n\n#[derive(Debug)]\nenum CameraFilters {\n   Sparkles,\n   Rain,\n   Fire,\n   Disco\n}\n\n```", "```rs\nimpl WebCamera {\n   fn map_emotion<T,F>(&self, translate: F) -> Vec<(BoundingBox,T)>\n   where F: Fn(VisibleEmotion) -> T {\n      //Simulate emotion extracted from WebCamera\n      vec![\n         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Anger),\n         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Sadness),\n         (BoundingBox { top: 4, left: 4, height: 1, width: 1 }, VisibleEmotion::Surprise),\n         (BoundingBox { top: 8, left: 1, height: 1, width: 1 }, VisibleEmotion::Neutral)\n      ].into_iter().map(|(bb,emt)| {\n         (bb, translate(emt))\n      }).collect::<Vec<(BoundingBox,T)>>()\n   }\n   fn flatmap_emotion<T,F,U:IntoIterator<Item=T>>(&self, mut translate: F) -> Vec<(BoundingBox,T)>\n   where F: FnMut(VisibleEmotion) -> U {\n      //Simulate emotion extracted from WebCamera\n      vec![\n         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Anger),\n         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Sadness),\n         (BoundingBox { top: 4, left: 4, height: 1, width: 1 }, VisibleEmotion::Surprise),\n         (BoundingBox { top: 8, left: 1, height: 1, width: 1 }, VisibleEmotion::Neutral)\n      ].into_iter().flat_map(|(bb,emt)| {\n         translate(emt).into_iter().map(move |t| (bb.clone(), t))\n      }).collect::<Vec<(BoundingBox,T)>>()\n   }\n}\n\n```", "```rs\nfn main() {\n   let camera = WebCamera;\n   let emotes: Vec<(BoundingBox,VisibleEmotion)> = camera.map_emotion(|emt| {\n      match emt {\n         VisibleEmotion::Anger |\n         VisibleEmotion::Contempt |\n         VisibleEmotion::Disgust |\n         VisibleEmotion::Fear |\n         VisibleEmotion::Sadness => VisibleEmotion::Happiness,\n         VisibleEmotion::Neutral |\n         VisibleEmotion::Happiness |\n         VisibleEmotion::Surprise => VisibleEmotion::Sadness\n      }\n   });\n\n   let filters: Vec<(BoundingBox,CameraFilters)> = camera.flatmap_emotion(|emt| {\n      match emt {\n         VisibleEmotion::Anger |\n         VisibleEmotion::Contempt |\n         VisibleEmotion::Disgust |\n         VisibleEmotion::Fear |\n         VisibleEmotion::Sadness => vec![CameraFilters::Sparkles, CameraFilters::Rain],\n         VisibleEmotion::Neutral |\n         VisibleEmotion::Happiness |\n         VisibleEmotion::Surprise => vec![CameraFilters::Disco]\n      }\n   });\n\n   println!(\"{:?}\",emotes);\n   println!(\"{:?}\",filters);\n}\n```", "```rs\nMyMonad::return(value)  //We start with a new MyMonad<A>\n        .bind(|x| x+x)  //We take a step into MyMonad<B>\n        .bind(|y| y*y); //Similarly we get to MyMonad<C>\n```", "```rs\nfn main()\n{\n   let v1 = Some(2).and_then(|x| Some(x+x)).and_then(|y| Some(y*y));\n   println!(\"{:?}\", v1);\n\n   let v2 = None.or_else(|| None).or_else(|| Some(222));\n   println!(\"{:?}\", v2);\n}\n```", "```rs\nfn main() {\n   let v3 = Some(2).and_then(|x| Some(\"abc\"));\n   println!(\"{:?}\", v3);\n\n   // or_else is not quite a monad\n   // does not permit polymorphic bind\n   //let v4 = Some(2).or_else(|| Some(\"abc\"));\n   //println!(\"{:?}\", v4);\n}\n```", "```rs\nuse std::fmt::{Debug};\n\nstruct LogMonad<T>(T);\nimpl<T> LogMonad<T> {\n   fn _return(t: T) -> LogMonad<T>\n   where T: Debug {\n      println!(\"{:?}\", t);\n      LogMonad(t)\n   }\n   fn bind<R,F>(&self, f: F) -> LogMonad<R>\n   where F: FnOnce(&T) -> R,\n   R: Debug {\n      let r = f(&self.0);\n      println!(\"{:?}\", r);\n      LogMonad(r)\n   }\n}\n\nfn main() {\n   LogMonad::_return(4)\n            .bind(|x| x+x)\n            .bind(|y| y*y)\n            .bind(|z| format!(\"{}{}{}\", z, z, z));\n}\n```", "```rs\nstruct LazyMonad<A,B>(Box<Fn(A) -> B>);\n\nimpl<A: 'static,B: 'static> LazyMonad<A,B> {\n   fn _return(u: A) -> LazyMonad<B,B> {\n      LazyMonad(Box::new(move |b: B| b))\n   }\n   fn bind<C,G: 'static>(self, g: G) -> LazyMonad<A,C>\n   where G: Fn(B) -> C {\n      LazyMonad(Box::new(move |a: A| g(self.0(a))))\n   }\n   fn apply(self, a: A) -> B {\n      self.0(a)\n   }\n}\n\nfn main() {\n   let notyet = LazyMonad::_return(())   //we create LazyMonad<()>\n                          .bind(|x| x+2) //and now a LazyMonad<A>\n                          .bind(|y| y*3) //and now a LazyMonad<B>\n                          .bind(|z| format!(\"{}{}\", z, z));\n\n   let nowdoit = notyet.apply(222); //The above code now run\n   println!(\"nowdoit {}\", nowdoit);\n}\n```", "```rs\nuse std::io::prelude::*;\nuse std::net::TcpListener;\nuse std::net::TcpStream;\n\nstruct ServerMonad<St> {\n   state: St,\n   handlers: Vec<Box<Fn(&mut St,&String) -> Option<String>>>\n}\n\nimpl<St: Clone> ServerMonad<St> {\n   fn _return(st: St) -> ServerMonad<St> {\n      ServerMonad {\n         state: st,\n         handlers: Vec::new()\n      }\n   }\n   fn listen(&mut self, address: &str) {\n      let listener = TcpListener::bind(address).unwrap();\n      for stream in listener.incoming() {\n         let mut st = self.state.clone();\n         let mut buffer = [0; 2048];\n         let mut tcp = stream.unwrap();\n         tcp.read(&mut buffer);\n         let buffer = String::from_utf8_lossy(&buffer).into_owned();\n         for h in self.handlers.iter() {\n            if let Some(response) = h(&mut st,&buffer) {\n               tcp.write(response.as_bytes());\n               break\n            }\n         }\n      }\n   }\n   fn bind_handler<F>(mut self, f: F) -> Self\n      where F: 'static + Fn(&mut St,&String) -> Option<String> {\n      self.handlers.push(Box::new(f));\n      self\n   }\n}\n```", "```rs\nfn main() {\n   ServerMonad::_return(())\n               .bind_handler(|&mut st, ref msg| if msg.len()%2 == 0 { Some(\"divisible by 2\".to_string()) } else { None })\n               .bind_handler(|&mut st, ref msg| if msg.len()%3 == 0 { Some(\"divisible by 3\".to_string()) } else { None })\n               .bind_handler(|&mut st, ref msg| if msg.len()%5 == 0 { Some(\"divisible by 5\".to_string()) } else { None })\n               .bind_handler(|&mut st, ref msg| if msg.len()%7 == 0 { Some(\"divisible by 7\".to_string()) } else { None })\n               .listen(\"127.0.0.1:8888\");\n}\n```", "```rs\nfn compose<A,B,C,F,G>(f: F, g: G) -> impl Fn(A) -> C\n   where F: 'static + Fn(A) -> B,\n         G: 'static + Fn(B) -> C {\n   move |x| g(f(x))\n}\n\nfn main() {\n   let fa = |x| x+1;\n   let fb = |y| y*2;\n   let fc = |z| z/3;\n   let g = compose(compose(fa,fb),fc);\n   println!(\"g(1) = {}\", g(1));\n   println!(\"g(12) = {}\", g(12));\n   println!(\"g(123) = {}\", g(123));\n}\n```", "```rs\n#[macro_use]\nextern crate chomp;\nuse chomp::prelude::*;\n\n#[derive(Debug, Eq, PartialEq)]\nstruct Name<B: Buffer> {\n   first: B,\n   last:  B,\n}\n\nfn name<I: U8Input>(i: I) -> SimpleResult<I, Name<I::Buffer>> {\n   parse!{i;\n      let first = take_while1(|c| c != b' ');\n      token(b' ');  // skipping this char\n      let last  = take_while1(|c| c != b'\\n');\n\n      ret Name{\n         first: first,\n         last:  last,\n      }\n   }\n}\n\nfn main() {\n   let parse_result = parse_only(name, \"Martin Wernst√•l\\n\".as_bytes()).unwrap();\n   println!(\"first:{} last:{}\",\n\n```", "```rs\n      String::from_utf8_lossy(parse_result.first),\n      String::from_utf8_lossy(parse_result.last));\n}\n```", "```rs\nuse std::rc::Rc;\n\n#[derive(Clone)]\nstruct ParseState<A: Clone> {\n   buffer: Rc<Vec<char>>,\n   index: usize,\n   a: A\n}\n\nimpl<A: Clone> ParseState<A> {\n   fn new(a: A, buffer: String) -> ParseState<A> {\n      let buffer: Vec<char> = buffer.chars().collect();\n      ParseState {\n         buffer: Rc::new(buffer),\n         index: 0,\n         a: a\n      }\n   }\n   fn next(&self) -> (ParseState<A>,Option<char>) {\n      if self.index < self.buffer.len() {\n         let new_char = self.buffer[self.index];\n         let new_index = self.index + 1;\n         (ParseState {\n            buffer: Arc::clone(&self.buffer),\n            index: new_index,\n            a: self.a.clone()\n         }, Some(new_char))\n      } else {\n         (ParseState {\n            buffer: Rc::clone(&self.buffer),\n            index: self.index,\n            a: self.a.clone()\n         },None)\n      }\n   }\n}\n\n#[derive(Debug)]\nstruct ParseRCon<A,B>(A,Result<Option<B>,String>);\n\n#[derive(Debug)]\nenum ParseOutput<A> {\n   Success(A),\n   Failure(String)\n}\n```", "```rs\nfn parse<St: Clone,A,P>(p: &P, st: &ParseState<St>) -> ParseOutput<A>\n   where P: Fn(ParseState<St>) -> ParseRCon<ParseState<St>,A> {\n   match p(st.clone()) {\n      ParseRCon(_,Ok(Some(a))) => ParseOutput::Success(a),\n      ParseRCon(_,Ok(None)) => ParseOutput::Failure(\"expected input\".to_string()),\n      ParseRCon(_,Err(err)) => ParseOutput::Failure(err)\n   }\n}\n\nfn parse_mzero<St: Clone,A>(st: ParseState<St>) -> ParseRCon<ParseState<St>,A> {\n   ParseRCon(st,Err(\"mzero failed\".to_string()))\n}\n\nfn parse_return<St: Clone,A: Clone>(a: A) -> impl (Fn(ParseState<St>) -> ParseRCon<ParseState<St>,A>) {\n   move |st| { ParseRCon(st,Ok(Some(a.clone()))) }\n}\n\nfn main() {\n   let input1 = ParseState::new((), \"1 + 2 * 3\".to_string());\n   let input2 = ParseState::new((), \"3 / 2 - 1\".to_string());\n\n   let p1 = parse_mzero::<(),()>;\n   println!(\"p1 input1: {:?}\", parse(&p1,&input1));\n   println!(\"p1 input2: {:?}\", parse(&p1,&input2));\n\n   let p2 = parse_return(123);\n   println!(\"p2 input1: {:?}\", parse(&p2,&input1));\n   println!(\"p2 input2: {:?}\", parse(&p2,&input2));\n}\n```", "```rs\nfn parse_token<St: Clone,A,T>(t: T) -> impl (Fn(ParseState<St>) -> ParseRCon<ParseState<St>,A>)\n   where T: 'static + Fn(char) -> Option<A> {\n   move |st: ParseState<St>| {\n      let (next_state,next_char) = st.clone().next();\n      match next_char {\n         Some(c) => ParseRCon(next_state,Ok(t(c))),\n         None => ParseRCon(st,Err(\"end of input\".to_string()))\n      }\n   }\n}\n\nfn parse_satisfy<St: Clone,T>(t: T) -> impl (Fn(ParseState<St>) -> ParseRCon<ParseState<St>,char>)\n   where T: 'static + Fn(char) -> bool {\n   parse_token(move |c| if t(c) {Some(c)} else {None})\n}\n\nfn main() {\n   let input1 = ParseState::new((), \"1 + 2 * 3\".to_string());\n   let input2 = ParseState::new((), \"3 / 2 - 1\".to_string());\n\n   let p3 = parse_satisfy(|c| c=='1');\n   println!(\"p3 input1: {:?}\", parse(&p3,&input1));\n   println!(\"p3 input2: {:?}\", parse(&p3,&input2));\n\n   let digit = parse_satisfy(|c| c.is_digit(10));\n   println!(\"digit input1: {:?}\", parse(&digit,&input1));\n   println!(\"digit input2: {:?}\", parse(&digit,&input2));\n\n   let space = parse_satisfy(|c| c==' ');\n   println!(\"space input1: {:?}\", parse(&space,&input1));\n   println!(\"space input2: {:?}\", parse(&space,&input2));\n\n   let operator = parse_satisfy(|c| c=='+' || c=='-' || c=='*' || c=='/');\n   println!(\"operator input1: {:?}\", parse(&operator,&input1));\n   println!(\"operator input2: {:?}\", parse(&operator,&input2));\n}\n```", "```rs\nfn parse_bind<St: Clone,A,B,P1,P2,B1>(p1: P1, b1: B1)\n   -> impl Fn(ParseState<St>) -> ParseRCon<ParseState<St>,B>\n   where P1: Fn(ParseState<St>) -> ParseRCon<ParseState<St>,A>,\n         P2: Fn(ParseState<St>) -> ParseRCon<ParseState<St>,B>,\n         B1: Fn(A) -> P2 {\n   move |st| {\n      match p1(st) {\n         ParseRCon(nst,Ok(Some(a))) => b1(a)(nst),\n         ParseRCon(nst,Ok(None)) => ParseRCon(nst,Err(\"bind failed\".to_string())),\n         ParseRCon(nst,Err(err)) => ParseRCon(nst,Err(err))\n      }\n   }\n}\n\nfn parse_sequence<St: Clone,A,B,P1,P2>(p1: P1, p2: P2)\n   -> impl Fn(ParseState<St>) -> ParseRCon<ParseState<St>,B>\n   where P1: Fn(ParseState<St>) -> ParseRCon<ParseState<St>,A>,\n         P2: Fn(ParseState<St>) -> ParseRCon<ParseState<St>,B> {\n   move |st| {\n      match p1(st) {\n         ParseRCon(nst,Ok(_)) => p2(nst),\n         ParseRCon(nst,Err(err)) => ParseRCon(nst,Err(err))\n      }\n   }\n}\n\nfn parse_or<St: Clone,A,P1,P2>(p1: P1, p2: P2)\n   -> impl Fn(ParseState<St>) -> ParseRCon<ParseState<St>,A>\n   where P1: Fn(ParseState<St>) -> ParseRCon<ParseState<St>,A>,\n         P2: Fn(ParseState<St>) -> ParseRCon<ParseState<St>,A> {\n   move |st| {\n      match p1(st.clone()) {\n         ParseRCon(nst,Ok(Some(a))) => ParseRCon(nst,Ok(Some(a))),\n         ParseRCon(_,Ok(None)) => p2(st),\n         ParseRCon(nst,Err(err)) => ParseRCon(nst,Err(err))\n      }\n   }\n}\n\nfn main() {\n   let input1 = ParseState::new((), \"1 + 2 * 3\".to_string());\n   let input2 = ParseState::new((), \"3 / 2 - 1\".to_string());\n\n   let digit = parse_satisfy(|c| c.is_digit(10));\n   let space = parse_satisfy(|c| c==' ');\n   let operator = parse_satisfy(|c| c=='+' || c=='-' || c=='*' || c=='/');\n   let ps1 = parse_sequence(digit,space);\n   let ps2 = parse_sequence(ps1,operator);\n   println!(\"digit,space,operator input1: {:?}\", parse(&ps2,&input1));\n   println!(\"digit,space,operator input2: {:?}\", parse(&ps2,&input2));\n}\n```", "```rs\nfn main()\n{\n   2 + 3;\n\n   || 2 + 3;\n}\n```", "```rs\nfn main() {\n   let a = (0..10).map(|x| x * x);\n   //nothing yet\n\n   for x in a {\n      println!(\"{}\", x);\n\n```", "```rs\n   }\n   //now it ran\n}\n```", "```rs\nuse std::rc::Rc;\n\n#[derive(Clone)]\nstruct LazyList<A: Clone> {\n   buffer: Rc<Vec<A>>,\n   index: usize\n}\n\nimpl<A: Clone> LazyList<A> {\n   fn new(buf: Vec<A>) -> LazyList<A> {\n      LazyList {\n         buffer: Rc::new(buf),\n         index: 0\n      }\n   }\n   fn next(&self) -> Option<(LazyList<A>,A)> {\n      if self.index < self.buffer.len() {\n         let new_item = self.buffer[self.index].clone();\n         let new_index = self.index + 1;\n         Some((LazyList {\n            buffer: Rc::clone(&self.buffer),\n            index: new_index\n         },new_item))\n      } else {\n         None\n      }\n   }\n}\n\nfn main()\n{\n   let ll = LazyList::new(vec![1,2,3]);\n   let (ll1,a1) = ll.next().expect(\"expect 1 item\");\n   println!(\"lazy item 1: {}\", a1);\n\n   let (ll2,a2) = ll1.next().expect(\"expect 2 item\");\n   println!(\"lazy item 2: {}\", a2);\n\n   let (ll3,a3) = ll2.next().expect(\"expect 3 item\");\n   println!(\"lazy item 3: {}\", a3);\n\n   let (ll2,a2) = ll1.next().expect(\"expect 2 item\");\n   println!(\"lazy item 2: {}\", a2);\n}\n```", "```rs\nstruct ReactiveUnit<St,A,B> {\n   state: Arc<Mutex<St>>,\n   event_handler: Arc<Fn(&mut St,A) -> B>\n}\n\nimpl<St: 'static,A: 'static,B: 'static> ReactiveUnit<St,A,B> {\n   fn new<F>(st: St, f: F) -> ReactiveUnit<St,A,B>\n      where F: 'static + Fn(&mut St,A) -> B\n   {\n      ReactiveUnit {\n         state: Arc::new(Mutex::new(st)),\n         event_handler: Arc::new(f)\n      }\n   }\n   fn bind<G,C>(&self, g: G) -> ReactiveUnit<St,A,C>\n      where G: 'static + Fn(&mut St,B) -> C {\n      let ev = Arc::clone(&self.event_handler);\n      ReactiveUnit {\n         state: Arc::clone(&self.state),\n         event_handler: Arc::new(move |st: &mut St,a| {\n            let r = ev(st,a);\n            let r = g(st,r);\n            r\n         })\n      }\n   }\n   fn plus<St2: 'static,C: 'static>(&self, other: ReactiveUnit<St2,B,C>) -> ReactiveUnit<(Arc<Mutex<St>>,Arc<Mutex<St2>>),A,C> {\n      let ev1 = Arc::clone(&self.event_handler);\n      let st1 = Arc::clone(&self.state);\n      let ev2 = Arc::clone(&other.event_handler);\n      let st2 = Arc::clone(&other.state);\n      ReactiveUnit {\n         state: Arc::new(Mutex::new((st1,st2))),\n         event_handler: Arc::new(move |stst: &mut (Arc<Mutex<St>>,Arc<Mutex<St2>>),a| {\n            let mut st1 = stst.0.lock().unwrap();\n            let r = ev1(&mut st1, a);\n            let mut st2 = stst.1.lock().unwrap();\n            let r = ev2(&mut st2, r);\n            r\n         })\n      }\n   }\n   fn apply(&self, a: A) -> B {\n      let mut st = self.state.lock().unwrap();\n      (self.event_handler)(&mut st, a)\n   }\n}\n```", "```rs\nlet render1 = ReactiveUnit::new((),|(),()| {\n   let html = r###\"$('body').innerHTML = '\n      <header>\n         <h3 data-section=\"1\" class=\"active\">Section 1</h3>\n         <h3 data-section=\"2\">Section 2</h3>\n         <h3 data-section=\"3\">Section 3</h3>\n      </header>\n      <div>page content</div>\n    <footer>Copyright</footer>\n  ';\"###;\n  html.to_string()\n});\nprintln!(\"{}\", render1.apply(()));\n```", "```rs\nlet render2 = ReactiveUnit::new((),|(),section: usize| {\n\n   let section_1 = r###\"$('body').innerHTML = '\n      <header>\n         <h3 data-section=\"1\" class=\"active\">Section 1</h3>\n         <h3 data-section=\"2\">Section 2</h3>\n         <h3 data-section=\"3\">Section 3</h3>\n      </header>\n      <div>section 1 content</div>\n      <footer>Copyright</footer>\n    ';\"###;\n\n    let section_2 = r###\"$('body').innerHTML = '\n      <header>\n        <h3 data-section=\"1\">Section 1</h3>\n        <h3 data-section=\"2\" class=\"active\">Section 2</h3>\n        <h3 data-section=\"3\">Section 3</h3>\n      </header>\n      <div>section 2 content</div>\n      <footer>Copyright</footer>\n    ';\"###;\n\n    let section_3 = r###\"$('body').innerHTML = '\n      <header>\n        <h3 data-section=\"1\">Section 1</h3>\n        <h3 data-section=\"2\">Section 2</h3>\n        <h3 data-section=\"3\" class=\"active\">Section 3</h3>\n      </header>\n      <div>section 3 content</div>\n      <footer>Copyright</footer>\n   ';\"###;\n\n   if section==1 {\n      section_1.to_string()\n   } else if section==2 {\n      section_2.to_string()\n   } else if section==3 {\n      section_3.to_string()\n   } else {\n      panic!(\"unknown section\")\n   }\n});\n\nprintln!(\"{}\", render2.apply(1));\nprintln!(\"{}\", render2.apply(2));\nprintln!(\"{}\", render2.apply(3));\n```", "```rs\nlet render3header = ReactiveUnit::new(None,|opsec: &mut Option<usize>,section: usize| {\n   let section_1 = r###\"$('header').innerHTML = '\n      <h3 data-section=\"1\" class=\"active\">Section 1</h3>\n      <h3 data-section=\"2\">Section 2</h3>\n      <h3 data-section=\"3\">Section 3</h3>\n   ';\"###;\n   let section_2 = r###\"$('header').innerHTML = '\n      <h3 data-section=\"1\">Section 1</h3>\n      <h3 data-section=\"2\" class=\"active\">Section 2</h3>\n      <h3 data-section=\"3\">Section 3</h3>\n   ';\"###;\n   let section_3 = r###\"$('header').innerHTML = '\n      <h3 data-section=\"1\">Section 1</h3>\n      <h3 data-section=\"2\">Section 2</h3>\n      <h3 data-section=\"3\" class=\"active\">Section 3</h3>\n   ';\"###;\n   let changed = if section==1 {\n      section_1\n   } else if section==2 {\n      section_2\n   } else if section==3 {\n      section_3\n   } else {\n      panic!(\"invalid section\")\n   };\n   if let Some(sec) = *opsec {\n      if sec==section { \"\" }\n      else {\n         *opsec = Some(section);\n         changed\n      }\n   } else {\n      *opsec = Some(section);\n      changed\n   }\n});\n\n```", "```rs\nlet render3content = ReactiveUnit::new(None,|opsec: &mut Option<usize>,section: usize| {\n   let section_1 = r###\"$('div#content').innerHTML = '\n      section 1 content\n   ';\"###;\n   let section_2 = r###\"$('div#content').innerHTML = '\n      section 2 content\n   ';\"###;\n   let section_3 = r###\"$('div#content').innerHTML = '\n      section 3 content\n   ';\"###;\n   let changed = if section==1 {\n      section_1\n   } else if section==2 {\n      section_2\n   } else if section==3 {\n      section_3\n   } else {\n      panic!(\"invalid section\")\n   };\n   if let Some(sec) = *opsec {\n      if sec==section { \"\" }\n      else {\n         *opsec = Some(section);\n         changed\n      }\n   } else {\n      *opsec = Some(section);\n      changed\n   }\n});\n```", "```rs\nlet render3 = ReactiveUnit::new((render3header,render3content), |(rheader,rcontent),section: usize| {\n   let header = rheader.apply(section);\n   let content = rcontent.apply(section);\n   format!(\"{}{}\", header, content)\n});\n```", "```rs\nprintln!(\"section 1: {}\", render3.apply(1));\nprintln!(\"section 2: {}\", render3.apply(2));\nprintln!(\"section 2: {}\", render3.apply(2));\nprintln!(\"section 3: {}\", render3.apply(3));\n```", "```rs\nlet database = (\"hello world\", 5, 2);\nlet react1 = ReactiveUnit::new((database,render3), |(database,render),evt:(&str,&str)| {\n   match evt {\n      (\"header button click\",n) => render.apply(n.parse::<usize>().unwrap()),\n      (\"text submission\",s) => { database.0 = s; format!(\"db.textfield1.set(\\\"{}\\\")\",s) },\n      (\"number 1 submission\",n) => { database.1 += n.parse::<i32>().unwrap(); format!(\"db.numfield1.set(\\\"{}\\\")\",database.1) },\n      (\"number 2 submission\",n) => { database.2 += n.parse::<i32>().unwrap(); format!(\"db.numfield2.set(\\\"{}\\\")\",database.2) },\n      _ => \"\".to_string()\n   }\n});\n\nprintln!(\"react 1: {}\", react1.apply((\"header button click\",\"2\")));\nprintln!(\"react 1: {}\", react1.apply((\"header button click\",\"2\")));\nprintln!(\"react 1: {}\", react1.apply((\"text submission\",\"abc def\")));\nprintln!(\"react 1: {}\", react1.apply((\"number 1 submission\",\"123\")));\nprintln!(\"react 1: {}\", react1.apply((\"number 1 submission\",\"234\")));\nprintln!(\"react 1: {}\", react1.apply((\"number 2 submission\",\"333\")));\nprintln!(\"react 1: {}\", react1.apply((\"number 2 submission\",\"222\")));\n```", "```rs\nevent: (\"header button click\", \"2\")\n$('header').innerHTML = '\n   <h3 data-section=\"1\">Section 1</h3>\n   <h3 data-section=\"2\" class=\"active\">Section 2</h3>\n   <h3 data-section=\"3\">Section 3</h3>\n';$('div#content').innerHTML = '\n   section 2 content\n';\n\nevent: (\"header button click\", \"2\")\n\nevent: (\"text submission\", \"abc def\")\ndb.textfield1.set(\"abc def\")\n\nevent: (\"number 1 submission\", \"123\")\ndb.numfield1.set(\"128\")\n\nevent: (\"number 1 submission\", \"234\")\ndb.numfield1.set(\"362\")\n\nevent: (\"number 2 submission\", \"333\")\ndb.numfield2.set(\"335\")\n\nevent: (\"number 2 submission\", \"222\")\ndb.numfield2.set(\"557\")\n```"]