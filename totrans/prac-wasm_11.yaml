- en: '*Chapter 8*: Bundling WebAssembly Using wasm-pack'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：使用wasm-pack打包WebAssembly'
- en: JavaScript is omnipresent, but being everywhere is both an advantage and a disadvantage.
    There are many different ecosystems that have various standards and purposes.
    Building a unique solution for all ecosystems is not practical.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript无处不在，但无处不在既是优点也是缺点。有许多不同的生态系统，它们有不同的标准和目的。为所有生态系统构建独特的解决方案并不实际。
- en: Despite all this, the JavaScript community is doing a wonderful job here. The
    effort from the community makes JavaScript one of the go-to languages. For a language
    as versatile as JavaScript, there will be some weird corners (which of course
    every language has). When you are writing JavaScript, these need extra care and
    attention.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，JavaScript社区在这里做得非常出色。社区的付出使JavaScript成为首选语言之一。对于像JavaScript这样多才多艺的语言，总会有些奇怪的地方（当然，每种语言都有）。当您编写JavaScript时，这些地方需要额外的关注和注意。
- en: JavaScript is dynamically typed. This makes it difficult (almost impossible)
    to avoid runtime exceptions. While TypeScript, Flow, and Elm try to provide a
    (typed) superset on JavaScript's dynamic types, they cannot completely fix the
    underlying problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是动态类型的。这使得避免运行时异常变得困难（几乎不可能）。虽然TypeScript、Flow和Elm试图在JavaScript的动态类型上提供（类型化的）超集，但它们无法完全解决根本问题。
- en: For any language to grow, it has to evolve fast, which JavaScript does. Evolving
    fast without breaking the existing usage is also important and JavaScript provides
    polyfills to make it backward compatible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 任何语言要成长，都必须快速演变，JavaScript就是这样做的。快速演变而不破坏现有用法也同样重要，JavaScript提供了polyfills来实现向后兼容。
- en: But creating polyfills is a mundane task. There are various other mundane steps,
    such as bundling and packaging libraries, minifying bundles, and lazy-loading
    libraries, to name a few. Bundlers provide a solution to most of them. They act
    as a compiler for the frontend.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但创建polyfills是一项平凡的任务。还有许多其他平凡的任务，例如打包和包装库、压缩包和懒加载库，仅举几例。打包器为大多数这些问题提供了解决方案。它们充当前端编译器。
- en: 'So far, we have seen how Rust makes it easy to create and run WebAssembly modules.
    In this chapter, we will explore `wasm-pack`, a tool that makes it easier to pack
    and publish WebAssembly modules. We will cover the following sections in this
    chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了Rust如何使创建和运行WebAssembly模块变得容易。在本章中，我们将探讨 `wasm-pack`，这是一个使打包和发布WebAssembly模块更容易的工具。本章将涵盖以下部分：
- en: Bundling WebAssembly modules with webpack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack打包WebAssembly模块
- en: Bundling WebAssembly modules with Parcel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Parcel打包WebAssembly模块
- en: Introducing `wasm-pack`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 `wasm-pack`
- en: Packing and publishing using `wasm-pack`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `wasm-pack` 打包和发布
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中存在的代码文件，网址为[https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly)。
- en: Bundling WebAssembly modules with webpack
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用webpack打包WebAssembly模块
- en: webpack is a static module bundler for modern JavaScript applications. So, what
    does it do?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: webpack是现代JavaScript应用程序的静态模块打包器。那么，它做什么呢？
- en: You can consider webpack as an informal compiler for the frontend. webpack takes
    in an entry point of an application, slowly runs through the modules, and builds
    a dependency graph. The dependency graph holds all the modules. These modules
    are necessary for the application to run.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将webpack视为前端的一个非正式编译器。webpack接受一个应用程序的入口点，逐步运行模块，并构建依赖图。依赖图包含所有模块。这些模块对于应用程序的运行是必要的。
- en: Once the dependency graph is built, webpack outputs one or more bundles. Webpack
    is very flexible, helping us to bundle or package JavaScript as we need it and
    the options are provided in the webpack configuration. Based on the provided options,
    webpack creates the output.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了依赖图，webpack就会输出一个或多个包。webpack非常灵活，帮助我们根据需要打包或包装JavaScript，webpack配置中提供了选项。根据提供的选项，webpack创建输出。
- en: '*Well, that sounds simple, right?*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*听起来很简单，对吧？*'
- en: It was that simple a few years ago when the only library that we needed was
    jQuery.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，当我们需要唯一的库就是jQuery时，事情很简单。
- en: But due to JavaScript's rapid evolution, there are a lot of different things
    happening now. The underlying runtime is not the same. There are three different
    browser engines and various targets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于JavaScript的快速演变，现在有很多不同的事情正在发生。底层运行时不尽相同。存在三种不同的浏览器引擎和多种目标。
- en: Browser engines evolve at different speeds and browsers support various versions
    of JavaScript. In some workplace machines, upgrading browsers to the latest version
    is prohibited. This means the running JavaScript application needs tweaking and
    polyfills at various times.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器引擎的演进速度不同，浏览器支持各种版本的 JavaScript。在某些工作场所的机器上，升级到最新版本的浏览器是被禁止的。这意味着运行的 JavaScript
    应用需要在不同的时间进行调整和填充。
- en: The underlying target system needs a certain tweak to make your JavaScript code
    run. Doing all this by hand will take a long time to complete and will be error-prone.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基础目标系统需要对您的 JavaScript 代码进行一定的调整才能运行。手动完成所有这些工作将花费很长时间，并且容易出错。
- en: There are various flavors of JavaScript, including TypeScript and CoffeeScript.
    They are different, but they will compile down to JavaScript before running. Browser-based
    development needs CSS, SCSS, SASS, and LESS. Supporting all those variations and
    compiling them manually after every change is not an easy deal.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有多种变体，包括 TypeScript 和 CoffeeScript。它们各不相同，但在运行之前都会编译成 JavaScript。基于浏览器的开发需要
    CSS、SCSS、SASS 和 LESS。支持所有这些变体并在每次更改后手动编译它们并不是一件容易的事情。
- en: JavaScript's answer to all this is bundlers. Whether you hate them or love them,
    bundlers reduce the overload and remove the clutter when developing with JavaScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对此的回应是打包器。无论你讨厌它们还是喜欢它们，打包器都能在用 JavaScript 开发时减少负担和混乱。
- en: webpack provides a solution to all these problems and more.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 为所有这些问题以及更多问题提供了一个解决方案。
- en: webpack is a tool built for bundling JavaScript applications. It comes with
    loaders and plugins that will help to convert, add, remove, and manipulate the
    output bundles. The most interesting part of webpack is its loaders and plugins,
    which propel the ability of webpack to the fullest.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 是一个用于打包 JavaScript 应用的工具。它包含加载器和插件，可以帮助转换、添加、删除和操作输出包。webpack 最有趣的部分是其加载器和插件，它们将
    webpack 的能力发挥到极致。
- en: Loaders allow us to load or import a Rust, CSS, or TypeScript file like any
    other module inside JavaScript. webpack then takes care of producing the bundle
    that will support the target environment as specified.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器允许我们像在 JavaScript 中加载或导入任何其他模块一样加载或导入 Rust、CSS 或 TypeScript 文件。然后 webpack
    负责生成支持指定目标环境的包。
- en: Plugins allow us to optimize and manage the bundles produced. It is important
    to note that webpack is built entirely on top of this plugin system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 插件允许我们优化和管理生成的包。需要注意的是，webpack 完全建立在插件系统之上。
- en: '*How does webpack help with WebAssembly?*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*webpack 如何帮助 WebAssembly？*'
- en: webpack internally depends on the `webassemblyjs` library. So, all the applications
    that use webpack are already WebAssembly-ready. All you have to do is start loading
    the WebAssembly file as normal JavaScript and webpack will take care of the rest.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 内部依赖于 `webassemblyjs` 库。因此，所有使用 webpack 的应用都已经为 WebAssembly 准备就绪。你只需像加载普通
    JavaScript 文件一样开始加载 WebAssembly 文件，webpack 就会处理其余部分。
- en: In the webpack configuration, we will define the entry point. webpack then loads
    the entry file. The `import` statements in the entry file are loaded as a module
    based on JavaScript's module resolution algorithm. If the imported module is a
    WebAssembly module, it gets the module's content and hands it over to the `webassemblyjs`
    compiler.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 webpack 配置中，我们将定义入口点。然后 webpack 加载入口文件。入口文件中的 `import` 语句根据 JavaScript 的模块解析算法被加载为一个模块。如果导入的模块是
    WebAssembly 模块，它将获取模块的内容并将其交给 `webassemblyjs` 编译器。
- en: The compiler is responsible for parsing and mutating the WebAssembly modules.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器负责解析和修改 WebAssembly 模块。
- en: Did You Know?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '`webassemblyjs` can parse the WebAssembly text format and WebAssembly binary
    format out of the box.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`webassemblyjs` 可以直接解析 WebAssembly 文本格式和 WebAssembly 二进制格式。'
- en: The compiler generates the **abstract syntax tree** (**AST**). The generated
    AST is then validated. Once the validation is successful, any custom sections
    in the WebAssembly module are removed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成 **抽象语法树**（**AST**）。生成的 AST 然后进行验证。一旦验证成功，WebAssembly 模块中的任何自定义部分都将被移除。
- en: The custom section is a section inside the WebAssembly module where users can
    store custom information about the WebAssembly module. This information may include
    names of the function and local variables. Browsers may then use this information
    to have a better debugging process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义部分是 WebAssembly 模块内部的一个部分，用户可以在此存储关于 WebAssembly 模块的自定义信息。这些信息可能包括函数和局部变量的名称。浏览器可以使用这些信息来改善调试过程。
- en: webpack also does not support the start section. The start section is a section
    in a WebAssembly module that will be called as soon as the WebAssembly module
    is loaded.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 也不支持起始部分。起始部分是 WebAssembly 模块中的一个部分，将在 WebAssembly 模块加载时立即调用。
- en: Instead, webpack creates a function and calls it after the WebAssembly module
    is loaded. `webassemblyjs` removes the start section and converts the start function
    into a normal function on the WebAssembly module. Then, webpack takes care of
    generating the wrapper that calls the function as soon as the module is loaded.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，webpack 创建一个函数，并在 WebAssembly 模块加载后调用它。`webassemblyjs` 移除了起始部分，并将起始函数转换为
    WebAssembly 模块上的普通函数。然后，webpack 负责生成调用该函数的包装器，以便模块加载后立即调用。
- en: Finally, `webassemblyjs` is also responsible for optimizing the binary and eliminating
    dead code from the WebAssembly module.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`webassemblyjs` 还负责优化二进制文件，并从 WebAssembly 模块中消除死代码。
- en: '`webassemblyjs` comes with an interpreter and CLI, which makes it easy to experiment
    with the WebAssembly modules.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`webassemblyjs` 内置了解释器和 CLI，这使得实验 WebAssembly 模块变得容易。'
- en: '**Code, refresh, and repeat.**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码，刷新，重复。**'
- en: This was the workflow for web development for a long time. Live reloading provides
    an extra pair of hands to web developers. Live reloading can automatically compile
    and reload the changes once the code is saved. The code can be shared across multiple
    devices, factors, and orientations. Interactions in one place can automatically
    be synchronized with other devices. While the web provides a medium to deliver
    software easily, it comes in various forms. These forms are feature phones, smartphones,
    tablets, laptops, computers, ultra-wide monitors, 360-degree virtual worlds, and
    so on. Supporting all or some of them is an uphill task. Live reloading works
    like an extra pair of hands.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这长期以来一直是 Web 开发的流程。实时重新加载为 Web 开发者提供了额外的帮助。一旦代码保存，实时重新加载可以自动编译和重新加载更改。代码可以在多个设备、因素和方向之间共享。在一个地方进行的交互可以自动与其他设备同步。虽然
    Web 提供了一种轻松交付软件的媒介，但它以各种形式存在。这些形式包括功能手机、智能手机、平板电脑、笔记本电脑、计算机、超宽显示器、360 度虚拟世界等等。支持所有或其中一些是一项艰巨的任务。实时重新加载就像一双额外的手。
- en: webpack provides multiple options to add live reloading to your application.
    It provides plugins for live reloading tools, such as BrowserSync. The webpack
    ecosystem also provides a watch mode in its configuration.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 为添加实时重新加载到您的应用程序提供了多个选项。它为实时重新加载工具，如 BrowserSync，提供了插件。webpack 生态系统在其配置中也提供了监视模式。
- en: The watch mode, once enabled, looks for any changes that happen in the source
    file and its directory. Once the changes are detected, it will recompile automatically.
    But watch mode is for recompiling input into output.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用，监视模式会查找源文件及其目录中发生的任何更改。一旦检测到更改，它将自动重新编译。但监视模式是为了将输入重新编译为输出。
- en: The automatic reloading of web pages is provided by a library called webpack-dev-server.
    webpack-dev-server is an in-memory web server. The contents are generated and
    are placed in memory rather than in actual files in the filesystem.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自动重新加载网页是由一个名为 webpack-dev-server 的库提供的。webpack-dev-server 是一个内存中的 Web 服务器。内容是在内存中生成和放置的，而不是在文件系统中的实际文件中。
- en: In addition to that, webpack-dev-server also supports Hot Module Replacement.
    This allows the server to patch only the changes in the browser rather than doing
    a full page refresh.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，webpack-dev-server 还支持热模块替换。这允许服务器仅修补浏览器中的更改，而不是进行完整的页面刷新。
- en: 'Let''s see how we can enable live reloading in a WebAssembly project:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 WebAssembly 项目中启用实时重新加载：
- en: 'First, we will create a new Rust project:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的 Rust 项目：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the project is created, open it in your favorite editor. To define the
    `wasm-bindgen` dependency for the project, open the `Cargo.toml` file:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了项目，就在您喜欢的编辑器中打开它。为了为项目定义 `wasm-bindgen` 依赖项，打开 `Cargo.toml` 文件：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, add the `[lib]` section and add `crate-type = ["cdylib"]`. With the `crate-type`
    option, we are instructing the compiler that the library is dynamic. After that,
    add the `wasm-bindgen` dependency to the `[dependencies]` tag.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加 `[lib]` 部分，并添加 `crate-type = ["cdylib"]`。通过 `crate-type` 选项，我们指示编译器该库是动态的。之后，将
    `wasm-bindgen` 依赖项添加到 `[dependencies]` 标签中。
- en: 'Then, open the `src/lib.rs` file and replace the contents with the following:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 `src/lib.rs` 文件，并用以下内容替换其内容：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will reuse the simple Hello World example from previous chapters here. Build
    the WASM module using the following:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这里重用前几章中的简单 Hello World 示例。使用以下命令构建 WASM 模块：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then create a `webpack.config.js` file to instruct webpack on how to handle
    and compile the files:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个`webpack.config.js`文件来指导webpack如何处理和编译文件：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a `package.json` file to download the webpack dependencies:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`package.json`文件来下载webpack依赖项：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Please use the latest version of the dependencies applicable here.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请使用此处适用的最新版本的依赖项。
- en: 'Create an `index.js` file to load the binding JavaScript that in turn loads
    the WebAssembly module generated:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`index.js`文件来加载绑定JavaScript，该JavaScript反过来加载生成的WebAssembly模块：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, head over to the terminal and install the npm dependencies using the following:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到终端并使用以下命令安装npm依赖项：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run webpack-dev-server using the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '使用以下命令运行webpack-dev-server:'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have already used webpack-dev-server to enable automatic recompiling. We
    can now go and change the HTML, CSS, or JavaScript file. Once we save the changes,
    the webpack server will compile everything. Once compiled, the changes are reflected
    in the browser.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用webpack-dev-server来启用自动重新编译。现在我们可以去更改HTML、CSS或JavaScript文件。一旦我们保存更改，webpack服务器将编译一切。一旦编译完成，更改将在浏览器中反映出来。
- en: 'But wait, what will happen if you change the Rust file? Let''s try changing
    it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，如果你更改Rust文件会发生什么？让我们尝试更改它：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We made a huge change in our `main.rs` file. Yeah, we changed from *world* to
    *universe*; isn't that huge? But once you save the file, you will not see any
    changes in the browser. In fact, even the webpack compiler is not recompiling
    things.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main.rs`文件中进行了重大更改。是的，我们从*world*更改为*universe*；这不是很大吗？但一旦你保存文件，你将不会在浏览器中看到任何更改。事实上，甚至webpack编译器也没有重新编译东西。
- en: The webpack compiler by default looks for the changes that will happen in the
    HTML, CSS, and JavaScript files (things that are defined in the configuration
    file and those that are included inside the dependency graph). But it has no idea
    about the Rust code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: webpack编译器默认查找将在HTML、CSS和JavaScript文件中发生的更改（在配置文件中定义的东西以及包含在依赖图中的东西）。但它对Rust代码一无所知。
- en: We need to somehow tell webpack to look for the code changes in Rust. We can
    use a plugin for that, one that will look at any changes in the specified location
    of the specified file type. Then, it will retrigger the build process. We will
    use `wasm-pack-plugin` for this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以某种方式告诉webpack在Rust中查找代码更改。我们可以使用一个插件来完成这个任务，该插件将检查指定文件类型的指定位置中的任何更改。然后，它将重新触发构建过程。我们将使用`wasm-pack-plugin`来完成这个任务。
- en: 'Add the `wasm-pack-plugin` dependency to the application using the following
    command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将`wasm-pack-plugin`依赖项添加到应用程序中：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, hook this plugin into webpack''s plugin system via the `webpack.config.js`
    file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过`webpack.config.js`文件将此插件钩入webpack的插件系统：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We import `wasm-pack-plugin`. We specify the crate directory in which the `Cargo.toml`
    file is present and then the plugin will take care of the auto-reloading part.
    To see it in action, let's stop and start the webpack server using `npm run serve`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`wasm-pack-plugin`。我们指定包含`Cargo.toml`文件的crate目录，然后插件将负责自动重新加载部分。要看到它的实际效果，让我们使用`npm
    run serve`停止并启动webpack服务器。
- en: Now, let's edit the `src/main.rs` file with Hello Galaxy. Open the browser to
    see the console log changed to **Hello Galaxy** already.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用Hello Galaxy编辑`src/main.rs`文件。打开浏览器以查看控制台日志已更改为**Hello Galaxy**。
- en: So, what happens here?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？
- en: '`wasm-pack-plugin` is hooked into webpack using webpack''s plugin system. This
    will run along with the webpack compiler. If any changes are made in the `src`
    directory, `wasm-pack-plugin` will then run the `wasm-pack` compilation to compile
    the Rust code into WebAssembly modules automatically. This will trigger a recompilation
    in the webpack compiler. Once the webpack compiler recompiles, it will notify
    `webpack-dev-server` to reload the changes in the browser. The browser then reloads
    the changes automatically.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack-plugin`通过webpack的插件系统连接到webpack。这将与webpack编译器一起运行。如果`src`目录中发生任何更改，`wasm-pack-plugin`将运行`wasm-pack`编译来自动将Rust代码编译成WebAssembly模块。这将触发webpack编译器的重新编译。一旦webpack编译器重新编译，它将通知`webpack-dev-server`在浏览器中重新加载更改。然后浏览器将自动重新加载更改。'
- en: '`wasm-pack-plugin` makes it easy to run Rust and WebAssembly along with webpack.
    Now, let''s check how we can run Rust and WebAssembly with Parcel.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack-plugin`使得在webpack中运行Rust和WebAssembly变得容易。现在，让我们检查如何使用Parcel运行Rust和WebAssembly。'
- en: Bundling WebAssembly modules with Parcel
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parcel打包WebAssembly模块
- en: '*Parcel is a blazing-fast, zero-configuration web application bundler.*`index.html`)
    and then build the entire graph from there.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*Parcel是一个快速、零配置的Web应用程序打包器*`index.html`)，然后从那里构建整个图。'
- en: While webpack has a plugin-based architecture, Parcel has a worker-based architecture.
    This enables Parcel to be faster than webpack as it uses multicore compilation
    and cache.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Webpack 具有基于插件的架构，但 Parcel 具有基于工作进程的架构。这使得 Parcel 比 Webpack 更快，因为它使用多核编译和缓存。
- en: Parcel also has inbuilt configuration to support JavaScript, CSS, and HTML files.
    Just like webpack, it also has various plugins that we can use to configure the
    bundler to produce the required output.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Parcel 还内置了配置以支持 JavaScript、CSS 和 HTML 文件。就像 Webpack 一样，它也有各种插件，我们可以使用这些插件来配置打包器以生成所需的输出。
- en: It also has inbuilt transformation support using standard Babel, PostCSS, and
    PostHTML when it is required. We can extend them and change them via plugins if
    needed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，它还内置了对标准 Babel、PostCSS 和 PostHTML 的转换支持。如果需要，我们可以通过插件扩展和更改它们。
- en: 'Parcel also has automatic, out-of-the-box hot module replacement to track and
    record changes to files (that are recorded by the dependency graph). Let''s build
    WebAssembly modules using parcel as a bundler:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Parcel 还具有自动的、开箱即用的热模块替换功能，用于跟踪和记录文件的更改（这些更改由依赖关系图记录）。让我们使用 Parcel 作为打包器来构建
    WebAssembly 模块：
- en: 'We will start by creating a new Rust project:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的 Rust 项目：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once the project is created, open the project in your favorite editor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建项目，就在您最喜欢的编辑器中打开项目。
- en: 'To define the `wasm-bindgen` dependency for the project, open the `Cargo.toml`
    file:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为项目定义`wasm-bindgen`依赖项，打开`Cargo.toml`文件：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, remove the `[dependencies]` tag and replace it with the bold lines above.
    We are telling the compiler that the library that is getting generated will be
    dynamic and it has a dependency on the `wasm-bindgen` library.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，删除`[dependencies]`标签，并用上面的粗体行替换它。我们正在告诉编译器，生成的库将是动态的，并且它依赖于`wasm-bindgen`库。
- en: 'Then, we open the `src/lib.rs` file and replace the contents with the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打开`src/lib.rs`文件，并将其内容替换为以下内容：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will reuse the simple Hello World example here. Build the `wasm` module
    using the following:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重用简单的 Hello World 示例。使用以下命令构建`wasm`模块：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since Parcel supports zero configuration, all we need to do is add Parcel dependencies
    to `package.json`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Parcel 支持零配置，我们所需做的只是将 Parcel 依赖项添加到`package.json`中：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since Parcel is a zero-configuration bundler, we just have to define the entry
    point to it. We define the entry point in the `scripts` section. The `serve` command
    is the command that we use to run the code for development purposes. When we define
    `parcel build index.html`, we are informing Parcel that the entry point is `index.html`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Parcel 是零配置打包器，我们只需定义它的入口点。我们在`scripts`部分定义入口点。`serve`命令是我们用于开发目的运行代码的命令。当我们定义`parcel
    build index.html`时，我们正在通知 Parcel 入口点是`index.html`。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please use the latest version applicable here.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用此处适用的最新版本。
- en: 'Then, we will create the entry point. We will create an `index.html` file as
    specified in the `package.json` script:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建入口点。我们将创建一个`index.html`文件，正如`package.json`脚本中指定的那样：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create an `index.js` file to load the binding JavaScript, which in turn loads
    the WebAssembly module generated:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`index.js`文件来加载绑定 JavaScript，它反过来加载生成的 WebAssembly 模块：
- en: '[PRE18]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, head over to the terminal. Run the following command to install the dependencies:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到终端。运行以下命令来安装依赖项：
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the Parcel application using the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行 Parcel 应用程序：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Parcel's zero-configuration nature makes it extremely easy to get started with
    WebAssembly. By default, Parcel supports `.wasm` files. We can even import `.wasm`
    files just like any other `.js` file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Parcel 的零配置特性使得开始使用 WebAssembly 非常容易。默认情况下，Parcel 支持 `.wasm` 文件。我们甚至可以像导入任何其他
    `.js` 文件一样导入 `.wasm` 文件。
- en: It is important to note that synchronously importing WebAssembly modules is
    still not supported. But we can write an import as a synchronous import. Internally,
    Parcel will generate the necessary extra code to preload the file before JavaScript
    execution starts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，同步导入 WebAssembly 模块仍然不受支持。但我们可以将导入写为同步导入。内部，Parcel 将生成必要的额外代码，在 JavaScript
    执行开始前预加载文件。
- en: This implies the WebAssembly file will be a separate bundle rather than in line
    with the bundled JavaScript file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 WebAssembly 文件将是一个单独的包，而不是与打包的 JavaScript 文件一起。
- en: 'Let''s change the Rust file and see what happens:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更改 Rust 文件并看看会发生什么：
- en: '[PRE21]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once you save the file, you will not see any changes. Parcel has no clue that
    you have changed the source and the compiler will not react.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件后，您将看不到任何变化。Parcel 无法得知您已更改源代码，编译器也不会做出反应。
- en: To make Parcel react to the Rust source changes, we need to add a plugin. The
    plugin is `parcel-plugin-wasm.rs`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Parcel 对 Rust 源代码更改做出反应，我们需要添加一个插件。该插件是 `parcel-plugin-wasm.rs`。
- en: 'To install the plugin, we can run the following:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装插件，我们可以运行以下命令：
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will download the plugin to `node_modules`. This will also save the plugin
    in `package.json`'s `devDependencies`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把插件下载到 `node_modules`。这也会在 `package.json` 的 `devDependencies` 中保存插件。
- en: 'Once installed, we need to change `index.js` such that it looks at the source
    code directly instead of referencing from the `Cargo.toml` file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要更改 `index.js`，使其直接查看源代码，而不是从 `Cargo.toml` 文件中引用：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, instead of importing from the WebAssembly module, we specify the entry
    Rust file. We can even specify the location of the `Cargo.toml` file to make Parcel
    look for changes in the respective places.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是从 WebAssembly 模块导入，而是指定入口 Rust 文件。我们甚至可以指定 `Cargo.toml` 文件的位置，以便 Parcel
    在相应位置查找更改。
- en: Now, let's edit the `src/main.rs` file with Hello Galaxy. Open the browser to
    see how the console log has changed to **Hello Galaxy.**
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用 Hello Galaxy 编辑 `src/main.rs` 文件。打开浏览器查看控制台日志如何变为 **Hello Galaxy**。
- en: So, what happens here?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？
- en: Parcel just requires the starting point of our application. It will generate
    the dependency graph from there. The parcel plugin keeps looking for any changes
    in the folder to happen. It basically looks in the folder that contains the `Cargo.toml`
    file. The `Cargo.toml` location is given to the Parcel bundler and its plugin
    via `index.js`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Parcel 只需要我们应用程序的起点。它将从那里生成依赖图。Parcel 插件会持续查找文件夹中的任何更改。它基本上会查看包含 `Cargo.toml`
    文件的文件夹。`Cargo.toml` 的位置是通过 `index.js` 传递给 Parcel 打包器和其插件的。
- en: So, any changes that happen to the Rust file will lead to the following process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对 Rust 文件所做的任何更改都将导致以下过程。
- en: When the Rust file is saved, the watchers inside `parcel-plugin-wasm.rs` are
    triggered. Then, `parcel-plugin-wasm.rs` will initiate the compilation process
    of the Rust code into WebAssembly via `wasm-pack`. Once `wasm-pack` compiles and
    produces new WebAssembly code, the plugin will notify the Parcel compiler that
    something in the dependency graph has been changed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Rust 文件被保存时，`parcel-plugin-wasm.rs` 内部的监视器会被触发。然后，`parcel-plugin-wasm.rs`
    将通过 `wasm-pack` 启动 Rust 代码编译成 WebAssembly 的过程。一旦 `wasm-pack` 编译并生成新的 WebAssembly
    代码，插件将通知 Parcel 编译器依赖图中的某个部分发生了变化。
- en: The Parcel compiler then recompiles, which will result in the browser being
    refreshed. The browser now displays the changed message.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Parcel 编译器会重新编译，这将导致浏览器刷新。浏览器现在显示更改后的消息。
- en: Note that for Parcel, we actually used a synchronous module import, while for
    webpack, we were relying on asynchronous import.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于 Parcel，我们实际上使用了同步模块导入，而对于 webpack，我们依赖于异步导入。
- en: The `parcel-plugin-wasm.rs` plugin makes it easy to run Rust and WebAssembly
    along with Parcel. Now, let's check how we can install and use `wasm-pack` to
    pack and publish WebAssembly modules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`parcel-plugin-wasm.rs` 插件使得在 Parcel 中运行 Rust 和 WebAssembly 变得容易。现在，让我们看看如何安装和使用
    `wasm-pack` 来打包和发布 WebAssembly 模块。'
- en: Introducing wasm-pack
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 wasm-pack
- en: To be compatible with JavaScript, Rust-based WebAssembly applications should
    be completely interoperable with the JavaScript world. Without that, it will be
    difficult for developers to bootstrap their WebAssembly projects in JavaScript.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 JavaScript 兼容，基于 Rust 的 WebAssembly 应用程序应该能够完全与 JavaScript 世界互操作。没有这一点，开发者将难以在
    JavaScript 中启动他们的 WebAssembly 项目。
- en: The node modules completely changed the perspective of the JavaScript world.
    They make it easier to develop and share the modules between Browser and Node
    environments. Developers around the world can use these libraries wherever and
    whenever they want.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 节点模块完全改变了 JavaScript 世界的视角。它们使得在浏览器和 Node 环境之间开发和共享模块变得更加容易。世界各地的开发者可以在任何地方和任何时候使用这些库。
- en: The `wasm-pack` tool seeks to be a one-stop shop for building and working with
    Rust-generated WebAssembly that you would like to interoperate with JavaScript,
    in the browser or with Node.js. `- wasm-pack` website. [https://github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack` 工具旨在成为构建和与 Rust 生成的 WebAssembly 交互的一站式商店，这些 WebAssembly 可以在浏览器或
    Node.js 中与 JavaScript 交互。`- wasm-pack` 网站。[https://github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack)'
- en: Why do you need wasm-pack?
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你为什么需要 wasm-pack？
- en: '`wasm-pack` makes it easy to build and pack Rust- and WebAssembly-based projects.
    Once packed, the module is ready to be shared with the world via the npm registry
    – just like millions (or even billions) of JavaScript libraries out there.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack` 使得构建和打包基于 Rust 和 WebAssembly 的项目变得简单。一旦打包，模块就准备好通过 npm 注册表与世界共享——就像那里数百万（甚至数十亿）的
    JavaScript 库一样。'
- en: How to use wasm-pack
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用 wasm-pack
- en: '`wasm-pack` is available as a Cargo library. If you are following along with
    this book, then you might have already installed Cargo. To install `wasm-pack`,
    run the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack` 可作为 Cargo 库使用。如果您正在跟随这本书学习，那么您可能已经安装了 Cargo。要安装 `wasm-pack`，请运行以下命令：'
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding command will download, compile, and install the `wasm-pack` library.
    Once installed, the `wasm-pack` command will be available.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将下载、编译并安装 `wasm-pack` 库。一旦安装完成，`wasm-pack` 命令将可用。
- en: 'To check whether `wasm-pack` is installed correctly, run the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 `wasm-pack` 是否正确安装，请运行以下命令：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once you have `wasm-pack` installed, let''s see how to use `wasm-pack` to build
    and pack Rust and WebAssembly projects:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了 `wasm-pack`，让我们看看如何使用 `wasm-pack` 来构建和打包 Rust 和 WebAssembly 项目：
- en: 'We will first generate a new project with Cargo. To generate the project, use
    the following:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先使用 Cargo 生成一个新的项目。要生成项目，请使用以下命令：
- en: '[PRE26]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once the project is created, open it in your favorite editor.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，请使用您最喜欢的编辑器打开它。
- en: 'To define the `wasm-bindgen` dependency for the project, open the `cargo.toml`
    file:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为项目定义 `wasm-bindgen` 依赖项，请打开 `cargo.toml` 文件：
- en: '[PRE27]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, remove the `[dependencies]` tag and replace that with the `wasm-bindgen`
    library. We are telling the compiler that the library that is getting generated
    will be dynamic and it has a dependency to the `wasm-bindgen` library.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，删除 `[dependencies]` 标签，并用 `wasm-bindgen` 库替换它。我们告诉编译器，正在生成的库将是动态的，并且它依赖于
    `wasm-bindgen` 库。
- en: 'Then, we open the `src/lib.rs` file and replace the contents with the following:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打开 `src/lib.rs` 文件，并将内容替换为以下内容：
- en: '[PRE28]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, this is a simple function that returns a number (which is the universal
    answer).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一个简单的函数，它返回一个数字（这是万能的答案）。
- en: Previously, we used to build the Rust and WebAssembly application with `rustc`
    or Cargo. This produced a WebAssembly binary. But the binary is not useful by
    itself; it needs a binding file. With `wasm-bindgen`, we will generate the binding
    file along with the WebAssembly binary.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们使用 `rustc` 或 Cargo 构建 Rust 和 WebAssembly 应用程序。这会产生一个 WebAssembly 二进制文件。但二进制文件本身并没有用；它需要一个绑定文件。使用
    `wasm-bindgen`，我们将生成绑定文件以及 WebAssembly 二进制文件。
- en: These two steps are mandatory, but they are mundane. We can replace them with
    `wasm-pack`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤是强制性的，但它们很平凡。我们可以用 `wasm-pack` 替换它们。
- en: 'To build the WebAssembly application with `wasm-pack`, run the following command:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `wasm-pack` 构建 WebAssembly 应用程序，请运行以下命令：
- en: '[PRE29]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we run `wasm-pack build`, this is what happens:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `wasm-pack build` 时，会发生以下情况：
- en: '`wasm-pack` first checks whether the Rust compiler is installed. If it''s installed,
    then it checks whether the Rust compiler is greater than version 1.30.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wasm-pack` 首先检查 Rust 编译器是否已安装。如果已安装，那么它会检查 Rust 编译器版本是否大于 1.30。'
- en: '`wasm-pack` checks for the crate configuration and whether the library indicates
    that we are generating a dynamic library.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wasm-pack` 检查 crate 配置以及库是否指示我们正在生成动态库。'
- en: '`wasm-pack` validates whether there is any `wasm-target` available for building.
    If the `wasm32-unknown-unknown` target is not available, `wasm-pack` will download
    and add the target.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wasm-pack` 验证是否有任何 `wasm-target` 可用于构建。如果 `wasm32-unknown-unknown` 目标不可用，`wasm-pack`
    将下载并添加该目标。'
- en: Once the environment is ready, `wasm-pack` then starts compiling the module
    and build the WebAssembly Module and binding JavaScript files.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦环境准备就绪，`wasm-pack` 然后开始编译模块并构建 WebAssembly 模块和绑定 JavaScript 文件。
- en: 'Note that the `wasm-pack` command also generates the `package.json` file. The
    `package.json` file looks similar to this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`wasm-pack` 命令也会生成 `package.json` 文件。`package.json` 文件看起来类似于以下内容：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, it copies over the Readme and LICENSE file if we have one, to ensure
    there is shared documentation between the Rust and WebAssembly versions.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果有的话，它会复制 Readme 和 LICENSE 文件，以确保 Rust 和 WebAssembly 版本之间有共享文档。
- en: '`wasm-pack` also checks for the presence of `wasm-bindgen-cli`, which, if not
    present, will be installed using Cargo.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack` 还会检查 `wasm-bindgen-cli` 的存在。如果不存在，将使用 Cargo 进行安装。'
- en: 'When the build has successfully finished, it will create a `pkg` directory.
    Inside `pkg`, it will pipe the output of `wasm-bindgen`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当构建成功完成后，它将创建一个 `pkg` 目录。在 `pkg` 目录内，它将通过 `wasm-bindgen` 将输出重定向：
- en: '[PRE31]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, this `pkg` folder can be bundled and shared like any other JavaScript module.
    We'll see how to achieve that in the future recipes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个 `pkg` 文件夹可以像任何其他 JavaScript 模块一样打包和共享。我们将在未来的菜谱中看到如何实现这一点。
- en: '`wasm-pack` is a great tool to pack and publish WebAssembly modules. Now, let''s
    check out how to use it.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack` 是一个打包和发布 WebAssembly 模块的强大工具。现在，让我们来看看如何使用它。'
- en: Packing and publishing using wasm-pack
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 wasm-pack 打包和发布
- en: The most amazing (and, of course, the most important) thing for a library developer
    to do is to pack and publish artifacts. That is why we spend our days and nights
    carefully crafting the application, publishing it to the world, receiving feedback
    (either negative or positive), and then enhancing the application based on that.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于库开发者来说，最令人惊叹（当然，也是最重要的）的事情就是打包和发布工件。这就是我们日夜精心制作应用程序，将其发布到世界，接收反馈（无论是负面还是正面），然后根据这些反馈增强应用程序的原因。
- en: The critical point for any project is its first release, which defines the fate
    of the project. Even though it is simply an MVP, it will give the world a glimpse
    of what we are working on and gives us a glimpse of what we have to work on in
    the future.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 任何项目的关键点是其首次发布，这决定了项目的命运。即使它只是一个 MVP，它也会让世界一瞥我们正在做什么，并让我们一瞥未来我们必须做什么。
- en: '`wasm-pack` helps us to build, pack, and publish Rust- and WebAssembly-based
    projects into the npm registry. We have already seen how `wasm-pack` makes it
    simpler to build Rust into the WebAssembly binary along with the binding JavaScript
    file using `wasm-bindgen` underneath. Let''s further explore what we can do with
    its `pack` and `publish` flags.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack` 帮助我们将基于 Rust 和 WebAssembly 的项目构建、打包和发布到 npm 注册表。我们已经看到了 `wasm-pack`
    如何通过底层的 `wasm-bindgen` 使将 Rust 构建到 WebAssembly 二进制文件以及绑定 JavaScript 文件变得更加简单。让我们进一步探索我们可以使用其
    `pack` 和 `publish` 标志做什么。'
- en: '`wasm-pack` provides a `pack` flag to pack the artifacts that were generated
    using the `wasm-pack` build command. Although it is not necessary to use `wasm-pack`
    to build binaries, it generates all the boilerplate that we will need to pack
    the artifacts into a Node module.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack` 提供了一个 `pack` 标志来打包使用 `wasm-pack` 构建命令生成的工件。尽管使用 `wasm-pack` 构建二进制文件不是必需的，但它生成了我们将需要将工件打包成
    Node 模块的所有样板代码。'
- en: 'In order to pack the built artifacts using `wasm-pack`, we have to run the
    following command with reference to `pkg` (or the directory with which we generated
    our build artifacts):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `wasm-pack` 打包构建的工件，我们必须运行以下命令，并参考 `pkg`（或我们生成构建工件的那个目录）：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can also run the command by passing in `project_folder/pkg` as its argument.
    Without any argument, the `wasm-pack pack` command will search for the `pkg` directory
    in the current working directory where it is running.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过传递 `project_folder/pkg` 作为其参数来运行命令。如果没有参数，`wasm-pack pack` 命令将在它运行的当前工作目录中搜索
    `pkg` 目录。
- en: The `wasm-pack pack` command first identifies whether the folder provided is
    a `pkg` directory or contains a `pkg` directory as its immediate child. If the
    check passes, then `wasm-pack` will invoke the npm pack command underneath, to
    pack the library into an npm package.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack pack` 命令首先确定提供的文件夹是否是 `pkg` 目录或包含一个 `pkg` 目录作为其直接子目录。如果检查通过，那么 `wasm-pack`
    将调用底层的 npm pack 命令，将库打包成一个 npm 包。'
- en: To bundle the npm package, all we need is a valid `package.json` file. That
    file is generated by the `wasm-pack` build command.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捆绑 npm 包，我们只需要一个有效的 `package.json` 文件。该文件由 `wasm-pack` 构建命令生成。
- en: 'We can run the `pack` command inside the `cg-array-world` example from our
    previous recipe and check what happens:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在之前的菜谱中的 `cg-array-world` 示例内部运行 `pack` 命令，并检查会发生什么：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see here, the `pack` command creates a tarball package with the contents
    inside the `pkg` folder with the help of the `npm pack` command.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`pack` 命令在 `npm pack` 命令的帮助下，创建了一个包含 `pkg` 文件夹内容的 tarball 包。
- en: Once we have packed our application, the obvious next step will be to publish
    it. In order to publish the tarball generated, `wasm-pack` has a `publish` option.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打包了我们的应用程序，下一步显然就是发布它。为了发布生成的 tarball，`wasm-pack` 有一个 `publish` 选项。
- en: 'In order to publish the package, we have to run the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发布包，我们必须运行以下命令：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `wasm-pack publish` command will first check whether the `pkg` directory
    is already present in the directory provided.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack publish`命令将首先检查提供的目录中是否已经存在`pkg`目录。'
- en: 'If the `pkg` directory is not present, then it will ask whether you want to
    create the package first:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pkg`目录不存在，那么它会询问你是否想要首先创建包：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you answer `Y` to the question, then it asks for you to input the folder
    in which you want to generate the build artifacts. We can give any folder name
    or use the default:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回答“Y”来回答这个问题，那么它会要求你输入你想要生成构建工件文件夹的位置。我们可以给出任何文件夹名称或使用默认值：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, it asks for your target, that is, the target in which the build should
    be generated. You can choose between the various options here, as discussed in
    the build recipe:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它会询问你的目标，即构建应该生成的目标。你可以在这里选择各种选项，如构建配方中所述：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Based on the option provided, it will generate the artifact in the specified
    folder.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供的选项，它将在指定的文件夹中生成工件。
- en: Once the artifacts are produced, they are then ready to be published using npm
    publish. For npm publish to work correctly, we need to be authenticated. You can
    authenticate to npm by using either npm login or `wasm-pack` login.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成工件，它们就准备好使用npm publish进行发布了。为了npm publish能够正确工作，我们需要进行认证。你可以通过使用npm login或`wasm-pack`
    login来对npm进行认证。
- en: 'The `wasm-pack login` command will invoke the underlying npm login command
    and then create a session:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack login`命令将调用底层的npm login命令然后创建一个会话：'
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `wasm-pack publish` command also supports two options, namely the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-pack publish`命令还支持两个选项，即以下内容：'
- en: '`-a` or `--access` to determine the access level of the package to be deployed.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`或`--access`用于确定要部署的包的访问级别。'
- en: 'This accepts either `public` or `restricted`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这接受`public`或`restricted`：
- en: '`public` – Makes the package public'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` – 使包公开'
- en: '`restricted` – Makes the package internal'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restricted` – 使包内部化'
- en: '`-t` or `--target` to support various targets in which the build is produced.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`或`--target`用于支持在构建中产生的各种目标。'
- en: Thus, `wasm-pack` makes it easy to pack and publish WebAssembly binaries.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`wasm-pack`使得打包和发布WebAssembly二进制文件变得简单。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to run a WebAssembly project with bundlers such
    as webpack and Parcel. Parcel and webpack make it easy for JavaScript developers
    to run and develop Rust and WebAssembly projects. Then, we installed `wasm-pack`
    and used it to run the project. Finally, we used `wasm-pack` to pack and publish
    the WebAssembly module to npm.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用webpack和Parcel等打包器运行WebAssembly项目。Parcel和webpack使得JavaScript开发者能够轻松运行和开发Rust和WebAssembly项目。然后，我们安装了`wasm-pack`并使用它来运行项目。最后，我们使用`wasm-pack`将WebAssembly模块打包并发布到npm。
- en: In the next chapter, we will explore how to share complex objects between Rust
    and WebAssembly with `wasm-bindgen`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用`wasm-bindgen`在Rust和WebAssembly之间共享复杂对象。
