- en: '*Chapter 8*: Bundling WebAssembly Using wasm-pack'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is omnipresent, but being everywhere is both an advantage and a disadvantage.
    There are many different ecosystems that have various standards and purposes.
    Building a unique solution for all ecosystems is not practical.
  prefs: []
  type: TYPE_NORMAL
- en: Despite all this, the JavaScript community is doing a wonderful job here. The
    effort from the community makes JavaScript one of the go-to languages. For a language
    as versatile as JavaScript, there will be some weird corners (which of course
    every language has). When you are writing JavaScript, these need extra care and
    attention.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is dynamically typed. This makes it difficult (almost impossible)
    to avoid runtime exceptions. While TypeScript, Flow, and Elm try to provide a
    (typed) superset on JavaScript's dynamic types, they cannot completely fix the
    underlying problem.
  prefs: []
  type: TYPE_NORMAL
- en: For any language to grow, it has to evolve fast, which JavaScript does. Evolving
    fast without breaking the existing usage is also important and JavaScript provides
    polyfills to make it backward compatible.
  prefs: []
  type: TYPE_NORMAL
- en: But creating polyfills is a mundane task. There are various other mundane steps,
    such as bundling and packaging libraries, minifying bundles, and lazy-loading
    libraries, to name a few. Bundlers provide a solution to most of them. They act
    as a compiler for the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen how Rust makes it easy to create and run WebAssembly modules.
    In this chapter, we will explore `wasm-pack`, a tool that makes it easier to pack
    and publish WebAssembly modules. We will cover the following sections in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Bundling WebAssembly modules with webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundling WebAssembly modules with Parcel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing `wasm-pack`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packing and publishing using `wasm-pack`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly).
  prefs: []
  type: TYPE_NORMAL
- en: Bundling WebAssembly modules with webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: webpack is a static module bundler for modern JavaScript applications. So, what
    does it do?
  prefs: []
  type: TYPE_NORMAL
- en: You can consider webpack as an informal compiler for the frontend. webpack takes
    in an entry point of an application, slowly runs through the modules, and builds
    a dependency graph. The dependency graph holds all the modules. These modules
    are necessary for the application to run.
  prefs: []
  type: TYPE_NORMAL
- en: Once the dependency graph is built, webpack outputs one or more bundles. Webpack
    is very flexible, helping us to bundle or package JavaScript as we need it and
    the options are provided in the webpack configuration. Based on the provided options,
    webpack creates the output.
  prefs: []
  type: TYPE_NORMAL
- en: '*Well, that sounds simple, right?*'
  prefs: []
  type: TYPE_NORMAL
- en: It was that simple a few years ago when the only library that we needed was
    jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: But due to JavaScript's rapid evolution, there are a lot of different things
    happening now. The underlying runtime is not the same. There are three different
    browser engines and various targets.
  prefs: []
  type: TYPE_NORMAL
- en: Browser engines evolve at different speeds and browsers support various versions
    of JavaScript. In some workplace machines, upgrading browsers to the latest version
    is prohibited. This means the running JavaScript application needs tweaking and
    polyfills at various times.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying target system needs a certain tweak to make your JavaScript code
    run. Doing all this by hand will take a long time to complete and will be error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: There are various flavors of JavaScript, including TypeScript and CoffeeScript.
    They are different, but they will compile down to JavaScript before running. Browser-based
    development needs CSS, SCSS, SASS, and LESS. Supporting all those variations and
    compiling them manually after every change is not an easy deal.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript's answer to all this is bundlers. Whether you hate them or love them,
    bundlers reduce the overload and remove the clutter when developing with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: webpack provides a solution to all these problems and more.
  prefs: []
  type: TYPE_NORMAL
- en: webpack is a tool built for bundling JavaScript applications. It comes with
    loaders and plugins that will help to convert, add, remove, and manipulate the
    output bundles. The most interesting part of webpack is its loaders and plugins,
    which propel the ability of webpack to the fullest.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders allow us to load or import a Rust, CSS, or TypeScript file like any
    other module inside JavaScript. webpack then takes care of producing the bundle
    that will support the target environment as specified.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins allow us to optimize and manage the bundles produced. It is important
    to note that webpack is built entirely on top of this plugin system.
  prefs: []
  type: TYPE_NORMAL
- en: '*How does webpack help with WebAssembly?*'
  prefs: []
  type: TYPE_NORMAL
- en: webpack internally depends on the `webassemblyjs` library. So, all the applications
    that use webpack are already WebAssembly-ready. All you have to do is start loading
    the WebAssembly file as normal JavaScript and webpack will take care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: In the webpack configuration, we will define the entry point. webpack then loads
    the entry file. The `import` statements in the entry file are loaded as a module
    based on JavaScript's module resolution algorithm. If the imported module is a
    WebAssembly module, it gets the module's content and hands it over to the `webassemblyjs`
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler is responsible for parsing and mutating the WebAssembly modules.
  prefs: []
  type: TYPE_NORMAL
- en: Did You Know?
  prefs: []
  type: TYPE_NORMAL
- en: '`webassemblyjs` can parse the WebAssembly text format and WebAssembly binary
    format out of the box.'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler generates the **abstract syntax tree** (**AST**). The generated
    AST is then validated. Once the validation is successful, any custom sections
    in the WebAssembly module are removed.
  prefs: []
  type: TYPE_NORMAL
- en: The custom section is a section inside the WebAssembly module where users can
    store custom information about the WebAssembly module. This information may include
    names of the function and local variables. Browsers may then use this information
    to have a better debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: webpack also does not support the start section. The start section is a section
    in a WebAssembly module that will be called as soon as the WebAssembly module
    is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, webpack creates a function and calls it after the WebAssembly module
    is loaded. `webassemblyjs` removes the start section and converts the start function
    into a normal function on the WebAssembly module. Then, webpack takes care of
    generating the wrapper that calls the function as soon as the module is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `webassemblyjs` is also responsible for optimizing the binary and eliminating
    dead code from the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: '`webassemblyjs` comes with an interpreter and CLI, which makes it easy to experiment
    with the WebAssembly modules.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code, refresh, and repeat.**'
  prefs: []
  type: TYPE_NORMAL
- en: This was the workflow for web development for a long time. Live reloading provides
    an extra pair of hands to web developers. Live reloading can automatically compile
    and reload the changes once the code is saved. The code can be shared across multiple
    devices, factors, and orientations. Interactions in one place can automatically
    be synchronized with other devices. While the web provides a medium to deliver
    software easily, it comes in various forms. These forms are feature phones, smartphones,
    tablets, laptops, computers, ultra-wide monitors, 360-degree virtual worlds, and
    so on. Supporting all or some of them is an uphill task. Live reloading works
    like an extra pair of hands.
  prefs: []
  type: TYPE_NORMAL
- en: webpack provides multiple options to add live reloading to your application.
    It provides plugins for live reloading tools, such as BrowserSync. The webpack
    ecosystem also provides a watch mode in its configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The watch mode, once enabled, looks for any changes that happen in the source
    file and its directory. Once the changes are detected, it will recompile automatically.
    But watch mode is for recompiling input into output.
  prefs: []
  type: TYPE_NORMAL
- en: The automatic reloading of web pages is provided by a library called webpack-dev-server.
    webpack-dev-server is an in-memory web server. The contents are generated and
    are placed in memory rather than in actual files in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, webpack-dev-server also supports Hot Module Replacement.
    This allows the server to patch only the changes in the browser rather than doing
    a full page refresh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can enable live reloading in a WebAssembly project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new Rust project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the project is created, open it in your favorite editor. To define the
    `wasm-bindgen` dependency for the project, open the `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, add the `[lib]` section and add `crate-type = ["cdylib"]`. With the `crate-type`
    option, we are instructing the compiler that the library is dynamic. After that,
    add the `wasm-bindgen` dependency to the `[dependencies]` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, open the `src/lib.rs` file and replace the contents with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will reuse the simple Hello World example from previous chapters here. Build
    the WASM module using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then create a `webpack.config.js` file to instruct webpack on how to handle
    and compile the files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `package.json` file to download the webpack dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please use the latest version of the dependencies applicable here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an `index.js` file to load the binding JavaScript that in turn loads
    the WebAssembly module generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, head over to the terminal and install the npm dependencies using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run webpack-dev-server using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have already used webpack-dev-server to enable automatic recompiling. We
    can now go and change the HTML, CSS, or JavaScript file. Once we save the changes,
    the webpack server will compile everything. Once compiled, the changes are reflected
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait, what will happen if you change the Rust file? Let''s try changing
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We made a huge change in our `main.rs` file. Yeah, we changed from *world* to
    *universe*; isn't that huge? But once you save the file, you will not see any
    changes in the browser. In fact, even the webpack compiler is not recompiling
    things.
  prefs: []
  type: TYPE_NORMAL
- en: The webpack compiler by default looks for the changes that will happen in the
    HTML, CSS, and JavaScript files (things that are defined in the configuration
    file and those that are included inside the dependency graph). But it has no idea
    about the Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: We need to somehow tell webpack to look for the code changes in Rust. We can
    use a plugin for that, one that will look at any changes in the specified location
    of the specified file type. Then, it will retrigger the build process. We will
    use `wasm-pack-plugin` for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `wasm-pack-plugin` dependency to the application using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, hook this plugin into webpack''s plugin system via the `webpack.config.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We import `wasm-pack-plugin`. We specify the crate directory in which the `Cargo.toml`
    file is present and then the plugin will take care of the auto-reloading part.
    To see it in action, let's stop and start the webpack server using `npm run serve`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's edit the `src/main.rs` file with Hello Galaxy. Open the browser to
    see the console log changed to **Hello Galaxy** already.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens here?
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-pack-plugin` is hooked into webpack using webpack''s plugin system. This
    will run along with the webpack compiler. If any changes are made in the `src`
    directory, `wasm-pack-plugin` will then run the `wasm-pack` compilation to compile
    the Rust code into WebAssembly modules automatically. This will trigger a recompilation
    in the webpack compiler. Once the webpack compiler recompiles, it will notify
    `webpack-dev-server` to reload the changes in the browser. The browser then reloads
    the changes automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-pack-plugin` makes it easy to run Rust and WebAssembly along with webpack.
    Now, let''s check how we can run Rust and WebAssembly with Parcel.'
  prefs: []
  type: TYPE_NORMAL
- en: Bundling WebAssembly modules with Parcel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Parcel is a blazing-fast, zero-configuration web application bundler.*`index.html`)
    and then build the entire graph from there.'
  prefs: []
  type: TYPE_NORMAL
- en: While webpack has a plugin-based architecture, Parcel has a worker-based architecture.
    This enables Parcel to be faster than webpack as it uses multicore compilation
    and cache.
  prefs: []
  type: TYPE_NORMAL
- en: Parcel also has inbuilt configuration to support JavaScript, CSS, and HTML files.
    Just like webpack, it also has various plugins that we can use to configure the
    bundler to produce the required output.
  prefs: []
  type: TYPE_NORMAL
- en: It also has inbuilt transformation support using standard Babel, PostCSS, and
    PostHTML when it is required. We can extend them and change them via plugins if
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parcel also has automatic, out-of-the-box hot module replacement to track and
    record changes to files (that are recorded by the dependency graph). Let''s build
    WebAssembly modules using parcel as a bundler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a new Rust project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the project is created, open the project in your favorite editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the `wasm-bindgen` dependency for the project, open the `Cargo.toml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, remove the `[dependencies]` tag and replace it with the bold lines above.
    We are telling the compiler that the library that is getting generated will be
    dynamic and it has a dependency on the `wasm-bindgen` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we open the `src/lib.rs` file and replace the contents with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will reuse the simple Hello World example here. Build the `wasm` module
    using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since Parcel supports zero configuration, all we need to do is add Parcel dependencies
    to `package.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since Parcel is a zero-configuration bundler, we just have to define the entry
    point to it. We define the entry point in the `scripts` section. The `serve` command
    is the command that we use to run the code for development purposes. When we define
    `parcel build index.html`, we are informing Parcel that the entry point is `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please use the latest version applicable here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will create the entry point. We will create an `index.html` file as
    specified in the `package.json` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `index.js` file to load the binding JavaScript, which in turn loads
    the WebAssembly module generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, head over to the terminal. Run the following command to install the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the Parcel application using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Parcel's zero-configuration nature makes it extremely easy to get started with
    WebAssembly. By default, Parcel supports `.wasm` files. We can even import `.wasm`
    files just like any other `.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that synchronously importing WebAssembly modules is
    still not supported. But we can write an import as a synchronous import. Internally,
    Parcel will generate the necessary extra code to preload the file before JavaScript
    execution starts.
  prefs: []
  type: TYPE_NORMAL
- en: This implies the WebAssembly file will be a separate bundle rather than in line
    with the bundled JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the Rust file and see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you save the file, you will not see any changes. Parcel has no clue that
    you have changed the source and the compiler will not react.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make Parcel react to the Rust source changes, we need to add a plugin. The
    plugin is `parcel-plugin-wasm.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the plugin, we can run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will download the plugin to `node_modules`. This will also save the plugin
    in `package.json`'s `devDependencies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, we need to change `index.js` such that it looks at the source
    code directly instead of referencing from the `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, instead of importing from the WebAssembly module, we specify the entry
    Rust file. We can even specify the location of the `Cargo.toml` file to make Parcel
    look for changes in the respective places.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's edit the `src/main.rs` file with Hello Galaxy. Open the browser to
    see how the console log has changed to **Hello Galaxy.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, what happens here?
  prefs: []
  type: TYPE_NORMAL
- en: Parcel just requires the starting point of our application. It will generate
    the dependency graph from there. The parcel plugin keeps looking for any changes
    in the folder to happen. It basically looks in the folder that contains the `Cargo.toml`
    file. The `Cargo.toml` location is given to the Parcel bundler and its plugin
    via `index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: So, any changes that happen to the Rust file will lead to the following process.
  prefs: []
  type: TYPE_NORMAL
- en: When the Rust file is saved, the watchers inside `parcel-plugin-wasm.rs` are
    triggered. Then, `parcel-plugin-wasm.rs` will initiate the compilation process
    of the Rust code into WebAssembly via `wasm-pack`. Once `wasm-pack` compiles and
    produces new WebAssembly code, the plugin will notify the Parcel compiler that
    something in the dependency graph has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: The Parcel compiler then recompiles, which will result in the browser being
    refreshed. The browser now displays the changed message.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for Parcel, we actually used a synchronous module import, while for
    webpack, we were relying on asynchronous import.
  prefs: []
  type: TYPE_NORMAL
- en: The `parcel-plugin-wasm.rs` plugin makes it easy to run Rust and WebAssembly
    along with Parcel. Now, let's check how we can install and use `wasm-pack` to
    pack and publish WebAssembly modules.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing wasm-pack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be compatible with JavaScript, Rust-based WebAssembly applications should
    be completely interoperable with the JavaScript world. Without that, it will be
    difficult for developers to bootstrap their WebAssembly projects in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The node modules completely changed the perspective of the JavaScript world.
    They make it easier to develop and share the modules between Browser and Node
    environments. Developers around the world can use these libraries wherever and
    whenever they want.
  prefs: []
  type: TYPE_NORMAL
- en: The `wasm-pack` tool seeks to be a one-stop shop for building and working with
    Rust-generated WebAssembly that you would like to interoperate with JavaScript,
    in the browser or with Node.js. `- wasm-pack` website. [https://github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack)
  prefs: []
  type: TYPE_NORMAL
- en: Why do you need wasm-pack?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`wasm-pack` makes it easy to build and pack Rust- and WebAssembly-based projects.
    Once packed, the module is ready to be shared with the world via the npm registry
    – just like millions (or even billions) of JavaScript libraries out there.'
  prefs: []
  type: TYPE_NORMAL
- en: How to use wasm-pack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`wasm-pack` is available as a Cargo library. If you are following along with
    this book, then you might have already installed Cargo. To install `wasm-pack`,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will download, compile, and install the `wasm-pack` library.
    Once installed, the `wasm-pack` command will be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether `wasm-pack` is installed correctly, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have `wasm-pack` installed, let''s see how to use `wasm-pack` to build
    and pack Rust and WebAssembly projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first generate a new project with Cargo. To generate the project, use
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the project is created, open it in your favorite editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the `wasm-bindgen` dependency for the project, open the `cargo.toml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, remove the `[dependencies]` tag and replace that with the `wasm-bindgen`
    library. We are telling the compiler that the library that is getting generated
    will be dynamic and it has a dependency to the `wasm-bindgen` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we open the `src/lib.rs` file and replace the contents with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, this is a simple function that returns a number (which is the universal
    answer).
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we used to build the Rust and WebAssembly application with `rustc`
    or Cargo. This produced a WebAssembly binary. But the binary is not useful by
    itself; it needs a binding file. With `wasm-bindgen`, we will generate the binding
    file along with the WebAssembly binary.
  prefs: []
  type: TYPE_NORMAL
- en: These two steps are mandatory, but they are mundane. We can replace them with
    `wasm-pack`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the WebAssembly application with `wasm-pack`, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run `wasm-pack build`, this is what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-pack` first checks whether the Rust compiler is installed. If it''s installed,
    then it checks whether the Rust compiler is greater than version 1.30.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wasm-pack` checks for the crate configuration and whether the library indicates
    that we are generating a dynamic library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wasm-pack` validates whether there is any `wasm-target` available for building.
    If the `wasm32-unknown-unknown` target is not available, `wasm-pack` will download
    and add the target.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the environment is ready, `wasm-pack` then starts compiling the module
    and build the WebAssembly Module and binding JavaScript files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that the `wasm-pack` command also generates the `package.json` file. The
    `package.json` file looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it copies over the Readme and LICENSE file if we have one, to ensure
    there is shared documentation between the Rust and WebAssembly versions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wasm-pack` also checks for the presence of `wasm-bindgen-cli`, which, if not
    present, will be installed using Cargo.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the build has successfully finished, it will create a `pkg` directory.
    Inside `pkg`, it will pipe the output of `wasm-bindgen`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, this `pkg` folder can be bundled and shared like any other JavaScript module.
    We'll see how to achieve that in the future recipes.
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-pack` is a great tool to pack and publish WebAssembly modules. Now, let''s
    check out how to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Packing and publishing using wasm-pack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most amazing (and, of course, the most important) thing for a library developer
    to do is to pack and publish artifacts. That is why we spend our days and nights
    carefully crafting the application, publishing it to the world, receiving feedback
    (either negative or positive), and then enhancing the application based on that.
  prefs: []
  type: TYPE_NORMAL
- en: The critical point for any project is its first release, which defines the fate
    of the project. Even though it is simply an MVP, it will give the world a glimpse
    of what we are working on and gives us a glimpse of what we have to work on in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-pack` helps us to build, pack, and publish Rust- and WebAssembly-based
    projects into the npm registry. We have already seen how `wasm-pack` makes it
    simpler to build Rust into the WebAssembly binary along with the binding JavaScript
    file using `wasm-bindgen` underneath. Let''s further explore what we can do with
    its `pack` and `publish` flags.'
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-pack` provides a `pack` flag to pack the artifacts that were generated
    using the `wasm-pack` build command. Although it is not necessary to use `wasm-pack`
    to build binaries, it generates all the boilerplate that we will need to pack
    the artifacts into a Node module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to pack the built artifacts using `wasm-pack`, we have to run the
    following command with reference to `pkg` (or the directory with which we generated
    our build artifacts):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can also run the command by passing in `project_folder/pkg` as its argument.
    Without any argument, the `wasm-pack pack` command will search for the `pkg` directory
    in the current working directory where it is running.
  prefs: []
  type: TYPE_NORMAL
- en: The `wasm-pack pack` command first identifies whether the folder provided is
    a `pkg` directory or contains a `pkg` directory as its immediate child. If the
    check passes, then `wasm-pack` will invoke the npm pack command underneath, to
    pack the library into an npm package.
  prefs: []
  type: TYPE_NORMAL
- en: To bundle the npm package, all we need is a valid `package.json` file. That
    file is generated by the `wasm-pack` build command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the `pack` command inside the `cg-array-world` example from our
    previous recipe and check what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, the `pack` command creates a tarball package with the contents
    inside the `pkg` folder with the help of the `npm pack` command.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have packed our application, the obvious next step will be to publish
    it. In order to publish the tarball generated, `wasm-pack` has a `publish` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to publish the package, we have to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `wasm-pack publish` command will first check whether the `pkg` directory
    is already present in the directory provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `pkg` directory is not present, then it will ask whether you want to
    create the package first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you answer `Y` to the question, then it asks for you to input the folder
    in which you want to generate the build artifacts. We can give any folder name
    or use the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it asks for your target, that is, the target in which the build should
    be generated. You can choose between the various options here, as discussed in
    the build recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Based on the option provided, it will generate the artifact in the specified
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once the artifacts are produced, they are then ready to be published using npm
    publish. For npm publish to work correctly, we need to be authenticated. You can
    authenticate to npm by using either npm login or `wasm-pack` login.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `wasm-pack login` command will invoke the underlying npm login command
    and then create a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wasm-pack publish` command also supports two options, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-a` or `--access` to determine the access level of the package to be deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This accepts either `public` or `restricted`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` – Makes the package public'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restricted` – Makes the package internal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t` or `--target` to support various targets in which the build is produced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, `wasm-pack` makes it easy to pack and publish WebAssembly binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to run a WebAssembly project with bundlers such
    as webpack and Parcel. Parcel and webpack make it easy for JavaScript developers
    to run and develop Rust and WebAssembly projects. Then, we installed `wasm-pack`
    and used it to run the project. Finally, we used `wasm-pack` to pack and publish
    the WebAssembly module to npm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to share complex objects between Rust
    and WebAssembly with `wasm-bindgen`.
  prefs: []
  type: TYPE_NORMAL
