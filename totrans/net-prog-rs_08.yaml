- en: Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: 'Security is often looked at as an afterthought in systems design. That is evident
    in common protocols; security related RFCs has historically been proposed after
    the main protocol. Notice that any communication over a public medium (like the
    internet) is vulnerable to man-in-the-middle attacks. An adversary might hijack the
    communication by carefully inspecting input packets from both sides. In light
    of that, some security related questions are reasonable: When a client connects
    to a server, how does it verify that the server is the one it claims to be? How
    do they decide on a shared secret key to use for encryption? In this chapter,
    we will see how these questions are commonly addressed.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性通常在系统设计中被视为事后考虑。这在常见协议中很明显；安全相关的RFC在历史上是在主要协议之后提出的。请注意，任何在公共媒介（如互联网）上的通信都容易受到中间人攻击。对手可能会通过仔细检查来自双方的输入数据包来劫持通信。鉴于这一点，一些安全相关问题是合理的：当客户端连接到服务器时，它如何验证服务器是它声称的那个？他们如何决定用于加密的共享密钥？在本章中，我们将看到这些问题通常是如何解决的。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Securing web-based applications using certificates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用证书保护基于Web的应用程序
- en: Key exchange using the Diffie-Hellman method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Diffie-Hellman方法进行密钥交换
- en: Securing the web
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护网络
- en: In a previous chapter, we studied HTTP. We noted how important it has been in
    making our lives easier. However, HTTP is vulnerable to a range of attacks that
    might result in leaking the payload. Thus, it was necessary to add some form of
    security between parties using HTTP to communicate. RFC 2818 proposed HTTPS (HTTP
    Secure) as a version of HTTP that uses a secure streaming protocol underneath.
    Initially, this was **Secure Socket Layer** (**SSL**), and later evolved into
    **Transport Layer Security** (**TLS**).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们学习了HTTP。我们注意到HTTP在使我们的生活变得更轻松方面是多么重要。然而，HTTP容易受到各种攻击，可能导致有效载荷泄露。因此，在HTTP通信的各方之间添加某种形式的安全措施是必要的。RFC
    2818提出了HTTPS（HTTP安全）作为HTTP的一个使用安全流协议的版本。最初，这被称为**安全套接字层**（**SSL**），后来演变为**传输层安全性**（**TLS**）。
- en: 'The basic scheme of things goes like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 基本方案是这样的：
- en: The **Client** and **Server** establish a TCP connection.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**和**服务器**建立TCP连接。'
- en: The **Client** and **Server** agree upon a cipher and hash function to use throughout
    the connection. For this, the client sends a list of ciphers and hash functions.
    The **Server** picks one from that list and lets the **Client** know.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**和**服务器**就整个连接期间使用的加密算法和散列函数达成一致。为此，客户端发送一个加密算法和散列函数列表。**服务器**从该列表中选择一个，并通知**客户端**。'
- en: The **Server** sends a certificate to the **Client**. The **Client** validates
    this against a list of certificate authorities that it has locally.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**向**客户端**发送证书。**客户端**将其与本地拥有的证书颁发机构列表进行验证。'
- en: Both agree on a session key to be used to encrypt data during the connection.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都同意使用会话密钥来加密连接期间的数据。
- en: At this point, a regular HTTP session can begin.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到这一点，一个普通的HTTP会话可以开始了。
- en: 'The following image illustrates the steps for this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了这一步骤：
- en: '![](img/00017.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: Client-server communication over SSL
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSL的客户端-服务器通信
- en: 'One of the most important steps here is verifying the server''s identity. This
    answers a fundamental question: W*hen the client talks to a server, how does it
    know the server is actually the server it wanted?* In practice, this is achieved
    using certificates. A certificate is a document that is signed by a certificate
    authority, a trusted provider who is legally allowed to vouch for others. A client
    has a list of trusted CAs, and if the CA which issued a given certificate is on
    that list, a client can trust the server that presents that certificate. In practice,
    there are often a chain of certificates issued as a chain of trust relationships,
    going back to a root CA.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的步骤之一是验证服务器的身份。这回答了一个基本问题：当客户端与服务器通信时，它如何知道服务器确实是它想要的服务器？在实践中，这是通过证书实现的。证书是由证书颁发机构签发的文件，这是一个受法律允许为他人作保的可信提供商。客户端有一份受信任的CA列表，如果颁发给定证书的CA在该列表中，客户端可以信任提供该证书的服务器。在实践中，通常有一系列证书作为信任关系链发行，追溯到根CA。
- en: In recent years, search engines put a heavy emphasis on having HTTPS on websites,
    often ranking them higher in that case. However, issuing a certificate for a website
    has traditionally been a tedious process. A website owner will have to log in
    to a CA's website and provide some form of identification. Issuing the certificate
    often took a few hours and was very costly for small business owners. In 2015,
    Let's Encrypt launched as a non-profit CA with the goal of providing free, short-lived
    certificates to all websites on the internet. They automate the validation process
    by issuing a challenge to the server administrator. This typically involves either
    placing a given file in a known location on the website or creating a DNS record
    with a given content. Once `letsencrypt` has validated the server, it issues a
    certificate valid for 90 days. Thus, the certificate needs to be renewed periodically.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，搜索引擎非常重视网站使用HTTPS，通常会将这些网站排名更高。然而，为网站颁发证书一直是传统上繁琐的过程。网站所有者必须登录到CA的网站并提供某种形式的身份证明。颁发证书通常需要几个小时，对小企业主来说成本很高。2015年，Let's
    Encrypt作为一个非营利性CA成立，旨在为互联网上的所有网站提供免费、短期有效的证书。他们通过向服务器管理员发出挑战来自动化验证过程。这通常涉及在网站上已知位置放置一个文件或创建一个具有给定内容的DNS记录。一旦`letsencrypt`验证了服务器，它就会颁发一个有效期为90天的证书。因此，证书需要定期续订。
- en: 'More recently, `letsencrypt` standardized the challenge response protocol as
    JSON over HTTPS and named it ACME. Here is how this works:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，`letsencrypt`将挑战响应协议标准化为HTTPS上的JSON，并将其命名为ACME。以下是它是如何工作的：
- en: The local client generates a private-public keypair and contacts the letsencrypt
    server with the **Public** key.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地客户端生成一个私钥-公钥对，并使用**公钥**联系letsencrypt服务器。
- en: The server creates an account for the given key and registers it.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器为给定的密钥创建一个账户并将其注册。
- en: 'Based on challenge preferences, the **Client** will present a list of challenges
    that can be fulfilled and ask the server to validate the domain. Currently, two
    challenges are supported: an HTTP based challenge where a file is placed on a
    known location and the server will read it to validate, or a DNS based challenge
    where the operator has to create a `TXT` record on the domain with a given content.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据挑战偏好，**客户端**将展示一个可以满足的挑战列表，并要求服务器验证域名。目前支持两种挑战：基于HTTP的挑战，其中在已知位置放置一个文件，服务器将读取它以进行验证；或基于DNS的挑战，其中操作员必须在域名上创建一个具有给定内容的`TXT`记录。
- en: The server generates the challenge and sends it back.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器生成挑战并将其发送回。
- en: At this point, the client will poll the server for confirmation.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这一点上，客户端将轮询服务器以获取确认。
- en: When the server returns an OK, the client can proceed to generating a **certificate
    signing request** (**CSR**) for the server and send it across.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器返回OK时，客户端可以继续为服务器生成一个**证书签名请求**（**CSR**）并将其发送过去。
- en: The server then generates a certificate and sends it back.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，服务器生成一个证书并将其发送回。
- en: 'The following diagram illustrates individual steps in the ACME protocol:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了ACME协议中的各个步骤：
- en: '![](img/00018.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: ACME protocol operation
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ACME协议操作
- en: Letsencrypt using Rust
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rust的Let's Encrypt
- en: Currently, there is one crate that allows access to `letsencrypt` using Rust.
    The CLI tool called `acme-client` can interact with the API to obtain or revoke
    a certificate or run validations of ownership. The binary is backed by a crate
    called acme-client that enables programmatic interaction with the API. Let's see
    how this can be used to secure an HTTP server running on Rocket. Remember, for
    this to work, `letsencrypt` will need to reach the server. Thus, this needs to
    be publicly accessible over the internet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有一个crate允许使用Rust访问`letsencrypt`。名为`acme-client`的CLI工具可以与API交互以获取或撤销证书或运行所有权验证。该二进制文件由名为acme-client的crate支持，它允许程序与API进行交互。让我们看看如何使用它来保护运行在Rocket上的HTTP服务器。记住，为了使这生效，`letsencrypt`需要能够访问服务器。因此，这需要在互联网上公开访问。
- en: 'The first step is to install the CLI tool using Cargo:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用Cargo安装CLI工具：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For our example, we will run our rocket blog over TLS. While Rocket does support
    TLS out of the box, it is not enabled by default. We will need to change the `Cargo.toml`
    file to add TLS as a feature flag. It should look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将运行我们的Rocket博客通过TLS。虽然Rocket默认支持TLS，但它不是默认启用的。我们需要更改`Cargo.toml`文件以将TLS添加为功能标志。它应该看起来像这样：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will also run Rocket on the public interface. For this, we will place a
    config file called `Rocket.toml` in the root of the repository. This is how it
    looks; everything else is left at the defaults:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将运行 Rocket 在公共接口上。为此，我们将在存储库的根目录中放置一个名为 `Rocket.toml` 的配置文件。这是它的样子；其他所有设置都保留为默认值：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Like we did before, we can run our server using Cargo:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们可以使用 Cargo 运行我们的服务器：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Letsencrypt also requires all servers to have a domain name. Thus, we will
    need to create a record for our server in a DNS provider. In our example, that
    DNS name is `my.domain.io`, which we will use in subsequent steps. Once that record
    has propagated everywhere, we can move on to the next step: generating certificates.
    Here is how we will do that using the CLI:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Let'sencrypt 还要求所有服务器都必须有一个域名。因此，我们需要在我们的 DNS 提供商中为我们的服务器创建一个记录。在我们的例子中，该 DNS
    名称是 `my.domain.io`，我们将在后续步骤中使用它。一旦该记录在所有地方都传播开来，我们就可以继续到下一步：生成证书。以下是我们将如何使用 CLI
    来完成这项工作：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will have to use the DNS based validation here since we will not be able
    to serve back challenges. The CLI asked us to create a `TXT` record with a given
    name and content. Once we create the record, we will need to wait for some time
    so that it can propagate before we move forward. It is a good idea to check if
    the record is updated using `dig` before moving forward. Here is how the output
    of `dig` should look:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法提供挑战，因此在这里我们必须使用基于 DNS 的验证。CLI 要求我们创建一个具有给定名称和内容的 `TXT` 记录。一旦我们创建了记录，我们就需要等待一段时间，以便在继续之前它能够传播。在继续之前，使用
    `dig` 检查记录是否已更新是个好主意。以下是 `dig` 输出的样子：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the output from `dig` says that we have the correct `TXT` record, we can
    move ahead with installing the certificate. `letsencrypt` will then query the
    `TXT` record and run domain validation. When everything looks fine, we will get
    a new certificate named `domain.crt`. Let''s inspect the certificate to make sure
    everything looks okay. The subject should match our domain name and the issuer
    should always be *Let''s Encrypt*, as shown in the following code snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `dig` 的输出表明我们拥有正确的 `TXT` 记录时，我们可以继续安装证书。`letsencrypt` 将查询 `TXT` 记录并运行域名验证。当一切看起来都正常时，我们将获得一个名为
    `domain.crt` 的新证书。让我们检查证书以确保一切正常。主题应该匹配我们的域名，而发行者始终应该是 *Let's Encrypt*，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we are ready to use this certificate in our Rocket application. We will
    need to place it at a location where the running Rocket has permission to read
    it. Now, if we restart Rocket and use `curl` to access the endpoint over HTTPS,
    it should work exactly like last time:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在我们的 Rocket 应用程序中使用这个证书了。我们需要将其放置在一个运行中的 Rocket 有权限读取的位置。现在，如果我们重启
    Rocket 并使用 `curl` 通过 HTTPS 访问端点，它应该和上次一样工作：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As of the time of writing, Let's Encrypt has a limit of five certificates for
    a given domain per week. For testing, it is possible to reach that limit pretty
    quickly. If that happens, the client will just say Acme server error*.*
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到编写本文时为止，Let's Encrypt 对每个域名每周有五个证书的限制。对于测试，可能很快就会达到这个限制。如果发生这种情况，客户端将只显示“Acme
    服务器错误”。
- en: 'Let''s write a simple client for our server here using `rustls`. We set up
    the project using Cargo:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里为我们的服务器编写一个简单的客户端，使用 `rustls`。我们使用 Cargo 设置项目：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then add `rustls` to our project as a dependency :'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `rustls` 添加到我们的项目中作为依赖项：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is how the client looks; note that the `webpki` crate does DNS resolution,
    which is then used by `rustls`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端看起来是这样的；请注意，`webpki` 包执行 DNS 解析，然后由 `rustls` 使用：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we are connecting to our server and running the same HTTP request. We
    import all three required crates. The first step is to initialize a TLS session
    and add the root certificates to it. We then resolve our given server to a DNS
    name reference and establish a TLS session with it. Having set this up, we can
    set up a TCP session by using `connect`. Finally, a `rustls` `Stream` is a combination
    of the SSL session and the TCP session. Once all those are working, we can write
    HTTP queries by hand. Here we are running a `GET` on the `/posts` endpoint. Later,
    we read the response and print it out. The output should be exactly the same as
    using the other clients:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在连接到我们的服务器并运行相同的 HTTP 请求。我们导入所有三个必需的包。第一步是初始化一个 TLS 会话并向其中添加根证书。然后，我们将给定的服务器解析为一个
    DNS 名称引用，并与之建立 TLS 会话。设置好这些后，我们可以通过使用 `connect` 来设置一个 TCP 会话。最后，`rustls` 的 `Stream`
    是 SSL 会话和 TCP 会话的组合。一旦所有这些都正常工作，我们就可以手动编写 HTTP 查询。这里我们在 `/posts` 端点运行一个 `GET`。稍后，我们读取响应并将其打印出来。输出应该和使用其他客户端一样：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: OpenSSL using Rust
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 的 OpenSSL
- en: The OpenSSL library and CLI is a complete set of tools to work with SSL (and
    TLS) objects. It is an open source project and is widely used by companies all
    around. As one would expect, Rust has bindings for using as a library in Rust
    projects. In this discussion, we will take a closer look at the certificates we
    saw in the last section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL库和CLI是一套完整的工具，用于处理SSL（和TLS）对象。它是一个开源项目，并被全球各地的公司广泛使用。正如预期的那样，Rust为在Rust项目中作为库使用提供了绑定。在本讨论中，我们将更详细地查看上一节中看到的证书。
- en: 'These are commonly defined by a standard called X.509 (defined in RFC 5280)
    and have the following fields:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常由一个称为X.509的标准（在RFC 5280中定义）定义，并具有以下字段：
- en: '**Version number**: Almost always set to 2, corresponding to version 3 (since
    the first version is 0). According to the standard, this field can be omitted
    and should be assumed to be version 1 (value set to 0).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本号**：几乎总是设置为2，对应于版本3（因为第一个版本是0）。根据标准，此字段可以省略，并应假定版本为1（值设置为0）。'
- en: '**Serial number**: A 20 octet identifier that is unique for the CA which signed
    this certificate.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列号**：一个20字节标识符，对于签发此证书的CA是唯一的。'
- en: '**Signature**: A unique ID that identifies the algorithm used to sign this
    certificate. This is usually a string defined in subsequent RFCs, an example being
    `sha1WithRSAEncryption`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：一个唯一ID，用于标识用于签发此证书的算法。这通常是在后续RFC中定义的字符串，例如`sha1WithRSAEncryption`。'
- en: '**Issuer name**: Identifies the CA that signed the certificate. This must have
    at least one **Distinguished name** (**DN**) composed of a number of components,
    including a **Common Name** (**CN**), **State** (**ST**), **Country** (**C**),
    and so on.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行者名称**：标识签发证书的CA。这必须至少包含一个**区分名称**（**DN**），由多个组件组成，包括**通用名称**（**CN**）、**州**（**ST**）、**国家**（**C**）等。'
- en: '**Validity**: Defines when the certificate should be valid. This has two sub-fields;
    `notBefore` denotes when this starts to be valid and `notAfter` denotes when it
    expires.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效期**：定义证书何时有效。它有两个子字段；`notBefore` 表示何时开始有效，`notAfter` 表示何时过期。'
- en: '**Subject name**: Identifies the entity this certificate certifies. For a root
    certificate, this will be the same as the issuer. This has the same format as
    the issuer name and should at least have a DN.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题名称**：标识此证书所证明的实体。对于根证书，这将与发行者相同。它具有与发行者名称相同的格式，并且至少应包含一个DN。'
- en: '**Subject public key info**: Information about the subject''s encrypted public
    key. This has two sub-fields; the first one is an ID for the encryption algorithm
    (as in the signature field), and the second is a bit stream that has the encrypted
    public key.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题公钥信息**：关于主题加密公钥的信息。它有两个子字段；第一个是一个加密算法的ID（如签名字段中所示），第二个是一个包含加密公钥的位流。'
- en: '**Issuer unique ID**: An optional field that can be used to uniquely identify
    the issuer.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行者唯一标识符**：一个可选字段，可用于唯一标识发行者。'
- en: '**Subject unique ID**: An optional field that can be used to identify the subject.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题唯一标识符**：一个可选字段，可用于标识主题。'
- en: '**Extensions**: This field is only applicable if the version is set to 3\.
    Denotes a number of optional fields that can be used to attach additional information
    to certificates.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：此字段仅在版本设置为3时适用。表示可以用于将附加信息附加到证书的多个可选字段。'
- en: '**Certificate signature algorithm**: Algorithm used to sign this certificate;
    must be the same as the one used in the signature attribute previously.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书签名算法**：用于签发此证书的算法；必须与之前签名属性中使用的算法相同。'
- en: '**Certificate signature value**: A bit string that has the actual signature
    for verification.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书签名值**：一个实际签名的位字符串，用于验证。'
- en: 'In the following example, we will use `rust-openssl` to generate and inspect
    a certificate from scratch. Installing the library, however, can be a little complicated.
    Since it is a wrapper around `libopenssl`, it needs to link against the native
    library. Thus, the library has to be installed. The crate''s documentation has
    instructions to get this set up. The project setup is routine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用 `rust-openssl` 从头开始生成和检查证书。然而，安装这个库可能有点复杂。因为它围绕 `libopenssl` 包装，所以需要链接到本地库。因此，必须安装这个库。该软件包的文档提供了设置此环境的说明。项目设置是常规的：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is the `Cargo.toml` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Cargo.toml`文件：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Also, for this example, we will use the master branch of the repository, since
    we need a few features that are not released yet. For that, we will need to specify
    the repository link, as shown previously. Here is the main file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于这个示例，我们将使用存储库的master分支，因为我们需要一些尚未发布的特性。为此，我们需要指定存储库链接，如前所述。以下是主文件：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we take in a filename as a command-line parameter to write the certificate
    to. Certificate creation is offloaded to a helper function called `create_cert`
    that returns either a tuple having the generated certificate and private key or
    a list of errors as a `Result`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们接受一个命令行参数作为文件名，以将证书写入。证书创建被委托给一个名为`create_cert`的辅助函数，该函数返回一个包含生成的证书和私钥的元组，或者作为一个`Result`的错误列表。
- en: The first step is to initialize a certificate builder object that we will add
    on to, and finally, build our certificate. We use the `set_version` method to
    set the version to 3 (numerically set to `2`). Now we need to generate a serial
    number and set it. We generate that by randomly sampling 160 bits (20 octets of
    8 bits each). We use the `set_serial_number` method to set the serial number.
    The next step is to generate a name by using a name builder. The `append_entry_by_text`
    method is then used to add a country name and a common name to our name builder.
    We use `set_issuer_name` to append the `name` object to the certificate. We set
    the expiry date to 365 days after the current date and use `set_not_before` and
    `set_not_after` to set those two. The subject name is set to the same name object
    using `set_subject_name`. Finally, we need to generate a private key, which we
    generate using the `Rsa` module, and we set the private key on the certificate.
    Now, the certificate needs to be signed with the private key using SHA512\. Once
    done, we can use the `build` method to create the certificate. At the end of the
    function, we return the certificate and private key to the caller.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是初始化一个证书构建器对象，我们将添加到它上面，并最终构建我们的证书。我们使用`set_version`方法将版本设置为3（数值设置为`2`）。现在我们需要生成一个序列号并设置它。我们通过随机采样160位（每个8位20个八位字节）来生成它。我们使用`set_serial_number`方法来设置序列号。下一步是使用名称构建器生成一个名称。然后使用`append_entry_by_text`方法将国家名称和通用名称添加到我们的名称构建器中。我们使用`set_issuer_name`将`name`对象附加到证书上。我们将到期日期设置为当前日期后的365天，并使用`set_not_before`和`set_not_after`来设置这两个日期。使用`set_subject_name`将主题名称设置为相同的名称对象。最后，我们需要生成一个私钥，我们使用`Rsa`模块生成它，并将私钥设置在证书上。现在，证书需要使用SHA512进行签名。完成后，我们可以使用`build`方法创建证书。函数结束时，我们将证书和私钥返回给调用者。
- en: In our `main` function, we call the `helper` function. For our example, we will
    ignore the key, but a real application does need to save it for verification later.
    We convert the `certificate` object to PEM encoding and write it to a file on
    the disk. The next step is reading the subject name programmatically. For this,
    we use the `subject_name` method on the `certificate` object and print it out
    as a string. This should match the subject name we set earlier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，我们调用`helper`函数。对于我们的示例，我们将忽略密钥，但实际应用确实需要保存它以供稍后验证。我们将`certificate`对象转换为PEM编码，并将其写入磁盘上的文件。下一步是程序化地读取主题名称。为此，我们使用`certificate`对象上的`subject_name`方法，并将其作为字符串打印出来。这应该与之前设置的名称相匹配。
- en: 'Here is how we can run this using Cargo. Note that this creates a certificate
    named `bar.crt` in the current directory:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Cargo运行此代码的方法。请注意，这将在当前目录中创建一个名为`bar.crt`的证书：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Securing tokio applications
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护Tokio应用程序
- en: 'A common problem in implementing Tokio based protocols is around securing them.
    Luckily, the Tokio ecosystem has `tokio-tls` for this. Let''s look at an example
    of using this to secure our hyper example from a previous chapter. Here is our
    setup:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现基于Tokio的协议时，一个常见问题是如何确保其安全性。幸运的是，Tokio生态系统提供了`tokio-tls`来解决这个问题。让我们看看如何使用这个工具来保护我们之前章节中的超示例。以下是我们的设置：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Cargo manifest should look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo清单应该看起来像这样：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will need to use the `tokio-proto` feature on `tokio-tls` to enable integration
    with `tokio-proto`. The next step is to generate a self-signed certificate for
    our server. `tokio-tls` uses the `native-tls` library underneath, and that does
    not support constructing acceptors from X509 certificates at the time of this
    writing. Thus, we will need to use PKCS12 certificates. The command shown ahead
    generates a self signed certificate, valid for 365 days, in PEM format. This will
    ask for a pass-phrase for the certificate. In our case, we used `foobar`. Please
    ensure that this command is run in the `tokio-tls-example` directory so that our
    code can read the certificate:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`tokio-proto`功能在`tokio-tls`上启用与`tokio-proto`的集成。下一步是为我们的服务器生成一个自签名证书。`tokio-tls`在底层使用`native-tls`库，而该库在撰写本文时不支持从X509证书构建接受者。因此，我们需要使用PKCS12证书。前面显示的命令生成一个有效期为365天的自签名证书，格式为PEM。这将要求输入证书的密码短语。在我们的例子中，我们使用了`foobar`。请确保在`tokio-tls-example`目录中运行此命令，以便我们的代码可以读取证书：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following command converts the given certificate to PKCS12 format. This
    should generate a file called `cert.pfx` in the current directory, which we will
    use in the code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将给定的证书转换为PKCS12格式。这将在当前目录中生成一个名为`cert.pfx`的文件，我们将在代码中使用它：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is our main file, with some changes for enabling SSL:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的主要文件，为了启用SSL进行了一些修改：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The major changes here are that in the main function, we use the `include_bytes`
    macro to read the certificate as raw bytes. We then construct a `Pkcs12` object
    using `from_der` by passing the certificate bytes and the pass-phrase that we
    used while creating the certificate. The next step is to create a `TlsAcceptor`
    object using the given `Pkcs12` `certificate` object. We will then need to wrap
    the `acceptor` object and the `hyper protocol` object into a `Server`. This is
    passed to the `TcpServer` constructor, which we then start.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里主要的改变是在主函数中，我们使用`include_bytes`宏以原始字节读取证书。然后我们使用`from_der`通过传递证书字节和我们在创建证书时使用的密码短语来构造一个`Pkcs12`对象。下一步是使用给定的`Pkcs12`证书对象创建一个`TlsAcceptor`对象。然后我们需要将`acceptor`对象和`hyper协议`对象包装到一个`Server`中。这被传递给`TcpServer`构造函数，然后我们启动它。
- en: 'Here is what a session looks like from a client''s perspective:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端视角下的会话看起来像什么：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is what the server prints; this originates from the `println!` macro in
    the call function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是服务器打印的内容；这源自调用函数中的`println!`宏：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Interestingly, the `openssl` command-line tool has a TCP client that can be
    used to test SSL connections as well. Here is how to use it to test our server:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`openssl`命令行工具有一个TCP客户端，可以用来测试SSL连接。以下是使用它来测试我们的服务器的方法：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This tool negotiates an SSL session and dumps the server certificate as shown
    previously (we have replaced the actual certificate for brevity). Notice that
    it correctly detects that the given server is using a self-signed certificate.
    Finally, it starts a TCP session. Since this is bare TCP, we will need to hand
    craft our HTTP requests. If we use a simple `GET` request on `/`, we get back
    a response of `200 OK`, and the string is done. On the other side, this is what
    the server prints:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具协商SSL会话，并像之前显示的那样输出服务器证书（为了简洁，我们已替换了实际的证书）。注意，它正确地检测到给定的服务器正在使用自签名证书。最后，它启动一个TCP会话。由于这是裸TCP，我们需要手动构建我们的HTTP请求。如果我们对`/`使用简单的`GET`请求，我们会收到一个`200
    OK`的响应，字符串就完成了。在服务器那一侧，这是它打印的内容：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that this prints the `Host` header, set to the string `foobar`, as we
    wrote on the client side.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里打印了`Host`头，设置为字符串`foobar`，正如我们在客户端所写的那样。
- en: Cryptography using ring
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ring的加密
- en: A commonly used crate for cryptography is called `ring`. This crate supports
    a number of lower-level crypto primitives, like random number generation, key
    exchanges, and so on. In this section, we will take key exchange as an example
    and see how this crate can be used in client-server applications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常用的加密库叫做`ring`。这个库支持许多底层加密原语，如随机数生成、密钥交换等。在本节中，我们将以密钥交换为例，看看这个库如何在客户端-服务器应用程序中使用。
- en: A common problem in communication is that of encrypting information so that
    a third-party cannot decipher it. In a private key system, both the client and
    the server will need to agree on a key to use for this to work. Now, this key
    cannot be transmitted in plain text over an insecure connection. The Diffie-Hellman
    key exchange method defines a mechanism where two parties talking over a secure
    link can negotiate a key that is shared between them, but has not been transmitted
    over the connection. This method has a number of implementations on many platforms,
    including the crate in question.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通信中一个常见的问题是加密信息，以便第三方无法解密它。在私钥系统中，客户端和服务器都需要就一个用于此目的的密钥达成一致。现在，这个密钥不能在不可信的连接上以明文形式传输。Diffie-Hellman密钥交换方法定义了一种机制，其中两个通过安全链路交谈的当事人可以协商一个双方共享的密钥，但这个密钥没有通过连接传输。这种方法在许多平台上都有多种实现，包括所讨论的crate。
- en: 'The following diagram shows how the protocol works:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了该协议的工作方式：
- en: '![](img/00019.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00019.jpeg)'
- en: Diffie-Hellman key exchange in action
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie-Hellman密钥交换在实际操作中
- en: 'Initially, the server will be listening for incoming clients. When a client
    connects, this is the sequence of events:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，服务器将监听传入的客户端。当客户端连接时，这是事件序列：
- en: A TCP session is first set up.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP会话首先被建立。
- en: Both the server and the client generate private and public keys.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器和客户端都会生成私钥和公钥。
- en: The client then sends its public key to the server.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端然后将它的公钥发送给服务器。
- en: The server responds by sending the public key that it generated.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器通过发送它生成的公钥进行响应。
- en: At this point, both of the parties can generate the shared secret key using
    their private keys and the public key that they received.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，双方可以使用他们的私钥和收到的公钥生成共享的秘密密钥。
- en: Further communication can be encrypted using the shared secret key.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进一步的通信可以使用共享的秘密密钥进行加密。
- en: 'We will create an empty library project for this example. We will then create
    an example directory and place the two files shown later in there. Project setup
    will go like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个示例创建一个空的库项目。然后我们将创建一个示例目录并将稍后显示的两个文件放在那里。项目设置将如下进行：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, here is what `Cargo.toml` should look like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这是`Cargo.toml`应该看起来像的样子：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s look at the client first. This is heavily borrowed from the simple TCP
    servers we wrote in the second chapter. This is completely synchronous and blocking:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看客户端。这主要借鉴了我们在第二章中编写的简单TCP服务器。这是完全同步和阻塞的：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We of course need the `ring` crate as an external dependency. The other crate,
    called `untrusted`, is a helper for taking in data from untrusted sources to `ring`
    as input. We then initialize ring's random number generator; this will be used
    to generate keys later. We then generate a private key for the client using the
    `generate` method. The client's public key is generated based on the private key
    using `compute_public_key`. At this point, the client is ready to send the public
    key to the server. It writes the key as a byte stream to the connection created
    earlier. Ideally, the server should send out its public key at this point, which
    the client needs to read off the same connection. This is done by the `read_until`
    call that places the data received in the buffer. The incoming data is then passed
    through the untrusted crate so that `ring` can consume it. Finally, the client-side
    key is generated using `agree_ephemeral`, which takes in the two keys collected
    (the client's private key and the server's public key), an error value, and a
    closure to be used on the generated byte stream. In the closure, we collect all
    the data in a vector and return it. The last step is to print that vector.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然需要`ring`crate作为外部依赖。另一个crate，称为`untrusted`，是用于从不受信任的源数据到`ring`作为输入的辅助工具。然后我们初始化ring的随机数生成器；这将用于稍后生成密钥。然后我们使用`generate`方法为客户生成一个私钥。客户端的公钥是基于私钥使用`compute_public_key`生成的。在这个时候，客户端准备好将公钥发送给服务器。它将密钥作为字节流写入之前创建的连接。理想情况下，服务器应该在这个时候发送其公钥，客户端需要从相同的连接中读取。这是通过`read_until`调用完成的，该调用将接收到的数据放入缓冲区。然后，传入的数据通过`untrusted`crate传递，以便`ring`可以消费它。最后，客户端使用`agree_ephemeral`生成密钥，该函数接受收集到的两个密钥（客户端的私钥和服务器公钥）、一个错误值和一个用于生成的字节流的闭包。在闭包中，我们收集所有数据到一个向量中并返回它。最后一步是打印那个向量。
- en: 'The server is similar and looks like the following code snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器类似，如下代码片段所示：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Like we did last time, we handle each client in a new thread. The semantics
    in the `handle_client` function is similar to that of the client; we start with
    generating a private and a public key. The next step is to read the public key
    that the client sent, followed by sending the public key of the server. Once settled,
    we can then use `agree_ephemeral` to generate the shared secret key, which should
    match the one generated on the client side.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上次一样，我们为每个客户端处理一个新的线程。`handle_client` 函数的语义与客户端相似；我们首先生成一个私钥和一个公钥。下一步是读取客户端发送的公钥，然后发送服务器的公钥。一旦确定，我们就可以使用
    `agree_ephemeral` 生成共享密钥，这个密钥应该与客户端生成的密钥相匹配。
- en: 'Here is a sample run on the server side:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在服务器端的一个示例运行：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And here is one on the client side:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这里有一个客户端的例子：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that the generated key is the same for both the server and the client,
    which is what we expect.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，生成的密钥对于服务器和客户端都是相同的，这正是我们所期望的。
- en: 'At the time of writing, the ring crate does not work on the latest nightly.
    To make it work, run these in the project directory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，ring crate 在最新的 nightly 版本上无法工作。为了使其工作，请在项目目录中运行以下命令：
- en: '`**$ rustup component add rustfmt-preview --toolchain nightly-2017-12-21**`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`**$ rustup component add rustfmt-preview --toolchain nightly-2017-12-21**`'
- en: '`**$ rustup override set nightly-2017-12-21**`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`**$ rustup override set nightly-2017-12-21**`'
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a quick look at securing communication over public
    networks. We started with an overview of certificates and how they are used for
    identifying servers on the web. We looked at using `letsencrypt` and `openssl`
    in Rust. We then moved on to securing Tokio applications using the same techniques.
    Finally, we took a quick look at doing key exchanges using the DH method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速浏览了在公共网络上确保通信的安全性。我们从证书的概述开始，了解了它们是如何用于在网络上识别服务器的。我们探讨了在 Rust 中使用 `letsencrypt`
    和 `openssl`。然后，我们继续使用相同的技术来确保 Tokio 应用程序的安全性。最后，我们简要地看了一下使用 DH 方法进行密钥交换。
- en: The following section is the appendix; there, we will look at some extra crates
    and techniques that are becoming popular in the community.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分是附录；在那里，我们将探讨一些在社区中变得越来越流行的额外 crate 和技术。
