- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Security is often looked at as an afterthought in systems design. That is evident
    in common protocols; security related RFCs has historically been proposed after
    the main protocol. Notice that any communication over a public medium (like the
    internet) is vulnerable to man-in-the-middle attacks. An adversary might hijack the
    communication by carefully inspecting input packets from both sides. In light
    of that, some security related questions are reasonable: When a client connects
    to a server, how does it verify that the server is the one it claims to be? How
    do they decide on a shared secret key to use for encryption? In this chapter,
    we will see how these questions are commonly addressed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing web-based applications using certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key exchange using the Diffie-Hellman method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a previous chapter, we studied HTTP. We noted how important it has been in
    making our lives easier. However, HTTP is vulnerable to a range of attacks that
    might result in leaking the payload. Thus, it was necessary to add some form of
    security between parties using HTTP to communicate. RFC 2818 proposed HTTPS (HTTP
    Secure) as a version of HTTP that uses a secure streaming protocol underneath.
    Initially, this was **Secure Socket Layer** (**SSL**), and later evolved into
    **Transport Layer Security** (**TLS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic scheme of things goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Client** and **Server** establish a TCP connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Client** and **Server** agree upon a cipher and hash function to use throughout
    the connection. For this, the client sends a list of ciphers and hash functions.
    The **Server** picks one from that list and lets the **Client** know.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Server** sends a certificate to the **Client**. The **Client** validates
    this against a list of certificate authorities that it has locally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both agree on a session key to be used to encrypt data during the connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, a regular HTTP session can begin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image illustrates the steps for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Client-server communication over SSL
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important steps here is verifying the server''s identity. This
    answers a fundamental question: W*hen the client talks to a server, how does it
    know the server is actually the server it wanted?* In practice, this is achieved
    using certificates. A certificate is a document that is signed by a certificate
    authority, a trusted provider who is legally allowed to vouch for others. A client
    has a list of trusted CAs, and if the CA which issued a given certificate is on
    that list, a client can trust the server that presents that certificate. In practice,
    there are often a chain of certificates issued as a chain of trust relationships,
    going back to a root CA.'
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, search engines put a heavy emphasis on having HTTPS on websites,
    often ranking them higher in that case. However, issuing a certificate for a website
    has traditionally been a tedious process. A website owner will have to log in
    to a CA's website and provide some form of identification. Issuing the certificate
    often took a few hours and was very costly for small business owners. In 2015,
    Let's Encrypt launched as a non-profit CA with the goal of providing free, short-lived
    certificates to all websites on the internet. They automate the validation process
    by issuing a challenge to the server administrator. This typically involves either
    placing a given file in a known location on the website or creating a DNS record
    with a given content. Once `letsencrypt` has validated the server, it issues a
    certificate valid for 90 days. Thus, the certificate needs to be renewed periodically.
  prefs: []
  type: TYPE_NORMAL
- en: 'More recently, `letsencrypt` standardized the challenge response protocol as
    JSON over HTTPS and named it ACME. Here is how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: The local client generates a private-public keypair and contacts the letsencrypt
    server with the **Public** key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server creates an account for the given key and registers it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on challenge preferences, the **Client** will present a list of challenges
    that can be fulfilled and ask the server to validate the domain. Currently, two
    challenges are supported: an HTTP based challenge where a file is placed on a
    known location and the server will read it to validate, or a DNS based challenge
    where the operator has to create a `TXT` record on the domain with a given content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server generates the challenge and sends it back.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the client will poll the server for confirmation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the server returns an OK, the client can proceed to generating a **certificate
    signing request** (**CSR**) for the server and send it across.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server then generates a certificate and sends it back.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates individual steps in the ACME protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ACME protocol operation
  prefs: []
  type: TYPE_NORMAL
- en: Letsencrypt using Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, there is one crate that allows access to `letsencrypt` using Rust.
    The CLI tool called `acme-client` can interact with the API to obtain or revoke
    a certificate or run validations of ownership. The binary is backed by a crate
    called acme-client that enables programmatic interaction with the API. Let's see
    how this can be used to secure an HTTP server running on Rocket. Remember, for
    this to work, `letsencrypt` will need to reach the server. Thus, this needs to
    be publicly accessible over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to install the CLI tool using Cargo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For our example, we will run our rocket blog over TLS. While Rocket does support
    TLS out of the box, it is not enabled by default. We will need to change the `Cargo.toml`
    file to add TLS as a feature flag. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also run Rocket on the public interface. For this, we will place a
    config file called `Rocket.toml` in the root of the repository. This is how it
    looks; everything else is left at the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Like we did before, we can run our server using Cargo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Letsencrypt also requires all servers to have a domain name. Thus, we will
    need to create a record for our server in a DNS provider. In our example, that
    DNS name is `my.domain.io`, which we will use in subsequent steps. Once that record
    has propagated everywhere, we can move on to the next step: generating certificates.
    Here is how we will do that using the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have to use the DNS based validation here since we will not be able
    to serve back challenges. The CLI asked us to create a `TXT` record with a given
    name and content. Once we create the record, we will need to wait for some time
    so that it can propagate before we move forward. It is a good idea to check if
    the record is updated using `dig` before moving forward. Here is how the output
    of `dig` should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the output from `dig` says that we have the correct `TXT` record, we can
    move ahead with installing the certificate. `letsencrypt` will then query the
    `TXT` record and run domain validation. When everything looks fine, we will get
    a new certificate named `domain.crt`. Let''s inspect the certificate to make sure
    everything looks okay. The subject should match our domain name and the issuer
    should always be *Let''s Encrypt*, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to use this certificate in our Rocket application. We will
    need to place it at a location where the running Rocket has permission to read
    it. Now, if we restart Rocket and use `curl` to access the endpoint over HTTPS,
    it should work exactly like last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As of the time of writing, Let's Encrypt has a limit of five certificates for
    a given domain per week. For testing, it is possible to reach that limit pretty
    quickly. If that happens, the client will just say Acme server error*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a simple client for our server here using `rustls`. We set up
    the project using Cargo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add `rustls` to our project as a dependency :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the client looks; note that the `webpki` crate does DNS resolution,
    which is then used by `rustls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are connecting to our server and running the same HTTP request. We
    import all three required crates. The first step is to initialize a TLS session
    and add the root certificates to it. We then resolve our given server to a DNS
    name reference and establish a TLS session with it. Having set this up, we can
    set up a TCP session by using `connect`. Finally, a `rustls` `Stream` is a combination
    of the SSL session and the TCP session. Once all those are working, we can write
    HTTP queries by hand. Here we are running a `GET` on the `/posts` endpoint. Later,
    we read the response and print it out. The output should be exactly the same as
    using the other clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: OpenSSL using Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenSSL library and CLI is a complete set of tools to work with SSL (and
    TLS) objects. It is an open source project and is widely used by companies all
    around. As one would expect, Rust has bindings for using as a library in Rust
    projects. In this discussion, we will take a closer look at the certificates we
    saw in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are commonly defined by a standard called X.509 (defined in RFC 5280)
    and have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version number**: Almost always set to 2, corresponding to version 3 (since
    the first version is 0). According to the standard, this field can be omitted
    and should be assumed to be version 1 (value set to 0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial number**: A 20 octet identifier that is unique for the CA which signed
    this certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature**: A unique ID that identifies the algorithm used to sign this
    certificate. This is usually a string defined in subsequent RFCs, an example being
    `sha1WithRSAEncryption`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issuer name**: Identifies the CA that signed the certificate. This must have
    at least one **Distinguished name** (**DN**) composed of a number of components,
    including a **Common Name** (**CN**), **State** (**ST**), **Country** (**C**),
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validity**: Defines when the certificate should be valid. This has two sub-fields;
    `notBefore` denotes when this starts to be valid and `notAfter` denotes when it
    expires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subject name**: Identifies the entity this certificate certifies. For a root
    certificate, this will be the same as the issuer. This has the same format as
    the issuer name and should at least have a DN.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subject public key info**: Information about the subject''s encrypted public
    key. This has two sub-fields; the first one is an ID for the encryption algorithm
    (as in the signature field), and the second is a bit stream that has the encrypted
    public key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issuer unique ID**: An optional field that can be used to uniquely identify
    the issuer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subject unique ID**: An optional field that can be used to identify the subject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensions**: This field is only applicable if the version is set to 3\.
    Denotes a number of optional fields that can be used to attach additional information
    to certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificate signature algorithm**: Algorithm used to sign this certificate;
    must be the same as the one used in the signature attribute previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificate signature value**: A bit string that has the actual signature
    for verification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we will use `rust-openssl` to generate and inspect
    a certificate from scratch. Installing the library, however, can be a little complicated.
    Since it is a wrapper around `libopenssl`, it needs to link against the native
    library. Thus, the library has to be installed. The crate''s documentation has
    instructions to get this set up. The project setup is routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, for this example, we will use the master branch of the repository, since
    we need a few features that are not released yet. For that, we will need to specify
    the repository link, as shown previously. Here is the main file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we take in a filename as a command-line parameter to write the certificate
    to. Certificate creation is offloaded to a helper function called `create_cert`
    that returns either a tuple having the generated certificate and private key or
    a list of errors as a `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to initialize a certificate builder object that we will add
    on to, and finally, build our certificate. We use the `set_version` method to
    set the version to 3 (numerically set to `2`). Now we need to generate a serial
    number and set it. We generate that by randomly sampling 160 bits (20 octets of
    8 bits each). We use the `set_serial_number` method to set the serial number.
    The next step is to generate a name by using a name builder. The `append_entry_by_text`
    method is then used to add a country name and a common name to our name builder.
    We use `set_issuer_name` to append the `name` object to the certificate. We set
    the expiry date to 365 days after the current date and use `set_not_before` and
    `set_not_after` to set those two. The subject name is set to the same name object
    using `set_subject_name`. Finally, we need to generate a private key, which we
    generate using the `Rsa` module, and we set the private key on the certificate.
    Now, the certificate needs to be signed with the private key using SHA512\. Once
    done, we can use the `build` method to create the certificate. At the end of the
    function, we return the certificate and private key to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: In our `main` function, we call the `helper` function. For our example, we will
    ignore the key, but a real application does need to save it for verification later.
    We convert the `certificate` object to PEM encoding and write it to a file on
    the disk. The next step is reading the subject name programmatically. For this,
    we use the `subject_name` method on the `certificate` object and print it out
    as a string. This should match the subject name we set earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can run this using Cargo. Note that this creates a certificate
    named `bar.crt` in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Securing tokio applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common problem in implementing Tokio based protocols is around securing them.
    Luckily, the Tokio ecosystem has `tokio-tls` for this. Let''s look at an example
    of using this to secure our hyper example from a previous chapter. Here is our
    setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The Cargo manifest should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to use the `tokio-proto` feature on `tokio-tls` to enable integration
    with `tokio-proto`. The next step is to generate a self-signed certificate for
    our server. `tokio-tls` uses the `native-tls` library underneath, and that does
    not support constructing acceptors from X509 certificates at the time of this
    writing. Thus, we will need to use PKCS12 certificates. The command shown ahead
    generates a self signed certificate, valid for 365 days, in PEM format. This will
    ask for a pass-phrase for the certificate. In our case, we used `foobar`. Please
    ensure that this command is run in the `tokio-tls-example` directory so that our
    code can read the certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command converts the given certificate to PKCS12 format. This
    should generate a file called `cert.pfx` in the current directory, which we will
    use in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our main file, with some changes for enabling SSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The major changes here are that in the main function, we use the `include_bytes`
    macro to read the certificate as raw bytes. We then construct a `Pkcs12` object
    using `from_der` by passing the certificate bytes and the pass-phrase that we
    used while creating the certificate. The next step is to create a `TlsAcceptor`
    object using the given `Pkcs12` `certificate` object. We will then need to wrap
    the `acceptor` object and the `hyper protocol` object into a `Server`. This is
    passed to the `TcpServer` constructor, which we then start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what a session looks like from a client''s perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what the server prints; this originates from the `println!` macro in
    the call function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, the `openssl` command-line tool has a TCP client that can be
    used to test SSL connections as well. Here is how to use it to test our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This tool negotiates an SSL session and dumps the server certificate as shown
    previously (we have replaced the actual certificate for brevity). Notice that
    it correctly detects that the given server is using a self-signed certificate.
    Finally, it starts a TCP session. Since this is bare TCP, we will need to hand
    craft our HTTP requests. If we use a simple `GET` request on `/`, we get back
    a response of `200 OK`, and the string is done. On the other side, this is what
    the server prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this prints the `Host` header, set to the string `foobar`, as we
    wrote on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography using ring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A commonly used crate for cryptography is called `ring`. This crate supports
    a number of lower-level crypto primitives, like random number generation, key
    exchanges, and so on. In this section, we will take key exchange as an example
    and see how this crate can be used in client-server applications.
  prefs: []
  type: TYPE_NORMAL
- en: A common problem in communication is that of encrypting information so that
    a third-party cannot decipher it. In a private key system, both the client and
    the server will need to agree on a key to use for this to work. Now, this key
    cannot be transmitted in plain text over an insecure connection. The Diffie-Hellman
    key exchange method defines a mechanism where two parties talking over a secure
    link can negotiate a key that is shared between them, but has not been transmitted
    over the connection. This method has a number of implementations on many platforms,
    including the crate in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the protocol works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Diffie-Hellman key exchange in action
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, the server will be listening for incoming clients. When a client
    connects, this is the sequence of events:'
  prefs: []
  type: TYPE_NORMAL
- en: A TCP session is first set up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the server and the client generate private and public keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client then sends its public key to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server responds by sending the public key that it generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, both of the parties can generate the shared secret key using
    their private keys and the public key that they received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further communication can be encrypted using the shared secret key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create an empty library project for this example. We will then create
    an example directory and place the two files shown later in there. Project setup
    will go like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, here is what `Cargo.toml` should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the client first. This is heavily borrowed from the simple TCP
    servers we wrote in the second chapter. This is completely synchronous and blocking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We of course need the `ring` crate as an external dependency. The other crate,
    called `untrusted`, is a helper for taking in data from untrusted sources to `ring`
    as input. We then initialize ring's random number generator; this will be used
    to generate keys later. We then generate a private key for the client using the
    `generate` method. The client's public key is generated based on the private key
    using `compute_public_key`. At this point, the client is ready to send the public
    key to the server. It writes the key as a byte stream to the connection created
    earlier. Ideally, the server should send out its public key at this point, which
    the client needs to read off the same connection. This is done by the `read_until`
    call that places the data received in the buffer. The incoming data is then passed
    through the untrusted crate so that `ring` can consume it. Finally, the client-side
    key is generated using `agree_ephemeral`, which takes in the two keys collected
    (the client's private key and the server's public key), an error value, and a
    closure to be used on the generated byte stream. In the closure, we collect all
    the data in a vector and return it. The last step is to print that vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server is similar and looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Like we did last time, we handle each client in a new thread. The semantics
    in the `handle_client` function is similar to that of the client; we start with
    generating a private and a public key. The next step is to read the public key
    that the client sent, followed by sending the public key of the server. Once settled,
    we can then use `agree_ephemeral` to generate the shared secret key, which should
    match the one generated on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample run on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is one on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that the generated key is the same for both the server and the client,
    which is what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the ring crate does not work on the latest nightly.
    To make it work, run these in the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**$ rustup component add rustfmt-preview --toolchain nightly-2017-12-21**`'
  prefs: []
  type: TYPE_NORMAL
- en: '`**$ rustup override set nightly-2017-12-21**`'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a quick look at securing communication over public
    networks. We started with an overview of certificates and how they are used for
    identifying servers on the web. We looked at using `letsencrypt` and `openssl`
    in Rust. We then moved on to securing Tokio applications using the same techniques.
    Finally, we took a quick look at doing key exchanges using the DH method.
  prefs: []
  type: TYPE_NORMAL
- en: The following section is the appendix; there, we will look at some extra crates
    and techniques that are becoming popular in the community.
  prefs: []
  type: TYPE_NORMAL
