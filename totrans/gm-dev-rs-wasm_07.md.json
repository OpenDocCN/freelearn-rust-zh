["```rs\npub struct Image {\n    element: HtmlImageElement,\n    position: Point,\n}\nimpl Image {\n    pub fn new(element: HtmlImageElement, position: \n        Point) -> Self {\n        Self { element, position }\n    }\n}\n```", "```rs\nimpl Renderer {\n    ...\n    pub fn draw_entire_image(&self, image: \n        &HtmlImageElement, position: &Point) \n            self.context\n            .draw_image_with_html_image_element(image, \n                position.x.into(), position.y.into())\n            .expect(\"Drawing is throwing exceptions! \n                Unrecoverable error.\");\n    }\n}\n```", "```rs\n    impl HtmlImageElement {\n        ...\n        pub fn draw(&self, renderer: &Renderer) {\n            renderer.draw_entire_image\n                (&self.element,&self.position)\n        }\n    }\n    ```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn \n        Game>> {\n        match self {\n            WalkTheDog::Loading => {\n                let sheet = browser::fetch_json\n                    (\"rhb.json\").await?.into_serde()?;\n                let background = engine::\n                    load_image(\"BG.png\").await?;\n                ....\n```", "```rs\n    pub enum WalkTheDog {\n        Loading,\n        Loaded(Walk),\n    }\n    ```", "```rs\n    pub struct Walk {\n        boy: RedHatBoy,\n        background: Image,\n    }\n    ```", "```rs\n    impl Game for WalkTheDog {\n        async fn initialize(&mut self) -> Result<Box<dyn \n             Game>> {\n            ...\n            Ok(Box::new(WalkTheDog::Loaded(Walk {\n                boy: rhb,\n                background: Image::new(background, Point {                 \n                    x: 0, y: 0 }),\n            })))\n        }\n        ...\n    }\n    ```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            if keystate.is_pressed(\"ArrowRight\") {\n                walk.boy.run_right();\n            }\n            ...\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn draw(&self, renderer: &Renderer) {\n        if let WalkTheDog::Loaded(walk) = self {\n             walk.boy.draw(renderer);\n        }\n        ...\n```", "```rs\n    impl Game for WalkTheDog {\n        ...\n        fn draw(&self, renderer: &Renderer) {\n            if let WalkTheDog::Loaded(walk) = self {\n                 walk.background.draw(renderer);\n                 walk.boy.draw(renderer);\n            }\n            ...\n    ```", "```rs\n    struct Walk {\n        boy: RedHatBoy,\n        background: Image,\n        stone: Image,\n    }\n    ```", "```rs\n    impl Game for WalkTheDog {\n        async fn initialize(&mut self) -> Result<Box<dyn \n            Game>> {\n            ...\n            match self {\n                WalkTheDog::Loading => {\n                    ...\n                    let background = engine::load_image\n                        (\"BG.png\").await?;\n                    let stone = engine::\n                        load_image(\"Stone.png\").await?;\n                    ...\n    ```", "```rs\n    impl Game for WalkTheDog {\n        async fn initialize(&mut self) -> Result<Box<dyn \n            Game>> {\n            ....\n            Ok(Box::new(WalkTheDog::Loaded(Walk {\n                boy: rhb,\n                background: Image::new(background, Point { \n                    x: 0, y: 0 }),\n                stone: Image::new(stone, Point { x: 150, \n                    y: 546 }),\n            })))\n    ```", "```rs\n    impl Game for WalkTheDog {\n        ...\n        fn draw(&self, renderer: &Renderer) {\n            if let WalkTheDog::Loaded(walk) = self {\n                walk.background.draw(renderer);\n                walk.boy.draw(renderer);\n                walk.stone.draw(renderer);\n            }\n    ```", "```rs\nif (box_one.x < box_two.right) &&\n    (box_one.right > box_two.x) {\n        log!(\"Collision!\");\n    }\n```", "```rs\nif (box_one.x < box_two.right) &&\n    (box_one.right > box_two.x) &&\n    (box_one.y < box_two.bottom) &&\n    (box_one.bottom > box_two.y) {\n        log!(\"Collision!\");\n    }\n```", "```rs\n\"Idle (1).png\":\n{\n    \"frame\": {\"x\":117,\"y\":122,\"w\":71,\"h\":115},\n    \"rotated\": false,\n    \"trimmed\": true,\n    \"spriteSourceSize\": {\"x\":58,\"y\":8,\"w\":71,\"h\":115},\n    \"sourceSize\": {\"w\":160,\"h\":136}\n},\n\"Idle (2).png\":\n{\n    \"frame\": {\"x\":234,\"y\":122,\"w\":71,\"h\":115},\n    \"rotated\": false,\n    \"trimmed\": true,\n    \"spriteSourceSize\": {\"x\":58,\"y\":8,\"w\":71,\"h\":115},\n    \"sourceSize\": {\"w\":160,\"h\":136}\n},\n```", "```rs\n#[derive(Deserialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct Cell {\n    pub frame: SheetRect,\n    pub sprite_source_size: SheetRect,\n}\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn draw(&self, renderer: &Renderer) {\n        ...\n        renderer.draw_image(\n        &self.image,\n        &Rect {\n                x: sprite.frame.x.into(),\n                y: sprite.frame.y.into(),\n                width: sprite.frame.w.into(),\n                height: sprite.frame.h.into(),\n            },\n        &Rect {\n                x: (self.state_machine.context().position.x \n                    + sprite.sprite_source_size.x as i16)\n                    .into(),\n                y: (self.state_machine.context().position.y \n                    + sprite.sprite_source_size.y as i16)\n                    .into(),\n                width: sprite.frame.w.into(),\n                height: sprite.frame.h.into(),\n            },\n        );\n    }\n```", "```rs\nconst FLOOR: i16 = 479;\nconst STARTING_POINT: i16 = -20;\n```", "```rs\nimpl RedHatBoyState<Idle> {\n    fn new() -> Self {\n        RedHatBoyState {\n            context: RedHatBoyContext {\n                frame: 0,\n                position: Point {\n                    x: STARTING_POINT,\n                    y: FLOOR,\n                },\n                velocity: Point { x: 0, y: 0 },\n            },\n            _state: Idle {},\n        }\n    }\n}\n```", "```rs\npub struct Image {\n    element: HtmlImageElement,\n    position: Point,\n    bounding_box: Rect,\n}\nimpl Image {\n    pub fn new(element: HtmlImageElement, position: Point) -> Self {\n        let bounding_box = Rect {\n            x: position.x.into(),\n            y: position.y.into(),\n            width: element.width() as f32,\n            height: element.height() as f32,\n        };\n        Self {\n            element,\n            position,\n            bounding_box,\n        }\n    }\n    ....\n}\n```", "```rs\nimpl Image {\n    ...\n    pub fn bounding_box(&self) ->&Rect {\n        &self.bounding_box\n    }\n}\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn bounding_box(&self) ->Rect {\n        let frame_name = format!(\n            \"{} ({}).png\",\n            self.state_machine.frame_name(),\n            (self.state_machine.context().frame / 3) + 1\n        );\n        let sprite = self\n            .sprite_sheet\n            .frames\n            .get(&frame_name)\n            .expect(\"Cell not found\");\n        Rect {\n            x: (self.state_machine.context().position.x + \n                sprite.sprite_source_size.x as i16).into(),\n            y: (self.state_machine.context().position.y + \n                sprite.sprite_source_size.y as i16).into(),\n            width: sprite.frame.w.into(),\n            height: sprite.frame.h.into(),\n        }\n    }\n    ...\n}\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn frame_name(&self) -> String {\n        format!(\n            \"{} ({}).png\",\n            self.state_machine.frame_name(),\n            (self.state_machine.context().frame / 3) + 1\n        )\n    }\n    fn current_sprite(&self) -> Option<&Cell> {\n        self.sprite_sheet.frames.get(&self.frame_name())\n    }\n    ...\n}\n```", "```rs\nimpl RedHatBoy {\n    …\n    fn bounding_box(&self) ->Rect {\n        let sprite = self.current_sprite().expect(\"Cell not\n            found\");\n        Rect {\n            x: (self.state_machine.context().position.x + \n                sprite.sprite_source_size.x as i16).into(),\n            y: (self.state_machine.context().position.y + \n                sprite.sprite_source_size.y as i16).into(),\n            width: sprite.frame.w.into(),\n            height: sprite.frame.h.into(),\n        }\n    }\n    ...\n}\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn draw(&self, renderer: &Renderer) {\n        let sprite = self.current_sprite().expect(\"Cell not \n            found\");\n        renderer.draw_image(\n        &self.image,\n        &Rect {\n                x: sprite.frame.x.into(),\n                y: sprite.frame.y.into(),\n                width: sprite.frame.w.into(),\n                height: sprite.frame.h.into(),\n            },\n            &self.bounding_box(),\n        );\n    }\n    ...\n}\n```", "```rs\nimpl Rect {\n    pub fn intersects(&self, rect: &Rect) -> bool {\n        self.x < (rect.x + rect.width)\n        && self.x + self.width > rect.x\n        && self.y < (rect.y + rect.height)\n        && self.y + self.height > rect.y\n    }\n}\n```", "```rs\nimpl WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n           walk.boy.update();\n            if walk\n                .boy\n                .bounding_box()\n                .intersects(walk.stone.bounding_box())\n            {\n                walk.boy.knock_out();\n            }\n        }\n    }\n}\n```", "```rs\npub enum Event {\n    Run,\n    Jump,\n    Slide,\n    KnockOut,\n    Update,\n}\n...\nimpl RedHatBoy {\n    ...\n    fn knock_out(&mut self) {\n        self.state_machine = \n            self.state_machine.transition(Event::KnockOut);\n}\n    ...\n```", "```rs\nimpl RedHatBoyStateMachine {\n    fn transition(self, event: Event) -> Self {\n        match (self, event) {\n            ...\n            (RedHatBoyStateMachine::Running(state), \n                Event::KnockOut) => state.knock_out\n                    ().into(),\n            (RedHatBoyStateMachine::Jumping(state), \n                Event::KnockOut) =>   \n                    state.knock_out().into(),\n            (RedHatBoyStateMachine::Sliding(state), \n                Event::KnockOut) =>   \n                    state.knock_out().into(),\n            _ => self,\n        }\n    }\n    ...\n```", "```rs\nconst FALLING_FRAMES: u8 = 29; // 10 'Dead' frames in the sheet, * 3 - 1.\nconst FALLING_FRAME_NAME: &str = \"Dead\";\n```", "```rs\nimpl RedHatBoyState<Running> {\n    pub fn knock_out(self) -> RedHatBoyState<Falling> {\n        RedHatBoyState {\n                context: self.context,\n                _state: Falling {},\n        }\n    }\n    ...\n```", "```rs\nimpl RedHatBoyState<Running> {\n    pub fn knock_out(self) -> RedHatBoyState<Falling> {\n        RedHatBoyState {\n                context: self.context.reset_frame().stop(),\n                _state: Falling {},\n        }\n    }\n    ...\n```", "```rs\nimpl RedHatBoyContext {\n      fn stop(mut self) -> Self {\n          self.velocity.x = 0;\n              self\n        }\n    }\n...\n```", "```rs\nimpl RedHatBoyState<Sliding> {\n    ...\n    pub fn update(mut self) -> SlidingEndState {\n        self.update_context(SLIDING_FRAMES);\n        if self.context.frame >= SLIDING_FRAMES {\n            SlidingEndState::Running(self.stand())\n        } else {\n            SlidingEndState::Sliding(self)\n        }\n    }\n}\n```", "```rs\nstruct Platform {\n    sheet: Sheet,\n    image: HtmlImageElement,\n    position: Point,\n}\nimpl Platform {\n    fn new(sheet: Sheet, image: HtmlImageElement, position:         Point) -> Self {\n        Platform {\n            sheet,\n            image,\n            position,\n        }\n    }\n}\n```", "```rs\nimpl Platform {\n    ...\nfn draw(&self, renderer: &Renderer) {\n        let platform = self\n            .sheet\n            .frames\n            .get(\"13.png\")\n            .expect(\"13.png does not exist\");\n        renderer.draw_image(\n        &self.image,\n        &Rect {\n                x: platform.frame.x.into(),\n                y: platform.frame.y.into(),\n                width: (platform.frame.w * 3).into(),\n                height: platform.frame.h.into(),\n            },\n            &Rect {\n                x: self.position.x.into(),\n                y: self.position.y.into(),\n                width: (platform.frame.w * 3).into(),\n                height: platform.frame.h.into(),\n            },\n        );\n}\n```", "```rs\nimpl Platform {\n    ...\n    fn bounding_box(&self) ->Rect {\n        let platform = self\n            .sheet\n            .frames\n            .get(\"13.png\")\n            .expect(\"13.png does not exist\");\n        Rect {\n            x: self.position.x.into(),\n            y: self.position.y.into(),\n            width: (platform.frame.w * 3).into(),\n            height: platform.frame.h.into(),\n        }\n    }\n    fn draw(&self, renderer: &Renderer) {\n        ...\n        renderer.draw_image(\n            &self.image,\n            &Rect {\n                x: platform.frame.x.into(),\n                y: platform.frame.y.into(),\n                width: (platform.frame.w * 3).into(),\n                height: platform.frame.h.into(),\n            },\n            &self.bounding_box(),\n        );\n    }\n```", "```rs\nstruct Walk {\n    boy: RedHatBoy,\n    background: Image,\n    stone: Image,\n    platform: Platform,\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn Game>> {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                let stone = engine::\n                   load_image(\"Stone.png\").await?;\n                let platform_sheet = browser::\n                    fetch_json(\"tiles.json\").await?;\n                let platform = Platform::new(\n                    platform_sheet.into_serde::<Sheet>()?,\n                    engine::load_image(\"tiles.png\").await?,\n                    Point { x: 200, y: 400 },\n                );\n                ...\n                Ok(Box::new(WalkTheDog::Loaded(Walk {\n                    boy: rhb,\n                    background: Image::new(background,\n                        Point { x: 0, y: 0 }),\n                    stone: Image::new(stone, Point { x: \n                        150, y: 546 }),\n                    platform,\n                })))\n                ...\n```", "```rs\nfndraw(&self, renderer: &Renderer) {\n    ...\n    if let WalkTheDog::Loaded(walk) = self {\n        walk.background.draw(renderer);\n        walk.boy.draw(renderer);\n        walk.stone.draw(renderer);\n        walk.platform.draw(renderer);\n    }\n}\n```", "```rs\nfn update(&mut self, keystate: &KeyState) {\n    if let WalkTheDog::Loaded(walk) = self {\n        ...\n        walk.boy.update();\n        if walk\n            .boy\n            .bounding_box()\n            .intersects(&walk.platform.bounding_box())\n        {\n            walk.boy.land();\n        }\n        if walk\n            .boy\n            .bounding_box()\n            .intersects(walk.stone.bounding_box())\n        {\n            walk.boy.knock_out()\n        }\n        ...\n    }\n}\n```", "```rs\nimpl RedHatBoyStateMachine {\n    fn transition(self, event: Event) -> Self {\n        match (self, event) {\n            (RedHatBoyStateMachine::Jumping(state), Event::Land) => {\n                state.land().into()\n            }\n            ...\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        ...\n        if walk\n            .boy\n            .bounding_box()\n            .intersects(&walk.platform.bounding_box())\n        {\n            walk.boy.land_on(walk.platform.bounding_box().y);\n        }\n    }\n    ...\n}\n```", "```rs\nimpl RedHatBoyState<Jumping> {\n    ...\n    pub fn land_on(mut self, position: f32) -> \n        RedHatBoyState<Running> {\n            self.context.position.y = position as i16;\n            RedHatBoyState {\n                context: self.context.reset_frame(),\n                _state: Running,\n        }\n    }\n```", "```rs\nimpl RedHatBoyState<Jumping>{\n    ...\n    fn land_on(mut self, position: f32, height: f32) {\n        let position = (position - height) as i16;\n        RedHatBoyState {\n            context: self.context.reset_frame(),\n            _state: Running,\n        }\n    }\n}\n```", "```rs\nmod red_hat_boy_states {\nuse super::HEIGHT;\n  ...\n    const FLOOR: i16 = 479;\n    const PLAYER_HEIGHT: i16 = HEIGHT - FLOOR;\n```", "```rs\nimpl RedHatBoyContext {\n    ...\n    fn set_on(mut self, position: i16) -> Self {\n        let position = position - PLAYER_HEIGHT;\n        self.position.y = position;\n        self\n    }\n}\n...\nimpl RedHatBoyState<Jumping> {\n    pub fn land_on(self, position: f32) ->         RedHatBoyState<Running> {\n        RedHatBoyState {\n            context: self.context.reset_frame()\n            .set_on(position as i16),\n            _state: Running,\n          }\n     }\n...\n```", "```rs\n    impl RedHatBoyState<Jumping> {\n        pub fn update(mut self) -> JumpingEndState {\n            self.update_context(JUMPING_FRAMES);\n            if self.context.position.y >= FLOOR {\n                JumpingEndState::Landing(self.land_on\n                    (HEIGHT.into()))\n            } else {\n                JumpingEndState::Jumping(self)\n            }\n        }\n```", "```rs\nimpl RedHatBoyStateMachine {\n    fn transition(self, event: Event) -> Self {\n        match (self, event) {\n            ...\n            (RedHatBoyStateMachine::Running(state), Event::\n                Land(position)) => {\n                state.land_on(position).into()\n            }\n```", "```rs\n...\nimpl RedHatBoyState<Running> {\n    ...\n    pub fn land_on(self, position: f32) -> \n        RedHatBoyState<Running> {\n        RedHatBoyState {\n            context: self.context.set_on(position as   \n                i16),\n            _state: Running {},\n        }\n    }\n}\n```", "```rs\nmod red_hat_boy_states {\n    ...\n    const TERMINAL_VELOCITY: i16 = 20;\n    ...\n    impl RedHatBoyContext {\n        pub fn update(mut self, frame_count: u8) -> Self {\n            if self.velocity.y < TERMINAL_VELOCITY {\n                self.velocity.y += GRAVITY;\n            }\n           ...\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n            walk.boy.update();\n            if walk\n                .boy\n                .bounding_box()\n                .intersects(&walk.platform.bounding_box())\n            {\n                if walk.boy.velocity_y() > 0 && walk.boy.pos_y() < walk.platform.position.y {\n                    walk.boy.land_on(walk.platform.bounding_box().y);\n                } else {\n                    walk.boy.knock_out();\n                }\n            }\n            ...\n        }\n    }\n}\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn pos_y(&self) -> i16 {\n        self.state_machine.context().position.y\n    }\n    fn velocity_y(&self) -> i16 {\n        self.state_machine.context().velocity.y\n    }\n    ...\n}\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn bounding_box(&self) -> Rect {\n        const X_OFFSET: f32 = 18.0;\n        const Y_OFFSET: f32 = 14.0;\n        const WIDTH_OFFSET: f32 = 28.0;\n        let mut bounding_box = self.destination_box();\n        bounding_box.x += X_OFFSET;\n        bounding_box.width -= WIDTH_OFFSET;\n        bounding_box.y += Y_OFFSET;\n        bounding_box.height -= Y_OFFSET;\n        bounding_box\n    }\n```", "```rs\nimpl Platform {\n    fn bounding_boxes(&self) -> Vec<Rect> {\n        const X_OFFSET: f32 = 60.0;\n        const END_HEIGHT: f32 = 54.0;\n        let destination_box = self.destination_box();\n        let bounding_box_one = Rect {\n            x: destination_box.x,\n            y: destination_box.y,\n            width: X_OFFSET,\n            height: END_HEIGHT,\n        };\n        let bounding_box_two = Rect {\n            x: destination_box.x + X_OFFSET,\n            y: destination_box.y,\n            width: destination_box.width - (X_OFFSET * \n                2.0),\n            height: destination_box.height,\n        };\n        let bounding_box_three = Rect {\n            x: destination_box.x + destination_box.width – \n                X_OFFSET,\n            y: destination_box.y,\n            width: X_OFFSET,\n            height: END_HEIGHT,\n        };\n        vec![bounding_box_one, bounding_box_two,  \n            bounding_box_three]\n    }\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        ...\n        for bounding_box in &walk.platform.bounding_boxes() {\n            if walk.boy.bounding_box()\n                .intersects(bounding_box) {\n                if walk.boy.velocity_y() > 0 && \n                    walk.boy.pos_y() < \n                        walk.platform.position.y {\n                    walk.boy.land_on(bounding_box.y);\n                    } else {\n                        walk.boy.knock_out();\n                    }\n                }\n            }\n           ...\n        }\n    }\n```", "```rs\nconst LOW_PLATFORM: i16 = 420;\nconst HIGH_PLATFORM: i16 = 375;\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                let platform = Platform::new(\n                    platform_sheet.into_serde::<Sheet>()?,\n                    engine::load_image(\"tiles.png\").await?,\n                    Point {\n                        x: 370,\n                        y: LOW_PLATFORM,\n                    },\n                );\n```"]