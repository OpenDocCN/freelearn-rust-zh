["```rs\nclass Door {\n    private bool is_open = false;\n\n    public void Open() {\n        this.is_open = true;\n    }\n}\n```", "```rs\nstruct Door {\n    is_open: bool\n}\n\nimpl Door {\n    fn new(is_open: bool) -> Door {\n        Door { is_open: is_open }\n    }\n}\n\ntrait Openable {\n    fn open(&mut self);\n}\n\nimpl Openable for Door {\n    fn open(&mut self) {\n        self.is_open = true;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn open_door() {\n        let mut door = Door::new(false);\n        door.open();\n        assert!(door.is_open);\n    }\n}\n```", "```rs\nfn find(needle: u16, haystack: Vec<u16>) -> Option<usize> {\n    // find the needle in the haystack\n}\n\nfn read_file(path: &str) -> Result<String, io::Error> {\n    // open the path as a file and read it\n}\n```", "```rs\nmatch find(2, vec![1,3,4,5]) {\n    Some(_) => println!(\"Found!\"),\n    None => println!(\"Not found :(\")\n}\n\n// another way\nif let Some(result) = find(2, vec![1,2,3,4]) {\n    println!(\"Found!\")\n}\n\n// similarly for results!\nmatch read_file(\"/tmp/not/a/file\") {\n    Ok(content) => println!(content),\n    Err(error) => println!(\"Oh no!\")\n}\n```", "```rs\n#[macro_export] \nmacro_rules! vec {\n     ( $( $x:expr ),* ) => {\n         {             \n            let mut temp_vec = Vec::new();              \n             $( temp_vec.push($x); )*      \n            temp_vec\n         }     \n    }; \n}\n```", "```rs\n#[derive(Debug)]\nstruct FileName {\n    name: Rc<String>,\n    ext: Rc<String>\n}\n```", "```rs\nfn my_func() {\n    // the compiler allocates memory for x \n    let x = LargeObject::new(); \n    x.do_some_computation();\n    // allocate memory for y\n    let y = call_another_func();\n    if y > 10 {\n        do_more_things();\n    }\n} // deallocate (drop) x, y\n```", "```rs\nfn my_function() {\n    let x = 10;\n    do_something(x); // ownership is moved here\n    let y = x;       // x is now invalid!\n}\n```", "```rs\nfn my_function() {\n    let x = 10;\n    do_something(&x); // pass a reference to x\n    let y = x;        // x is still valid!\n}\n```", "```rs\nfn another_function(mut passing_through: MyStruct) -> MyStruct {\n    let x = vec![1, 2, 3];\n\n    // passing_through cannot hold a reference \n    // to a shorter lived x!\n    // the compiler will complain.\n    passing_through.x = &x;\n\n    return passing_through;\n} // x's life ends here\n```", "```rs\nfn another_function(mut passing_through: MyStruct) -> MyStruct {\n    let x = vec![1, 2, 3];\n\n    // passing_through owns x and it will be\n    // dropped together with passing_through.\n    passing_through.x = x; \n\n    return passing_through;\n}\n```", "```rs\nfn another_function(mut passing_through: MyStruct) -> MyStruct {\n    let x = vec![1, 2, 3];\n    let y = &x;\n\n    // passing_through owns a deep copy of x'value that is be\n    // dropped together with passing_through.\n    passing_through.x = y.clone(); \n\n    return passing_through;\n}\n```", "```rs\nfn another_function<'a>(mut passing_through: MyStruct<'a>, x: &'a Vec<u32>) -> MyStruct<'a> {\n\n    // The compiler knows and expects a lifetime that is \n    // at least as long as the struct's \n    // of any reference passed in as x. \n    passing_through.x = x; \n\n    return passing_through;\n}\n```", "```rs\nfn main() {     \n    let mut a = 42;     \n    let b = &a; // borrow a     \n    let c = &mut a; // borrow a again, mutably         \n    // ... but don't ever use b\n}\n```", "```rs\n#[derive(Debug)]\nstruct FileName {\n    name: String,\n    ext: String \n}\n\nfn no_ref_counter() {\n    let name = String::from(\"main\");\n    let ext = String::from(\"rs\");\n\n    for _ in 0..3 {\n        println!(\"{;?}\", FileName {\n                    name: name, \n                    ext: ext \n        });\n    }\n}\n```", "```rs\nerror[E0382]: use of moved value: `name`\n --> src/main.rs:63:33\n |\n63 | let _ = FileName { name: name, ext: ext };\n |                            ^^^^ value moved here in previous iteration of loop\n |\n = note: move occurs because `name` has type `std::string::String`, which does not implement the `Copy` trait\n\nerror[E0382]: use of moved value: `ext`\n --> src/main.rs:63:44\n |\n63 | let _ = FileName { name: name, ext: ext };\n |                                       ^^^ value moved here in previous iteration of loop\n |\n = note: move occurs because `ext` has type `std::string::String`, which does not implement the `Copy` trait\n```", "```rs\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct FileName {\n    name: Rc<String>,\n    ext: Rc<String> \n}\n\nfn ref_counter() {\n    let name = Rc::new(String::from(\"main\"));\n    let ext = Rc::new(String::from(\"rs\")));\n\n    for _ in 0..3 {\n        println!(\"{;?}\", FileName {\n                    name: name.clone(), \n                    ext: ext.clone() \n        });\n    }\n}\n```", "```rs\nFileName { name: \"main\", ext: \"rs\" }\nFileName { name: \"main\", ext: \"rs\" }\nFileName { name: \"main\", ext: \"rs\" }\n```", "```rs\nuse std::thread; \n\nfn threading() { \n    // The to pipes (||) is the space where parameters go,\n    // akin to a function signature's parameters, without\n    // the need to always declare types explicitly. \n    // This way, variables can move from the outer into the inner scope\n    let handle = thread::spawn(|| { \n        println!(\"Hello from a thread\");\n    }); \n    handle.join().unwrap(); \n}\n```", "```rs\nfn sanitize(s: String) -> String {\n    let s = s.trim();\n    let s = s.replace(\" \", \"_\");\n    s\n} \n```", "```rs\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Clone)]\nstruct Node {\n    value: String,\n    next: Link,\n    prev: Link,\n}\n\ntype Link = Option<Rc<RefCell<Node>>>;\n```", "```rs\npub fn append(&mut self, value: String) {\n    let new = Rc::new(RefCell::new(Node::new(value)));\n    match self.tail.take() {\n        Some(old) => {\n            old.borrow_mut().next = Some(new.clone());\n            new.borrow_mut().prev = Some(old);\n        }\n        None => self.head = Some(new.clone()),\n    };\n}\n```", "```rs\nuse std::thread; \n\nfn threading() { \n    let x = 10;\n    let handle = thread::spawn(|| { \n        println!(\"Hello from a thread, the number is {}\", x);\n    }); \n    handle.join().unwrap(); \n}\n```", "```rs\nCompiling ch1 v0.1.0 (file:///code/ch1) \nerror[E0373]: closure may outlive the current function, but it borrows `x`, which is owned by the current function \n --> src/main.rs:5:32 \n | \n5 |     let handle = thread::spawn(|| { \n |                                ^^ may outlive borrowed value `x` \n6 |         println!(\"Hello from a thread, the number is {}\", x); \n |                                                           - `x` is borrowed here \nhelp: to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword \n | \n5 |     let handle = thread::spawn(move || { \n |                                ^^^^^^^\n```", "```rs\nfn threading() { \n    let x = 10;\n    let handle = thread::spawn(move || {\n        println!(\"Hello from a thread, the number is {}\", x);\n    }); \n    handle.join().unwrap(); \n} \n```", "```rs\nHello from a thread, the number is 10\n```", "```rs\nuse std::sync::mpsc::{channel, Sender, Receiver};\n\nfn channels() {\n    const N: i32 = 10;\n    let (tx, rx): (Sender<i32>, Receiver<i32>) = channel();\n    let handles = (0..N).map(|i| {\n        let _tx = tx.clone();\n        thread::spawn(move || { \n            // don't use the result\n            let _ = _tx.send(i).unwrap(); \n        })\n    });\n    // close all threads\n    for h in handles {\n        h.join().unwrap();\n    }\n    // receive N times\n    let numbers: Vec<i32> = (0..N).map(|_|\n            rx.recv().unwrap()\n        ).collect();\n\n    println!(\"{:?}\", numbers);\n}\n```", "```rs\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```", "```rs\nuse std::thread;\nuse std::sync::{Mutex, Arc};\n\nfn shared_state() {\n    let v = Arc::new(Mutex::new(vec![]));\n    let handles = (0..10).map(|i| {\n        let numbers = Arc::clone(&v);\n        thread::spawn(move || {\n            let mut vector = numbers\n                .lock()\n                .unwrap();\n            (*vector).push(i);\n        })\n    });\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"{:?}\", *v.lock().unwrap());\n}\n```", "```rs\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \n```"]