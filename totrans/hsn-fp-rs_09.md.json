["```rs\ncargo build\n```", "```rs\ncargo build --release\n```", "```rs\n$ time performance_release_mode\nreal 0m13.424s\nuser 0m13.406s\nsys 0m0.010s\n```", "```rs\n$ time ./performance_release_mode\nreal 0m0.316s\nuser 0m0.309s\nsys 0m0.005s\n```", "```rs\nextern crate flame;\nuse std::fs::File;\n\nfn main() {\n   let v: Vec<u64> = vec![2; 1000000];\n\n   flame::start(\"Iterator .collect\");\n   let mut _z = vec![];\n   for _ in 0..1000 {\n      _z = v.iter().map(|x| x*x).collect::<Vec<u64>>();\n   }\n   flame::end(\"Iterator .collect\");\n\n   flame::start(\"Iterator iterate\");\n   for _ in 0..1000 {\n      v.iter().map(|x| x * x).for_each(drop);\n   }\n   flame::end(\"Iterator iterate\");\n\n   flame::dump_html(&mut File::create(\"flame-graph.html\").unwrap()).unwrap();\n}\n```", "```rs\nuse std::mem::forget;\n\nfn main() {\n   for _ in 0..10000 {\n      let mut a = vec![2; 10000000];\n      a[2] = 2;\n      forget(a);\n   }\n}\n\n```", "```rs\nuse std::{thread,time};\n\nfn initialization() {\n   let t = time::Duration::from_millis(15000);\n   thread::sleep(t);\n}\n\nfn work() {\n   let t = time::Duration::from_millis(15000);\n   loop {\n      thread::sleep(t);\n      println!(\"Work.\");\n   }\n}\n\nfn main() {\n   initialization();\n   println!(\"Done initializing, start work.\");\n   work();\n}\n```", "```rs\nuse std::{thread,time};\n\nfn initialization() -> Vec<i32> {\n   let t = time::Duration::from_millis(15000);\n   thread::sleep(t);\n   println!(\"Initialize data.\");\n   vec![1, 2, 3];\n}\n\nfn work(x: i32) -> i32 {\n   let t = time::Duration::from_millis(150);\n   thread::sleep(t);\n   println!(\"Work.\");\n   x * x\n}\n\nfn main() {\n   for _ in 0..10 {\n      let data = initialization();\n      data.iter().map(|x| work(*x)).for_each(drop);\n   }\n}\n```", "```rs\nextern crate flame;\nuse std::fs::File;\nuse std::{thread,time};\n\nfn a() {\n   flame::start(\"fn a\");\n   let t = time::Duration::from_millis(1000);\n   thread::sleep(t);\n   b();\n   b();\n   b();\n   flame::end(\"fn a\");\n}\n```", "```rs\nfn b() {\n   flame::start(\"fn b\");\n   let t = time::Duration::from_millis(1000);\n   thread::sleep(t);\n   c();\n   c();\n   c();\n   flame::end(\"fn b\");\n}\n```", "```rs\nfn c() {\n   flame::start(\"fn c\");\n   let t = time::Duration::from_millis(1000);\n   thread::sleep(t);\n   flame::end(\"fn c\");\n}\n```", "```rs\nfn main() {\n   flame::start(\"fn main\");\n   let t = time::Duration::from_millis(1000);\n   thread::sleep(t);\n   a();\n   a();\n   a();\n   flame::end(\"fn main\");\n   flame::dump_html(&mut File::create(\"flame-graph.html\").unwrap()).unwrap();\n}\n```", "```rs\nfn a(n: u64) -> u64 {\n   if n>0 {\n      b(n);\n      b(n);\n   }\n   n * n\n}\n\nfn b(n: u64) -> u64 {\n   c(n);\n   c(n);\n   n + 2 / 3\n}\n\nfn c(n: u64) -> u64 {\n   a(n-1);\n   a(n-1);\n   vec![1, 2, 3].into_iter().map(|x| x+2).sum()\n}\n\nfn main() {\n   a(6);\n}\n```", "```rs\n$ cargo profiler callgrind --bin ./target/debug/performance_profiling4 -n 10\n\n```", "```rs\nProfiling performance_profiling4 with callgrind...\n\nTotal Instructions...344,529,557\n\n27,262,872 (7.9%) ???:core::iter::iterator::Iterator\n----------------------------------------------------------\n22,319,604 (6.5%) ???:<alloc::vec\n----------------------------------------------------------\n16,627,356 (4.8%) ???:<core::iter\n----------------------------------------------------------\n13,182,048 (3.8%) ???:<alloc::vec\n----------------------------------------------------------\n10,785,312 (3.1%) ???:core::iter::iterator::Iterator::fold\n----------------------------------------------------------\n10,485,720 (3.0%) ???:core::mem\n----------------------------------------------------------\n8,088,984 (2.3%) ???:alloc::slice::hack\n----------------------------------------------------------\n7,639,596 (2.2%) ???:core::ptr\n----------------------------------------------------------\n7,190,208 (2.1%) ???:core::ptr\n----------------------------------------------------------\n7,190,016 (2.1%) ???:performance_profiling4\n```", "```rs\nfn allocate() -> [u64; 1000] {\n   [22; 1000]\n}\n\nfn flop(x: f64, y: f64) -> f64 {\n   x * y\n}\n\nfn lookup(x: &[u64; 1000]) -> u64 {\n   x[234] * x[345]\n}\n\nfn main() {\n   let mut data = allocate();\n   for _ in 0..1000 {\n      //constant size memory allocation\n      data = allocate();\n   }\n\n   for _ in 0..1000000 {\n      //reference data\n      lookup(&data);\n   }\n\n   for _ in 0..1000000 {\n      //floating point operation\n      flop(2.0, 3.0);\n   }\n}\n```", "```rs\nProfiling performance_constant with callgrind...\n\nTotal Instructions...896,049,080\n\n217,133,740 (24.2%) ???:_platform_memmove$VARIANT$Haswell\n-----------------------------------------------------------\n108,054,000 (12.1%) ???:core::ptr\n-----------------------------------------------------------\n102,051,069 (11.4%) ???:core::iter::range\n-----------------------------------------------------------\n76,038,000 (8.5%) ???:<i32\n-----------------------------------------------------------\n56,028,000 (6.3%) ???:core::ptr\n-----------------------------------------------------------\n46,023,000 (5.1%) ???:core::iter::range::ptr_try_from_impls\n-----------------------------------------------------------\n45,027,072 (5.0%) ???:performance_constant\n-----------------------------------------------------------\n44,022,000 (4.9%) ???:core::ptr\n-----------------------------------------------------------\n40,020,000 (4.5%) ???:core::mem\n-----------------------------------------------------------\n30,015,045 (3.3%) ???:core::cmp::impls\n```", "```rs\nextern crate rand;\nextern crate flame;\nuse std::fs::File;\n\nfn main() {\n   let mut data = vec![0; 1000];\n   for di in 0..data.len() {\n      data[di] = rand::random::<u64>();\n   }\n\n   flame::start(\"sort n=1000\");\n   data.sort();\n   flame::end(\"sort n=1000\");\n\n   flame::start(\"binary search n=1000 100 times\");\n   for _ in 0..100 {\n      let c = rand::random::<u64>();\n      data.binary_search(&c).ok();\n   }\n   flame::end(\"binary search n=1000 100 times\");\n```", "```rs\n   let mut data = vec![0; 10000];\n   for di in 0..data.len() {\n      data[di] = rand::random::<u64>();\n   }\n\n   flame::start(\"sort n=10000\");\n   data.sort();\n   flame::end(\"sort n=10000\");\n\n   flame::start(\"binary search n=10000 100 times\");\n   for _ in 0..100 {\n      let c = rand::random::<u64>();\n      data.binary_search(&c).ok();\n   }\n   flame::end(\"binary search n=10000 100 times\");\n\n   flame::dump_html(&mut File::create(\"flame-graph.html\").unwrap()).unwrap();\n}\n```", "```rs\nfn main() {\n   for _ in 0..1000 {\n      //O(n)\n      //n = 1000\n   }\n}\n```", "```rs\nfn main() {\n   for _ in 0..1000 {\n      for _ in 0..1000 {\n         //O(n^2)\n         //n = 1000\n      }\n   }\n}\n```", "```rs\nfn a(n: u64) {\n   //Is this O(n)?\n   for _ in 0..n {\n      b(n)\n   }\n}\n\nfn b(n: u64) {\n   //Is this O(n)?\n   for _ in 0..n {\n      c(n)\n   }\n}\n\nfn c(n: u64) {\n   //This is O(n)\n   for _ in 0..n {\n      let _ = 1 + 1;\n   }\n}\n\nfn main() {\n   //What time complexity is this?\n   a(1000)\n}\n```", "```rs\nextern crate rusty_machine;\nuse rusty_machine::linalg::{Matrix,Vector};\nuse rusty_machine::learning::gp::{GaussianProcess,ConstMean};\nuse rusty_machine::learning::toolkit::kernel;\nuse rusty_machine::learning::SupModel;\n\nfn main() {\n   let inputs = Matrix::new(3,3,vec![1.1,1.2,1.3,2.1,2.2,2.3,3.1,3.2,3.3]);\n   let targets = Vector::new(vec![0.1,0.8,0.3]);\n   let test_inputs = Matrix::new(2,3, vec![1.2,1.3,1.4,2.2,2.3,2.4]);\n   let ker = kernel::SquaredExp::new(2., 1.);\n   let zero_mean = ConstMean::default();\n   let mut gp = GaussianProcess::new(ker, zero_mean, 0.5);\n\n   gp.train(&inputs, &targets).unwrap();\n   let _ = gp.predict(&test_inputs).unwrap();\n}\n```", "```rs\nfn bomb(n: u64) -> u64 {\n   if n > 0 {\n      bomb(n-1);\n      bomb(n-1);\n   }\n   n\n}\n\nfn main() {\n   bomb(1000);\n}\n```", "```rs\nextern crate flame;\nuse std::fs::File;\n\nfn byref(n: u64, data: &[u64; 1024]) {\n   if n>0 {\n      byref(n-1, data);\n      byref(n-1, data);\n   }\n}\n\nfn bycopy(n: u64, data: [u64; 1024]) {\n   if n>0 {\n      bycopy(n-1, data);\n      bycopy(n-1, data);\n   }\n}\n\nstruct DataClonable([u64; 1024]);\nimpl Clone for DataClonable {\n   fn clone(&self) -> Self {\n      let mut newdata = [0; 1024];\n      for i in 0..1024 {\n         newdata[i] = self.0[i];\n      }\n      DataClonable(newdata)\n   }\n}\n\nfn byclone<T: Clone>(n: u64, data: T) {\n   if n>0 {\n      byclone(n-1, data.clone());\n      byclone(n-1, data.clone());\n   }\n}\n```", "```rs\nfn main() {\n   let data = [0; 1024];\n   flame::start(\"by reference\");\n   byref(15, &data);\n   flame::end(\"by reference\");\n\n   let data = [0; 1024];\n   flame::start(\"by copy\");\n   bycopy(15, data);\n   flame::end(\"by copy\");\n\n   let data = [0; 1024];\n   flame::start(\"by clone\");\n   byclone(15, data);\n   flame::end(\"by clone\");\n\n   let data = DataClonable([0; 1024]);\n   flame::start(\"by clone (with extras)\");\n   //2^4 instead of 2^15!!!!\n   byclone(4, data);\n   flame::end(\"by clone (with extras)\");\n\n   flame::dump_html(&mut File::create(\"flame-graph.html\").unwrap()).unwrap();\n}\n```", "```rs\n//This function returns an Option if the value is not expected\nfn expect_1or2or_other(n: u64) -> Option<u64> {\n   match n {\n      1|2 => Some(n),\n      _ => None\n   }\n}\n\n//This function returns an Err if the value is not expected\nfn expect_1or2or_error(n: u64) -> Result<u64,()> {\n   match n {\n      1|2 => Ok(n),\n      _ => Err(())\n   }\n}\n\n//This function uses functions that return Option and Return types\nfn mixed_1or2() -> Result<(),()> {\n   expect_1or2or_other(1);\n   expect_1or2or_other(2);\n   expect_1or2or_other(3);\n\n   expect_1or2or_error(1)?;\n   expect_1or2or_error(2)?;\n   expect_1or2or_error(3).unwrap_or(222);\n   Ok(())\n}\n\nfn main() {\n   mixed_1or2().expect(\"mixed 1 or 2 is OK.\");\n}\n```", "```rs\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io;\n\nfn lots_of_io() -> io::Result<()> {\n   {\n      let mut file = File::create(\"data.txt\")?;\n      file.write_all(b\"data\\ndata\\ndata\")?;\n   }\n\n   {\n      let mut file = File::open(\"data.txt\")?;\n      let mut data = String::new();\n      file.read_to_string(&mut data)?;\n      println!(\"{}\", data);\n   }\n   Ok(())\n}\n\nfn main() {\n   lots_of_io().expect(\"lots of io is OK.\");\n}\n```", "```rs\nconst MyEnum_A: u32 = 1;\nconst MyEnum_B: u32 = 2;\nconst MyEnum_C: u32 = 3;\n```", "```rs\n\"a\"\n\"b\"\n\"c\"\n```", "```rs\nenum MyEnum {\n   A,\n   B,\n   C,\n}\n```", "```rs\nfn foo(n: u64) {} //not all u64 are valid inputs\nfn bar(n: &str) {} //not all &str are valid inputs\nfn baz(n: MyEnum) {} //all MyEnum are valid\n```", "```rs\nmatch a {\n   1 => println!(“1 is ok”),\n   2 => println!(“2 is ok”),\n   3 => println!(“3 is ok”),\n   n => println!(“{} was unexpected”, n)\n}\n```", "```rs\nparent\n —- child 1\n —- child 2\n —- child 3\n```", "```rs\nuse std::{thread,time,process};\n\nfn main() {\n   let life_expectancy = process::id() % 8;\n   let t = time::Duration::from_millis(1000);\n   for _ in 0..life_expectancy {\n      thread::sleep(t);\n   }\n   println!(\"process {} dies unexpectedly.\", process::id());\n}\n```", "```rs\nuse std::process::Command;\nuse std::env::current_exe;\nuse std::{thread,time};\n\nfn main() {\n   //There is an executable called debugging_buggy_worker\n   //it crashes a lot but we still want to run it\n   let path = current_exe()\n             .expect(\"could not find current executable\");\n   let path = path.with_file_name(\"debugging_buggy_worker\");\n   let mut children = Vec::new();\n\n   //we start 3 workers\n   for _ in 0..3 {\n      children.push(\n         Command::new(path.as_os_str())\n                 .spawn()\n                 .expect(\"failed to spawn child\")\n      );\n   }\n\n   //those workers will randomly die because they are buggy\n   //so after they die, we restart a new process to replace them\n   let t = time::Duration::from_millis(1000);\n   loop {\n      thread::sleep(t);\n      for ci in 0..children.len() {\n         let is_dead = children[ci].try_wait().expect(\"failed to try_wait\");\n         if let Some(_exit_code) = is_dead {\n            children[ci] = Command::new(path.as_os_str())\n                                   .spawn()\n                                   .expect(\"failed to spawn child\");\n            println!(\"starting a new process from parent.\");\n         }\n      }\n   }\n}\n```", "```rs\nuse std::io;\n\n//This function checks the precondition that [n < 100]\nfn debug_precondition(n: u64) -> u64 {\n   debug_assert!(n < 100);\n   n * n\n}\n\n//This function checks the postcondition that [return > 10]\nfn debug_postcondition(n: u64) -> u64 {\n   let r = n * n;\n   debug_assert!(r > 10);\n   r\n}\n\n//this function dynamically checks the precondition [n < 100]\nfn runtime_precondition(n: u64) -> Result<u64,()> {\n   if !(n<100) { return Err(()) };\n   Ok(n * n)\n}\n\n//this function dynamically checks the postcondition [return > 10]\nfn runtime_postcondition(n: u64) -> Result<u64,()> {\n   let r = n * n;\n   if !(r>10) { return Err(()) };\n   Ok(r)\n}\n\n//This main function uses all of the functions\n//The dynamically validated functions are subjected to user input\nfn main() {\n   //inward facing code should assert expectations\n   debug_precondition(5);\n   debug_postcondition(5);\n\n   //outward facing code should handle errors\n   let mut s = String::new();\n   println!(\"Please input a positive integer greater or equal to 4:\");\n   io::stdin().read_line(&mut s).expect(\"error reading input\");\n   let i = s.trim().parse::<u64>().expect(\"error parsing input as integer\");\n   runtime_precondition(i).expect(\"runtime precondition violated\");\n   runtime_postcondition(i).expect(\"runtime postcondition violated\");\n}\n```", "```rs\ncargo build\n```", "```rs\n$ sudo rust-lldb target/debug/deps/performance_polynomial3-8048e39c94dd7157\n```", "```rs\n(lldb) command source -s 0 '/tmp/rust-lldb-commands.YnRBkV'\nExecuting commands in '/tmp/rust-lldb-commands.YnRBkV'.\n(lldb) command script import \"/Users/andrewjohnson/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/etc/lldb_rust_formatters.py\"\n(lldb) type summary add --no-value --python-function lldb_rust_formatters.print_val -x \".*\" --category Rust\n(lldb) type category enable Rust\n(lldb) target create \"target/debug/deps/performance_polynomial3-8048e39c94dd7157\"\nCurrent executable set to 'target/debug/deps/performance_polynomial3-8048e39c94dd7157' (x86_64).\n(lldb)\n\n```", "```rs\n(lldb) b a\nBreakpoint 1: where = performance_polynomial3-8048e39c94dd7157`performance_polynomial3::a::h0b267f360bbf8caa + 12 at performance_polynomial3.rs:3, address = 0x000000010000191c\n```", "```rs\n(lldb) r\nProcess 99468 launched: '/Users/andrewjohnson/subarctic.org/subarctic.org/Hands-On-Functional-Programming-in-RUST/Chapter09/target/debug/deps/performance_polynomial3-8048e39c94dd7157' (x86_64)\nProcess 99468 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n  frame #0: 0x000000010000191c performance_polynomial3-8048e39c94dd7157`performance_polynomial3::a::h0b267f360bbf8caa(n=1000) at performance_polynomial3.rs:3\n   1    fn a(n: u64) {\n   2       //Is this O(n);\n-> 3       for _ in 0..n {\n   4          b(n);\n   5       }\n   6    }\n   7    \nTarget 0: (performance_polynomial3-8048e39c94dd7157) stopped.\n```", "```rs\n(lldb) frame variable\n(unsigned long) n = 1000\n```", "```rs\n(lldb) p n\n(unsigned long) $0 = 1000\n```", "```rs\n(lldb) c\nProcess 99468 resuming\nProcess 99468 exited with status = 0 (0x00000000)\n```", "```rs\n//This macro rule matches one token tree \"tt\"\nmacro_rules! match_tt {\n   ($e: tt) => { println!(\"match_tt: {}\", stringify!($e)) }\n}\n\n//This macro rule matches one identifier \"ident\"\nmacro_rules! match_ident {\n   ($e: ident) => { println!(\"match_ident: {}\", stringify!($e)) }\n}\n\n//This macro rule matches one expression \"expr\"\nmacro_rules! match_expr {\n   ($e: expr) => { println!(\"match_expr: {}\", stringify!($e)) }\n}\n\n//This macro rule matches one type \"ty\" \nmacro_rules! match_ty {\n   ($e: ty) => { println!(\"match_ty: {}\", stringify!($e)) }\n}\n\n//This macro rule matches one statement \"stmt\"\nmacro_rules! match_stmt {\n   ($e: stmt) => { println!(\"match_stmt: {}\", stringify!($e)) }\n}\n\n//This macro rule matches one block \"block\"\nmacro_rules! match_block {\n   ($e: block) => { println!(\"match_block: {}\", stringify!($e)) }\n}\n\n//This macro rule matches one item \"item\"\n//items are things like function definitions, struct definitions, ...\nmacro_rules! match_item {\n   ($e: item) => { println!(\"match_item: {}\", stringify!($e)) }\n}\n\n//This macro rule matches one pattern \"pat\"\nmacro_rules! match_pat {\n   ($e: pat) => { println!(\"match_pat: {}\", stringify!($e)) }\n}\n\n//This macro rule matches one path \"path\"\n//A path is a canonical named path like std::fs::File\nmacro_rules! match_path {\n   ($e: path) => { println!(\"match_path: {}\", stringify!($e)) }\n}\n\n//This macro rule matches one meta \"meta\"\n//A meta is anything inside of the #[...] or #![...] syntax\nmacro_rules! match_meta {\n   ($e: meta) => { println!(\"match_meta: {}\", stringify!($e)) }\n}\n```", "```rs\nfn main() {\n   match_tt!(a);\n   match_tt!(let);\n   match_tt!(+);\n\n   match_ident!(a);\n   match_ident!(bcd);\n   match_ident!(_def);\n\n   match_expr!(1.2);\n   match_expr!(bcd);\n   match_expr!(1.2 + bcd / \"b\" - [1, 3, 4] .. vec![1, 2, 3]);\n\n   match_ty!(A);\n   match_ty!(B + 'static);\n   match_ty!(A<&(B + 'b),&mut (C + 'c)> + 'static);\n\n   match_stmt!(let x = y);\n   match_stmt!(());\n   match_stmt!(fn f(){});\n\n   match_block!({});\n   match_block!({1; 2});\n   match_block!({1; 2 + 3});\n\n   match_item!(struct A(u64););\n   match_item!(enum B { C, D });\n   match_item!(fn C(n: NotAType) -> F<F<F<F<F>>>> { a + b });\n\n   match_pat!(_);\n   match_pat!(1);\n   match_pat!(A {b, c:D( d@3 )} );\n\n   match_path!(A);\n   match_path!(::A);\n   match_path!(std::A);\n   match_path!(a::<A,_>);\n\n   match_meta!(A);\n   match_meta!(Property(B,C));\n}\n```", "```rs\n//this is a grammar sequence\nmacro_rules! abc {\n   (a b c) => { println!(\"'a b c' is the only correct syntax.\") };\n}\n\n//this is a grammar alternative\nmacro_rules! a_or_b {\n   (a) => { println!(\"'a' is one correct syntax.\") };\n   (b) => { println!(\"'b' is also correct syntax.\") };\n}\n\n//this is a grammar of alternative sequences\nmacro_rules! abc_or_aaa {\n   (a b c) => { println!(\"'a b c' is one correct syntax.\") };\n   (a a a) => { println!(\"'a a a' is also correct syntax.\") };\n}\n\n//this is a grammar sequence matching many of one token\nmacro_rules! many_a {\n   ( $($a:ident)* ) => {{ $( print!(\"one {} \", stringify!($a)); )* println!(\"\"); }};\n   ( $($a:ident),* ) => {{ $( print!(\"one {} comma \", stringify!($a)); )* println!(\"\"); }};\n}\n\nfn main() {\n   abc!(a b c);\n\n   a_or_b!(a);\n   a_or_b!(b);\n\n   abc_or_aaa!(a b c);\n   abc_or_aaa!(a a a);\n\n   many_a!(a a a);\n   many_a!(a, a, a);\n}\n```", "```rs\nmacro_rules! f {\n   () => { f!(1) f!(2) f!(3) };\n   (1) => { 1 };\n   (2) => { + };\n   (3) => { 2 };\n}\n\nfn main() {\n   f!()\n}\n```", "```rs\nerror: macro expansion ignores token `f` and any following\n--> t.rs:2:19\n  |\n2 |    () => { f!(1); f!(2); f!(3) };\n  |                   ^\n  |\nnote: caused by the macro expansion here; the usage of `f!` is likely invalid in expression context\n--> t.rs:9:4\n  |\n9 |    f!()\n  |    ^^^^\n\nerror: aborting due to previous error\n```", "```rs\n[package]\nname = \"procmacro\"\nversion = \"1.0.0\"\n\n[dependencies]\nsyn = \"0.12\"\nquote = \"0.4\"\n\n[lib]\nproc-macro = true\n```", "```rs\n#![feature(proc_macro)]\n#![crate_type = \"proc-macro\"]\nextern crate proc_macro;\nextern crate syn;\n#[macro_use] extern crate quote;\nuse proc_macro::TokenStream;\n#[proc_macro]\n\npub fn f(input: TokenStream) -> TokenStream {\n   assert!(input.is_empty());\n\n   (quote! {\n      1 + 2\n   }).into()\n}\n```", "```rs\n#![feature(proc_macro_non_items)]\n#![feature(use_extern_macros)]\nextern crate procmacro;\n\nfn main() {\n   let _ = procmacro::f!();\n}\n```", "```rs\n#![feature(proc_macro)]\n#![crate_type = \"proc-macro\"]\nextern crate proc_macro;\n#[macro_use] extern crate syn;\n#[macro_use] extern crate quote;\nuse proc_macro::TokenStream;\nuse syn::{Ident, Type, Expr, WhereClause, TypeSlice, Path};\nuse syn::synom::Synom;\n\nstruct MiscSyntax {\n   id: Ident,\n   ty: Type,\n   expr: Expr,\n   where_clause: WhereClause,\n   type_slice: TypeSlice,\n   path: Path\n}\n```", "```rs\nimpl Synom for MiscSyntax {\n   named!(parse -> Self, do_parse!(\n      keyword!(where) >>\n      keyword!(while) >>\n      id: syn!(Ident) >>\n      punct!(:) >>\n      ty: syn!(Type) >>\n      punct!(>>) >>\n      expr: syn!(Expr) >>\n      punct!(;) >>\n      where_clause: syn!(WhereClause) >>\n      punct!(;) >>\n      type_slice: syn!(TypeSlice) >>\n      punct!(;) >>\n      path: syn!(Path) >>\n      (MiscSyntax { id, ty, expr, where_clause, type_slice, path })\n   ));\n}\n```", "```rs\n#[proc_macro]\npub fn misc_syntax(input: TokenStream) -> TokenStream {\n   let m: MiscSyntax = syn::parse(input).expect(\"expected Miscellaneous Syntax\");\n   let MiscSyntax { id, ty, expr, where_clause, type_slice, path } = m;\n\n   (quote! {\n      let #id: #ty = #expr;\n      println!(\"variable = {}\", #id);\n    }).into()\n}\n```", "```rs\n#![feature(proc_macro_non_items)]\n#![feature(use_extern_macros)]\nextern crate procmacro2;\n\nfn main() {\n   procmacro2::misc_syntax!(\n      where while abcd : u64 >> 1 + 2 * 3;\n      where T: 'x + A<B='y+C+D>;\n      [M];A::f\n   );\n}\n```"]