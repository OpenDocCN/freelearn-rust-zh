- en: Important Standard Traits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要标准特质
- en: As we've seen already, traits are an important part of the Rust ecosystem. The
    traits that are built into the Rust standard library affect many things, including
    even what operators can be used on a particular data value. In this chapter, we're
    going to review many of these traits, and see how to implement them on our own
    data types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，特质是 Rust 生态系统的重要组成部分。Rust 标准库中内置的特质影响了许多事物，包括甚至可以在特定数据值上使用的运算符。在本章中，我们将回顾许多这些特质，并了解如何在我们的数据类型上实现它们。
- en: 'In this chapter, we''re going to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Look at an assortment of traits defined by the Rust standard library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看由 Rust 标准库定义的特质集合
- en: Learn about the meanings and implications of those traits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解这些特质的含义和影响
- en: Learn about what traits are applied automatically
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解哪些特质是自动应用的
- en: Learn how to use the `derive` command to generate trait implementations for
    select traits
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 `derive` 命令为选定的特质生成特质实现
- en: Learn how to manually implement the remaining traits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何手动实现剩余的特质
- en: Traits that can be derived
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可以推导的特质
- en: For some traits, the compiler itself knows how to implement them for a type.
    If we want them, we only have to tell it that we do, and it will take care of
    the rest for us.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些特质，编译器本身知道如何为类型实现它们。如果我们想要它们，我们只需要告诉它，然后它会为我们处理其余的事情。
- en: We still have the option of manually implementing derivable traits, but that
    would usually just be a waste of time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以选择手动实现可推导的特质，但这通常只是浪费时间。
- en: Telling the compiler that we want a data type to have a derivable trait is easy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉编译器我们希望数据类型具有可推导的特质是很容易的。
- en: 'Here, we''re telling it that we want our `CopyExample` enumeration to implement
    `Copy` and `Clone`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉它我们希望我们的 `CopyExample` 枚举实现 `Copy` 和 `Clone`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A trait can only be derived if the people who created the trait were able to
    write a program to generate the trait implementation. When we write `#[derive(Copy,
    Clone)]`, we're telling the compiler to go find those programs for deriving `Copy`
    and `Clone` in the source code of the packages where the traits were defined,
    and run those programs to generate the source code for the trait implementations
    before it continues compiling. If the decisions that need to be made to implement
    a trait are too complex for a program to make without user input, the trait can't
    be derived.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特质只有在创建特质的那些人能够编写一个生成特质实现的程序时才能被推导。当我们编写 `#[derive(Copy, Clone)]` 时，我们告诉编译器在定义特质的包的源代码中查找这些程序，以推导
    `Copy` 和 `Clone`，并在继续编译之前运行这些程序来生成特质实现的源代码。如果实现特质所需做出的决策对于没有用户输入的程序来说过于复杂，则特质不能被推导。
- en: Clone
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clone
- en: The `Clone` trait means that it is possible to make an explicit copy of a data
    value. The compiler won't ever do it automatically, but when we want to copy a
    value, we can do so by calling its `Clone` function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clone` 特质意味着可以显式地复制数据值。编译器永远不会自动这样做，但当我们想要复制一个值时，我们可以通过调用它的 `Clone` 函数来实现。'
- en: 'Deriving the `Clone` trait looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 推导 `Clone` 特质的样式如下：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Copy
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copy
- en: The `Copy` trait means that creating a copy of the data value is just a matter
    of copying the bits that make up its representation. If the data value contains
    any borrows or uses heap memory, it can't have the `Copy` trait.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Copy` 特质意味着创建数据值的副本只是复制构成其表示的位。如果数据值包含任何借用或使用堆内存，它就不能有 `Copy` 特质。'
- en: The compiler will automatically copy data values that have the `Copy` trait
    when it would have otherwise moved them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器在其他情况下会移动数据值时，它会自动复制具有 `Copy` 特质的数据值。
- en: Since anything that has the `Copy` trait can certainly be duplicated on request
    as well, `Copy` requires `Clone` to be implemented.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何具有 `Copy` 特质的对象都可以在请求时肯定被复制，因此 `Copy` 需要 `Clone` 被实现。
- en: 'Deriving `Copy` looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 推导 `Copy` 的样子如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Debug
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Debug
- en: The `Debug` trait tells Rust how to format the data value for debugging output.
    One place this is used is if we use `{:?}` instead of `{}` as the substitution
    marker for the data value in `println!` or `print!`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug` 特质告诉 Rust 如何格式化数据值以供调试输出。这种用法的一个例子是，如果我们使用 `{:?}` 而不是 `{}` 作为 `println!`
    或 `print!` 中数据值的替换标记。'
- en: Since the debugging representation of a data value should be pretty close to
    the way it would be represented in the source code, Rust is able to derive it
    for us automatically.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据值的调试表示应该非常接近它在源代码中的表示方式，Rust 能够自动为我们推导它。
- en: 'Deriving `Debug` looks like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 推导Debug看起来像这样：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: PartialEq
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PartialEq
- en: The `PartialEq` trait represents the ability to compare the data value with
    another one to determine whether they are equal. It does *not* imply that a value
    is considered equal to itself, however.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: PartialEq特性表示比较数据值以确定它们是否相等的能力。然而，它并不表示一个值被认为是等于它自己。
- en: The `PartialEq` trait is used by the compiler to implement the `==` comparison
    operation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: PartialEq特性被编译器用来实现`==`比较操作。
- en: Floating point numbers are the classic example of a data type that has `PartialEq`,
    because the floating point representation of a `NaN` or `Not a Number` value is
    not considered equal to itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数是具有PartialEq的经典数据类型示例，因为NaN（非数字）值的浮点表示被认为不等于它自己。
- en: 'Deriving `PartialEq` looks like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 推导PartialEq看起来像这样：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, that derivation only compares two `PartialEqSelf` data values. If we
    want to enable an equality comparison with data values of other types, we need
    to implement the trait manually.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，那个推导只比较了两个PartialEqSelf数据值。如果我们想启用与其他类型的数据值的相等比较，我们需要手动实现该特性。
- en: 'Here, we have a manual implementation of the trait, enabling comparison with
    the `u32` data type:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个手动实现的特性，允许与u32数据类型进行比较：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we've arranged for the `PartialEqU32::Good` value to compare as equal
    to even number `u32`s, and `PartialEqU32::Bad` to compare equal to odd number
    `u32`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经安排了PartialEqU32::Good值与偶数u32进行比较视为相等，而PartialEqU32::Bad与奇数u32进行比较视为相等。
- en: Eq
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eq
- en: The `Eq` trait means the same thing that `PartialEq` does, *except* that a data
    value is always equal to itself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Eq特性意味着与PartialEq相同的意思，*除了*数据值总是等于它自己。
- en: Implementing the `Eq` trait requires implementing the `PartialEq` trait as well,
    and the only thing it does beyond what `PartialEq` does is provide the compiler
    with the hint that it doesn't need to bother running the `Eq` function when both
    sides of the comparison are the same data value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Eq特性需要同时实现PartialEq特性，并且它所做的唯一超出PartialEq的事情就是向编译器提供提示，即当比较的两边都是相同的数据值时，不需要麻烦地运行Eq函数。
- en: 'Deriving `Eq` looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 推导Eq看起来像这样：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: PartialOrd
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PartialOrd
- en: The `PartialOrd` trait represents the ability to define some sort of ordering
    between two data values, so we can say one of them is less than the other, or
    greater than the other, or that they're the same, *or* that the ordering relation
    does not apply to these values. That last one is the reason why this is a *partial*
    ordering.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: PartialOrd特性表示在两个数据值之间定义某种排序能力，因此我们可以说出一个小于另一个，或大于另一个，或者它们是相同的，*或者*排序关系不适用于这些值。这就是为什么这是一个*部分*排序的原因。
- en: Since *they're the same* is a valid result of the comparison, implementing `PartialOrd`
    requires the implemention of `PartialEq`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“它们相同”是比较的有效结果，实现PartialOrd需要实现PartialEq。
- en: As with `PartialEq`, we can derive an implementation that compares two data
    values of the same type, but we can also manually implement the trait to allow
    comparison with data of different types.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与PartialEq一样，我们可以推导出一个实现，用于比较相同类型的数据值，但我们也可以手动实现特性以允许与不同类型的数据比较。
- en: 'Here, we have the automatic derivation of the trait:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有特性的自动推导：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have implemented it manually to support comparison with a different
    data type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们手动实现了它以支持与不同数据类型的比较：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we're telling Rust that a `PartialOrdU32::Good` value is always greater
    than any `u32` value, but a `PartialOrdU32::Bad` value does not have any relation
    to any `u32` value at all.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们告诉Rust，PartialOrdU32::Good值总是大于任何u32值，但PartialOrdU32::Bad值与任何u32值都没有任何关系。
- en: Ord
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ord
- en: '`Ord` is like `PartialOrd`, except that it doesn''t allow the option of returning
    a "no relation" value; for any pair of values, either they are equal, or one is
    less than the other.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ord`类似于`PartialOrd`，除了它不允许返回“无关系”的选项；对于任何一对值，要么它们相等，要么一个小于另一个。'
- en: '`Ord` is used by the compiler to implement the `<` (less than), `>` (greater
    than), `<=` (less than or equal), and `>=` (greater than or equal) comparison
    operators.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ord`被编译器用来实现`<`（小于）、`>`（大于）、`<=`（小于等于）、`>=`（大于等于）比较运算符。'
- en: If a data type has the `Ord` trait, it has to also have the `PartialOrd`, `Eq`,
    and `PartialEq` traits. Like those traits, it can be manually implemented to enable
    comparisons between different data types, but we have to be very careful that
    the results returned by the various functions that are used to implement those
    traits agree with each other. When we derive the traits, we don't have to worry
    about that.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数据类型具有`Ord`特质，它也必须具有`PartialOrd`、`Eq`和`PartialEq`特质。像这些特质一样，它们可以手动实现以启用不同数据类型之间的比较，但我们必须非常小心，确保用于实现这些特质的各个函数返回的结果是一致的。当我们推导特质时，我们不必担心这一点。
- en: 'Here''s an example of deriving `Ord`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是推导`Ord`的一个示例：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Hash
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希
- en: The `Hash` trait enables a data value to be used as a key in several of Rust's
    standard library data structures, such as `HashMap` and `HashSet`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hash`特质使数据值能够用作Rust标准库中几个数据结构的键，例如`HashMap`和`HashSet`。'
- en: 'Deriving the `Hash` trait looks like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 推导`Hash`特质看起来像这样：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While `Eq` and `PartialEq` are not actually required to implement `Hash`, if
    they are implemented, they need to agree with it, which is to say that if two
    values are equal, their hash values should also be equal. The automatically generated
    implementations have this property, so we only need to worry about it if we're
    doing manual implementations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Eq`和`PartialEq`实际上不是实现`Hash`所必需的，但如果它们被实现，它们需要与之一致，也就是说，如果两个值相等，它们的哈希值也应该相等。自动生成的实现具有这个属性，所以我们只有在进行手动实现时才需要担心它。
- en: Default
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认
- en: When the `Default` trait is implemented for a type, it makes it possible for
    us to request a default value for that type of data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当为类型实现`Default`特质时，它使我们能够请求该类型数据的默认值。
- en: 'When we derive `Default` for a data type, it sets the default value for that
    type to be made up of the default values for all of the contained data types,
    so when we do this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为一个数据类型推导`Default`时，它将该类型的默认值设置为包含所有包含数据类型的默认值，因此当我们这样做时：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What we're doing is setting the default for the `DefaultExample` type to be
    a `DefaultExample` containing the default values of a `String` and an `i32`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是将`DefaultExample`类型的默认值设置为包含`String`和`i32`的默认值的`DefaultExample`。
- en: 'We can request a default value like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样请求一个默认值：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Traits that enable operators
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使操作员具备特性的特质
- en: Most of the operators and the special syntax of Rust are backed up by traits,
    which tell the compiler how to perform the operation on the specific data type
    it's looking at. We've seen some of those already, but many of them can't be derived,
    so if we want to enable that syntax for our data types, we need to implement them
    manually.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运算符和Rust的特殊语法都有特质的支撑，这些特质告诉编译器如何对特定数据类型执行操作。我们已经看到了一些，但其中许多不能被推导，所以如果我们想为我们自己的数据类型启用这种语法，我们需要手动实现它们。
- en: ​Add, Mul, Sub, and Div
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加、乘法、减法和除法
- en: The `Add`, `Mul`, `Sub`, and `Div` traits represent the ability to add, multiply,
    subtract, or divide two values. These traits are used by the compiler to implement
    the `+`, `*`, `-`, and `/` operators.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add`、`Mul`、`Sub`和`Div`特质代表了对两个值进行加、乘、减或除的能力。这些特质被编译器用来实现`+`、`*`、`-`和`/`运算符。'
- en: Notice that if the values of `self` and `other` do not have the `Copy` trait,
    they are moved into the implementation function and consumed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果`self`和`other`的值不具有`Copy`特质，它们将被移动到实现函数中并被消耗。
- en: 'All of these traits follow the same pattern, so here''s an example implementation
    of `Add`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特质遵循相同的模式，所以这里是一个`Add`的实现示例：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Mul`, `Sub`, and `Div` follow the same pattern.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mul`、`Sub`和`Div`遵循相同的模式。'
- en: What we've defined here is a very primitive form of counting, that considers
    any number greater than 3 to be "many".
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的是一种非常原始的计数形式，它将任何大于3的数字视为“很多”。
- en: Inside the `impl` block, we have `type Output = AddExample;`. That's a bit of
    new syntax we haven't seen before. What we're doing is setting the `Output` *associated
    type* for this implementation, which is fed back into the trait definition to
    be used in declaring the signature of the `add` function. After all, we're returning
    an `AddExample` here, and there was no such type when the trait was originally
    defined. That's not a problem, though, because the trait says that the `add` function
    returns a data value of type `Output`, and we've just told it that `Output` is
    an alias for `AddExample`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `impl` 块内部，我们有 `type Output = AddExample;`。这是一种我们之前没有见过的语法。我们所做的是为这个实现设置 `Output`
    *关联类型*，它被反馈到特性定义中，用于声明 `add` 函数的签名。毕竟，我们在这里返回一个 `AddExample`，而在特性最初定义时并没有这样的类型。但这不是问题，因为特性说明
    `add` 函数返回一个类型为 `Output` 的数据值，而我们刚刚告诉它 `Output` 是 `AddExample` 的别名。
- en: We can also implement adding data of two different types together, by implementing
    `Add<OtherType> for OneType` to represent the ability to have a `OneType` value
    on the left side of the `+` and an `OtherType` value on the right, similarly to
    the way we were able to create comparisons between two different types earlier
    in the chapter. The same trick works for `Mul`, `Sub`, and `Div` as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过实现 `Add<OtherType> for OneType` 来实现将两种不同类型的数据相加，这表示在 `+` 的左侧有一个 `OneType`
    值，在右侧有一个 `OtherType` 值，这与我们在本章前面能够创建两种不同类型之间比较的方式类似。同样的技巧也适用于 `Mul`、`Sub` 和 `Div`。
- en: AddAssign, MulAssign, SubAssign, and DivAssign
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddAssign, MulAssign, SubAssign, and DivAssign
- en: These traits enable the `+=`, `*=`, `-=`, and `/=` operators for the types that
    implement them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性为实现了它们的类型启用了 `+=`、`*=`、`-=` 和 `/=` 操作符。
- en: They are similar to the `Add`, `Sub`, `Mul`, and `Div` traits, with the difference
    that their implementation functions take `&mut self` instead of plain `self`.
    Instead of consuming their left-side input, they have the ability to change its
    contained value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它们类似于 `Add`、`Sub`、`Mul` 和 `Div` 特性，不同之处在于它们的实现函数接受 `&mut self` 而不是普通的 `self`。它们不是消耗它们的左侧输入，而是有改变其包含值的能力。
- en: 'All of these traits follow the same pattern, so here''s an example implementation
    of `AddAssign`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性都遵循相同的模式，所以这里是一个 `AddAssign` 的示例实现：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Apart from the differences based on assigning the new value to `&mut self`,
    this is much like the implementation of the `add` function for the `Add` trait,
    which isn't very surprising.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于将新值赋给 `&mut self` 的差异之外，这和 `Add` 特性的 `add` 函数实现非常相似，这并不令人惊讶。
- en: In particular, while it doesn't consume its `self`, it does still consume the
    value on the right-hand side of the operand, assuming that value doesn't have
    the `Copy` trait.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，虽然它不消耗它的 `self`，但它仍然消耗操作符右侧的值，假设这个值没有 `Copy` 特性。
- en: BitAnd
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BitAnd
- en: The `BitAnd` trait enables the `&` operator for types that implement it. This
    operator is used for computing the *bitwise and* value of two integers (hence
    the name), but has different meanings for various other data types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitAnd` 特性为实现了它的类型启用了 `&` 操作符。这个操作符用于计算两个整数的 *按位与* 值（因此得名），但对于各种其他数据类型有不同的含义。'
- en: 'Implementing `BitAnd` looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `BitAnd` 的样子如下：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: BitAndAssign
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BitAndAssign
- en: The `BitAndAssign` trait enables the `&=` operator for data types that implement
    it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitAndAssign` 特性为实现了它的数据类型启用了 `&=` 操作符。'
- en: 'Implementing `BitAndAssign` looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `BitAndAssign` 的样子如下：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: BitOr
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BitOr
- en: The `BitOr` trait enables the `|` operator for types that implement it. This
    operator is used for computing the *bitwise or* value of two integers, but has
    different meanings for various other data types.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitOr` 特性为实现了它的类型启用了 `|` 操作符。这个操作符用于计算两个整数的 *按位或* 值，但对于各种其他数据类型有不同的含义。'
- en: 'Implementing `BitOr` looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `BitOr` 的样子如下：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: BitOrAssign
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BitOrAssign
- en: The `BitOrAssign` trait enables the `|=` operator for data types that implement
    it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitOrAssign` 特性为实现了它的数据类型启用了 `|=` 操作符。'
- en: 'Implementing `BitOrAssign` looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `BitOrAssign` 的样子如下：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: BitXor
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BitXor
- en: The `BitXor` trait enables the `^` operator for types that implement it. This
    operator is used for computing the *bitwise exclusive or* value of two integers,
    but has different meanings for various other data types.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitXor` 特性为实现了它的类型启用了 `^` 操作符。这个操作符用于计算两个整数的 *按位异或* 值，但对于各种其他数据类型有不同的含义。'
- en: 'Implementing `BitXor` looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `BitXor` 的样子如下：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: BitXorAssign
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BitXorAssign
- en: The `BitXorAssign` trait enables the `^=` operator for data types that implement
    it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitXorAssign`特质为实现了它的数据类型启用了`^=`运算符。'
- en: 'Implementing `BitXorAssign` looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`BitXorAssign`看起来是这样的：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Deref
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deref
- en: The `Deref` trait grants the ability to dereference a value as if it were a
    borrow. Smart pointers implement this trait, which is why they can be used as
    though they were borrows of the contained data value. `String` does the same thing,
    which is what allows us to use a `String` value anywhere that an `&str` is expected.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deref`特质赋予了将值解引用为借用一样的功能。智能指针实现了这个特质，这就是为什么它们可以用作包含数据值的借用。`String`也做了同样的事情，这就是为什么我们可以在期望`&str`的地方使用`String`值。'
- en: 'Here we have an implementation of the `Deref` trait:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Deref`特质的实现：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the implementation function doesn't actually dereference anything.
    Instead, it converts an `&self` borrow into a borrow of something else.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到实现函数实际上并没有解引用任何东西。相反，它将一个`&self`借用转换成了对其他东西的借用。
- en: That's what the compiler needs in order to correctly and efficiently handle
    dereferencing smart pointers and such, but the compiler also uses that ability
    to let us interact with something like a `Rc<Box<String>>` as if it were just
    a plain old `&str`. The `Rc` has a `deref` function that returns a borrow of a
    `Box`, and the `Box` has a `deref` function that returns a  borrow of a `String`,
    and the `String` has a `deref` function that returns a borrow of a `str`, so the
    compiler lets us treat the whole thing as if it was an `&str` for the purposes
    of calling its functions or using it as a parameter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是编译器需要的东西，以便正确且高效地处理解引用智能指针等，但编译器也使用这种能力让我们能够像处理普通的`&str`一样与`Rc<Box<String>>`这样的东西交互。`Rc`有一个返回`Box`借用的`deref`函数，`Box`有一个返回`String`借用的`deref`函数，而`String`有一个返回`str`借用的`deref`函数，因此编译器允许我们将整个结构视为`&str`，以便调用其函数或将其用作参数。
- en: DerefMut
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DerefMut
- en: The `DerefMut` trait does the same thing `Deref` does, but it is used when derefencing
    a mutable value. The compiler decides whether to use `Deref` or `DerefMut`, so
    usually when we need to implement one, we need to implement them both.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`DerefMut`特质与`Deref`做的是同样的事情，但它用于解引用可变值。编译器决定使用`Deref`还是`DerefMut`，所以通常当我们需要实现一个时，我们通常需要实现两个。'
- en: 'Here we have an implementation of `DerefMut`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`DerefMut`的实现：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `DerefMut` trait requires that the `Deref` trait is also implemented, and
    that the `deref` and `deref_mut` functions have the same return type.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`DerefMut`特质要求也实现了`Deref`特质，并且`deref`和`deref_mut`函数有相同的返回类型。'
- en: Drop
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drop
- en: When a data type has the `Drop` trait, the program will call the `drop` function
    for values of that type immediately before their lifetimes end. That's how `Rc`,
    `Mutex`, `RefCell`, and so on are able to keep track of how many borrows their
    contained value has.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数据类型具有`Drop`特质时，程序将在该类型值的生命周期结束之前立即调用`drop`函数。这就是`Rc`、`Mutex`、`RefCell`等能够跟踪它们包含的值有多少借用的方式。
- en: The `drop` function is called before the data value's lifetime ends, so we don't
    have to worry about it being an invalid reference. Also, we don't have to worry
    about manually cleaning up the contained values for our data type, because they
    will be automatically dropped themselves after our `drop` function is finished.
    All we need to do is handle whatever special case led us to implement `Drop` in
    the first place.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop`函数在数据值的生命周期结束之前被调用，所以我们不必担心它是一个无效的引用。此外，我们也不必担心手动清理我们数据类型中包含的值，因为它们将在我们的`drop`函数完成后自动丢弃。我们唯一需要做的就是处理导致我们最初实现`Drop`的特殊情况。'
- en: We can't directly call the `drop` function, because that would be an extremely
    good way to make a mess. There is a `std::mem::drop` function we can use that
    consumes a data value and drops it for us, if we need to trigger this at a specific
    time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接调用`drop`函数，因为这会是一个制造混乱的极好方式。有一个`std::mem::drop`函数我们可以使用，它会消耗一个数据值并将其丢弃，如果我们需要在特定时间触发这个操作。
- en: 'Implementing `Drop` looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Drop`看起来是这样的：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Index
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Index
- en: The `Index` trait means that the data type can be used with the `x[y]` syntax,
    where a value is looked up inside of `x` based on the *index value* `y`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index`特质意味着数据类型可以用`x[y]`语法使用，其中根据索引值`y`在`x`内部查找一个值。'
- en: 'When we implement `Index`, we need to identify what data type can be used for
    the index value, as well as what data type the operation returns, so the implementation
    looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现 `Index` 时，我们需要确定可以用于索引值的什么数据类型，以及操作返回什么数据类型，因此实现看起来是这样的：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've used `&str` for the data type of the index, and were using `u32` for the
    data type of the value. Using `&str` means that we need to be a little bit careful
    of lifetimes, but it's not too bad.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `&str` 作为索引的数据类型，并使用 `u32` 作为值的类型。使用 `&str` 意味着我们需要稍微注意生命周期，但这并不太糟糕。
- en: IndexMut
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IndexMut
- en: The `IndexMut` trait represents the abilities to assign to a contained value
    using the `x[y] = z` syntax. Like the `Index` trait, it lets us look up a contained
    data value by providing an index value, but it produces a mutable borrow of the
    contained value, which can be used to change it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexMut` 特性表示使用 `x[y] = z` 语法对包含的值进行赋值的abilities。像 `Index` 特性一样，它允许我们通过提供一个索引值来查找包含的数据值，但它产生一个可变借用，可以用来更改它。'
- en: 'Implementing `IndexMut` looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `IndexMut` 的样子如下：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that we've added a `junk` value to the `IndexExample` structure. We did
    that because there's no way to indicate that an index value doesn't map to a valid
    contained value; if the `index_mut` function gets called, is *has* to return a
    mutable borrow of the correct type, and that borrow has to have a long enough
    lifetime as well. Adding a junk value to the data structure is a simple way of
    achieving that, though there are other approaches that would save memory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `IndexExample` 结构体中添加了一个 `junk` 值。我们这样做是因为没有方法可以表示索引值不映射到一个有效的包含值；如果调用
    `index_mut` 函数，它必须返回正确类型的可变借用，并且这个借用必须有足够长的生命周期。将垃圾值添加到数据结构是一种简单的方法，尽管还有其他可以节省内存的方法。
- en: Any type that implements `IndexMut` has to implement `Index` as well, and the
    `index` and `index_mut` functions have to return a borrow and a mutable borrow
    of the same data type, respectively.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了 `IndexMut` 的类型都必须实现 `Index`，并且 `index` 和 `index_mut` 函数必须分别返回相同数据类型的借用和可变借用。
- en: Neg
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Neg
- en: The `Neg` trait enables a data type to be used with the *unary negation* operator,
    also known as the negative sign. When we write `-5`, we're applying the unary
    negation operator to the value 5, producing a negative 5 as the result.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Neg` 特性使数据类型能够与 *一元否定* 操作符一起使用，也称为负号。当我们写 `-5` 时，我们正在将一元否定操作符应用于值 5，产生一个结果为负
    5。'
- en: 'Implementing `Neg` looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `Neg` 的样子如下：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Not
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Not
- en: The `Not` trait enables the *logical negation* operator, which is written as
    an `!`. `Not` is both conceptually and practically similar to `Neg`, but its primary
    use is for Boolean logic rather than arithmetic.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Not` 特性启用了 *逻辑非* 操作符，它被写作一个 `!`。`Not` 在概念上和实际应用上都与 `Neg` 类似，但它的主要用途是布尔逻辑而不是算术。'
- en: 'Implementing `Not` looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `Not` 的样子如下：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Rem and RemAssign
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rem 和 RemAssign
- en: The `Rem` trait enables the `%` operator for types that implement it. This operator
    is used for computing the *modulus* (also known as the remainder of a division) value
    of two integers, but has different meanings for various other data types.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rem` 特性为实现了它的类型启用了 `%` 操作符。这个操作符用于计算两个整数的 *模数*（也称为除法的余数），但对于各种其他数据类型有不同的含义。'
- en: The `Rem` trait has both an `Output` associated type, and the option of implementing
    it to operate on different types by implementing `Rem<OtherType>` rather than
    just `Rem`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rem` 特性既有一个关联的 `Output` 类型，也有通过实现 `Rem<OtherType>` 而不是仅仅 `Rem` 来在多种类型上操作的选择。'
- en: '`RemAssign` has the same relationship to `Rem` that `AddAssign` has to `Add`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemAssign` 与 `Rem` 的关系类似于 `AddAssign` 与 `Add` 的关系。'
- en: Shl and ShlAssign
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shl 和 ShlAssign
- en: The `Shl` trait enables the `<<` operator for types that implement it. This
    operator is used for *left-shifting* an integer by a number of bits, but has different
    meanings for various other data types.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shl` 特性为实现了它的类型启用了 `<<` 操作符。这个操作符用于将整数左移一定数量的位，但对于各种其他数据类型有不同的含义。'
- en: The `Shl` trait has both an output associated type, and the option of implementing
    it to operate on different types by implementing `Shl<OtherType>` rather than
    just `Shl`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shl` 特性既有一个关联的输出类型，也有通过实现 `Shl<OtherType>` 而不是仅仅 `Shl` 来在多种类型上操作的选择。'
- en: '`ShlAssign` has the same relationship to `Shl` that `AddAssign` has to `Add`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShlAssign` 与 `Shl` 的关系类似于 `AddAssign` 与 `Add` 的关系。'
- en: Shr and ShrAssign
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shr 和 ShrAssign
- en: The `Shr` trait enables the `>>` operator for types that implement it. This
    operator is used for *right-shifting* an integer by a number of bits, but has
    different meanings for various other data types.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shr` 特性为实现了它的类型启用了 `>>` 操作符。这个操作符用于将整数右移若干位，但对于其他各种数据类型有不同的含义。'
- en: The `Shr` trait has both an `Output` associated type, and the option of implementing
    it to operate on different types by implementing `Shr<OtherType>` rather than
    just `Shr`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shr` 特性既有 `Output` 关联类型，也有通过实现 `Shr<OtherType>` 而不是仅仅 `Shr` 来操作不同类型的选项。'
- en: '`ShrAssign` has the same relationship to `Shr` that `AddAssign` has to `Add`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShrAssign` 与 `Shr` 的关系类似于 `AddAssign` 与 `Add` 的关系。'
- en: Traits that are implemented automatically
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动实现的特性
- en: There are a few traits that are automatically implemented where appropriate,
    without even a `#[derive()]` tag. These tend to represent extremely low-level
    aspects of the data types in question.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特性在适当的情况下会自动实现，甚至不需要 `#[derive()]` 标签。这些通常代表数据类型极其低级方面的特性。
- en: Sync
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sync
- en: The `Sync` trait is automatically applied to any data type that can safely be
    borrowed between threads.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sync` 特性会自动应用于任何可以在线程之间安全借用数据的数据类型。'
- en: While our data types will have the `Sync` trait automatically if they qualify
    for it, occasionally we want to be sure that a data type *does not* have `Sync`,
    even if it looks to the compiler like it should.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的数据类型如果符合条件会自动具有 `Sync` 特性，但有时我们想要确保数据类型**不**具有 `Sync`，即使它看起来对编译器来说应该是这样的。
- en: 'We can achieve that by implementing `!Sync` for our data type:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为我们的数据类型实现 `!Sync` 来实现这一点：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We don't actually need any functions inside of `!Sync`. All we're doing is telling
    the compiler that the `Sync` trait is inappropriate for this type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不需要在 `!Sync` 中实现任何函数。我们只是在告诉编译器 `Sync` 特性对于这个类型来说是不合适的。
- en: As of Rust 1.29, implementing `!Sync` is still considered an unstable feature,
    and is not available in the stable build of the compiler. It can be enabled in
    the nightly build by placing `#![feature(optin_builtin_traits)]` at the top of
    the file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Rust 1.29 版本，实现 `!Sync` 仍然被视为一个不稳定特性，并且不在编译器的稳定构建中可用。它可以通过在文件顶部放置 `#![feature(optin_builtin_traits)]`
    来在夜间构建中启用。
- en: A lot of data types have the `Sync` trait, but `Rc`, `Cell`, and `RefCell` are
    notable examples of types that do not. `Arc`, `Mutex`, and `RwLock` do, though.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据类型都有 `Sync` 特性，但 `Rc`、`Cell` 和 `RefCell` 是不具该特性的类型中的显著例子。`Arc`、`Mutex` 和
    `RwLock` 则具有。
- en: Send
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Send
- en: The `Send` trait is automatically applied to any data type that can safely be
    moved between threads. It is a close relative of `Sync`, and like `Sync`, we can
    implement `!Send` to tell the compiler that a data type should *not* have the
    trait.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Send` 特性会自动应用于任何可以在线程之间安全移动的数据类型。它是 `Sync` 的一个近亲，并且像 `Sync` 一样，我们可以实现 `!Send`
    来告诉编译器一个数据类型**不应该**具有该特性。'
- en: If we don't explicitly forbid it, the compiler decides whether a type has the
    `Send` trait based on whether the types it contains have the trait.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有明确禁止，编译器会根据它包含的类型是否具有该特性来决定一个类型是否具有 `Send` 特性。
- en: Sized
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sized
- en: The `Sized` trait is automatically applied to any data type for which the size
    is known by the compiler. All trait bounds automatically include `Sized` as an
    additional, implicit requirement, unless we instead tell it that `?Sized` is the
    requirement. If we explicitly declare a trait bound is `?Sized`, that means that
    the data type that matches the bound is allowed to be `Sized`, but not required.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译器已知大小的任何数据类型，`Sized` 特性都会自动应用。所有特性界限都会自动包含 `Sized` 作为额外的、隐含的要求，除非我们明确告诉它
    `?Sized` 是要求。如果我们明确声明特性界限是 `?Sized`，这意味着符合界限的数据类型允许是 `Sized`，但不是必须的。
- en: Fn
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fn
- en: The `Fn` trait is automatically applied to any function or closure that uses
    only immutable borrows to access data outside its own scope.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fn` 特性会自动应用于任何只使用不可变借用访问其自身作用域之外数据的函数或闭包。'
- en: This is a strict requirement, and many functions and closures fail that test,
    so `Fn` is the least common of the function traits.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个严格的要求，许多函数和闭包都未能通过这个测试，所以 `Fn` 是函数特性中最不常见的。
- en: FnMut
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FnMut
- en: The `FnMut` trait is automatically applied to any function or closure that uses
    mutable or immutable borrows to access data outside its own scope.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`FnMut` 特性会自动应用于任何使用可变或不可变借用访问其自身作用域之外数据的函数或闭包。'
- en: This is a moderate requirement, but some functions and closures fail that test,
    so `FnMut` is more common than `Fn`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个中等要求，但一些函数和闭包未能通过这个测试，所以 `FnMut` 比较常见于 `Fn`。
- en: FnOnce
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FnOnce
- en: The `FnOnce` trait is automatically applied to any function that uses mutable
    borrows, immutable borrows, or moved variables to access data outside its own
    scope.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`FnOnce`特质会自动应用于任何使用可变借用、不可变借用或移动变量来访问其作用域外数据的函数。'
- en: The is a loose requirement, which any function or closure will satisfy, so `FnOnce`
    is the most common of the function traits.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个宽松的要求，任何函数或闭包都会满足，因此`FnOnce`是函数特质的常见类型。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have done the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们做了以下工作：
- en: Looked at many different traits
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究了许多不同的特质
- en: Examined the traits' specific meanings and how they interact with syntax of
    Rust
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查了特质的特定含义以及它们如何与Rust的语法交互
- en: Learned about the details of implementing the traits
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了实现特质的细节
- en: Learned how to easily derive traits that support that feature
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了如何轻松推导支持该特性的特质
- en: We've reached the end of this quick start guide, but the journey is never over.
    Good luck on your next steps.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了快速入门指南的结尾，但旅程永远不会结束。祝你在下一步好运。
