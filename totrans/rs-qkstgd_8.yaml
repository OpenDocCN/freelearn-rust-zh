- en: Important Standard Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen already, traits are an important part of the Rust ecosystem. The
    traits that are built into the Rust standard library affect many things, including
    even what operators can be used on a particular data value. In this chapter, we're
    going to review many of these traits, and see how to implement them on our own
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at an assortment of traits defined by the Rust standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the meanings and implications of those traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about what traits are applied automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use the `derive` command to generate trait implementations for
    select traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to manually implement the remaining traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits that can be derived
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some traits, the compiler itself knows how to implement them for a type.
    If we want them, we only have to tell it that we do, and it will take care of
    the rest for us.
  prefs: []
  type: TYPE_NORMAL
- en: We still have the option of manually implementing derivable traits, but that
    would usually just be a waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: Telling the compiler that we want a data type to have a derivable trait is easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''re telling it that we want our `CopyExample` enumeration to implement
    `Copy` and `Clone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A trait can only be derived if the people who created the trait were able to
    write a program to generate the trait implementation. When we write `#[derive(Copy,
    Clone)]`, we're telling the compiler to go find those programs for deriving `Copy`
    and `Clone` in the source code of the packages where the traits were defined,
    and run those programs to generate the source code for the trait implementations
    before it continues compiling. If the decisions that need to be made to implement
    a trait are too complex for a program to make without user input, the trait can't
    be derived.
  prefs: []
  type: TYPE_NORMAL
- en: Clone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Clone` trait means that it is possible to make an explicit copy of a data
    value. The compiler won't ever do it automatically, but when we want to copy a
    value, we can do so by calling its `Clone` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deriving the `Clone` trait looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Copy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Copy` trait means that creating a copy of the data value is just a matter
    of copying the bits that make up its representation. If the data value contains
    any borrows or uses heap memory, it can't have the `Copy` trait.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will automatically copy data values that have the `Copy` trait
    when it would have otherwise moved them.
  prefs: []
  type: TYPE_NORMAL
- en: Since anything that has the `Copy` trait can certainly be duplicated on request
    as well, `Copy` requires `Clone` to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deriving `Copy` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Debug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Debug` trait tells Rust how to format the data value for debugging output.
    One place this is used is if we use `{:?}` instead of `{}` as the substitution
    marker for the data value in `println!` or `print!`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the debugging representation of a data value should be pretty close to
    the way it would be represented in the source code, Rust is able to derive it
    for us automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deriving `Debug` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: PartialEq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `PartialEq` trait represents the ability to compare the data value with
    another one to determine whether they are equal. It does *not* imply that a value
    is considered equal to itself, however.
  prefs: []
  type: TYPE_NORMAL
- en: The `PartialEq` trait is used by the compiler to implement the `==` comparison
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point numbers are the classic example of a data type that has `PartialEq`,
    because the floating point representation of a `NaN` or `Not a Number` value is
    not considered equal to itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deriving `PartialEq` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, that derivation only compares two `PartialEqSelf` data values. If we
    want to enable an equality comparison with data values of other types, we need
    to implement the trait manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have a manual implementation of the trait, enabling comparison with
    the `u32` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've arranged for the `PartialEqU32::Good` value to compare as equal
    to even number `u32`s, and `PartialEqU32::Bad` to compare equal to odd number
    `u32`.
  prefs: []
  type: TYPE_NORMAL
- en: Eq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Eq` trait means the same thing that `PartialEq` does, *except* that a data
    value is always equal to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the `Eq` trait requires implementing the `PartialEq` trait as well,
    and the only thing it does beyond what `PartialEq` does is provide the compiler
    with the hint that it doesn't need to bother running the `Eq` function when both
    sides of the comparison are the same data value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deriving `Eq` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: PartialOrd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `PartialOrd` trait represents the ability to define some sort of ordering
    between two data values, so we can say one of them is less than the other, or
    greater than the other, or that they're the same, *or* that the ordering relation
    does not apply to these values. That last one is the reason why this is a *partial*
    ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Since *they're the same* is a valid result of the comparison, implementing `PartialOrd`
    requires the implemention of `PartialEq`.
  prefs: []
  type: TYPE_NORMAL
- en: As with `PartialEq`, we can derive an implementation that compares two data
    values of the same type, but we can also manually implement the trait to allow
    comparison with data of different types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the automatic derivation of the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have implemented it manually to support comparison with a different
    data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're telling Rust that a `PartialOrdU32::Good` value is always greater
    than any `u32` value, but a `PartialOrdU32::Bad` value does not have any relation
    to any `u32` value at all.
  prefs: []
  type: TYPE_NORMAL
- en: Ord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Ord` is like `PartialOrd`, except that it doesn''t allow the option of returning
    a "no relation" value; for any pair of values, either they are equal, or one is
    less than the other.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ord` is used by the compiler to implement the `<` (less than), `>` (greater
    than), `<=` (less than or equal), and `>=` (greater than or equal) comparison
    operators.'
  prefs: []
  type: TYPE_NORMAL
- en: If a data type has the `Ord` trait, it has to also have the `PartialOrd`, `Eq`,
    and `PartialEq` traits. Like those traits, it can be manually implemented to enable
    comparisons between different data types, but we have to be very careful that
    the results returned by the various functions that are used to implement those
    traits agree with each other. When we derive the traits, we don't have to worry
    about that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of deriving `Ord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Hash` trait enables a data value to be used as a key in several of Rust's
    standard library data structures, such as `HashMap` and `HashSet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deriving the `Hash` trait looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While `Eq` and `PartialEq` are not actually required to implement `Hash`, if
    they are implemented, they need to agree with it, which is to say that if two
    values are equal, their hash values should also be equal. The automatically generated
    implementations have this property, so we only need to worry about it if we're
    doing manual implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Default
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the `Default` trait is implemented for a type, it makes it possible for
    us to request a default value for that type of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we derive `Default` for a data type, it sets the default value for that
    type to be made up of the default values for all of the contained data types,
    so when we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What we're doing is setting the default for the `DefaultExample` type to be
    a `DefaultExample` containing the default values of a `String` and an `i32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can request a default value like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Traits that enable operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the operators and the special syntax of Rust are backed up by traits,
    which tell the compiler how to perform the operation on the specific data type
    it's looking at. We've seen some of those already, but many of them can't be derived,
    so if we want to enable that syntax for our data types, we need to implement them
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: ​Add, Mul, Sub, and Div
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Add`, `Mul`, `Sub`, and `Div` traits represent the ability to add, multiply,
    subtract, or divide two values. These traits are used by the compiler to implement
    the `+`, `*`, `-`, and `/` operators.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that if the values of `self` and `other` do not have the `Copy` trait,
    they are moved into the implementation function and consumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these traits follow the same pattern, so here''s an example implementation
    of `Add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Mul`, `Sub`, and `Div` follow the same pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: What we've defined here is a very primitive form of counting, that considers
    any number greater than 3 to be "many".
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `impl` block, we have `type Output = AddExample;`. That's a bit of
    new syntax we haven't seen before. What we're doing is setting the `Output` *associated
    type* for this implementation, which is fed back into the trait definition to
    be used in declaring the signature of the `add` function. After all, we're returning
    an `AddExample` here, and there was no such type when the trait was originally
    defined. That's not a problem, though, because the trait says that the `add` function
    returns a data value of type `Output`, and we've just told it that `Output` is
    an alias for `AddExample`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also implement adding data of two different types together, by implementing
    `Add<OtherType> for OneType` to represent the ability to have a `OneType` value
    on the left side of the `+` and an `OtherType` value on the right, similarly to
    the way we were able to create comparisons between two different types earlier
    in the chapter. The same trick works for `Mul`, `Sub`, and `Div` as well.
  prefs: []
  type: TYPE_NORMAL
- en: AddAssign, MulAssign, SubAssign, and DivAssign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These traits enable the `+=`, `*=`, `-=`, and `/=` operators for the types that
    implement them.
  prefs: []
  type: TYPE_NORMAL
- en: They are similar to the `Add`, `Sub`, `Mul`, and `Div` traits, with the difference
    that their implementation functions take `&mut self` instead of plain `self`.
    Instead of consuming their left-side input, they have the ability to change its
    contained value.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these traits follow the same pattern, so here''s an example implementation
    of `AddAssign`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the differences based on assigning the new value to `&mut self`,
    this is much like the implementation of the `add` function for the `Add` trait,
    which isn't very surprising.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, while it doesn't consume its `self`, it does still consume the
    value on the right-hand side of the operand, assuming that value doesn't have
    the `Copy` trait.
  prefs: []
  type: TYPE_NORMAL
- en: BitAnd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BitAnd` trait enables the `&` operator for types that implement it. This
    operator is used for computing the *bitwise and* value of two integers (hence
    the name), but has different meanings for various other data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `BitAnd` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: BitAndAssign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BitAndAssign` trait enables the `&=` operator for data types that implement
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `BitAndAssign` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: BitOr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BitOr` trait enables the `|` operator for types that implement it. This
    operator is used for computing the *bitwise or* value of two integers, but has
    different meanings for various other data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `BitOr` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: BitOrAssign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BitOrAssign` trait enables the `|=` operator for data types that implement
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `BitOrAssign` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: BitXor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BitXor` trait enables the `^` operator for types that implement it. This
    operator is used for computing the *bitwise exclusive or* value of two integers,
    but has different meanings for various other data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `BitXor` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: BitXorAssign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BitXorAssign` trait enables the `^=` operator for data types that implement
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `BitXorAssign` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Deref
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Deref` trait grants the ability to dereference a value as if it were a
    borrow. Smart pointers implement this trait, which is why they can be used as
    though they were borrows of the contained data value. `String` does the same thing,
    which is what allows us to use a `String` value anywhere that an `&str` is expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have an implementation of the `Deref` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the implementation function doesn't actually dereference anything.
    Instead, it converts an `&self` borrow into a borrow of something else.
  prefs: []
  type: TYPE_NORMAL
- en: That's what the compiler needs in order to correctly and efficiently handle
    dereferencing smart pointers and such, but the compiler also uses that ability
    to let us interact with something like a `Rc<Box<String>>` as if it were just
    a plain old `&str`. The `Rc` has a `deref` function that returns a borrow of a
    `Box`, and the `Box` has a `deref` function that returns a  borrow of a `String`,
    and the `String` has a `deref` function that returns a borrow of a `str`, so the
    compiler lets us treat the whole thing as if it was an `&str` for the purposes
    of calling its functions or using it as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: DerefMut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DerefMut` trait does the same thing `Deref` does, but it is used when derefencing
    a mutable value. The compiler decides whether to use `Deref` or `DerefMut`, so
    usually when we need to implement one, we need to implement them both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have an implementation of `DerefMut`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `DerefMut` trait requires that the `Deref` trait is also implemented, and
    that the `deref` and `deref_mut` functions have the same return type.
  prefs: []
  type: TYPE_NORMAL
- en: Drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a data type has the `Drop` trait, the program will call the `drop` function
    for values of that type immediately before their lifetimes end. That's how `Rc`,
    `Mutex`, `RefCell`, and so on are able to keep track of how many borrows their
    contained value has.
  prefs: []
  type: TYPE_NORMAL
- en: The `drop` function is called before the data value's lifetime ends, so we don't
    have to worry about it being an invalid reference. Also, we don't have to worry
    about manually cleaning up the contained values for our data type, because they
    will be automatically dropped themselves after our `drop` function is finished.
    All we need to do is handle whatever special case led us to implement `Drop` in
    the first place.
  prefs: []
  type: TYPE_NORMAL
- en: We can't directly call the `drop` function, because that would be an extremely
    good way to make a mess. There is a `std::mem::drop` function we can use that
    consumes a data value and drops it for us, if we need to trigger this at a specific
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `Drop` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Index` trait means that the data type can be used with the `x[y]` syntax,
    where a value is looked up inside of `x` based on the *index value* `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we implement `Index`, we need to identify what data type can be used for
    the index value, as well as what data type the operation returns, so the implementation
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We've used `&str` for the data type of the index, and were using `u32` for the
    data type of the value. Using `&str` means that we need to be a little bit careful
    of lifetimes, but it's not too bad.
  prefs: []
  type: TYPE_NORMAL
- en: IndexMut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `IndexMut` trait represents the abilities to assign to a contained value
    using the `x[y] = z` syntax. Like the `Index` trait, it lets us look up a contained
    data value by providing an index value, but it produces a mutable borrow of the
    contained value, which can be used to change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `IndexMut` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've added a `junk` value to the `IndexExample` structure. We did
    that because there's no way to indicate that an index value doesn't map to a valid
    contained value; if the `index_mut` function gets called, is *has* to return a
    mutable borrow of the correct type, and that borrow has to have a long enough
    lifetime as well. Adding a junk value to the data structure is a simple way of
    achieving that, though there are other approaches that would save memory.
  prefs: []
  type: TYPE_NORMAL
- en: Any type that implements `IndexMut` has to implement `Index` as well, and the
    `index` and `index_mut` functions have to return a borrow and a mutable borrow
    of the same data type, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Neg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Neg` trait enables a data type to be used with the *unary negation* operator,
    also known as the negative sign. When we write `-5`, we're applying the unary
    negation operator to the value 5, producing a negative 5 as the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `Neg` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Not
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Not` trait enables the *logical negation* operator, which is written as
    an `!`. `Not` is both conceptually and practically similar to `Neg`, but its primary
    use is for Boolean logic rather than arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `Not` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Rem and RemAssign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Rem` trait enables the `%` operator for types that implement it. This operator
    is used for computing the *modulus* (also known as the remainder of a division) value
    of two integers, but has different meanings for various other data types.
  prefs: []
  type: TYPE_NORMAL
- en: The `Rem` trait has both an `Output` associated type, and the option of implementing
    it to operate on different types by implementing `Rem<OtherType>` rather than
    just `Rem`.
  prefs: []
  type: TYPE_NORMAL
- en: '`RemAssign` has the same relationship to `Rem` that `AddAssign` has to `Add`.'
  prefs: []
  type: TYPE_NORMAL
- en: Shl and ShlAssign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Shl` trait enables the `<<` operator for types that implement it. This
    operator is used for *left-shifting* an integer by a number of bits, but has different
    meanings for various other data types.
  prefs: []
  type: TYPE_NORMAL
- en: The `Shl` trait has both an output associated type, and the option of implementing
    it to operate on different types by implementing `Shl<OtherType>` rather than
    just `Shl`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ShlAssign` has the same relationship to `Shl` that `AddAssign` has to `Add`.'
  prefs: []
  type: TYPE_NORMAL
- en: Shr and ShrAssign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Shr` trait enables the `>>` operator for types that implement it. This
    operator is used for *right-shifting* an integer by a number of bits, but has
    different meanings for various other data types.
  prefs: []
  type: TYPE_NORMAL
- en: The `Shr` trait has both an `Output` associated type, and the option of implementing
    it to operate on different types by implementing `Shr<OtherType>` rather than
    just `Shr`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ShrAssign` has the same relationship to `Shr` that `AddAssign` has to `Add`.'
  prefs: []
  type: TYPE_NORMAL
- en: Traits that are implemented automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few traits that are automatically implemented where appropriate,
    without even a `#[derive()]` tag. These tend to represent extremely low-level
    aspects of the data types in question.
  prefs: []
  type: TYPE_NORMAL
- en: Sync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Sync` trait is automatically applied to any data type that can safely be
    borrowed between threads.
  prefs: []
  type: TYPE_NORMAL
- en: While our data types will have the `Sync` trait automatically if they qualify
    for it, occasionally we want to be sure that a data type *does not* have `Sync`,
    even if it looks to the compiler like it should.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve that by implementing `!Sync` for our data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We don't actually need any functions inside of `!Sync`. All we're doing is telling
    the compiler that the `Sync` trait is inappropriate for this type.
  prefs: []
  type: TYPE_NORMAL
- en: As of Rust 1.29, implementing `!Sync` is still considered an unstable feature,
    and is not available in the stable build of the compiler. It can be enabled in
    the nightly build by placing `#![feature(optin_builtin_traits)]` at the top of
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of data types have the `Sync` trait, but `Rc`, `Cell`, and `RefCell` are
    notable examples of types that do not. `Arc`, `Mutex`, and `RwLock` do, though.
  prefs: []
  type: TYPE_NORMAL
- en: Send
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Send` trait is automatically applied to any data type that can safely be
    moved between threads. It is a close relative of `Sync`, and like `Sync`, we can
    implement `!Send` to tell the compiler that a data type should *not* have the
    trait.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't explicitly forbid it, the compiler decides whether a type has the
    `Send` trait based on whether the types it contains have the trait.
  prefs: []
  type: TYPE_NORMAL
- en: Sized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Sized` trait is automatically applied to any data type for which the size
    is known by the compiler. All trait bounds automatically include `Sized` as an
    additional, implicit requirement, unless we instead tell it that `?Sized` is the
    requirement. If we explicitly declare a trait bound is `?Sized`, that means that
    the data type that matches the bound is allowed to be `Sized`, but not required.
  prefs: []
  type: TYPE_NORMAL
- en: Fn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Fn` trait is automatically applied to any function or closure that uses
    only immutable borrows to access data outside its own scope.
  prefs: []
  type: TYPE_NORMAL
- en: This is a strict requirement, and many functions and closures fail that test,
    so `Fn` is the least common of the function traits.
  prefs: []
  type: TYPE_NORMAL
- en: FnMut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FnMut` trait is automatically applied to any function or closure that uses
    mutable or immutable borrows to access data outside its own scope.
  prefs: []
  type: TYPE_NORMAL
- en: This is a moderate requirement, but some functions and closures fail that test,
    so `FnMut` is more common than `Fn`.
  prefs: []
  type: TYPE_NORMAL
- en: FnOnce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FnOnce` trait is automatically applied to any function that uses mutable
    borrows, immutable borrows, or moved variables to access data outside its own
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: The is a loose requirement, which any function or closure will satisfy, so `FnOnce`
    is the most common of the function traits.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Looked at many different traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examined the traits' specific meanings and how they interact with syntax of
    Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned about the details of implementing the traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to easily derive traits that support that feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've reached the end of this quick start guide, but the journey is never over.
    Good luck on your next steps.
  prefs: []
  type: TYPE_NORMAL
