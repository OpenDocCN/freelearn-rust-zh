["```rs\n[0, 1, 2, 3, 4]\n```", "```rs\n[0, 1, 2, 3, 4]\n```", "```rs\n---------------\n```", "```rs\n[0, 2, 4, 6, 8]\n```", "```rs\nimport time\n```", "```rs\nimport numpy as np\n```", "```rs\nimport matplotlib.pyplot as plt\n```", "```rs\ndef numpy_function(total_vector_size: int) -> float:\n```", "```rs\n    t1 = time.time()\n```", "```rs\n    first_vector = np.arange(total_vector_size)\n```", "```rs\n    second_vector = np.arange(total_vector_size)\n```", "```rs\n    sum_vector = first_vector + second_vector\n```", "```rs\n    return time.time() - t1\n```", "```rs\nnumpy_results = [numpy_function(i) for i in range(0 \\ \n```", "```rs\n  10000)]\n```", "```rs\nplt.plot(numpy_results, linestyle='dashdot')\n```", "```rs\nplt.show()\n```", "```rs\ndef python_function(total_vector_size: int) -> float:\n```", "```rs\n    t1 = time.time()\n```", "```rs\n    first_vector = range(total_vector_size)\n```", "```rs\n    second_vector = range(total_vector_size)\n```", "```rs\n    sum_vector = [first_vector[i] + second_vector[i] for \\\n```", "```rs\n      i in range(len(second_vector))]\n```", "```rs\n    return time.time() - t1\n```", "```rs\nprint(python_function(1000))\n```", "```rs\nprint(numpy_function(1000))\n```", "```rs\npython_results = [python_function(i) for i in range(0, \\\n```", "```rs\n  10000)]\n```", "```rs\nnumpy_results = [numpy_function(i) for i in range(0, \\\n```", "```rs\n  10000)]\n```", "```rs\nplt.plot(python_results, linestyle='solid')\n```", "```rs\nplt.plot(numpy_results, linestyle='dashdot')\n```", "```rs\nplt.show()\n```", "```rs\n    #[pyfunction]\n    fn time_add_vectors(total_vector_size: i32)\n        -> Vec<i32> {    \n        let mut buffer: Vec<i32> = Vec::new();\n        let first_vector: Vec<i32> = \n          (0..total_vector_size.clone()\n             ).map(|x| x).collect();\n        let second_vector: Vec<i32> = \\\n          (0..total_vector_size\n             ).map(|x| x).collect();\n\n        for i in &first_vector {\n            buffer.push(first_vector[**&i as usize] + \n                         second_vector[*i as usize]);\n        }\n       return buffer\n    }\n    ```", "```rs\n    #[pymodule]\n    fn flitton_fib_rs(_py: Python, m: &PyModule) -> \\\n      PyResult<()> {\n        . . .\n        m.add_wrapped(wrap_pyfunction!(time_add_vectors));\n        . . .\n        Ok(())\n    }\n    ```", "```rs\n    import time\n    import matplotlib.pyplot as plt\n    import numpy as np\n    from flitton_fib_rs import time_add_vectors\n    ```", "```rs\n    def rust_function(total_vector_size: int) -> float:\n        t1 = time.time()\n        sum_vector = time_add_vectors(total_vector_size)\n        result = time.time() - t1\n        if result > 0.00001:\n            result = 0.00001\n        return result\n    ```", "```rs\n    def numpy_function(total_vector_size: int) -> float:\n        t1 = time.time()\n        first_vector = np.arange(total_vector_size)\n        second_vector = np.arange(total_vector_size)\n        sum_vector = first_vector + second_vector\n        result = time.time() - t1\n        if result > 0.00001:\n            result = 0.00001\n        return result\n    ```", "```rs\n    def python_function(total_vector_size: int) -> float:\n        t1 = time.time()\n        first_vector = range(total_vector_size)\n        second_vector = range(total_vector_size)\n        sum_vector = [first_vector[i] + second_vector[i] for\n          i in range(len(second_vector))]\n        result = time.time() - t1\n        if result > 0.0001:\n            result = 0.0001\n        return result\n    ```", "```rs\n    numpy_results = [numpy_function(i) for i in range(0, \\ \n      300)]\n    rust_results = [rust_function(i) for i in range(0, \\\n      300)]\n    python_results = [python_function(i) for i in range \\\n      (0,300)]\n    plt.plot(rust_results, linestyle='solid', \\\n      color=\"green\")\n    plt.plot(python_results, linestyle='solid', \\\n     color=\"red\")\n    plt.plot(numpy_results, linestyle='solid', \\\n    color=\"blue\")\n    plt.show()\n    ```", "```rs\nimport numpy as np\n```", "```rs\nclass MatrixModel:\n```", "```rs\n    @property\n```", "```rs\n    def weights_matrix(self) -> np.array:\n```", "```rs\n        return np.array([\n```", "```rs\n            [3, 2],\n```", "```rs\n            [1, 4]\n```", "```rs\n        ])\n```", "```rs\n>>> import numpy as np\n```", "```rs\n>>> t = np.array([\n```", "```rs\n                [3, 2],\n```", "```rs\n                [1, 4]\n```", "```rs\n            ])\n```", "```rs\n>>> t.transpose()\n```", "```rs\narray([[3, 1],\n```", "```rs\n       [2, 4]])\n```", "```rs\n>>> x = np.array([\n```", "```rs\n                    [3],\n```", "```rs\n                    [1]\n```", "```rs\n                ])\n```", "```rs\n>>> x.transpose()\n```", "```rs\narray([[3, 1]])\n```", "```rs\n    def calculate_times(self, distance: int, \\\n```", "```rs\n      traffic_grade: int) -> dict:\n```", "```rs\n        inputs = np.array([\n```", "```rs\n            [distance],\n```", "```rs\n            [traffic_grade]\n```", "```rs\n        ])\n```", "```rs\n        result = np.dot(self.weights_matrix, inputs)\n```", "```rs\n        return {\n```", "```rs\n            \"car time\": result[0][0],\n```", "```rs\n            \"truck time\": result[1][0]\n```", "```rs\n        }\n```", "```rs\n    def calculate_parameters(self, car_time: int, \n```", "```rs\n                             truck_time: int) -> dict:\n```", "```rs\n        inputs = np.array([\n```", "```rs\n            [car_time],\n```", "```rs\n            [truck_time]\n```", "```rs\n        ])\n```", "```rs\n        result = np.dot(np.linalg.inv(self. \\\n```", "```rs\n          weights_matrix), inputs)\n```", "```rs\n        return {\n```", "```rs\n            \"distance\": result[0][0],\n```", "```rs\n            \"traffic grade\": result[1][0]\n```", "```rs\n        }\n```", "```rs\ntest = MatrixModel()\n```", "```rs\ntimes = test.calculate_times(distance=10, traffic_grade=3)\n```", "```rs\nprint(f\"here are the times: {times}\")\n```", "```rs\nparameters = test.calculate_parameters(\n```", "```rs\n    car_time=times[\"car time\"], truck_time=times[\"truck \\\n```", "```rs\n      time\"]\n```", "```rs\n)\n```", "```rs\nprint(f\"here are the parameters: {parameters}\")\n```", "```rs\n{'car time': 36, 'truck time': 22}\n```", "```rs\n{'distance': 10.0, 'traffic grade': 3.0}\n```", "```rs\n    use pyo3::types::PyDict;\n    ```", "```rs\n    #[pyfunction]\n    fn test_numpy<'a>(result_dict: &'a PyDict) \n                -> PyResult<&'a PyDict> {\n        let gil = Python::acquire_gil();\n        let py = gil.python();\n        let locals = PyDict::new(py);\n        locals.set_item(\"np\", \n          py.import(\"numpy\").unwrap());\n    }\n    ```", "```rs\n        let code = \"np.array([[3, 2], [1, 4]])\";\n        let weights_matrix = py.eval(code, \n                               None, \n                               Some(&locals)).unwrap();\n        locals.set_item(\"weights_matrix\", weights_matrix);\n    ```", "```rs\n        let new_code = \"np.array([[10], [20]])\";\n        let input_matrix = py.eval(new_code, None, \n                                  Some(&locals)).unwrap();\n        locals.set_item(\"input_matrix\", input_matrix);\n    ```", "```rs\n        let calc_code = \"np.dot(weights_matrix, \\\n           input_matrix)\";\n        let result_end = py.eval(calc_code, None, \n                                 Some(&locals)).unwrap();\n        result_dict.set_item(\"numpy result\", result_end);\n        return Ok(result_dict)\n    ```", "```rs\n>>> from flitton_fib_rs import test_numpy\n```", "```rs\n>>> outcome = test_numpy({})\n```", "```rs\n>>> outcome[\"numpy result\"].transpose()\n```", "```rs\narray([[70, 90]])\n```", "```rs\n    use pyo3::prelude::*;\n    use pyo3::types::PyDict;\n    ```", "```rs\n    fn get_weight_matrix(py: &Python, locals: &PyDict) \\\n      -> () {\n        let code: &str = \"np.array([[3, 2], [1, 4]])\";\n        let weights_matrix = py.eval(code, None, \n                             Some(&locals)).unwrap();\n        locals.set_item(\"weights_matrix\", weights_matrix);\n    }\n    ```", "```rs\n    fn invert_get_weight_matrix(py: &Python, \n                                locals: &PyDict) -> () {\n        let code: &str = \"np.linalg.inv(weights_matrix)\";\n        let inverted_weights_matrix = py.eval(code, None, \n                                  Some(&locals)).unwrap();\n        locals.set_item(\"inverted_weights_matrix\", \n                        inverted_weights_matrix);\n    }\n    ```", "```rs\n    fn get_input_vector(py: &Python, locals: &PyDict, \n                        first: i32, second: i32) -> () {\n        let code: String = format!(\"np.array([[{}], \\\n          [{}]])\", first, second);\n        let input_vector = py.eval(&code.as_str(), None, \n                           Some(&locals)).unwrap();\n        locals.set_item(\"input_vector\", input_vector);\n    }\n    ```", "```rs\n    fn get_times<'a>(py: &'a Python, \n                     locals: &PyDict) -> &'a PyAny {\n        let code: &str = \"np.dot(weights_matrix, \\\n          input_vector)\";\n        let times = py.eval(code, None, \n          Some(&locals)).unwrap();\n        return times\n    }\n    fn get_parameters<'a>(py: &'a Python, \n                         locals: &PyDict) -> &'a PyAny {\n        let code: &str = \"\n        np.dot(inverted_weights_matrix, input_vector)\";\n        let parameters = py.eval(code, None, \n                         Some(&locals)).unwrap();\n        return parameters\n    }\n    ```", "```rs\n#[pyfunction]\n```", "```rs\npub fn calculate_times<'a>(result_dict: &'a PyDict, \n```", "```rs\n    distance: i32, traffic_grade: i32) -> PyResult<&'a \\\n```", "```rs\n      PyDict> {\n```", "```rs\n    let gil = Python::acquire_gil();\n```", "```rs\n    let py = gil.python();\n```", "```rs\n    let locals = PyDict::new(py);\n```", "```rs\n    locals.set_item(\"np\", py.import(\"numpy\").unwrap());\n```", "```rs\n    get_weight_matrix(&py, locals);\n```", "```rs\n    get_input_vector(&py, locals, distance, traffic_grade);\n```", "```rs\n    result_dict.set_item(\"times\", get_times(&py, locals));\n```", "```rs\n    return Ok(result_dict)\n```", "```rs\n}\n```", "```rs\n#[pyfunction]\n```", "```rs\npub fn calculate_parameters<'a>(result_dict: &'a PyDict, \n```", "```rs\n    car_time: i32, truck_time: i32) -> PyResult<&'a PyDict> {\n```", "```rs\n    let gil = Python::acquire_gil();\n```", "```rs\n    let py = gil.python();\n```", "```rs\n    let locals = PyDict::new(py);\n```", "```rs\n    locals.set_item(\"np\", py.import(\"numpy\").unwrap());\n```", "```rs\n    get_weight_matrix(&py, locals);\n```", "```rs\n    invert_get_weight_matrix(&py, locals);\n```", "```rs\n    get_input_vector(&py, locals, car_time, truck_time);\n```", "```rs\n    result_dict.set_item(\"parameters\", \n```", "```rs\n        get_parameters(&py, locals));\n```", "```rs\n    return Ok(result_dict)\n```", "```rs\n}\n```", "```rs\n    mod numpy_model;\n    ```", "```rs\n    use numpy_model::__pyo3_get_function_calculate_times;\n    use numpy_model::__pyo3_get_function_calculate_ \\\n      parameters;\n    ```", "```rs\n    #[pymodule]\n    fn flitton_fib_rs(_py: Python, m: &PyModule) -> \\\n      PyResult<()> {\n        . . . \n        m.add_wrapped(wrap_pyfunction!(calculate_times));\n        m.add_wrapped(wrap_pyfunction!(calculate_parameters));\n        . . . \n    }\n    ```", "```rs\n        requirements=[\n            \"pyyaml>=3.13\",\n            \"numpy\"\n        ]\n    ```", "```rs\nfrom .flitton_fib_rs import calculate_times, \\\n```", "```rs\ncalculate_parameters\n```", "```rs\nclass NumpyInterface:\n```", "```rs\n    def __init__(self):\n```", "```rs\n        self.inventory = {}\n```", "```rs\n    def calc_times(self, distance, traffic_grade):\n```", "```rs\n        result = calculate_times({}, distance, \n```", "```rs\n                                 traffic_grade)\n```", "```rs\n        self.inventory[\"car time\"] = result[\"times\"][0][0]\n```", "```rs\n        self.inventory[\"truck time\"] = \\\n```", "```rs\n          result[\"times\"][1][0]\n```", "```rs\n    def calc_parameters(self, car_time, truck_time):\n```", "```rs\n        result = calculate_parameters({}, car_time, \n```", "```rs\n            truck_time)\n```", "```rs\n        self.inventory[\"distance\"] = \n```", "```rs\n                          result[\"parameters\"][0][0]\n```", "```rs\n        self.inventory[\"traffic grade\"] = \n```", "```rs\n                          result[\"parameters\"][1][0]\n```", "```rs\n>>> from flitton_fib_rs.numpy_interface import \n```", "```rs\nNumpyInterface\n```", "```rs\n>>> test = NumpyInterface()\n```", "```rs\n>>> test.calc_times(10, 20)\n```", "```rs\n>>> test.calc_parameters(70, 90)\n```", "```rs\n>>> test.inventory\n```", "```rs\n{'car time': 70, 'truck time': 90, \n```", "```rs\n 'distance': 9.999999999999998, \n```", "```rs\n 'traffic grade': 20.0}\n```", "```rs\n    let code = \"5 + 6\";\n    number should be 11. \n    ```"]