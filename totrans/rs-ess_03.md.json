["```rs\n// from Chapter 3/code/ifelse.rs\nfn main() {\n  let dead = false;\n  let health = 48;\n if dead {\n    println!(\"Game over!\");\n    return;\n  }\n if dead {\n    println!(\"Game over!\");\n    return;\n } else {\n    println!(\"You still have a chance to win!\");\n  }\n if health >= 50 {\n    println!(\"Continue to fight!\");\n } else if health >= 20  {\n    println!(\"Stop the battle and gain strength!\");\n } else {\n    println!(\"Hide and try to recover!\");\n  }\n}\n```", "```rs\nStop the battle and gain strength!\n\n```", "```rs\nlet active =\nif health >= 50 {\n     true\n} else {\n      false\n};\nprintln!(\"Am I active? {}\", active);\n```", "```rs\nAm I active? false\n\n```", "```rs\nlet adult = true;\nlet age = if adult { \"+18\" } else { \"-18\" };\nprintln!(\"Age is {}\", age);  // Age is +18\n```", "```rs\n    let result = if health <=0 { \"Game over man!\" };\n    ```", "```rs\n    fn verbose(x: i32) -> &'static str {\n      let mut result: &'static str;\n      if x < 10 {\n        result = \"less than 10\";\n      } else {\n        result = \"10 or more\";\n      }\n      return result;\n    }\n    ```", "```rs\n// from Chapter 3/code/loops.rs\nfn main() {\n  let max_power = 10;\n  let mut power = 1;\n while power < max_power {\n        print!(\"{} \", power); // prints without newline\n        power += 1;           // increment counter\n  }\n}\n```", "```rs\n1 2 3 4 5 6 7 8 9\n\n```", "```rs\nloop {\n  power += 1;\n  if power == 42 {\n    // Skip the rest of this iteration\n continue;\n  }\n  print!(\"{}  \", power);\n  if power == 50 {\n    print!(\"OK, that's enough for today\");\n break;  // exit the loop\n  }\n}\n```", "```rs\n  'outer: loop {\n        println!(\"Entered the outer dungeon - \");\n        'inner: loop {\n            println!(\"Entered the inner dungeon - \");\n            // break;    // this would break out of the inner loop\n            break 'outer; // breaks to the outer loop\n        }\n      println!(\"This treasure can sadly never be reached - \");\n  }\n  println!(\"Exited the outer dungeon!\");\n```", "```rs\nEntered the outer dungeon – \nEntered the inner dungeon - \nExited the outer dungeon!\n\n```", "```rs\nfor n in 1..11 { \n      println!(\"The square of {} is {}\", n, n * n);\n}\n```", "```rs\nlet mut x = 10;\nfor _ in 1 .. x { x -= 1; print!(\".\"); }\n```", "```rs\n// from Chapter 3/code/functions.rs\nfn main() {\n  let hero1 = \"Pac Man\";\n  let hero2 = \"Riddick\";\n greet(hero2);\n greet_both(hero1, hero2);\n}\n\nfn greet(name: &str) {\n println!(\"Hi mighty {}, what brings you here?\", name);\n}\n\nfn greet_both(name1: &str, name2: &str) {\n  greet(name1);\n  greet(name2);\n}\n```", "```rs\nHi mighty Riddick, what brings you here?\nHi mighty Pac Man, what brings you here?\nHi mighty Riddick, what brings you here?\n\n```", "```rs\nfn increment_power(power: i32) -> i32 {\n println!(\"My power is going to increase:\");\n power + 1\n}\n\nfn main() {\n let power = increment_power(1); // function is called\n  println!(\"My power level is now: {}\", power);}\n}\n```", "```rs\nMy power is going to increase:\nI am now at power level: 2\n\n```", "```rs\nif power < 100 { return 999; }\n```", "```rs\nif power < 100 { 999 }\n```", "```rs\nfn abs(x: i32) -> i32 {\n  if x > 0 {\n    x\n  } else {\n    -x\n  }\n}\n```", "```rs\nfn main() {\n  println!(\"The cube of 4 is {}\", cube(4));\n}\n/// Calculates the cube `val * val * val`.\n///\n/// # Examples\n///\n/// ```", "```rs\npub fn cube(val: u32) -> u32 {\n    val * val * val\n}\n```", "```rs` ```", "```rs`. For a function to be documented, it must be prefixed with `pub` so that it belongs to the public interface (see [Chapter 7](part0062.xhtml#aid-1R42S2 \"Chapter 7. Organizing Code and Macros\"), *Organizing Code and Macros*). For more information on this, go to [http://doc.rust-lang.org/book/documentation.html](http://doc.rust-lang.org/book/documentation.html).\n\n# Attributes\n\nYou may have already seen examples of warnings within `#[ … ]` signs, such as `#[warn(unused_variables)]`, in compiler output. These are **attributes** that represent **metadata** information about the code and are placed right before an item (such as a function) about which they have something to say. They can, for example, disable certain classes of warnings, turn on certain compiler features, or mark functions as being part of unit-tests or benchmark code.\n\n## Conditional compilation\n\nIf you want to make a function that only works on a specific operating system then annotate it with the `#[cfg(target_os = \"xyz\")]` attribute (where `xyz` can be either `windows`, `macos`, `linux`, `android`, `freebsd`, `dragonfly`, `bitrig`, or `openbsd`). For example, the following code works fine and runs on Windows:\n\n```", "```rs\n\nThis produces the output, **This machine has Windows as its OS**. If we try to build this code on a Linux machine, we get the **error: unresolved name `on_windows`** error, as the code does not build on Linux because the attribute prevents it from doing so!\n\nFurthermore, you can even make your own custom conditions; go to [http://rustbyexample.com/attribute/cfg/custom.html](http://rustbyexample.com/attribute/cfg/custom.html) for more information on this.\n\nAttributes are also used when testing and benchmarking code.\n\n# Testing\n\nWe can prefix a function with the `#[test]` attribute to indicate that it is part of the unit tests for our application or library. We can then compile with `rustc --test program.rs`. This will replace the `main()` function with a test runner and show the result from the functions marked with `#[test]`. Have a look at the following code snippet:\n\n```", "```rs\n\nTest functions, such as `arithmetic()` in the example, are black boxes; they have no arguments or returns. When this program is run on the command line, it produces the following output:\n\n![Testing](img/image00178.jpeg)\n\nHowever, even if we change the test to `if 2 + 3 == 6`, the test passes! Try it out. It turns out that test functions always pass when their execution does not cause a crash (called a panic in Rust terminology), and it fails when it does panic. This is why testing (or debugging) uses the `assert_eq!` macro (or other similar macros):\n\n```", "```rs\n\nThis statement tests whether `power` has the value 2\\. If it does, nothing happens, but if `power` is different from 2, an exception occurs and the program panics with, **thread '<main>' panicked at 'assertion failed**.\n\nIn our first function, we will write the `assert_eq!(5, 2 + 3);` test that will pass. We can also write this as `assert!(2 + 3 == 5);` by using the `assert!` macro.\n\nA test fails when the function panics, as is the case with the following example:\n\n```", "```rs\n\nThis produces the following output:\n\n![Testing](img/image00179.jpeg)\n\nUnit test your functions by comparing the actual function result to the expected result with an `assert_eq!(actual, expected)` macro call. In a real project, the tests will be collected in a separate tests module. (Have a look at [Chapter 7](part0062.xhtml#aid-1R42S2 \"Chapter 7. Organizing Code and Macros\"), *Organizing Code and Macros*, for more information.)\n\n## Testing with cargo\n\nAn executable project, or a crate as it is called in Rust, needs to have a `main()` startup function, but a library crate, to be used in other crates, does not need a `main()` function. Create a new `mylib` library crate with cargo as `cargo new mylib`.\n\nThis creates a `src` subfolder with a `lib.rs` source file that contains the following code:\n\n```"]