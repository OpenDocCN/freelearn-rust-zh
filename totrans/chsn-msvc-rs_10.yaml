- en: Background Tasks and Thread Pools in Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的后台任务和线程池
- en: In this chapter, you'll learn how to use background tasks in microservices.
    In [Chapter 5](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml), *Understanding Asynchronous
    Operations with the Futures Crate,* we created a microservice that provides a
    feature that enables the user to upload images. Now, we'll create another version
    of this service, which loads an image and returns a resized version of that image.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在微服务中使用后台任务。在[第5章](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml)，*使用Futures
    Crate理解异步操作*中，我们创建了一个提供用户上传图像功能的微服务。现在，我们将创建这个服务的另一个版本，该版本加载一个图像并返回该图像的缩放版本。
- en: To utilize the available resources fully, microservices have to be implemented
    with asynchronous code, but not every part of a microservices can be asynchronous.
    For example, parts that require massive CPU load or parts that have to use shared
    resources should be implemented in a separate thread or use a pool of threads
    to avoid blocking the main threads that are used to process the event loops used
    by asynchronous code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用可用资源，微服务必须使用异步代码实现，但微服务的每个部分并不都可以异步。例如，需要大量CPU负载的部分或必须使用共享资源的部分应该在一个单独的线程中实现，或者使用线程池来避免阻塞用于处理异步代码事件循环的主线程。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: How to interact with spawned threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与生成的线程交互
- en: How to use the `futures-cpupool` and `tokio-threadpool`crates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`futures-cpupool`和`tokio-threadpool`crate
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we'll improve the images microservice from [Chapter 5](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml), *Understanding
    Asynchronous Operations with the Futures Crate,* by adding an image-resizing feature.
    To compile the examples, you need the Rust compiler, version 1.31 or newer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过添加图像缩放功能来改进[第5章](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml)，*使用Futures
    Crate理解异步操作*中的图像微服务。要编译示例，你需要Rust编译器，版本1.31或更高。
- en: 'You can get the sources of the examples in this chapter from the project on
    GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter10).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub上的项目获取本章示例的源代码：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter10)。
- en: Interacting with threads
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与线程交互
- en: We'll first implement this using a separate thread that will resize all incoming
    images. After that, we'll improve the microservice with multiple threads using
    thread pools. In this section, we'll start to use threads to perform tasks in
    the background.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将使用一个单独的线程来实现这个功能，该线程将缩放所有传入的图像。之后，我们将使用线程池改进微服务。在本节中，我们将开始使用线程在后台执行任务。
- en: Synchronous or asynchronous?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步还是异步？
- en: In this book, we prefer to create asynchronous microservices, because these
    can handle a lot of concurrent requests. Not every task, however, can be handled
    in an asynchronous way. Whether we can use an asynchronous microservice depends
    on the kind of task and the resources it needs. Let's explore the difference further.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们更喜欢创建异步微服务，因为这些可以处理大量的并发请求。然而，并不是每个任务都可以通过异步方式处理。我们是否可以使用异步微服务取决于任务的类型和它需要的资源。让我们进一步探讨这种差异。
- en: IO-bound versus CPU-bound tasks
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O密集型任务与CPU密集型任务
- en: There are two types of tasks. If a task doesn't carry out many calculations,
    but it does do a lot of input/output operations, it's called an I/O-bound task.
    Since CPU is much faster than input/output buses, we have to wait a long time
    for a bus or device to be available for reading or writing. I/O-bound tasks can
    be handled well in an asynchronous way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的任务。如果一个任务不进行很多计算，但进行大量的输入/输出操作，那么它被称为I/O密集型任务。由于CPU的速度远快于输入/输出总线，我们不得不等待很长时间才能使总线或设备可用进行读写。I/O密集型任务可以通过异步方式很好地处理。
- en: If a task does a lot operations using CPU, it's called a CPU-bound task. For
    example, image resizing is a kind of CPU-bound task, because it recalculates the
    pixels from an original image, but only saves the result when it's ready.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个任务使用CPU进行大量操作，那么它被称为CPU密集型任务。例如，图像缩放是一种CPU密集型任务，因为它从原始图像重新计算像素，但只有在准备好时才保存结果。
- en: The difference between I/O-bound and CPU-bound tasks isn't obvious and not every
    task can be classified strictly to an I/O or CPU domain. To resize an image, you
    have to keep the whole image in the memory, but if your service transcodes video
    streams, it may take a lot of I/O and CPU resources simultaneously.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 密集型任务和 CPU 密集型任务之间的区别并不明显，并不是每个任务都可以严格归类为 I/O 或 CPU 领域。为了调整图像大小，你必须将整个图像保持在内存中，但如果你提供的服务转码视频流，它可能需要大量的
    I/O 和 CPU 资源。
- en: Synchronous tasks inside asynchronous contexts
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步上下文中的同步任务
- en: Let's say you know which class the task belongs to, either I/O or CPU. IO tasks
    can be handled in a single thread, because they have to wait for a lot of I/O
    data. If your hardware has multicore CPUs and a lot of I/O devices, however, a
    single thread isn't enough. You may decide to use multiple threads with a single
    asynchronous context, but there's a problem—not every asynchronous task can be
    transferred between threads. For example, SQLite-embedded databases stores service
    data in thread-local storage, and you can't use the same database handle with
    multiple threads.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你知道任务属于哪个类别，无论是 I/O 还是 CPU。IO 任务可以在单个线程中处理，因为它们必须等待大量的 I/O 数据。然而，如果你的硬件具有多核
    CPU 和大量的 I/O 设备，那么单个线程就不够了。你可能会决定使用单个异步上下文中的多个线程，但有一个问题——并不是每个异步任务都可以在线程之间传递。例如，SQLite-嵌入式数据库将服务数据存储在线程局部存储中，你不能在多个线程中使用相同的数据库句柄。
- en: SQLite can't work with databases asynchronously; it has asynchronous methods
    that interact with instances that run in a separate thread, but you have to remember
    that not every task can be run in multithreaded contexts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 不能异步地与数据库一起工作；它有异步方法可以与在单独线程中运行的实例交互，但你必须记住，并不是每个任务都可以在多线程上下文中运行。
- en: A good solution if we have a multicore hardware is to use a thread pool to handle
    connections. You can transfer connection contexts to any thread from the pool,
    which can handle connections asynchronously.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拥有多核硬件，一个好的解决方案是使用线程池来处理连接。你可以将连接上下文从池中的任何线程传递，这样就可以异步地处理连接。
- en: 'Rust and well-written crates prevent you from making mistakes; in my opinion,
    Rust is the best tool in existence for writing fast and secure software. However,
    it''s important to be aware of a certain situation that''s hard to detect with
    a compiler, which occurs when you call a blocking operation in an asynchronous
    context. Asynchronous applications use a reactor that calls the necessary code
    when a piece of data is ready to read or write, but if you''ve called the blocking
    method, the reactor can''t be called and all connections that are handled by the
    blocked thread will be blocked as well. Even worse, the application might be completely
    blocked if you call a synchronous method related to the reactor. For example,
    if you try to send a message to a receiver handled by a reactor, but the channel
    is full, the program will be blocked, because the reactor must be called to drain
    the channel, but this can''t be done because the thread is already blocked by
    the message being sent. Take a look at the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 和编写良好的 crate 可以防止你犯错；在我看来，Rust 是编写快速和安全的软件的最佳工具。然而，重要的是要意识到某些难以通过编译器检测到的特定情况，这发生在你在异步上下文中调用阻塞操作时。异步应用程序使用一个反应器，当数据准备好读取或写入时，它会调用必要的代码，但如果你已经调用了阻塞方法，反应器就无法被调用，并且所有由被阻塞的线程处理的连接都将被阻塞。更糟糕的是，如果你调用与反应器相关的同步方法，应用程序可能会完全阻塞。例如，如果你尝试向由反应器处理的接收器发送消息，但通道已满，程序将被阻塞，因为反应器必须被调用以排空通道，但由于线程已被发送的消息阻塞，这无法完成。看看以下示例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The conclusion is simple—only use asynchronous operations in asynchronous contexts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 结论很简单——只应在异步上下文中使用异步操作。
- en: The limitations of using IO operations on files
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件上使用 IO 操作的限制
- en: As mentioned, some libraries, such as SQLite, use blocking operations to perform
    queries to a database and get the result back, but this depends on what kind of
    IO they use. A network stack is completely asynchronous in modern operating systems,
    but the input/output of files is harder to use asynchronously. Operating systems
    contain functions to carry out asynchronous reading or writing, but it's hard
    to implement this with cross-platform compatibility. It's simpler to use a separate
    thread to handle hard-drive IO interactions. The `tokio` crate uses a separate
    thread to handle the IO of files. Other platforms, such as Go or Erlang, do the
    same thing. You can use asynchronous IO for files for specific operating systems,
    but this isn't a very flexible approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一些库，例如 SQLite，使用阻塞操作来对数据库进行查询并获取结果，但这取决于它们使用的 I/O 类型。在现代操作系统中，网络堆栈是完全异步的，但文件的输入/输出更难异步使用。操作系统包含执行异步读取或写入的函数，但很难实现跨平台的兼容性。使用单独的线程来处理硬盘
    I/O 交互会更简单。`tokio` 包使用单独的线程来处理文件的 I/O。其他平台，如 Go 或 Erlang，也做同样的事情。你可以为特定操作系统使用异步
    I/O 来处理文件，但这不是一个非常灵活的方法。
- en: Now that you know the difference between synchronous and asynchronous tasks,
    we're ready to create an asynchronous service that uses a separate thread for
    the CPU-bound task of resizing images.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了同步和异步任务之间的区别，我们准备创建一个使用单独线程来处理调整图像大小的 CPU 密集型任务的异步服务。
- en: Spawning a thread for image processing
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为图像处理启动一个线程
- en: 'In our first example, we''ll create a microservice that expects a request with
    an image, loads it completely to the memory, sends it to a thread for resizing,
    and waits for the result. Let''s start by creating a thread that expects image
    data and responses. To receive the request, we''ll use the `mpsc::channel` module
    and `oneshot::channel` for responses, because multiple clients can''t send requests
    and we only expect one response per image. For the requests, we''ll use the following
    struct:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，我们将创建一个微服务，该服务期望接收一个包含图像的请求，将其完全加载到内存中，将其发送到线程进行调整大小，并等待结果。让我们首先创建一个期望图像数据和响应的线程。为了接收请求，我们将使用
    `mpsc::channel` 模块和 `oneshot::channel` 用于响应，因为多个客户端不能发送请求，我们只期望每个图像有一个响应。对于请求，我们将使用以下结构体：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`WorkerRequest` contains the `buffer` field for binary image data, the desired
    `width` and `height` of the resized image, and a `tx` sender of the `oneshot::Sender` type for
    sending a `WorkerReponse` response.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkerRequest` 包含用于二进制图像数据的 `buffer` 字段，所需调整大小的图像的 `width` 和 `height`，以及一个
    `oneshot::Sender` 类型的 `tx` 发送器，用于发送 `WorkerReponse` 响应。'
- en: 'The response is presented by a type alias to the `Result` type, which holds
    the successful result with the binary data of the resized image or an error:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 响应通过类型别名呈现为 `Result` 类型，该类型包含成功的结果，其中包含调整大小图像的二进制数据或错误：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now create a thread that supports these messages and carries out resizing:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个支持这些消息并执行调整大小的线程：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since we use a single thread for all resizing requests, we can use the `wait`
    method of the `Sender` and `Receiver` for interacting with clients. The preceding
    code creates a `channel` from the `mpsc` module that can keep one message in a
    buffer. We don't need more space in the buffer for the message, because resizing
    takes a long period of time and we just need to send the next message to a receiver
    while we're processing an image.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为所有调整大小请求使用单个线程，我们可以使用 `Sender` 和 `Receiver` 的 `wait` 方法与客户端交互。前面的代码从 `mpsc`
    模块创建了一个 `channel`，该 `channel` 可以在缓冲区中保持一条消息。我们不需要在缓冲区中为消息腾出更多空间，因为调整大小需要很长时间，而我们只需要在我们处理图像的同时将下一条消息发送给接收器。
- en: We use the `thread::spawn` method to spawn a new thread with a processing function.
    The `Receiver::wait` method converts a `Receiver` to a blocking iterator of the
    incoming messages. We use a simple loop to iterate over all the requests. The
    reactor isn't needed here. If the message is received successfully, we'll process
    the request. To convert the image, we use the `convert` method that's described
    in the following code snippet. We send the result to `oneshot::Sender`, which
    doesn't have a `wait` method; all we need to do is call the `send` method, which
    returns a `Result`. This operation won't block and doesn't need a reactor, because
    it uses `UnsafeCell` internally to provide a value for the `Receiver` that implements
    the `Future` trait.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`thread::spawn`方法来创建一个新的线程，并使用处理函数。`Receiver::wait`方法将`Receiver`转换为接收消息的阻塞迭代器。我们使用一个简单的循环来遍历所有请求。在这里不需要反应器。如果成功接收到消息，我们将处理请求。为了转换图像，我们使用以下代码片段中描述的`convert`方法。我们将结果发送到`oneshot::Sender`，它没有`wait`方法；我们只需要调用`send`方法，它返回一个`Result`。这个操作不会阻塞，也不需要反应器，因为它内部使用`UnsafeCell`来为实现了`Future`特质的`Receiver`提供一个值。
- en: 'To resize the image, we use an `image` crate. This contains a rich set of methods
    for image transformation and supports multiple image formats. Take a look at the
    implementation of the `convert` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要调整图像大小，我们使用一个`image`包。这个包包含了一组丰富的图像转换方法，并支持多种图像格式。看看`convert`函数的实现：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function expects binary data of an image, related to its width and height.
    The `convert` function returns an `ImageResult`, which is a type alias for `Result`
    with `ImageError` as the error type. We use this error type, because some methods
    inside the `convert` function implementation can return errors of this type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数期望接收图像的二进制数据，以及与其宽度和高度相关的数据。`convert`函数返回一个`ImageResult`，这是`Result`类型的一个别名，其错误类型为`ImageError`。我们使用这个错误类型，因为`convert`函数实现内部的一些方法可能会返回这种类型的错误。
- en: The first line of the implementation tries to guess the format of incoming data with
    the `guess_format` function. We can use this format value later on to use the
    same format for the output image. After that, we use the `load_from_memory` function
    to read an image from a data vector. This call reads the data and actually doubles
    the amount of consumed memory for the image – be aware of this if you want to
    process multiple images simultaneously. After resizing, we write the scaled image
    to a vector and return it as a `Result`. The scaled image also consumes some memory,
    meaning we're almost tripling the consumption. It's better to add limits for the
    size of the incoming message, the width, and the height to prevent memory overflow.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的第一行尝试使用`guess_format`函数猜测传入数据的格式。我们可以在之后使用这个格式值来为输出图像使用相同的格式。之后，我们使用`load_from_memory`函数从数据向量中读取图像。这个调用读取数据并实际上将图像消耗的内存量加倍——如果你想要同时处理多个图像，请注意这一点。调整大小后，我们将缩放后的图像写入向量，并作为`Result`返回。缩放后的图像也消耗了一些内存，这意味着我们几乎将内存消耗量翻了两番。最好为传入消息的大小、宽度和高度添加限制，以防止内存溢出。
- en: 'We can now implement the `main` function, which spawns a worker thread and
    starts a server instance:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现`main`函数，它创建一个工作线程并启动服务器实例：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only difference here from the `main` function of the previous chapter is
    that we call the `start_worker` function and use the returned `Sender` as a parameter
    for the handler function along with a request.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章的`main`函数相比，这里唯一的区别是我们调用`start_worker`函数，并使用返回的`Sender`作为处理函数的参数，同时附带一个请求。
- en: Let's look at an implementation of `microservice_handler` and learn how it interacts
    with a worker.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`microservice_handler`的实现，并了解它是如何与工作线程交互的。
- en: Interacting with a thread in an asynchronous way
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以异步方式与线程交互
- en: 'The handler function of the image-resizing microservice contains two branches:
    one for the index page and one for the resize request. Take a look at the following
    code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图像调整微服务的处理函数包含两个分支：一个用于索引页面，一个用于调整请求。看看以下代码：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `resize` branch part of the handler, we have to carry out various actions:
    extract parameters, collect a body from a stream, send a task to a worker, and
    generate a body. Since we use asynchronous code, we''ll create a chain of method
    calls to construct the necessary `Future` object.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理函数的`resize`分支部分，我们必须执行各种操作：提取参数、从流中收集正文、向工作线程发送任务以及生成正文。由于我们使用异步代码，我们将创建一系列方法调用，以构建必要的`Future`对象。
- en: 'To extract the parameters, we use the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取参数，我们使用以下代码：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We use the `query` part of `uri` and the `parse` function of the `queryst`
    crate to parse the parameters to `Json::Value`. After that, we can extract the
    necessary values by index because the `Value` type implements the `std::ops::Index`
    trait. Taking a value by index returns a `Value`, which will be `Value::Null`
    if the value isn''t set. The `to_number` function tries to represent a value as
    a string and parse it to the `u16` value. Alternatively, it returns a default
    value, which you set as a second parameter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`uri`的`query`部分和`queryst` crate的`parse`函数将参数解析为`Json::Value`。之后，我们可以通过索引提取必要的值，因为`Value`类型实现了`std::ops::Index`特质。通过索引获取值返回一个`Value`，如果值未设置，则返回`Value::Null`。`to_number`函数尝试将值表示为字符串并将其解析为`u16`值。或者，它返回一个默认值，这是作为第二个参数设置的：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By default, we'll use an image size of 180 × 180 pixels.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们将使用180 × 180像素的图像大小。
- en: 'The next part of the handling branch creates the body of the response using
    the size parameters we extracted from the query string. The following code collects
    a stream of the request to a vector and uses a worker instance to resize an image:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 处理分支的下一部分使用我们从查询字符串中提取的大小参数创建响应体。以下代码收集请求流到一个向量中，并使用工作者实例调整图像大小：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To interact with a worker, we create a `oneshot::channel` instance and a `WorkerRequest`
    with the necessary parameters. After that, we `send` a request to a worker using
    the `tx` variable, which is a `Sender` instance connected to a worker and was
    provided with the `microservice_handler` function call. The `send` method creates
    a future that succeeds if a message is sent successfully. We add a step to this
    future with the `and_then` method, which reads a value from a `oneshot::Recevier`
    that implements the `Future` trait as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要与工作者交互，我们创建一个`oneshot::channel`实例和一个带有必要参数的`WorkerRequest`。之后，我们使用`tx`变量向工作者发送请求，`tx`是一个连接到工作者并提供了`microservice_handler`函数调用的`Sender`实例。`send`方法创建一个如果消息成功发送则成功的future。我们使用`and_then`方法添加一个步骤到这个future中，该方法从实现了`Future`特质的`oneshot::Recevier`中读取一个值。
- en: When the scaled message is ready, we take it as a result of `Future` and `map`
    it to a response.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当缩放的消息准备好时，我们将其作为`Future`的结果，并将其`map`到响应。
- en: 'Test the example by sending an image using `curl`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl`发送图像来测试示例：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've sent `image.jpg` from the media folder and saved the result to the `files/resized.jpg`
    file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已从媒体文件夹发送了`image.jpg`并将其结果保存到`files/resized.jpg`文件中。
- en: The major drawback of this microservice is that it only uses a single thread,
    which will quickly become a bottleneck. To prevent this, we can use multiple threads
    to share CPU resources to handle more requests. Let's now look at how to use thread
    pools.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微服务的最大缺点是它只使用单个线程，这很快就会成为瓶颈。为了防止这种情况，我们可以使用多个线程来共享CPU资源以处理更多请求。现在让我们看看如何使用线程池。
- en: Using thread pools
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程池
- en: To use thread pools, you don't need a special library. Instead, you can implement
    a scheduler that sends requests to a bunch of threads. You can even check the
    responses of workers to decide which thread to choose for processing, but there
    are ready-to-use crates that help to solve this issue more elegantly. In this
    section, we're going to look at the `futures-cpupool` and `tokio-threadpool` crates.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用线程池，你不需要特殊的库。相反，你可以实现一个调度器，将请求发送到一组线程。你甚至可以检查工作者的响应来决定选择哪个线程进行处理，但有一些现成的crate可以帮助更优雅地解决这个问题。在本节中，我们将探讨`futures-cpupool`和`tokio-threadpool`crate。
- en: CpuPool
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CpuPool
- en: 'Here, we''ll reuse an existing microservice and remove the `start_worker` function,
    and the `WorkerRequest` and `WorkerResult` types. Keep the `convert` function
    and add a new dependency to `Cargo.toml`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将重用现有的微服务并移除`start_worker`函数，以及`WorkerRequest`和`WorkerResult`类型。保留`convert`函数并添加一个新的依赖到`Cargo.toml`：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Import the `CpuPool` type from that crate:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从该crate导入`CpuPool`类型：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The pool is now ready to use in the request handler. We can pass it as a parameter,
    like we did with the `Sender` of the worker thread in the previous example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个池已经准备好在请求处理程序中使用。我们可以像在先前的例子中传递工作者线程的`Sender`一样传递它作为参数：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we created a thread pool with four threads and passed
    it to the `serve` function to `clone` it for the handler. The handler function
    takes a pool as the first argument:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个包含四个线程的线程池，并将其传递给`serve`函数以`clone`它用于处理程序。处理程序函数将池作为第一个参数：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We use the same branches and the code to extract the width and height parameters.
    We change how we convert the image, however:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的分支和代码来提取宽度和高度参数。然而，我们改变了对图像的转换方式：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code of this implementation has become more compact and accurate. In this
    implementation, we also collect a body to a `Vec` binary, but to convert the image
    we use a lazy `Future` that spawned in a thread pool using the `spawn` method
    of `CpuPool`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的代码变得更加紧凑和准确。在这个实现中，我们也将一个体收集到一个`Vec`二进制中，但是为了转换图像，我们使用一个在`CpuPool`中使用`spawn`方法产生的懒`Future`。
- en: We use the `future::lazy` call to postpone the execution of the `convert` function.
    Without the `lazy` call, the `convert` function will be called immediately and
    will block all IO activities. You can also set specific parameters for `CpuPool`
    using `Bulder`. This helps to set the quantity of threads in a pool, the stack
    size, and the hooks that will be called after the start of a new thread and before
    it stops.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`future::lazy`调用来推迟`convert`函数的执行。如果没有`lazy`调用，`convert`函数将立即被调用并阻塞所有IO活动。你还可以使用`Builder`为`CpuPool`设置特定的参数。这有助于设置池中线程的数量、堆栈大小以及在新线程启动后和停止前将被调用的钩子。
- en: '`CpuPool` is not the only way to use pools. Let''s look at another example.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`CpuPool`不是使用池的唯一方法。让我们看看另一个例子。'
- en: The blocking section
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞部分
- en: 'The `tokio-threadpool` crate contains a `blocking` function that''s declared
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokio-threadpool`存储库包含一个声明如下所示的`blocking`函数：'
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function expects any function that performs blocking operations and runs
    it in a separate thread, providing a `Poll` result that can be used by a reactor.
    It is a slightly low-level approach but it's actively used by `tokio` and other
    crates (to perform IO operations on files).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数期望任何执行阻塞操作的功能，并在一个单独的线程中运行它，提供一个可以由反应器使用的`Poll`结果。这是一个稍微低级的方法，但它被`tokio`和其他存储库（在文件上执行IO操作）积极使用。
- en: 'The positive side of this approach is that we don''t need to create a thread
    pool manually. We can use the simple `main` function, as we''ve done before:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是我们不需要手动创建线程池。我们可以使用简单的`main`函数，就像我们之前做的那样：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To spawn a task that calls the `convert` function, we can use the following
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个调用`convert`函数的任务，我们可以使用以下代码：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `blocking` function call delegates the task execution to another thread
    and returns a `Poll` for every call until the result of the execution is ready.
    To call a raw function that returns a `Poll` result, we can wrap that function
    with a `future::poll_fn` function call that converts any polling function to a
    `Future` instance. Looks simple, doesn't it? We didn't even create a thread pool
    manually.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`blocking`函数调用将任务执行委托给另一个线程，并在每次调用时返回一个`Poll`，直到执行结果准备好。要调用返回`Poll`结果的原始函数，我们可以使用`future::poll_fn`函数调用将该函数包装起来，将任何轮询函数转换为`Future`实例。看起来很简单，不是吗？我们甚至没有手动创建线程池。'
- en: 'For example, the `tokio-fs` crate uses this method to implement IO operations
    on files:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`tokio-fs`存储库使用这种方法在文件上实现IO操作：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`would_block` is a wrapper over the blocking function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`would_block`是阻塞函数的一个包装器：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You now know how any blocking operation can be joined with an asynchronous reactor.
    This approach is used not only to interact with filesystems, but also for databases
    and other crates that don't support the `futures` crate or that need massive calculations
    with CPU.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道任何阻塞操作都可以与异步反应器结合使用。这种方法不仅用于与文件系统交互，还用于数据库和其他不支持`futures`存储库或需要大量CPU计算的存储库。
- en: Actors
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员
- en: 'Threads and thread pools are good ways to utilize more resources of a server,
    but it''s a tedious programming style. You have to think about a lot of details:
    sending and receiving messages, load distribution, and respawning failed threads.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和线程池是利用服务器更多资源的好方法，但编程风格很繁琐。你必须考虑很多细节：发送和接收消息、负载分配以及重新启动失败的线程。
- en: 'There''s another approach to run tasks concurrently: actors. The actors model
    is a computational model that uses computational primitives called **actors**.
    They work in parallel and interact with each other by passing messages. It''s
    a more flexible approach than using threads or pools, because you delegate every
    complex task to a separate actor that receives messages and return results to
    any entity that sent a request to an actor. Your code becomes well structured
    and you can even reuse actors for different projects.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种并行运行任务的方法是演员。演员模型是一种计算模型，它使用称为**演员**的计算原语。它们并行工作并通过传递消息相互交互。与使用线程或池相比，这是一种更灵活的方法，因为你可以将每个复杂任务委托给一个单独的演员，该演员接收消息并将结果返回给任何向演员发送请求的实体。你的代码结构良好，你甚至可以重用演员来处理不同的项目。
- en: 'We already studied `futures` and `tokio` crates, which are tricky to use directly,
    but they''re a good foundation to build asynchronous computational frameworks,
    and especially it''s good to implement actors model. The `actix` crate already
    did that: it''s based on both crates to bring an actors model to Rust. Let''s
    study how we can use actors to perform background tasks.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了`futures`和`tokio`库，它们直接使用起来比较复杂，但它们是构建异步计算框架的良好基础，尤其是实现演员模型非常好。`actix`库已经实现了这一点：它基于这两个库将演员模型引入Rust。让我们研究一下我们如何使用演员来执行后台任务。
- en: 'We''ll re-implement the resizing microservice, but add three actors: a resizing
    actor, a counting actor, which counts the amount of requests, and a logging actor,
    which will write the count values to `syslog`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新实现缩放微服务，但添加三个演员：一个缩放演员，一个计数演员，它计算请求数量，以及一个日志演员，它将计数值写入`syslog`。
- en: Basics of the actix framework
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: actix框架的基础
- en: The `actix` crate provides a well-organized actors model that's simple to use.
    There are main concepts you should remember. At first, the `actix` crate has the `System`
    type, which is the main type to maintain actors system. You have to create the `System`
    instance before you create and spawn any actor. Actually, `System` is an `Actor`
    that controls the whole process and can be used to stop an application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`actix`库提供了一个组织良好的演员模型，使用起来很简单。有一些主要概念你应该记住。首先，`actix`库有`System`类型，这是维护演员系统的主要类型。在创建和启动任何演员之前，你必须创建`System`实例。实际上，`System`是一个控制整个过程的`Actor`，可以用来停止应用程序。'
- en: '`Actor` is the most-used trait of the framework. Every type that implements
    the `Actor` trait can be spawned. We''ll implement this trait for our types later
    in this chapter. Also, the `actix` crate contains the `Arbiter` type, which is
    an event loop controller that have to be one per thread. There''s `SyncArbiter`
    to run CPU-boud tasks, and this arbiter uses pools of threads to perform actors.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Actor`是框架中最常用的特质。实现了`Actor`特质的每个类型都可以被启动。我们将在本章后面实现这个特质。此外，`actix`库还包含`Arbiter`类型，这是一个事件循环控制器，每个线程必须有一个。有`SyncArbiter`来运行CPU密集型任务，这个仲裁者使用线程池来执行演员。'
- en: Every `Actor` has to work in a `Context`, which is an environment to a runtime
    and can be used to spawn other tasks. Also, every `Actor` instance takes an `Address`
    and you can use it to send messages to actors and receive responses. We'll store
    in our example addresses of all necessary actors to a shared state to use them
    from different handlers in parallel.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Actor`都必须在一个`Context`中工作，这是一个运行时环境，可以用来启动其他任务。此外，每个`Actor`实例都带有一个`Address`，你可以用它向演员发送消息并接收响应。在我们的示例中，我们将所有必要的演员的地址存储在共享状态中，以便从不同的处理程序并行使用它们。
- en: '`Address` provides a `send` method that expects a type that implements the `Message`
    trait. To implement message-handling for `Actor`, you have to implement the `Handler`
    trait for the actor''s type.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`提供了一个期望实现`Message`特质的类型的`send`方法。为了为`Actor`实现消息处理，你必须为演员的类型实现`Handler`特质。'
- en: Let's create three actors for our resizing microservice.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的缩放微服务创建三个演员。
- en: Implementing actors
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现演员
- en: 'First, we have to import all necessary dependencies. We''ll use the same common
    dependencies from previous examples in this chapter, but you also have to add
    the following dependencies to `Cargo.toml`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须导入所有必要的依赖项。在本章中，我们将使用与之前示例相同的公共依赖项，但你还需要将以下依赖项添加到`Cargo.toml`中：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We added the `actix` crate. It's the main crate for the current example. Also,
    we imported the `failure` crate, because we'll use the `Fail` trait to get access
    to the `compat` method, which converts any error type that implements the `Fail`
    trait into a `Compat` type that implements the `std::error::Error` trait.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`actix`crate。它是当前示例的主要crate。此外，我们还导入了`failure`crate，因为我们将使用`Fail`特质来获取对`compat`方法的访问权限，该方法将实现`Fail`特质的任何错误类型转换为实现`std::error::Error`特质的`Compat`类型。
- en: Also, we'll use `syslog` and we added the `syslog` crate to access the system
    API. `syslog` is a standard of system logging. We'll use it to demonstrate how
    actors can perform separate tasks of the whole process. Now we can add the `actors`
    module to our example and add three actors.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用`syslog`，并添加了`syslog`crate来访问系统API。`syslog`是系统日志的标准。我们将用它来演示actor如何执行整个过程中的单独任务。现在，我们可以将`actors`模块添加到我们的示例中，并添加三个actor。
- en: The count actor
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数actor
- en: The first actor we'll implement is a counter. It takes a message with a string
    and counts the number of the same strings. We will use it to count the amount
    of requests of specified paths.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实现的第一个actor是一个计数器。它接收一个包含字符串的消息，并计算相同字符串的数量。我们将用它来计算指定路径的请求数量。
- en: Types
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'Create the `src/actors/count.rs` module and import the following types:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`src/actors/count.rs`模块并导入以下类型：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We'll use the `Actor` trait to implement an actor's behavior, which works in
    a `Context` and receive a `Message` and handle it by the `Handler` trait implementation.
    Also, we need `HashMap` to store all counts. We also add the `Value` types alias
    and use it as a type for counting.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Actor`特质来实现actor的行为，该行为在`Context`中工作，接收`Message`并通过`Handler`特质的实现来处理它。此外，我们需要`HashMap`来存储所有计数。我们还添加了`Value`类型别名，并将其用作计数的类型。
- en: Actor
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Actor`'
- en: 'Actor is a struct that implements the `Actor` trait. We''ll use a struct with
    `HashMap` inside to count the number of incoming strings:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Actor`是一个实现了`Actor`特质的`struct`。我们将使用一个包含`HashMap`的`struct`来计数传入字符串的数量：'
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We added a new method to create an empty `CountActor` instance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新方法来创建一个空的`CountActor`实例。
- en: 'Now we can implement the `Actor` trait for our struct. The implementation is
    simple:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的`struct`实现`Actor`特质。实现很简单：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We specify a context and set it to the `Context` type. The actor trait contains
    the default implementation of different methods that help you to react on lifetime
    events of your actor:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定一个上下文并将其设置为`Context`类型。actor特质包含不同方法的默认实现，这些方法可以帮助你响应actor的生命周期事件：
- en: '`started`: This is called when the `Actor` instance starts.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`started`: 当`Actor`实例启动时调用此方法。'
- en: '`stopping`: This is called when the `Actor` instance switches to the Stopping
    state (if `Context::stop` is called, for example).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopping`: 当`Actor`实例切换到停止状态（例如，当调用`Context::stop`时）时调用此方法。'
- en: '`stopped`: This is called when the `Actor` instance stops.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopped`: 当`Actor`实例停止时调用此方法。'
- en: Now, let's add a message type that will be handled by the actor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个actor将处理的消息类型。
- en: Message
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Message`'
- en: 'The counting actor expects a message with a string, and we''ll add the following
    struct:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 计数actor期望一个包含字符串的消息，我们将添加以下`struct`：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Count` struct has a single filed with the String type and implements the
    `Message` trait of the Actix framework. This implementation allows us to send
    `Count` instances using the address of the actor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count``struct`有一个字段，类型为`String`，并实现了Actix框架的`Message`特质。此实现允许我们使用actor的地址发送`Count`实例。'
- en: The Message trait needs type of associated type `Result`. This value will be
    returned after the message is processed. We'll return a counter value for the
    provided string.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`特质需要关联类型`Result`。在消息处理完毕后，将返回此值。我们将为提供的字符串返回一个计数器值。'
- en: Handler
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Handler`'
- en: 'To add support for incoming message types, we have to implement the `Handler`
    trait for our actor. Let''s implement `Handler` of `Count` messages for our `CountActor`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持传入的消息类型，我们必须为我们的actor实现`Handler`特质。让我们为我们的`CountActor`实现`Count`消息的`Handler`：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We also have to set the associated type with the same type of a result.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须设置与结果相同类型的关联类型。
- en: Handling occurs in the body of the `handle` method of the `Handler` trait. We'll
    get entry for a provided String value with the `Count` message and extract the
    entry of `HashMap`. If no entry is found, we'll get a default value that equals
    0 for `u64` type (`Value` alias) and add `1` to that `value`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 处理发生在`Handler`特质的`handle`方法体中。我们将使用`Count`消息获取提供的字符串条目，并提取`HashMap`中的条目。如果没有找到条目，我们将获取一个默认值，该值对于`u64`类型（`Value`别名）等于0，并将`1`添加到该值中。
- en: Now `ConnActor` is ready to use. We can instantiate it and use the address of
    the actor to count the paths of HTTP requests. Let's add two more actors.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`ConnActor`已经准备好使用。我们可以实例化它，并使用演员的地址来计数HTTP请求的路径。让我们再添加两个演员。
- en: The log actor
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志演员
- en: The logging actor will add records to `syslog`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录演员将向`syslog`添加记录。
- en: Types
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'We need basic types from the `actix` crate and import some types from the `syslog`
    crate:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`actix`crate的基本类型，并从`syslog`crate导入一些类型：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We don't need to study the `syslog` crate in detail, but let's discuss basic
    some types.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要详细研究`syslog`crate，但让我们讨论一些基本类型。
- en: You can also use `use actix::prelude::*;` to import all most-used types from
    the `actix` crate.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`use actix::prelude::*;`来导入`actix`crate中几乎所有常用的类型。
- en: '`Logger` is a main struct that allows writing methods to add records to `syslog`.
    It includes logging the methods order by level from highest to lowest: `emerg`,
    `alert`, `crit`, `err`, `warning`, `notice`, `info`, `debug`. The `LoggerBackend`
    enum specifies the type of a connection to a logger. It can be a socket or UNIX
    socket. The `Facility` enum specifies the type of application which writes logs.
    `Formatter3164` specifies the format of logging.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logger`是一个主要结构体，允许将方法写入`syslog`。它包括按级别从高到低记录日志的方法：`emerg`、`alert`、`crit`、`err`、`warning`、`notice`、`info`、`debug`。`LoggerBackend`枚举指定了连接到日志记录器的类型。它可以是套接字或UNIX套接字。`Facility`枚举指定了写入日志的应用程序类型。`Formatter3164`指定了日志记录的格式。'
- en: 'There are two `Syslog` protocols described in two RFCs: `3164` and `5424`.
    That''s why formatters have such strange names.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个RFC中描述了两种`Syslog`协议：`3164`和`5424`。这就是为什么格式化程序有如此奇怪的名字。
- en: Now we can implement the logging actor.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现日志记录演员。
- en: Actor
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员
- en: 'The main type is the `LogActor` struct, which contains a `Logger` instance
    in the `writer` field:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 主要类型是`LogActor`结构体，它包含一个位于`writer`字段的`Logger`实例：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ll use this logger in the `Handler` trait implementation to write messages,
    but now we need a constructor for our struct, because we have to configure `Logger`
    on start:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Handler`特质实现中使用这个记录器来写入消息，但现在我们需要为我们结构体提供一个构造函数，因为我们必须在启动时配置`Logger`：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We added new method that fills the `Formatter3164` struct with the `Facility`
    value and process name. Other fields are set to blank values. We create a `Logger`
    instance by calling the `syslog::unix` method and providing a formatter to it.
    We store the `Logger` in the writer field and return an instance of the `LogActor`
    struct.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新方法，该方法使用`Facility`值和进程名称填充`Formatter3164`结构体，并将其他字段设置为空白值。我们通过调用`syslog::unix`方法并提供一个格式化程序来创建一个`Logger`实例。我们将`Logger`存储在`writer`字段中，并返回一个`LogActor`结构体的实例。
- en: 'To add the actor''s behavior, we''ll implement the `Actor` trait for the `LogActor`
    struct:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加演员的行为，我们将为`LogActor`结构体实现`Actor`特质：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since this actor will work in the same thread with a server instance and a counting
    actor, we'll use the basic `Context` type.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个演员将与服务器实例和计数演员在同一个线程中工作，我们将使用基本的`Context`类型。
- en: Message
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: 'We need a message to send messages for writing them to `syslog`. It''s enough
    to have a simple struct with one public `String` filed:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个消息来发送消息以便将它们写入`syslog`。有一个简单的结构体，带有一个公共`String`字段就足够了：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We added the `Log` struct and implemented the `Message` trait for it. We don't
    need the return value for this message since logging will be a one-way process
    and all errors will be ignored, since they aren't critical for a microservice
    application. But if your microservice has to work with a strict security environment,
    you'll also have to inform an administrator about logging issues.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`Log`结构体并为它实现了`Message`特质。对于这个消息，我们不需要返回值，因为日志记录将是一个单向过程，并且所有错误都将被忽略，因为它们对于微服务应用来说不是关键的。但是，如果你的微服务必须在一个严格的安全环境中工作，你也必须通知管理员有关日志记录的问题。
- en: Handler
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: '`Handler` of the `Log` messages is quite simple. We call the info method of
    `Logger` with a provided message and ignore errors with by converting a `Result` into
    an `Option`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Log`消息的`Handler`非常简单。我们使用提供的信息调用`Logger`的info方法，并通过将`Result`转换为`Option`来忽略错误：'
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The last actor we have to implement is the resizing actor.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须实现的最后一个演员是调整大小的演员。
- en: The resize actor
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整大小的演员
- en: The resizing actor resizes incoming messages and return resized messages to
    a client.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 调整大小的演员调整传入的消息，并将调整大小后的消息返回给客户端。
- en: Types
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'We don''t need any special types and will use basic types of the `actix` crate
    and import types from the `image` crate that we''ve used before:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要任何特殊类型，将使用`actix`crate的基本类型，并从之前使用的`image`crate导入类型：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We'll convert the function body from previous examples in this chapter in handler
    implementation that's why we imported types from the `image` crate. We added the `Buffer`
    alias to the `Vec<u8>` type for convenience.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在处理器的实现中将之前示例中的函数主体转换为函数，这就是为什么我们导入了`image`包中的类型。我们为`Vec<u8>`类型添加了`Buffer`别名以方便使用。
- en: Actor
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员
- en: 'We need a struct without any fields, because we''ll use it with `SyncArbiter`,
    which runs multiple actors in multiple threads. Add the `ResizeActor` struct:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个没有字段的`struct`，因为我们将在`SyncArbiter`中使用它，它将在多个线程中运行多个演员。添加`ResizeActor`结构体：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We don't need a special constructor and we implemented the `Actor` trait with
    the `SyncContext` type for the associate  `Context` type. We'll use this context
    type to make this actor suitable for the synchronous environment of `SyncArbiter`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要特殊的构造函数，并且我们实现了带有`SyncContext`类型的`Actor`特质，用于关联的`Context`类型。我们将使用此上下文类型使此演员适合`SyncArbiter`的同步环境：
- en: Message
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: 'We don''t use the convert function in this example, but we need the same parameters
    and we''ll take them from the `Resize` struct:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中我们不使用转换函数，但我们需要相同的参数，我们将从`Resize`结构体中获取它们：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We provide a `buffer` with the image data, and the desired `width` and `height`.
    In the `Message` trait implementation of the `Resize` struct, we use the `ImageResult<Buffer>`
    type. The same result type that the `convert` function returns. We'll get this
    value from the actor in the HTTP handler implementation later.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个包含图像数据的`buffer`以及所需的`width`和`height`。在`Resize`结构体的`Message`特质实现中，我们使用`ImageResult<Buffer>`类型。与`convert`函数返回的相同结果类型。我们将在HTTP处理器实现中稍后从演员获取此值。
- en: Handler
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: 'We implement the `Handler` of the `Resize` message for `ResizeActor`, but use
    the body of the `convert` function with fields of the passed message:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`ResizeActor`实现了`Resize`消息的`Handler`，但使用了传递的消息的字段来使用`convert`函数的主体：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We also use `SyncContext` instead of `Context`, like we did for previous actors.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`SyncContext`而不是`Context`，就像我们之前为演员所做的那样。
- en: 'All actors are ready and you need to add all modules to the `src/actors/mod.rs`
    file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所有演员都已准备就绪，您需要将所有模块添加到`src/actors/mod.rs`文件中：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we can implement a server with actors that perform resizing and other tasks
    for every request.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现一个服务器，该服务器使用演员为每个请求执行调整大小和其他任务。
- en: Using the server with actors
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有演员的服务器
- en: 'Import all necessary types for a server. It''s worth noting only those with
    which you''re unfamiliar:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 导入服务器所需的全部必要类型。值得注意的是，只有那些你不熟悉的部分：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Addr` is an address of an actor. `SyncArbiter` is a synchronous event-loop
    controller that handles every message synchronously. We need it for resizing actors.
    Also, add the `actors` module and import all the types we declared in the submodules:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Addr`是演员的地址。`SyncArbiter`是一个同步事件循环控制器，它以同步方式处理每条消息。我们需要它来处理调整大小的演员。还要添加`actors`模块并导入我们在子模块中声明的所有类型：'
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We need a shared state to keep all the addresses of the actors that we''ll
    use to handle requests:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个共享状态来保存我们将用于处理请求的所有演员的地址：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Addr` type is cloneable and we can derive the `Clone` trait for our `State`
    struct, because we have to clone for every service function of `hyper`. Let''s
    implement the `main` function with a new shared `State`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Addr`类型是可克隆的，我们可以为我们的`State`结构体推导出`Clone`特质，因为我们必须为`hyper`的每个服务函数进行克隆。让我们实现一个带有新共享`State`的`main`函数：'
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, we have to start the event loop. This makes with `actix::run` method
    call. We pass a closure that prepares all actors and return a `Future` to run.
    We'll use the `Server` type of **`hyper`**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须启动事件循环。这是通过调用`actix::run`方法来完成的。我们传递一个闭包来准备所有演员，并返回一个`Future`来运行。我们将使用**`hyper`**的`Server`类型。
- en: In closure, we start `SyncArbiter` with a function that produces a `ResizeActor`
    instance. With the first argument, we set the amount of thread that `SyncArbiter`
    will use to process requests. The `start` method returned an address of an arbiter
    that will route the message to both resizing actors.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包中，我们使用一个产生`ResizeActor`实例的函数来启动`SyncArbiter`。通过第一个参数，我们设置`SyncArbiter`将用于处理请求的线程数量。`start`方法返回一个仲裁器的地址，该仲裁器将消息路由到调整大小的演员。
- en: To start other actors, we can use the start method of the `Actor` trait, because
    the `actix::run` method creates a `System` instance and a default `Arbiter` for
    us. We created `CountActor` and `LogActor` this way. The `start` method of the `Actor`
    trait also returns the addresses of actors. We put them all into a new `State`
    struct.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动其他actor，我们可以使用`Actor`特质的`start`方法，因为`actix::run`方法为我们创建了一个`System`实例和一个默认的`Arbiter`。我们就是这样创建了`CountActor`和`LogActor`的。`Actor`特质的`start`方法还返回actor的地址。我们将它们全部放入一个新的`State`结构体中。
- en: After, we create a `Server` instance, like we did in the previous example, but
    also pass a reference to the cloned `State`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了一个`Server`实例，就像之前的例子一样，但还传递了一个克隆的`State`引用。
- en: Requests handler
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求处理器
- en: 'Before we implement a handler of HTTP requests, let''s add a function that
    uses `State` to send a message to `CountActor` and use the returned value to print
    it with `LogActor`. Look at the following function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现HTTP请求处理器之前，让我们添加一个函数，该函数使用`State`向`CountActor`发送消息，并使用返回的值通过`LogActor`打印它。看看下面的函数：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We converted the path into a `String`, because we need this type for the `Count`
    message, and to move it to a `Future` that sends a `Log` message to `LogActor`.
    Also, we have to clone `Addr` to `LogActor`, because we'll need it later in the
    closure after the counter value become available. Now let's create a `Future`
    that sends the `Count` message and the `Log` message in turn.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将路径转换成了`String`类型，因为我们需要这种类型来发送`Count`消息，并将其移动到发送`Log`消息给`LogActor`的`Future`中。此外，我们还需要将`Addr`克隆到`LogActor`中，因为当计数器的值可用后，我们还需要在闭包中使用它。现在让我们创建一个`Future`，依次发送`Count`消息和`Log`消息。
- en: The `Addr` struct has a `send` method that returns a `Request` instance that
    implements the `Future` trait. `Request` will return a counter value when it's
    available. We use the `and_then` method of `Future` to add extra `Future` to a
    chain. We need to prepare a message for `syslog` and `send` it to `LogActor` using
    the cloned `Addr`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Addr`结构体有一个`send`方法，该方法返回一个实现了`Future`特质的`Request`实例。`Request`将在可用时返回一个计数器值。我们使用`Future`的`and_then`方法将额外的`Future`添加到链中。我们需要准备一个消息用于`syslog`，并使用克隆的`Addr`将其发送到`LogActor`。'
- en: We also convert error to `io::Error`, but the send method returns `MaiboxError`
    as an error type that implements the `Fail` trait, but not implement `Error` trait
    from standard library and we have to use the `compat` method to convert an error
    to the `Compat` type of the `failure` crate that implements the standard `Error`
    trait.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将错误转换为`io::Error`，但发送方法返回的`MaiboxError`是一个实现了`Fail`特质的错误类型，但没有实现标准库中的`Error`特质，因此我们必须使用`compat`方法将错误转换为`failure`crate中实现的`Compat`类型。
- en: 'We''ll use the `count_up` method for both paths, `/` and `/resize`. Look at
    the `microservice_handler` implementation:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在两个路径`/`和`/resize`上使用`count_up`方法，看看`microservice_handler`的实现：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It remains the same in some parts, but now it takes a reference to `State` as
    a first argument. Since this handling function has to return a `Future` implementation,
    we can use the value returned by the `count_up` function call, but replace the
    value to `Response`. We already did it for the root path. Let's add a resizing
    functionality using `Addr` of  `ResizeActor`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些部分保持不变，但现在它将`State`的引用作为第一个参数。由于这个处理函数必须返回一个`Future`实现，我们可以使用`count_up`函数调用的返回值，但将值替换为`Response`。我们已经在根路径上做了这件事。让我们使用`ResizeActor`的`Addr`添加调整大小的功能。
- en: 'To send an image buffer to an actor, we have to collect it from `Body` of `Request`
    using the `collect2` method, like we did before:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像缓冲区发送给actor，我们必须使用`collect2`方法从`Request`的`Body`中收集它，就像我们之前做的那样：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After that, we create the `Resize` message and send it to `ResizeActor` using
    the cloned `Addr` of that actor. We convert all errors to `io::Error`. But wait,
    we haven't added requests counting and logging. Add the `count_up` function call
    at the end and put it before the `Future` that resizes images by creating a chain
    using the `and_then` method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了`Resize`消息，并使用该actor克隆的`Addr`将其发送给`ResizeActor`。我们将所有错误转换为`io::Error`。但是等等，我们还没有添加请求计数和日志记录。在创建用于调整图像大小的`Future`之前，使用`and_then`方法调用`count_up`函数，并将其放在前面。
- en: That's all! Now every request send path to `CountActor` than send an informational
    message to `LogActor` and the resizing request also connect all data and send
    it for resizing to `ResizeActor`. It's time to test it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！现在每个请求都会发送到`CountActor`，然后向`LogActor`发送一个信息消息，调整大小的请求也会连接所有数据并发送到`ResizeActor`进行调整。是时候测试它了。
- en: Building and running
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行
- en: Build and run the code using the `cargo run` subcommand. When the server starts
    use the `curl` command to send `POST` request with an image. You can find example
    of parameters for this preceding command.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cargo run` 子命令来构建和运行代码。当服务器启动时，使用 `curl` 命令发送带有图像的 `POST` 请求。你可以找到此前置命令的参数示例。
- en: 'For example, I requested the root path five times with a browser and sent a
    resizing request once. It stored resized message to the `files` folder. Yeah,
    it works! Now we can check that the logging actor adds records to `syslog`. Use
    this command to print logs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我用浏览器请求了根路径五次，并发送了一次调整大小的请求。它将调整大小的消息存储到了 `files` 文件夹中。是的，它工作了！现在我们可以检查日志演员是否向
    `syslog` 添加记录。使用以下命令来打印日志：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can find the following records:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到以下记录：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, we have five requests to the root path and one to the `/resize`
    path.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们对根路径有五个请求，对 `/resize` 路径有一个请求。
- en: If you don't have the `jounrnalctl` command, you can try to print logs with
    the `less /var/log/syslog` command.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 `jounrnalctl` 命令，你可以尝试使用 `less /var/log/syslog` 命令来打印日志。
- en: This example used actors to run concurrent activities. Actually, only `ResizeActor`
    used a separate thread with `SyncArbiter`. `CountActor` and `LogActor` used the
    same thread with the `hyper` server. But it's OK, since neither actors don't load
    a lot of CPU.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用了演员来运行并发活动。实际上，只有 `ResizeActor` 使用了与 `SyncArbiter` 一起的单独线程。`CountActor`
    和 `LogActor` 使用与 `hyper` 服务器相同的线程。但这没关系，因为演员本身不会占用很多 CPU。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at how to use thread pools in microservices. We
    investigated three approaches: using plain threads, using the `futures-cpupool`
    crate, and using the `tokio-threadpool` crate. We used channels from the `futures`
    crate to interact with threads from asynchronous code. Special crates do all the
    interaction automatically; all you need to do is call a function that will be
    executed in a separate thread.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在微服务中使用线程池。我们研究了三种方法：使用普通线程、使用 `futures-cpupool` 库和使用 `tokio-threadpool`
    库。我们使用来自 `futures` 库的通道与异步代码中的线程进行交互。特殊的库会自动完成所有交互；你所需要做的只是调用一个将在单独线程中执行的功能。
- en: Also, we got acquainted with the `actix` crate and the actors model, which helps
    to split and run tasks as separate units that are managed by a smart runtime.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们熟悉了 `actix` 库和演员模型，这有助于将任务分割成由智能运行时管理的独立单元来运行。
- en: In the next chapter, we'll learn how to interact with different databases using
    Rust, including PostgreSQL, MySQL, Redis, MongoDB, and DynamoDB.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Rust 与不同的数据库交互，包括 PostgreSQL、MySQL、Redis、MongoDB 和 DynamoDB。
