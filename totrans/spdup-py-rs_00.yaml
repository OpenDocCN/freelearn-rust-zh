- en: '*Chapter 2*: Structuring Code in Rust'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have gotten to grips with the basics of Rust, we can move on to
    structuring code over several files so we can actually solve problems with Rust.
    In order to do this, we will have to understand how to manage dependencies as
    well as how to compile a basic and structured application. We also have to consider
    the isolation of code so we can reuse it and keep the development of the application
    agile, enabling us to make changes quickly without much pain. After covering this,
    we will also get the application to interact with the user directly by accepting
    user commands. We will also utilize Rust crates. A crate is a binary or library
    that we import and use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing our code with crates and Cargo instead of `pip`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring code over multiple files and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building module interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are no longer going to be implementing simple single-page applications that
    do not rely on any third-party dependencies as we did in the first chapter. As
    a result, you will have to directly install Rust onto your computer. We will also
    be managing third-party dependencies through Cargo. You can install Rust and Cargo
    on your computer here: https://www.rust-lang.org/tools/install.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this, the best **integrated development environment**
    (**IDE**) by far for writing Rust is Visual Studio Code. It has a range of Rust
    plugins that can help you keep track of and check your Rust code. It can be installed
    using this link: [https://code.visualstudio.com/download](https://code.visualstudio.com/download).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the code files in the GitHub repository for this chapter:
    [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_two](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_two).'
  prefs: []
  type: TYPE_NORMAL
- en: Managing our code with crates and Cargo instead of pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building our own application is going to involve the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple Rust file and run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple application using Cargo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run our application using Cargo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manage dependencies with Cargo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a third-party crate to serialize JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Document our application with Cargo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we start structuring our program with Cargo, we should compile a basic
    Rust script and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, make a file called `hello_world.rs` with the main function housing
    the `println!` function with a string, as we can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, we can navigate to the file and run the `rustc` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command compiles the file into a binary to be run. If we compile on Windows,
    we can run the binary with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we compile it on Linux or Mac, we can run it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The console should then print out the string. While this can come in useful
    when building a standalone file, it is not recommended for managing programs spanning
    multiple files. It is not even recommended when relying on dependencies. This
    is where Cargo comes in. Cargo manages everything – the running, testing, documentation,
    building, and dependency out of the box – with a few simple commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have a basic understanding of how to compile a basic file, we can
    move on to building a fully fledged application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal, navigate to where you want your application to sit, and create
    a new project called `wealth_manager` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: /target
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right now, all we have is the main file that has a printout to the console
    saying *"hello world."* We can run this with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this command, we get the following output in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want to run a release, we simply run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have got our application running, let''s explore how we manage
    the metadata around it. This can all be done by editing the `Cargo.toml` file.
    When we open this, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The name, version, and authors are fairly straightforward. Here are the effects
    each section has on the project:'
  prefs: []
  type: TYPE_NORMAL
- en: If we change the `name` value in the `Cargo.toml` file, then new binaries with
    that name will be made when we build or run our application. The old ones will
    still be there too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version` is for distribution on services such as `crates.io` if we want to
    open source our application for others to use. The authors are required for this
    as well, and our application will still compile and run locally if it''s not there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edition` is the edition of Rust that we are using. Rust gets updated frequently.
    These updates accumulate through time, and every two to three years, the smoothed-out
    new features are packaged, documented, and added to a new edition. The latest
    edition (2021) is available at [https://devclass.com/2021/10/27/rust-1-56-0-arrives-delivering-rust-2021-edition-support/](https://devclass.com/2021/10/27/rust-1-56-0-arrives-delivering-rust-2021-edition-support/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have `dependencies`. This is where we can import third-party crates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see how this works, let''s use a crate to convert a data structure of stock
    into JSON and then print it. Writing the code ourselves would be a bit of a headache.
    Luckily, we can install the `serde` crate and use the `json!` macro. In order
    for Cargo to download and install the crate, we fill our dependencies section
    in our `Cargo.toml` file with the code given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `main.rs` file, we then import the macro and struct needed to convert
    data about a stock into JSON and then print it out in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that we are returning a `Value` struct from the `serde_json`
    value. In order to see how we can use the return value, we can explore the documentation
    of the struct. This is when we get to see that Rust''s documentation system is
    very comprehensive. We can find the documentation of the struct here: [https://docs.rs/serde_json/1.0.64/serde_json/enum.Value.html](https://docs.rs/serde_json/1.0.64/serde_json/enum.Value.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see in *Figure 2.1* that the documentation covers all of the functions
    that the struct supports. Our `json!` macro is returning `Object(Map<String, Value>)`.
    We also have a range of other values, depending on how we call the `json!` macro.
    The documentation also covers a range of functions that we can exploit to check
    what type the value is, whether the JSON value is `null`, and ways in which we
    can cast the JSON value as a particular type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Documentation of the serde_json value'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.01_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Documentation of the serde_json value
  prefs: []
  type: TYPE_NORMAL
- en: 'When we perform a Cargo `run` command, we will see Cargo compiling the crates
    that we defined in the dependencies. We then see the compilation of our own app,
    and the printout of the price and the data related to the stock, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to the documentation, we can create our own. This is straightforward;
    we do not have to install anything. All we have to do is create documentation
    in the code, like **docstrings** in Python. In order to demonstrate this, we can
    create a function that adds two variables together and defines the docstring,
    as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that this documentation is Markdown! This example is overkill for
    this type of function. A standard developer should be able to implement this function
    without any examples. For more complex functions and structs, it is worth noting
    that there is nothing stopping us from documenting code examples on how to implement
    what we are documenting. Building the documentation only requires the command
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After the process has finished, we can open the documentation with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This opens up the documentation in a web browser, as shown in *Figure 2.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Documentation view of our module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Documentation view of our module
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can see here is that our `main` and `add_numbers` functions are available.
    We can also see on the left that the dependencies that were installed are also
    available. If we click on our `add_numbers` function, we get to see the Markdown
    that we wrote, as shown in *Figure 2.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Documentation view of our add_numbers function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.03_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Documentation view of our add_numbers function
  prefs: []
  type: TYPE_NORMAL
- en: Here we have it – we can create interactive documentation of our code as we
    build our application. It has to be noted that the rest of the book will not have
    Markdown in the code snippets; otherwise, this would simply extend the book to
    an unnecessary length. However, it is good practice to document all structs and
    functions as you code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have run our code, set up a basic application structure, and documented
    our code, we are ready to move on to the next section of structuring our application
    over multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring code over multiple files and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to build our module, we are going to carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Map out our file and folder structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create our `Stock` structs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link our `Stock` struct to the main file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use our `stocks` module in the main file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code from another module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we are at the stage of building out our application over multiple
    files, we have to define our first module in our application, which is the **stocks
    module**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make our module have the structure defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have taken this structure to enable flexibility; if we need to add more structs,
    we can do so in the `structs` directory. We can also add other directories alongside
    the `structs` directory. For instance, we might want to build a mechanism for
    storing the data for our stocks. This can be achieved by adding a `storage` directory
    in the `stocks` directory and using this throughout the module as and when it
    is needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For now, we simply want to create a stock struct in our `stocks` module, import
    it into our `main.rs` file, and use it. Our first step is to define our `Stock`
    struct in our `stock.rs` file with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This looks familiar, as it is the same as the `Stock` struct that we defined
    in the previous chapter. However, there is a slight difference. We must note that
    there is a `pub` keyword before the struct definition and each field definition.
    This is because we have to declare them public before we can use them outside
    the file. This also applies to functions implemented in the same file, as shown
    in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that we now have a public struct that is available with all its functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now have to enable our struct to be used in the `main.rs` file. This is
    where the `mod.rs` files come in. `mod.rs` files are essentially `__init__.py`
    files in Python. They show that the directory is a module. However, unlike Python,
    Rust data structures need to be publicly declared in order to be accessed from
    other files. We can see how the struct is passed through our `stocks` module to
    our `main.rs` file in *Figure 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – How a struct is passed through modules'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.04_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – How a struct is passed through modules
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that we are merely publicly declaring the struct in the module
    furthest away from `main.rs` in the `mod.rs` file belonging to that directory.
    We then publicly declare the `structs` module in the `stocks` `mod.rs` file. Here
    is a good time to explore the `mod` expression that declares modules. If we want
    to, we can declare multiple modules in a single file. It must be stressed that
    this is not happening in our example. We could declare module one and module two
    in a single file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have defined our modules in our main example project, we just declare
    the `stocks` module in the `main.rs` file. The reason why this is not a public
    declaration is that the `main.rs` file is the entry point of our application;
    we will not be importing this module into anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our struct is available, we can simply use it as we would if it was
    defined in the same file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this code unsurprisingly gives us this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the basics of using structs from different files covered,
    we can move on to exploring other pathways of accessing data structures from other
    files in order to be more flexible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first concept we have to explore is accessing from files in the same directory.
    In order to demonstrate this, we can do a throwaway example of building a print
    function in the structs. In a new file with the `src/stocks/structs/utils.rs`
    path, we can create a toy function that merely prints out that the constructor
    for the struct is firing, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then declare it in our `src/stocks/structs/mod.rs` file with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It must be noted that we are not making it public; we just declare it instead.
    Nothing is stopping us from making it public; however, with the non-public approach,
    we only allow files within the directory of `src/stocks/structs/` to access it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now want our `Stock` struct to access it and use it in our constructor,
    which can be done with an import in `src/stocks/structs/stock.rs` with the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want to move our reference to the `src/stocks/` directory, we can use
    `super::super`. We can chain as many supers as we want, depending on how deep
    the tree is. It has to be noted that we can only access what is declared in the
    `mod.rs` file of the directory. In our `src/stocks/structs/stock.rs` file, we
    can now use the function in our constructor with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we run our application, we will get the following printout in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While we have managed to access data structures from different files and modules,
    this is not very scalable, and there are going to be some rules in which we implement
    stocks. In order to enable us to write scalable safe code, we need to lock down
    the functionality with interfaces in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building module interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike Python, where we can import anything we want from anywhere and at the
    most our IDE will just give us a syntax highlight, Rust will actively not compile
    if we try and access data structures that have not explicitly been made public.
    This gives us an opportunity to really lock down our modules and enforce functionality
    through an interface.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we get started with this, let's fully explore what functionality
    we will be locking down. It is good practice to keep modules as isolated as possible.
    In our `stocks` module, the logic should only be around how to handle stocks and
    nothing else. This might seem a little overkill, but when we think about it, we
    quickly realize that this module is going to scale when it comes to complexity.
  prefs: []
  type: TYPE_NORMAL
- en: For the demonstrative purposes of this chapter, let's just build the functionality
    for a stock order. We can either buy or sell a stock. These stock orders come
    in multiples. It's fairly common to buy *n* stocks of a company. We will also
    have to check to see whether the stock order is short or long. With a short order,
    we borrow money from the broker, buy stocks with that money, sell them instantly,
    and then buy the stocks back at a later date. If the stock price goes down, we
    make money, as we keep the difference when repaying to the broker. If we go long,
    we just buy the stock and hold it. If it goes up, we make money, so depending
    on the order, there will be different outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to remember that this is not a book for developing software around
    stock markets, so we need to keep the details simple to avoid losing ourselves.
    A simple approach for us to take to demonstrate interfaces is to take a layered
    approach, as described in *Figure 2.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Approach to a simple module interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.05_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Approach to a simple module interface
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve this approach, we can carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Structure the module layout with the right files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an enum for the different types of orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build an order struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `chrono` crate needed for `datetime` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an order constructor that utilizes the `chrono` crate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create dynamic values for the struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a close order interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an open order interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the order interfaces in the main file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we only allow ourselves to access the stock struct through the order
    struct. Again, there are other ways to approach this problem, which is a demonstration
    of how to build interfaces in Rust. In order to achieve this in the code, we have
    the file structure defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First of all, we can define our enum order types in our `enums/order_types.rs`
    file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use this in our order and interfaces. In order to make this enum type
    available to the rest of the module, we have to declare it in our `enums/mod.rs`
    file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have built our enum type, it is time to put it to work. We can
    now build our order struct in our `stocks/structs/order.rs` file with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we use the `chrono` crate to define when the order was placed; we also
    have to note what stock the order is for, the number of stocks that we are buying,
    and the type of order. We have to remember to define our `chrono` dependency on
    our `Cargo.toml` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reason why we have kept our stock struct separate from the order struct
    is to allow flexibility. For instance, there are other things that we can do with
    stock data that is not an order. We may want to build a struct that houses stocks
    on the user watch list and the user hasn't actually bought anything, but they
    still want to see the stocks available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are other use cases for stock data, however. Considering this, we can
    see that keeping the data and methods around a stock in an individual stock struct
    helps to not only reduce the amount of code we have to write if we add more features
    but also standardizes the data around a stock. This also makes it easier for us
    to maintain the code. If we add or delete a field, or change a method for stock
    data, we only have to change it in one place as opposed to multiple places. Our
    constructor for our order struct can be made in the same file with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we create an `Order` struct by accepting `stock`, `number`, and `order_type`
    arguments and creating a `datetime` struct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Because our order focuses on the logic around pricing the order as it houses
    the number of stocks brought in an order, in our `impl` block, we can build our
    current value of the order with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It has to be noted that we have used `&self` as a parameter instead of just
    using `self`. This enables us to use the function multiple times. If the parameter
    was not a reference, then we would move the struct into the function. We would
    not be able to calculate the value multiple times, and it's going to be useful
    to do so unless the type is `Copy`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also build on this function to calculate the current profit in the `impl`
    block with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we get the current price and the initial price. We then match the order
    type, as this will change how the profit is calculated. Now our structs are complete,
    we have to ensure that the structs are available by defining them in the `stocks/structs/mod.rs`
    file with the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to create our interfaces. In order to build our interface
    in our `stocks` `/mod.rs` file, we initially have to import everything that we
    need, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have everything to build our interface, we can build our close
    order interface with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a fairly simple interface; we could do more, such as a database or
    API call, but for this demonstration, we merely print that the stock is being
    sold and return the current profit that we have made. With this in mind, we can
    build our more complex interface by opening an order in the same file with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we take in all of the parameters that we need. We have also introduced
    the `Option<f32>` argument type, which is implemented as an enum type. This allows
    us to pass in a `None` value. We then create a mutable stock (as the price will
    vary and we will have to update it), and then check to see whether the `stop_loss`
    value is provided; if it is, we then add the stop loss to the stock. We then check
    to see whether the `take_profit` value is provided, updating the stock with this
    if it is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have built all our interfaces, all we need to do is to use them
    in the `main.rs` file. In the main file, we need to import the needed structs
    and interfaces to utilize them with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our main function, we can start putting these interfaces to work by creating
    a new mutable order with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have set `take_profit` and `stop_loss` to `None`, but we can add them
    if we need to. To clarify what we have just bought, we can print out the current
    value and profit with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then get some movement in the stock market, which we can simulate by updating
    the price and printing the value of our investment at each change with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have a profit, and we will sell our stock to close the order and print
    out the profit with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, our interfaces, module, and main file are built. Running the Cargo `run`
    command gives us the following printout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we can see, our module works and it has a clean interface. For this book,
    our example stops here, as we have shown how we can build modules in Rust with
    interfaces. However, if you want to go further with building out the application,
    we can take the approach seen in *Figure 2.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Building out our application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.06_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Building out our application
  prefs: []
  type: TYPE_NORMAL
- en: In the account module, we would build data structures around keeping track of
    the amount the user has through trades. We would then build a storage module that
    has read and write interfaces for accounts and stocks. The reason why storage
    is a separate module is that we can keep the interfaces the same, and chop and
    change the storage logic under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we could start with a simple JSON file storage system for development
    and local usage; however, the application then gets put onto a server, and loads
    of users start making trades and accessing their accounts. We can switch the file
    reading and write for a database driver with database model mapping. The system
    then gets a lot of traffic and the application gets split into a cluster of microservices.
    One application would still be talking to a database, while another one for frequently
    requested stocks/accounts could be talking to a Redis cache.
  prefs: []
  type: TYPE_NORMAL
- en: Considering this, keeping the storage separate keeps us flexible. Changing the
    requirements for the storage is not going to break the build. In fact, a configuration
    file could enable the switching of different methods, depending on the environment.
    As long as the interfaces remain the same, refactoring will not be a huge task.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of documentation when coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As our module spans multiple files, we are now referencing functions and structs
    that are in different files. This is where the importance of documentation can
    be seen. We can revisit our point in the technical requirements of using Visual
    Studio Code. The code in GitHub is fully documented. If the Rust plugins are installed,
    merely hovering the mouse over the struct or function will pop up the documentation,
    allowing us to see what is needed in our interface, as shown in *Figure 2.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Popup documentation in Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.07_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Popup documentation in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: There is a reason why badly structured code that isn't documented is referred
    to as *tech debt*, and this is because it collects interest over time. Poorly
    structured code with no documentation is quick to develop, however, and as the
    size of the application grows, it's going to get harder to change things and understand
    what is going on. A well-structured module with good Markdown Rust documentation
    is a great way to keep you and your team's productivity high.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a functioning application that spans multiple pages and is clean
    and scalable. However, a user cannot dynamically use it, as everything has to
    be hardcoded. This is not practical. In the next section, we interact with the
    environment so we can pass arguments into the program.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are at the stage in which the only thing that is holding us back from building
    a fully functioning command-line application is interacting with the environment.
    As stated in the previous section, this is an open-ended subject that spans anything
    from taking command-line arguments to interacting with servers and databases.
    As in the previous section, we will cover enough in order to get an understanding
    of how to structure Rust code that accepts data from the outside and processes
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In order to explore this, we are going to get our stock application to take
    in command-line arguments from the user so that we can either buy or sell a stock.
    We will not over-complicate things by choosing whether to go short or go long,
    and we will not introduce storage.
  prefs: []
  type: TYPE_NORMAL
- en: However, by the end of this section, we will be equipped to approach building
    code that scales and accepts data from the outside world. With this, further reading
    on crates that connect to databases or read/write files will enable us to seamlessly
    add them to our well-structured code. In terms of databases, we will cover how
    to mirror the schema of a database and connect to it in [*Chapter 10*](B17720_10__Final_SK_ePub.xhtml#_idTextAnchor182),
    *Injecting Rust into a Python Flask App*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our toy example, we will be generating a random number for our sale stock
    price in order to calculate whether we sell at a profit or loss. We will do this
    by adding the `Cargo.toml` file with `rand="0.8.3"`. We can interact with our
    environment by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import all the required crates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the inputs from the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process our inputs with orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our `rand` crate has been added, we can add all the extra imports
    that we need in the `main.rs` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using `env` to get the arguments passed into Cargo. We import everything
    from the prelude of the `rand` crate so that we can generate random numbers, and
    we import `FromStr` trait so that we can convert strings passed in from the command-line
    arguments into numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our main function, we initially collect the arguments passed in from the
    command line with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We state that we are going to collect the command-line arguments in a vector
    of strings. We do this because pretty much everything can be represented as a
    string. We then define all the parameters that we need. We have to note that we
    start at index `1` instead of `0`. This is because index `0` is populated with
    the `run` command. We can also see that we are converting the strings into numbers
    when we need them and directly unwrapping them. This is a little dangerous; we
    should ideally match the result of the `from_str` function and give better information
    to the user if we were building a proper production command-line tool.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have everything we need, we create a new order with the data we
    collected using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are creating a new order every time even if it is a sell because we do not
    have storage, and we need to have all the structured data and logic around our
    stock position. We then match our actions. If we are going to sell our stock,
    we generate a new price for the stock before selling. Considering this, we can
    see whether we make a profit or not with the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It must be noted that we have a `_` at the end of the match expression. This
    is because the string could theoretically be anything and Rust is a safe language.
    It will not allow us to compile the code if we did not account for every outcome.
    The `_` is a catch-all pattern. If not all of the match patterns are made, then
    this is executed. For us, we merely raise an error, stating that only sell and
    buy are supported.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to run this program, we perform the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this will give us the following outcome:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The profit you make will be different, as the number generated will be random.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here we have it – our application is interactive and scalable. If you want to
    build more comprehensive command-line interfaces with help menus, it is recommended
    that you read and utilize the `clap` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the basics of Cargo. With Cargo, we managed
    to build basic applications, document them, compile them, and run them. Looking
    at how clean and easy this implementation was, it is clear to see why Rust is
    one of the most favored languages. Managing all the functionality, documentation,
    and dependencies in one file with a few lines of code speeds up the whole process.
    Combining this with a strict, helpful compiler makes Rust a no-brainer when it
    comes to managing complex projects. We managed our complexity by wrapping our
    module in easy-to-use interfaces and interacting with the user's inputs through
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, as you stand, you can start building Rust code to solve a range of
    problems. If you want to build an application that interacts as a Rust web server
    with a frontend and database, I recommend that you read my other book on web development
    in Rust, *Rust Web Programming*, and start at [*Chapter 3*](B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046),
    as you have now covered enough Rust fundamentals to start building Rust servers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter of this book, we will cover how to exploit Rust's concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we continue to code, how do we document it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to keep modules isolated to a single concept?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we enable our modules to keep the advantages of isolated modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we manage dependencies in our application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we ensure that all outcomes in a match expression are accounted for when
    there is theoretically an infinite number of outcomes, such as matching different
    strings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's say that we have a struct called `SomeStruct` in a `some_file/some_struct.rs`
    file. How do we make this available outside of the directory that it is in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's say that we have changed our mind about our `SomeStruct` struct in question
    6 and we want it only available in the `some_file/` directory. How would we do
    this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we access our `SomeStruct` struct in the `some_file/another_struct.rs`
    file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our docstrings can support Markdown while we are building our structs and functions.
    Because it's Markdown, we can document ways in which we can implement the struct
    or function. If we are using Visual Studio Code, this also helps our productivity,
    as merely hovering the mouse over the function or struct throws up the documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping our modules constrained to a single concept increases the flexibility
    of the application, enabling us to chop and change modules as and when they are
    needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to keep our modules isolated, we need to keep the interfaces of the
    module the same; this means that we can change logic inside the module without
    having to alter anything in the rest of the application. If we delete the module,
    we only have to look for implementations of the interface throughout the application
    as opposed to the implementation of all functions and structs in the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We manage our dependencies in the `Cargo.toml` file. Just running Cargo will
    install the requirements we have when it is compiling before running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can account for everything by catching anything that hasn't satisfied all
    our matches. This is done by implementing a `_` pattern at the end of our match
    expression, executing the code attached to that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make it publicly available by writing `pub mod some_struct;` in the `some_file/mod.rs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make it available only in the `some_file/` directory by writing `mod some_struct;`
    in the `some_file/mod.rs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can access the `SomeStruct` by typing `use super::some_struct::SomeStruct;`
    in the `some_file/another_struct.rs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Rust Web Programming*, *Maxwell Flitton*, *Packt Publishing* (2021)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Rust*, *Rahul Sharma and Vesa Kaihlavirta*, *Packt Publishing* (2019)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Rust Programming Language*, Rust Foundation: [https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)
    (2018)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Clap documentation*, Clap Docs: [https://docs.rs/clap/2.33.3/clap/](https://docs.rs/clap/2.33.3/clap/)
    (2021)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The standard file documentation*, Rust Foundation: [https://doc.rust-lang.org/std/fs/struct.File.html](https://doc.rust-lang.org/std/fs/struct.File.html)
    (2021)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The chrono DateTime documentation*, Rust Foundation: ,https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html
    (2021)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
