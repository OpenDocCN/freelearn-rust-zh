- en: Implementing an Asynchronous FTP Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we wrote a synchronous FTP server. Now, we''ll write
    an asynchronous version with `tokio`, the asynchronous IO (Input/Output) library
    for Rust. We''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Futures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async/await
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of asynchronous IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous IO allows us to send a request without waiting for its result,
    we'll get notified somehow later when we receive the response. This enables our
    programs to be more concurrent and scale better.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we used threads in order to avoid blocking other clients
    while we wait for a response. Using threads has a cost, though, besides the fact
    that threads require more memory, they also impose a performance cost because
    they require a context switch when the code goes from one thread to the other.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of asynchronous IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, using asynchronous IO does not come without drawbacks. Using asynchronous
    IO is harder than using synchronous IO. With asynchronous IO, we also need a way
    to know when an event has terminated. So, we need to learn a new way to manage
    the IO events and it'll take more time to implement the same software that we
    wrote in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new binary project, as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add the following dependencies in the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see here, we specify a dependency via a Git URL. This dependency
    is using nightly-only features, so make sure you''re using the nightly compiler
    by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start our `main` module by adding the required `extern crate` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're using some nightly features. These are needed by the `futures-await`
    crate. We also decided to import this crate under another name, `futures`, because
    it exports the same types and functions as the `futures` crate itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll copy some code from the previous chapter and put them in the new module,
    for better organization. Here are the new modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new file, called `src/cmd.rs`, put the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We first have an enumeration representing the different commands and their
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a method to get the string representation of a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor parses a byte string as a `Command`. This requires a function
    to convert a byte string to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply decrement all lowercase letters by 32 to convert them to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have an enumeration for the transfer type and a function to parse
    a byte character to this type. And in another file, `src/ftp.rs`, let''s write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We're now ready to start working on the FTP server itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using Tokio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tokio is based on the lower-level crate mio, which is itself directly based
    on system calls such as `epoll` (Linux), `kqueue` (FreeBSD), and IOCP (Windows).
    This crate is also based on the `futures` crate, which provides abstractions to
    reason about a value (or multiple values) that will be available later. As I told
    you when using asynchronous I/O, the calls do not block so we need a way to know
    when the result of a read is available. This is where `Future` and `Stream`, two
    abstractions from the `futures` crate, come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Tokio event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tokio also provides an event loop, on which we will be able to execute some
    code (with `futures`) that will be executed when some I/O events happen, such
    as when the result of a socket read is ready. To do so, the event loop will register
    events on specific file descriptors that represent sockets. It registers these
    events using the aforementioned system calls and then waits for any of the registered
    events to happen. The file descriptors and the system calls are low-level stuff
    that we do not need to know to use `tokio`, but it is important to understand
    how it works at the lower level. For instance, `epoll` does not support regular
    files, so if you try to wait for an event to happen on a regular file, it could
    block even though we're using asynchronous I/O which should not block.
  prefs: []
  type: TYPE_NORMAL
- en: Using futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `future` represents a value that will be available later, or an error, similar
    to the `Result` type. A `stream` represents multiple values (or errors) that will
    be available at different times in the `future`, similar to an `Iterator<Result<T>>`.
    This crate provides many combinators such as `and_then()`, `map()`, and others
    similar to the one available on the `Result` type. But, we won't use them, preferring
    the `async`/`await` syntax that we'll see later.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start coding the FTP server, let's talk about how we'll be handling
    the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Unwrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous projects, we used the `unwrap()` or `expect()` methods a lot.
    These methods are handy for fast prototyping, but when we want to write high-quality
    software, we should avoid them in most cases. Since we're writing an FTP server,
    a software that must keep running for a long time, we don't want it to crash because
    we called `unwrap()` and a client sent a bad command. So, we'll do proper error
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: Custom error type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we can get different types of errors and we want to keep track of all
    of them, we''ll create a custom error type. Let''s create a new module in which
    we''ll put this new type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add it to the `src/error.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an enum representing the different errors that can happen in our
    FTP server to be implemented. There are UTF-8 errors since FTP is a string-based
    protocol and I/O errors because we communicate over the network and communication
    issues can happen. We created variants for error types coming from the standard
    library, which will be helpful later when we want to compose different types of
    errors. We also created a variant `Msg` for our own errors and we represent them
    as a `String` since we only want to show them in the terminal (we could also log
    them to `syslog`, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: This is the standard way in Rust to represent an error type. It's a good practice
    to create this type, especially if your crate is a library, so that the users
    of your crate can know exactly why an error happened.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we want to print the error to the terminal, we''ll implement the `Display` trait
    for our `Error` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For the three cases where we wrap an error from another type, we just call the
    corresponding `fmt()` method of these errors. In the case that it is a `Msg`,
    we write the string using the `write!` macro. This macro is a bit similar to `print!`,
    but needs a parameter to specify where to write the formatted data.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not very helpful in our case, but it is recommended to also implement
    the `Error` trait for custom error types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The only required method of this trait is `description()`, which returns a short
    description of the error. Again, in the three cases, we just call the `description()`
    method from the wrapped type itself. And, for our `Msg` variant, we return the
    wrapped message.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible that we don''t have a string to return from this method. If
    it is the case, we can just return `&''static str`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `cause()` method is optional and is used to return the cause of the error.
    Here, we return the inner error when there's one in the variant and return `None`
    for our `Msg` variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trait `Error` requires the `Self` type to implement both `Display` and
    `Debug`. We implemented `Display` earlier, but we don''t implement `Debug` yet.
    Let''s fix that by adding an attribute in front of the type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It is good practice to provide a type alias named `Result` that is specialized
    for our error type. Let''s write one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By doing so, we hide the original `Result` type from the standard library. That's
    why we're specifying a qualified version of this type. Otherwise, the compiler
    will assume that it is a recursive type, which is not the case here. We'll have
    to be careful when we import this type in other modules, because it hides the
    `Result` type. In case we want to use the original `Result` type, we'll have to
    use the same trick; qualifying it.
  prefs: []
  type: TYPE_NORMAL
- en: Composing error types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing we need to do in order to use all the good practices for error
    types in Rust is to make them easy to compose, because, for now, if we have another
    error type, such as `io::Error`, we would need to use the following code every
    time we have another type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This can quickly become cumbersome. To improve that, we''ll implement the `From` trait
    for different error types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These implementations are easy to understand: if we have an `io::Error`, we
    just wrap them in the corresponding variant. We also added a convenient conversion
    from the `&str` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will allow us to use the following, which is not really better, but the
    good old `?` operator will help us to reduce the boilerplate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The ? operator, revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This operator will not only return the error if there is one, but will also
    convert it to the required type. It converts it with a call to `Into::into()`,
    `Into` being a trait. But why did we implement the `From` trait, instead of `Into`?
    Because there''s a generic implementation of `Into` which is based on `From`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to this implementation, we rarely need to implement the `Into` trait
    ourselves. We only need to implement the `From` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can rewrite the previous code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And it will behave exactly the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Tokio event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `tokio`, the object we need to use to manage an event loop is `Core`. Here''s
    how we start an event loop using `tokio` (in the `main` module):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We first create a new `Core` object, and then call the `run()` method to start
    the event loop. The latter method will return when the provided future ends. Here,
    we call `server()` to get the future, so let''s write this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `#[async]` attribute. Since attributes are currently
    instable in Rust, we had to specify that we are using the `proc_macro` feature.
    We also import the `async` attribute from the `futures_await` crate (which was
    imported under the name `futures`). So don't forget the `#![feature]` attribute
    and the `extern crate` statements at the top.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute allows us to write a normal function, returning a `Result`, and
    will convert this function to actually return a `Future`. This function does nothing
    and returns `Ok(())`, so when you run the program, it will end immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another syntax we could have used that is provided by the `futures-await`
    crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We won't use this syntax in our FTP server, but it is worth knowing about. By
    using an `async_block`, we are not required to create a new function.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program we just wrote does absolutely nothing, so let''s update it so that
    it at least starts a server, using `tokio`. Let''s write an actual body to our
    `server()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The function now takes a `Handle`, which will be useful to specify on which
    event loop the server must run. We start this function by specifying on which
    port we want to start the server by creating a `SocketAddr`. Then, we create a
    `TcpListener` in a similar way to how we would create a synchronous `TcpListener`
    from the standard library. The difference here is that we also send the `handle`
    as an argument to specify on which event loop we want the server to run. After
    that, we use the `#[async]` attribute again, but on a `for` loop this time.
  prefs: []
  type: TYPE_NORMAL
- en: Async `for` loops are used to iterate over a `Stream`, returning an error if
    there is one. These async loops can only be used in an `#[async]` function. In
    the loop, we spawn the future returned by `handle_client()`. Spawning a future
    means that it will be executed and handled by the event loop. The difference with
    `Core::run()` is that the future must return `()` and the error should also be
    `()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that this function takes an argument, we''ll need to update the `main`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Handling clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now see the `handle_client()` function we''ve just mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is a simple wrapper over the `client` future. Here, we used a new macro,
    `await!`, which allows us to write asynchronous code in an asynchronous way. When
    the result of the future inside `await!()` is not ready, the event loop will execute
    other stuff, and when it's ready it will continue executing the code after the
    `await!()`. In this case, we print the error returned by the `client` future.
    This is why we needed a wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write this `client` future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we specify that the `stream` will be handled by a `FtpCodec`, which means
    that we''ll be able to encode and decode structured data instead of dealing with
    bytes directly. We''ll write this `FtpCodec` soon. Then, we split the stream between
    a `reader` and a `writer`. This `split()` method is very useful in Rust, because
    of ownership: we cannot have two owners, one that will write to the socket and
    another that will read to it. To fix this issue, we split the stream and we can
    now have an owner for the `reader` and another owner for the `writer`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the `writer` to send a welcome message. Again, we use the `await!`
    macro to specify that the code after will be executed when the message is sent
    (but without blocking the whole program, thanks to asynchronous I/O). Next, we
    create a `Client` which will be the object that will manage a client, by executing
    the appropriate actions when it receives commands and sending the right responses.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we use again an `#[async] for` loop to iterate over a stream; here,
    we iterate over the stream of the data received by this specific client. In the
    `for` loop, we call the `handle_cmd()` method that we will soon write. This method,
    as its name indicates, will handle the command received from this FTP client,
    act accordingly, and send a response back. Here, we use `await!()?` with a question
    mark at the end. The `futures-await` crate allows us to do so; this means that
    if the future returned an error, this error will propagate to the `client` future,
    which is the same semantic for the normal `?` operator used in a function returning
    a `Result`. We'll see why we reassign the result to `client` when we write the
    `handle_cmd()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Handling commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle the commands received by the FTP server, we''ll have a `Client` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The client contains a `Writer` object that will be useful to send messages
    to the client. The `Writer` type represents a `Sink` that has been split, and
    uses the `FtpCodec` on a `TcpStream`. A `Sink` is the opposite of a `Stream`:
    instead of representing a sequence of values that are received, it represents
    a sequence of values that are sent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We used two methods on `Client`, so let''s write them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is very simple and creates the `struct` with the provided argument.
    The `handle_cmd()` receives the command sent to the FTP server by this specific
    client and will handle them; we''ll write the code to handle them progressively
    in this chapter and the next. For now, it only returns `self`. Also, take note
    that this method receives `self` by move, instead of by `reference`. This is due
    to a current limitation of the `futures-await` crate: for now, async functions
    cannot take a reference. This issue will probably be fixed later, which will make
    the code even better. This is why we reassigned to the `client` variable in the
    `client` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: FTP codec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only remaining thing to code before we can try our FTP server is the `codec`.
    So, let''s create a new module for the `codec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `src/codec.rs` file, we''ll create our FTP `codec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a `codec`, we must implement the traits `Decoder` and `Encoder`.
    These traits come from the `tokio-io` crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Decoding FTP commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first write the decoder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `Decoder` trait has two associated types, `Item` and `Error`. The former
    is the type produced when we're able to decode a sequence of bytes. The latter
    is the type of the error. We first check if there the bytes `CR` and `LF`. If
    we don't find them, we return `Ok(None)` to indicate that we need more bytes to
    parse the command. If we find them, we get the line of the command, excluding
    these bytes. Then, we skip these bytes so that the next parsing does not see them.
    Finally, we parse the line with `Command::new()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used two new functions here that we must implement. The first one is the
    `Error::to_io_error()` method that we''ll add to the `error` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If we have an `Io` error, we return it. Otherwise, we return the `Other` kind
    of I/O error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `decode()` methods also uses the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This returns the position of the byte string `"\r\n"` if it is present. Remember
    that this string is the delimiter in the FTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding FTP commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We still need to write an `Encoder` in order to have a `codec` that can send
    commands to FTP clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, if we have a non-empty message, we push it to the buffer, preceded by
    the FTP code number. Otherwise, we only push this code number to the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now try the FTP server in FileZilla to see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)*Figure 9.1*'
  prefs: []
  type: TYPE_NORMAL
- en: Handling commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `handle_cmd()` method does nothing, for now, so let''s update it. First
    of all, we''ll need a method to send a response to a client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This simply calls the `send()` method of the `writer`. Since it consumes it,
    we reassign the result to the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll handle the `USER` FTP command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we pattern match to know which command was sent by the client. If it is
    not `User`, we send a response to say that the command is not implemented. If
    it is `User`, we check the content and if it is good, we send the welcome message.
    This is very similar to what we did in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the server again, we''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/00044.jpeg)*Figure 9.2*'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the current working directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are still a few commands missing before we can see the files in the FTP
    client. Let's now add the command to print the current directory and to change
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the current directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we''ll need a new attribute for our `Client` structure to specify
    what the current directory is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cwd` attribute stands for current working directory. We also need to update
    the `Client` constructor accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the handler for the `PWD` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So, again, we have a code similar to the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the current directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add another case in our `match` expression in the `handle_cmd()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It simply calls the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This code uses the following two methods, which are similar to those in the
    previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it uses a new attribute, let''s add it to the `Client` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to pass this value in a few places, first, in the `client` function
    and its wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to update the `server` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To send the server root to the `handle_client` function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we''ll update the main function to send it to the `server` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we send the current directory as the server root.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the transfer type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a new command before we test our server again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This requires a new attribute for our `Client` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to update the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this new server and connect to it through FileZilla, we''ll see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg) *Figure 9.3*'
  prefs: []
  type: TYPE_NORMAL
- en: Entering passive mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now write the code to handle the `PASV` command. Add the following case
    in `handle_cmd()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For the following, we''ll need four new fields in the `Client` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And all of them are initialized to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This requires changing a few other functions to send the `Handle` to the `Client`
    constructor. First, the `client` function now requires a new `handle` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handle_client()` method also needs to take a new parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `server()` function, you need to send the `handler` to the `handle_client()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the start of the method that does the real stuff for the `PASV`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If a port was set by an earlier command, we use it, otherwise, we use zero
    to ask the system to choose one. As you know from the previous chapter, there
    are two channels in FTP—the command channel and the data channel. So, here, we
    check whether the data channel is already open. If that is the case, we send the
    appropriate response and end the function by returning. Here''s the rest of the
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by starting the listener for the data channel. See the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is used to get the port that was chosen by the system, if we specified
    port `0` to let the operating system choose a port. Then, we use an `async for`
    loop that breaks immediately after the first iteration because we only have one
    client that will connect to this new channel. In the loop, we're using the same
    split trick again; after saying that our stream uses the `BytesCodec`, we split
    the stream between the `writer` and the `reader`. We'll describe this new `codec`
    shortly. We then same both the data `writer` and `reader`.
  prefs: []
  type: TYPE_NORMAL
- en: Bytes codec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating an empty structure for the `codec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Decoding data bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Then, we implement the `Decoder` trait like we did for the `FtpCodec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Since the data of a transmitted file can be binary, we cannot use an `Item`
    of type `String`. We instead use `Vec<u8>`, which we can contain every possible
    byte. If the buffer is empty, we return `Ok(None)` to indicate to `tokio` that
    we need more data. Otherwise, we convert it to a vector, clear the buffer and
    return the vector.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding data bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now see how to encode data; it''s even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We just extend the buffer with the data.
  prefs: []
  type: TYPE_NORMAL
- en: Quitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now implement the `QUIT` command. As always, we need to add a case in
    the `handle_cmd()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the code of the `quit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: So, we send a response back to the client and `close()` the `writer`.
  prefs: []
  type: TYPE_NORMAL
- en: To finish this chapter, let's implement the command to create and delete directories.
  prefs: []
  type: TYPE_NORMAL
- en: Creating directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by handling the command to create a new directory. So, we add
    a case in `handle_cmd()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And the function handling this command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We first check that the `parent` directory is valid and under the server root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If it is, we create the directory. Otherwise, we send an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'This requires two new functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: These are simple wrappers over the methods from the standard library, doing
    type conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Removing directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s see the code to remove directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Like for the previous commands, we add a new case that calls the method that
    will handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here again, we check that the directory is valid and under the server root,
    and delete it if that is the case. Otherwise, we send an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a lot of commands for our asynchronous FTP server
    and learned about using `tokio`. We also saw in more detail what asynchronous
    I/O is, and its advantages and disadvantages. We used the new `async`/`await`
    syntax to simplify the code using `tokio`. We learned what futures and streams are, and
    how they interact with `tokio`. We also saw how to do proper error handling and
    how to do it concisely. In the next chapter, we'll complete the implementation
    of the FTP server and see how to test it.
  prefs: []
  type: TYPE_NORMAL
