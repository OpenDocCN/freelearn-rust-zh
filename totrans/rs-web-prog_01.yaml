- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Quick Introduction to Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Rust** is growing in popularity, but it has a steep learning curve. By covering
    the basic rules around Rust, as well as learning how to manipulate a range of
    data types and variables, we will be able to write simple programs in the same
    fashion as dynamically-typed languages using a similar number of lines of code.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to cover the main differences between Rust and generic
    dynamic languages and to provide you with a quick understanding of how to utilize
    Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is Rust revolutionary?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing data types and variables in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling variable ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaprogramming with macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have covered the main concepts in this chapter, you will be able to
    code basic programs in Rust that will run. You will also be able to debug your
    programs and understand the error messages that are thrown by the Rust compiler.
    As a result, you will have the foundations to be productive in Rust. You will
    also be able to move on to structuring Rust code over multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we only need access to the internet as we will be using the
    online Rust playground to implement the code. The code examples provided can be
    run in the online Rust playground at [https://play.rust-lang.org/](https://play.rust-lang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For detailed instructions, please refer to the file found here: [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter01](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter01)'
  prefs: []
  type: TYPE_NORMAL
- en: Why is Rust revolutionary?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With programming, there is usually a trade-off between speed and resources and
    development speed and safety. Low-level languages such as C/C++ can give the developer
    fine-grained control over the computer with fast code execution and minimal resource
    consumption. However, this is not free. Manual memory management can introduce
    bugs and security vulnerabilities. A simple example of this is a buffer overflow
    attack. This occurs when the programmer does not allocate enough memory. For instance,
    if the buffer only has a size of 15 bytes, and 20 bytes are sent, then the excess
    5 bytes might be written past the boundary. An attacker can exploit this by passing
    in more bytes than the buffer can handle. This can potentially overwrite areas
    that hold executable code with their own code. There are other ways to exploit
    a program that does not have correctly managed memory. On top of increased vulnerabilities,
    it takes more code and time to solve a problem in a low-level language. As a result
    of this, C++ web frameworks do not take up a large share of web development. Instead,
    it usually makes sense to go for high-level languages such as Python, Ruby, and
    JavaScript. Using such languages will generally result in the developer solving
    problems safely and quickly.
  prefs: []
  type: TYPE_NORMAL
- en: However, it must be noted that this memory safety comes at a cost. These high-level
    languages generally keep track of all the variables defined and their references
    to a memory address. When there are no more variables pointing to a memory address,
    the data in that memory address gets deleted. This process is called garbage collection
    and consumes extra resources and time as a program must be stopped to clean up
    the variables.
  prefs: []
  type: TYPE_NORMAL
- en: With Rust, memory safety is ensured without the costly garbage collection process.
    Rust ensures memory safety through a set of ownership rules checked at compile
    time with a borrow checker. These rules are the quirks mentioned in the following
    section. Because of this, Rust enables rapid, safe problem-solving with truly
    performant code, thus breaking the speed/safety trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: Memory safety
  prefs: []
  type: TYPE_NORMAL
- en: Memory safety is the property of programs having memory pointers that always
    point to valid memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'With more data processing, traffic, and complex tasks lifted into the web stack,
    Rust, with its growing number of web frameworks and libraries, has now become
    a viable choice for web development. This has led to some truly amazing results
    in the web space for Rust. In 2020, Shimul Chowdhury ran a series of tests against
    servers with the same specs but different languages and frameworks. The results
    can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Results of different frameworks and languages by Shimul Chowdhury
    (found at https://www.shimul.dev/posts/06-04-2020-benchmarking-flask-falcon-actix-web-rocket-nestjs/)](img/Figure_1.1_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Results of different frameworks and languages by Shimul Chowdhury
    (found at https://www.shimul.dev/posts/06-04-2020-benchmarking-flask-falcon-actix-web-rocket-nestjs/)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we can see that there are some variations in the languages
    and frameworks. However, we must note that the Rust frameworks comprise Actix
    Web and Rocket. These Rust servers are in a completely different league when it
    comes to total requests handled and data transferred. Other languages, such as
    Golang, have come onto the scene, but the lack of garbage collection in Rust has
    managed to outshine Golang. This was demonstrated in Jesse Howarth’s blog post
    *Why Discord is switching from Go to Rust*, where the following graph was published:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Discord’s findings => Golang is spikey and Rust is smooth (found
    at https://discord.com/blog/why-discord-is-switching-from-go-to-rust)](img/Figure_1.2_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Discord’s findings => Golang is spikey and Rust is smooth (found
    at https://discord.com/blog/why-discord-is-switching-from-go-to-rust)
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collection that Golang was implementing to keep the memory safe
    resulted in 2-minute spikes. This is not to say that we should use Rust for everything.
    It is best practice to use the right tool for the job. All these languages have
    different merits. What we have done in the preceding figure is merely display
    Rust’s merits.
  prefs: []
  type: TYPE_NORMAL
- en: The lack of need for garbage collection is because Rust uses enforced rules
    to ensure memory safety using the borrow checker. Now that we have understood
    why we want to code in Rust, we can move on to reviewing data types in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing data types and variables in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have coded in another language before, you will have used variables and
    handled different data types. However, Rust does have some quirks that can put
    off developers. This is especially true if the developer has come from a dynamic
    language, as these quirks mainly revolve around memory management and reference
    to variables. These can be intimidating initially, but when you get to understand
    them, you will learn to appreciate them. Some people might hear about these quirks
    and wonder why they should bother with the language at all. This is understandable,
    but these quirks are why Rust is such a paradigm-shifting language. Working with
    borrow checking and wrestling with concepts such as lifetimes and references gives
    us the high-level memory safety of a dynamic language such as Python. However,
    we can also get memory safe low-level resources such as those delivered by C and
    C++. This means that we do not have to worry about dangling pointers, buffer overflows,
    null pointers, segmentation faults, data races, and other issues when coding in
    Rust. Issues such as null pointers and data races can be hard to debug. With this
    in mind, the rules enforced are a good trade-off as we must learn about Rust’s
    quirks to get the speed and control of non-memory safe languages, but we do not
    get the headaches these non-memory-safe languages introduce.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do any web development, we need to run our first program. We can do
    this in the Rust playground at [https://play.rust-lang.org/](https://play.rust-lang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have never visited the Rust playground before, you will see the following
    layout once you are there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will look like the following screenshot when it comes to
    using the online Rust playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – View of the online Rust playground](img/Figure_1.3_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – View of the online Rust playground
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `hello world` code, what we have is a `main` function, which is our
    entry point. This function fires when we run our program. All programs have entry
    points. If you have not heard of the concept before, due to coming from a dynamic
    language, the entry point is the script file that you point your interpreter at.
    For Python, a closer analogy would be the `main` block that runs if the file is
    directly run by the interpreter, denoted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to code in Python, you would probably see this used in a Flask
    application. Right now, we have not done anything new. This is a standard *Hello
    World* example with a little change in syntax; however, even with this example,
    the string that we are printing is not all that it seems. For instance, let us
    write our own function that accepts a string and prints it out with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code should just work. We pass it into our function and print it. However,
    if we do print it, we get the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is not very straightforward, but it brings us to the first area we must
    understand if we are to code in Rust, and this is strings. Don’t worry, strings
    are the quirkiest variable that you need to get your head around to write functional
    Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: Using strings in Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we explore the error in the previous section, let us rectify it, so
    we know what to work toward. We can get the `print` function to work without any
    errors with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did was create a `String` from `"hello world"` and passed the `String`
    into the `print` function. This time the compiler did not throw an error because
    we always know the size of a `String`, so we can keep the right amount of memory
    free for it. This may sound counterintuitive because strings are usually of different
    lengths. It would not be a very flexible programming language if we were only
    allowed to use the same length of letters for every string in our code. This is
    because strings are essentially pointers implemented as a vector of bytes, which,
    in Rust, is denoted as `Vec<u8>`. This holds a reference to the string content
    (`str`, also known as a string slice) in the heap memory, as seen in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_1.4_B18722.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – A string’s relationship to str “one”
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see, in *Figure 1**.4*, that a string is a vector of three numbers.
    One is the actual memory address of the `str` it is referencing. The second number
    is the size of the memory allocated, and the third is the length of the string
    content. Therefore, we can access string literals in our code without having to
    pass variables of various sizes around our code. We know that `String` has a set
    size and, therefore, can allocate this size in the `print` function. It also must
    be noted that `String` is on the stack memory while our string literal is on the
    heap memory. Considering that we know that `String` has a set size while our string
    literal varies, we can deduce that the stack memory is used for predictable memory
    sizes and is allocated ahead of time when the program runs. Our heap memory is
    dynamic, and therefore memory is allocated when it is needed. Now that we know
    the basics of strings, we can use the different ways in which they are created,
    as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We must note, however, that creating `string_three` is expensive as we must
    copy the underlying data in the heap, and heap operations are expensive. This
    is not a unique quirk of Rust. In our example, we are just experiencing what happens
    under the hood. For instance, if we alter strings in Python, we will have different
    outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Looping through and adding the strings is slower because Python must allocate
    new memory and copy the entire string to that new memory address. The `join` method
    is faster because Python can allocate the memory of all the data of the list and
    then copy over the strings in the array, meaning the string must only be copied
    once. This shows us that although high-level languages like Python may not force
    you to think about the memory allocation of strings, you will still end up paying
    the price if you don’t acknowledge it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass a string literal into the `print` function by borrowing it,
    as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The borrow is denoted by `&`. We will go into borrowing later in the chapter.
    For now, however, we can deduce that the borrow is only a fixed-size reference
    to a variable-sized string slice. If the borrow was a fixed size, we would not
    be able to pass it into the `print` function because we would not know the size.
    At this point, we can comfortably use strings in Rust productively. The next concept
    that we must understand before we start writing Rust programs is integers and
    floats.
  prefs: []
  type: TYPE_NORMAL
- en: Using integers and floats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most high-level web programming languages, we merely assign a float or integer
    to a variable name and move on with the program. However, from what we have been
    exposed to in the previous section on strings, we now understand that we must
    worry about memory size when using strings in Rust. This is no different with
    integers and floats. We know that integers and floats have a range of sizes. Therefore,
    we must tell Rust what we are passing around our code. Rust supports signed integers,
    which are denoted by `i`, and unsigned integers, which are denoted by `u`. These
    integers consist of 8, 16, 32, 64, and 128 bits. Exploring the math behind numbers
    being represented in binary is not relevant for this book; however, we do need
    to understand the range of numbers that can be represented with several bits,
    as this will help us understand what the different types of floats and integers
    in Rust denote. Because binary is either a 0 or a 1, we can calculate the range
    of integers that can be represented by the bits by raising 2 to the power of the
    number of bits we have. For example, if we have an integer that is represented
    by 8 bits, 2 to the power of 8 equates to 256\. We must remember that 0 is also
    represented. Considering this, an integer of 8 bits has a range of 0 to 255\.
    We can test this calculation with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is one higher than the range that we calculated. As a result, we should
    not be surprised to see the overflow error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can deduce that if we lower the unsigned integer to `255`, it will pass.
    However, let’s say we change the unsigned integer into a signed integer with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see that we get a helpful error message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this helpful error message, we can see that a signed integer considers
    negative numbers, so the absolute value that a signed integer can take is roughly
    half. Therefore, we can increase the range by assigning the number as a 16-bit
    signed integer with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This would work. However, let us add our 16-bit integer with our 8-bit integer
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code might look a little different to you. All we have done in
    the preceding code is define the data type with a suffix instead. So, `number`
    has a value of `255` and a type of `i16`, and `number_two` has a value of `5`
    and a type of `i8`. If we run the previous code, we get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will cover traits later in this chapter. For now, all we must understand
    is that we cannot add the two different integers. If they were both the same type,
    then we could. We can change the integer type through casting using `as`, as seen
    in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that `number_two` is now a 16-bit integer, and `result` will be
    260\. However, we must be careful with casting because if we were to do it the
    wrong way, we could end up with a silent bug, which is unusual for Rust. If we
    cast `number` as `i8` instead of casting `number_two` as `i16`, then `result`
    would equate to 4, which does not make sense because 255 + 5 equals 260\. This
    is because `i8` is smaller than `i16`. So, if we cast an `i16` integer as an `i8`
    integer, we are essentially chopping off some of the data, by just taking the
    lower bits of the number and disregarding the upper bits. Therefore, `number`
    ends up being -1 if we cast it to an `i8` integer. To be safer, we can use the
    `i8::from` function, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this will give us the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we will go over traits later on in the chapter, but we can see in the
    preceding code that because the `From<i16>` trait is not implemented for an `i8`
    integer, we cannot cast an `i8` integer into an `i16` integer. With this understood,
    we are free to work with integers safely and productively. One last point about
    integer sizes in Rust is that they are not continuous. The supported sizes are
    shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bits** | **Calculation** | **Size** |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 2^8 | 256 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 2^16 | 65536 |'
  prefs: []
  type: TYPE_TB
- en: '| 32 | 2^32 | 4294967296 |'
  prefs: []
  type: TYPE_TB
- en: '| 64 | 2^64 | 1.8446744e+19 |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 2^128 | 3.4028237e+38 |'
  prefs: []
  type: TYPE_TB
- en: Table 1.1 – Size of integer types
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to floats, Rust accommodates `f32` and `f64` floating-point numbers.
    Both these floating-point types support negative and positive values. Declaring
    a floating-point variable requires the same syntax as integers, as seen in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can comfortably work with integers and floats in our Rust code.
    However, we know as developers that just declaring floats and integers is not
    very useful. We want to be able to contain and loop through them. In the next
    section, we will do just that with vectors and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data in vectors and arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Rust, we can store our floats, integers, and strings in arrays and vectors.
    First, we will focus on arrays. Arrays are stored on stack memory. Knowing this,
    and remembering what we learned about strings, we can deduce that arrays are of
    a fixed size. This is because, as we remember, if the variable is stored on the
    stack, then the memory is allocated and loaded into the stack when the program
    starts. We can define an array of integers, loop through it, print each integer,
    and then access an integer by index with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With the previous code, we define the type and size by wrapping them in square
    brackets. For instance, if we were going to create an array of floats with a length
    of 4, we would use `int_array: [f32; 4] = [1.1, 2.2, 3.3, 4.4]`. Running the preceding
    code will give you the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding printout, we see that the loop works and that we can access
    the second integer with square brackets. Although the memory size of the array
    is fixed, we can still change it. This is where mutability comes in. When we define
    a variable as mutable, this means that we can mutate it. In other words, we can
    alter the value of the variable after it has been defined if it is mutable. If
    you tried to update any of the variables in the code that we have written in this
    chapter, you will have realized that you can’t. This is because all variables
    in Rust are immutable by default. We can make any variable in Rust mutable by
    putting a `mut` tag in front of the variable name. Going back to the fixed array,
    we cannot change the size of the array, meaning we cannot append/push new integers
    to it due to it being stored on stack memory. However, if we define a mutable
    array, we can update parts of it with other integers that are the same memory
    size. An example of this is the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that the last integer in our array is updated
    to `3`. We then print out the full array and then print out the length. You may
    have also noted that the first print statement of the preceding code now employs
    `{:?}`. This calls the `Debug` trait. If `Debug` is implemented for the thing
    that we are trying to print, then the full representation of the thing we are
    printing is then displayed in the console. You can also see that we print out
    the result of the length of the array. Running this code will give the following
    printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding printout, we can confirm that the array is now updated.
    We can also access slices with our arrays. To demonstrate this, we can create
    an array of 100 zeros. We can then take a slice of this and print it out with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code will result in the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now able to be productive with arrays. Arrays can be useful for caching.
    For instance, if we know the amount that we need to store, then we can use arrays
    effectively. However, we have only managed to store one type of data in the array.
    If we tried to store strings and integers in the same array, we would have a problem.
    How would we define the type? This problem goes for all collections, such as vectors
    and **HashMaps**. There are multiple ways to do this, but the most straightforward
    is using enums. Enums are, well, enums. In dynamic languages such as Python, you
    may not have had to use them due to being able to pass any type anywhere you want.
    However, they are still available. Enum is short for enumerated type and basically
    defines a type with possible variants. In our case, we want our array to store
    strings and integers in the same collection. We can do this by initially defining
    our enum with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we defined an enum with the name of
    `SomeValue`. We then denoted that `StringValue` holds the value of a string and
    that `IntValue` holds the value of an integer. We can then define an array with
    a length of `4`, consisting of 2 strings and 2 integers, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we wrap our strings and integers in
    our enum. Now, looping through and getting it out is going to be another task.
    For instance, there are things that we can do to an integer that we cannot do
    to a string and vice versa. Considering this, we are going to have to use a `match`
    statement when looping through the array, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that if `i` is `SomeValue::StringValue`,
    we then assign the data wrapped in `SomeValue::StringValue` to the variable named
    `data`. We then pass `data` into the inner scope to be printed. We use the same
    approach with our integer. Even though we are merely printing to demonstrate the
    concept, we can do anything in these inner scopes to the `data` variable that
    the type allows us to. Running the preceding code gives the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using enums to wrap data and `match` statements to handle them can be applied
    to HashMaps and vectors. Also, what we have covered with arrays can be applied
    to vectors. The only difference is that we do not have to define the length and
    that we can increase the size of the vector if needed. To demonstrate this, we
    can create a vector of strings and then add a string to the end with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we use the `vec!` macro to create the
    vector of strings. You may have noticed with macros such as `vec!` and `println!`
    that we can vary the number of inputs. We will cover macros later in the chapter.
    Running the preceding code will result in the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create an empty vector with the `new` function from the `Vec` struct
    with `let _empty_vector: Vec<&str> = Vec::new();`. You may be wondering when to
    use vectors and when to use arrays. Vectors are more flexible. You may be tempted
    to reach for arrays for performance gains. At face value, this seems logical as
    it is stored in the stack. Accessing the stack is going to be quicker because
    the memory sizes can be computed at compile time, making the allocation and deallocation
    simpler compared to the heap. However, because it is on the stack it cannot outlive
    the scope that it is allocated. Moving a vector around would merely require moving
    a pointer around. However, moving an array requires copying the whole array. Therefore,
    copying fixed-size arrays is more expensive than moving a vector. If you have
    a small amount of data that you only need in a small scope and you know the size
    of the data, then reaching for an array does make sense. However, if you’re going
    to be moving the data around, even if you know the size of the data, using vectors
    is a better choice. Now that we can be productive with basic collections, we can
    move on to a more advanced collection, a HashMap.'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping data with HashMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some other languages, HashMaps are referred to as dictionaries. They have
    a key and a value. We can insert and get values using the key. Now that we have
    learned about handling collections, we can get a little more adventurous in this
    section. We can create a simple profile of a game character. In this character
    profile, we are going to have a name, age, and a list of items that they have.
    This means that we need an enum that houses a string, an integer, and a vector
    that also houses strings. We will want to print out the complete HashMap to see
    whether our code is correct in one glance. To do this, we are going to implement
    the `Debug` trait for our enum, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we have annotated our enum with the
    `derive` attribute. An attribute is metadata that can be applied to the `CharacterValue`
    enum in this case. The `derive` attribute tells the compiler to provide a basic
    implementation of a trait. So, in the preceding code, we are telling the compiler
    to apply the basic implementation of `Debug` to the `CharacterValue` enum. With
    this, we can then create a new HashMap that has keys pointing to the values we
    defined with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We stated that it is mutable because we are going to insert values with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we have inserted all the data that we need. Running this would
    give us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, we can see that our data is correct. Inserting it
    is one thing; however, we now must get it out again. We can do this with a `get`
    function. The `get` function returns an `Option` type. The `Option` type returns
    either `Some` or `None`. So, if we were to get `name` from our HashMap, we would
    need to do two matches, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can check to see if there is a name in the keys.
    If there is not, then we just print out that it was not present. If the `name`
    key is present, we then move on to our second check, which prints out the name
    if it is `CharacterValue::Name`. However, there is something wrong if the `name`
    key is not housing  `CharacterValue::Name`. So, we add only one more check in
    `match`, which is `_`. This is a catch meaning `anything else`. We are not interested
    in anything other than `CharacterValue::Name`. Therefore, the `_` catch maps to
    a `panic!` macro, which essentially throws an error. We could make this shorter.
    If we know that the `name` key is going to be in the HashMap, we can employ the
    `unwrap` function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unwrap` function directly exposes the result. However, if the result is
    `None`, then it will directly result in an error terminating the program, which
    would look like the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This might seem risky, but in practice, you will end up using the `unwrap` function
    a lot because you need direct access to the result, and you cannot carry on the
    program without it anyway. A prime example is connecting to a database. In a lot
    of web programming, if the database connection is not successful, then you cannot
    carry on with the API call. Therefore, it makes sense to just allow an error like
    most other web languages would. Now that we have been exposed to errors terminating
    the program, we might as well learn how to handle errors in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling results and errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we learned that directly unwrapping `Option` resulting
    in `None` panics a thread. There is another outcome that can also throw an error
    if unsuccessfully unwrapped, and this is `Result`. The `Result` type can return
    either `Ok` or `Err`. To demonstrate this, we can create a basic function that
    returns a `Result` type based on a simple Boolean we pass into it with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we return `Result<i8, &''static str>`.
    This means that we return an integer if `Result` is `Ok`, or we return an integer
    if `Result` is `Err`. The `&''static str` variable is basically our error string.
    We can tell it’s a reference because of `&`. The `''static` part means that the
    reference is valid for the entire lifetime of the running program. If this does
    not make sense now, do not worry, we will be covering lifetimes later in the chapter.
    Now that we have created our error-checking function, we can test to see what
    these outcomes look like with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code gives us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, we can see that it returned exactly what we wanted.
    We can also note that we can run the `is_err()` function on the `Result` variable,
    resulting in `false` if returning `Ok` or `true` if returning `Err`. We can also
    directly unwrap but add extra tracing to the stack trace with the following `expect`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function will result in the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Through the preceding example, we can see that we get the message from the `expect`
    function first, and then the error message returned in `Result`. With this understanding,
    we can throw, handle, and add extra tracing to errors. However, we are getting
    more exposed to lifetimes and borrow references as we move forward. Now is the
    time to address this by understanding variable ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling variable ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we remember from the beginning of the chapter, Rust does not have a garbage
    collector. However, it has memory safety. It achieves this by having strict rules
    around variable ownership. These rules are enforced when Rust is being compiled.
    If you are coming from a dynamic language, then this can initially lead to frustration.
    This is known as *fighting the borrow checker*. Sadly, this unjustly gives Rust
    the false *steep learning curve* reputation, as when you are fighting the borrow
    checker without knowing what is going on, it can seem like an impossible task
    to get even the most basic programs written. However, if we take the time to learn
    the rules before we try and code anything too complex, the knowledge of the rules
    and the helpfulness of the compiler will make writing code in Rust fun and rewarding.
    Again, I take the time to remind you that Rust has been the most favorited language
    7 years in a row. This is not because it’s impossible to get anything done in
    it. The people who vote for Rust in these surveys understand the rules around
    ownership. Rust’s compiling, checking, and enforcing of these rules protect against
    the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use after frees**: This occurs when memory is accessed once it has been freed,
    which can cause crashes. It can also allow hackers to execute code via this memory
    address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dangling pointers**: This occurs when a reference points to a memory address
    that no longer houses the data that the pointer was referencing. Essentially,
    this pointer now points to null or random data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Double frees**: This occurs when allocated memory is freed and then freed
    again. This can cause the program to crash and increases the risk of sensitive
    data being revealed. This also enables a hacker to execute arbitrary code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Segmentation faults**: This occurs when the program tries to access the memory
    it’s not allowed to access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer overrun**: An example of this error is reading off the end of an array.
    This can cause the program to crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To protect against these errors and thus achieve memory safety, Rust enforces
    the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Values are owned by the variables assigned to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As soon as the variable moves out of the scope of where it was defined, it is
    then deallocated from the memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values can be referenced and altered if we adhere to the rules for copying,
    moving, immutable borrowing, and mutable borrowing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the rules is one thing but, to practically work with the rules in Rust
    code, we need to understand copying, moving, and borrowing in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Copying variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copying occurs when a value is copied. Once it has been copied, the new variable
    owns the value, while the existing variable also owns its own value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Variable copy path](img/Figure_1.5_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Variable copy path
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 1**.5*, we can see that the path of `copy` trait, then it will automatically
    be copied, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code will give us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we appreciate that the very fact that variables `one`
    and `two` can be printed indicates that `one` has been copied for `two` to utilize.
    To test this, we can test our example with strings using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Because strings do not implement the `Copy` trait, the code does not work,
    as `one` was moved to `two`. However, the code will run if we get rid of `println!("{}",
    one);`. This brings us to the next concept that we must understand: moving.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Moving refers to when the value is moved from one variable to another. However,
    unlike copying, the original variable no longer owns the value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Variable move path](img/Figure_1.6_B18722.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Variable move path
  prefs: []
  type: TYPE_NORMAL
- en: 'From what we can see in *Figure 1**.6*, `one` can no longer be accessed once
    it’s moved to `two`. To really establish what is going on here and how strings
    are affected, we can set up some code designed to fail as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code gives the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the compiler has been helpful here. It shows us where the string
    was moved to and where the value of that string is borrowed. So, we can make the
    code run instantly by merely removing the `println!("{}", one);` line. However,
    we want to be able to use that `print` function at the bottom of the preceding
    code block. We should not have to constrain the functionality of the code due
    to the rules implemented by Rust. We can solve this by using the `to_owned` function
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `to_owned` function is available because strings implement the `ToOwned`
    trait. We will cover traits later in the chapter, so do not halt your reading
    if you do not know what this means yet. We could have used `clone` on the string.
    We must note that `to_owned` is a generalized implementation of `clone`. However,
    it does not really matter which approach we use. It is understandable to wonder
    why strings do not have the `Copy` trait. This is because the string is a pointer
    to a string literal. If we were to copy strings, we would have multiple unconstrained
    pointers to the same string literal data, which would be dangerous. Because of
    this, we can explore the move concept using strings. If we force our string outside
    of the scope with a function, we can see how this affects our move. This can be
    done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If we run the preceding code, we will get an error stating that the `print`
    function moved the `one` value. As a result, the `println!("{}", one);` line borrows
    `one` after it is moved into the `print` function. The key part of this message
    is the word *borrow*. To understand what is going on, we need to explore the concept
    of immutable borrowing.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable borrowing of variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An immutable borrow occurs when a variable can be referenced by another variable
    without having to clone or copy it. This essentially solves our problem. If the
    borrowed variable falls out of scope, then it is not deallocated from the memory
    and the original reference to the value can still be used.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Immutable borrow path](img/Figure_1.7_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Immutable borrow path
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see in *Figure 1**.7* that `two` borrows the value from `one`. It must
    be noted that when `one` is borrowed from, `one` is locked and cannot be accessed
    until the borrow is finished. To perform a borrow operation, we merely apply a
    prefix with `&`. This can be demonstrated with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that our immutable borrow enables us to pass
    a string into the `print` function and still print it afterward. This can be confirmed
    with the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: From what we see in our code, the immutable borrow that we performed can be
    demonstrated in *Figure 1**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Immutable borrow in relation to the print function](img/Figure_1.8_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Immutable borrow in relation to the print function
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we can see that `one` is not available when the `print`
    function is running. We can demonstrate this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, we will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we cannot utilize `one` even though it is utilized in the `print`
    function after `&one`. This is because the lifetime of `&one` is throughout the
    entire lifetime of the `print` function. Thus, we can conclude that *Figure 1**.8*
    is correct. However, we can run one more experiment. We can change `value_one`
    to a borrow to see what happens with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we do two immutable borrows of `one`,
    and the code runs. This highlights an important fact: we can make as many immutable
    borrows as we like. However, what happens if the borrow is mutable? To understand,
    we must explore mutable borrows.'
  prefs: []
  type: TYPE_NORMAL
- en: Mutable borrowing of variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A mutable borrow is essentially the same as an immutable borrow, except that
    the borrow is mutable. Therefore, we can change the borrowed value. To demonstrate
    this, we can create a `print` statement that will alter the borrowed value before
    printing it. We then print it in the `main` function to establish that the value
    has been changed with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code will give us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output proves that `one` is `6` even after the lifetime of the
    mutable reference in the `print` function has expired. We can see that in the
    `print` function, we update the value of `one` using a `*` operator. This is called
    a dereference operator. This dereference operator exposes the underlying value
    so it can be operated. This all seems straightforward, but is it exactly like
    our immutable references? If we remember, we could have multiple immutable references.
    We can put this to the test with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we make two mutable references and pass
    them through, just like in the previous section, but with immutable references.
    However, running it gives us the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Through this example, we can confirm that we cannot have more than one mutable
    reference at a time. This prevents data races and has given Rust the *fearless
    concurrency* tag. With what we have covered here, we can now be productive when
    the compiler is combined with the borrow checker. However, we have touched on
    the concepts of scope and lifetimes. The use of them has been intuitive, but like
    the rules around borrowing, we need to dive into scopes and then lifetimes in
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand scopes, let us go back to how we declare variables. You will
    have noticed that when we declare a new variable, we use `let`. When we do, that
    variable is the only one that owns the resource. Therefore, if the value is moved
    or reassigned, then the initial variable no longer owns the value. When a variable
    is moved, it is essentially moved into another scope. Variables declared in an
    outer scope can be referenced in an inner scope, but a variable declared in an
    inner scope cannot be accessed in the inner scope once the inner scope has expired.
    We can break down some code into scopes in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Basic Rust code broken into scopes](img/Figure_1.9_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Basic Rust code broken into scopes
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.9* shows us that we can create an inner scope by merely using curly
    brackets. Applying what we just learned about scopes to *Figure 1**.9*, can you
    work out whether it will crash? If it will crash, how will it?'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you guessed that it would result in a compiler error, then you are correct.
    Running the code would result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `one` is defined in the inner scope, we will not be able to reference
    it in the outer scope. We can solve this problem by declaring the variable in
    the outer scope but assigning the value in the inner scope with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we do not use `let` when assigning the
    value because we have already declared the variable in the outer scope. Running
    the preceding code gives us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We also must remember that if we move a variable into a function, then the
    variable gets destroyed once the scope of the function finishes. We cannot access
    the variable after the execution of the function, even though we declared the
    variable before the execution of the function. This is because once the variable
    has been moved into the function, it is no longer in the original scope. It has
    been moved. And because it has been moved to that scope, it is then bound to the
    lifetime of the scope that it was moved into. This brings us to our next section:
    lifetimes.'
  prefs: []
  type: TYPE_NORMAL
- en: Running through lifetimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Understanding lifetimes will wrap up our exploration of borrowing rules and
    scopes. We can explore the effect of lifetimes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding code, we declare `one` before the inner scope starts. However,
    we assign it to have a reference of `two`. `two` only has the lifetime of the
    inner scope, so the lifetime dies before we try and print it out. This is established
    with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`two` is dropped when the lifetime of `two` has finished. With this, we can
    state that the lifetimes of `one` and `two` are not equal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is great that this is flagged when compiling, Rust does not stop here.
    This concept also applies to functions. Let’s say that we build a function that
    references two integers, compares them, and returns the highest integer reference.
    The function is an isolated piece of code. In this function, we can denote the
    lifetimes of the two integers. This is done by using the `''` prefix, which is
    a lifetime notation. The names of the notations can be anything you come up with,
    but it is convention to use `a`, `b`, `c`, and so on. We can explore this by creating
    a simple function that takes in two integers and returns the highest one with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the first and second lifetimes have the same notation of `a`.
    They both must be present for the duration of the function. We also must note
    that the function returns an `i8` integer with the lifetime of `a`. If we were
    to try and use lifetime notation on function parameters without a borrow, we would
    get some very confusing errors. In short, it is not possible to use lifetime notation
    without a borrow. This is because if we do not use a borrow, the value passed
    into the function is moved into the function. Therefore, its lifetime is the lifetime
    of the function. This seems straightforward; however, when we run it, we get the
    following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The error occurs because all the lifetimes of the parameters passed into the
    function and the returned integer are the same. Therefore, the compiler does not
    know what could be returned. As a result, `two` could be returned. If `two` is
    returned, then the result of the function will not live long enough to be printed.
    However, if `one` is returned, then it will. Therefore, there is a possibility
    of not having a value to print after the inner scope is executed. In a dynamic
    language, we would be able to run code that runs the risk of referencing variables
    that have not been initialized yet. However, with Rust, we can see that if there
    is a possibility of an error like this, it will not compile. In the short term,
    it might seem like Rust takes longer to code, but as the project progresses, this
    strictness will save a lot of time by preventing silent bugs. In conclusion of
    our error, there is no way of solving our problem with the exact function and
    main layout that we have. We would either have to move our printing of the outcome
    into the inner scope or clone the integers and pass them into the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create one more function to explore functions with different lifetime
    parameters. This time we will create a `filter` function. If the first number
    is lower than the second number, we will then return `0`. Otherwise, we will return
    the first number. This can be achieved with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code works because we know the lifetimes are different. The first
    parameter has the same lifetime as the returned integer. If we were to implement
    `filter(&two, &one)` instead, we would get an error stating that the outcome does
    not live long enough to be printed. We have now covered all that we need to know
    for now to write productive code in Rust without the borrow checker getting in
    our way. We now need to move on to creating bigger building blocks for our programs
    so we can focus on tackling the complex problems we want to solve with code. We
    will start this with a versatile building block of programs: **structs**.'
  prefs: []
  type: TYPE_NORMAL
- en: Building structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In modern high-level dynamic languages, objects have been the bedrock for building
    big applications and solving complex problems, and for good reason. Objects enable
    us to encapsulate data, functionality, and behavior. In Rust, we do not have objects.
    However, we do have structs that can hold data in fields. We can then manage the
    functionality of these structs and group them together with traits. This is a
    powerful approach, and it gives us the benefits of objects without the high coupling,
    as highlighted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – Difference between Rust structs and objects](img/Figure_1.10_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – Difference between Rust structs and objects
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with something basic by creating a `Human` struct with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that our string literal fields have the same
    lifetime as the struct itself. We have also applied the `Debug` trait to the `Human`
    struct, so we can print it out and see everything. We can then create the `Human`
    struct and print the struct out using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code would give us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that our fields are what we expect. However, we can change our string
    slice fields to strings to get rid of lifetime parameters. We may also want to
    add another field where we can reference another `Human` struct under a `friend`
    field. However, we may also have no friends. We can account for this by creating
    an enum that is either a friend or not and assigning this to a `friend` field,
    as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define the `Human` struct initially with no friends just to see
    if it works with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we run the compiler, it does not work. I would like to think
    this is because the compiler cannot believe that I have no friends. But alas,
    it’s to do with the compiler not knowing how much memory to allocate for this
    declaration. This is shown through the following error code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the enum, theoretically, the memory needed to store this variable
    could be infinite. One `Human` struct could reference another `Human` struct as
    a `friend` field, which could in turn reference another `Human` struct, resulting
    in a potentially infinite number of `Human` structs being linked together through
    the `friend` field. We can solve this problem with pointers. Instead of storing
    all the data of a `Human` struct in the `friend` field, we store a memory address
    that we know has a maximum value because it’s a standard integer. This memory
    address points to where another `Human` struct is stored in the memory. As a result,
    the program knows exactly how much memory to allocate when it crosses a `Human`
    struct, irrespective of whether the `Human` struct has a `friend` field or not.
    This can be achieved by using a `Box` struct, which is essentially a smart pointer
    for our enum, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now our enum states whether the friend exists or not, and if so, it has
    a memory address if we need to extract information about this friend. We can achieve
    this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that we have created one `Human` struct, and
    then another `Human` struct with a reference to the first `Human` struct as a
    `friend` field. We then access the second `Human` struct’s `friend` through the
    `friend` field. Remember, we must handle both possibilities as it could be a nil
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is exciting that friends can be made, if we take a step back, we can
    see that there is a lot of code written for each human we create. This is not
    helpful if we must create a lot of humans in a program. We can reduce this by
    implementing some functionality for our struct. We will essentially create a constructor
    for the struct with extra functions, so we can add optional values if we want.
    We will also make the `thought` field optional. So, a basic struct with a constructor
    populating only the most essential fields can be achieved with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, creating a new human now only takes the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have the following field values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: `"``Maxwell Flitton"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Age: `32`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Current Thought: `None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Friend: `NIL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can add more functions in the implement block for adding friends and a current
    thought with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we pass in a mutable version of the
    struct that is calling these functions. These functions can be chained because
    they return the struct that called them. If we want to create a developer with
    a thought, we can do this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We must note that a function that does not require `self` as a parameter can
    be called with `::`, while a function that does require `self` as a parameter
    can be called with a simple dot (`.`). If we want to create a developer with a
    friend, it can be done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code will result in the following parameters for `developer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We can see that structs combined with enums and functions that have been implemented
    with these structs can be powerful building blocks. We can define fields and functionality
    with only a small amount of code if we have defined our structs well. However,
    writing the same functionality for multiple structs can be time-consuming and
    result in a lot of repeated code. If you have worked with objects before, you
    may have utilized inheritance for that. Rust goes one better. It has traits, which
    we will explore in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying with traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can see enums can empower structs so that they can handle multiple types.
    This can also be translated for any type of function or data structure. However,
    this can lead to a lot of repetition. Take, for instance, a `User` struct. Users
    have a core set of values, such as a username and password. However, they could
    also have extra functionality based on roles. With users, we must check roles
    before firing certain processes. We can wrap up structs with traits by creating
    a simple toy program that defines users and their roles with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define our users with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see in the preceding code that the `User` and `AdminUser` structs have
    the same fields. For this exercise, we merely need two different structs to demonstrate
    the effect traits have on them. Now that our structs are defined, we can move
    on to our next step, which is creating the traits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be implementing these traits in our structs. The total traits that
    we will have are, comprise create, edit, and delete. We will be using them to
    assign permissions to our users. We can create these three traits with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that the functions for the traits only take in `self`. We cannot
    make any references to the fields in the functions to `self` as we do not know
    what structs will be implemented. However, we can override functions when we implement
    the trait to the struct if needed. If we are to return `self`, we will need to
    wrap it in a `Box` struct, as the compiler will not know the size of the struct
    being returned. We also must note that the signature of the function (input parameters
    and return values) must be the same as the original if we overwrite the function
    for a struct. Now that we have defined the traits, we can move on to the next
    step of implementing the traits to define roles for our user.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our roles, we can make our admin have every permission and our user only
    the edit permission. This can be achieved with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From our previous step, we can remember that all the functions already worked
    for the admin by printing out that the admin is doing the action. Therefore, we
    do not have to do anything for the implementation of the traits for the admin.
    We can also see that we can implement multiple traits for a single struct. This
    adds a lot of flexibility. In our user implementation of the `CanEdit` trait,
    we have overwritten the `edit` function so that we can have the correct statement
    printed out. Now that we have implemented the traits, our `user` structs have
    permission in the code to enter scopes that require those traits. We can now build
    the functions for using these traits in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could utilize the functions in the traits by directly running them in the
    `main` function on the structs that have implemented them. However, if we do this,
    we will not see their true power in this exercise. We may also want this standard
    functionality throughout our program in the future when we span multiple files.
    The following code shows how we create functions that utilize the traits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding notation is fairly like the lifetime annotation. We use angle
    brackets before the input definitions to define the trait we want to accept at
    `T`. We then state that we will accept a borrowed struct that has implemented
    the trait as `&T`. This means that any struct that implements that specific trait
    can pass through the function. Because we know what the trait can do, we can then
    use the trait functions. However, because we do not know what struct is going
    to be passed through, we cannot utilize specific fields. But remember, we can
    overwrite a trait function to utilize struct fields when we implement the trait
    for the struct. This might seem rigid, but the process enforces good, isolated,
    decoupled coding that is safe. For instance, let’s say we remove a function from
    a trait or remove a trait from a struct. The compiler would refuse to compile
    until all the effects of this change were complete. Thus, we can see that, especially
    for big systems, Rust is safe, and can save time by reducing the risk of silent
    bugs. Now that we have defined the functions, we can use them in the `main` function
    in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test to see whether all the traits work with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that the functions that accept traits are used just like any other
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the entire program will give us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: In our output, we can see that the overriding of the `edit` function for the
    `User` struct works.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned enough about traits to be productive with web development.
    Traits get even more powerful, and we will be using them for some key parts of
    our web programming. For instance, several web frameworks have traits that execute
    before the request is processed by the view/API endpoint. Implementing structs
    with these traits automatically loads the `view` function with the result of the
    `trait` function. This can be database connections, extraction of tokens from
    headers, or anything else we wish to work with. There is also one last concept
    that we need to tackle before we move on to the next chapter, and that is macros.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming with macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Metaprogramming** can generally be described as a way in which the program
    can manipulate itself based on certain instructions. Considering the strong typing
    Rust has, one of the simplest ways in which we can meta program is by using generics.
    A classic example of demonstrating generics is through coordinates, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can see that the `Coordinate` struct managed to
    take in and handle three different types of numbers. We can add even more variance
    to the `Coordinate` struct so we can have two different types of numbers in one
    struct with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'What is happening in the preceding code with generics is that the compiler
    is looking for all instances where the struct is used, creating structs with the
    types used when the compilation is running. Now that we have covered generics,
    we can move on to the main mechanism of metaprogramming: macros.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros enable us to abstract code. We’ve already been using macros in our print
    functions. The `!` notation at the end of the function denotes that this is a
    macro that’s being called. Defining our own macros is a blend of defining a function
    and using a lifetime notation within a `match` statement in the function. To demonstrate
    this, we will define a macro that capitalizes a string with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the term `fn`, we use the `macro_rules!` definition. We then
    say that `$a` is the expression passed into the macro. We get the expression,
    convert it into a vector of chars, then make the first `char` uppercase, and then
    convert it back to a string. We must note that we don’t return anything in the
    `capitalize` macro, and when we call the macro, we don’t assign a variable to
    it. However, when we print the `x` variable at the end, we can see that it is
    capitalized. This does not behave like an ordinary function. We also must note
    that we didn’t define a type, instead, we just said it was an expression; the
    macro still does checks via traits. Passing an integer into the macro creates
    the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Lifetimes, blocks, literals, paths, metaprogramming, and more, can also be passed
    instead of an expression. While it’s important to have a brief understanding of
    what’s under the hood of a basic macro for debugging and further reading, diving
    more into developing complex macros will not help us in developing web apps. We
    must remember that macros are a last resort and should be used sparingly. Errors
    thrown in macros can be hard to debug. In web development, a lot of the macros
    are already defined in third-party packages. Because of this, we do not need to
    write macros ourselves to get a web app up and running. Instead, we will mainly
    be using derive macros out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Rust, we have seen that there are some traps when coming from a dynamic
    programming language background. However, with a little bit of knowledge of referencing
    and basic memory management, we can avoid common pitfalls and write safe, performant
    code quickly that can handle errors. By utilizing structs and traits, we can build
    objects that are analogous to classes in standard dynamic programming languages.
    On top of this, the traits enabled us to build mixin-like functionality. This
    not only enables us to slot in functionality when it’s useful to us but also perform
    checks on the structs through typing to ensure that the container or function
    is processing structs with certain attributes belonging to the trait that we can
    utilize in the code.
  prefs: []
  type: TYPE_NORMAL
- en: With our fully functioning structs, we bolted on even more functionality with
    macros and looked under the hood of basic macros by building our own `capitalize`
    function, giving us guidance for further reading and debugging. We also got to
    see a brief demonstration of how powerful macros combined with structs can be
    in web development with JSON serialization. With what we have learned in this
    chapter, we can now write basic Rust programs. Because we understand the concepts
    that the borrow checker enforces, we can debug the application that we code. Like
    other languages, there are limited real-world applications that we can do yet.
    However, we do have the essential foundation to build real-world applications
    spanning multiple files running on our own local computers.
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to the next chapter and investigate setting up a Rust environment
    on our own computers to structure files and code to enable us to build programs
    that can solve real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between `str` and `String`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can’t string slices be passed into a function (string slice meaning `str`
    as opposed to `&str`)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we access the data belonging to a key in a HashMap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a function results in an error, can we handle other processes, or will
    the error crash the program instantly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does Rust only allow one mutable borrow at a point in time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would we need to define two different lifetimes in a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can structs link to the same struct via one of their fields?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we add extra functionality to a struct where the functionality can also
    be implemented by other structs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we allow a container or function to accept different data structures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the quickest way to add a trait, such as `Copy`, to a struct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`String` is a fixed-size reference stored in the stack that points to string-type
    data on the heap. `str` is an immutable sequence of bytes stored somewhere in
    memory. Because the size of `str` is unknown, it can only be handled by a `&``str`
    pointer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we do not know the size of the string slice at compile time, we cannot
    allocate the correct amount of memory for it. Strings, on the other hand, have
    a fixed-size reference stored on the stack that points to the string slice on
    the heap. Because we know this fixed size of the string reference, we can allocate
    the correct amount of memory and pass it through to a function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the HashMap’s `get` function. However, we must remember that the `get`
    function merely returns an `Option` struct. If we are confident that there is
    something there or we want the program to crash if nothing is found, we can directly
    unwrap it. However, if we don’t want that, we can use a `match` statement and
    handle the `Some` and `None` output as we wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, results must be unwrapped before exposing the error. A simple `match` statement
    can handle unwrapping the result and managing the error as we see fit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rust only allows one mutable borrow to prevent memory unsafety. In Goregaokar’s
    blog, the example of an enum is used to illustrate this. If an enum supports two
    different data types (`String` and `i64`), if a mutable reference of the string
    variant of the enum is made, and then another reference is made, the mutable reference
    can change the data, and then the second reference would still be referencing
    the string variant of the enum. The second reference would then try to dereference
    the string variant of the enum, potentially causing a segmentation fault. Elaboration
    on this example and others is provided in the *Further reading* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We would need to define two different lifetimes when the result of a function
    relies on one of the lifetimes and the result of the function is needed outside
    of the scope of where it is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a struct is referencing itself in one of its fields, the size could be infinite
    as it could continue to reference itself continuously. To prevent this, we can
    wrap the reference to the struct in the field in a `Box` struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can slot extra functionality and freedom into a struct by using traits. Implementing
    a trait will give the struct the ability to use functions that belong to the trait.
    The trait’s implementation also allows the struct to pass typing checks for that
    trait.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We allow a container or function to accept different data structures by declaring
    enums or traits in the type checking or by utilizing generics (see the *Further
    reading* section: *Mastering Rust* or *Hands-On Functional Programming in Rust
    (first chapter)*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The quickest way to add a trait to a struct is by annotating the struct with
    a derive macro that has the copy and clone traits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Hands-On Functional Programming in Rust* (2018) by Andrew Johnson, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Rust* (2019) by Rahul Sharma and Vesa Kaihlavirta, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Rust Programming Language* (2018): [https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Problem With Single-threaded Shared Mutability* (2015) by Manish Goregaokar:
    [https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/](https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
