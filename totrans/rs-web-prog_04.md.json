["```rs\n├── main.rs\n├── processes.rs\n├── state.rs\n```", "```rs\n├── to_do\n│   ├── enums.rs\n│   ├── mod.rs\n│   ├── structs\n│   │   ├── base.rs\n│   │   ├── done.rs\n│   │   ├── mod.rs\n│   │   └── pending.rs\n│   └── traits\n│       ├── create.rs\n│       ├── delete.rs\n│       ├── edit.rs\n│       ├── get.rs\n│       └── mod.rs\n```", "```rs\n└── views\n    ├── auth\n    │   ├── login.rs\n    │   ├── logout.rs\n    │   └── mod.rs\n    ├── mod.rs\n    ├── path.rs\n```", "```rs\nuse actix_web::{App, HttpServer};\nmod views;\nmod to_do;\nmod state;\nmod processes;\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        let app = App::new().configure(views::views_factory);\n        return app\n    })\n        .bind(\"127.0.0.1:8000\")?\n        .run()\n        .await\n}\n```", "```rs\n[dependencies]\nactix-web = \"4.0.1\"\nserde_json = \"1.0.59\"\n```", "```rs\n└── views\n    ├── auth\n    │   ├── login.rs\n    │   ├── logout.rs\n    │   └── mod.rs\n    ├── mod.rs\n    └── to_do\n        ├── create.rs\n        └── mod.rs\n```", "```rs\nuse serde_json::value::Value;\nuse serde_json::Map;\nuse actix_web::HttpRequest;\nuse crate::to_do::{to_do_factory, enums::TaskStatus};\nuse crate::state::read_file;\nuse crate::processes::process_input;\n```", "```rs\npub async fn create(req: HttpRequest) -> String {\n    let state: Map<String, Value> = read_file(\n        \"./state.json\"); // step 1\n    let title: String = req.match_info().get(\"title\"\n    ).unwrap().to_string(); // step 2\n    let item = to_do_factory(&title.as_str(), \n                             TaskStatus::PENDING); // step 3\n    process_input(item, \"create\".to_string(), &state);\n    // step 4\n    return format!(\"{} created\", title) // step 5\n}\n```", "```rs\nmod create;\nuse actix_web::web::{ServiceConfig, get, scope};\npub fn to_do_views_factory(app: &mut ServiceConfig) {\n    app.service(\n        scope(\"v1/item\")\n        .route(\"create/{title}\", get().to(create::create))\n    );\n}\n```", "```rs\nmod auth;\nmod to_do; // define the module\nuse auth::auth_views_factory;\nuse to_do::to_do_views_factory; // import the factory \nuse actix_web::web::ServiceConfig;\npub fn views_factory(app: &mut ServiceConfig) {\n    auth_views_factory(app);\n    to_do_views_factory(app); // pass the ServiceConfig \n}\n```", "```rs\nlearn to code rust is being created\n```", "```rs\n{\"learn to code rust\":\"PENDING\"}\n```", "```rs\nmod create;\nuse actix_web::web::{ServiceConfig, post, scope};\npub fn to_do_views_factory(app: &mut ServiceConfig) {\n    app.service(\n        scope(\"v1/item\")\n        .route(\"create\", post().to(create::create))\n    );\n}\n```", "```rs\n{\"learn to code rust\":\"PENDING\",\"washing\":\"PENDING\"}\n```", "```rs\napp.service(\n    scope(\"v1/item\")\n    .route(\"create/{title}\", post().to(create::create))\n    .route(\"create/{title}\", get().to(create::create))\n);\n```", "```rs\nuse actix_web::{web, Responder};\nuse serde_json::value::Value;\nuse serde_json::Map;\nuse crate::state::read_file;\npub async fn get() -> impl Responder {\n    let state: Map<String, Value> = read_file(\"./state.json\");\n    return web::Json(state);\n}\n```", "```rs\npub async fn get() -> Map<String, Value>  {\n    let state: Map<String, Value> = read_file(\"./state.json\");\n    return state;\n}\n```", "```rs\nmod create;\nmod get; // import the get file \nuse actix_web::web::{ServiceConfig, post, get, scope};\n// import get\npub fn to_do_views_factory(app: &mut ServiceConfig) {\n    app.service(\n        scope(\"v1/item\")\n        .route(\"create/{title}\", post().to(create::create))\n        .route(\"get\", get().to(get::get)) // define view and URL\n    );\n}\n```", "```rs\n{\n    \"learn to code rust\": \"PENDING\",\n    \"washing\": \"PENDING\"\n}\n```", "```rs\n[dependencies]\nactix-web = \"4.0.1\"\nserde_json = \"1.0.59\"\nserde = { version = \"1.0.136\", features = [\"derive\"] }\n```", "```rs\npub enum TaskStatus {\n    DONE,\n    PENDING\n}\nimpl TaskStatus {\n    pub fn stringify(&self) -> String {\n        match &self {\n            &Self::DONE => {return \"DONE\".to_string()},\n            &Self::PENDING => \n                {return \"PENDING\".to_string()}\n        }\n    }\n    pub fn from_string(input_string: String) -> Self {\n        match input_string.as_str() {\n            \"DONE\" => TaskStatus::DONE,\n            \"PENDING\" => TaskStatus::PENDING,\n            _ => panic!(\"input {} not supported\", \n                        input_string)\n        }\n    }\n}\n```", "```rs\nuse serde::ser::{Serialize, Serializer, SerializeStruct};\n```", "```rs\nimpl Serialize for TaskStatus {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, \n                    S::Error>\n    where\n        S: Serializer,\n    {\n        Ok(serializer.serialize_str(&self.stringify()\n                                   .as_str())?)\n    }\n}\n```", "```rs\n#[derive(Debug)]\nstruct TwoDposition {\n    x: i32,\n    y: i32\n}\n#[derive(Debug)]\nstruct ThreeDposition {\n    x: i32,\n    y: i32,\n    z: i32\n}\n```", "```rs\nfn print_two(s: &TwoDposition) {\n    println!(\"{:?}\", s);\n}\nfn print_three(s: &ThreeDposition) {\n    println!(\"{:?}\", s);\n}\n```", "```rs\nuse core::fmt::Debug;\n```", "```rs\nfn print_debug<S>(s: &S)\nwhere\n    S: Debug {\n    println!(\"{:?}\", s);    \n}\n```", "```rs\nfn main() {\n    let two = TwoDposition{x: 1, y: 2};\n    let three = ThreeDposition{x: 1, y: 2, z: 3};    \n    print_debug(&two);\n    print_debug(&three);\n}\n```", "```rs\nTwoDposition { x: 1, y: 2 }\nThreeDposition { x: 1, y: 2, z: 3 }\n```", "```rs\nprint_debug::<TwoDposition>(&two);\nprint_debug::<ThreeDposition>(&three);\n```", "```rs\nfn debug_iter<I>(iter: I)\nwhere\n    I: Iterator\n    I::Item: Debug\n{\n    for item in iter {\n        println!(\"{:?}\", iter);\n    }\n}\n```", "```rs\nimpl Serialize for TaskStatus {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, \n                                                  S::Error>\n    where\n        S: Serializer,\n    {\n        Ok(serializer.serialize_str(&self.stringify()\n                                    .as_str())?)\n    }\n}\n```", "```rs\nfn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\nwhere\n    S: Serializer,\n{\n    let mut s = serializer.serialize_struct(\"TaskStatus\", \n                                             1)?;\n    s.serialize_field(\"status\", &self.stringify())?;\n    s.end()\n}\n```", "```rs\n#[derive(Serialize)]\nstruct TaskStatus {\n    status: String\n}\n```", "```rs\n├── main.rs\n├── json_serialization\n│   ├── mod.rs\n│   └── to_do_items.rs\n```", "```rs\nuse serde::Serialize;\nuse crate::to_do::ItemTypes;\nuse crate::to_do::structs::base::Base;\n#[derive(Serialize)]\npub struct ToDoItems {\n    pub pending_items: Vec<Base>,\n    pub done_items: Vec<Base>,\n    pub pending_item_count: i8,\n    pub done_item_count: i8\n}\n```", "```rs\nimpl ToDoItems {\n    pub fn new(input_items: Vec<ItemTypes>) -> ToDoItems {\n        . . . // code to be filled in\n    }\n}\n```", "```rs\nlet mut pending_array_buffer = Vec::new();\nlet mut done_array_buffer = Vec::new();\nfor item in input_items {\n    match item {\n        ItemTypes::Pending(packed) => pending_array_buffer.\n            push(packed.super_struct),\n        ItemTypes::Done(packed) => done_array_buffer.push(\n            packed.super_struct)\n    }\n}\n```", "```rs\nlet done_count: i8 = done_array_buffer.len() as i8;\nlet pending_count: i8 = pending_array_buffer.len() as i8;\n```", "```rs\n    return ToDoItems{\n    ```", "```rs\n        pending_items: pending_array_buffer, \n    ```", "```rs\n        done_item_count: done_count,\n    ```", "```rs\n        pending_item_count: pending_count, \n    ```", "```rs\n        done_items: done_array_buffer\n    ```", "```rs\n    }\n    ```", "```rs\npub mod to_do_items;\n```", "```rs\nmod json_serialization;\n```", "```rs\npub mod to_do_items;\nuse super::super::enums::TaskStatus;\nuse serde::Serialize;\n#[derive(Serialize)]\npub struct Base {\n    pub title: String,\n    pub status: TaskStatus\n}\n```", "```rs\nuse actix_web::{web, Responder};\nuse serde_json::value::Value;\nuse serde_json::Map;\nuse crate::state::read_file;\nuse crate::to_do::{ItemTypes, to_do_factory, enums::TaskStatus};\nuse crate::json_serialization::to_do_items::ToDoItems;\npub async fn get() -> impl Responder {\n    let state: Map<String, Value> = read_file(\n                                    \"./state.json\");\n    let mut array_buffer = Vec::new();\n    for (key, value) in state {\n        let status = TaskStatus::from_string(\n                          &value.as_str().unwrap())\n                                      .to_string();\n        let item: ItemTypes = to_do_factory(\n                                &key, status);\n        array_buffer.push(item);\n    }\n    let return_package: ToDoItems = ToDoItems::new(\n                                     array_buffer);\n    return web::Json(return_package);\n}\n```", "```rs\n{\n    \"pending_items\": [\n        {\n            \"title\": \"learn to code rust\",\n            \"status\": \"PENDING\"\n        },\n        {\n            \"title\": \"washing\",\n            \"status\": \"PENDING\"\n        }\n    ],\n    \"done_items\": [],\n    \"pending_item_count\": 2,\n    \"done_item_count\": 0\n}\n```", "```rs\nuse serde::Serialize;\nuse std::vec::Vec;\nuse serde_json::value::Value;\nuse serde_json::Map;\nuse actix_web::{\n    body::BoxBody, http::header::ContentType, \n    HttpRequest, HttpResponse, Responder,\n};\nuse crate::to_do::ItemTypes;\nuse crate::to_do::structs::base::Base;\nuse crate::state::read_file;\nuse crate::to_do::{to_do_factory, enums::TaskStatus};\n```", "```rs\nimpl ToDoItems {\n    pub fn new(input_items: Vec<ItemTypes>) -> ToDoItems {\n        . . .\n    }\n    pub fn get_state() -> ToDoItems {\n        let state: Map<String, Value> = read_file(\"./state.            json\");\n        let mut array_buffer = Vec::new();\n        for (key, value) in state {\n            let status = TaskStatus::from_string(&value\n                         .as_str().unwrap().to_string());\n            let item = to_do_factory(&key, status);\n            array_buffer.push(item);\n        }\n        return ToDoItems::new(array_buffer)\n    }\n}\n```", "```rs\nimpl Responder for ToDoItems {\n    type Body = BoxBody;\n    fn respond_to(self, _req: &HttpRequest) \n                            -> HttpResponse<Self::Body> {\n        let body = serde_json::to_string(&self).unwrap();\n        HttpResponse::Ok()\n            .content_type(ContentType::json())\n            .body(body)\n    }\n}\n```", "```rs\nuse actix_web::Responder;\nuse crate::json_serialization::to_do_items::ToDoItems;\npub async fn get() -> impl Responder {\n    return ToDoItems::get_state();\n}\n```", "```rs\nuse serde::Deserialize;\n#[derive(Deserialize)]\npub struct ToDoItem {\n    pub title: String,\n    pub status: String\n}\n```", "```rs\npub mod to_do_items;\npub mod to_do_item;\n```", "```rs\nuse actix_web::{web, HttpResponse};\nuse serde_json::value::Value;\nuse serde_json::Map;\nuse crate::state::read_file;\nuse crate::to_do::{to_do_factory, enums::TaskStatus};\nuse crate::json_serialization::{to_do_item::ToDoItem, \n                                to_do_items::ToDoItems};\nuse crate::processes::process_input;\n```", "```rs\npub async fn edit(to_do_item: web::Json<ToDoItem>) \n                                 -> HttpResponse {\n    . . .\n}\n```", "```rs\nlet state: Map<String, Value> = read_file(\"./state.json\");\n```", "```rs\nlet status: TaskStatus;\nmatch &state.get(&to_do_item.title) {\n    Some(result) => {\n        status = TaskStatus::new(result.as_str().unwrap());\n    }\n    None=> {\n        return HttpResponse::NotFound().json(\n            format!(\"{} not in state\", &to_do_item.title))\n    }\n}\n```", "```rs\nlet existing_item = to_do_factory(to_do_item.title.as_str(), \n              status.clone());\n```", "```rs\nif &status.stringify() == &TaskStatus::from_string(\n                          &to_do_item.status.as_str()\n                          .to_string()).stringify() {\n    return HttpResponse::Ok().json(ToDoItems::get_state())\n}\n```", "```rs\nprocess_input(existing_item, \"edit\".to_owned(), &state);\nreturn HttpResponse::Ok().json(ToDoItems::get_state())\n```", "```rs\n#[derive(Clone)]\npub enum TaskStatus {\n    DONE,\n    PENDING\n}\n```", "```rs\nmod create;\nmod get;\nmod edit;\nuse actix_web::web::{ServiceConfig, post, get, scope};\npub fn to_do_views_factory(app: &mut ServiceConfig) {\n    app.service(\n        scope(\"v1/item\")\n        .route(\"create/{title}\", post().to(create::create))\n        .route(\"get\", get().to(get::get))\n        .route(\"edit\", post().to(edit::edit))\n    );\n}\n```", "```rs\n{\n    \"pending_items\": [\n        {\n            \"title\": \"learn to code rust\",\n            \"status\": \"PENDING\"\n        }\n    ],\n    \"done_items\": [\n        {\n            \"title\": \"washing\",\n            \"status\": \"DONE\"\n        }\n    ],\n    \"pending_item_count\": 1,\n    \"done_item_count\": 1\n}\n```", "```rs\n[dependencies]\nactix-web = \"4.0.1\"\nserde_json = \"1.0.59\"\nserde = { version = \"1.0.136\", features = [\"derive\"] }\nactix-service = \"2.0.2\"\n```", "```rs\nuse actix_web::{App, HttpServer};\nuse actix_service::Service;\nmod views;\nmod to_do;\nmod state;\nmod processes;\nmod json_serialization;\n```", "```rs\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        let app = App::new()\n            .wrap_fn(|req, srv|{\n                println!(\"{:?}\", req);\n                let future = srv.call(req);\n                async {\n                    let result = future.await?;\n                    Ok(result)\n                }\n        }).configure(views::views_factory);\n        return app\n    })\n    .bind(\"127.0.0.1:8000\")?\n    .run()\n    .await\n}\n```", "```rs\nServiceRequest HTTP/1.1 GET:/v1/item/get\n  headers:\n    \"accept-language\": \"en-GB,en-US;q=0.9,en;q=0.8\"\n    \"accept\": \"text/html,application/xhtml+xml,application/xml;\n    q=0.9,image/avif,image/webp,image/        apng,*/*;q=0.8,application\n    signed-exchange;v=b3;q=0.9\"\n    \"sec-ch-ua-platform\": \"\\\"macOS\\\"\"\n    \"sec-fetch-site\": \"none\"\n    . . . \n    \"host\": \"127.0.0.1:8000\"\n    \"connection\": \"keep-alive\"\n    \"sec-fetch-user\": \"?1\"\n```", "```rs\nfutures = \"0.3.21\"\n```", "```rs\nuse actix_web::dev::Payload;\nuse actix_web::{Error, FromRequest, HttpRequest};\nuse futures::future::{Ready, ok};\n```", "```rs\npub struct JwToken {\n    pub message: String\n}\n```", "```rs\nimpl FromRequest for JwToken {\n    type Error = Error;\n    type Future = Ready<Result<JwToken, Error>>;\n    fn from_request(req: &HttpRequest, _: &mut Payload) \n                                          -> Self::Future {\n    . . .\n    }\n}\n```", "```rs\nmatch req.headers().get(\"token\") {\n    Some(data) => {\n        let token = JwToken{\n            message: data.to_str().unwrap().to_string()\n        };\n        ok(token)\n    },\n    None => {\n        let token = JwToken{\n            message: String::from(\"nothing found\")\n        };\n        ok(token)\n    }\n}\n```", "```rs\nmod jwt;\n```", "```rs\nuse crate::jwt::JwToken;\npub async fn edit(to_do_item: web::Json<ToDoItem>, \n                  token: JwToken) -> HttpResponse {\n    println!(\"here is the message in the token: {}\", \n              token.message);\n    . . .\n```", "```rs\nhere is the message in the token: nothing found\n```", "```rs\nhere is the message in the token: \"hello from header\"\n```"]