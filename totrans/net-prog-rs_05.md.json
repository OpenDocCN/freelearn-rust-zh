["```rs\n$ cargo new --bin grpc_example\nprotoc-rust-grpc crate. Hence, we will need to add that as a build dependency:\n```", "```rs\n$ cat Cargo.toml\n[package]\nname = \"grpc_example\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nprotobuf = \"1.4.1\"\ngrpc = \"0.2.1\"\ntls-api = \"0.1.8\"\n\n[build-dependencies]\nprotoc-rust-grpc = \"0.2.1\"\n```", "```rs\n// ch5/grpc/build.rs\n\nextern crate protoc_rust_grpc;\n\nfn main() {\n    protoc_rust_grpc::run(protoc_rust_grpc::Args {\n        out_dir: \"src\",\n        includes: &[],\n        input: &[\"foobar.proto\"],\n```", "```rs\n        rust_protobuf: true,\n    }).expect(\"Failed to generate Rust src\");\n}\n```", "```rs\n$ curl -Lo https://github.com/google/protobuf/releases/download/v3.5.1/protoc-3.5.1-linux-x86_64.zip\n```", "```rs\n$ unzip protoc-3.5.1-linux-x86_64.zip -d protoc3\n```", "```rs\n$ sudo mv protoc3/bin/* /usr/local/bin/\n```", "```rs\n// ch5/grpc/foobar.proto\n\nsyntax = \"proto3\";\n\npackage foobar;\n\n// Top level gRPC service with two RPC calls\nservice FooBarService {\n    rpc record_cab_location(CabLocationRequest) returns\n    (CabLocationResponse);\n    rpc get_cabs(GetCabRequest) returns (GetCabResponse);\n}\n\n// A request to record location of a cab\n// Name: unique name for a cab\n// Location: current location of the given cab\nmessage CabLocationRequest {\n    string name = 1;\n    Location location = 2;\n}\n\n// A response for a CabLocationRequest\n// Accepted: a boolean indicating if this\n// request was accepted for processing\nmessage CabLocationResponse {\n    bool accepted = 1;\n}\n\n// A request to return cabs at a given location\n// Location: a given location\nmessage GetCabRequest {\n    Location location = 1;\n}\n\n// A response for GetCabLocation\n// Cabs: list of cabs around the given location\nmessage GetCabResponse {\n    repeated Cab cabs = 1;\n}\n\n// Message that the CabLocationRequest passes\n// to the server\nmessage Cab {\n    string name = 1;\n    Location location = 2;\n}\n\n// Message with the location of a cab\nmessage Location {\n    float latitude = 1;\n    float longitude = 2;\n}\n```", "```rs\n// ch5/grpc/src/bin/server.rs\n\nextern crate grpc_example;\nextern crate grpc;\nextern crate protobuf;\n\nuse std::thread;\n\nuse grpc_example::foobar_grpc::*;\nuse grpc_example::foobar::*;\n\nstruct FooBarServer;\n\n// Implementation of RPC functions\n    impl FooBarService for FooBarServer {\n    fn record_cab_location(&self,\n                       _m: grpc::RequestOptions,\n                       req: CabLocationRequest)\n                       ->\n        grpc::SingleResponse<CabLocationResponse> {\n        let mut r = CabLocationResponse::new();\n\n        println!(\"Recorded cab {} at {}, {}\", req.get_name(),\n        req.get_location().latitude, req.get_location().longitude);\n\n        r.set_accepted(true);\n        grpc::SingleResponse::completed(r)\n    }\n\n    fn get_cabs(&self,\n                      _m: grpc::RequestOptions,\n                      _req: GetCabRequest)\n                      -> grpc::SingleResponse<GetCabResponse> {\n        let mut r = GetCabResponse::new();\n\n        let mut location = Location::new();\n        location.latitude = 40.7128;\n        location.longitude = -74.0060;\n\n        let mut one = Cab::new();\n        one.set_name(\"Limo\".to_owned());\n        one.set_location(location.clone());\n\n        let mut two = Cab::new();\n        two.set_name(\"Merc\".to_owned());\n        two.set_location(location.clone());\n\n        let vec = vec![one, two];\n        let cabs = ::protobuf::RepeatedField::from_vec(vec);\n\n        r.set_cabs(cabs);\n\n        grpc::SingleResponse::completed(r)\n    }\n}\n\nfn main() {\n    let mut server = grpc::ServerBuilder::new_plain();\n    server.http.set_port(9001);\n    server.add_service(FooBarServiceServer::new_service_def(FooBarServer));\n    server.http.set_cpu_pool_threads(4);\n    let _server = server.build().expect(\"Could not start server\");\n    loop {\n        thread::park();\n    }\n}\n```", "```rs\n// ch5/grpc/src/bin/client.rs\n\nextern crate grpc_example;\nextern crate grpc;\n\nuse grpc_example::foobar::*;\nuse grpc_example::foobar_grpc::*;\n\nfn main() {\n    // Create a client to talk to a given server\n    let client = FooBarServiceClient::new_plain(\"127.0.0.1\", 9001,\n    Default::default()).unwrap();\n\n    let mut req = CabLocationRequest::new();\n    req.set_name(\"foo\".to_string());\n\n    let mut location = Location::new();\n    location.latitude = 40.730610;\n    location.longitude = -73.935242;\n    req.set_location(location);\n\n    // First RPC call\n    let resp = client.record_cab_location(grpc::RequestOptions::new(),\n    req);\n    match resp.wait() {\n        Err(e) => panic!(\"{:?}\", e),\n        Ok((_, r, _)) => println!(\"{:?}\", r),\n    }\n\n    let mut nearby_req = GetCabRequest::new();\n    let mut location = Location::new();\n    location.latitude = 40.730610;\n    location.longitude = -73.935242;\n    nearby_req.set_location(location);\n\n    // Another RPC call\n    let nearby_resp = client.get_cabs(grpc::RequestOptions::new(),\n    nearby_req);\n    match nearby_resp.wait() {\n        Err(e) => panic!(\"{:?}\", e),\n        Ok((_, cabs, _)) => println!(\"{:?}\", cabs),\n    }\n}\n```", "```rs\n$ cargo run --bin client\n   Blocking waiting for file lock on build directory\n   Compiling grpc_example v0.1.0 (file:///rust-book/src/ch5/grpc)\n   Finished dev [unoptimized + debuginfo] target(s) in 3.94 secs\n     Running `/rust-book/src/ch5/grpc/target/debug/client`\naccepted: true\ncabs {name: \"Limo\" location {latitude: 40.7128 longitude: -74.006}} cabs {name: \"Merc\" location {latitude: 40.7128 longitude: -74.006}}\n```", "```rs\n$ cargo run --bin server\n   Compiling grpc_example v0.1.0 (file:///rust-book/src/ch5/grpc)\n    Finished dev [unoptimized + debuginfo] target(s) in 5.93 secs\n     Running `/rust-book/src/ch5/grpc/target/debug/server`\nRecorded cab foo at 40.73061, -73.93524\n```", "```rs\n$ cargo new --bin lettre-example\n```", "```rs\n$ cat Cargo.toml\n[package]\nname = \"lettre-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nlettre = \"0.7\"\nuuid = \"0.5.1\"\nnative-tls = \"0.1.4\"\n```", "```rs\n// ch5/lettre-example/src/main.rs\n\nextern crate uuid;\nextern crate lettre;\nextern crate native_tls;\n\nuse std::env;\nuse lettre::{SendableEmail, EmailAddress, EmailTransport};\nuse lettre::smtp::{SmtpTransportBuilder, SUBMISSION_PORT};\nuse lettre::smtp::authentication::Credentials;\nuse lettre::smtp::client::net::ClientTlsParameters;\n\nuse native_tls::TlsConnector;\n\n// This struct represents our email with all the data\n// we want to send.\nstruct CrashReport {\n    to: Vec<EmailAddress>,\n    from: EmailAddress,\n    message_id: String,\n    message: Vec<u8>,\n}\n\n// A simple constructor for our email.\nimpl CrashReport {\n    pub fn new(from_address: EmailAddress,\n        to_addresses: Vec<EmailAddress>,\n        message_id: String,\n        message: String) -> CrashReport {\n            CrashReport { from: from_address,\n            to: to_addresses,\n            message_id: message_id,\n            message: message.into_bytes()\n            }\n        }\n}\n\nimpl<'a> SendableEmail<'a, &'a [u8]> for CrashReport {\n    fn to(&self) -> Vec<EmailAddress> {\n        self.to.clone()\n    }\n\n    fn from(&self) -> EmailAddress {\n        self.from.clone()\n    }\n\n    fn message_id(&self) -> String {\n        self.message_id.clone()\n    }\n\n    fn message(&'a self) -> Box<&[u8]> {\n        Box::new(self.message.as_slice())\n    }\n}\n\nfn main() {\n    let server = \"smtp.foo.bar\";\n    let connector = TlsConnector::builder().unwrap().build().unwrap();\n    let mut transport = SmtpTransportBuilder::new((server, SUBMISSION_PORT), lettre::ClientSecurity::Opportunistic(<ClientTlsParameters>::new(server.to_string(), connector)))\n.expect(\"Failed to create transport\")\n    .credentials(Credentials::new(env::var(\"USERNAME\").unwrap_or_else(|_| \"user\".to_string()),\nenv::var(\"PASSWORD\").unwrap_or_else\n(|_| \"password\".to_string())))\n    .build();\n    let report = CrashReport::new(EmailAddress::\n    new(\"foo@bar.com\".to_string()), vec!   \n    [EmailAddress::new(\"foo@bar.com\".to_string())]\n    , \"foo\".to_string(), \"OOPS!\".to_string());\n    transport.send(&report).expect(\"Failed to send the report\");\n}\n```", "```rs\n$ cargo new --bin ftp-example\n```", "```rs\n[package]\nname = \"ftp-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies.ftp]\nversion = \"2.2.1\"\n```", "```rs\n// ch5/ftp-example/src/main.rs\n\nextern crate ftp;\n\nuse std::str;\nuse std::io::Cursor;\nuse ftp::{FtpStream, FtpError};\n\nfn run_ftp(addr: &str, user: &str, pass: &str) -> Result<(), FtpError> {\n    let mut ftp_stream = FtpStream::connect((addr, 21))?;\n    ftp_stream.login(user, pass)?;\n    println!(\"current dir: {}\", ftp_stream.pwd()?);\n\n    let data = \"A random string to write to a file\";\n    let mut reader = Cursor::new(data);\n    ftp_stream.put(\"my_file.txt\", &mut reader)?;\n\n    ftp_stream.quit()\n}\n\nfn main() {\n    run_ftp(\"ftp.dlptest.com\", \"dlpuser@dlptest.com\", \"eiTqR7EMZD5zy7M\").unwrap();\n}\n```", "```rs\n$ cargo run\n   Compiling ftp-example v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/ch5/ftp-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.5 secs\n     Running `target/debug/ftp-example`\ncurrent dir: /\n```", "```rs\n$ cargo new --bin tftp-example\n```", "```rs\n[package]\nname = \"tftp-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\ntftp_server = \"0.0.2\"\n```", "```rs\n// ch5/tftp-example/src/main.rs\n\nextern crate tftp_server;\n\nuse tftp_server::server::TftpServer;\n\nuse std::net::SocketAddr;\nuse std::str::FromStr;\n\nfn main() {\n    let addr = format!(\"0.0.0.0:{}\", 69);\n    let socket_addr = SocketAddr::from_str(addr.as_str()).expect(\"Error\n    parsing address\");\n    let mut server =\n    TftpServer::new_from_addr(&socket_addr).expect(\"Error creating\n    server\");\n    match server.run() {\n        Ok(_) => println!(\"Server completed successfully!\"),\n```", "```rs\n        Err(e) => println!(\"Error: {:?}\", e),\n    }\n}\n```", "```rs\n$ tftp\ntftp> connect 127.0.0.1 69\ntftp> status\nConnected to 127.0.0.1.\nMode: netascii Verbose: off Tracing: off\nRexmt-interval: 5 seconds, Max-timeout: 25 seconds\ntftp> get Cargo.toml\nReceived 144 bytes in 0.0 seconds\ntftp> ^D\n```"]