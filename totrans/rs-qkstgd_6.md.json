["```rs\npub struct Person {\n    pub name: String,\n    pub validated: bool,\n}\n```", "```rs\nlet jack = Box::new(Person { name: \"Jack\".to_string(), validated: true });\nlet x = &jack.name;\nprintln!(\"The person in the box is {}\", x);\n```", "```rs\nlet x = *jack;\n```", "```rs\nlet x = &jack.name;\nprintln!(\"The person in the box is {}\", x);\n```", "```rs\nprintln!(\"The person in the box is {}\", jack.name);\n```", "```rs\npub struct TreeNode {\n    pub value: i32,\n    pub left: TreeNode,\n    pub right: TreeNode,\n}\n```", "```rs\npub struct TreeNode {\n    pub value: i32,\n    pub left: Box<TreeNode>,\n    pub right: Box<TreeNode>,\n}\n```", "```rs\nlet jill: Box<dyn Any> = Box::new(Person { name: \"Jill\".to_string(), validated: false });\n```", "```rs\nlet real_jill = jill.downcast::<Person>().unwrap();\nprintln!(\"{}\", real_jill.name);\n```", "```rs\nlet mut text = String::new();\ntext.push('W');\ntext.push_str(\"elcome to mutable strings\");\ntext.insert_str(11, \"exciting \");\ntext.replace_range(28.., \"text\");\nprintln!(\"{}\", text);\n```", "```rs\nlet mut vector = Vec::new();\n```", "```rs\nvector.push(1.5);\n```", "```rs\nvector.push(\"nope\");\n```", "```rs\nlet x: f64 = 99.9;\nvector.push(x);\n```", "```rs\nlet mut second_vector = Vec::new();\nsecond_vector.push(\"This\");\nsecond_vector.push(\"works\");\nsecond_vector.push(\"fine\");\n```", "```rs\n    println!(\"{} {} {}.\", second_vector[0], second_vector[1], second_vector[2]);\n```", "```rs\nlet third_vector = vec![\"This\", \"works\", \"too\"];\n```", "```rs\npub fn make_vector_of_rcs() -> Vec<Rc<String>> {\n    let ada = Rc::new(\"Ada\".to_string());\n    let mel = Rc::new(\"Mel\".to_string());\n\n    return vec![\n        Rc::clone(&ada),\n        Rc::clone(&mel),\n        Rc::clone(&ada),\n        Rc::clone(&ada),\n        Rc::clone(&mel),\n        Rc::clone(&ada),\n        Rc::clone(&mel),\n    ];\n}\n```", "```rs\nlet mut ada_and_mel = make_vector_of_rcs();\n\nwhile ada_and_mel.len() > 0 {\n println!(\"{:?}\", ada_and_mel);\n\n print!(\"Remove which: \");\n io::stdout().flush().unwrap();\n\n let mut line = String::new();\n io::stdin().read_line(&mut line).unwrap();\n\n let idx: usize = line.trim().parse().unwrap();\n ada_and_mel.remove(idx);\n}\n```", "```rs\nlet cell = Cell::new(\"Let me out!\".to_string());\nprintln!(\"{}\", cell.replace(\"Don't put me in there.\".to_string()));\nprintln!(\"{}\", cell.replace(\"I didn't do anything.\".to_string()));\ncell.set(\"You'll never hold me, copper!\".to_string());\nprintln!(\"{}\", cell.into_inner());\n```", "```rs\n let refcell = RefCell::new(\"It's a string\".to_string());\n\n match refcell.try_borrow() {\n Ok(x) => { println!(\"Borrowed: {}\", x); }\n Err(_) => { println!(\"Couldn't borrow first try\"); }\n };\n\n let borrowed_mutably = refcell.try_borrow_mut()?;\n\n match refcell.try_borrow() {\n Ok(x) => { println!(\"Borrowed: {}\", x); }\n Err(_) => { println!(\"Couldn't borrow second try\"); }\n };\n\n println!(\"Mutable borrow is still alive: {}\", borrowed_mutably);\n```", "```rs\nlet counter = Arc::new(Mutex::new(0));\n\nfor _ in 0..10 {\n let local_counter = Arc::clone(&counter);\n thread::spawn(move || {\n let wait = time::Duration::new(random::<u64>() % 8, 0);\n thread::sleep(wait);\n let mut shared = local_counter.lock().unwrap();\n *shared += 1;\n });\n}\n\nloop {\n    {\n        let shared = counter.lock().unwrap();\n        println!(\"{} threads have completed\", *shared);\n\n        if *shared >= 10 {\n            break;\n        };\n    };\n    thread::sleep(time::Duration::new(1, 0));\n}\n```"]