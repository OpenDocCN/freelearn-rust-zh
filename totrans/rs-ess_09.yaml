- en: Chapter 9. Programming at the Boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we look at how we can start up a Rust program with command-line
    parameters. Then, we go on to look at situations where we have to leave the safety
    boundaries, such as when interfacing with C programs, and how Rust minimizes potential
    dangers when doing so.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Program arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsafe code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing with C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inlining assembly code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Rust from other languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reading program parameters from the command line at startup is easy in Rust;
    just use the `std::env::args()` method. We can collect these parameters into a
    vector of `String` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the program in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments arg1 arg2` on Windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./arguments arg1 arg2` on Linux and Mac OS X'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the output from a real call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Program arguments](img/image00185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The program's name is `args[0]`; the next arguments are the command-line parameters.
    We can iterate through the arguments or access them by index. The number of parameters
    is given by `args.len() – 1`.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex parsing with options and flags, use the `getopts` or `docopt`
    crate. To get started, there is an example at [http://rustbyexample.com](http://rustbyexample.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `env::vars()` returns the operating system''s environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This starts with printing out the following on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unsafe code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are situations in which even the Rust compiler cannot guarantee us that
    our code will behave in a safe manner. This can occur in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When we have to program against the "metal", close to the operating system,
    processors, and hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we want to work with the same amount of control that is possible in C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we delegate a part of program execution to an unsafe language such as C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we want to inline assembly language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rust allows us to code for these scenarios, but we have to envelop this possibly
    dangerous code in an `unsafe` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, the programmer takes full responsibility. The `unsafe` block is a promise
    to the compiler that the unsafety will not leak out of the block. The compiler
    will check the code areas that are marked as `unsafe` more loosely and allow otherwise
    forbidden manipulations, but a number of rules from the ownership system (refer
    to [Chapter 6](part0056.xhtml#aid-1LCVG2 "Chapter 6. Pointers and Memory Safety"),
    *Pointers and Memory Safety*, for more information) will still remain in place.
  prefs: []
  type: TYPE_NORMAL
- en: The clear advantage is that problem areas will now appear very well isolated;
    if a problem occurs, we will know that it can only occur in these marked code
    areas. Having a code base where 99 percent of the code is safe and 1 percent is
    unsafe is much easier to maintain than a code base with 100 percent unsafe code,
    as in C!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we can do in an `unsafe` block:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with raw pointers, especially by dereferencing them. For more information,
    refer to the *Raw pointers* section of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call a function in another language through a **Foreign Function Interface**
    (**FFI**). For more information, see the *Interfacing with C* section of this
    chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline assembly code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use `std::mem::transmute` to convert simple types bitwise; here is an example
    of its use in which a string is transformed into a slice of bytes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: An `unsafe` block can also call the `unsafe` functions that perform these dangerous
    operations and are marked as `unsafe fn dangerous() { }`.
  prefs: []
  type: TYPE_NORMAL
- en: In `unsafe` code, the use of the `std::mem` module (which contains functions
    to work with memory at a low level) and the `std::ptr` module (which contains
    functions to work with raw pointers) is common.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We recommend that you use `assert!` statements abundantly inside unsafe code
    to check at runtime whether it is doing what you expect it to. For instance, before
    dereferencing a raw `ptr` pointer of unknown origin, always call `assert!(!ptr.is_null());`
    to ensure that the pointer points to a valid memory location.
  prefs: []
  type: TYPE_NORMAL
- en: Raw pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In unsafe code blocks, Rust allows the use of a new kind of pointers called
    *raw pointers*. For these pointers, there is no built-in security, and you can
    work with them with the same freedom as C pointers. They are written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*const T`: This is used for a pointer of an immutable value or the `T` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*mut T`: This is used as a mutable pointer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can point to invalid memory, and the memory resource needs to be manually
    freed. This means that a raw pointer could inadvertently be used after freeing
    the memory that it points to. In addition, multiple concurrent threads have nonexclusive
    access to mutable raw pointers. Since we're not sure of the contents (at least
    we have no compiler guarantee of valid content), dereferencing a raw pointer can
    also lead to program failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why dereferencing a raw pointer can only be done inside an `unsafe`
    block, as illustrated in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to do this in normal code, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make raw pointers safely out of references, implicitly or explicitly,
    with `&` as `*const`, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, converting a raw pointer into a reference, which should be done through
    a `&*` (address of a dereference) operation, must be done within an `unsafe` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Raw pointers could also be useful when defining other more intelligent pointers;
    for example, they are used to implement the `Rc` and `Arc` pointer types.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the vast functionality that exists in C's code, it can sometimes be useful
    to delegate processing to a C routine, instead of writing everything in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can call all functions from the C standard library by using the `libc`
    crate, which must be obtained through Cargo. To do this, simply add the following
    to your Rust code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To import C functions and types, you can sum them up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use a `*` wildcard, such as `use libc::*;`, to make them
    all available.
  prefs: []
  type: TYPE_NORMAL
- en: To work with C (or another language) from Rust, you will have to use the FFI,
    which has its utilities in the `std::ffi` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example to call C for printing out a Rust string with the
    `puts` function in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out the following sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `new()` method of `CString` will produce a string (ending with a 0 byte)
    that is compatible with C from the Rust string. The `as_ptr()` method returns
    a pointer to this C string.
  prefs: []
  type: TYPE_NORMAL
- en: The `#![feature(libc)]` attribute (a so called feature gate) is (temporarily)
    necessary to enable the use of `libc`. It does not work with Rust from the beta
    channel, you need to take the Rust compiler from the nightly channel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feature gates are common in Rust to enable the use of a certain functionality,
    but they are not available in stable Rust; they are only available in the current
    development branch (the nightly release).
  prefs: []
  type: TYPE_NORMAL
- en: Using a C library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we want to calculate the tangents of a complex number. The `num` crate
    offers basic operations on complex numbers, but at this time, the `tangents` function
    is not yet included, so we will call the `ctanf` function from the C library `libm`,
    which is a collection of mathematical functions that are implemented in C.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code does just that and defines a complex number as a simple
    `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This program prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `#[derive(Debug)]` attribute is necessary because we want to show the number
    in a `{:?}` format string. The `#[derive(Copy, Clone)]` attribute is needed because
    we want to use `z` in the `println!` statement, after we have moved it by calling
    `ctanf(z)`. The function of `#[repr(C)]` is to reassure the compiler that the
    type we are passing to C is foreign function-safe, and it tells `rustc` to create
    `struct` with the same layout as C.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signatures of the C functions that we want to use must be listed in an
    `extern {}` block. The compiler cannot check these signatures, so it is important
    to specify them accurately to make the correct bindings at runtime. This block
    can also declare global variables that are exported by C to use in Rust. They
    must be marked as `static` or `static mut`, for example, `static mut version:
    libc::c_int`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `extern` block must be preceded by a `#[link(name = "m")]` attribute to
    link the `libm` library. This instructs `rustc` to link to that native library
    so that symbols from that library are resolved.
  prefs: []
  type: TYPE_NORMAL
- en: The C call itself must evidently be done inside an `unsafe {}` block. This block
    is enveloped inside a `tan(z)` wrapper function, which only uses Rust types. This
    way this wrapper can be exposed as a safe interface, by hiding the unsafe calls
    and type conversions between Rust and C types, especially C pointers. When the
    C code returns a resource, the Rust code must contain destructors for these values
    to assure their memory release.
  prefs: []
  type: TYPE_NORMAL
- en: Inlining assembly code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Rust, we can embed assembly code. This should be extremely rare, but we can
    think of situations where this might be useful, for example, when you have to
    get the utmost performance or very low-level control. However, the portability
    of your code and perhaps its stability are decreased when you do this. The Rust
    compiler will probably generate better assembly code than you could write, so
    it isn't worth the effort most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This feature is not yet enabled in Rust 1.0 on the stable release channel. To
    use this mechanism (or other unstable features) in the meantime, you have to use
    Rust from the master branch (which is the nightly release).
  prefs: []
  type: TYPE_NORMAL
- en: 'The mechanism works by using the `asm!` macro, like this example where we calculate
    `b` in the subtract function by calling assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This prints out the result as `35`.
  prefs: []
  type: TYPE_NORMAL
- en: We can only use `asm!` with a so-called feature gate, which is `#![feature(asm)]`
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The `asm!` macro has a number of parameters separated by `:`. The first is the
    assembly template, containing the assembly code as a string, then the output and
    input operands follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can indicate the kind of processor your assembly code is meant to execute
    on with the `cfg` attribute and its `target_arch` value, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will then check whether you have specified valid assembly code
    for that processor.
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed information about the use of `asm!`, refer to the *Inline
    Assembly* section of this chapter at [http://doc.rust-lang.org/book/unsafe.html](http://doc.rust-lang.org/book/unsafe.html).
  prefs: []
  type: TYPE_NORMAL
- en: Calling Rust from other languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Rust code can be called from any language that can call C. However, the Rust
    library should have the `dylib` crate type value. When `rustfn1` is the Rust function
    to be called, this must be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, `#[no_mangle]` serves to keep the function names plain and simple so that
    they are easier to link to. C exports the function to the outside world with the
    C calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of calling Rust from C, Python, Haskell, and Node.js can be found in
    the article at [https://siciarz.net/24-days-of-rust-calling-rust-from-other-languages/](https://siciarz.net/24-days-of-rust-calling-rust-from-other-languages/).
    Calling Rust from Perl and Julia is shown at [http://paul.woolcock.us/posts/rust-perl-julia-ffi.html](http://paul.woolcock.us/posts/rust-perl-julia-ffi.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to process parameters for your program that
    are read from the command line at startup. Then, we proceeded to unsafe territory
    where raw pointers point the way. We covered how to use assembly code, how to
    call C functions from Rust, and how to call Rust functions from other languages.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes our essential tour of Rust. In the [Appendix](part0075.xhtml#aid-27GQ61
    "Appendix A. Exploring Further"), *Exploring Further*, that follows this chapter,
    we provide you with pointers (no pun intended!) to pursue your Rust journey.
  prefs: []
  type: TYPE_NORMAL
