["```rs\nfn main() {\n    println!(\"GREETINGS, HUMANS\");\n}\n```", "```rs\nhello_worlds > rustc -C opt-level=3 sequential_hello_world.rs\nhello_worlds > time for i in {1..100}; do ./sequential_hello_world > /dev/null; done\n\nreal    0m0.091s\nuser    0m0.004s\nsys     0m0.012s\n```", "```rs\nuse std::thread;\n\nfn main() {\n    thread::spawn(|| println!(\"GREETINGS, HUMANS\"))\n        .join()\n        .unwrap();\n}\n```", "```rs\nhello_worlds > rustc -C opt-level=3 parallel_hello_world.rs\nhello_worlds > time for i in {1..100}; do ./parallel_hello_world > /dev/null; done\n\nreal    0m0.115s\nuser    0m0.004s\nsys     0m0.012s\n```", "```rs\npub struct HashMap<K, V, S = RandomState> {\n    // All hashes are keyed on these values, to prevent \n    // hash collision attacks.\n    hash_builder: S,\n\n    table: RawTable<K, V>,\n\n    resize_policy: DefaultResizePolicy,\n}\n```", "```rs\npub struct RawTable<K, V> {\n    capacity_mask: usize,\n    size: usize,\n    hashes: TaggedHashUintPtr,\n\n    // Because K/V do not appear directly in any of the\n    // types in the struct, inform rustc that in fact \n    // instances of K and V are reachable from here.\n    marker: marker::PhantomData<(K, V)>,\n}\n```", "```rs\n    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n        let hash = self.make_hash(&k);\n        self.reserve(1);\n        self.insert_hashed_nocheck(hash, k, v)\n    }\n```", "```rs\n    pub fn reserve(&mut self, additional: usize) {\n        let remaining = self.capacity() - self.len(); // this can't \n        overflow\n        if remaining < additional {\n            let min_cap = \n            self.len().checked_add(additional)\n                      .expect(\"reserve overflow\");\n            let raw_cap = self.resize_policy.raw_capacity(min_cap);\n            self.resize(raw_cap);\n        } else if self.table.tag() && remaining <= self.len() {\n            // Probe sequence is too long and table is half full,\n            // resize early to reduce probing length.\n            let new_capacity = self.table.capacity() * 2;\n            self.resize(new_capacity);\n        }\n    }\n```", "```rs\n    #[inline(never)]\n    #[cold]\n    fn resize(&mut self, new_raw_cap: usize) {\n        assert!(self.table.size() <= new_raw_cap);\n        assert!(new_raw_cap.is_power_of_two() || new_raw_cap == 0);\n\n        let mut old_table = replace(&mut self.table, \n        RawTable::new(new_raw_cap));\n        let old_size = old_table.size();\n\n        if old_table.size() == 0 {\n            return;\n        }\n\n        let mut bucket = Bucket::head_bucket(&mut old_table);\n\n        // This is how the buckets might be laid out in memory:\n        // ($ marks an initialized bucket)\n        //  ________________\n        // |$$$_$$$$$$_$$$$$|\n        //\n        // But we've skipped the entire initial cluster of buckets\n        // and will continue iteration in this order:\n        //  ________________\n        //     |$$$$$$_$$$$$\n        //                  ^ wrap around once end is reached\n        //  ________________\n        //  $$$_____________|\n        //    ^ exit once table.size == 0\n        loop {\n            bucket = match bucket.peek() {\n                Full(bucket) => {\n                    let h = bucket.hash();\n                    let (b, k, v) = bucket.take();\n                    self.insert_hashed_ordered(h, k, v);\n                    if b.table().size() == 0 {\n                        break;\n                    }\n                    b.into_bucket()\n                }\n                Empty(b) => b.into_bucket(),\n            };\n            bucket.next();\n        }\n\n        assert_eq!(self.table.size(), old_size);\n    }\n```", "```rs\npub struct Bucket<K, V, M> {\n    raw: RawBucket<K, V>,\n    table: M,\n}\n```", "```rs\npub enum BucketState<K, V, M> {\n    Empty(EmptyBucket<K, V, M>),\n    Full(FullBucket<K, V, M>),\n}\n```", "```rs\n    fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n        let mut buckets = Bucket::new(&mut self.table, hash);\n        let start_index = buckets.index();\n\n        loop {\n            // We don't need to compare hashes for value swap.\n            // Not even DIBs for Robin Hood.\n            buckets = match buckets.peek() {\n                Empty(empty) => {\n                    empty.put(hash, k, v);\n                    return;\n                }\n                Full(b) => b.into_bucket(),\n            };\n            buckets.next();\n            debug_assert!(buckets.index() != start_index);\n        }\n    }\n```", "```rs\n    pub fn put(mut self, hash: SafeHash, key: K, value: V) \n        -> FullBucket<K, V, M> \n    {\n        unsafe {\n            *self.raw.hash() = hash.inspect();\n            ptr::write(self.raw.pair(), (key, value));\n\n            self.table.borrow_table_mut().size += 1;\n        }\n\n        FullBucket {\n            raw: self.raw,\n            table: self.table,\n        }\n    }\n```", "```rs\npub struct RawBucket<K, V> {\n    hash_start: *mut HashUint,\n    // We use *const to ensure covariance with respect to K and V\n    pair_start: *const (K, V),\n    idx: usize,\n    _marker: marker::PhantomData<(K, V)>,\n}\n```", "```rs\n    fn raw_bucket_at(&self, index: usize) -> RawBucket<K, V> {\n        let hashes_size = self.capacity() * size_of::<HashUint>();\n        let pairs_size = self.capacity() * size_of::<(K, V)>();\n\n        let (pairs_offset, _, oflo) =\n            calculate_offsets(hashes_size, pairs_size, \n                              align_of::<(K, V)>());\n        debug_assert!(!oflo, \"capacity overflow\");\n\n        let buffer = self.hashes.ptr() as *mut u8;\n        unsafe {\n            RawBucket {\n                hash_start: buffer as *mut HashUint,\n                pair_start: buffer.offset(pairs_offset as isize) \n                              as *const (K, V),\n                idx: index,\n                _marker: marker::PhantomData,\n            }\n        }\n    }\n```", "```rs\n> cargo new naive_hashmap\n     Created library `naive_hashmap` project\n```", "```rs\n[package]\nname = \"naive_hashmap\"\nversion = \"0.1.0\"\n\n[dependencies]\nrand = \"0.4.2\"\n\n[dev-dependencies]\nquickcheck = \"0.6\"\ncriterion = \"0.1\"\n\n[[bench]]\nname = \"naive\"\nharness = false\n\n[[bin]]\nname = \"naive_interpreter\"\ndoc = false\n\n[[bin]]\nname = \"standard\"\ndoc = false\n\n[[bin]]\nname = \"naive\"\ndoc = false\n\n[[bench]]\nname = \"specialized\"\nharness = false\n\n[[bin]]\nname = \"specialized_interpreter\"\ndoc = false\n\n[[bin]]\nname = \"specialized\"\ndoc = false\n```", "```rs\n#[cfg(test)]\nextern crate quickcheck;\n\nuse std::hash::{BuildHasher, Hash, Hasher};\nuse std::borrow::Borrow;\nuse std::collections::hash_map::RandomState;\nuse std::{cmp, mem, ptr};\n```", "```rs\n#[derive(Default)]\npub struct HashMap<K, V, S = RandomState>\nwhere\n    K: Eq,\n    V: ::std::fmt::Debug,\n{\n    hash_builder: S,\n    data: Vec<(u64, K, V)>,\n}\n```", "```rs\nimpl<K: Eq, V> HashMap<K, V, RandomState>\nwhere\n    K: Eq + Hash,\n    V: ::std::fmt::Debug,\n{\n    pub fn new() -> HashMap<K, V> {\n        HashMap {\n            hash_builder: RandomState::new(),\n            data: Vec::new(),\n        }\n    }\n}\n\nfn make_hash<T: ?Sized, S>(hash_builder: &S, t: &T) -> u64\nwhere\n    T: Hash,\n    S: BuildHasher,\n{\n    let mut state = hash_builder.build_hasher();\n    t.hash(&mut state);\n    state.finish()\n}\n\nimpl<K, V, S> HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher,\n    V: ::std::fmt::Debug,\n{\n    pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n        HashMap {\n            hash_builder: hash_builder,\n            data: Vec::new(),\n        }\n    }\n```", "```rs\n    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n        let hash = make_hash(&self.hash_builder, &k);\n\n        let end = self.data.len();\n        for idx in 0..end {\n            match self.data[idx].0.cmp(&hash) {\n                cmp::Ordering::Greater => {\n                    self.data.insert(idx, (hash, k, v));\n                    return None;\n                }\n                cmp::Ordering::Less => continue,\n                cmp::Ordering::Equal => {\n                    let old = mem::replace(&mut self.data[idx].2, v);\n                    return Some(old);\n                }\n            }\n        }\n        self.data.push((hash, k, v));\n        None\n    }\n```", "```rs\n    pub fn get<Q: ?Sized>(&mut self, k: &Q) -> Option<&V>\n    where\n        K: Borrow<Q> + ::std::fmt::Debug,\n        Q: Hash + Eq + ::std::fmt::Debug,\n    {\n        let hash = make_hash(&self.hash_builder, k);\n\n        for &(bucket_hash, _, ref v) in &self.data {\n            if hash == bucket_hash {\n                return Some(v);\n            }\n        }\n        None\n    }\n```", "```rs\n#[cfg(test)]\nmod test {\n    extern crate quickcheck;\n\n    use super::*;\n    use quickcheck::{Arbitrary, Gen, QuickCheck, TestResult};\n```", "```rs\n    #[test]\n    fn get_what_you_give() {\n        fn property(k: u16, v: u16) -> TestResult {\n            let mut system_under_test = HashMap::new();\n\n            assert_eq!(None, system_under_test.insert(k, v));\n            assert_eq!(Some(&v), system_under_test.get(&k));\n\n            TestResult::passed()\n        }\n        QuickCheck::new().quickcheck(property as fn(u16, u16) -> \n                                     TestResult);\n    }\n```", "```rs\npub trait Arbitrary : Clone + Send + 'static {\n    fn arbitrary<G: Gen>(g: &mut G) -> Self;\n\n    fn shrink(&self) -> Box<Iterator<Item=Self>> {\n        empty_shrinker()\n    }\n}\n```", "```rs\nmacro_rules! unsigned_arbitrary {\n    ($($ty:tt),*) => {\n        $(\n            impl Arbitrary for $ty {\n                fn arbitrary<G: Gen>(g: &mut G) -> $ty {\n                    #![allow(trivial_numeric_casts)]\n                    let s = g.size() as $ty;\n                    use std::cmp::{min, max};\n                    g.gen_range(0, max(1, min(s, $ty::max_value())))\n                }\n                fn shrink(&self) -> Box<Iterator<Item=$ty>> {\n                    unsigned_shrinker!($ty);\n                    shrinker::UnsignedShrinker::new(*self)\n                }\n            }\n        )*\n    }\n}\n\nunsigned_arbitrary! {\n    usize, u8, u16, u32, u64\n}\n```", "```rs\n    #[derive(Clone, Debug)]\n    enum Action<T>\n    where\n        T: Arbitrary,\n    {\n        Insert(T, u16),\n        Lookup(T),\n    }\n```", "```rs\n    impl<T> Arbitrary for Action<T>\n    where\n        T: Arbitrary,\n    {\n        fn arbitrary<G>(g: &mut G) -> Action<T>\n        where\n            G: Gen,\n        {\n            let i: usize = g.gen_range(0, 100);\n            match i {\n                0...50 => Action::Insert(Arbitrary::arbitrary(g), \n                                         u16::arbitrary(g)),\n                _ => Action::Lookup(Arbitrary::arbitrary(g)),\n            }\n        }\n    }\n```", "```rs\n    #[test]\n    fn sut_vs_genuine_article() {\n        fn property<T>(actions: Vec<Action<T>>) -> TestResult\n        where\n            T: Arbitrary + Eq + Hash + ::std::fmt::Debug,\n        {\n            let mut model = ::std::collections::HashMap::new();\n            let mut system_under_test = HashMap::new();\n\n            for action in actions.into_iter() {\n                match action {\n                    Action::Insert(k, v) => {\n                        assert_eq!(model.insert(k.clone(), v), \n                        system_under_test.insert(k, v));\n                    }\n                    Action::Lookup(k) => {\n                        assert_eq!(model.get(&k), \n                        system_under_test.get(&k));\n                    }\n                }\n            }\n            TestResult::passed()\n        }\n        QuickCheck::new().quickcheck(property as fn(Vec<Action<u8>>) -> \n                                     TestResult);\n    }\n}\n```", "```rs\n[[bin]]\nname = \"naive_interpreter\"\ndoc = false\n```", "```rs\nextern crate naive_hashmap;\n\nuse std::io;\nuse std::io::prelude::*;\n\nfn main() {\n    let mut hash_map = naive_hashmap::HashMap::new();\n\n    let n = io::stdin();\n    for line in n.lock().lines() {\n        if let Ok(line) = line {\n            let mut cmd = line.split(\" \");\n            match cmd.next() {\n                Some(\"LOOKUP\") => {\n                    if let Some(key) = cmd.next() {\n                        let _ = hash_map.get(key);\n                    } else {\n                        continue;\n                    }\n                }\n                Some(\"INSERT\") => {\n                    if let Some(key) = cmd.next() {\n                        if let Some(val) = cmd.next() {\n                            let _ = hash_map.insert(key.to_string(), \n                            val.to_string());\n                        }\n                    } else {\n                        continue;\n                    }\n                }\n                _ => continue,\n            }\n        } else {\n            break;\n        }\n    }\n}\n```", "```rs\nLOOKUP 10\nINSERT abs 10\nLOOKUP abs\n```", "```rs\n> cargo afl build --release\n> cargo afl fuzz -i resources/in/ -o resources/out/ target/release/naive_interpreter\n```", "```rs\n#[macro_use]\nextern crate criterion;\nextern crate naive_hashmap;\nextern crate rand;\n\nuse criterion::{Criterion, Fun};\nuse rand::{Rng, SeedableRng, XorShiftRng};\n```", "```rs\nfn insert_and_lookup_naive(mut n: u64) {\n    let mut rng: XorShiftRng = SeedableRng::from_seed([1981, 1986,\n                                                       2003, 2011]);\n    let mut hash_map = naive_hashmap::HashMap::new();\n\n    while n != 0 {\n        let key = rng.gen::<u8>();\n        if rng.gen::<bool>() {\n            let value = rng.gen::<u32>();\n            hash_map.insert(key, value);\n        } else {\n            hash_map.get(&key);\n        }\n        n -= 1;\n    }\n}\n```", "```rs\nfn insert_and_lookup_standard(mut n: u64) {\n    let mut rng: XorShiftRng = SeedableRng::from_seed([1981, 1986, \n                                                       2003, 2011]);\n    let mut hash_map = ::std::collections::HashMap::new();\n\n    while n != 0 {\n        let key = rng.gen::<u8>();\n        if rng.gen::<bool>() {\n            let value = rng.gen::<u32>();\n            hash_map.insert(key, value);\n        } else {\n            hash_map.get(&key);\n        }\n        n -= 1;\n    }\n}\n```", "```rs\nmacro_rules! insert_lookup {\n    ($fn:ident, $s:expr) => {\n        fn $fn(c: &mut Criterion) {\n            let naive = Fun::new(\"naive\", |b, i| b.iter(||                   \n                                   insert_and_lookup_naive(*i))\n            );\n            let standard = Fun::new(\"standard\", |b, i| b.iter(|| \n                                      insert_and_lookup_standard(*i))\n            );\n\n            let functions = vec![naive, standard];\n\n            c.bench_functions(&format!(\"HashMap/{}\", $s),\n                              functions, &$s);\n        }\n    }\n}\n\ninsert_lookup!(insert_lookup_100000, 100_000);\ninsert_lookup!(insert_lookup_10000, 10_000);\ninsert_lookup!(insert_lookup_1000, 1_000);\ninsert_lookup!(insert_lookup_100, 100);\ninsert_lookup!(insert_lookup_10, 10);\ninsert_lookup!(insert_lookup_1, 1);\n```", "```rs\ncriterion_group!{\n    name = benches;\n    config = Criterion::default();\n    targets = insert_lookup_100000, insert_lookup_10000, \n              insert_lookup_1000, insert_lookup_100, \n              insert_lookup_10, insert_lookup_1\n}\ncriterion_main!(benches);\n```", "```rs\n> cargo bench\n   Compiling naive_hashmap v0.1.0 (file:///home/blt/projects/us/troutwine/concurrency_in_rust/external_projects/naive_hashmap)\n    Finished release [optimized] target(s) in 5.26 secs\n     Running target/release/deps/naive_hashmap-fe6fcaf7cf309bb8\n\nrunning 2 tests\ntest test::get_what_you_give ... ignored\ntest test::sut_vs_genuine_article ... ignored\n\ntest result: ok. 0 passed; 0 failed; 2 ignored; 0 measured; 0 filtered out\n\n     Running target/release/deps/naive_interpreter-26c60c76389fd26d\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/release/deps/naive-96230b57fe0068b7\nHashMap/100000/naive    time:   [15.807 ms 15.840 ms 15.879 ms]\nFound 13 outliers among 100 measurements (13.00%)\n  2 (2.00%) low mild\n  1 (1.00%) high mild\n  10 (10.00%) high severe\nHashMap/100000/standard time:   [2.9067 ms 2.9102 ms 2.9135 ms]\nFound 7 outliers among 100 measurements (7.00%)\n  1 (1.00%) low severe\n  5 (5.00%) low mild\n  1 (1.00%) high mild\n\nHashMap/10000/naive     time:   [1.5475 ms 1.5481 ms 1.5486 ms]\nFound 9 outliers among 100 measurements (9.00%)\n  1 (1.00%) low severe\n  2 (2.00%) high mild\n  6 (6.00%) high severe\nHashMap/10000/standard  time:   [310.60 us 310.81 us 311.03 us]\nFound 11 outliers among 100 measurements (11.00%)\n  1 (1.00%) low severe\n  2 (2.00%) low mild\n  3 (3.00%) high mild\n  5 (5.00%) high severe\n```", "```rs\nextern crate naive_hashmap;\nextern crate rand;\n\nuse std::collections::HashMap;\nuse rand::{Rng, SeedableRng, XorShiftRng};\n\nfn main() {\n    let mut rng: XorShiftRng = SeedableRng::from_seed([1981, 1986, \n                                                       2003, 2011]);\n    let mut hash_map = HashMap::new();\n\n    let mut insert_empty = 0;\n    let mut insert_present = 0;\n    let mut get_fail = 0;\n    let mut get_success = 0;\n\n    for _ in 0..100_000 {\n        let key = rng.gen::<u16>();\n        if rng.gen::<bool>() {\n            let value = rng.gen::<u32>();\n            if hash_map.insert(key, value).is_none() {\n                insert_empty += 1;\n            } else {\n                insert_present += 1;\n            }\n        } else {\n            if hash_map.get(&key).is_none() {\n                get_fail += 1;\n            } else {\n                get_success += 1;\n            }\n        }\n    }\n\n    println!(\"INSERT\");\n    println!(\"  empty:   {}\", insert_empty);\n    println!(\"  present: {}\", insert_present);\n    println!(\"LOOKUP\");\n    println!(\"  fail:    {}\", get_fail);\n    println!(\"  success: {}\", get_success);\n}\n```", "```rs\nextern crate naive_hashmap;\nextern crate rand;\n\nuse naive_hashmap::HashMap;\nuse rand::{Rng, SeedableRng, XorShiftRng};\n\nfn main() {\n    let mut rng: XorShiftRng = SeedableRng::from_seed([1981, 1986, \n                                                       2003, 2011]);\n    let mut hash_map = HashMap::new();\n\n    let mut insert_empty = 0;\n    let mut insert_present = 0;\n    let mut get_fail = 0;\n    let mut get_success = 0;\n\n    for _ in 0..100_000 {\n        let key = rng.gen::<u16>();\n        if rng.gen::<bool>() {\n            let value = rng.gen::<u32>();\n            if hash_map.insert(key, value).is_none() {\n                insert_empty += 1;\n            } else {\n                insert_present += 1;\n            }\n        } else {\n            if hash_map.get(&key).is_none() {\n                get_fail += 1;\n            } else {\n                get_success += 1;\n            }\n        }\n    }\n\n    println!(\"INSERT\");\n    println!(\"  empty:   {}\", insert_empty);\n    println!(\"  present: {}\", insert_present);\n    println!(\"LOOKUP\");\n    println!(\"  fail:    {}\", get_fail);\n    println!(\"  success: {}\", get_success);\n}\n```", "```rs\nnaive_hashmap > valgrind --tool=memcheck target/release/standard\n==13285== Memcheck, a memory error detector\n==13285== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==13285== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info\n==13285== Command: target/release/standard\n==13285==\nINSERT\n  empty:   35217\n  present: 15071\nLOOKUP\n  fail:    34551\n  success: 15161\n==13285==\n==13285== HEAP SUMMARY:\n==13285==     in use at exit: 0 bytes in 0 blocks\n==13285==   total heap usage: 7 allocs, 7 frees, 2,032 bytes allocated\n==13285==\n==13285== All heap blocks were freed -- no leaks are possible\n==13285==\n==13285== For counts of detected and suppressed errors, rerun with: -v\n==13285== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n```", "```rs\n==13307== HEAP SUMMARY:\n==13307==     in use at exit: 0 bytes in 0 blocks\n==13307==   total heap usage: 7 allocs, 7 frees, 2,032 bytes allocated\n```", "```rs\nnaive_hashmap > valgrind --tool=cachegrind --branch-sim=yes target/release/standard\n==13372== Cachegrind, a cache and branch-prediction profiler\n==13372== Copyright (C) 2002-2015, and GNU GPL'd, by Nicholas Nethercote et al.\n==13372== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info\n==13372== Command: target/release/standard\n==13372==\n--13372-- warning: L3 cache found, using its data for the LL simulation.\nINSERT\n  empty:   35217\n  present: 15071\nLOOKUP\n  fail:    34551\n  success: 15161\n==13372==\n==13372== I   refs:      25,733,614\n==13372== I1  misses:         2,454\n==13372== LLi misses:         2,158\n==13372== I1  miss rate:       0.01%\n==13372== LLi miss rate:       0.01%\n==13372==\n==13372== D   refs:       5,400,581  (2,774,345 rd   + 2,626,236 wr)\n==13372== D1  misses:       273,218  (  219,462 rd   +    53,756 wr)\n==13372== LLd misses:        36,267  (    2,162 rd   +    34,105 wr)\n==13372== D1  miss rate:        5.1% (      7.9%     +       2.0%  )\n==13372== LLd miss rate:        0.7% (      0.1%     +       1.3%  )\n==13372==\n==13372== LL refs:          275,672  (  221,916 rd   +    53,756 wr)\n==13372== LL misses:         38,425  (    4,320 rd   +    34,105 wr)\n==13372== LL miss rate:         0.1% (      0.0%     +       1.3%  )\n==13372==\n==13372== Branches:       3,008,198  (3,006,105 cond +     2,093 ind)\n==13372== Mispredicts:      315,772  (  315,198 cond +       574 ind)\n==13372== Mispred rate:        10.5% (     10.5%     +      27.4%   )\n```", "```rs\n==13372== I   refs:      25,733,614\n==13372== I1  misses:         2,454\n==13372== LLi misses:         2,158\n==13372== I1  miss rate:       0.01%\n==13372== LLi miss rate:       0.01%\n```", "```rs\n==13372== D   refs:       5,400,581  (2,774,345 rd   + 2,626,236 wr)\n==13372== D1  misses:       273,218  (  219,462 rd   +    53,756 wr)\n==13372== LLd misses:        36,267  (    2,162 rd   +    34,105 wr)\n==13372== D1  miss rate:        5.1% (      7.9%     +       2.0%  )\n==13372== LLd miss rate:        0.7% (      0.1%     +       1.3%  )\n```", "```rs\n==13372== LL refs:          275,672  (  221,916 rd   +    53,756 wr)\n==13372== LL misses:         38,425  (    4,320 rd   +    34,105 wr)\n==13372== LL miss rate:         0.1% (      0.0%     +       1.3%  )\n```", "```rs\n==13372== Branches:       3,008,198  (3,006,105 cond +     2,093 ind)\n==13372== Mispredicts:      315,772  (  315,198 cond +       574 ind)\n==13372== Mispred rate:        10.5% (     10.5%     +      27.4%   )\n```", "```rs\nnaive_hashmap > valgrind --tool=cachegrind --branch-sim=yes target/release/naive\n==13439== Cachegrind, a cache and branch-prediction profiler\n==13439== Copyright (C) 2002-2015, and GNU GPL'd, by Nicholas Nethercote et al.\n==13439== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info\n==13439== Command: target/release/naive\n==13439==\n--13439-- warning: L3 cache found, using its data for the LL simulation.\nINSERT\n  empty:   35217\n  present: 15071\nLOOKUP\n  fail:    34551\n  success: 15161\n==13439==\n==13439== I   refs:      15,385,395,657\n==13439== I1  misses:             2,376\n==13439== LLi misses:             2,157\n==13439== I1  miss rate:           0.00%\n==13439== LLi miss rate:           0.00%\n==13439==\n==13439== D   refs:       1,609,901,359  (1,453,944,896 rd   + 155,956,463 wr)\n==13439== D1  misses:       398,465,518  (  398,334,276 rd   +     131,242 wr)\n==13439== LLd misses:            12,647  (        2,153 rd   +      10,494 wr)\n==13439== D1  miss rate:           24.8% (         27.4%     +         0.1%  )\n==13439== LLd miss rate:            0.0% (          0.0%     +         0.0%  )\n==13439==\n==13439== LL refs:          398,467,894  (  398,336,652 rd   +     131,242 wr)\n==13439== LL misses:             14,804  (        4,310 rd   +      10,494 wr)\n==13439== LL miss rate:             0.0% (          0.0%     +         0.0%  )\n==13439==\n==13439== Branches:       4,430,578,248  (4,430,540,970 cond +      37,278 ind)\n==13439== Mispredicts:          193,192  (      192,618 cond +         574 ind)\n==13439== Mispred rate:             0.0% (          0.0%     +         1.5%   )\n```", "```rs\nnaive_hashmap > perf stat --event task-clock,context-switches,page-faults,cycles,instructions,branches,branch-misses,cache-references,cache-misses target/release/standard > /dev/null\n\n Performance counter stats for 'target/release/standard':\n\n      6.923765      task-clock (msec)         #    0.948 CPUs utilized\n             0      context-switches          #    0.000 K/sec\n           633      page-faults               #    0.091 M/sec\n    19,703,427      cycles                    #    2.846 GHz\n    26,234,708      instructions              #    1.33  insn per cycle\n     2,802,334      branches                  #  404.741 M/sec\n      290,475      branch-misses             #   10.37% of all branches\n       635,526      cache-references          #   91.789 M/sec\n     67,304      cache-misses              # 10.590 % of all cache refs\n\n       0.007301775 seconds time elapsed\n```", "```rs\nnaive_hashmap > perf stat --event task-clock,context-switches,page-faults,cycles,instructions,branches,branch-misses,cache-references,cache-misses target/release/naive > /dev/null\n\n Performance counter stats for 'target/release/naive':\n\n    1323.724713      task-clock (msec)         #    1.000 CPUs utilized\n              1      context-switches          #    0.001 K/sec\n            254      page-faults               #    0.192 K/sec\n  3,953,955,131      cycles                    #    2.987 GHz 15,390,499,356      instructions               #  3.89  insn per cycle    4,428,637,974      branches                    # 3345.588 M/sec\n      204,132      branch-misses               #  0.00% of all branches\n    455,719,875      cache-references          #  344.271 M/sec\n   21,311      cache-misses                 # 0.005 % of all cache refs\n\n       1.324163884 seconds time elapsed\n```", "```rs\npub struct HashMapU8<V>\nwhere\n    V: ::std::fmt::Debug,\n{\n    data: [Option<V>; 256],\n}\n\nimpl<V> HashMapU8<V>\nwhere\n    V: ::std::fmt::Debug,\n{\n    pub fn new() -> HashMapU8<V> {\n        let data = unsafe {\n            let mut data: [Option<V>; 256] = mem::uninitialized();\n            for element in data.iter_mut() {\n                ptr::write(element, None)\n            }\n            data\n        };\n        HashMapU8 { data: data }\n    }\n\n    pub fn insert(&mut self, k: u8, v: V) -> Option<V> {\n        mem::replace(&mut self.data[(k as usize)], Some(v))\n    }\n\n    pub fn get(&mut self, k: &u8) -> Option<&V> {\n        let val = unsafe { self.data.get_unchecked((*k as usize)) };\n        val.as_ref()\n    }\n}\n```", "```rs\nextern crate naive_hashmap;\n\nuse std::io;\nuse std::io::prelude::*;\nuse std::str::FromStr;\n\nfn main() {\n    let mut hash_map = naive_hashmap::HashMapU8::new();\n\n    let n = io::stdin();\n    for line in n.lock().lines() {\n        if let Ok(line) = line {\n            let mut cmd = line.split(\" \");\n            match cmd.next() {\n                Some(\"LOOKUP\") => {\n                    if let Some(key) = cmd.next() {\n                        if let Ok(key) = u8::from_str(key) {\n                            let _ = hash_map.get(&key);\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        continue;\n                    }\n                }\n                Some(\"INSERT\") => {\n                    if let Some(key) = cmd.next() {\n                        if let Ok(key) = u8::from_str(key) {\n                            if let Some(val) = cmd.next() {\n                          let _ = hash_map.insert(key, \n                           val.to_string());\n                            } else {\n                                continue;\n                            }\n                        }\n                    } else {\n                        continue;\n                    }\n                }\n                _ => continue,\n            }\n        } else {\n            break;\n        }\n    }\n}\n```", "```rs\n> cargo afl build --release\n> cargo afl fuzz -i resources/in/ -o resources/out/ target/release/specialized_interpreter\n```", "```rs\nHashMap/100000/speciali time:   [662.01 us 665.28 us 668.44 us]\nHashMap/100000/standard time:   [2.3471 ms 2.3521 ms 2.3583 ms]\n\nHashMap/10000/specializ time:   [64.294 us 64.440 us 64.576 us]\nHashMap/10000/standard  time:   [253.14 us 253.31 us 253.49 us]\n```", "```rs\nnaive_hashmap > valgrind --tool=cachegrind --branch-sim=yes target/release/specialized\n==24235== Cachegrind, a cache and branch-prediction profiler\n==24235== Copyright (C) 2002-2015, and GNU GPL'd, by Nicholas Nethercote et al.\n==24235== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info\n==24235== Command: target/release/specialized\n==24235==\n--24235-- warning: L3 cache found, using its data for the LL simulation.\nINSERT\n  empty:   256\n  present: 50032\nLOOKUP\n  fail:    199\n  success: 49513\n==24235==\n==24235== I   refs:      5,200,051\n==24235== I1  misses:        2,248\n==24235== LLi misses:        2,068\n==24235== I1  miss rate:      0.04%\n==24235== LLi miss rate:      0.04%\n==24235==\n==24235== D   refs:        443,562  (233,633 rd   + 209,929 wr)\n==24235== D1  misses:        4,736  (  3,249 rd   +   1,487 wr)\n==24235== LLd misses:        3,512  (  2,112 rd   +   1,400 wr)\n==24235== D1  miss rate:       1.1% (    1.4%     +     0.7%  )\n==24235== LLd miss rate:       0.8% (    0.9%     +     0.7%  )\n==24235==\n==24235== LL refs:           6,984  (  5,497 rd   +   1,487 wr)\n==24235== LL misses:         5,580  (  4,180 rd   +   1,400 wr)\n==24235== LL miss rate:        0.1% (    0.1%     +     0.7%  )\n==24235==\n==24235== Branches:        393,599  (391,453 cond +   2,146 ind)\n==24235== Mispredicts:      57,380  ( 56,657 cond +     723 ind)\n==24235== Mispred rate:       14.6% (   14.5%     +    33.7%   )\n```", "```rs\nnaive_hashmap > perf stat --event task-clock,context-switches,page-faults,cycles,instructions,branches,branch-misses,cache-references,cache-misses target/release/specialized > /dev/null\n\n Performance counter stats for 'target/release/specialized':\n\n     1.433884      task-clock (msec)         #    0.788 CPUs utilized\n            0      context-switches          #    0.000 K/sec\n          104      page-faults               #    0.073 M/sec\n    4,138,436      cycles                    #    2.886 GHz\n    6,141,529      instructions              #    1.48  insn per cycle\n      749,155      branches                  #  522.466 M/sec\n       59,914      branch-misses             #    8.00% of all branches\n       74,760      cache-references          #   52.138 M/sec\n\n       0.001818537 seconds time elapsed\n```"]