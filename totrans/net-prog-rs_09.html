<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Appendix</h1>
                
            
            
                
<p class="calibre2">Rust is an open source project with a large number of contributors from all over the world. As with any such project, there are often multiple solutions to the same problems. The crate ecosystem makes this easier, since people can publish multiple crates that propose multiple ways of solving the same set of problems. This approach fosters a healthy sense of competition in true open source spirit. In this book, we have covered a number of different topics in the ecosystem. This chapter will be an addendum to those topics. We will discuss:</p>
<ul class="calibre7">
<li class="calibre8">Coroutine and generator-based approaches to concurrency</li>
<li class="calibre8">The async/await abstraction</li>
<li class="calibre8">Data parallelism</li>
<li class="calibre8">Parsing using Pest</li>
<li class="calibre8">Miscellaneous utilities in the ecosystem</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introduction to coroutines and generators</h1>
                
            
            
                
<p class="calibre2">We looked into the Tokio ecosystem earlier. We saw how it is very common to chain futures in Tokio, yielding a larger task that can then be scheduled as necessary. In practice, the following often looks like the pseudocode:</p>
<pre class="calibre17">fn download_parse(url: &amp;str) {<br class="title-page-name"/>    let task = download(url)<br class="title-page-name"/>               .and_then(|data| parse_html(data))<br class="title-page-name"/>               .and_then(|link| process_link(link))<br class="title-page-name"/>               .map_err(|e| OurErr(e));<br class="title-page-name"/>    Core.run(task);<br class="title-page-name"/>}</pre>
<p class="calibre2">Here, our function takes in a URL and recursively downloads raw HTML. It then parses and collects links in the document. Our task is run in an event loop. Arguably, the control flow here is harder to follow, due to all the callbacks and how they interact. This becomes more complex with larger tasks and more conditional branches.</p>
<p class="calibre2">The idea of coroutines helps us to better reason about non-linearity in these examples. A coroutine (also known as a <strong class="calibre1">generator</strong>) is a generalization of a function that can suspend or resume itself at will, yielding control to another entity. Since they do not require preemption by a supersizing entity, they are often easier to work with. Note that we always assume a cooperative model where a coroutine yields when it is waiting for  a computation to finish or I/O, and we ignore cases where a coroutine might be malicious in some other way. When a coroutine starts execution again, it resumes from the point where it left off, providing a form of continuity. They generally have multiple entry and exit points.</p>
<p class="calibre2">Having set that up, a subroutine (function) becomes approximately a special case of coroutine, which has exactly one entry and exit point, and cannot be externally suspended. Computer science literature also distinguishes between generators and coroutines, arguing that the former cannot control where execution continues after they are suspended, while the later can. However, in our current context, we will use generator and coroutines interchangeably.</p>
<p class="calibre2">Coroutines can be of two broad types: stackless and stackful. Stackless coroutines do not maintain a stack when they are suspended. As a result, they cannot resume at arbitrary locations. Stackful coroutines, on the other hand, always maintain a small stack. This enables them to suspend and resume from any arbitrary point in execution. They always preserve the complete state when they suspend. Thus, from a caller's point of view, they behave like any regular function that can run independent of current execution. In practice, stackful coroutines are generally more resource heavy but easier to work with (for the caller). Note that all coroutines are resource light compared to threads and processes.</p>
<p class="calibre2">In the recent past, Rust has been experimenting with a generator implementation in the standard library. These are located in <kbd class="calibre11">std::ops</kbd>, and like all new features, this is behind multiple feature gates: <kbd class="calibre11">generators</kbd> and <kbd class="calibre11">generator_trait</kbd>. There are a few parts to this implementation. Firstly, there is a new yield keyword for yielding from a generator. Generators are defined by overloading the closure syntax. Secondly, there are a few items defined as follows:</p>
<pre class="calibre17">pub trait Generator {<br class="title-page-name"/>    type Yield;<br class="title-page-name"/>    type Return;<br class="title-page-name"/>    fn resume(&amp;mut self) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;; <br class="title-page-name"/>}</pre>
<p>Since these are generators (not coroutines), they can have only one <kbd class="calibre31">yield</kbd> and only one <kbd class="calibre31">return</kbd>.</p>
<p class="calibre2">The <kbd class="calibre11">Generator</kbd> trait has two types: one for the <kbd class="calibre11">yield</kbd> case and one for the <kbd class="calibre11">return</kbd> case. The <kbd class="calibre11">resume</kbd> function resumes execution from the last point. The return value for resume is <kbd class="calibre11">GeneratorState</kbd>, which is an enum, and looks like this:</p>
<pre class="calibre17">pub enum GeneratorState&lt;Y, R&gt; {<br class="title-page-name"/>    Yielded(Y),<br class="title-page-name"/>    Complete(R)<br class="title-page-name"/>}</pre>
<p class="calibre2">There are two variants; <kbd class="calibre11">Yielded</kbd> represents the variant for the <kbd class="calibre11">yield</kbd> statement, and <kbd class="calibre11">Complete</kbd> represents the variant for the <kbd class="calibre11">return</kbd> statement. Also, the <kbd class="calibre11">Yielded</kbd> variant represents that the generator can continue again from the last yield statement. <kbd class="calibre11">Complete</kbd> represents that the generator has finished executing.</p>
<p class="calibre2">Let's look at an example of using this to generate the Collatz sequence:</p>
<pre class="calibre17">// appendix/collatz-generator/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(generators, generator_trait)]<br class="title-page-name"/><br class="title-page-name"/>use std::ops::{Generator, GeneratorState};<br class="title-page-name"/>use std::env;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let input = env::args()<br class="title-page-name"/>        .nth(1)<br class="title-page-name"/>        .expect("Please provide only one argument")<br class="title-page-name"/>        .parse::&lt;u64&gt;()<br class="title-page-name"/>        .expect("Could not convert input to integer");<br class="title-page-name"/><br class="title-page-name"/>    // The given expression will evaluate to our generator<br class="title-page-name"/>    let mut generator = || {<br class="title-page-name"/>        let end = 1u64;<br class="title-page-name"/>        let mut current: u64 = input;<br class="title-page-name"/>        while current != end {<br class="title-page-name"/>            yield current;<br class="title-page-name"/>            if current % 2 == 0 {<br class="title-page-name"/>                current /= 2;<br class="title-page-name"/>            } else {<br class="title-page-name"/>                current = 3 * current + 1;<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>        return end;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    loop {<br class="title-page-name"/>        // The resume call can have two results. If we have an<br class="title-page-name"/>        // yielded value, we print it. If we have a completed<br class="title-page-name"/>        // value, we print it and break from the loop (this is<br class="title-page-name"/>        // the return case)<br class="title-page-name"/>        match generator.resume() {<br class="title-page-name"/>            GeneratorState::Yielded(el) =&gt; println!("{}", el),<br class="title-page-name"/>            GeneratorState::Complete(el) =&gt; {<br class="title-page-name"/>                println!("{}", el);<br class="title-page-name"/>                break;<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Since these are in the standard library, we do not need external dependencies. We start with the feature gates and imports. In our main function, we define a generator using the closure syntax. Notice how it captures the variable called <kbd class="calibre11">input</kbd> from the enclosing scope. Instead of returning the current position at the sequence, we <kbd class="calibre11">yield</kbd> it. And when we are done, we <kbd class="calibre11">return</kbd> from the generator. Now we need to call <kbd class="calibre11">resume</kbd> on the generator to actually run it. We do that in an infinite loop, since we do not know in advance how many times we will need to iterate. In that, we <kbd class="calibre11">match</kbd> on the <kbd class="calibre11">resume</kbd> call; in both arms, we print out the value that we have. Additionally, in the <kbd class="calibre11">Complete</kbd> arm, we need to <kbd class="calibre11">break</kbd> away from the loop.</p>
<p class="calibre2">Note that we did not use the implicit return syntax here; rather, we did an explicit <kbd class="calibre11">return end;</kbd>. This was not necessary, but this makes the code a little bit easier to read in this case.</p>
<p class="calibre2">This is what it produces:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run 10</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/collatz-generator 10`<br class="title-page-name"/>10<br class="title-page-name"/>5<br class="title-page-name"/>16<br class="title-page-name"/>8<br class="title-page-name"/>4<br class="title-page-name"/>2<br class="title-page-name"/>1</pre>
<p>Generators are only available in nightly Rust, for now. Their syntax is expected to change over time, possibly by a huge amount.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How May handles coroutines</h1>
                
            
            
                
<p class="calibre2">The Rust ecosystem has a number of coroutine implementations, while the core team is working on in-language implementations. Of these, one of the widely used is called <em class="calibre16">May</em>, which is a standalone stackful coroutine library based on generators. May strives to be user-friendly enough so that a function can be asynchronously invoked using a simple macro that takes in the function. In feature parity with the Go programming language, this macro is called <kbd class="calibre11">go!</kbd>. Let's look at a small example of using May.</p>
<p class="calibre2">We will use our good ol' friend, Collatz sequence, for this example; this will show us multiple ways of achieving the same goal. Let's start with setting up our project using Cargo:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "collatz-may"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>may = "0.2.0"<br class="title-page-name"/>generator = "0.6"</pre>
<p class="calibre2">The following is the main file. There are two examples here; one uses the generator crate to yield numbers in the collatz sequence, acting as a coroutine. The other one is a regular function, which is being run as a coroutine using the <kbd class="calibre11">go!</kbd> macro:</p>
<pre class="calibre17">// appendix/collatz-may/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(conservative_impl_trait)]<br class="title-page-name"/><br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate generator;<br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate may;<br class="title-page-name"/><br class="title-page-name"/>use std::env;<br class="title-page-name"/>use generator::Gn;<br class="title-page-name"/><br class="title-page-name"/>// Returns a generator as an iterator<br class="title-page-name"/>fn collatz_generator(start: u64) -&gt; impl Iterator&lt;Item = u64&gt; {<br class="title-page-name"/>    Gn::new_scoped(move |mut s| {<br class="title-page-name"/>        let end = 1u64;<br class="title-page-name"/>        let mut current: u64 = start;<br class="title-page-name"/>        while current != end {<br class="title-page-name"/>            s.yield_(current);<br class="title-page-name"/>            if current % 2 == 0 {<br class="title-page-name"/>                current /= 2;<br class="title-page-name"/>            } else {<br class="title-page-name"/>                current = 3 * current + 1;<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>        s.yield_(end);<br class="title-page-name"/>        done!();<br class="title-page-name"/>    })<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// A regular function returning result in a vector<br class="title-page-name"/>fn collatz(start: u64) -&gt; Vec&lt;u64&gt; {<br class="title-page-name"/>    let end = 1u64;<br class="title-page-name"/>    let mut current: u64 = start;<br class="title-page-name"/>    let mut result = Vec::new();<br class="title-page-name"/>    while current != end {<br class="title-page-name"/>        result.push(current);<br class="title-page-name"/>        if current % 2 == 0 {<br class="title-page-name"/>            current /= 2;<br class="title-page-name"/>        } else {<br class="title-page-name"/>            current = 3 * current + 1;<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    result.push(end);<br class="title-page-name"/>    result<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let input = env::args()<br class="title-page-name"/>        .nth(1)<br class="title-page-name"/>        .expect("Please provide only one argument")<br class="title-page-name"/>        .parse::&lt;u64&gt;()<br class="title-page-name"/>        .expect("Could not convert input to integer");<br class="title-page-name"/><br class="title-page-name"/>    // Using the go! macro<br class="title-page-name"/>    go!(move || {<br class="title-page-name"/>        println!("{:?}", collatz(input));<br class="title-page-name"/>    }).join()<br class="title-page-name"/>        .unwrap();<br class="title-page-name"/><br class="title-page-name"/>    // results is a generator expression that we can<br class="title-page-name"/>    // iterate over<br class="title-page-name"/>    let results = collatz_generator(input);<br class="title-page-name"/>    for result in results {<br class="title-page-name"/>        println!("{}", result);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Let's start with the <kbd class="calibre11">collatz_generator</kbd> function that takes in an input to start from and returns an iterator of type <kbd class="calibre11">u64</kbd>. To be able to specify this, we will need to activate the <kbd class="calibre11">conservative_impl_trait</kbd> feature. We create a scoped generator using <kbd class="calibre11">Gn::new_scoped</kbd> from the generator crate. It takes in a closure that actually does the computation. We yield the current value using the <kbd class="calibre11">yield_</kbd> function and signal the end of the computation using the <kbd class="calibre11">done!</kbd> macro.</p>
<p class="calibre2">Our second example is a regular function that returns a vector of numbers in the Collatz sequence. It collects intermediate results in a vector and finally returns it once the sequence reaches <kbd class="calibre11">1</kbd>. In our main function, we parse and sanitize input as we always do. We then call our non-generator function asynchronously in a coroutine using the <kbd class="calibre11">go!</kbd> macro. However, <kbd class="calibre11">collatz_generator</kbd> returns an iterator, which we can iterate over in a loop while printing out the numbers.</p>
<p class="calibre2">As one would expect, this is how the output looks:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run 10</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/collatz-may 10`<br class="title-page-name"/>[10, 5, 16, 8, 4, 2, 1]<br class="title-page-name"/>10<br class="title-page-name"/>5<br class="title-page-name"/>16<br class="title-page-name"/>8<br class="title-page-name"/>4<br class="title-page-name"/>2<br class="title-page-name"/>1</pre>
<p class="calibre2">May also includes an asynchronous network stack implementation (like Tokio), and over the last few months, it has gathered a mini ecosystem of a few dependent crates. Apart from the generator and coroutine implementations, there is an HTTP library based on those, an RPC library, and a crate that supports actor-based programming. Let's look at an example where we write our hyper HTTP using May. Here is what a Cargo config looks like:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "may-http"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>may_minihttp = { git = "https://github.com/Xudong-Huang/may_minihttp.git" }<br class="title-page-name"/>may = "0.2.0"<br class="title-page-name"/>num_cpus = "1.7.0"</pre>
<p class="calibre2">At the time of writing, <kbd class="calibre11">may_minihttp</kbd> is not published in <kbd class="calibre11">crates.io</kbd> yet, so we will need to use the repository to build. Here is the main file:</p>
<pre class="calibre17">// appendix/may-http/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate may;<br class="title-page-name"/>extern crate may_minihttp;<br class="title-page-name"/>extern crate num_cpus;<br class="title-page-name"/><br class="title-page-name"/>use std::io;<br class="title-page-name"/>use may_minihttp::{HttpServer, HttpService, Request, Response};<br class="title-page-name"/>use std::{thread, time};<br class="title-page-name"/><br class="title-page-name"/>fn heavy_work() -&gt; String {<br class="title-page-name"/>    let duration = time::Duration::from_millis(100);<br class="title-page-name"/>    thread::sleep(duration);<br class="title-page-name"/>    "done".to_string()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[derive(Clone, Copy)]<br class="title-page-name"/>struct Echo;<br class="title-page-name"/><br class="title-page-name"/>// Implementation of HttpService for our service struct Echo<br class="title-page-name"/>// This implementation defines how content should be served<br class="title-page-name"/>impl HttpService for Echo {<br class="title-page-name"/>    fn call(&amp;self, req: Request) -&gt; io::Result&lt;Response&gt; {<br class="title-page-name"/>        let mut resp = Response::new();<br class="title-page-name"/>        match (req.method(), req.path()) {<br class="title-page-name"/>            ("GET", "/data") =&gt; {<br class="title-page-name"/>                let b = heavy_work();<br class="title-page-name"/>                resp.body(&amp;b).status_code(200, "OK");<br class="title-page-name"/>            }<br class="title-page-name"/>            (&amp;_, _) =&gt; {<br class="title-page-name"/>                resp.status_code(404, "Not found");<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>        Ok(resp)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    // Set the number of IO workers to the number of cores<br class="title-page-name"/>    may::config().set_io_workers(num_cpus::get());<br class="title-page-name"/>    let server = HttpServer(Echo).start("0.0.0.0:3000").unwrap();<br class="title-page-name"/>    server.join().unwrap();<br class="title-page-name"/>}</pre>
<p class="calibre2">This time, our code is much shorter than with Hyper. This is because May nicely abstracts away a lot of things, while letting us have a similar set of functionalities. Like the <kbd class="calibre11">Service</kbd> trait earlier, the <kbd class="calibre11">HttpService</kbd> trait is what defines a server. Functionality is defined by the <kbd class="calibre11">call</kbd> function. There are some minor differences in function calls and how responses are constructed. Another advantage here is that this does not expose futures and works with regular <kbd class="calibre11">Result</kbd>. Arguably, this model is easier to understand and follow. In the <kbd class="calibre11">main</kbd> function, we set the number of I/O workers to the number of cores we have. We then start the server on port <kbd class="calibre11">3000</kbd> and wait for it to exit. According to some rough benchmarks on the GitHub page, the <kbd class="calibre11">may</kbd> based HTTP server is slightly faster than a Tokio implementation.</p>
<p class="calibre2">Here is what we see upon running the server. In this particular run, it got two <kbd class="calibre11">GET</kbd> requests:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling may-http v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/appendix/may-http)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 1.57 secs<br class="title-page-name"/>     Running `target/debug/may-http`<br class="title-page-name"/>Incoming request &lt;HTTP Request GET /data&gt;<br class="title-page-name"/>Incoming request &lt;HTTP Request GET /data&gt;<br class="title-page-name"/>^C</pre>
<p class="calibre2">Our client side is just <kbd class="calibre11">curl</kbd>, and we see <kbd class="calibre11">done</kbd> being printed for each request. Note that since our server and the client are on the same physical box, we can use <kbd class="calibre11">127.0.0.1</kbd> as the server's address. If that is not the case, the actual address should be used:</p>
<pre class="calibre17"><strong class="calibre1">$ curl http://127.0.0.1:3000/data</strong><br class="title-page-name"/>done</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Awaiting the future</h1>
                
            
            
                
<p class="calibre2">In the last section, we saw how tasks composed of multiple futures are often difficult to write and debug. One attempt at remedying this is using a crate that wraps futures and associated error handling, yielding a more linear flow of code. This crate is called <em class="calibre16">futures-await</em> and is under active development.</p>
<p class="calibre2">This crate provides two primary mechanisms of dealing with futures:</p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">#[async]</kbd> attribute that can be applied to functions, marking them as asynchronous. These functions must return the <kbd class="calibre11">Result</kbd> of their computation as a future.</li>
<li class="calibre8">The <kbd class="calibre11">await!</kbd> macro that can be used with async functions to consume the future, returning a <kbd class="calibre11">Result</kbd>.</li>
</ul>
<p class="calibre2">Given these constructions, our earlier example download will look like this:</p>
<pre class="calibre17">#[async]<br class="title-page-name"/>fn download(url: &amp;str) -&gt; io::Result&lt;Data&gt; {<br class="title-page-name"/>    ...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[async]<br class="title-page-name"/>fn parse_html(data: &amp;Data) -&gt; io::Result&lt;Links&gt; {<br class="title-page-name"/>    ...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[async]<br class="title-page-name"/>fn process_links(links: &amp;Links) -&gt; io::Result&lt;bool&gt; {<br class="title-page-name"/>    ...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[async]<br class="title-page-name"/>fn download_parse(url: &amp;str) -&gt; io::Result&lt;bool&gt; {<br class="title-page-name"/>    let data = await!(download(url));<br class="title-page-name"/>    let links = await!(parse_html(data));<br class="title-page-name"/>    let result = await!(process_links(links));<br class="title-page-name"/>    Ok(result)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let task = download_parse("foo.bar");<br class="title-page-name"/>    Core.run(task).unwrap();<br class="title-page-name"/>}</pre>
<p class="calibre2">This is arguably easier to read than the example with futures. Internally, the compiler translates this to code which looks like our earlier example. Additionally, since each of the steps returns a <kbd class="calibre11">Result</kbd>, we can use the <kbd class="calibre11">?</kbd> operator to nicely bubble up errors. The final task can then be run in an event loop, like always.</p>
<p class="calibre2">Let's look at a more concrete example, rewriting our hyper server project using this crate. In this case, our Cargo setup looks like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "hyper-async-await"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>hyper = "0.11.7"<br class="title-page-name"/>futures = "0.1.17"<br class="title-page-name"/>net2 = "0.2.31"<br class="title-page-name"/>tokio-core = "0.1.10"<br class="title-page-name"/>num_cpus = "1.0"<br class="title-page-name"/>futures-await = "0.1.0"</pre>
<p class="calibre2">Here is our code, as shown in the following code snippet. Notice that we have not used types from the futures crate like last time. Instead, we have used types re-exported from futures-await, which are wrapped versions of those types:</p>
<pre class="calibre17">// appendix/hyper-async-await/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(proc_macro, conservative_impl_trait, generators)]<br class="title-page-name"/><br class="title-page-name"/>extern crate futures_await as futures;<br class="title-page-name"/>extern crate hyper;<br class="title-page-name"/>extern crate net2;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/>extern crate num_cpus;<br class="title-page-name"/><br class="title-page-name"/>use futures::prelude::*;<br class="title-page-name"/>use net2::unix::UnixTcpBuilderExt;<br class="title-page-name"/>use tokio_core::reactor::Core;<br class="title-page-name"/>use tokio_core::net::TcpListener;<br class="title-page-name"/>use std::{thread, time};<br class="title-page-name"/>use std::net::SocketAddr;<br class="title-page-name"/>use std::sync::Arc;<br class="title-page-name"/>use hyper::{Get, StatusCode};<br class="title-page-name"/>use hyper::header::ContentLength;<br class="title-page-name"/>use hyper::server::{Http, Service, Request, Response};<br class="title-page-name"/>use futures::future::FutureResult;<br class="title-page-name"/>use std::io;<br class="title-page-name"/><br class="title-page-name"/>// Our blocking function that waits for a random<br class="title-page-name"/>// amount of time and then returns a fixed string<br class="title-page-name"/>fn heavy_work() -&gt; String {<br class="title-page-name"/>    let duration = time::Duration::from_millis(100);<br class="title-page-name"/>    thread::sleep(duration);<br class="title-page-name"/>    "done".to_string()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[derive(Clone, Copy)]<br class="title-page-name"/>struct Echo;<br class="title-page-name"/><br class="title-page-name"/>// Service implementation for the Echo struct<br class="title-page-name"/>impl Service for Echo {<br class="title-page-name"/>    type Request = Request;<br class="title-page-name"/>    type Response = Response;<br class="title-page-name"/>    type Error = hyper::Error;<br class="title-page-name"/>    type Future = FutureResult&lt;Response, hyper::Error&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn call(&amp;self, req: Request) -&gt; Self::Future {<br class="title-page-name"/>        futures::future::ok(match (req.method(), req.path()) {<br class="title-page-name"/>            (&amp;Get, "/data") =&gt; {<br class="title-page-name"/>                let b = heavy_work().into_bytes();<br class="title-page-name"/>                Response::new()<br class="title-page-name"/>                    .with_header(ContentLength(b.len() as u64))<br class="title-page-name"/>                    .with_body(b)<br class="title-page-name"/>            }<br class="title-page-name"/>            _ =&gt; Response::new().with_status(StatusCode::NotFound),<br class="title-page-name"/>        })<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Sets up everything and runs the event loop<br class="title-page-name"/>fn serve(addr: &amp;SocketAddr, protocol: &amp;Http) {<br class="title-page-name"/>    let mut core = Core::new().unwrap();<br class="title-page-name"/>    let handle = core.handle();<br class="title-page-name"/>    let listener = net2::TcpBuilder::new_v4()<br class="title-page-name"/>        .unwrap()<br class="title-page-name"/>        .reuse_port(true)<br class="title-page-name"/>        .unwrap()<br class="title-page-name"/>        .bind(addr)<br class="title-page-name"/>        .unwrap()<br class="title-page-name"/>        .listen(128)<br class="title-page-name"/>        .unwrap();<br class="title-page-name"/>    let listener = TcpListener::from_listener<br class="title-page-name"/>    (listener, addr, &amp;handle).unwrap();<br class="title-page-name"/>    let server = async_block! {<br class="title-page-name"/>        #[async]<br class="title-page-name"/>        for (socket, addr) in listener.incoming() {<br class="title-page-name"/>            protocol.bind_connection(&amp;handle, socket, addr, Echo);<br class="title-page-name"/>        }<br class="title-page-name"/>        Ok::&lt;(), io::Error&gt;(())<br class="title-page-name"/>    };<br class="title-page-name"/>    core.run(server).unwrap();<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn start_server(num: usize, addr: &amp;str) {<br class="title-page-name"/>    let addr = addr.parse().unwrap();<br class="title-page-name"/><br class="title-page-name"/>    let protocol = Arc::new(Http::new());<br class="title-page-name"/>    {<br class="title-page-name"/>        for _ in 0..num - 1 {<br class="title-page-name"/>            let protocol = Arc::clone(&amp;protocol);<br class="title-page-name"/>            thread::spawn(move || serve(&amp;addr, &amp;protocol));<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    serve(&amp;addr, &amp;protocol);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    start_server(num_cpus::get(), "0.0.0.0:3000");<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre11">async_block!</kbd> macro takes in a closure and converts that to an <kbd class="calibre11">async</kbd> function. Thus, our server here is an <kbd class="calibre11">async</kbd> function. We also use an asynchronous <kbd class="calibre11">for</kbd> loop (a <kbd class="calibre11">for</kbd> loop marked by <kbd class="calibre11">#[async]</kbd>) to asynchronously iterate over the stream of connections. The rest of the code is exactly the same as last time. Running the server is simple; we will use Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/hyper-server-faster`</pre>
<p class="calibre2">On the client side, we can use curl:</p>
<pre class="calibre17"><strong class="calibre1">$ curl http://127.0.0.1:3000/data</strong><br class="title-page-name"/>done<strong class="calibre1">$ curl http://127.0.0.1:3000/data</strong><br class="title-page-name"/>done<strong class="calibre1">$</strong></pre>
<p>At the time of writing, running this example will produce a warning about using <em class="calibre27">bind_connection</em>. Since there is no clear deprecation timeline for this API, we will ignore the warning for now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Data parallelism</h1>
                
            
            
                
<p class="calibre2">Data parallelism is a way of speeding up computation by making data a central entity. This is in contrast to the coroutine and thread-based parallelism that we have seen so far. In those cases, we first determine tasks that can be run independently. We then distribute available data to those tasks as needed. This approach is often called <strong class="calibre1">task parallelism</strong>. Our topic of discussion in this section is data parallelism. In this case, we need to figure out what parts of the input data can be used independently; then multiple tasks can be assigned to individual parts. This also conforms to the divide and conquer approach, one strong example being <kbd class="calibre11">mergesort</kbd>.</p>
<p class="calibre2">The Rust ecosystem has a library called <strong class="calibre1">Rayon</strong> that provides simple APIs for writing data parallel code. Let's look at a simple example of using Rayon for a binary search on a given slice. We start with setting up our project using <kbd class="calibre11">cargo</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin rayon-search</strong></pre>
<p class="calibre2">Let's look at the Cargo configuration file:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "rayon-search"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>rayon = "0.9.0"</pre>
<p class="calibre2">In our code, we have two implementations of the binary search function, both being recursive. The naive implementation is called <kbd class="calibre11">binary_search_recursive</kbd> and does not do any data parallelism. The other version, called <kbd class="calibre11">binary_search_rayon</kbd>, computes the two cases in parallel. Both functions take in a slice of type <kbd class="calibre11">T</kbd> that implements a number of traits. They also take an element of the same type. The functions will look for the given element in the slice and return <kbd class="calibre11">true</kbd> if it exists, and <kbd class="calibre11">false</kbd> otherwise. Let's look at the code now:</p>
<pre class="calibre17">// appendix/rayon-search/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate rayon;<br class="title-page-name"/><br class="title-page-name"/>use std::fmt::Debug;<br class="title-page-name"/>use rayon::scope;<br class="title-page-name"/><br class="title-page-name"/>// Parallel binary search, searches the two halves in parallel<br class="title-page-name"/>fn binary_search_rayon&lt;T: Ord + Send + Copy + Sync + Debug&gt;(src: &amp;mut [T], el: T) -&gt; bool {<br class="title-page-name"/>    src.sort();<br class="title-page-name"/>    let mid = src.len() / 2;<br class="title-page-name"/>    let srcmid = src[mid];<br class="title-page-name"/>    if src.len() == 1 &amp;&amp; src[0] != el {<br class="title-page-name"/>        return false;<br class="title-page-name"/>    }<br class="title-page-name"/>    if el == srcmid {<br class="title-page-name"/>        true<br class="title-page-name"/>    } else {<br class="title-page-name"/>        let mut left_result = false;<br class="title-page-name"/>        let mut right_result = false;<br class="title-page-name"/>        let (left, right) = src.split_at_mut(mid);<br class="title-page-name"/>        scope(|s| if el &lt; srcmid {<br class="title-page-name"/>            s.spawn(|_| left_result = binary_search_rayon(left, el))<br class="title-page-name"/>        } else {<br class="title-page-name"/>            s.spawn(|_| right_result = binary_search_rayon(right, el))<br class="title-page-name"/>        });<br class="title-page-name"/>        left_result || right_result<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Non-parallel binary search, goes like this:<br class="title-page-name"/>// 1. Sort input<br class="title-page-name"/>// 2. Find middle point, return if middle point is target<br class="title-page-name"/>// 3. If not, recursively search left and right halves<br class="title-page-name"/>fn binary_search_recursive&lt;T: Ord + Send + Copy&gt;(src: &amp;mut [T], el: T) -&gt; bool {<br class="title-page-name"/>    src.sort();<br class="title-page-name"/>    let mid = src.len() / 2;<br class="title-page-name"/>    let srcmid = src[mid];<br class="title-page-name"/>    if src.len() == 1 &amp;&amp; src[0] != el {<br class="title-page-name"/>        return false;<br class="title-page-name"/>    }<br class="title-page-name"/>    if el == srcmid {<br class="title-page-name"/>        true<br class="title-page-name"/>    } else {<br class="title-page-name"/>        let (left, right) = src.split_at_mut(mid);<br class="title-page-name"/>        if el &lt; srcmid {<br class="title-page-name"/>            binary_search_recursive(left, el)<br class="title-page-name"/>        } else {<br class="title-page-name"/>            binary_search_recursive(right, el)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut v = vec![100, 12, 121, 1, 23, 35];<br class="title-page-name"/>    println!("{}", binary_search_recursive(&amp;mut v, 5));<br class="title-page-name"/>    println!("{}", binary_search_rayon(&amp;mut v, 5));<br class="title-page-name"/>    println!("{}", binary_search_rayon(&amp;mut v, 100));<br class="title-page-name"/>}</pre>
<p class="calibre2">In both cases, the first thing to do is to sort the input slice, since a binary search requires input to be sorted. <kbd class="calibre11">binary_search_recursive</kbd> is straightforward; we compute the middle point, and if the element there is the one we want, we return a <kbd class="calibre11">true</kbd>. We also include a case checking if there is only one element left in the slice and if that is the element we want. We return <kbd class="calibre11">true</kbd> or <kbd class="calibre11">false</kbd>, accordingly. This case forms the base case for our recursion. We can then check if our desired element is less than or greater than the current mid-point. We recursively search either side, based on that check.</p>
<p class="calibre2">The Rayon case is mostly the same, the only difference being how we recurse. We use a <kbd class="calibre11">scope</kbd> to spawn the two cases in parallel and collect their results. The scope takes in a closure and invokes that in reference to the named scope, <kbd class="calibre11">s</kbd>. The scope also ensures that each of the tasks is completed before it exits. We collect the results from each half in two variables, and finally, we return a logical OR of those, since we care about finding the element in either of the two halves. Here is how a sample run looks:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling rayon-search v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/appendix/rayon-search)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.88 secs<br class="title-page-name"/>     Running `target/debug/rayon-search`<br class="title-page-name"/>false<br class="title-page-name"/>false<br class="title-page-name"/>true</pre>
<p class="calibre2">Rayon also provides a parallel iterator, an iterator that has the same semantics as the one in the standard library, but where elements might be accessed in parallel. This construct is useful in situations where each unit of data can be processed completely independently, without any form of synchronization between each processing task. Let's look at an example of how to use these iterators, starting with the project setup using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin rayon-parallel</strong></pre>
<p class="calibre2">In this case, we will compare the performance of a regular iterator to that of a parallel iterator using Rayon. For that, we will need to use the <kbd class="calibre11">rustc-test</kbd> crate. Here is how the Cargo setup looks:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "rayon-parallel"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>rayon = "0.9.0"<br class="title-page-name"/>rustc-test = "0.3.0"</pre>
<p class="calibre2">Here is the code, as shown in the following code snippet. We have two functions doing the exact same thing. Both of them receive a vector of integers, they then iterate over that vector and filter out even integers. Finally, they return squares of odd integers:</p>
<pre class="calibre17">// appendix/rayon-parallel/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(test)]<br class="title-page-name"/><br class="title-page-name"/>extern crate rayon;<br class="title-page-name"/>extern crate test;<br class="title-page-name"/><br class="title-page-name"/>use rayon::prelude::*;<br class="title-page-name"/><br class="title-page-name"/>// This function uses a parallel iterator to<br class="title-page-name"/>// iterate over the input vector, filtering<br class="title-page-name"/>// elements that are even and then squares the remaining<br class="title-page-name"/>fn filter_parallel(src: Vec&lt;u64&gt;) -&gt; Vec&lt;u64&gt; {<br class="title-page-name"/>    src.par_iter().filter(|x| *x % 2 != 0)<br class="title-page-name"/>    .map(|x| x * x)<br class="title-page-name"/>    .collect()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// This function does exactly the same operation<br class="title-page-name"/>// but uses a regular, sequential iterator<br class="title-page-name"/>fn filter_sequential(src: Vec&lt;u64&gt;) -&gt; Vec&lt;u64&gt; {<br class="title-page-name"/>    src.iter().filter(|x| *x % 2 != 0)<br class="title-page-name"/>    .map(|x| x * x)<br class="title-page-name"/>    .collect()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let nums_one = (1..10).collect();<br class="title-page-name"/>    println!("{:?}", filter_sequential(nums_one));<br class="title-page-name"/><br class="title-page-name"/>    let nums_two = (1..10).collect();<br class="title-page-name"/>    println!("{:?}", filter_parallel(nums_two));<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[cfg(test)]<br class="title-page-name"/>mod tests {<br class="title-page-name"/>    use super::*;<br class="title-page-name"/>    use test::Bencher;<br class="title-page-name"/><br class="title-page-name"/>    #[bench]<br class="title-page-name"/>    fn bench_filter_sequential(b: &amp;mut Bencher) {<br class="title-page-name"/>        b.iter(|| filter_sequential((1..1000).collect::&lt;Vec&lt;u64&gt;&gt;()));<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    #[bench]<br class="title-page-name"/>    fn bench_filter_parallel(b: &amp;mut Bencher) {<br class="title-page-name"/>        b.iter(|| filter_parallel((1..1000).collect::&lt;Vec&lt;u64&gt;&gt;()));<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We start with importing everything from Rayon. In <kbd class="calibre11">filter_parallel</kbd>, we use <kbd class="calibre11">par_iter</kbd> to get a parallel iterator. <kbd class="calibre11">filter_sequential</kbd> is the same, the only difference being that it uses the <kbd class="calibre11">iter</kbd> function to get a regular iterator. In our main function, we create two sequences and pass those to our functions while printing the outputs. Here is what we should see:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling rayon-parallel v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/appendix/rayon-parallel)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 1.65 secs<br class="title-page-name"/>     Running `target/debug/rayon-parallel`<br class="title-page-name"/>[1, 9, 25, 49, 81]<br class="title-page-name"/>[1, 9, 25, 49, 81]</pre>
<p class="calibre2">Not surprisingly, both return the same result. The most important part of this example is the benchmark. For this to work, we will need to activate the test feature using <kbd class="calibre11">#![feature(test)]</kbd> and declare a new test module. In that, we import everything from the top-level module, which is the main file in this case. We also import <kbd class="calibre11">test::Bencher</kbd>, which will be used for running the benchmarks. The benchmarks are defined by the <kbd class="calibre11">#[bench]</kbd> attributes, which are applied to functions that take in an object which is a mutable reference to a <kbd class="calibre11">Bencher</kbd> type. We pass the functions that we need to benchmark to the bencher, which takes care of running those and printing results.</p>
<p class="calibre2">The benchmarks can be run using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo bench</strong><br class="title-page-name"/>    Finished release [optimized] target(s) in 0.0 secs<br class="title-page-name"/>     Running target/release/deps/rayon_parallel-333850e4b1422ead<br class="title-page-name"/><br class="title-page-name"/>running 2 tests<br class="title-page-name"/>test tests::bench_filter_parallel ... bench: 92,630 ns/iter (+/- 4,942)<br class="title-page-name"/>test tests::bench_filter_sequential ... bench: 1,587 ns/iter (+/- 269)<br class="title-page-name"/><br class="title-page-name"/>test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured; 0 filtered out</pre>
<p class="calibre2">This output shows the two functions and how much time it took to execute an iteration of each. The number in the bracket indicates the confidence interval for the given measurement. While the confidence interval for the parallel version is larger than the non-parallel one, it does perform 58 times more iterations than the non-parallel one. Thus, the parallel version is considerably faster.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Parsing using Pest</h1>
                
            
            
                
<p class="calibre2">We studied different parsing techniques in <a href="part0053.html#1IHDQ0-e803f047c8b7448c90887daa96419287" class="calibre10">Chapter 4</a><em class="calibre16">,</em> <em class="calibre16">Data serialization, De-Serialization, and Parsing</em>. We looked at using parser combinators using Nom, building a large parser from smaller parts. There is a completely different way of solving the same problem of parsing textual data, using <strong class="calibre1">Parsing Expression Grammar (PEG)</strong>. A PEG is a formal grammar that defines how a parser should behave. Thus, it includes a finite set of rules, from basic tokens to more complex structures. A library that can take in such grammar to produce a functional parser is Pest. Let's look at an example of rewriting our HTTP parsing example from <a href="part0053.html#1IHDQ0-e803f047c8b7448c90887daa96419287" class="calibre10">Chapter 4</a>,<em class="calibre16"> Data Serialization, De-Serialization, and Parsing</em>, using Pest. Start with the Cargo project set up:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin pest-example</strong></pre>
<p class="calibre2">Like always, we will need to declare dependency on Pest components like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "pest-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>pest = "^1.0"<br class="title-page-name"/>pest_derive = "^1.0"</pre>
<p class="calibre2">The next step is to define our grammar, which is a linear collection of parsing rules. Like we did previously, we are interested in parsing <kbd class="calibre11">HTTP GET</kbd> or <kbd class="calibre11">POST</kbd> requests. Here is what the grammar looks like:</p>
<pre class="calibre17">// src/appendix/pest-example/src/grammar.pest<br class="title-page-name"/><br class="title-page-name"/>newline = { "\n" }<br class="title-page-name"/>carriage_return = { "\r" }<br class="title-page-name"/>space = { " " }<br class="title-page-name"/>get = { "GET" }<br class="title-page-name"/>post = { "POST" }<br class="title-page-name"/>sep = { "/" }<br class="title-page-name"/>version = { "HTTP/1.1" }<br class="title-page-name"/>chars = { 'a'..'z' | 'A'..'Z' }<br class="title-page-name"/>request = { get | post }<br class="title-page-name"/><br class="title-page-name"/>ident_list = _{ request ~ space ~ sep ~ chars+ ~ sep ~ space ~ version ~ carriage_return ~ newline }</pre>
<p class="calibre2">The first step is to define literal rules that are to be matched verbatim. These correspond to the leaf parsers in Nom. We define literals for newline, carriage return, space, the two request strings, the separator, and the fixed string for the HTTP version. We also define <kbd class="calibre11">request</kbd> as the logical OR of the two request literals. A list of characters is the logical OR of all lowercase letters and all uppercase letters. At this point, we have all we need to define the final rule. That is given by <kbd class="calibre11">ident_list</kbd> and consists of the request, followed by a single space, then a separator; then we indicate that our parser should accept one or more characters using <kbd class="calibre11">*</kbd>. The next valid input is again a separator, followed by a single space, the version string, a carriage return, and finally, a newline. Note that consecutive inputs are separated by the <kbd class="calibre11">~</kbd> character. The leading <kbd class="calibre11">_</kbd> in front indicates that this is a silent rule and should only be used at the top level, as we will see shortly.</p>
<p class="calibre2">The main file looks like this:</p>
<pre class="calibre17">// src/appendix/pest-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate pest;<br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate pest_derive;<br class="title-page-name"/><br class="title-page-name"/>use pest::Parser;<br class="title-page-name"/><br class="title-page-name"/>#[derive(Parser)]<br class="title-page-name"/>#[grammar = "grammar.pest"]<br class="title-page-name"/>// Unit struct that will be used as the parser<br class="title-page-name"/>struct RequestParser;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let get = RequestParser::parse(Rule::ident_list, "GET /foobar/ HTTP/1.1\r\n")<br class="title-page-name"/>        .unwrap_or_else(|e| panic!("{}", e));<br class="title-page-name"/>    for pair in get {<br class="title-page-name"/>        println!("Rule: {:?}", pair.as_rule());<br class="title-page-name"/>        println!("Span: {:?}", pair.clone().into_span());<br class="title-page-name"/>        println!("Text: {}", pair.clone().into_span().as_str());<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    let _ = RequestParser::parse(Rule::ident_list, "WRONG /foobar/<br class="title-page-name"/>    HTTP/1.1\r\n")<br class="title-page-name"/>        .unwrap_or_else(|e| panic!("{}", e));<br class="title-page-name"/>}</pre>
<p class="calibre2">The code is simple; the library provides one basic trait, called <kbd class="calibre11">Parser</kbd>. This can be custom derived for unit structures to produce a functional parser based on the grammar file, as input using an attribute called <kbd class="calibre11">grammar</kbd>. Notably, this library uses custom derivatives and custom attributes very efficiently to provide a nicer user experience. In our case, the unit structure is called <kbd class="calibre11">RequestParser</kbd>, which implements the <kbd class="calibre11">parse</kbd> method. In our main function, we call the that method, passing in the rule from which parsing should start (in our case, that happens to be the final top-level rule, called <kbd class="calibre11">ident_list</kbd>) and a string to parse. Errors are handled by aborting, since there is not much point in continuing if parsing failed.</p>
<p class="calibre2">Having set this structure up, we attempt to parse two strings. The first one is a normal HTTP request. The <kbd class="calibre11">parse</kbd> method returns an iterator over the stream of parsed tokens. We loop over them and print out the name of the rule that token matched with, the span in the input that has the token, and the literal text in that token. Later, we attempt to parse a string which does not have a valid HTTP request. Here is the output:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling pest-example v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/chapter4/pest-example)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs<br class="title-page-name"/>     Running `target/debug/pest-example`<br class="title-page-name"/>Rule: request<br class="title-page-name"/>Span: Span { start: 0, end: 3 }<br class="title-page-name"/>Text: GET<br class="title-page-name"/>Rule: space<br class="title-page-name"/>Span: Span { start: 3, end: 4 }<br class="title-page-name"/>Text:<br class="title-page-name"/>Rule: sep<br class="title-page-name"/>Span: Span { start: 4, end: 5 }<br class="title-page-name"/>Text: /<br class="title-page-name"/>Rule: chars<br class="title-page-name"/>Span: Span { start: 5, end: 6 }<br class="title-page-name"/>Text: f<br class="title-page-name"/>Rule: chars<br class="title-page-name"/>Span: Span { start: 6, end: 7 }<br class="title-page-name"/>Text: o<br class="title-page-name"/>Rule: chars<br class="title-page-name"/>Span: Span { start: 7, end: 8 }<br class="title-page-name"/>Text: o<br class="title-page-name"/>Rule: chars<br class="title-page-name"/>Span: Span { start: 8, end: 9 }<br class="title-page-name"/>Text: b<br class="title-page-name"/>Rule: chars<br class="title-page-name"/>Span: Span { start: 9, end: 10 }<br class="title-page-name"/>Text: a<br class="title-page-name"/>Rule: chars<br class="title-page-name"/>Span: Span { start: 10, end: 11 }<br class="title-page-name"/>Text: r<br class="title-page-name"/>Rule: sep<br class="title-page-name"/>Span: Span { start: 11, end: 12 }<br class="title-page-name"/>Text: /<br class="title-page-name"/>Rule: space<br class="title-page-name"/>Span: Span { start: 12, end: 13 }<br class="title-page-name"/>Text:<br class="title-page-name"/>Rule: version<br class="title-page-name"/>Span: Span { start: 13, end: 21 }<br class="title-page-name"/>Text: HTTP/1.1<br class="title-page-name"/>Rule: carriage_return<br class="title-page-name"/>Span: Span { start: 21, end: 22 }<br class="title-page-name"/>Text:<br class="title-page-name"/>Rule: newline<br class="title-page-name"/>Span: Span { start: 22, end: 23 }<br class="title-page-name"/>Text:<br class="title-page-name"/><br class="title-page-name"/>thread 'main' panicked at ' --&gt; 1:1<br class="title-page-name"/>  |<br class="title-page-name"/>1 | WRONG /foobar/ HTTP/1.1<br class="title-page-name"/>  | ^---<br class="title-page-name"/>  |<br class="title-page-name"/>  = expected request', src/main.rs:21:29<br class="title-page-name"/>note: Run with `RUST_BACKTRACE=1` for a backtrace.</pre>
<p class="calibre2">The first thing to notice is that parsing a wrong HTTP request failed. The error message is nice and clear, explaining exactly where it failed to parse. The correct request did parse successfully and printed out the tokens and all required details to further process those.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Miscellaneous utilities</h1>
                
            
            
                
<p class="calibre2">In C and C++, a common workflow is to define a set of bits as flags. They are generally defined at powers of two, so the first flag will have the decimal value of one, the second one will have two, and so on. This helps in performing logical combinations of those flags. The Rust ecosystem has a crate to facilitate the same workflow. Let's look at an example of using the bitflags crate for working with flags. Let's start with initializing an empty project using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin bitflags-example</strong></pre>
<p class="calibre2">We will set up our project manifest to add <kbd class="calibre11">bitflags</kbd> as a dependency:</p>
<pre class="calibre17">$ cat Cargo.toml<br class="title-page-name"/>[package]<br class="title-page-name"/>name = "bitflags-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>bitflags = "1.0"</pre>
<p class="calibre2">When all of that is ready, our main file will look like this:</p>
<pre class="calibre17">// appendix/bitflags-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate bitflags;<br class="title-page-name"/><br class="title-page-name"/>// This macro defines a struct that holds our<br class="title-page-name"/>// flags. This also defines a number of convinience<br class="title-page-name"/>// methods on the struct.<br class="title-page-name"/>bitflags! {<br class="title-page-name"/>    struct Flags: u32 {<br class="title-page-name"/>        const X = 0b00000001;<br class="title-page-name"/>        const Y = 0b00000010;<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// We define a custom trait to print a<br class="title-page-name"/>// given bitflag in decimal<br class="title-page-name"/>pub trait Format {<br class="title-page-name"/>    fn decimal(&amp;self);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// We implement our trait for the Flags struct<br class="title-page-name"/>// which is defined by the bitflags! macro<br class="title-page-name"/>impl Format for Flags {<br class="title-page-name"/>    fn decimal(&amp;self) {<br class="title-page-name"/>        println!("Decimal: {}", self.bits());<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Main driver function<br class="title-page-name"/>fn main() {<br class="title-page-name"/>    // A logical OR of two given bitflags<br class="title-page-name"/>    let flags = Flags::X | Flags::Y;<br class="title-page-name"/> <br class="title-page-name"/>    // Prints the decimal representation of<br class="title-page-name"/>    // the logical OR<br class="title-page-name"/>    flags.decimal();<br class="title-page-name"/><br class="title-page-name"/>    // Same as before<br class="title-page-name"/>    (Flags::X | Flags::Y).decimal();<br class="title-page-name"/><br class="title-page-name"/>    // Prints one individual flag in decimal<br class="title-page-name"/>    (Flags::Y).decimal();<br class="title-page-name"/><br class="title-page-name"/>    // Examples of the convenience methods mentioned<br class="title-page-name"/>    // earlier. The all method gets the current state<br class="title-page-name"/>    // as a human readable string. The contain method<br class="title-page-name"/>    // returns a bool indicating if the given bitflag<br class="title-page-name"/>    // has the other flag.<br class="title-page-name"/>    println!("Current state: {:?}", Flags::all());<br class="title-page-name"/>    println!("Contains X? {:?}", flags.contains(Flags::X));<br class="title-page-name"/>}</pre>
<p class="calibre2">We import our dependencies and then use the <kbd class="calibre11">bitflags!</kbd> macro to define a number of flags, as mentioned before, we set their values in powers of two. We also demonstrate attaching additional properties to the <kbd class="calibre11">bitflags</kbd> using the trait system. For this, we have a custom trait called <kbd class="calibre11">Format</kbd> that prints a given input as a decimal. The conversion is achieved using the <kbd class="calibre11">bits()</kbd> method that returns all the bits in the given input. The next step is to implement our trait for the <kbd class="calibre11">Flags</kbd> structure.</p>
<p class="calibre2">Once we have done that, we move on to the <kbd class="calibre11">main</kbd> function; in there, we construct a logical OR of two given flags. We use the <kbd class="calibre11">decimal</kbd> method to print out representations of the bitflags and ensure they are equal. Finally, we use the <kbd class="calibre11">all</kbd> function to display a human readable form of the flags. Here, the <kbd class="calibre11">contains</kbd> function returns <kbd class="calibre11">true</kbd>, since the flag <kbd class="calibre11">X</kbd> is indeed in the logical OR of <kbd class="calibre11">X</kbd> and <kbd class="calibre11">Y</kbd>.</p>
<p class="calibre2">Here is what we should see upon running this:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling bitflags-example v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/appendix/bitflags-example)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs<br class="title-page-name"/>     Running `target/debug/bitflags-example`<br class="title-page-name"/>Decimal: 3<br class="title-page-name"/>Decimal: 3<br class="title-page-name"/>Decimal: 2<br class="title-page-name"/>Current state: X | Y<br class="title-page-name"/>Contains X? true</pre>
<p>The values of individual flags should always be an integer type.</p>
<p class="calibre2">Another useful utility for network programming is the <kbd class="calibre11">url</kbd> crate. This crate provides a number of functionalities to parse parts of URLs, from links to web pages to relative addresses. Let's look at a very simple example, starting with the project setup:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin url-example</strong></pre>
<p class="calibre2">The Cargo manifest should look like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cat Cargo.toml</strong><br class="title-page-name"/>[package]<br class="title-page-name"/>name = "url-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>url = "1.6.0"</pre>
<p class="calibre2">Let's look at the main file. In this relatively short example, we are parsing a GitLab URL to extract a few important pieces of information:</p>
<pre class="calibre17">// appendix/url-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate url;<br class="title-page-name"/><br class="title-page-name"/>use url::Url;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    // We are parsing a gitlab URL. This one happens to be using<br class="title-page-name"/>    // git and https, a given username/password and a fragment<br class="title-page-name"/>    // pointing to one line in the source<br class="title-page-name"/>    let url = Url::parse("git+https://foo:bar@gitlab.com/gitlab-org/gitlab-ce/blob/master/config/routes/development.rb#L8").unwrap();<br class="title-page-name"/><br class="title-page-name"/>    // Prints the scheme<br class="title-page-name"/>    println!("Scheme: {}", url.scheme());<br class="title-page-name"/><br class="title-page-name"/>    // Prints the username<br class="title-page-name"/>    println!("Username: {}", url.username());<br class="title-page-name"/><br class="title-page-name"/>    // Prints the password<br class="title-page-name"/>    println!("Password: {}", url.password().unwrap());<br class="title-page-name"/><br class="title-page-name"/>    // Prints the fragment (everything after the #)<br class="title-page-name"/>    println!("Fragment: {}", url.fragment().unwrap());<br class="title-page-name"/><br class="title-page-name"/>    // Prints the host<br class="title-page-name"/>    println!("Host: {:?}", url.host().unwrap());<br class="title-page-name"/>}</pre>
<p class="calibre2">This example URL contains a fragment, pointing to a one-line number in a file. The scheme is set to git, and there is a username and password set for HTTP based authentication. The URL crate provides a method call <kbd class="calibre11">parse</kbd> that takes in a string and returns a struct that has all required information. We can subsequently call individual methods on that variable to print out relevant information.</p>
<p class="calibre2">Here is what this code outputs, matching our expectation:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling url-example v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/appendix/url-example)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.58 secs<br class="title-page-name"/>     Running `target/debug/url-example`<br class="title-page-name"/>Scheme: git+https<br class="title-page-name"/>Username: foo<br class="title-page-name"/>Password: bar<br class="title-page-name"/>Fragment: L8<br class="title-page-name"/>Host: Domain("gitlab.com")</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">This last chapter was a mix of a number of topics which we did not consider to be mainstream enough for other chapters. But we should remember that, in a large ecosystem like Rust has, things evolve very quickly. So some ideas which may not be mainstream today, might just be adopted in the community tomorrow.</p>
<p class="calibre2">Overall, Rust is a wonderful language with enormous potential. We earnestly hope that this book helped the reader get a sense of how to harness its power for network programming.</p>


            

            
        
    </body></html>