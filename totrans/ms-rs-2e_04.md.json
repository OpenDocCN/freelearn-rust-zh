["```rs\npub struct Vec<T> {\n    buf: RawVec<T>,\n    len: usize,\n}\n```", "```rs\nerror[E0412]: cannot find type `T` in this scope\n```", "```rs\n// generic_function.rs\n\nfn give_me<T>(value: T) {\n    let _ = value;\n}\n\nfn main() {\n    let a = \"generics\";\n    let b = 1024;\n    give_me(a);\n    give_me(b);\n}\n```", "```rs\n// generic_struct.rs\n\nstruct GenericStruct<T>(T);\n\nstruct Container<T> {\n    item: T\n}\n\nfn main() {\n    // stuff\n}\n```", "```rs\n// generic_enum.rs\n\nenum Transmission<T> {\n    Signal(T),\n    NoSignal\n}\n\nfn main() {\n    // stuff\n}\n```", "```rs\n// generic_struct_impl.rs\n\nstruct Container<T> {\n    item: T\n}\n\nimpl Container<T> {\n    fn new(item: T) -> Self {\n        Container { item }\n    }\n}\n\nfn main() {\n    // stuff\n}\n```", "```rs\nimpl<T> Container<T> {\n    fn new(item: T) -> Self {\n        Container { item }\n    }\n}\n```", "```rs\nimpl Container<u32> {\n    fn sum(item: u32) -> Self {\n        Container { item }\n    }\n}\n```", "```rs\n// creating_generic_vec.rs\n\nfn main() {\n    let a = Vec::new();\n}\n```", "```rs\n// using_generic_vec.rs\n\nfn main() {\n    // providing a type\n    let v1: Vec<u8> = Vec::new();\n\n    // or calling method\n    let mut v2 = Vec::new();\n    v2.push(2);    // v2 is now Vec<i32>\n\n    // or using turbofish\n    let v3 = Vec::<u8>::new();    // not so readable\n}\n```", "```rs\n// using_generic_func.rs\n\nuse std::str;\n\nfn main() {\n    let num_from_str = str::parse::<u8>(\"34\").unwrap();\n    println!(\"Parsed number {}\", num_from_str);\n}\n```", "```rs\n// super_player/src/main.rs\n\nstruct Audio(String);\nstruct Video(String);\n\nfn main() {\n    // stuff\n}\n```", "```rs\n// super_player/src/media.rs\n\ntrait Playable {\n    fn play(&self);\n    fn pause() {\n        println!(\"Paused\");\n    }\n}\n```", "```rs\n// super_player/src/main.rs\n\nstruct Audio(String);\nstruct Video(String);\n\nimpl Playable for Audio {\n    fn play(&self) {\n        println!(\"Now playing: {}\", self.0);\n    }\n}\n\nimpl Playable for Video {\n    fn play(&self) {\n        println!(\"Now playing: {}\", self.0);\n    }\n}\n\nfn main() {\n    println!(\"Super player!\");\n}\n```", "```rs\n// super_player/src/media.rs\n\npub trait Playable {\n    fn play(&self);\n    fn pause() {\n        println!(\"Paused\");\n    }\n}\n```", "```rs\n// super_player/src/main.rs\n\nmod media;\n\nstruct Audio(String);\nstruct Video(String);\n\nimpl Playable for Audio {\n    fn play(&self) {\n        println!(\"Now playing: {}\", self.0);\n    }\n}\n\nimpl Playable for Video {\n    fn play(&self) {\n        println!(\"Now playing: {}\", self.0);\n    }\n}\n\nfn main() {\n    println!(\"Super player!\");\n    let audio = Audio(\"ambient_music.mp3\".to_string());\n    let video = Video(\"big_buck_bunny.mkv\".to_string());\n    audio.play();\n    video.play();\n}\n```", "```rs\n// trait_inheritance.rs\n\ntrait Vehicle {\n    fn get_price(&self) -> u64;\n}\n\ntrait Car: Vehicle {\n    fn model(&self) -> String;\n}\n\nstruct TeslaRoadster {\n    model: String,\n    release_date: u16\n}\n\nimpl TeslaRoadster {\n    fn new(model: &str, release_date: u16) -> Self {\n        Self { model: model.to_string(), release_date }\n    }\n}\n\nimpl Car for TeslaRoadster {\n    fn model(&self) -> String {\n        \"Tesla Roadster I\".to_string()\n    }\n}\n\nfn main() {\n    let my_roadster = TeslaRoadster::new(\"Tesla Roadster II\", 2020);\n    println!(\"{} is priced at ${}\", my_roadster.model, my_roadster.get_price());\n}\n```", "```rs\n// trait_inheritance.rs\n\nimpl Vehicle for TeslaRoadster {\n    fn get_price(&self) -> u64 {\n        200_000\n    }\n}\n```", "```rs\n Tesla Roadster II is priced at $200000\n```", "```rs\ntrait Foo {\n    fn foo();\n}\n```", "```rs\npub trait From<T> {\n    fn from(T) -> Self;\n}\n```", "```rs\ntrait Foo {\n    type Out;\n    fn get_value(self) -> Self::Out;\n}\n```", "```rs\ntrait Bar {\n    fn bar();\n}\n\ntrait Foo: Bar {\n    fn foo();\n}\n```", "```rs\n// trait_bound_intro.rs\n\nstruct Game;\nstruct Enemy;\nstruct Hero;\n\nimpl Game {\n    fn load<T>(&self, entity: T) {\n        entity.init();\n    }\n}\n\nfn main() {\n    let game = Game;\n    game.load(Enemy);\n    game.load(Hero);\n}\n```", "```rs\n// trait_bounds_intro_fixed.rs\n\nstruct Game;\nstruct Enemy;\nstruct Hero;\n\ntrait Loadable {\n    fn init(&self);\n}\n\nimpl Loadable for Enemy {\n    fn init(&self) {\n        println!(\"Enemy loaded\");\n    }\n}\n\nimpl Loadable for Hero {\n    fn init(&self) {\n        println!(\"Hero loaded\");\n    }\n}\n\nimpl Game {\n    fn load<T: Loadable>(&self, entity: T) {\n        entity.init();\n    }\n}\n\nfn main() {\n    let game = Game;\n    game.load(Enemy);\n    game.load(Hero);\n}\n```", "```rs\nfn load<T: Loadable>(&self, entity: T) { .. }\n```", "```rs\n// trait_bounds_basics.rs\n\nfn add_thing<T>(fst: T, snd: T) {\n    let _ = fst + snd;\n}\n\nfn main() {\n    add_thing(2, 2);\n}\n```", "```rs\n// trait_bound_basics_fixed.rs\n\nuse std::ops::Add;\n\nfn add_thing<T: Add>(fst: T, snd: T) {\n    let _ = fst + snd;\n}\n\nfn main() {\n    add_thing(2, 2);\n}\n```", "```rs\nfn show_me<T: Display>(val: T) {\n    // can use {} format string now, because of Display bound\n    println!(\"{}\", val);\n}\n```", "```rs\npub fn parse<F>(&self) -> Result<F, <F as FromStr>::Err>\nwhere F: FromStr { ... }\n```", "```rs\n// trait_bounds_types.rs\n\nuse std::fmt::Display;\n\nstruct Foo<T: Display> {\n    bar: T\n}\n\n// or\n\nstruct Bar<F> where F: Display {\n    inner: F\n}\n\nfn main() {}\n```", "```rs\n// trait_bounds_functions.rs\n\nuse std::fmt::Debug;\n\ntrait Eatable {\n    fn eat(&self);\n}\n\n#[derive(Debug)]\nstruct Food<T>(T);\n\n#[derive(Debug)]\nstruct Apple;\n\nimpl<T> Eatable for Food<T> where T: Debug {\n    fn eat(&self) {\n        println!(\"Eating {:?}\", self);\n    }\n}\n\nfn eat<T>(val: T) where T: Eatable {\n    val.eat();\n}\n\nfn main() {\n    let apple = Food(Apple);\n    eat(apple);\n}\n```", "```rs\nimpl<K: Hash + Eq, V> HashMap<K, V, RandomState>\n```", "```rs\n// traits_composition.rs\n\ntrait Eat {\n    fn eat(&self) {\n        println!(\"eat\");\n    }\n}\ntrait Code {\n    fn code(&self) {\n        println!(\"code\");\n    }\n}\ntrait Sleep {\n    fn sleep(&self) {\n        println!(\"sleep\");\n    }\n}\n\ntrait Programmer : Eat + Code + Sleep {\n    fn animate(&self) {\n        self.eat();\n        self.code();\n        self.sleep();\n        println!(\"repeat!\");\n    }\n}\n\nstruct Bob;\nimpl Programmer for Bob {}\nimpl Eat for Bob {}\nimpl Code for Bob {}\nimpl Sleep for Bob {}\n\nfn main() {\n    Bob.animate();\n}\n```", "```rs\neat\ncode\nsleep\nrepeat!\n```", "```rs\n// impl_trait_syntax.rs\n\nuse std::fmt::Display;\n\nfn show_me(val: impl Display) {\n    println!(\"{}\", val);\n}\n\nfn main() {\n    show_me(\"Trait bounds are awesome\");\n}\n```", "```rs\n// impl_trait_closure.rs\n\nfn lazy_adder(a:u32, b: u32) -> impl Fn() -> u32 {\n    move || a + b\n}\n\nfn main() {\n    let add_later = lazy_adder(1024, 2048);\n    println!(\"{:?}\", add_later());\n}\n```", "```rs\n// impl_trait_both.rs\n\nuse std::fmt::Display;\n\nfn surround_with_braces(val: impl Display) -> impl Display {\n    format!(\"{{{}}}\", val)\n}\n\nfn main() {\n    println!(\"{}\", surround_with_braces(\"Hello\"));\n}\n```", "```rs\n// complex/src/lib.rs\n\nstruct Complex<T> {\n    // Real part\n    re: T,\n    // Complex part\n    im: T\n}\n```", "```rs\n// complex/src/lib.rs\n\n#[derive(Default)]\nstruct Complex<T> {\n    // Real part\n    re: T,\n    // Complex part\n    im: T\n}\n\nimpl<T> Complex<T> {\n    fn new(re: T, im: T) -> Self {\n        Complex { re, im }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use Complex;\n    #[test]\n    fn complex_basics() {\n        let first = Complex::new(3,5);\n        let second: Complex<i32> = Complex::default();\n        assert_eq!(first.re, 3);\n        assert_eq!(first.im, 5);\n        assert!(second.re == second.im);\n    }\n}\n```", "```rs\n#[derive(Default, Debug, PartialEq, Copy, Clone)]\nstruct Complex<T> {\n    // Real part\n    re: T,\n    // Complex part\n    im: T\n}\n```", "```rs\npub trait Add<RHS = Self> { \n    type Output; \n    fn add(self, rhs: RHS) -> Self::Output; \n} \n```", "```rs\n// complex/src/lib.rs\n\nuse std::ops::Add;\n\n#[derive(Default, Debug, PartialEq, Copy, Clone)]\nstruct Complex<T> {\n    // Real part\n    re: T,\n    // Complex part\n    im: T\n}\n\nimpl<T> Complex<T> {\n    fn new(re: T, im: T) -> Self {\n        Complex { re, im }\n    }\n}\n\nimpl<T: Add<T, Output=T>> Add for Complex<T> { \n    type Output = Complex<T>; \n    fn add(self, rhs: Complex<T>) -> Self::Output { \n        Complex { re: self.re + rhs.re, im: self.im + rhs.im } \n    } \n}\n\n#[cfg(test)]\nmod tests {\n    use Complex;\n    #[test]\n    fn complex_basics() {\n        let first = Complex::new(3,5);\n        let second: Complex<i32> = Complex::default();\n    }\n\n    fn complex_addition() {\n        let a = Complex::new(1,-2);\n        let b = Complex::default();\n        let res = a + b;\n        assert_eq!(res, a);\n    }\n}\n```", "```rs\nimpl<T: Add<T, Output=T> Add for Complex<T>\n```", "```rs\npub trait From<T> { \n    fn from(self) -> T;\n} \n```", "```rs\n// complex/src/lib.rs\n\n// previous code omitted for brevity\n\nuse std::convert::From;\n\nimpl<T> From<(T, T)> for Complex<T> { \n    fn from(value: (T, T)) -> Complex<T> { \n        Complex { re: value.0, im: value.1 }\n    } \n}\n\n// other impls omitted\n\n#[cfg(test)]\nmod tests {\n\n    // other tests\n\n     use Complex;\n     #[test]\n     fn complex_from() {\n         let a = (2345, 456);\n         let complex = Complex::from(a);\n         assert_eq!(complex.re, 2345);\n         assert_eq!(complex.im, 456);\n     }\n}\n```", "```rs\nimpl<T> From<(T, T)> for Complex<T> { \n    fn from(value: (T, T)) -> Complex<T> { \n        Complex { re: value.0, im: value.1 }\n    } \n}\n```", "```rs\npub trait Display { \n    fn fmt(&self, &mut Formatter) -> Result<(), Error>; \n}\n```", "```rs\n// complex/src/lib.rs\n\n// previous code omitted for brevity\n\nuse std::fmt::{Formatter, Display, Result};\n\nimpl<T: Display> Display for Complex<T> {\n    fn fmt(&self, f: &mut Formatter) -> Result { \n        write!(f, \"{} + {}i\", self.re, self.im)\n    } \n} \n\n#[cfg(test)]\nmod tests {\n\n    // other tests\n\n    use Complex;\n    #[test]\n    fn complex_display() {\n        let my_imaginary = Complex::new(2345,456);\n        println!(\"{}\", my_imaginary);\n    }\n}\n```", "```rs\n// trait_objects.rs\n\nuse std::fmt::Debug;\n\n#[derive(Debug)]\nstruct Square(f32);\n#[derive(Debug)]\nstruct Rectangle(f32, f32);\n\ntrait Area: Debug {\n    fn get_area(&self) -> f32; \n}\n\nimpl Area for Square {\n    fn get_area(&self) -> f32 {\n        self.0 * self.0\n    }\n}\n\nimpl Area for Rectangle {\n    fn get_area(&self) -> f32 {\n        self.0 * self.1\n    }\n}\n\nfn main() {\n    let shapes: Vec<&dyn Area> = vec![&Square(3f32), &Rectangle(4f32, 2f32)];\n    for s in shapes {\n        println!(\"{:?}\", s);\n    }\n}\n```", "```rs\n// dyn_trait.rs\n\nuse std::fmt::Display;\n\nfn show_me(item: &dyn Display) {\n    println!(\"{}\", item);\n}\n\nfn main() {\n    show_me(&\"Hello trait object\");\n}\n```"]