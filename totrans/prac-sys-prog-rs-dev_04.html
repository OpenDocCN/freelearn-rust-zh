<html><head></head><body>
		<div><h1 id="_idParaDest-56"><em class="italic"><a id="_idTextAnchor056"/>Chapter 3</em>: <a id="_idTextAnchor057"/>Introduction to the Rust Standard Library</h1>
			<p>In the previous chapter, we built a command-line tool using various Rust language primitives and modules from the Rust Standard Library. However, in order to fully exploit the power of Rust, it is imperative to understand the breadth of what features are available within the standard library for system programming tasks, without having to reach out to third-party crates.</p>
			<p>In this chapter, we'll deep-dive into the structure of the Rust Standard Library. You'll get an introduction to the standard modules for accessing system resources and learn how to manage them programmatically. With the knowledge gained, we will implement a tiny portion of a template engine in Rust. By the end of this chapter, you will be able to confidently navigate the Rust Standard Library and make use of it in your projects.</p>
			<p>The following are the key learning outcomes for this chapter:</p>
			<ul>
				<li>Introducing the Rust Standard Library</li>
				<li>Writing one feature of a template engine using the standard library modules</li>
			</ul>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor058"/>Technical requirements</h1>
			<p>Rustup and Cargo must be installed in your local development environment. The GitHub repository for the examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03</a>.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor059"/>The Rust Standard Library and systems programming</h1>
			<p>Before we dive <a id="_idIndexMarker175"/>into the standard library, let's understand the context of how it fits into systems programming.</p>
			<p>In systems programming, one of the cardinal requirements is to manage system resources such as memory, files, network I/O, devices, and processes. Every operating system has a kernel (or equivalent), which is the central software module that is loaded in memory and connects the system hardware with the application processes. You may think, where does the Rust Standard Library fit in then? Are we going to write a kernel in Rust? No, that's not the purpose of this book. The most popular operating systems, which are basically the Unix, Linux, and Windows variants, all have kernels written mostly in <strong class="bold">C</strong> with a mix of assembly. It is still early days for Rust to augment C as the kernel development language, though there are several experimental efforts in that direction. However, what <a id="_idIndexMarker176"/>the Rust Standard Library offers is an API interface to make system calls from Rust programs, in order to manage and manipulate various system resources. The following figure shows this context:</p>
			<div><div><img src="img/Figure_3.1_B16405.jpg" alt="Figure 3.1 – Rust Standard Library"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Rust Standard Library</p>
			<p>Let's walk through this figure to understand each of the components better:</p>
			<ul>
				<li><code>read()</code>, which the kernel will then execute on behalf of the editor program. The reason for this restriction is that modern processor architectures (such as x86-64) allow the CPU to operate at two different privilege levels—<em class="italic">kernel mode</em> and <em class="italic">user mode</em>. The user mode has a lower level of privilege than the kernel mode. The CPU can perform certain operations only while running in the kernel mode. This design prevents user programs from accidentally doing tasks that could adversely affect the system operation.</li>
				<li><strong class="bold">System call (syscall) interface</strong>: The kernel also <a id="_idIndexMarker178"/>provides a system call <em class="italic">application programming interface</em> that acts as the entry point for processes to request the kernel to perform various tasks.</li>
				<li><code>libc</code> (or <code>glibc</code>). For the Windows operating system, there are equivalent APIs.</li>
				<li><code>libc</code> (or another platform-specific equivalent library) internally to invoke system calls. The Rust Standard Library is cross-platform, which means that the details of how system calls are invoked (or which wrapper libraries are used) are abstracted away from the Rust developer. There are ways to invoke system calls from Rust code without using the standard library (for example, in embedded systems development), but that is beyond the scope of this book.</li>
				<li><strong class="bold">User space programs</strong>: These are the programs that you will write as part of this book using the <a id="_idIndexMarker181"/>standard library. The <em class="italic">arithmetic expression evaluator</em> you wrote in the previous chapter is an example of this. In this chapter, you will learn how to write a feature of the template engine using the standard library, which is also a user space program.<p class="callout-heading">Note</p><p class="callout">Not all modules and functions within the Rust Standard Library invoke system calls (for example, there are methods for string manipulation, and to handle errors). As we go through the standard library, it is important to remember this distinction.</p></li>
			</ul>
			<p>Let's now begin our journey to understand and start using the Rust Standard Library.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor061"/>Exploring the Rust Standard Library</h1>
			<p>We earlier discussed the <a id="_idIndexMarker182"/>role of the Rust Standard Library in enabling user programs to invoke kernel operations. The following are some of the notable features of the standard library, which we will refer to as <code>std</code> for brevity:</p>
			<ul>
				<li><code>std</code> is cross-platform. It provides functionality that hides the differences among underlying platform architectures.</li>
				<li><code>std</code> is available to all Rust crates by default. The <code>use</code> statement gives access to the respective modules and their constituents (traits, methods, structs, and so on). For example, the statement <code>use std::fs</code> gives access to the module providing file manipulation operations.</li>
				<li><code>std</code> includes operations on standard Rust primitives (such as integers and floating-point numbers). For example, <code>std::i8::MAX</code> is a constant implemented in the standard library that specifies the maximum value that can be stored in a variable of type i8.</li>
				<li>It implements core data types such as <em class="italic">vector, strings</em>, and <em class="italic">smart pointers</em> such as <code>Box</code>, <code>Rc</code>, and <code>Arc</code>.</li>
				<li>It provides functionality for operations such as data manipulation, memory allocation, error <a id="_idIndexMarker183"/>handling, networking, I/O, concurrency, async I/O primitives, and foreign function interfaces.</li>
			</ul>
			<p>The following figure shows a <a id="_idIndexMarker184"/>high-level view of the Rust standard library:</p>
			<div><div><img src="img/Figure_3.2_B16405.jpg" alt="Figure 3.2 – Rust Standard Library – high-level view"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Rust Standard Library – high-level view</p>
			<p>The Rust Standard Library (<code>std</code>) is broadly organized as follows:</p>
			<ul>
				<li><strong class="bold">Rust language primitives</strong>, which contain basic types such as signed and unsigned, integers, bool, floating point, char, array, tuple, slice, and string. Primitives are implemented by the compiler. The Rust Standard Library includes the primitives and builds on top of them.</li>
				<li>The <code>libc</code>) or other external dependencies. You can instruct the compiler to compile without the Rust Standard Library and use the core crate instead (such an environment is called <code>no_std</code> in Rust parlance, which is annotated with the <code>#![no_std]</code> attribute), and this is used commonly in embedded programming.</li>
				<li>The <code>Box&lt;T&gt;</code>), reference-counted pointers (<code>Rc&lt;T&gt;</code>), and atomically reference-counted pointers (<code>Arc&lt;T&gt;</code>). It also includes and collections such as <code>Vec</code> and <code>String</code> (note that <code>String</code> is implemented in Rust as a UTF-8 sequence). This crate does not <a id="_idIndexMarker185"/>need to be used directly when the standard library is used, as the contents of the <code>alloc</code> crate are re-exported and made available as part of the <code>std</code> library. The only exception to this rule is when developing in a <code>no_std</code> environment, when this crate can be directly used to access its functionality.</li>
				<li><code>core</code> or <code>alloc</code> crates) include rich functionality for operations around concurrency, I/O, file system access, networking, async I/O, errors, and OS-specific functions.</li>
			</ul>
			<p>In this book, we will not directly work with the <code>core</code> or <code>alloc</code> crates, but use the Rust Standard Library modules that are a higher-level abstraction over these crates.</p>
			<p>We will now analyze the key modules within the Rust Standard Library with a focus on systems programming. The standard library is organized into modules. For example, the functionality that enables user programs to run on multiple threads for concurrency is in the <code>std::thread</code> module, and the Rust constructs for dealing with synchronous I/O are in the <code>std::io</code> module. Understanding how the functionality within the standard library is organized across modules is a critical part of being an effective and productive Rust programmer.</p>
			<p><em class="italic">Figure 3.3</em> shows the <a id="_idIndexMarker186"/>layout of the standard library modules organized into groups:</p>
			<div><div><img src="img/Figure_3.3_B16405.jpg" alt="Figure 3.3 – Rust Standard Library modules"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Rust Standard Library modules</p>
			<p>The modules in this figure have been grouped by their primary area of focus.</p>
			<p>How do we know, though, which of these modules is related to managing system resources? As this might be of interest for the purposes of this book, let's attempt to classify the modules further into one of these two buckets:</p>
			<ul>
				<li><strong class="bold">Syscalls-oriented</strong>: These are modules <a id="_idIndexMarker187"/>that either manage <a id="_idIndexMarker188"/>system hardware resources directly or require the kernel for other privileged operations.</li>
				<li><strong class="bold">Computation-oriented</strong>: These are the <a id="_idIndexMarker189"/>modules that are <a id="_idIndexMarker190"/>oriented towards data representation, computation, and instructions to the compiler. </li>
			</ul>
			<p><em class="italic">Figure 3.4</em> shows the same module grouping as in <em class="italic">Figure 3.3</em> but segregated as <strong class="bold">Syscalls-oriented</strong> or <strong class="bold">Computation-oriented</strong>. Note that this may not be a perfect classification as not all methods in all modules marked in the <strong class="bold">Syscalls-oriented</strong> category involve actual system calls. But this classification can serve as a guide to find our way around <a id="_idIndexMarker191"/>the standard library:</p>
			<div><div><img src="img/Figure_3.4_B16405.jpg" alt="Figure 3.4 – Rust modules with classification"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Rust modules with classification</p>
			<p>Let's get to know the functionality of each module.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>Computation-oriented modules</h2>
			<p>The standard library modules in this section deal <em class="italic">mostly</em> with programming constructs that deal with data <a id="_idIndexMarker192"/>processing, data modeling, error handling, and instructions to the compiler. Some of the modules may have functionality that overlaps with the syscalls-oriented category, but this grouping is based on the primary focus of each module.</p>
			<h3>Data types</h3>
			<p>The modules <a id="_idIndexMarker193"/>related to data types and structures in the Rust Standard Library are mentioned in this section. There are broadly two categories of data types in Rust. The first group comprises primitive types such as integers (signed, unsigned), floating points, and char, which are a core part of the language and compiler and the standard library adds additional functionality to those types. The second group consists of higher-level data structures and traits such as vectors and strings, which are implemented within the standard library. Modules from both these groups are listed here:</p>
			<ul>
				<li><code>any</code>: This can be used when the type of the value passed to a function is not known at compile time. Runtime reflection is used to check the type and perform suitable processing. An example of using this would be in the logging function, where we want to customize what is logged depending on the data type.</li>
				<li><code>array</code>: It contains utility functions such as comparing arrays, implemented over the primitive array type. Note that Rust arrays are value types, that is, they are allocated on the stack, and have a fixed length (not growable).</li>
				<li><code>char</code>: This contains utility functions implemented over the <code>char</code> primitive type, such as checking for digits, converting to uppercase, encoding to UTF-8, and so on.</li>
				<li><code>collections</code>: This is Rust's standard collection library, which contains efficient implementations of common collection data structures used in programming. Collections in this library include <code>Vectors</code>, <code>LinkedLists</code>, <code>HashMaps</code>, <code>HashSet</code>, <code>BTtreeMap</code>, <code>BTreeSet</code>, and <code>BinaryHeap</code>.</li>
				<li><code>f32</code>, <code>f64</code>: This library provides constants specific to floating point implementations of the <code>f32</code> and <code>f64</code> primitive types. Examples of constants are <code>MAX</code> and <code>MIN</code>, which provide the maximum and minimum value of floating point numbers that can be stored by <code>f32</code> and <code>f64</code> types.</li>
				<li><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>: Signed integer types of various sizes. For example, <code>i8</code> represents a signed integer of length 8 bits (1 byte) and <code>i128</code> represents a signed integer of length 128 bits (16 bytes).</li>
				<li><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>: Unsigned integer types of various sizes. For example, <code>u8</code> represents an unsigned integer of length 8 bits (1 byte) and <code>u128</code> represents an unsigned integer of length 128 bits (16 bytes).</li>
				<li><code>isize</code>, <code>usize</code>: Rust has two data types, <code>isize</code> and <code>usize</code>, that correspond to signed and unsigned integer types. The uniqueness of these types is that their size is <a id="_idIndexMarker194"/>dependent on whether the CPU uses a 32-bit or 64-bit architecture. For example, on a 32-bit system, the size of the <code>isize</code> and <code>usize</code> data types is 32 bits (4 bytes), and likewise, for 64-bit systems, their size is 64 bits (8 bytes).</li>
				<li><code>marker</code>: Basic properties that can be attached to types (in the form of traits) are described in this module. Examples include <code>Copy</code> (types whose values can be duplicated by a simple copy of its bits) and <code>Send</code> (thread-safe types).</li>
				<li><code>slice</code>: Contains structs and methods useful to perform operations such as <code>iterate</code> and <code>split</code> on <code>slice</code> data types.</li>
				<li><code>string</code>: This module contains the <code>String</code> type and methods such as <code>to_string</code>, which allows converting a value to a <code>String</code>. Note that <code>String</code> is not a primitive data type in Rust. The primitive types in Rust are listed here: <a href="https://doc.rust-lang.org/std/">https://doc.rust-lang.org/std/</a>.</li>
				<li><code>str</code>: This module contains structs and methods associated with string slices such as <code>iterate</code> and <code>split</code> on <code>str</code> slices.</li>
				<li><code>vec</code>: This module contains the <code>Vector</code> type, which is a growable array with heap-allocated contents, and associated methods for operating on vectors such as splicing and iterating. A <code>vec</code> module is an owned reference and a smart pointer (such as <code>Box&lt;T&gt;</code>). Note that <code>vec</code> was originally defined in the <code>alloc</code> crate, but was made available as part of both the <code>std::vec</code> and <code>std::collections</code> modules.</li>
			</ul>
			<h3>Data processing</h3>
			<p>This is an assorted collection of modules that provides helper methods for different types of <a id="_idIndexMarker195"/>processing such as dealing with ASCII characters, comparing, ordering, and printing formatted values, arithmetic operations, and iterators:</p>
			<ul>
				<li><code>ascii</code>: Most string operations in Rust act on UTF-8 strings and characters. But in some cases, there may be a need to operate on ASCII characters only. This module provides operations on ASCII strings and characters.</li>
				<li><code>cmp</code>: This module contains functions for ordering and comparing values, and associated macros. For example, implementing the <code>Eq</code> trait contained in this module allows a comparison of custom struct instances using the <code>==</code> and <code>!=</code> operators.</li>
				<li><code>fmt</code>: This module contains utilities to format and print strings. Implementing this trait enables printing any custom data type using the <code>format!</code> macro.</li>
				<li><code>hash</code>: This module provides functionality to compute a hash of data objects.</li>
				<li><code>iter</code>: This module contains the <code>Iterator</code> trait, which is part and parcel of idiomatic Rust code, and a popular feature of Rust. This trait can be implemented by custom data types for iterating over their values.</li>
				<li><code>num</code>: This module provides additional data types for numeric operations.</li>
				<li><code>ops</code>: This module has a set of traits that allow you to overload operators for custom data types. For example, the <code>Add</code> trait can be implemented for a custom struct and the <code>+</code> operator can be used to add two structs of that type.</li>
			</ul>
			<h3>Error handling</h3>
			<p>This group consists of <a id="_idIndexMarker196"/>modules that have functionality for error handling in Rust programs. The <code>Error</code> trait is the foundational construct to represent errors. <code>Result</code> deals with the presence or absence of errors in the return value of functions, and <code>Option</code> deals with the presence or absence of values in a variable. The latter prevents the dreaded <em class="italic">null value</em> error that plagues several programming languages. <code>Panic</code> is provided as a way to exit the program if errors cannot be handled:</p>
			<ul>
				<li><code>error</code>: This module contains the <code>Error</code> trait, which represents the basic expectations of error values. All errors implement the trait <code>Error</code>, and this module is used to implement custom or application-specific error types.</li>
				<li><code>option</code>: This module contains the <code>Option</code> type, which provides the ability for a value to be initialized to either <code>Some</code> value or <code>None</code> value. The <code>Option</code> type can be considered as a very basic way to handle errors involving the absence of values. Null values cause havoc in other programming languages in the form of null pointer exceptions or the equivalent.</li>
				<li><code>panic</code>: This module provides support to deal with panic including capturing the cause of panic and setting hooks to trigger custom logic on panic.</li>
				<li><code>result</code>: This module contains the <code>Result</code> type, which along with the <code>Error</code> trait and <code>Option</code> type form the foundation of error handling in Rust. <code>Result</code> is represented as <code>Result&lt;T,E&gt;</code>, which is used to return either values or errors from functions. Functions return the <code>Result</code> type whenever errors are expected and if the error is recoverable.</li>
			</ul>
			<h3>Foreign function interface (FFI)</h3>
			<p>FFI is <a id="_idIndexMarker197"/>provided by the <code>ffi</code> module. This module <a id="_idIndexMarker198"/>provides utilities to exchange data across non-Rust interface boundaries, such as working with other programming languages or to deal directly with the underlying operating system/kernel.</p>
			<h3>Compiler</h3>
			<p>This group contains <a id="_idIndexMarker199"/>modules that are related to the Rust compiler. </p>
			<ul>
				<li><code>hint</code>: This module contains functions to hint to the compiler about how code should be emitted or optimized.</li>
				<li><code>prelude</code>: The prelude is the list of items that Rust automatically imports into each Rust program. It is a convenience feature.</li>
				<li><code>primitive</code>: This module re-exports Rust primitive types, normally for use in macro code.</li>
			</ul>
			<p>We've so far seen the <strong class="bold">computation-oriented</strong> modules of the Rust standard library. Let's take a look at the <strong class="bold">syscalls-oriented</strong> modules now.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor063"/>Syscalls-oriented modules</h2>
			<p>While the previous <a id="_idIndexMarker200"/>group of modules was related to in-memory computations, this section deals with operations that involve managing hardware resources or other privileged operations that <em class="italic">normally</em> require kernel intervention. Note that not all methods in these modules involve system calls to the kernel, but it helps to construct a mental model at the module level.</p>
			<h3>Memory management</h3>
			<p>This grouping contains a set of modules from the standard library that deal with memory <a id="_idIndexMarker201"/>management and smart pointers. Memory management includes static memory allocation (on the stack), dynamic memory allocation (on the heap), memory deallocation (when a variable goes out of scope, its destructor is run), cloning or copying values, managing raw pointers and smart pointers (which are pointers to data on the heap), and fixing memory locations for objects so that they cannot be moved around (which is needed for special situations). The modules are as follows:</p>
			<ul>
				<li><code>alloc</code>: This module contains APIs for the allocation and deallocation of memory, and to register a custom or third-party memory allocator as the standard library's default.</li>
				<li><code>borrow</code>: In Rust, it is common to use different representations of a given type for different use cases. For example, a value can be stored and managed as <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, or <code>Arc&lt;T&gt;</code>. Similarly, a string value can be stored as the <code>String</code> or <code>str</code> type. Rust provides methods that allow one type to be borrowed as some other type, by implementing the <code>borrow</code> method from the <code>Borrow</code> trait. So basically, a type is free to be borrowed as many different types. This module contains the trait <code>Borrow</code>, which allows the conversion of an owned value to borrowed or to convert borrowed data of any type to an owned value. For example, a value of type <code>String</code> (which is an owned type) can be borrowed as <code>str</code>.</li>
				<li><code>cell</code>: In Rust, memory safety is based on the rule that a value can have either several immutable references to it or a single mutable reference. But there may be scenarios where a shared, mutable reference is required. This module provides shareable mutable containers that include <code>Cell</code> and <code>RefCell</code>. These types provide controlled mutability of shared types.</li>
				<li><code>clone</code>: In Rust, primitive types such as integers are <em class="italic">copyable</em>, that is, they implement the <code>Copy</code> trait. This means that when assigning the value of a variable <a id="_idIndexMarker202"/>to another variable or while passing a parameter to a function, the value of the object is duplicated. But not all types can be copied, because they may require memory allocations (for example, <code>String</code> or <code>Vec</code> types where memory is allocated in the heap, rather than the stack). In such cases, a <code>clone()</code> method is used to duplicate a value. This module provides the <code>Clone</code> trait, which allows values of custom data types to be duplicated.</li>
				<li><code>convert</code>: This module contains functionality to facilitate the conversion between data types. For example, by implementing the <code>AsRef</code> trait contained in this module, you can write a function that takes a parameter of type <code>AsRef&lt;str&gt;</code>, which means that this function can accept any reference that can be converted into a string reference (<code>&amp;str</code>). Since both the <code>str</code> and <code>String</code> types implement the <code>AsRef</code> trait, you can pass either a <code>String</code> reference (<code>String</code>) or string slice reference (<code>&amp;str</code>) to this function.</li>
				<li><code>default</code>: This module has the trait <code>Default</code>, which is used to assign meaningful default values for data types.</li>
				<li><code>mem</code>: This module contains memory-related functions including querying memory size, initialization, swapping, and other memory manipulation operations.</li>
				<li><code>pin</code>: Types in Rust are movable, by default. For example, on a <code>Vec</code> type, a <code>pop()</code> operation moves a value out and a push operation may result in the reallocation of memory. However, there are situations where it is useful to have objects that have fixed memory locations and do not move. For example, self-referencing data structures such as linked lists. For such cases, Rust provides a data type that pins data to a location in memory. This is achieved by wrapping a type in the pinned pointer, <code>Pin&lt;P&gt;</code>, which pins the value <code>P</code> in its place in memory.</li>
				<li><code>ptr</code>: Working <a id="_idIndexMarker203"/>with raw pointers in Rust is not common, and is used only in selective use cases. Rust allows working with raw pointers in unsafe code blocks, where the compiler does not take responsibility for memory safety and the programmer is responsible for memory-safe operations. This module provides functions to work with raw pointers. Rust supports two types of raw pointers—immutable (for example, <code>*const i32</code>) and mutable (for example, <code>*mut i32</code>). Raw pointers have no restrictions on how they are used. They are the only pointer type in Rust that can be null, and there is no automatic dereferencing of raw pointers.</li>
				<li><code>rc</code>: This module provides single-threaded reference-counting pointers, where <code>rc</code> stands for reference-counted. A reference-counted pointer to an object of type <code>T</code> can be represented as <code>Rc&lt;T&gt;</code>. <code>Rc&lt;T&gt;</code> provides shared ownership of value <code>T</code>, which is allocated in the heap. If a value of this type is cloned, it returns a new pointer to the same memory location in the heap (does not duplicate the value in memory). This value is retained until the last <code>Rc</code> pointer that references this value is in existence, after which the value is dropped.</li>
			</ul>
			<h3>Concurrency</h3>
			<p>This <a id="_idIndexMarker204"/>category groups modules related to synchronous concurrent processing. Concurrent programs can be designed in Rust by spawning processes, spawning threads within a process, and having ways to synchronize and share data across threads and processes. Asynchronous concurrency is covered under the <code>Async</code> group.</p>
			<ul>
				<li><code>env</code>: This module allows inspecting and manipulating a process's environment, including environment variables, the arguments of a process, and paths. This module could belong to its own category as it is widely used beyond just concurrency, but it is grouped here along with the <code>process</code> module because this module is designed to work with a <em class="italic">process</em> (for example, getting and setting the environment variables of a process or getting the command-line parameters used to start a process).</li>
				<li><code>process</code>: This module provides functions for dealing with processes including spawning a new process, handling I/O, and terminating processes.</li>
				<li><code>sync</code>: The sequence of instructions executed in a Rust program may vary in cases where concurrency is involved. In such cases, there may be multiple threads of execution in parallel (for example, multiple threads in a multi-core CPU), in which case synchronization primitives are needed to coordinate operations across threads. This module includes synchronization primitives such as <code>Arc</code>, <code>Mutex</code>, <code>RwLock</code>, and <code>Condvar</code>.</li>
				<li><code>thread</code>: Rust's threading model consists of native OS threads. This module provides functionality to work with threads such as spawning new threads, and configuring, naming, and synchronizing them.</li>
			</ul>
			<h3>File system</h3>
			<p>This contains two modules that deal with filesystem operations. The <code>fs</code> module deals with <a id="_idIndexMarker205"/>methods for working with and manipulating the contents of the local file system. The <code>path</code> module provides methods to navigate and manipulate directory and file system paths programmatically:</p>
			<ul>
				<li><code>fs</code>: This module contains operations to work with and manipulate file systems. Note that operations in this module can be used cross-platform. Structs and methods in this module deal with files, naming, file types, directories, file metadata, permissions, and iterating over entries in a directory.</li>
				<li><code>path</code>: This module provides the types <code>PathBuf</code> and <code>Path</code> for working with and manipulating paths.</li>
			</ul>
			<h3>Input-Output</h3>
			<p>This contains the <code>io</code> module, <a id="_idIndexMarker206"/>which provides core I/O functionality. The <code>io</code> module contains common functions that are used while dealing with inputs and outputs. This includes reading and writing to I/O types, such as files or TCP streams, buffered reads and writes for better performance, and working with standard input and output.</p>
			<h3>Networking</h3>
			<p>The core networking <a id="_idIndexMarker207"/>functionality is provided by the <code>net</code> module. This module contains the primitives for TCP and UDP communications and for working with ports and sockets.</p>
			<h3>OS-specific</h3>
			<p>The OS-specific functions are <a id="_idIndexMarker208"/>provided in the <code>os</code> module. This module contains platform-specific definitions and extensions for the Linux, Unix, and Windows operating systems.</p>
			<h3>Time</h3>
			<p>The <code>time</code> module provides <a id="_idIndexMarker209"/>functions to work with system time. This module contains structs to deal with system time and to compute durations, typically used for system timeouts.</p>
			<h3>Async</h3>
			<p>Asynchronous I/O functionality is <a id="_idIndexMarker210"/>provided by the <code>future</code> and <code>task</code> modules:</p>
			<ul>
				<li><code>future</code>: This contains the <code>Future</code> trait that serves as the foundation for building asynchronous services in Rust.</li>
				<li><code>task</code>: This module provides functions needed to work with asynchronous tasks including <code>Context</code>, <code>Waker</code>, and <code>Poll</code>.<p class="callout-heading">A note on the prelude module</p><p class="callout">As we've seen, Rust comes with a lot of functionality in the standard library. To use it, you have to import the respective modules into the programs. However, there is a set of commonly needed <em class="italic">traits</em>, <em class="italic">types</em>, and <em class="italic">functions</em> that Rust automatically imports into every Rust program, so the Rust programmer does not have to manually import them. This is <a id="_idIndexMarker211"/>called the <code>use std::prelude::v1::*</code> into Rust programs. This module re-exports frequently used Rust constructs.</p><p class="callout">The list of items exported by the <code>prelude</code> module includes traits, types, and functions including <code>Box</code>, <code>Copy</code>, <code>Send</code>, <code>Sync</code>, <code>drop</code>, <code>Clone</code>, <code>Into</code>, <code>From</code>, <code>Iterator</code>, <code>Option</code>,<code> Result</code>, <code>String</code>, and <code>Vec</code>. The list of modules re-exported can be found at <a href="https://doc.rust-lang.org/std/prelude/v1/index.html">https://doc.rust-lang.org/std/prelude/v1/index.html</a>.</p></li>
			</ul>
			<p>This concludes the overview of the Rust Standard Library modules. The Rust Standard Library is vast and is rapidly evolving. It is highly recommended that you review the official <a id="_idIndexMarker212"/>documentation at <a href="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a> with the understanding gained in this chapter, for specific methods, traits, data structures, and example snippets.</p>
			<p>Let's now move on to the next section where we will put this knowledge to use by writing some code.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/>Building a template engine</h1>
			<p>In this section, we <a id="_idIndexMarker213"/>will look at the design of an <strong class="bold">HTML template engine</strong> and implement one of the features using the Rust Standard Library.  Let's first understand what a template engine is.</p>
			<p>Applications such as web and mobile apps use structured data stored in datastores such as relational databases, NoSQL databases, and key-value stores. However, there is a lot of data on the web that is unstructured. One particular example is text data that all web pages contain. Web pages are generated as HTML files that have a text-based format.</p>
			<p>On observing closely, we can see that an HTML page has two parts: <em class="italic">static text literals</em> and <em class="italic">dynamic parts</em>. The HTML page is authored as a template with the static and dynamic parts, and the context for HTML generation comes from a data source. While generating a web page, the generator should take the static text and output it without change, while it should combine some processing and the supplied context to generate the dynamic string result. Generating HTML pages involves syscalls (to create, open, read, and write files) and computationally intensive in-memory string manipulations.</p>
			<p>A <strong class="bold">template engine</strong> is the system <a id="_idIndexMarker214"/>software component that can be used to generate dynamic HTML pages in a performant manner. It contains a combination of software components including parsers, tokenizers, generators, and template files.</p>
			<p><em class="italic">Figure 3.5</em> shows the process involved in generating HTML with a template engine:</p>
			<div><div><img src="img/Figure_3.5_B16405.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Generating HTML with templates</p>
			<p>To understand this better, let's <a id="_idIndexMarker215"/>take an example of an internet banking page showing a statement of transactions for a customer. This can be built using an HTML template, where:</p>
			<ul>
				<li>The static HTML includes the bank name, logo, other branding, and content that is <em class="italic">common to all users</em>.</li>
				<li>The dynamic portion of the web page contains the actual list of past transactions <em class="italic">for the logged-in user</em>. The transaction list varies from user to user.</li>
			</ul>
			<p>The advantage of this approach is the segregation of responsibilities in the web development life cycle:</p>
			<ul>
				<li> A <em class="italic">frontend (web) designer</em> can author the static HTML with sample data using web design tools.</li>
				<li>A <em class="italic">template designer</em> would convert the static HTML into an HTML template embedding the metadata for the dynamic portions of the page in specific syntax.</li>
				<li>At runtime (when the page request comes into the server), <em class="italic">the template engine</em> takes the template file from the specified location, applies the transaction list for the logged-in user from the database, and generates the final HTML page.</li>
			</ul>
			<p>Examples of popular <a id="_idIndexMarker216"/>template engines include <em class="italic">Jinja, Mustache, Handlebars, HAML, Apache Velocity, Twig</em>, and <em class="italic">Django</em>. There are differences in the architectures and syntax adopted by the various template engines.</p>
			<p>In this book, we will write the structure for a basic template engine that uses a syntax similar to <strong class="bold">Django templates</strong>. <em class="italic">Django</em> is a popular <a id="_idIndexMarker217"/>web framework in Python. Commercial templating engines such as that in <em class="italic">Django</em> are full-featured and complex. It will not be possible for us to recreate them completely in this chapter, but we will build the code structure and implement a representative feature.</p>
			<p class="callout-heading">Types of HTML template engines</p>
			<p class="callout">There are two <a id="_idIndexMarker218"/>types of HTML template engines, based on when the template data is parsed.</p>
			<p class="callout">The first type of template engines parse the HTML template and convert it into code, at compilation time. Then, at runtime, dynamic data is fetched and loaded into the compiled template. These tend to have better runtime performance as part of the work is done at compilation time.</p>
			<p class="callout">The second type of template engines do both the parsing of the template and HTML generation at runtime. We will be using this type in our project, as it is relatively simple to understand and implement.</p>
			<p>Let's begin with the design of an HTML template file.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/>Template syntax and design</h2>
			<p>A template is <a id="_idIndexMarker219"/>essentially a text file. A list of common features supported by a template file is shown here:</p>
			<ul>
				<li>Literals, for example, <code>&lt;h1&gt; hello world &lt;/h1&gt;</code></li>
				<li>Template variables surrounded by <code>{{</code> and <code>}}</code>, for example, <code>&lt;p&gt; {{name}} &lt;/p&gt;</code></li>
				<li>Control logic using an <code>if</code> tag, for example, <code>{% if amount &gt; 100000 %} {% endif %}</code></li>
				<li>Loop control with a <code>for</code> tag, for example, <code>&lt;ul&gt;{% for customer in customer_list}&lt;li&gt;{{customer.name}}&lt;/li&gt;{% endfor %}&lt;/ul&gt;</code></li>
				<li>Content import, for example, <code>{% include "footer.html" %}</code></li>
				<li>Filters, for example, <code>{{name | upper}}</code></li>
			</ul>
			<p><em class="italic">Figure 3.6</em> shows a sample template and the HTML generated from the template engine:</p>
			<div><div><img src="img/Figure_3.6_B16405.jpg" alt="Figure 3.6 – Conceptual model of the template engine"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Conceptual model of the template engine</p>
			<p>In <em class="italic">Figure 3.6</em>, we can <a id="_idIndexMarker220"/>see the following:</p>
			<ul>
				<li>On the left-hand side, a sample template file is shown. The template file is a mix of static and dynamic content. An example of static content is <code>&lt;h1&gt; Welcome to XYZ Bank &lt;/h1&gt;</code>. An example of dynamic content is <code>&lt;p&gt; Welcome {{name}} &lt;/p&gt;</code>, because the value for <code>name</code> will be substituted at runtime. There are three types of dynamic content shown in the template file – an <code>if</code> tag, a <code>for</code> tag, and a template variable.</li>
				<li>In the middle of the figure, we can see the template engine with two sources of inputs – template file and data source. The template engine takes these inputs and generates the output HTML file.</li>
			</ul>
			<p><em class="italic">Figure 3.7</em> explains the working of the template engine using an example:</p>
			<div><div><img src="img/Figure_3.7_B16405.jpg" alt="Figure 3.7 – Illustrated example for a template engine"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 3.7 – Illustrated example for a template engine</p>
			<p>From a design standpoint, the <a id="_idIndexMarker221"/>template engine has two parts:</p>
			<ul>
				<li>Parser</li>
				<li>HTML generator</li>
			</ul>
			<p>Let's start by understanding the steps involved in HTML generation using the template engine.</p>
			<p>The template file contains a set of statements. Some of these are static literals while others are placeholders for dynamic content represented using special syntax. The template engine reads each statement from the template file. Let's call each line read as a template string, henceforth. The process flow begins with the template string read from the template file:</p>
			<ol>
				<li>The template string is fed to the parser. The template string in our example is <code>&lt;p&gt; Welcome {{name}} &lt;/p&gt;</code>.</li>
				<li>The parser first determines the type of template string, which is called <code>if</code> tags, <code>for</code> tags, and template variables. In this example, a token of type template variable is generated (if the template string contains a static literal, it is written to the HTML output without any changes).</li>
				<li>Then the <a id="_idIndexMarker223"/>template string is parsed into a static literal, <code>Welcome</code>, and a template variable <code>{{name}}</code>.</li>
				<li>The outputs of the parser (from steps 2 and 3) are passed to the HTML generator.</li>
				<li>Data from a data source is passed as context by the template engine to the generator.</li>
				<li>The parsed token and strings (from steps 2 and 3) are combined with the context data (from <em class="italic">step 5</em>) to produce the result string, which is written to the output HTML file.</li>
			</ol>
			<p>The preceding steps are repeated for every statement (template string) read from the template file.</p>
			<p>We cannot use the parser we created for arithmetic parsing in <a href="B16405_02_Final_NM_ePUB.xhtml#_idTextAnchor041"><em class="italic">Chapter 2</em></a>, <em class="italic">A Tour of the Rust Programming Language</em>, for this example, as we need something specific for the HTML template language syntax. We could use the general-purpose parsing libraries (for example, <code>nom</code>, <code>pest</code>, and <code>lalrpop</code> are a few popular parsing libraries in Rust), but for this book, we will custom-build a template parser. The reason for this approach is that each parsing library has its own API and grammar that we need to familiarize ourselves with. Doing that would deviate from the goal of this book, which is learning to write idiomatic code in Rust from the first principles.</p>
			<p>First, let's create a new library project with the following:</p>
			<pre>cargo new –-lib template-engine</pre>
			<p>The <code>src/lib.rs</code> file (which is automatically created by the <code>cargo</code> tool) will contain all the functionality of the template engine.</p>
			<p>Create a new file, <code>src/main.rs</code>. The <code>main()</code> function will be placed in this file.</p>
			<p>Let's now design the code <a id="_idIndexMarker224"/>structure for the template engine. <em class="italic">Figure 3.8</em> shows the detailed design:</p>
			<div><div><img src="img/Figure_3.8_B16405.jpg" alt="Figure 3.8: Design of the template engine"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8: Design of the template engine</p>
			<p>Let's cover the key data structures and functions of the template engine along with some code snippets. We will start with the data structures.</p>
			<h3>Data structures</h3>
			<p><code>ContentType</code> is the main data structure to classify the <em class="italic">template string</em> read from the <em class="italic">template file</em>. It is <a id="_idIndexMarker225"/>represented as <code>enum</code> and contains the list of possible <code>ContentType</code> is as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>// Each line in input can be of one of following types
#[derive(PartialEq, Debug)]
pub enum ContentType {
    Literal(String),
    TemplateVariable(ExpressionData),
    Tag(TagType),
    Unrecognized,
}</pre>
			<p>Pay special attention to the annotations <code>PartialEq</code> and <code>Debug</code>. The former is used to allow content types to be compared, and the latter is used to print the values of the content to the console.</p>
			<p class="callout-heading">Derivable traits</p>
			<p class="callout">The Rust compiler can automatically derive default implementations for a few traits defined in the standard library. Such <a id="_idIndexMarker226"/>traits are called <em class="italic">derivable traits</em>. To instruct the compiler to provide default trait implementations, the <code>#[derive]</code> attribute is used. Note that this can be done only for types such as custom structs and enums that you have defined, not for types defined in other libraries that you don't own.</p>
			<p class="callout">Types for which trait implementations can be derived automatically include comparison traits such as <code>Eq</code>, <code>PartialEq</code>, and <code>Ord</code>, and others such as <code>Copy</code>, <code>Clone</code>, <code>Hash</code>, <code>Default</code>, and <code>Debug</code>.</p>
			<p><code>TagType</code> is a supporting data structure that is used to indicate whether a template string corresponds to a <code>for-tag</code> (repetitive loop) or <code>if-tag</code> (display control):</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>#[derive(PartialEq, Debug)]
pub enum TagType {
    ForTag,
    IfTag,
}</pre>
			<p>We will create a <a id="_idIndexMarker227"/>struct to store the result of the tokenization of the template string:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>#[derive(PartialEq, Debug)]
pub struct ExpressionData {
    pub head: Option&lt;String&gt;,
    pub variable: String,
    pub tail: Option&lt;String&gt;,
}</pre>
			<p>Note that <code>head</code> and <code>tail</code> are of type <code>Option&lt;String&gt;</code> to allow for the possibility that a template variable may not contain static literal text before or after it.</p>
			<p>To summarize, the template string is first tokenized as type <code>ContentType::TemplateVariable(ExpressionData)</code>, and <code>ExpressionData</code> is parsed into <code>head="Hello"</code>, <code>variable="name"</code>, and <code>tail =",welcome"</code>.</p>
			<h3>Key functions</h3>
			<p>Let's look at the key functions <a id="_idIndexMarker228"/>to implement the template engine:</p>
			<ul>
				<li><code>Program: main()</code>: This is the starting point of the program. It first calls functions to tokenize and parse the template string, accepts context data to feed into the template, and then calls functions to generate the HTML using the parser outputs and context data.</li>
				<li><code>Program: get_content_type()</code>: This is the entry point into the parser. It parses each line of the template file (which we refer to as the template string) and classifies it as one of the following token types: Literal, Template variable, Tag, or Unrecognized. The Tag token type can be either a <code>for</code> tag or an <code>if</code> tag. If the token is of type Template variable, it parses the template string to extract the head, tail, and template variable.<p>These types are <a id="_idIndexMarker229"/>defined as part of the <code>ContentType</code> enum. Let's write a few test cases to crystallize what we would like to see as inputs and outputs to this function, and then look at the actual <a id="_idIndexMarker230"/>code for <code>get_content_type()</code>. Let's take a <code>tests</code> module by adding the following block of code in <code>src/lib.rs</code>:</p><pre>#[cfg(test)]
mod tests {
    use super::*;
}</pre></li>
			</ul>
			<p>Place the unit tests within this <code>tests</code> module. Each test will begin with the annotation <code>#[test]</code>.</p>
			<p><strong class="bold">Test case 1</strong>: To check if the content type is a literal:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>    #[test]
    fn <strong class="bold">check_literal_test</strong>() {
        let s = "&lt;h1&gt;Hello world&lt;/h1&gt;";
        assert_eq!(ContentType::Literal(s.to_string()),     
            get_content_type(s));
    }</pre>
			<p>This test case is to check whether the literal string stored in variable <code>s</code> is tokenized as <code>ContentType::Literal(s)</code>.</p>
			<p><strong class="bold">Test case 2</strong>: To check if the content type is of the template variable type:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>    #[test]
    fn <strong class="bold">check_template_var_test</strong>() {
        let content = ExpressionData {
            head: Some("Hi ".to_string()),
            variable: "name".to_string(),
            tail: Some(" ,welcome".to_string()),
        };
        assert_eq!(
            ContentType::TemplateVariable(content),
            get_content_type("Hi {{name}} ,welcome")
        );
    }</pre>
			<p>For <a id="_idIndexMarker231"/>the <code>Template String</code> token type, this test case checks to see if the expression in the template string is parsed into the <code>head</code>, <code>variable</code>, and <code>tail</code> components, and successfully returned as type <code>ContentType::TemplateVariable (ExpressionData)</code>.</p>
			<p><code>ForTag</code>:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>    #[test]
    fn <strong class="bold">check_for_tag_test</strong>() {
        assert_eq!(
            ContentType::Tag(TagType::ForTag),
            get_content_type("{% for name in names %} 
                ,welcome")
        );
    }</pre>
			<p>This test <a id="_idIndexMarker232"/>case is to check if a statement containing a <code>for</code> tag is tokenized successfully as <code>ContentType::Tag(TagType::ForTag)</code>.</p>
			<p><code>IfTag</code>:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>    #[test]
    fn <strong class="bold">check_if_tag_test</strong>() {
        assert_eq!(
            ContentType::Tag(TagType::IfTag),
            get_content_type("{% if name == 'Bob' %}")
        );
    }</pre>
			<p>This test case is to check if a statement containing an <code>if</code> tag is tokenized successfully as <code>ContentType::Tag(TagType::IfTag)</code>.</p>
			<p>Now that we have written the unit test cases, let's write the code for the template engine.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor066"/>Writing the template engine</h2>
			<p>There are two key <a id="_idIndexMarker233"/>parts to writing the template engine – the parser and HTML generator. We will start with the parser. <em class="italic">Figure 3.9</em> shows the design of the parser:</p>
			<div><div><img src="img/Figure_3.9_B16405.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9: Parser design</p>
			<p>Here is a brief description of the various methods in the parser:</p>
			<ul>
				<li><code>get_content_type()</code>: Entry point for parser. Accepts an input statement and tokenizes it into one of an <code>if</code> tag, a <code>for</code> tag, or a template variable.</li>
				<li><code>check_symbol_string()</code>: This is a supporting method that checks if a symbol is present within another string. For example, we can check if the pattern <code>{%</code> is present in a statement from the template file, and use it to determine if it is a tag statement or template variable.</li>
				<li><code>check matching pair()</code>: This is a supporting method that is used to verify if a statement in a template file is syntactically correct. For example, we can check for the presence of matching pairs <code>{%</code> and <code>%}</code>. Otherwise, the statement is marked as <code>Unrecognized</code>.</li>
				<li><code>get_index_for_symbol()</code>: This method returns <a id="_idIndexMarker234"/>the starting index of a substring within another string. It is used for string manipulation.</li>
				<li><code>get_expression_data()</code>: This method parses a template string into its constituent parts for a token of type <code>TemplateString</code>.</li>
			</ul>
			<h3>Writing the parser</h3>
			<p>Let's first <a id="_idIndexMarker235"/>look at the <code>get_content_type()</code> method. Here is a summary of the program logic:</p>
			<ul>
				<li><code>for</code> tags are enclosed by <code>{%</code> and <code>%}</code> and contain the <code>for</code> keyword.</li>
				<li><code>if</code> tags are enclosed by <code>{%</code> and <code>%}</code> and contain the <code>if </code>keyword.</li>
				<li>Template variables are enclosed by <code>{{</code> and <code>}}</code>.</li>
			</ul>
			<p>Based on these rules, the statement is parsed and the appropriate token is returned – a <code>for</code> tag, an <code>if</code> tag, or a template variable.</p>
			<p>Here is the complete code listing for the <code>get_content_type()</code> function:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>pub fn<strong class="bold"> get_content_type</strong>(input_line: &amp;str) -&gt; ContentType {
    let is_tag_expression = check_matching_pair
        (&amp;input_line, "{%", "%}");
    let is_for_tag = (check_symbol_string(&amp;input_line, 
        "for")
        &amp;&amp; check_symbol_string(&amp;input_line, "in"))
        || check_symbol_string(&amp;input_line, "endfor");
    let is_if_tag =
        check_symbol_string(&amp;input_line, "if") || 
            check_symbol_string(&amp;input_line, "endif");
 
    let is_template_variable = check_matching_pair
        (&amp;input_line, "{{", "}}");
    let return_val;
 
    if is_tag_expression &amp;&amp; is_for_tag {
        return_val = ContentType::Tag(TagType::ForTag);
    } else if is_tag_expression &amp;&amp; is_if_tag {
        return_val = ContentType::Tag(TagType::IfTag);
    } else if is_template_variable {
        let content = get_expression_data(&amp;input_line);
        return_val = ContentType::TemplateVariable
            (content);
    } else if !is_tag_expression &amp;&amp; !is_template_variable {
        return_val = ContentType::Literal
            (input_line.to_string());
    } else {
        return_val = ContentType::Unrecognized;
    }
    return_val
}</pre>
			<h3>Supporting functions</h3>
			<p>Let's now talk <a id="_idIndexMarker236"/>about supporting functions. The parser utilizes these supporting functions to perform operations such as checking for the presence of a substring within a string, checking for matching pairs of braces, and so on. They are needed to check whether the template string is syntactically correct, and also to parse the template string into its constituent parts. Before writing some more code, let's look at the test cases for these supporting functions to understand how they will be used, and then see the code. Note that these functions are designed to enable reuse across projects. All supporting functions are placed in <code>src/lib.rs</code>:</p>
			<ul>
				<li><code>check_symbol_string()</code>: Checks if a symbol string, for example, <code>'{%'</code>, is contained within another string. Here is the test case:<pre>    #[test]
    fn <strong class="bold">check_symbol_string_test</strong>() {
        assert_eq!(true, check_symbol_string(
            "{{Hello}}", "{{"));
    }</pre><p>Here is the code for the function:</p><pre>pub fn check_symbol_string(input: &amp;str, symbol: &amp;str)  
    -&gt; bool {
    input.contains(symbol)
}</pre><p>The standard library provides a straightforward way to check for a substring within a string slice.</p></li>
				<li><code>check_matching_pair()</code>: This function checks for matching symbol strings. Here is the test case:<pre>    #[test]
    fn <code>'{{'</code> and <code>'}}'</code>, to this function, and check if both are contained within another string expression, <code>"{{Hello}}"</code>.</p><p>Here is the code for the function:</p><pre>pub fn check_matching_pair(input: &amp;str, symbol1: &amp;str, 
    symbol2: &amp;str) -&gt; bool {
    input.contains(symbol1) &amp;&amp; input.contains(symbol2)
}</pre><p>In this function, we are checking if the two matching tags are contained within the input string.</p></li>
				<li><code>get_expression_data()</code>: This parses an <a id="_idIndexMarker237"/>expression with a template variable, parses it into <code>head</code>, <code>variable</code>, and <code>tail</code> components, and returns the results. Here is the test case for this function:<pre>    #[test]
    fn <strong class="bold">check_get_expression_data_test</strong>() {
        let expression_data = ExpressionData {
            head: Some("Hi ".to_string()),
            variable: "name".to_string(),
            tail: Some(" ,welcome".to_string()),
        };
 
        assert_eq!(expression_data, 
            get_expression_data("Hi {{name}} 
            ,welcome"));
    }</pre><p>Here is the code for the function:</p><pre>pub fn <strong class="bold">get_expression_data</strong>(input_line: &amp;str) -&gt; 
    ExpressionData {
    let (_h, i) = get_index_for_symbol(input_line, 
    '{');
    let head = input_line[0..i].to_string();
    let (_j, k) = get_index_for_symbol(input_line, 
        '}');
    let variable = input_line[i + 1 + 1..k]
        .to_string();
    let tail = input_line[k + 1 + 1..].to_string();
 
    ExpressionData {
        head: Some(head),
        variable: variable,
        tail: Some(tail),
    }
}</pre></li>
				<li><code>get_index_for_symbol</code>: This function <a id="_idIndexMarker238"/>takes two parameters and returns the index where the second value is found within the first value. This makes it easy to split the template string into three parts – <code>head</code>, <code>variable</code>, and <code>tail</code>. Here is the test case:<pre>    #[test]
    fn <code>char_indices()</code> method on the slice available as part of the standard library, and converts the input <a id="_idIndexMarker239"/>string into an iterator that is capable of tracking indices. We then iterate over the input string and return the index of the symbol when found:</p><pre>pub fn <strong class="bold">get_index_for_symbol</strong>(input: &amp;str, symbol: char) 
    -&gt; (bool, usize) {
    let mut characters = input.char_indices();
    let mut does_exist = false;
    let mut index = 0;
    while let Some((c, d)) = characters.next() {
        if d == symbol {
            does_exist = true;
            index = c;
            break;
        }
    }
    (does_exist, index)
}</pre></li>
			</ul>
			<p>This concludes the code for the <code>Parser</code> module. Let's now look at the main function that ties all the pieces together.</p>
			<h3>The main() function</h3>
			<p>The <code>main()</code> function is the <a id="_idIndexMarker240"/>entry point into the template engine. <em class="italic">Figure 3.10</em> shows the design of the <code>main()</code> function:</p>
			<div><div><img src="img/Figure_3.10_B16405.jpg" alt="Figure 3.10: The main() function"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10: The main() function</p>
			<p>The <code>main()</code> function performs the coordination role tying all pieces together. It invokes the parser, initializes the context data, and then invokes the generator:</p>
			<ul>
				<li><code>HashMap</code> to pass <a id="_idIndexMarker241"/>values for the template variables mentioned in the template. We add values for <code>name</code> and <code>city</code> to this <code>HashMap</code>. The <code>HashMap</code> is passed to the generator function along with the parsed template input:<pre>    let mut context: HashMap&lt;String, String&gt; = 
        HashMap::new();
    context.insert("name".to_string(), 
        "Bob".to_string());
    context.insert("city".to_string(), 
        "Boston".to_string());</pre></li>
				<li><code>get_context_data()</code> function for each line of input read from the command line (standard input).<p>a) If the line contains template variable, it invokes the HTML generator <code>generate_html_template_var()</code> to create the HTML output.</p><p>b) If the line contains a literal string, it simply echoes back the input HTML literal string.</p><p>c) If the line contains <code>for</code> or <code>if</code> tags, right now, we simply print out a statement that the feature is not yet implemented. We will implement this in future chapters:</p><pre>    for line in io::stdin().lock().lines() {
        match get_content_type(&amp;line?.clone()) {
            ContentType::TemplateVariable(content) =&gt; {
                let html = generate_html_template_var
                    (content, context.clone());
                println!("{}", html);
            }
            ContentType::Literal(text) =&gt; println!
                ("{}", text),
            ContentType::Tag(TagType::ForTag) =&gt; 
                println!("For Tag not implemented"),
            ContentType::Tag(TagType::IfTag) =&gt; 
                println!("If Tag not implemented"),
            ContentType::Unrecognized =&gt; 
                println!("Unrecognized input"),
        }
    }</pre></li>
				<li><code>io::stdin()</code> function creates a new handle to the standard input of the current process. The standard input is read one line at a time using the following <code>for</code> loop, which is then passed on to the parser for processing:<pre>for line in io::stdin().lock().lines() {..}</pre></li>
			</ul>
			<p>Here is the complete code listing for the <code>main()</code> function:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/main.rs</p>
			<pre>use std::collections::HashMap;
use std::io;
use std::io::BufRead;
use template_engine::*;
 
fn main() {
    let mut context: HashMap&lt;String, String&gt; = 
        HashMap::new();
    context.insert("name".to_string(), "Bob".to_string());
    context.insert("city".to_string(),     
        "Boston".to_string());
 
    for line in io::stdin().lock().lines() {
        match get_content_type(&amp;line.unwrap().clone()) {
            ContentType::TemplateVariable(content) =&gt; {
                let html = generate_html_template_var
                    (content, context.clone());
                println!("{}", html);
            }
            ContentType::Literal(text) =&gt; println!("{}",    
                text),
            ContentType::Tag(TagType::ForTag) =&gt; 
                println!("For Tag not implemented"),
            ContentType::Tag(TagType::IfTag) =&gt; 
                println!("If Tag not implemented"),
            ContentType::Unrecognized =&gt; 
                println!("Unrecognized input"),
        }
    }
}</pre>
			<p>The implementation for the <code>generate_html_template_var()</code> function is shown here:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>use std::collections::HashMap;
pub fn <strong class="bold">generate_html_template_var</strong>(
    content: ExpressionData,
    context: HashMap&lt;String, String&gt;,
) -&gt; String {
    let mut html = String::new();
 
    if let Some(h) = content.head {
        html.push_str(&amp;h);
    }
 
    if let Some(val) = context.get(&amp;content.variable) {
        html.push_str(&amp;val);
    }
 
    if let Some(t) = content.tail {
        html.push_str(&amp;t);
    }
 
    html
}</pre>
			<p>This function constructs the output <code>html</code> statement consisting of <em class="italic">head</em>, <em class="italic">text content</em>, and <em class="italic">tail</em>. To construct <a id="_idIndexMarker245"/>the text content, the template variables are replaced with the values from the context data. The constructed <code>html</code> statement is returned from the function.</p>
			<p>The complete code from this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03</a>. </p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor067"/>Executing the template engine</h2>
			<p>We have, for now, the outline <a id="_idIndexMarker246"/>and foundations for a basic template engine that can deal with two kinds of input – static literals and template variables.</p>
			<p>Let's execute the program <a id="_idIndexMarker247"/>and run some tests:</p>
			<ol>
				<li value="1">Build and run the project with the following:<pre><strong class="bold">&gt;cargo run</strong></pre></li>
				<li><code>&lt;h2&gt; Hello, welcome to my page &lt;/h2&gt;</code>. You will see the same string printed out as there is no transformation to be done.</li>
				<li><code>&lt;p&gt; My name is {{name}} &lt;/p&gt;</code>  or <code>&lt;p&gt; I live in {{city}} &lt;/p&gt;</code>. You will see <code>&lt;p&gt; My name is Bob  &lt;/p&gt;</code> or <code>&lt;p&gt; I live in Boston &lt;/p&gt;</code> printed out corresponding to the input. This is because we initialized the variable <code>name</code> to <code>Bob</code> and <code>city</code> to <code>Boston</code> in the <code>main()</code> program. You are encouraged to enhance this code to add support for two template vars in a single HTML statement.</li>
				<li><code>{%</code> and <code>%}</code>, and containing either the string <code>for</code> or <code>if</code>. You will see one of the following messages printed out to the terminal: <code>For Tag not implemented</code> or <code>If Tag not implemented</code>.</li>
			</ol>
			<p>You are encouraged to write the code for the <code>for</code> tag and <code>if</code> tag as an exercise. Ensure to check for the right <a id="_idIndexMarker248"/>sequence of symbols. For example, an invalid format such as <code>{% for }%</code> or <code>%} if {%</code> should be rejected.</p>
			<p>Even though we are not able to implement more features of the template engine, in this chapter, we have seen how to use the Rust Standard Library in a real-life use case. We have primarily used the <code>io</code>, <code>collections</code>, <code>iter</code>, and<code> str</code> modules from the Rust Standard Library to implement the code in this chapter. As we go through future chapters, we will cover more of the standard library.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor068"/>Summary</h1>
			<p>In this chapter, we reviewed the overall structure of the Rust Standard Library and classified the modules of the standard library into different categories for better understanding. You got a brief introduction to the modules in areas of concurrency, memory management, file system operations, data processing, data types, error handling, compiler-related, FFI, networking, I/O, OS-specific, and time-related features.</p>
			<p>We looked at what a template engine is, how it works, and defined the scope and requirements of our project. We designed the template engine in terms of Rust data structures (enum and struct) and Rust functions. We saw how to write code for parsing templates and to generate HTML for statements involving template variables. We executed the program providing input data and verified the generated HTML in the terminal (command line).</p>
			<p>In the next chapter, we will take a closer look at the Rust Standard Library modules that deal with managing process environment, command-line arguments, and time-related functionality.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor069"/>Further reading</h1>
			<ul>
				<li><strong class="bold">Django template language</strong>: <a href="https://docs.djangoproject.com/en/3.0/ref/templates/language/">https://docs.djangoproject.com/en/3.0/ref/templates/language/</a></li>
				<li><strong class="bold">Rust Standard Library</strong>: <a href="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a></li>
			</ul>
		</div>
	</body></html>