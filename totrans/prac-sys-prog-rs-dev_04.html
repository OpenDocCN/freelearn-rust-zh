<html><head></head><body>
		<div id="_idContainer032">
			<h1 id="_idParaDest-56"><em class="italic"><a id="_idTextAnchor056"/>Chapter 3</em>: <a id="_idTextAnchor057"/>Introduction to the Rust Standard Library</h1>
			<p>In the previous chapter, we built a command-line tool using various Rust language primitives and modules from the Rust Standard Library. However, in order to fully exploit the power of Rust, it is imperative to understand the breadth of what features are available within the standard library for system programming tasks, without having to reach out to third-party crates.</p>
			<p>In this chapter, we'll deep-dive into the structure of the Rust Standard Library. You'll get an introduction to the standard modules for accessing system resources and learn how to manage them programmatically. With the knowledge gained, we will implement a tiny portion of a template engine in Rust. By the end of this chapter, you will be able to confidently navigate the Rust Standard Library and make use of it in your projects.</p>
			<p>The following are the key learning outcomes for this chapter:</p>
			<ul>
				<li>Introducing the Rust Standard Library</li>
				<li>Writing one feature of a template engine using the standard library modules</li>
			</ul>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor058"/>Technical requirements</h1>
			<p>Rustup and Cargo must be installed in your local development environment. The GitHub repository for the examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03</a>.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor059"/>The Rust Standard Library and systems programming</h1>
			<p>Before we dive <a id="_idIndexMarker175"/>into the standard library, let's understand the context of how it fits into systems programming.</p>
			<p>In systems programming, one of the cardinal requirements is to manage system resources such as memory, files, network I/O, devices, and processes. Every operating system has a kernel (or equivalent), which is the central software module that is loaded in memory and connects the system hardware with the application processes. You may think, where does the Rust Standard Library fit in then? Are we going to write a kernel in Rust? No, that's not the purpose of this book. The most popular operating systems, which are basically the Unix, Linux, and Windows variants, all have kernels written mostly in <strong class="bold">C</strong> with a mix of assembly. It is still early days for Rust to augment C as the kernel development language, though there are several experimental efforts in that direction. However, what <a id="_idIndexMarker176"/>the Rust Standard Library offers is an API interface to make system calls from Rust programs, in order to manage and manipulate various system resources. The following figure shows this context:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_3.1_B16405.jpg" alt="Figure 3.1 – Rust Standard Library"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Rust Standard Library</p>
			<p>Let's walk through this figure to understand each of the components better:</p>
			<ul>
				<li><strong class="bold">Kernel</strong>: The kernel is the central component of an operating system that manages <a id="_idIndexMarker177"/>system resources such as memory, disk and file systems, CPU, network, and ot<a id="_idTextAnchor060"/>her devices such as the mouse, keyboard, and monitors. User programs (for example, a <em class="italic">command-line tool</em> or <em class="italic">text editor</em>) cannot manage system resources directly. They have to rely on the kernel to perform operations. If a text editor program wants to read a file, it will have to make a corresponding system call, <strong class="source-inline">read()</strong>, which the kernel will then execute on behalf of the editor program. The reason for this restriction is that modern processor architectures (such as x86-64) allow the CPU to operate at two different privilege levels—<em class="italic">kernel mode</em> and <em class="italic">user mode</em>. The user mode has a lower level of privilege than the kernel mode. The CPU can perform certain operations only while running in the kernel mode. This design prevents user programs from accidentally doing tasks that could adversely affect the system operation.</li>
				<li><strong class="bold">System call (syscall) interface</strong>: The kernel also <a id="_idIndexMarker178"/>provides a system call <em class="italic">application programming interface</em> that acts as the entry point for processes to request the kernel to perform various tasks.</li>
				<li><strong class="bold">Syscall wrapper APIs</strong>: A user program cannot directly make a system call in the way normal functions are <a id="_idIndexMarker179"/>called because they cannot be resolved by the linker. So, architecture-specific assembly language code is needed to make system calls into the kernel. Such code is made available through wrapper libraries, which are platform-specific. For Unix/Linux/POSIX systems, this library is <strong class="source-inline">libc</strong> (or <strong class="source-inline">glibc</strong>). For the Windows operating system, there are equivalent APIs.</li>
				<li><strong class="bold">Rust Standard Library</strong>: The Rust Standard Library is the primary interface for Rust programs into the kernel <a id="_idIndexMarker180"/>functions of an operating system. It uses <strong class="source-inline">libc</strong> (or another platform-specific equivalent library) internally to invoke system calls. The Rust Standard Library is cross-platform, which means that the details of how system calls are invoked (or which wrapper libraries are used) are abstracted away from the Rust developer. There are ways to invoke system calls from Rust code without using the standard library (for example, in embedded systems development), but that is beyond the scope of this book.</li>
				<li><strong class="bold">User space programs</strong>: These are the programs that you will write as part of this book using the <a id="_idIndexMarker181"/>standard library. The <em class="italic">arithmetic expression evaluator</em> you wrote in the previous chapter is an example of this. In this chapter, you will learn how to write a feature of the template engine using the standard library, which is also a user space program.<p class="callout-heading">Note</p><p class="callout">Not all modules and functions within the Rust Standard Library invoke system calls (for example, there are methods for string manipulation, and to handle errors). As we go through the standard library, it is important to remember this distinction.</p></li>
			</ul>
			<p>Let's now begin our journey to understand and start using the Rust Standard Library.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor061"/>Exploring the Rust Standard Library</h1>
			<p>We earlier discussed the <a id="_idIndexMarker182"/>role of the Rust Standard Library in enabling user programs to invoke kernel operations. The following are some of the notable features of the standard library, which we will refer to as <strong class="source-inline">std</strong> for brevity:</p>
			<ul>
				<li><strong class="source-inline">std</strong> is cross-platform. It provides functionality that hides the differences among underlying platform architectures.</li>
				<li><strong class="source-inline">std</strong> is available to all Rust crates by default. The <strong class="source-inline">use</strong> statement gives access to the respective modules and their constituents (traits, methods, structs, and so on). For example, the statement <strong class="source-inline">use std::fs</strong> gives access to the module providing file manipulation operations.</li>
				<li><strong class="source-inline">std</strong> includes operations on standard Rust primitives (such as integers and floating-point numbers). For example, <strong class="source-inline">std::i8::MAX</strong> is a constant implemented in the standard library that specifies the maximum value that can be stored in a variable of type i8.</li>
				<li>It implements core data types such as <em class="italic">vector, strings</em>, and <em class="italic">smart pointers</em> such as <strong class="source-inline">Box</strong>, <strong class="source-inline">Rc</strong>, and <strong class="source-inline">Arc</strong>.</li>
				<li>It provides functionality for operations such as data manipulation, memory allocation, error <a id="_idIndexMarker183"/>handling, networking, I/O, concurrency, async I/O primitives, and foreign function interfaces.</li>
			</ul>
			<p>The following figure shows a <a id="_idIndexMarker184"/>high-level view of the Rust standard library:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_3.2_B16405.jpg" alt="Figure 3.2 – Rust Standard Library – high-level view"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Rust Standard Library – high-level view</p>
			<p>The Rust Standard Library (<strong class="source-inline">std</strong>) is broadly organized as follows:</p>
			<ul>
				<li><strong class="bold">Rust language primitives</strong>, which contain basic types such as signed and unsigned, integers, bool, floating point, char, array, tuple, slice, and string. Primitives are implemented by the compiler. The Rust Standard Library includes the primitives and builds on top of them.</li>
				<li>The <strong class="bold">core crate</strong> is the foundation of the Rust Standard Library. It acts as the link between the Rust language and the standard library. It provides types, traits, constants, and functions implemented on top of Rust primitives, and provides the foundational building blocks for all Rust code. The core crate can be used independently, is not platform-specific, and does not have any links to operating system libraries (such as <strong class="source-inline">libc</strong>) or other external dependencies. You can instruct the compiler to compile without the Rust Standard Library and use the core crate instead (such an environment is called <strong class="source-inline">no_std</strong> in Rust parlance, which is annotated with the <strong class="source-inline">#![no_std]</strong> attribute), and this is used commonly in embedded programming.</li>
				<li>The <strong class="bold">alloc crate</strong> contains types, functions, and traits related to memory allocation for heap-allocated values. It includes smart pointer types such as Box (<strong class="source-inline">Box&lt;T&gt;</strong>), reference-counted pointers (<strong class="source-inline">Rc&lt;T&gt;</strong>), and atomically reference-counted pointers (<strong class="source-inline">Arc&lt;T&gt;</strong>). It also includes and collections such as <strong class="source-inline">Vec</strong> and <strong class="source-inline">String</strong> (note that <strong class="source-inline">String</strong> is implemented in Rust as a UTF-8 sequence). This crate does not <a id="_idIndexMarker185"/>need to be used directly when the standard library is used, as the contents of the <strong class="source-inline">alloc</strong> crate are re-exported and made available as part of the <strong class="source-inline">std</strong> library. The only exception to this rule is when developing in a <strong class="source-inline">no_std</strong> environment, when this crate can be directly used to access its functionality.</li>
				<li><strong class="bold">Modules</strong> (libraries) that are directly part of the standard library (and not re-exported from <strong class="source-inline">core</strong> or <strong class="source-inline">alloc</strong> crates) include rich functionality for operations around concurrency, I/O, file system access, networking, async I/O, errors, and OS-specific functions.</li>
			</ul>
			<p>In this book, we will not directly work with the <strong class="source-inline">core</strong> or <strong class="source-inline">alloc</strong> crates, but use the Rust Standard Library modules that are a higher-level abstraction over these crates.</p>
			<p>We will now analyze the key modules within the Rust Standard Library with a focus on systems programming. The standard library is organized into modules. For example, the functionality that enables user programs to run on multiple threads for concurrency is in the <strong class="source-inline">std::thread</strong> module, and the Rust constructs for dealing with synchronous I/O are in the <strong class="source-inline">std::io</strong> module. Understanding how the functionality within the standard library is organized across modules is a critical part of being an effective and productive Rust programmer.</p>
			<p><em class="italic">Figure 3.3</em> shows the <a id="_idIndexMarker186"/>layout of the standard library modules organized into groups:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_3.3_B16405.jpg" alt="Figure 3.3 – Rust Standard Library modules"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Rust Standard Library modules</p>
			<p>The modules in this figure have been grouped by their primary area of focus.</p>
			<p>How do we know, though, which of these modules is related to managing system resources? As this might be of interest for the purposes of this book, let's attempt to classify the modules further into one of these two buckets:</p>
			<ul>
				<li><strong class="bold">Syscalls-oriented</strong>: These are modules <a id="_idIndexMarker187"/>that either manage <a id="_idIndexMarker188"/>system hardware resources directly or require the kernel for other privileged operations.</li>
				<li><strong class="bold">Computation-oriented</strong>: These are the <a id="_idIndexMarker189"/>modules that are <a id="_idIndexMarker190"/>oriented towards data representation, computation, and instructions to the compiler. </li>
			</ul>
			<p><em class="italic">Figure 3.4</em> shows the same module grouping as in <em class="italic">Figure 3.3</em> but segregated as <strong class="bold">Syscalls-oriented</strong> or <strong class="bold">Computation-oriented</strong>. Note that this may not be a perfect classification as not all methods in all modules marked in the <strong class="bold">Syscalls-oriented</strong> category involve actual system calls. But this classification can serve as a guide to find our way around <a id="_idIndexMarker191"/>the standard library:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_3.4_B16405.jpg" alt="Figure 3.4 – Rust modules with classification"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Rust modules with classification</p>
			<p>Let's get to know the functionality of each module.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>Computation-oriented modules</h2>
			<p>The standard library modules in this section deal <em class="italic">mostly</em> with programming constructs that deal with data <a id="_idIndexMarker192"/>processing, data modeling, error handling, and instructions to the compiler. Some of the modules may have functionality that overlaps with the syscalls-oriented category, but this grouping is based on the primary focus of each module.</p>
			<h3>Data types</h3>
			<p>The modules <a id="_idIndexMarker193"/>related to data types and structures in the Rust Standard Library are mentioned in this section. There are broadly two categories of data types in Rust. The first group comprises primitive types such as integers (signed, unsigned), floating points, and char, which are a core part of the language and compiler and the standard library adds additional functionality to those types. The second group consists of higher-level data structures and traits such as vectors and strings, which are implemented within the standard library. Modules from both these groups are listed here:</p>
			<ul>
				<li><strong class="source-inline">any</strong>: This can be used when the type of the value passed to a function is not known at compile time. Runtime reflection is used to check the type and perform suitable processing. An example of using this would be in the logging function, where we want to customize what is logged depending on the data type.</li>
				<li><strong class="source-inline">array</strong>: It contains utility functions such as comparing arrays, implemented over the primitive array type. Note that Rust arrays are value types, that is, they are allocated on the stack, and have a fixed length (not growable).</li>
				<li><strong class="source-inline">char</strong>: This contains utility functions implemented over the <strong class="source-inline">char</strong> primitive type, such as checking for digits, converting to uppercase, encoding to UTF-8, and so on.</li>
				<li><strong class="source-inline">collections</strong>: This is Rust's standard collection library, which contains efficient implementations of common collection data structures used in programming. Collections in this library include <strong class="source-inline">Vectors</strong>, <strong class="source-inline">LinkedLists</strong>, <strong class="source-inline">HashMaps</strong>, <strong class="source-inline">HashSet</strong>, <strong class="source-inline">BTtreeMap</strong>, <strong class="source-inline">BTreeSet</strong>, and <strong class="source-inline">BinaryHeap</strong>.</li>
				<li><strong class="source-inline">f32</strong>, <strong class="source-inline">f64</strong>: This library provides constants specific to floating point implementations of the <strong class="source-inline">f32</strong> and <strong class="source-inline">f64</strong> primitive types. Examples of constants are <strong class="source-inline">MAX</strong> and <strong class="source-inline">MIN</strong>, which provide the maximum and minimum value of floating point numbers that can be stored by <strong class="source-inline">f32</strong> and <strong class="source-inline">f64</strong> types.</li>
				<li><strong class="source-inline">i8</strong>, <strong class="source-inline">i16</strong>, <strong class="source-inline">i32</strong>, <strong class="source-inline">i64</strong>, <strong class="source-inline">i128</strong>: Signed integer types of various sizes. For example, <strong class="source-inline">i8</strong> represents a signed integer of length 8 bits (1 byte) and <strong class="source-inline">i128</strong> represents a signed integer of length 128 bits (16 bytes).</li>
				<li><strong class="source-inline">u8</strong>, <strong class="source-inline">u16</strong>, <strong class="source-inline">u32</strong>, <strong class="source-inline">u64</strong>, <strong class="source-inline">u128</strong>: Unsigned integer types of various sizes. For example, <strong class="source-inline">u8</strong> represents an unsigned integer of length 8 bits (1 byte) and <strong class="source-inline">u128</strong> represents an unsigned integer of length 128 bits (16 bytes).</li>
				<li><strong class="source-inline">isize</strong>, <strong class="source-inline">usize</strong>: Rust has two data types, <strong class="source-inline">isize</strong> and <strong class="source-inline">usize</strong>, that correspond to signed and unsigned integer types. The uniqueness of these types is that their size is <a id="_idIndexMarker194"/>dependent on whether the CPU uses a 32-bit or 64-bit architecture. For example, on a 32-bit system, the size of the <strong class="source-inline">isize</strong> and <strong class="source-inline">usize</strong> data types is 32 bits (4 bytes), and likewise, for 64-bit systems, their size is 64 bits (8 bytes).</li>
				<li><strong class="source-inline">marker</strong>: Basic properties that can be attached to types (in the form of traits) are described in this module. Examples include <strong class="source-inline">Copy</strong> (types whose values can be duplicated by a simple copy of its bits) and <strong class="source-inline">Send</strong> (thread-safe types).</li>
				<li><strong class="source-inline">slice</strong>: Contains structs and methods useful to perform operations such as <strong class="source-inline">iterate</strong> and <strong class="source-inline">split</strong> on <strong class="source-inline">slice</strong> data types.</li>
				<li><strong class="source-inline">string</strong>: This module contains the <strong class="source-inline">String</strong> type and methods such as <strong class="source-inline">to_string</strong>, which allows converting a value to a <strong class="source-inline">String</strong>. Note that <strong class="source-inline">String</strong> is not a primitive data type in Rust. The primitive types in Rust are listed here: <a href="https://doc.rust-lang.org/std/">https://doc.rust-lang.org/std/</a>.</li>
				<li><strong class="source-inline">str</strong>: This module contains structs and methods associated with string slices such as <strong class="source-inline">iterate</strong> and <strong class="source-inline">split</strong> on <strong class="source-inline">str</strong> slices.</li>
				<li><strong class="source-inline">vec</strong>: This module contains the <strong class="source-inline">Vector</strong> type, which is a growable array with heap-allocated contents, and associated methods for operating on vectors such as splicing and iterating. A <strong class="source-inline">vec</strong> module is an owned reference and a smart pointer (such as <strong class="source-inline">Box&lt;T&gt;</strong>). Note that <strong class="source-inline">vec</strong> was originally defined in the <strong class="source-inline">alloc</strong> crate, but was made available as part of both the <strong class="source-inline">std::vec</strong> and <strong class="source-inline">std::collections</strong> modules.</li>
			</ul>
			<h3>Data processing</h3>
			<p>This is an assorted collection of modules that provides helper methods for different types of <a id="_idIndexMarker195"/>processing such as dealing with ASCII characters, comparing, ordering, and printing formatted values, arithmetic operations, and iterators:</p>
			<ul>
				<li><strong class="source-inline">ascii</strong>: Most string operations in Rust act on UTF-8 strings and characters. But in some cases, there may be a need to operate on ASCII characters only. This module provides operations on ASCII strings and characters.</li>
				<li><strong class="source-inline">cmp</strong>: This module contains functions for ordering and comparing values, and associated macros. For example, implementing the <strong class="source-inline">Eq</strong> trait contained in this module allows a comparison of custom struct instances using the <strong class="source-inline">==</strong> and <strong class="source-inline">!=</strong> operators.</li>
				<li><strong class="source-inline">fmt</strong>: This module contains utilities to format and print strings. Implementing this trait enables printing any custom data type using the <strong class="source-inline">format!</strong> macro.</li>
				<li><strong class="source-inline">hash</strong>: This module provides functionality to compute a hash of data objects.</li>
				<li><strong class="source-inline">iter</strong>: This module contains the <strong class="source-inline">Iterator</strong> trait, which is part and parcel of idiomatic Rust code, and a popular feature of Rust. This trait can be implemented by custom data types for iterating over their values.</li>
				<li><strong class="source-inline">num</strong>: This module provides additional data types for numeric operations.</li>
				<li><strong class="source-inline">ops</strong>: This module has a set of traits that allow you to overload operators for custom data types. For example, the <strong class="source-inline">Add</strong> trait can be implemented for a custom struct and the <strong class="source-inline">+</strong> operator can be used to add two structs of that type.</li>
			</ul>
			<h3>Error handling</h3>
			<p>This group consists of <a id="_idIndexMarker196"/>modules that have functionality for error handling in Rust programs. The <strong class="source-inline">Error</strong> trait is the foundational construct to represent errors. <strong class="source-inline">Result</strong> deals with the presence or absence of errors in the return value of functions, and <strong class="source-inline">Option</strong> deals with the presence or absence of values in a variable. The latter prevents the dreaded <em class="italic">null value</em> error that plagues several programming languages. <strong class="source-inline">Panic</strong> is provided as a way to exit the program if errors cannot be handled:</p>
			<ul>
				<li><strong class="source-inline">error</strong>: This module contains the <strong class="source-inline">Error</strong> trait, which represents the basic expectations of error values. All errors implement the trait <strong class="source-inline">Error</strong>, and this module is used to implement custom or application-specific error types.</li>
				<li><strong class="source-inline">option</strong>: This module contains the <strong class="source-inline">Option</strong> type, which provides the ability for a value to be initialized to either <strong class="source-inline">Some</strong> value or <strong class="source-inline">None</strong> value. The <strong class="source-inline">Option</strong> type can be considered as a very basic way to handle errors involving the absence of values. Null values cause havoc in other programming languages in the form of null pointer exceptions or the equivalent.</li>
				<li><strong class="source-inline">panic</strong>: This module provides support to deal with panic including capturing the cause of panic and setting hooks to trigger custom logic on panic.</li>
				<li><strong class="source-inline">result</strong>: This module contains the <strong class="source-inline">Result</strong> type, which along with the <strong class="source-inline">Error</strong> trait and <strong class="source-inline">Option</strong> type form the foundation of error handling in Rust. <strong class="source-inline">Result</strong> is represented as <strong class="source-inline">Result&lt;T,E&gt;</strong>, which is used to return either values or errors from functions. Functions return the <strong class="source-inline">Result</strong> type whenever errors are expected and if the error is recoverable.</li>
			</ul>
			<h3>Foreign function interface (FFI)</h3>
			<p>FFI is <a id="_idIndexMarker197"/>provided by the <strong class="source-inline">ffi</strong> module. This module <a id="_idIndexMarker198"/>provides utilities to exchange data across non-Rust interface boundaries, such as working with other programming languages or to deal directly with the underlying operating system/kernel.</p>
			<h3>Compiler</h3>
			<p>This group contains <a id="_idIndexMarker199"/>modules that are related to the Rust compiler. </p>
			<ul>
				<li><strong class="source-inline">hint</strong>: This module contains functions to hint to the compiler about how code should be emitted or optimized.</li>
				<li><strong class="source-inline">prelude</strong>: The prelude is the list of items that Rust automatically imports into each Rust program. It is a convenience feature.</li>
				<li><strong class="source-inline">primitive</strong>: This module re-exports Rust primitive types, normally for use in macro code.</li>
			</ul>
			<p>We've so far seen the <strong class="bold">computation-oriented</strong> modules of the Rust standard library. Let's take a look at the <strong class="bold">syscalls-oriented</strong> modules now.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor063"/>Syscalls-oriented modules</h2>
			<p>While the previous <a id="_idIndexMarker200"/>group of modules was related to in-memory computations, this section deals with operations that involve managing hardware resources or other privileged operations that <em class="italic">normally</em> require kernel intervention. Note that not all methods in these modules involve system calls to the kernel, but it helps to construct a mental model at the module level.</p>
			<h3>Memory management</h3>
			<p>This grouping contains a set of modules from the standard library that deal with memory <a id="_idIndexMarker201"/>management and smart pointers. Memory management includes static memory allocation (on the stack), dynamic memory allocation (on the heap), memory deallocation (when a variable goes out of scope, its destructor is run), cloning or copying values, managing raw pointers and smart pointers (which are pointers to data on the heap), and fixing memory locations for objects so that they cannot be moved around (which is needed for special situations). The modules are as follows:</p>
			<ul>
				<li><strong class="source-inline">alloc</strong>: This module contains APIs for the allocation and deallocation of memory, and to register a custom or third-party memory allocator as the standard library's default.</li>
				<li><strong class="source-inline">borrow</strong>: In Rust, it is common to use different representations of a given type for different use cases. For example, a value can be stored and managed as <strong class="source-inline">Box&lt;T&gt;</strong>, <strong class="source-inline">Rc&lt;T&gt;</strong>, or <strong class="source-inline">Arc&lt;T&gt;</strong>. Similarly, a string value can be stored as the <strong class="source-inline">String</strong> or <strong class="source-inline">str</strong> type. Rust provides methods that allow one type to be borrowed as some other type, by implementing the <strong class="source-inline">borrow</strong> method from the <strong class="source-inline">Borrow</strong> trait. So basically, a type is free to be borrowed as many different types. This module contains the trait <strong class="source-inline">Borrow</strong>, which allows the conversion of an owned value to borrowed or to convert borrowed data of any type to an owned value. For example, a value of type <strong class="source-inline">String</strong> (which is an owned type) can be borrowed as <strong class="source-inline">str</strong>.</li>
				<li><strong class="source-inline">cell</strong>: In Rust, memory safety is based on the rule that a value can have either several immutable references to it or a single mutable reference. But there may be scenarios where a shared, mutable reference is required. This module provides shareable mutable containers that include <strong class="source-inline">Cell</strong> and <strong class="source-inline">RefCell</strong>. These types provide controlled mutability of shared types.</li>
				<li><strong class="source-inline">clone</strong>: In Rust, primitive types such as integers are <em class="italic">copyable</em>, that is, they implement the <strong class="source-inline">Copy</strong> trait. This means that when assigning the value of a variable <a id="_idIndexMarker202"/>to another variable or while passing a parameter to a function, the value of the object is duplicated. But not all types can be copied, because they may require memory allocations (for example, <strong class="source-inline">String</strong> or <strong class="source-inline">Vec</strong> types where memory is allocated in the heap, rather than the stack). In such cases, a <strong class="source-inline">clone()</strong> method is used to duplicate a value. This module provides the <strong class="source-inline">Clone</strong> trait, which allows values of custom data types to be duplicated.</li>
				<li><strong class="source-inline">convert</strong>: This module contains functionality to facilitate the conversion between data types. For example, by implementing the <strong class="source-inline">AsRef</strong> trait contained in this module, you can write a function that takes a parameter of type <strong class="source-inline">AsRef&lt;str&gt;</strong>, which means that this function can accept any reference that can be converted into a string reference (<strong class="source-inline">&amp;str</strong>). Since both the <strong class="source-inline">str</strong> and <strong class="source-inline">String</strong> types implement the <strong class="source-inline">AsRef</strong> trait, you can pass either a <strong class="source-inline">String</strong> reference (<strong class="source-inline">String</strong>) or string slice reference (<strong class="source-inline">&amp;str</strong>) to this function.</li>
				<li><strong class="source-inline">default</strong>: This module has the trait <strong class="source-inline">Default</strong>, which is used to assign meaningful default values for data types.</li>
				<li><strong class="source-inline">mem</strong>: This module contains memory-related functions including querying memory size, initialization, swapping, and other memory manipulation operations.</li>
				<li><strong class="source-inline">pin</strong>: Types in Rust are movable, by default. For example, on a <strong class="source-inline">Vec</strong> type, a <strong class="source-inline">pop()</strong> operation moves a value out and a push operation may result in the reallocation of memory. However, there are situations where it is useful to have objects that have fixed memory locations and do not move. For example, self-referencing data structures such as linked lists. For such cases, Rust provides a data type that pins data to a location in memory. This is achieved by wrapping a type in the pinned pointer, <strong class="source-inline">Pin&lt;P&gt;</strong>, which pins the value <strong class="source-inline">P</strong> in its place in memory.</li>
				<li><strong class="source-inline">ptr</strong>: Working <a id="_idIndexMarker203"/>with raw pointers in Rust is not common, and is used only in selective use cases. Rust allows working with raw pointers in unsafe code blocks, where the compiler does not take responsibility for memory safety and the programmer is responsible for memory-safe operations. This module provides functions to work with raw pointers. Rust supports two types of raw pointers—immutable (for example, <strong class="source-inline">*const i32</strong>) and mutable (for example, <strong class="source-inline">*mut i32</strong>). Raw pointers have no restrictions on how they are used. They are the only pointer type in Rust that can be null, and there is no automatic dereferencing of raw pointers.</li>
				<li><strong class="source-inline">rc</strong>: This module provides single-threaded reference-counting pointers, where <strong class="source-inline">rc</strong> stands for reference-counted. A reference-counted pointer to an object of type <strong class="source-inline">T</strong> can be represented as <strong class="source-inline">Rc&lt;T&gt;</strong>. <strong class="source-inline">Rc&lt;T&gt;</strong> provides shared ownership of value <strong class="source-inline">T</strong>, which is allocated in the heap. If a value of this type is cloned, it returns a new pointer to the same memory location in the heap (does not duplicate the value in memory). This value is retained until the last <strong class="source-inline">Rc</strong> pointer that references this value is in existence, after which the value is dropped.</li>
			</ul>
			<h3>Concurrency</h3>
			<p>This <a id="_idIndexMarker204"/>category groups modules related to synchronous concurrent processing. Concurrent programs can be designed in Rust by spawning processes, spawning threads within a process, and having ways to synchronize and share data across threads and processes. Asynchronous concurrency is covered under the <strong class="source-inline">Async</strong> group.</p>
			<ul>
				<li><strong class="source-inline">env</strong>: This module allows inspecting and manipulating a process's environment, including environment variables, the arguments of a process, and paths. This module could belong to its own category as it is widely used beyond just concurrency, but it is grouped here along with the <strong class="source-inline">process</strong> module because this module is designed to work with a <em class="italic">process</em> (for example, getting and setting the environment variables of a process or getting the command-line parameters used to start a process).</li>
				<li><strong class="source-inline">process</strong>: This module provides functions for dealing with processes including spawning a new process, handling I/O, and terminating processes.</li>
				<li><strong class="source-inline">sync</strong>: The sequence of instructions executed in a Rust program may vary in cases where concurrency is involved. In such cases, there may be multiple threads of execution in parallel (for example, multiple threads in a multi-core CPU), in which case synchronization primitives are needed to coordinate operations across threads. This module includes synchronization primitives such as <strong class="source-inline">Arc</strong>, <strong class="source-inline">Mutex</strong>, <strong class="source-inline">RwLock</strong>, and <strong class="source-inline">Condvar</strong>.</li>
				<li><strong class="source-inline">thread</strong>: Rust's threading model consists of native OS threads. This module provides functionality to work with threads such as spawning new threads, and configuring, naming, and synchronizing them.</li>
			</ul>
			<h3>File system</h3>
			<p>This contains two modules that deal with filesystem operations. The <strong class="source-inline">fs</strong> module deals with <a id="_idIndexMarker205"/>methods for working with and manipulating the contents of the local file system. The <strong class="source-inline">path</strong> module provides methods to navigate and manipulate directory and file system paths programmatically:</p>
			<ul>
				<li><strong class="source-inline">fs</strong>: This module contains operations to work with and manipulate file systems. Note that operations in this module can be used cross-platform. Structs and methods in this module deal with files, naming, file types, directories, file metadata, permissions, and iterating over entries in a directory.</li>
				<li><strong class="source-inline">path</strong>: This module provides the types <strong class="source-inline">PathBuf</strong> and <strong class="source-inline">Path</strong> for working with and manipulating paths.</li>
			</ul>
			<h3>Input-Output</h3>
			<p>This contains the <strong class="source-inline">io</strong> module, <a id="_idIndexMarker206"/>which provides core I/O functionality. The <strong class="source-inline">io</strong> module contains common functions that are used while dealing with inputs and outputs. This includes reading and writing to I/O types, such as files or TCP streams, buffered reads and writes for better performance, and working with standard input and output.</p>
			<h3>Networking</h3>
			<p>The core networking <a id="_idIndexMarker207"/>functionality is provided by the <strong class="source-inline">net</strong> module. This module contains the primitives for TCP and UDP communications and for working with ports and sockets.</p>
			<h3>OS-specific</h3>
			<p>The OS-specific functions are <a id="_idIndexMarker208"/>provided in the <strong class="source-inline">os</strong> module. This module contains platform-specific definitions and extensions for the Linux, Unix, and Windows operating systems.</p>
			<h3>Time</h3>
			<p>The <strong class="source-inline">time</strong> module provides <a id="_idIndexMarker209"/>functions to work with system time. This module contains structs to deal with system time and to compute durations, typically used for system timeouts.</p>
			<h3>Async</h3>
			<p>Asynchronous I/O functionality is <a id="_idIndexMarker210"/>provided by the <strong class="source-inline">future</strong> and <strong class="source-inline">task</strong> modules:</p>
			<ul>
				<li><strong class="source-inline">future</strong>: This contains the <strong class="source-inline">Future</strong> trait that serves as the foundation for building asynchronous services in Rust.</li>
				<li><strong class="source-inline">task</strong>: This module provides functions needed to work with asynchronous tasks including <strong class="source-inline">Context</strong>, <strong class="source-inline">Waker</strong>, and <strong class="source-inline">Poll</strong>.<p class="callout-heading">A note on the prelude module</p><p class="callout">As we've seen, Rust comes with a lot of functionality in the standard library. To use it, you have to import the respective modules into the programs. However, there is a set of commonly needed <em class="italic">traits</em>, <em class="italic">types</em>, and <em class="italic">functions</em> that Rust automatically imports into every Rust program, so the Rust programmer does not have to manually import them. This is <a id="_idIndexMarker211"/>called the <strong class="bold">prelude</strong>. V1 is the first (and the current) version of the <em class="italic">prelude</em> of the Rust Standard Library. The compiler automatically adds the statement <strong class="source-inline">use std::prelude::v1::*</strong> into Rust programs. This module re-exports frequently used Rust constructs.</p><p class="callout">The list of items exported by the <strong class="source-inline">prelude</strong> module includes traits, types, and functions including <strong class="source-inline">Box</strong>, <strong class="source-inline">Copy</strong>, <strong class="source-inline">Send</strong>, <strong class="source-inline">Sync</strong>, <strong class="source-inline">drop</strong>, <strong class="source-inline">Clone</strong>, <strong class="source-inline">Into</strong>, <strong class="source-inline">From</strong>, <strong class="source-inline">Iterator</strong>, <strong class="source-inline">Option</strong>,<strong class="source-inline"> Result</strong>, <strong class="source-inline">String</strong>, and <strong class="source-inline">Vec</strong>. The list of modules re-exported can be found at <a href="https://doc.rust-lang.org/std/prelude/v1/index.html">https://doc.rust-lang.org/std/prelude/v1/index.html</a>.</p></li>
			</ul>
			<p>This concludes the overview of the Rust Standard Library modules. The Rust Standard Library is vast and is rapidly evolving. It is highly recommended that you review the official <a id="_idIndexMarker212"/>documentation at <a href="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a> with the understanding gained in this chapter, for specific methods, traits, data structures, and example snippets.</p>
			<p>Let's now move on to the next section where we will put this knowledge to use by writing some code.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/>Building a template engine</h1>
			<p>In this section, we <a id="_idIndexMarker213"/>will look at the design of an <strong class="bold">HTML template engine</strong> and implement one of the features using the Rust Standard Library.  Let's first understand what a template engine is.</p>
			<p>Applications such as web and mobile apps use structured data stored in datastores such as relational databases, NoSQL databases, and key-value stores. However, there is a lot of data on the web that is unstructured. One particular example is text data that all web pages contain. Web pages are generated as HTML files that have a text-based format.</p>
			<p>On observing closely, we can see that an HTML page has two parts: <em class="italic">static text literals</em> and <em class="italic">dynamic parts</em>. The HTML page is authored as a template with the static and dynamic parts, and the context for HTML generation comes from a data source. While generating a web page, the generator should take the static text and output it without change, while it should combine some processing and the supplied context to generate the dynamic string result. Generating HTML pages involves syscalls (to create, open, read, and write files) and computationally intensive in-memory string manipulations.</p>
			<p>A <strong class="bold">template engine</strong> is the system <a id="_idIndexMarker214"/>software component that can be used to generate dynamic HTML pages in a performant manner. It contains a combination of software components including parsers, tokenizers, generators, and template files.</p>
			<p><em class="italic">Figure 3.5</em> shows the process involved in generating HTML with a template engine:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_3.5_B16405.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Generating HTML with templates</p>
			<p>To understand this better, let's <a id="_idIndexMarker215"/>take an example of an internet banking page showing a statement of transactions for a customer. This can be built using an HTML template, where:</p>
			<ul>
				<li>The static HTML includes the bank name, logo, other branding, and content that is <em class="italic">common to all users</em>.</li>
				<li>The dynamic portion of the web page contains the actual list of past transactions <em class="italic">for the logged-in user</em>. The transaction list varies from user to user.</li>
			</ul>
			<p>The advantage of this approach is the segregation of responsibilities in the web development life cycle:</p>
			<ul>
				<li> A <em class="italic">frontend (web) designer</em> can author the static HTML with sample data using web design tools.</li>
				<li>A <em class="italic">template designer</em> would convert the static HTML into an HTML template embedding the metadata for the dynamic portions of the page in specific syntax.</li>
				<li>At runtime (when the page request comes into the server), <em class="italic">the template engine</em> takes the template file from the specified location, applies the transaction list for the logged-in user from the database, and generates the final HTML page.</li>
			</ul>
			<p>Examples of popular <a id="_idIndexMarker216"/>template engines include <em class="italic">Jinja, Mustache, Handlebars, HAML, Apache Velocity, Twig</em>, and <em class="italic">Django</em>. There are differences in the architectures and syntax adopted by the various template engines.</p>
			<p>In this book, we will write the structure for a basic template engine that uses a syntax similar to <strong class="bold">Django templates</strong>. <em class="italic">Django</em> is a popular <a id="_idIndexMarker217"/>web framework in Python. Commercial templating engines such as that in <em class="italic">Django</em> are full-featured and complex. It will not be possible for us to recreate them completely in this chapter, but we will build the code structure and implement a representative feature.</p>
			<p class="callout-heading">Types of HTML template engines</p>
			<p class="callout">There are two <a id="_idIndexMarker218"/>types of HTML template engines, based on when the template data is parsed.</p>
			<p class="callout">The first type of template engines parse the HTML template and convert it into code, at compilation time. Then, at runtime, dynamic data is fetched and loaded into the compiled template. These tend to have better runtime performance as part of the work is done at compilation time.</p>
			<p class="callout">The second type of template engines do both the parsing of the template and HTML generation at runtime. We will be using this type in our project, as it is relatively simple to understand and implement.</p>
			<p>Let's begin with the design of an HTML template file.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/>Template syntax and design</h2>
			<p>A template is <a id="_idIndexMarker219"/>essentially a text file. A list of common features supported by a template file is shown here:</p>
			<ul>
				<li>Literals, for example, <strong class="source-inline">&lt;h1&gt; hello world &lt;/h1&gt;</strong></li>
				<li>Template variables surrounded by <strong class="source-inline">{{</strong> and <strong class="source-inline">}}</strong>, for example, <strong class="source-inline">&lt;p&gt; {{name}} &lt;/p&gt;</strong></li>
				<li>Control logic using an <strong class="source-inline">if</strong> tag, for example, <strong class="source-inline">{% if amount &gt; 100000 %} {% endif %}</strong></li>
				<li>Loop control with a <strong class="source-inline">for</strong> tag, for example, <strong class="source-inline">&lt;ul&gt;{% for customer in customer_list}&lt;li&gt;{{customer.name}}&lt;/li&gt;{% endfor %}&lt;/ul&gt;</strong></li>
				<li>Content import, for example, <strong class="source-inline">{% include "footer.html" %}</strong></li>
				<li>Filters, for example, <strong class="source-inline">{{name | upper}}</strong></li>
			</ul>
			<p><em class="italic">Figure 3.6</em> shows a sample template and the HTML generated from the template engine:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_3.6_B16405.jpg" alt="Figure 3.6 – Conceptual model of the template engine"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Conceptual model of the template engine</p>
			<p>In <em class="italic">Figure 3.6</em>, we can <a id="_idIndexMarker220"/>see the following:</p>
			<ul>
				<li>On the left-hand side, a sample template file is shown. The template file is a mix of static and dynamic content. An example of static content is <strong class="source-inline">&lt;h1&gt; Welcome to XYZ Bank &lt;/h1&gt;</strong>. An example of dynamic content is <strong class="source-inline">&lt;p&gt; Welcome {{name}} &lt;/p&gt;</strong>, because the value for <strong class="source-inline">name</strong> will be substituted at runtime. There are three types of dynamic content shown in the template file – an <strong class="source-inline">if</strong> tag, a <strong class="source-inline">for</strong> tag, and a template variable.</li>
				<li>In the middle of the figure, we can see the template engine with two sources of inputs – template file and data source. The template engine takes these inputs and generates the output HTML file.</li>
			</ul>
			<p><em class="italic">Figure 3.7</em> explains the working of the template engine using an example:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_3.7_B16405.jpg" alt="Figure 3.7 – Illustrated example for a template engine"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 3.7 – Illustrated example for a template engine</p>
			<p>From a design standpoint, the <a id="_idIndexMarker221"/>template engine has two parts:</p>
			<ul>
				<li>Parser</li>
				<li>HTML generator</li>
			</ul>
			<p>Let's start by understanding the steps involved in HTML generation using the template engine.</p>
			<p>The template file contains a set of statements. Some of these are static literals while others are placeholders for dynamic content represented using special syntax. The template engine reads each statement from the template file. Let's call each line read as a template string, henceforth. The process flow begins with the template string read from the template file:</p>
			<ol>
				<li>The template string is fed to the parser. The template string in our example is <strong class="source-inline">&lt;p&gt; Welcome {{name}} &lt;/p&gt;</strong>.</li>
				<li>The parser first determines the type of template string, which is called <strong class="bold">tokenizing</strong>. Let's <a id="_idIndexMarker222"/>consider three types of tokens – <strong class="source-inline">if</strong> tags, <strong class="source-inline">for</strong> tags, and template variables. In this example, a token of type template variable is generated (if the template string contains a static literal, it is written to the HTML output without any changes).</li>
				<li>Then the <a id="_idIndexMarker223"/>template string is parsed into a static literal, <strong class="source-inline">Welcome</strong>, and a template variable <strong class="source-inline">{{name}}</strong>.</li>
				<li>The outputs of the parser (from steps 2 and 3) are passed to the HTML generator.</li>
				<li>Data from a data source is passed as context by the template engine to the generator.</li>
				<li>The parsed token and strings (from steps 2 and 3) are combined with the context data (from <em class="italic">step 5</em>) to produce the result string, which is written to the output HTML file.</li>
			</ol>
			<p>The preceding steps are repeated for every statement (template string) read from the template file.</p>
			<p>We cannot use the parser we created for arithmetic parsing in <a href="B16405_02_Final_NM_ePUB.xhtml#_idTextAnchor041"><em class="italic">Chapter 2</em></a>, <em class="italic">A Tour of the Rust Programming Language</em>, for this example, as we need something specific for the HTML template language syntax. We could use the general-purpose parsing libraries (for example, <strong class="source-inline">nom</strong>, <strong class="source-inline">pest</strong>, and <strong class="source-inline">lalrpop</strong> are a few popular parsing libraries in Rust), but for this book, we will custom-build a template parser. The reason for this approach is that each parsing library has its own API and grammar that we need to familiarize ourselves with. Doing that would deviate from the goal of this book, which is learning to write idiomatic code in Rust from the first principles.</p>
			<p>First, let's create a new library project with the following:</p>
			<p class="source-code">cargo new –-lib template-engine</p>
			<p>The <strong class="source-inline">src/lib.rs</strong> file (which is automatically created by the <strong class="source-inline">cargo</strong> tool) will contain all the functionality of the template engine.</p>
			<p>Create a new file, <strong class="source-inline">src/main.rs</strong>. The <strong class="source-inline">main()</strong> function will be placed in this file.</p>
			<p>Let's now design the code <a id="_idIndexMarker224"/>structure for the template engine. <em class="italic">Figure 3.8</em> shows the detailed design:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_3.8_B16405.jpg" alt="Figure 3.8: Design of the template engine"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8: Design of the template engine</p>
			<p>Let's cover the key data structures and functions of the template engine along with some code snippets. We will start with the data structures.</p>
			<h3>Data structures</h3>
			<p><strong class="source-inline">ContentType</strong> is the main data structure to classify the <em class="italic">template string</em> read from the <em class="italic">template file</em>. It is <a id="_idIndexMarker225"/>represented as <strong class="source-inline">enum</strong> and contains the list of possible <strong class="bold">token types</strong> read from the template file. As each statement (template string) is read from the template file, it is evaluated to check if it is one of the types defined in this enum. The code for <strong class="source-inline">ContentType</strong> is as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<p class="source-code">// Each line in input can be of one of following types</p>
			<p class="source-code">#[derive(PartialEq, Debug)]</p>
			<p class="source-code">pub enum ContentType {</p>
			<p class="source-code">    Literal(String),</p>
			<p class="source-code">    TemplateVariable(ExpressionData),</p>
			<p class="source-code">    Tag(TagType),</p>
			<p class="source-code">    Unrecognized,</p>
			<p class="source-code">}</p>
			<p>Pay special attention to the annotations <strong class="source-inline">PartialEq</strong> and <strong class="source-inline">Debug</strong>. The former is used to allow content types to be compared, and the latter is used to print the values of the content to the console.</p>
			<p class="callout-heading">Derivable traits</p>
			<p class="callout">The Rust compiler can automatically derive default implementations for a few traits defined in the standard library. Such <a id="_idIndexMarker226"/>traits are called <em class="italic">derivable traits</em>. To instruct the compiler to provide default trait implementations, the <strong class="source-inline">#[derive]</strong> attribute is used. Note that this can be done only for types such as custom structs and enums that you have defined, not for types defined in other libraries that you don't own.</p>
			<p class="callout">Types for which trait implementations can be derived automatically include comparison traits such as <strong class="source-inline">Eq</strong>, <strong class="source-inline">PartialEq</strong>, and <strong class="source-inline">Ord</strong>, and others such as <strong class="source-inline">Copy</strong>, <strong class="source-inline">Clone</strong>, <strong class="source-inline">Hash</strong>, <strong class="source-inline">Default</strong>, and <strong class="source-inline">Debug</strong>.</p>
			<p><strong class="source-inline">TagType</strong> is a supporting data structure that is used to indicate whether a template string corresponds to a <strong class="source-inline">for-tag</strong> (repetitive loop) or <strong class="source-inline">if-tag</strong> (display control):</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<p class="source-code">#[derive(PartialEq, Debug)]</p>
			<p class="source-code">pub enum TagType {</p>
			<p class="source-code">    ForTag,</p>
			<p class="source-code">    IfTag,</p>
			<p class="source-code">}</p>
			<p>We will create a <a id="_idIndexMarker227"/>struct to store the result of the tokenization of the template string:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<p class="source-code">#[derive(PartialEq, Debug)]</p>
			<p class="source-code">pub struct ExpressionData {</p>
			<p class="source-code">    pub head: Option&lt;String&gt;,</p>
			<p class="source-code">    pub variable: String,</p>
			<p class="source-code">    pub tail: Option&lt;String&gt;,</p>
			<p class="source-code">}</p>
			<p>Note that <strong class="source-inline">head</strong> and <strong class="source-inline">tail</strong> are of type <strong class="source-inline">Option&lt;String&gt;</strong> to allow for the possibility that a template variable may not contain static literal text before or after it.</p>
			<p>To summarize, the template string is first tokenized as type <strong class="source-inline">ContentType::TemplateVariable(ExpressionData)</strong>, and <strong class="source-inline">ExpressionData</strong> is parsed into <strong class="source-inline">head="Hello"</strong>, <strong class="source-inline">variable="name"</strong>, and <strong class="source-inline">tail =",welcome"</strong>.</p>
			<h3>Key functions</h3>
			<p>Let's look at the key functions <a id="_idIndexMarker228"/>to implement the template engine:</p>
			<ul>
				<li><strong class="source-inline">Program: main()</strong>: This is the starting point of the program. It first calls functions to tokenize and parse the template string, accepts context data to feed into the template, and then calls functions to generate the HTML using the parser outputs and context data.</li>
				<li><strong class="source-inline">Program: get_content_type()</strong>: This is the entry point into the parser. It parses each line of the template file (which we refer to as the template string) and classifies it as one of the following token types: Literal, Template variable, Tag, or Unrecognized. The Tag token type can be either a <strong class="source-inline">for</strong> tag or an <strong class="source-inline">if</strong> tag. If the token is of type Template variable, it parses the template string to extract the head, tail, and template variable.<p>These types are <a id="_idIndexMarker229"/>defined as part of the <strong class="source-inline">ContentType</strong> enum. Let's write a few test cases to crystallize what we would like to see as inputs and outputs to this function, and then look at the actual <a id="_idIndexMarker230"/>code for <strong class="source-inline">get_content_type()</strong>. Let's take a <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) approach here.</p><p>First, create a <strong class="source-inline">tests</strong> module by adding the following block of code in <strong class="source-inline">src/lib.rs</strong>:</p><p class="source-code">#[cfg(test)]</p><p class="source-code">mod tests {</p><p class="source-code">    use super::*;</p><p class="source-code">}</p></li>
			</ul>
			<p>Place the unit tests within this <strong class="source-inline">tests</strong> module. Each test will begin with the annotation <strong class="source-inline">#[test]</strong>.</p>
			<p><strong class="bold">Test case 1</strong>: To check if the content type is a literal:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<p class="source-code">    #[test]</p>
			<p class="source-code">    fn <strong class="bold">check_literal_test</strong>() {</p>
			<p class="source-code">        let s = "&lt;h1&gt;Hello world&lt;/h1&gt;";</p>
			<p class="source-code">        assert_eq!(ContentType::Literal(s.to_string()),     </p>
			<p class="source-code">            get_content_type(s));</p>
			<p class="source-code">    }</p>
			<p>This test case is to check whether the literal string stored in variable <strong class="source-inline">s</strong> is tokenized as <strong class="source-inline">ContentType::Literal(s)</strong>.</p>
			<p><strong class="bold">Test case 2</strong>: To check if the content type is of the template variable type:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<p class="source-code">    #[test]</p>
			<p class="source-code">    fn <strong class="bold">check_template_var_test</strong>() {</p>
			<p class="source-code">        let content = ExpressionData {</p>
			<p class="source-code">            head: Some("Hi ".to_string()),</p>
			<p class="source-code">            variable: "name".to_string(),</p>
			<p class="source-code">            tail: Some(" ,welcome".to_string()),</p>
			<p class="source-code">        };</p>
			<p class="source-code">        assert_eq!(</p>
			<p class="source-code">            ContentType::TemplateVariable(content),</p>
			<p class="source-code">            get_content_type("Hi {{name}} ,welcome")</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p>For <a id="_idIndexMarker231"/>the <strong class="source-inline">Template String</strong> token type, this test case checks to see if the expression in the template string is parsed into the <strong class="source-inline">head</strong>, <strong class="source-inline">variable</strong>, and <strong class="source-inline">tail</strong> components, and successfully returned as type <strong class="source-inline">ContentType::TemplateVariable (ExpressionData)</strong>.</p>
			<p><strong class="bold">Test case 3</strong>: To check if the content is a <strong class="source-inline">ForTag</strong>:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<p class="source-code">    #[test]</p>
			<p class="source-code">    fn <strong class="bold">check_for_tag_test</strong>() {</p>
			<p class="source-code">        assert_eq!(</p>
			<p class="source-code">            ContentType::Tag(TagType::ForTag),</p>
			<p class="source-code">            get_content_type("{% for name in names %} </p>
			<p class="source-code">                ,welcome")</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p>This test <a id="_idIndexMarker232"/>case is to check if a statement containing a <strong class="source-inline">for</strong> tag is tokenized successfully as <strong class="source-inline">ContentType::Tag(TagType::ForTag)</strong>.</p>
			<p><strong class="bold">Test case 4</strong> – To check if the content contains <strong class="source-inline">IfTag</strong>:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<p class="source-code">    #[test]</p>
			<p class="source-code">    fn <strong class="bold">check_if_tag_test</strong>() {</p>
			<p class="source-code">        assert_eq!(</p>
			<p class="source-code">            ContentType::Tag(TagType::IfTag),</p>
			<p class="source-code">            get_content_type("{% if name == 'Bob' %}")</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p>This test case is to check if a statement containing an <strong class="source-inline">if</strong> tag is tokenized successfully as <strong class="source-inline">ContentType::Tag(TagType::IfTag)</strong>.</p>
			<p>Now that we have written the unit test cases, let's write the code for the template engine.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor066"/>Writing the template engine</h2>
			<p>There are two key <a id="_idIndexMarker233"/>parts to writing the template engine – the parser and HTML generator. We will start with the parser. <em class="italic">Figure 3.9</em> shows the design of the parser:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_3.9_B16405.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9: Parser design</p>
			<p>Here is a brief description of the various methods in the parser:</p>
			<ul>
				<li><strong class="source-inline">get_content_type()</strong>: Entry point for parser. Accepts an input statement and tokenizes it into one of an <strong class="source-inline">if</strong> tag, a <strong class="source-inline">for</strong> tag, or a template variable.</li>
				<li><strong class="source-inline">check_symbol_string()</strong>: This is a supporting method that checks if a symbol is present within another string. For example, we can check if the pattern <strong class="source-inline">{%</strong> is present in a statement from the template file, and use it to determine if it is a tag statement or template variable.</li>
				<li><strong class="source-inline">check matching pair()</strong>: This is a supporting method that is used to verify if a statement in a template file is syntactically correct. For example, we can check for the presence of matching pairs <strong class="source-inline">{%</strong> and <strong class="source-inline">%}</strong>. Otherwise, the statement is marked as <strong class="source-inline">Unrecognized</strong>.</li>
				<li><strong class="source-inline">get_index_for_symbol()</strong>: This method returns <a id="_idIndexMarker234"/>the starting index of a substring within another string. It is used for string manipulation.</li>
				<li><strong class="source-inline">get_expression_data()</strong>: This method parses a template string into its constituent parts for a token of type <strong class="source-inline">TemplateString</strong>.</li>
			</ul>
			<h3>Writing the parser</h3>
			<p>Let's first <a id="_idIndexMarker235"/>look at the <strong class="source-inline">get_content_type()</strong> method. Here is a summary of the program logic:</p>
			<ul>
				<li><strong class="source-inline">for</strong> tags are enclosed by <strong class="source-inline">{%</strong> and <strong class="source-inline">%}</strong> and contain the <strong class="source-inline">for</strong> keyword.</li>
				<li><strong class="source-inline">if</strong> tags are enclosed by <strong class="source-inline">{%</strong> and <strong class="source-inline">%}</strong> and contain the <strong class="source-inline">if </strong>keyword.</li>
				<li>Template variables are enclosed by <strong class="source-inline">{{</strong> and <strong class="source-inline">}}</strong>.</li>
			</ul>
			<p>Based on these rules, the statement is parsed and the appropriate token is returned – a <strong class="source-inline">for</strong> tag, an <strong class="source-inline">if</strong> tag, or a template variable.</p>
			<p>Here is the complete code listing for the <strong class="source-inline">get_content_type()</strong> function:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<p class="source-code">pub fn<strong class="bold"> get_content_type</strong>(input_line: &amp;str) -&gt; ContentType {</p>
			<p class="source-code">    let is_tag_expression = check_matching_pair</p>
			<p class="source-code">        (&amp;input_line, "{%", "%}");</p>
			<p class="source-code">    let is_for_tag = (check_symbol_string(&amp;input_line, </p>
			<p class="source-code">        "for")</p>
			<p class="source-code">        &amp;&amp; check_symbol_string(&amp;input_line, "in"))</p>
			<p class="source-code">        || check_symbol_string(&amp;input_line, "endfor");</p>
			<p class="source-code">    let is_if_tag =</p>
			<p class="source-code">        check_symbol_string(&amp;input_line, "if") || </p>
			<p class="source-code">            check_symbol_string(&amp;input_line, "endif");</p>
			<p class="source-code"> </p>
			<p class="source-code">    let is_template_variable = check_matching_pair</p>
			<p class="source-code">        (&amp;input_line, "{{", "}}");</p>
			<p class="source-code">    let return_val;</p>
			<p class="source-code"> </p>
			<p class="source-code">    if is_tag_expression &amp;&amp; is_for_tag {</p>
			<p class="source-code">        return_val = ContentType::Tag(TagType::ForTag);</p>
			<p class="source-code">    } else if is_tag_expression &amp;&amp; is_if_tag {</p>
			<p class="source-code">        return_val = ContentType::Tag(TagType::IfTag);</p>
			<p class="source-code">    } else if is_template_variable {</p>
			<p class="source-code">        let content = get_expression_data(&amp;input_line);</p>
			<p class="source-code">        return_val = ContentType::TemplateVariable</p>
			<p class="source-code">            (content);</p>
			<p class="source-code">    } else if !is_tag_expression &amp;&amp; !is_template_variable {</p>
			<p class="source-code">        return_val = ContentType::Literal</p>
			<p class="source-code">            (input_line.to_string());</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        return_val = ContentType::Unrecognized;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return_val</p>
			<p class="source-code">}</p>
			<h3>Supporting functions</h3>
			<p>Let's now talk <a id="_idIndexMarker236"/>about supporting functions. The parser utilizes these supporting functions to perform operations such as checking for the presence of a substring within a string, checking for matching pairs of braces, and so on. They are needed to check whether the template string is syntactically correct, and also to parse the template string into its constituent parts. Before writing some more code, let's look at the test cases for these supporting functions to understand how they will be used, and then see the code. Note that these functions are designed to enable reuse across projects. All supporting functions are placed in <strong class="source-inline">src/lib.rs</strong>:</p>
			<ul>
				<li><strong class="source-inline">check_symbol_string()</strong>: Checks if a symbol string, for example, <strong class="source-inline">'{%'</strong>, is contained within another string. Here is the test case:<p class="source-code">    #[test]</p><p class="source-code">    fn <strong class="bold">check_symbol_string_test</strong>() {</p><p class="source-code">        assert_eq!(true, check_symbol_string(</p><p class="source-code">            "{{Hello}}", "{{"));</p><p class="source-code">    }</p><p>Here is the code for the function:</p><p class="source-code">pub fn check_symbol_string(input: &amp;str, symbol: &amp;str)  </p><p class="source-code">    -&gt; bool {</p><p class="source-code">    input.contains(symbol)</p><p class="source-code">}</p><p>The standard library provides a straightforward way to check for a substring within a string slice.</p></li>
				<li><strong class="source-inline">check_matching_pair()</strong>: This function checks for matching symbol strings. Here is the test case:<p class="source-code">    #[test]</p><p class="source-code">    fn <strong class="bold">check_symbol_pair_test</strong>() {</p><p class="source-code">        assert_eq!(true, check_matching_pair(</p><p class="source-code">            "{{Hello}}", "{{", "}}"));</p><p class="source-code">    }</p><p>In this test case, we pass matching tags, <strong class="source-inline">'{{'</strong> and <strong class="source-inline">'}}'</strong>, to this function, and check if both are contained within another string expression, <strong class="source-inline">"{{Hello}}"</strong>.</p><p>Here is the code for the function:</p><p class="source-code">pub fn check_matching_pair(input: &amp;str, symbol1: &amp;str, </p><p class="source-code">    symbol2: &amp;str) -&gt; bool {</p><p class="source-code">    input.contains(symbol1) &amp;&amp; input.contains(symbol2)</p><p class="source-code">}</p><p>In this function, we are checking if the two matching tags are contained within the input string.</p></li>
				<li><strong class="source-inline">get_expression_data()</strong>: This parses an <a id="_idIndexMarker237"/>expression with a template variable, parses it into <strong class="source-inline">head</strong>, <strong class="source-inline">variable</strong>, and <strong class="source-inline">tail</strong> components, and returns the results. Here is the test case for this function:<p class="source-code">    #[test]</p><p class="source-code">    fn <strong class="bold">check_get_expression_data_test</strong>() {</p><p class="source-code">        let expression_data = ExpressionData {</p><p class="source-code">            head: Some("Hi ".to_string()),</p><p class="source-code">            variable: "name".to_string(),</p><p class="source-code">            tail: Some(" ,welcome".to_string()),</p><p class="source-code">        };</p><p class="source-code"> </p><p class="source-code">        assert_eq!(expression_data, </p><p class="source-code">            get_expression_data("Hi {{name}} </p><p class="source-code">            ,welcome"));</p><p class="source-code">    }</p><p>Here is the code for the function:</p><p class="source-code">pub fn <strong class="bold">get_expression_data</strong>(input_line: &amp;str) -&gt; </p><p class="source-code">    ExpressionData {</p><p class="source-code">    let (_h, i) = get_index_for_symbol(input_line, </p><p class="source-code">    '{');</p><p class="source-code">    let head = input_line[0..i].to_string();</p><p class="source-code">    let (_j, k) = get_index_for_symbol(input_line, </p><p class="source-code">        '}');</p><p class="source-code">    let variable = input_line[i + 1 + 1..k]</p><p class="source-code">        .to_string();</p><p class="source-code">    let tail = input_line[k + 1 + 1..].to_string();</p><p class="source-code"> </p><p class="source-code">    ExpressionData {</p><p class="source-code">        head: Some(head),</p><p class="source-code">        variable: variable,</p><p class="source-code">        tail: Some(tail),</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">get_index_for_symbol</strong>: This function <a id="_idIndexMarker238"/>takes two parameters and returns the index where the second value is found within the first value. This makes it easy to split the template string into three parts – <strong class="source-inline">head</strong>, <strong class="source-inline">variable</strong>, and <strong class="source-inline">tail</strong>. Here is the test case:<p class="source-code">    #[test]</p><p class="source-code">    fn <strong class="bold">check_get_index_for_symbol_test</strong>() {</p><p class="source-code">        assert_eq!((true, 3), get_index_for_symbol("Hi </p><p class="source-code">            {name}, welcome", '{'));</p><p class="source-code">    }</p><p>We see the code for the function in the following snippet. This makes use of the <strong class="source-inline">char_indices()</strong> method on the slice available as part of the standard library, and converts the input <a id="_idIndexMarker239"/>string into an iterator that is capable of tracking indices. We then iterate over the input string and return the index of the symbol when found:</p><p class="source-code">pub fn <strong class="bold">get_index_for_symbol</strong>(input: &amp;str, symbol: char) </p><p class="source-code">    -&gt; (bool, usize) {</p><p class="source-code">    let mut characters = input.char_indices();</p><p class="source-code">    let mut does_exist = false;</p><p class="source-code">    let mut index = 0;</p><p class="source-code">    while let Some((c, d)) = characters.next() {</p><p class="source-code">        if d == symbol {</p><p class="source-code">            does_exist = true;</p><p class="source-code">            index = c;</p><p class="source-code">            break;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    (does_exist, index)</p><p class="source-code">}</p></li>
			</ul>
			<p>This concludes the code for the <strong class="source-inline">Parser</strong> module. Let's now look at the main function that ties all the pieces together.</p>
			<h3>The main() function</h3>
			<p>The <strong class="source-inline">main()</strong> function is the <a id="_idIndexMarker240"/>entry point into the template engine. <em class="italic">Figure 3.10</em> shows the design of the <strong class="source-inline">main()</strong> function:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_3.10_B16405.jpg" alt="Figure 3.10: The main() function"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10: The main() function</p>
			<p>The <strong class="source-inline">main()</strong> function performs the coordination role tying all pieces together. It invokes the parser, initializes the context data, and then invokes the generator:</p>
			<ul>
				<li><strong class="bold">Pass context data</strong>: It creates a <strong class="source-inline">HashMap</strong> to pass <a id="_idIndexMarker241"/>values for the template variables mentioned in the template. We add values for <strong class="source-inline">name</strong> and <strong class="source-inline">city</strong> to this <strong class="source-inline">HashMap</strong>. The <strong class="source-inline">HashMap</strong> is passed to the generator function along with the parsed template input:<p class="source-code">    let mut context: HashMap&lt;String, String&gt; = </p><p class="source-code">        HashMap::new();</p><p class="source-code">    context.insert("name".to_string(), </p><p class="source-code">        "Bob".to_string());</p><p class="source-code">    context.insert("city".to_string(), </p><p class="source-code">        "Boston".to_string());</p></li>
				<li><strong class="bold">Invoke parser and generator</strong>: The parser is <a id="_idIndexMarker242"/>invoked by the <a id="_idIndexMarker243"/>call to the <strong class="source-inline">get_context_data()</strong> function for each line of input read from the command line (standard input).<p>a) If the line contains template variable, it invokes the HTML generator <strong class="source-inline">generate_html_template_var()</strong> to create the HTML output.</p><p>b) If the line contains a literal string, it simply echoes back the input HTML literal string.</p><p>c) If the line contains <strong class="source-inline">for</strong> or <strong class="source-inline">if</strong> tags, right now, we simply print out a statement that the feature is not yet implemented. We will implement this in future chapters:</p><p class="source-code">    for line in io::stdin().lock().lines() {</p><p class="source-code">        match get_content_type(&amp;line?.clone()) {</p><p class="source-code">            ContentType::TemplateVariable(content) =&gt; {</p><p class="source-code">                let html = generate_html_template_var</p><p class="source-code">                    (content, context.clone());</p><p class="source-code">                println!("{}", html);</p><p class="source-code">            }</p><p class="source-code">            ContentType::Literal(text) =&gt; println!</p><p class="source-code">                ("{}", text),</p><p class="source-code">            ContentType::Tag(TagType::ForTag) =&gt; </p><p class="source-code">                println!("For Tag not implemented"),</p><p class="source-code">            ContentType::Tag(TagType::IfTag) =&gt; </p><p class="source-code">                println!("If Tag not implemented"),</p><p class="source-code">            ContentType::Unrecognized =&gt; </p><p class="source-code">                println!("Unrecognized input"),</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li><strong class="bold">Read template strings from the command-line</strong>: A template engine in production would read <a id="_idIndexMarker244"/>inputs from a template file stored somewhere on the local file system of the server. However, since we have not yet covered file systems in this book, we will accept template strings as inputs through a command line (standard input) from the user. The <strong class="source-inline">io::stdin()</strong> function creates a new handle to the standard input of the current process. The standard input is read one line at a time using the following <strong class="source-inline">for</strong> loop, which is then passed on to the parser for processing:<p class="source-code">for line in io::stdin().lock().lines() {..}</p></li>
			</ul>
			<p>Here is the complete code listing for the <strong class="source-inline">main()</strong> function:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/main.rs</p>
			<p class="source-code">use std::collections::HashMap;</p>
			<p class="source-code">use std::io;</p>
			<p class="source-code">use std::io::BufRead;</p>
			<p class="source-code">use template_engine::*;</p>
			<p class="source-code"> </p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let mut context: HashMap&lt;String, String&gt; = </p>
			<p class="source-code">        HashMap::new();</p>
			<p class="source-code">    context.insert("name".to_string(), "Bob".to_string());</p>
			<p class="source-code">    context.insert("city".to_string(),     </p>
			<p class="source-code">        "Boston".to_string());</p>
			<p class="source-code"> </p>
			<p class="source-code">    for line in io::stdin().lock().lines() {</p>
			<p class="source-code">        match get_content_type(&amp;line.unwrap().clone()) {</p>
			<p class="source-code">            ContentType::TemplateVariable(content) =&gt; {</p>
			<p class="source-code">                let html = generate_html_template_var</p>
			<p class="source-code">                    (content, context.clone());</p>
			<p class="source-code">                println!("{}", html);</p>
			<p class="source-code">            }</p>
			<p class="source-code">            ContentType::Literal(text) =&gt; println!("{}",    </p>
			<p class="source-code">                text),</p>
			<p class="source-code">            ContentType::Tag(TagType::ForTag) =&gt; </p>
			<p class="source-code">                println!("For Tag not implemented"),</p>
			<p class="source-code">            ContentType::Tag(TagType::IfTag) =&gt; </p>
			<p class="source-code">                println!("If Tag not implemented"),</p>
			<p class="source-code">            ContentType::Unrecognized =&gt; </p>
			<p class="source-code">                println!("Unrecognized input"),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The implementation for the <strong class="source-inline">generate_html_template_var()</strong> function is shown here:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<p class="source-code">use std::collections::HashMap;</p>
			<p class="source-code">pub fn <strong class="bold">generate_html_template_var</strong>(</p>
			<p class="source-code">    content: ExpressionData,</p>
			<p class="source-code">    context: HashMap&lt;String, String&gt;,</p>
			<p class="source-code">) -&gt; String {</p>
			<p class="source-code">    let mut html = String::new();</p>
			<p class="source-code"> </p>
			<p class="source-code">    if let Some(h) = content.head {</p>
			<p class="source-code">        html.push_str(&amp;h);</p>
			<p class="source-code">    }</p>
			<p class="source-code"> </p>
			<p class="source-code">    if let Some(val) = context.get(&amp;content.variable) {</p>
			<p class="source-code">        html.push_str(&amp;val);</p>
			<p class="source-code">    }</p>
			<p class="source-code"> </p>
			<p class="source-code">    if let Some(t) = content.tail {</p>
			<p class="source-code">        html.push_str(&amp;t);</p>
			<p class="source-code">    }</p>
			<p class="source-code"> </p>
			<p class="source-code">    html</p>
			<p class="source-code">}</p>
			<p>This function constructs the output <strong class="source-inline">html</strong> statement consisting of <em class="italic">head</em>, <em class="italic">text content</em>, and <em class="italic">tail</em>. To construct <a id="_idIndexMarker245"/>the text content, the template variables are replaced with the values from the context data. The constructed <strong class="source-inline">html</strong> statement is returned from the function.</p>
			<p>The complete code from this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03</a>. </p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor067"/>Executing the template engine</h2>
			<p>We have, for now, the outline <a id="_idIndexMarker246"/>and foundations for a basic template engine that can deal with two kinds of input – static literals and template variables.</p>
			<p>Let's execute the program <a id="_idIndexMarker247"/>and run some tests:</p>
			<ol>
				<li value="1">Build and run the project with the following:<p class="source-code"><strong class="bold">&gt;cargo run</strong></p></li>
				<li><strong class="bold">Test for the literal string</strong>: You can enter the literal string <strong class="source-inline">&lt;h2&gt; Hello, welcome to my page &lt;/h2&gt;</strong>. You will see the same string printed out as there is no transformation to be done.</li>
				<li><strong class="bold">Test for the template variable</strong>: Enter a statement with the name or city variable (as mentioned in the main program) such as <strong class="source-inline">&lt;p&gt; My name is {{name}} &lt;/p&gt;</strong>  or <strong class="source-inline">&lt;p&gt; I live in {{city}} &lt;/p&gt;</strong>. You will see <strong class="source-inline">&lt;p&gt; My name is Bob  &lt;/p&gt;</strong> or <strong class="source-inline">&lt;p&gt; I live in Boston &lt;/p&gt;</strong> printed out corresponding to the input. This is because we initialized the variable <strong class="source-inline">name</strong> to <strong class="source-inline">Bob</strong> and <strong class="source-inline">city</strong> to <strong class="source-inline">Boston</strong> in the <strong class="source-inline">main()</strong> program. You are encouraged to enhance this code to add support for two template vars in a single HTML statement.</li>
				<li><strong class="bold">Test for tag and if tag</strong>: Enter a statement enclosed within <strong class="source-inline">{%</strong> and <strong class="source-inline">%}</strong>, and containing either the string <strong class="source-inline">for</strong> or <strong class="source-inline">if</strong>. You will see one of the following messages printed out to the terminal: <strong class="source-inline">For Tag not implemented</strong> or <strong class="source-inline">If Tag not implemented</strong>.</li>
			</ol>
			<p>You are encouraged to write the code for the <strong class="source-inline">for</strong> tag and <strong class="source-inline">if</strong> tag as an exercise. Ensure to check for the right <a id="_idIndexMarker248"/>sequence of symbols. For example, an invalid format such as <strong class="source-inline">{% for }%</strong> or <strong class="source-inline">%} if {%</strong> should be rejected.</p>
			<p>Even though we are not able to implement more features of the template engine, in this chapter, we have seen how to use the Rust Standard Library in a real-life use case. We have primarily used the <strong class="source-inline">io</strong>, <strong class="source-inline">collections</strong>, <strong class="source-inline">iter</strong>, and<strong class="source-inline"> str</strong> modules from the Rust Standard Library to implement the code in this chapter. As we go through future chapters, we will cover more of the standard library.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor068"/>Summary</h1>
			<p>In this chapter, we reviewed the overall structure of the Rust Standard Library and classified the modules of the standard library into different categories for better understanding. You got a brief introduction to the modules in areas of concurrency, memory management, file system operations, data processing, data types, error handling, compiler-related, FFI, networking, I/O, OS-specific, and time-related features.</p>
			<p>We looked at what a template engine is, how it works, and defined the scope and requirements of our project. We designed the template engine in terms of Rust data structures (enum and struct) and Rust functions. We saw how to write code for parsing templates and to generate HTML for statements involving template variables. We executed the program providing input data and verified the generated HTML in the terminal (command line).</p>
			<p>In the next chapter, we will take a closer look at the Rust Standard Library modules that deal with managing process environment, command-line arguments, and time-related functionality.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor069"/>Further reading</h1>
			<ul>
				<li><strong class="bold">Django template language</strong>: <a href="https://docs.djangoproject.com/en/3.0/ref/templates/language/">https://docs.djangoproject.com/en/3.0/ref/templates/language/</a></li>
				<li><strong class="bold">Rust Standard Library</strong>: <a href="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a></li>
			</ul>
		</div>
	</body></html>