- en: TCP and UDP Using Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rust进行TCP和UDP
- en: Being a system programming language, the Rust Standard Library has support for
    interacting with the network stack. All the networking-related functionality is
    located in the `std::net` namespace; reading and writing to sockets also uses `Read`
    and `Write` traits from `std::io`. Some of the most important structures here
    are `IpAddr`, which represents a generic IP address that can either be v4 or v6, `SocketAddr`,
    which represents a generic socket address (a combination of an IP and a port on
    a host), `TcpListener` and `TcpStream` for communicating over TCP, `UdpSocket`
    for UDP, and more. Currently, the standard library does not provide any APIs to
    deal with the network stack at a lower level. While this might change in the future,
    a number of crates fill that gap. The most important of these is `libpnet`, which
    provides a set of APIs for lower-level networking.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种系统编程语言，Rust标准库支持与网络栈交互。所有与网络相关的功能都位于`std::net`命名空间中；读取和写入套接字也使用了来自`std::io`的`Read`和`Write`特质。这里一些最重要的结构包括`IpAddr`，它表示一个通用的IP地址，可以是v4或v6，`SocketAddr`表示一个通用的套接字地址（主机上的IP和端口的组合），`TcpListener`和`TcpStream`用于TCP通信，`UdpSocket`用于UDP，等等。目前，标准库不提供任何用于处理较低级别网络栈的API。虽然这可能在将来改变，但许多crate填补了这一空白。其中最重要的是`libpnet`，它提供了一套用于低级别网络编程的API。
- en: Some other important crates for networking are `net2` and `socket2`. These were
    meant to be incubators for APIs that might be moved to the standard library. Some
    of the functionality here is ported to Rust core repo when it is deemed to be
    useful and stable enough. Unfortunately, this doesn't work out as planned in all
    cases. On the whole, the community now suggests using the tokio ecosystem of crates
    for writing high-performance networking applications that do not require fine-grained
    control of socket semantics. Note that tokio is not in the scope of this chapter,
    and that we will cover it in a following chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他重要的网络crate是`net2`和`socket2`。这些原本是为了孵化可能被移至标准库的API而设计的。当认为某些功能有用且足够稳定时，这些功能会被移植到Rust核心仓库。不幸的是，在所有情况下这并不按计划进行。总的来说，社区现在建议使用tokio生态系统中的crate来编写不需要精细控制套接字语义的高性能网络应用程序。请注意，tokio不在本章的范围内，我们将在下一章中介绍它。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What a simple multithreaded TCP client and server looks like in Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust中一个简单的多线程TCP客户端和服务器看起来是什么样子
- en: Writing a simple multithreaded UDP client and server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的多线程UDP客户端和服务器
- en: A number of functionalities in `std::net`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::net`中的许多功能'
- en: Learning how to use `net2`, `ipnetwork`, and `libpnet`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`net2`、`ipnetwork`和`libpnet`
- en: For the sake of simplicity, all code in this chapter will deal with IPv4 only.
    Extending the given examples to IPv6 should be trivial.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，本章中的所有代码都将仅处理IPv4。将给定的示例扩展到IPv6应该是微不足道的。
- en: A Simple TCP server and client
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的TCP服务器和客户端
- en: 'Most networking examples start with an echo server. So, let''s go ahead and
    write a basic echo server in Rust to see how all the pieces fit together. We will
    use the threading model from the standard library for handling multiple clients
    in parallel. The code is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络示例都是从echo服务器开始的。所以，让我们先写一个基本的echo服务器，看看所有部件是如何组合在一起的。我们将使用标准库中的线程模型来并行处理多个客户端。代码如下：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In our `main` function, we create a new `TcpListener`, which in Rust, represents
    a TCP socket that is listening for incoming connections from clients. For our
    example, we have hardcoded the local address and the port; the local address being
    set to `0.0.0.0` tells the kernel to bind this socket to all available interfaces
    on this host. Setting a well-known port here is important since we will need to
    know that to connect from the client. In a real application, this should be a
    configurable parameter taken from the CLI or a configuration file. We call `bind`
    on the local IP and port pair to create a local listening socket. As discussed
    earlier, our given choice of IP will bind this socket to all interfaces available
    on the host, on port 8888\. As a result, any client that can reach a network connected
    to this host will be able to talk to this host. As we have seen in the last chapter,
    the `expect` function returns the listener if there were no errors. If that is
    not the case, it panics with the given message. Panicking on failing to bind to
    the port is actually okay here, since if that fails, there is no way the server
    will continue working. The `incoming` method on `listener` returns an iterator
    over streams that have connected to the server. We loop over them and check if
    any of those have encountered an error. In that case, we can print the error and
    move on to the next connected client. Note that panicking in this case is not
    appropriate since the server can function fine if some of the clients run into
    errors for some reason.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，我们创建一个新的`TcpListener`，在Rust中，它代表一个监听客户端传入连接的TCP套接字。在我们的示例中，我们硬编码了本地地址和端口；将本地地址设置为`0.0.0.0`告诉内核将此套接字绑定到该主机上所有可用的接口。在这里设置一个知名端口很重要，因为我们需要知道这个端口才能从客户端连接。在实际应用中，这应该是一个可配置的参数，从CLI或配置文件中获取。我们在本地IP和端口对上调用`bind`以创建一个本地监听套接字。如前所述，我们选择的IP将绑定此套接字到主机上的所有接口，端口为8888。因此，任何可以连接到连接到该主机的网络的客户端都将能够与该主机通信。正如我们在上一章中看到的，`expect`函数在没有错误的情况下返回监听器。如果情况不是这样，它将使用给定的消息恐慌。在这里，在绑定端口失败时恐慌实际上是可行的，因为如果失败了，服务器将无法继续工作。`listener`上的`incoming`方法返回一个迭代器，遍历已连接到服务器的流。我们遍历它们并检查是否有任何遇到错误。在这种情况下，我们可以打印错误并继续下一个已连接的客户端。请注意，在这种情况下恐慌是不适当的，因为如果一些客户端由于某种原因遇到错误，服务器仍然可以正常工作。
- en: Now, we must read data from each of the clients in an infinite loop. But running
    an infinite loop in the main thread will block it and no other clients will be
    able to connect. That behavior is definitely not desirable. Thus, we must spawn
    a worker thread to handle each client connection. The logic of reading from each
    stream and writing it back is encapsulated in the function called `handle_client`.
    Each thread receives a closure that calls this function. This closure must be
    a `move` closure, since this must read a variable (`stream`) from the enclosing
    scope. In the function, we print the remote endpoint address and port, and then
    define a buffer to hold data temporarily. We also make sure that the buffer is
    zeroed out. We then run an infinite loop in which we read all data in the stream.
    The read method in the stream returns the length of the data it has read. It can
    return zero in two cases, if it has reached the end of the stream or if the given
    buffer was zero in length. We know for sure that the second case is not true.
    Thus, we break out of the loop (and the function) when the read method returns
    a zero. In that case, we return a `Ok()`. We then write the same data back to
    the stream using the slice syntax. Note that we have used `eprintln!` to output
    errors. This macro writes the given string to a standard error, and has been stabilized
    recently.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在一个无限循环中从每个客户端读取数据。但在主线程中运行无限循环将会阻塞它，其他客户端将无法连接。这种行为肯定是不希望的。因此，我们必须创建一个工作线程来处理每个客户端连接。从每个流中读取并写回的逻辑封装在名为`handle_client`的函数中。每个线程接收一个调用此函数的闭包。这个闭包必须是一个`move`闭包，因为必须从封装的作用域中读取一个变量（`stream`）。在函数中，我们打印远程端点的地址和端口，然后定义一个缓冲区来临时存储数据。我们还确保缓冲区被清零。然后我们运行一个无限循环，在其中读取流中的所有数据。流中的读取方法返回它已读取的数据长度。它可以在两种情况下返回零，如果它已到达流的末尾，或者如果给定的缓冲区长度为零。我们肯定第二种情况是不正确的。因此，当读取方法返回零时，我们跳出循环（和函数）。在这种情况下，我们返回一个`Ok()`。然后我们使用切片语法将相同的数据写回流。请注意，我们使用了`eprintln!`来输出错误。这个宏将给定的字符串写入标准错误，最近已经稳定下来。
- en: One might notice the apparent lack of error handling in reading from and writing
    to the stream. But that is not actually the case. We have used the `?` operator
    to handle errors in these invocations. This operator unwraps the result to an
    `Ok` if everything was fine; otherwise, it does an early return of the error to
    the calling function. Given this setup, the return type of the function must be
    either the empty type, to handle success cases, or the `io::Error` type, to handle
    error cases. Note that it might be a good idea to implement custom errors in such
    cases and return those instead of built-in errors. Also note that the `?` operator
    cannot be used in the `main` function currently since the `main` function does
    not return a `Result`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有人在读取和写入流时可能注意到明显的错误处理缺失。但实际上并非如此。我们已经使用了`?`运算符来处理这些调用中的错误。如果一切顺利，此运算符将结果展开为`Ok`；否则，它将错误提前返回给调用函数。考虑到这种设置，函数的返回类型必须是空类型，以处理成功情况，或者`io::Error`类型，以处理错误情况。注意，在这种情况下实现自定义错误可能是一个好主意，并返回这些错误而不是内置错误。另外，请注意，目前`?`运算符不能在`main`函数中使用，因为`main`函数不返回`Result`。
- en: Rust recently accepted an RFC which proposes the ability to use the `?` operator
    in the `main` function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rust最近接受了一个RFC，该RFC提议在`main`函数中使用`?`运算符。
- en: 'Interacting with the server from the terminal is easy. When we run the server
    on a Linux machine and `nc` on another terminal, any text entered to `nc` should
    be echoed back. Note that if the client and the server are running on the same
    node, we can use 127.0.0.1 as the server address:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端与服务器交互很简单。当我们在Linux机器上运行服务器，并在另一个终端运行`nc`时，输入到`nc`的任何文本都应该被回显。注意，如果客户端和服务器在同一节点上运行，我们可以使用127.0.0.1作为服务器地址：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While using `nc` to interact with the server is fine, it is much more fun to
    write a client from scratch. In this section, we will see what a simple TCP client
    might look like. This client will read input from `stdin` as a string and send
    it over to the server. When it gets back a reply, it will print that in `stdout`.
    In our example here, the client and the server are running on the same physical
    host, so we can use 127.0.0.1 as the server address:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`nc`与服务器交互是可以的，但从头开始编写客户端会更有趣。在本节中，我们将看到一个简单的TCP客户端可能的样子。这个客户端将从`stdin`读取输入作为字符串，并将其发送到服务器。当它收到回复时，它将在`stdout`中打印出来。在我们的示例中，客户端和服务器运行在同一物理主机上，因此我们可以使用127.0.0.1作为服务器地址：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we start with importing all required libraries. We then set up
    a connection to the server using `TcpStrem::connect`, which takes in the remote
    endpoint address as a string. Like all TCP connections, the client needs to know
    the remote IP and port to connect. In case setting up the connection fails, we
    will abort our program with an error message. We then start an infinite loop,
    in which we will initialize an empty string to read user input locally and a vector
    of `u8` to read responses from the server. Since a vector in Rust grows as necessary,
    we will not need to manually chunk the data at each iteration. The `read_line`
    function reads a line from standard input and stores it in the variable called
    `input`. Then, it is written to the connection as a stream of bytes. At this point,
    if everything worked as expected, the server should have sent back a response.
    We will read that using a `BufReader` that takes care of chunking the data internally.
    This also makes reading more efficient since there will not be more system calls
    than necessary. The `read_until` method reads the data in our buffer, which grows
    as needed. Finally, we can print out the buffer as a string, which has been converted
    using the `from_utf8` method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们首先导入所有必需的库。然后，我们使用`TcpStream::connect`设置到服务器的连接，该函数接受远程端点地址作为字符串。像所有TCP连接一样，客户端需要知道远程IP和端口才能连接。如果设置连接失败，我们将使用错误消息终止我们的程序。然后我们启动一个无限循环，在这个循环中，我们将初始化一个空字符串以读取本地用户输入，以及一个`u8`向量以读取来自服务器的响应。由于Rust中的向量会根据需要增长，我们不需要在每次迭代中手动分块数据。`read_line`函数从标准输入读取一行并将其存储在名为`input`的变量中。然后，它作为字节流写入连接。此时，如果一切按预期进行，服务器应该已经发送了响应。我们将使用`BufReader`读取该响应，该`BufReader`负责内部分块数据。这也使得读取更高效，因为将不会进行比必要的更多系统调用。`read_until`方法读取缓冲区中的数据，该缓冲区根据需要增长。最后，我们可以使用`from_utf8`方法将缓冲区打印为字符串。
- en: 'Running the client is easy, and as expected, behaves exactly like `nc`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行客户端很简单，并且正如预期的那样，其行为与`nc`完全相同：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Real-world applications are often more complex than this. A server might need
    some time to process the input before serving back the response. Let''s simulate
    that by sleeping for a random amount of time in the `handle_client` function;
    the `main` function will remain exactly the same as the previous example. The
    first step is to create our project using `cargo`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用通常比这更复杂。服务器可能需要一些时间来处理输入然后再返回响应。让我们通过在 `handle_client` 函数中随机睡眠一段时间来模拟这种情况；`main`
    函数将保持与上一个示例完全相同。第一步是使用 `cargo` 创建我们的项目：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that we will need to add the `rand` crate in our `Cargo.toml`, as shown
    in the following code snippet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要在 `Cargo.toml` 中添加 `rand` crate，如下代码片段所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Having set up our dependencies, let''s modify the `handle_client` function
    to sleep for a random delay before sending the response back:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好依赖项后，让我们修改 `handle_client` 函数，在发送响应之前先随机睡眠一段时间：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our main file, we must declare a dependency on the `rand` crate and declare
    it as an `extern crate`. We use the `thread_rng` function to select an integer
    between zero and five randomly and then sleep for that time duration using `std::thread::sleep`.
    On the client side, we will set read and connect timeouts, since replies won''t
    be instantaneous from the server:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主文件中，我们必须声明对 `rand` crate 的依赖，并将其声明为 `extern crate`。我们使用 `thread_rng` 函数随机选择一个介于零和五之间的整数，然后使用
    `std::thread::sleep` 睡眠相应的时间长度。在客户端，我们将设置读取和连接超时，因为来自服务器的回复不会立即出现：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we use `set_read_timeout` to set the timeout to three seconds. Thus,
    if the server sleeps for more than three seconds, the client will abort the connection.
    This function is curious since it takes in `Option<Duration>` to be able to specify
    a `Duration` that is `None`. Hence, we will need to wrap our `Duration` in a `Some`
    before passing to this function. Now, if we open two sessions, running the server
    using cargo in one and the client in another, here is what we''ll see; the server
    prints how long it slept, for each client it accepts:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `set_read_timeout` 将超时设置为三秒。因此，如果服务器睡眠超过三秒，客户端将终止连接。这个函数很奇怪，因为它接受 `Option<Duration>`
    来能够指定一个 `None` 的 `Duration`。因此，我们需要在传递给这个函数之前将我们的 `Duration` 包装在 `Some` 中。现在，如果我们打开两个会话，一个使用
    cargo 运行服务器，另一个运行客户端，我们会看到以下内容；服务器打印出它为每个接受的客户端睡眠了多长时间：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the client side, we have a single file (not a cargo project) that we will
    build using `rustc` and run the executable directly after compiling:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们有一个单独的文件（不是一个 cargo 项目），我们将使用 `rustc` 构建，并在编译后直接运行可执行文件：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For the first three inputs, the server chose delays which were less than three
    seconds. The client got a response back within three seconds and did not abort
    the connection. For the last message, the delay was five seconds, which caused
    the client to abort reading.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前三个输入，服务器选择的延迟小于三秒。客户端在三秒内收到响应，并且没有终止连接。对于最后一条消息，延迟为五秒，这导致客户端终止读取。
- en: A Simple UDP server and client
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的 UDP 服务器和客户端
- en: 'There are a few semantic differences between the UDP server and the TCP server
    we wrote earlier. Unlike TCP, UDP does not have a stream structure. This derives
    from the semantic differences between the two protocols. Let''s take a look at
    what a UDP server might look like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前编写的 UDP 服务器和 TCP 服务器之间有一些语义上的差异。与 TCP 不同，UDP 没有流结构。这源于两种协议之间的语义差异。让我们看看一个
    UDP 服务器可能的样子：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with TCP, we start with binding to the local address on a given port and
    we handle the possibility that binding can fail. Since UDP is a connectionless
    protocol, we will not need to do a sliding window to read all the data. Thus,
    we can just allocate a static buffer of a given size. It will be a better idea
    to dynamically detect the MTU of the underlying network card and set the buffer
    size to be that, since that is the maximum size each UDP packet can have. However,
    since MTU for a common LAN is around 1,500, we can get away with allocating a
    buffer of that size here. The `try_clone` method clones the given socket and returns
    a new one, which is moved into the closure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TCP 一样，我们从绑定到给定端口上的本地地址开始，并处理绑定可能失败的可能性。由于 UDP 是无连接协议，我们不需要进行滑动窗口来读取所有数据。因此，我们可以分配一个给定大小的静态缓冲区。动态检测底层网络卡的
    MTU 并将缓冲区大小设置为该值会更好，因为这是每个 UDP 数据包的最大大小。然而，由于常见局域网的 MTU 大约是 1,500，我们可以在这里分配一个同样大小的缓冲区。`try_clone`
    方法克隆给定的套接字并返回一个新的套接字，该套接字被移动到闭包中。
- en: We then read from the socket, which returns the length of the data read and
    the source in the `Ok()` case. We then spawn a new thread, in which we write back
    the same buffer to the given socket. For anything that can fail, we will need
    to handle the error like we did for the TCP server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后从套接字读取，在`Ok()`情况下返回读取的数据长度和源。然后我们启动一个新线程，在该线程中我们将相同的缓冲区写回到给定的套接字。对于任何可能失败的操作，我们都需要像处理TCP服务器那样处理错误。
- en: 'Interacting with this server is exactly the same as last time—using `nc`. The
    only difference is that in this case, we will need to pass the `-u` flag to force
    `nc` to make it use only UDP. Take a look at the following example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与上次一样，与这个服务器交互——使用`nc`。唯一的区别是，在这种情况下，我们需要传递`-u`标志来强制`nc`只使用UDP。看看下面的例子：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s write a simple UDP client to achieve the same results. As we will
    see, there are some subtle differences between the TCP server and this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个简单的UDP客户端以实现相同的结果。正如我们将看到的，TCP服务器和这个之间有一些细微的差别：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There is a major difference between this basic client and the TCP client we
    saw in the last section. In this case, it is absolutely essential to `bind` to
    a client-side socket first before connecting to the server. Once that is done,
    the rest of the example is essentially the same. Running it on the client side
    and the server side produces similar results like the TCP case. Here is a session
    on the server side:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节中看到的TCP客户端相比，这个基本客户端有一个主要的不同之处。在这种情况下，在连接到服务器之前，`bind`到客户端套接字是绝对必要的。一旦完成，其余的例子基本上是相同的。在客户端和服务器端运行它会产生与TCP案例相似的结果。以下是服务器端的一个会话：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is what we see on the client side:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们看到的是：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: UDP multicasting
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP多播
- en: 'The `UdpSocket` type has a number of methods that the corresponding TCP types
    do not. Of these, the most interesting ones are for multicasting and broadcasting.
    Let''s look at how multicasting works with an example server and client. For this
    example, we will combine the client and the server in one file. In the `main`
    function, we will check whether a CLI argument has been passed. If there has,
    we will run the client; otherwise, we will run the server. Note that the value
    of the argument will not be used; it will be treated as a Boolean:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`UdpSocket`类型有几个方法，而相应的TCP类型没有。其中最有趣的是用于多播和广播的方法。让我们通过一个示例服务器和客户端来看看多播是如何工作的。对于这个例子，我们将客户端和服务器合并到一个文件中。在`main`函数中，我们将检查是否传递了CLI参数。如果有，我们将运行客户端；否则，我们将运行服务器。请注意，参数的值将不会被使用；它将被视为一个布尔值：'
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Both the client and the server parts here are mostly similar to what we discussed
    before. One difference is that the `join_multicast_v4` call makes the current
    socket join a multicast group with the address passed. For both the server and
    the client, we do not specify a single address while binding. Instead, we use
    the special address `0.0.0.0` that denotes any available address. This is equivalent
    to passing `INADDR_ANY` to the underlying `setsockopt` call. In the server case,
    we send it to the multicast group instead. Running this is a bit more tricky.
    Since there is no way to set `SO_REUSEADDR` and `SO_REUSEPORT` in the standard
    library, we will need to run the client on multiple different machines and the
    server on another. For this to work, all of those need to be in the same network
    and the address of the multicast group needs to be a valid multicast address (the
    first four bits should be 1110). The `UdpSocket` type also supports leaving multicast
    groups, broadcasting, and so on. Note that broadcasting does not make sense for
    TCP since it is a connection between two hosts by definition.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的客户端和服务器部分与我们之前讨论的大多数相似。一个不同之处在于`join_multicast_v4`调用使当前套接字加入一个带有传递地址的多播组。对于服务器和客户端，我们在绑定时没有指定单个地址。相反，我们使用特殊地址`0.0.0.0`，表示任何可用的地址。这相当于向底层的`setsockopt`调用传递`INADDR_ANY`。在服务器的情况下，我们将其发送到多播组。运行这个稍微有点棘手。由于标准库中没有方法可以设置`SO_REUSEADDR`和`SO_REUSEPORT`，我们需要在多个不同的机器上运行客户端，并在另一台机器上运行服务器。为了使其工作，所有这些都需要在同一个网络中，并且多播组的地址需要是一个有效的多播地址（前四个位应该是1110）。`UdpSocket`类型还支持离开多播组、广播等。请注意，由于广播在定义上是由两个主机之间的连接，所以对于TCP来说没有意义。
- en: 'Running the previous example is simple; on one host, we will run the server,
    and on the other, the client. Given this setup, the output should look like this
    on the server side:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的例子很简单；在一个主机上，我们将运行服务器，在另一个主机上运行客户端。在这种配置下，服务器端的输出应该如下所示：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Miscellaneous utilities in std::net
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::net 中的杂项实用工具
- en: 'Another important type in the standard library is `IpAddr`, which represents
    an IP address. Not surprisingly, it is an enum with two variants, one for v4 addresses
    and the other for v6 addresses. All of these types have methods to classify addresses
    according to their types (global, loopback, multicast, and so on). Note that a
    number of these methods are not stabilized yet and hence are only available in
    the nightly compiler. They are behind a feature flag named `ip` which must be
    included in the crate root so that you can use those methods. A closely related
    type is `SocketAddr`, which is a combination of an IP address and a port number.
    Thus, this also has two variants, one for v4 and one for v6\. Let''s look at some
    examples:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中另一个重要的类型是 `IpAddr`，它表示一个 IP 地址。不出所料，它是一个有两个变体的枚举，一个用于 v4 地址，另一个用于 v6 地址。所有这些类型都有方法根据它们的类型（全局、环回、多播等）对地址进行分类。请注意，其中许多方法尚未稳定，因此仅在夜间编译器中可用。它们位于名为
    `ip` 的功能标志之后，必须在 crate 根目录中包含该标志，以便可以使用这些方法。一个与之密切相关的类型是 `SocketAddr`，它是 IP 地址和端口号的组合。因此，它也有两个变体，一个用于
    v4，一个用于 v6。让我们看看一些例子：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `feature(ip)` declaration is necessary since the `is_global` function is
    not stabilized yet. This example does not produce any output since all asserts
    should evaluate to true.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`feature(ip)` 声明是必要的，因为 `is_global` 函数尚未稳定。这个例子没有产生任何输出，因为所有断言都应该评估为真。'
- en: 'A common functionality is that of a DNS lookup, given a hostname. Rust does
    this using the `lookup_host` function that returns the `LookupHost` type, which
    is actually an iterator over DNS responses. Let''s look at how this can be used.
    This function is gated by the `looup_host` flag and must be included to use this
    function with the nightly compiler:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的功能是 DNS 查询，给定一个主机名。Rust 使用 `lookup_host` 函数来完成这项工作，该函数返回 `LookupHost` 类型，实际上是一个
    DNS 响应的迭代器。让我们看看如何使用它。这个函数由 `looup_host` 标志控制，并且必须包含在夜间编译器中使用此函数：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we read a CLI argument and exit if we were not given exactly one name
    to resolve. Otherwise, we call `lookup_host` with the given hostname. We iterate
    over the returned results and print the IP of each. Note that each of the returned
    results is of type `SocketAddr`; since we are only interested in the IP, we extract
    that using the `ip()` method. This function corresponds to the `getaddrinfo` call
    in libc, and thus it returns only `A` and `AAAA` record types. Running this is
    as expected:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们读取一个 CLI 参数，如果没有给出恰好一个名称来解析，则退出。否则，我们使用给定的主机名调用 `lookup_host`。我们遍历返回的结果并打印每个的
    IP 地址。请注意，每个返回的结果都是 `SocketAddr` 类型；因为我们只对 IP 地址感兴趣，所以我们使用 `ip()` 方法提取它。这个函数对应于
    libc 中的 `getaddrinfo` 调用，因此它只返回 `A` 和 `AAAA` 记录类型。运行结果符合预期：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Currently, reverse DNS lookup is not possible in the standard library. In the
    next section, we will discuss some crates in the ecosystem that can be used for
    the advanced networking functionality. For instance, the `trust-dns` crate supports
    interacting with DNS servers in more detail, and it also supports querying all
    record types and also reverse DNS.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，标准库中无法进行反向 DNS 查询。在下一节中，我们将讨论生态系统中可以用于高级网络功能的一些 crate。例如，`trust-dns` crate
    支持与 DNS 服务器进行更详细的交互，并且它还支持查询所有记录类型以及反向 DNS。
- en: Some related crates
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些相关的 crate
- en: 'A careful reader might have noticed that a lot of common networking-related
    functionalities are missing from the standard library. For instance, there is
    no way to deal with IP networks (CIDRs). Let''s look at how the `ipnetwork` crate
    helps with that. Since we are going to use an external crate, the example has
    to be in a cargo project. We will need to add it as a dependency to `Cargo.toml`.
    Let''s start by setting up a project:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个细心的读者可能会注意到，许多常见的网络相关功能都缺失在标准库中。例如，没有处理 IP 网络（CIDR）的方法。让我们看看 `ipnetwork` crate
    如何帮助解决这个问题。由于我们将使用外部 crate，示例必须在 cargo 项目中。我们需要将其添加为 `Cargo.toml` 中的依赖项。让我们先设置一个项目：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This generates a `Cargo.toml` file that we need to modify to declare our dependency.
    Once we do that, it should look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个 `Cargo.toml` 文件，我们需要修改它以声明我们的依赖项。一旦我们这样做，它应该看起来像这样：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Having set up the project, let''s look at our `main` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好项目后，让我们看看我们的 `main` 函数：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first two lines show two different ways of constructing `IpNetwork` instances,
    either using the constructor or by parsing a string. The next `assert` makes sure
    they are indeed identical. The `assert` after that ensures that the network we
    created is a v4 network. Next, we specifically create `Ipv4Network` objects and
    as expected, the size of the network matches *2^(32 - prefix)*. The next `assert`
    makes sure the `contains` method works correctly for an IP in that network. We
    then create a `Ipv6Network`, and since all of these types implement the iterator
    protocol, we can iterate over the network and print individual addresses in a
    `for` loop. Here is the output that we should see by running the last example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行展示了构建 `IpNetwork` 实例的两种不同方式，要么使用构造函数，要么通过解析字符串。接下来的 `assert` 确保它们确实是相同的。之后的
    `assert` 确保我们创建的网络是一个 v4 网络。接下来，我们特别创建了 `Ipv4Network` 对象，正如预期的那样，网络的大小与 *2^(32
    - prefix)* 匹配。下一个 `assert` 确保在该网络中的 `contains` 方法对 IP 地址正确工作。然后我们创建了一个 `Ipv6Network`，由于所有这些类型都实现了迭代器协议，我们可以通过
    `for` 循环遍历网络并打印出单个地址。以下是运行最后一个示例时应看到的输出：
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The standard library also lacks fine-grained control over sockets and connections,
    one example being the ability to set `SO_REUSEADDR`, as we described before. The
    primary reason for this is that the community has not been able to reach a strong
    consensus on how to best expose these features while maintaining a clean API.
    A useful library in this context is `mio`, which provides an alternative to thread-based
    concurrency. `mio` essentially runs an event loop where all parties register.
    When there is an event, every listener is alerted and they have the option to
    handle that event. Let''s look at the following example. Like last time, we will
    need to set up the project using cargo:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库也缺乏对套接字和连接的精细控制，一个例子就是设置 `SO_REUSEADDR` 的能力，正如我们之前所描述的。主要原因在于社区尚未能够就如何最好地暴露这些功能同时保持一个干净的
    API 达成强有力的共识。在这个上下文中，一个有用的库是 `mio`，它提供了基于线程的并发性的替代方案。`mio` 实质上运行一个事件循环，所有参与者都在其中注册。当有事件发生时，每个监听器都会被通知，并且他们有处理该事件的选项。让我们看看以下示例。像上次一样，我们需要使用
    cargo 设置项目：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next step is to add `mio` as a dependency; the `Cargo.toml` file should
    look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将 `mio` 添加为依赖项；`Cargo.toml` 文件应如下所示：
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Like all other cargo projects, we will need to declare `mio` as a dependency
    in `Cargo.toml` and pin it to a specific version so that cargo can download it
    and link it against our app:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有其他的 cargo 项目一样，我们需要在 `Cargo.toml` 中声明 `mio` 作为依赖项，并将其固定到特定版本，这样 cargo 就可以下载它并将其链接到我们的应用程序：
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unlike our previous examples, this is a TCP server that just prints the client's
    source IP and port. In `mio`, every listener on the event loop is assigned a token,
    which can then be used to differentiate between the listeners when an event is
    delivered. We define a struct for our server (`TCPServer`) in its constructor,
    and we `bind` to all local addresses and return an instance of the struct. The
    `run` method of that struct binds the socket to the given socket address; it then
    uses the `Poll` struct to instantiate the event loop.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的示例不同，这是一个仅打印客户端源 IP 和端口的 TCP 服务器。在 `mio` 中，事件循环上的每个监听器都会分配一个令牌，该令牌可以用来在事件传递时区分监听器。我们在构造函数中定义了一个用于我们的服务器（`TCPServer`）的结构体，并将其
    `bind` 到所有本地地址，并返回该结构体的一个实例。该结构体的 `run` 方法将套接字绑定到给定的套接字地址；然后它使用 `Poll` 结构体来实例化事件循环。
- en: It then registers the server socket, with a token on the instance. We also indicate
    that we should be alerted when the event is ready for reading or writing. Lastly,
    we indicate that we want edge-triggered events only, which means that the event
    should be wholly consumed when it is received, otherwise subsequent calls on the
    same token might block it. We then set up an empty container for our events. Having
    done all the boilerplate, we enter an infinite loop and start polling with the
    events container we just created. We loop over the list of events, and if any
    of the event's tokens match the server's token, we know it is meant for the server.
    We can then accept the connection and print the remote end's information. We then
    go back to the next event, and so on. In our `main` function, we first deal with
    CLI arguments, making sure that we passed a port number as an integer. Then, we
    instantiate the server and call the run method on it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它注册了服务器套接字，并在实例上设置了一个令牌。我们还指示当事件准备好读取或写入时应该发出警报。最后，我们指示我们只想接收边缘触发的事件，这意味着事件在接收时应完全消耗，否则在相同令牌上的后续调用可能会阻塞它。然后我们为我们的事件设置了一个空的容器。完成所有样板代码后，我们进入一个无限循环，并使用我们刚刚创建的事件容器开始轮询。我们遍历事件列表，如果任何事件令牌与服务器令牌匹配，我们知道它是为服务器准备的。然后我们可以接受连接并打印远程端的信息。然后我们回到下一个事件，依此类推。在我们的`main`函数中，我们首先处理CLI参数，确保我们传递了一个整数端口号。然后，我们实例化服务器并调用其上的`run`方法。
- en: 'Here is a sample session on running the server when two clients are connected
    to it. Note that either `nc` or the TCP clients from earlier can be used to connect
    to this server:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例会话，展示了当两个客户端连接到服务器时运行服务器的情况。请注意，可以使用`nc`或之前提到的TCP客户端来连接到这个服务器：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Some other major things that are missing from the standard library and the
    crates discussed here is the ability to work with the physical network device,
    a nicer API to craft and parse packets, and so on. One crate that helps in dealing
    with lower level network-related things in `libpnet`. Let''s write a small packet
    dumper using it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从标准库和这里讨论的crates中缺失的一些主要功能包括与物理网络设备工作的能力、一个更友好的API来构建和解析数据包等。有一个crate可以帮助处理`libpnet`中的底层网络相关事务。让我们使用它来编写一个小的数据包转储器：
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We initialize our Cargo project like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化我们的Cargo项目如下：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then add `pnet` as a dependency, pinning it to a specific version (the latest
    one currently available). We can then move on to our source, which should look
    like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`pnet`添加为依赖项，将其锁定到特定版本（目前可用的最新版本）。然后我们可以继续到我们的源代码，它应该看起来像这样：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Like always, we start with declaring `pnet` as an external crate. We then import
    a bunch of things that we will use later. We take in the name of the interface
    we should sniff as a CLI argument. The `datalink::interfaces()` gets us a list
    of all available interfaces in the current host, and we filter that list by the
    name of the interface we were given. In case we do not find a match, we throw
    an error and exit. The `datalink::channel()` call gives us a channel to send and
    receive packets. In this case, we do not care about the sending end since we are
    just interested in sniffing packets. We match on the returned channel type to
    make sure we work with Ethernet only. The receiving end of the channel, `rx`,
    gives us an iterator that yields packets on each `next()` call.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们首先声明`pnet`为一个外部crate。然后我们导入我们将要使用的一堆东西。我们通过CLI参数接收要嗅探的接口名称。`datalink::interfaces()`给我们当前主机上所有可用接口的列表，我们通过提供的接口名称过滤这个列表。如果我们找不到匹配项，我们抛出一个错误并退出。`datalink::channel()`调用给我们一个发送和接收数据包的通道。在这种情况下，我们不需要关心发送端，因为我们只对嗅探数据包感兴趣。我们根据返回的通道类型进行匹配，以确保我们只处理以太网。通道的接收端`rx`给我们一个迭代器，它在每次`next()`调用时产生数据包。
- en: The packets are then passed to the `handle_packet` function, which extracts
    relevant information and prints those. For this toy example, we will only deal
    with IPv4-based TCP packets. A real network will obviously get IPv6 and ICMP packets
    with UDP and TCP. All those combinations will be ignored here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包随后传递给`handle_packet`函数，该函数提取相关信息并打印出来。对于这个玩具示例，我们将只处理基于IPv4的TCP数据包。现实中的网络显然会得到带有UDP和TCP的IPv6和ICMP数据包。所有这些组合都将在此忽略。
- en: 'In the `handle_packet` function, we match on the ethertype of the packet to
    make sure we only process IPv4 packets. Since the whole payload of the Ethernet
    packet is the IP packet (refer to [Chapter 1](part0020.html#J2B80-e803f047c8b7448c90887daa96419287),
    *Introduction to Client/Server Networking*), we construct an IP packet from the
    payload. The `get_next_level_protocol()` call returns the transport protocol,
    and if that matches TCP, we construct a TCP packet from the payload of the preceding
    layer. At this point, we can print the source and destination port from the TCP
    packet. The source and destination IP will be in the enclosing IP packet. An example
    run is shown in the following code block. We need to pass the name of the interface
    to listen on to our program as command line arguments. Here is how we can get
    the interface name in Linux:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handle_packet` 函数中，我们根据数据包的 ethertype 匹配以确保我们只处理 IPv4 数据包。由于整个以太网数据包的有效负载是
    IP 数据包（参看[第 1 章](part0020.html#J2B80-e803f047c8b7448c90887daa96419287)，*客户端/服务器网络简介*)，我们从有效负载中构造一个
    IP 数据包。`get_next_level_protocol()` 调用返回传输协议，如果它匹配 TCP，我们就从前一层的有效负载中构造一个 TCP 数据包。在这个时候，我们可以从
    TCP 数据包中打印出源端口和目标端口。源 IP 和目标 IP 将在封装的 IP 数据包中。以下代码块显示了示例运行。我们需要将监听接口的名称作为命令行参数传递给我们的程序。以下是在
    Linux 中获取接口名称的方法：
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For this example, we will ignore the loopback interface `l0` since it does not
    receive a lot of traffic, and use the other interface `enp1s0`. We will also run
    this example with root privileges (using sudo) since it need to access the network
    device directly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将忽略回环接口 `l0`，因为它不接收很多流量，并使用其他接口 `enp1s0`。我们还将以 root 权限（使用 sudo）运行此示例，因为它需要直接访问网络设备。
- en: 'The first step is to build the project using cargo and the run the executable.
    Note that the exact output of this example might be a bit different, depending
    on what packets arrive:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用 cargo 构建项目并运行可执行文件。请注意，这个示例的确切输出可能略有不同，这取决于到达的数据包：
- en: '[PRE32]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the previous section, we saw how the DNS-related functionality in the standard
    library is rather limited. One crate that is widely popular for DNS-related things
    in `trust-dns`. Let''s look at an example of using this for querying a given name.
    Let''s start with the empty project:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了标准库中 DNS 相关功能的局限性。`trust-dns` 是一个在 DNS 相关事务中广泛流行的 crate。让我们看看如何使用它来查询给定名称的示例。让我们从一个空项目开始：
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will then add the versions of required crates in `Cargo.toml` first:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们首先在 `Cargo.toml` 中添加所需 crate 的版本：
- en: '[PRE34]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our app depends on `trust-dns` for DNS-related things. As usual, we will add
    it to our `Cargo.toml` before using it in our app:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序依赖于 `trust-dns` 来处理 DNS 相关的事务。像往常一样，在使用我们的应用程序之前，我们将它添加到 `Cargo.toml`
    中：
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We set up all required imports and `extern` crate declarations. Here, we expect
    to get the name to resolve as a CLI argument, and if everything goes well, it
    should be in `args[1]`. This crate supports two types of synchronous DNS resolver. `Resolver::new`
    creates a synchronous resolver, and with default options, it will use Google's
    public DNS as upstream servers. The `Resolver::from_system_conf` creates a synchronous
    resolver with configurations from the system's `resolv.conf`. Thus, this second
    option is only available on Unix systems. Before we pass the query to the `resolver`,
    we format it to FQDN by appending a `.` to the name, using the `format!` macro.
    We pass the query using the `lookup_ip` function, which then returns an iterator
    over the answers of the DNS question. Once we get that, we can iterate over it
    and print out each answer. As the name suggests, the `lookup_ip` function only
    looks up `A` and `AAAA` records. There is a more general `lookup` function that
    can take in a record type to query. In the last step, we want to get all `NS`
    records for the given name. Once we get back an answer, we loop over it and print
    the results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了所有必需的导入和 `extern` crate 声明。在这里，我们期望从 CLI 参数中获取要解析的名称，如果一切顺利，它应该在 `args[1]`
    中。这个 crate 支持两种类型的同步 DNS 解析器。`Resolver::new` 创建一个同步解析器，默认情况下，它将使用 Google 的公共 DNS
    作为上游服务器。`Resolver::from_system_conf` 创建一个使用系统 `resolv.conf` 配置的同步解析器。因此，这个第二个选项仅在
    Unix 系统上可用。在我们将查询传递给 `resolver` 之前，我们使用 `format!` 宏将名称格式化为 FQDN，并在名称后附加一个 `.`。我们使用
    `lookup_ip` 函数传递查询，该函数随后返回 DNS 问题的答案的迭代器。一旦我们得到它，我们就可以遍历它并打印出每个答案。正如其名所示，`lookup_ip`
    函数只查找 `A` 和 `AAAA` 记录。还有一个更通用的 `lookup` 函数，可以接受要查询的记录类型。在最后一步，我们想要获取给定名称的所有 `NS`
    记录。一旦我们得到答案，我们就遍历它并打印结果。
- en: '`trust-dns` also supports a tokio-based asynchronous DNS resolver.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`trust-dns` 也支持基于 tokio 的异步 DNS 解析器。'
- en: 'An example session will look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例会话将看起来像这样：
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, all prints are using the debug representation of the structures.
    A real application will want to format these as required.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，所有打印都使用结构的调试表示形式。实际应用可能需要按需格式化这些内容。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a short introduction to the basic networking functionality
    in Rust. We started with given functionality in `std::net`, and we wrote a few
    TCP and UDP servers using those. We then looked at some other utilities in the
    same namespace. At the end, we went over examples of a number of crates which
    are aimed at extending the standard library's functionality around networking.
    Bear in mind that it is always possible to just use the libc crate to write networking
    code, which is based on POSIX-compatible networking code with access to fine-grained
    control over sockets and network devices. The problem with this approach is that
    the code might be unsafe, breaking Rust's guarantee of safety. Another crate called
    nix aims to provide libc's functionality native Rust so that it preserves all
    the memory and type safety guarantees that the compiler provides: this might be
    a useful alternative for someone who needs very fine control over networking.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了 Rust 中的基本网络功能。我们从 `std::net` 中给出的功能开始，并使用这些功能编写了一些 TCP 和 UDP 服务器。然后，我们查看了一些同一命名空间中的其他实用工具。最后，我们回顾了几个旨在扩展标准库网络功能功能的
    crate 的示例。请注意，始终可以使用基于 POSIX 兼容网络代码并具有对套接字和网络设备细粒度控制的 libc crate 来编写网络代码，但这可能会导致代码不安全，违反
    Rust 的安全性保证。另一个名为 nix 的 crate 旨在提供原生的 Rust libc 功能，以便它保留编译器提供的所有内存和类型安全性保证：这可能是一个需要非常细粒度控制网络的人的有用替代方案。
- en: In the next chapter, we will look at how to handle data once we receive it in
    a server or a client using a number of serialization/de-serialization methods
    in the Rust ecosystem.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在服务器或客户端接收到数据后，如何使用 Rust 生态系统中的多种序列化/反序列化方法来处理数据。
