<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Advanced Concepts</h1>
                </header>
            
            <article>
                
<p>Quite a few concepts we learned in the previous chapters really deserve close attention so we can appreciate the design of Rust. Learning these advanced topics will also help you further when you need to understand complex code bases. These concepts are also helpful when you want to create libraries that provide idiomatic Rust APIs.</p>
<p>We'll cover the following topics in this chapter:</p>
<ul>
<li>Type system tidbits</li>
<li>Strings</li>
<li>Iterators</li>
<li>Closures</li>
<li>Modules</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type system tidbits</h1>
                </header>
            
            <article>
                
<div class="packt_quote">"An algorithm must be seen to be believed"</div>
<p class="CDPAlignRight CDPAlign"><span>– <em>Donald Knuth</em></span></p>
<p>Before we go into more dense topics in this chapter, we'll first discuss some of the type system tidbits in statically typed programming languages in general, with focus on Rust. Some of these topics may already be familiar to you from <a href="d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml">Chapter 1</a>, <em>Getting Started with Rust</em>, but we're going to dig into the details here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blocks and expressions</h1>
                </header>
            
            <article>
                
<p>Despite being a mix of statements and expressions, Rust is primarily an expression-oriented language. This means that most constructs are expressions that return a value. It's also a language that uses C-like braces <kbd>{}</kbd>, to introduce new scope for variables in a program. Let's get these concepts straight before we talk more about them later in this chapter.</p>
<p>A <strong>block expression</strong> (hereby referred as blocks) is any item that starts with <kbd>{</kbd> and ends with <kbd>}</kbd>. In Rust, they include <kbd>if else</kbd> expressions, match expressions, <kbd>while</kbd> loops, loops, bare <kbd>{}</kbd> blocks, functions, methods, and closures, and all of them return a value which is the last line of the expression. If you put a semicolon in the last expression, the block expressions default to a return value of the unit <kbd>()</kbd> type.</p>
<p>A related concept to blocks is the <strong>scope</strong>. A scope is introduced whenever a new block is created. When we a new block and create any variable bindings within it, the bindings are confined to that scope and any reference to them is valid only within the scope bounds. It's like a new environment for variables to live in, isolated from the others. Items such as functions, <kbd>impl</kbd> blocks, bare blocks, if else expressions, match expressions, functions, and closures introduce new scope in Rust. Within a block/scope, we can declare structs, enums, modules, traits and their implementations, and even blocks. Every Rust program starts with one root scope, which is the scope introduced by the <kbd>main</kbd> function. Within that, many nested scopes can be created. The <kbd>main</kbd> scope becomes the parent scope for all inner scopes declared. Consider the following snippet:</p>
<pre>// scopes.rs<br/><br/>fn main() {<br/>    let mut b = 4;<br/>    {<br/>        let mut a = 34 + b;<br/>        a += 1;<br/>    }<br/><br/>    b = a;   <br/>}</pre>
<p>We used a bare block <kbd>{}</kbd>, to introduce a new inner scope and created a variable <kbd>a</kbd>. Following the end of the scope, we are trying to assign <kbd>b</kbd> to the value of <kbd>a</kbd>, which comes from the inner scope. Rust throws a compile time error saying <kbd>cannot find value `a` in this scope</kbd> . The parent scope from <kbd>main</kbd> does not know anything about <kbd>a</kbd> as it comes from the inner scope. This property of scopes is also used sometimes to control how long we want a reference to be valid, as we saw in <a href="db2c2723-8ca0-43be-b135-afd847342146.xhtml">Chapter 5</a>, <em>Memory Management and Safety</em>.</p>
<p>But the inner scope can access values from their parent scope. Because of that, it is possible to write <kbd>34 + b</kbd> within our inner scope.</p>
<p>Now we come to expressions. We can benefit from their property of returning a value and that they must be of the same type in all branches. This results in very concise code. For example, consider this snippet:</p>
<pre>// block_expr.rs<br/><br/>fn main() {<br/>    // using bare blocks to do multiple things at once<br/>    let precompute = {<br/>        let a = (-34i64).abs();<br/>        let b = 345i64.pow(3);<br/>        let c = 3;<br/>        a + b + c<br/>    };<br/><br/>    // match expressions<br/>    let result_msg = match precompute {<br/>        42 =&gt; "done",<br/>        a if a % 2 == 0 =&gt; "continue",<br/>        _ =&gt; panic!("Oh no !")<br/>    };<br/><br/>    println!("{}", result_msg);<br/>}</pre>
<p>We can use bare blocks to chunk several lines of code together and assign the value at the end with an implicit return of the <kbd>a + b + c</kbd> <span>expression </span>to <kbd>precompute</kbd> as shown previously. Match expressions can also assign and return values from their match arms directly.</p>
<div class="packt_tip packt_infobox"><strong>Note</strong>: Being similar to the <kbd>switch</kbd> statement in C, match arms in Rust do not suffer from the <kbd>case fall through</kbd> side effect that results in lots of bugs in C code.</div>
<p>The C switch case requires every <kbd>case</kbd> statement within the <kbd>switch</kbd> block to have a <kbd>break</kbd> if we want to bail out after running the code in that <kbd>case</kbd>. If the <kbd>break</kbd> is not present, any <kbd>case</kbd> statement following that is also executed, which is called the fall-through behavior. A match expression, on the other hand, is guaranteed to evaluate only one of the match arms.</p>
<p><kbd>If else</kbd> expressions provide the same conciseness:</p>
<pre>// if_expr.rs<br/><br/>fn compute(i: i32) -&gt; i32 {<br/>    2 * i<br/>}<br/><br/>fn main() {<br/>    let result_msg = "done";<br/>    <br/>    // if expression assignments<br/>    let result = if result_msg == "done" {<br/>        let some_work = compute(8);<br/>        let stuff = compute(4);<br/>        compute(2) + stuff // last expression gets assigned to result<br/>    } else {<br/>        compute(1)<br/>    };<br/><br/>    println!("{}", result);<br/>}</pre>
<p>In statement-based languages such as Python<em>,</em> you would write something like this for the preceding snippet:</p>
<pre>result = None<br/>if (state == "continue"):<br/>    let stuff = work()<br/>    result = compute_next_result() + stuff<br/>else:<br/>    result = compute_last_result()</pre>
<p>In the Python code, we had to declare <kbd>result</kbd> beforehand, followed by doing separate assignments in the if else branch. Rust is more concise here, with the assignment being done as a result of the if else expression. Also, in Python, you can forget to assign a value to a variable in either of the branches and the variable may be left uninitialized. Rust will report at compile time if you return and assign something from the <kbd>if</kbd> block and either miss or return a different type from the <kbd>else</kbd> block.</p>
<p>As an added note, Rust also supports declaring uninitialized variables:</p>
<pre>fn main() {<br/>    let mut a: i32;<br/>    println!("{:?}", a);    // error<br/>    a = 23;<br/>    println!("{:?}", a);    // fine now<br/>}</pre>
<p class="mce-root"/>
<p>But they need to be initialized before we use them. If an uninitialized variable is attempted to be read from later, Rust will forbid that and report at compile time that the variable must be initialized:</p>
<pre>   Compiling playground v0.0.1 (file:///playground)<br/>error[E0381]: use of possibly uninitialized variable: `a`<br/> --&gt; src/main.rs:7:22<br/>  |<br/>7 |     println!("{:?}", a);<br/>  |                      ^ use of possibly uninitialized `a`</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Let statements</h1>
                </header>
            
            <article>
                
<p>In <a href="d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml">Chapter 1</a>, <em>Getting Started with Rust</em>, we briefly introduced <kbd>let</kbd>, which is used to create new variable bindings—but <kbd>let</kbd> is more than that. In fact, <kbd>let</kbd> is a pattern-matching statement. Pattern matching is a construct mostly seen in functional languages such as Haskell and allows us to manipulate and make decisions about values based on their internal structure or can be used to extract values out of algebraic data types. We had already</p>
<pre>let a = 23;<br/>let mut b = 403;</pre>
<p>Our first line is <kbd>let</kbd> in its simplest form and it declares an immutable variable binding, <kbd>a</kbd>. In the second line, we have <kbd>mut</kbd> after the <kbd>let</kbd> keyword for <kbd>b</kbd> . <kbd>mut</kbd> is part of the <kbd>let</kbd> pattern, which binds <kbd>b</kbd> mutably to <kbd>i32</kbd> types in this case. <kbd>mut</kbd> enables <kbd>b</kbd> to bind again to some other <kbd>i32</kbd> type. Another keyword that's seen less frequently with <kbd>let</kbd> is the <kbd>ref</kbd> keyword. Now, we generally use the <kbd>&amp;</kbd> operator to create a reference/pointer to any value. The other way to create a reference to any value is to use the <kbd>ref</kbd> keyword with <kbd>let</kbd>. To illustrate <kbd>ref</kbd> and <kbd>mut</kbd>, we have a snippet:</p>
<pre>// let_ref_mut.rs<br/><br/>#[derive(Debug)]<br/>struct Items(u32);<br/><br/>fn main() {<br/>    let items = Items(2);<br/>    let items_ptr = &amp;items;<br/>    let ref items_ref = items;<br/><br/>    assert_eq!(items_ptr as *const Items, items_ref as *const Items);<br/><br/>    let mut a = Items(20);<br/>    // using scope to limit the mutation of `a` within this block by b<br/>    {<br/>        // can take a mutable reference like this too<br/>        let ref mut b = a; // same as: let b = &amp;mut a;<br/>        b.0 += 25;<br/>    }<br/> <br/>    println!("{:?}", items);<br/><br/>    println!("{:?}", a);   // without the above scope<br/>                           // this does not compile. Try removing the scope<br/>}</pre>
<p>Here, <kbd>items_ref</kbd> is a reference created using the usual <kbd>&amp;</kbd> operator. The next line also creates the <kbd>items_ref</kbd> <span>reference </span>to the same <kbd>items</kbd> value using <kbd>ref</kbd>. We can confirm, with the <kbd>assert_eq!</kbd> call following it, that the two pointer variables point to the same <kbd>items</kbd> value. The cast to <kbd>*const Items</kbd> is used to compare whether two pointers point to the same memory location, where <kbd>*const Items</kbd> is a raw pointer type to <kbd>Items</kbd>. Additionally, by combining <kbd>ref</kbd> and <kbd>mut</kbd> as shown in the second to last part of the code, we can get a mutable reference to any owned value other than the usual way of doing so with the <kbd>&amp;mut</kbd> operator. But we have to use an inner scope to modify <kbd>a</kbd> from <kbd>b</kbd>.</p>
<p>Languages using pattern matching are not just limited to having identifiers on the left hand side of <kbd>`=`</kbd> but can additionally have patterns referring to the structure of types. So, another convenience <kbd>let</kbd> provides us with is the ability to extract values from fields of an algebraic data type, such as a struct or enum as new variables. Here, we have a snippet that demonstrates this:</p>
<pre>// destructure_struct.rs<br/><br/>enum Food {<br/>    Pizza,<br/>    Salad<br/>}<br/><br/>enum PaymentMode {<br/>    Bitcoin,<br/>    Credit<br/>}<br/><br/>struct Order {<br/>    count: u8,<br/>    item: Food,<br/>    payment: PaymentMode<br/>}<br/><br/>fn main() {<br/>    let food_order = Order { count: 2,<br/>                             item: Food::Salad,<br/>                             payment: PaymentMode::Credit };<br/><br/>    // let can pattern match inner fields into new variables<br/>    let Order { count, item, .. } = food_order;<br/>}</pre>
<p>Here, we created an instance of <kbd>Order</kbd>, which is bound to <kbd>food_order</kbd>. Let's assume we got <kbd>food_order</kbd> from some method call and we want to access the <kbd>count</kbd> and <kbd>item</kbd> values. We can extract the individual fields, <kbd>count</kbd> and <kbd>item</kbd>, directly using <kbd>let</kbd>. <kbd>count</kbd> and <kbd>item</kbd> become new variables that hold the corresponding field values from the <kbd>Order</kbd> instance. This is technically called the <strong>destructuring syntax</strong> of <strong><kbd>let</kbd></strong>. The way the variables get destructured depends on whether the value on the right is an immutable reference, mutable reference, or an owned value or by how we reference it on the left-hand side using the <kbd>ref</kbd> or <kbd>mut</kbd> patterns. In the previous code, it was captured by the value because <kbd>food_order</kbd> owns the <kbd>Order</kbd> instance and we matched the members on the left-hand side without any <kbd>ref</kbd> or <kbd>mut</kbd> keyword. If we want to destructure the members by immutable reference, we would put an <kbd>&amp;</kbd> symbol before <kbd>food_order</kbd> or use <kbd>ref</kbd> or <kbd>mut</kbd> alternatively:</p>
<pre>let Order { count, item, .. } = &amp;food_order;<br/>// or<br/>let Order { ref count, ref item, .. } = food_order;</pre>
<p>The first style is generally preferred as it's concise. If we want to have a mutable reference, we have to place <kbd>&amp;mut</kbd> after making <kbd>food_order</kbd> itself mutable:</p>
<pre>let mut food_order = Foo { count: 2,<br/>                           item: Food::Salad,<br/>                           payment: PaymentMode::Credit };<br/>let Order { count, item, .. } = &amp;mut food_order;</pre>
<p>Fields that we don't care about can be ignored by using the <kbd>..</kbd>, as shown in the code. Also, a slight restriction of <kbd>let</kbd> destructuring is that we are not free to choose the mutability of individual fields. All variables must have the the same mutability—either all are immutable or all are mutable. Note that <kbd>ref</kbd> isn<span>'</span>t generally used to declare variable bindings and is mostly used in match expressions in cases where we want to match against a value by reference because the <kbd>&amp;</kbd> operator does not work within match arms, as demonstrated here:</p>
<pre>// match_ref.rs<br/><br/>struct Person(String);<br/><br/>fn main() {<br/>    let a = Person("Richard Feynman".to_string());<br/>    match a {<br/>        Person(&amp;name) =&gt; println!("{} was a great physicist !", name),<br/>         _ =&gt; panic!("Oh no !")<br/>    }<br/><br/>    let b = a;<br/>}</pre>
<p>If we want to use the inner value from <kbd>Person</kbd> struct by an immutable reference, our intuition would say to use something like <kbd>Person(&amp;name)</kbd> in the match arm to match by reference. But we get this error upon compilation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/671b0a41-8760-460e-bcd3-0a7d5f440343.png" style="width:37.33em;height:11.17em;"/></p>
<p>This gives us a misleading error because <kbd>&amp;name</kbd> is creating a reference out of <kbd>name</kbd> (<kbd>&amp;</kbd> is an operator) and the compiler thinks that we want to match against <kbd>Person(&amp;String)</kbd> but the <kbd>a</kbd> <span>value </span>is actually <kbd>Person(String)</kbd>. So, in this case <kbd>ref</kbd> has to be used to destructure it as a reference. To make it compile, we change it accordingly to <kbd>Person(ref name)</kbd> on the left-hand side.</p>
<p>The destructuring syntax is also applicable to enum types as well:</p>
<pre>// destructure_enum.rs<br/><br/>enum Container {<br/>    Item(u64),<br/>    Empty<br/>}<br/><br/>fn main() {<br/>    let maybe_item = Container::Item(0u64);<br/>    let has_item = if let Container::Item(0) = maybe_item {<br/>        true<br/>    } else {<br/>        false<br/>    };<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Here, we have <kbd>maybe_item</kbd> as a <kbd>Container</kbd> enum. Combining <kbd>if let</kbd> and pattern matching, we can conditionally assign the value to <kbd>has_item</kbd> variable using the <kbd>if let &lt;destructure pattern&gt; = expression {}</kbd> syntax.</p>
<p>The destructuring syntax can be used in function parameters as well. For example, in the case of custom types, such as a struct when used in a function as arguments:</p>
<pre>// destructure_func_param.rs<br/><br/>struct Container {<br/>    items_count: u32<br/>}<br/><br/>fn increment_item(Container {mut items_count}: &amp;mut Container) {<br/>    items_count += 1;<br/>}<br/><br/>fn calculate_cost(Container {items_count}: &amp;Container) -&gt; u32 {<br/>    let rate = 67;<br/>    rate * items_count<br/>}<br/><br/>fn main() {<br/>    let mut container = Container {<br/>        items_count: 10<br/>    };<br/><br/>    increment_item(&amp;mut container);<br/>    let total_cost = calculate_cost(&amp;container);<br/>    println!("Total cost: {}", total_cost);<br/>}</pre>
<p>Here, <kbd>calculate_cost</kbd> function has a parameter that's destructured as a struct with fields bound to the <kbd>items_count</kbd> variable. If we want to destructure mutably, we add the <kbd>mut</kbd> keyword before the member field as is the case with the <kbd>increment_item</kbd> function.</p>
<p><strong>Refutable patterns</strong>: Refutable pattern are <kbd>let</kbd> patterns where the left-hand side and the right-hand side are not compatible for pattern matching and, in those cases one has to use the exhaustive match expression instead. Up until now, all forms of <kbd>let</kbd> patterns we've seen were irrefutable patterns. Irrefutable means that they're able to properly match against the value on the right side of <kbd>'='</kbd> as a valid pattern.</p>
<p class="mce-root"/>
<p>But sometimes, pattern matching with <kbd>let</kbd> may fail because of invalid patterns, for example, when matching an enum <kbd>Container</kbd> that has two variants:</p>
<pre>// refutable_pattern.rs<br/><br/>enum Container {<br/>    Item(u64),<br/>    Empty<br/>}<br/><br/>fn main() {<br/>    let mut item = Container::Item(56);<br/>    let Container::Item(it) = item;<br/>}</pre>
<p>Ideally, we expect <kbd>it</kbd> to store <kbd>56</kbd> as the value, after being destructured from <kbd>item</kbd>. If we try compiling this, we get the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fc30cd83-74e1-4e93-9a81-e4a783a82cfe.png" style="width:34.92em;height:7.50em;"/></p>
<p class="mce-root"/>
<p>The reason this match does not succeed is because <kbd>Container</kbd> has two variants, <kbd>Item(u64)</kbd> and <kbd>Empty</kbd>. Even though we know that <kbd>item</kbd> contains the <kbd>Item</kbd> variant, <kbd>let</kbd> patterns can't rely on this fact, because if <kbd>item</kbd> is mutable, some code can assign an <kbd>Empty</kbd> variant there later, which would render the destructure an undefined operation. We have to cover all possible cases. Destructuring directly against a single variant violates the semantics of exhaustive pattern matching and hence our match fails.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loop as an expression</h1>
                </header>
            
            <article>
                
<p>In Rust, a loop is also an expression that returns <kbd>()</kbd> by default when we <kbd>break</kbd> out of it. The implication of this is that <kbd>loop</kbd> can also be used to assign value to a variable with <kbd>break</kbd>. For example, it can be used in something like this:</p>
<pre>// loop_expr.rs<br/><br/>fn main() {<br/>    let mut i = 0;<br/>    let counter = loop {<br/>        i += 1;<br/>        if i == 10 {<br/>            break i;<br/>        }<br/>    };<br/>    println!("{}", counter);<br/>}</pre>
<p>Following the <kbd>break</kbd> keyword, we include the value we want to return and this gets assigned to <kbd>counter</kbd> variable when the loop breaks (if at all). This is really handy in cases where you assign the value of any variable within the loop after breaking from the loop and need to use it afterward.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type clarity and sign distinction in numeric types</h1>
                </header>
            
            <article>
                
<p>While mainstream languages differentiate between numeric primitives such as an integer, a double<em>,</em> and a byte<em>,</em> a lot of newer languages such as Golang have started adding distinction between signed and unsigned numeric types too. Rust follows in the same footsteps by distinguishing signed and unsigned numeric types, providing them as separate types altogether. From a type-checking perspective, this adds another layer of safety to our programs. This allows us to write code that exactly specifies its requirements. For example, consider a database connection pool struct:</p>
<pre>struct ConnectionPool {<br/>    pool_count: usize<br/>}</pre>
<p>For languages that provide a common integer type that incorporates both signed and unsigned values, you would specify the type of <kbd>pool_count</kbd> as an integer, which can also store negative values. It does not make sense for <kbd>pool_count</kbd> to be negative. With Rust, we can specify this clearly in code by using an unsigned type instead, such as <kbd>u32</kbd> or <kbd>usize</kbd>.</p>
<p>One more aspect to note about primitive types is that Rust does not perform automatic casts when mixing signed and unsigned types in arithmetic operations. You have to be explicit about this and cast the value manually. An example of an unintended auto cast in C/C++ would be the following:</p>
<pre>#include &lt;iostream&gt;<br/>int main(int argc, const char * argv[]) {
    uint foo = 5;
    int bar = 6;<br/>    auto difference = foo - bar;
    std::cout &lt;&lt; difference;
    return 0;
}</pre>
<p>The preceding code prints <kbd>4294967295</kbd>. Here, the difference won't be <kbd>-1</kbd> on subtracting <kbd>foo</kbd> and <kbd>bar</kbd>; instead C++ does its own thing without the programmer's consent. <kbd>int</kbd> (signed integer) is auto cast to <kbd>uint</kbd> (unsigned integer) and wraps to a maximum value of <kbd>uint</kbd> being <kbd>4294967295</kbd>. This code continues to run without complaining about underflow here.</p>
<p>Translating the same program in Rust, we get the following:</p>
<pre>// safe_arithmetic.rs<br/><br/>fn main() {<br/>    let foo: u32 = 5;<br/>    let bar: i32 = 6;<br/>    let difference = foo - bar;<br/>  println!("{}", difference);<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">Following will be the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b15dd415-e0d3-4148-b663-134157d69bc1.png" style="width:35.75em;height:14.33em;"/></div>
<p class="mce-root"/>
<p>Rust won't compile this, showing an error message. You have to explicitly cast either of the values according to your intent. Also, <span>if we perform overflow/underflow operations on two unsigned or signed types,</span> Rust will <kbd>panic!()</kbd> and abort your program when you build and run in <kbd>debug</kbd> mode. When built in <kbd>release</kbd> mode, it does a wrapping arithmetic.</p>
<div class="packt_infobox">By wrapping arithmetic, we mean that adding <kbd>1</kbd> to <kbd>255</kbd> (a <kbd>u8</kbd>) will result in <kbd>0</kbd>.</div>
<p>Panicking in debug mode is the right thing to do here because if such arbitrary values are allowed to propagate to other parts of code, they can taint your business logic and introduce further hard-to-track bugs in the program. So, a fail-stop approach is better in these cases where the user accidentally performs an overflow/underflow operation and this gets caught in debug mode. When the programmer wants to allow wrapping semantics on arithmetic operations, then they may choose to ignore the panic and proceed to compile in release mode. That's another aspect of safety that the language provides you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference</h1>
                </header>
            
            <article>
                
<p><span>Type inference is useful in statically typed languages as it makes the code easier to write, maintain, and refactor. Rust's type system can figure out types for fields, methods, local variables, and most generic type arguments when you don't specify them. Under the hood, a component of the compiler called the type checker uses the <em>Hindley Milner</em> type inference algorithm to decide what the types of local variables should be. It is a set of rules about establishing types of expressions based on their usage. As such, it can infer types based on the environment and the way a type is used. One such example is the following:</span></p>
<pre>let mut v = vec![];<br/>v.push(2);    // can figure type of `v` now to be of Vec&lt;i32&gt;</pre>
<p>With only the first line initializing the vector, Rust's type checker is unsure of what the type for <kbd>v</kbd> should be. It's only when it reaches the next line, <kbd>v.push(2)</kbd>, that it knows that <kbd>v</kbd> is of the type, <kbd>Vec&lt;i32&gt;</kbd>. Now the type of <kbd>v</kbd> is frozen to <kbd>Vec&lt;i32&gt;</kbd>.</p>
<p>If we added another line, <kbd>v.push(2.4f32);</kbd>, then the compiler will complain of type mismatch as it already had inferred it from the previous line to be of <kbd>Vec&lt;i32&gt;</kbd>. But sometimes, the type checker cannot figure out types of variables in complex situations. But with some help from the programmer, the type checker is able to infer types. For example, for the next snippet, we read a file <kbd>foo.txt</kbd>, containing some text and read it as bytes:</p>
<pre>// type_inference_iterator.rs<br/><br/>use std::fs::File;<br/>use std::io::Read;<br/><br/>fn main() {<br/>    let file = File::open("foo.txt").unwrap();<br/>    let bytes = file.bytes().collect();<br/>}</pre>
<p>Compiling this gives us this error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/90d9cd48-e50f-439a-8a16-7073beff3614.png" style="width:31.67em;height:12.25em;"/></p>
<p class="mce-root"/>
<p>The <kbd>collect</kbd> method on iterators is basically an <kbd>aggregator</kbd> method. We'll look at iterators later in this chapter. The resulting type it collects into can be any collection type. It can either be <kbd>LinkedList</kbd>, <kbd>VecDeque</kbd>, or <kbd>Vec</kbd>. Rust does not know what the programmer intends and, due to such ambiguity, it needs our help here. We made the following change for the second line in <kbd>main</kbd>:</p>
<pre> let bytes: Vec&lt;Result&lt;u8, _&gt;&gt; = file.bytes().collect();</pre>
<p>Calling <kbd>bytes()</kbd> returns <kbd>Result&lt;u8, std::io::Error&gt;</kbd>. After adding some type hint as to what to collect into (here, <kbd>Vec</kbd>), the program compiles fine. Note the <kbd>_</kbd> on the <kbd>Result</kbd> error variant. It was enough for Rust to hint that we need a <kbd>Vec</kbd> of <kbd>Result</kbd> of <kbd>u8</kbd>. The rest, it is able to figure out—the error type in <kbd>Result</kbd> needs to be of <kbd>std::io::Error</kbd> type. It was able to figure that out because there is no such ambiguity here. It gets the information from the <kbd>bytes()</kbd> method signature. Quite smart!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type aliases</h1>
                </header>
            
            <article>
                
<p>Type aliases are a feature not unique to Rust. C has the <kbd>typedef</kbd> keyword, while Kotlin has <kbd>typealias</kbd> for the same. They are there to make your code more readable and remove the type signature cruft that often piles up in statically typed languages, for example, if you have an API from your crate where you return a <kbd>Result</kbd> type, wrapping a complex object as depicted below:</p>
<pre>// type_alias.rs<br/><br/>pub struct ParsedPayload&lt;T&gt; {<br/>    inner: T<br/>}<br/><br/>pub struct ParseError&lt;E&gt; {<br/>    inner: E<br/>}<br/><br/>pub fn parse_payload&lt;T, E&gt;(stream: &amp;[u8]) -&gt; Result&lt;ParsedPayload&lt;T&gt;, ParseError&lt;E&gt;&gt; {<br/>    unimplemented!();<br/>}<br/><br/>fn main() {<br/>    // todo<br/>}</pre>
<p>As you can see, for some of the methods, such as <kbd>parse_payload</kbd>, the type signature gets too large to fit in a line. Also, having to type <kbd>Result&lt;ParsedPayload&lt;T&gt;, ParseError&lt;E&gt;&gt;</kbd> every time they are used becomes cumbersome. What if we could refer to this type by a simpler name? This is the exact use case type aliases serve. They enable us to give another (desirably simpler) name to types with a complex type signature.</p>
<p>So, we can give an alias to the return type of <kbd>parse_payload</kbd> as follows:</p>
<pre>// added a type alias<br/>type ParserResult&lt;T, E&gt; = Result&lt;ParsedPayload&lt;T&gt;, ParseError&lt;E&gt;&gt;;<br/><br/>// and modify parse_payload function as:<br/>pub fn parse_payload&lt;T, E&gt;(stream: &amp;[u8]) -&gt; ParserResult&lt;T, E&gt; {<br/>    unimplemented!();<br/>}</pre>
<p class="mce-root"/>
<p>This makes it more manageable if we later want to change the actual inner types. We can type alias any simple types too:</p>
<pre>type MyString = String;</pre>
<p>So, now we can use <kbd>MyString</kbd> anywhere we use <kbd>String.</kbd> But this doesn't mean that <kbd>MyString</kbd> is of a different type. During compilation, this just gets substituted/expanded to the original type. When creating type aliases for generic types, the type alias also needs a generic type parameter (<kbd>T</kbd>). So aliasing <kbd>Vec&lt;Result&lt;Option&lt;T&gt;&gt;&gt;</kbd> becomes the following:</p>
<pre>type SomethingComplex&lt;T&gt; = Vec&lt;Result&lt;Option&lt;T&gt;&gt;&gt;;</pre>
<p>Let's assume you have a lifetime in your type, as in <kbd>SuperComplexParser&lt;'a&gt;</kbd>:</p>
<pre>struct SuperComplexParser&lt;'s&gt; {<br/>    stream: &amp;'a [u8]<br/>}<br/><br/>type Parser&lt;'s&gt; = SuperComplexParser&lt;'s&gt;;</pre>
<p>When creating type aliases for them, we need to specify the lifetime as well, as is the case with the <kbd>Parser</kbd> type alias.</p>
<p>With those type system niceties out of the way, let's talk about strings again!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strings</h1>
                </header>
            
            <article>
                
<p>In <a href="d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml">Chapter 1</a>, <em>Getting Started with Rust</em>, we mentioned that strings are of two types. In this section, we'll give a clearer picture on strings, their peculiarities, and how they differ from strings in other languages.</p>
<p>While other languages have a pretty straightforward story on string types, the <kbd>String</kbd> type in Rust is one of the tricky and uneasy types to handle. As we know, Rust places distinction on whether a value is allocated on the heap or on the stack. Due to that, there are two kinds of strings in Rust: owned strings (<kbd>String</kbd>) and borrowed strings (<kbd>&amp;str</kbd>). Let's explore both of them.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Owned strings – String</h1>
                </header>
            
            <article>
                
<p>The <kbd>String</kbd> type comes from the standard library and is a heap-allocated UTF-8 encoded sequence of bytes. They are simply <kbd>Vec&lt;u8&gt;</kbd> under the hood but have extra methods that are applicable to only strings. They are owned types, which means that a variable that holds a <kbd>String</kbd> value is its owner. You will usually find that <kbd>String</kbd> types can be created in multiple ways, as shown in the following code:</p>
<pre>// strings.rs<br/><br/>fn main() {<br/>    let a: String = "Hello".to_string();    <br/>    let b = String::from("Hello");<br/>    let c = "World".to_owned();<br/>    let d = c.clone();<br/>}</pre>
<p>In the preceding code, we created four strings in four different ways. All of them create the same string type and have the same performance characteristics. The first variable, <kbd>a</kbd>, creates the string by calling the <kbd>to_string</kbd> method, which comes from the <kbd>ToString</kbd> trait with the string literal, <kbd>"Hello"</kbd>. A string literal such as <kbd>"Hello"</kbd> by itself also has a type of <kbd>&amp;str</kbd>. We'll explain them when we get to borrowed versions of strings. We then create another string, <kbd>b</kbd>, by calling the <kbd>from</kbd> method, which is an associated method on <kbd>String</kbd>. The third string <kbd>c</kbd>, is created by calling a trait method, <kbd>to_owned</kbd>, from the <kbd>ToOwned</kbd> trait, which is implemented for <kbd>&amp;str</kbd> types—literal strings. The fourth string, <kbd>d</kbd>, is created by cloning an existing string, <kbd>c</kbd>. The fourth way of creating strings is an expensive operation , which we should avoid as it involves copying the underlying bytes by iterating over them.</p>
<p>As <kbd>String</kbd> is allocated on heap, it can be mutated and can grow at runtime. This means that strings have an associated overhead when manipulating them because they might possibly get reallocated as you keep adding bytes to them. Heap allocation is a relatively expensive operation but, fortunately, the way allocation happens for <kbd>Vec</kbd> (doubled every capacity limit), means this cost is amortized over usage.</p>
<p>Strings also have a lot of convenient methods in the standard library. Following are the important ones:</p>
<ul>
<li><kbd>String::new()</kbd> allocates an empty <kbd>String</kbd> type.</li>
<li><kbd>String::from(s: &amp;str)</kbd> allocates a new <kbd>String</kbd> type and populates it from a string slice.</li>
<li><kbd>String::with_capacity(capacity: usize)</kbd> allocates an empty <kbd>String</kbd> type with a preallocated size. This is performant when you know the size of your string beforehand.</li>
<li><kbd>String::from_utf8(vec: Vec&lt;u8&gt;)</kbd> tries to allocate a new <kbd>String</kbd> type from <kbd>bytestring</kbd>. The contents of the parameter must be UTF-8 or this will fail. It returns the <kbd>Result</kbd> wrapper type.</li>
<li>The <kbd>len()</kbd> method on string instances gives you the length of the <kbd>String</kbd> type<span>,</span> taking Unicode into account. As an example, a <kbd>String</kbd> <span>type </span>containing the word <kbd>yö</kbd> has a length of two, even though it takes three bytes in memory.</li>
<li>The <kbd>push(ch: char)</kbd> and <kbd>push_str(string: &amp;str)</kbd> methods add a character or a string slice to the string.</li>
</ul>
<p>This is, of course, a non-exhaustive list. A complete list of all the operations can be found at <a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a>.</p>
<p>Here's an example that uses all of the aforementioned methods:</p>
<pre>// string_apis.rs<br/><br/>fn main() { <br/>    let mut empty_string = String::new(); <br/>    let empty_string_with_capacity = String::with_capacity(50); <br/>    let string_from_bytestring: String = String::from_utf8(vec![82, 85, 83,<br/>    84]).expect("Creating String from bytestring failed"); <br/><br/>    println!("Length of the empty string is {}", empty_string.len()); <br/>    println!("Length of the empty string with capacity is {}",<br/>    empty_string_with_capacity.len()); <br/>    println!("Length of the string from a bytestring is {}",<br/>    string_from_bytestring.len()); <br/><br/>    println!("Bytestring says {}", string_from_bytestring); <br/><br/>    empty_string.push('1'); <br/>    println!("1) Empty string now contains {}", empty_string); <br/>    empty_string.push_str("2345"); <br/>    println!("2) Empty string now contains {}", empty_string); <br/>    println!("Length of the previously empty string is now {}",<br/>    empty_string.len()); <br/>} </pre>
<p>With <kbd>String</kbd> explored, let's look at the borrowed version of strings known as string slices or the <kbd>&amp;str</kbd> type.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Borrowed strings – &amp;str</h1>
                </header>
            
            <article>
                
<p>We can also have strings as references called string slices. These are denoted by <kbd>&amp;str</kbd> (pronounced as <em>stir</em>), which is a reference to a <kbd>str</kbd> type. In constrast to the <kbd>String</kbd> type, <kbd>str</kbd> is a built-in type known to the compiler and is not something from the standard library. String slices are created as <kbd>&amp;str</kbd> by default—a pointer to a UTF-8 encoded byte sequence. We cannot create and use values of the bare <kbd>str</kbd> type, as it represents a contiguous sequence of UTF-8 encoded bytes with a finite but unknown size. They are technically called unsized types. We'll explain unsized types later in this chapter.</p>
<p><kbd>str</kbd> can only be created as a reference type. Let's assume we try to create a <kbd>str</kbd> type forcibly by providing the type signature on the left:</p>
<pre>// str_type.rs<br/><br/>fn main() {<br/>    let message: str = "Wait, but why ?";<br/>}</pre>
<p>We'll be presented with a confusing error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d9213101-fb42-45e3-bab3-5146b26c780e.png"/></p>
<p class="mce-root"/>
<p>It says: <span class="packt_screen">all local variables must have a statically known size</span>. This basically means that every local variable we define using a <kbd>let</kbd> statement needs to have a size as they are allocated on the stack and the stack has a fixed size. As we know, all variable declarations go on the stack either as values themselves or as pointers to heap allocated types. All stack-allocated values need to have a proper size known and, due to this, <kbd>str</kbd> cannot be initialized.</p>
<p><kbd>str</kbd> basically means a fixed-sized sequence of strings that's agnostic to the location where it resides. It could either be a reference to a heap-allocated string, or it could be a <kbd>&amp;'static str</kbd> string residing on the data segment of the process that lives for the entire duration of the program, which is what the <kbd>'static</kbd> lifetime denotes.</p>
<p>We can, however, create a borrowed version of <kbd>str</kbd>, as in <kbd>&amp;str</kbd>, which is what gets created by default when we write a string literal. So string slices are only created and used behind a pointer—<kbd>&amp;str</kbd>. Being a reference, they also have different lifetimes associated with them based on the scope of their owned variable. One of them is of <kbd>'static</kbd> lifetime, which is the lifetime of string literals.</p>
<p>String literals are any sequence of characters you declare within double quotes. For example, we create them like so:</p>
<pre>// borrowed_strings.rs<br/><br/>fn get_str_literal() -&gt; &amp;'static str {<br/>    "from function"<br/>}<br/><br/>fn main() {<br/>    let my_str = "This is borrowed";<br/>    let from_func = get_str_literal();<br/>    println!("{} {}", my_str, from_func);<br/>}</pre>
<p>In the preceding code, we have a <kbd>get_str_literal</kbd> <span>function </span>that returns a string literal. We also create a string literal <kbd>my_str</kbd> in <kbd>main</kbd>. <kbd>my_str</kbd> and the string returned by <kbd>get_str_literal</kbd> has the type, <kbd>&amp;'static str</kbd>. The <kbd>'static</kbd> lifetime annotation denotes that the string stays for the entire duration of the program. The <kbd>&amp;</kbd> prefix says that it's a pointer to the string literal, while <kbd>str</kbd> is the unsized type. Any other <kbd>&amp;str</kbd> type you encounter are <strong>borrowed string slices</strong> of any owned <kbd>String</kbd> type on the heap. The <kbd>&amp;str</kbd> types, once created, can't be modified as they are created immutable by default.</p>
<p class="mce-root"/>
<p>We can also take a mutable slice to the string, and the type changes to <kbd>&amp;mut str</kbd>, though it's uncommon to use them in this form except with a few methods in the standard library. The <kbd>&amp;str</kbd> type is the recommended type to be used when passing strings around, either to functions or to other variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Slicing and dicing strings</h1>
                </header>
            
            <article>
                
<p>All strings in Rust are guaranteed to be UTF-8 by default, and indexing on string types in Rust does not work as you would use them in other languages. Let's try accessing the individual characters of our string:</p>
<pre>// strings_indexing.rs<br/><br/>fn main() {<br/>    let hello = String::from("Hello");<br/>    let first_char = hello[0];<br/>}</pre>
<p>On compiling this, we get the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/12722a16-aaec-4fa4-8a72-9356a58b75cd.png"/></p>
<p>That's not a very helpful message. But it refers to something called the <kbd>Index</kbd> trait. The <kbd>Index</kbd> trait is implemented on collection types whose elements can be accessed by the indexing operator <kbd>[]</kbd> using index type as a <kbd>usize</kbd> value. Strings are valid UTF-8-encoded byte sequences and a single byte does not equate to a single character. In UTF-8, a single character may also be represented by multiple bytes. So, indexing does not work on strings.</p>
<p class="mce-root"/>
<p>Instead, we can have slices of strings. This can either be done as follows:</p>
<pre>// string_range_slice.rs<br/><br/>fn main() {<br/>    let my_str = String::from("Strings are cool");<br/>    let first_three = &amp;my_str[0..3];<br/>    println!("{:?}", first_three);<br/>}</pre>
<p>But, as is the case with all indexing operation, this panics if the start or the end index is not on a valid <kbd>char</kbd> boundary.</p>
<p>Another way to iterator over all characters of a string is to use the <kbd>chars()</kbd> method, which turns the string into an iterator over its characters. Let's change our code to use <kbd>chars</kbd> instead:</p>
<pre>// strings_chars.rs<br/><br/>fn main() {<br/>    let hello = String::from("Hello");<br/>    for c in hello.chars() {<br/>        println!("{}", c);<br/>    }<br/>}</pre>
<p>The <kbd>chars</kbd> method returns characters of the string at proper Unicode boundaries. We can also call other iterator methods on this to either skip or get a range of characters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using strings in functions</h1>
                </header>
            
            <article>
                
<p>It's idiomatic and performant to pass string slices to functions. Here's an example:</p>
<pre>// string_slices_func.rs<br/><br/>fn say_hello(to_whom: &amp;str) { <br/>    println!("Hey {}!", to_whom) <br/>} <br/><br/>fn main() { <br/>    let string_slice: &amp;'static str = "you"; <br/>    let string: String = string_slice.into(); <br/>    say_hello(string_slice); <br/>    say_hello(&amp;string); <br/>} </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>To the astute observer, the <kbd>say_hello</kbd> <span>method </span>also worked with a <kbd>&amp;String</kbd> type. Internally, <kbd>&amp;String</kbd> automatically coerces to <kbd>&amp;str</kbd>, due to the type coercion trait <kbd>Deref</kbd> implemented for <kbd>&amp;String</kbd> to <kbd>&amp;str</kbd>. This is because <kbd>String</kbd> implements <kbd>Deref</kbd> for the <kbd>str</kbd> type.</p>
<p>Here, you can see why I stressed the point earlier. A string slice is an acceptable input parameter not only for actual string slice references but also for <kbd>String</kbd> references! So, once more: if you need to pass a string to your function, use the string slice, <kbd>&amp;str</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Joining strings</h1>
                </header>
            
            <article>
                
<p>Another source of confusion when dealing with strings in Rust is when concatenating two strings. In other languages, you have a very intuitive syntax for joining two strings. You just do <kbd>"Foo" + "Bar"</kbd> and you get a <kbd>"FooBar"</kbd>. Not quite the case with Rust:</p>
<pre>// string_concat.rs<br/><br/>fn main() {<br/>    let a = "Foo";<br/>    let b = "Bar";<br/>    let c = a + b;<br/>}</pre>
<p>If we compile this, we get the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bb3f608a-3b51-44ff-adf0-11ad37c59fa4.png"/></p>
<p class="mce-root"/>
<p>The error message is really helpful here. The concatenation operation is a two step process. First, you need to allocate a string and then iterate over both of them to copy their bytes to this newly allocated string. As such, there's an implicit heap allocation involved, hidden behind the <kbd>+</kbd> operator. Rust discourages implicit heap allocation. Instead, the compiler suggests that we can concatenate two string literals by explicitly making the first one an owned string. So our code changes, like so:</p>
<pre>// string_concat.rs<br/><br/>fn main() {<br/>    let foo = "Foo";<br/>    let bar = "Bar";<br/>    let baz = foo.to_string() + bar;<br/>}</pre>
<p>So we made <kbd>foo</kbd> a <kbd>String</kbd> type by calling the <kbd>to_string()</kbd> method. With that change, our code compiles.</p>
<p>The main difference between both <kbd>String</kbd> and <kbd>&amp;str</kbd> is that <kbd>&amp;str</kbd> is natively recognized by the compiler, while <kbd>String</kbd> is a custom type from the standard library. You could implement your own similar <kbd>String</kbd> abstraction on top of <kbd>Vec&lt;u8&gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to use &amp;str versus String ?</h1>
                </header>
            
            <article>
                
<p>To a programmer coming to Rust, often the confusion is around which one to use. Well, the best practice is to use APIs that take a <kbd>&amp;str</kbd> type when possible, as when the string is already allocated somewhere, you can save copying and allocation costs just by referencing that string. Passing <kbd>&amp;str</kbd> around your program is nearly free: it incurs nearly no allocation costs and no copying of memory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Global values</h1>
                </header>
            
            <article>
                
<p>Apart from variable and type declarations, Rust also allows us to define global values that can be accessed from anywhere in the program. They follow the naming convention of every letter being uppercase. These are of two kinds: constants and statics. There are also constant functions, which can be called to initialize these global values. Let's explore constants first.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constants</h1>
                </header>
            
            <article>
                
<p>The first form of global values are constants. Here's how we can define one:</p>
<pre>// constants.rs<br/><br/>const HEADER: &amp;'static [u8; 4] = b"Obj\0"; <br/><br/>fn main() {<br/>    println!("{:?}", HEADER);<br/>}</pre>
<p>We use the <kbd>const</kbd> keyword to create constants. As constants aren't declared with the <kbd>let</kbd> keyword, specifying types is a must when creating them. Now, we can use <kbd>HEADER</kbd> where we would use the byte literal, <kbd>Obj\</kbd>.  <kbd>b""</kbd> is a convenient syntax to create a sequence of bytes of the <kbd>&amp;'static [u8; n]</kbd> type, as in a <kbd>'static</kbd> reference to a fixed-sized array of bytes. Constants represent concrete values and don't have any memory location associated with them. They are inlined wherever they are used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Statics</h1>
                </header>
            
            <article>
                
<p>Statics are proper global values, as in they have a fixed memory location and exist as a single instance in the whole program. These can also be made mutable. However, as global variables are a breeding ground for the nastiest bugs out there, there are some safety mechanisms in place. Both reading and writing to statics has to be done inside an <kbd>unsafe {}</kbd> block. Here's how we crate and use statics:</p>
<pre>// statics.rs<br/><br/>static mut BAZ: u32 = 4; <br/>static FOO: u8 = 9; <br/><br/>fn main() {<br/>    unsafe {<br/>        println!("baz is {}", BAZ);<br/>        BAZ = 42;<br/>        println!("baz is now {}", BAZ);<br/>        println!("foo is {}", FOO);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the code, we've declared two statics <kbd>BAZ</kbd> and <kbd>FOO</kbd>. We use the <kbd>static</kbd> keyword to create them along with specifying the type explicitly. If we want them to be mutable, we add the <kbd>mut</kbd> keyword after <kbd>static</kbd>. Statics aren't inlined like constants. When we read or write the static values, we need to use an <kbd>unsafe</kbd> block. Statics are generally combined with synchronization primitives for any kind of thread-safe use. They are also used to implement global locks and when integrating with C libraries.</p>
<p>Generally, if you don't need to rely on singleton property of statics and its predefined memory location and just want a concrete value, you should prefer using <kbd>consts</kbd>. They allow the compiler to make better optimizations and are more straightforward to use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compile time functions – const fn</h1>
                </header>
            
            <article>
                
<p>We can also define constant functions that evaluate their argument during compile time. This means that a <kbd>const</kbd> value declaration can have a value that's from an invocation of a <kbd>const</kbd> function. <kbd>const</kbd> functions are pure functions and must be reproducible. This means that they cannot take mutable arguments to any type. They also cannot include operations that are dynamic such as a heap allocation. They can be called in non-const places where they act just like normal functions. But when they are called in const contexts, they are evaluated at compile time. Here's how we define a const function:</p>
<pre>// const_fns.rs<br/><br/>const fn salt(a: u32) -&gt; u32 {<br/>    0xDEADBEEF ^ a<br/>}<br/><br/>const CHECKSUM: u32 = salt(23);<br/><br/>fn main() {<br/>    println!("{}", CHECKSUM);<br/>}</pre>
<p>In the code, we defined a <kbd>const</kbd> function, <kbd>salt</kbd>, that takes a <kbd>u32</kbd> value as parameter and does a <kbd>xor</kbd> operation with the hex value, <kbd>0xDEADBEEF</kbd>. Const functions are quite useful for operations that can be performed at compile time. For instance, let's say you are writing a binary file parser and you need to read the first four bytes of the file as an initialization and validation step for the parser. The following code demonstrates how we can do this entirely at runtime:</p>
<pre>// const_fn_file.rs<br/><br/>const fn read_header(a: &amp;[u8]) -&gt; (u8, u8, u8, u8) {<br/>    (a[0], a[1], a[2], a[3])<br/>}<br/><br/>const FILE_HEADER: (u8,u8,u8,u8) = read_header(include_bytes!("./const_fn_file.rs"));<br/><br/>fn main() {<br/>    println!("{:?}", FILE_HEADER);<br/>}</pre>
<p>In the code, the <kbd>read_header</kbd> function receives a file as a bytes array using the <kbd>include_bytes!</kbd> macro, which also reads the file at compile time. We then pull <kbd>4</kbd> bytes out of it and return it as a four-element tuple. Without the <kbd>const</kbd> function, all this would be done at runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic statics using the lazy_static! macro</h1>
                </header>
            
            <article>
                
<p>As we have seen, global values can only be declared for types that are non-dynamic in their initialization and have a known size on the stack at compile time. For example, you can't create a <kbd>HashMap</kbd> as a static value because it requires a heap allocation. Fortunately, we can have <kbd>HashMap</kbd> and other dynamic collection types such as <kbd>Vec</kbd> as global statics too, using a third-party crate called <kbd>lazy_static</kbd>. This crate exposes the <kbd>lazy_static!</kbd> macro, which can be used to initialize any dynamic type that's accessible globally from anywhere in the program. Here's a snippet of how to initialize a Vec that can be mutated from multiple threads:</p>
<pre>// lazy_static_demo<br/><br/>use std::sync::Mutex;<br/><br/>lazy_static! {<br/>    static ref ITEMS: Mutex&lt;Vec&lt;u64&gt;&gt; = {<br/>        let mut v = vec![];<br/>        v.push(9);<br/>        v.push(2);<br/>        v.push(1);<br/>        Mutex::new(v)<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Items declared within the <kbd>lazy_static!</kbd> macro are required to implement the Sync trait. This means if we want a mutable static, we have to use a multithreaded type such as <kbd>Mutex</kbd> or <kbd>RwLock</kbd> instead of  <kbd>RefCell</kbd>. We'll explain these types when we get to <a href="8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml">Chapter 8</a>, <em>Concurrency</em>. We'll be using this macro frequently in future chapters. Head over to the crate repository to learn more about using <kbd>lazy_static</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iterators</h1>
                </header>
            
            <article>
                
<p>We glimpsed iterators in <a href="d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml">Chapter 1</a>, <em>Getting Started with Rust</em>. To recap, an iterator is any ordinary type that can walk over elements of a collection type in one of three ways: via <kbd>self</kbd>, <kbd>&amp;self</kbd>, or  <kbd>&amp;mut self</kbd>. They are not a new concept and mainstream language such as C++ and Python have them already though that in Rust, they can appear surprising at first due to their form as an associated type trait. Iterators are used quite frequently in idiomatic Rust code when dealing with collection types.</p>
<p>To understand how they work, let's look at the definition of the <kbd>Iterator</kbd> trait from the <kbd>std::iter</kbd> module:</p>
<pre>pub trait Iterator {<br/>    type Item;<br/>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;<br/>    // other default methods omitted<br/>}</pre>
<p>The <kbd>Iterator</kbd> trait is an associated type trait which mandates the two items, to be defined for any implementing type. First is the associated type, <kbd>Item</kbd>, which specifies what item the iterator yields. Second is the <kbd>next</kbd> method, which is called every time we need to read a value from the type being iterated over. There are also other methods that we've omitted here, as they have default implementations. To make a type iterable, we only need to specify the <kbd>Item</kbd> type and implement the <kbd>next</kbd> method and all other methods with default implementations become available for the type. In this way, iterators are a really powerful abstraction. You can see the full set of default methods at: <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">https://doc.rust-lang.org/std/iter/trait.Iterator.html</a>.</p>
<p class="mce-root"/>
<p>The <kbd>Iterator</kbd> trait has a sibling trait called <kbd>IntoIterator</kbd>, which is implemented by types that want to convert in to an iterator. It provides the <kbd>into_iter</kbd> method that takes the implementing type via <kbd>self</kbd> and consumes the elements of the type.</p>
<p>Let's implement the <kbd>Iterator</kbd> trait for a custom type. Identify what you want to iterate over in your data type if it's not a collection. Then, create a wrapper struct holding any state of the iterator. Often, we' will find iterators being implemented for some wrapper type that references the collection type's element either by ownership or by an immutable or mutable reference. The methods to convert a type in to an iterator are also named conventionally:</p>
<ul>
<li><kbd>iter()</kbd> takes elements by reference.</li>
<li><kbd>iter_mut()</kbd> takes mutable reference to elements.</li>
<li><kbd>into_iter()</kbd> takes ownership of the values and consumes the actual type once iterated completely. The original collection can no longer be accessed.</li>
</ul>
<p>The type that implements the <kbd>Iterator</kbd> trait can be used in a <kbd>for</kbd> loop and under the hood, the next method of the item gets called. Consider the for loop as shown in the following:</p>
<pre>for i in 0..20 {<br/>    // do stuff<br/>}</pre>
<p>The preceding code would get de-sugared as follows:</p>
<pre>let a = Range(..);<br/>while let Some(i) = a.next() {<br/>    // do stuff<br/>}</pre>
<p>It' will repeatedly call <kbd>a.next()</kbd> until it matches a <kbd>Some(i)</kbd> variant. When it matches  <kbd>None</kbd>, the iteration stops.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a custom iterator</h1>
                </header>
            
            <article>
                
<p>To understand iterators more thoroughly, we'll implement an iterator that generates prime numbers up to a certain limit that's customizable by the user. First, let's clarify the API expectations that we'll need from our iterator:</p>
<pre>// custom_iterator.rs<br/><br/>use std::usize;<br/><br/>struct Primes {<br/>    limit: usize<br/>}<br/><br/>fn main() {<br/>    let primes = Primes::new(100);<br/>    for i in primes.iter() {<br/>        println!("{}", i);<br/>    }<br/>}</pre>
<p>So, we have a type called <kbd>Primes</kbd> that we can instantiate with the <kbd>new</kbd> method, providing the upper bound on the number of primes to generate. We can call <kbd>iter()</kbd> on this instance to convert it in to an iterator type, which can then be used in a <kbd>for</kbd> loop. With that said, let's add the <kbd>new</kbd> and <kbd>iter</kbd> methods on it:</p>
<pre>// custom_iterator.rs<br/><br/>impl Primes {<br/>    fn iter(&amp;self) -&gt; PrimesIter {<br/>        PrimesIter {<br/>            index: 2,<br/>            computed: compute_primes(self.limit)<br/>        }<br/>    }<br/><br/>    fn new(limit: usize) -&gt; Primes {<br/>        Primes { limit }<br/>    }<br/>}</pre>
<p>The <kbd>iter</kbd> method takes the <kbd>Primes</kbd> type via <kbd>&amp;self</kbd> and returns a <kbd>PrimesIter</kbd> type containing two fields: <kbd>index</kbd>, which stores the <kbd>index</kbd> in the vector, and a <kbd>computed</kbd> field that stores the pre-computed primes in a vector. The <kbd>compute_primes</kbd> method is defined as follows:</p>
<pre>// custom_iterator.rs<br/><br/>fn compute_primes(limit: usize) -&gt; Vec&lt;bool&gt; {<br/>    let mut sieve = vec![true; limit];<br/>    let mut m = 2;<br/>    while m * m &lt; limit {<br/>        if sieve[m] {<br/>            for i in (m * 2..limit).step_by(m) {<br/>                sieve[i] = false;<br/>            }<br/>        }<br/>        m += 1;<br/>    }<br/>    sieve<br/>}</pre>
<p>This function implements the sieve of the eratosthenes algorithm for efficiently generating prime numbers up to a given limit. Next, there's the definition of the <kbd>PrimesIter</kbd> struct along with its <kbd>Iterator</kbd> implementation:</p>
<pre>// custom_iterator.rs<br/><br/>struct PrimesIter {<br/>    index: usize,<br/>    computed: Vec&lt;bool&gt;<br/>}<br/><br/>impl Iterator for PrimesIter {<br/>    type Item = usize;<br/>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br/>        loop {<br/>            self.index += 1;<br/>            if self.index &gt; self.computed.len() - 1 {<br/>                return None;<br/>            } else if self.computed[self.index] {<br/>                return Some(self.index);<br/>            } else {<br/>                continue<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>In the <kbd>next</kbd> method, we loop and get the next prime number if the value at <kbd>self.index</kbd> is <kbd>true</kbd> in the <kbd>self.computed</kbd> <kbd>Vec</kbd>. If we went past the elements in our <kbd>computed</kbd> Vec, then we return <kbd>None</kbd> to signify that we are done. Here's the complete code with the main function that generates <kbd>100</kbd> prime numbers:</p>
<pre>// custom_iterator.rs<br/><br/>use std::usize;<br/><br/>struct Primes {<br/>    limit: usize<br/>}<br/><br/>fn compute_primes(limit: usize) -&gt; Vec&lt;bool&gt; {<br/>    let mut sieve = vec![true; limit];<br/>    let mut m = 2;<br/>    while m * m &lt; limit {<br/>        if sieve[m] {<br/>            for i in (m * 2..limit).step_by(m) {<br/>                sieve[i] = false;<br/>            }<br/>        }<br/>        m += 1;<br/>    }<br/>    sieve<br/>}<br/><br/>impl Primes {<br/>    fn iter(&amp;self) -&gt; PrimesIter {<br/>        PrimesIter {<br/>            index: 2,<br/>            computed: compute_primes(self.limit)<br/>        }<br/>    }<br/><br/>    fn new(limit: usize) -&gt; Primes {<br/>        Primes { limit }<br/>    }<br/>}<br/><br/>struct PrimesIter {<br/>    index: usize,<br/>    computed: Vec&lt;bool&gt;<br/>}<br/><br/>impl Iterator for PrimesIter {<br/>    type Item = usize;<br/>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br/>        loop {<br/>            self.index += 1;<br/>            if self.index &gt; self.computed.len() - 1 {<br/>                return None;<br/>            } else if self.computed[self.index] {<br/>                return Some(self.index);<br/>            } else {<br/>                continue<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>fn main() {<br/>    let primes = Primes::new(100);<br/>    for i in primes.iter() {<br/>        print!("{},", i);<br/>    }<br/>}</pre>
<p>We get the following output:</p>
<pre>3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97</pre>
<p>Great! Apart from <kbd>Vec</kbd>, there are a lot of types that implement the <kbd>Iterator</kbd> trait in the standard library, such as <kbd>HashMap</kbd>, <kbd>BTreeMap</kbd>, and <kbd>VecDeque</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced types</h1>
                </header>
            
            <article>
                
<p>In this section, we'll look at some of the advanced types in Rust. Let's first start with unsized types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unsized types</h1>
                </header>
            
            <article>
                
<p>Unsized types are categories of types that are first encountered if one tries to create a variable of the type, <kbd>str</kbd>. We know that we can create and use string references only behind references such as <kbd>&amp;str</kbd>. Let's see what error message we get if we try to create a <kbd>str</kbd> type:</p>
<pre>// unsized_types.rs<br/><br/>fn main() {<br/>    let a: str = "2048";<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We get the following error upon compilation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4c64fca4-6cf4-41ab-a462-c38cd22f9e2d.png"/></p>
<p>By default, Rust creates a reference type of <kbd>str</kbd> as <kbd>'static str</kbd>. The error message mentions that all local variables—values that live on the stack—must have a statically known size at compile time. This is because the stack memory is finite and we cannot have infinite- or dynamic-sized types. Similarly, there are other instances of types that are unsized:</p>
<ul>
<li><kbd>[T]</kbd>: This is a slice of type, <kbd>T</kbd>. They can only be used as <kbd>&amp;[T]</kbd> or <kbd>&amp;mut [T]</kbd>.</li>
<li><kbd>dyn Trait</kbd>: <span>This is a</span> trait object. They can only be used as a <kbd>&amp;dyn Trait</kbd> or <kbd>&amp;mut dyn Trait</kbd> type.</li>
<li>Any struct that has an unsized type as its last field is also considered an unsized type as well.</li>
<li>There's <kbd>str</kbd>, which we already explored. <kbd>str</kbd> internally is just a <kbd>[u8]</kbd> but with the added guarantee that the bytes are valid UTF-8.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function types</h1>
                </header>
            
            <article>
                
<p>Functions in Rust also have a concrete type and they differ in terms of their argument types and also in their <kbd>arity</kbd>, as in how many arguments they take, as in the example:</p>
<pre>// function_types.rs<br/><br/>fn add_two(a: u32, b: u32) -&gt; u32 {<br/>    a + b<br/>}<br/><br/>fn main() {<br/>    let my_func = add_two;<br/>    let res = my_func(3, 4);<br/>    println!("{:?}", res);<br/>}<br/><br/></pre>
<p>Functions in Rust are first class citizens. This means they can be stored in variables or passed to other functions or returned from functions. The preceding code declares a function <kbd>add_two</kbd>, which we store in <kbd>my_func</kbd> and later invoke with <kbd>3</kbd> and <kbd>4</kbd>.<br/></p>
<div class="packt_tip">Function types are not to be confused with <kbd>Fn</kbd> closures as they both have <kbd>fn</kbd> as their type signature prefix.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Never type ! and diverging functions</h1>
                </header>
            
            <article>
                
<p>We used a macro called <kbd>unimplemented!()</kbd>, which helps in letting the compiler ignore any unimplemented function and to compile our code. This works because the unimplemented macro returns something called a never type, denoted by <kbd>!</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unions</h1>
                </header>
            
            <article>
                
<p>For interoperability with C code, Rust also supports the <kbd>union</kbd> type, which maps directly to a C union. Unions are unsafe to read from. Let's see an example of how to create and interact with them:</p>
<pre>// unions.rs<br/><br/>#[repr(C)]<br/>union Metric {<br/>    rounded: u32,<br/>    precise: f32,<br/>}<br/><br/>fn main() {<br/>    let mut a = Metric { rounded: 323 };<br/>    unsafe {<br/>        println!("{}", a.rounded);<br/>    }<br/>    unsafe {<br/>        println!("{}", a.precise);<br/>    }<br/>    a.precise = 33.3;<br/>    unsafe {<br/>        println!("{}", a.precise);<br/>    }<br/>}</pre>
<p>We created a union type, <kbd>Metric</kbd>, that has two fields <kbd>rounded</kbd> and <kbd>precise</kbd>, and represents some measurement. In <kbd>main</kbd>, we initialize an instance of it in the <kbd>a</kbd> <span>variable</span>.</p>
<p>We can only initialize one of the variables, otherwise the compiler complains with the following message:</p>
<pre>error: union expressions should have exactly one field<br/>  --&gt; unions.rs:10:17<br/>   |<br/>10 |     let mut a = Metric { rounded: 323, precise:23.0 };</pre>
<p>We also had to use unsafe blocks to print fields of our union. Compiling and running the previous code gives us the following output:</p>
<pre>323<br/>0.000000000000000000000000000000000000000000453<br/>33.3</pre>
<p>As you can see, we get a garbage value for the uninitialized field, <kbd>precise</kbd>. At the time of writing this book, union types only allow <kbd>Copy</kbd> types as their fields. They share the same memory space with all of their fields, exactly like C unions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cow</h1>
                </header>
            
            <article>
                
<p>Cow is a smart pointer type that provides two versions of strings. It stands for Clone on Write. It has the following type signature:</p>
<pre>pub enum Cow&lt;'a, B&gt; where B: 'a + ToOwned + 'a + ?Sized,  {<br/>    Borrowed(&amp;'a B),<br/>    Owned(&lt;B as ToOwned&gt;::Owned),<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>First, we have the two variants:</p>
<ul>
<li>Borrowed that represents the borrowed version of some type B. This B has to implement the <kbd>ToOwned</kbd> trait.</li>
<li>There is also owned variant which contains the owned version of the type.</li>
</ul>
<p>This type is suitable for cases where one needs to avoid allocations where it's not needed. A real world example is the JSON parser crate called <kbd>serde_json</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced traits</h1>
                </header>
            
            <article>
                
<p>In this section, we'll discuss some of the advanced traits that are important to know when we are dealing with complex code bases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sized and ?Sized</h1>
                </header>
            
            <article>
                
<p>The <kbd>Sized</kbd> trait is a marker trait that represents types whose sizes are known at compile time. It is implemented for most types in Rust except for unsized types. All type parameters have an implicit trait bound of <kbd>Sized</kbd> in their definition. We can also specify optional trait bounds using the <kbd>?</kbd> operator before a trait, but the <kbd>?</kbd> operator with traits only works for marker traits as the time of writing this book. It may be extended to other types in future.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Borrow and AsRef</h1>
                </header>
            
            <article>
                
<p>These are special traits that carry the notion of able to construct a out of any type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ToOwned</h1>
                </header>
            
            <article>
                
<p>This trait is meant to be implemented for types that can be converted in to an owned version. For example, the <kbd>&amp;str</kbd> type has this trait implemented for <kbd>String</kbd>. This means the <kbd>&amp;str</kbd> type has a method called <kbd>to_owned()</kbd> on it that can convert it in to a <kbd>String</kbd> type, which is an owned type.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">From and Into</h1>
                </header>
            
            <article>
                
<p>To convert one type into another, we have the <kbd>From</kbd> and <kbd>Into</kbd> traits. The interesting part about both of these traits is that we only need to implement the <kbd>From</kbd> trait and we get the implementation of the <kbd>Into</kbd> trait for free, because of the following impl:</p>
<pre>#[stable(feature = "rust1", since = "1.0.0")]<br/>impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {<br/>    fn into(self) -&gt; U {<br/>        U::from(self)<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trait objects and object safety</h1>
                </header>
            
            <article>
                
<p>Object safety is a set of rules and restrictions that does not allow trait objects to be constructed. Consider the following code:</p>
<pre>// object_safety.rs<br/><br/>trait Foo {<br/>    fn foo();<br/>}<br/><br/>fn generic(val: &amp;Foo) {<br/><br/>}<br/><br/>fn main() {<br/><br/>}</pre>
<p>We get the following error upon compilation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/637e6031-d0a6-4e35-9ffe-ecad5de2e43d.png" style="width:49.75em;height:13.83em;"/></p>
<p class="mce-root"/>
<p>This brings us to the idea of object safety, which is a set of restrictions that forbids creating a trait object from a trait. In this example, since our type doesn't have a self reference, it's not possible to create a trait object out of it. In this case, to convert any type into a trait object, methods on the type need to be an instance—one that takes <kbd>self</kbd> by reference. So, we change our trait method declaration, <kbd>foo</kbd>, to the following:</p>
<pre>trait Foo {<br/>    fn foo(&amp;self);<br/>}</pre>
<p>This makes the the compiler happy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Universal function call syntax</h1>
                </header>
            
            <article>
                
<p>There are times when you are using a type that has the same set of methods as one of its implemented traits. In those situations, Rust provides us with the uniform function call syntax that works for calling methods that are either on types themselves or come from a trait. Consider the following code:</p>
<pre>// ufcs.rs<br/><br/>trait Driver {<br/>    fn drive(&amp;self) {<br/>        println!("Driver's driving!");<br/>    }<br/>}<br/><br/>struct MyCar;<br/><br/>impl MyCar {<br/>    fn drive(&amp;self) {<br/>        println!("I'm driving!");<br/>    }<br/>}<br/><br/>impl Driver for MyCar {}<br/><br/>fn main() {<br/>    let car = MyCar;<br/>    car.drive();<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The preceding code has two methods with the same name, <kbd>drive</kbd>. One of them is an inherent method and the other comes from the trait, <kbd>Driver</kbd>. If we compile and run this, we get the following output:</p>
<pre>I'm driving</pre>
<p>Well, what if we wanted to call the <kbd>Driver</kbd> trait's <kbd>drive</kbd> method? Inherent methods on types are given higher priority than other methods with the same name. To call a trait method, we can use the <strong>Universal Function Call Syntax</strong> (<strong>UFCS</strong>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trait rules</h1>
                </header>
            
            <article>
                
<p>Traits also have special properties and restrictions, which are important to know about when you are using them.</p>
<p>An important property of the type system in the context of traits is the <strong>trait coherence</strong> rule. The idea of trait coherence is that there should be exactly one implementation of a trait on a type that implements it. This should be quite obvious since, with two implementations there would be ambiguity in what to choose between the two.</p>
<p>Another rule that might confuse many about traits is the <strong>orphan rule</strong>. The orphan rule, in simple words, states that we cannot implement external traits on external types.</p>
<p>To word it in another way, either the trait must be defined by you if you are implementing something on an external type, or your type should be defined by you when you are implementing an external trait. This rules out the possibility of having conflicts in overlapping trait implementations across crates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Closures in depth</h1>
                </header>
            
            <article>
                
<p>As we know already, closures are a fancier version of functions. They are also first-class functions, which means that they can be put into variables or can be passed as an argument to functions or even returned from a function. But what sets them apart from functions is that they are also aware of the environment they are declared within and can reference any variable from their environment. The way they reference variables from their environment is determined by how the variable is used inside the closure.</p>
<p class="mce-root"/>
<p>A closure, by default, will try to capture the variable in the most flexible way possible. Only when the programmer needs a certain way of capturing the value will they coerce to the programmer's intent. That won't make much sense unless we see different kinds of closures in action. Closures under the hood are anonymous structs that implement three traits that represent how closures access their environment. We will look at the three traits (ordered from least restrictive to most restrictive) next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fn closures</h1>
                </header>
            
            <article>
                
<p>Closures that access variables only for read access implement the <kbd>Fn</kbd> trait. Any value they access are as reference types (<kbd>&amp;T</kbd>). This is the default mode of borrowing the closures assumes. Consider the following code:</p>
<pre>// fn_closure.rs<br/><br/>fn main() {<br/>    let a = String::from("Hey!");<br/>    let fn_closure = || {<br/>        println!("Closure says: {}", a);    <br/>    };<br/>    fn_closure();<br/>    println!("Main says: {}", a);<br/>}</pre>
<p>We get the following output upon compilation:</p>
<pre>Closure says: Hey!<br/>Main says: Hey!</pre>
<p>The <kbd>a</kbd> <span>variable</span> was still accessible even after invoking the closure as the closure used <kbd>a</kbd> by reference.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">FnMut closures</h1>
                </header>
            
            <article>
                
<p>When the compiler figures out that a closure mutates a value referenced from the environment, the closure implements the <kbd>FnMut</kbd> trait. Adapting the same code as before, we have the following:</p>
<pre>// fn_mut_closure.rs<br/><br/>fn main() {<br/>    let mut a = String::from("Hey!");<br/>    let fn_mut_closure = || {<br/>        a.push_str("Alice");    <br/>    };<br/>    fn_mut_closure();<br/>    println!("Main says: {}", a);<br/>}</pre>
<p>The previous closure adds the  <kbd>"Alice"</kbd> <span>string</span> to <kbd>a</kbd>. <kbd>fn_mut_closure</kbd> mutates its environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">FnOnce closures</h1>
                </header>
            
            <article>
                
<p>Closures that take ownership of the data they read from their environment get implemented with <kbd>FnOnce</kbd>. The name signifies that this closure can only be called once and, because of that, the variables are available only once. This is the least recommended way to construct and use closures, because you cannot use the referenced variables later:</p>
<pre>// fn_once.rs<br/><br/>fn main() {<br/>    let mut a = Box::new(23);<br/>    let call_me = || {<br/>        let c = a;<br/>    };<br/><br/>    call_me();<br/>    call_me();<br/>}</pre>
<p>This fails with the following error:</p>
<p><img src="assets/2fedfd1b-c35a-4c96-b0de-71bbe8b31a4f.png"/></p>
<p class="mce-root"/>
<p>But there are use cases where <kbd>FnOnce</kbd> closures are the only applicable closures. One such example is the <kbd>thread::spawn</kbd> method in the standard library used for spawning new threads.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consts in structs, enums, and traits</h1>
                </header>
            
            <article>
                
<p>Structs, enums, and traits definitions can also be provided with constant field members. They can be used in cases where you need to share a constant among them. Take, for example, a scenario where we have a <kbd>Circle</kbd> trait that's is meant to be implemented by different circular shape types. We can add a <kbd>PI</kbd> constant to the <kbd>Circle</kbd> trait, which can be shared by any type that has an  <kbd>area</kbd> property and relies on value of <kbd>PI</kbd> for calculating the area:</p>
<pre>// trait_constants.rs<br/><br/>trait Circular {<br/>    const PI: f64 = 3.14;<br/>    fn area(&amp;self) -&gt; f64;<br/>}<br/><br/>struct Circle {<br/>    rad: f64<br/>}<br/><br/>impl Circular for Circle {<br/>    fn area(&amp;self) -&gt; f64 {<br/>        Circle::PI * self.rad * self.rad<br/>    }<br/>}<br/><br/>fn main() {<br/>    let c_one = Circle { rad: 4.2 };<br/>    let c_two = Circle { rad: 75.2 };<br/>    println!("Area of circle one: {}", c_one.area());<br/>    println!("Area of circle two: {}", c_two.area());<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>We can also have consts in structs and enums:</p>
<pre>// enum_struct_consts.rs<br/><br/>enum Item {<br/>    One,<br/>    Two<br/>}<br/><br/>struct Food {<br/>    Cake,<br/>    Chocolate<br/>}<br/><br/>impl Item {<br/>    const DEFAULT_COUNT: u32 = 34;<br/>}<br/><br/>impl Food {<br/>    const FAVORITE_FOOD: &amp;str = "Cake";<br/>}<br/><br/>fn main() {<br/>    <br/>}</pre>
<p>Next, let's look at some of the advanced aspects of modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modules, paths, and imports</h1>
                </header>
            
            <article>
                
<p>Rust provides us with a lot of flexibility in terms of how we organize our project, as we saw in <a href="41099eaf-eb1e-4f75-bfdd-628152f59b58.xhtml">Chapter 2</a>, <em>Managing Projects with Cargo</em>. Here, we'll go into some of the advanced aspects of modules and different ways to introduce more privacy in our code.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Imports</h1>
                </header>
            
            <article>
                
<p>We can do <strong>nested imports</strong> of items from modules. This helps in reducing the taken up by imports. Consider the following code:</p>
<pre>// nested_imports.rs<br/><br/>use std::sync::{Mutex, Arc, mpsc::channel};<br/><br/>fn main() {<br/>    let (tx, rx) = channel();<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Re-exports</h1>
                </header>
            
            <article>
                
<p>Re-exports allows one to selectively expose items from a module. We were already using the convenience of reexports when we used the <kbd>Option</kbd> and <kbd>Result</kbd> types. Re-exports also helps in reducing the import path one has to write if the module is created a nested directory containing many submodules.</p>
<p>For example, here we have a sub module named <kbd>bar.rs</kbd> from a cargo project we created called <kbd>reexports</kbd>:</p>
<pre>// reexports_demo/src/foo/bar.rs<br/><br/>pub struct Bar;</pre>
<p>The <kbd>Bar</kbd> is a publicly exposed struct module under <kbd>src/foo/bar.rs</kbd>. If the user wants to use <kbd>Bar</kbd> in their code, they will have to write something like the following:</p>
<pre>// reexports_demo/src/main.rs<br/><br/>use foo::bar::Bar;<br/><br/>fn main() {<br/>    <br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The above <kbd>use</kbd> statement is quite verbose. When you have a lot of nested sub-modules in your project, this gets awkward and redundant. Instead, we can reexport <kbd>Bar</kbd> from the <kbd>bar</kbd> module all of the way to our crate root, like so, in our <kbd>foo.rs</kbd>:</p>
<pre>// reexports_demo/src/foo.rs<br/><br/>mod bar;<br/>pub use bar::Bar;</pre>
<p>To re-export, we use the <kbd>pub use</kbd> keyword. Now we can easily use <kbd>Bar</kbd> as well as using <kbd>foo::Bar</kbd>.</p>
<p>By default, Rust recommends <strong>absolute imports</strong> within root modules. Absolute imports are done starting with the <kbd>crate</kbd> keyword, whereas <strong>relative imports</strong> are done using the <kbd>self</kbd> keyword. When re-exporting sub-modules to their parent modules, we might benefit from relative imports, as using absolute imports becomes long and redundant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selective privacy</h1>
                </header>
            
            <article>
                
<p>The privacy of items in Rust starts at the module level. As a library author, to expose things to users from a module, we use the <kbd>pub</kbd> keyword. But there are items that we only want to expose to other modules within the crate, but not to the users. In such cases, we can use the <kbd>pub(crate)</kbd> modifier for the item, which allows the item to be exposed only within the crate.</p>
<p>Consider the following code:</p>
<pre>// pub_crate.rs<br/><br/>fn main() {<br/>    <br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced match patterns and guards</h1>
                </header>
            
            <article>
                
<p>In this section, we'll take a look at some of the advanced usage of match and let patterns. First, let's look at match.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Match guards</h1>
                </header>
            
            <article>
                
<p>We can also use match guards on arms (<kbd>if code &gt; 400 || code &lt;= 500</kbd>) to match on a subset of values. They start with an <kbd>if</kbd> expression.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced let destructure</h1>
                </header>
            
            <article>
                
<p>We have the following complex data that we want to match against:</p>
<pre>// complex_destructure.rs<br/><br/>enum Foo {<br/>    One, Two, Three<br/>}<br/><br/>enum Bar(Foo);<br/><br/>struct Dummy {<br/>    inner: Bar<br/>}<br/><br/>struct ComplexStruct {<br/>    obj: Dummy<br/>}<br/><br/>fn get_complex_struct() -&gt; ComplexStruct {<br/>    ComplexStruct {<br/>        obj: Dummy { inner: Bar(Foo::Three) }<br/>    }<br/>}<br/><br/>fn main() {<br/>    let a = get_complex_struct();<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Casting and coercion</h1>
                </header>
            
            <article>
                
<p>Casting is a mechanism of downgrading or upgrading a type to some other type. When the casting happens implicitly, it is called coercion. Rust also allows for casting types at various levels. The very obvious candidates are primitive numeric types. You may have the need to cast a <kbd>u8</kbd> type to promote to <kbd>u64</kbd> or to truncate <kbd>i64</kbd> to <kbd>i32</kbd>. To perform trivial casts, we use the <kbd>as</kbd> keyword, like so:</p>
<pre>let a = 34u8;<br/>let b = a as u64;</pre>
<p>It's not only primitive types—casting is supported at higher-level types too. We can also cast a reference of a type to its trait object, if it implements that particular trait. So we can do something like the following:</p>
<pre>// cast_trait_object.rs<br/><br/>use std::fmt::Display;<br/><br/>fn show_me(item: &amp;Display) {<br/>    println!("{}", item);<br/>}<br/><br/>fn main() {<br/>    let a = "hello".to_string();<br/>    let b = &amp;a;<br/>    show_me(b);<br/>    // let c = b as &amp;Display;<br/>}</pre>
<p>There are other classes of casting supported by various pointer types:</p>
<ul>
<li>Converting a <kbd>*mut T</kbd> to <kbd>*const T</kbd>. The other method is forbidden in safe Rust and requires an <kbd>unsafe</kbd> block</li>
<li>Converting  <kbd>&amp;T</kbd>  in to <kbd>*const T</kbd> and vice versa</li>
</ul>
<p>There is also another explicit and unsafe version of casting called <kbd>transmutes</kbd> and, because it's unsafe, it is very dangerous to use when you are unaware of the consequences. When used ignorantly, it leads you into situations similar to one where you create a pointer from an integer in C.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types and memory</h1>
                </header>
            
            <article>
                
<p>In this section, we'll touch on some aspects and low-level details of types in programming languages that are important to know if you are someone writing systems software and care about performance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory alignment</h1>
                </header>
            
            <article>
                
<p>This is one of those aspects of memory management that you will rarely have to care about unless performance is a strict requirement. Due to data access latency between memory and the processor, when the processor accesses data from memory, it does so in a chunk and not byte by byte. This is to help reduce the number of memory accesses. This chunk size is called the memory access granularity of the CPU. Usually, the chunk sizes are one word (32 bit), two word, four word, and so on, and they depend on the target architecture. Due to this access granularity, it is desired that the data resides in memory which is aligned to a multiple of the word size. If that is not the case, then the CPU has to read and then perform left or right shifts on the data bits and discard the unneeded data to read a particular value. This wastes CPU cycles. In most cases, the compiler is smart enough to figure out the data alignment for us, but in some cases, we need to tell it. There are two important terms we need to understand:</p>
<ul>
<li><strong>Word size:</strong> Word size means the number of bits of data processed by the microprocessor as a unit.</li>
<li><strong>Memory access granularity:</strong> The minimum chunk of data accessed by the CPU from the memory bus is called the memory access granularity.</li>
</ul>
<p>Data types in all programming languages have both a size and an alignment. The alignment of primitive types is equal to their size. So, usually, all primitive types are aligned and the CPU has no problem doing an aligned read for these. But when we create custom data types, compilers usually insert padding between our struct fields if they are not aligned to allow the CPU to access memory in an aligned manner.</p>
<p>Having known about data type size and alignment, let's explore the <kbd>std::mem</kbd> module from the standard library that allows us to introspect data types and their sizes.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the std::mem module</h1>
                </header>
            
            <article>
                
<p>In regard to types and their size in memory, the <kbd>mem</kbd> module from the standard library provides us with convenient APIs to inspect sizes and alignment of types and functionalities for initializing raw memory. Quite a few of these functions are unsafe and must only be used when the programmer knows what they are doing. We'll restrict our exploration to these APIs:</p>
<ul>
<li><kbd>size_of</kbd> returns the size of a type given via a generic type</li>
<li><kbd>size_of_val</kbd> returns the size of a value given as a reference</li>
</ul>
<p>Being generic, these methods are meant to be called using the turbofish <kbd>::&lt;&gt;</kbd> operator. We are not actually giving these methods a type as a parameter; we're just explicitly calling them against a type. If we were skeptical about the zero-cost claims of some of the preceding generic types, we could use these functions to check the overhead. Let's take a look at some sizes of types in Rust:</p>
<pre>// mem_introspection.rs<br/><br/>use std::cell::Cell; <br/>use std::cell::RefCell; <br/>use std::rc::Rc; <br/><br/>fn main() { <br/>    println!("type u8: {}", std::mem::size_of::&lt;u8&gt;()); <br/>    println!("type f64: {}", std::mem::size_of::&lt;f64&gt;()); <br/>    println!("value 4u8:  {}", std::mem::size_of_val(&amp;4u8)); <br/>    println!("value 4:  {}", std::mem::size_of_val(&amp;4)); <br/>    println!("value 'a': {}", std::mem::size_of_val(&amp;'a')); <br/><br/>    println!("value \"Hello World\" as a static str slice: {}", std::mem::size_of_val("Hello World")); <br/>    println!("value \"Hello World\" as a String: {}", std::mem::size_of_val("Hello World").to_string()); <br/><br/>    println!("Cell(4)): {}", std::mem::size_of_val(&amp;Cell::new(84))); <br/>    println!("RefCell(4)): {}", std::mem::size_of_val(&amp;RefCell::new(4))); <br/><br/>    println!("Rc(4): {}", std::mem::size_of_val(&amp;Rc::new(4))); <br/>    println!("Rc&lt;RefCell(8)&gt;): {}", std::mem::size_of_val(&amp;Rc::new(RefCell::new(4)))); <br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Another observation that's important to notice, is the size of various pointers. Consider the following code:</p>
<pre>// pointer_layouts.rs<br/><br/>trait Position {}<br/><br/>struct Coordinates(f64, f64);<br/><br/>impl Position for Coordinates {}<br/><br/>fn main() {<br/>    let val = Coordinates(1.0, 2.0);<br/>    let ref_: &amp;Coordinates = &amp;val;<br/>    let pos_ref: &amp;Position = &amp;val as &amp;Position;<br/>    let ptr:       *const Coordinates = &amp;val as *const Coordinates;<br/>    let pos_ptr: *const Position  = &amp;val as *const Position;<br/>    <br/>    println!("ref_: {}", std::mem::size_of_val(&amp;ref_));<br/>    println!("ptr: {}", std::mem::size_of_val(&amp;ptr));<br/>    println!("val: {}", std::mem::size_of_val(&amp;val));<br/>    println!("pos_ref: {}", std::mem::size_of_val(&amp;pos_ref));<br/>    println!("pos_ptr: {}", std::mem::size_of_val(&amp;pos_ptr));<br/>}</pre>
<p>We create pointers to a Coordinate struct in a bunch of different ways and we print their sizes by casting them as different kind of pointers. Compiling and running the code above, gives us the following output:</p>
<pre>ref_: 8<br/>ptr: 8<br/>val: 16<br/>pos_ref: 16<br/>pos_ptr: 16</pre>
<p>This clearly shows that trait objects and references to traits are fat pointers double the size of a normal pointer.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serialization and deserialization using serde</h1>
                </header>
            
            <article>
                
<p>Serialization and deserialization are important concepts to understand for any kind of application needs to transfer or store data in a compact manner. <strong>Serialization</strong> is the process by which an in-memory data type can be converted into a sequence of bytes, while <strong>deserilization</strong> is the opposite of that, meaning it can read data. Many programming languages provide support for converting a data structure into a sequence of bytes. The beautiful part about <kbd>serde</kbd> is that it generates the serialization of any supported type at compile time, relying heavily on procedural macros. Serialization and deserialization is a zero cost operation with serde most of the time.</p>
<p>In this demo, we'll explore the <kbd>serde</kbd> crate to serialize and deserialize a user defined type. Let's create a new project by running <kbd>cargo new serde_demo</kbd> with the following contents in <kbd>Cargo.toml</kbd>:</p>
<pre># serde_demo/Cargo.toml<br/><br/>[dependencies]<br/>serde = "1.0.84"<br/>serde_derive = "1.0.84"<br/>serde_json = "1.0.36"</pre>
<p>Following are the contents in <kbd>main.rs</kbd>:</p>
<pre><br/>serde_demo/src/main.rs<br/><br/>use serde_derive::{Serialize, Deserialize};<br/><br/>#[derive(Debug, Serialize, Deserialize)]<br/>struct Foo {<br/>    a: String,<br/>    b: u64<br/>}<br/><br/>impl Foo {<br/>    fn new(a: &amp;str, b: u64) -&gt; Self {<br/>        Self {<br/>            a: a.to_string(),<br/>            b<br/>        }<br/>    }<br/>}<br/><br/>fn main() {<br/>    let foo_json = serde_json::to_string(Foo::new("It's that simple", 101)).unwrap();<br/>    println!("{:?}", foo_json);<br/>    let foo_value: Foo = serde_json::from_str(foo_json).unwrap();<br/>    println!("{:?}", foo_value);<br/>}</pre>
<p>To serialize any native data type to a JSON-like format, we simply need to put a derive annotation over our types, which is the case of for our struct, <kbd>Foo</kbd>.</p>
<p><kbd>serde</kbd> supports a lot of serializers implemented as crates. Popular examples are <kbd>serde_json</kbd>, <kbd>bincode</kbd> and  <kbd>TOML</kbd>. More supported formats can be found at: <a href="https://github.com/TyOverby/bincode">https://github.com/TyOverby/bincode</a>. These serialization implementors, such as the <kbd>serde_json</kbd> crate, provide methods such as <kbd>to_string</kbd> to convert</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered quite a bit of detail on some of the advanced aspects of Rust's type system. We got to know the various traits that make writing ergonomic Rust code. We also saw advanced pattern matching constructs. In the end, we looked at the serde crate that is blazing fast in performing data serialization. The next chapter will be about how to do multiple things at the same time using concurrency.</p>


            </article>

            
        </section>
    </body></html>