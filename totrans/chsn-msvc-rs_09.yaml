- en: Simple REST Definition and Request Routing with Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll have a look at alternative frameworks for creating
    microservices. In the previous chapters, we used a `hyper` crate to handle HTTP
    interaction, but it required us to write asynchronous code. If you don''t need
    low-level control, if a microservice you''ve created won''t work with a high load,
    or if you need to write one simply and quickly, you can try using the following
    crates to create microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rouille`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nickel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rocket`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gotham`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will create four microservices that use database interaction
    concepts from previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces you to new crates—`rouille`, `nickel`, `rocket`, and
    `gotham`. You don't need to install special software instead of `cargo` and the
    Rust compiler, but you need a nightly version, because the Rocket framework requires
    it.
  prefs: []
  type: TYPE_NORMAL
- en: To make the examples complex, we will use SQL Database and an SMTP server. But
    you don't need to install this software locally. It's sufficient to start containers
    with PostgreSQL and Postfix servers using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the sources for this chapter from the relevant project on GitHub:
    [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Rouille
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `rouille` crate helps you to create a microservice with a simple routing
    declaration using the `route!` macro. This framework provides a synchronous API
    and every request is processed by a thread from a pool.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write a microservice for user registration using the Rouille framework.
    It allows users to create an account and authorize the use of other microservices.
    We can start by creating a server instance.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Rouille framework is very simple to use. It contains `start_server` functions
    that expect a function to handle every incoming request. Let''s create a `main`
    function that uses a `diesel` crate with an `r2d2` pool feature and calls a function
    to handle requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a `ConnectionManager` for a local `test.db` SQLite database and
    a `Pool` instance with this manager. We discussed this in previous chapters. We
    are interested in the line with the `rouille::start_server` function call. This
    function takes two arguments: a listening address and a closure for handling requests.
    We moved `pool` to the closure and called `handler` functions, which we declared
    underneath it to generate a response for a request with `Pool` as an argument.'
  prefs: []
  type: TYPE_NORMAL
- en: Since `handler` functions have to return a `Response` instance, we have to return
    a response with a 500 status code if a `handler` function returns an error. Looks
    pretty simple, doesn't it? Let's look at a `handler` function declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rouille framework contains a `router!` macro that helps you declare a handler
    for every path and HTTP method. If we add a `handler` function that is called
    from a closure we used in the `start_server` function call, the `router!` macro
    expects a request instance as the first argument and the desired number of request
    handlers. Let's analyze the four handler functions in order.
  prefs: []
  type: TYPE_NORMAL
- en: Root handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a simple handler that expects a `GET` method and returns a
    text response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Sign-up handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle sign-up requests, we need a `POST` method handler for the `/signup`
    path. We can declare it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This handler is more complex and also demonstrates how to parse the parameters
    of a request. We need to parse an HTML form with two parameters—`email` and `password`.
    To do this, we used the `post_input!` macro, which expects a request instance
    and a form declaration with types. The form structure declaration looks like a
    simple struct declaration without a name, but with fields. We added two necessary
    fields and the `post_input!` macro parsed a request to fill an object with the
    corresponding fields.
  prefs: []
  type: TYPE_NORMAL
- en: Since parsed parameters only fit types, we also had to add extra processing
    to it. The `email` field is a `String` type, and we used the `trim` method to
    remove unnecessary spacing and the `to_lowercase` method to convert it to lowercase.
    We used the `password` field without any changes and passed it as a parameter
    to the `pbkdf2_simple` method of the `rust-crypto` crate.
  prefs: []
  type: TYPE_NORMAL
- en: PBKDF2 is an algorithm that adds computational cost to an encrypted value to
    prevent brute-force attacks. If your microservice is attacked and your password
    is stolen, it won't be easy for attackers to find a password value to access the
    service with someone else's account. If you use hashes, then the attacker will
    be able to find the matching password quickly.
  prefs: []
  type: TYPE_NORMAL
- en: After we prepared parameters, we used them with object-relational mapping methods.
    First, to check whether the user with the provided email exists, we use a DSL
    generated by the `diesel` crate and, if the user doesn't exist, we generate a
    unique ID for the user using the `uuid` crate. The handler fills the `NewUser`
    instance with corresponding values and inserts it into a database. Upon success,
    it returns an empty JSON response. If the user already exists, the handler returns
    a response with a 400 status code (Bad Response) with a message to the effect
    that the user with the provided email already exists. Let's look at how to sign
    in with a stored user value.
  prefs: []
  type: TYPE_NORMAL
- en: Sign-in handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code represents a handler for the `/signin` request path and
    parses a query with the data from the HTML form using `post_input!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the data has been extracted, we get a connection from a pool and use types
    generated by the `diesel` crate to send a query to the database. The code gets
    the first record from the users table with the provided email value. After that,
    we use the `pbkdf2_check` function to check that the password matches the stored
    one. If the user is valid, we return a JSON value with the user's ID. In the next
    chapters, we won't provide this service directly but will use it from another
    microservice. If the password doesn't match, we will return a response with a
    `403` status code.
  prefs: []
  type: TYPE_NORMAL
- en: Default handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For cases where there is no path or method pair matched for the request, we
    can add a default handler. Our microservice returns a `404` error for all unknown
    requests. Add this to the `router!` macro call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prepare the database and run the server using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server is started, try to send sign-in and sign-up requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second request will return a response with a user identifier in JSON format
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we can try to implement another service with the `nickel` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Nickel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another framework  that helps us create a microservice very simply is `nickel`.
    In terms of the design of its handlers, it's very similar to `hyper`, but it's
    synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a service that sends emails to any address. This microservice will
    also build the email's body content from a template. To start with, we have to
    add the necessary dependencies to start a server instance.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write a mailer microservice, we need two dependencies: the `nickel` crate
    and the `lettre` crate. The first is a framework inspired by the Express framework
    for Node.js. The second implements the SMTP protocol and lets us interact with
    a mail server such as Postfix. Add these dependencies to `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `lettre` crate, we''re using version 0.9.0 from GitHub, because it''s
    not available on crates.io at the time of writing. We need to import some types
    from these crates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Types from the `std` and `failure` crates are not presented in the preceding
    code. Now we can declare the `Data` struct that represents the shared state of
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This struct contains two fields—a `Sender` to send messages to the mailer worker
    that we will implement later, and `TemplateCache`, which lets us load and render
    templates from a local directory. We will use it directly for the body of emails
    only, because this microservice won't render HTML responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code spawns a mail sender worker, creates an instance of the `Data`
    struct, creates a `Nickel` server, and binds it to the `127.0.0.1:8002` socket
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the `cache` field of the `Data` struct, we set a `TemplateCache` instance
    that needs `ReloadPolicy` as an argument. The `ReloadPolicy` parameter controls
    how often templates will be reloaded. We use the `Always` variant, which means
    templates will be reloaded on every rendering. It lets an administrator update
    templates without interrupting the service.
  prefs: []
  type: TYPE_NORMAL
- en: To start the server, we need to create a `Nickel` instance, which we initialize
    with the `Data` instance using the `with_data` method. Since `Data` will be shared
    across threads, we have to wrap `Sender` with `Mutex`. `TemplateCache` already
    implements `Sync` and `Send` and can be shared safely.
  prefs: []
  type: TYPE_NORMAL
- en: We add two methods to the `Nickel` server instance using the `get` and `post`
    methods. We add two handlers. The first is for the root path, `/`, which uses
    the `middleware!` macro from the `nickel` crate to attach a handler that returns
    a text response. The second handles requests with the `/send` path and calls the `send`
    function, which is implemented beneath that. The last method call, `listen`, binds
    the server's socket to an address. Now we can move forward and implement a handler.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handlers of the Nickel framework take two parameters: a mutable reference to
    a `Request` struct and an owned `Response` instance that we can fill with data.
    Handlers have to return `MiddlewareResult`. Every input and output type has a
    type parameter of a shared data type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nickel` crate contains the `try_with!` macro. It needs to unwrap the `Result`
    type, but returns an HTTP error if the result equals `Err`. I created the `send_impl`
    method to use the usual `?` operator; `failure::Error` is the error type. I''ve
    found this to be more common than using a special macro such as `try_with!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We mapped the result to `BadRequest`. If the method returns `Ok`, we will send
    a JSON `true` value as a response. We don't need to use serialization for this
    simplest type of JSON value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the `send_impl` function implementation. Let''s take
    it apart piece by piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Request` instance has the `from_body` method, which returns query parameters
    as a `Params` struct instance. The `get` method of `Params` returns a parameter
    called `Option`. If any of the parameters are not provided, we return an `Err`
    value, because the method requires all parameters to be set.
  prefs: []
  type: TYPE_NORMAL
- en: To get access to a shared server's data, there is the `server_data` method of
    `Request`, which returns a `Data` instance, because we set this type as a type
    parameter of a `Request` and provided an instance of `Data` to the server.
  prefs: []
  type: TYPE_NORMAL
- en: When we have got all the parameters, we can extract a `Sender` instance (used
    to send tasks to a worker) compose an email using a template from the cache, and
    send it to a worker. We create an `EmailAddress` instance from the `to` parameter
    of the query. Then, we fill `HashMap` with parameters for a template that contains
    the `code` parameter with a confirmation code value.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters have been prepared and we use the `cache` field of the `Data`
    instance to get access to `TemplateCache`. The `render` method of the cache loads
    a template and fills it with the provided parameters. The `render` method expects
    a buffer to fill the rendered content. After we get it, we create a `SendableEmail`
    instance, we clone a `Sender`, and use the cloned instance to send an email to
    a worker. Let's look at how an email worker is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Worker for sending emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use a separate thread that receives `SendableEmail` values and send them
    using the SMTP protocol. The following code creates an instance of `SmtpClient`
    and uses the `credentials` method to set the credentials for a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`StmpClient` has moved to the new thread''s context. It''s wrapped with `SmtpTransport`
    and is used to send every received `SendableEmail` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: The worker implements a non-transactional email sender. If you want a guarantee
    of email delivery, you need to implement more diverse interaction with a mail
    server, or you can even embed an email server, or use a third-party service. I
    recommend you use as many external services as possible; they will cost you, but
    you will save much more on maintenance. We implemented the mailer service for
    demonstration purposes only to show how to integrate multiple services together
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start our microservice, we need a working SMTP server. Let''s create
    one with Docker. The following command creates a container with a Postfix server
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The server exposes port `*25*` and we remap it to local port `*2525*`. The
    command sets all the necessary parameters using environment variables and now
    the mailer microservice is ready to compile and run. Do so using the `cargo run`
    command, and when it starts, check it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When you call this command, the microservice will build and send an email to
    the Postfix server. Actually, the email won't be delivered, because our mail server
    works as a relay only and many mail services will reject emails from this kind
    of mail server. If you want to receive emails, you need to configure the service
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next framework we will explore is Rocket. It's a simple-to-use framework
    that uses the nightly compiler's features to provide a tool that converts a set
    of Rust functions into a complete web service. The Rocket framework is different
    than the frameworks we've discussed before. It implements application configurations
    with environment variables and logging. The imperfection of this approach is that
    tuning and replacing parts is a little complex, but the positive side of this
    approach is that you spend next to no time coding the logging and configuration
    capabilities of your microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a microservice that implements the commenting features of our application.
    It will take new comments and store them in a database. Also, a client can request
    any and all comments from the microservice. To start with, we need to bootstrap
    a new server with the Rocket framework.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start a server instance, we have to prepare a database interaction. But
    it doesn''t work directly as it did with the `diesel` crate. To connect a database,
    we have to add the crates we need and activate the necessary features of the `rocket_contrib`
    crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `diesel_sqlite_pool` feature of the `rocket_contrib` crate and `sqlite`
    with `r2d2` from the `diesel` crate. The following lines of code import macros
    from all of the crates we need, add the `comment` module that we will create later,
    and import all necessary types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also see that we used two features from the nightly release: `proc_macro_hygiene`
    and `decl_macro`. Without these features, you can''t declare handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The nightly Rust compiler contains a lot of cool but unstable features. Unstable
    doesn''t mean you can''t use them in production applications; it means the features
    may be changed or even removed. Their being unstable means that it''s risky to
    use these, because you may need to rewrite your code later. The Rocket framework
    requires you to use some unstable features. You can find the complete list of
    unstable features in the Unstable Book: [https://doc.rust-lang.org/stable/unstable-book/](https://doc.rust-lang.org/stable/unstable-book/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can connect to SQLite Database in the code. To do so, we create a wrapper
    for `SqliteConnection` and the user database attribute to assign a database connection
    is set in the `global.database.sqlite_database` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another feature we used is migration embedding, which includes all of the SQL
    scripts from the `migrations` folder in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create and launch a server instance. We create a `Rocket` instance
    with the `ignite` method call, but before we launch it, we add two middleware
    called fairings in the Rocket framework. The first is created for the `Db` database
    wrapper and provides a database pool in requests. The second is the `AdHoc` fairing,
    which tries to run migrations for a database. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After that, we call the `mount` method to add routes to the root path. Routes
    are created by the `routes!` macro, where we include all of the routes defined
    later in this section. When the `Rocket` instance is built, we run it with the `launch`
    method call.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our microservice contains two handlers. The first handles the request for the `/list`
    path and returns all comments from a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a handler in the Rocket framework is a function that takes parameters
    that `**rocket**` automatically binds and expects a function to return a result.
    Our `list` function returns a list of comments in JSON format. We use the `Comment`
    model declared in the `comment` module to extract all comments using a connection
    from a pool provided as an argument of function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a method and a path, we add the `get` attribute to a function declaration
    with the path we need. The get attribute allows you to call a handler with the `GET`
    method. Also, there is the `post` attribute, which we use for adding the comment
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function expects two parameters: `Form`, which can be parsed
    to the `NewComment` object, and the `Db` instance. The `Form` wrapper holds the
    inner value of the provided type. To extract it, we call the `into_inner` method,
    which returns the `NewComment` struct in our case. If form doesn''t provide a
    request, the method won''t even be called. We set the `data` bind in the `post`
    attribute to set an argument that stores the provided data. At the end, we use
    the insert method of the `Comment` type to insert the `NewComment` struct into
    the database using the provided `Connection`.'
  prefs: []
  type: TYPE_NORMAL
- en: That's all! The microservice has been declared. It's pretty simple, isn't it?
    But the final thing we need is a schema declaration. Let's add that.
  prefs: []
  type: TYPE_NORMAL
- en: Database schema and models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comments will be stored in a `comments` table that has three fields: the `id`
    of a comment, the `uid` of a user, and the `text` of a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Comment` struct has the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We repeated the same field in the `Comment` struct and added the `NewComment`
    struct without `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And now for something new—we derive the `FormForm` type for the `NewComment`
    struct. It helps Rocket convert a query into a `Form` instance. The next `Comment`
    struct implementation adds two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We use the generated method with the `diesel` crate to interact with a database
    using a `Connection` instance. If you want to know more about the `diesel` crate,
    you can read more in [Chapter 8](78b65084-762a-4697-b142-f47b2120e4c6.xhtml),
    *Interaction to Database with Object-Relational Mapping*.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run a microservice created with `Rocket`, you need to create a `Rocket.toml`
    configuration file. This allows you to configure a microservice before starting.
    Look at the following `Rocket.toml` contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this configuration, we declared global parameters such as: the `template_dir`
    directory with templates (if we use it), `address` and `port`, and a `url` for
    a database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can override any parameter using environment variables. For example, if
    we need to set the `port` parameter to 80, we can run a microservice with a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The Rocket framework also supports three different types of environment: `development`,
    `staging`, and `production`. It allows you to have three configurations in one.
    Add an extra section in addition to the `global` section and run a microservice
    with the corresponding mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To test a microservice, it''s sufficient to start it with a simple cargo run
    without extra parameters. When the service starts, we can add a comment with the
    following command and print a list of all comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This command prints all comments in JSON format. As you can see, we don't convert
    any structs directly to JSON. Rocket does this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Gotham
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how to use three frameworks that simplify writing microservices:
    Rouille, Nickel, and Rocket. But all of these frameworks are synchronous. If you
    want to write an asynchronous microservice, you have three paths to choose from:
    using the `hyper` crate directly, as we did in [Chapter 2](621dffeb-7f43-4c11-9ac5-00a366dc8d9f.xhtml),
    *Developing a Microservice with Hyper Crate*; using the `gotham` crate, which
    uses `hyper` and `tokio` internally; or using the `actix-web` framework. In this
    section, we will learn how to use the `gotham` crate with the asynchronous `tokio-postgres`
    crate to work with PostgreSQL asynchronously. We will learn about the `actix-web`
    crate later, in [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *Involving
    Concurrency with Actors and Actix Crate*.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example of using the `gotham` crate, we will create a microservice that
    takes the `User-Agent` `header` from a request and stores it in a PostgreSQL database.
    We will create a completely asynchronous application and also learn about the `tokio-postgres`
    crate.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new binary crate and add the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we added the `gotham` and `gotham_derive` crates. The first
    is a framework and the second helps us derive an implementation of the `StateData`
    trait for the shared state with the connection we need. The `gotham_derive` crate
    can also be used to derive the `NewMiddleware` trait for middleware, but we don't
    need special middleware for our example.
  prefs: []
  type: TYPE_NORMAL
- en: We also added the `tokio-postgres` crate to dependencies. It contains an implementation
    of an asynchronous database connector for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Types of framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a lot of types for the microservice. Let''s talk a little about every
    type we import here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Most likely, you are familiar with types from `failure` and `futures` crates,
    because we used them a lot in the first part of the book. The most interesting
    are types of the `gotham` crate. There are modules that cover different parts
    of the framework; the `handler` module contains `HandlerFuture`, which is an alias
    to the `Future` trait with predefined types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We will use this `Future` alias in our asynchronous handlers. Also, this module
    contains the `IntoHandlerFuture` trait, which is implemented for a tuple that
    can be converted into a response.
  prefs: []
  type: TYPE_NORMAL
- en: The `middleware` module contains `StateMiddleware`, which we will use to attach
    a state to our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pipeline` module contains two functions we will use: `single_middleware`
    and `single_pipeline`. The first creates a `Pipeline` with a single provided middleware
    inside. The second function is necessary to create a pipeline chain from a single
    pipeline instance.'
  prefs: []
  type: TYPE_NORMAL
- en: The `router` module includes types we need to construct a routing table for
    our microservice. The `Router` struct is a type that contains routes and we have
    to instantiate and provide it for a server. We will do this with the `build_router`
    function call.
  prefs: []
  type: TYPE_NORMAL
- en: For the `DrawRoutes` trait, we need to have methods of `Router` to add paths.
    It adds `get`, `get_or_head`, `put`, `post`, and other methods to register paths
    with corresponding HTTP methods. Calling those methods returns the `SingleRouteBuilder`
    instance and we need to use the `DefineSingleRoute` trait for the `to` method,
    which allows us to map a registered path to a `Handler`.
  prefs: []
  type: TYPE_NORMAL
- en: The `state` module provides us with the capability to use generic `State` and
    convert it to a type we need by calling the `borrow_from` method of the `FromState`
    trait that implemented the types that implement the `StateData` trait.
  prefs: []
  type: TYPE_NORMAL
- en: Generic `State` in `gotham` is a very flexible concept and provides the capability
    to get references to different parts of the environment. You can get a reference
    to your own state type or to the request data.
  prefs: []
  type: TYPE_NORMAL
- en: We need some types from the `hyper` crate, because the crate is used in the  `gotham`
    implementation and in some types of `hyper`. We imported the `Response` type to
    create responses for a client and the `HeaderMap` to get access to request headers,
    because we need to get a value for the `USER_AGENT` `header`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are developing an asynchronous application, we have to use the same
    reactor to execute all tasks in the same runtime. To do this, we will use a manually
    created `Runtime` from the `tokio` crate.
  prefs: []
  type: TYPE_NORMAL
- en: To connect to a database, we need to import the `Client` type from the `tokio-postgres`
    crate and `NoTls` to configure a connection.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have imported all we need to write the `main` function of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `main` function implementation, we create a `Runtime` instance, which
    we will use for database queries and to process HTTP requests. Look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `Runtime` instance. After that, we can create a new database connection
    by calling the connect function of the `tokio-postgres` crate. It returns a `Future`
    that we have to execute immediately. To run a `Future`, we will use the same `Runtime`
    we have already created. `Runtime` has the `block_on` method, which we have already
    discussed in [Chapter 5,](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml) *Understanding
    Asynchronous Operations with Futures Crate*. We call it with a `Connect` future
    and take a pair of results: `Client` and `Connection` instances.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Client` is a type that provides a method to create statements. We will store
    this instance in `ConnState`, which we will declare later in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Connection` type is a task that performs actual interaction with a database.
    We have to spawn this task within `Runtime`. If you forget to do this, your database
    queries will be blocked and will never be sent to a database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the `Client` instance to execute SQL statements. The first statement
    we need creates a table to log `User-Agent` `header` values. The `Client` struct
    has the `batch_execute` method, which executes multiple statements from a string.
    We''ve used only one statement, but this call is useful if you want to create
    more than one table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`batch_execute` returns a `Future` instance and we have to execute it immediately
    to initialize the database before inserting a record into it. We use the `block_on`
    method of a `Runtime` instance to execute the statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we finish implementing the main function, let''s look at the `ConnState`
    struct implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The struct is very simple and contains the atomic reference counter, `Arc`,
    to a database `Client` wrapped with a `Mutex`. We need only one method to simplify
    instance creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: But you can also add a method to get the inner value of this state. It's useful
    if you want to declare a state type in a separate module. We will use the `client`
    field directly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you might notice that `ConnState` derives `Clone` and `StateData` traits.
    The struct has to be cloneable, because a state is cloned by Gotham for every
    request. `StateData` allows us to attach an instance of this struct to `StateMiddleware`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can finish the `main` function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We created the `ConnState` state with a `Client` value. We stored the result
    to the `state` variable and used it for the `router` function call, which we will
    declare later.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can start a Gotham server by calling the `start_on_executor`
    function. It expects three arguments: the *address* that we set to the `"127.0.0.1:7878"`
    value, the *router* value that we created with the `router` function call, and
    the `TaskExecutor` instance that we extracted from our `Runtime`.'
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the `start_on_executor` function call the spawns a task to the asynchronous
    reactor and we have to start our `Runtime` instance. We can do this with the `shutdown_on_idle`
    method call. It returns the `Shutdown` future that we run in the current thread
    using the `wait` method call. The `main` function ends when all tasks are complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `router` function implementation that creates the `Router`
    instance for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the function implementation, we create a `StateMiddleware` instance and provide
    `ConnState` to it. We add a middleware to a pipeline with the `single_middleware`
    call and create a chain by calling the `single_pipeline` function call. It returns
    a pair of a chain and a set of pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: We pass these values to the `build_router` function, which returns the `Router`
    instance, but we can tune the resulting `Router` by calling methods of `RouterBuilder`
    in a closure that we pass as a third argument to the `build_router` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We called the get method of `RouterBuilder` to set a handler implemented in
    the `register_user_agent` function to the root path, `/`. The Gotham framework
    supports scopes of routes that help you group handlers by a path prefix, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We now only have to implement a handler.
  prefs: []
  type: TYPE_NORMAL
- en: Handler implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every handler in Gotham has to return the `HandlerFuture` implementation of
    a tuple that can be converted to `HandlerFuture`. Also, a handler has to accept
    a `State` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember, we need to extract the `User-Agent` `header` from a request.
    We can do this using a `State` value, because we can borrow `HeaderMap` from a
    `State` with the `borrow_from` method call. It returns a map that we can use to
    get the `User-Agent` HTTP `header` by using the `USER_AGENT` key imported from
    the `hyper` crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`HeaderMap` returns `HeaderValue` as a value of `header` and we have to get
    the string value using the `to_str` method and convert it to an owned string with
    the `to_string` method. If the `header` was not provided, we use the `"<undefined>"`
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can borrow the `ConnState` value from `State` and add a new record to
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We need two references to a `Client`, because we have to resolve two futures:
    one is to prepare a query, the second to execute that query. To prepare a query,
    we will use the `prepare` method, which expects a string with a SQL statement.
    The method call returns a `Future` instance that returns a `Statement` instance,
    but we can''t create that `Future` directly in the function''s body, because we
    have to lock `Mutex` to get access to the `Client` and it will be blocked after
    the `Future` statement is resolved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Client` twice, we need two references to the `Client` and use them
    in separate closures in a chain of futures. We start creating a futures chain
    with the `future::ok` method call, which returns a successful `Future`. We use
    the `and_then` method to add the first step: statement preparation. We lock the
    `Mutex` to get a mutable reference to a `Client`. Then, we call the `prepare`
    method to create a `Future `that returns a `Statement`.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond that, we can add the next step to the futures chain to fill a `Statement`
    with values. We lock the second `Mutex` clone to the call query method of a `Client`.
    The method expects a statement as a first parameter and a reference to an array
    with references to values. Since we know that the statement we're using inserts
    a new record and returns exactly one row, we extract a `String` value from the
    first position of the first row.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chain, we then use the method to convert a `Result` of the
    query execution into a `Response`. We create a new `Builder` for a `Response`.
    If the query returns a successful result, we return it to a client. If the query
    fails, we print an error with the `500` status code. The closure returns a tuple
    with a pair: the `State` and `Response` instances. Gotham uses this result to
    return the response to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is finished and now we can check it with a database instance.
  prefs: []
  type: TYPE_NORMAL
- en: Running and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run this example, we need a PostgreSQL database instance. The simplest way
    to run it is to start a Docker container. We already did that in [Chapter 7](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml),
    *Reliable Integration with Databases*, where we studied how to use Rust with databases.
    You can start a new container with a PostgreSQL database instance using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When the container is started, run the example server we wrote in this section
    with the `cargo run` command. It prints after compilation and the server is ready
    to accept requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use the link provided to log visits from your browser. If it is
    configured successfully, you will see the response in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc7f0d17-5d2d-44d8-b313-1c01b32cc5c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Gotham processed the request and returned a result to you. If you shut down
    the database, the server will return a response with a 500 error code and the *"connection
    closed"* string. The last thing we have to do is verify that the server added
    the records to the database, because we used an asynchronous approach to interact
    with the database and used the same `Runtime` to handle HTTP requests and perform
    SQL statements. Run the `**psql**` client for the `postgres://postgres@localhost:5432`
    connection and enter a query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We made two requests from two different browsers and now we have two records
    in the `agents` table.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced you to comfortable frameworks that greatly simplify
    the writing of microservices: Rouille, Nickel, and Rocket.'
  prefs: []
  type: TYPE_NORMAL
- en: The Rouille framework is built around the `router!` macro and helps you to declare
    all the paths and methods you need in a simple way. The routing declaration looks
    similar to how we did it with Hyper, but much, much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The Nickel framework is also pretty simple to use and is inspired by the Express
    framework of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The Rocket framework is pretty cool and helps you to write a handler in an intuitive,
    clear style, but it needs the nightly version of the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gotham framework is an asynchronous framework that''s based on the `tokio`
    and `hyper` crates. It allows you to use all of the benefits of asynchronous applications:
    handling thousands of requests in parallel and utilizing all resources completely.
    We created an example that works with a database by sending queries to it using
    the asynchronous `tokio-postgres` crate.'
  prefs: []
  type: TYPE_NORMAL
- en: But there are many more frameworks and we can't cover all of them. Most frameworks
    are synchronous and are simple to use. If you want to write an asynchronous microservice,
    I recommend you use, in most cases, the `actix-web` crate, which we will explore
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
