- en: Simple REST Definition and Request Routing with Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用框架进行简单的REST定义和请求路由
- en: 'In this chapter, we''ll have a look at alternative frameworks for creating
    microservices. In the previous chapters, we used a `hyper` crate to handle HTTP
    interaction, but it required us to write asynchronous code. If you don''t need
    low-level control, if a microservice you''ve created won''t work with a high load,
    or if you need to write one simply and quickly, you can try using the following
    crates to create microservices:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨创建微服务的替代框架。在前面的章节中，我们使用了`hyper`crate来处理HTTP交互，但它要求我们编写异步代码。如果你不需要低级控制，如果你创建的微服务在高负载下无法工作，或者你需要简单快速地编写代码，你可以尝试使用以下crate来创建微服务：
- en: '`rouille`'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rouille`'
- en: '`nickel`'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nickel`'
- en: '`rocket`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rocket`'
- en: '`gotham`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gotham`'
- en: In this chapter, we will create four microservices that use database interaction
    concepts from previous chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建四个使用之前章节中数据库交互概念的微服务。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter introduces you to new crates—`rouille`, `nickel`, `rocket`, and
    `gotham`. You don't need to install special software instead of `cargo` and the
    Rust compiler, but you need a nightly version, because the Rocket framework requires
    it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了新的crate——`rouille`、`nickel`、`rocket`和`gotham`。你不需要安装除`cargo`和Rust编译器之外的特殊软件，但你需要一个nightly版本，因为Rocket框架需要它。
- en: To make the examples complex, we will use SQL Database and an SMTP server. But
    you don't need to install this software locally. It's sufficient to start containers
    with PostgreSQL and Postfix servers using Docker.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例复杂，我们将使用SQL数据库和SMTP服务器。但你不需要在本地安装此软件。使用Docker启动带有PostgreSQL和Postfix服务器的容器就足够了。
- en: 'You can get the sources for this chapter from the relevant project on GitHub:
    [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter09).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub上的相关项目获取本章的源代码：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter09)。
- en: Rouille
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rouille
- en: The `rouille` crate helps you to create a microservice with a simple routing
    declaration using the `route!` macro. This framework provides a synchronous API
    and every request is processed by a thread from a pool.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`rouille`crate帮助你使用`route!`宏通过简单的路由声明创建微服务。这个框架提供了一个同步API，每个请求都由池中的一个线程处理。'
- en: Creating a microservice
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建微服务
- en: Let's write a microservice for user registration using the Rouille framework.
    It allows users to create an account and authorize the use of other microservices.
    We can start by creating a server instance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Rouille框架编写一个用户注册的微服务。它允许用户创建账户并授权使用其他微服务。我们可以从创建服务器实例开始。
- en: Bootstrapping a server
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务器
- en: 'The Rouille framework is very simple to use. It contains `start_server` functions
    that expect a function to handle every incoming request. Let''s create a `main`
    function that uses a `diesel` crate with an `r2d2` pool feature and calls a function
    to handle requests:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Rouille框架非常易于使用。它包含`start_server`函数，这些函数期望一个函数来处理每个传入的请求。让我们创建一个`main`函数，使用带有`r2d2`池功能的`diesel`crate，并调用一个处理请求的函数：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We created a `ConnectionManager` for a local `test.db` SQLite database and
    a `Pool` instance with this manager. We discussed this in previous chapters. We
    are interested in the line with the `rouille::start_server` function call. This
    function takes two arguments: a listening address and a closure for handling requests.
    We moved `pool` to the closure and called `handler` functions, which we declared
    underneath it to generate a response for a request with `Pool` as an argument.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为本地`test.db` SQLite数据库创建了一个`ConnectionManager`和一个带有此管理器的`Pool`实例。我们之前章节中讨论过这一点。我们感兴趣的是带有`rouille::start_server`函数调用的那一行。这个函数接受两个参数：一个监听地址和一个用于处理请求的闭包。我们将`pool`移动到闭包中，并调用位于其下方的`handler`函数，以生成一个以`Pool`作为参数的请求响应。
- en: Since `handler` functions have to return a `Response` instance, we have to return
    a response with a 500 status code if a `handler` function returns an error. Looks
    pretty simple, doesn't it? Let's look at a `handler` function declaration.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`handler`函数必须返回一个`Response`实例，如果一个`handler`函数返回错误，我们必须返回一个带有500状态码的响应。看起来很简单，不是吗？让我们看看`handler`函数的声明。
- en: Handling requests
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求
- en: The Rouille framework contains a `router!` macro that helps you declare a handler
    for every path and HTTP method. If we add a `handler` function that is called
    from a closure we used in the `start_server` function call, the `router!` macro
    expects a request instance as the first argument and the desired number of request
    handlers. Let's analyze the four handler functions in order.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Rouille 框架包含一个 `router!` 宏，它可以帮助你为每个路径和 HTTP 方法声明处理程序。如果我们添加一个从 `start_server`
    函数调用中使用的闭包中调用的 `handler` 函数，`router!` 宏期望一个请求实例作为第一个参数和所需的请求处理程序数量。让我们按顺序分析四个处理程序函数。
- en: Root handler
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根处理程序
- en: 'The following is a simple handler that expects a `GET` method and returns a
    text response:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的处理程序，它期望一个 `GET` 方法并返回一个文本响应：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Sign-up handler
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册处理程序
- en: 'To handle sign-up requests, we need a `POST` method handler for the `/signup`
    path. We can declare it in the following way:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理注册请求，我们需要为 `/signup` 路径提供一个 `POST` 方法处理程序。我们可以按以下方式声明它：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This handler is more complex and also demonstrates how to parse the parameters
    of a request. We need to parse an HTML form with two parameters—`email` and `password`.
    To do this, we used the `post_input!` macro, which expects a request instance
    and a form declaration with types. The form structure declaration looks like a
    simple struct declaration without a name, but with fields. We added two necessary
    fields and the `post_input!` macro parsed a request to fill an object with the
    corresponding fields.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序更复杂，也展示了如何解析请求的参数。我们需要解析一个包含两个参数——`email` 和 `password` 的 HTML 表单。为此，我们使用了
    `post_input!` 宏，它期望一个请求实例和一个带有类型的表单声明。表单结构声明看起来像是一个没有名称但带有字段的简单结构声明。我们添加了两个必要的字段，`post_input!`
    宏解析请求以填充具有相应字段的对象。
- en: Since parsed parameters only fit types, we also had to add extra processing
    to it. The `email` field is a `String` type, and we used the `trim` method to
    remove unnecessary spacing and the `to_lowercase` method to convert it to lowercase.
    We used the `password` field without any changes and passed it as a parameter
    to the `pbkdf2_simple` method of the `rust-crypto` crate.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解析的参数只适合类型，我们还需要对其进行额外的处理。`email` 字段是 `String` 类型，我们使用了 `trim` 方法来删除不必要的空格，并使用
    `to_lowercase` 方法将其转换为小写。我们没有对 `password` 字段进行任何更改，并将其作为参数传递给 `rust-crypto` crate
    的 `pbkdf2_simple` 方法。
- en: PBKDF2 is an algorithm that adds computational cost to an encrypted value to
    prevent brute-force attacks. If your microservice is attacked and your password
    is stolen, it won't be easy for attackers to find a password value to access the
    service with someone else's account. If you use hashes, then the attacker will
    be able to find the matching password quickly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PBKDF2 是一种算法，它通过向加密值添加计算成本来防止暴力攻击。如果你的微服务遭到攻击并且你的密码被盗，攻击者将很难找到密码值以使用他人的账户访问服务。如果你使用散列，那么攻击者将能够快速找到匹配的密码。
- en: After we prepared parameters, we used them with object-relational mapping methods.
    First, to check whether the user with the provided email exists, we use a DSL
    generated by the `diesel` crate and, if the user doesn't exist, we generate a
    unique ID for the user using the `uuid` crate. The handler fills the `NewUser`
    instance with corresponding values and inserts it into a database. Upon success,
    it returns an empty JSON response. If the user already exists, the handler returns
    a response with a 400 status code (Bad Response) with a message to the effect
    that the user with the provided email already exists. Let's look at how to sign
    in with a stored user value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们准备参数后，我们使用对象关系映射方法使用它们。首先，为了检查提供的电子邮件地址是否已存在用户，我们使用由 `diesel` crate 生成的 DSL，如果用户不存在，我们使用
    `uuid` crate 为用户生成一个唯一的 ID。处理程序使用相应的值填充 `NewUser` 实例并将其插入数据库。成功后，它返回一个空的 JSON
    响应。如果用户已经存在，处理程序返回一个包含 400 状态码（错误响应）的响应，并带有一条消息，说明提供的电子邮件地址的用户已存在。让我们看看如何使用存储的用户值进行登录。
- en: Sign-in handler
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录处理程序
- en: 'The following code represents a handler for the `/signin` request path and
    parses a query with the data from the HTML form using `post_input!`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示 `/signin` 请求路径的处理程序，并使用 `post_input!` 解析来自 HTML 表单的数据：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the data has been extracted, we get a connection from a pool and use types
    generated by the `diesel` crate to send a query to the database. The code gets
    the first record from the users table with the provided email value. After that,
    we use the `pbkdf2_check` function to check that the password matches the stored
    one. If the user is valid, we return a JSON value with the user's ID. In the next
    chapters, we won't provide this service directly but will use it from another
    microservice. If the password doesn't match, we will return a response with a
    `403` status code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数据提取后，我们从连接池中获取一个连接，并使用 `diesel` 包生成的类型向数据库发送查询。代码从用户表中获取提供的电子邮件值对应的第一条记录。之后，我们使用
    `pbkdf2_check` 函数检查密码是否与存储的密码匹配。如果用户有效，我们返回一个包含用户 ID 的 JSON 值。在接下来的章节中，我们不会直接提供这个服务，而是将从另一个微服务中使用它。如果密码不匹配，我们将返回一个带有
    `403` 状态码的响应。
- en: Default handler
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认处理器
- en: 'For cases where there is no path or method pair matched for the request, we
    can add a default handler. Our microservice returns a `404` error for all unknown
    requests. Add this to the `router!` macro call:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有匹配路径或方法对的请求，我们可以添加一个默认处理器。我们的微服务对所有未知请求返回 `404` 错误。将其添加到 `router!` 宏调用中：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Compiling and running
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行
- en: 'Prepare the database and run the server using the following commands:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令准备数据库并运行服务器：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the server is started, try to send sign-in and sign-up requests:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，尝试发送登录和注册请求：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second request will return a response with a user identifier in JSON format
    that looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个请求将返回一个包含用户标识符的 JSON 格式响应，其外观如下：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we can try to implement another service with the `nickel` crate.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试使用 `nickel` 包实现另一个服务。
- en: Nickel
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nickel
- en: Another framework  that helps us create a microservice very simply is `nickel`.
    In terms of the design of its handlers, it's very similar to `hyper`, but it's
    synchronous.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个帮助我们非常简单地创建微服务的框架是 `nickel`。在处理器的设计方面，它与 `hyper` 非常相似，但它支持同步操作。
- en: Creating a microservice
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建微服务
- en: Let's create a service that sends emails to any address. This microservice will
    also build the email's body content from a template. To start with, we have to
    add the necessary dependencies to start a server instance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个向任何地址发送电子邮件的服务。这个微服务还将从模板构建电子邮件的正文内容。首先，我们必须添加必要的依赖项以启动服务器实例。
- en: Bootstrapping a server
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务器
- en: 'To write a mailer microservice, we need two dependencies: the `nickel` crate
    and the `lettre` crate. The first is a framework inspired by the Express framework
    for Node.js. The second implements the SMTP protocol and lets us interact with
    a mail server such as Postfix. Add these dependencies to `Cargo.toml`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个邮件微服务，我们需要两个依赖项：`nickel` 包和 `lettre` 包。第一个是一个受 Node.js 的 Express 框架启发的框架。第二个实现了
    SMTP 协议，并允许我们与 Postfix 等邮件服务器交互。将这些依赖项添加到 `Cargo.toml` 文件中：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the `lettre` crate, we''re using version 0.9.0 from GitHub, because it''s
    not available on crates.io at the time of writing. We need to import some types
    from these crates:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `lettre` 包，我们使用 GitHub 上的 0.9.0 版本，因为在编写时它不在 crates.io 上可用。我们需要从这些包中导入一些类型：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Types from the `std` and `failure` crates are not presented in the preceding
    code. Now we can declare the `Data` struct that represents the shared state of
    the server:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`std` 和 `failure` 包中的类型在前面代码中没有展示。现在我们可以声明代表服务器共享状态的 `Data` 结构体：'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This struct contains two fields—a `Sender` to send messages to the mailer worker
    that we will implement later, and `TemplateCache`, which lets us load and render
    templates from a local directory. We will use it directly for the body of emails
    only, because this microservice won't render HTML responses.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体包含两个字段——一个 `Sender` 用于向我们将要实现的邮件工作进程发送消息，以及 `TemplateCache`，它允许我们从本地目录加载和渲染模板。我们只直接使用它来生成电子邮件的正文，因为这个微服务不会渲染
    HTML 响应。
- en: 'The following code spawns a mail sender worker, creates an instance of the `Data`
    struct, creates a `Nickel` server, and binds it to the `127.0.0.1:8002` socket
    address:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码启动了一个邮件发送工作进程，创建了一个 `Data` 结构体的实例，创建了一个 `Nickel` 服务器，并将其绑定到 `127.0.0.1:8002`
    端口地址：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `cache` field of the `Data` struct, we set a `TemplateCache` instance
    that needs `ReloadPolicy` as an argument. The `ReloadPolicy` parameter controls
    how often templates will be reloaded. We use the `Always` variant, which means
    templates will be reloaded on every rendering. It lets an administrator update
    templates without interrupting the service.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Data` 结构体的 `cache` 字段中，我们设置了一个需要 `ReloadPolicy` 参数的 `TemplateCache` 实例。`ReloadPolicy`
    参数控制模板将重新加载的频率。我们使用 `Always` 变体，这意味着模板将在每次渲染时重新加载。它允许管理员更新模板而不会中断服务。
- en: To start the server, we need to create a `Nickel` instance, which we initialize
    with the `Data` instance using the `with_data` method. Since `Data` will be shared
    across threads, we have to wrap `Sender` with `Mutex`. `TemplateCache` already
    implements `Sync` and `Send` and can be shared safely.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务器，我们需要创建一个 `Nickel` 实例，并使用 `with_data` 方法用 `Data` 实例初始化它。由于 `Data` 将在多个线程之间共享，我们必须将
    `Sender` 包装在 `Mutex` 中。`TemplateCache` 已经实现了 `Sync` 和 `Send`，并且可以安全地共享。
- en: We add two methods to the `Nickel` server instance using the `get` and `post`
    methods. We add two handlers. The first is for the root path, `/`, which uses
    the `middleware!` macro from the `nickel` crate to attach a handler that returns
    a text response. The second handles requests with the `/send` path and calls the `send`
    function, which is implemented beneath that. The last method call, `listen`, binds
    the server's socket to an address. Now we can move forward and implement a handler.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `get` 和 `post` 方法向 `Nickel` 服务器实例添加两个方法。我们添加了两个处理器。第一个是针对根路径 `/`，它使用来自
    `nickel` 包的 `middleware!` 宏附加一个返回文本响应的处理程序。第二个处理程序处理带有 `/send` 路径的请求，并调用位于其下的
    `send` 函数。最后一个方法调用 `listen` 将服务器的套接字绑定到一个地址。现在我们可以继续前进并实现一个处理程序。
- en: Handling requests
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求
- en: 'Handlers of the Nickel framework take two parameters: a mutable reference to
    a `Request` struct and an owned `Response` instance that we can fill with data.
    Handlers have to return `MiddlewareResult`. Every input and output type has a
    type parameter of a shared data type.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Nickel 框架的处理程序接受两个参数：一个可变引用到 `Request` 结构体和一个拥有的 `Response` 实例，我们可以用数据填充它。处理程序必须返回
    `MiddlewareResult`。每个输入和输出类型都有一个共享数据类型的类型参数。
- en: 'The `nickel` crate contains the `try_with!` macro. It needs to unwrap the `Result`
    type, but returns an HTTP error if the result equals `Err`. I created the `send_impl`
    method to use the usual `?` operator; `failure::Error` is the error type. I''ve
    found this to be more common than using a special macro such as `try_with!`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`nickel` 包包含 `try_with!` 宏。它需要解包 `Result` 类型，但如果结果等于 `Err`，则返回 HTTP 错误。我创建了
    `send_impl` 方法来使用常规的 `?` 操作符；`failure::Error` 是错误类型。我发现这比使用像 `try_with!` 这样的特殊宏更常见：'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We mapped the result to `BadRequest`. If the method returns `Ok`, we will send
    a JSON `true` value as a response. We don't need to use serialization for this
    simplest type of JSON value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结果映射到 `BadRequest`。如果方法返回 `Ok`，我们将发送一个 JSON `true` 值作为响应。对于这种最简单的 JSON 值类型，我们不需要使用序列化。
- en: 'The following code is the `send_impl` function implementation. Let''s take
    it apart piece by piece:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `send_impl` 函数的实现。让我们逐个分析：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Request` instance has the `from_body` method, which returns query parameters
    as a `Params` struct instance. The `get` method of `Params` returns a parameter
    called `Option`. If any of the parameters are not provided, we return an `Err`
    value, because the method requires all parameters to be set.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request` 实例具有 `from_body` 方法，该方法返回一个 `Params` 结构体实例的查询参数。`Params` 的 `get`
    方法返回一个名为 `Option` 的参数。如果任何参数未提供，我们将返回一个 `Err` 值，因为该方法要求所有参数都必须设置。'
- en: To get access to a shared server's data, there is the `server_data` method of
    `Request`, which returns a `Data` instance, because we set this type as a type
    parameter of a `Request` and provided an instance of `Data` to the server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问共享服务器的数据，有 `Request` 的 `server_data` 方法，它返回一个 `Data` 实例，因为我们将其设置为 `Request`
    的类型参数，并向服务器提供了一个 `Data` 实例。
- en: When we have got all the parameters, we can extract a `Sender` instance (used
    to send tasks to a worker) compose an email using a template from the cache, and
    send it to a worker. We create an `EmailAddress` instance from the `to` parameter
    of the query. Then, we fill `HashMap` with parameters for a template that contains
    the `code` parameter with a confirmation code value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取所有参数后，我们可以提取一个 `Sender` 实例（用于向工作者发送任务），使用缓存中的模板编写一封电子邮件，并将其发送给工作者。我们从查询的
    `to` 参数创建一个 `EmailAddress` 实例。然后，我们用包含具有确认码值的 `code` 参数的模板参数填充 `HashMap`。
- en: The parameters have been prepared and we use the `cache` field of the `Data`
    instance to get access to `TemplateCache`. The `render` method of the cache loads
    a template and fills it with the provided parameters. The `render` method expects
    a buffer to fill the rendered content. After we get it, we create a `SendableEmail`
    instance, we clone a `Sender`, and use the cloned instance to send an email to
    a worker. Let's look at how an email worker is implemented.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 参数已经准备就绪，我们使用`Data`实例的`cache`字段来访问`TemplateCache`。缓存中的`render`方法加载一个模板并用提供的参数填充它。`render`方法期望一个缓冲区来填充渲染的内容。在我们获取它之后，我们创建一个`SendableEmail`实例，克隆一个`Sender`，并使用克隆的实例向一个工作节点发送电子邮件。让我们看看电子邮件工作节点是如何实现的。
- en: Worker for sending emails
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送电子邮件的工作节点
- en: 'We use a separate thread that receives `SendableEmail` values and send them
    using the SMTP protocol. The following code creates an instance of `SmtpClient`
    and uses the `credentials` method to set the credentials for a connection:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个单独的线程来接收`SendableEmail`值，并使用SMTP协议发送它们。以下代码创建了一个`SmtpClient`实例，并使用`credentials`方法设置连接的凭据：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`StmpClient` has moved to the new thread''s context. It''s wrapped with `SmtpTransport`
    and is used to send every received `SendableEmail` instance.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`StmpClient`已移动到新线程的上下文中。它被`SmtpTransport`包装，并用于发送每个接收到的`SendableEmail`实例。'
- en: The worker implements a non-transactional email sender. If you want a guarantee
    of email delivery, you need to implement more diverse interaction with a mail
    server, or you can even embed an email server, or use a third-party service. I
    recommend you use as many external services as possible; they will cost you, but
    you will save much more on maintenance. We implemented the mailer service for
    demonstration purposes only to show how to integrate multiple services together
    later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 工作节点实现了一个非事务性的电子邮件发送器。如果你想保证电子邮件的投递，你需要与邮件服务器实现更多样化的交互，或者你可以甚至嵌入一个邮件服务器，或者使用第三方服务。我建议你尽可能多地使用外部服务；虽然它们会花费你一些费用，但你在维护方面可以节省更多。我们仅为了演示目的实现了邮件服务，以展示如何将多个服务集成在一起。
- en: Compiling and running
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行
- en: 'Before we start our microservice, we need a working SMTP server. Let''s create
    one with Docker. The following command creates a container with a Postfix server
    instance:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始微服务之前，我们需要一个工作的SMTP服务器。让我们使用Docker创建一个。以下命令创建了一个包含Postfix服务器实例的容器：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The server exposes port `*25*` and we remap it to local port `*2525*`. The
    command sets all the necessary parameters using environment variables and now
    the mailer microservice is ready to compile and run. Do so using the `cargo run`
    command, and when it starts, check it using the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器公开端口`*25*`，我们将它重映射到本地端口`*2525*`。该命令使用环境变量设置所有必要的参数，现在邮件微服务已准备好编译和运行。使用`cargo
    run`命令执行此操作，启动后，使用以下命令进行检查：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you call this command, the microservice will build and send an email to
    the Postfix server. Actually, the email won't be delivered, because our mail server
    works as a relay only and many mail services will reject emails from this kind
    of mail server. If you want to receive emails, you need to configure the service
    accordingly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用这个命令时，微服务将构建并发送一封电子邮件到Postfix服务器。实际上，这封电子邮件不会被投递，因为我们的邮件服务器仅作为中继使用，许多邮件服务会拒绝来自这种邮件服务器的电子邮件。如果你想接收电子邮件，你需要相应地配置该服务。
- en: Rocket
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 火箭
- en: The next framework we will explore is Rocket. It's a simple-to-use framework
    that uses the nightly compiler's features to provide a tool that converts a set
    of Rust functions into a complete web service. The Rocket framework is different
    than the frameworks we've discussed before. It implements application configurations
    with environment variables and logging. The imperfection of this approach is that
    tuning and replacing parts is a little complex, but the positive side of this
    approach is that you spend next to no time coding the logging and configuration
    capabilities of your microservice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的下一个框架是Rocket。它是一个易于使用的框架，它使用夜间编译器的功能提供了一种将一组Rust函数转换为完整Web服务的工具。Rocket框架与我们之前讨论的框架不同。它使用环境变量实现应用程序配置和日志记录。这种方法的不足之处在于调整和替换部分稍微复杂一些，但这种方法的好处是，你在编码微服务的日志和配置功能上几乎不花时间。
- en: Creating a microservice
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建微服务
- en: Let's create a microservice that implements the commenting features of our application.
    It will take new comments and store them in a database. Also, a client can request
    any and all comments from the microservice. To start with, we need to bootstrap
    a new server with the Rocket framework.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个实现我们应用程序评论功能的微服务。它将接受新的评论并将它们存储在数据库中。此外，客户端可以请求微服务中的任何和所有评论。首先，我们需要使用Rocket框架启动一个新的服务器。
- en: Bootstrapping a server
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务器
- en: 'To start a server instance, we have to prepare a database interaction. But
    it doesn''t work directly as it did with the `diesel` crate. To connect a database,
    we have to add the crates we need and activate the necessary features of the `rocket_contrib`
    crate:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务器实例，我们必须准备数据库交互。但是它并不能像使用`diesel` crate那样直接工作。为了连接数据库，我们必须添加所需的crates并激活`rocket_contrib`
    crate的必要功能：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We used the `diesel_sqlite_pool` feature of the `rocket_contrib` crate and `sqlite`
    with `r2d2` from the `diesel` crate. The following lines of code import macros
    from all of the crates we need, add the `comment` module that we will create later,
    and import all necessary types:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`rocket_contrib` crate的`diesel_sqlite_pool`功能和`diesel` crate中的`sqlite`以及`r2d2`。以下代码行从我们需要的所有crates中导入宏，添加我们稍后将要创建的`comment`模块，并导入所有必要的类型：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will also see that we used two features from the nightly release: `proc_macro_hygiene`
    and `decl_macro`. Without these features, you can''t declare handlers.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到我们使用了nightly发布版中的两个功能：`proc_macro_hygiene`和`decl_macro`。没有这些功能，你无法声明处理器。
- en: 'The nightly Rust compiler contains a lot of cool but unstable features. Unstable
    doesn''t mean you can''t use them in production applications; it means the features
    may be changed or even removed. Their being unstable means that it''s risky to
    use these, because you may need to rewrite your code later. The Rocket framework
    requires you to use some unstable features. You can find the complete list of
    unstable features in the Unstable Book: [https://doc.rust-lang.org/stable/unstable-book/](https://doc.rust-lang.org/stable/unstable-book/).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: nightly Rust编译器包含许多酷但不稳定的功能。不稳定并不意味着你不能在生产应用程序中使用它们；这意味着这些功能可能会更改或甚至被删除。它们的不稳定性意味着使用它们是有风险的，因为你可能需要稍后重写你的代码。Rocket框架要求你使用一些不稳定的功能。你可以在不稳定手册中找到不稳定功能的完整列表：[https://doc.rust-lang.org/stable/unstable-book/](https://doc.rust-lang.org/stable/unstable-book/)。
- en: 'Now we can connect to SQLite Database in the code. To do so, we create a wrapper
    for `SqliteConnection` and the user database attribute to assign a database connection
    is set in the `global.database.sqlite_database` parameters:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在代码中连接到SQLite数据库。为此，我们为`SqliteConnection`创建一个包装器，并将用户数据库属性设置为`global.database.sqlite_database`参数，以分配数据库连接：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another feature we used is migration embedding, which includes all of the SQL
    scripts from the `migrations` folder in a program:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了迁移嵌入功能，它将`migrations`文件夹中的所有SQL脚本包含在一个程序中：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can create and launch a server instance. We create a `Rocket` instance
    with the `ignite` method call, but before we launch it, we add two middleware
    called fairings in the Rocket framework. The first is created for the `Db` database
    wrapper and provides a database pool in requests. The second is the `AdHoc` fairing,
    which tries to run migrations for a database. Look at the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建并启动服务器实例。我们通过调用`ignite`方法创建一个`Rocket`实例，但在启动它之前，我们在Rocket框架中添加了两个称为fairings的中间件。第一个是为`Db`数据库包装器创建的，它为请求提供数据库池。第二个是`AdHoc`
    fairing，它尝试为数据库运行迁移。看看以下代码：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After that, we call the `mount` method to add routes to the root path. Routes
    are created by the `routes!` macro, where we include all of the routes defined
    later in this section. When the `Rocket` instance is built, we run it with the `launch`
    method call.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用`mount`方法将路由添加到根路径。路由是通过`routes!`宏创建的，其中我们包括本节稍后定义的所有路由。当`Rocket`实例构建完成后，我们通过调用`launch`方法来运行它。
- en: Handling requests
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求
- en: 'Our microservice contains two handlers. The first handles the request for the `/list`
    path and returns all comments from a database:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微服务包含两个处理器。第一个处理器处理`/list`路径的请求，并从数据库返回所有评论：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, a handler in the Rocket framework is a function that takes parameters
    that `**rocket**` automatically binds and expects a function to return a result.
    Our `list` function returns a list of comments in JSON format. We use the `Comment`
    model declared in the `comment` module to extract all comments using a connection
    from a pool provided as an argument of function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Rocket框架中的处理器是一个函数，它接受`**rocket**`自动绑定的参数，并期望一个函数返回一个结果。我们的`list`函数返回JSON格式的评论列表。我们使用在`comment`模块中声明的`Comment`模型，通过函数参数提供的连接池提取所有评论。
- en: 'To declare a method and a path, we add the `get` attribute to a function declaration
    with the path we need. The get attribute allows you to call a handler with the `GET`
    method. Also, there is the `post` attribute, which we use for adding the comment
    handler:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个方法和路径，我们向具有所需路径的函数声明中添加`get`属性。`get`属性允许您使用`GET`方法调用处理器。此外，还有一个`post`属性，我们用它来添加评论处理器：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding function expects two parameters: `Form`, which can be parsed
    to the `NewComment` object, and the `Db` instance. The `Form` wrapper holds the
    inner value of the provided type. To extract it, we call the `into_inner` method,
    which returns the `NewComment` struct in our case. If form doesn''t provide a
    request, the method won''t even be called. We set the `data` bind in the `post`
    attribute to set an argument that stores the provided data. At the end, we use
    the insert method of the `Comment` type to insert the `NewComment` struct into
    the database using the provided `Connection`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数期望两个参数：`Form`，它可以解析到`NewComment`对象，以及`Db`实例。`Form`包装器持有提供的类型内部值。为了提取它，我们调用`into_inner`方法，在我们的情况下返回`NewComment`结构体。如果表单不提供请求，该方法甚至不会被调用。我们在`post`属性的`data`绑定中设置一个参数，用于存储提供的数据。最后，我们使用`Comment`类型的插入方法，使用提供的`Connection`将`NewComment`结构体插入到数据库中。
- en: That's all! The microservice has been declared. It's pretty simple, isn't it?
    But the final thing we need is a schema declaration. Let's add that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！微服务已经声明。这很简单，不是吗？但我们最后需要的是模式声明。让我们添加它。
- en: Database schema and models
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库模式和管理
- en: 'Comments will be stored in a `comments` table that has three fields: the `id`
    of a comment, the `uid` of a user, and the `text` of a comment:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 评论将存储在具有三个字段的`comments`表中：评论的`id`、用户的`uid`和评论的`text`：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Comment` struct has the following declaration:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comment`结构体的声明如下：'
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We repeated the same field in the `Comment` struct and added the `NewComment`
    struct without `id`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Comment`结构体中重复了相同的字段，并添加了没有`id`的`NewComment`结构体：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And now for something new—we derive the `FormForm` type for the `NewComment`
    struct. It helps Rocket convert a query into a `Form` instance. The next `Comment`
    struct implementation adds two methods:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来点新的——我们为`NewComment`结构体推导出`FormForm`类型。这有助于Rocket将查询转换为`Form`实例。下一个`Comment`结构体实现添加了两个方法：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use the generated method with the `diesel` crate to interact with a database
    using a `Connection` instance. If you want to know more about the `diesel` crate,
    you can read more in [Chapter 8](78b65084-762a-4697-b142-f47b2120e4c6.xhtml),
    *Interaction to Database with Object-Relational Mapping*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用由`diesel`包生成的函数与数据库交互，使用`Connection`实例。如果您想了解更多关于`diesel`包的信息，您可以在[第8章](78b65084-762a-4697-b142-f47b2120e4c6.xhtml)中阅读更多，*使用对象关系映射与数据库交互*。
- en: Compiling and running
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行
- en: 'To run a microservice created with `Rocket`, you need to create a `Rocket.toml`
    configuration file. This allows you to configure a microservice before starting.
    Look at the following `Rocket.toml` contents:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行使用`Rocket`创建的微服务，您需要创建一个`Rocket.toml`配置文件。这允许您在启动之前配置微服务。查看以下`Rocket.toml`内容：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this configuration, we declared global parameters such as: the `template_dir`
    directory with templates (if we use it), `address` and `port`, and a `url` for
    a database connection.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置中，我们声明了全局参数，例如：包含模板的`template_dir`目录（如果使用它）、`address`和`port`，以及数据库连接的`url`。
- en: 'You can override any parameter using environment variables. For example, if
    we need to set the `port` parameter to 80, we can run a microservice with a command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用环境变量覆盖任何参数。例如，如果我们需要将`port`参数设置为80，我们可以使用以下命令运行微服务：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Rocket framework also supports three different types of environment: `development`,
    `staging`, and `production`. It allows you to have three configurations in one.
    Add an extra section in addition to the `global` section and run a microservice
    with the corresponding mode:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket框架也支持三种不同的环境类型：`development`、`staging`和`production`。它允许你在同一个配置中拥有三个配置。在`global`部分之外添加一个额外的部分，并使用相应的模式运行微服务：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To test a microservice, it''s sufficient to start it with a simple cargo run
    without extra parameters. When the service starts, we can add a comment with the
    following command and print a list of all comments:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个微服务，只需用简单的`cargo run`命令启动它，无需额外参数。当服务启动时，我们可以添加以下命令的注释并打印所有注释的列表：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command prints all comments in JSON format. As you can see, we don't convert
    any structs directly to JSON. Rocket does this automatically.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令以JSON格式打印所有注释。正如你所见，我们没有直接将任何结构体转换为JSON。Rocket会自动完成这项工作。
- en: Gotham
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gotham
- en: 'We have learned how to use three frameworks that simplify writing microservices:
    Rouille, Nickel, and Rocket. But all of these frameworks are synchronous. If you
    want to write an asynchronous microservice, you have three paths to choose from:
    using the `hyper` crate directly, as we did in [Chapter 2](621dffeb-7f43-4c11-9ac5-00a366dc8d9f.xhtml),
    *Developing a Microservice with Hyper Crate*; using the `gotham` crate, which
    uses `hyper` and `tokio` internally; or using the `actix-web` framework. In this
    section, we will learn how to use the `gotham` crate with the asynchronous `tokio-postgres`
    crate to work with PostgreSQL asynchronously. We will learn about the `actix-web`
    crate later, in [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *Involving
    Concurrency with Actors and Actix Crate*.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用三个简化微服务编写的框架：Rouille、Nickel和Rocket。但所有这些框架都是同步的。如果你想编写异步微服务，你有三条路径可以选择：直接使用`hyper`依赖库，就像我们在[第2章](621dffeb-7f43-4c11-9ac5-00a366dc8d9f.xhtml)中做的那样，*使用Hyper依赖库开发微服务*；使用使用`hyper`和`tokio`的`gotham`依赖库；或者使用`actix-web`框架。在本节中，我们将学习如何使用`gotham`依赖库和异步的`tokio-postgres`依赖库来异步地与PostgreSQL交互。我们将在[第11章](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml)中学习如何使用`actix-web`依赖库，*使用Actors和Actix依赖库处理并发*。
- en: As an example of using the `gotham` crate, we will create a microservice that
    takes the `User-Agent` `header` from a request and stores it in a PostgreSQL database.
    We will create a completely asynchronous application and also learn about the `tokio-postgres`
    crate.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`gotham`依赖库的示例，我们将创建一个微服务，该服务从请求中获取`User-Agent` `header`并将其存储在PostgreSQL数据库中。我们将创建一个完全异步的应用程序，并了解`tokio-postgres`依赖库。
- en: Creating a microservice
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个微服务
- en: 'Create a new binary crate and add the following dependencies:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的二进制依赖库，并添加以下依赖：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we added the `gotham` and `gotham_derive` crates. The first
    is a framework and the second helps us derive an implementation of the `StateData`
    trait for the shared state with the connection we need. The `gotham_derive` crate
    can also be used to derive the `NewMiddleware` trait for middleware, but we don't
    need special middleware for our example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们添加了`gotham`和`gotham_derive`依赖库。第一个是一个框架，第二个帮助我们为所需的共享连接推导出`StateData`特质的实现。`gotham_derive`依赖库也可以用来推导中间件的`NewMiddleware`特质，但我们的示例不需要特殊的中间件。
- en: We also added the `tokio-postgres` crate to dependencies. It contains an implementation
    of an asynchronous database connector for PostgreSQL.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了`tokio-postgres`依赖库。它包含了一个异步数据库连接器的实现，用于PostgreSQL。
- en: Types of framework
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架类型
- en: 'We need a lot of types for the microservice. Let''s talk a little about every
    type we import here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为微服务准备很多类型。让我们简要谈谈我们这里导入的每个类型：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Most likely, you are familiar with types from `failure` and `futures` crates,
    because we used them a lot in the first part of the book. The most interesting
    are types of the `gotham` crate. There are modules that cover different parts
    of the framework; the `handler` module contains `HandlerFuture`, which is an alias
    to the `Future` trait with predefined types:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你已经熟悉`failure`和`futures`依赖库中的类型，因为我们在这本书的第一部分中大量使用了它们。最有趣的是`gotham`依赖库的类型。有多个模块涵盖了框架的不同部分；`handler`模块包含`HandlerFuture`，它是`Future`特质的别名，具有预定义的类型：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We will use this `Future` alias in our asynchronous handlers. Also, this module
    contains the `IntoHandlerFuture` trait, which is implemented for a tuple that
    can be converted into a response.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在异步处理程序中使用这个`Future`别名。此外，此模块包含`IntoHandlerFuture`特质，该特质为可以转换为响应的元组实现。
- en: The `middleware` module contains `StateMiddleware`, which we will use to attach
    a state to our microservice.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`middleware`模块包含`StateMiddleware`，我们将使用它来将状态附加到我们的微服务上。'
- en: 'The `pipeline` module contains two functions we will use: `single_middleware`
    and `single_pipeline`. The first creates a `Pipeline` with a single provided middleware
    inside. The second function is necessary to create a pipeline chain from a single
    pipeline instance.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipeline`模块包含我们将要使用的两个函数：`single_middleware`和`single_pipeline`。第一个函数在内部创建一个包含单个提供的中间件的`Pipeline`。第二个函数是创建从单个管道实例创建管道链所必需的。'
- en: The `router` module includes types we need to construct a routing table for
    our microservice. The `Router` struct is a type that contains routes and we have
    to instantiate and provide it for a server. We will do this with the `build_router`
    function call.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`router`模块包括我们构建微服务路由表的所需类型。`Router`结构是一个包含路由的类型，我们必须实例化并提供它给服务器。我们将通过调用`build_router`函数来完成这项工作。'
- en: For the `DrawRoutes` trait, we need to have methods of `Router` to add paths.
    It adds `get`, `get_or_head`, `put`, `post`, and other methods to register paths
    with corresponding HTTP methods. Calling those methods returns the `SingleRouteBuilder`
    instance and we need to use the `DefineSingleRoute` trait for the `to` method,
    which allows us to map a registered path to a `Handler`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`DrawRoutes`特质，我们需要有`Router`的方法来添加路径。它添加了`get`、`get_or_head`、`put`、`post`和其他方法来注册与相应HTTP方法对应的路径。调用这些方法返回`SingleRouteBuilder`实例，我们需要使用`DefineSingleRoute`特质为`to`方法，这允许我们将注册的路径映射到`Handler`。
- en: The `state` module provides us with the capability to use generic `State` and
    convert it to a type we need by calling the `borrow_from` method of the `FromState`
    trait that implemented the types that implement the `StateData` trait.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`模块为我们提供了使用通用的`State`并将其通过调用实现了`StateData`特质的类型所实现的`FromState`特质的`borrow_from`方法转换为所需类型的可能性。'
- en: Generic `State` in `gotham` is a very flexible concept and provides the capability
    to get references to different parts of the environment. You can get a reference
    to your own state type or to the request data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gotham`中的通用`State`是一个非常灵活的概念，它提供了获取环境不同部分引用的能力。你可以获取你自己的状态类型的引用或请求数据的引用。
- en: We need some types from the `hyper` crate, because the crate is used in the  `gotham`
    implementation and in some types of `hyper`. We imported the `Response` type to
    create responses for a client and the `HeaderMap` to get access to request headers,
    because we need to get a value for the `USER_AGENT` `header`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从`hyper`crate中获取一些类型，因为该crate在`gotham`实现中以及某些类型的`hyper`中使用。我们导入了`Response`类型来创建客户端的响应，以及`HeaderMap`来获取对请求头部的访问，因为我们需要获取`USER_AGENT`头部的值。
- en: Since we are developing an asynchronous application, we have to use the same
    reactor to execute all tasks in the same runtime. To do this, we will use a manually
    created `Runtime` from the `tokio` crate.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在开发一个异步应用程序，我们必须使用相同的reactor在同一运行时中执行所有任务。为此，我们将使用从`tokio`crate中手动创建的`Runtime`。
- en: To connect to a database, we need to import the `Client` type from the `tokio-postgres`
    crate and `NoTls` to configure a connection.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到数据库，我们需要从`tokio-postgres`crate中导入`Client`类型和`NoTls`来配置连接。
- en: Now we have imported all we need to write the `main` function of the application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了编写应用程序的`main`函数所需的所有内容。
- en: The main function
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'In the `main` function implementation, we create a `Runtime` instance, which
    we will use for database queries and to process HTTP requests. Look at the following
    code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的实现中，我们创建一个`Runtime`实例，我们将使用它进行数据库查询和处理HTTP请求。查看以下代码：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We create a `Runtime` instance. After that, we can create a new database connection
    by calling the connect function of the `tokio-postgres` crate. It returns a `Future`
    that we have to execute immediately. To run a `Future`, we will use the same `Runtime`
    we have already created. `Runtime` has the `block_on` method, which we have already
    discussed in [Chapter 5,](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml) *Understanding
    Asynchronous Operations with Futures Crate*. We call it with a `Connect` future
    and take a pair of results: `Client` and `Connection` instances.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`Runtime`实例。之后，我们可以通过调用`tokio-postgres`crate的连接函数来创建一个新的数据库连接。它返回一个`Future`，我们必须立即执行它。要运行`Future`，我们将使用我们已创建的相同的`Runtime`。`Runtime`有我们已经在[第5章](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml)中讨论过的`block_on`方法，*使用Futures
    Crate理解异步操作*。我们用`Connect`未来调用它，并获取一对结果：`Client`和`Connection`实例。
- en: '`Client` is a type that provides a method to create statements. We will store
    this instance in `ConnState`, which we will declare later in this section.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client`是一个提供创建语句方法的类型。我们将在这个部分稍后声明的`ConnState`中存储这个实例。'
- en: The `Connection` type is a task that performs actual interaction with a database.
    We have to spawn this task within `Runtime`. If you forget to do this, your database
    queries will be blocked and will never be sent to a database server.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connection`类型是一个执行与数据库实际交互的任务。我们必须在`Runtime`中派发这个任务。如果你忘记这样做，你的数据库查询将被阻塞，永远不会发送到数据库服务器。'
- en: 'Now we can use the `Client` instance to execute SQL statements. The first statement
    we need creates a table to log `User-Agent` `header` values. The `Client` struct
    has the `batch_execute` method, which executes multiple statements from a string.
    We''ve used only one statement, but this call is useful if you want to create
    more than one table:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`Client`实例来执行SQL语句。我们需要的第一个语句是创建一个用于记录`User-Agent` `header`值的表。`Client`结构体有`batch_execute`方法，它从字符串中执行多个语句。我们只使用了一个语句，但如果你想创建多个表，这个调用很有用：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`batch_execute` returns a `Future` instance and we have to execute it immediately
    to initialize the database before inserting a record into it. We use the `block_on`
    method of a `Runtime` instance to execute the statement.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`batch_execute`返回一个`Future`实例，我们必须立即执行它以在插入记录之前初始化数据库。我们使用`Runtime`实例的`block_on`方法来执行语句。'
- en: 'Before we finish implementing the main function, let''s look at the `ConnState`
    struct implementation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成实现主函数之前，让我们看看`ConnState`结构体的实现：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The struct is very simple and contains the atomic reference counter, `Arc`,
    to a database `Client` wrapped with a `Mutex`. We need only one method to simplify
    instance creation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体非常简单，包含一个原子引用计数器`Arc`，它包装了一个带有`Mutex`的数据库`Client`。我们只需要一个方法来简化实例创建：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: But you can also add a method to get the inner value of this state. It's useful
    if you want to declare a state type in a separate module. We will use the `client`
    field directly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也可以添加一个方法来获取这个状态的内值。如果你想在单独的模块中声明状态类型，这很有用。我们将直接使用`client`字段。
- en: Also, you might notice that `ConnState` derives `Clone` and `StateData` traits.
    The struct has to be cloneable, because a state is cloned by Gotham for every
    request. `StateData` allows us to attach an instance of this struct to `StateMiddleware`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能还会注意到`ConnState`继承了`Clone`和`StateData`特性。结构体必须是可克隆的，因为Gotham会为每个请求克隆一个状态。`StateData`允许我们将此结构体的一个实例附加到`StateMiddleware`。
- en: 'Now we can finish the `main` function implementation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以完成`main`函数的实现：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We created the `ConnState` state with a `Client` value. We stored the result
    to the `state` variable and used it for the `router` function call, which we will
    declare later.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Client`值创建了`ConnState`状态，并将结果存储在`state`变量中，用于`router`函数调用，我们将在稍后声明。
- en: 'After that, we can start a Gotham server by calling the `start_on_executor`
    function. It expects three arguments: the *address* that we set to the `"127.0.0.1:7878"`
    value, the *router* value that we created with the `router` function call, and
    the `TaskExecutor` instance that we extracted from our `Runtime`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过调用`start_on_executor`函数来启动Gotham服务器。它期望三个参数：我们设置为`"127.0.0.1:7878"`的*地址*，我们使用`router`函数调用创建的*路由器*值，以及我们从`Runtime`中提取的`TaskExecutor`实例。
- en: Actually, the `start_on_executor` function call the spawns a task to the asynchronous
    reactor and we have to start our `Runtime` instance. We can do this with the `shutdown_on_idle`
    method call. It returns the `Shutdown` future that we run in the current thread
    using the `wait` method call. The `main` function ends when all tasks are complete.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`start_on_executor`函数调用会向异步反应器派发一个任务，我们必须启动我们的`Runtime`实例。我们可以通过调用`shutdown_on_idle`方法来实现，它返回一个`Shutdown`未来对象，我们使用`wait`方法调用在当前线程中运行它。当所有任务完成时，`main`函数结束。
- en: 'Let''s look at the `router` function implementation that creates the `Router`
    instance for our application:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建我们应用程序的`Router`实例的`router`函数实现：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the function implementation, we create a `StateMiddleware` instance and provide
    `ConnState` to it. We add a middleware to a pipeline with the `single_middleware`
    call and create a chain by calling the `single_pipeline` function call. It returns
    a pair of a chain and a set of pipelines.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数实现中，我们创建一个`StateMiddleware`实例，并将`ConnState`提供给它。我们通过`single_middleware`调用将中间件添加到管道中，并通过调用`single_pipeline`函数调用创建一个链。它返回一个链和一组管道。
- en: We pass these values to the `build_router` function, which returns the `Router`
    instance, but we can tune the resulting `Router` by calling methods of `RouterBuilder`
    in a closure that we pass as a third argument to the `build_router` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些值传递给`build_router`函数，该函数返回`Router`实例，但我们可以通过在将闭包作为第三个参数传递给`build_router`函数时调用`RouterBuilder`的方法来调整生成的`Router`。
- en: 'We called the get method of `RouterBuilder` to set a handler implemented in
    the `register_user_agent` function to the root path, `/`. The Gotham framework
    supports scopes of routes that help you group handlers by a path prefix, like
    this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`RouterBuilder`的get方法，将`register_user_agent`函数中实现的处理器设置到根路径`/`。Gotham框架支持路由的scope范围，这可以帮助你通过路径前缀来分组处理器，如下所示：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We now only have to implement a handler.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要实现一个处理器。
- en: Handler implementation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器实现
- en: 'Every handler in Gotham has to return the `HandlerFuture` implementation of
    a tuple that can be converted to `HandlerFuture`. Also, a handler has to accept
    a `State` parameter:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Gotham中的每个处理器都必须返回一个可以转换为`HandlerFuture`的元组的`HandlerFuture`实现。此外，处理器必须接受一个`State`参数：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you remember, we need to extract the `User-Agent` `header` from a request.
    We can do this using a `State` value, because we can borrow `HeaderMap` from a
    `State` with the `borrow_from` method call. It returns a map that we can use to
    get the `User-Agent` HTTP `header` by using the `USER_AGENT` key imported from
    the `hyper` crate:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们需要从请求中提取`User-Agent` `header`。我们可以使用`State`值来完成此操作，因为我们可以通过`borrow_from`方法调用从`State`借用`HeaderMap`。它返回一个我们可以使用`USER_AGENT`键（从`hyper`
    crate导入）来获取`User-Agent` HTTP `header`的映射：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`HeaderMap` returns `HeaderValue` as a value of `header` and we have to get
    the string value using the `to_str` method and convert it to an owned string with
    the `to_string` method. If the `header` was not provided, we use the `"<undefined>"`
    value.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeaderMap`返回`HeaderValue`作为`header`的值，我们必须使用`to_str`方法获取字符串值，并使用`to_string`方法将其转换为所有者字符串。如果未提供`header`，我们使用`"<undefined>"`值。'
- en: 'Now we can borrow the `ConnState` value from `State` and add a new record to
    the database:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从`State`中借用`ConnState`值，并向数据库添加一条新记录：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We need two references to a `Client`, because we have to resolve two futures:
    one is to prepare a query, the second to execute that query. To prepare a query,
    we will use the `prepare` method, which expects a string with a SQL statement.
    The method call returns a `Future` instance that returns a `Statement` instance,
    but we can''t create that `Future` directly in the function''s body, because we
    have to lock `Mutex` to get access to the `Client` and it will be blocked after
    the `Future` statement is resolved.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个`Client`的引用，因为我们必须解决两个未来：一个是准备查询，另一个是执行该查询。为了准备查询，我们将使用`prepare`方法，该方法期望一个包含SQL语句的字符串。方法调用返回一个返回`Statement`实例的`Future`实例，但我们不能在函数体中直接创建该`Future`，因为我们必须锁定`Mutex`以获取对`Client`的访问权限，并且它将在`Future`语句解决后阻塞。
- en: 'To use `Client` twice, we need two references to the `Client` and use them
    in separate closures in a chain of futures. We start creating a futures chain
    with the `future::ok` method call, which returns a successful `Future`. We use
    the `and_then` method to add the first step: statement preparation. We lock the
    `Mutex` to get a mutable reference to a `Client`. Then, we call the `prepare`
    method to create a `Future `that returns a `Statement`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要两次使用`Client`，我们需要两个`Client`的引用，并在未来的链中分别使用它们。我们通过调用`future::ok`方法来创建一个成功的`Future`，从而开始创建一个未来的链。我们使用`and_then`方法添加第一步：语句准备。然后，我们锁定`Mutex`以获取对`Client`的可变引用。接下来，我们调用`prepare`方法创建一个返回`Statement`的`Future`。
- en: Beyond that, we can add the next step to the futures chain to fill a `Statement`
    with values. We lock the second `Mutex` clone to the call query method of a `Client`.
    The method expects a statement as a first parameter and a reference to an array
    with references to values. Since we know that the statement we're using inserts
    a new record and returns exactly one row, we extract a `String` value from the
    first position of the first row.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们还可以将下一步添加到未来的链中，以填充`Statement`中的值。我们锁定第二个`Mutex`克隆以调用`Client`的查询方法。该方法期望一个语句作为第一个参数和一个引用数组，其中包含对值的引用。由于我们知道我们使用的语句插入一条新记录并返回一行，我们从第一行的第一个位置提取一个`String`值。
- en: 'At the end of the chain, we then use the method to convert a `Result` of the
    query execution into a `Response`. We create a new `Builder` for a `Response`.
    If the query returns a successful result, we return it to a client. If the query
    fails, we print an error with the `500` status code. The closure returns a tuple
    with a pair: the `State` and `Response` instances. Gotham uses this result to
    return the response to the client.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在链的末端，我们使用方法将查询执行的结果 `Result` 转换为 `Response`。我们为 `Response` 创建一个新的 `Builder`。如果查询返回成功的结果，我们将其返回给客户端。如果查询失败，我们使用
    `500` 状态码打印一个错误。闭包返回一个包含一对的元组：`State` 和 `Response` 实例。Gotham 使用这个结果将响应返回给客户端。
- en: The implementation is finished and now we can check it with a database instance.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 实现完成，现在我们可以使用数据库实例来检查它。
- en: Running and testing
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和测试
- en: 'To run this example, we need a PostgreSQL database instance. The simplest way
    to run it is to start a Docker container. We already did that in [Chapter 7](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml),
    *Reliable Integration with Databases*, where we studied how to use Rust with databases.
    You can start a new container with a PostgreSQL database instance using the following
    command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，我们需要一个 PostgreSQL 数据库实例。最简单的方法是启动一个 Docker 容器。我们已经在[第 7 章](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml)，*与数据库的可靠集成*中做了这件事，在那里我们学习了如何使用
    Rust 与数据库交互。你可以使用以下命令启动一个新的包含 PostgreSQL 数据库实例的容器：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When the container is started, run the example server we wrote in this section
    with the `cargo run` command. It prints after compilation and the server is ready
    to accept requests:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，使用 `cargo run` 命令运行本节中编写的示例服务器。编译后它会打印出来，服务器准备好接受请求：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now you can use the link provided to log visits from your browser. If it is
    configured successfully, you will see the response in the browser:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用提供的链接从你的浏览器记录访问。如果配置成功，你将在浏览器中看到响应：
- en: '![](img/bc7f0d17-5d2d-44d8-b313-1c01b32cc5c4.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc7f0d17-5d2d-44d8-b313-1c01b32cc5c4.png)'
- en: 'Gotham processed the request and returned a result to you. If you shut down
    the database, the server will return a response with a 500 error code and the *"connection
    closed"* string. The last thing we have to do is verify that the server added
    the records to the database, because we used an asynchronous approach to interact
    with the database and used the same `Runtime` to handle HTTP requests and perform
    SQL statements. Run the `**psql**` client for the `postgres://postgres@localhost:5432`
    connection and enter a query:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Gotham 处理了请求并返回了一个结果给你。如果你关闭数据库，服务器将返回一个带有 500 错误代码和 `"connection closed"` 字符串的响应。我们最后要做的就是验证服务器是否将记录添加到了数据库中，因为我们使用异步方法与数据库交互，并使用相同的
    `Runtime` 来处理 HTTP 请求和执行 SQL 语句。为 `postgres://postgres@localhost:5432` 连接运行 `**psql**`
    客户端并输入一个查询：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We made two requests from two different browsers and now we have two records
    in the `agents` table.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个不同的浏览器中发出了两个请求，现在我们在 `agents` 表中有两条记录。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduced you to comfortable frameworks that greatly simplify
    the writing of microservices: Rouille, Nickel, and Rocket.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了几个简化微服务编写的舒适框架：Rouille、Nickel 和 Rocket。
- en: The Rouille framework is built around the `router!` macro and helps you to declare
    all the paths and methods you need in a simple way. The routing declaration looks
    similar to how we did it with Hyper, but much, much simpler.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Rouille 框架围绕 `router!` 宏构建，帮助你以简单的方式声明所需的全部路径和方法。路由声明看起来与我们使用 Hyper 的方式相似，但简单得多。
- en: The Nickel framework is also pretty simple to use and is inspired by the Express
    framework of JavaScript.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Nickel 框架也很简单易用，灵感来源于 JavaScript 的 Express 框架。
- en: The Rocket framework is pretty cool and helps you to write a handler in an intuitive,
    clear style, but it needs the nightly version of the compiler.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket 框架非常酷，可以帮助你以直观、清晰的方式编写处理器，但它需要编译器的夜间版本。
- en: 'The Gotham framework is an asynchronous framework that''s based on the `tokio`
    and `hyper` crates. It allows you to use all of the benefits of asynchronous applications:
    handling thousands of requests in parallel and utilizing all resources completely.
    We created an example that works with a database by sending queries to it using
    the asynchronous `tokio-postgres` crate.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Gotham 框架是一个基于 `tokio` 和 `hyper` crate 的异步框架。它允许你使用异步应用程序的所有好处：并行处理数千个请求并充分利用所有资源。我们创建了一个示例，通过向它发送查询来使用异步的
    `tokio-postgres` crate 与数据库一起工作。
- en: But there are many more frameworks and we can't cover all of them. Most frameworks
    are synchronous and are simple to use. If you want to write an asynchronous microservice,
    I recommend you use, in most cases, the `actix-web` crate, which we will explore
    in the next chapter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有更多的框架，我们无法涵盖所有。大多数框架都是同步的，并且使用起来很简单。如果你想编写一个异步微服务，我推荐你大多数情况下使用`actix-web`
    crate，我们将在下一章中对其进行探讨。
