- en: Now It&#x27;s Your Turn!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're rapidly approaching the end of the book and it is time for you to put
    what we've covered and you've learned into practice. As with [Chapter 6](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Rust Applications*, this chapter will take the form of a number of challenges
    for you. There is no sample code for this chapter, so it's all down to you. The
    majority of the challenges will be based around the `mathlib` library covered
    in [Chapter 10](part0238.html#72V5S0-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Crate*, as well as using code created in [Chapter 6](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Rust Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – cleaning the code (part 1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you consider the code examples in `temperature.rs`, you will see that some
    use a tuple and some use a single type `return`. While for development this is
    a fairly acceptable approach, for a release we may want something more structured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the two functions `kelvin_to_celcius` and `celcius_to_farenheit`;
    in order to use them, we need to have two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of possible solutions to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Do nothing! Many libraries use multiple variables when the function returns
    different types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a trait within the module that tests the return for false and returns
    either a `String` containing the answer or *calculation failed*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define a single `struct` for the answer of the form, which is then passed back
    to the caller, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we remove the first option (after all, what would be the point in doing this
    as part of a chapter given over to testing what we have covered?), we are left
    with options 2 - 4 or 3.
  prefs: []
  type: TYPE_NORMAL
- en: The problems with each option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each option has its own unique associated problems.
  prefs: []
  type: TYPE_NORMAL
- en: The String option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The issue with the second option is that, if we return a `String` and then want
    to do something else with the answer (possibly a further calculation from one
    of the other modules within the crate), we will need some method of converting
    the string (after checking it doesn't contain the error code) back to an `f32`
    to pass into the second function.
  prefs: []
  type: TYPE_NORMAL
- en: The struct option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem with the third option is that, when we call within the library,
    we either have a return type of `tuple(bool, f32)` or `f32`. Therefore, in a function
    that only returns a single type, we will need to set `calc_completed` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to set a default value on the `struct` by deriving or implementing
    `std::Default` (we will cover the standard library in [Chapter 13](part0303.html#90UQE0-a5175cb437d742a9aed0ea574000ee2d),
    *The Standard Library*,  and [Chapter 14](part0359.html#AMBPU0-a5175cb437d742a9aed0ea574000ee2d), *Foreign
    Function Interfaces*). Here''s a derived version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All primitive types in Rust have a sensible default value: numbers are zeroes,
    bool is false, Strings are empty strings, and so on. The preceding code is equivalent
    to the following manually implemented `Default` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we want the calc_complete default to be true, so we''ll use this implementation
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `Default` implementation, we may choose to only fill in some of the
    values when creating an instance and supply `Default::default()` for the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The potential problem is where to put the struct in terms of scope. Where would
    it be best to place it?
  prefs: []
  type: TYPE_NORMAL
- en: The task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are to decide which one of the options for refactoring the code would work
    best and then implement it. You should create a number of unit tests to ensure
    the sanity checks work and then test it in your own test rig application to ensure
    nothing has broken with the crate and scope.
  prefs: []
  type: TYPE_NORMAL
- en: Task 2 – cleaning the code (part 2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While each function is kept apart in the crate, we can always clean up the code
    to make it safer (we have a single public function and keep the calculations away
    from prying eyes).
  prefs: []
  type: TYPE_NORMAL
- en: The task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each function takes a single parameter of either the `f32` or `i32` type and
    thankfully, we can separate out the modules to be those that return an `f32` or
    `i32` (the bases all return `i32`: all of the others have their answers in `f32`).'
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the temperatures module, everything will return the answer as
    `f32` (after task 1, how it does this is up to you). We can therefore create a
    single function that takes as the first parameter the conversion to be performed
    and as the second the value.
  prefs: []
  type: TYPE_NORMAL
- en: When the single function recognizes the first parameter, it calls the now private
    functions and returns the value.
  prefs: []
  type: TYPE_NORMAL
- en: As with the first task, you will need to implement this and create documentation
    for the new library. You should create a new unit test for the crate and test
    it in your test rig application.
  prefs: []
  type: TYPE_NORMAL
- en: Task 3 – extending the crate (part 1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will have noticed that, in the example library, there is no code at all
    for the `regression_analysis` module. This is deliberate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in [Chapter 6](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Rust Applications*, one of the tasks was to create code that enabled
    you to perform a regression analysis based on formulae provided. The code created
    can now be firmly split into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The equation for the straight line, *y = mx + c*, which will also give the intercepts
    on the *x* and *y* axis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard deviation and regression analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this task, you are to take your code and put it into the `mathslib` crate.
    This may not be as simple as it seems. The library will need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: A filename for the file containing the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vector containing either a `struct` or `tuple` that holds the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the problem doesn't lie in the data, but rather in the fact that, each
    time a calculation is made, the whole regression analysis has to be performed.
    For example, to calculate the standard deviation, you can't just pass in the results
    for the equation of a straight line—that won't work, but will cause the whole
    calculation to be performed again.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the speed of a library, this is very inefficient; you should calculate
    once and be able to draw out all answers from there. In terms of your code, this
    will require some re-organization.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have done this, you should create the unit tests for each function
    and test them in your test rig app with both a vector then the filename.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to add the documentation for this task to your current documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Task 4 – extending the crate (part 2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, you will have a firm grasp of how crates work, the required testing
    regime, and creating a test rig. Your final task in this section is to create
    your own extension to the crate. There are some criteria though to your extension:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the functions must return a non-primitive type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The calculations should be private; there should be some form of interface to
    the function call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be a single function that takes an XML file as a parameter to perform
    the calculation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new module must be fully documented and complete with its own tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've finished the main part of the book. We've covered the majority of the
    Rust language and these end-of-section chapters should have helped you consolidate
    your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: In the final part of the book, we'll cover the standard libraries and how to
    interface your Rust application to an external library.
  prefs: []
  type: TYPE_NORMAL
