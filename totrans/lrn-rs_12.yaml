- en: Now It&#x27;s Your Turn!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're rapidly approaching the end of the book and it is time for you to put
    what we've covered and you've learned into practice. As with [Chapter 6](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Rust Applications*, this chapter will take the form of a number of challenges
    for you. There is no sample code for this chapter, so it's all down to you. The
    majority of the challenges will be based around the `mathlib` library covered
    in [Chapter 10](part0238.html#72V5S0-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Crate*, as well as using code created in [Chapter 6](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Rust Applications*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – cleaning the code (part 1)
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you consider the code examples in `temperature.rs`, you will see that some
    use a tuple and some use a single type `return`. While for development this is
    a fairly acceptable approach, for a release we may want something more structured.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the two functions `kelvin_to_celcius` and `celcius_to_farenheit`;
    in order to use them, we need to have two variables:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are a number of possible solutions to this problem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Do nothing! Many libraries use multiple variables when the function returns
    different types.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a trait within the module that tests the return for false and returns
    either a `String` containing the answer or *calculation failed*.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define a single `struct` for the answer of the form, which is then passed back
    to the caller, as follows:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we remove the first option (after all, what would be the point in doing this
    as part of a chapter given over to testing what we have covered?), we are left
    with options 2 - 4 or 3.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The problems with each option
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each option has its own unique associated problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The String option
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The issue with the second option is that, if we return a `String` and then want
    to do something else with the answer (possibly a further calculation from one
    of the other modules within the crate), we will need some method of converting
    the string (after checking it doesn't contain the error code) back to an `f32`
    to pass into the second function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The struct option
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem with the third option is that, when we call within the library,
    we either have a return type of `tuple(bool, f32)` or `f32`. Therefore, in a function
    that only returns a single type, we will need to set `calc_completed` to `true`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to set a default value on the `struct` by deriving or implementing
    `std::Default` (we will cover the standard library in [Chapter 13](part0303.html#90UQE0-a5175cb437d742a9aed0ea574000ee2d),
    *The Standard Library*,  and [Chapter 14](part0359.html#AMBPU0-a5175cb437d742a9aed0ea574000ee2d), *Foreign
    Function Interfaces*). Here''s a derived version:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All primitive types in Rust have a sensible default value: numbers are zeroes,
    bool is false, Strings are empty strings, and so on. The preceding code is equivalent
    to the following manually implemented `Default` :'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, we want the calc_complete default to be true, so we''ll use this implementation
    instead:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the `Default` implementation, we may choose to only fill in some of the
    values when creating an instance and supply `Default::default()` for the rest:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The potential problem is where to put the struct in terms of scope. Where would
    it be best to place it?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The task
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are to decide which one of the options for refactoring the code would work
    best and then implement it. You should create a number of unit tests to ensure
    the sanity checks work and then test it in your own test rig application to ensure
    nothing has broken with the crate and scope.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Task 2 – cleaning the code (part 2)
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While each function is kept apart in the crate, we can always clean up the code
    to make it safer (we have a single public function and keep the calculations away
    from prying eyes).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The task
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each function takes a single parameter of either the `f32` or `i32` type and
    thankfully, we can separate out the modules to be those that return an `f32` or
    `i32` (the bases all return `i32`: all of the others have their answers in `f32`).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the temperatures module, everything will return the answer as
    `f32` (after task 1, how it does this is up to you). We can therefore create a
    single function that takes as the first parameter the conversion to be performed
    and as the second the value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: When the single function recognizes the first parameter, it calls the now private
    functions and returns the value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: As with the first task, you will need to implement this and create documentation
    for the new library. You should create a new unit test for the crate and test
    it in your test rig application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Task 3 – extending the crate (part 1)
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will have noticed that, in the example library, there is no code at all
    for the `regression_analysis` module. This is deliberate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in [Chapter 6](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Rust Applications*, one of the tasks was to create code that enabled
    you to perform a regression analysis based on formulae provided. The code created
    can now be firmly split into two parts:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The equation for the straight line, *y = mx + c*, which will also give the intercepts
    on the *x* and *y* axis
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard deviation and regression analysis
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this task, you are to take your code and put it into the `mathslib` crate.
    This may not be as simple as it seems. The library will need to take:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: A filename for the file containing the data
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vector containing either a `struct` or `tuple` that holds the data
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the problem doesn't lie in the data, but rather in the fact that, each
    time a calculation is made, the whole regression analysis has to be performed.
    For example, to calculate the standard deviation, you can't just pass in the results
    for the equation of a straight line—that won't work, but will cause the whole
    calculation to be performed again.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the speed of a library, this is very inefficient; you should calculate
    once and be able to draw out all answers from there. In terms of your code, this
    will require some re-organization.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就库的速度而言，这非常低效；你应该计算一次，然后能够从那里提取所有答案。至于你的代码，这需要一些重新组织
- en: Once you have done this, you should create the unit tests for each function
    and test them in your test rig app with both a vector then the filename.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你应该为每个函数创建单元测试，并在你的测试应用中用向量以及文件名来测试它们
- en: You will need to add the documentation for this task to your current documentation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将此任务的文档添加到你的当前文档中
- en: Task 4 – extending the crate (part 2)
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务4 – 扩展crate（第二部分）
- en: 'By now, you will have a firm grasp of how crates work, the required testing
    regime, and creating a test rig. Your final task in this section is to create
    your own extension to the crate. There are some criteria though to your extension:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你将牢固掌握crate的工作方式、所需的测试规范以及创建测试应用。本节你最后的任务是创建自己的crate扩展。不过，你的扩展也有一些标准：
- en: One of the functions must return a non-primitive type
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个函数必须返回一个非原始类型
- en: The calculations should be private; there should be some form of interface to
    the function call
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算应该是私有的；应该有一种形式来访问函数调用
- en: There should be a single function that takes an XML file as a parameter to perform
    the calculation
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个函数，它接受一个XML文件作为参数来执行计算
- en: The new module must be fully documented and complete with its own tests
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新模块必须完全文档化，并包含其自身的测试
- en: Summary
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've finished the main part of the book. We've covered the majority of the
    Rust language and these end-of-section chapters should have helped you consolidate
    your knowledge.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了书籍的主要部分。我们已经涵盖了Rust语言的大部分内容，这些章节的结尾应该有助于你巩固你的知识
- en: In the final part of the book, we'll cover the standard libraries and how to
    interface your Rust application to an external library.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的最后一部分，我们将介绍标准库以及如何将你的Rust应用程序与外部库接口
