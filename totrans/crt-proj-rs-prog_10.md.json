["```rs\nsu root\n```", "```rs\nsudo apt update\nsudo apt install llvm clang\n```", "```rs\nsudo apt install linux-headers-4.15.0-72-generic\n```", "```rs\nsudo apt install linux-headers-\"$(uname -r)\"\n```", "```rs\nrustup toolchain install nightly\n```", "```rs\nrustup component add --toolchain=nightly rust-src rustfmt \n```", "```rs\nrustup default nightly-x86_64-unknown-linux-gnu\n```", "```rs\ncargo install cargo-xbuild\n```", "```rs\n./bd\n```", "```rs\nmodinfo boilerplate.ko\n```", "```rs\nsudo insmod boilerplate.ko\n```", "```rs\nlsmod | grep -w boilerplate\n```", "```rs\nsudo rmmod boilerplate\n```", "```rs\ndmesg --color=always | tail\n```", "```rs\n#!/bin/sh\ncur_dir=$(pwd)\ncd ../linux-fw\ncargo build\ncd $cur_dir\nRUST_TARGET_PATH=$(pwd)/../linux-fw cargo xbuild --target x86_64-linux-kernel-module && make\n```", "```rs\n[package]\nname = \"boilerplate\"\nversion = \"0.1.0\"\nauthors = []\nedition = \"2018\"\n\n[lib]\ncrate-type = [\"staticlib\"]\n\n[dependencies]\nlinux-kernel-module = { path = \"../linux-fw\" }\n\n[profile.release]\npanic = \"abort\"\nlto = true\n\n[profile.dev]\npanic = \"abort\"\n```", "```rs\n./br\n```", "```rs\n#![no_std]\n```", "```rs\nuse linux_kernel_module::c_types;\nuse linux_kernel_module::println;\n```", "```rs\n#[no_mangle]\npub extern \"C\" fn init_module() -> c_types::c_int {\n    println!(\"boilerplate: Loaded\");\n    0\n}\n\n#[no_mangle]\npub extern \"C\" fn cleanup_module() {\n    println!(\"boilerplate: Unloaded\");\n}\n```", "```rs\n#[link_section = \".modinfo\"]\npub static MODINFO: [u8; 12] = *b\"license=GPL\\0\";\n```", "```rs\nsudo insmod state.ko\nlsmod | grep -w state\nsudo rmmod state\ndmesg --color=always | tail\n```", "```rs\n[123456.789012] state: Loaded\n[123463.987654] state: Unloaded 1001\n```", "```rs\nstruct GlobalData { n: u16 }\n\nstatic mut GLOBAL: GlobalData = GlobalData { n: 1000 };\n```", "```rs\nunsafe { GLOBAL.n += 1; }\n```", "```rs\nprintln!(\"state: Unloaded {}\", unsafe { GLOBAL.n });\n```", "```rs\nsudo insmod allocating.ko\nlsmod | grep -w allocating\nsudo rmmod allocating\ndmesg --color=always | tail\n```", "```rs\nallocating: Unloaded 1001 abcd 500000\n```", "```rs\nextern crate alloc;\nuse crate::alloc::string::String;\nuse crate::alloc::vec::Vec;\n```", "```rs\nstruct GlobalData {\n    n: u16,\n    msg: String,\n    values: Vec<i32>,\n}\n\nstatic mut GLOBAL: GlobalData = GlobalData {\n    n: 1000,\n    msg: String::new(),\n    values: Vec::new(),\n};\n```", "```rs\nunsafe {\n    GLOBAL.n += 1;\n    GLOBAL.msg += \"abcd\";\n    GLOBAL.values.push(500_000);\n}\n```", "```rs\nunsafe {\n    println!(\"allocating: Unloaded {} {} {}\",\n        GLOBAL.n,\n        GLOBAL.msg,\n        GLOBAL.values[0]\n    );\n}\n```", "```rs\nsudo insmod dots.ko\nlsmod | grep -w dots\n```", "```rs\ngrep -w dots /proc/devices\n```", "```rs\n236 dots\n```", "```rs\nsudo mknod /dev/dots1 c 236 0\n```", "```rs\nhead -c42 /dev/dots1\n```", "```rs\n.........*.........*.........*.........*..\n```", "```rs\nsudo mknod /dev/dots2 c 236 0\n```", "```rs\nhead -c12 /dev/dots2\n```", "```rs\n.......*....\n```", "```rs\ncat /dev/dots1\n```", "```rs\nsudo rm /dev/dots1 /dev/dots2\n```", "```rs\nsudo rmmod dots\n```", "```rs\nhead: cannot open '/dev/dots1' for reading: No such device or address\n```", "```rs\ndmesg --color=always | tail\n```", "```rs\n[123456.789012] dots: Loaded with major device number 236\n[123463.987654] dots: Unloaded 54\n```", "```rs\nuse linux_kernel_module::bindings::{\n    __register_chrdev, __unregister_chrdev, _copy_to_user, file, file_operations, loff_t,\n};\n```", "```rs\nstruct CharDeviceGlobalData {\n    major: c_types::c_uint,\n    name: &'static str,\n    fops: Option<Box<file_operations>>,\n    count: u64,\n}\n```", "```rs\nstatic mut GLOBAL: CharDeviceGlobalData = CharDeviceGlobalData {\n    major: 0,\n    name: \"dots\\0\",\n    fops: None,\n    count: 0,\n};\n```", "```rs\nlet mut fops = Box::new(file_operations::default());\nfops.read = Some(read_dot);\nlet major = unsafe {\n    __register_chrdev(\n        0,\n        0,\n        256,\n        GLOBAL.name.as_bytes().as_ptr() as *const i8,\n        &*fops,\n    )\n};\n```", "```rs\nif major < 0 {\n    return 1;\n}\nunsafe {\n    GLOBAL.major = major as c_types::c_uint;\n}\nprintln!(\"dots: Loaded with major device number {}\", major);\nunsafe {\n    GLOBAL.fops = Some(fops);\n}\n0\n```", "```rs\nunsafe {\n    println!(\"dots: Unloaded {}\", GLOBAL.count);\n    __unregister_chrdev(\n        GLOBAL.major,\n        0,\n        256,\n        GLOBAL.name.as_bytes().as_ptr() as *const i8,\n    )\n}\n```", "```rs\nextern \"C\" fn read_dot(\n    _arg1: *mut file,\n    arg2: *mut c_types::c_char,\n    _arg3: usize,\n    _arg4: *mut loff_t,\n) -> isize {\n    unsafe {\n        GLOBAL.count += 1;\n        _copy_to_user(\n            arg2 as *mut c_types::c_void,\n            if GLOBAL.count % 10 == 0 { \"*\" } else { \".\" }.as_ptr() as *const c_types::c_void,\n            1,\n        );\n        1\n    }\n}\n```"]