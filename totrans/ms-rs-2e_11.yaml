- en: Logging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: Logging is an important, yet overlooked, practice in the software development
    life cycle. It is often integrated as an afterthought on facing the consequences
    of latent invalid states and errors that accumulate over time in software systems.
    Any moderate sized project should have logging support from the initial days of
    development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是软件开发生命周期中一个重要但常被忽视的实践。它通常是在面对潜在无效状态和错误积累的后果时才被作为事后考虑而集成。任何适度规模的项目都应该在开发初期就具备日志支持。
- en: In this chapter, we'll get to know why setting up logging in an application
    is important, the need for a logging framework, how to approach logging, and what
    crates are available in the Rust ecosystem to enable programmers to leverage the
    power of logging in their applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解为什么在应用程序中设置日志很重要，日志框架的需求，如何处理日志，以及Rust生态系统中可用的crate，以使程序员能够利用日志在他们的应用程序中的力量。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is logging and why do we need it?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是日志以及为什么我们需要它？
- en: The need for logging frameworks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志框架的需求
- en: Logging frameworks and their features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志框架及其功能
- en: Exploring logging crates in Rust
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Rust中的日志crate
- en: What is logging and why do we need it?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是日志以及为什么我们需要它？
- en: '"Generally, a program should say nothing unless and until it has something
    to say."                                                                     
                                                                                 
                                                                                 
                                    - Kernighan and Plauger'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “一般来说，一个程序除非有话要说，否则不应该说任何话。” —— 肯尼根和普劳格
- en: Before we talk about the importance of logging, let's define the term so that
    we have a better context for it. Logging is the practice of making an application
    record its activity at runtime to any output, where the individual record is called
    an **event log**or simply a **log**. This is often associated with a timestamp
    describing when the event occurred. The event could be anything that changes the
    state of the program internally or externally. Logs help you in gaining insights
    on an application's runtime behavior over the course of time, or in getting more
    context on the application state when debugging a bug. They also find their use
    in generating analytics reports for business purposes. This is to say that the
    degree of utility logging provides to a user depends mainly on the application
    and consumers' needs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论日志的重要性之前，让我们定义这个术语，以便我们有一个更好的背景。日志是在运行时让应用程序将其活动记录到任何输出中的实践，其中单个记录被称为**事件日志**或简单地称为**日志**。这通常与一个时间戳相关联，描述事件发生的时间。事件可以是任何改变程序内部或外部状态的事情。日志可以帮助你在一段时间内了解应用程序的运行时行为，或者在调试错误时获得更多关于应用程序状态的信息。它们还用于生成用于商业目的的分析报告。也就是说，日志为用户提供的有用程度主要取决于应用程序和消费者的需求。
- en: Now, in an application without any kind of logging integration, there are limited
    options for us to know about the behavior of our program at runtime. We could
    use external utilities such as *htop* in Linux to monitor our program, but this
    gives us a view of the program from the outside and provides limited information
    regarding the internals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在一个没有任何类型日志集成的应用程序中，我们了解程序在运行时行为的选择有限。我们可以使用外部工具，如Linux中的*htop*来监控我们的程序，但这只提供了从外部看程序的角度，并且关于内部信息提供的信息有限。
- en: Information from within a program while it's running is useful for debugging
    purposes or can be used for runtime performance analysis. In the case of fatal
    failures in our program, we can get to know about the whereabouts of our program
    when it crashes. At the very least, the program will leave a stack trace, thus
    providing a bit of context on where the program went wrong. However, there are
    classes of bugs and events that do not cause immediate problems but later turn
    into fatal errors, especially in long running systems. In these cases, event logs
    can help quickly narrow down the issue in the program. That's where adding logging
    capabilities to a program becomes tremendously helpful.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序运行期间从程序内部获取的信息对于调试目的很有用，或者可以用于运行时性能分析。在我们的程序发生致命故障的情况下，我们可以了解程序崩溃时的位置。至少，程序会留下堆栈跟踪，从而提供一些关于程序出错位置的上下文。然而，有一些类别的错误和事件不会立即引起问题，但后来会变成致命错误，尤其是在长时间运行的系统中。在这些情况下，事件日志可以帮助快速缩小程序中的问题范围。这就是为什么在程序中添加日志功能变得极其有帮助。
- en: Systems that benefit greatly from logging and need to rely on event logs are
    web services, network servers, stream processing services, and similar long running
    systems. In these systems, individual event logs combined with subsequent logs
    over the course of time, when ingested and put into analysis by a log aggregation
    service, can provide useful statistics about the system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志中受益并需要依赖事件日志的系统包括网络服务、网络服务器、流处理服务以及类似的长时间运行系统。在这些系统中，单个事件日志与随时间推移产生的后续日志相结合，当由日志聚合服务摄取并进行分析时，可以提供有关系统的有用统计数据。
- en: For a commercial application such as a shopping website, you can leverage log
    analytics to get business insights, leading to better sales. In network servers,
    you can find useful activity logs to track any malicious attempts made to the
    server such as a distributed denial of service (DDoS) attack. Developers can assess
    the performance of their web API endpoints by getting request-response latency
    figures from the collected API request logs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像购物网站这样的商业应用程序，你可以利用日志分析来获得业务洞察，从而带来更好的销售。在网络服务器中，你可以找到有用的活动日志来跟踪对服务器进行的任何恶意尝试，例如分布式拒绝服务（DDoS）攻击。开发者可以通过从收集的API请求日志中获得请求-响应延迟数据来评估他们的Web
    API端点的性能。
- en: Logs also serve as an important debugging context and can minimize the time
    that's taken in performing root cause analysis during a debugging session, where
    you have time constraints to fix issues that happen in production.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 日志还充当重要的调试上下文，并可以在调试会话中进行根本原因分析时最小化所花费的时间，在调试会话中，你有时间限制来修复生产中发生的问题。
- en: Sometimes, logging is the only way to do this because debuggers are not always
    available or applicable. This is usually the case in distributed systems and multi-threaded
    applications. Anyone who has done a fair amount of development within these systems
    is quite aware of why logging is such an important part of the software development
    pipeline.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，日志是唯一的方法，因为并非总是有调试器可用或适用。这通常是在分布式系统和多线程应用程序中。任何在这些系统中进行过相当数量开发的人都非常清楚为什么日志是软件开发流程中如此重要的一个部分。
- en: 'There are three broad categories of users who benefit greatly from the practice
    of application logging:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有三类用户从应用日志实践中获得巨大益处：
- en: '**System administrators**: They need to monitor server logs for any malfunction,
    for example, a hard disk crash or network failures.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统管理员**：他们需要监控服务器日志以发现任何故障，例如硬盘崩溃或网络故障。'
- en: '**Developers**: During development, integrating logs in the project can help
    cut down development time by a lot and can later be used to get insights into
    the way users use their application.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者**：在开发过程中，将日志集成到项目中可以大大减少开发时间，并且以后可以用来深入了解用户如何使用他们的应用程序。'
- en: '**Network security teams**: In the case of any attack on a remote server, the
    security folks benefit greatly from logging as they can get to know how a certain
    attack was carried out by tracing the event logs that the victim server logged.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络安全团队**：在远程服务器遭受任何攻击的情况下，安全人员从日志中受益匪浅，因为他们可以通过追踪受攻击服务器记录的事件日志来了解某种攻击是如何进行的。'
- en: Being a functional component in software development practices, and providing
    great value in the long run, integrating logging in a system demands dedicated
    frameworks, and we'll see why in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发实践中的功能组件，并在长期内提供巨大价值，将日志集成到系统中需要专门的框架，我们将在下一节中看到原因。
- en: The need for logging frameworks
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对日志框架的需求
- en: We now know why logs are important. The next question however is how do we integrate
    logging capabilities in our application? The simplest and most straightforward
    way to get your application to log events is to have a bunch of print statements
    sprinkled in code at the required places. This way, we easily get our event logs
    to the standard output on our Terminal console, which gets our job done, but there's
    more to be desired. In quite a few cases, we also want our logs to persist for
    analysis at a later point in time. So, if we want to collect the output from our
    print statements to a file, we have to look for additional ways such as piping
    the output to a file using the shell output redirection facility, which is basically
    plumbing a different set of tools to get to the goal of getting logs from our
    application to different outputs. As it turns out, there are limitations to this
    approach.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道日志为什么很重要。然而，接下来的问题是，我们如何在应用程序中集成日志功能？让应用程序记录事件最简单、最直接的方法是在代码中需要的地方添加一些打印语句。这样，我们就可以轻松地将事件日志输出到我们的终端控制台的标准输出，这样我们的工作就完成了，但还有更多值得期待。在许多情况下，我们还想让我们的日志在稍后进行分析时保持持久。因此，如果我们想将打印语句的输出收集到文件中，我们必须寻找额外的途径，例如使用shell输出重定向功能将输出管道到文件，这基本上是使用不同的工具来实现将日志从我们的应用程序输出到不同输出的目标。结果证明，这种方法存在局限性。
- en: You don't get to filter or turn off your print statements for cases where you
    don't need to log for a particular module. For that, you either have to comment
    them out or remove them and redeploy your services. Another limitation is that
    when your logging commands become large, you have to write and maintain shell
    scripts for collecting logs for multiple outputs. All of this gets unwieldy and
    less maintainable very quickly. Using a print statement is a quick and dirty logging
    practice and is not a very scalable solution. What we need is a better and more
    customizable architecture for application logging. The scalable and cleaner way
    is to have a dedicated logger that removes all of these limitations, and that
    is why logging frameworks exist. In addition to basic logging needs, these frameworks
    also provide additional features such as log file rotations when reaching a certain
    size limit, setting logging frequency, granular log configuration per module,
    and much more.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法过滤或关闭不需要为特定模块记录日志的打印语句。为此，你必须注释掉它们或删除它们并重新部署你的服务。另一个限制是，当你的日志命令变得很大时，你必须编写和维护用于收集多个输出的日志的shell脚本。所有这些都很快变得难以控制且难以维护。使用打印语句是一种快速而低效的日志记录实践，并且不是一个非常可扩展的解决方案。我们需要的是一个更好、更可定制的应用程序日志架构。可扩展且更干净的方法是拥有一个专门的记录器，它可以消除所有这些限制，这就是为什么存在日志框架的原因。除了基本的日志需求之外，这些框架还提供了诸如达到一定大小限制时的日志文件轮换、设置日志频率、按模块进行细粒度日志配置等附加功能。
- en: Logging frameworks and their key features
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志框架及其关键特性
- en: 'There are a wide variety of logging frameworks offered by mainstream languages.
    Some notable ones to mention include *Log4j* from Java, *Serilog* from C#, and *Bunyan*
    from Node.js. From the time of proliferation of these frameworks, and from their
    use cases, there are similarities in what features a logging framework should
    provides to its users. The following are the most desirable properties that logging
    frameworks should have:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 主流语言提供了各种各样的日志框架。其中一些值得提及的包括来自Java的*Log4j*，来自C#的*Serilog*，以及来自Node.js的*Bunyan*。自这些框架的普及以来，从它们的使用案例来看，日志框架应该提供给用户哪些功能有相似之处。以下是最理想的属性，日志框架应该具备：
- en: '**Fast**: Logging frameworks must ensure that they are not doing expensive
    operations when logging and should be able to process efficiently using as few
    CPU cycles as possible. For instance, in Java, if your log statements contain
    objects with lots of `to_string()` calls to them to just interpolate the object
    within the log message, then that''s an expensive operation. This is considered
    an inefficient practice in Java.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**：日志框架必须确保在日志记录时不会执行昂贵的操作，并且应该能够尽可能少地使用CPU周期来高效地处理。例如，在Java中，如果你的日志语句包含许多需要调用`to_string()`方法的对象，只是为了在日志消息中内联对象，那么这被认为是一种低效的做法。'
- en: '**Configurable outputs**: It''s very limiting to have the ability to log messages only
    to standard output. It stays only until the shell session and you need to manually
    paste the logs to a file to use them later. Logging frameworks should provide
    the ability to support multiple outputs, such as a file or even a network socket.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置的输出**：只有将日志消息记录到标准输出是非常有限的。它们仅在shell会话中保留，您需要手动将日志粘贴到文件中才能稍后使用。日志框架应该提供支持多个输出的能力，例如文件或甚至网络套接字。'
- en: '**Log levels:** The prominent feature of logging frameworks that makes them
    stand out from normal print-based logging is the ability to control what and when
    things get logged. This is usually implemented using the idea of *log levels*.
    A log level is a configurable filter that''s usually implemented as a type that
    is checked for before sending the log output anywhere. The levels are usually
    in the following order, from lowest priority to highest priority:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志级别**：日志框架的显著特征是能够控制记录什么和何时记录，这使得它们与基于打印的常规日志记录区分开来。这通常是通过使用*日志级别*的概念实现的。日志级别是一个可配置的过滤器，通常实现为一个在发送日志输出之前检查的类型。级别通常按以下顺序排列，从最低优先级到最高优先级：'
- en: '**Error**: This level is suitable for logging events that are critical and
    those that may lead to invalid outputs from the application.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：此级别适用于记录关键事件以及可能导致应用程序输出无效的事件。'
- en: '**Warn**: This level is suitable for events for which you have taken measures,
    but also want to know when it happens to take actions later if they occur frequently.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告**：此级别适用于已经采取措施的事件，但也希望在事件频繁发生时能够采取后续行动。'
- en: '**Info**: This level can be used for normal events such as printing the application
    version, user logins, connection successful messages, and so on.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**：此级别可用于正常事件，例如打印应用程序版本、用户登录、连接成功消息等。'
- en: '**Debug**: As the name suggests, this is used to support debugging. It is useful
    for monitoring the values of variables and how they get manipulated in different
    code paths when debugging.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：正如其名所示，这用于支持调试。在调试时，它有助于监控变量的值以及它们在不同代码路径中的操作。'
- en: '**Trace**: This level is used when you want a step-by-step execution of your
    algorithm or any non-trivial function that you wrote. Method invocations with
    parameter and return values are things that can be put as trace logs.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：当您想要算法或您编写的任何非平凡函数的逐步执行时，使用此级别。带有参数和返回值的函数调用可以作为跟踪日志放置。'
- en: Some of these names might differ slightly across frameworks, but the priorities
    they signify are mostly the same. In major logging frameworks, these levels are
    set by the logger during its initialization and any subsequent logging invocations
    check for the set level and filters out the logs accordingly. For example, a `Logger`
    object with the call to `Logger.set_level(INFO)` would allow all logs using levels
    above `Info` to be logged, while ignoring `Debug` and `Trace` logs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称在不同的框架中可能会有细微差别，但它们所表示的优先级大多相同。在主要的日志框架中，这些级别是在日志记录器初始化时设置的，任何后续的日志调用都会检查设置的级别，并根据该级别过滤日志。例如，调用`Logger.set_level(INFO)`的`Logger`对象将允许记录所有高于`Info`级别的日志，而忽略`Debug`和`Trace`日志。
- en: '**Log filtering**: It should be easy to log only the desired places in code
    and to turn off other logs based on the severity/importance of events.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志过滤**：应该能够轻松地仅记录代码中需要的地方，并根据事件的严重性/重要性关闭其他日志。'
- en: '**Log Rotation**: When logging to a file, it is imminent that prolonged logging
    will fill up disk space. A logging framework should provide facilities to limit
    the log file size and allow for the deletion of older log files.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志轮转**：当将日志记录到文件时，长期记录会填满磁盘空间。日志框架应该提供限制日志文件大小和允许删除旧日志文件的功能。'
- en: '**Asynchronous logging**: Logging invocations on the main thread have the possibility
    of blocking the main code from making progress. Even though an efficient logger
    would do as little as possible, it still does a blocking I/O call between the
    actual code. As such, it is desirable that most logging invocations are offloaded
    to a dedicated logger thread.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步日志记录**：主线程上的日志调用可能会阻塞主代码的执行。尽管高效的日志记录器会尽可能少地执行，但它仍然会在实际代码之间进行阻塞I/O调用。因此，最好将大多数日志调用卸载到专门的日志记录器线程。'
- en: '**Log message attributes**: Another thing worth mentioning are the attributes
    on log messages that get sent to the logging API. At a minimum, a logging framework
    should provide the following attributes to log messages:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志消息属性**：另一个值得提及的是发送到日志API的日志消息上的属性。至少，日志框架应该为日志消息提供以下属性：'
- en: '**Timestamp**: The time at which the event happened'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间戳**：事件发生的时间'
- en: '**Log Severity**: The importance of the message, for example, Error, Warning,
    Information, Debug, and so on'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志严重性**：消息的重要性，例如错误、警告、信息、调试等'
- en: '**Event location**: The place in the source code where the event happened'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件位置**：事件发生的源代码中的位置'
- en: '**Message**: The actual event message that describes what happened'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：描述发生了什么的实际事件消息'
- en: Depending on these features, there are differences in how logging frameworks
    approach logging. Let's explore them next.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些特性，日志框架在日志记录方面的方法有所不同。让我们接下来探讨它们。
- en: Approaches to logging
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录方法
- en: 'When integrating logging in an application, we need to decide what information
    to log and how granular it should be. If there are too many logs, we lose the
    ability of easily finding relevant information in the sea of noise and if there''s
    not enough log messages, we risk missing that one important event. We also need
    to think about how to organize information in our log message so that it becomes
    easier to search and analyze it later. These questions lead to logging frameworks
    that are broadly divided into two categories: unstructured logging and structured
    logging.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中集成日志时，我们需要决定要记录哪些信息以及它们应该有多详细。如果日志太多，我们就会失去在噪声中轻松找到相关信息的能力；如果日志消息不够，我们就有可能错过那个重要的事件。我们还需要考虑如何组织日志消息中的信息，以便稍后更容易搜索和分析。这些问题导致日志框架大致分为两类：非结构化日志和结构化日志。
- en: Unstructured logging
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非结构化日志
- en: The usual way to approach logging is the practice of logging events as plain
    strings and shoving any fields from required values into the log message by converting
    them into strings. This form of logging is called unstructured logging as the
    information in the log message doesn't have any predefined structure or order.
    Unstructured logging serves well for most use cases, but it has its downsides
    too.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 处理日志的通常方法是将事件记录为普通字符串，并将任何必需的值转换为字符串后放入日志消息中。这种日志记录形式称为非结构化日志，因为日志消息中的信息没有任何预定义的结构或顺序。非结构化日志对于大多数用例来说效果很好，但也有其缺点。
- en: After collecting log messages, a common use case with them is to be able search
    for them for a particular event at a later point in time. However, the retrieval
    of unstructured logs from a collection of logs can be a pain. The problem with
    unstructured log messages is that they don't have any predictable format and it
    becomes quite resource heavy for a log aggregation service to sift through all
    of the raw log messages using simple text matching queries. You need to write
    regular expressions that match on a chunk of text or grep them from the command
    line to get that particular event. With an increasing amount of logs, this approach
    eventually becomes a bottleneck in getting useful information from log files.
    The other approach is to log messages that have a predefined structure and for
    that we have structured logging.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 收集日志消息后，一个常见的用例是在稍后的时间点搜索特定事件的日志。然而，从日志集合中检索非结构化日志可能会很痛苦。非结构化日志消息的问题在于它们没有任何可预测的格式，对于日志聚合服务来说，使用简单的文本匹配查询来筛选所有原始日志消息会变得非常耗费资源。你需要编写匹配文本块的正则表达式，或者从命令行中grep它们以获取特定事件。随着日志数量的增加，这种方法最终会成为从日志文件中获取有用信息的瓶颈。另一种方法是记录具有预定义结构的日志消息，为此我们有了结构化日志。
- en: Structured logging
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化日志
- en: Structured logging is a scalable and better alternative to unstructured logging.
    As the name suggests, structured logging defines a structure and formatting to
    your log messages and every log message is guaranteed to have this format. The
    advantage of this is that it becomes very easy for log aggregation services to
    build a search index and present any particular event to the user, regardless
    of the amount of messages they have. There are quite a few structured logging
    frameworks such as Serilog in C# that provide support for structured logging.
    These frameworks provide a plugin-based log output abstraction called *Sinks. *Sinks
    are how you direct where you want your logs to be sent. A Sink can be your Terminal,
    a file, a database, or a log aggregation service such as logstash.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化日志是无结构日志的一个可扩展且更好的替代方案。正如其名所示，结构化日志为日志消息定义了结构和格式，并且保证每个日志消息都具有这种格式。这种格式的优点是，对于日志聚合服务来说，构建搜索索引并呈现任何特定事件给用户变得非常容易，无论他们有多少条消息。有许多结构化日志框架，如C#中的Serilog，它们提供了对结构化日志的支持。这些框架提供了一个基于插件的日志输出抽象，称为*Sinks*。Sinks是您将日志发送到何处的方式。一个Sink可以是您的终端、文件、数据库或日志聚合服务，如logstash。
- en: Structured logging frameworks know how to serialize a certain object and can
    do so in a proper format. They also automate the formatting of log messages by
    providing hierarchical log outputs, depending on which component the log is emitted
    from. The downside to structured logging is that it can be a bit time-consuming
    to integrate it into your application as you have to decide on the hierarchy and
    the format of your logs beforehand.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化日志框架知道如何将某个对象序列化，并且可以以适当的格式进行序列化。它们还通过提供基于组件的分层日志输出来自动化日志消息的格式化。结构化日志的缺点是，在将它们集成到应用程序中时可能会有些耗时，因为你必须事先决定日志的层次结构和格式。
- en: It's often a trade-off when choosing between structured logging and unstructured
    logging. Complex projects that log heavily can benefit from structured logging
    as they can get semantic and efficiently searchable logs from their modules, while
    small to moderate size projects can make do with unstructured logging. Ultimately,
    it's the application's needs that should decide how you integrate logging in your
    application. In the next section, we'll explore a couple of unstructured logging
    frameworks as well as structure logging frameworks in Rust that you can use for
    getting your application to log events.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择结构化日志和无结构日志之间，通常需要权衡。日志量大的复杂项目可以从结构化日志中受益，因为它们可以从模块中获得语义化和高效可搜索的日志，而小型到中等规模的项目可以使用无结构日志。最终，应该由应用程序的需求来决定您如何将日志集成到应用程序中。在下一节中，我们将探讨几个无结构日志框架以及Rust中的结构化日志框架，您可以使用这些框架使您的应用程序记录事件。
- en: Logging in Rust
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust中的日志
- en: 'Rust has quite a few flexible and extensive logging solutions. Like popular
    logging frameworks in other languages, the logging ecosystem here is split into
    two parts:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有相当多的灵活和广泛的日志解决方案。与其他语言的流行日志框架一样，这里的日志生态系统分为两部分：
- en: '**Logging facade**: This part is implemented by the `log` crate and provides
    an implementation agnostic logging API. While other frameworks implement logging
    APIs as functions or methods on some object, the log crate provides us with macro-based
    logging APIs, which are categorized by log levels to log events to a configured
    log output.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志外观**：这部分由`log` crate实现，提供了一个与实现无关的日志API。虽然其他框架将日志API实现为某些对象上的函数或方法，但log
    crate为我们提供了基于宏的日志API，这些API按日志级别分类，以将事件记录到配置的日志输出中。'
- en: '**Logging implementations**: These are community developed crates that provide
    actual logging implementation in terms of where the output goes and how it happens.
    There are many such crates, such as `env_logger`, `simple_logger`, `log4rs`, and `fern`.
    We''ll visit a couple of them in a moment. Crates that come under this category
    are meant to be used only by binary crates, that is, executables.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志实现**：这些是由社区开发的crate，它们提供了实际的日志实现，包括输出去向和实现方式。有许多这样的crate，例如`env_logger`、`simple_logger`、`log4rs`和`fern`。我们稍后会访问其中的一些。属于这一类别的crate仅适用于二进制crate，即可执行文件。'
- en: This separation of concerns between the logging API and the underlying mechanism
    by which logs go to an output is done so that developers don't need to change
    their log statements in code and can easily swap the underlying logging implementation
    on an as-needed basis.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关注点分离，即日志 API 与日志输出到输出机制之间的底层机制，是为了让开发者不需要更改代码中的日志语句，并且可以轻松地根据需要交换底层日志实现。
- en: log – Rust's logging facade
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: log – Rust 的日志门面
- en: The `log` crate comes from the *rust-lang nursery* organization on GitHub and
    is managed by the community at [https://github.com/rust-lang-nursery/log](https://github.com/rust-lang-nursery/log).
    It provides separate macros for logging at different log levels such as `error!`,
    `warn!`, `info!`, `debug!`, and `trace!`, in the order of the most priority to
    the least priority. These macros are major points of interaction for consumers
    of this crate. They internally call the `log!` macro in this crate, which does
    all the bookkeeping such as checking for the log level and formatting log messages.
    The core component of this crate is the `log` trait that other backend crates
    implement. The trait defines operations that are required for a logger and has
    other APIs, such as for checking whether logging is enabled or for flushing any
    buffered logs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` crate 来自 GitHub 上的 *rust-lang nursery* 组织，并由社区在 [https://github.com/rust-lang-nursery/log](https://github.com/rust-lang-nursery/log)
    进行管理。它为不同日志级别（如 `error!`、`warn!`、`info!`、`debug!` 和 `trace!`）提供了独立的宏，按照优先级从高到低排序。这些宏是此
    crate 的消费者主要交互点。它们内部调用此 crate 中的 `log!` 宏，该宏负责所有账簿工作，例如检查日志级别和格式化日志消息。此 crate
    的核心组件是 `log` trait，其他后端 crate 实现此 trait。该 trait 定义了日志记录器所需的操作，并具有其他 API，例如检查是否启用了日志记录或刷新任何缓冲的日志。'
- en: 'The log crate also provides a maximum log level constant called `STATIC_MAX_LEVEL`,
    which can be configured project wide at compile time. With this constant, you
    can set the log level of an application statically using cargo feature flags,
    which allows for the compile time filtering of logs for the application and all
    of its dependencies. These level filters can be set in `Cargo.toml` separately
    for debug and release builds: `max_level_<LEVEL>` (debug) and `release_max_level_<LEVEL>`
    (release). In binary projects, you can specify the dependency on the `log` crate
    with compile time log levels as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` crate 还提供了一个名为 `STATIC_MAX_LEVEL` 的最大日志级别常量，可以在编译时配置项目范围。使用此常量，您可以使用
    cargo 功能标志静态地设置应用程序的日志级别，这允许在编译时过滤应用程序及其所有依赖项的日志。这些级别过滤器可以在 `Cargo.toml` 中分别针对调试和发布构建设置：`max_level_<LEVEL>`（调试）和
    `release_max_level_<LEVEL>`（发布）。在二进制项目中，您可以指定对 `log` crate 的依赖项，并使用编译时日志级别如下：'
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's a good practice to set this constant to a desired value as, by default,
    the level is set to `Off`. It also allows the log macros to optimize away any
    log invocations at disabled levels. Libraries should only link to the `log` crate
    and not any logger implementation crate as binary crates should have control over
    what to log and how to log it. Using this crate solely in your application won't
    produce any log output as you need to use logging crates such as `env_logger`
    or `log4rs` along with it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将此常量设置为所需值是一个好习惯，因为默认情况下，级别设置为 `Off`。它还允许日志宏优化掉任何禁用级别的日志调用。库应仅链接到 `log` crate，而不是任何日志实现
    crate，因为二进制 crate 应该控制要记录的内容以及如何记录。仅在使用此 crate 的应用程序中，不会产生任何日志输出，因为您需要使用 `env_logger`
    或 `log4rs` 等日志 crate 与之配合使用。
- en: 'To see the `log` crate in action, we''ll build a library crate by running `cargo
    new user_auth --lib` and adding `log` as a dependency in our `Cargo.toml` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `log` crate 的实际应用，我们将通过运行 `cargo new user_auth --lib` 并在 `Cargo.toml` 文件中添加
    `log` 作为依赖项来构建一个库 crate：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This crate simulates a dummy user sign-in API. Our `lib.rs` file has a `User`
    struct, which has a method called `sign_in`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此 crate 模拟了一个虚拟的用户登录 API。我们的 `lib.rs` 文件有一个 `User` 结构体，该结构体有一个名为 `sign_in` 的方法：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `sign_in` method, we have a couple of log invocations on whether the
    sign in succeeded or failed. We'll use this library crate together with a binary
    crate thats creates a `User` instance and calls the `sign_in` method. Since depending
    on the `log` crate itself won't produce any log output, we'll use the `env_logger`
    as the logging backend for this example. Let's explore `env_logger` first.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sign_in` 方法中，我们对登录成功或失败进行了几次日志调用。我们将使用这个库 crate 与一个创建 `User` 实例并调用 `sign_in`
    方法的二进制 crate 一起使用。由于依赖于 `log` crate 本身不会产生任何日志输出，我们将使用 `env_logger` 作为此示例的日志后端。让我们首先探索
    `env_logger`。
- en: The env_logger
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: env_logger
- en: '`env_logger` is a simple logging implementation that allows you to control
    logs to `stdout` or `stderr` through the `RUST_LOG` environment variable. The
    values of this environment variable are comma-separated logger strings that correspond
    to module names and log levels. To demonstrate `env_logger`, we''ll create a new
    binary crate by running `cargo new env_logger_demo` and specifying dependencies
    for `log`, `env_logger`, and our `user_auth` library, which we created in the
    previous section. Here''s our `Cargo.toml` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`env_logger`是一个简单的记录实现，允许您通过`RUST_LOG`环境变量控制日志输出到`stdout`或`stderr`。这个环境变量的值是逗号分隔的记录器字符串，对应于模块名称和日志级别。为了演示`env_logger`，我们将通过运行`cargo
    new env_logger_demo`并指定`log`、`env_logger`和我们在上一节中创建的`user_auth`库的依赖项来创建一个新的二进制crate。以下是我们的`Cargo.toml`文件：'
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s our `main.rs` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`main.rs`文件：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We create our `User` instance and call `sign_in`, passing in our password.
    The first sign in attempt is a failed one, which will get logged as an error.
    We can run it by setting the `RUST_LOG` environment variable, followed by `cargo
    run`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建我们的`User`实例并调用`sign_in`，传入我们的密码。第一次登录尝试是失败的，这将记录为错误。我们可以通过设置`RUST_LOG`环境变量，然后执行`cargo
    run`来运行它：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We set the logs from the `user_auth` crate to `info` and the levels above it,
    while logs from our `env_logger_demo` crate are set to `debug` and above.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`user_auth`crate的日志设置为`info`及其以上级别，而来自我们的`env_logger_demo`crate的日志设置为`debug`及其以上级别。
- en: 'Running this gives us the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会给我们以下输出：
- en: '![](img/d1d12879-ec6b-44aa-8b5a-5ec66e5cd8bf.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1d12879-ec6b-44aa-8b5a-5ec66e5cd8bf.png)'
- en: The `RUST_LOG` accepts the `RUST_LOG=path::to_module=log_level[,]` pattern,
    where `path::to_module` specifies the logger and should be a path to any module
    with the crate name as the base. The `log_level` is any of the log levels that
    are defined in the log crate. `[,]` at the end indicates that we can optionally
    have as many of these logger specifications separated by a comma.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUST_LOG`接受`RUST_LOG=path::to_module=log_level[,]`模式，其中`path::to_module`指定了记录器，应该是一个以crate名称为基本路径的任何模块。`log_level`是记录crate中定义的任何日志级别。结尾的`[,]`表示我们可以有任意多个这样的记录器指定，用逗号分隔。'
- en: 'An alternative way to run the preceding program is by setting the environment
    variable within the code itself using the `set_var` method from the `env` module
    in the standard library:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面程序的另一种方法是，通过在代码本身中设置环境变量，使用标准库中的`env`模块的`set_var`方法：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This produces the same output as before. Next, let's take a look at a more complex
    and highly configurable logging crate.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生与之前相同的输出。接下来，让我们看看一个更复杂且高度可配置的记录crate。
- en: log4rs
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: log4rs
- en: The `log4rs` crate, as the name suggests, is inspired by the popular `log4j`
    library from Java. This crate is much more powerful than `env_logger` and allows
    for granular logger configuration via YAML files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`log4rs`crate受到了Java中流行的`log4j`库的启发。这个crate比`env_logger`更强大，允许通过YAML文件进行细粒度的记录器配置。
- en: We'll build two crates to demonstrate integrating logging via the `log4rs` crate.
    One will be a library crate, `cargo new my_lib --lib`, and the other will be our
    binary crate, `cargo new my_app`, which uses `my_lib`. A cargo workspace directory,
    called `log4rs_demo`, contains both of our crates.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建两个crate来演示通过`log4rs`crate集成记录。一个将是库crate，`cargo new my_lib --lib`，另一个将是我们的二进制crate，`cargo
    new my_app`，它使用`my_lib`。一个名为`log4rs_demo`的cargo工作空间目录包含这两个crate。
- en: 'Our `my_lib` crate has the following contents in the `lib.rs` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`my_lib`crate在`lib.rs`文件中有以下内容：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It has a struct called `Config` with a dummy method called `load_global_config`,
    which logs a message at the debug level. Next, our `my_app` crate contains the
    following contents in the `main.rs` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个名为`Config`的结构体，有一个名为`load_global_config`的模拟方法，在调试级别记录一条消息。接下来，我们的`my_app`crate在`main.rs`文件中有以下内容：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we initialize our `log4rs` logger via the `init_file`
    method, passing in the path to the `log4rs.yaml` config file. Next, we log a dummy
    error message, thus printing the app version. Following that, we call `load_global_config`,
    which logs another message. The following is the content of the `log4rs.yaml`
    configuration file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过`init_file`方法初始化我们的`log4rs`记录器，传入`log4rs.yaml`配置文件的路径。接下来，我们记录一个模拟的错误消息，从而打印出应用程序版本。随后，我们调用`load_global_config`，它记录了另一条消息。以下就是`log4rs.yaml`配置文件的内容：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's go through this line by line. The first line, `refresh_rate`, specifies
    the time interval after which `log4rs` reloads the configuration file to account
    for any changes that are made to this file. This means that we can modify any
    value in our YAML file and `log4rs` will dynamically reconfigure its loggers for
    us. Then, we have the `root` logger, which is the parent of all loggers. We specify
    the default level as `error` and the appender as `stdout`, which is defined below
    it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析。第一行 `refresh_rate` 指定了 `log4rs` 重新加载配置文件的时间间隔，以便对文件中进行的任何更改进行会计。这意味着我们可以修改
    YAML 文件中的任何值，`log4rs` 将会动态地为我们重新配置其日志记录器。然后，我们有 `root` 日志记录器，它是所有日志记录器的父级。我们指定默认级别为
    `error`，附加器为 `stdout`，它定义在其下方。
- en: 'Next, we have the `appenders` section. Appenders are places where logs go.
    We have specified two appenders: `stdout`, which is of `console` type, and `my_lib_append`,
    which is a `file` appender, which includes information about the path of the file
    and the log pattern to use under the `encoder` section.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `appenders` 部分。附加器是日志的去向。我们指定了两个附加器：`stdout`，它是 `console` 类型，以及 `my_lib_append`，它是一个
    `file` 附加器，在 `encoder` 部分包括有关文件路径和要使用的日志模式的详细信息。
- en: Next, there is the section of `loggers` where we can define loggers based on
    the crates or modules with different levels. We defined a logger called `my_lib`,
    which corresponds to our `my_lib` crate, with the `debug` level and appender as
    `my_lib_append`. This means that any logs from the `my_lib` crate will go to the
    `my_lib.log` file, as specified by the `my_lib_append` appender.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `日志记录器` 部分，我们可以根据不同的级别定义基于库或模块的日志记录器。我们定义了一个名为 `my_lib` 的日志记录器，它对应于我们的
    `my_lib` 库，具有 `debug` 级别和 `my_lib_append` 作为附加器。这意味着来自 `my_lib` 库的所有日志都将发送到 `my_lib.log`
    文件，这是由 `my_lib_append` 附加器指定的。
- en: 'By running `cargo run` in the `log4rs_demo` directory, we get the following
    output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `log4rs_demo` 目录下运行 `cargo run`，我们得到以下输出：
- en: '![](img/613c23dc-a436-4634-ab2e-e1cfab50130e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/613c23dc-a436-4634-ab2e-e1cfab50130e.png)'
- en: That was a brief intro to `log4rs`. If you want to explore more on configuring
    these logs, head over to the documentation page at [https://docs.rs/log4rs](https://docs.rs/log4rs).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 `log4rs` 的简要介绍。如果你想了解更多关于配置这些日志的信息，请访问文档页面 [https://docs.rs/log4rs](https://docs.rs/log4rs)。
- en: Structured logging using slog
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `slog` 进行结构化日志记录
- en: All of the aforementioned crates are quite useful and are ideal for most use
    cases, but they do not support structured logging. In this section, we'll see
    how structured logging can be integrated into our application using the `slog`
    crate, one of the few popular structured logging crates in the Rust ecosystem.
    For this demo, we'll create a new project by running `cargo new slog_demo`, which
    simulates a shooting game.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的所有库都非常有用，并且适用于大多数用例，但它们不支持结构化日志。在本节中，我们将看到如何使用 `slog` 库将结构化日志集成到我们的应用程序中，`slog`
    是 Rust 生态系统中的少数几个流行的结构化日志库之一。为此演示，我们将通过运行 `cargo new slog_demo` 创建一个新的项目，这模拟了一个射击游戏。
- en: 'We''ll need the following dependencies in our `Cargo.toml` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `Cargo.toml` 文件中添加以下依赖项：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `slog` framework is ideal for moderate to big projects where there is lot
    of interplay between modules as it helps to integrate detailed logs for the long-term
    monitoring of events. It works on the idea of providing hierarchical and composable
    logging configuration in the application and allows for semantic event logging.
    There are two important concepts under `slog` that you need to be aware of to
    successfully use the crate: *Loggers* and *Drains*. Logger objects are used to
    log events while a Drain is an abstraction specifying a place where the log messages
    go and how they get there. This can be your standard output, a file, or a network
    socket. Drains are similar to what you would call a `Sink` in the *Serilog* framework
    in C#.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`slog` 框架非常适合中等到大型的项目，在这些项目中，模块之间存在大量的交互，因为它有助于集成详细的日志，以便对事件进行长期监控。它基于提供应用中的分层和可组合的日志配置以及允许进行语义事件日志记录的理念。在
    `slog` 下有两个重要的概念，你需要了解它们才能成功使用这个库：*日志记录器* 和 *排水口*。日志记录器对象用于记录事件，而排水口是一个抽象，指定了日志消息的去向以及如何到达那里。这可以是标准输出、一个文件或一个网络套接字。排水口类似于你在
    C# 的 *Serilog* 框架中所称的 `Sink`。'
- en: Our demo simulates game events from dummy game entities based on their actions.
    The entities have a parent-child relationship in the game, where we can attach
    the hierarchical logging capability in them quite easily with `slog` framework's
    structural logging configuration. We'll get to know about this when we see the
    code. At the root level, we have the `Game` instance, for which we can define
    a root logger to provide a baseline context in our log messages, such as the game
    name and version. So, we'll create a root logger attached to the `Game` instance.
    Next, we have the `Player` and `Enemy` types, which are child entities to the
    `Game`. These become child loggers of the root logger. Then, we have weapons for
    both the enemy and the player, which become the child logger for the player and
    the enemy logger. As you can see, setting up `slog` is a bit more involved than
    the previous frameworks we looked at.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的演示模拟了基于实体行为的游戏事件。这些实体在游戏中具有父子关系，我们可以通过`slog`框架的结构化日志配置轻松地在它们中附加分层日志功能。当我们查看代码时，我们将了解这一点。在根级别，我们有`Game`实例，对于它，我们可以定义一个根日志记录器，为我们的日志消息提供一个基线上下文，例如游戏名称和版本。因此，我们将创建一个与`Game`实例关联的根日志记录器。接下来，我们有`Player`和`Enemy`类型，它们是`Game`的子实体。这些成为根日志记录器的子日志记录器。然后，我们有敌人和玩家的武器，它们成为玩家的子日志记录器和敌人的日志记录器。正如你所见，设置`slog`比我们之前查看的框架要复杂一些。
- en: 'Along with `slog` as the base crate, we''ll also use the following crates in
    our demo:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`slog`作为基本crate外，我们还在我们的演示中使用了以下crate：
- en: '`slog-async`: Provides an asynchronous logging drain that decouples logging
    calls from the main thread.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slog-async`: 提供了一个异步日志输出，将日志调用与主线程解耦。'
- en: '`slog-json`: A drain that outputs messages to any `Writer` as JSON. We''ll
    use `stdout()` as the `Writer` instance for this demo.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slog-json`: 一个将消息输出到任何`Writer`的JSON输出。在这个演示中，我们将使用`stdout()`作为`Writer`实例。'
- en: 'Let''s take a look at our `main.rs` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`main.rs`文件：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we have a bunch of `use` statements, followed by our
    `PlayingCharacter` trait, which is implemented by our `Player` and `Enemy` structs.
    Our `Game` struct has a `simulate` method, which simply loops and randomly sleeps,
    thereby selecting at random either the player or the enemy before calling the `shoot`
    method on them. Let''s continue down the same file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一系列`use`语句，然后是我们的`PlayingCharacter`特质，它由我们的`Player`和`Enemy`结构体实现。我们的`Game`结构体有一个`simulate`方法，它简单地循环并随机休眠，从而在调用`shoot`方法之前随机选择玩家或敌人。让我们继续查看同一文件：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In `main`, we first create our `drain` using `slog_json::Json`, which can log
    messages as JSON objects, followed by passing it to another drain, `Async`, which
    will offload all log invocations to a separate thread. Then, we create our `root_logger` by
    passing in our `drain` with an initial context for our log messages using the
    convenient `o!` macro. In this macro, we simply print the name and version of
    our game using the `CARGO_PKG_VERSION` environment variable. Next, our `Game` struct
    takes our root logger and `enemy` and `player` instances. To the `Player` and
    `Enemy` instances, we pass a reference to the `root_logger`, using which they
    create their child loggers. Then, we call `simulate` on our game instance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中，我们首先使用`slog_json::Json`创建我们的`drain`，它可以将消息作为JSON对象记录，然后将其传递给另一个`Async`输出，它将所有日志调用卸载到单独的线程。然后，我们通过传递我们的`drain`和用于日志消息的初始上下文使用方便的`o!`宏创建我们的`root_logger`。在这个宏中，我们简单地使用`CARGO_PKG_VERSION`环境变量打印我们游戏的名字和版本。接下来，我们的`Game`结构体接受我们的根日志记录器和`enemy`以及`player`实例。我们将根日志记录器的引用传递给`Player`和`Enemy`实例，它们使用它创建自己的子日志记录器。然后，我们在游戏实例上调用`simulate`。
- en: 'The following is the content of `player.rs`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`player.rs`的内容：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, our `new` method on `Player` gets the root `logger`, to which it adds
    its own context with the `o!` macro. We also create a logger for `weapon` and
    pass the player logger to it, which add its own information such as the ID of
    the weapon. Finally, we return our configured `Player` instance:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的`Player`上的`new`方法获取根`logger`，然后使用`o!`宏添加自己的上下文。我们还创建了一个`weapon`的日志记录器，并将玩家日志记录器传递给它，它添加了自己的信息，例如武器的ID。最后，我们返回配置好的`Player`实例：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We also implement the `PlayingCharacter` trait for our `Player`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为我们的`Player`实现了`PlayingCharacter`特质。
- en: 'Next is our `enemy.rs` file, which is identical to everything we had in `player.rs`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`enemy.rs`文件，它与`player.rs`中的所有内容相同：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we have our `weapon.rs` file, which contains two weapons that are used
    by the enemy and player instances:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`weapon.rs`文件，它包含两个被敌人和玩家实例使用的武器：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s all that is required for our game simulation. We can now run it by
    invoking `cargo run`. Here''s the output on my machine:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的游戏模拟所需的所有内容。现在我们可以通过调用`cargo run`来运行它。以下是我机器上的输出：
- en: '![](img/1f3dabf7-78a6-43d3-bd3b-3b3001aa49c4.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f3dabf7-78a6-43d3-bd3b-3b3001aa49c4.png)'
- en: As you can see, our game entities send log messages, which are then formatted
    and output as JSON with the help of `slog` and its drains. Similar to the JSON
    drain we used previously, there are many such drains that have been built by the
    community for `slog`. We can have a drain that outputs log messages directly to
    a log aggregation service, which knows how to handle JSON data and can easily
    index them for the efficient retrieval of logs. The pluggable and composable nature
    of `slog` makes it stand out from other logging solutions. With this demo, we
    have come to the end of the logging story in Rust. However, there are other more
    interesting logging frameworks for you to explore, and you can find them at [http://www.arewewebyet.org/topics/logging/](http://www.arewewebyet.org/topics/logging/).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的游戏实体发送日志消息，然后借助`slog`及其drains进行格式化并输出为JSON。与之前使用的JSON drain类似，社区为`slog`构建了许多这样的drains。我们可以有一个将日志消息直接输出到日志聚合服务的drain，该服务知道如何处理JSON数据，并且可以轻松地对它们进行索引，以便高效地检索日志。`slog`的可插拔和可组合特性使其在日志解决方案中脱颖而出。通过这个演示，我们已经到达了Rust中日志记录故事的结尾。然而，还有其他更多有趣的日志框架供您探索，您可以在[http://www.arewewebyet.org/topics/logging/](http://www.arewewebyet.org/topics/logging/)找到它们。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the importance of logging in software development
    and the ways of approaching it, including what characteristics to look for when
    choosing a logging framework. We also got to know about unstructured and structured
    logging, their pros and cons, and explored the available crates in the Rust ecosystem
    to integrate logging into our applications.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在软件开发中日志记录的重要性以及接近它的方法，包括在选择日志框架时应该寻找哪些特性。我们还了解了非结构化和结构化日志，它们的优缺点，并探讨了Rust生态系统中的可用crate，以将日志集成到我们的应用程序中。
- en: The next chapter will be about network programming, where we will explore the
    built-in facilities and crates that Rust provides to create efficient applications
    that communicate with one another.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍网络编程，我们将探讨Rust提供的内置功能和crate，以创建能够相互通信的高效应用程序。
