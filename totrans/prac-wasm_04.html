<html><head></head><body>
		<div><h1 id="_idParaDest-35"><em class="italic"><a id="_idTextAnchor041"/>Chapter 3</em>:Exploring WebAssembly Modules</h1>
			<p>WebAssembly is a low-level assembly-like code that is designed for efficient execution and compact representation. WebAssembly runs at a near-native speed in all JavaScript engines (including modern desktop and mobile browsers and Node.js). Compact representation of the binary enables the generated binary to be as small as possible in size. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The main goal of WebAssembly is to enable high-performance applications.</p>
			<p>Each WebAssembly <a id="_idIndexMarker098"/>file is an efficient, optimal, and self-sufficient module called a <strong class="bold">WebAssembly module</strong> (<strong class="bold">WASM</strong>). WASM is safe, that is, the binary runs in a memory-safe and sandboxed environment. WASM does not have permission to access anything outside of that sandbox. WASM is language-, hardware-, and platform-independent. </p>
			<p>WebAssembly <a id="_idIndexMarker099"/>is a virtual <strong class="bold">instruction set architecture</strong> (<strong class="bold">ISA</strong>). The <a id="_idIndexMarker100"/>WebAssembly specifications define the following:  </p>
			<ul>
				<li>Instruction set</li>
				<li>Binary encoding </li>
				<li>Validation </li>
				<li>Execution semantics</li>
			</ul>
			<p>The WebAssembly specification also defines a textual representation of the WebAssembly binary.</p>
			<p>In this chapter, we will explore WASM and how a JavaScript engine executes WASM. We then explore the WebAssembly text format and why it is useful. Understanding WASM execution and the WebAssembly text format will enable us to easily understand the module and debug it in the JavaScript engine. We will cover the following main topics in this chapter:</p>
			<ul>
				<li>Understanding how WebAssembly works</li>
				<li>Exploring the WebAssembly text format</li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor042"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor043"/>Understanding how WebAssembly works</h1>
			<p>Let's first <a id="_idIndexMarker101"/>explore how JavaScript and WebAssembly are executed inside the JavaScript engine.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor044"/>Understanding JavaScript execution inside the JavaScript engine</h2>
			<p>The JavaScript <a id="_idIndexMarker102"/>engine first fetches the complete <a id="_idIndexMarker103"/>JavaScript file (note that the engine has to wait until the entire file is downloaded/loaded).</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The bigger the JavaScript file, the longer it takes to load. It doesn't matter how fast your JavaScript engine is or how efficient your code is. If your JavaScript file is huge (that is, greater than 170 KB), then your application is going to be slow at loading time.</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_3.1_B14844.jpg" alt="Figure 3.1 – JavaScript execution inside the JavaScript engine&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – JavaScript execution inside the JavaScript engine</p>
			<p>Once loaded, the JavaScript is <a id="_idIndexMarker104"/>parsed into <strong class="bold">abstract syntax trees</strong> (<strong class="bold">ASTs</strong>). This phase <a id="_idIndexMarker105"/>is called <strong class="bold">parse</strong>. Since JavaScript is both an interpreted and compiled language, the JavaScript engine kickstarts the execution after parsing. The interpreter executes the code faster but it compiles the code every time. This phase <a id="_idIndexMarker106"/>is called <strong class="bold">interpret</strong>.</p>
			<p>The JavaScript <a id="_idIndexMarker107"/>engine has <strong class="bold">watchers</strong> (called <strong class="bold">profilers</strong> in some browsers). Watchers keep <a id="_idIndexMarker108"/>track of code execution. If a particular block of code is executed frequently, then the watcher marks it as hot code. The engine compiles the block <a id="_idIndexMarker109"/>of code using the <strong class="bold">just-in-time</strong> (<strong class="bold">JIT</strong>) compiler. The engine spends some time doing the compilation, say in the order of nanoseconds. The time spent here is worth it, because the next time the function is called, the execution happens much faster, because the compiled version is always faster than the <a id="_idIndexMarker110"/>interpreted one. This phase is called <strong class="bold">optimize</strong>.</p>
			<p>JavaScript engines add one (or two) more layers of optimization. The watchers continue watching the code execution. The watchers then name the code that is called more often <em class="italic">very hot code</em>. The engine optimizes this code further. This optimization takes a long time (consider something like <code>-O3</code>-level optimization). This phase produces highly optimized code that runs super fast. This code is much faster than the previously optimized code and the interpreted version. Obviously, the engine spends more time during this phase, say in the order of milliseconds. This is compensated by the code performance and frequency of execution.</p>
			<p>JavaScript is a <a id="_idIndexMarker111"/>dynamically typed language and all the <a id="_idIndexMarker112"/>optimizations the engine can do are based on the assumption of <em class="italic">types</em>. If the assumption breaks, then the code is interpreted and executed, and the optimized code gets removed rather than throwing a runtime exception. The JavaScript engine implements the necessary type checks and bails out the optimized code when the assumed type changes. But the time spent on the optimize phase is in vain.</p>
			<p>We can prevent these <em class="italic">type</em>-related issues by <a id="_idIndexMarker113"/>using something such as <strong class="bold">TypeScript</strong>. TypeScript is a superset of JavaScript. With TypeScript, we can prevent polymorphic code (code that accepts different types). In the JavaScript engine, monomorphic code (code that accepts only one type) always runs faster than its polymorphic counterpart. </p>
			<p>There is no use in having highly optimized monomorphic JavaScript code if the JavaScript files are huge in size. The JavaScript engine has to wait until the entire file is downloaded. With a poor connection, that takes forever to happen.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">It is important to split the JavaScript bundle into smaller chunks. Including the JavaScript asynchronously (or in other words, lazy loading) boosts the performance of your application. We need to strike a correct balance and know which JavaScript module/file to load, cache, and then revalidate. Larger file sizes (payloads) will degrade the performance of the application greatly.</p>
			<p>The final step is <strong class="bold">garbage collection</strong>, where all the live objects in the memory are removed. The garbage <a id="_idIndexMarker114"/>collection in the JavaScript engine works on the basis of reference. During the garbage collection cycle, the JavaScript engine starts <a id="_idIndexMarker115"/>from the root object (something like global in Node.js). It finds all the objects referenced from the root object and marks <a id="_idIndexMarker116"/>them as reachable objects. It marks the remaining objects as unreachable objects. Finally, it sweeps the unreachable objects. Since it is automatically done by the JavaScript engine, the garbage collection process is not efficient and it is much slower. </p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor045"/>Understanding WebAssembly execution inside the JavaScript engine</h2>
			<p>WASM is <a id="_idIndexMarker117"/>in binary format and is already <a id="_idIndexMarker118"/>compiled and optimized. The JavaScript engine fetches the WASM. Then, it decodes the WASM and converts it into the module's internal representation (that is, AST). This phase is called <strong class="bold">decode</strong>. The decode <a id="_idIndexMarker119"/>phase is much <a id="_idIndexMarker120"/>faster than JavaScript's <strong class="bold">parse</strong> phase.</p>
			<div><div><img src="img/Figure_3.2_B14844.jpg" alt="Figure 3.2 – WebAssembly execution inside the JavaScript engine&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – WebAssembly execution inside the JavaScript engine</p>
			<p>Next, the decoded WASM <a id="_idIndexMarker121"/>enters the <strong class="bold">compile</strong> phase. During this phase, the module is validated, and during the validation, the code is checked for certain conditions to guarantee the module is safe and does not have any harmful code. The functions, instruction sequences, and the usage of stacks are type-checked during the validation process. The validated code is then compiled to machine-executable code. Since the WASM is <a id="_idIndexMarker122"/>already compiled and optimized, this <a id="_idIndexMarker123"/>compile phase is faster. During this phase, the WASM is converted into machine code.</p>
			<p>The compiled code <a id="_idIndexMarker124"/>then enters the <strong class="bold">execute</strong> phase. In the execute phase, the module is instantiated and invoked. During the instantiation, the engine instantiates the state and the execution stack (memory where it stores all the information related to the program) and then executes the module. </p>
			<p>The other advantage of WebAssembly is that the module is ready to compile and instantiate right from the first byte. Thus, the JavaScript engine need not wait until the entire module is downloaded. This further increases WebAssembly's performance. WebAssembly is fast because its execution has fewer steps than JavaScript execution, so the binary is already optimized and compiled, and the binary can be streaming compiled.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">WASM does not always provide high performance. There are scenarios in which JavaScript performs better. So, it is necessary to understand that and think before using WebAssembly.</p>
			<p>Find out more <a id="_idIndexMarker125"/>about JavaScript performance and how load time is involved at <a href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4">https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4</a>.</p>
			<p>Find out <a id="_idIndexMarker126"/>more about chunking and code splitting in webpack at <a href="https://webpack.js.org/guides/code-splitting/">https://webpack.js.org/guides/code-splitting/</a>.</p>
			<p>We have seen how WebAssembly works inside the browser; now, let's explore the WebAssembly text format. </p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor046"/>Exploring the WebAssembly text format</h1>
			<p>Machines understand a bunch of 1s and 0s. We optimize the binary to make it run faster and more efficiently. The more concise and optimal the instructions are, the more efficient and <a id="_idIndexMarker127"/>performant the machine will be. But for people, it is difficult to contextually analyze and understand a huge blob of 1s and 0s. That is the very reason why we started abstracting and creating high-level programming languages.</p>
			<p>In the WebAssembly world, we convert human-readable programming languages, such as Rust, Go, and C/C++, into binary code. These binaries are a bunch of instructions with opcodes and operands. These instructions make the machine highly efficient but contextually make it difficult for us to understand.</p>
			<p>Why should we worry about the readability of the binary generated? Because it helps us to understand the code, which helps while debugging the code.</p>
			<p>WebAssembly provides <a id="_idTextAnchor047"/>the WebA<a id="_idTextAnchor048"/>ssembly text format, WAST or WAT. WAST is a human-readable format of the WebAssembly binary. The JavaScript engine (both in the browser and Node.js), when loading the WebAssembly file, can convert the binary into WebAssembly text format. This helps in understanding what is in the code and debugging. Text editors can show the binary in WebAssembly text format, which is much more readable than its binary counterpart.</p>
			<p>Basic WASM in binary format is as follows:</p>
			<pre>00 61 73 6d 01 00 00 00</pre>
			<p>This translates to the following:</p>
			<pre> 00 61 73 6d 01 00 00 00
\0  a  s  m  1  0  0  0 (ascii value of the character)
|         |  |
---------  version
    |
Magic Header</pre>
			<p>This basic module has a magic header (<code>\0asm</code>) followed by the version of WebAssembly (<code>01</code>).</p>
			<p>The textual format <a id="_idIndexMarker128"/>is written in an <code>()</code>. S-expressions are commonly used when defining a nested list or structured tree. Many research papers on tree-based data structures use this notation to showcase their code. The s-expression removes all the unnecessary ceremony from XML, providing a concise format.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Does this expression (defining everything within parentheses) look familiar? Have you ever worked with LISP (or the languages that are built inspired by LISP)? </p>
			<p>Modules are <a id="_idIndexMarker129"/>the basic building blocks in WASM. A textual representation of basic WASM is as follows:</p>
			<pre>(module ) </pre>
			<p>WASM is made up of a header and zero or more sections. The header starts with a magic header and the version of WASM. Following the header, the WASM may have zero or <a id="_idIndexMarker130"/>more of the following sections:</p>
			<ul>
				<li>Types</li>
				<li>Functions</li>
				<li>Tables</li>
				<li>Memories</li>
				<li>Globals</li>
				<li>Element</li>
				<li>Data</li>
				<li>Start function</li>
				<li>Exports</li>
				<li>Imports</li>
			</ul>
			<p>All these <a id="_idIndexMarker131"/>sections are optional in WASM. The structure of WASM looks as follows:</p>
			<pre> module ::= {
    types vec&lt;funcType&gt;,
    funcs vec&lt;func&gt;,
    tables vec&lt;table&gt;,
    mems vec&lt;mem&gt;,
    globals vec&lt;global&gt;,
    elem vec&lt;elem&gt;,
    data vec&lt;data&gt;,
    start start,
    imports vec&lt;import&gt;,
    exports vec&lt;export&gt;
 } </pre>
			<p>Every section <a id="_idIndexMarker132"/>inside the WASM is a vector (array) that contains zero or more values of the respective types, except for <code>start</code>. We will explore the <code>start</code> section later in the book. For now, <code>start</code> holds an index that references a function in the <code>funcs</code> section.</p>
			<p>Every section in the WASM takes the following format:</p>
			<pre>&lt;section id&gt;&lt;u32 section size&gt;&lt;Actual content of the section&gt; </pre>
			<p>The first byte refers to a unique section ID. Every section has a unique section ID. Next to the unique <a id="_idIndexMarker133"/>section ID is an <strong class="bold">unsigned 32-bit</strong> (<strong class="bold">u32</strong>) integer that defines the section's size in bytes. The remaining bytes are the section content.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Since the section size is defined by a u32 integer, the maximum size of the section is limited to approximately 4.2 GB of memory (that is, 2^32 - 1).   </p>
			<p>In the WebAssembly text format, we use the name of the section to represent each segment in the section.</p>
			<p>For example, the function <a id="_idIndexMarker134"/>section contains a list of functions. A sample function definition in WebAssembly text format is as follows:</p>
			<pre> (func &lt;name&gt;? &lt;func_type&gt; &lt;local&gt;* &lt;inst&gt;* )</pre>
			<p>As with other expressions, everything that we define goes within parentheses, <code>()</code>. First, we define the function <a id="_idIndexMarker135"/>block with a <code>func</code> keyword. Following the <code>func</code> keyword, we add the name of the function. The function name is optional here because in binary, the function is identified by the index of the function block inside the function section.</p>
			<p>The name is followed by <code>func_type</code>. <code>func_type</code> is referred <a id="_idIndexMarker136"/>to as <code>type_use</code> in the spec. <code>type_use</code> here refers <a id="_idIndexMarker137"/>to the type definition. <code>func_type</code> holds all the input parameters (along with their types) and the return type of the function. So, for an <code>add</code> function, which takes two input operands and returns the result, <code>func_type</code> will look like this:</p>
			<pre>(param $lhs i32) (param $rhs i32) (result i32) </pre>
			<p class="callout-heading">Note </p>
			<p class="callout">The type is either <code>i32</code>, <code>i64</code>, <code>f32</code>, or <code>f64</code> (32-bit and 64-bit integer or float). The type information might change in the future, when WebAssembly adds support for more types.</p>
			<p>The <code>param</code> keyword denotes <a id="_idIndexMarker138"/>the defined expression holds a parameter. <code>$lhs</code> is the variable name. Note that all variables defined in the WebAssembly text format will have <code>$</code> as a prefix. Following that, we have the type of the parameter, <code>i32</code>. Similarly, we have defined another expression for the second operand, <code>$rhs</code>. Finally, the return type is mentioned as <code>(result i32)</code>. The <code>result</code> keyword denotes that the expression is a return type, followed by the type, <code>i32</code>.</p>
			<p>Following <code>func_type</code>, we define any local variables that we will use inside the function. Finally, we have a list of instructions/operations.</p>
			<p>Let's define an <code>add</code> function with the preceding code snippets as a reference:</p>
			<pre> (func $add (param $lhs i32) (param $rhs i32) (result i32)
    get_local $lhs
    get_local $rhs
    i32.add) </pre>
			<p>The entire block is <a id="_idIndexMarker139"/>wrapped inside the parentheses. The function block starts with a <code>func</code> keyword. Then, we have an optional name (<code>$add</code>) for the function. The WebAssembly binary module will use the function index inside the function section to identify the function rather than a name. Then, we define the operand and return type.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">In binary format, the parameters and results are defined via the <code>type</code> section as that helps to optimize the generated functions. But in the text format, for brevity and ease of understanding, the type information will be shown in every function definition.</p>
			<p>Then, we have a list of instructions. The first instruction, <code>get_local</code>, gets the local value of (from the heap) <code>$lhs</code>. Then, we fetch the local value of <code>$rhs</code>. After that, we add them both using the <code>i32.add</code> instruction. Finally, the closing parenthesis finishes things off.</p>
			<p>There is no separate <code>return</code> statement/expression. So, how does the function know what to return?</p>
			<p>As we have seen before, WebAssembly is a stack machine. When a function is called, it creates an empty stack for it. The function then uses this stack to push and pop data. So, when the <code>get_local</code> instruction is executed, it pushes the value into the stack. After the two <code>get_local</code> calls, the stack will have <code>$lhs</code> and <code>$rhs</code> in the stack. Finally, <code>i32.add</code> will pop two values from the stack, do the <code>add</code> operation, and push the element. When the function is ended, the top of the stack will be taken out and provided to the function caller.</p>
			<p>If we want to export this function to the outside world, then we can add an <code>export</code> block:</p>
			<pre> (export &lt;export_name&gt; (func &lt;function_reference&gt;))</pre>
			<p>The <code>export</code> block is defined inside <code>()</code>. The <code>export</code> block starts with an <code>export</code> keyword. The <code>export</code> keyword is <a id="_idIndexMarker140"/>followed by the name of the function. Following the name, we refer to the function. The function block consists of the following <code>func</code> keyword. Then, we have <code>function_reference</code>, which refers to the name of the function defined/imported inside the module.</p>
			<p>In order to export the <code>add</code> function, we define the following:</p>
			<pre> (export "add" (func $add)) </pre>
			<p><code>"add"</code> refers to the name with which the function is exported outside the module, followed by <code>(func $add)</code>, referring to the function.</p>
			<p>Both the function <a id="_idIndexMarker141"/>and <code>export</code> sections should be wrapped inside a <code>module</code> section, to make it valid WASM:</p>
			<pre>(module
    (func $add (param $lhs i32) (param $rhs i32) 
      (result i32)
        get_local $lhs
        get_local $rhs
        i32.add)
    (export "add" (func $add))
) </pre>
			<p>The preceding is valid WASM. Imagine it as a tree structure with the module as its root and both the function and export as its children.</p>
			<p>We have seen how to create a simple function in WebAssembly text format. Now, let's define a complex function in WebAssembly text format.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor049"/>Building a function in WebAssembly text format </h2>
			<p>For this, we <a id="_idIndexMarker142"/>will use a recursive <a id="_idIndexMarker143"/>Fibonacci series generator. The Fibonacci function that we will be writing will be of the following format:</p>
			<pre> # Sample code in C for reference
int fib(n) {
    if (n &lt;= 1)
        return 1;
    else
        return fib(n-1)+ fib(n-2);
} </pre>
			<p>Let's first define the function signature for the given <code>fib</code> function using WebAssembly text format. The <code>fib</code> function, similar to its C counterpart, takes in a number parameter and returns a number. So, the function definition follows the same signature in the WebAssembly text format:</p>
			<pre> (func $fib (param $n i32) (result i32)
    ...
)</pre>
			<p>We define the function inside parentheses, <code>()</code>. The function starts with a <code>func</code> keyword. Following the keyword, we add the function name, <code>$fib</code>. Then, we add the parameter to the function; in our case, the function has only one parameter, <code>n</code>; we define it as <code>(param $n i32)</code>. Then, the function returns a number, <code>(result i32)</code>.</p>
			<p>WebAssembly does not have in-memory to handle temporary variables. In order to have local values, we should push the value into the stack and then retrieve it. So, to check <code>n&lt;=1</code>, we have to first create a local variable and store <code>1</code> inside it, and then do the check. To define a local variable, we use the <code>local</code> block. The <code>local</code> block starts with a <code>local</code> keyword. This keyword is followed by the name of the variable. After the variable name, we define the type of the variable:</p>
			<pre> (local &lt;name&gt; &lt;type&gt;)</pre>
			<p>Let's create a <code>local</code> variable called <code>$tmp</code>:</p>
			<pre> (local $tmp i32) </pre>
			<p class="callout-heading">Note</p>
			<p class="callout"> <code>(local $tmp i32)</code> is not an instruction. It is part of the function declaration. Remember, the preceding function syntax includes <code>local</code>.</p>
			<p>We then <a id="_idIndexMarker144"/>have to set the value of <code>$tmp</code> to <code>1</code>. To set the value, we first have to push the value <code>1</code> into the stack, after <a id="_idIndexMarker145"/>which we have to pop the value from the stack and set it to <code>$tmp</code>:</p>
			<pre>i32.const 1
set_local $tmp </pre>
			<p><code>i32.const</code> creates an <code>i32</code> constant value and pushes that into the stack. So, here, we create a constant with a value of <code>1</code> and push that into the stack.</p>
			<p>Then, we set the value in <code>$tmp</code> using <code>set_local</code>. <code>set_local</code> takes the topmost value from the stack, in our case, 1, and assigns the value of <code>$tmp</code> to <code>1</code>.</p>
			<p>Now, we have to check whether the given parameter is less than 2. WebAssembly provides <code>i32.&lt;some_action&gt;</code> to do some action on <code>i32</code>. For example, to add two numbers, we have used <code>i32.add</code>. Similarly, to check whether it's less than a particular value, we have <code>i32.lt_s</code>. <code>_s</code> here denotes that we are checking for a signed number.</p>
			<p><code>i32.lt_s</code> expects two operands. For the first operand (that is, <code>$n</code>), we use the <code>get_local</code> expression to fetch the value from <code>$n</code> and put it at the top of the stack. Then, we create a constant of <code>2</code> using <code>i32.const 2</code> and add <code>2</code> to the stack. Finally, we compare the <code>$n</code> value with <code>2</code> using <code>i32.lt_s</code>:</p>
			<pre>get_local $n
i32.const 2
i32.lt_s</pre>
			<p>But how do we define the <em class="italic">if condition</em>? WebAssembly provides <code>br_if</code> and <code>block</code>.</p>
			<p>In WebAssembly text format, a block is defined with a <code>block</code> keyword followed by a name to identify the block. We end the block using <code>end</code>. The block looks as follows:</p>
			<pre>block $block
... ; some code goes in here.
end</pre>
			<p>We will <a id="_idIndexMarker146"/>provide this block to <code>br_if</code>. <code>br_if</code> calls the block if the condition succeeds:</p>
			<pre>get_local $n
i32.const 2
i32.lt_s
br_if $block ; calls the $block` only when the condition
  succeeds.</pre>
			<p>The <a id="_idIndexMarker147"/>WebAssembly text format so far will look like this:</p>
			<pre> (module
  (func $fib (param $n i32) (result i32) (local $tmp i32)
    i32.const 1
    set_local $tmp
    ; block
    block $block
      ; if condition
      get_local $n
      i32.const 2
      i32.lt_s
      br_if $block
    ... ; some code
    end
    ; return value
    get_local $tmp
  )
) </pre>
			<p>Everything <a id="_idIndexMarker148"/>is wrapped inside <code>module</code>. At the <a id="_idIndexMarker149"/>end of <code>$block</code>, the value will be stored in <code>$tmp</code>. We get the value of <code>$tmp</code> using <code>get_local $tmp</code>. The only thing that is left to do is to create the loop.</p>
			<h3>Loop time</h3>
			<p>First, we set <code>$tmp</code> to <code>1</code>:</p>
			<pre>i32.const 1
set_local $tmp </pre>
			<p>Then, we will <a id="_idIndexMarker150"/>create a loop. To create a loop, the WebAssembly text format uses the <code>loop</code> keyword:</p>
			<pre>loop $loop
end </pre>
			<p>The <code>loop</code> keyword is <a id="_idIndexMarker151"/>followed by the name of the loop. The loop ends with the <code>end</code> keyword. <code>loop</code> is a special block that will run until we exit using some conditional expression such as <code>br_if</code>:</p>
			<pre>get_local $n
i32.const -2
i32.add
call $fib
get_local $tmp
i32.add
set_local $tmp
get_local $n
i32.const -1
i32.add
tee_local $n
i32.const 1
i32.gt_s
br_if $loop</pre>
			<p>We get <code>$n</code> and add <code>-2</code> to it, and then call the <code>fib</code> function. To call a function, we use the <code>call</code> keyword followed by the name of the function. Here, <code>call $fib</code> returns the value and <a id="_idIndexMarker152"/>pushes the value into the stack.</p>
			<p>Now, get <code>$tmp</code> using <code>get_local $tmp</code>. This pushes <code>$tmp</code> to the stack. Then, we use <code>i32.add</code> to pop two values from the stack and add them. Finally, we set <code>$tmp</code> using <code>set_local $tmp</code>. <code>set_local $tmp</code> takes the topmost value from the stack and assigns it to <code>$tmp</code>. We get <code>$n</code> and add <code>-1</code> to it.</p>
			<p>We use <code>tee_local</code> here because <code>tee_local</code> is similar to <code>set_local</code> but instead of pushing the value into the stack, it returns the value. Finally, we run the loop until <code>$n</code> is greater than 1. If it is less than 1, we break the loop using <code>br_if $loop</code>. The complete WebAssembly text format will look like this:</p>
			<pre>(module
  (func (export $fib (param $n i32) (result i32) 
    (local $tmp i32)
    i32.const 1
    set_local $tmp
    ; block
    block $block
      ; if condition
      get_local $n
      i32.const 2
      i32.lt_s
      br_if $block
      ; loop
      loop $loop
        get_local $n
        i32.const -2
        i32.add
        call $fib
        get_local $tmp
        i32.add
        set_local $tmp
        get_local $n
        i32.const -1
        i32.add
        tee_local $n
        i32.const 1
        i32.gt_s
        br_if $loop
      end
    end
    ; return value
    get_local $tmp
  )
)</pre>
			<p>In future <a id="_idIndexMarker153"/>chapters, we will see how we can convert this WebAssembly text format into WASM and execute it.</p>
			<p>If you're interested <a id="_idIndexMarker154"/>in learning more about s-expressions, check out <a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a>.</p>
			<p>To find out <a id="_idIndexMarker155"/>more about the WebAssembly text format design, check out the specifications at <a href="https://github.com/WebAssembly/design/blob/master/Semantics.md">https://github.com/WebAssembly/design/blob/master/Semantics.md</a>.</p>
			<p>Check out more text instructions at <a href="https://webassembly.github.io/spec/core/text/instructions.html">https://webassembly.github.io/spec/core/text/instructions.html</a>.</p>
			<p>Refer to various instructions and their opcode at <a href="https://webassembly.github.io/spec/core/binary/instructions.html">https://webassembly.github.io/spec/core/binary/instructions.html</a>.</p>
			<p>Find out more about binary encoding at <a href="https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md">https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md</a>.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor050"/>Summary</h1>
			<p>In this chapter, we have seen how WebAssembly is executed inside the JavaScript engine and explored what WebAssembly text format is and how to define WASM using WebAssembly text format. In the next chapter, we will explore the WebAssembly Binary Toolkit.</p>
		</div>
	</body></html>