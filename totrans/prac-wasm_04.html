<html><head></head><body>
		<div id="_idContainer013">
			<h1 id="_idParaDest-35"><em class="italic"><a id="_idTextAnchor041"/>Chapter 3</em>:Exploring WebAssembly Modules</h1>
			<p>WebAssembly is a low-level assembly-like code that is designed for efficient execution and compact representation. WebAssembly runs at a near-native speed in all JavaScript engines (including modern desktop and mobile browsers and Node.js). Compact representation of the binary enables the generated binary to be as small as possible in size. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The main goal of WebAssembly is to enable high-performance applications.</p>
			<p>Each WebAssembly <a id="_idIndexMarker098"/>file is an efficient, optimal, and self-sufficient module called a <strong class="bold">WebAssembly module</strong> (<strong class="bold">WASM</strong>). WASM is safe, that is, the binary runs in a memory-safe and sandboxed environment. WASM does not have permission to access anything outside of that sandbox. WASM is language-, hardware-, and platform-independent. </p>
			<p>WebAssembly <a id="_idIndexMarker099"/>is a virtual <strong class="bold">instruction set architecture</strong> (<strong class="bold">ISA</strong>). The <a id="_idIndexMarker100"/>WebAssembly specifications define the following:  </p>
			<ul>
				<li>Instruction set</li>
				<li>Binary encoding </li>
				<li>Validation </li>
				<li>Execution semantics</li>
			</ul>
			<p>The WebAssembly specification also defines a textual representation of the WebAssembly binary.</p>
			<p>In this chapter, we will explore WASM and how a JavaScript engine executes WASM. We then explore the WebAssembly text format and why it is useful. Understanding WASM execution and the WebAssembly text format will enable us to easily understand the module and debug it in the JavaScript engine. We will cover the following main topics in this chapter:</p>
			<ul>
				<li>Understanding how WebAssembly works</li>
				<li>Exploring the WebAssembly text format</li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor042"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor043"/>Understanding how WebAssembly works</h1>
			<p>Let's first <a id="_idIndexMarker101"/>explore how JavaScript and WebAssembly are executed inside the JavaScript engine.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor044"/>Understanding JavaScript execution inside the JavaScript engine</h2>
			<p>The JavaScript <a id="_idIndexMarker102"/>engine first fetches the complete <a id="_idIndexMarker103"/>JavaScript file (note that the engine has to wait until the entire file is downloaded/loaded).</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The bigger the JavaScript file, the longer it takes to load. It doesn't matter how fast your JavaScript engine is or how efficient your code is. If your JavaScript file is huge (that is, greater than 170 KB), then your application is going to be slow at loading time.</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_3.1_B14844.jpg" alt="Figure 3.1 – JavaScript execution inside the JavaScript engine&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – JavaScript execution inside the JavaScript engine</p>
			<p>Once loaded, the JavaScript is <a id="_idIndexMarker104"/>parsed into <strong class="bold">abstract syntax trees</strong> (<strong class="bold">ASTs</strong>). This phase <a id="_idIndexMarker105"/>is called <strong class="bold">parse</strong>. Since JavaScript is both an interpreted and compiled language, the JavaScript engine kickstarts the execution after parsing. The interpreter executes the code faster but it compiles the code every time. This phase <a id="_idIndexMarker106"/>is called <strong class="bold">interpret</strong>.</p>
			<p>The JavaScript <a id="_idIndexMarker107"/>engine has <strong class="bold">watchers</strong> (called <strong class="bold">profilers</strong> in some browsers). Watchers keep <a id="_idIndexMarker108"/>track of code execution. If a particular block of code is executed frequently, then the watcher marks it as hot code. The engine compiles the block <a id="_idIndexMarker109"/>of code using the <strong class="bold">just-in-time</strong> (<strong class="bold">JIT</strong>) compiler. The engine spends some time doing the compilation, say in the order of nanoseconds. The time spent here is worth it, because the next time the function is called, the execution happens much faster, because the compiled version is always faster than the <a id="_idIndexMarker110"/>interpreted one. This phase is called <strong class="bold">optimize</strong>.</p>
			<p>JavaScript engines add one (or two) more layers of optimization. The watchers continue watching the code execution. The watchers then name the code that is called more often <em class="italic">very hot code</em>. The engine optimizes this code further. This optimization takes a long time (consider something like <strong class="source-inline">-O3</strong>-level optimization). This phase produces highly optimized code that runs super fast. This code is much faster than the previously optimized code and the interpreted version. Obviously, the engine spends more time during this phase, say in the order of milliseconds. This is compensated by the code performance and frequency of execution.</p>
			<p>JavaScript is a <a id="_idIndexMarker111"/>dynamically typed language and all the <a id="_idIndexMarker112"/>optimizations the engine can do are based on the assumption of <em class="italic">types</em>. If the assumption breaks, then the code is interpreted and executed, and the optimized code gets removed rather than throwing a runtime exception. The JavaScript engine implements the necessary type checks and bails out the optimized code when the assumed type changes. But the time spent on the optimize phase is in vain.</p>
			<p>We can prevent these <em class="italic">type</em>-related issues by <a id="_idIndexMarker113"/>using something such as <strong class="bold">TypeScript</strong>. TypeScript is a superset of JavaScript. With TypeScript, we can prevent polymorphic code (code that accepts different types). In the JavaScript engine, monomorphic code (code that accepts only one type) always runs faster than its polymorphic counterpart. </p>
			<p>There is no use in having highly optimized monomorphic JavaScript code if the JavaScript files are huge in size. The JavaScript engine has to wait until the entire file is downloaded. With a poor connection, that takes forever to happen.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">It is important to split the JavaScript bundle into smaller chunks. Including the JavaScript asynchronously (or in other words, lazy loading) boosts the performance of your application. We need to strike a correct balance and know which JavaScript module/file to load, cache, and then revalidate. Larger file sizes (payloads) will degrade the performance of the application greatly.</p>
			<p>The final step is <strong class="bold">garbage collection</strong>, where all the live objects in the memory are removed. The garbage <a id="_idIndexMarker114"/>collection in the JavaScript engine works on the basis of reference. During the garbage collection cycle, the JavaScript engine starts <a id="_idIndexMarker115"/>from the root object (something like global in Node.js). It finds all the objects referenced from the root object and marks <a id="_idIndexMarker116"/>them as reachable objects. It marks the remaining objects as unreachable objects. Finally, it sweeps the unreachable objects. Since it is automatically done by the JavaScript engine, the garbage collection process is not efficient and it is much slower. </p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor045"/>Understanding WebAssembly execution inside the JavaScript engine</h2>
			<p>WASM is <a id="_idIndexMarker117"/>in binary format and is already <a id="_idIndexMarker118"/>compiled and optimized. The JavaScript engine fetches the WASM. Then, it decodes the WASM and converts it into the module's internal representation (that is, AST). This phase is called <strong class="bold">decode</strong>. The decode <a id="_idIndexMarker119"/>phase is much <a id="_idIndexMarker120"/>faster than JavaScript's <strong class="bold">parse</strong> phase.</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_3.2_B14844.jpg" alt="Figure 3.2 – WebAssembly execution inside the JavaScript engine&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – WebAssembly execution inside the JavaScript engine</p>
			<p>Next, the decoded WASM <a id="_idIndexMarker121"/>enters the <strong class="bold">compile</strong> phase. During this phase, the module is validated, and during the validation, the code is checked for certain conditions to guarantee the module is safe and does not have any harmful code. The functions, instruction sequences, and the usage of stacks are type-checked during the validation process. The validated code is then compiled to machine-executable code. Since the WASM is <a id="_idIndexMarker122"/>already compiled and optimized, this <a id="_idIndexMarker123"/>compile phase is faster. During this phase, the WASM is converted into machine code.</p>
			<p>The compiled code <a id="_idIndexMarker124"/>then enters the <strong class="bold">execute</strong> phase. In the execute phase, the module is instantiated and invoked. During the instantiation, the engine instantiates the state and the execution stack (memory where it stores all the information related to the program) and then executes the module. </p>
			<p>The other advantage of WebAssembly is that the module is ready to compile and instantiate right from the first byte. Thus, the JavaScript engine need not wait until the entire module is downloaded. This further increases WebAssembly's performance. WebAssembly is fast because its execution has fewer steps than JavaScript execution, so the binary is already optimized and compiled, and the binary can be streaming compiled.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">WASM does not always provide high performance. There are scenarios in which JavaScript performs better. So, it is necessary to understand that and think before using WebAssembly.</p>
			<p>Find out more <a id="_idIndexMarker125"/>about JavaScript performance and how load time is involved at <a href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4">https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4</a>.</p>
			<p>Find out <a id="_idIndexMarker126"/>more about chunking and code splitting in webpack at <a href="https://webpack.js.org/guides/code-splitting/">https://webpack.js.org/guides/code-splitting/</a>.</p>
			<p>We have seen how WebAssembly works inside the browser; now, let's explore the WebAssembly text format. </p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor046"/>Exploring the WebAssembly text format</h1>
			<p>Machines understand a bunch of 1s and 0s. We optimize the binary to make it run faster and more efficiently. The more concise and optimal the instructions are, the more efficient and <a id="_idIndexMarker127"/>performant the machine will be. But for people, it is difficult to contextually analyze and understand a huge blob of 1s and 0s. That is the very reason why we started abstracting and creating high-level programming languages.</p>
			<p>In the WebAssembly world, we convert human-readable programming languages, such as Rust, Go, and C/C++, into binary code. These binaries are a bunch of instructions with opcodes and operands. These instructions make the machine highly efficient but contextually make it difficult for us to understand.</p>
			<p>Why should we worry about the readability of the binary generated? Because it helps us to understand the code, which helps while debugging the code.</p>
			<p>WebAssembly provides <a id="_idTextAnchor047"/>the WebA<a id="_idTextAnchor048"/>ssembly text format, WAST or WAT. WAST is a human-readable format of the WebAssembly binary. The JavaScript engine (both in the browser and Node.js), when loading the WebAssembly file, can convert the binary into WebAssembly text format. This helps in understanding what is in the code and debugging. Text editors can show the binary in WebAssembly text format, which is much more readable than its binary counterpart.</p>
			<p>Basic WASM in binary format is as follows:</p>
			<p class="source-code">00 61 73 6d 01 00 00 00</p>
			<p>This translates to the following:</p>
			<p class="source-code"> 00 61 73 6d 01 00 00 00</p>
			<p class="source-code">\0  a  s  m  1  0  0  0 (ascii value of the character)</p>
			<p class="source-code">|         |  |</p>
			<p class="source-code">---------  version</p>
			<p class="source-code">    |</p>
			<p class="source-code">Magic Header</p>
			<p>This basic module has a magic header (<strong class="source-inline">\0asm</strong>) followed by the version of WebAssembly (<strong class="source-inline">01</strong>).</p>
			<p>The textual format <a id="_idIndexMarker128"/>is written in an <strong class="bold">s-expression format</strong>. Every instruction/expression in s-expression syntax should live within a pair of parentheses, <strong class="source-inline">()</strong>. S-expressions are commonly used when defining a nested list or structured tree. Many research papers on tree-based data structures use this notation to showcase their code. The s-expression removes all the unnecessary ceremony from XML, providing a concise format.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Does this expression (defining everything within parentheses) look familiar? Have you ever worked with LISP (or the languages that are built inspired by LISP)? </p>
			<p>Modules are <a id="_idIndexMarker129"/>the basic building blocks in WASM. A textual representation of basic WASM is as follows:</p>
			<p class="source-code">(module ) </p>
			<p>WASM is made up of a header and zero or more sections. The header starts with a magic header and the version of WASM. Following the header, the WASM may have zero or <a id="_idIndexMarker130"/>more of the following sections:</p>
			<ul>
				<li>Types</li>
				<li>Functions</li>
				<li>Tables</li>
				<li>Memories</li>
				<li>Globals</li>
				<li>Element</li>
				<li>Data</li>
				<li>Start function</li>
				<li>Exports</li>
				<li>Imports</li>
			</ul>
			<p>All these <a id="_idIndexMarker131"/>sections are optional in WASM. The structure of WASM looks as follows:</p>
			<p class="source-code"> module ::= {</p>
			<p class="source-code">    types vec&lt;funcType&gt;,</p>
			<p class="source-code">    funcs vec&lt;func&gt;,</p>
			<p class="source-code">    tables vec&lt;table&gt;,</p>
			<p class="source-code">    mems vec&lt;mem&gt;,</p>
			<p class="source-code">    globals vec&lt;global&gt;,</p>
			<p class="source-code">    elem vec&lt;elem&gt;,</p>
			<p class="source-code">    data vec&lt;data&gt;,</p>
			<p class="source-code">    start start,</p>
			<p class="source-code">    imports vec&lt;import&gt;,</p>
			<p class="source-code">    exports vec&lt;export&gt;</p>
			<p class="source-code"> } </p>
			<p>Every section <a id="_idIndexMarker132"/>inside the WASM is a vector (array) that contains zero or more values of the respective types, except for <strong class="source-inline">start</strong>. We will explore the <strong class="source-inline">start</strong> section later in the book. For now, <strong class="source-inline">start</strong> holds an index that references a function in the <strong class="source-inline">funcs</strong> section.</p>
			<p>Every section in the WASM takes the following format:</p>
			<p class="source-code">&lt;section id&gt;&lt;u32 section size&gt;&lt;Actual content of the section&gt; </p>
			<p>The first byte refers to a unique section ID. Every section has a unique section ID. Next to the unique <a id="_idIndexMarker133"/>section ID is an <strong class="bold">unsigned 32-bit</strong> (<strong class="bold">u32</strong>) integer that defines the section's size in bytes. The remaining bytes are the section content.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Since the section size is defined by a u32 integer, the maximum size of the section is limited to approximately 4.2 GB of memory (that is, 2^32 - 1).   </p>
			<p>In the WebAssembly text format, we use the name of the section to represent each segment in the section.</p>
			<p>For example, the function <a id="_idIndexMarker134"/>section contains a list of functions. A sample function definition in WebAssembly text format is as follows:</p>
			<p class="source-code"> (func &lt;name&gt;? &lt;func_type&gt; &lt;local&gt;* &lt;inst&gt;* )</p>
			<p>As with other expressions, everything that we define goes within parentheses, <strong class="source-inline">()</strong>. First, we define the function <a id="_idIndexMarker135"/>block with a <strong class="source-inline">func</strong> keyword. Following the <strong class="source-inline">func</strong> keyword, we add the name of the function. The function name is optional here because in binary, the function is identified by the index of the function block inside the function section.</p>
			<p>The name is followed by <strong class="source-inline">func_type</strong>. <strong class="source-inline">func_type</strong> is referred <a id="_idIndexMarker136"/>to as <strong class="source-inline">type_use</strong> in the spec. <strong class="source-inline">type_use</strong> here refers <a id="_idIndexMarker137"/>to the type definition. <strong class="source-inline">func_type</strong> holds all the input parameters (along with their types) and the return type of the function. So, for an <strong class="source-inline">add</strong> function, which takes two input operands and returns the result, <strong class="source-inline">func_type</strong> will look like this:</p>
			<p class="source-code">(param $lhs i32) (param $rhs i32) (result i32) </p>
			<p class="callout-heading">Note </p>
			<p class="callout">The type is either <strong class="source-inline">i32</strong>, <strong class="source-inline">i64</strong>, <strong class="source-inline">f32</strong>, or <strong class="source-inline">f64</strong> (32-bit and 64-bit integer or float). The type information might change in the future, when WebAssembly adds support for more types.</p>
			<p>The <strong class="source-inline">param</strong> keyword denotes <a id="_idIndexMarker138"/>the defined expression holds a parameter. <strong class="source-inline">$lhs</strong> is the variable name. Note that all variables defined in the WebAssembly text format will have <strong class="source-inline">$</strong> as a prefix. Following that, we have the type of the parameter, <strong class="source-inline">i32</strong>. Similarly, we have defined another expression for the second operand, <strong class="source-inline">$rhs</strong>. Finally, the return type is mentioned as <strong class="source-inline">(result i32)</strong>. The <strong class="source-inline">result</strong> keyword denotes that the expression is a return type, followed by the type, <strong class="source-inline">i32</strong>.</p>
			<p>Following <strong class="source-inline">func_type</strong>, we define any local variables that we will use inside the function. Finally, we have a list of instructions/operations.</p>
			<p>Let's define an <strong class="source-inline">add</strong> function with the preceding code snippets as a reference:</p>
			<p class="source-code"> (func $add (param $lhs i32) (param $rhs i32) (result i32)</p>
			<p class="source-code">    get_local $lhs</p>
			<p class="source-code">    get_local $rhs</p>
			<p class="source-code">    i32.add) </p>
			<p>The entire block is <a id="_idIndexMarker139"/>wrapped inside the parentheses. The function block starts with a <strong class="source-inline">func</strong> keyword. Then, we have an optional name (<strong class="source-inline">$add</strong>) for the function. The WebAssembly binary module will use the function index inside the function section to identify the function rather than a name. Then, we define the operand and return type.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">In binary format, the parameters and results are defined via the <strong class="source-inline">type</strong> section as that helps to optimize the generated functions. But in the text format, for brevity and ease of understanding, the type information will be shown in every function definition.</p>
			<p>Then, we have a list of instructions. The first instruction, <strong class="source-inline">get_local</strong>, gets the local value of (from the heap) <strong class="source-inline">$lhs</strong>. Then, we fetch the local value of <strong class="source-inline">$rhs</strong>. After that, we add them both using the <strong class="source-inline">i32.add</strong> instruction. Finally, the closing parenthesis finishes things off.</p>
			<p>There is no separate <strong class="source-inline">return</strong> statement/expression. So, how does the function know what to return?</p>
			<p>As we have seen before, WebAssembly is a stack machine. When a function is called, it creates an empty stack for it. The function then uses this stack to push and pop data. So, when the <strong class="source-inline">get_local</strong> instruction is executed, it pushes the value into the stack. After the two <strong class="source-inline">get_local</strong> calls, the stack will have <strong class="source-inline">$lhs</strong> and <strong class="source-inline">$rhs</strong> in the stack. Finally, <strong class="source-inline">i32.add</strong> will pop two values from the stack, do the <strong class="source-inline">add</strong> operation, and push the element. When the function is ended, the top of the stack will be taken out and provided to the function caller.</p>
			<p>If we want to export this function to the outside world, then we can add an <strong class="source-inline">export</strong> block:</p>
			<p class="source-code"> (export &lt;export_name&gt; (func &lt;function_reference&gt;))</p>
			<p>The <strong class="source-inline">export</strong> block is defined inside <strong class="source-inline">()</strong>. The <strong class="source-inline">export</strong> block starts with an <strong class="source-inline">export</strong> keyword. The <strong class="source-inline">export</strong> keyword is <a id="_idIndexMarker140"/>followed by the name of the function. Following the name, we refer to the function. The function block consists of the following <strong class="source-inline">func</strong> keyword. Then, we have <strong class="source-inline">function_reference</strong>, which refers to the name of the function defined/imported inside the module.</p>
			<p>In order to export the <strong class="source-inline">add</strong> function, we define the following:</p>
			<p class="source-code"> (export "add" (func $add)) </p>
			<p><strong class="source-inline">"add"</strong> refers to the name with which the function is exported outside the module, followed by <strong class="source-inline">(func $add)</strong>, referring to the function.</p>
			<p>Both the function <a id="_idIndexMarker141"/>and <strong class="source-inline">export</strong> sections should be wrapped inside a <strong class="source-inline">module</strong> section, to make it valid WASM:</p>
			<p class="source-code">(module</p>
			<p class="source-code">    (func $add (param $lhs i32) (param $rhs i32) </p>
			<p class="source-code">      (result i32)</p>
			<p class="source-code">        get_local $lhs</p>
			<p class="source-code">        get_local $rhs</p>
			<p class="source-code">        i32.add)</p>
			<p class="source-code">    (export "add" (func $add))</p>
			<p class="source-code">) </p>
			<p>The preceding is valid WASM. Imagine it as a tree structure with the module as its root and both the function and export as its children.</p>
			<p>We have seen how to create a simple function in WebAssembly text format. Now, let's define a complex function in WebAssembly text format.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor049"/>Building a function in WebAssembly text format </h2>
			<p>For this, we <a id="_idIndexMarker142"/>will use a recursive <a id="_idIndexMarker143"/>Fibonacci series generator. The Fibonacci function that we will be writing will be of the following format:</p>
			<p class="source-code"> # Sample code in C for reference</p>
			<p class="source-code">int fib(n) {</p>
			<p class="source-code">    if (n &lt;= 1)</p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    else</p>
			<p class="source-code">        return fib(n-1)+ fib(n-2);</p>
			<p class="source-code">} </p>
			<p>Let's first define the function signature for the given <strong class="source-inline">fib</strong> function using WebAssembly text format. The <strong class="source-inline">fib</strong> function, similar to its C counterpart, takes in a number parameter and returns a number. So, the function definition follows the same signature in the WebAssembly text format:</p>
			<p class="source-code"> (func $fib (param $n i32) (result i32)</p>
			<p class="source-code">    ...</p>
			<p class="source-code">)</p>
			<p>We define the function inside parentheses, <strong class="source-inline">()</strong>. The function starts with a <strong class="source-inline">func</strong> keyword. Following the keyword, we add the function name, <strong class="source-inline">$fib</strong>. Then, we add the parameter to the function; in our case, the function has only one parameter, <strong class="source-inline">n</strong>; we define it as <strong class="source-inline">(param $n i32)</strong>. Then, the function returns a number, <strong class="source-inline">(result i32)</strong>.</p>
			<p>WebAssembly does not have in-memory to handle temporary variables. In order to have local values, we should push the value into the stack and then retrieve it. So, to check <strong class="source-inline">n&lt;=1</strong>, we have to first create a local variable and store <strong class="source-inline">1</strong> inside it, and then do the check. To define a local variable, we use the <strong class="source-inline">local</strong> block. The <strong class="source-inline">local</strong> block starts with a <strong class="source-inline">local</strong> keyword. This keyword is followed by the name of the variable. After the variable name, we define the type of the variable:</p>
			<p class="source-code"> (local &lt;name&gt; &lt;type&gt;)</p>
			<p>Let's create a <strong class="source-inline">local</strong> variable called <strong class="source-inline">$tmp</strong>:</p>
			<p class="source-code"> (local $tmp i32) </p>
			<p class="callout-heading">Note</p>
			<p class="callout"> <strong class="source-inline">(local $tmp i32)</strong> is not an instruction. It is part of the function declaration. Remember, the preceding function syntax includes <strong class="source-inline">local</strong>.</p>
			<p>We then <a id="_idIndexMarker144"/>have to set the value of <strong class="source-inline">$tmp</strong> to <strong class="source-inline">1</strong>. To set the value, we first have to push the value <strong class="source-inline">1</strong> into the stack, after <a id="_idIndexMarker145"/>which we have to pop the value from the stack and set it to <strong class="source-inline">$tmp</strong>:</p>
			<p class="source-code">i32.const 1</p>
			<p class="source-code">set_local $tmp </p>
			<p><strong class="source-inline">i32.const</strong> creates an <strong class="source-inline">i32</strong> constant value and pushes that into the stack. So, here, we create a constant with a value of <strong class="source-inline">1</strong> and push that into the stack.</p>
			<p>Then, we set the value in <strong class="source-inline">$tmp</strong> using <strong class="source-inline">set_local</strong>. <strong class="source-inline">set_local</strong> takes the topmost value from the stack, in our case, 1, and assigns the value of <strong class="source-inline">$tmp</strong> to <strong class="source-inline">1</strong>.</p>
			<p>Now, we have to check whether the given parameter is less than 2. WebAssembly provides <strong class="source-inline">i32.&lt;some_action&gt;</strong> to do some action on <strong class="source-inline">i32</strong>. For example, to add two numbers, we have used <strong class="source-inline">i32.add</strong>. Similarly, to check whether it's less than a particular value, we have <strong class="source-inline">i32.lt_s</strong>. <strong class="source-inline">_s</strong> here denotes that we are checking for a signed number.</p>
			<p><strong class="source-inline">i32.lt_s</strong> expects two operands. For the first operand (that is, <strong class="source-inline">$n</strong>), we use the <strong class="source-inline">get_local</strong> expression to fetch the value from <strong class="source-inline">$n</strong> and put it at the top of the stack. Then, we create a constant of <strong class="source-inline">2</strong> using <strong class="source-inline">i32.const 2</strong> and add <strong class="source-inline">2</strong> to the stack. Finally, we compare the <strong class="source-inline">$n</strong> value with <strong class="source-inline">2</strong> using <strong class="source-inline">i32.lt_s</strong>:</p>
			<p class="source-code">get_local $n</p>
			<p class="source-code">i32.const 2</p>
			<p class="source-code">i32.lt_s</p>
			<p>But how do we define the <em class="italic">if condition</em>? WebAssembly provides <strong class="source-inline">br_if</strong> and <strong class="source-inline">block</strong>.</p>
			<p>In WebAssembly text format, a block is defined with a <strong class="source-inline">block</strong> keyword followed by a name to identify the block. We end the block using <strong class="source-inline">end</strong>. The block looks as follows:</p>
			<p class="source-code">block $block</p>
			<p class="source-code">... ; some code goes in here.</p>
			<p class="source-code">end</p>
			<p>We will <a id="_idIndexMarker146"/>provide this block to <strong class="source-inline">br_if</strong>. <strong class="source-inline">br_if</strong> calls the block if the condition succeeds:</p>
			<p class="source-code">get_local $n</p>
			<p class="source-code">i32.const 2</p>
			<p class="source-code">i32.lt_s</p>
			<p class="source-code">br_if $block ; calls the $block` only when the condition</p>
			<p class="source-code">  succeeds.</p>
			<p>The <a id="_idIndexMarker147"/>WebAssembly text format so far will look like this:</p>
			<p class="source-code"> (module</p>
			<p class="source-code">  (func $fib (param $n i32) (result i32) (local $tmp i32)</p>
			<p class="source-code">    i32.const 1</p>
			<p class="source-code">    set_local $tmp</p>
			<p class="source-code">    ; block</p>
			<p class="source-code">    block $block</p>
			<p class="source-code">      ; if condition</p>
			<p class="source-code">      get_local $n</p>
			<p class="source-code">      i32.const 2</p>
			<p class="source-code">      i32.lt_s</p>
			<p class="source-code">      br_if $block</p>
			<p class="source-code">    ... ; some code</p>
			<p class="source-code">    end</p>
			<p class="source-code">    ; return value</p>
			<p class="source-code">    get_local $tmp</p>
			<p class="source-code">  )</p>
			<p class="source-code">) </p>
			<p>Everything <a id="_idIndexMarker148"/>is wrapped inside <strong class="source-inline">module</strong>. At the <a id="_idIndexMarker149"/>end of <strong class="source-inline">$block</strong>, the value will be stored in <strong class="source-inline">$tmp</strong>. We get the value of <strong class="source-inline">$tmp</strong> using <strong class="source-inline">get_local $tmp</strong>. The only thing that is left to do is to create the loop.</p>
			<h3>Loop time</h3>
			<p>First, we set <strong class="source-inline">$tmp</strong> to <strong class="source-inline">1</strong>:</p>
			<p class="source-code">i32.const 1</p>
			<p class="source-code">set_local $tmp </p>
			<p>Then, we will <a id="_idIndexMarker150"/>create a loop. To create a loop, the WebAssembly text format uses the <strong class="source-inline">loop</strong> keyword:</p>
			<p class="source-code">loop $loop</p>
			<p class="source-code">end </p>
			<p>The <strong class="source-inline">loop</strong> keyword is <a id="_idIndexMarker151"/>followed by the name of the loop. The loop ends with the <strong class="source-inline">end</strong> keyword. <strong class="source-inline">loop</strong> is a special block that will run until we exit using some conditional expression such as <strong class="source-inline">br_if</strong>:</p>
			<p class="source-code">get_local $n</p>
			<p class="source-code">i32.const -2</p>
			<p class="source-code">i32.add</p>
			<p class="source-code">call $fib</p>
			<p class="source-code">get_local $tmp</p>
			<p class="source-code">i32.add</p>
			<p class="source-code">set_local $tmp</p>
			<p class="source-code">get_local $n</p>
			<p class="source-code">i32.const -1</p>
			<p class="source-code">i32.add</p>
			<p class="source-code">tee_local $n</p>
			<p class="source-code">i32.const 1</p>
			<p class="source-code">i32.gt_s</p>
			<p class="source-code">br_if $loop</p>
			<p>We get <strong class="source-inline">$n</strong> and add <strong class="source-inline">-2</strong> to it, and then call the <strong class="source-inline">fib</strong> function. To call a function, we use the <strong class="source-inline">call</strong> keyword followed by the name of the function. Here, <strong class="source-inline">call $fib</strong> returns the value and <a id="_idIndexMarker152"/>pushes the value into the stack.</p>
			<p>Now, get <strong class="source-inline">$tmp</strong> using <strong class="source-inline">get_local $tmp</strong>. This pushes <strong class="source-inline">$tmp</strong> to the stack. Then, we use <strong class="source-inline">i32.add</strong> to pop two values from the stack and add them. Finally, we set <strong class="source-inline">$tmp</strong> using <strong class="source-inline">set_local $tmp</strong>. <strong class="source-inline">set_local $tmp</strong> takes the topmost value from the stack and assigns it to <strong class="source-inline">$tmp</strong>. We get <strong class="source-inline">$n</strong> and add <strong class="source-inline">-1</strong> to it.</p>
			<p>We use <strong class="source-inline">tee_local</strong> here because <strong class="source-inline">tee_local</strong> is similar to <strong class="source-inline">set_local</strong> but instead of pushing the value into the stack, it returns the value. Finally, we run the loop until <strong class="source-inline">$n</strong> is greater than 1. If it is less than 1, we break the loop using <strong class="source-inline">br_if $loop</strong>. The complete WebAssembly text format will look like this:</p>
			<p class="source-code">(module</p>
			<p class="source-code">  (func (export $fib (param $n i32) (result i32) </p>
			<p class="source-code">    (local $tmp i32)</p>
			<p class="source-code">    i32.const 1</p>
			<p class="source-code">    set_local $tmp</p>
			<p class="source-code">    ; block</p>
			<p class="source-code">    block $block</p>
			<p class="source-code">      ; if condition</p>
			<p class="source-code">      get_local $n</p>
			<p class="source-code">      i32.const 2</p>
			<p class="source-code">      i32.lt_s</p>
			<p class="source-code">      br_if $block</p>
			<p class="source-code">      ; loop</p>
			<p class="source-code">      loop $loop</p>
			<p class="source-code">        get_local $n</p>
			<p class="source-code">        i32.const -2</p>
			<p class="source-code">        i32.add</p>
			<p class="source-code">        call $fib</p>
			<p class="source-code">        get_local $tmp</p>
			<p class="source-code">        i32.add</p>
			<p class="source-code">        set_local $tmp</p>
			<p class="source-code">        get_local $n</p>
			<p class="source-code">        i32.const -1</p>
			<p class="source-code">        i32.add</p>
			<p class="source-code">        tee_local $n</p>
			<p class="source-code">        i32.const 1</p>
			<p class="source-code">        i32.gt_s</p>
			<p class="source-code">        br_if $loop</p>
			<p class="source-code">      end</p>
			<p class="source-code">    end</p>
			<p class="source-code">    ; return value</p>
			<p class="source-code">    get_local $tmp</p>
			<p class="source-code">  )</p>
			<p class="source-code">)</p>
			<p>In future <a id="_idIndexMarker153"/>chapters, we will see how we can convert this WebAssembly text format into WASM and execute it.</p>
			<p>If you're interested <a id="_idIndexMarker154"/>in learning more about s-expressions, check out <a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a>.</p>
			<p>To find out <a id="_idIndexMarker155"/>more about the WebAssembly text format design, check out the specifications at <a href="https://github.com/WebAssembly/design/blob/master/Semantics.md">https://github.com/WebAssembly/design/blob/master/Semantics.md</a>.</p>
			<p>Check out more text instructions at <a href="https://webassembly.github.io/spec/core/text/instructions.html">https://webassembly.github.io/spec/core/text/instructions.html</a>.</p>
			<p>Refer to various instructions and their opcode at <a href="https://webassembly.github.io/spec/core/binary/instructions.html">https://webassembly.github.io/spec/core/binary/instructions.html</a>.</p>
			<p>Find out more about binary encoding at <a href="https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md">https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md</a>.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor050"/>Summary</h1>
			<p>In this chapter, we have seen how WebAssembly is executed inside the JavaScript engine and explored what WebAssembly text format is and how to define WASM using WebAssembly text format. In the next chapter, we will explore the WebAssembly Binary Toolkit.</p>
		</div>
	</body></html>