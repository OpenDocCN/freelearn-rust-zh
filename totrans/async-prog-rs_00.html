<html><head></head><body>
		<div id="_idContainer004">
			<h1 id="_idParaDest-5"><a id="_idTextAnchor004"/>Preface</h1>
			<p>The content in this book was initially written as a series of shorter books for programmers wanting to learn asynchronous programming from the ground up using Rust. I found the existing material I came upon at the time to be in equal parts frustrating, enlightening, and confusing, so I wanted to do something <span class="No-Break">about that.</span></p>
			<p>Those shorter books became popular, so when I got the chance to write everything a second time, improve the parts that I was happy with, and completely rewrite everything else and put it in a single, coherent book, I just had to do it. The result is right in front <span class="No-Break">of you.</span></p>
			<p>People start programming for a variety of different reasons. Scientists start programming to model problems and perform calculations. Business experts create programs that solve specific problems that help their businesses. Some people start programming as a hobby or in their spare time. Common to these programmers is that they learn programming from the <span class="No-Break">top down.</span></p>
			<p>Most of the time, this is perfectly fine, but on the topic of asynchronous programming in general, and Rust in particular, there is a clear advantage to learning about the topic from first principles, and this book aims to provide a means to do <span class="No-Break">just that.</span></p>
			<p><strong class="bold">Asynchronous programming</strong> is a way to write programs where you divide your program into tasks that can be stopped and resumed at specific points. This, in turn, allows a language runtime, or a library, to drive and schedule these tasks so their <span class="No-Break">progress interleaves.</span></p>
			<p>Asynchronous programming will, by its very nature, affect the entire program flow, and it’s very invasive. It rewrites, reorders, and schedules the program you write in a way that’s not always obvious to you as <span class="No-Break">a programmer.</span></p>
			<p>Most programming languages try to make asynchronous programming so easy that you don’t really have to understand how it works just to be productive <span class="No-Break">in it.</span></p>
			<p>You can get quite productive writing asynchronous Rust without really knowing how it works as well, but Rust is more explicit and surfaces more complexity to the programmer than most other languages. You will have a much easier time handling this complexity if you get a deep understanding of asynchronous programming in general and what really happens when you write <span class="No-Break">asynchronous Rust.</span></p>
			<p>Another huge upside is that learning from first principles results in knowledge that is applicable way beyond Rust, and it will, in turn, make it easier to pick up asynchronous programming in other languages as well. I would even go so far as to say that most of this knowledge will be useful even in your day-to-day programming. At least, that’s how it’s been <span class="No-Break">for me.</span></p>
			<p>I want this book to feel like you’re joining me on a journey, where we build our knowledge topic by topic and learn by creating examples and experiments along the way. I don’t want this book to feel like a lecturer simply telling you how <span class="No-Break">everything works.</span></p>
			<p>This book is created for people who are curious by nature, the kind of programmers who want to understand the systems they use, and who like creating small and big experiments as a way to explore <span class="No-Break">and learn.</span></p>
			<h1 id="_idParaDest-6"><a id="_idTextAnchor005"/>Who this book is for</h1>
			<p>This book is for developers with some prior programming experience who want to learn asynchronous programming from the ground up so they can be proficient in async Rust and be able to participate in technical discussions on the subject. The book is perfect for those who like writing working examples they can pick apart, expand, and <span class="No-Break">experiment with.</span> There are two kinds of personas that I feel this book is especially <span class="No-Break">relevant to:</span></p>
			<ul>
				<li>Developers coming from higher-level languages with a garbage collector, interpreter, or runtime, such as C#, Java, JavaScript, Python, Ruby, Swift, or Go. Programmers who have extensive experience with asynchronous programming in any of these languages but want to learn it from the ground up and programmers with no experience with asynchronous programming should both find this book equally useful.</li>
				<li>Developers with experience in languages such as C or C++ that have limited experience with asynchronous programming.</li>
			</ul>
			<h1 id="_idParaDest-7"><a id="_idTextAnchor006"/>What this book covers</h1>
			<p><a href="B20892_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Concurrency and Asynchronous Programming: A Detailed Overview</em>, provides a short history leading up to the type of asynchronous programming we use today. We give several important definitions and provide a mental model that explains what kind of problems asynchronous programming really solves, and how concurrency differs from parallelism. We also cover the importance of choosing the correct reference frame when discussing asynchronous program flow, and we go through several important and fundamental concepts about CPUs, operating systems, hardware, interrupts, <span class="No-Break">and I/O.</span></p>
			<p><a href="B20892_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">How Programming Languages Model Asynchronous Program Flow</em>, narrows the scope from the previous chapter and focuses on the different ways programming languages deal with asynchronous programming. It starts by giving several important definitions before explaining stackful and stackless coroutines, OS threads, green threads, fibers, callbacks, promises, futures, <span class="No-Break">and async/await.</span></p>
			<p><a href="B20892_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Understanding OS-Backed Event Queues, System Calls, and Cross-Platform Abstractions</em>, explains what epoll, kqueue, and IOCP are and how they differ. It prepares us for the next chapters by giving an introduction to syscalls, FFI, and <span class="No-Break">cross-platform abstractions.</span></p>
			<p><a href="B20892_04.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Create Your Own Event Queue</em>, is the chapter where you create your own event queue that mimics the API of <em class="italic">mio</em> (the popular Rust library that underpins much of the current async ecosystem). The example will center around epoll and go into quite a bit of detail on how <span class="No-Break">it works.</span></p>
			<p><a href="B20892_05.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Creating Our Own Fibers</em>, walks through an example where we create our own kind of stackful coroutines called fibers. They’re the same kind of green threads that Go uses and show one of the most widespread and popular alternatives to the type of abstraction Rust uses with futures and async/await today. Rust used this kind of abstraction in its early days before it reached 1.0, so it’s also a part of Rust’s history. This chapter will also cover quite a few general programming concepts, such as stacks, assembly, <strong class="bold">Application Binary Interfaces</strong> (<strong class="bold">ABIs</strong>), and <strong class="bold">instruction set architecture</strong> (<strong class="bold">ISAs</strong>), that are useful beyond the context of asynchronous programming <span class="No-Break">as well.</span></p>
			<p><a href="B20892_06.xhtml#_idTextAnchor113"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Futures in Rust</em>, gives a short introduction and overview of futures, runtimes, and asynchronous programming <span class="No-Break">in Rust.</span></p>
			<p><a href="B20892_07.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Coroutines and async/await</em>, is a chapter where you write your own coroutines that are simplified versions of the ones created by async/await in Rust today. We’ll write a few of them by hand and introduce a new syntax that allows us to programmatically rewrite what look like regular functions into the coroutines we wrote <span class="No-Break">by hand.</span></p>
			<p><a href="B20892_08.xhtml#_idTextAnchor138"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Runtimes, Wakers, and the Reactor-Executor Pattern</em>, introduces runtimes and runtime design. By iterating on the example we created in <a href="B20892_07.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, we’ll create a runtime for our coroutines that we’ll gradually improve. We’ll also do some experiments with our runtime once it’s done to better understand how <span class="No-Break">it works.</span></p>
			<p><a href="B20892_09.xhtml#_idTextAnchor156"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Coroutines, Self-Referential Structs, and Pinning</em>, is the chapter where we introduce self-referential structs and pinning in Rust. By improving our coroutines further, we’ll experience first-hand why we need something such as <strong class="source-inline">Pin</strong>, and how it helps us solve the problems <span class="No-Break">we encounter.</span></p>
			<p><a href="B20892_10.xhtml#_idTextAnchor178"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Create Your Own Runtime</em>, is the chapter where we finally put all the pieces together. We’ll improve the same example from the previous chapters further so we can run Rust futures, which will allow us to use the full power of async/await and asynchronous Rust. We’ll also do a few experiments that show some of the difficulties with asynchronous Rust and how we can best <span class="No-Break">solve them.</span></p>
			<h1 id="_idParaDest-8"><a id="_idTextAnchor007"/>To get the most out of this book</h1>
			<p>You should have some prior programming experience and, preferably, some knowledge about Rust. Reading the free, and excellent, introductory book <em class="italic">The Rust Programming Language</em> (<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>) should give you more than enough knowledge about Rust to follow along since any advanced topics will be explained step <span class="No-Break">by step.</span></p>
			<p>The ideal way to read this book is to have the book and a code editor open side by side. You should also have the accompanying repository available so you can refer to that if you encounter <span class="No-Break">any issues.</span></p>
			<table id="table001" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Software/hardware covered in </strong><span class="No-Break"><strong class="bold">the book</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Operating </strong><span class="No-Break"><strong class="bold">system requirements</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Rust (version 1.51 <span class="No-Break">or later)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Windows, macOS, <span class="No-Break">or Linux</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>You need Rust installed. If you haven’t already, follow the instructions <span class="No-Break">here: </span><a href="https://www.rust-lang.org/tools/install"><span class="No-Break">https://www.rust-lang.org/tools/install</span></a><span class="No-Break">.</span></p>
			<p>Some examples will require you to use <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>) on Windows. If you’re following along on a Windows machine, I recommend that you enable WSL (<a href="https://learn.microsoft.com/en-us/windows/wsl/install">https://learn.microsoft.com/en-us/windows/wsl/install</a>) now and install Rust by following the instructions for installing Rust on WSL <span class="No-Break">here: </span><a href="https://www.rust-lang.org/tools/install"><span class="No-Break">https://www.rust-lang.org/tools/install</span></a><span class="No-Break">.</span></p>
			<p><strong class="bold">If you are using the digital version of this book, we advise you to type the code yourself or access the code from the book’s GitHub repository (a link is available in the next section). Doing so will help you avoid any potential errors related to the copying and pasting </strong><span class="No-Break"><strong class="bold">of code.</strong></span></p>
			<p>The accompanying repository is organized in the <span class="No-Break">following fashion:</span></p>
			<ul>
				<li>Code that belongs to a specific chapter is in that chapter’s folder (e.g., <strong class="source-inline">ch01</strong>).</li>
				<li>Each example is organized as a separate crate.</li>
				<li>The letters in front of the example names indicate in what order the different examples are presented in the book. For example, the <strong class="source-inline">a-runtime</strong> example comes before the <strong class="source-inline">b-reactor-executor</strong> example. This way, they will be ordered chronologically (at least by default on most systems).</li>
				<li>Some examples have a version postfixed with <strong class="source-inline">-bonus</strong>. These versions will be mentioned in the book text and often contain a specific variant of the example that might be interesting to check out but is not important to the topic at hand.</li>
			</ul>
			<h1 id="_idParaDest-9"><a id="_idTextAnchor008"/>Download the example code files</h1>
			<p>You can download the example code files for this book from GitHub at <a href="https://github.com/PacktPublishing/Asynchronous-Programming-in-Rust">https://github.com/PacktPublishing/Asynchronous-Programming-in-Rust</a>. If there’s an update to the code, it will be updated in the <span class="No-Break">GitHub repository.</span></p>
			<p>We also have other code bundles from our rich catalog of books and videos available at <a href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a>. Check <span class="No-Break">them out!</span></p>
			<h1 id="_idParaDest-10"><a id="_idTextAnchor009"/>Conventions used</h1>
			<p>There are a number of text conventions used throughout <span class="No-Break">this book.</span></p>
			<p><strong class="source-inline">Code in text</strong>: Indicates code words in text, database table names, folder names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter handles. Here is an example: “So, now we have created our own async runtime that uses Rust’s <strong class="source-inline">Futures</strong>, <strong class="source-inline">Waker</strong>, <strong class="source-inline">Context</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">async/await</strong></span><span class="No-Break">.”</span></p>
			<p>A block of code is set <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
pub trait Future {
    type Output;
    fn poll(&amp;mut self) -&gt; PollState&lt;Self::Output&gt;;
}</pre>			<p>When we wish to draw your attention to a particular part of a code block, the relevant lines or items are set <span class="No-Break">in bold:</span></p>
			<pre class="source-code">
struct Coroutine0 {
    <strong class="bold">stack: Stack0,</strong>
    state: State0,
}</pre>			<p>Any command-line input or output is written <span class="No-Break">as follows:</span></p>
			<pre class="console">
$ cargo run</pre>			<p class="callout-heading">Tips or important notes</p>
			<p class="callout">Appear like this.</p>
			<h1 id="_idParaDest-11"><a id="_idTextAnchor010"/>Get in touch</h1>
			<p>Feedback from our readers is <span class="No-Break">always welcome.</span></p>
			<p><strong class="bold">General feedback</strong>: If you have questions about any aspect of this book, email us at <a href="mailto:customercare@packtpub.com">customercare@packtpub.com</a> and mention the book title in the subject of <span class="No-Break">your message.</span></p>
			<p><strong class="bold">Errata</strong>: Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you have found a mistake in this book, we would be grateful if you would report this to us. Please visit <a href="http://www.packtpub.com/support/errata">www.packtpub.com/support/errata</a> and fill in <span class="No-Break">the form.</span></p>
			<p><strong class="bold">Piracy</strong>: If you come across any illegal copies of our works in any form on the internet, we would be grateful if you would provide us with the location address or website name. Please contact us at <a href="mailto:copyright@packt.com">copyright@packt.com</a> with a link to <span class="No-Break">the material.</span></p>
			<p><strong class="bold">If you are interested in becoming an author</strong>: If there is a topic that you have expertise in and you are interested in either writing or contributing to a book, please <span class="No-Break">visit </span><a href="http://authors.packtpub.com"><span class="No-Break">authors.packtpub.com</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-12"><a id="_idTextAnchor011"/>Share your thoughts</h1>
			<p>Once you’ve read <em class="italic">Asynchronous Programming in Rust</em>, we’d love to hear your thoughts! Please <a href="https://packt.link/r/1805128132">click here to go straight to the Amazon review page</a> for this book and share <span class="No-Break">your feedback.</span></p>
			<p>Your review is important to us and the tech community and will help us make sure we’re delivering excellent <span class="No-Break">quality content.</span></p>
			<h1 id="_idParaDest-13"><a id="_idTextAnchor012"/>Download a free PDF copy of this book</h1>
			<p>Thanks for purchasing <span class="No-Break">this book!</span></p>
			<p>Do you like to read on the go but are unable to carry your print <span class="No-Break">books everywhere?</span></p>
			<p>Is your eBook purchase not compatible with the device of <span class="No-Break">your choice?</span></p>
			<p>Don’t worry, now with every Packt book you get a DRM-free PDF version of that book at <span class="No-Break">no cost.</span></p>
			<p>Read anywhere, any place, on any device. Search, copy, and paste code from your favorite technical books directly into <span class="No-Break">your application.</span></p>
			<p>The perks don’t stop there, you can get exclusive access to discounts, newsletters, and great free content in your <span class="No-Break">inbox daily</span></p>
			<p>Follow these simple steps to get <span class="No-Break">the benefits:</span></p>
			<ol>
				<li>Scan the QR code or visit the <span class="No-Break">link below</span></li>
			</ol>
			<p> </p>
			<div>
				<div id="_idContainer003" class="IMG---Figure">
					<img src="image/B20892_QR_Free_PDF.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a href="https://packt.link/free-ebook/9781805128137">https://packt.link/free-ebook/9781805128137</a></p>
			<p>2.	Submit your proof <span class="No-Break">of purchase</span></p>
			<p>3.	That’s it! We’ll send your free PDF and other benefits to your <span class="No-Break">email directly</span></p>
		</div>
	

		<div id="_idContainer005" class="Content">
			<h1 id="_idParaDest-14" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor013"/>Part 1:Asynchronous Programming Fundamentals</h1>
			<p>In this part, you’ll receive a thorough introduction to concurrency and asynchronous programming. We’ll also explore various techniques that programming languages employ to model asynchrony, examining the most popular ones and covering some of the pros and cons associated with each. Finally, we’ll explain the concept of OS-backed event queues, such as epoll, kqueue, and IOCP, detailing how system calls are used to interact with the operating system and addressing the challenges encountered in creating cross-platform abstractions like mio. This section comprises the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B20892_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Concurrency and Asynchronous Programming: A Detailed Overview</em></li>
				<li><a href="B20892_02.xhtml#_idTextAnchor043"><em class="italic">Chapter 2</em></a>, <em class="italic">How Programming Languages Model Asynchronous Program Flow</em></li>
				<li><a href="B20892_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a><em class="italic">, Understanding OS-Backed Event Queues, System Calls and Cross Platform Abstractions</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer006" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>