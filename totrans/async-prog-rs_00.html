<html><head></head><body>
		<div><h1 id="_idParaDest-5"><a id="_idTextAnchor004"/>Preface</h1>
			<p>The content in this book was initially written as a series of shorter books for programmers wanting to learn asynchronous programming from the ground up using Rust. I found the existing material I came upon at the time to be in equal parts frustrating, enlightening, and confusing, so I wanted to do something about that.</p>
			<p>Those shorter books became popular, so when I got the chance to write everything a second time, improve the parts that I was happy with, and completely rewrite everything else and put it in a single, coherent book, I just had to do it. The result is right in front of you.</p>
			<p>People start programming for a variety of different reasons. Scientists start programming to model problems and perform calculations. Business experts create programs that solve specific problems that help their businesses. Some people start programming as a hobby or in their spare time. Common to these programmers is that they learn programming from the top down.</p>
			<p>Most of the time, this is perfectly fine, but on the topic of asynchronous programming in general, and Rust in particular, there is a clear advantage to learning about the topic from first principles, and this book aims to provide a means to do just that.</p>
			<p><strong class="bold">Asynchronous programming</strong> is a way to write programs where you divide your program into tasks that can be stopped and resumed at specific points. This, in turn, allows a language runtime, or a library, to drive and schedule these tasks so their progress interleaves.</p>
			<p>Asynchronous programming will, by its very nature, affect the entire program flow, and it’s very invasive. It rewrites, reorders, and schedules the program you write in a way that’s not always obvious to you as a programmer.</p>
			<p>Most programming languages try to make asynchronous programming so easy that you don’t really have to understand how it works just to be productive in it.</p>
			<p>You can get quite productive writing asynchronous Rust without really knowing how it works as well, but Rust is more explicit and surfaces more complexity to the programmer than most other languages. You will have a much easier time handling this complexity if you get a deep understanding of asynchronous programming in general and what really happens when you write asynchronous Rust.</p>
			<p>Another huge upside is that learning from first principles results in knowledge that is applicable way beyond Rust, and it will, in turn, make it easier to pick up asynchronous programming in other languages as well. I would even go so far as to say that most of this knowledge will be useful even in your day-to-day programming. At least, that’s how it’s been for me.</p>
			<p>I want this book to feel like you’re joining me on a journey, where we build our knowledge topic by topic and learn by creating examples and experiments along the way. I don’t want this book to feel like a lecturer simply telling you how everything works.</p>
			<p>This book is created for people who are curious by nature, the kind of programmers who want to understand the systems they use, and who like creating small and big experiments as a way to explore and learn.</p>
			<h1 id="_idParaDest-6"><a id="_idTextAnchor005"/>Who this book is for</h1>
			<p>This book is for developers with some prior programming experience who want to learn asynchronous programming from the ground up so they can be proficient in async Rust and be able to participate in technical discussions on the subject. The book is perfect for those who like writing working examples they can pick apart, expand, and experiment with. There are two kinds of personas that I feel this book is especially relevant to:</p>
			<ul>
				<li>Developers coming from higher-level languages with a garbage collector, interpreter, or runtime, such as C#, Java, JavaScript, Python, Ruby, Swift, or Go. Programmers who have extensive experience with asynchronous programming in any of these languages but want to learn it from the ground up and programmers with no experience with asynchronous programming should both find this book equally useful.</li>
				<li>Developers with experience in languages such as C or C++ that have limited experience with asynchronous programming.</li>
			</ul>
			<h1 id="_idParaDest-7"><a id="_idTextAnchor006"/>What this book covers</h1>
			<p><a href="B20892_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Concurrency and Asynchronous Programming: A Detailed Overview</em>, provides a short history leading up to the type of asynchronous programming we use today. We give several important definitions and provide a mental model that explains what kind of problems asynchronous programming really solves, and how concurrency differs from parallelism. We also cover the importance of choosing the correct reference frame when discussing asynchronous program flow, and we go through several important and fundamental concepts about CPUs, operating systems, hardware, interrupts, and I/O.</p>
			<p><a href="B20892_02.xhtml#_idTextAnchor043"><em class="italic">Chapter 2</em></a>, <em class="italic">How Programming Languages Model Asynchronous Program Flow</em>, narrows the scope from the previous chapter and focuses on the different ways programming languages deal with asynchronous programming. It starts by giving several important definitions before explaining stackful and stackless coroutines, OS threads, green threads, fibers, callbacks, promises, futures, and async/await.</p>
			<p><a href="B20892_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding OS-Backed Event Queues, System Calls, and Cross-Platform Abstractions</em>, explains what epoll, kqueue, and IOCP are and how they differ. It prepares us for the next chapters by giving an introduction to syscalls, FFI, and cross-platform abstractions.</p>
			<p><a href="B20892_04.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Create Your Own Event Queue</em>, is the chapter where you create your own event queue that mimics the API of <em class="italic">mio</em> (the popular Rust library that underpins much of the current async ecosystem). The example will center around epoll and go into quite a bit of detail on how it works.</p>
			<p><a href="B20892_05.xhtml#_idTextAnchor092"><em class="italic">Chapter 5</em></a>, <em class="italic">Creating Our Own Fibers</em>, walks through an example where we create our own kind of stackful coroutines called fibers. They’re the same kind of green threads that Go uses and show one of the most widespread and popular alternatives to the type of abstraction Rust uses with futures and async/await today. Rust used this kind of abstraction in its early days before it reached 1.0, so it’s also a part of Rust’s history. This chapter will also cover quite a few general programming concepts, such as stacks, assembly, <strong class="bold">Application Binary Interfaces</strong> (<strong class="bold">ABIs</strong>), and <strong class="bold">instruction set architecture</strong> (<strong class="bold">ISAs</strong>), that are useful beyond the context of asynchronous programming as well.</p>
			<p><a href="B20892_06.xhtml#_idTextAnchor113"><em class="italic">Chapter 6</em></a>, <em class="italic">Futures in Rust</em>, gives a short introduction and overview of futures, runtimes, and asynchronous programming in Rust.</p>
			<p><a href="B20892_07.xhtml#_idTextAnchor122"><em class="italic">Chapter 7</em></a>, <em class="italic">Coroutines and async/await</em>, is a chapter where you write your own coroutines that are simplified versions of the ones created by async/await in Rust today. We’ll write a few of them by hand and introduce a new syntax that allows us to programmatically rewrite what look like regular functions into the coroutines we wrote by hand.</p>
			<p><a href="B20892_08.xhtml#_idTextAnchor138"><em class="italic">Chapter 8</em></a>, <em class="italic">Runtimes, Wakers, and the Reactor-Executor Pattern</em>, introduces runtimes and runtime design. By iterating on the example we created in <a href="B20892_07.xhtml#_idTextAnchor122"><em class="italic">Chapter 7</em></a>, we’ll create a runtime for our coroutines that we’ll gradually improve. We’ll also do some experiments with our runtime once it’s done to better understand how it works.</p>
			<p><a href="B20892_09.xhtml#_idTextAnchor156"><em class="italic">Chapter 9</em></a>, <em class="italic">Coroutines, Self-Referential Structs, and Pinning</em>, is the chapter where we introduce self-referential structs and pinning in Rust. By improving our coroutines further, we’ll experience first-hand why we need something such as <code>Pin</code>, and how it helps us solve the problems we encounter.</p>
			<p><a href="B20892_10.xhtml#_idTextAnchor178"><em class="italic">Chapter 10</em></a>, <em class="italic">Create Your Own Runtime</em>, is the chapter where we finally put all the pieces together. We’ll improve the same example from the previous chapters further so we can run Rust futures, which will allow us to use the full power of async/await and asynchronous Rust. We’ll also do a few experiments that show some of the difficulties with asynchronous Rust and how we can best solve them.</p>
			<h1 id="_idParaDest-8"><a id="_idTextAnchor007"/>To get the most out of this book</h1>
			<p>You should have some prior programming experience and, preferably, some knowledge about Rust. Reading the free, and excellent, introductory book <em class="italic">The Rust Programming Language</em> (<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>) should give you more than enough knowledge about Rust to follow along since any advanced topics will be explained step by step.</p>
			<p>The ideal way to read this book is to have the book and a code editor open side by side. You should also have the accompanying repository available so you can refer to that if you encounter any issues.</p>
			<table id="table001" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Software/hardware covered in </strong><strong class="bold">the book</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Operating </strong><strong class="bold">system requirements</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Rust (version 1.51 or later)</p>
						</td>
						<td class="No-Table-Style">
							<p>Windows, macOS, or Linux</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>You need Rust installed. If you haven’t already, follow the instructions here: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>.</p>
			<p>Some examples will require you to use <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>) on Windows. If you’re following along on a Windows machine, I recommend that you enable WSL (<a href="https://learn.microsoft.com/en-us/windows/wsl/install">https://learn.microsoft.com/en-us/windows/wsl/install</a>) now and install Rust by following the instructions for installing Rust on WSL here: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>.</p>
			<p><strong class="bold">If you are using the digital version of this book, we advise you to type the code yourself or access the code from the book’s GitHub repository (a link is available in the next section). Doing so will help you avoid any potential errors related to the copying and pasting </strong><strong class="bold">of code.</strong></p>
			<p>The accompanying repository is organized in the following fashion:</p>
			<ul>
				<li>Code that belongs to a specific chapter is in that chapter’s folder (e.g., <code>ch01</code>).</li>
				<li>Each example is organized as a separate crate.</li>
				<li>The letters in front of the example names indicate in what order the different examples are presented in the book. For example, the <code>a-runtime</code> example comes before the <code>b-reactor-executor</code> example. This way, they will be ordered chronologically (at least by default on most systems).</li>
				<li>Some examples have a version postfixed with <code>-bonus</code>. These versions will be mentioned in the book text and often contain a specific variant of the example that might be interesting to check out but is not important to the topic at hand.</li>
			</ul>
			<h1 id="_idParaDest-9"><a id="_idTextAnchor008"/>Download the example code files</h1>
			<p>You can download the example code files for this book from GitHub at <a href="https://github.com/PacktPublishing/Asynchronous-Programming-in-Rust">https://github.com/PacktPublishing/Asynchronous-Programming-in-Rust</a>. If there’s an update to the code, it will be updated in the GitHub repository.</p>
			<p>We also have other code bundles from our rich catalog of books and videos available at <a href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a>. Check them out!</p>
			<h1 id="_idParaDest-10"><a id="_idTextAnchor009"/>Conventions used</h1>
			<p>There are a number of text conventions used throughout this book.</p>
			<p><code>Code in text</code>: Indicates code words in text, database table names, folder names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter handles. Here is an example: “So, now we have created our own async runtime that uses Rust’s <code>Futures</code>, <code>Waker</code>, <code>Context</code>, and <code>async/await</code>.”</p>
			<p>A block of code is set as follows:</p>
			<pre class="source-code">
pub trait Future {
    type Output;
    fn poll(&amp;mut self) -&gt; PollState&lt;Self::Output&gt;;
}</pre>			<p>When we wish to draw your attention to a particular part of a code block, the relevant lines or items are set in bold:</p>
			<pre class="source-code">
struct Coroutine0 {
    <strong class="bold">stack: Stack0,</strong>
    state: State0,
}</pre>			<p>Any command-line input or output is written as follows:</p>
			<pre class="console">
$ cargo run</pre>			<p class="callout-heading">Tips or important notes</p>
			<p class="callout">Appear like this.</p>
			<h1 id="_idParaDest-11"><a id="_idTextAnchor010"/>Get in touch</h1>
			<p>Feedback from our readers is always welcome.</p>
			<p><strong class="bold">General feedback</strong>: If you have questions about any aspect of this book, email us at <a href="mailto:customercare@packtpub.com">customercare@packtpub.com</a> and mention the book title in the subject of your message.</p>
			<p><strong class="bold">Errata</strong>: Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you have found a mistake in this book, we would be grateful if you would report this to us. Please visit <a href="http://www.packtpub.com/support/errata">www.packtpub.com/support/errata</a> and fill in the form.</p>
			<p><strong class="bold">Piracy</strong>: If you come across any illegal copies of our works in any form on the internet, we would be grateful if you would provide us with the location address or website name. Please contact us at <a href="mailto:copyright@packt.com">copyright@packt.com</a> with a link to the material.</p>
			<p><strong class="bold">If you are interested in becoming an author</strong>: If there is a topic that you have expertise in and you are interested in either writing or contributing to a book, please visit <a href="http://authors.packtpub.com">authors.packtpub.com</a>.</p>
			<h1 id="_idParaDest-12"><a id="_idTextAnchor011"/>Share your thoughts</h1>
			<p>Once you’ve read <em class="italic">Asynchronous Programming in Rust</em>, we’d love to hear your thoughts! Please <a href="https://packt.link/r/1805128132">click here to go straight to the Amazon review page</a> for this book and share your feedback.</p>
			<p>Your review is important to us and the tech community and will help us make sure we’re delivering excellent quality content.</p>
			<h1 id="_idParaDest-13"><a id="_idTextAnchor012"/>Download a free PDF copy of this book</h1>
			<p>Thanks for purchasing this book!</p>
			<p>Do you like to read on the go but are unable to carry your print books everywhere?</p>
			<p>Is your eBook purchase not compatible with the device of your choice?</p>
			<p>Don’t worry, now with every Packt book you get a DRM-free PDF version of that book at no cost.</p>
			<p>Read anywhere, any place, on any device. Search, copy, and paste code from your favorite technical books directly into your application.</p>
			<p>The perks don’t stop there, you can get exclusive access to discounts, newsletters, and great free content in your inbox daily</p>
			<p>Follow these simple steps to get the benefits:</p>
			<ol>
				<li>Scan the QR code or visit the link below</li>
			</ol>
			<p> </p>
			<div><div><img src="img/B20892_QR_Free_PDF.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a href="https://packt.link/free-ebook/9781805128137">https://packt.link/free-ebook/9781805128137</a></p>
			<p>2.	Submit your proof of purchase</p>
			<p>3.	That’s it! We’ll send your free PDF and other benefits to your email directly</p>
		</div>
	

		<div><h1 id="_idParaDest-14" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor013"/>Part 1:Asynchronous Programming Fundamentals</h1>
			<p>In this part, you’ll receive a thorough introduction to concurrency and asynchronous programming. We’ll also explore various techniques that programming languages employ to model asynchrony, examining the most popular ones and covering some of the pros and cons associated with each. Finally, we’ll explain the concept of OS-backed event queues, such as epoll, kqueue, and IOCP, detailing how system calls are used to interact with the operating system and addressing the challenges encountered in creating cross-platform abstractions like mio. This section comprises the following chapters:</p>
			<ul>
				<li><a href="B20892_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Concurrency and Asynchronous Programming: A Detailed Overview</em></li>
				<li><a href="B20892_02.xhtml#_idTextAnchor043"><em class="italic">Chapter 2</em></a>, <em class="italic">How Programming Languages Model Asynchronous Program Flow</em></li>
				<li><a href="B20892_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a><em class="italic">, Understanding OS-Backed Event Queues, System Calls and Cross Platform Abstractions</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
	</body></html>