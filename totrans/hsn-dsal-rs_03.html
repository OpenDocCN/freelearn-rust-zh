<html><head></head><body>
        

                            
                    <h1 class="header-title">Storing Efficiently</h1>
                
            
            
                
<p>With the foundation of the previous chapters in place, we can now move on to more architectural aspects of algorithms and data structures. Rust—with its ownership model—calls for considering lifetimes, memory placement, and mutability in their algorithmic design. In this chapter, you can look forward to learning about the following topics:</p>
<ul>
<li>Trade-offs considering speed and readability</li>
<li>Accessing heap and stack variables</li>
<li>How immutability influences design</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Heaps and stacks</h1>
                
            
            
                
<p>As we discussed in <a href="e07bf37e-f255-42ef-abbb-9f141dc5be61.xhtml">Chapter 1</a>, <em>Hello Rust!</em>, stack variables are preferred thanks to their low overhead and speed compared to heap-allocated data, which automatically introduces overhead thanks to the necessary heap pointer. For stack variables, Rust's types even allow for zero overhead structures, so no additional metadata is stored. The following snippet asserts that there are no additional bytes being used for arrays or user-defined types:</p>
<div><pre>use std::mem;<br/><br/>struct MyStruct {<br/>    a: u8,<br/>    b: u8,<br/>    c: u8<br/>}<br/><br/>fn main() {<br/>    assert_eq!(mem::size_of::&lt;MyStruct&gt;(), 3 * mem::size_of::&lt;u8&gt;());<br/>    assert_eq!(mem::size_of::&lt;[MyStruct; 2]&gt;(), 3 * mem::size_of::&lt;u8&gt;() * 2);<br/>}</pre></div>
<p>Consequently, the size of an instance of the <kbd>MyStruct</kbd> type is always going to be three bytes—perfectly suitable for placing it on the stack. Why is that good? In short, data locality. Instead of pointer dereferencing, the data is stored right at the point of execution, making it easy to cache and fast to access.</p>
<p>Types that don't have predictable sizes (such as <kbd>String</kbd> instances) require heap allocation, just like objects that are wrapped into <kbd>Rc</kbd>, <kbd>Cell</kbd>, <kbd>RefCell</kbd>, or <kbd>Box</kbd> instances. However, heap allocations and access come at a considerable cost, as minimizing those typically yields great performance improvements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sized and unsized</h1>
                
            
            
                
<p>For the compiler to translate written code into a binary format, it's necessary to know each type's size. As we discussed earlier, the size is important so that we can put other types <em>on top</em> when working on the stack, something that is easy if the size doesn't change with respect to the data it contains (a sized type). The best example for this is <kbd>u32</kbd>: it uses 32 bits (or 4 bytes), regardless of whether you store <kbd>0</kbd> or <kbd>10000900</kbd>.</p>
<p>This isn't the case when the type is unsized or dynamically sized, the best example being a <kbd>str</kbd>. Depending on the number of characters, this type's size will vary considerably, and which is why instances are usually encountered in the form of slices.</p>
<p>Slices are Rust's way of providing generic algorithms to all kinds of data types, and they will be discussed more in <a href="c6ebe545-0fc3-42fe-adf2-3a8d8fe3d501.xhtml"/><a href="04e371f3-13fa-4c73-9329-8074a080785a.xhtml">Chapter 12</a>, <em>Algorithms of the Standard Library</em>.</p>
<p>Slices work around the size issue by storing a fixed-size reference (<kbd>&amp;str</kbd>) to the heap-allocated value, along with its length in bytes. Similar to pointers, this is a fixed-size view into a previously-unsized value. Every time a pointer of some kind (<kbd>&amp;</kbd>, <kbd>Rc</kbd>, <kbd>Box</kbd>, <kbd>Cell</kbd>, and so on) is created, the reference is stored alongside the length and some (fixed size) metadata. The knowledge of sized versus unsized is especially useful when the type is previously unknown—when working with Rust's generics, for example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generics</h1>
                
            
            
                
<p>Rust supports generics and even allows us to enforce the implementation of certain traits. These constraints can either come as a where clause attached to the function definition or with a colon in the generic type declaration:</p>
<pre>fn my_generic_func&lt;T: MyTrait&gt;(t: T) {<br/>    // code <br/>}<br/><br/>// ... is the same as <br/><br/>fn my_generic_func &lt;T&gt;(t: T) where T: MyTrait {<br/>    // code<br/>}<br/><br/>// but better use in 2018 and beyond<br/><br/>fn my_generic_func(t: impl MyTrait) {<br/>    // code<br/>}</pre>
<p>Additionally, the 2018 <kbd>impl Trait</kbd> syntax simplifies single-trait requirements (to do static instead of dynamic dispatch) for input and return parameters, thereby eliminating the need for a <kbd>Box</kbd> or lengthy type constraints (such as <kbd>MyTrait</kbd> in the preceding snippet). Unless multiple trait implementations are required (for example, <kbd>fn f(x: T) where T: Clone + Debug + MyTrait {}</kbd>), the <kbd>impl Trait</kbd> syntax allows us to put them where they matter, which is into the parameter list:</p>
<pre>fn my_generic_func&lt;T&gt;(t: T) {<br/>    // code <br/>}<br/><br/>// ... is the same as <br/><br/>fn my_generic_func &lt;T: Sized&gt;(t: T) {<br/>    // code<br/>}</pre>
<p>When working with generics, the situation is a bit more complex. Type parameters are <kbd>Sized</kbd> by default (see the preceding snippet), which means that they will not match unsized types. To match those as well, the special <kbd>?Sized</kbd> type constraint can be used. This snippet also shows the required change to passing in a reference:</p>
<pre>fn my_generic_func &lt;T: ?Sized&gt;(t: &amp;T) {<br/>    // code<br/>}</pre>
<p>However, any type of heap-allocated reference will incur an extra step to access the contained value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Accessing the box</h1>
                
            
            
                
<p>An extra step doesn't sound like much, but it has considerable consequences. This trade-off for easily sharing ownership across various functions or threads removes the ability to put as much data as possible into the CPU's cache, since the pointer makes any data locality difficult. Heap allocations themselves are expensive operations and reducing those will already provide a major speedup.</p>
<p>Furthermore, the compiler cannot deallocate a boxed value if it's still referenced in some places—a problem that occurs especially if the program is large and complex. Similar to orphaned objects in C# or Java, a saved <kbd>Rc</kbd> reference can easily be forgotten, creating a memory leak. Therefore, it's recommended to use heap memory only when required.</p>
<p>One principle piece of advice that requires a boxed value in Rust is to "favor object composition over class inheritance" (Gang of Four 1995:20). In the absence of class inheritance, the choice is obviously to use object composition. Considering that you should also "program to an interface not to an implementation" (ibid), there is often a strong wish to put a reference to a trait inside of a <kbd>struct</kbd> instead of directly working with the implementation.</p>
<p>To apply this architecture in Rust, the language requires us to put a trait's implementation into a <kbd>Box&lt;dyn TheTrait&gt;</kbd>, making it more difficult to handle, test, and reason about. This <kbd>trait</kbd> object requires the compiler to rely on dynamic dispatch, which is considerably slower than the default static dispatch.</p>
<p>Static and dynamic dispatch are the two major ways of calling functions in many programming languages, including Rust. While for static dispatch functions, locations are known at compile time, dynamic dispatch functions are only known at runtime and have to be looked up in a <strong>vtable</strong> that points to the actual address. Both have their merits, so be intentional with their use.</p>
<p>Other than generics, there is no default solution to this issue. The <kbd>impl Trait</kbd> addition of Rust 2018 alleviates this issue for function parameters and return values, but cannot be used for field types.</p>
<p>So far, it looks like the best choice is to use concrete types instead of traits to avoid multiple dereference operations—as long as refactoring on change seems to be doable. If you create a library, generics are a better way to go for performance and flexibility.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Copying and cloning</h1>
                
            
            
                
<p>In <a href="e07bf37e-f255-42ef-abbb-9f141dc5be61.xhtml">Chapter 1</a>, <em>Hello Rust!,</em> we discussed <kbd>Send</kbd>, a marker trait that allows a type to be "sent" across multiple threads. Something that's similar but less complex is local moving, which commonly occurs in a program—for example, when you pass a variable into a function.</p>
<p>Copying and cloning, on the other hand, happen on different occasions. When a variable is assigned to another variable, the compiler will typically copy the value implicitly, which can be done safely and cheaply for stack-allocated variables.</p>
<div><kbd>Copy</kbd> is an implicit, bitwise copy of the value of a variable. If that variable is a pointer, the memory responsibility becomes ambiguous (who takes care of freeing?) and compilation will fail. This is where <kbd>Clone</kbd> comes in. The trait requires an explicit implementation of the <kbd>clone()</kbd> function to provide an appropriate copy of the type.</div>
<p>Cloning is always a deep copy of a type—implemented either manually (with the <kbd>Clone</kbd> trait) or by using the <kbd>derive</kbd> macro. Then, cloning is only a matter of invoking the <kbd>clone()</kbd> function, an operation that is not necessarily cheap. The following snippet illustrates these two operations:</p>
<pre>let y = 5;<br/>let x = y;                 // Copy<br/><br/>let a = Rc::new(5);<br/>let b = a.clone();         // Clone</pre>
<p>The regular usage of these traits and operations is usually intuitive and there isn't much that can go wrong. Usually the compiler clearly states the need for a <kbd>Copy</kbd> implementation.</p>
<p>It's recommended to derive or implement <kbd>Copy</kbd> wherever possible, but be mindful of breaking changes. Adding the trait is a non-intrusive action, whereas removing the trait will potentially break other people's code.</p>
<p>While copying and cloning are great for providing ownership to multiple scopes, they are required when working with immutable storage.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Immutable storage</h1>
                
            
            
                
<p>Garbage collectors simplified mutability considerably and, as a consequence, many of these languages don't need a specific modifier for mutability. While this garbage collection mechanism comes at the expense of runtime with frequent cleanups, not having to care about making variables mutable is very convenient. It lets developers focus on the logic they are implementing instead.</p>
<p>So why did Rust (and many functional languages) bring back this concept?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">States and reasoning</h1>
                
            
            
                
<p>The state of an object is essentially the current values that its fields have at any given time. Changing this state is done by the object itself via messages on defined behavior (called methods) according to object-orientation principles. These state changes require mutability.</p>
<p>Throughout their lifetimes, most objects change their states multiple times, and since this happens at runtime, we find ourselves often looking at an object's debug print in frustration, thinking, "How did this value get here?"</p>
<p>Immutable data structures remedy this by making it impossible to change their contents, so any time you would look at an object, it has exactly the right values. It's a known fact that the majority of variables don't need to be mutable, and unless there is a resource constraint, creating another instance of the object with its new state is recommended. This principle, called <strong>copy-on-write</strong>, improves readability for better maintenance.</p>
<p>A popular type that employs copy-on-write is the <kbd>String</kbd>—in almost any language. The type wraps a byte array and interprets it using a provided character set (usually UTF-8), and if you modify a character, this array is copied and saved with the changes made. This is done so often that <kbd>String</kbd> allocations are a common performance pitfall.</p>
<p>In the Rust standard library, there is a <kbd>Cow</kbd> enumeration (<kbd>std::borrow::Cow</kbd>) that lazily clones a contained reference whenever mutation or ownership is requested. For a great example, check out the Cow documentation: <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">https://doc.rust-lang.org/std/borrow/enum.Cow.html</a>.</p>
<p>The principle of copy-on-write can also be found in filesystems to create snapshots (for example, in ZFS or BRTFS) and provides the benefits of both immutability and mutability at the cost of runtime resources. It's a trade-off between maintainability and absolute performance. A similar concept is employed by persistent data structures, which can be partially or fully persistent and still be immutable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Concurrency and performance</h1>
                
            
            
                
<p>Having code that is easier to reason about and where the state cannot be changed is even more important in multithreaded scenarios. This prevents so-called anomalies (or side effects) where the state of an object is changed outside a dependent thread.</p>
<p>Locks are generally made to change the state of a shared object—they secure critical sections, which only a single thread can modify at any given time. Other threads have to "line up" and wait for the lock to be released to access the part as well. In Rust, this is called a <strong>mutex</strong>.</p>
<p>Locks and mutex zones are bad for the following reasons:</p>
<ul>
<li>They have to be in the right order (acquired and released).</li>
<li>What happens when a thread panics in a mutex zone?</li>
<li>They are hard to integrate seamlessly into the part of the program that they protect.</li>
<li>They are a bottleneck for performance.</li>
</ul>
<p>Immutability is a simple way to avoid all of these, and there are many immutable data structure crates available, including one with persistent data structures called <strong>Rust Persistent Data Structures</strong> (<strong>RPDS</strong>) (<a href="https://crates.io/crates/rpds">https://crates.io/crates/rpds</a>), that utilize a copy-on-write approach with versioning to capture state changes. Since these changes build on top of each other, threads can fully read one consistent object state at a time without having to wait or acquire a lock.</p>
<div><strong>Lock-free data structures</strong> are a specialized version of data structures that are very challenging to implement. These data structures use atomic operations to modify important parts (for example, the head pointer in a stack) and thereby achieve excellent performance without locking caveats.<br/>
<strong>Persistent data structures</strong> are a take on creating data structures that are as efficient and mutable as their traditional counterparts, but better suited for concurrency. This is achieved by keeping the original data immutable and storing versioned change sets.</div>
<p>The idea of immutable data is best thought of in the context of functional programming. Functional programming is built on the principle of mathematical functions. A function is a relation of two sets of data (typically <em>X</em> and <em>Y</em>), where each element of <em>X</em> has exactly one element in <em>Y</em> that it maps to using the <em>f</em> function ( in short: <em><img class="fm-editor-equation" src="img/db4b77af-b0e4-4a71-8788-925b5d520ea8.png" style="width:3.83em;height:1.17em;"/></em>where <em><img class="fm-editor-equation" src="img/44f9059b-3a25-4d99-ad23-b9c0c48d3edc.png" style="width:6.92em;height:1.33em;"/>).</em></p>
<p>As a consequence, the input data, <em>X</em>, will not be changed to produce output data, <em>Y</em>, making it easy to run the <em>f</em> function in parallel. The downside is the increased cost at runtime: regardless of the operation, whether it's only to flip a bit on the input data or to overhaul everything, the result is always a full copy.</p>
<p>To reduce this inefficiency, the Gang of Four's decorator pattern on <em>X</em>'s iterator can be used to stack up only the changes and execute them on every call, reducing runtime complexity and avoiding multiple copies of the output data. A problem that remains is that if the input and the output are large, a lot of memory is required. This is a tricky situation and can only be avoided by the programmer thinking thoroughly about decomposing the function better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Moving one level above the details of code, this chapter discusses considerations when designing and using types. Rust's differentiation between stack- and heap-allocated variables in code provides a level of control that should be used to improve performance and API flexibility. <kbd>Sized</kbd>, a marker trait for mostly stack-allocated values, is the default for generic type parameters and can be relaxed by applying the <kbd>?Sized</kbd> constraint instead.</p>
<p>When working with more object-oriented architectures, trait objects become a way to "work with interfaces" instead of specific implementations. However, they come at a performance cost, that is, dynamic dispatch, another trade-off between maintainability and performance.</p>
<p>Other than moving, Rust can copy or clone variables when necessary. Copy performs a deep copy in the case of sized values; unsized values require a reference that has to be cloned instead. Using these operations is often encountered when working with immutable data types in a principle called copy-on-write. Choosing whether we are able to reason about the object's state at any given time and avoiding data race conditions, but having to create a copy for each change, is another important trade-off when designing data structures.</p>
<p>This trade-off will become apparent in the next chapter, where we will start working with lists, such as the singly-linked list, doubly-linked list, and the dynamic array.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ul>
<li>How are <kbd>Sized</kbd> types different from other types?</li>
<li>How does <kbd>Clone</kbd> differ from <kbd>Copy</kbd>?</li>
<li>What are the main drawbacks of immutable data structures?</li>
<li>How can applications benefit from immutable data structures?</li>
<li>Think about an immutable list that you want to work on—how would you distribute it across multiple threads?</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>For more information on the topics that are covered in this chapter, check out the following links:</p>
<ul>
<li><a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a></li>
<li><a href="https://doc.rust-lang.org/std/mem/fn.size_of.html">https://doc.rust-lang.org/std/mem/fn.size_of.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Functional_programming">https://en.wikipedia.org/wiki/Functional_programming</a></li>
<li><a href="https://en.wikipedia.org/wiki/Persistent_data_structure">https://en.wikipedia.org/wiki/Persistent_data_structure</a></li>
</ul>


            

            
        
    </body></html>