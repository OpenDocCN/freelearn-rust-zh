["```rs\nenum Result<Y, N> \n{ \n    Ok(Y), \n    Err(N), \n} \n```", "```rs\nenum Option<T> \n{ \n    Some_Type(T), \n    None \n} \nlet varname: Option<f32> = Some_Type(3.1416f32); \n```", "```rs\nfn defined_type_fn(x: i32) \n{ \n    // do something with x \n} \n```", "```rs\nfn generic_type_fn<T>(x: T) \n{ \n    // do something with x \n} \n```", "```rs\nvoid generic_type_method<T>(T x) \n{ \n    // do something \n} \n```", "```rs\nfn generic_type_fn<T>(x: T, y: T) \n{ \n    // do something \n} \n```", "```rs\nfn generic_types_fn<T, U, V>(x: T, y: U, z: V) \n{ \n    // do something \n} \n```", "```rs\nfn multiply(a: i32, b: i32) -> i32 \n{ \n    return a * b; \n} \n```", "```rs\nfn multiply_generic<T>(a: T, b: T) -> T \n{ \n    return a * b; \n} \n```", "```rs\nBinary operation '*' cannot be applied to type 'T'; an implementation of 'std::ops::Mul' might be missing for 'T'\n```", "```rs\nfn multiply_generic<T: Mul<Output = T>>(a: T, b: T) -> T \n{\n  return a * b; \n}\n```", "```rs\nfn multiply_generic<T>(a: T, b: T) -> T \n  where T: Mul<Output = T> \n{\n  return a * b; \n}\n```", "```rs\n#![feature(core_intrinsics)] \nfn display_type<T>(_: &T)\n{\n  let typename = unsafe {std::intrinsics::type_name::<T>()};\n  println!(\"{}\", typename);\n}\n\nfn main()\n{\n  display_type(&3.14f32);\n  display_type(&1i32);\n  display_type(&1.555);\n  display_type(&(vec!(1,3,5)));\n}\n```", "```rs\n#[test]\nfn do_check()\n{\n  // perform check \n}\n```", "```rs\nimpl MyImpl\n{\n  fn reference_name (&self) ... \n}\n```", "```rs\nimpl <T> MyGenericImpl<T>\n{\n  fn reference_name(&self) ... \n}\n```", "```rs\nimpl<'a> MyFunction<'a>(varname: &'a as i32) {...}\n```", "```rs\n// mylib.h \nint myFunction(int a, int b, float c);\n\n// mylib.c\n#include \"mylib.h\"\nint myFunction(int a, int b, float c)\n{\n  // implement the code \n  return some_value; \n}\n\n// myotherfile.c \n#include \"mylib.h\"\nint some_function()\n{\n  int value = myFunction(1, 2, 3.14f); \n  return value; \n}\n```", "```rs\nstruct Perimeter \n{\n  side_one: i32,\n  side_two: i32, \n}\n\nstruct Oval \n{\n  radius: f32,\n  height: f32,\n}\n```", "```rs\ntrait TraitName \n{ \n  fn function_name(&self) -> return_type; \n}\n```", "```rs\ntrait CalcPerimeter\n{\n  fn calc_perimeter(&self) -> i32; \n}\n\ntrait CalcArea \n{\n  fn calc_area(&self) -> f32; \n}\n```", "```rs\nimpl SomeImplement\n{ \n  ...\n}\n```", "```rs\nimpl SomeImplement for MyStruct \n{\n  ...\n}\n```", "```rs\nimpl CalcPerimeter for Perimeter \n{ \n  fn calc_perimeter(&self) -> i32 \n  {\n    self.side_one * 2 + self.side_two * 2 \n  }\n}\n```", "```rs\nimpl CalcArea for Oval\n{ \n  fn calc_area(&self) -> f32 \n  { \n    3.1415927f32 * self.radius * self.height \n  }\n}\n```", "```rs\nfn main() \n{ \n  let peri = Perimeter \n  {\n    side_one: 5, side_two: 12 };\n    println!(\"Side 1 = 5, Side 2 = 12, Perimeter = {}\", \n              peri.calc_perimeter());\n    let area = Oval \n    {\n      radius: 5.1f32,\n      height: 12.3f32\n    };\n    println!(\"Radius = 5.1, Height = 12.3, Area = {}\", \n              area.calc_area()); }\n```", "```rs\nstruct Perimeter { side_one: i32, side_two: i32, } \nstruct Oval { radius: f32, height: f32, }\n```", "```rs\nstruct Shape<T> { line_one: T, line_two: T, }\n```", "```rs\ntrait Calculate<T> { fn calc(&self) -> T; }\n```", "```rs\nimpl Calculate<i32> for Shape<i32> \n{ \n  fn calc(&self) -> i32\n  {\n    self.line_one * 2 + self.line_two * 2 \n  }\n}\n```", "```rs\nimpl<T> Calculate<T> for Shape<T> where T: Mul<Output = T>\n```", "```rs\nfn main() \n{\n  let peri = Shape\n  {\n    line_one: 5,\n    line_two: 12\n  };\n  println!(\"line_one = 5, line_two = 12, Perimeter = {}\", \n            peri.calc ()); \n}\n```", "```rs\nimpl Calculate<f32> for Shape<f32> \n{\n  fn calc(&self) -> f32 \n  {\n    3.1415927f32 * self.line_one * self.line_two\n  } \n}\n```", "```rs\nfn my_multiply<T: Mul<Output = T>>(a: T, b: T) -> T { return a * b; }\n```", "```rs\nextern crate num; \nuse std::ops::{Add, Mul}; \nuse num::FromPrimitive;\n```", "```rs\nimpl<T> Calculate<T> for Shape<T> \n  where T: Copy + FromPrimitive + Add<Output = T> + \n  Mul<Output = T> \n{\n  fn calc(&self) -> T {\n    let two = T::from_u8(2).expect(\"Unable to create a value of 2\");\n    self.line_one * two + self.line_two * two\n  } \n}\n```", "```rs\n[dependencies] \nnum = \"*\"\n```", "```rs\ntrait MyTrait \n{\n  fn test_code(&self) -> bool;\n  fn self_test_code(&self) -> bool { self.test_code() } }\n```", "```rs\nstruct UseFirstTime; \nimpl MyTrait for UseFirstTime \n{\n  fn is_done(&self) -> bool \n  {\n    println!(\"UseFirstTime.is_done\"); \n    true\n  } \n}\n```", "```rs\nstruct OverrideFirstTime;\nimpl MyTrait for OverrideFirstTime \n{\n  fn is_done(&self) -> bool \n  {\n    println!(\"OverrideFirstTime.is_done\");\n    true\n  }\n  fn is_not_done(&self) -> bool \n  {\n    println!(\"OverrideFirstTime.is_not_done\");\n    true\n  }\n}\n```", "```rs\ntrait One \n{\n  fn one(&self); \n}\ntrait OneTwo : One \n{\n  fn onetwo(&self); \n}\n```", "```rs\nstruct Three; \nimpl One for Three \n{ \n  fn one(&self) \n  {\n    println!(\"one\");\n  }\n}\nimpl OneTwo for Three \n{\n  fn onetwo(&self) \n  {\n    println!(\"onetwo\");\n  } \n}\n```", "```rs\ncall_some_method(some_value);\n```", "```rs\nlet m = MyStruct {a: 3, b: 4, c: 1, d: 4}; m.call_some_method();\n```", "```rs\ntrait StaticObject \n{ \n  fn static_method(&self) -> String; \n}\n\nimpl StaticObject for u8 \n{\n  fn static_method(&self) -> String {format!(\"u8 : {}, \", *self)} \n} \n\nimpl StaticObject for String \n{ \n  fn static_method(&self) -> String {format!(\"string : {}\", *self)} \n} \n\nfn display_code<T: StaticObject>(data : T) \n{\n  println!(\"{}\", data.static_method()); \n} \n\nfn main() \n{\n  let test_one = 8u8;\n  let test_two = \"Some text\".to_string();\n  display_code(test_one);\n  display_code(test_two); \n}\n```", "```rs\nfn display_code<T: StaticObject>(data: T) \n{\n  println!(\"{}\", data.static_method()); \n}\n```", "```rs\nfn display_code(data : &DynamicObject) \n{\n  println!(\"{}\", data.dynamic_method()); \n}\n```", "```rs\ndisplay_code(test_one);\n```", "```rs\ndisplay_code(&test_one as &DynamicObject);\n```", "```rs\nlet my_vec = vec![1,3,5,7,9]; \nlet dupe = &my_vec as &Clone;\n```"]