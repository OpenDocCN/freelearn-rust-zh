["```rs\n1   use std::{error, fmt, io, num, result};\n2   use std::fs::File;\n3   use std::io::{BufReader, Read};\n4 \n5   #[derive(Debug)]\n6   // This is going to be our custom Error type\n7   enum AgeReaderError {\n8     Io(io::Error),\n9     Parse(num::ParseIntError),\n10    NegativeAge(),\n11  }\n12 \n13  // It is common to alias Result in an Error module\n14  type Result<T> = result::Result<T, AgeReaderError>;\n15 \n16  impl error::Error for AgeReaderError {\n17    fn description(&self) -> &str {\n18      // Defer to the existing description if possible\n19      match *self {\n20      AgeReaderError::Io(ref err) => err.description(),\n21      AgeReaderError::Parse(ref err) => err.description(),\n22      // Descriptions should be as short as possible\n23      AgeReaderError::NegativeAge() => \"Age is negative\",\n24      }\n25    }\n26 \n27    fn cause(&self) -> Option<&error::Error> {\n28      // Return the underlying error, if any\n29      match *self {\n30        AgeReaderError::Io(ref err) => Some(err),\n31        AgeReaderError::Parse(ref err) => Some(err),\n32        AgeReaderError::NegativeAge() => None,\n33      }\n34    }\n35  }\n36 \n37  impl fmt::Display for AgeReaderError {\n38    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n39      // Write a detailed description of the problem\n40      match *self {\n41        AgeReaderError::Io(ref err) => write!(f, \"IO error: {}\", \n           err),\n42        AgeReaderError::Parse(ref err) => write!(f, \"Parse \n           error: {}\", err),\n43        AgeReaderError::NegativeAge() => write!(f, \"Logic error: \n           Age cannot be negative\"),\n44      }\n45    }\n46  }\n47 \n48  // Implement From<T> for every sub-error\n49  impl From<io::Error> for AgeReaderError {\n50    fn from(err: io::Error) -> AgeReaderError {\n51    AgeReaderError::Io(err)\n52    }\n53  }\n54 \n55  impl From<num::ParseIntError> for AgeReaderError {\n56    fn from(err: num::ParseIntError) -> AgeReaderError {\n57    AgeReaderError::Parse(err)\n58    }\n59  }\n60 \n61  fn main() {\n62    // Assuming a file called age.txt exists\n63    const FILENAME: &str = \"age.txt\";\n64    let result = read_age(FILENAME);\n65    match result {\n66      Ok(num) => println!(\"{} contains the age {}\", FILENAME, \n         num),\n67      Err(AgeReaderError::Io(err)) => eprintln!(\"Failed to open \n         the file {}: {}\", FILENAME, err),\n68      Err(AgeReaderError::Parse(err)) => eprintln!(\n69       \"Failed to read the contents of {} as a number: {}\",\n70        FILENAME, err\n71         ),\n72      Err(AgeReaderError::NegativeAge()) => eprintln!(\"The age in \n         the file is negative\"),\n73      }\n74  }\n75 \n76  // Read an age out of a file\n77  fn read_age(filename: &str) -> Result<i32> {\n78    let file = File::open(filename)?;\n79    let mut buf_reader = BufReader::new(file);\n80    let mut content = String::new();\n81    buf_reader.read_to_string(&mut content)?;\n82    let age: i32 = content.trim().parse()?;\n83    if age.is_positive() {\n84      Ok(age)\n85    } else {\n86      Err(AgeReaderError::NegativeAge())\n87    }\n88  }\n```", "```rs\ntype Result<T> = result::Result<T, AgeReaderError>;\n```", "```rs\nfn read_age(filename: &str) -> Result<i32> { ... }\n```", "```rs\nAgeReaderError::Io(ref err) => err.description()\n```", "```rs\nmatch result {\n    Ok(num) => println!(\"{} contains the age {}\", FILENAME, num),\n    Err(AgeReaderError::Io(err)) => eprintln!(\"Failed to open the file \n    {}: {}\", FILENAME, err),\n    Err(AgeReaderError::Parse(err)) => eprintln!(\n        \"Failed to read the contents of {} as a number: {}\",\n        FILENAME, err\n    ),\n    Err(AgeReaderError::NegativeAge()) => eprintln!(\"The age in the file is negative\"),\n}\n```", "```rs\nmod error;\npub use error::Error;\n```", "```rs\nlog = \"0.4.1\"\nenv_logger = \"0.5.3\"\n```", "```rs\n1   extern crate env_logger;\n2   #[macro_use]\n3   extern crate log;\n4   use log::Level;\n5 \n6   fn main() {\n7     // env_logger's priority levels are:\n8     // error > warn > info > debug > trace\n9     env_logger::init();\n10    // All logging calls log! in the background\n11    log!(Level::Debug, \"env_logger has been initialized\");\n12 \n13    // There are convenience macros for every logging level \n       however\n14    info!(\"The program has started!\");\n15 \n16    // A log's target is its parent module per default \n17    // ('logging' in our case, as we're in a binary)\n18    // We can override this target however:\n19    info!(target: \"extra_info\", \"This is additional info that \n       will only show if you \\\n20    activate info level logging for the extra_info target\");\n21 \n22    warn!(\"Something that requires your attention happened\");\n23 \n24    // Only execute code if logging level is active\n25    if log_enabled!(Level::Debug) {\n26    let data = expensive_operation();\n27    debug!(\"The expensive operation returned: \\\"{}\\\"\", data);\n28    }\n29 \n30    error!(\"Something terrible happened!\");\n31  }\n32 \n33  fn expensive_operation() -> String {\n34    trace!(\"Starting an expensive operation\");\n35    let data = \"Imagine this is a very very expensive \n       task\".to_string();\n36    trace!(\"Finished the expensive operation\");\n37    data\n38  }\n```", "```rs\nerror > warn > info > debug > trace\n```", "```rs\n    std::panic::set_hook(Box::new(|e| {\n        println!(\"Oh noes, something went wrong D:\");\n        println!(\"{:?}\", e);\n    }));\n    panic!(\"A thing broke\");\n```", "```rs\nlog = \"0.4.1\"\n```", "```rs\n1   #[macro_use]\n2   extern crate log;\n3 \n4   use log::{Level, Metadata, Record};\n5   use std::fs::{File, OpenOptions};\n6   use std::io::{self, BufWriter, Write};\n7   use std::{error, fmt, result};\n8   use std::sync::RwLock;\n9   use std::time::{SystemTime, UNIX_EPOCH};\n10 \n11  // This logger will write logs into a file on disk\n12  struct FileLogger {\n13    level: Level,\n14    writer: RwLock<BufWriter<File>>,\n15  }\n16 \n17  impl log::Log for FileLogger {\n18    fn enabled(&self, metadata: &Metadata) -> bool {\n19      // Check if the logger is enabled for a certain log level\n20      // Here, you could also add own custom filtering based on \n         targets or regex\n21      metadata.level() <= self.level\n22    }\n23 \n24    fn log(&self, record: &Record) {\n25      if self.enabled(record.metadata()) {\n26        let mut writer = self.writer\n27          .write()\n28          .expect(\"Failed to unlock log file writer in write \n             mode\");\n29        let now = SystemTime::now();\n30        let timestamp = now.duration_since(UNIX_EPOCH).expect(\n31         \"Failed to generate timestamp: This system is \n            operating before the unix epoch\",\n32        );\n33        // Write the log into the buffer\n34        write!(\n35          writer,\n36          \"{} {} at {}: {}\\n\",\n37          record.level(),\n38          timestamp.as_secs(),\n39          record.target(),\n40          record.args()\n41        ).expect(\"Failed to log to file\");\n42      }\n43      self.flush();\n44    }\n45 \n46    fn flush(&self) {\n47      // Write the buffered logs to disk\n48      self.writer\n49        .write()\n50        .expect(\"Failed to unlock log file writer in write \n               mode\")\n51        .flush()\n52        .expect(\"Failed to flush log file writer\");\n53    }\n54  }\n55 \n56  impl FileLogger {\n57    // A convenience method to set everything up nicely\n58    fn init(level: Level, file_name: &str) -> Result<()> {\n59      let file = OpenOptions::new()\n60        .create(true)\n61        .append(true)\n62        .open(file_name)?;\n63      let writer = RwLock::new(BufWriter::new(file));\n64      let logger = FileLogger { level, writer };\n65      // set the global level filter that log uses to optimize \n         ignored logs\n66      log::set_max_level(level.to_level_filter());\n67      // set this logger as the one used by the log macros\n68      log::set_boxed_logger(Box::new(logger))?;\n69      Ok(())\n70    }\n71  }\n```", "```rs\n73  // Our custom error for our FileLogger\n74  #[derive(Debug)]\n75  enum FileLoggerError {\n76    Io(io::Error),\n77    SetLogger(log::SetLoggerError),\n78  }\n79 \n80  type Result<T> = result::Result<T, FileLoggerError>;\n81  impl error::Error for FileLoggerError {\n82    fn description(&self) -> &str {\n83      match *self {\n84        FileLoggerError::Io(ref err) => err.description(),\n85        FileLoggerError::SetLogger(ref err) => \n           err.description(),\n86      }\n87    }\n88  \n89    fn cause(&self) -> Option<&error::Error> {\n90      match *self {\n91        FileLoggerError::Io(ref err) => Some(err),\n92        FileLoggerError::SetLogger(ref err) => Some(err),\n93      }\n94    }\n95  }\n96 \n97  impl fmt::Display for FileLoggerError {\n98    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n99      match *self {\n100       FileLoggerError::Io(ref err) => write!(f, \"IO error: {}\", \n           err),\n101       FileLoggerError::SetLogger(ref err) => write!(f, \"Parse \n           error: {}\", err),\n102     }\n103   }\n104 }\n105 \n106 impl From<io::Error> for FileLoggerError {\n107   fn from(err: io::Error) -> FileLoggerError {\n108     FileLoggerError::Io(err)\n109   }\n110 }\n111 \n112 impl From<log::SetLoggerError> for FileLoggerError {\n113   fn from(err: log::SetLoggerError) -> FileLoggerError {\n114     FileLoggerError::SetLogger(err)\n115   }\n116 }\n```", "```rs\n118 fn main() {\n119   FileLogger::init(Level::Info, \"log.txt\").expect(\"Failed to \n       init \n      FileLogger\");\n120   trace!(\"Beginning the operation\");\n121   info!(\"A lightning strikes a body\");\n122   warn!(\"It's moving\");\n123   error!(\"It's alive!\");\n124   debug!(\"Dr. Frankenstein now knows how it feels to be god\");\n125   trace!(\"End of the operation\");\n126 }\n```", "```rs\nfn flush(&self) {}\n```", "```rs\nif self.enabled(record.metadata()) {\n```", "```rs\n    fn init(level: Level, file_name: &str) -> Result<()> {\n        let file = OpenOptions::new()\n            .create(true)\n            .append(true)\n            .open(file_name)?;\n        let writer = RwLock::new(BufWriter::new(file));\n        let logger = FileLogger { level, writer };\n        log::set_max_level(level.to_level_filter());\n        log::set_boxed_logger(Box::new(logger))?;\n        Ok(())\n    }\n```", "```rs\nFileLogger::init(Level::Info, \"log.txt\").expect(\"Failed to init FileLogger\");\n```", "```rs\n1   use std::fmt::Debug;\n2 \n3   struct CustomSmartPointer<D>\n4   where\n5   D: Debug,\n6   {\n7   data: D,\n8   }\n9 \n10  impl<D> CustomSmartPointer<D>\n11  where\n12  D: Debug,\n13  {\n14    fn new(data: D) -> Self {\n15    CustomSmartPointer { data }\n16    }\n17  }\n18 \n19  impl<D> Drop for CustomSmartPointer<D>\n20  where\n21  D: Debug,\n22  {\n23    // This will automatically be called when a variable is \n       dropped\n24    // It cannot be called manually\n25    fn drop(&mut self) {\n26    println!(\"Dropping CustomSmartPointer with data `{:?}`\", \n       self.data);\n27    }\n28  }\n29 \n30  fn main() {\n31    let a = CustomSmartPointer::new(\"A\");\n32    let b = CustomSmartPointer::new(\"B\");\n33    let c = CustomSmartPointer::new(\"C\");\n34    let d = CustomSmartPointer::new(\"D\");\n35 \n36    // The next line would cause a compiler error,\n37    // as destructors cannot be explicitely called\n38    // c.drop();\n39 \n40    // The correct way to drop variables early is the following:\n41    std::mem::drop(c);\n42  }\n```", "```rs\npub fn drop<T>(_x: T) { }\n```", "```rs\n1   use std::ops::Deref;\n2 \n3   // This represents a low level, close to the metal OS feature \n     that\n4   // needs to be locked and unlocked in some way in order to be   \n     accessed\n5   // and is usually unsafe to use directly\n6   struct SomeOsSpecificFunctionalityHandle;\n7 \n8   // This is a safe wrapper around the low level struct\n9   struct SomeOsFunctionality<T> {\n10    // The data variable represents whatever useful information\n11    // the user might provide to the OS functionality\n12    data: T,\n13    // The underlying struct is usually not savely movable,\n14    // so it's given a constant address in a box\n15    inner: Box<SomeOsSpecificFunctionalityHandle>,\n16  }\n17 \n18  // Access to a locked SomeOsFunctionality is wrapped in a guard\n19  // that automatically unlocks it when dropped\n20  struct SomeOsFunctionalityGuard<'a, T: 'a> {\n21    lock: &'a SomeOsFunctionality<T>,\n22  }\n23 \n24  impl SomeOsSpecificFunctionalityHandle {\n25    unsafe fn lock(&self) {\n26      // Here goes the unsafe low level code\n27    }\n28    unsafe fn unlock(&self) {\n29      // Here goes the unsafe low level code\n30    }\n31  }\n```", "```rs\n\n33  impl<T> SomeOsFunctionality<T> {\n34    fn new(data: T) -> Self {\n35      let handle = SomeOsSpecificFunctionalityHandle;\n36        SomeOsFunctionality {\n37          data,\n38          inner: Box::new(handle),\n39        }\n40    }\n41 \n42    fn lock(&self) -> SomeOsFunctionalityGuard<T> {\n43      // Lock the underlying resource.\n44      unsafe {\n45        self.inner.lock();\n46      }\n47 \n48      // Wrap a reference to our locked selves in a guard\n49      SomeOsFunctionalityGuard { lock: self }\n50    }\n51  }\n52 \n53  // Automatically unlock the underlying resource on drop\n54  impl<'a, T> Drop for SomeOsFunctionalityGuard<'a, T> {\n55    fn drop(&mut self) {\n56      unsafe {\n57        self.lock.inner.unlock();\n58      }\n59    }\n60  }\n61 \n62  // Implementing Deref means we can directly\n63  // treat SomeOsFunctionalityGuard as if it was T\n64  impl<'a, T> Deref for SomeOsFunctionalityGuard<'a, T> {\n65    type Target = T;\n66 \n67    fn deref(&self) -> &T {\n68    &self.lock.data\n69    }\n70  }\n\n```", "```rs\n72  fn main() {\n73    let foo = SomeOsFunctionality::new(\"Hello World\");\n74    {\n75      // Locking foo returns an unlocked guard\n76      let bar = foo.lock();\n77      // Because of the Deref implementation on the guard,\n78      // we can use it as if it was the underlying data\n79      println!(\"The string behind foo is {} characters long\", \n         bar.len());\n80 \n81      // foo is automatically unlocked when we exit this scope\n82    }\n83    // foo could now be unlocked again if needed\n84  }\n```", "```rs\nimpl SomeOsSpecificFunctionalityHandle {\n    unsafe fn lock(&self) {\n        // Here goes the unsafe low level code\n    }\n    unsafe fn unlock(&self) {\n        // Here goes the unsafe low level code\n    }\n}\n...\nfn lock(&self) -> SomeOsFunctionalityGuard<T> {\n    // Lock the underlying resource.\n    unsafe {\n        self.inner.lock();\n    }\n\n```", "```rs\n    // Wrap a reference to our locked selves in a guard\n    SomeOsFunctionalityGuard { lock: self }\n}\n```", "```rs\nunsafe {\n    self.inner.lock();\n}\n```", "```rs\nunsafe fn lock(&self) { ... }\n```", "```rs\nfn new(data: T) -> Self {\n    let handle = SomeOsSpecificFunctionalityHandle;\n    SomeOsFunctionality {\n        data,\n        inner: Box::new(handle),\n    }\n}\n```", "```rs\nfn lock(&self) -> SomeOsFunctionalityGuard<T> {\n    // Lock the underlying resource.\n    unsafe {\n        self.inner.lock();\n    }\n\n    // Wrap a reference to our locked selves in a guard\n    SomeOsFunctionalityGuard { lock: self }\n}\n```", "```rs\nfn main() {\n    let foo = SomeOsFunctionality::new(\"Hello World\");\n    {\n        let bar = foo.lock();\n        println!(\"The string behind foo is {} characters long\", \n        bar.len());\n    }\n}\n```"]