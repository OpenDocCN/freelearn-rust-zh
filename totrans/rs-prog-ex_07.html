<html><head></head><body>
        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Music Player in a More Rusty Way with Relm</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In the previous chapter, we finished our music player. It is completely fine, but using <span><kbd class="calibre14">gtk-rs</kbd></span> directly in Rust can be error-prone. That's why we'll rewrite our music player using <span><kbd class="calibre14">relm</kbd></span>, an idiomatic GUI library for Rust. <span><kbd class="calibre14">Relm</kbd></span> is based on <span><kbd class="calibre14">gtk-rs</kbd></span>, so the application will look the same at the end. However, the code will be cleaner and more declarative.</p>
<p class="calibre3">We will cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Relm</li>
<li class="calibre11">Relm widgets</li>
<li class="calibre11">Model-view-controller</li>
<li class="calibre11">Declarative view</li>
<li class="calibre11">Message passing</li>
</ul>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Reasons to use relm instead of gtk-rs directly</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">As you have seen in the previous chapters, we used concepts that were not really obvious, and doing certain things that would normally be easy to do aren't that easy when using GTK+ with Rust. These are some of the many reasons to use <span><kbd class="calibre14">relm</kbd></span>.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">State mutation</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">It might not be clear from the previous chapter, but we indirectly used <span><kbd class="calibre14">Rc&lt;RefCell&lt;T&gt;&gt;</kbd></span> to do state mutation. Indeed, our <span><kbd class="calibre14">Playlist</kbd></span> type contains a <span><kbd class="calibre14">RefCell&lt;Option&lt;String&gt;&gt;</kbd></span> and we wrapped our <span><kbd class="calibre14">Playlist</kbd></span> inside a reference-counted pointer. This was to be able to mutate the state in reaction to events, for instance playing the song when clicking the play button:</p>
<pre class="calibre22"><span>let</span> playlist = <span>self</span>.playlist.clone();
<span>let</span> play_image = <span>self</span>.toolbar.play_image.clone();
<span>let</span> cover = <span>self</span>.cover.clone();
<span>let</span> state = <span>self</span>.state.clone();
<span>self</span>.toolbar.play_button.connect_clicked(<span>move</span> |_| <span>{</span>
    <span>if</span> state.lock().unwrap().stopped <span>{</span>
        <span>if</span> playlist.play() <span>{</span>
            set_image_icon(&amp;play_image, PAUSE_ICON);
            set_cover(&amp;cover, &amp;playlist);
        <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
        playlist.pause();
        set_image_icon(&amp;play_image, PLAY_ICON);
    <span>}</span>
<span>}</span>);</pre>
<p class="calibre3">Having to use all these calls to <span><kbd class="calibre14">clone()</kbd></span> is cumbersome and using the <span><kbd class="calibre14">RefCell&lt;T&gt;</kbd></span> type can lead to issues that are hard to debug in complex applications. The issue with this type is that the borrow checking happens at runtime. For instance, the following application:</p>
<pre class="calibre22"><span>use</span> std::cell::RefCell;
<span>use</span> std::collections::HashMap;

<span>fn</span> main() <span>{</span>
    <span>let</span> cell = RefCell::new(HashMap::new());
    cell.borrow_mut().insert(<span>"one"</span>, <span>1</span>);
    <span>let</span> borrowed_cell = cell.borrow();
    <span>if</span> <span>let</span> <span>Some</span>(key) = borrowed_cell.get(<span>"one"</span>) <span>{</span>
        cell.borrow_mut().insert(<span>"two"</span>, <span>2</span>);
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Will panic:</p>
<pre class="calibre22">thread 'main' panicked at 'already borrowed: BorrowMutError', /checkout/src/libcore/result.rs:906:4</pre>
<p class="calibre3">Even though it is obvious why it panics in this example (we called <span><kbd class="calibre14">borrow_mut()</kbd></span> when the borrow was still alive in <span><kbd class="calibre14">borrowed_cell</kbd></span>), in more complex applications, it will be harder to understand why the panic happens, especially if we wrap the <span><kbd class="calibre14">RefCell&lt;T&gt;</kbd></span> in an <span><kbd class="calibre14">Rc</kbd></span> and clone it everywhere. This brings us to the second issue with this type: using <span><kbd class="calibre14">Rc&lt;T&gt;</kbd></span> encourages us to clone our data and share it too much which increases the coupling between our modules.</p>
<p class="calibre3">The <span><kbd class="calibre14">relm</kbd></span> crate takes a different approach: widgets owns their data and the different widgets communicate between them using message passing.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Asynchronous user interface</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Another common issue when creating user interfaces is that we might want to perform an action that might take time (such as a network request) without freezing the UI. By being based on <span><kbd class="calibre14">tokio</kbd></span>, an asynchronous I/O framework for Rust, <span><kbd class="calibre14">relm</kbd></span> allows you to easily program graphical user interfaces that can perform network requests without freezing the interface itself.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Creating custom widgets</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In object-oriented languages, it is very easy to create new widgets and use them like built-in widgets. In this paradigm, you only need to create a new class that inherits from a widget and that's it.</p>
<p class="calibre3">In <a target="_blank" href="part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 5</a>, <em class="calibre21">Creating a Music Player</em>, we created custom widgets, such as <span><kbd class="calibre14">Playlist</kbd></span> and <span><kbd class="calibre14">MusicToolbar</kbd></span>, but we needed to create a function to get the real GTK+ widget:</p>
<pre class="calibre22"><span>pub</span> <span>fn</span> view(&amp;<span>self</span>) -&gt; &amp;TreeView <span>{</span>
    &amp;<span>self</span>.treeview
<span>}</span></pre>
<p class="calibre3">An alternative would have been to implement the <span><kbd class="calibre14">Deref</kbd></span> trait:</p>
<pre class="calibre22"><span>use</span> std::ops::Deref;

<span>impl</span> Deref <span>for</span> Playlist <span>{</span>
    <span>type</span> Target = TreeView;

    <span>fn</span> deref(&amp;<span>self</span>) -&gt; &amp;TreeView <span>{</span>
        &amp;<span>self</span>.treeview
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">That implementation would allow us to add the widget to its <kbd class="calibre14">parent</kbd> like this:</p>
<pre class="calibre22">parent.add(&amp;*playlist);</pre>
<p class="calibre3">(Note the leading <span><kbd class="calibre14">*</kbd></span> in front of <span><kbd class="calibre14">playlist</kbd></span> which is the call to <span><kbd class="calibre14">deref()</kbd></span>.)</p>
<p class="calibre3">Instead of adding it in the following way:</p>
<pre class="calibre22">parent.add(playlist.view());</pre>
<p class="calibre3">But it is still different than when using normal <span><kbd class="calibre14">gtk</kbd></span> widgets.</p>
<p class="calibre3"><span><kbd class="calibre14">Relm</kbd></span> solves all of these issues. Let's start using this crate.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a window with relm</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">First of all, we'll use the nightly version of the Rust compiler.</p>
<div class="packt_infobox">
<p class="calibre24">While using this nightly version is not strictly necessary to use <span class="packt_screen"><kbd class="calibre25">relm</kbd></span>, it provides a syntax that is a bit nicer using a feature that is only available on this version.</p>
</div>
<p class="calibre3">That will be a good opportunity to learn how to install a different version of the compiler. Nightly is the unstable version of Rust; it's a version that is compiled almost every day. Some unstable features of Rust are only available on nightly. But, don't worry, we'll also see how to use <span><kbd class="calibre14">relm</kbd></span> on the stable version of Rust.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Installing Rust nightly</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">With <span><kbd class="calibre14">rustup</kbd></span>, the tool we installed in <a target="_blank" href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>, it is very easy to install nightly:</p>
<pre class="calibre23"><strong class="calibre5"><span>rustup</span> default nightly</strong></pre>
<p class="calibre3">Running this command will install the nightly version of the tools (<span><kbd class="calibre14">cargo</kbd></span>, <span><kbd class="calibre14">rustc</kbd></span>, and so on). Also, it will switch the corresponding commands to use the nightly version.</p>
<p class="calibre3">If you want to go back to the stable version, issue the following command:</p>
<pre class="calibre23"><strong class="calibre5"><span>rustup</span> default stable</strong></pre>
<p class="calibre3">The nightly version is updated very frequently, so you might want to update it every week or more often. To do so, you need to run this command:</p>
<pre class="calibre23"><strong class="calibre5"><span>rustup</span> update</strong></pre>
<p class="calibre3">This will also update the stable version if a new version was released (one stable version is released every 6 weeks).</p>
<p class="calibre3">Now that we are using Rust nightly, we're ready to create a <kbd class="calibre14">new</kbd> project:</p>
<pre class="calibre23"><strong class="calibre5"><span>cargo</span> new rusic-relm --bin</strong></pre>
<p class="calibre3">Add the following dependencies in the <span><kbd class="calibre14">Cargo.toml</kbd></span> file:</p>
<pre class="calibre22">[dependencies]
gtk = "^0.3.0"
gtk-sys = "^0.5.0"
relm = "^0.11.0"
relm-attributes = "^0.11.0"
relm-derive = "^0.11.0"</pre>
<p class="calibre3">We still need <span><kbd class="calibre14">gtk</kbd></span> because <span><kbd class="calibre14">relm</kbd></span> is based on it. Let's add the corresponding <span><kbd class="calibre14">extern crate</kbd></span> statements:</p>
<pre class="calibre22"><span>#![</span>feature<span>(</span>proc_macro<span>)]</span>

<span>extern</span> <span>crate</span> gtk;
<span>extern</span> <span>crate</span> gtk_sys;
<span>#[</span>macro_use<span>]</span>
<span>extern</span> <span>crate</span> relm;
<span>extern</span> <span>crate</span> relm_attributes;
<span>#[</span>macro_use<span>]</span>
<span>extern</span> <span>crate</span> relm_derive;</pre>
<p class="calibre3"><span><kbd class="calibre14">relm</kbd></span> provides some macros, that's why we needed to add <span><kbd class="calibre14">#[macro_use]</kbd></span>. We'll start slowly by creating a simple window with <span><kbd class="calibre14">relm</kbd></span>.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Widget</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">This crate is centered around the concept of widgets, which are different than the <span><kbd class="calibre14">gtk</kbd></span> widgets. In <span><kbd class="calibre14">relm</kbd></span>, a widget is composed of a view, a model, and a method to update the model in reaction to events. The concept of widget is implemented by a trait in <span><kbd class="calibre14">relm</kbd></span>: the <span><kbd class="calibre14">Widget</kbd></span> trait.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Model</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We'll start with an empty model and we'll populate it later in this chapter:</p>
<pre class="calibre22"><span>pub</span> <span>struct</span> Model <span>{</span>
<span>}</span></pre>
<p class="calibre3">As you can see, a model can be a simple structure. It could also be <span><kbd class="calibre14">()</kbd></span> if your widget don't need a model. Actually, it can be any type you want.</p>
<p class="calibre3">Besides the model, a widget needs to know the initial value of its model. To specify what it is, we need to implement the <span><kbd class="calibre14">model()</kbd></span> method of the <span><kbd class="calibre14">Widget</kbd></span> trait:</p>
<pre class="calibre22">#[widget]
impl Widget for App {
    fn model() -&gt; Model {
        Model {
        }
    }

    // …
}</pre>
<p class="calibre3">Here, we use the <span><kbd class="calibre14">#[widget]</kbd></span> attribute provided by the <span><kbd class="calibre14">relm_attributes</kbd></span> crate. Attributes are currently an unstable feature of the language, that's why we use nightly. We'll see in the section about the declarative view why this attribute is needed. So, let's go back to our <span><kbd class="calibre14">model()</kbd></span> model, we only return <span><kbd class="calibre14">Model {}</kbd></span> for now as our model does not contain any data. Other methods are needed for this trait, so this implementation is incomplete for now.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Messages</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3"><span><kbd class="calibre14">Relm</kbd></span> widgets communicate by sending messages to other widgets, but also to themselves. For instance, when the <span><kbd class="calibre14">delete_event</kbd></span> signal is emitted, we can emit the <span><kbd class="calibre14">Quit</kbd></span> message to our widget and take appropriate action when we receive this message. A message is modeled as an <span><kbd class="calibre14">enum</kbd></span> using the custom derive <span><kbd class="calibre14">Msg</kbd></span> that is specific to <span><kbd class="calibre14">relm</kbd></span>:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span>Msg<span>)]</span>
<span>pub</span> <span>enum</span> Msg <span>{</span>
    Quit,
<span>}</span></pre>
<p class="calibre3">This custom derive is provided by the <span><kbd class="calibre14">relm_derive</kbd></span> crate.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">View</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Views are created in a declarative way in <span><kbd class="calibre14">relm</kbd></span> as a part of the <span><kbd class="calibre14">Widget</kbd></span> trait:</p>
<pre class="calibre22"><span>use</span> gtk::<span>{</span>
    GtkWindowExt,
    Inhibit,
    WidgetExt,
<span>}</span>;
<span>use</span> relm::Widget;
<span>use</span> relm_attributes::widget;

<span>use</span> <span>self</span>::Msg::*;

<span>#[</span>widget<span>]</span>
<span>impl</span> Widget <span>for</span> App <span>{</span>
    <span>// …</span>

    <span>view!</span> <span>{</span>
        gtk::Window <span>{</span>
            title: <span>"Rusic"</span>,
            delete_event(_, _) =&gt; (Quit, Inhibit(<span>false</span>)),
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We first imported some stuff from the <span><kbd class="calibre14">gtk</kbd></span> crate. Then we imported the <span><kbd class="calibre14">Widget</kbd></span> trait from <span><kbd class="calibre14">relm</kbd></span> and the <span><kbd class="calibre14">widget</kbd></span> attribute. Later, we imported the variant of our <span><kbd class="calibre14">enum Msg</kbd></span> because we use it in this code. To declare the view, we use the <span><kbd class="calibre14">view!</kbd></span> macro. This macro is very particular, it is not a macro that is declared as <span><kbd class="calibre14">macro_rules!</kbd></span>, as we saw in <a target="_blank" href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>. Instead, it is parsed by the procedural macro implementing the <span><kbd class="calibre14">#[widget]</kbd></span> attribute in order to provide a syntax that is not allowed in Rust.</p>
<p class="calibre3">To declare our view, we first specify the name of the <span><kbd class="calibre14">gtk::Window</kbd></span> widget.</p>
<div class="packt_infobox">
<p class="calibre24">We cannot import <span class="packt_screen"><kbd class="calibre25">gtk::Window</kbd></span> to be able to use only <span class="packt_screen"><kbd class="calibre25">Window</kbd></span> in the declaration of the view.</p>
</div>
<p class="calibre3">After that, we use curly brackets and inside them, we specify the properties and events handled by the widget.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Properties</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Here, we declare that the <span><kbd class="calibre14">title</kbd></span> property is <span><kbd class="calibre14">"Rusic"</kbd></span>. So we transformed the <span><kbd class="calibre14">set_title()</kbd></span> call from <span><kbd class="calibre14">gtk</kbd></span> to the <span><kbd class="calibre14">title</kbd></span> property, only the part after <span><kbd class="calibre14">set_</kbd></span> is needed. Actually, <span><kbd class="calibre14">relm</kbd></span> will convert the property (<span><kbd class="calibre14">title: "Rusic"</kbd></span>) to the <span><kbd class="calibre14">set_title("Rusic")</kbd></span> call, as we'll see later.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Events</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The syntax of the event handler is a bit special:</p>
<pre class="calibre22">delete_event(_, _) =&gt; (Quit, Inhibit(false)),</pre>
<p class="calibre3">First, we only need to write <span><kbd class="calibre14">delete_event(_, _) =&gt;</kbd></span> instead of <span><kbd class="calibre14">connect_delete_event(move |_, _| { })</kbd></span>. If we needed the arguments of the signal, we could have written the name of an identifier instead of using underscores (<span><kbd class="calibre14">_</kbd></span>). On the right side of the fat arrow (<span><kbd class="calibre14">=&gt;</kbd></span>), we specify two things between parentheses and separated by a comma. First, there's <span><kbd class="calibre14">Quit</kbd></span>, which is the message that will be sent to the current widget when the event is emitted. And second is the value to return to the <span><kbd class="calibre14">gtk</kbd></span> callback. Here, we return <span><kbd class="calibre14">Inhibit(false)</kbd></span> to specify that we don't want to prevent the default event handler from running.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Code generation</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The code generated by the attribute is a normal Rust method that looks like:</p>
<pre class="calibre22"><span>fn</span> view(relm: &amp;Relm&lt;<span>Self</span>&gt;, model: <span>Self</span>::Model) -&gt; <span>Self</span> <span>{</span>
   <span>// This method does not actually exist, but relm directly create a window using the functions from the sys crates.</span>
    <span>let</span> window = gtk::Window::new();
    window.set_title(<span>"Rusic"</span>);

    window.show();

    <span>connect!</span>(relm, window, connect_delete_event(_, _), <span>return</span> <br class="calibre6"/>     (<span>Some</span>(Quit), Inhibit(<span>false</span>)));

    Win <span>{</span>
        model,
        window: window,
    <span>}</span>
<span>}</span></pre>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Update function</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The only remaining required method of the <span><kbd class="calibre14">Widget</kbd></span> trait is <span><kbd class="calibre14">update()</kbd></span>. In this method, we'll manage the <span><kbd class="calibre14">Quit</kbd></span> message:</p>
<pre class="calibre22"><span>#[</span>widget<span>]</span>
<span>impl</span> Widget <span>for</span> App <span>{</span>
    <span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
        <span>match</span> event <span>{</span>
            Quit =&gt; gtk::main_quit(),
        <span>}</span>
    <span>}</span>

    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">Here, we specify that when we receive the <span><kbd class="calibre14">Quit</kbd></span> message, we call <span><kbd class="calibre14">gtk::main_quit()</kbd></span>, which is a function similar to <span><kbd class="calibre14">Application::quit()</kbd></span> that we used in <a target="_blank" href="part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 5</a>, <em class="calibre21">Creating a Music Player</em>.</p>
<p class="calibre3">It should be noted that the <span><kbd class="calibre14">#[widget]</kbd></span> attribute will also generate the <span><kbd class="calibre14">App</kbd></span> structure that will contain the widgets and the model.</p>
<p class="calibre3">We can finally show this window by calling its <span><kbd class="calibre14">run()</kbd></span> method in the <kbd class="calibre14">main</kbd> function:</p>
<pre class="calibre22"><span>fn</span> main() <span>{</span>
    App::run(()).unwrap();
<span>}</span></pre>
<p class="calibre3">Later, we'll see why we need to specify <span><kbd class="calibre14">()</kbd></span> as a parameter to <span><kbd class="calibre14">run()</kbd></span>.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Adding child widgets</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We saw the basics of how to create a widget with relm. Now, let's continue the creation of our user interface. We'll start by adding the toolbar. Besides specifying properties and signals in the <span><kbd class="calibre14">view!</kbd></span> macro, we can also nest widgets in order to add a child to a container. So, to add <span><kbd class="calibre14">gtk::Box</kbd></span> as a child of our window, we simply need to nest the former inside the latter:</p>
<pre class="calibre22"><span>view!</span> <span>{</span>
    gtk::Window <span>{</span>
        title: <span>"Rusic"</span>,
        delete_event(_, _) =&gt; (Quit, Inhibit(<span>false</span>)),
        gtk::<span>Box</span> <span>{</span>
        <span>}</span>,
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">And to add a toolbar to the <span><kbd class="calibre14">gtk::Box</kbd></span>, we create a new level of nesting:</p>
<pre class="calibre22"><span>view!</span> <span>{</span>
    gtk::Window <span>{</span>
        title: <span>"Rusic"</span>,
        delete_event(_, _) =&gt; (Quit, Inhibit(<span>false</span>)),
        gtk::<span>Box</span> <span>{</span>
            orientation: Vertical,
            <span>#[</span>name<span>=</span><span>"toolbar"</span><span>]</span>
            gtk::Toolbar <span>{</span>
            <span>}</span>,
        <span>}</span>,
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Here, we can see that there's an attribute: the <span><kbd class="calibre14">#[name]</kbd></span> attribute gives a name to a widget which will allow us to access this widget by the specified identifier, as we'll see later. We'll encounter other attributes in the rest of this chapter.</p>
<p class="calibre3">We'll add an attribute to our model to keep the image to be shown on the play/pause button:</p>
<pre class="calibre22"><span>use</span> gtk::Image;

<span>pub</span> <span>const</span> PAUSE_ICON: &amp;<span>str</span> = <span>"gtk-media-pause"</span>;
<span>pub</span> <span>const</span> PLAY_ICON: &amp;<span>str</span> = <span>"gtk-media-play"</span>;

<span>pub</span> <span>struct</span> Model <span>{</span>
    play_image: Image,
<span>}</span></pre>
<p class="calibre3">We also added the constants for the name of the images representing the state of the button. We need to update the <span><kbd class="calibre14">model()</kbd></span> method to specify this new field:</p>
<pre class="calibre22"><span>fn</span> model() -&gt; Model <span>{</span>
    Model <span>{</span>
        play_image: new_icon(PLAY_ICON),
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">This uses the following function to create an image:</p>
<pre class="calibre22"><span>fn</span> new_icon(icon: &amp;<span>str</span>) -&gt; Image <span>{</span>
    Image::new_from_file(<span>format!</span>(<span>"assets/{}.png"</span>, icon))
<span>}</span></pre>
<p class="calibre3">Let's add the items to the toolbar:</p>
<pre class="calibre22"><span>use</span> gtk::<span>{</span>
    OrientableExt,
    ToolButtonExt,
<span>}</span>;
<span>use</span> gtk::Orientation::Vertical;

<span>view!</span> <span>{</span>
    gtk::Window <span>{</span>
        title: <span>"Rusic"</span>,
        delete_event(_, _) =&gt; (Quit, Inhibit(<span>false</span>)),
        gtk::<span>Box</span> <span>{</span>
            orientation: Vertical,
            <span>#[</span>name<span>=</span><span>"toolbar"</span><span>]</span>
            gtk::Toolbar <span>{</span>
                gtk::ToolButton <span>{</span>
                    icon_widget: &amp;new_icon(<span>"document-open"</span>),
                    clicked =&gt; Open,
                <span>}</span>,
                gtk::ToolButton <span>{</span>
                    icon_widget: &amp;new_icon(<span>"document-save"</span>),
                    clicked =&gt; Save,
                <span>}</span>,
                gtk::SeparatorToolItem <span>{</span>
                <span>}</span>,
                gtk::ToolButton <span>{</span>
                    icon_widget: &amp;new_icon(<span>"gtk-media-previous"</span>),
                <span>}</span>,
                gtk::ToolButton <span>{</span>
                    icon_widget: &amp;<span>self</span>.model.play_image,
                    clicked =&gt; PlayPause,
                <span>}</span>,
                gtk::ToolButton <span>{</span>
                    icon_widget: &amp;new_icon(<span>"gtk-media-stop"</span>),
                    clicked =&gt; Stop,
                <span>}</span>,
                gtk::ToolButton <span>{</span>
                    icon_widget: &amp;new_icon(<span>"gtk-media-next"</span>),
                <span>}</span>,
                gtk::SeparatorToolItem <span>{</span>
                <span>}</span>,
                gtk::ToolButton <span>{</span>
                    icon_widget: &amp;new_icon(<span>"remove"</span>),
                <span>}</span>,
                gtk::SeparatorToolItem <span>{</span>
                <span>}</span>,
                gtk::ToolButton <span>{</span>
                    icon_widget: &amp;new_icon(<span>"gtk-quit"</span>),
                    clicked =&gt; Quit,
                <span>}</span>,
            <span>}</span>,
        <span>}</span>,
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Here, there's no new syntax shown. Take note that we can specify function calls as well as model attributes in the value of a property. We needed to put a <span><kbd class="calibre14">&amp;</kbd></span> before <span><kbd class="calibre14">new_icon()</kbd></span> because the code is translated as such:</p>
<pre class="calibre22">tool_button.set_icon_widget(&amp;new_icon(<span>"gtk-quit"</span>));</pre>
<p class="calibre3">And this <span><kbd class="calibre14">set_icon_widget()</kbd></span> method requires something that can be converted into an <span><kbd class="calibre14">Option&lt;&amp;P&gt;</kbd></span> where <span><kbd class="calibre14">P</kbd></span> is a widget. It requires a reference, so we give it a reference.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">One-way data binding</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Setting a property from a model attribute is very frequent in relm and it actually creates a one-way bond between the model attribute and the property. This means that when the attribute is updated, the widget property will be updated as well. There are some restrictions to this feature though:</p>
<ul class="calibre10">
<li class="calibre11">Only an assignment to a model attribute will update the property.</li>
<li class="calibre11">This assignment <em class="calibre21">must</em> be inside an implementation decorated with the <span><kbd class="calibre14">#[widget]</kbd></span> attribute.</li>
</ul>
<p class="calibre3">These restrictions come from the fact that <span><kbd class="calibre14">relm</kbd></span> only analyzes the source code decorated by this attribute. And it only considers assignment to be an update of the model data.</p>
<p class="calibre3">This might require changing some code. For instance, the following code will not trigger a property update:</p>
<pre class="calibre22"><span>self</span>.model.string.push_str(<span>"string"</span>);</pre>
<p class="calibre3">You can rewrite it this way in order for  <kbd class="calibre14">relm</kbd> to consider it an update:</p>
<pre class="calibre22"><span>self</span>.model.string += <span>"string"</span>;</pre>
<p class="calibre3">As you can see, <span><kbd class="calibre14">relm</kbd></span> recognizes not only the <span><kbd class="calibre14">=</kbd></span> assignment, but also the assignments using an operator such as <span><kbd class="calibre14">+=</kbd></span>.</p>
<p class="calibre3">We used many new messages in the previous code, so let's update our enumeration accordingly:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span>Msg<span>)]</span>
<span>pub</span> <span>enum</span> Msg <span>{</span>
    Open,
    PlayPause,
    Quit,
    Save,
    Stop,
<span>}</span></pre>
<p class="calibre3">We also need to change the <span><kbd class="calibre14">update()</kbd></span> method to consider these new messages:</p>
<pre class="calibre23">    <span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
        <span>match</span> event <span>{</span>
            Open =&gt; (),
            PlayPause =&gt; (),
            Quit =&gt; gtk::main_quit(),
            Save =&gt; (),
            Stop =&gt; (),
        <span>}</span>
    <span>}</span></pre>
<p class="calibre3">For now, since we only code the interface, we do nothing when we receive these messages.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Post-initialization of the view</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">If you run the application, you'll see that the images are not shown on the toolbar buttons. This is because of the way <span><kbd class="calibre14">relm</kbd></span> works. When it generates the code, it calls the <span><kbd class="calibre14">show()</kbd></span> method on every widget, instead of <span><kbd class="calibre14">show_all()</kbd></span>. So, the toolbar and the tool buttons will be shown, but not the images, as they are only attributes of the buttons, they are not created using the widget syntax. To solve this issue, we'll call <span><kbd class="calibre14">show_all()</kbd></span> on the toolbar in the <span><kbd class="calibre14">init_view()</kbd></span> method:</p>
<pre class="calibre22"><span>#[</span>widget<span>]</span>
<span>impl</span> Widget <span>for</span> App <span>{</span>
    <span>fn</span> init_view(&amp;<span>mut</span> <span>self</span>) <span>{</span>
        <span>self</span>.toolbar.show_all();
    <span>}</span>

    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">That's why we gave a name to the toolbar widget earlier: we needed to call a method on this widget here. The <span><kbd class="calibre14">init_view()</kbd></span> method is called after the <kbd class="calibre14">view</kbd> is created. This is useful to execute some code to customize the view when it's not possible to do so using the <span><kbd class="calibre14">view!</kbd></span> syntax. If you run the application again, you'll see that the buttons now have an image.</p>
<p class="calibre3">Let's now add the cover image widget and the cursor widget. For the image, we'll need to add a new crate to <span><kbd class="calibre14">Cargo.toml</kbd></span>:</p>
<pre class="calibre22">[dependencies]
gdk-pixbuf = "^0.3.0"</pre>
<p class="calibre3">Let's also add the corresponding <span><kbd class="calibre14">extern crate</kbd></span> statement:</p>
<pre class="calibre22"><span>extern</span> <span>crate</span> gdk_pixbuf;</pre>
<p class="calibre3">We also need new import statements:</p>
<pre class="calibre22"><span>use</span> gdk_pixbuf::Pixbuf;
<span>use</span> gtk::<span>{</span>
    Adjustment,
    BoxExt,
    ImageExt,
    LabelExt,
    ScaleExt,
<span>}</span>;
<span>use</span> gtk::Orientation::Horizontal;</pre>
<p class="calibre3">Let's add a couple of new fields to our <span><kbd class="calibre14">Model</kbd></span>:</p>
<pre class="calibre22"><span>pub</span> <span>struct</span> Model <span>{</span>
    adjustment: Adjustment,
    cover_pixbuf: <span>Option</span>&lt;Pixbuf&gt;,
    cover_visible: <span>bool</span>,
    current_duration: <span>u64</span>,
    current_time: <span>u64</span>,
    play_image: Image,
<span>}</span></pre>
<p class="calibre3">Most of the new fields existed in the application we developed in the two previous chapters. The <span><kbd class="calibre14">cover_visible</kbd></span> attribute is new, though. We'll use it to know whether we should show the image of the cover. Don't forget to update the initialization of the model:</p>
<pre class="calibre22"><span>fn</span> model() -&gt; Model <span>{</span>
    Model <span>{</span>
        adjustment: Adjustment::new(<span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>0.0</span>),
        cover_pixbuf: <span>None</span>,
        cover_visible: <span>false</span>,
        current_duration: <span>0</span>,
        current_time: <span>0</span>,
        play_image: new_icon(PLAY_ICON),
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We can now add the <span><kbd class="calibre14">Image</kbd></span> after the <span><kbd class="calibre14">Toolbar</kbd></span> widget:</p>
<pre class="calibre22">gtk::Image <span>{</span>
    from_pixbuf: <span>self</span>.model.cover_pixbuf.as_ref(),
    visible: <span>self</span>.model.cover_visible,
<span>}</span>,</pre>
<p class="calibre3">Here, we call <span><kbd class="calibre14">as_ref()</kbd></span> on the <span><kbd class="calibre14">cover_pixbuf</kbd></span> attribute, because, once again, the method (<span><kbd class="calibre14">set_from_pixbuf()</kbd></span>) requires something that can be converted into a <span><kbd class="calibre14">Option&lt;&amp;Pixbuf&gt;</kbd></span>. We also specify that the <span><kbd class="calibre14">visible</kbd></span> property of the image is bound to the <span><kbd class="calibre14">cover_visible</kbd></span> model attribute. This means that we'll be able to hide the image by setting this attribute to <span><kbd class="calibre14">false</kbd></span>.</p>
<p class="calibre3">We'll then add the cursor, which will give us the following view:</p>
<pre class="calibre22"><span>view!</span> <span>{</span>
    gtk::Window <span>{</span>
        title: <span>"Rusic"</span>,
        delete_event(_, _) =&gt; (Quit, Inhibit(<span>false</span>)),
        gtk::<span>Box</span> <span>{</span>
            orientation: Vertical,
            <span>#[</span>name<span>=</span><span>"toolbar"</span><span>]</span>
            gtk::Toolbar <span>{</span>
                <span>// …</span>
            <span>}</span>,
            gtk::Image <span>{</span>
                from_pixbuf: <span>self</span>.model.cover_pixbuf.as_ref(),
                visible: <span>self</span>.model.cover_visible,
            <span>}</span>,
            gtk::<span>Box</span> <span>{</span>
                orientation: Horizontal,
                spacing: <span>10</span>,
                gtk::Scale(Horizontal, &amp;<span>self</span>.model.adjustment) <span>{</span>
                    draw_value: <span>false</span>,
                    hexpand: <span>true</span>,
                <span>}</span>,
                gtk::Label <span>{</span>
                    text: &amp;millis_to_minutes(<span>self</span>.model.current_time),
                <span>}</span>,
                gtk::Label <span>{</span>
                    text: <span>"/"</span>,
                <span>}</span>,
                gtk::Label <span>{</span>
                    margin_right: <span>10</span>,
                    text: &amp;millis_to_minutes(<span>self</span>.model.current_duration),
                <span>}</span>,
            <span>}</span>,
        <span>}</span>,
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">This require the following method, which we saw in the previous chapter:</p>
<pre class="calibre22"><span>fn</span> millis_to_minutes(millis: <span>u64</span>) -&gt; <span>String</span> <span>{</span>
    <span>let</span> <span>mut</span> seconds = millis / <span>1_000</span>;
    <span>let</span> minutes = seconds / <span>60</span>;
    seconds %= <span>60</span>;
    <span>format!</span>(<span>"{}:{:02}"</span>, minutes, seconds)
<span>}</span></pre>
<p class="calibre3">We used another way to create a widget:</p>
<pre class="calibre22">gtk::Scale(Horizontal, &amp;<span>self</span>.model.adjustment) <span>{</span>
    draw_value: <span>false</span>,
    hexpand: <span>true</span>,
<span>}</span></pre>
<p class="calibre3">This syntax will call the constructor of the widget, like so:</p>
<pre class="calibre22">gtk::Scale::new(Horizontal, &amp;<span>self</span>.model.adjustment);</pre>
<p class="calibre3">We could also have used the traditional syntax to create a widget:</p>
<pre class="calibre22"><span>use</span> gtk::RangeExt;

gtk::Scale <span>{</span>
    adjustment: &amp;<span>self</span>.model.adjustment,
    orientation: Horizontal,
    draw_value: <span>false</span>,
    hexpand: <span>true</span>,
<span>}</span></pre>
<p class="calibre3">These are just two ways to do the same thing.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Dialogs</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">For the open and save dialog, we'll use the same functions as in the previous chapter:</p>
<pre class="calibre22"><span>use</span> std::path::PathBuf;

<span>use</span> gtk::<span>{</span>FileChooserAction, FileChooserDialog, FileFilter<span>}</span>;
<span>use</span> gtk_sys::<span>{</span>GTK_RESPONSE_ACCEPT, GTK_RESPONSE_CANCEL<span>}</span>;

<span>const</span> RESPONSE_ACCEPT: <span>i32</span> = GTK_RESPONSE_ACCEPT <span>as</span> <span>i32</span>;
<span>const</span> RESPONSE_CANCEL: <span>i32</span> = GTK_RESPONSE_CANCEL <span>as</span> <span>i32</span>;

<span>fn</span> show_open_dialog(parent: &amp;Window) -&gt; <span>Option</span>&lt;PathBuf&gt; <span>{</span>
    <span>let</span> <span>mut</span> file = <span>None</span>;
    <span>let</span> dialog = FileChooserDialog::new(<span>Some</span>(<span>"Select an MP3 audio file"</span>), <br class="calibre6"/><span>    Some</span>(parent), FileChooserAction::Open);

    <span>let</span> mp3_filter = FileFilter::new();
    mp3_filter.add_mime_type(<span>"audio/mp3"</span>);
    mp3_filter.set_name(<span>"MP3 audio file"</span>);
    dialog.add_filter(&amp;mp3_filter);

    <span>let</span> m3u_filter = FileFilter::new();
    m3u_filter.add_mime_type(<span>"audio/x-mpegurl"</span>);
    m3u_filter.set_name(<span>"M3U playlist file"</span>);
    dialog.add_filter(&amp;m3u_filter);

    dialog.add_button(<span>"Cancel"</span>, RESPONSE_CANCEL);
    dialog.add_button(<span>"Accept"</span>, RESPONSE_ACCEPT);
    <span>let</span> result = dialog.run();
    <span>if</span> result == RESPONSE_ACCEPT <span>{</span>
        file = dialog.get_filename();
    <span>}</span>
    dialog.destroy();
    file
<span>}</span>

<span>fn</span> show_save_dialog(parent: &amp;Window) -&gt; <span>Option</span>&lt;PathBuf&gt; <span>{</span>
    <span>let</span> <span>mut</span> file = <span>None</span>;
    <span>let</span> dialog = FileChooserDialog::new(<span>Some</span>(<span>"Choose a destination M3U playlist <br class="calibre6"/>    file"</span>), <span>Some</span>(parent), FileChooserAction::Save);
    <span>let</span> filter = FileFilter::new();
    filter.add_mime_type(<span>"audio/x-mpegurl"</span>);
    filter.set_name(<span>"M3U playlist file"</span>);
    dialog.set_do_overwrite_confirmation(<span>true</span>);
    dialog.add_filter(&amp;filter);
    dialog.add_button(<span>"Cancel"</span>, RESPONSE_CANCEL);
    dialog.add_button(<span>"Save"</span>, RESPONSE_ACCEPT);
    <span>let</span> result = dialog.run();
    <span>if</span> result == RESPONSE_ACCEPT <span>{</span>
        file = dialog.get_filename();
    <span>}</span>
    dialog.destroy();
    file
<span>}</span></pre>
<p class="calibre3">But this time, we'll put the code for the open action in a method on the <span><kbd class="calibre14">App</kbd></span> widget:</p>
<pre class="calibre22"><span>use</span> gtk::<span>{</span>ButtonsType, DialogFlags, MessageDialog, MessageType<span>}</span>;

<span>impl</span> App <span>{</span>
    <span>fn</span> open(&amp;<span>self</span>) <span>{</span>
        <span>let</span> file = show_open_dialog(&amp;<span>self</span>.window);
        <span>if</span> <span>let</span> <span>Some</span>(file) = file <span>{</span>
            <span>let</span> ext = file.extension().map(|ext| <br class="calibre6"/>             ext.to_str().unwrap().to_string());
            <span>if</span> <span>let</span> <span>Some</span>(ext) = ext <span>{</span>
                <span>match</span> ext.as_str() <span>{</span>
                    <span>"mp3"</span> =&gt; (),
                    <span>"m3u"</span> =&gt; (),
                    extension =&gt; <span>{</span>
                        <span>let</span> dialog = <br class="calibre6"/>                        MessageDialog::new(<span>Some</span>(&amp;<span>self</span>.window),  <br class="calibre6"/>                        DialogFlags::empty(), MessageType::Error,
                        ButtonsType::<span>Ok</span>, &amp;<span>format!</span>(<span>"Cannot open file <br class="calibre6"/>                         with extension . {}"</span>, extension));
                        dialog.run();
                        dialog.destroy();
                    <span>}</span>,
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We can then call these functions in the <span><kbd class="calibre14">update()</kbd></span> method:</p>
<pre class="calibre22"><span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        Open =&gt; <span>self</span>.open(),
        PlayPause =&gt;  (),
        Quit =&gt; gtk::main_quit(),
        Save =&gt; show_save_dialog(&amp;<span>self</span>.window),
        Stop =&gt; (),
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Let's manage some of the other actions.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Other methods</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">This will require two new methods in the <span><kbd class="calibre14">impl Widget</kbd></span>:</p>
<pre class="calibre22">#[widget]
impl Widget for App {
    // …

    fn set_current_time(&amp;mut self, time: u64) {
        self.model.current_time = time;
        self.model.adjustment.set_value(time as f64);
    }

    fn set_play_icon(&amp;self, icon: &amp;str) {
        self.model.play_image.set_from_file(format!("assets/{}.png", icon));
    }
}</pre>
<p class="calibre3">But these methods have nothing to do with a <span><kbd class="calibre14">Widget</kbd></span>, so why are we allowed to add <kbd class="calibre14">custom</kbd> methods in a trait implementation? Well, the <span><kbd class="calibre14">#[widget]</kbd></span> attribute will take these methods and move them to a separate <span><kbd class="calibre14">impl App</kbd></span> where they belong. But why do we want to do this instead of placing them ourselves? That's because <span><kbd class="calibre14">relm</kbd></span> analyzes the assignments to the model attributes in the methods in the implementation decorated by the <span><kbd class="calibre14">#[widget]</kbd></span> attribute. As we saw earlier, an assignment to a model field will automatically update the view. If we placed these methods in a separate <span><kbd class="calibre14">impl App</kbd></span>, <span><kbd class="calibre14">relm</kbd></span> would have been unable to analyze these methods and generate the code to automatically update the view.</p>
<p class="calibre3">This is a frequent mistake, if your view is not updating when you're assigning to a model attribute, it's probably because your assignment is not within an implementation decorated by the <span><kbd class="calibre14">#[widget]</kbd></span> attribute.</p>
<p class="calibre3">We also need a new attribute for our model:</p>
<pre class="calibre22"><span>pub</span> <span>struct</span> Model <span>{</span>
    adjustment: Adjustment,
    cover_pixbuf: <span>Option</span>&lt;Pixbuf&gt;,
    cover_visible: <span>bool</span>,
    current_duration: <span>u64</span>,
    current_time: <span>u64</span>,
    play_image: Image,
    stopped: <span>bool</span>,
<span>}</span></pre>
<p class="calibre3">We added a <span><kbd class="calibre14">stopped</kbd></span> attribute that we also need to add in the model initialization:</p>
<pre class="calibre22"><span>fn</span> model() -&gt; Model <span>{</span>
    Model <span>{</span>
        adjustment: Adjustment::new(<span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>0.0</span>),
        cover_pixbuf: <span>None</span>,
        cover_visible: <span>false</span>,
        current_duration: <span>0</span>,
        current_time: <span>0</span>,
        play_image: new_icon(PLAY_ICON),
        stopped: <span>true</span>,
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We can now change the <span><kbd class="calibre14">update()</kbd></span> method to use these new methods:</p>
<pre class="calibre22"><span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        Open =&gt; <span>self</span>.open(),
        PlayPause =&gt;  <span>{</span>
            <span>if</span> !<span>self</span>.model.stopped <span>{</span>
                <span>self</span>.set_play_icon(PLAY_ICON);
            <span>}</span>
        <span>}</span>,
        Quit =&gt; gtk::main_quit(),
        Save =&gt; show_save_dialog(&amp;<span>self</span>.window),
        Stop =&gt; <span>{</span>
            <span>self</span>.set_current_time(<span>0</span>);
            <span>self</span>.model.current_duration = <span>0</span>;
            <span>self</span>.model.cover_visible = <span>false</span>;
            <span>self</span>.set_play_icon(PLAY_ICON);
        <span>}</span>,
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">The <span><kbd class="calibre14">update()</kbd></span> method receives <span><kbd class="calibre14">self</kbd></span> by a mutable reference, which allows us to update the model attributes.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Playlist</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We're now ready to create a new widget: the playlist. We'll need the following new <kbd class="calibre14">dependencies</kbd>:</p>
<pre class="calibre22">[dependencies]
id3 = "^0.2.0"
m3u = "^1.0.0"</pre>
<p class="calibre3">Add their corresponding <span><kbd class="calibre14">extern crate</kbd></span> statements:</p>
<pre class="calibre22"><span>extern</span> <span>crate</span> id3;
<span>extern</span> <span>crate</span> m3u;</pre>
<p class="calibre3">Let's create a new module for our <span><kbd class="calibre14">playlist</kbd></span>:</p>
<pre class="calibre22"><span>mod</span> playlist;</pre>
<p class="calibre3">In the <span><kbd class="calibre14">src/playlist.rs</kbd></span> file, we start by creating our model:</p>
<pre class="calibre22"><span>use</span> gtk::ListStore;

<span>pub</span> <span>struct</span> Model <span>{</span>
    current_song: <span>Option</span>&lt;<span>String</span>&gt;,
    model: ListStore,
    relm: Relm&lt;Playlist&gt;,
<span>}</span></pre>
<p class="calibre3">The <span><kbd class="calibre14">Relm</kbd></span> type comes from the <span><kbd class="calibre14">relm</kbd></span> crate:</p>
<pre class="calibre22"><span>use</span> relm::Relm;</pre>
<p class="calibre3">It is useful to send messages to a widget. We'll learn more about that in the section about widget communication. Let's add the model initialization function:</p>
<pre class="calibre22"><span>use</span> gdk_pixbuf::Pixbuf;
<span>use</span> gtk::<span>{</span>StaticType, Type<span>}</span>;

<span>#[</span>widget<span>]</span>
<span>impl</span> Widget <span>for</span> Playlist <span>{</span>
    <span>fn</span> model(relm: &amp;Relm&lt;<span>Self</span>&gt;, _: ()) -&gt; Model <span>{</span>
        Model <span>{</span>
            current_song: <span>None</span>,
            model: ListStore::new(&amp;<span>[</span>
                Pixbuf::static_type(),
                Type::<span>String</span>,
                Type::<span>String</span>,
                Type::<span>String</span>,
                Type::<span>String</span>,
                Type::<span>String</span>,
                Type::<span>String</span>,
                Type::<span>String</span>,
                Pixbuf::static_type(),
            <span>]</span>),
            relm: relm.clone(),
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Here, we notice that we use a different signature for the <span><kbd class="calibre14">model()</kbd></span> method. How is this possible? The method of the trait cannot change, right? It is another convenience brought by the <span><kbd class="calibre14">#[widget]</kbd></span> crate. In many cases, we don't need these parameters, so they are automatically added if they are needed. The first parameter is <span><kbd class="calibre14">relm</kbd></span> and we save a copy of it in the model. The second parameter is the model initialization parameter. The <span><kbd class="calibre14">ListStore</kbd></span> is the same as in <a target="_blank" href="part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 5</a>, <em class="calibre21">Creating a Music Player</em>, we only save it in our model because we'll need it later.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Model parameter</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's talk more about this second parameter. It could be used to send data to the widget when we create it. Remember when we called <span><kbd class="calibre14">run()</kbd></span>:</p>
<pre class="calibre22">App::run(()).unwrap();</pre>
<p class="calibre3">Here, we specified <span><kbd class="calibre14">()</kbd></span> as the model parameter because we don't need one. But we could have used a different value, such as <span><kbd class="calibre14">42</kbd></span>, and this value would have been received in the second parameter of the <span><kbd class="calibre14">model()</kbd></span> method.</p>
<p class="calibre3">We're now ready to create the view:</p>
<pre class="calibre22">use gtk;
use gtk::{TreeViewExt, WidgetExt};
use relm::Widget;
use relm_attributes::widget;

#[widget]
impl Widget for Playlist {
    // …

    view! {
        #[name="treeview"]
        gtk::TreeView {
            hexpand: true,
            model: &amp;self.model.model,
            vexpand: true,
        }
    }
}</pre>
<p class="calibre3">It is really simple: we give it a name and set both the <span><kbd class="calibre14">hexpand</kbd></span> and <span><kbd class="calibre14">vexpand</kbd></span> properties to <span><kbd class="calibre14">true</kbd></span> and we bind the <span><kbd class="calibre14">model</kbd></span> property with our <span><kbd class="calibre14">ListStore</kbd></span>.</p>
<p class="calibre3">Let's create an empty <span><kbd class="calibre14">update()</kbd></span> method for now:</p>
<pre class="calibre22"><span>#[</span>widget<span>]</span>
<span>impl</span> Widget <span>for</span> Playlist <span>{</span>
    <span>// …</span>

    <span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We'll see the <span><kbd class="calibre14">Msg</kbd></span> type later. We'll now add the columns exactly like we did it in <span> </span><a href="https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&amp;action=edit#post_86" target="_blank" class="calibre13">Chapter 5</a><span>, </span><em class="calibre21">Creating a Music Player</em>. Let's copy the following enumeration and constants:</p>
<pre class="calibre22"><span>use</span> <span>self</span>::Visibility::*;

<span>#[</span>derive<span>(</span><span>PartialEq</span><span>)]</span>
<span>enum</span> Visibility <span>{</span>
    Invisible,
    Visible,
<span>}</span>

<span>const</span> THUMBNAIL_COLUMN: <span>u32</span> = <span>0</span>;
<span>const</span> TITLE_COLUMN: <span>u32</span> = <span>1</span>;
<span>const</span> ARTIST_COLUMN: <span>u32</span> = <span>2</span>;
<span>const</span> ALBUM_COLUMN: <span>u32</span> = <span>3</span>;
<span>const</span> GENRE_COLUMN: <span>u32</span> = <span>4</span>;
<span>const</span> YEAR_COLUMN: <span>u32</span> = <span>5</span>;
<span>const</span> TRACK_COLUMN: <span>u32</span> = <span>6</span>;
<span>const</span> PATH_COLUMN: <span>u32</span> = <span>7</span>;
<span>const</span> PIXBUF_COLUMN: <span>u32</span> = <span>8</span>;</pre>
<p class="calibre3">And let's add new methods to the <span><kbd class="calibre14">Paylist</kbd></span>:</p>
<pre class="calibre22"><span>impl</span> Playlist <span>{</span>
    <span>fn</span> add_pixbuf_column(&amp;<span>self</span>, column: <span>i32</span>, visibility: Visibility) <span>{</span>
        <span>let</span> view_column = TreeViewColumn::new();
        <span>if</span> visibility == Visible <span>{</span>
            <span>let</span> cell = CellRendererPixbuf::new();
            view_column.pack_start(&amp;cell, <span>true</span>);
            view_column.add_attribute(&amp;cell, <span>"pixbuf"</span>, column);
        <span>}</span>
        <span>self</span>.treeview.append_column(&amp;view_column);

    <span>}</span>

    <span>fn</span> add_text_column(&amp;<span>self</span>, title: &amp;<span>str</span>, column: <span>i32</span>) <span>{</span>
        <span>let</span> view_column = TreeViewColumn::new();
        view_column.set_title(title);
        <span>let</span> cell = CellRendererText::new();
        view_column.set_expand(<span>true</span>);
        view_column.pack_start(&amp;cell, <span>true</span>);
        view_column.add_attribute(&amp;cell, <span>"text"</span>, column);
        <span>self</span>.treeview.append_column(&amp;view_column);
    <span>}</span>

    <span>fn</span> create_columns(&amp;<span>self</span>) <span>{</span>
        <span>self</span>.add_pixbuf_column(THUMBNAIL_COLUMN <span>as</span> <span>i32</span>, Visible);
        <span>self</span>.add_text_column(<span>"Title"</span>, TITLE_COLUMN <span>as</span> <span>i32</span>);
        <span>self</span>.add_text_column(<span>"Artist"</span>, ARTIST_COLUMN <span>as</span> <span>i32</span>);
        <span>self</span>.add_text_column(<span>"Album"</span>, ALBUM_COLUMN <span>as</span> <span>i32</span>);
        <span>self</span>.add_text_column(<span>"Genre"</span>, GENRE_COLUMN <span>as</span> <span>i32</span>);
        <span>self</span>.add_text_column(<span>"Year"</span>, YEAR_COLUMN <span>as</span> <span>i32</span>);
        <span>self</span>.add_text_column(<span>"Track"</span>, TRACK_COLUMN <span>as</span> <span>i32</span>);
        <span>self</span>.add_pixbuf_column(PIXBUF_COLUMN <span>as</span> <span>i32</span>, Invisible);
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">The difference from these functions in <span> </span><a href="https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&amp;action=edit#post_86" target="_blank" class="calibre13">Chapter 5</a><span>, </span><em class="calibre21">Creating a Music Player</em> is that here, we have direct access to the <span><kbd class="calibre14">treeview</kbd></span> as an attribute. This requires new import statements:</p>
<pre class="calibre22"><span>use</span> gtk::<span>{</span>
    CellLayoutExt,
    CellRendererPixbuf,
    CellRendererText,
    TreeViewColumn,
    TreeViewColumnExt,
    TreeViewExt,
<span>}</span>;</pre>
<p class="calibre3">We'll now call the <span><kbd class="calibre14">create_columns()</kbd></span> method in the <span><kbd class="calibre14">init_view()</kbd></span> method:</p>
<pre class="calibre22">#[widget]
impl Widget for Playlist {
    fn init_view(&amp;mut self) {
        self.create_columns();
    }

    // …
}</pre>
<p class="calibre3">Let's start interacting with the playlist. We'll create a method to add a song to the playlist:</p>
<pre class="calibre22"><span>use</span> std::path::Path;

<span>use</span> gtk::<span>{</span>ListStoreExt, ListStoreExtManual, ToValue<span>}</span>;
<span>use</span> id3::Tag;

<span>impl</span> Playlist <span>{</span>
    <span>fn</span> add(&amp;<span>self</span>, path: &amp;Path) <span>{</span>
        <span>let</span> filename =  <br class="calibre6"/>         path.file_stem().unwrap_or_default().to_str().unwrap_or_default();

        <span>let</span> row = <span>self</span>.model.model.append();

        <span>if</span> <span>let</span> <span>Ok</span>(tag) = Tag::read_from_path(path) <span>{</span>
            <span>let</span> title = tag.title().unwrap_or(filename);
            <span>let</span> artist = tag.artist().unwrap_or(<span>"(no artist)"</span>);
            <span>let</span> album = tag.album().unwrap_or(<span>"(no album)"</span>);
            <span>let</span> genre = tag.genre().unwrap_or(<span>"(no genre)"</span>);
            <span>let</span> year = tag.year().map(|year|<br class="calibre6"/>            year.to_string()).unwrap_or(<span>"(no year)"</span>.to_string());
            <span>let</span> track = tag.track().map(|track|  <br class="calibre6"/>             track.to_string()).unwrap_or(<span>"??"</span>.to_string());
            <span>let</span> total_tracks = <br class="calibre6"/>             tag.total_tracks().map(|total_tracks|  <br class="calibre6"/>             total_tracks.to_string()).unwrap_or(<span>"??"</span>.to_string());
            <span>let</span> track_value = <span>format!</span>(<span>"{} / {}"</span>, track, <br class="calibre6"/>             total_tracks);

            <span>self</span>.set_pixbuf(&amp;row, &amp;tag);

            <span>self</span>.model.model.set_value(&amp;row, TITLE_COLUMN, <br class="calibre6"/>            &amp;title.to_value());
            <span>self</span>.model.model.set_value(&amp;row, ARTIST_COLUMN,<br class="calibre6"/>            &amp;artist.to_value());
            <span>self</span>.model.model.set_value(&amp;row, ALBUM_COLUMN, <br class="calibre6"/>            &amp;album.to_value());
            <span>self</span>.model.model.set_value(&amp;row, GENRE_COLUMN, <br class="calibre6"/>            &amp;genre.to_value());
            <span>self</span>.model.model.set_value(&amp;row, YEAR_COLUMN,<br class="calibre6"/>            &amp;year.to_value());
            <span>self</span>.model.model.set_value(&amp;row, TRACK_COLUMN,<br class="calibre6"/>            &amp;track_value.to_value());
        <span>}</span>
        <span>else</span> <span>{</span>
            <span>self</span>.model.model.set_value(&amp;row, TITLE_COLUMN, <br class="calibre6"/>             &amp;filename.to_value());
        <span>}</span>

        <span>let</span> path = path.to_str().unwrap_or_default();
        <span>self</span>.model.model.set_value(&amp;row, PATH_COLUMN,<br class="calibre6"/>         &amp;path.to_value());
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">This calls the <span><kbd class="calibre14">set_pixbuf()</kbd></span> method, so let's define it:</p>
<pre class="calibre22"><span>use</span> gdk_pixbuf::<span>{</span>InterpType, PixbufLoader<span>}</span>;
<span>use</span> gtk::TreeIter;

<span>const</span> INTERP_HYPER: InterpType = <span>3</span>;

<span>const</span> IMAGE_SIZE: <span>i32</span> = <span>256</span>;
<span>const</span> THUMBNAIL_SIZE: <span>i32</span> = <span>64</span>;

<span>fn</span> set_pixbuf(&amp;<span>self</span>, row: &amp;TreeIter, tag: &amp;Tag) <span>{</span>
    <span>if</span> <span>let</span> <span>Some</span>(picture) = tag.pictures().next() <span>{</span>
        <span>let</span> pixbuf_loader = PixbufLoader::new();
        pixbuf_loader.set_size(IMAGE_SIZE, IMAGE_SIZE);
        pixbuf_loader.loader_write(&amp;picture.data).unwrap();
        <span>if</span> <span>let</span> <span>Some</span>(pixbuf) = pixbuf_loader.get_pixbuf() <span>{</span>
            <span>let</span> thumbnail = pixbuf.scale_simple(THUMBNAIL_SIZE, <br class="calibre6"/>             THUMBNAIL_SIZE, INTERP_HYPER).unwrap();
            <span>self</span>.model.model.set_value(row, THUMBNAIL_COLUMN, <br class="calibre6"/>             &amp;thumbnail.to_value());
            <span>self</span>.model.model.set_value(row, PIXBUF_COLUMN, <br class="calibre6"/>             &amp;pixbuf.to_value());
        <span>}</span>
        pixbuf_loader.close().unwrap();
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">It is very similar to the one created in <span> </span><a href="https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&amp;action=edit#post_86" target="_blank" class="calibre13">Chapter 5</a><span>, </span><em class="calibre21">Creating a Music Player</em>. This method will be called when we receive the <span><kbd class="calibre14">AddSong(path)</kbd></span> message, so let's now create our message type:</p>
<pre class="calibre22"><span>use</span> std::path::PathBuf;

<span>use</span> <span>self</span>::Msg::*;

<span>#[</span>derive<span>(</span>Msg<span>)]</span>
<span>pub</span> <span>enum</span> Msg <span>{</span>
    AddSong(PathBuf),
    LoadSong(PathBuf),
    NextSong,
    PauseSong,
    PlaySong,
    PreviousSong,
    RemoveSong,
    SaveSong(PathBuf),
    SongStarted(<span>Option</span>&lt;Pixbuf&gt;),
    StopSong,
<span>}</span></pre>
<p class="calibre3">And let's modify the <span><kbd class="calibre14">update()</kbd></span> method accordingly:</p>
<pre class="calibre23">   <span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
      <span>match</span> event <span>{</span>
          AddSong(path) =&gt; <span>self</span>.add(&amp;path),
          LoadSong(path) =&gt; (),
          NextSong =&gt; (),
          PauseSong =&gt; (),
          PlaySong =&gt; (),
          PreviousSong =&gt; (),
          RemoveSong =&gt; (),
          SaveSong(path) =&gt; (),
          SongStarted(_) =&gt; (),
          StopSong =&gt; (),
        <span>}</span>
    <span>}</span></pre>
<p class="calibre3">Here, we call the method <span><kbd class="calibre14">add()</kbd></span> when we receive the <span><kbd class="calibre14">AddSong</kbd></span> message. But where is this message emitted? Well, it will be emitted by the <span><kbd class="calibre14">App</kbd></span> type, when the user requests to open a file. It is time we go back to the main module and use this new <span><kbd class="calibre14">relm</kbd></span> widget.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Adding a relm widget</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">First, we'll need these new import statements:</p>
<pre class="calibre22"><span>use</span> playlist::Playlist;
<span>use</span> playlist::Msg::<span>{</span>
    AddSong,
    LoadSong,
    NextSong,
    PlaySong,
    PauseSong,
    PreviousSong,
    RemoveSong,
    SaveSong,
    SongStarted,
    StopSong,
<span>}</span>;</pre>
<p class="calibre3">And then, add the <span><kbd class="calibre14">Playlist</kbd></span> widget below the toolbar:</p>
<pre class="calibre22"><span>view!</span> <span>{</span>
    <span>#[</span>name<span>=</span><span>"window"</span><span>]</span>
    gtk::Window <span>{</span>
        title: <span>"Rusic"</span>,
        gtk::<span>Box</span> <span>{</span>
            orientation: Vertical,
            <span>#[</span>name<span>=</span><span>"toolbar"</span><span>]</span>
            gtk::Toolbar <span>{</span>
                <span>// …</span>
            <span>}</span>,
            <span>#[</span>name<span>=</span><span>"playlist"</span><span>]</span>
            Playlist <span>{</span>
            <span>}</span>,
            gtk::Image <span>{</span>
                from_pixbuf: <span>self</span>.model.cover_pixbuf.as_ref(),
                visible: <span>self</span>.model.cover_visible,
            <span>}</span>,
            gtk::<span>Box</span> <span>{</span>
                <span>// …</span>
            <span>}</span>,
        <span>}</span>,
        delete_event(_, _) =&gt; (Quit, Inhibit(<span>false</span>)),
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">There's something different with using <span><kbd class="calibre14">relm</kbd></span> widgets and <span><kbd class="calibre14">gtk</kbd></span> widgets. <span><kbd class="calibre14">Relm</kbd></span> widgets must not contain a module prefix, while <span><kbd class="calibre14">gtk</kbd></span> widget must contain one. This is why we imported <span><kbd class="calibre14">Playlist</kbd></span>, but now <span><kbd class="calibre14">gtk::Toolbar</kbd></span>, for instance. But why is it needed? Well, <span><kbd class="calibre14">relm</kbd></span> widgets are different than <span><kbd class="calibre14">gtk</kbd></span> widgets, so they are not created or added to another widget in the same way. Thus, <span><kbd class="calibre14">relm</kbd></span> can distinguish them this way: if there's a prefix, this is a built-in <span><kbd class="calibre14">gtk</kbd></span> widget, otherwise it is a custom <span><kbd class="calibre14">relm</kbd></span> widget. When I say <span><kbd class="calibre14">gtk</kbd></span> widgets, this even includes <span><kbd class="calibre14">gtk</kbd></span> widgets from other crates, such as <span><kbd class="calibre14">webkit2gtk::WebView</kbd></span>.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Communicating between widgets</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We'll now communicate between the widgets to indicate we want to add a song to the playlist. But before we do so, we'll look in more detail at how a widget can communicate with itself.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Communicating with the same widget</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We previously saw how to communicate with the same widget. To send a message to the same widget from an event handler in the view, we simply need to specify the message to be sent on the right side of <span><kbd class="calibre14">=&gt;</kbd></span>, like in the following example:</p>
<pre class="calibre22">gtk::ToolButton <span>{</span>
    icon_widget: &amp;new_icon(<span>"gtk-quit"</span>),
    clicked =&gt; Quit,
<span>}</span></pre>
<p class="calibre3">Here, the <span><kbd class="calibre14">Quit</kbd></span> message is sent to the same widget (that is, <span><kbd class="calibre14">App</kbd></span>) when the user clicks this tool button. But this is syntax sugar for a call to the <span><kbd class="calibre14">emit()</kbd></span> method on the stream of events of a <span><kbd class="calibre14">relm</kbd></span> widget.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Emit</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">So, let's see how to send a message to the same widget without using this syntax: this is useful in more complex cases, such as when we want to conditionally send a message. Let's go back to our <span><kbd class="calibre14">Playlist</kbd></span> and add a <span><kbd class="calibre14">play()</kbd></span> method:</p>
<pre class="calibre22"><span>impl</span> Playlist <span>{</span>
    <span>fn</span> play(&amp;<span>mut</span> <span>self</span>) <span>{</span>
        <span>if</span> <span>let</span> <span>Some</span>(path) = <span>self</span>.selected_path() <span>{</span>
            <span>self</span>.model.current_song = <span>Some</span>(path.into());
            <span>self</span>.model.relm.stream().emit(SongStarted(<span>self</span>.pixbuf()));
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">This line sends a message to the current widget:</p>
<pre class="calibre22"><span>self</span>.model.relm.stream().emit(SongStarted(<span>self</span>.pixbuf()));</pre>
<p class="calibre3">We first get the event stream from the <span><kbd class="calibre14">relm</kbd></span> widget and then call <span><kbd class="calibre14">emit()</kbd></span> on it with a message. This <span><kbd class="calibre14">play()</kbd></span> method requires two new methods:</p>
<pre class="calibre22"><span>use</span> gtk::<span>{</span>
    TreeModelExt,
    TreeSelectionExt,
<span>}</span>;

<span>impl</span> Playlist <span>{</span>
    <span>fn</span> pixbuf(&amp;<span>self</span>) -&gt; <span>Option</span>&lt;Pixbuf&gt; <span>{</span>
        <span>let</span> selection = <span>self</span>.treeview.get_selection();
        <span>if</span> <span>let</span> <span>Some</span>((_, iter)) = selection.get_selected() <span>{</span>
            <span>let</span> value = <span>self</span>.model.model.get_value(&amp;iter, <br class="calibre6"/>             PIXBUF_COLUMN <span>as</span> <span>i32</span>);
            <span>return</span> value.get::&lt;Pixbuf&gt;();
        <span>}</span>
        <span>None</span>
    <span>}</span>

    <span>fn</span> selected_path(&amp;<span>self</span>) -&gt; <span>Option</span>&lt;<span>String</span>&gt; <span>{</span>
        <span>let</span> selection = <span>self</span>.treeview.get_selection();
        <span>if</span> <span>let</span> <span>Some</span>((_, iter)) = selection.get_selected() <span>{</span>
            <span>let</span> value = <span>self</span>.model.model.get_value(&amp;iter, PATH_COLUMN <span>as</span> <span>i32</span>);
            <span>return</span> value.get::&lt;<span>String</span>&gt;();
        <span>}</span>
        <span>None</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">These are very similar to the ones we wrote in the previous chapters. We can now call the <span><kbd class="calibre14">play()</kbd></span> method in the <span><kbd class="calibre14">update()</kbd></span> method:</p>
<pre class="calibre23">    <span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
        <span>match</span> event <span>{</span>
            AddSong(path) =&gt; <span>self</span>.add(&amp;path),
            LoadSong(path) =&gt; (),
            NextSong =&gt; (),
            PauseSong =&gt; (),
            PlaySong =&gt; <span>self</span>.play(),
            PreviousSong =&gt; (),
            RemoveSong =&gt; (),
            SaveSong(path) =&gt; (),
            <span>// To be listened by App.</span>
            SongStarted(_) =&gt; (),
            StopSong =&gt; (),
        <span>}</span>
    <span>}</span></pre>
<p class="calibre3">I also added a comment before <span><kbd class="calibre14">SongStarted</kbd></span> to indicate that this message will not be handled by the <span><kbd class="calibre14">Paylist</kbd></span> widget, but by the <span><kbd class="calibre14">App</kbd></span> widget. Now, let's see how to communicate between different widgets.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">With different widgets</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's update the <span><kbd class="calibre14">open()</kbd></span> method to communicate with the playlist:</p>
<pre class="calibre23"><span>impl</span> App <span>{</span>
    <span>fn</span> open(&amp;<span>self</span>) <span>{</span>
        <span>let</span> file = show_open_dialog(&amp;<span>self</span>.window);
        <span>if</span> <span>let</span> <span>Some</span>(file) = file <span>{</span>
            <span>let</span> ext = file.extension().map(|ext| ext.to_str().unwrap().to_string());
            <span>if</span> <span>let</span> <span>Some</span>(ext) = ext <span>{</span>
                <span>match</span> ext.as_str() <span>{</span>
                    <span>"mp3"</span> =&gt; <span>self</span>.playlist.emit(AddSong(file)),
                    <span>"m3u"</span> =&gt; <span>self</span>.playlist.emit(LoadSong(file)),
                    extension =&gt; <span>{</span>
                        <span>let</span> dialog = MessageDialog::new(<span>Some</span>(&amp;<span>self</span>.window),  <br class="calibre6"/>                        DialogFlags::empty(), MessageType::Error,
                        ButtonsType::<span>Ok</span>, &amp;<span>format!</span>(<span>"Cannot open file with <br class="calibre6"/>                         extension . {}"</span>, extension));
                        dialog.run();
                        dialog.destroy();
                    <span>}</span>,
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">So, we call the same <span><kbd class="calibre14">emit()</kbd></span> method to send a message to another widget:</p>
<pre class="calibre22"><span>self</span>.playlist.emit(AddSong(file))</pre>
<p class="calibre3">Here, we sent a message that is not yet handled by the <span><kbd class="calibre14">Playlist</kbd></span> (<span><kbd class="calibre14">LoadSong</kbd></span>), so let's fix that:</p>
<pre class="calibre22"><span>use</span> m3u;

<span>impl</span> Playlist <span>{</span>
    <span>fn</span> load(&amp;<span>self</span>, path: &amp;Path) <span>{</span>
        <span>let</span> <span>mut</span> reader = m3u::Reader::open(path).unwrap();
        <span>for</span> entry <span>in</span> reader.entries() <span>{</span>
            <span>if</span> <span>let</span> <span>Ok</span>(m3u::Entry::Path(path)) = entry <span>{</span>
                <span>self</span>.add(&amp;path);
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">This method is called in the <span><kbd class="calibre14">update()</kbd></span> method:</p>
<pre class="calibre22"><span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        AddSong(path) =&gt; <span>self</span>.add(&amp;path),
        LoadSong(path) =&gt; <span>self</span>.load(&amp;path),
        NextSong =&gt; (),
        PauseSong =&gt; (),
        PlaySong =&gt; <span>self</span>.play(),
        PreviousSong =&gt; (),
        RemoveSong =&gt; (),
        SaveSong(path) =&gt; (),
        <span>// To be listened by App.</span>
        SongStarted(_) =&gt; (),
        StopSong =&gt; (),
    <span>}</span>
<span>}</span></pre>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Handle messages from a relm widget</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's now see how to handle the <span><kbd class="calibre14">SongStarted</kbd></span> message. To do so, we use a syntax similar to the one for handling <span><kbd class="calibre14">gtk</kbd></span> events. The message is on the left side of <span><kbd class="calibre14">=&gt;</kbd></span> while the handler is on the right side of it:</p>
<pre class="calibre22"><span>#[</span>widget<span>]</span>
<span>impl</span> Widget <span>for</span> App <span>{</span>
    <span>// …</span>

    <span>view!</span> <span>{</span>
        <span>// …</span>
        <span>#[</span>name<span>=</span><span>"playlist"</span><span>]</span>
        Playlist <span>{</span>
            SongStarted(<span>ref</span> pixbuf) =&gt; Started(pixbuf.clone()),
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We can see here that when we receive the <span><kbd class="calibre14">SongStarted</kbd></span> message from the playlist, we emit the <span><kbd class="calibre14">Started</kbd></span> message on the same widget (<span><kbd class="calibre14">App</kbd></span>). We needed to use <span><kbd class="calibre14">ref</kbd></span> and then <span><kbd class="calibre14">clone()</kbd></span> the value contained in the message here because we do not own the message. Indeed, multiple widgets can listen to the same message, the widget that emitted the message and its parent. Before we handle this new message, we'll add it to our <span><kbd class="calibre14">Msg</kbd></span> enumeration:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span>Msg<span>)]</span>
<span>pub</span> <span>enum</span> Msg <span>{</span>
    Open,
    PlayPause,
    Quit,
    Save,
    Started(<span>Option</span>&lt;Pixbuf&gt;),
    Stop,
<span>}</span></pre>
<p class="calibre3">This variant takes an optional <kbd class="calibre14">pixbuf</kbd> because some MP3 files do not have a cover image inside them. And here's how we handle this message:</p>
<pre class="calibre22"><span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        <span>// …</span>
        Started(pixbuf) =&gt; <span>{</span>
            <span>self</span>.set_play_icon(PAUSE_ICON);
            <span>self</span>.model.cover_visible = <span>true</span>;
            <span>self</span>.model.cover_pixbuf = pixbuf;
        <span>}</span>,
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">When the song starts playing, we show the pause icon and the cover.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Syntax sugar to send a message to another relm widget</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Sending a message to another widget with <span><kbd class="calibre14">emit()</kbd></span> is a bit verbose, so <span><kbd class="calibre14">relm</kbd></span> provides syntactic sugar for this case. Let's send a message to the playlist when the user clicks the remove button:</p>
<pre class="calibre22">gtk::ToolButton <span>{</span>
    icon_widget: &amp;new_icon(<span>"remove"</span>),
    clicked =&gt; playlist@RemoveSong,
<span>}</span></pre>
<p class="calibre3">Here, we used the <span><kbd class="calibre14">@</kbd></span> syntax to specify that the message will be sent to another widget. The part before the <span><kbd class="calibre14">@</kbd></span> is the receiver widget, while the part after this character is the message. So, this code means that whenever the user clicks the remove button, send the <span><kbd class="calibre14">RemoveSong</kbd></span> message to the <span><kbd class="calibre14">playlist</kbd></span> widget.</p>
<p class="calibre3">Let's handle this message in the <span><kbd class="calibre14">Paylist::update()</kbd></span> method:</p>
<pre class="calibre22"><span>#[</span>widget<span>]</span>
<span>impl</span> Widget <span>for</span> Playlist <span>{</span>
    <span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
        <span>match</span> event <span>{</span>
            AddSong(path) =&gt; <span>self</span>.add(&amp;path),
            LoadSong(path) =&gt; <span>self</span>.load(&amp;path),
            NextSong =&gt; (),
            PauseSong =&gt; (),
            PlaySong =&gt; <span>self</span>.play(),
            PreviousSong =&gt; (),
            RemoveSong =&gt; <span>self</span>.remove_selection(),
            SaveSong(path) =&gt; (),
            <span>// To be listened by App.</span>
            SongStarted(_) =&gt; (),
            StopSong =&gt; (),
        <span>}</span>
    <span>}</span>

    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">This calls the <span><kbd class="calibre14">remove_selection()</kbd></span> method, as shown here:</p>
<pre class="calibre22"><span>fn</span> remove_selection(&amp;<span>self</span>) <span>{</span>
    <span>let</span> selection = <span>self</span>.treeview.get_selection();
    <span>if</span> <span>let</span> <span>Some</span>((_, iter)) = selection.get_selected() <span>{</span>
        <span>self</span>.model.model.remove(&amp;iter);
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">This is the same method as the one from <span> </span><a href="https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&amp;action=edit#post_86" target="_blank" class="calibre13">Chapter 5</a><span>, </span><em class="calibre21">Creating a Music Player</em>. Now, let's send the remaining messages. The <span><kbd class="calibre14">PlaySong</kbd></span>, <span><kbd class="calibre14">PauseSong</kbd></span>, <span><kbd class="calibre14">SaveSong</kbd></span>, and <span><kbd class="calibre14">StopSong</kbd></span> messages are emitted in the <span><kbd class="calibre14">update()</kbd></span> method:</p>
<pre class="calibre22"><span>#[</span>widget<span>]</span>
<span>impl</span> Widget <span>for</span> App <span>{</span>
    <span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
        <span>match</span> event <span>{</span>
            PlayPause =&gt;  <span>{</span>
                <span>if</span> <span>self</span>.model.stopped <span>{</span>
                    <span>self</span>.playlist.emit(PlaySong);
                <span>}</span> <span>else</span> <span>{</span>
                    <span>self</span>.playlist.emit(PauseSong);
                    <span>self</span>.set_play_icon(PLAY_ICON);
                <span>}</span>
            <span>}</span>,
            Save =&gt; <span>{</span>
                <span>let</span> file = show_save_dialog(&amp;<span>self</span>.window);
                <span>if</span> <span>let</span> <span>Some</span>(file) = file <span>{</span>
                    <span>self</span>.playlist.emit(SaveSong(file));
                <span>}</span>
            <span>}</span>,
            Stop =&gt; <span>{</span>
                <span>self</span>.set_current_time(<span>0</span>);
                <span>self</span>.model.current_duration = <span>0</span>;
                <span>self</span>.playlist.emit(StopSong);
                <span>self</span>.model.cover_visible = <span>false</span>;
                <span>self</span>.set_play_icon(PLAY_ICON);
            <span>}</span>,
            <span>// …</span>
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">The other messages are sent using the <span><kbd class="calibre14">@</kbd></span> syntax in the view:</p>
<pre class="calibre22"><span>view!</span> <span>{</span>
    <span>#[</span>name<span>=</span><span>"window"</span><span>]</span>
    gtk::Window <span>{</span>
        title: <span>"Rusic"</span>,
        gtk::<span>Box</span> <span>{</span>
            orientation: Vertical,
            <span>#[</span>name<span>=</span><span>"toolbar"</span><span>]</span>
            gtk::Toolbar <span>{</span>
                <span>// …</span>
                gtk::ToolButton <span>{</span>
                    icon_widget: &amp;new_icon(<span>"gtk-media-previous"</span>),
                    clicked =&gt; playlist@PreviousSong,
                <span>}</span>,
                <span>// …</span>
                gtk::ToolButton <span>{</span>
                    icon_widget: &amp;new_icon(<span>"gtk-media-next"</span>),
                    clicked =&gt; playlist@NextSong,
                <span>}</span>,
            <span>}</span>,
            <span>// …</span>
        <span>}</span>,
        delete_event(_, _) =&gt; (Quit, Inhibit(<span>false</span>)),
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We'll handle these messages in the <span><kbd class="calibre14">Paylist::update()</kbd></span> method:</p>
<pre class="calibre22"><span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        AddSong(path) =&gt; <span>self</span>.add(&amp;path),
        LoadSong(path) =&gt; <span>self</span>.load(&amp;path),
        NextSong =&gt; <span>self</span>.next(),
        PauseSong =&gt; (),
        PlaySong =&gt; <span>self</span>.play(),
        PreviousSong =&gt; <span>self</span>.previous(),
        RemoveSong =&gt; <span>self</span>.remove_selection(),
        SaveSong(path) =&gt; <span>self</span>.save(&amp;path),
        <span>// To be listened by App.</span>
        SongStarted(_) =&gt; (),
        StopSong =&gt; <span>self</span>.stop(),
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">This requires some new methods:</p>
<pre class="calibre22"><span>fn</span> next(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>let</span> selection = <span>self</span>.treeview.get_selection();
    <span>let</span> next_iter =
        <span>if</span> <span>let</span> <span>Some</span>((_, iter)) = selection.get_selected() <span>{</span>
            <span>if</span> !<span>self</span>.model.model.iter_next(&amp;iter) <span>{</span>
                <span>return</span>;
            <span>}</span>
            <span>Some</span>(iter)
        <span>}</span>
        <span>else</span> <span>{</span>
            <span>self</span>.model.model.get_iter_first()
        <span>}</span>;
    <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> iter) = next_iter <span>{</span>
        selection.select_iter(iter);
        <span>self</span>.play();
    <span>}</span>
<span>}</span></pre>
<pre class="calibre22"><span>fn</span> previous(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>let</span> selection = <span>self</span>.treeview.get_selection();
    <span>let</span> previous_iter =
        <span>if</span> <span>let</span> <span>Some</span>((_, iter)) = selection.get_selected() <span>{</span>
            <span>if</span> !<span>self</span>.model.model.iter_previous(&amp;iter) <span>{</span>
                <span>return</span>;
            <span>}</span>
            <span>Some</span>(iter)
        <span>}</span>
        <span>else</span> <span>{</span>
            <span>self</span>.model.model.iter_nth_child(<span>None</span>, max(<span>0</span>,  <br class="calibre6"/><span>            self</span>.model.model.iter_n_children(<span>None</span>) - <span>1</span>))
        <span>}</span>;
    <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> iter) = previous_iter <span>{</span>
        selection.select_iter(iter);
        <span>self</span>.play();
    <span>}</span>
<span>}</span></pre>
<pre class="calibre22"><span>use</span> std::fs::File;

<span>fn</span> save(&amp;<span>self</span>, path: &amp;Path) <span>{</span>
    <span>let</span> <span>mut</span> file = File::create(path).unwrap();
    <span>let</span> <span>mut</span> writer = m3u::Writer::new(&amp;<span>mut</span> file);

    <span>let</span> <span>mut</span> write_iter = |iter: &amp;TreeIter| <span>{</span>
        <span>let</span> value = <span>self</span>.model.model.get_value(&amp;iter, PATH_COLUMN <span>as</span> <span>i32</span>);
        <span>let</span> path = value.get::&lt;<span>String</span>&gt;().unwrap();
        writer.write_entry(&amp;m3u::path_entry(path)).unwrap();
    <span>}</span>;

    <span>if</span> <span>let</span> <span>Some</span>(iter) = <span>self</span>.model.model.get_iter_first() <span>{</span>
        write_iter(&amp;iter);
        <span>while</span> <span>self</span>.model.model.iter_next(&amp;iter) <span>{</span>
            write_iter(&amp;iter);
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">And function <kbd class="calibre14">stop</kbd>:</p>
<pre class="calibre22"><span>fn</span> stop(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>self</span>.model.current_song = <span>None</span>;
<span>}</span></pre>
<p class="calibre3">These methods are all similar to the ones we created in the previous chapters. You can run the application to see that we can open and remove songs, but we cannot play them yet. So let's fix this.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Playing music</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">First, add the <span><kbd class="calibre14">mp3</kbd></span> module:</p>
<pre class="calibre22"><span>mod</span> mp3;</pre>
<p class="calibre3">Copy the <span><kbd class="calibre14">src/mp3.rs</kbd></span> file from the previous chapter.</p>
<p class="calibre3">We also need the following dependencies:</p>
<pre class="calibre22">[dependencies]
crossbeam = "^0.3.0"
futures = "^0.1.16"
pulse-simple = "^1.0.0"
simplemad = "^0.8.1"</pre>
<p class="calibre3">And add these statements to the <kbd class="calibre14">main</kbd> module:</p>
<pre class="calibre22"><span>extern</span> <span>crate</span> crossbeam;
<span>extern</span> <span>crate</span> futures;
<span>extern</span> <span>crate</span> pulse_simple;
<span>extern</span> <span>crate</span> simplemad;</pre>
<p class="calibre3">We'll now add a <span><kbd class="calibre14">player</kbd></span> module:</p>
<pre class="calibre22"><span>mod</span> player;</pre>
<p class="calibre3">This new module will start with a bunch of import statements:</p>
<pre class="calibre22"><span>use</span> std::cell::Cell;
<span>use</span> std::fs::File;
<span>use</span> std::io::BufReader;
<span>use</span> std::path::<span>{</span>Path, PathBuf<span>}</span>;
<span>use</span> std::sync::<span>{</span>Arc, Condvar, Mutex<span>}</span>;
<span>use</span> std::thread;
<span>use</span> std::time::Duration;

<span>use</span> crossbeam::sync::SegQueue;
<span>use</span> futures::<span>{</span>AsyncSink, Sink<span>}</span>;
<span>use</span> futures::sync::mpsc::UnboundedSender;
<span>use</span> pulse_simple::Playback;

<span>use</span> mp3::Mp3Decoder;
<span>use</span> playlist::PlayerMsg::<span>{</span>
    <span>self</span>,
    PlayerPlay,
    PlayerStop,
    PlayerTime,
<span>}</span>;
<span>use</span> <span>self</span>::Action::*;</pre>
<p class="calibre3">We imported a new <span><kbd class="calibre14">PlayerMsg</kbd></span> type from the <span><kbd class="calibre14">playlist</kbd></span> module, so let's add it:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span><span>Clone</span><span>)]</span>
<span>pub</span> <span>enum</span> PlayerMsg <span>{</span>
    PlayerPlay,
    PlayerStop,
    PlayerTime(<span>u64</span>),
<span>}</span></pre>
<p class="calibre3">We'll define some constants:</p>
<pre class="calibre22"><span>const</span> BUFFER_SIZE: <span>usize</span> = <span>1000</span>;
<span>const</span> DEFAULT_RATE: <span>u32</span> = <span>44100</span>;</pre>
<p class="calibre3">And let's create the types that we'll need:</p>
<pre class="calibre22"><span>enum</span> Action <span>{</span>
    Load(PathBuf),
    Stop,
<span>}</span>

<span>#[</span>derive<span>(</span><span>Clone</span><span>)]</span>
<span>struct</span> EventLoop <span>{</span>
    condition_variable: Arc&lt;(Mutex&lt;<span>bool</span>&gt;, Condvar)&gt;,
    queue: Arc&lt;SegQueue&lt;Action&gt;&gt;,
    playing: Arc&lt;Mutex&lt;<span>bool</span>&gt;&gt;,
<span>}</span>

<span>pub</span> <span>struct</span> Player <span>{</span>
    event_loop: EventLoop,
    paused: Cell&lt;<span>bool</span>&gt;,
    tx: UnboundedSender&lt;PlayerMsg&gt;,
<span>}</span></pre>
<p class="calibre3">The <span><kbd class="calibre14">Action</kbd></span> and <span><kbd class="calibre14">EventLoop</kbd></span> are the same as in the previous chapter, but the <span><kbd class="calibre14">Player</kbd></span> type is a bit different. Instead of having a field with the state of the application, it contains a sender that will be used to send messages to the playlist and ultimately to the application itself. So, instead of using a shared state and a timeout like we did in the previous chapter, we'll use message passing, which is more efficient.</p>
<p class="calibre3">We'll need a constructor for <span><kbd class="calibre14">EventLoop</kbd></span>:</p>
<pre class="calibre22"><span>impl</span> EventLoop <span>{</span>
    <span>fn</span> new() -&gt; <span>Self</span> <span>{</span>
        EventLoop <span>{</span>
            condition_variable: Arc::new((Mutex::new(<span>false</span>), Condvar::new())),
            queue: Arc::new(SegQueue::new()),
            playing: Arc::new(Mutex::new(<span>false</span>)),
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Let's create the constructor for <span><kbd class="calibre14">Player</kbd></span>:</p>
<pre class="calibre23"><span>impl</span> Player <span>{</span>
    <span>pub</span>(<span>crate</span>) <span>fn</span> new(tx: UnboundedSender&lt;PlayerMsg&gt;) -&gt; <span>Self</span> <span>{</span>
        <span>let</span> event_loop = EventLoop::new();

        <span>{</span>
            <span>let</span> <span>mut</span> tx = tx.clone();
            <span>let</span> event_loop = event_loop.clone();
            <span>let</span> condition_variable = event_loop.condition_variable.clone();
            thread::spawn(<span>move</span> || <span>{</span>
                <span>let</span> block = || <span>{</span>
                    <span>let</span> (<span>ref</span> lock, <span>ref</span> condition_variable) = *condition_variable;
                    <span>let</span> <span>mut</span> started = lock.lock().unwrap();
                    *started = <span>false</span>;
                    <span>while</span> !*started <span>{</span>
                        started = condition_variable.wait(started).unwrap();
                    <span>}</span>
                <span>}</span>;

                <span>let</span> <span>mut</span> buffer = <span>[[</span><span>0</span>; <span>2</span><span>]</span>; BUFFER_SIZE<span>]</span>;
                <span>let</span> <span>mut</span> playback = Playback::new(<span>"MP3"</span>, <span>"MP3 Playback"</span>, <span>None</span>,  <br class="calibre6"/>                DEFAULT_RATE);
                <span>let</span> <span>mut</span> source = <span>None</span>;
                <span>loop</span> <span>{</span>
                    <span>if</span> <span>let</span> <span>Some</span>(action) = event_loop.queue.try_pop() <span>{</span>
                        <span>match</span> action <span>{</span>
                            Load(path) =&gt; <span>{</span>
                                <span>let</span> file = File::open(path).unwrap();
                                source = <br class="calibre6"/><span>                Some</span>(Mp3Decoder::new(BufReader::new(file)).unwrap());
                                <span>let</span> rate = source.as_ref().map(|source|  <br class="calibre6"/>                                source.samples_rate()).unwrap_or(DEFAULT_RATE);
                                playback = Playback::new(<span>"MP3"</span>, <span>"MP3 Playback"</span>,  <br class="calibre6"/><span>                                 None</span>, rate);
                                send(&amp;<span>mut</span> tx, PlayerPlay);
                            <span>}</span>,
                            Stop =&gt; <span>{</span>
                                source = <span>None</span>;
                            <span>}</span>,
                        <span>}</span>
                    <span>}</span> <span>else</span> <span>if</span> *event_loop.playing.lock().unwrap() <span>{</span>
                        <span>let</span> <span>mut</span> written = <span>false</span>;
                        <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> source) = source <span>{</span>
                            <span>let</span> size = iter_to_buffer(source, &amp;<span>mut</span> buffer);
                            <span>if</span> size &gt; <span>0</span> <span>{</span>
                                send(&amp;<span>mut</span> tx, PlayerTime(source.current_time()));
                                playback.write(&amp;buffer<span>[</span>..size<span>]</span>);
                                written = <span>true</span>;
                            <span>}</span>
                        <span>}</span>

                        <span>if</span> !written <span>{</span>
                            send(&amp;<span>mut</span> tx, PlayerStop);
                            *event_loop.playing.lock().unwrap() = <span>false</span>;
                            source = <span>None</span>;
                            block();
                        <span>}</span>
                    <span>}</span> <span>else</span> <span>{</span>
                        block();
                    <span>}</span>
                <span>}</span>
            <span>}</span>);
        <span>}</span>

        Player <span>{</span>
            event_loop,
            paused: Cell::new(<span>false</span>),
            tx,
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">It is similar to the one we wrote in the previous chapter, but instead of using the shared state, we send messages back to the playlist. Here's an example of how we send these messages:</p>
<pre class="calibre22">send(&amp;<span>mut</span> tx, PlayerTime(source.current_time()));</pre>
<p class="calibre3">This sends the current time back to the UI so that it can display it. This requires the <span><kbd class="calibre14">send()</kbd></span> function to be defined:</p>
<pre class="calibre22">fn send(tx: &amp;mut UnboundedSender&lt;PlayerMsg&gt;, msg: PlayerMsg) {
    if let Ok(AsyncSink::Ready) = tx.start_send(msg) {
        tx.poll_complete().unwrap();
    } else {
        eprintln!("Unable to send message to sender");
    }
}</pre>
<p class="calibre3">This code uses the <span><kbd class="calibre14">future</kbd></span> crate to send the message and it shows an error in case it fails. The <span><kbd class="calibre14">iter_to_buffer()</kbd></span> function is the same as the one from the previous chapter:</p>
<pre class="calibre22"><span>fn</span> iter_to_buffer&lt;I: <span>Iterator</span>&lt;Item=<span>i16</span>&gt;&gt;(iter: &amp;<span>mut</span> I, buffer: &amp;<span>mut</span> <span>[[</span><span>i16</span>; <span>2</span><span>]</span>; BUFFER_SIZE<span>]</span>) -&gt; <span>usize</span> <span>{</span>
    <span>let</span> <span>mut</span> iter = iter.take(BUFFER_SIZE);
    <span>let</span> <span>mut</span> index = <span>0</span>;
    <span>while</span> <span>let</span> <span>Some</span>(sample1) = iter.next() <span>{</span>
        <span>if</span> <span>let</span> <span>Some</span>(sample2) = iter.next() <span>{</span>
            buffer<span>[</span>index<span>][</span><span>0</span><span>]</span> = sample1;
            buffer<span>[</span>index<span>][</span><span>1</span><span>]</span> = sample2;
        <span>}</span>
        index += <span>1</span>;
    <span>}</span>
    index
<span>}</span></pre>
<p class="calibre3">We'll now add the methods to play and pause a song:</p>
<pre class="calibre22"><span>pub</span> <span>fn</span> load&lt;P: AsRef&lt;Path&gt;&gt;(&amp;<span>self</span>, path: P) <span>{</span>
    <span>let</span> pathbuf = path.as_ref().to_path_buf();
    <span>self</span>.emit(Load(pathbuf));
    <span>self</span>.set_playing(<span>true</span>);
<span>}</span>

<span>pub</span> <span>fn</span> pause(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>self</span>.paused.set(<span>true</span>);
    <span>self</span>.send(PlayerStop);
    <span>self</span>.set_playing(<span>false</span>);
<span>}</span>

<span>pub</span> <span>fn</span> resume(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>self</span>.paused.set(<span>false</span>);
    <span>self</span>.send(PlayerPlay);
    <span>self</span>.set_playing(<span>true</span>);
<span>}</span></pre>
<p class="calibre3">They're very similar to the ones from the previous chapter, but we send a message instead of modifying a state. They require the following methods:</p>
<pre class="calibre22"><span>fn</span> emit(&amp;<span>self</span>, action: Action) <span>{</span>
    <span>self</span>.event_loop.queue.push(action);
<span>}</span>

<span>fn</span> send(&amp;<span>mut</span> <span>self</span>, msg: PlayerMsg) <span>{</span>
    send(&amp;<span>mut</span> <span>self</span>.tx, msg);
<span>}</span>

<span>fn</span> set_playing(&amp;<span>self</span>, playing: <span>bool</span>) <span>{</span>
    *<span>self</span>.event_loop.playing.lock().unwrap() = playing;
    <span>let</span> (<span>ref</span> lock, <span>ref</span> condition_variable) = *<span>self</span>.event_loop.condition_variable;
    <span>let</span> <span>mut</span> started = lock.lock().unwrap();
    *started = playing;
    <span>if</span> playing <span>{</span>
        condition_variable.notify_one();
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">The <span><kbd class="calibre14">emit()</kbd></span> and <span><kbd class="calibre14">set_playing()</kbd></span> methods are the same as in the previous chapter. The <span><kbd class="calibre14">send()</kbd></span> method simply calls the <span><kbd class="calibre14">send()</kbd></span> function we defined earlier.</p>
<p class="calibre3">We'll also need these two methods:</p>
<pre class="calibre22"><span>pub</span> <span>fn</span> is_paused(&amp;<span>self</span>) -&gt; <span>bool</span> <span>{</span>
    <span>self</span>.paused.get()
<span>}</span>

<span>pub</span> <span>fn</span> stop(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>self</span>.paused.set(<span>false</span>);
    <span>self</span>.send(PlayerTime(<span>0</span>));
    <span>self</span>.send(PlayerStop);
    <span>self</span>.emit(Stop);
    <span>self</span>.set_playing(<span>false</span>);
<span>}</span></pre>
<p class="calibre3">The <span><kbd class="calibre14">is_paused()</kbd></span> method has not changed. And the <span><kbd class="calibre14">stop()</kbd></span> method is similar, but again, it sends messages instead of updating the application state directly. Let's go back to our <span><kbd class="calibre14">Paylist</kbd></span> to use this new player. The model will now contain the player itself:</p>
<pre class="calibre22"><span>use</span> player::Player;

<span>pub</span> <span>struct</span> Model <span>{</span>
    current_song: <span>Option</span>&lt;<span>String</span>&gt;,
    player: Player,
    model: ListStore,
    relm: Relm&lt;Playlist&gt;,
<span>}</span></pre>
<p class="calibre3">The <span><kbd class="calibre14">Msg</kbd></span> type will contain a new variant called <span><kbd class="calibre14">PlayerMsgRecv</kbd></span> that will be emitted whenever the player sends a message:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span>Msg<span>)]</span>
<span>pub</span> <span>enum</span> Msg <span>{</span>
    AddSong(PathBuf),
    LoadSong(PathBuf),
    NextSong,
    PauseSong,
    PlayerMsgRecv(PlayerMsg),
    PlaySong,
    PreviousSong,
    RemoveSong,
    SaveSong(PathBuf),
    SongStarted(<span>Option</span>&lt;Pixbuf&gt;),
    StopSong,
<span>}</span></pre>
<p class="calibre3">We're now ready to update the model initialization:</p>
<pre class="calibre22"><span>use</span> futures::sync::mpsc;

<span>fn</span> model(relm: &amp;Relm&lt;<span>Self</span>&gt;, _: ()) -&gt; Model <span>{</span>
    <span>let</span> (tx, rx) = mpsc::unbounded();
    relm.connect_exec_ignore_err(rx, PlayerMsgRecv);
    Model <span>{</span>
        current_song: <span>None</span>,
        player: Player::new(tx),
        model: ListStore::new(&amp;<span>[</span>
            Pixbuf::static_type(),
            Type::<span>String</span>,
            Type::<span>String</span>,
            Type::<span>String</span>,
            Type::<span>String</span>,
            Type::<span>String</span>,
            Type::<span>String</span>,
            Type::<span>String</span>,
            Pixbuf::static_type(),
        <span>]</span>),
        relm: relm.clone(),
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">It now creates a sender and receiver pair from the <span><kbd class="calibre14">mpsc</kbd></span> type of the <span><kbd class="calibre14">future</kbd></span> crate. <strong class="calibre5">MPSC</strong> stands for <strong class="calibre5">Multiple-Producers-Single-Consumer</strong>. We now call the <span><kbd class="calibre14">Relm::connect_exec_ignore_err()</kbd></span> method, this method connects a <span><kbd class="calibre14">Future</kbd></span> or a <span><kbd class="calibre14">Stream</kbd></span> to a message. This means that whenever a value is produced in the <span><kbd class="calibre14">Stream</kbd></span>, a message will be emitted. The message needs to take a parameter of the same type as the value produced by the <span><kbd class="calibre14">Stream</kbd></span>. A <span><kbd class="calibre14">Future</kbd></span> represents a value that is possibly not yet available, but will be available in the future, unless an error happens. A <span><kbd class="calibre14">Stream</kbd></span> is similar, but can produce multiple values that will be available at different times in the future. Similar to the <span><kbd class="calibre14">connect_exec_ignore_err()</kbd></span> method, there's also the <span><kbd class="calibre14">connect_exec()</kbd></span> method, which takes another message variant as a parameter, this second message will be emitted when there's an error. Here, we simply ignore the errors.</p>
<p class="calibre3">In the <span><kbd class="calibre14">update()</kbd></span> method:</p>
<pre class="calibre22"><span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        <span>// To be listened by App.</span>
        PlayerMsgRecv(_) =&gt; (),
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We have nothing to do with this message because it will be handled by the <span><kbd class="calibre14">App</kbd></span> widget. We'll now add a method to pause the player:</p>
<pre class="calibre22"><span>fn</span> pause(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>self</span>.model.player.pause();
<span>}</span></pre>
<p class="calibre3">Next we need to update the <span><kbd class="calibre14">play()</kbd></span> and <span><kbd class="calibre14">stop()</kbd></span> methods:</p>
<pre class="calibre22"><span>fn</span> play(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>if</span> <span>let</span> <span>Some</span>(path) = <span>self</span>.selected_path() <span>{</span>
        <span>if</span> <span>self</span>.model.player.is_paused() &amp;&amp; <span>Some</span>(&amp;path) == <span>self</span>.path().as_ref() <span>{</span>
            <span>self</span>.model.player.resume();
        <span>}</span> <span>else</span> <span>{</span>
            <span>self</span>.model.player.load(&amp;path);
            <span>self</span>.model.current_song = <span>Some</span>(path.into());
            <span>self</span>.model.relm.stream().emit(SongStarted(<span>self</span>.pixbuf()));
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>fn</span> stop(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>self</span>.model.current_song = <span>None</span>;
    <span>self</span>.model.player.stop();
<span>}</span></pre>
<p class="calibre3">The <span><kbd class="calibre14">stop()</kbd></span> method is the same, except that we can update the model directly, because we don't need to use the <span><kbd class="calibre14">RefCell</kbd></span> type anymore. The <span><kbd class="calibre14">play()</kbd></span> method will now load or resume the song depending on the state of the player.</p>
<p class="calibre3">The <span><kbd class="calibre14">play()</kbd></span> method requires a <span><kbd class="calibre14">path()</kbd></span> method:</p>
<pre class="calibre22"><span>fn</span> path(&amp;<span>self</span>) -&gt; <span>Option</span>&lt;<span>String</span>&gt; <span>{</span>
    <span>self</span>.model.current_song.clone()
<span>}</span></pre>
<p class="calibre3">Let's go back to the <kbd class="calibre14">main</kbd> module to manage the messages sent by the player. First, we need a new variant for our <span><kbd class="calibre14">enum Msg</kbd></span>:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span>Msg<span>)]</span>
<span>pub</span> <span>enum</span> Msg <span>{</span>
    MsgRecv(PlayerMsg),
    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">We will handle this in the <span><kbd class="calibre14">update()</kbd></span> method:</p>
<pre class="calibre22"><span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        MsgRecv(player_msg) =&gt; <span>self</span>.player_message(player_msg),
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">This requires a new method to be added in <span><kbd class="calibre14">impl Widget for App</kbd></span>:</p>
<pre class="calibre22">#[widget]
impl Widget for App {
    fn player_message(&amp;mut self, player_msg: PlayerMsg) {
        match player_msg {
            PlayerPlay =&gt; {
                self.model.stopped = false;
                self.set_play_icon(PAUSE_ICON);
            },
            PlayerStop =&gt; {
                self.set_play_icon(PLAY_ICON);
                self.model.stopped = true;
            },
            PlayerTime(time) =&gt; self.set_current_time(time),
        }
    }
}</pre>
<p class="calibre3">This is also a <kbd class="calibre14">custom</kbd> method, that is, a method that is not part of the <span><kbd class="calibre14">Widget</kbd></span> trait, but is analyzed by the <span><kbd class="calibre14">#[widget]</kbd></span> attribute. We put it there instead of a separate <span><kbd class="calibre14">impl App</kbd></span> because we updated the model. In this method, we either update the icon to display the play button or the current time.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Computing the song duration</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The only remaining feature that needs to be implemented in order to be on par with the music player of the previous chapter is to compute and display the song duration. First, we will copy the <span><kbd class="calibre14">compute_duration()</kbd></span> method from the previous chapter and paste it in our <span><kbd class="calibre14">Player</kbd></span>:</p>
<pre class="calibre22">pub fn compute_duration&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Option&lt;Duration&gt; {
    let file = File::open(path).unwrap();
    Mp3Decoder::compute_duration(BufReader::new(file))
}</pre>
<p class="calibre3">We'll now call this method in the <span><kbd class="calibre14">Playlist</kbd></span>:</p>
<pre class="calibre22"><span>use</span> std::thread;
<span>use</span> futures::sync::oneshot;

<span>fn</span> compute_duration(&amp;<span>self</span>, path: &amp;Path) <span>{</span>
    <span>let</span> path = path.to_path_buf();
    <span>let</span> (tx, rx) = oneshot::channel();
    thread::spawn(<span>move</span> || <span>{</span>
        <span>if</span> <span>let</span> <span>Some</span>(duration) = Player::compute_duration(&amp;path) <span>{</span>
            tx.send((path, duration))
                .expect(<span>"Cannot send computed duration"</span>);
        <span>}</span>
    <span>}</span>);
    <span>self</span>.model.relm.connect_exec_ignore_err(rx, |(path, duration)| DurationComputed(path, duration));
<span>}</span></pre>
<p class="calibre3">Here, we use <span><kbd class="calibre14">oneshot</kbd></span> which is also a channel, similar to <span><kbd class="calibre14">mpsc</kbd></span>, but <span><kbd class="calibre14">oneshot</kbd></span> can only send a message once. The message sent is a tuple, so we convert it to our <span><kbd class="calibre14">Msg</kbd></span> type by using a new <span><kbd class="calibre14">DurationComputed</kbd></span> variant that we'll add to the type:</p>
<pre class="calibre22"><span>use</span> std::time::Duration;

<span>#[</span>derive<span>(</span>Msg<span>)]</span>
<span>pub</span> <span>enum</span> Msg <span>{</span>
    AddSong(PathBuf),
    DurationComputed(PathBuf, Duration),
    SongDuration(<span>u64</span>),
    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">We've also added a <span><kbd class="calibre14">SongDuration</kbd></span> message that we'll use soon.</p>
<p class="calibre3">We need to call this method in <span><kbd class="calibre14">Playlist::add()</kbd></span>:</p>
<pre class="calibre22"><span>impl</span> Playlist <span>{</span>
    <span>fn</span> add(&amp;<span>self</span>, path: &amp;Path) <span>{</span>
        <span>self</span>.compute_duration(path);
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We then need to handle the new <span><kbd class="calibre14">DurationComputed</kbd></span> message in <span><kbd class="calibre14">Playlist::update()</kbd></span>:</p>
<pre class="calibre22"><span>use</span> to_millis;

<span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        DurationComputed(path, duration) =&gt; <span>{</span>
            <span>let</span> path = path.to_string_lossy().to_string();
            <span>if</span> <span>self</span>.model.current_song.as_ref() == <span>Some</span>(&amp;path) <span>{</span>
                <span>self</span>.model.relm.stream().emit(SongDuration(to_millis(duration)));
            <span>}</span>
            <span>self</span>.model.durations.insert(path, to_millis(duration));
        <span>}</span>,
        <span>// To be listened by App.</span>
        SongDuration(_) =&gt; (),
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Here, we insert the computed duration in the model. And if the song is the one currently being played, we send the <span><kbd class="calibre14">SongDuration</kbd></span> message so that the <span><kbd class="calibre14">App</kbd></span> widget can update itself.</p>
<p class="calibre3">This requires a new field for the durations in the model:</p>
<pre class="calibre22"><span>use</span> std::collections::HashMap;

<span>pub</span> <span>struct</span> Model <span>{</span>
    current_song: <span>Option</span>&lt;<span>String</span>&gt;,
    durations: HashMap&lt;<span>String</span>, <span>u64</span>&gt;,
    player: Player,
    model: ListStore,
    relm: Relm&lt;Playlist&gt;,
<span>}</span></pre>
<p class="calibre3">Add the new model initialization:</p>
<pre class="calibre22"><span>fn</span> model(relm: &amp;Relm&lt;<span>Self</span>&gt;, _: ()) -&gt; Model <span>{</span>
    <span>// …</span>
    Model <span>{</span>
        durations: HashMap::new(),
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">This also requires the <span><kbd class="calibre14">to_millis()</kbd></span> function to be added in the <kbd class="calibre14">main</kbd> module, which is the same as in the previous chapter:</p>
<pre class="calibre22"><span>use</span> std::time::Duration;

<span>fn</span> to_millis(duration: Duration) -&gt; <span>u64</span> <span>{</span>
    duration.as_secs() * <span>1000</span> + duration.subsec_nanos() <span>as</span> <span>u64</span> / <span>1_000_000</span>
<span>}</span></pre>
<p class="calibre3">Since the duration is only computed once, we also need to send it when we start playing the song, so let's update the <span><kbd class="calibre14">Playlist::play()</kbd></span> method:</p>
<pre class="calibre22"><span>fn</span> play(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>if</span> <span>let</span> <span>Some</span>(path) = <span>self</span>.selected_path() <span>{</span>
        <span>if</span> <span>self</span>.model.player.is_paused() &amp;&amp; <span>Some</span>(&amp;path) == <span>self</span>.path().as_ref() <span>{</span>
            <span>self</span>.model.player.resume();
        <span>}</span> <span>else</span> <span>{</span>
            <span>self</span>.model.player.load(&amp;path);
            <span>if</span> <span>let</span> <span>Some</span>(&amp;duration) = <span>self</span>.model.durations.get(&amp;path) <span>{</span>
                <span>self</span>.model.relm.stream().emit(SongDuration(duration));
            <span>}</span>
            <span>self</span>.model.current_song = <span>Some</span>(path.into());
            <span>self</span>.model.relm.stream().emit(SongStarted(<span>self</span>.pixbuf()));
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We send the <span><kbd class="calibre14">SongDuration</kbd></span> message if we found it in the <span><kbd class="calibre14">HashMap</kbd></span> (it is possible that the song starts playing before the duration is computed).</p>
<p class="calibre3">Finally, we need to handle the following message in the <span><kbd class="calibre14">App</kbd></span> view:</p>
<pre class="calibre22"><span>view!</span> <span>{</span>
    Playlist <span>{</span>
        PlayerMsgRecv(<span>ref</span> player_msg) =&gt; MsgRecv(player_msg.clone()),
        SongDuration(duration) =&gt; Duration(duration),
        SongStarted(<span>ref</span> pixbuf) =&gt; Started(pixbuf.clone()),
    <span>}</span>
    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">When we receive the <span><kbd class="calibre14">SongDuration</kbd></span> message from the playlist, we send the <span><kbd class="calibre14">Duration</kbd></span> message to <span><kbd class="calibre14">App</kbd></span>, so we need to add this variant to its <span><kbd class="calibre14">Msg</kbd></span> type:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span>Msg<span>)]</span>
<span>pub</span> <span>enum</span> Msg <span>{</span>
    Duration(<span>u64</span>),
    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">We'll simply handle it in the <span><kbd class="calibre14">update()</kbd></span> method:</p>
<pre class="calibre22"><span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        Duration(duration) =&gt; <span>{</span>
            <span>self</span>.model.current_duration = duration;
            <span>self</span>.model.adjustment.set_upper(duration <span>as</span> <span>f64</span>);
        <span>}</span>,
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">You can now run the application and see that it works exactly the same as the one from the previous chapter.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Using relm on stable Rust</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In this whole chapter, we used Rust nightly to be able to use <kbd class="calibre14">custom</kbd> attributes, which are currently unstable. The <span><kbd class="calibre14">#[widget]</kbd></span> attribute provided by <span><kbd class="calibre14">relm</kbd></span> provides many advantages:</p>
<ul class="calibre10">
<li class="calibre11">Declarative view</li>
<li class="calibre11">Data bindings</li>
<li class="calibre11">Less typing</li>
</ul>
<p class="calibre3">So it would be nice to be able to use a similar syntax on stable that provides the same advantages. And it is possible to do so, by using the <span><kbd class="calibre14">relm_widget!</kbd></span> macro. We'll rewrite the <span><kbd class="calibre14">App</kbd></span> widget to use this macro:</p>
<pre class="calibre22"><span>relm_widget!</span> <span>{</span>
    <span>impl</span> Widget <span>for</span> App <span>{</span>
        <span>fn</span> init_view(&amp;<span>mut</span> <span>self</span>) <span>{</span>
            <span>self</span>.toolbar.show_all();
        <span>}</span>

        <span>fn</span> model() -&gt; Model <span>{</span>
            Model <span>{</span>
                adjustment: Adjustment::new(<span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>0.0</span>, <span>0.0</span>),
                cover_pixbuf: <span>None</span>,
                cover_visible: <span>false</span>,
                current_duration: <span>0</span>,
                current_time: <span>0</span>,
                play_image: new_icon(PLAY_ICON),
                stopped: <span>true</span>,
            <span>}</span>
        <span>}</span>

        <span>fn</span> open(&amp;<span>self</span>) <span>{</span>
            <span>// …</span>
        <span>}</span>

        <span>// …</span>

        <span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
            <span>// …</span>
        <span>}</span>

        <span>view!</span> <span>{</span>
            <span>#[</span>name<span>=</span><span>"window"</span><span>]</span>
            gtk::Window <span>{</span>
                title: <span>"Rusic"</span>,
                <span>// …</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">As you can see, we moved the external <span><kbd class="calibre14">open()</kbd></span> method inside the implementation decorated by the <span><kbd class="calibre14">relm_widget!</kbd></span> macro. This is due to a limitation of this macro, while it allows us to use the nice syntax provided by relm on stable Rust, we cannot access the fields of the model from outside the macro. The rest is exactly the same as the previous versions.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Relm widgets data binding</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">There are many other features available in relm and I wanted to show you the most important of them: the syntax that is provided to simulate property binding. As you may have noticed by now, there's no property in <kbd class="calibre14">relm</kbd> widgets, but you can use message passing to update the internal state of a <span><kbd class="calibre14">relm</kbd></span> widget. To make it more convenient, the <span><kbd class="calibre14">#[widget]</kbd></span> attribute also allows you to bind a model attribute to a message, this means that whenever the attribute is updated, the message will be emitted with this new value.</p>
<p class="calibre3">We'll add a toggle button to be able to switch between a simple and a detailed view for the playlist. The simple view will only show the cover and the title while the detailed view will show all the columns. First, let's add an attribute to the <span><kbd class="calibre14">App</kbd></span> model:</p>
<pre class="calibre22"><span>pub</span> <span>struct</span> Model <span>{</span>
    detailed_view: <span>bool</span>,
    <span>// …</span>
<span>}</span>

    <span>fn</span> model() -&gt; Model <span>{</span>
        Model <span>{</span>
            detailed_view: <span>false</span>,
            <span>// …</span>
        <span>}</span>
    <span>}</span></pre>
<p class="calibre3">This field specifies whether we're in the detailed view mode or not. We'll also need a message that will be emitted when we click the toggle button:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span>Msg<span>)]</span>
<span>pub</span> <span>enum</span> Msg <span>{</span>
    ViewToggle,
    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">Then, we add the toggle button to the toolbar:</p>
<pre class="calibre22"><span>#[</span>name<span>=</span><span>"toggle_button"</span><span>]</span>
gtk::ToggleToolButton <span>{</span>
    label: <span>"Detailed view"</span>,
    toggled =&gt; ViewToggle,
<span>}</span></pre>
<p class="calibre3">When we receive this message, we'll set the <kbd class="calibre14">model</kbd> attribute accordingly:</p>
<pre class="calibre22"><span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        ViewToggle =&gt; <span>self</span>.model.detailed_view = <span>self</span>.toggle_button.get_active(),
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Now, let's a message to the <span><kbd class="calibre14">Playlist</kbd></span>:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span>Msg<span>)]</span>
<span>pub</span> <span>enum</span> Msg <span>{</span>
    DetailedView(<span>bool</span>),
    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">This is the message we'll use for the binding. Let's handle it:</p>
<pre class="calibre22"><span>fn</span> update(&amp;<span>mut</span> <span>self</span>, event: Msg) <span>{</span>
    <span>match</span> event <span>{</span>
        DetailedView(detailed) =&gt; <span>self</span>.set_detailed_view(detailed),
        <span>// …</span>
    <span>}</span>
<span>}</span>

<span>fn</span> set_detailed_view(&amp;<span>self</span>, detailed: <span>bool</span>) <span>{</span>
    <span>for</span> column <span>in</span> <span>self</span>.treeview.get_columns().iter().skip(<span>2</span>) <span>{</span>
        column.set_visible(detailed);
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">The latter method toggles the visible of all columns except the first two. We can now create the binding in the <span><kbd class="calibre14">App</kbd></span> view:</p>
<pre class="calibre22">use playlist::Msg::DetailedView;

view! {
    // …
    #[name="playlist"]
    Playlist {
        // …
        DetailedView: self.model.detailed_view,
    }
}</pre>
<p class="calibre3">This code will send the <span><kbd class="calibre14">DetailedView</kbd></span> message with the specified attribute as the value whenever it changes.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In this chapter, we used <span><kbd class="calibre14">relm</kbd></span> to create a music player. We saw how simple it is to use rust nightly with <span><kbd class="calibre14">rustup</kbd></span>. We learned how to declaratively create views and use message passing to communicate between widgets. We also learned how to structure GUI applications by separating the model, the view, and the function to update the model in reaction to events. In the next chapter, we'll switch to another project: an FTP server.</p>
<p class="calibre3"/>


            </article>

            
        </section>
    </body></html>