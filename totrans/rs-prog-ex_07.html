<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Music Player in a More Rusty Way with Relm</h1>
                
            
            
                
<p class="calibre3">In the previous chapter, we finished our music player. It is completely fine, but using <kbd class="calibre14">gtk-rs</kbd> directly in Rust can be error-prone. That's why we'll rewrite our music player using <kbd class="calibre14">relm</kbd>, an idiomatic GUI library for Rust. <kbd class="calibre14">Relm</kbd> is based on <kbd class="calibre14">gtk-rs</kbd>, so the application will look the same at the end. However, the code will be cleaner and more declarative.</p>
<p class="calibre3">We will cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Relm</li>
<li class="calibre11">Relm widgets</li>
<li class="calibre11">Model-view-controller</li>
<li class="calibre11">Declarative view</li>
<li class="calibre11">Message passing</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Reasons to use relm instead of gtk-rs directly</h1>
                
            
            
                
<p class="calibre3">As you have seen in the previous chapters, we used concepts that were not really obvious, and doing certain things that would normally be easy to do aren't that easy when using GTK+ with Rust. These are some of the many reasons to use <kbd class="calibre14">relm</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">State mutation</h1>
                
            
            
                
<p class="calibre3">It might not be clear from the previous chapter, but we indirectly used <kbd class="calibre14">Rc&lt;RefCell&lt;T&gt;&gt;</kbd> to do state mutation. Indeed, our <kbd class="calibre14">Playlist</kbd> type contains a <kbd class="calibre14">RefCell&lt;Option&lt;String&gt;&gt;</kbd> and we wrapped our <kbd class="calibre14">Playlist</kbd> inside a reference-counted pointer. This was to be able to mutate the state in reaction to events, for instance playing the song when clicking the play button:</p>
<pre class="calibre22">let playlist = self.playlist.clone();
let play_image = self.toolbar.play_image.clone();
let cover = self.cover.clone();
let state = self.state.clone();
self.toolbar.play_button.connect_clicked(move |_| {
    if state.lock().unwrap().stopped {
        if playlist.play() {
            set_image_icon(&amp;play_image, PAUSE_ICON);
            set_cover(&amp;cover, &amp;playlist);
        }
    } else {
        playlist.pause();
        set_image_icon(&amp;play_image, PLAY_ICON);
    }
});</pre>
<p class="calibre3">Having to use all these calls to <kbd class="calibre14">clone()</kbd> is cumbersome and using the <kbd class="calibre14">RefCell&lt;T&gt;</kbd> type can lead to issues that are hard to debug in complex applications. The issue with this type is that the borrow checking happens at runtime. For instance, the following application:</p>
<pre class="calibre22">use std::cell::RefCell;
use std::collections::HashMap;

fn main() {
    let cell = RefCell::new(HashMap::new());
    cell.borrow_mut().insert("one", 1);
    let borrowed_cell = cell.borrow();
    if let Some(key) = borrowed_cell.get("one") {
        cell.borrow_mut().insert("two", 2);
    }
}</pre>
<p class="calibre3">Will panic:</p>
<pre class="calibre22">thread 'main' panicked at 'already borrowed: BorrowMutError', /checkout/src/libcore/result.rs:906:4</pre>
<p class="calibre3">Even though it is obvious why it panics in this example (we called <kbd class="calibre14">borrow_mut()</kbd> when the borrow was still alive in <kbd class="calibre14">borrowed_cell</kbd>), in more complex applications, it will be harder to understand why the panic happens, especially if we wrap the <kbd class="calibre14">RefCell&lt;T&gt;</kbd> in an <kbd class="calibre14">Rc</kbd> and clone it everywhere. This brings us to the second issue with this type: using <kbd class="calibre14">Rc&lt;T&gt;</kbd> encourages us to clone our data and share it too much which increases the coupling between our modules.</p>
<p class="calibre3">The <kbd class="calibre14">relm</kbd> crate takes a different approach: widgets owns their data and the different widgets communicate between them using message passing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Asynchronous user interface</h1>
                
            
            
                
<p class="calibre3">Another common issue when creating user interfaces is that we might want to perform an action that might take time (such as a network request) without freezing the UI. By being based on <kbd class="calibre14">tokio</kbd>, an asynchronous I/O framework for Rust, <kbd class="calibre14">relm</kbd> allows you to easily program graphical user interfaces that can perform network requests without freezing the interface itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating custom widgets</h1>
                
            
            
                
<p class="calibre3">In object-oriented languages, it is very easy to create new widgets and use them like built-in widgets. In this paradigm, you only need to create a new class that inherits from a widget and that's it.</p>
<p class="calibre3">In <a target="_blank" href="part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 5</a>, <em class="calibre21">Creating a Music Player</em>, we created custom widgets, such as <kbd class="calibre14">Playlist</kbd> and <kbd class="calibre14">MusicToolbar</kbd>, but we needed to create a function to get the real GTK+ widget:</p>
<pre class="calibre22">pub fn view(&amp;self) -&gt; &amp;TreeView {
    &amp;self.treeview
}</pre>
<p class="calibre3">An alternative would have been to implement the <kbd class="calibre14">Deref</kbd> trait:</p>
<pre class="calibre22">use std::ops::Deref;

impl Deref for Playlist {
    type Target = TreeView;

    fn deref(&amp;self) -&gt; &amp;TreeView {
        &amp;self.treeview
    }
}</pre>
<p class="calibre3">That implementation would allow us to add the widget to its <kbd class="calibre14">parent</kbd> like this:</p>
<pre class="calibre22">parent.add(&amp;*playlist);</pre>
<p class="calibre3">(Note the leading <kbd class="calibre14">*</kbd> in front of <kbd class="calibre14">playlist</kbd> which is the call to <kbd class="calibre14">deref()</kbd>.)</p>
<p class="calibre3">Instead of adding it in the following way:</p>
<pre class="calibre22">parent.add(playlist.view());</pre>
<p class="calibre3">But it is still different than when using normal <kbd class="calibre14">gtk</kbd> widgets.</p>
<p class="calibre3"><kbd class="calibre14">Relm</kbd> solves all of these issues. Let's start using this crate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a window with relm</h1>
                
            
            
                
<p class="calibre3">First of all, we'll use the nightly version of the Rust compiler.</p>
<div><p class="calibre24">While using this nightly version is not strictly necessary to use <kbd class="calibre25">relm</kbd>, it provides a syntax that is a bit nicer using a feature that is only available on this version.</p>
</div>
<p class="calibre3">That will be a good opportunity to learn how to install a different version of the compiler. Nightly is the unstable version of Rust; it's a version that is compiled almost every day. Some unstable features of Rust are only available on nightly. But, don't worry, we'll also see how to use <kbd class="calibre14">relm</kbd> on the stable version of Rust.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing Rust nightly</h1>
                
            
            
                
<p class="calibre3">With <kbd class="calibre14">rustup</kbd>, the tool we installed in <a target="_blank" href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>, it is very easy to install nightly:</p>
<pre class="calibre23"><strong class="calibre5">rustup default nightly</strong></pre>
<p class="calibre3">Running this command will install the nightly version of the tools (<kbd class="calibre14">cargo</kbd>, <kbd class="calibre14">rustc</kbd>, and so on). Also, it will switch the corresponding commands to use the nightly version.</p>
<p class="calibre3">If you want to go back to the stable version, issue the following command:</p>
<pre class="calibre23"><strong class="calibre5">rustup default stable</strong></pre>
<p class="calibre3">The nightly version is updated very frequently, so you might want to update it every week or more often. To do so, you need to run this command:</p>
<pre class="calibre23"><strong class="calibre5">rustup update</strong></pre>
<p class="calibre3">This will also update the stable version if a new version was released (one stable version is released every 6 weeks).</p>
<p class="calibre3">Now that we are using Rust nightly, we're ready to create a <kbd class="calibre14">new</kbd> project:</p>
<pre class="calibre23"><strong class="calibre5">cargo new rusic-relm --bin</strong></pre>
<p class="calibre3">Add the following dependencies in the <kbd class="calibre14">Cargo.toml</kbd> file:</p>
<pre class="calibre22">[dependencies]
gtk = "^0.3.0"
gtk-sys = "^0.5.0"
relm = "^0.11.0"
relm-attributes = "^0.11.0"
relm-derive = "^0.11.0"</pre>
<p class="calibre3">We still need <kbd class="calibre14">gtk</kbd> because <kbd class="calibre14">relm</kbd> is based on it. Let's add the corresponding <kbd class="calibre14">extern crate</kbd> statements:</p>
<pre class="calibre22">#![feature(proc_macro)]

extern crate gtk;
extern crate gtk_sys;
#[macro_use]
extern crate relm;
extern crate relm_attributes;
#[macro_use]
extern crate relm_derive;</pre>
<p class="calibre3"><kbd class="calibre14">relm</kbd> provides some macros, that's why we needed to add <kbd class="calibre14">#[macro_use]</kbd>. We'll start slowly by creating a simple window with <kbd class="calibre14">relm</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Widget</h1>
                
            
            
                
<p class="calibre3">This crate is centered around the concept of widgets, which are different than the <kbd class="calibre14">gtk</kbd> widgets. In <kbd class="calibre14">relm</kbd>, a widget is composed of a view, a model, and a method to update the model in reaction to events. The concept of widget is implemented by a trait in <kbd class="calibre14">relm</kbd>: the <kbd class="calibre14">Widget</kbd> trait.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Model</h1>
                
            
            
                
<p class="calibre3">We'll start with an empty model and we'll populate it later in this chapter:</p>
<pre class="calibre22">pub struct Model {
}</pre>
<p class="calibre3">As you can see, a model can be a simple structure. It could also be <kbd class="calibre14">()</kbd> if your widget don't need a model. Actually, it can be any type you want.</p>
<p class="calibre3">Besides the model, a widget needs to know the initial value of its model. To specify what it is, we need to implement the <kbd class="calibre14">model()</kbd> method of the <kbd class="calibre14">Widget</kbd> trait:</p>
<pre class="calibre22">#[widget]
impl Widget for App {
    fn model() -&gt; Model {
        Model {
        }
    }

    // …
}</pre>
<p class="calibre3">Here, we use the <kbd class="calibre14">#[widget]</kbd> attribute provided by the <kbd class="calibre14">relm_attributes</kbd> crate. Attributes are currently an unstable feature of the language, that's why we use nightly. We'll see in the section about the declarative view why this attribute is needed. So, let's go back to our <kbd class="calibre14">model()</kbd> model, we only return <kbd class="calibre14">Model {}</kbd> for now as our model does not contain any data. Other methods are needed for this trait, so this implementation is incomplete for now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Messages</h1>
                
            
            
                
<p class="calibre3"><kbd class="calibre14">Relm</kbd> widgets communicate by sending messages to other widgets, but also to themselves. For instance, when the <kbd class="calibre14">delete_event</kbd> signal is emitted, we can emit the <kbd class="calibre14">Quit</kbd> message to our widget and take appropriate action when we receive this message. A message is modeled as an <kbd class="calibre14">enum</kbd> using the custom derive <kbd class="calibre14">Msg</kbd> that is specific to <kbd class="calibre14">relm</kbd>:</p>
<pre class="calibre22">#[derive(Msg)]
pub enum Msg {
    Quit,
}</pre>
<p class="calibre3">This custom derive is provided by the <kbd class="calibre14">relm_derive</kbd> crate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">View</h1>
                
            
            
                
<p class="calibre3">Views are created in a declarative way in <kbd class="calibre14">relm</kbd> as a part of the <kbd class="calibre14">Widget</kbd> trait:</p>
<pre class="calibre22">use gtk::{
    GtkWindowExt,
    Inhibit,
    WidgetExt,
};
use relm::Widget;
use relm_attributes::widget;

use self::Msg::*;

#[widget]
impl Widget for App {
    // …

    view! {
        gtk::Window {
            title: "Rusic",
            delete_event(_, _) =&gt; (Quit, Inhibit(false)),
        }
    }
}</pre>
<p class="calibre3">We first imported some stuff from the <kbd class="calibre14">gtk</kbd> crate. Then we imported the <kbd class="calibre14">Widget</kbd> trait from <kbd class="calibre14">relm</kbd> and the <kbd class="calibre14">widget</kbd> attribute. Later, we imported the variant of our <kbd class="calibre14">enum Msg</kbd> because we use it in this code. To declare the view, we use the <kbd class="calibre14">view!</kbd> macro. This macro is very particular, it is not a macro that is declared as <kbd class="calibre14">macro_rules!</kbd>, as we saw in <a target="_blank" href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>. Instead, it is parsed by the procedural macro implementing the <kbd class="calibre14">#[widget]</kbd> attribute in order to provide a syntax that is not allowed in Rust.</p>
<p class="calibre3">To declare our view, we first specify the name of the <kbd class="calibre14">gtk::Window</kbd> widget.</p>
<div><p class="calibre24">We cannot import <kbd class="calibre25">gtk::Window</kbd> to be able to use only <kbd class="calibre25">Window</kbd> in the declaration of the view.</p>
</div>
<p class="calibre3">After that, we use curly brackets and inside them, we specify the properties and events handled by the widget.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Properties</h1>
                
            
            
                
<p class="calibre3">Here, we declare that the <kbd class="calibre14">title</kbd> property is <kbd class="calibre14">"Rusic"</kbd>. So we transformed the <kbd class="calibre14">set_title()</kbd> call from <kbd class="calibre14">gtk</kbd> to the <kbd class="calibre14">title</kbd> property, only the part after <kbd class="calibre14">set_</kbd> is needed. Actually, <kbd class="calibre14">relm</kbd> will convert the property (<kbd class="calibre14">title: "Rusic"</kbd>) to the <kbd class="calibre14">set_title("Rusic")</kbd> call, as we'll see later.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Events</h1>
                
            
            
                
<p class="calibre3">The syntax of the event handler is a bit special:</p>
<pre class="calibre22">delete_event(_, _) =&gt; (Quit, Inhibit(false)),</pre>
<p class="calibre3">First, we only need to write <kbd class="calibre14">delete_event(_, _) =&gt;</kbd> instead of <kbd class="calibre14">connect_delete_event(move |_, _| { })</kbd>. If we needed the arguments of the signal, we could have written the name of an identifier instead of using underscores (<kbd class="calibre14">_</kbd>). On the right side of the fat arrow (<kbd class="calibre14">=&gt;</kbd>), we specify two things between parentheses and separated by a comma. First, there's <kbd class="calibre14">Quit</kbd>, which is the message that will be sent to the current widget when the event is emitted. And second is the value to return to the <kbd class="calibre14">gtk</kbd> callback. Here, we return <kbd class="calibre14">Inhibit(false)</kbd> to specify that we don't want to prevent the default event handler from running.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Code generation</h1>
                
            
            
                
<p class="calibre3">The code generated by the attribute is a normal Rust method that looks like:</p>
<pre class="calibre22">fn view(relm: &amp;Relm&lt;Self&gt;, model: Self::Model) -&gt; Self {
   // This method does not actually exist, but relm directly create a window using the functions from the sys crates.
    let window = gtk::Window::new();
    window.set_title("Rusic");

    window.show();

    connect!(relm, window, connect_delete_event(_, _), return <br class="calibre6"/>     (Some(Quit), Inhibit(false)));

    Win {
        model,
        window: window,
    }
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Update function</h1>
                
            
            
                
<p class="calibre3">The only remaining required method of the <kbd class="calibre14">Widget</kbd> trait is <kbd class="calibre14">update()</kbd>. In this method, we'll manage the <kbd class="calibre14">Quit</kbd> message:</p>
<pre class="calibre22">#[widget]
impl Widget for App {
    fn update(&amp;mut self, event: Msg) {
        match event {
            Quit =&gt; gtk::main_quit(),
        }
    }

    // …
}</pre>
<p class="calibre3">Here, we specify that when we receive the <kbd class="calibre14">Quit</kbd> message, we call <kbd class="calibre14">gtk::main_quit()</kbd>, which is a function similar to <kbd class="calibre14">Application::quit()</kbd> that we used in <a target="_blank" href="part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 5</a>, <em class="calibre21">Creating a Music Player</em>.</p>
<p class="calibre3">It should be noted that the <kbd class="calibre14">#[widget]</kbd> attribute will also generate the <kbd class="calibre14">App</kbd> structure that will contain the widgets and the model.</p>
<p class="calibre3">We can finally show this window by calling its <kbd class="calibre14">run()</kbd> method in the <kbd class="calibre14">main</kbd> function:</p>
<pre class="calibre22">fn main() {
    App::run(()).unwrap();
}</pre>
<p class="calibre3">Later, we'll see why we need to specify <kbd class="calibre14">()</kbd> as a parameter to <kbd class="calibre14">run()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding child widgets</h1>
                
            
            
                
<p class="calibre3">We saw the basics of how to create a widget with relm. Now, let's continue the creation of our user interface. We'll start by adding the toolbar. Besides specifying properties and signals in the <kbd class="calibre14">view!</kbd> macro, we can also nest widgets in order to add a child to a container. So, to add <kbd class="calibre14">gtk::Box</kbd> as a child of our window, we simply need to nest the former inside the latter:</p>
<pre class="calibre22">view! {
    gtk::Window {
        title: "Rusic",
        delete_event(_, _) =&gt; (Quit, Inhibit(false)),
        gtk::Box {
        },
    }
}</pre>
<p class="calibre3">And to add a toolbar to the <kbd class="calibre14">gtk::Box</kbd>, we create a new level of nesting:</p>
<pre class="calibre22">view! {
    gtk::Window {
        title: "Rusic",
        delete_event(_, _) =&gt; (Quit, Inhibit(false)),
        gtk::Box {
            orientation: Vertical,
            #[name="toolbar"]
            gtk::Toolbar {
            },
        },
    }
}</pre>
<p class="calibre3">Here, we can see that there's an attribute: the <kbd class="calibre14">#[name]</kbd> attribute gives a name to a widget which will allow us to access this widget by the specified identifier, as we'll see later. We'll encounter other attributes in the rest of this chapter.</p>
<p class="calibre3">We'll add an attribute to our model to keep the image to be shown on the play/pause button:</p>
<pre class="calibre22">use gtk::Image;

pub const PAUSE_ICON: &amp;str = "gtk-media-pause";
pub const PLAY_ICON: &amp;str = "gtk-media-play";

pub struct Model {
    play_image: Image,
}</pre>
<p class="calibre3">We also added the constants for the name of the images representing the state of the button. We need to update the <kbd class="calibre14">model()</kbd> method to specify this new field:</p>
<pre class="calibre22">fn model() -&gt; Model {
    Model {
        play_image: new_icon(PLAY_ICON),
    }
}</pre>
<p class="calibre3">This uses the following function to create an image:</p>
<pre class="calibre22">fn new_icon(icon: &amp;str) -&gt; Image {
    Image::new_from_file(format!("assets/{}.png", icon))
}</pre>
<p class="calibre3">Let's add the items to the toolbar:</p>
<pre class="calibre22">use gtk::{
    OrientableExt,
    ToolButtonExt,
};
use gtk::Orientation::Vertical;

view! {
    gtk::Window {
        title: "Rusic",
        delete_event(_, _) =&gt; (Quit, Inhibit(false)),
        gtk::Box {
            orientation: Vertical,
            #[name="toolbar"]
            gtk::Toolbar {
                gtk::ToolButton {
                    icon_widget: &amp;new_icon("document-open"),
                    clicked =&gt; Open,
                },
                gtk::ToolButton {
                    icon_widget: &amp;new_icon("document-save"),
                    clicked =&gt; Save,
                },
                gtk::SeparatorToolItem {
                },
                gtk::ToolButton {
                    icon_widget: &amp;new_icon("gtk-media-previous"),
                },
                gtk::ToolButton {
                    icon_widget: &amp;self.model.play_image,
                    clicked =&gt; PlayPause,
                },
                gtk::ToolButton {
                    icon_widget: &amp;new_icon("gtk-media-stop"),
                    clicked =&gt; Stop,
                },
                gtk::ToolButton {
                    icon_widget: &amp;new_icon("gtk-media-next"),
                },
                gtk::SeparatorToolItem {
                },
                gtk::ToolButton {
                    icon_widget: &amp;new_icon("remove"),
                },
                gtk::SeparatorToolItem {
                },
                gtk::ToolButton {
                    icon_widget: &amp;new_icon("gtk-quit"),
                    clicked =&gt; Quit,
                },
            },
        },
    }
}</pre>
<p class="calibre3">Here, there's no new syntax shown. Take note that we can specify function calls as well as model attributes in the value of a property. We needed to put a <kbd class="calibre14">&amp;</kbd> before <kbd class="calibre14">new_icon()</kbd> because the code is translated as such:</p>
<pre class="calibre22">tool_button.set_icon_widget(&amp;new_icon("gtk-quit"));</pre>
<p class="calibre3">And this <kbd class="calibre14">set_icon_widget()</kbd> method requires something that can be converted into an <kbd class="calibre14">Option&lt;&amp;P&gt;</kbd> where <kbd class="calibre14">P</kbd> is a widget. It requires a reference, so we give it a reference.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">One-way data binding</h1>
                
            
            
                
<p class="calibre3">Setting a property from a model attribute is very frequent in relm and it actually creates a one-way bond between the model attribute and the property. This means that when the attribute is updated, the widget property will be updated as well. There are some restrictions to this feature though:</p>
<ul class="calibre10">
<li class="calibre11">Only an assignment to a model attribute will update the property.</li>
<li class="calibre11">This assignment <em class="calibre21">must</em> be inside an implementation decorated with the <kbd class="calibre14">#[widget]</kbd> attribute.</li>
</ul>
<p class="calibre3">These restrictions come from the fact that <kbd class="calibre14">relm</kbd> only analyzes the source code decorated by this attribute. And it only considers assignment to be an update of the model data.</p>
<p class="calibre3">This might require changing some code. For instance, the following code will not trigger a property update:</p>
<pre class="calibre22">self.model.string.push_str("string");</pre>
<p class="calibre3">You can rewrite it this way in order for  <kbd class="calibre14">relm</kbd> to consider it an update:</p>
<pre class="calibre22">self.model.string += "string";</pre>
<p class="calibre3">As you can see, <kbd class="calibre14">relm</kbd> recognizes not only the <kbd class="calibre14">=</kbd> assignment, but also the assignments using an operator such as <kbd class="calibre14">+=</kbd>.</p>
<p class="calibre3">We used many new messages in the previous code, so let's update our enumeration accordingly:</p>
<pre class="calibre22">#[derive(Msg)]
pub enum Msg {
    Open,
    PlayPause,
    Quit,
    Save,
    Stop,
}</pre>
<p class="calibre3">We also need to change the <kbd class="calibre14">update()</kbd> method to consider these new messages:</p>
<pre class="calibre23">    fn update(&amp;mut self, event: Msg) {
        match event {
            Open =&gt; (),
            PlayPause =&gt; (),
            Quit =&gt; gtk::main_quit(),
            Save =&gt; (),
            Stop =&gt; (),
        }
    }</pre>
<p class="calibre3">For now, since we only code the interface, we do nothing when we receive these messages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Post-initialization of the view</h1>
                
            
            
                
<p class="calibre3">If you run the application, you'll see that the images are not shown on the toolbar buttons. This is because of the way <kbd class="calibre14">relm</kbd> works. When it generates the code, it calls the <kbd class="calibre14">show()</kbd> method on every widget, instead of <kbd class="calibre14">show_all()</kbd>. So, the toolbar and the tool buttons will be shown, but not the images, as they are only attributes of the buttons, they are not created using the widget syntax. To solve this issue, we'll call <kbd class="calibre14">show_all()</kbd> on the toolbar in the <kbd class="calibre14">init_view()</kbd> method:</p>
<pre class="calibre22">#[widget]
impl Widget for App {
    fn init_view(&amp;mut self) {
        self.toolbar.show_all();
    }

    // …
}</pre>
<p class="calibre3">That's why we gave a name to the toolbar widget earlier: we needed to call a method on this widget here. The <kbd class="calibre14">init_view()</kbd> method is called after the <kbd class="calibre14">view</kbd> is created. This is useful to execute some code to customize the view when it's not possible to do so using the <kbd class="calibre14">view!</kbd> syntax. If you run the application again, you'll see that the buttons now have an image.</p>
<p class="calibre3">Let's now add the cover image widget and the cursor widget. For the image, we'll need to add a new crate to <kbd class="calibre14">Cargo.toml</kbd>:</p>
<pre class="calibre22">[dependencies]
gdk-pixbuf = "^0.3.0"</pre>
<p class="calibre3">Let's also add the corresponding <kbd class="calibre14">extern crate</kbd> statement:</p>
<pre class="calibre22">extern crate gdk_pixbuf;</pre>
<p class="calibre3">We also need new import statements:</p>
<pre class="calibre22">use gdk_pixbuf::Pixbuf;
use gtk::{
    Adjustment,
    BoxExt,
    ImageExt,
    LabelExt,
    ScaleExt,
};
use gtk::Orientation::Horizontal;</pre>
<p class="calibre3">Let's add a couple of new fields to our <kbd class="calibre14">Model</kbd>:</p>
<pre class="calibre22">pub struct Model {
    adjustment: Adjustment,
    cover_pixbuf: Option&lt;Pixbuf&gt;,
    cover_visible: bool,
    current_duration: u64,
    current_time: u64,
    play_image: Image,
}</pre>
<p class="calibre3">Most of the new fields existed in the application we developed in the two previous chapters. The <kbd class="calibre14">cover_visible</kbd> attribute is new, though. We'll use it to know whether we should show the image of the cover. Don't forget to update the initialization of the model:</p>
<pre class="calibre22">fn model() -&gt; Model {
    Model {
        adjustment: Adjustment::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
        cover_pixbuf: None,
        cover_visible: false,
        current_duration: 0,
        current_time: 0,
        play_image: new_icon(PLAY_ICON),
    }
}</pre>
<p class="calibre3">We can now add the <kbd class="calibre14">Image</kbd> after the <kbd class="calibre14">Toolbar</kbd> widget:</p>
<pre class="calibre22">gtk::Image {
    from_pixbuf: self.model.cover_pixbuf.as_ref(),
    visible: self.model.cover_visible,
},</pre>
<p class="calibre3">Here, we call <kbd class="calibre14">as_ref()</kbd> on the <kbd class="calibre14">cover_pixbuf</kbd> attribute, because, once again, the method (<kbd class="calibre14">set_from_pixbuf()</kbd>) requires something that can be converted into a <kbd class="calibre14">Option&lt;&amp;Pixbuf&gt;</kbd>. We also specify that the <kbd class="calibre14">visible</kbd> property of the image is bound to the <kbd class="calibre14">cover_visible</kbd> model attribute. This means that we'll be able to hide the image by setting this attribute to <kbd class="calibre14">false</kbd>.</p>
<p class="calibre3">We'll then add the cursor, which will give us the following view:</p>
<pre class="calibre22">view! {
    gtk::Window {
        title: "Rusic",
        delete_event(_, _) =&gt; (Quit, Inhibit(false)),
        gtk::Box {
            orientation: Vertical,
            #[name="toolbar"]
            gtk::Toolbar {
                // …
            },
            gtk::Image {
                from_pixbuf: self.model.cover_pixbuf.as_ref(),
                visible: self.model.cover_visible,
            },
            gtk::Box {
                orientation: Horizontal,
                spacing: 10,
                gtk::Scale(Horizontal, &amp;self.model.adjustment) {
                    draw_value: false,
                    hexpand: true,
                },
                gtk::Label {
                    text: &amp;millis_to_minutes(self.model.current_time),
                },
                gtk::Label {
                    text: "/",
                },
                gtk::Label {
                    margin_right: 10,
                    text: &amp;millis_to_minutes(self.model.current_duration),
                },
            },
        },
    }
}</pre>
<p class="calibre3">This require the following method, which we saw in the previous chapter:</p>
<pre class="calibre22">fn millis_to_minutes(millis: u64) -&gt; String {
    let mut seconds = millis / 1_000;
    let minutes = seconds / 60;
    seconds %= 60;
    format!("{}:{:02}", minutes, seconds)
}</pre>
<p class="calibre3">We used another way to create a widget:</p>
<pre class="calibre22">gtk::Scale(Horizontal, &amp;self.model.adjustment) {
    draw_value: false,
    hexpand: true,
}</pre>
<p class="calibre3">This syntax will call the constructor of the widget, like so:</p>
<pre class="calibre22">gtk::Scale::new(Horizontal, &amp;self.model.adjustment);</pre>
<p class="calibre3">We could also have used the traditional syntax to create a widget:</p>
<pre class="calibre22">use gtk::RangeExt;

gtk::Scale {
    adjustment: &amp;self.model.adjustment,
    orientation: Horizontal,
    draw_value: false,
    hexpand: true,
}</pre>
<p class="calibre3">These are just two ways to do the same thing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Dialogs</h1>
                
            
            
                
<p class="calibre3">For the open and save dialog, we'll use the same functions as in the previous chapter:</p>
<pre class="calibre22">use std::path::PathBuf;

use gtk::{FileChooserAction, FileChooserDialog, FileFilter};
use gtk_sys::{GTK_RESPONSE_ACCEPT, GTK_RESPONSE_CANCEL};

const RESPONSE_ACCEPT: i32 = GTK_RESPONSE_ACCEPT as i32;
const RESPONSE_CANCEL: i32 = GTK_RESPONSE_CANCEL as i32;

fn show_open_dialog(parent: &amp;Window) -&gt; Option&lt;PathBuf&gt; {
    let mut file = None;
    let dialog = FileChooserDialog::new(Some("Select an MP3 audio file"), <br class="calibre6"/>    Some(parent), FileChooserAction::Open);

    let mp3_filter = FileFilter::new();
    mp3_filter.add_mime_type("audio/mp3");
    mp3_filter.set_name("MP3 audio file");
    dialog.add_filter(&amp;mp3_filter);

    let m3u_filter = FileFilter::new();
    m3u_filter.add_mime_type("audio/x-mpegurl");
    m3u_filter.set_name("M3U playlist file");
    dialog.add_filter(&amp;m3u_filter);

    dialog.add_button("Cancel", RESPONSE_CANCEL);
    dialog.add_button("Accept", RESPONSE_ACCEPT);
    let result = dialog.run();
    if result == RESPONSE_ACCEPT {
        file = dialog.get_filename();
    }
    dialog.destroy();
    file
}

fn show_save_dialog(parent: &amp;Window) -&gt; Option&lt;PathBuf&gt; {
    let mut file = None;
    let dialog = FileChooserDialog::new(Some("Choose a destination M3U playlist <br class="calibre6"/>    file"), Some(parent), FileChooserAction::Save);
    let filter = FileFilter::new();
    filter.add_mime_type("audio/x-mpegurl");
    filter.set_name("M3U playlist file");
    dialog.set_do_overwrite_confirmation(true);
    dialog.add_filter(&amp;filter);
    dialog.add_button("Cancel", RESPONSE_CANCEL);
    dialog.add_button("Save", RESPONSE_ACCEPT);
    let result = dialog.run();
    if result == RESPONSE_ACCEPT {
        file = dialog.get_filename();
    }
    dialog.destroy();
    file
}</pre>
<p class="calibre3">But this time, we'll put the code for the open action in a method on the <kbd class="calibre14">App</kbd> widget:</p>
<pre class="calibre22">use gtk::{ButtonsType, DialogFlags, MessageDialog, MessageType};

impl App {
    fn open(&amp;self) {
        let file = show_open_dialog(&amp;self.window);
        if let Some(file) = file {
            let ext = file.extension().map(|ext| <br class="calibre6"/>             ext.to_str().unwrap().to_string());
            if let Some(ext) = ext {
                match ext.as_str() {
                    "mp3" =&gt; (),
                    "m3u" =&gt; (),
                    extension =&gt; {
                        let dialog = <br class="calibre6"/>                        MessageDialog::new(Some(&amp;self.window),  <br class="calibre6"/>                        DialogFlags::empty(), MessageType::Error,
                        ButtonsType::Ok, &amp;format!("Cannot open file <br class="calibre6"/>                         with extension . {}", extension));
                        dialog.run();
                        dialog.destroy();
                    },
                }
            }
        }
    }
}</pre>
<p class="calibre3">We can then call these functions in the <kbd class="calibre14">update()</kbd> method:</p>
<pre class="calibre22">fn update(&amp;mut self, event: Msg) {
    match event {
        Open =&gt; self.open(),
        PlayPause =&gt;  (),
        Quit =&gt; gtk::main_quit(),
        Save =&gt; show_save_dialog(&amp;self.window),
        Stop =&gt; (),
    }
}</pre>
<p class="calibre3">Let's manage some of the other actions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Other methods</h1>
                
            
            
                
<p class="calibre3">This will require two new methods in the <kbd class="calibre14">impl Widget</kbd>:</p>
<pre class="calibre22">#[widget]
impl Widget for App {
    // …

    fn set_current_time(&amp;mut self, time: u64) {
        self.model.current_time = time;
        self.model.adjustment.set_value(time as f64);
    }

    fn set_play_icon(&amp;self, icon: &amp;str) {
        self.model.play_image.set_from_file(format!("assets/{}.png", icon));
    }
}</pre>
<p class="calibre3">But these methods have nothing to do with a <kbd class="calibre14">Widget</kbd>, so why are we allowed to add <kbd class="calibre14">custom</kbd> methods in a trait implementation? Well, the <kbd class="calibre14">#[widget]</kbd> attribute will take these methods and move them to a separate <kbd class="calibre14">impl App</kbd> where they belong. But why do we want to do this instead of placing them ourselves? That's because <kbd class="calibre14">relm</kbd> analyzes the assignments to the model attributes in the methods in the implementation decorated by the <kbd class="calibre14">#[widget]</kbd> attribute. As we saw earlier, an assignment to a model field will automatically update the view. If we placed these methods in a separate <kbd class="calibre14">impl App</kbd>, <kbd class="calibre14">relm</kbd> would have been unable to analyze these methods and generate the code to automatically update the view.</p>
<p class="calibre3">This is a frequent mistake, if your view is not updating when you're assigning to a model attribute, it's probably because your assignment is not within an implementation decorated by the <kbd class="calibre14">#[widget]</kbd> attribute.</p>
<p class="calibre3">We also need a new attribute for our model:</p>
<pre class="calibre22">pub struct Model {
    adjustment: Adjustment,
    cover_pixbuf: Option&lt;Pixbuf&gt;,
    cover_visible: bool,
    current_duration: u64,
    current_time: u64,
    play_image: Image,
    stopped: bool,
}</pre>
<p class="calibre3">We added a <kbd class="calibre14">stopped</kbd> attribute that we also need to add in the model initialization:</p>
<pre class="calibre22">fn model() -&gt; Model {
    Model {
        adjustment: Adjustment::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
        cover_pixbuf: None,
        cover_visible: false,
        current_duration: 0,
        current_time: 0,
        play_image: new_icon(PLAY_ICON),
        stopped: true,
    }
}</pre>
<p class="calibre3">We can now change the <kbd class="calibre14">update()</kbd> method to use these new methods:</p>
<pre class="calibre22">fn update(&amp;mut self, event: Msg) {
    match event {
        Open =&gt; self.open(),
        PlayPause =&gt;  {
            if !self.model.stopped {
                self.set_play_icon(PLAY_ICON);
            }
        },
        Quit =&gt; gtk::main_quit(),
        Save =&gt; show_save_dialog(&amp;self.window),
        Stop =&gt; {
            self.set_current_time(0);
            self.model.current_duration = 0;
            self.model.cover_visible = false;
            self.set_play_icon(PLAY_ICON);
        },
    }
}</pre>
<p class="calibre3">The <kbd class="calibre14">update()</kbd> method receives <kbd class="calibre14">self</kbd> by a mutable reference, which allows us to update the model attributes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Playlist</h1>
                
            
            
                
<p class="calibre3">We're now ready to create a new widget: the playlist. We'll need the following new <kbd class="calibre14">dependencies</kbd>:</p>
<pre class="calibre22">[dependencies]
id3 = "^0.2.0"
m3u = "^1.0.0"</pre>
<p class="calibre3">Add their corresponding <kbd class="calibre14">extern crate</kbd> statements:</p>
<pre class="calibre22">extern crate id3;
extern crate m3u;</pre>
<p class="calibre3">Let's create a new module for our <kbd class="calibre14">playlist</kbd>:</p>
<pre class="calibre22">mod playlist;</pre>
<p class="calibre3">In the <kbd class="calibre14">src/playlist.rs</kbd> file, we start by creating our model:</p>
<pre class="calibre22">use gtk::ListStore;

pub struct Model {
    current_song: Option&lt;String&gt;,
    model: ListStore,
    relm: Relm&lt;Playlist&gt;,
}</pre>
<p class="calibre3">The <kbd class="calibre14">Relm</kbd> type comes from the <kbd class="calibre14">relm</kbd> crate:</p>
<pre class="calibre22">use relm::Relm;</pre>
<p class="calibre3">It is useful to send messages to a widget. We'll learn more about that in the section about widget communication. Let's add the model initialization function:</p>
<pre class="calibre22">use gdk_pixbuf::Pixbuf;
use gtk::{StaticType, Type};

#[widget]
impl Widget for Playlist {
    fn model(relm: &amp;Relm&lt;Self&gt;, _: ()) -&gt; Model {
        Model {
            current_song: None,
            model: ListStore::new(&amp;[
                Pixbuf::static_type(),
                Type::String,
                Type::String,
                Type::String,
                Type::String,
                Type::String,
                Type::String,
                Type::String,
                Pixbuf::static_type(),
            ]),
            relm: relm.clone(),
        }
    }
}</pre>
<p class="calibre3">Here, we notice that we use a different signature for the <kbd class="calibre14">model()</kbd> method. How is this possible? The method of the trait cannot change, right? It is another convenience brought by the <kbd class="calibre14">#[widget]</kbd> crate. In many cases, we don't need these parameters, so they are automatically added if they are needed. The first parameter is <kbd class="calibre14">relm</kbd> and we save a copy of it in the model. The second parameter is the model initialization parameter. The <kbd class="calibre14">ListStore</kbd> is the same as in <a target="_blank" href="part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 5</a>, <em class="calibre21">Creating a Music Player</em>, we only save it in our model because we'll need it later.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Model parameter</h1>
                
            
            
                
<p class="calibre3">Let's talk more about this second parameter. It could be used to send data to the widget when we create it. Remember when we called <kbd class="calibre14">run()</kbd>:</p>
<pre class="calibre22">App::run(()).unwrap();</pre>
<p class="calibre3">Here, we specified <kbd class="calibre14">()</kbd> as the model parameter because we don't need one. But we could have used a different value, such as <kbd class="calibre14">42</kbd>, and this value would have been received in the second parameter of the <kbd class="calibre14">model()</kbd> method.</p>
<p class="calibre3">We're now ready to create the view:</p>
<pre class="calibre22">use gtk;
use gtk::{TreeViewExt, WidgetExt};
use relm::Widget;
use relm_attributes::widget;

#[widget]
impl Widget for Playlist {
    // …

    view! {
        #[name="treeview"]
        gtk::TreeView {
            hexpand: true,
            model: &amp;self.model.model,
            vexpand: true,
        }
    }
}</pre>
<p class="calibre3">It is really simple: we give it a name and set both the <kbd class="calibre14">hexpand</kbd> and <kbd class="calibre14">vexpand</kbd> properties to <kbd class="calibre14">true</kbd> and we bind the <kbd class="calibre14">model</kbd> property with our <kbd class="calibre14">ListStore</kbd>.</p>
<p class="calibre3">Let's create an empty <kbd class="calibre14">update()</kbd> method for now:</p>
<pre class="calibre22">#[widget]
impl Widget for Playlist {
    // …

    fn update(&amp;mut self, event: Msg) {
    }
}</pre>
<p class="calibre3">We'll see the <kbd class="calibre14">Msg</kbd> type later. We'll now add the columns exactly like we did it in  <a href="https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&amp;action=edit#post_86" target="_blank" class="calibre13">Chapter 5</a>, <em class="calibre21">Creating a Music Player</em>. Let's copy the following enumeration and constants:</p>
<pre class="calibre22">use self::Visibility::*;

#[derive(PartialEq)]
enum Visibility {
    Invisible,
    Visible,
}

const THUMBNAIL_COLUMN: u32 = 0;
const TITLE_COLUMN: u32 = 1;
const ARTIST_COLUMN: u32 = 2;
const ALBUM_COLUMN: u32 = 3;
const GENRE_COLUMN: u32 = 4;
const YEAR_COLUMN: u32 = 5;
const TRACK_COLUMN: u32 = 6;
const PATH_COLUMN: u32 = 7;
const PIXBUF_COLUMN: u32 = 8;</pre>
<p class="calibre3">And let's add new methods to the <kbd class="calibre14">Paylist</kbd>:</p>
<pre class="calibre22">impl Playlist {
    fn add_pixbuf_column(&amp;self, column: i32, visibility: Visibility) {
        let view_column = TreeViewColumn::new();
        if visibility == Visible {
            let cell = CellRendererPixbuf::new();
            view_column.pack_start(&amp;cell, true);
            view_column.add_attribute(&amp;cell, "pixbuf", column);
        }
        self.treeview.append_column(&amp;view_column);

    }

    fn add_text_column(&amp;self, title: &amp;str, column: i32) {
        let view_column = TreeViewColumn::new();
        view_column.set_title(title);
        let cell = CellRendererText::new();
        view_column.set_expand(true);
        view_column.pack_start(&amp;cell, true);
        view_column.add_attribute(&amp;cell, "text", column);
        self.treeview.append_column(&amp;view_column);
    }

    fn create_columns(&amp;self) {
        self.add_pixbuf_column(THUMBNAIL_COLUMN as i32, Visible);
        self.add_text_column("Title", TITLE_COLUMN as i32);
        self.add_text_column("Artist", ARTIST_COLUMN as i32);
        self.add_text_column("Album", ALBUM_COLUMN as i32);
        self.add_text_column("Genre", GENRE_COLUMN as i32);
        self.add_text_column("Year", YEAR_COLUMN as i32);
        self.add_text_column("Track", TRACK_COLUMN as i32);
        self.add_pixbuf_column(PIXBUF_COLUMN as i32, Invisible);
    }
}</pre>
<p class="calibre3">The difference from these functions in  <a href="https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&amp;action=edit#post_86" target="_blank" class="calibre13">Chapter 5</a>, <em class="calibre21">Creating a Music Player</em> is that here, we have direct access to the <kbd class="calibre14">treeview</kbd> as an attribute. This requires new import statements:</p>
<pre class="calibre22">use gtk::{
    CellLayoutExt,
    CellRendererPixbuf,
    CellRendererText,
    TreeViewColumn,
    TreeViewColumnExt,
    TreeViewExt,
};</pre>
<p class="calibre3">We'll now call the <kbd class="calibre14">create_columns()</kbd> method in the <kbd class="calibre14">init_view()</kbd> method:</p>
<pre class="calibre22">#[widget]
impl Widget for Playlist {
    fn init_view(&amp;mut self) {
        self.create_columns();
    }

    // …
}</pre>
<p class="calibre3">Let's start interacting with the playlist. We'll create a method to add a song to the playlist:</p>
<pre class="calibre22">use std::path::Path;

use gtk::{ListStoreExt, ListStoreExtManual, ToValue};
use id3::Tag;

impl Playlist {
    fn add(&amp;self, path: &amp;Path) {
        let filename =  <br class="calibre6"/>         path.file_stem().unwrap_or_default().to_str().unwrap_or_default();

        let row = self.model.model.append();

        if let Ok(tag) = Tag::read_from_path(path) {
            let title = tag.title().unwrap_or(filename);
            let artist = tag.artist().unwrap_or("(no artist)");
            let album = tag.album().unwrap_or("(no album)");
            let genre = tag.genre().unwrap_or("(no genre)");
            let year = tag.year().map(|year|<br class="calibre6"/>            year.to_string()).unwrap_or("(no year)".to_string());
            let track = tag.track().map(|track|  <br class="calibre6"/>             track.to_string()).unwrap_or("??".to_string());
            let total_tracks = <br class="calibre6"/>             tag.total_tracks().map(|total_tracks|  <br class="calibre6"/>             total_tracks.to_string()).unwrap_or("??".to_string());
            let track_value = format!("{} / {}", track, <br class="calibre6"/>             total_tracks);

            self.set_pixbuf(&amp;row, &amp;tag);

            self.model.model.set_value(&amp;row, TITLE_COLUMN, <br class="calibre6"/>            &amp;title.to_value());
            self.model.model.set_value(&amp;row, ARTIST_COLUMN,<br class="calibre6"/>            &amp;artist.to_value());
            self.model.model.set_value(&amp;row, ALBUM_COLUMN, <br class="calibre6"/>            &amp;album.to_value());
            self.model.model.set_value(&amp;row, GENRE_COLUMN, <br class="calibre6"/>            &amp;genre.to_value());
            self.model.model.set_value(&amp;row, YEAR_COLUMN,<br class="calibre6"/>            &amp;year.to_value());
            self.model.model.set_value(&amp;row, TRACK_COLUMN,<br class="calibre6"/>            &amp;track_value.to_value());
        }
        else {
            self.model.model.set_value(&amp;row, TITLE_COLUMN, <br class="calibre6"/>             &amp;filename.to_value());
        }

        let path = path.to_str().unwrap_or_default();
        self.model.model.set_value(&amp;row, PATH_COLUMN,<br class="calibre6"/>         &amp;path.to_value());
    }
}</pre>
<p class="calibre3">This calls the <kbd class="calibre14">set_pixbuf()</kbd> method, so let's define it:</p>
<pre class="calibre22">use gdk_pixbuf::{InterpType, PixbufLoader};
use gtk::TreeIter;

const INTERP_HYPER: InterpType = 3;

const IMAGE_SIZE: i32 = 256;
const THUMBNAIL_SIZE: i32 = 64;

fn set_pixbuf(&amp;self, row: &amp;TreeIter, tag: &amp;Tag) {
    if let Some(picture) = tag.pictures().next() {
        let pixbuf_loader = PixbufLoader::new();
        pixbuf_loader.set_size(IMAGE_SIZE, IMAGE_SIZE);
        pixbuf_loader.loader_write(&amp;picture.data).unwrap();
        if let Some(pixbuf) = pixbuf_loader.get_pixbuf() {
            let thumbnail = pixbuf.scale_simple(THUMBNAIL_SIZE, <br class="calibre6"/>             THUMBNAIL_SIZE, INTERP_HYPER).unwrap();
            self.model.model.set_value(row, THUMBNAIL_COLUMN, <br class="calibre6"/>             &amp;thumbnail.to_value());
            self.model.model.set_value(row, PIXBUF_COLUMN, <br class="calibre6"/>             &amp;pixbuf.to_value());
        }
        pixbuf_loader.close().unwrap();
    }
}</pre>
<p class="calibre3">It is very similar to the one created in  <a href="https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&amp;action=edit#post_86" target="_blank" class="calibre13">Chapter 5</a>, <em class="calibre21">Creating a Music Player</em>. This method will be called when we receive the <kbd class="calibre14">AddSong(path)</kbd> message, so let's now create our message type:</p>
<pre class="calibre22">use std::path::PathBuf;

use self::Msg::*;

#[derive(Msg)]
pub enum Msg {
    AddSong(PathBuf),
    LoadSong(PathBuf),
    NextSong,
    PauseSong,
    PlaySong,
    PreviousSong,
    RemoveSong,
    SaveSong(PathBuf),
    SongStarted(Option&lt;Pixbuf&gt;),
    StopSong,
}</pre>
<p class="calibre3">And let's modify the <kbd class="calibre14">update()</kbd> method accordingly:</p>
<pre class="calibre23">   fn update(&amp;mut self, event: Msg) {
      match event {
          AddSong(path) =&gt; self.add(&amp;path),
          LoadSong(path) =&gt; (),
          NextSong =&gt; (),
          PauseSong =&gt; (),
          PlaySong =&gt; (),
          PreviousSong =&gt; (),
          RemoveSong =&gt; (),
          SaveSong(path) =&gt; (),
          SongStarted(_) =&gt; (),
          StopSong =&gt; (),
        }
    }</pre>
<p class="calibre3">Here, we call the method <kbd class="calibre14">add()</kbd> when we receive the <kbd class="calibre14">AddSong</kbd> message. But where is this message emitted? Well, it will be emitted by the <kbd class="calibre14">App</kbd> type, when the user requests to open a file. It is time we go back to the main module and use this new <kbd class="calibre14">relm</kbd> widget.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding a relm widget</h1>
                
            
            
                
<p class="calibre3">First, we'll need these new import statements:</p>
<pre class="calibre22">use playlist::Playlist;
use playlist::Msg::{
    AddSong,
    LoadSong,
    NextSong,
    PlaySong,
    PauseSong,
    PreviousSong,
    RemoveSong,
    SaveSong,
    SongStarted,
    StopSong,
};</pre>
<p class="calibre3">And then, add the <kbd class="calibre14">Playlist</kbd> widget below the toolbar:</p>
<pre class="calibre22">view! {
    #[name="window"]
    gtk::Window {
        title: "Rusic",
        gtk::Box {
            orientation: Vertical,
            #[name="toolbar"]
            gtk::Toolbar {
                // …
            },
            #[name="playlist"]
            Playlist {
            },
            gtk::Image {
                from_pixbuf: self.model.cover_pixbuf.as_ref(),
                visible: self.model.cover_visible,
            },
            gtk::Box {
                // …
            },
        },
        delete_event(_, _) =&gt; (Quit, Inhibit(false)),
    }
}</pre>
<p class="calibre3">There's something different with using <kbd class="calibre14">relm</kbd> widgets and <kbd class="calibre14">gtk</kbd> widgets. <kbd class="calibre14">Relm</kbd> widgets must not contain a module prefix, while <kbd class="calibre14">gtk</kbd> widget must contain one. This is why we imported <kbd class="calibre14">Playlist</kbd>, but now <kbd class="calibre14">gtk::Toolbar</kbd>, for instance. But why is it needed? Well, <kbd class="calibre14">relm</kbd> widgets are different than <kbd class="calibre14">gtk</kbd> widgets, so they are not created or added to another widget in the same way. Thus, <kbd class="calibre14">relm</kbd> can distinguish them this way: if there's a prefix, this is a built-in <kbd class="calibre14">gtk</kbd> widget, otherwise it is a custom <kbd class="calibre14">relm</kbd> widget. When I say <kbd class="calibre14">gtk</kbd> widgets, this even includes <kbd class="calibre14">gtk</kbd> widgets from other crates, such as <kbd class="calibre14">webkit2gtk::WebView</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Communicating between widgets</h1>
                
            
            
                
<p class="calibre3">We'll now communicate between the widgets to indicate we want to add a song to the playlist. But before we do so, we'll look in more detail at how a widget can communicate with itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Communicating with the same widget</h1>
                
            
            
                
<p class="calibre3">We previously saw how to communicate with the same widget. To send a message to the same widget from an event handler in the view, we simply need to specify the message to be sent on the right side of <kbd class="calibre14">=&gt;</kbd>, like in the following example:</p>
<pre class="calibre22">gtk::ToolButton {
    icon_widget: &amp;new_icon("gtk-quit"),
    clicked =&gt; Quit,
}</pre>
<p class="calibre3">Here, the <kbd class="calibre14">Quit</kbd> message is sent to the same widget (that is, <kbd class="calibre14">App</kbd>) when the user clicks this tool button. But this is syntax sugar for a call to the <kbd class="calibre14">emit()</kbd> method on the stream of events of a <kbd class="calibre14">relm</kbd> widget.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Emit</h1>
                
            
            
                
<p class="calibre3">So, let's see how to send a message to the same widget without using this syntax: this is useful in more complex cases, such as when we want to conditionally send a message. Let's go back to our <kbd class="calibre14">Playlist</kbd> and add a <kbd class="calibre14">play()</kbd> method:</p>
<pre class="calibre22">impl Playlist {
    fn play(&amp;mut self) {
        if let Some(path) = self.selected_path() {
            self.model.current_song = Some(path.into());
            self.model.relm.stream().emit(SongStarted(self.pixbuf()));
        }
    }
}</pre>
<p class="calibre3">This line sends a message to the current widget:</p>
<pre class="calibre22">self.model.relm.stream().emit(SongStarted(self.pixbuf()));</pre>
<p class="calibre3">We first get the event stream from the <kbd class="calibre14">relm</kbd> widget and then call <kbd class="calibre14">emit()</kbd> on it with a message. This <kbd class="calibre14">play()</kbd> method requires two new methods:</p>
<pre class="calibre22">use gtk::{
    TreeModelExt,
    TreeSelectionExt,
};

impl Playlist {
    fn pixbuf(&amp;self) -&gt; Option&lt;Pixbuf&gt; {
        let selection = self.treeview.get_selection();
        if let Some((_, iter)) = selection.get_selected() {
            let value = self.model.model.get_value(&amp;iter, <br class="calibre6"/>             PIXBUF_COLUMN as i32);
            return value.get::&lt;Pixbuf&gt;();
        }
        None
    }

    fn selected_path(&amp;self) -&gt; Option&lt;String&gt; {
        let selection = self.treeview.get_selection();
        if let Some((_, iter)) = selection.get_selected() {
            let value = self.model.model.get_value(&amp;iter, PATH_COLUMN as i32);
            return value.get::&lt;String&gt;();
        }
        None
    }
}</pre>
<p class="calibre3">These are very similar to the ones we wrote in the previous chapters. We can now call the <kbd class="calibre14">play()</kbd> method in the <kbd class="calibre14">update()</kbd> method:</p>
<pre class="calibre23">    fn update(&amp;mut self, event: Msg) {
        match event {
            AddSong(path) =&gt; self.add(&amp;path),
            LoadSong(path) =&gt; (),
            NextSong =&gt; (),
            PauseSong =&gt; (),
            PlaySong =&gt; self.play(),
            PreviousSong =&gt; (),
            RemoveSong =&gt; (),
            SaveSong(path) =&gt; (),
            // To be listened by App.
            SongStarted(_) =&gt; (),
            StopSong =&gt; (),
        }
    }</pre>
<p class="calibre3">I also added a comment before <kbd class="calibre14">SongStarted</kbd> to indicate that this message will not be handled by the <kbd class="calibre14">Paylist</kbd> widget, but by the <kbd class="calibre14">App</kbd> widget. Now, let's see how to communicate between different widgets.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">With different widgets</h1>
                
            
            
                
<p class="calibre3">Let's update the <kbd class="calibre14">open()</kbd> method to communicate with the playlist:</p>
<pre class="calibre23">impl App {
    fn open(&amp;self) {
        let file = show_open_dialog(&amp;self.window);
        if let Some(file) = file {
            let ext = file.extension().map(|ext| ext.to_str().unwrap().to_string());
            if let Some(ext) = ext {
                match ext.as_str() {
                    "mp3" =&gt; self.playlist.emit(AddSong(file)),
                    "m3u" =&gt; self.playlist.emit(LoadSong(file)),
                    extension =&gt; {
                        let dialog = MessageDialog::new(Some(&amp;self.window),  <br class="calibre6"/>                        DialogFlags::empty(), MessageType::Error,
                        ButtonsType::Ok, &amp;format!("Cannot open file with <br class="calibre6"/>                         extension . {}", extension));
                        dialog.run();
                        dialog.destroy();
                    },
                }
            }
        }
    }
}</pre>
<p class="calibre3">So, we call the same <kbd class="calibre14">emit()</kbd> method to send a message to another widget:</p>
<pre class="calibre22">self.playlist.emit(AddSong(file))</pre>
<p class="calibre3">Here, we sent a message that is not yet handled by the <kbd class="calibre14">Playlist</kbd> (<kbd class="calibre14">LoadSong</kbd>), so let's fix that:</p>
<pre class="calibre22">use m3u;

impl Playlist {
    fn load(&amp;self, path: &amp;Path) {
        let mut reader = m3u::Reader::open(path).unwrap();
        for entry in reader.entries() {
            if let Ok(m3u::Entry::Path(path)) = entry {
                self.add(&amp;path);
            }
        }
    }
}</pre>
<p class="calibre3">This method is called in the <kbd class="calibre14">update()</kbd> method:</p>
<pre class="calibre22">fn update(&amp;mut self, event: Msg) {
    match event {
        AddSong(path) =&gt; self.add(&amp;path),
        LoadSong(path) =&gt; self.load(&amp;path),
        NextSong =&gt; (),
        PauseSong =&gt; (),
        PlaySong =&gt; self.play(),
        PreviousSong =&gt; (),
        RemoveSong =&gt; (),
        SaveSong(path) =&gt; (),
        // To be listened by App.
        SongStarted(_) =&gt; (),
        StopSong =&gt; (),
    }
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Handle messages from a relm widget</h1>
                
            
            
                
<p class="calibre3">Let's now see how to handle the <kbd class="calibre14">SongStarted</kbd> message. To do so, we use a syntax similar to the one for handling <kbd class="calibre14">gtk</kbd> events. The message is on the left side of <kbd class="calibre14">=&gt;</kbd> while the handler is on the right side of it:</p>
<pre class="calibre22">#[widget]
impl Widget for App {
    // …

    view! {
        // …
        #[name="playlist"]
        Playlist {
            SongStarted(ref pixbuf) =&gt; Started(pixbuf.clone()),
        }
    }
}</pre>
<p class="calibre3">We can see here that when we receive the <kbd class="calibre14">SongStarted</kbd> message from the playlist, we emit the <kbd class="calibre14">Started</kbd> message on the same widget (<kbd class="calibre14">App</kbd>). We needed to use <kbd class="calibre14">ref</kbd> and then <kbd class="calibre14">clone()</kbd> the value contained in the message here because we do not own the message. Indeed, multiple widgets can listen to the same message, the widget that emitted the message and its parent. Before we handle this new message, we'll add it to our <kbd class="calibre14">Msg</kbd> enumeration:</p>
<pre class="calibre22">#[derive(Msg)]
pub enum Msg {
    Open,
    PlayPause,
    Quit,
    Save,
    Started(Option&lt;Pixbuf&gt;),
    Stop,
}</pre>
<p class="calibre3">This variant takes an optional <kbd class="calibre14">pixbuf</kbd> because some MP3 files do not have a cover image inside them. And here's how we handle this message:</p>
<pre class="calibre22">fn update(&amp;mut self, event: Msg) {
    match event {
        // …
        Started(pixbuf) =&gt; {
            self.set_play_icon(PAUSE_ICON);
            self.model.cover_visible = true;
            self.model.cover_pixbuf = pixbuf;
        },
    }
}</pre>
<p class="calibre3">When the song starts playing, we show the pause icon and the cover.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Syntax sugar to send a message to another relm widget</h1>
                
            
            
                
<p class="calibre3">Sending a message to another widget with <kbd class="calibre14">emit()</kbd> is a bit verbose, so <kbd class="calibre14">relm</kbd> provides syntactic sugar for this case. Let's send a message to the playlist when the user clicks the remove button:</p>
<pre class="calibre22">gtk::ToolButton {
    icon_widget: &amp;new_icon("remove"),
    clicked =&gt; playlist@RemoveSong,
}</pre>
<p class="calibre3">Here, we used the <kbd class="calibre14">@</kbd> syntax to specify that the message will be sent to another widget. The part before the <kbd class="calibre14">@</kbd> is the receiver widget, while the part after this character is the message. So, this code means that whenever the user clicks the remove button, send the <kbd class="calibre14">RemoveSong</kbd> message to the <kbd class="calibre14">playlist</kbd> widget.</p>
<p class="calibre3">Let's handle this message in the <kbd class="calibre14">Paylist::update()</kbd> method:</p>
<pre class="calibre22">#[widget]
impl Widget for Playlist {
    fn update(&amp;mut self, event: Msg) {
        match event {
            AddSong(path) =&gt; self.add(&amp;path),
            LoadSong(path) =&gt; self.load(&amp;path),
            NextSong =&gt; (),
            PauseSong =&gt; (),
            PlaySong =&gt; self.play(),
            PreviousSong =&gt; (),
            RemoveSong =&gt; self.remove_selection(),
            SaveSong(path) =&gt; (),
            // To be listened by App.
            SongStarted(_) =&gt; (),
            StopSong =&gt; (),
        }
    }

    // …
}</pre>
<p class="calibre3">This calls the <kbd class="calibre14">remove_selection()</kbd> method, as shown here:</p>
<pre class="calibre22">fn remove_selection(&amp;self) {
    let selection = self.treeview.get_selection();
    if let Some((_, iter)) = selection.get_selected() {
        self.model.model.remove(&amp;iter);
    }
}</pre>
<p class="calibre3">This is the same method as the one from  <a href="https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&amp;action=edit#post_86" target="_blank" class="calibre13">Chapter 5</a>, <em class="calibre21">Creating a Music Player</em>. Now, let's send the remaining messages. The <kbd class="calibre14">PlaySong</kbd>, <kbd class="calibre14">PauseSong</kbd>, <kbd class="calibre14">SaveSong</kbd>, and <kbd class="calibre14">StopSong</kbd> messages are emitted in the <kbd class="calibre14">update()</kbd> method:</p>
<pre class="calibre22">#[widget]
impl Widget for App {
    fn update(&amp;mut self, event: Msg) {
        match event {
            PlayPause =&gt;  {
                if self.model.stopped {
                    self.playlist.emit(PlaySong);
                } else {
                    self.playlist.emit(PauseSong);
                    self.set_play_icon(PLAY_ICON);
                }
            },
            Save =&gt; {
                let file = show_save_dialog(&amp;self.window);
                if let Some(file) = file {
                    self.playlist.emit(SaveSong(file));
                }
            },
            Stop =&gt; {
                self.set_current_time(0);
                self.model.current_duration = 0;
                self.playlist.emit(StopSong);
                self.model.cover_visible = false;
                self.set_play_icon(PLAY_ICON);
            },
            // …
        }
    }
}</pre>
<p class="calibre3">The other messages are sent using the <kbd class="calibre14">@</kbd> syntax in the view:</p>
<pre class="calibre22">view! {
    #[name="window"]
    gtk::Window {
        title: "Rusic",
        gtk::Box {
            orientation: Vertical,
            #[name="toolbar"]
            gtk::Toolbar {
                // …
                gtk::ToolButton {
                    icon_widget: &amp;new_icon("gtk-media-previous"),
                    clicked =&gt; playlist@PreviousSong,
                },
                // …
                gtk::ToolButton {
                    icon_widget: &amp;new_icon("gtk-media-next"),
                    clicked =&gt; playlist@NextSong,
                },
            },
            // …
        },
        delete_event(_, _) =&gt; (Quit, Inhibit(false)),
    }
}</pre>
<p class="calibre3">We'll handle these messages in the <kbd class="calibre14">Paylist::update()</kbd> method:</p>
<pre class="calibre22">fn update(&amp;mut self, event: Msg) {
    match event {
        AddSong(path) =&gt; self.add(&amp;path),
        LoadSong(path) =&gt; self.load(&amp;path),
        NextSong =&gt; self.next(),
        PauseSong =&gt; (),
        PlaySong =&gt; self.play(),
        PreviousSong =&gt; self.previous(),
        RemoveSong =&gt; self.remove_selection(),
        SaveSong(path) =&gt; self.save(&amp;path),
        // To be listened by App.
        SongStarted(_) =&gt; (),
        StopSong =&gt; self.stop(),
    }
}</pre>
<p class="calibre3">This requires some new methods:</p>
<pre class="calibre22">fn next(&amp;mut self) {
    let selection = self.treeview.get_selection();
    let next_iter =
        if let Some((_, iter)) = selection.get_selected() {
            if !self.model.model.iter_next(&amp;iter) {
                return;
            }
            Some(iter)
        }
        else {
            self.model.model.get_iter_first()
        };
    if let Some(ref iter) = next_iter {
        selection.select_iter(iter);
        self.play();
    }
}</pre>
<pre class="calibre22">fn previous(&amp;mut self) {
    let selection = self.treeview.get_selection();
    let previous_iter =
        if let Some((_, iter)) = selection.get_selected() {
            if !self.model.model.iter_previous(&amp;iter) {
                return;
            }
            Some(iter)
        }
        else {
            self.model.model.iter_nth_child(None, max(0,  <br class="calibre6"/>            self.model.model.iter_n_children(None) - 1))
        };
    if let Some(ref iter) = previous_iter {
        selection.select_iter(iter);
        self.play();
    }
}</pre>
<pre class="calibre22">use std::fs::File;

fn save(&amp;self, path: &amp;Path) {
    let mut file = File::create(path).unwrap();
    let mut writer = m3u::Writer::new(&amp;mut file);

    let mut write_iter = |iter: &amp;TreeIter| {
        let value = self.model.model.get_value(&amp;iter, PATH_COLUMN as i32);
        let path = value.get::&lt;String&gt;().unwrap();
        writer.write_entry(&amp;m3u::path_entry(path)).unwrap();
    };

    if let Some(iter) = self.model.model.get_iter_first() {
        write_iter(&amp;iter);
        while self.model.model.iter_next(&amp;iter) {
            write_iter(&amp;iter);
        }
    }
}</pre>
<p class="calibre3">And function <kbd class="calibre14">stop</kbd>:</p>
<pre class="calibre22">fn stop(&amp;mut self) {
    self.model.current_song = None;
}</pre>
<p class="calibre3">These methods are all similar to the ones we created in the previous chapters. You can run the application to see that we can open and remove songs, but we cannot play them yet. So let's fix this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Playing music</h1>
                
            
            
                
<p class="calibre3">First, add the <kbd class="calibre14">mp3</kbd> module:</p>
<pre class="calibre22">mod mp3;</pre>
<p class="calibre3">Copy the <kbd class="calibre14">src/mp3.rs</kbd> file from the previous chapter.</p>
<p class="calibre3">We also need the following dependencies:</p>
<pre class="calibre22">[dependencies]
crossbeam = "^0.3.0"
futures = "^0.1.16"
pulse-simple = "^1.0.0"
simplemad = "^0.8.1"</pre>
<p class="calibre3">And add these statements to the <kbd class="calibre14">main</kbd> module:</p>
<pre class="calibre22">extern crate crossbeam;
extern crate futures;
extern crate pulse_simple;
extern crate simplemad;</pre>
<p class="calibre3">We'll now add a <kbd class="calibre14">player</kbd> module:</p>
<pre class="calibre22">mod player;</pre>
<p class="calibre3">This new module will start with a bunch of import statements:</p>
<pre class="calibre22">use std::cell::Cell;
use std::fs::File;
use std::io::BufReader;
use std::path::{Path, PathBuf};
use std::sync::{Arc, Condvar, Mutex};
use std::thread;
use std::time::Duration;

use crossbeam::sync::SegQueue;
use futures::{AsyncSink, Sink};
use futures::sync::mpsc::UnboundedSender;
use pulse_simple::Playback;

use mp3::Mp3Decoder;
use playlist::PlayerMsg::{
    self,
    PlayerPlay,
    PlayerStop,
    PlayerTime,
};
use self::Action::*;</pre>
<p class="calibre3">We imported a new <kbd class="calibre14">PlayerMsg</kbd> type from the <kbd class="calibre14">playlist</kbd> module, so let's add it:</p>
<pre class="calibre22">#[derive(Clone)]
pub enum PlayerMsg {
    PlayerPlay,
    PlayerStop,
    PlayerTime(u64),
}</pre>
<p class="calibre3">We'll define some constants:</p>
<pre class="calibre22">const BUFFER_SIZE: usize = 1000;
const DEFAULT_RATE: u32 = 44100;</pre>
<p class="calibre3">And let's create the types that we'll need:</p>
<pre class="calibre22">enum Action {
    Load(PathBuf),
    Stop,
}

#[derive(Clone)]
struct EventLoop {
    condition_variable: Arc&lt;(Mutex&lt;bool&gt;, Condvar)&gt;,
    queue: Arc&lt;SegQueue&lt;Action&gt;&gt;,
    playing: Arc&lt;Mutex&lt;bool&gt;&gt;,
}

pub struct Player {
    event_loop: EventLoop,
    paused: Cell&lt;bool&gt;,
    tx: UnboundedSender&lt;PlayerMsg&gt;,
}</pre>
<p class="calibre3">The <kbd class="calibre14">Action</kbd> and <kbd class="calibre14">EventLoop</kbd> are the same as in the previous chapter, but the <kbd class="calibre14">Player</kbd> type is a bit different. Instead of having a field with the state of the application, it contains a sender that will be used to send messages to the playlist and ultimately to the application itself. So, instead of using a shared state and a timeout like we did in the previous chapter, we'll use message passing, which is more efficient.</p>
<p class="calibre3">We'll need a constructor for <kbd class="calibre14">EventLoop</kbd>:</p>
<pre class="calibre22">impl EventLoop {
    fn new() -&gt; Self {
        EventLoop {
            condition_variable: Arc::new((Mutex::new(false), Condvar::new())),
            queue: Arc::new(SegQueue::new()),
            playing: Arc::new(Mutex::new(false)),
        }
    }
}</pre>
<p class="calibre3">Let's create the constructor for <kbd class="calibre14">Player</kbd>:</p>
<pre class="calibre23">impl Player {
    pub(crate) fn new(tx: UnboundedSender&lt;PlayerMsg&gt;) -&gt; Self {
        let event_loop = EventLoop::new();

        {
            let mut tx = tx.clone();
            let event_loop = event_loop.clone();
            let condition_variable = event_loop.condition_variable.clone();
            thread::spawn(move || {
                let block = || {
                    let (ref lock, ref condition_variable) = *condition_variable;
                    let mut started = lock.lock().unwrap();
                    *started = false;
                    while !*started {
                        started = condition_variable.wait(started).unwrap();
                    }
                };

                let mut buffer = [[0; 2]; BUFFER_SIZE];
                let mut playback = Playback::new("MP3", "MP3 Playback", None,  <br class="calibre6"/>                DEFAULT_RATE);
                let mut source = None;
                loop {
                    if let Some(action) = event_loop.queue.try_pop() {
                        match action {
                            Load(path) =&gt; {
                                let file = File::open(path).unwrap();
                                source = <br class="calibre6"/>                Some(Mp3Decoder::new(BufReader::new(file)).unwrap());
                                let rate = source.as_ref().map(|source|  <br class="calibre6"/>                                source.samples_rate()).unwrap_or(DEFAULT_RATE);
                                playback = Playback::new("MP3", "MP3 Playback",  <br class="calibre6"/>                                 None, rate);
                                send(&amp;mut tx, PlayerPlay);
                            },
                            Stop =&gt; {
                                source = None;
                            },
                        }
                    } else if *event_loop.playing.lock().unwrap() {
                        let mut written = false;
                        if let Some(ref mut source) = source {
                            let size = iter_to_buffer(source, &amp;mut buffer);
                            if size &gt; 0 {
                                send(&amp;mut tx, PlayerTime(source.current_time()));
                                playback.write(&amp;buffer[..size]);
                                written = true;
                            }
                        }

                        if !written {
                            send(&amp;mut tx, PlayerStop);
                            *event_loop.playing.lock().unwrap() = false;
                            source = None;
                            block();
                        }
                    } else {
                        block();
                    }
                }
            });
        }

        Player {
            event_loop,
            paused: Cell::new(false),
            tx,
        }
    }
}</pre>
<p class="calibre3">It is similar to the one we wrote in the previous chapter, but instead of using the shared state, we send messages back to the playlist. Here's an example of how we send these messages:</p>
<pre class="calibre22">send(&amp;mut tx, PlayerTime(source.current_time()));</pre>
<p class="calibre3">This sends the current time back to the UI so that it can display it. This requires the <kbd class="calibre14">send()</kbd> function to be defined:</p>
<pre class="calibre22">fn send(tx: &amp;mut UnboundedSender&lt;PlayerMsg&gt;, msg: PlayerMsg) {
    if let Ok(AsyncSink::Ready) = tx.start_send(msg) {
        tx.poll_complete().unwrap();
    } else {
        eprintln!("Unable to send message to sender");
    }
}</pre>
<p class="calibre3">This code uses the <kbd class="calibre14">future</kbd> crate to send the message and it shows an error in case it fails. The <kbd class="calibre14">iter_to_buffer()</kbd> function is the same as the one from the previous chapter:</p>
<pre class="calibre22">fn iter_to_buffer&lt;I: Iterator&lt;Item=i16&gt;&gt;(iter: &amp;mut I, buffer: &amp;mut [[i16; 2]; BUFFER_SIZE]) -&gt; usize {
    let mut iter = iter.take(BUFFER_SIZE);
    let mut index = 0;
    while let Some(sample1) = iter.next() {
        if let Some(sample2) = iter.next() {
            buffer[index][0] = sample1;
            buffer[index][1] = sample2;
        }
        index += 1;
    }
    index
}</pre>
<p class="calibre3">We'll now add the methods to play and pause a song:</p>
<pre class="calibre22">pub fn load&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) {
    let pathbuf = path.as_ref().to_path_buf();
    self.emit(Load(pathbuf));
    self.set_playing(true);
}

pub fn pause(&amp;mut self) {
    self.paused.set(true);
    self.send(PlayerStop);
    self.set_playing(false);
}

pub fn resume(&amp;mut self) {
    self.paused.set(false);
    self.send(PlayerPlay);
    self.set_playing(true);
}</pre>
<p class="calibre3">They're very similar to the ones from the previous chapter, but we send a message instead of modifying a state. They require the following methods:</p>
<pre class="calibre22">fn emit(&amp;self, action: Action) {
    self.event_loop.queue.push(action);
}

fn send(&amp;mut self, msg: PlayerMsg) {
    send(&amp;mut self.tx, msg);
}

fn set_playing(&amp;self, playing: bool) {
    *self.event_loop.playing.lock().unwrap() = playing;
    let (ref lock, ref condition_variable) = *self.event_loop.condition_variable;
    let mut started = lock.lock().unwrap();
    *started = playing;
    if playing {
        condition_variable.notify_one();
    }
}</pre>
<p class="calibre3">The <kbd class="calibre14">emit()</kbd> and <kbd class="calibre14">set_playing()</kbd> methods are the same as in the previous chapter. The <kbd class="calibre14">send()</kbd> method simply calls the <kbd class="calibre14">send()</kbd> function we defined earlier.</p>
<p class="calibre3">We'll also need these two methods:</p>
<pre class="calibre22">pub fn is_paused(&amp;self) -&gt; bool {
    self.paused.get()
}

pub fn stop(&amp;mut self) {
    self.paused.set(false);
    self.send(PlayerTime(0));
    self.send(PlayerStop);
    self.emit(Stop);
    self.set_playing(false);
}</pre>
<p class="calibre3">The <kbd class="calibre14">is_paused()</kbd> method has not changed. And the <kbd class="calibre14">stop()</kbd> method is similar, but again, it sends messages instead of updating the application state directly. Let's go back to our <kbd class="calibre14">Paylist</kbd> to use this new player. The model will now contain the player itself:</p>
<pre class="calibre22">use player::Player;

pub struct Model {
    current_song: Option&lt;String&gt;,
    player: Player,
    model: ListStore,
    relm: Relm&lt;Playlist&gt;,
}</pre>
<p class="calibre3">The <kbd class="calibre14">Msg</kbd> type will contain a new variant called <kbd class="calibre14">PlayerMsgRecv</kbd> that will be emitted whenever the player sends a message:</p>
<pre class="calibre22">#[derive(Msg)]
pub enum Msg {
    AddSong(PathBuf),
    LoadSong(PathBuf),
    NextSong,
    PauseSong,
    PlayerMsgRecv(PlayerMsg),
    PlaySong,
    PreviousSong,
    RemoveSong,
    SaveSong(PathBuf),
    SongStarted(Option&lt;Pixbuf&gt;),
    StopSong,
}</pre>
<p class="calibre3">We're now ready to update the model initialization:</p>
<pre class="calibre22">use futures::sync::mpsc;

fn model(relm: &amp;Relm&lt;Self&gt;, _: ()) -&gt; Model {
    let (tx, rx) = mpsc::unbounded();
    relm.connect_exec_ignore_err(rx, PlayerMsgRecv);
    Model {
        current_song: None,
        player: Player::new(tx),
        model: ListStore::new(&amp;[
            Pixbuf::static_type(),
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Pixbuf::static_type(),
        ]),
        relm: relm.clone(),
    }
}</pre>
<p class="calibre3">It now creates a sender and receiver pair from the <kbd class="calibre14">mpsc</kbd> type of the <kbd class="calibre14">future</kbd> crate. <strong class="calibre5">MPSC</strong> stands for <strong class="calibre5">Multiple-Producers-Single-Consumer</strong>. We now call the <kbd class="calibre14">Relm::connect_exec_ignore_err()</kbd> method, this method connects a <kbd class="calibre14">Future</kbd> or a <kbd class="calibre14">Stream</kbd> to a message. This means that whenever a value is produced in the <kbd class="calibre14">Stream</kbd>, a message will be emitted. The message needs to take a parameter of the same type as the value produced by the <kbd class="calibre14">Stream</kbd>. A <kbd class="calibre14">Future</kbd> represents a value that is possibly not yet available, but will be available in the future, unless an error happens. A <kbd class="calibre14">Stream</kbd> is similar, but can produce multiple values that will be available at different times in the future. Similar to the <kbd class="calibre14">connect_exec_ignore_err()</kbd> method, there's also the <kbd class="calibre14">connect_exec()</kbd> method, which takes another message variant as a parameter, this second message will be emitted when there's an error. Here, we simply ignore the errors.</p>
<p class="calibre3">In the <kbd class="calibre14">update()</kbd> method:</p>
<pre class="calibre22">fn update(&amp;mut self, event: Msg) {
    match event {
        // To be listened by App.
        PlayerMsgRecv(_) =&gt; (),
        // …
    }
}</pre>
<p class="calibre3">We have nothing to do with this message because it will be handled by the <kbd class="calibre14">App</kbd> widget. We'll now add a method to pause the player:</p>
<pre class="calibre22">fn pause(&amp;mut self) {
    self.model.player.pause();
}</pre>
<p class="calibre3">Next we need to update the <kbd class="calibre14">play()</kbd> and <kbd class="calibre14">stop()</kbd> methods:</p>
<pre class="calibre22">fn play(&amp;mut self) {
    if let Some(path) = self.selected_path() {
        if self.model.player.is_paused() &amp;&amp; Some(&amp;path) == self.path().as_ref() {
            self.model.player.resume();
        } else {
            self.model.player.load(&amp;path);
            self.model.current_song = Some(path.into());
            self.model.relm.stream().emit(SongStarted(self.pixbuf()));
        }
    }
}

fn stop(&amp;mut self) {
    self.model.current_song = None;
    self.model.player.stop();
}</pre>
<p class="calibre3">The <kbd class="calibre14">stop()</kbd> method is the same, except that we can update the model directly, because we don't need to use the <kbd class="calibre14">RefCell</kbd> type anymore. The <kbd class="calibre14">play()</kbd> method will now load or resume the song depending on the state of the player.</p>
<p class="calibre3">The <kbd class="calibre14">play()</kbd> method requires a <kbd class="calibre14">path()</kbd> method:</p>
<pre class="calibre22">fn path(&amp;self) -&gt; Option&lt;String&gt; {
    self.model.current_song.clone()
}</pre>
<p class="calibre3">Let's go back to the <kbd class="calibre14">main</kbd> module to manage the messages sent by the player. First, we need a new variant for our <kbd class="calibre14">enum Msg</kbd>:</p>
<pre class="calibre22">#[derive(Msg)]
pub enum Msg {
    MsgRecv(PlayerMsg),
    // …
}</pre>
<p class="calibre3">We will handle this in the <kbd class="calibre14">update()</kbd> method:</p>
<pre class="calibre22">fn update(&amp;mut self, event: Msg) {
    match event {
        MsgRecv(player_msg) =&gt; self.player_message(player_msg),
        // …
    }
}</pre>
<p class="calibre3">This requires a new method to be added in <kbd class="calibre14">impl Widget for App</kbd>:</p>
<pre class="calibre22">#[widget]
impl Widget for App {
    fn player_message(&amp;mut self, player_msg: PlayerMsg) {
        match player_msg {
            PlayerPlay =&gt; {
                self.model.stopped = false;
                self.set_play_icon(PAUSE_ICON);
            },
            PlayerStop =&gt; {
                self.set_play_icon(PLAY_ICON);
                self.model.stopped = true;
            },
            PlayerTime(time) =&gt; self.set_current_time(time),
        }
    }
}</pre>
<p class="calibre3">This is also a <kbd class="calibre14">custom</kbd> method, that is, a method that is not part of the <kbd class="calibre14">Widget</kbd> trait, but is analyzed by the <kbd class="calibre14">#[widget]</kbd> attribute. We put it there instead of a separate <kbd class="calibre14">impl App</kbd> because we updated the model. In this method, we either update the icon to display the play button or the current time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Computing the song duration</h1>
                
            
            
                
<p class="calibre3">The only remaining feature that needs to be implemented in order to be on par with the music player of the previous chapter is to compute and display the song duration. First, we will copy the <kbd class="calibre14">compute_duration()</kbd> method from the previous chapter and paste it in our <kbd class="calibre14">Player</kbd>:</p>
<pre class="calibre22">pub fn compute_duration&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Option&lt;Duration&gt; {
    let file = File::open(path).unwrap();
    Mp3Decoder::compute_duration(BufReader::new(file))
}</pre>
<p class="calibre3">We'll now call this method in the <kbd class="calibre14">Playlist</kbd>:</p>
<pre class="calibre22">use std::thread;
use futures::sync::oneshot;

fn compute_duration(&amp;self, path: &amp;Path) {
    let path = path.to_path_buf();
    let (tx, rx) = oneshot::channel();
    thread::spawn(move || {
        if let Some(duration) = Player::compute_duration(&amp;path) {
            tx.send((path, duration))
                .expect("Cannot send computed duration");
        }
    });
    self.model.relm.connect_exec_ignore_err(rx, |(path, duration)| DurationComputed(path, duration));
}</pre>
<p class="calibre3">Here, we use <kbd class="calibre14">oneshot</kbd> which is also a channel, similar to <kbd class="calibre14">mpsc</kbd>, but <kbd class="calibre14">oneshot</kbd> can only send a message once. The message sent is a tuple, so we convert it to our <kbd class="calibre14">Msg</kbd> type by using a new <kbd class="calibre14">DurationComputed</kbd> variant that we'll add to the type:</p>
<pre class="calibre22">use std::time::Duration;

#[derive(Msg)]
pub enum Msg {
    AddSong(PathBuf),
    DurationComputed(PathBuf, Duration),
    SongDuration(u64),
    // …
}</pre>
<p class="calibre3">We've also added a <kbd class="calibre14">SongDuration</kbd> message that we'll use soon.</p>
<p class="calibre3">We need to call this method in <kbd class="calibre14">Playlist::add()</kbd>:</p>
<pre class="calibre22">impl Playlist {
    fn add(&amp;self, path: &amp;Path) {
        self.compute_duration(path);
        // …
    }
}</pre>
<p class="calibre3">We then need to handle the new <kbd class="calibre14">DurationComputed</kbd> message in <kbd class="calibre14">Playlist::update()</kbd>:</p>
<pre class="calibre22">use to_millis;

fn update(&amp;mut self, event: Msg) {
    match event {
        DurationComputed(path, duration) =&gt; {
            let path = path.to_string_lossy().to_string();
            if self.model.current_song.as_ref() == Some(&amp;path) {
                self.model.relm.stream().emit(SongDuration(to_millis(duration)));
            }
            self.model.durations.insert(path, to_millis(duration));
        },
        // To be listened by App.
        SongDuration(_) =&gt; (),
        // …
    }
}</pre>
<p class="calibre3">Here, we insert the computed duration in the model. And if the song is the one currently being played, we send the <kbd class="calibre14">SongDuration</kbd> message so that the <kbd class="calibre14">App</kbd> widget can update itself.</p>
<p class="calibre3">This requires a new field for the durations in the model:</p>
<pre class="calibre22">use std::collections::HashMap;

pub struct Model {
    current_song: Option&lt;String&gt;,
    durations: HashMap&lt;String, u64&gt;,
    player: Player,
    model: ListStore,
    relm: Relm&lt;Playlist&gt;,
}</pre>
<p class="calibre3">Add the new model initialization:</p>
<pre class="calibre22">fn model(relm: &amp;Relm&lt;Self&gt;, _: ()) -&gt; Model {
    // …
    Model {
        durations: HashMap::new(),
        // …
    }
}</pre>
<p class="calibre3">This also requires the <kbd class="calibre14">to_millis()</kbd> function to be added in the <kbd class="calibre14">main</kbd> module, which is the same as in the previous chapter:</p>
<pre class="calibre22">use std::time::Duration;

fn to_millis(duration: Duration) -&gt; u64 {
    duration.as_secs() * 1000 + duration.subsec_nanos() as u64 / 1_000_000
}</pre>
<p class="calibre3">Since the duration is only computed once, we also need to send it when we start playing the song, so let's update the <kbd class="calibre14">Playlist::play()</kbd> method:</p>
<pre class="calibre22">fn play(&amp;mut self) {
    if let Some(path) = self.selected_path() {
        if self.model.player.is_paused() &amp;&amp; Some(&amp;path) == self.path().as_ref() {
            self.model.player.resume();
        } else {
            self.model.player.load(&amp;path);
            if let Some(&amp;duration) = self.model.durations.get(&amp;path) {
                self.model.relm.stream().emit(SongDuration(duration));
            }
            self.model.current_song = Some(path.into());
            self.model.relm.stream().emit(SongStarted(self.pixbuf()));
        }
    }
}</pre>
<p class="calibre3">We send the <kbd class="calibre14">SongDuration</kbd> message if we found it in the <kbd class="calibre14">HashMap</kbd> (it is possible that the song starts playing before the duration is computed).</p>
<p class="calibre3">Finally, we need to handle the following message in the <kbd class="calibre14">App</kbd> view:</p>
<pre class="calibre22">view! {
    Playlist {
        PlayerMsgRecv(ref player_msg) =&gt; MsgRecv(player_msg.clone()),
        SongDuration(duration) =&gt; Duration(duration),
        SongStarted(ref pixbuf) =&gt; Started(pixbuf.clone()),
    }
    // …
}</pre>
<p class="calibre3">When we receive the <kbd class="calibre14">SongDuration</kbd> message from the playlist, we send the <kbd class="calibre14">Duration</kbd> message to <kbd class="calibre14">App</kbd>, so we need to add this variant to its <kbd class="calibre14">Msg</kbd> type:</p>
<pre class="calibre22">#[derive(Msg)]
pub enum Msg {
    Duration(u64),
    // …
}</pre>
<p class="calibre3">We'll simply handle it in the <kbd class="calibre14">update()</kbd> method:</p>
<pre class="calibre22">fn update(&amp;mut self, event: Msg) {
    match event {
        Duration(duration) =&gt; {
            self.model.current_duration = duration;
            self.model.adjustment.set_upper(duration as f64);
        },
        // …
    }
}</pre>
<p class="calibre3">You can now run the application and see that it works exactly the same as the one from the previous chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using relm on stable Rust</h1>
                
            
            
                
<p class="calibre3">In this whole chapter, we used Rust nightly to be able to use <kbd class="calibre14">custom</kbd> attributes, which are currently unstable. The <kbd class="calibre14">#[widget]</kbd> attribute provided by <kbd class="calibre14">relm</kbd> provides many advantages:</p>
<ul class="calibre10">
<li class="calibre11">Declarative view</li>
<li class="calibre11">Data bindings</li>
<li class="calibre11">Less typing</li>
</ul>
<p class="calibre3">So it would be nice to be able to use a similar syntax on stable that provides the same advantages. And it is possible to do so, by using the <kbd class="calibre14">relm_widget!</kbd> macro. We'll rewrite the <kbd class="calibre14">App</kbd> widget to use this macro:</p>
<pre class="calibre22">relm_widget! {
    impl Widget for App {
        fn init_view(&amp;mut self) {
            self.toolbar.show_all();
        }

        fn model() -&gt; Model {
            Model {
                adjustment: Adjustment::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
                cover_pixbuf: None,
                cover_visible: false,
                current_duration: 0,
                current_time: 0,
                play_image: new_icon(PLAY_ICON),
                stopped: true,
            }
        }

        fn open(&amp;self) {
            // …
        }

        // …

        fn update(&amp;mut self, event: Msg) {
            // …
        }

        view! {
            #[name="window"]
            gtk::Window {
                title: "Rusic",
                // …
            }
        }
    }
}</pre>
<p class="calibre3">As you can see, we moved the external <kbd class="calibre14">open()</kbd> method inside the implementation decorated by the <kbd class="calibre14">relm_widget!</kbd> macro. This is due to a limitation of this macro, while it allows us to use the nice syntax provided by relm on stable Rust, we cannot access the fields of the model from outside the macro. The rest is exactly the same as the previous versions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Relm widgets data binding</h1>
                
            
            
                
<p class="calibre3">There are many other features available in relm and I wanted to show you the most important of them: the syntax that is provided to simulate property binding. As you may have noticed by now, there's no property in <kbd class="calibre14">relm</kbd> widgets, but you can use message passing to update the internal state of a <kbd class="calibre14">relm</kbd> widget. To make it more convenient, the <kbd class="calibre14">#[widget]</kbd> attribute also allows you to bind a model attribute to a message, this means that whenever the attribute is updated, the message will be emitted with this new value.</p>
<p class="calibre3">We'll add a toggle button to be able to switch between a simple and a detailed view for the playlist. The simple view will only show the cover and the title while the detailed view will show all the columns. First, let's add an attribute to the <kbd class="calibre14">App</kbd> model:</p>
<pre class="calibre22">pub struct Model {
    detailed_view: bool,
    // …
}

    fn model() -&gt; Model {
        Model {
            detailed_view: false,
            // …
        }
    }</pre>
<p class="calibre3">This field specifies whether we're in the detailed view mode or not. We'll also need a message that will be emitted when we click the toggle button:</p>
<pre class="calibre22">#[derive(Msg)]
pub enum Msg {
    ViewToggle,
    // …
}</pre>
<p class="calibre3">Then, we add the toggle button to the toolbar:</p>
<pre class="calibre22">#[name="toggle_button"]
gtk::ToggleToolButton {
    label: "Detailed view",
    toggled =&gt; ViewToggle,
}</pre>
<p class="calibre3">When we receive this message, we'll set the <kbd class="calibre14">model</kbd> attribute accordingly:</p>
<pre class="calibre22">fn update(&amp;mut self, event: Msg) {
    match event {
        ViewToggle =&gt; self.model.detailed_view = self.toggle_button.get_active(),
        // …
    }
}</pre>
<p class="calibre3">Now, let's a message to the <kbd class="calibre14">Playlist</kbd>:</p>
<pre class="calibre22">#[derive(Msg)]
pub enum Msg {
    DetailedView(bool),
    // …
}</pre>
<p class="calibre3">This is the message we'll use for the binding. Let's handle it:</p>
<pre class="calibre22">fn update(&amp;mut self, event: Msg) {
    match event {
        DetailedView(detailed) =&gt; self.set_detailed_view(detailed),
        // …
    }
}

fn set_detailed_view(&amp;self, detailed: bool) {
    for column in self.treeview.get_columns().iter().skip(2) {
        column.set_visible(detailed);
    }
}</pre>
<p class="calibre3">The latter method toggles the visible of all columns except the first two. We can now create the binding in the <kbd class="calibre14">App</kbd> view:</p>
<pre class="calibre22">use playlist::Msg::DetailedView;

view! {
    // …
    #[name="playlist"]
    Playlist {
        // …
        DetailedView: self.model.detailed_view,
    }
}</pre>
<p class="calibre3">This code will send the <kbd class="calibre14">DetailedView</kbd> message with the specified attribute as the value whenever it changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre3">In this chapter, we used <kbd class="calibre14">relm</kbd> to create a music player. We saw how simple it is to use rust nightly with <kbd class="calibre14">rustup</kbd>. We learned how to declaratively create views and use message passing to communicate between widgets. We also learned how to structure GUI applications by separating the model, the view, and the function to update the model in reaction to events. In the next chapter, we'll switch to another project: an FTP server.</p>
<p class="calibre3"/>


            

            
        
    </body></html>