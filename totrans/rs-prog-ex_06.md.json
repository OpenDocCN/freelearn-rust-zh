["```rs\nsudo apt-get install libmad0-dev libpulse-dev\n```", "```rs\nbrew install libmad pulseaudio\n```", "```rs\npacman -S mingw-w64-libmad\n```", "```rs\ncrossbeam = \"^0.3.0\"\npulse-simple = \"^1.0.0\"\nsimplemad = \"^0.8.1\"\n```", "```rs\nextern crate crossbeam;\nextern crate pulse_simple;\nextern crate simplemad;\n\nmod mp3;\n```", "```rs\nuse std::io::{Read, Seek, SeekFrom};\nuse std::time::Duration;\n\nuse simplemad;\n```", "```rs\npub struct Mp3Decoder<R> where R: Read {\n    reader: simplemad::Decoder<R>,\n    current_frame: simplemad::Frame,\n    current_frame_channel: usize,\n    current_frame_sample_pos: usize,\n    current_time: u64,\n}\n```", "```rs\npub struct Mp3Decoder<R: Read> {\n    // …\n}\n```", "```rs\nfn to_millis(duration: Duration) -> u64 {\n    duration.as_secs() * 1000 + duration.subsec_nanos() as u64 / 1_000_000\n}\n```", "```rs\nuse std::time::Duration;\n```", "```rs\nfn is_mp3<R>(mut data: R) -> bool where R: Read + Seek {\n    let stream_pos = data.seek(SeekFrom::Current(0)).unwrap();\n    let is_mp3 = simplemad::Decoder::decode(data.by_ref()).is_ok();\n    data.seek(SeekFrom::Start(stream_pos)).unwrap();\n    is_mp3\n}\n```", "```rs\nfn next_frame<R: Read>(decoder: &mut simplemad::Decoder<R>) -> simplemad::Frame {\n    decoder.filter_map(|f| f.ok()).next()\n        .unwrap_or_else(|| {\n            simplemad::Frame {\n                bit_rate: 0,\n                layer: Default::default(),\n                mode: Default::default(),\n                sample_rate: 44100,\n                samples: vec![Vec::new()],\n                position: Duration::from_secs(0),\n                duration: Duration::from_secs(0),\n            }\n        })\n}\n```", "```rs\nimpl<R> Mp3Decoder<R> where R: Read + Seek {\n    pub fn new(mut data: R) -> Result<Mp3Decoder<R>, R> {\n        if !is_mp3(data.by_ref()) {\n            return Err(data);\n        }\n\n        let mut reader = simplemad::Decoder::decode(data).unwrap();\n\n        let current_frame = next_frame(&mut reader);\n        let current_time = to_millis(current_frame.duration);\n\n        Ok(Mp3Decoder {\n            reader,\n            current_frame,\n            current_frame_channel: 0,\n            current_frame_sample_pos: 0,\n            current_time,\n        })\n    }\n}\n```", "```rs\nuse to_millis;\n```", "```rs\n    pub fn current_time(&self) -> u64 {\n        self.current_time\n    }\n\n    pub fn samples_rate(&self) -> u32 {\n        self.current_frame.sample_rate\n    }\n```", "```rs\n    pub fn compute_duration(mut data: R) -> Option<Duration> {\n        if !is_mp3(data.by_ref()) {\n            return None;\n        }\n\n        let decoder = simplemad::Decoder::decode_headers(data).unwrap();\n        Some(decoder.filter_map(|frame| {\n            match frame {\n                Ok(frame) => Some(frame.duration),\n                Err(_) => None,\n            }\n        })\n            .sum())\n    }\n```", "```rs\nfn next_sample<R: Read>(decoder: &mut Mp3Decoder<R>) -> Option<i16> {\n    if decoder.current_frame.samples[0].len() == 0 {\n        return None;\n    }\n\n    // getting the sample and converting it from fixed step to i16\n    let sample = decoder.current_frame.samples[decoder.current_frame_channel] \n    [decoder.current_frame_sample_pos];\n    let sample = sample.to_i32() + (1 << (28 - 16));\n    let sample = if sample >= 0x10000000 { 0x10000000 - 1 } else if sample <=  \n    -0x10000000 { -0x10000000 } else { sample };\n    let sample = sample >> (28 + 1 - 16);\n    let sample = sample as i16;\n\n    decoder.current_frame_channel += 1;\n\n    if decoder.current_frame_channel < decoder.current_frame.samples.len() {\n        return Some(sample);\n    }\n\n    decoder.current_frame_channel = 0;\n    decoder.current_frame_sample_pos += 1;\n\n    if decoder.current_frame_sample_pos < decoder.current_frame.samples[0].len() {\n        return Some(sample);\n    }\n\n    decoder.current_frame = next_frame(&mut decoder.reader);\n    decoder.current_frame_channel = 0;\n    decoder.current_frame_sample_pos = 0;\n    decoder.current_time += to_millis(decoder.current_frame.duration);\n\n    return Some(sample);\n}\n```", "```rs\nimpl<R> Iterator for Mp3Decoder<R> where R: Read {\n    type Item = i16;\n\n    fn next(&mut self) -> Option<i16> {\n        next_sample(self)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.current_frame.samples[0].len(), None)\n    }\n}\n```", "```rs\nmod player;\n```", "```rs\nuse std::fs::File;\nuse std::io::BufReader;\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Condvar, Mutex};\nuse std::thread;\n\nuse crossbeam::sync::SegQueue;\nuse pulse_simple::Playback;\n\nuse mp3::Mp3Decoder;\nuse self::Action::*;\n```", "```rs\nconst BUFFER_SIZE: usize = 1000;\nconst DEFAULT_RATE: u32 = 44100;\n```", "```rs\nenum Action {\n    Load(PathBuf),\n    Stop,\n}\n```", "```rs\n#[derive(Clone)]\nstruct EventLoop {\n    queue: Arc<SegQueue<Action>>,\n    playing: Arc<Mutex<bool>>,\n}\n```", "```rs\nerror[E0277]: the trait bound `std::rc::Rc<i32>: std::marker::Send` is not satisfied in `[closure@src/main.rs:6:19: 8:6 rc:std::rc::Rc<i32>]`\n --> src/main.rs:6:5\n  |\n6 |     thread::spawn(move || {\n  |     ^^^^^^^^^^^^^ `std::rc::Rc<i32>` cannot be sent between threads safely\n  |\n  = help: within `[closure@src/main.rs:6:19: 8:6 rc:std::rc::Rc<i32>]`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<i32>`\n  = note: required because it appears within the type `[closure@src/main.rs:6:19: 8:6 rc:std::rc::Rc<i32>]`\n  = note: required by `std::thread::spawn`\n```", "```rs\nimpl EventLoop {\n    fn new() -> Self {\n        EventLoop {\n            queue: Arc::new(SegQueue::new()),\n            playing: Arc::new(Mutex::new(false)),\n        }\n    }\n}\n```", "```rs\nstruct State {\n    stopped: bool,\n}\n```", "```rs\nstruct App {\n    adjustment: Adjustment,\n    cover: Image,\n    playlist: Rc<Playlist>,\n    state: Arc<Mutex<State>>,\n    toolbar: MusicToolbar,\n    window: Window,\n}\n```", "```rs\nuse std::sync::{Arc, Mutex};\n```", "```rs\nimpl App {\n    fn new() -> Self {\n        // …\n\n        let state = Arc::new(Mutex::new(State {\n            stopped: true,\n        }));\n\n        let playlist = Rc::new(Playlist::new(state.clone()));\n\n        // …\n\n        let app = App {\n            adjustment,\n            cover,\n            playlist,\n            state,\n            toolbar,\n            window,\n        };\n\n        // …\n    }\n}\n```", "```rs\nimpl Playlist {\n    pub(crate) fn new(state: Arc<Mutex<State>>) -> Self {\n        let model = ListStore::new(&[\n            Pixbuf::static_type(),\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Pixbuf::static_type(),\n        ]);\n        let treeview = TreeView::new_with_model(&model);\n        treeview.set_hexpand(true);\n        treeview.set_vexpand(true);\n\n        Self::create_columns(&treeview);\n\n        Playlist {\n            model,\n            player: Player::new(state.clone()),\n            treeview,\n        }\n    }\n}\n```", "```rs\npub struct Playlist {\n    model: ListStore,\n    player: Player,\n    treeview: TreeView,\n}\n```", "```rs\nuse std::sync::{Arc, Mutex};\n\nuse State;\nuse player::Player;\n```", "```rs\npub struct Player {\n    app_state: Arc<Mutex<super::State>>,\n    event_loop: EventLoop,\n}\n```", "```rs\nimpl Player {\n    pub(crate) fn new(app_state: Arc<Mutex<super::State>>) -> Self {\n        let event_loop = EventLoop::new();\n\n        {\n            let app_state = app_state.clone();\n            let event_loop = event_loop.clone();\n            thread::spawn(move || {\n                // …\n            });\n        }\n\n        Player {\n            app_state,\n            event_loop,\n        }\n    }\n}\n```", "```rs\nthread::spawn(move || {\n    let mut buffer = [[0; 2]; BUFFER_SIZE];\n    let mut playback = Playback::new(\"MP3\", \"MP3 Playback\", None,\n    DEFAULT_RATE);\n    let mut source = None;\n    loop {\n        if let Some(action) = event_loop.queue.try_pop() {\n            match action {\n                Load(path) => {\n                    let file = File::open(path).unwrap();\n                    source = Some(Mp3Decoder::new(BufReader::new(file)).unwrap());\n                    let rate = source.as_ref().map(|source| \n                     source.samples_rate()).unwrap_or(DEFAULT_RATE);\n                    playback = Playback::new(\"MP3\", \"MP3 Playback\", \n                     None, rate);\n                    app_state.lock().unwrap().stopped = false;\n                },\n                Stop => {},\n            }\n        }\n        // …\n    }\n});\n```", "```rs\napp_state.lock().unwrap().stopped = false;\n```", "```rs\nlet mut guard = app_state.lock().unwrap();\nguard.stopped = false;\n```", "```rs\nloop {\n    if let Some(action) = event_loop.queue.try_pop() {\n        // …\n    } else if *event_loop.playing.lock().unwrap() {\n        let mut written = false;\n        if let Some(ref mut source) = source {\n            let size = iter_to_buffer(source, &mut buffer);\n            if size > 0 {\n                playback.write(&buffer[..size]);\n                written = true;\n            }\n        }\n\n        if !written {\n            app_state.lock().unwrap().stopped = true;\n            *event_loop.playing.lock().unwrap() = false;\n            source = None;\n        }\n    }\n}\n```", "```rs\nfn iter_to_buffer<I: Iterator<Item=i16>>(iter: &mut I, buffer: &mut [[i16; 2]; BUFFER_SIZE]) -> usize {\n    let mut iter = iter.take(BUFFER_SIZE);\n    let mut index = 0;\n    while let Some(sample1) = iter.next() {\n        if let Some(sample2) = iter.next() {\n            buffer[index][0] = sample1;\n            buffer[index][1] = sample2;\n        }\n        index += 1;\n    }\n    index\n}\n```", "```rs\n    fn selected_path(&self) -> Option<String> {\n        let selection = self.treeview.get_selection();\n        if let Some((_, iter)) = selection.get_selected() {\n            let value = self.model.get_value(&iter, PATH_COLUMN as i32);\n            return value.get::<String>();\n        }\n        None\n    }\n```", "```rs\n    pub fn play(&self) -> bool {\n        if let Some(path) = self.selected_path() {\n            self.player.load(&path);\n            true\n        } else {\n            false\n        }\n    }\n```", "```rs\nimpl App {\n    pub fn connect_toolbar_events(&self) {\n        // …\n\n        let playlist = self.playlist.clone();\n        let play_image = self.toolbar.play_image.clone();\n        let cover = self.cover.clone();\n        let state = self.state.clone();\n        self.toolbar.play_button.connect_clicked(move |_| {\n            if state.lock().unwrap().stopped {\n                if playlist.play() {\n                    set_image_icon(&play_image, PAUSE_ICON);\n                    set_cover(&cover, &playlist);\n                }\n            } else {\n                set_image_icon(&play_image, PLAY_ICON);\n            }\n        });\n\n        // …\n    }\n}\n```", "```rs\nuse std::cell::Cell;\n\npub struct Player {\n    app_state: Arc<Mutex<super::State>>,\n    event_loop: EventLoop,\n    paused: Cell<bool>,\n}\n```", "```rs\nimpl Player {\n    pub(crate) fn new(app_state: Arc<Mutex<super::State>>) -> Self {\n        // …\n\n        Player {\n            app_state,\n            event_loop,\n            paused: Cell::new(false),\n        }\n    }\n}\n```", "```rs\n    pub fn is_paused(&self) -> bool {\n        self.paused.get()\n    }\n```", "```rs\n    pub fn pause(&self) {\n        self.paused.set(true);\n        self.app_state.lock().unwrap().stopped = true;\n        self.set_playing(false);\n    }\n\n    pub fn resume(&self) {\n        self.paused.set(false);\n        self.app_state.lock().unwrap().stopped = false;\n        self.set_playing(true);\n    }\n```", "```rs\n    fn set_playing(&self, playing: bool) {\n        *self.event_loop.playing.lock().unwrap() = playing;\n        let (ref lock, ref condition_variable) = *self.event_loop.condition_variable;\n        let mut started = lock.lock().unwrap();\n        *started = playing;\n        if playing {\n            condition_variable.notify_one();\n        }\n    }\n```", "```rs\n    pub fn pause(&self) {\n        self.player.pause();\n    }\n```", "```rs\nself.toolbar.play_button.connect_clicked(move |_| {\n    if state.lock().unwrap().stopped {\n        if playlist.play() {\n            set_image_icon(&play_image, PAUSE_ICON);\n            set_cover(&cover, &playlist);\n        }\n    } else {\n        playlist.pause();\n        set_image_icon(&play_image, PLAY_ICON);\n    }\n});\n```", "```rs\npub struct Playlist {\n    current_song: RefCell<Option<String>>,\n    model: ListStore,\n    player: Player,\n    treeview: TreeView,\n}\n```", "```rs\nuse std::cell::RefCell;\n```", "```rs\nimpl Playlist {\n    pub(crate) fn new(state: Arc<Mutex<State>>) -> Self {\n        // …\n\n        Playlist {\n            current_song: RefCell::new(None),\n            model,\n            player: Player::new(state.clone()),\n            treeview,\n        }\n    }\n}\n```", "```rs\n    pub fn path(&self) -> Option<String> {\n        self.current_song.borrow().clone()\n    }\n```", "```rs\n    pub fn play(&self) -> bool {\n        if let Some(path) = self.selected_path() {\n            if self.player.is_paused() && Some(&path) == \n             self.path().as_ref() {\n                self.player.resume();\n            } else {\n                self.player.load(&path);\n                *self.current_song.borrow_mut() = Some(path.into());\n            }\n            true\n        } else {\n            false\n        }\n    }\n```", "```rs\n    pub fn stop(&self) {\n        self.paused.set(false);\n        self.app_state.lock().unwrap().stopped = true;\n        self.emit(Stop);\n        self.set_playing(false);\n    }\n```", "```rs\nfn emit(&self, action: Action) {\n    self.event_loop.queue.push(action);\n}\n```", "```rs\nStop => {\n    source = None;\n},\n```", "```rs\n    pub fn stop(&self) {\n        *self.current_song.borrow_mut() = None;\n        self.player.stop();\n    }\n```", "```rs\n    let playlist = self.playlist.clone();\n    let play_image = self.toolbar.play_image.clone();\n    let cover = self.cover.clone();\n    self.toolbar.stop_button.connect_clicked(move |_| {\n        playlist.stop();\n        cover.hide();\n        set_image_icon(&play_image, PLAY_ICON);\n    });\n```", "```rs\n    pub fn next(&self) -> bool {\n        let selection = self.treeview.get_selection();\n        let next_iter =\n            if let Some((_, iter)) = selection.get_selected() {\n                if !self.model.iter_next(&iter) {\n                    return false;\n                }\n                Some(iter)\n            }\n            else {\n                self.model.get_iter_first()\n            };\n        if let Some(ref iter) = next_iter {\n            selection.select_iter(iter);\n            self.play();\n        }\n        next_iter.is_some()\n    }\n```", "```rs\n    pub fn previous(&self) -> bool {\n        let selection = self.treeview.get_selection();\n        let previous_iter =\n            if let Some((_, iter)) = selection.get_selected() {\n                if !self.model.iter_previous(&iter) {\n                    return false;\n                }\n                Some(iter)\n            }\n            else {\n                self.model.iter_nth_child(None, max(0, \n                 self.model.iter_n_children(None) \n                - 1))\n            };\n        if let Some(ref iter) = previous_iter {\n            selection.select_iter(iter);\n            self.play();\n        }\n        previous_iter.is_some()\n    }\n```", "```rs\nuse std::cmp::max;\n```", "```rs\nlet playlist = self.playlist.clone();\nlet play_image = self.toolbar.play_image.clone();\nlet cover = self.cover.clone();\nself.toolbar.next_button.connect_clicked(move |_| {\n    if playlist.next() {\n        set_image_icon(&play_image, PAUSE_ICON);\n        set_cover(&cover, &playlist);\n    }\n});\n```", "```rs\nlet playlist = self.playlist.clone();\nlet play_image = self.toolbar.play_image.clone();\nlet cover = self.cover.clone();\nself.toolbar.previous_button.connect_clicked(move |_| {\n    if playlist.previous() {\n        set_image_icon(&play_image, PAUSE_ICON);\n        set_cover(&cover, &playlist);\n    }\n});\n```", "```rs\nuse std::time::Duration;\n\n    pub fn compute_duration<P: AsRef<Path>>(path: P) -> \n     Option<Duration> {\n        let file = File::open(path).unwrap();\n        Mp3Decoder::compute_duration(BufReader::new(file))\n    }\n```", "```rs\nuse std::collections::HashMap;\n\nstruct State {\n    current_time: u64,\n    durations: HashMap<String, u64>,\n    stopped: bool,\n}\n```", "```rs\nlet current_time = 0;\nlet durations = HashMap::new();\nlet state = Arc::new(Mutex::new(State {\n    current_time,\n    durations,\n    stopped: true,\n}));\n```", "```rs\npub struct Playlist {\n    current_song: RefCell<Option<String>>,\n    model: ListStore,\n    player: Player,\n    state: Arc<Mutex<State>>,\n    treeview: TreeView,\n}\n```", "```rs\nPlaylist {\n    current_song: RefCell::new(None),\n    model,\n    player: Player::new(state.clone()),\n    state,\n    treeview,\n}\n```", "```rs\nuse std::thread;\nuse to_millis;\n\n    fn compute_duration(&self, path: &Path) {\n        let state = self.state.clone();\n        let path = path.to_string_lossy().to_string();\n        thread::spawn(move || {\n            if let Some(duration) = Player::compute_duration(&path)\n            {\n                let mut state = state.lock().unwrap();\n                state.durations.insert(path, to_millis(duration));\n            }\n        });\n    }\n```", "```rs\n    pub fn add(&self, path: &Path) {\n        self.compute_duration(path);\n\n        // …\n    }\n```", "```rs\nlet adjustment = Adjustment::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n```", "```rs\nuse gtk::{AdjustmentExt, Continue};\nuse toolbar::{set_image_icon, PAUSE_ICON, PLAY_ICON};\n\n    fn connect_events(&self) {\n        let playlist = self.playlist.clone();\n        let adjustment = self.adjustment.clone();\n        let state = self.state.clone();\n        let play_image = self.toolbar.play_image.clone();\n        gtk::timeout_add(100, move || {\n            let state = state.lock().unwrap();\n            if let Some(path) = playlist.path() {\n                if let Some(&duration) = state.durations.get(&path) \n                {\n                    adjustment.set_upper(duration as f64);\n                }\n            }\n            if state.stopped {\n                set_image_icon(&play_image, PLAY_ICON);\n            } else {\n                set_image_icon(&play_image, PAUSE_ICON);\n            }\n            adjustment.set_value(state.current_time as f64);\n            Continue(true)\n        });\n    }\n```", "```rs\nstruct EventLoop {\n    condition_variable: Arc<(Mutex<bool>, Condvar)>,\n    queue: Arc<SegQueue<Action>>,\n    playing: Arc<Mutex<bool>>,\n}\n```", "```rs\nimpl EventLoop {\n    fn new() -> Self {\n        EventLoop {\n            condition_variable: Arc::new((Mutex::new(false), Condvar::new())),\n            queue: Arc::new(SegQueue::new()),\n            playing: Arc::new(Mutex::new(false)),\n        }\n    }\n}\n```", "```rs\n{\n    let app_state = app_state.clone();\n    let event_loop = event_loop.clone();\n    let condition_variable = event_loop.condition_variable.clone();\n    thread::spawn(move || {\n        let block = || {\n            let (ref lock, ref condition_variable) = \n             *condition_variable;\n            let mut started = lock.lock().unwrap();\n            *started = false;\n            while !*started {\n                started =\n                 condition_variable.wait(started).unwrap();\n            }\n        };\n```", "```rs\n        let mut buffer = [[0; 2]; BUFFER_SIZE];\n        let mut playback = Playback::new(\"MP3\", \"MP3 Playback\", None, \n         DEFAULT_RATE);\n        let mut source = None;\n        loop {\n            if let Some(action) = event_loop.queue.try_pop() {\n                match action {\n                    Load(path) => {\n                        let file = File::open(path).unwrap();\n                        source = \n                         Some(Mp3Decoder::new(BufReader::new(file)).unwrap());\n                        let rate = source.as_ref().map(|source| \n                         source.samples_rate()).unwrap_or(DEFAULT_RATE);\n                        playback = Playback::new(\"MP3\", \"MP3 Playback\", \n                         None, rate);\n                        app_state.lock().unwrap().stopped = false;\n                    },\n                    Stop => {\n                        source = None;\n                    },\n                }\n            } else if *event_loop.playing.lock().unwrap() {\n                let mut written = false;\n                if let Some(ref mut source) = source {\n                    let size = iter_to_buffer(source, &mut buffer);\n                    if size > 0 {\n                        app_state.lock().unwrap().current_time = \n                         source.current_time();\n                        playback.write(&buffer[..size]);\n                        written = true;\n                    }\n                }\n```", "```rs\n                if !written {\n                    app_state.lock().unwrap().stopped = true;\n                    *event_loop.playing.lock().unwrap() = false;\n                    source = None;\n                    block();\n                }\n            } else {\n                block();\n            }\n        }\n    });\n}\n```", "```rs\nuse gtk::{Label, LabelExt};\n```", "```rs\nstruct App {\n    adjustment: Adjustment,\n    cover: Image,\n    current_time_label: Label,\n    duration_label: Label,\n    playlist: Rc<Playlist>,\n    state: Arc<Mutex<State>>,\n    toolbar: MusicToolbar,\n    window: Window,\n}\n```", "```rs\nlet hbox = gtk::Box::new(Horizontal, 10);\nvbox.add(&hbox);\n\nlet adjustment = Adjustment::new(0.0, 0.0, 10.0, 0.0, 0.0, 0.0);\nlet scale = Scale::new(Horizontal, &adjustment);\nscale.set_draw_value(false);\nscale.set_hexpand(true);\nhbox.add(&scale);\n```", "```rs\nlet current_time_label = Label::new(None);\nhbox.add(&current_time_label);\n\nlet slash_label = Label::new(\"/\");\nhbox.add(&slash_label);\n\nlet duration_label = Label::new(None);\nduration_label.set_margin_right(10);\nhbox.add(&duration_label);\n```", "```rs\nlet app = App {\n    adjustment,\n    cover,\n    current_time_label,\n    duration_label,\n    playlist,\n    state,\n    toolbar,\n    window,\n};\n```", "```rs\nfn millis_to_minutes(millis: u64) -> String {\n    let mut seconds = millis / 1_000;\n    let minutes = seconds / 60;\n    seconds %= 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n```", "```rs\nlet current_time_label = self.current_time_label.clone();\nlet duration_label = self.duration_label.clone();\nlet playlist = self.playlist.clone();\nlet adjustment = self.adjustment.clone();\nlet state = self.state.clone();\nlet play_image = self.toolbar.play_image.clone();\ngtk::timeout_add(100, move || {\n    let state = state.lock().unwrap();\n    if let Some(path) = playlist.path() {\n        if let Some(&duration) = state.durations.get(&path) {\n            adjustment.set_upper(duration as f64);\n            duration_label.set_text(&millis_to_minutes(duration));\n        }\n    }\n    if state.stopped {\n        set_image_icon(&play_image, PLAY_ICON);\n    } else {\n        set_image_icon(&play_image, PAUSE_ICON);\n        current_time_label.set_text(&millis_to_minutes(state.current_time));\n    }\n    adjustment.set_value(state.current_time as f64);\n    Continue(true)\n});\n```", "```rs\nlet current_time_label = self.current_time_label.clone();\nlet duration_label = self.duration_label.clone();\nlet playlist = self.playlist.clone();\nlet play_image = self.toolbar.play_image.clone();\nlet cover = self.cover.clone();\nself.toolbar.stop_button.connect_clicked(move |_| {\n    current_time_label.set_text(\"\");\n    duration_label.set_text(\"\");\n    playlist.stop();\n    cover.hide();\n    set_image_icon(&play_image, PLAY_ICON);\n});\n```", "```rs\nm3u = \"^1.0.0\"\n```", "```rs\nextern crate m3u;\n```", "```rs\npub struct MusicToolbar {\n    open_button: ToolButton,\n    next_button: ToolButton,\n    play_button: ToolButton,\n    pub play_image: Image,\n    previous_button: ToolButton,\n    quit_button: ToolButton,\n    remove_button: ToolButton,\n    save_button: ToolButton,\n    stop_button: ToolButton,\n    toolbar: Toolbar,\n}\n```", "```rs\nimpl MusicToolbar {\n    pub fn new() -> Self {\n        let toolbar = Toolbar::new();\n\n        let (open_button, _) = new_tool_button(\"document-open\");\n        toolbar.add(&open_button);\n\n        let (save_button, _) = new_tool_button(\"document-save\");\n        toolbar.add(&save_button);\n\n        toolbar.add(&SeparatorToolItem::new());\n\n        // …\n\n        let toolbar = MusicToolbar {\n            open_button,\n            next_button,\n            play_button,\n            play_image,\n            previous_button,\n            quit_button,\n            remove_button,\n            save_button,\n            stop_button,\n            toolbar\n        };\n\n        toolbar\n    }\n}\n```", "```rs\nuse std::fs::File;\n\nuse m3u;\n\n    pub fn save(&self, path: &Path) {\n        let mut file = File::create(path).unwrap();\n        let mut writer = m3u::Writer::new(&mut file);\n\n        let mut write_iter = |iter: &TreeIter| {\n            let value = self.model.get_value(&iter, PATH_COLUMN as\n              i32);\n            let path = value.get::<String>().unwrap();\n            writer.write_entry(&m3u::path_entry(path)).unwrap();\n        };\n\n        if let Some(iter) = self.model.get_iter_first() {\n            write_iter(&iter);\n            while self.model.iter_next(&iter) {\n                write_iter(&iter);\n            }\n        }\n    }\n```", "```rs\nfn show_save_dialog(parent: &ApplicationWindow) -> Option<PathBuf> {\n    let mut file = None;\n    let dialog = FileChooserDialog::new(Some(\"Choose a destination \n     M3U playlist  \n    file\"), Some(parent), FileChooserAct    ion::Save);\n    let filter = FileFilter::new();\n    filter.add_mime_type(\"audio/x-mpegurl\");\n    filter.set_name(\"M3U playlist file\");\n    dialog.set_do_overwrite_confirmation(true);\n    dialog.add_filter(&filter);\n    dialog.add_button(\"Cancel\", RESPONSE_CANCEL);\n    dialog.add_button(\"Save\", RESPONSE_ACCEPT);\n    let result = dialog.run();\n    if result == RESPONSE_ACCEPT {\n        file = dialog.get_filename();\n    }\n    dialog.destroy();\n    file\n}\n```", "```rs\nlet parent = self.window.clone();\nlet playlist = self.playlist.clone();\nself.toolbar.save_button.connect_clicked(move |_| {\n    let file = show_save_dialog(&parent);\n    if let Some(file) = file {\n        playlist.save(&file);\n    }\n});\n```", "```rs\n    pub fn load(&self, path: &Path) {\n        let mut reader = m3u::Reader::open(path).unwrap();\n        for entry in reader.entries() {\n            if let Ok(m3u::Entry::Path(path)) = entry {\n                self.add(&path);\n            }\n        }\n    }\n```", "```rs\nfn show_open_dialog(parent: &ApplicationWindow) -> Option<PathBuf> {\n    let mut file = None;\n    let dialog = FileChooserDialog::new(Some(\"Select an MP3 audio file\"), \n    Some(parent), FileChooserAction::Open);\n\n    let mp3_filter = FileFilter::new();\n    mp3_filter.add_mime_type(\"audio/mp3\");\n    mp3_filter.set_name(\"MP3 audio file\");\n    dialog.add_filter(&mp3_filter);\n\n    let m3u_filter = FileFilter::new();\n    m3u_filter.add_mime_type(\"audio/x-mpegurl\");\n    m3u_filter.set_name(\"M3U playlist file\");\n    dialog.add_filter(&m3u_filter);\n\n    dialog.add_button(\"Cancel\", RESPONSE_CANCEL);\n    dialog.add_button(\"Accept\", RESPONSE_ACCEPT);\n    let result = dialog.run();\n    if result == RESPONSE_ACCEPT {\n        file = dialog.get_filename();\n    }\n    dialog.destroy();\n    file\n}\n```", "```rs\nimpl App {\n    pub fn connect_toolbar_events(&self) {\n        let parent = self.window.clone();\n        let playlist = self.playlist.clone();\n        self.toolbar.open_button.connect_clicked(move |_| {\n            let file = show_open_dialog(&parent);\n            if let Some(file) = file {\n                if let Some(ext) = file.extension() {\n                    match ext.to_str().unwrap() {\n                        \"mp3\" => playlist.add(&file),\n                        \"m3u\" => playlist.load(&file),\n                        extension => {\n                            let dialog = \n                             MessageDialog::new(Some(&parent),  \n                             DialogFlags::empty(), MessageType::Error,\n                                ButtonsType::Ok, &format!(\"Cannot open \n                                 file with \n                                 extension .{}\", extension));\n                            dialog.run();\n                            dialog.destroy();\n                        },\n                    }\n                }\n            }\n        });\n\n        // …\n    }\n}\n```", "```rs\nuse gtk::{\n    ButtonsType,\n    DialogFlags,\n    MessageDialog,\n    MessageType,\n};\n```", "```rs\ncrossbeam = \"^0.3.0\"\npulse-simple = \"^1.0.0\"\nsimplemad = \"^0.8.1\"\n```", "```rs\ngstreamer = \"^0.9.1\"\ngstreamer-player = \"^0.9.0\"\n```", "```rs\nextern crate gstreamer as gst;\nextern crate gstreamer_player as gst_player;\n```", "```rs\ngst::init().expect(\"gstreamer initialization failed\");\n```", "```rs\nuse gst::{ClockTime, ElementExt};\nuse gst_player;\nuse gtk::Cast;\n```", "```rs\npub struct Playlist {\n    current_song: RefCell<Option<String>>,\n    model: ListStore,\n    player: gst_player::Player,\n    treeview: TreeView,\n}\n```", "```rs\nimpl Playlist {\n    pub(crate) fn new() -> Self {\n        let model = ListStore::new(&[\n            Pixbuf::static_type(),\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Pixbuf::static_type(),\n        ]);\n        let treeview = TreeView::new_with_model(&model);\n        treeview.set_hexpand(true);\n        treeview.set_vexpand(true);\n\n        Self::create_columns(&treeview);\n\n        let dispatcher = gst_player::PlayerGMainContextSignalDispatcher::new(None);\n        let player = gst_player::Player::new(None,\n        Some(&dispatcher.upcast:: \n        <gst_player::PlayerSignalDispatcher>\n        ()));\n\n        Playlist {\n            current_song: RefCell::new(None),\n            model,\n            player,\n            treeview,\n        }\n    }\n}\n```", "```rs\n    pub fn get_duration(&self) -> ClockTime {\n        self.player.get_duration()\n    }\n\n    pub fn get_current_time(&self) -> ClockTime {\n        self.player.get_position()\n    }\n\n    pub fn is_playing(&self) -> bool {\n        self.player.get_pipeline()\n            .map(|element| element.get_state(gst::CLOCK_TIME_NONE).1 == \n             gst::State::Playing)\n            .unwrap_or(false)\n    }\n```", "```rs\n    pub fn play(&self) -> bool {\n        if self.selected_path() == self.player.get_uri() {\n            self.player.play();\n            return false;\n        }\n        if let Some(path) = self.selected_path() {\n            let uri = format!(\"file://{}\", path);\n            self.player.set_uri(&uri);\n            self.player.play();\n            true\n        } else {\n            false\n        }\n    }\n```", "```rs\nlet playlist = Rc::new(Playlist::new());\n```", "```rs\ngtk::timeout_add(100, move || {\n    let duration = playlist.get_duration();\n    adjustment.set_upper(duration.nanoseconds().unwrap_or(0) as\n    f64);\n    duration_label.set_text(&format!(\"{:.0}\", duration));\n\n    let current_time = playlist.get_current_time();\n    if !playlist.is_playing() {\n        set_image_icon(&play_image, PLAY_ICON);\n    } else {\n        set_image_icon(&play_image, PAUSE_ICON);\n        current_time_label.set_text(&format!(\"{:.0}\", \n         current_time));\n    }\n    adjustment.set_value(current_time.nanoseconds().unwrap_or(0) as f64);\n    Continue(true)\n});\n```", "```rs\nself.toolbar.play_button.connect_clicked(move |_| {\n    if !playlist.is_playing() {\n        if playlist.play() {\n            set_image_icon(&play_image, PAUSE_ICON);\n            set_cover(&cover, &playlist);\n        }\n    } else {\n        playlist.pause();\n        set_image_icon(&play_image, PLAY_ICON);\n    }\n});\n```", "```rs\nself.toolbar.open_button.connect_clicked(move |_| {\n    let file = show_open_dialog(&parent);\n    if let Some(file) = file {\n        if let Some(ext) = file.extension() {\n            match ext.to_str().unwrap() {\n                \"mp3\" | \"ogg\" => playlist.add(&file),\n                \"m3u\" => playlist.load(&file),\n                extension => {\n                    let dialog = MessageDialog::new(Some(&parent), \n                     DialogFlags::empty(), MessageType::Error,\n                      ButtonsType::Ok, &format!(\"Cannot open file \n                       with extension . {}\", extension));\n                    dialog.run();\n                    dialog.destroy();\n                },\n            }\n        }\n    }\n});\n```"]