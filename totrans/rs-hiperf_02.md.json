["```rs\nstruct StringData {\n    data: String,\n}\n\nstruct NumberData {\n    data: i32,\n}\n```", "```rs\nuse std::fmt::Display;\n\ntrait ShowInfo {\n    type Out: Display;\n    fn info(&self) -> Self::Out;\n}\n```", "```rs\nimpl<'sd> ShowInfo for &'sd StringData {\n    type Out = &'sd str;\n    fn info(&self) -> Self::Out {\n        self.data.as_str()\n    }\n}\n\nimpl ShowInfo for NumberData {\n    type Out = i32;\n    fn info(&self) -> Self::Out {\n        self.data\n    }\n}\n```", "```rs\nfn print<I: ShowInfo>(data: I) {\n    println!(\"{}\", data.info());\n}\n```", "```rs\nfn main() {\n    let str_data = StringData {\n        data: \"This is my data\".to_owned(),\n    };\n    let num_data = NumberData { data: 34 };\n\n    print(&str_data);\n    print(num_data);\n}\n```", "```rs\npub trait StateMachine {\n    type Next: MainLogic;\n    fn execute(self) -> Self::Next;\n}\n```", "```rs\npub trait MainLogic {\n    fn main_logic(self);\n}\n```", "```rs\nimpl<S> MainLogic for S\nwhere\n    S: StateMachine,\n{\n    fn main_logic(self) {\n        self.execute().main_logic();\n    }\n}\n```", "```rs\nstruct FirstState;\nstruct LastState;\n\nimpl StateMachine for FirstState {\n    type Next = LastState;\n\n    fn execute(self) -> Self::Next {\n        unimplemented!()\n    }\n}\n\nimpl MainLogic for LastState {\n    fn main_logic(self) {\n        unimplemented!()\n    }\n}\n```", "```rs\nfn is_the_car_in_place() -> bool {\n    unimplemented!()\n}\nfn is_the_bolt_in_place() -> bool {\n    unimplemented!()\n}\nfn move_arm_to_new_door() {\n    unimplemented!();\n}\nfn move_arm_to_car() {\n    unimplemented!()\n}\nfn turn_bolt() {\n    unimplemented!()\n}\nfn grip_door() {\n    unimplemented!()\n}\n```", "```rs\nstruct WaitingCar;\nstruct TakingDoor;\nstruct PlacingDoor;\n```", "```rs\nstruct DoorMachine<S> {\n    state: S,\n}\n```", "```rs\nuse std::time::Duration;\nuse std::thread;\n\nimpl From<DoorMachine<WaitingCar>> for DoorMachine<TakingDoor> {\n    fn from(st: DoorMachine<WaitingCar>) -> DoorMachine<TakingDoor> {\n        while !is_the_car_in_place() {\n            thread::sleep(Duration::from_secs(1));\n        }\n        DoorMachine { state: TakingDoor }\n    }\n}\n```", "```rs\nuse std::time::Duration;\nuse std::thread;\n\nimpl From<DoorMachine<TakingDoor>> for DoorMachine<PlacingDoor> {\n    fn from(st: DoorMachine<TakingDoor>) -> DoorMachine<PlacingDoor> {\n        move_arm_to_new_door();\n        grip_door();\n\n        DoorMachine { state: PlacingDoor }\n    }\n}\n```", "```rs\nuse std::time::Duration;\nuse std::thread;\n\nimpl From<DoorMachine<PlacingDoor>> for DoorMachine<WaitingCar> {\n    fn from(st: DoorMachine<PlacingDoor>) -> DoorMachine<WaitingCar> {\n        move_arm_to_car();\n        while !is_the_bolt_in_place() {\n            turn_bolt();\n        }\n\n        DoorMachine { state: WaitingCar }\n    }\n}\n```", "```rs\n    let beginning_state = DoorMachine { state: WaitingCar };\n    let next_state: DoorMachine<TakingDoor> = beginning_state.into();\n```", "```rs\n    let beginning_state = DoorMachine { state: WaitingCar };\n    let next_state: DoorMachine<TakingDoor> = beginning_state.into();\n\n    // Lots of code\n\n    let last_state: DoorMachine<PlacingDoor> = next_state.into();\n```", "```rs\npub trait PageTable {}\n\npub enum P4 {}\npub enum P3 {}\npub enum P2 {}\npub enum P1 {}\n\nimpl PageTable for P4 {}\nimpl PageTable for P3 {}\nimpl PageTable for P2 {}\nimpl PageTable for P1 {}\n```", "```rs\npub trait HighTable: PageTable {\n    type NextTable: PageTable;\n}\n\nimpl HighTable for P4 {\n    type NextTable = P3;\n}\n\nimpl HighTable for P3 {\n    type NextTable = P2;\n}\n\nimpl HighTable for P2 {\n    type NextTable = P1;\n}\n```", "```rs\n    let opt = Some(123);\n    let non_opt = opt.unwrap_or(some_complex_function());\n```", "```rs\n    let opt = Some(123);\n    let non_opt = opt.unwrap_or_else(some_complex_function);\n```", "```rs\n    let opt = Some(123);\n    let non_opt = opt.unwrap_or_else(|| {\n        even_more_complex_function(get_argument())\n    });\n```", "```rs\n    let mut fruits = vec![\n        \"Orange\", \"Pome\", \"Peach\", \"Banana\", \"Kiwi\", \"Pear\"\n    ];\n    fruits.sort_by(|a, b| a.chars().next().cmp(&b.chars().next()));\n\n    println!(\"{:?}\", fruits);\n```", "```rs\n    let mut fruits = vec![\n        \"Orange\", \"Pome\", \"Peach\", \"Banana\", \"Kiwi\", \"Pear\"\n    ];\n    fruits.sort_unstable_by(|a, b| a.chars().next().cmp(&b.chars().next()));\n\n    println!(\"{:?}\", fruits);\n```", "```rs\nuse std::collections::HashMap;\nuse std::collections::hash_map::RandomState;\n\n// <u8, u8> as an example, just to make the type inference happy.\nlet map: HashMap<u8, u8> = HashMap::with_hasher(RandomState::new());\n\n```", "```rs\nuse std::hash::{BuildHasher, Hasher};\n\n#[derive(Clone)]\nstruct MyHasher {\n    count: u64,\n}\n\nimpl Hasher for MyHasher {\n    fn finish(&self) -> u64 {\n        self.count\n    }\n\n    fn write(&mut self, bytes: &[u8]) {\n        for byte in bytes {\n            self.count = self.count.wrapping_add(*byte as u64);\n        }\n    }\n}\n\nimpl BuildHasher for MyHasher {\n    type Hasher = Self;\n    fn build_hasher(&self) -> Self::Hasher {\n        self.clone()\n    }\n}\n```", "```rs\n    use std::collections::HashMap;\n\n    let mut map = HashMap::with_hasher(MyHasher { count: 12345 });\n    map.insert(\"Hello\", \"World\");\n```", "```rs\nextern crate phf_codegen;\n\nuse std::path::Path;\nuse std::env;\nuse std::fs::File;\nuse std::io::{BufWriter, Write};\n\nfn main() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let path = Path::new(&out_dir).join(\"phf.rs\");\n    let mut file = BufWriter::new(File::create(&path).unwrap());\n\n    let map = [(\"key1\", \"\\\"value1\\\"\"), (\"key2\", \"\\\"value2\\\"\")];\n\n    write!(\n        &mut file,\n        \"static MAP: phf::Map<&'static str, &'static str> =\\n\"\n    ).unwrap();\n\n    let mut phf_map = phf_codegen::Map::new();\n    for &(key, value) in &map {\n        phf_map.entry(key, value);\n    }\n\n    phf_map.build(&mut file).unwrap();\n    write!(&mut file, \";\\n\").unwrap();\n}\n```", "```rs\nextern crate phf;\n\ninclude!(concat!(env!(\"OUT_DIR\"), \"/phf.rs\"));\n\nfn main() {\n    println!(\"{}\", MAP.get(\"key1\").unwrap());\n}\n```"]