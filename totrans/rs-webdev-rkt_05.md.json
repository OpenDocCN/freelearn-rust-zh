["```rs\nuse std::sync::atomic::AtomicU64;\n```", "```rs\n...\n```", "```rs\nstruct VisitorCounter {\n```", "```rs\n    visitor: AtomicU64,\n```", "```rs\n}\n```", "```rs\nfn rocket() -> Rocket<Build> {\n```", "```rs\n    let visitor_counter = VisitorCounter {\n```", "```rs\n        visitor: AtomicU64::new(0),\n```", "```rs\n    };\n```", "```rs\n    rocket::build()\n```", "```rs\n        .manage(visitor_counter)\n```", "```rs\n        .mount(\"/\", routes![user, users, favicon])\n```", "```rs\n        .register(\"/\", catchers![not_found, forbidden])\n```", "```rs\n}\n```", "```rs\n#[get(\"/<param1>\")]\n```", "```rs\nfn handler1(param1: u8, type1: Guard1, type2: Guard2) {}\n```", "```rs\nuse rocket::{Build, Rocket, State};\n```", "```rs\n#[get(\"/user/<uuid>\", rank = 1, format = \"text/plain\")]\n```", "```rs\nfn user<'a>(counter: &State<VisitorCounter>, uuid: &'a str) -> Option<&'a User> {\n```", "```rs\n    counter.visitor.fetch_add(1, Ordering::Relaxed);\n```", "```rs\n    println!(\"The number of visitor is: {}\", counter.\n```", "```rs\n    visitor.load(Ordering::Relaxed));\n```", "```rs\n    USERS.get(uuid)\n```", "```rs\n}\n```", "```rs\nimpl VisitorCounter {\n```", "```rs\n    fn increment_counter(&self) {\n```", "```rs\n        self.visitor.fetch_add(1, Ordering::Relaxed);\n```", "```rs\n        println!(\n```", "```rs\n            \"The number of visitor is: {}\",\n```", "```rs\n            self.visitor.load(Ordering::Relaxed)\n```", "```rs\n        );\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\n...\n```", "```rs\nfn user<'a>(counter: &State<VisitorCounter>, uuid: &'a str) -> Option<&'a User> {\n```", "```rs\n    counter.increment_counter();\n```", "```rs\n    ...\n```", "```rs\n}\n```", "```rs\n...\n```", "```rs\nfn users<'a>(\n```", "```rs\n    counter: &State<VisitorCounter>,\n```", "```rs\n    name_grade: NameGrade,\n```", "```rs\n    filters: Option<Filters>,\n```", "```rs\n) -> Result<NewUser<'a>, Status> {\n```", "```rs\n    counter.increment_counter();\n```", "```rs\n    ...\n```", "```rs\n}\n```", "```rs\n    cargo install sqlx-cli\n    ```", "```rs\n    postgres://username:password@localhost:port/db_name?connect_options\n    ```", "```rs\nmysql://username:password@localhost:port/db_name\n```", "```rs\n    sqlx database create\n    ```", "```rs\n    sqlx migrate add create_users\n    ```", "```rs\n    CREATE TABLE IF NOT EXISTS users\n    (\n        uuid   UUID PRIMARY KEY,\n        name   VARCHAR NOT NULL,\n        age    SMALLINT NOT NULL DEFAULT 0,\n        grade  SMALLINT NOT NULL DEFAULT 0,\n        active BOOL NOT NULL DEFAULT TRUE\n    );\n    CREATE INDEX name_active_idx ON users(name, active);\n    ```", "```rs\n    sqlx migrate run\n    ```", "```rs\n    sqlx = {version = \"0.5.7\", features = [\"postgres\", \"uuid\", \"runtime-tokio-rustls\"]}\n    uuid = \"0.8.2\"\n    ```", "```rs\n    INSERT INTO public.users\n    (uuid, name, age, grade, active)\n    VALUES('3e3dd4ae-3c37-40c6-aa64-7061f284ce28'::uuid, 'John Doe', 18, 1, true);\n    ```", "```rs\n    use sqlx::FromRow;\n    use uuid::Uuid;\n    ...\n    #[derive(Debug, FromRow)]\n    struct User {\n        uuid: Uuid,\n        name: String,\n        age: i16,\n        grade: i16,\n        active: bool,\n    }\n    ```", "```rs\n#[derive(Debug, FromRow)]\n#[sqlx(rename_all = \"camelCase\")]\nstruct User {\n    uuid: Uuid,\n    name: String,\n    age: i16,\n    grade: i16,\n    #[sqlx(rename = \"active\")]\n    present: bool,\n    #[sqlx(default)]\n    not_in_database: String,\n}\n```", "```rs\n[dependencies]\n...\nserde = \"1.0.130\"\n```", "```rs\n    use serde::Deserialize;\n    ...\n    #[derive(Deserialize)]\n    struct Config {\n        database_url: String,\n    }\n    ```", "```rs\n    fn rocket() -> Rocket<Build> {\n        let our_rocket = rocket::build();\n        let config: Config = our_rocket\n            .figment()\n            .extract()\n            .expect(\"Incorrect Rocket.toml \n             configuration\");\n        ...\n        our_rocket\n            .manage(visitor_counter)\n        ...\n    }\n    ```", "```rs\n    use sqlx::postgres::PgPoolOptions;\n    ...\n    async fn rocket() -> Rocket<Build> {\n        ...\n        let config: Config = rocket_frame\n            .figment()\n            .extract()\n            .expect(\"Incorrect Rocket.toml \n            configuration\");\n        let pool = PgPoolOptions::new()\n            .max_connections(5)\n            .connect(&config.database_url)\n            .await\n            .expect(\"Failed to connect to database\");\n        ...\n        rocket_frame\n            .manage(visitor_counter)\n            .manage(pool)\n        ...\n    }\n    ```", "```rs\n    impl<'r> Responder<'r, 'r> for User { ... }\n    struct NewUser(Vec<User>);\n    impl<'r> Responder<'r, 'r> for NewUser { ... }\n    ```", "```rs\n    async fn user(\n        counter: &State<VisitorCounter>,\n        pool: &rocket::State<PgPool>,\n        uuid: &str,\n    ) -> Result<User, Status> {\n        ...\n        let parsed_uuid = Uuid::parse_str(uuid)\n        .map_err(|_| Status::BadRequest)?;\n        let user = sqlx::query_as!(\n            User,\n            \"SELECT * FROM users WHERE uuid = $1\",\n            parsed_uuid\n        )\n        .fetch_one(pool.inner())\n        .await;\n        user.map_err(|_| Status::NotFound)\n    }\n    ```", "```rs\n    async fn users(\n        counter: &State<VisitorCounter>,\n        pool: &rocket::State<PgPool>,\n        name_grade: NameGrade<'_>,\n        filters: Option<Filters>,\n    ) -> Result<NewUser, Status> {…}\n    ```", "```rs\n    ...\n    let mut query_str = String::from(\"SELECT * FROM users WHERE name LIKE $1 AND grade = $2\");\n    if filters.is_some() {\n        query_str.push_str(\" AND age = $3 AND active = \n        $4\");\n    }\n    ```", "```rs\n    ...\n    let mut query = sqlx::query_as::<_, User>(&query_str)\n        .bind(format!(\"%{}%\", &name_grade.name))\n        .bind(name_grade.grade as i16);\n    if let Some(fts) = &filters {\n        query = query.bind(fts.age as i16).bind(fts.\n        active);\n    }\n    let unwrapped_users = query.fetch_all(pool.inner()).await;\n    let users: Vec<User> = unwrapped_users.map_err(|_| Status::InternalServerError)?;\n    ```", "```rs\n    ...\n    if users.is_empty() {\n        Err(Status::NotFound)\n    } else {\n        Ok(NewUser(users))\n    }\n    ```", "```rs\n/* SQLx ping */; rows: 0, elapsed: 944.711µs\nSELECT * FROM users …; rows: 1, elapsed: 11.187ms\nSELECT\n  *\nFROM\n  users\nWHERE\n  uuid = $1\n```", "```rs\n/* SQLx ping */; rows: 0, elapsed: 524.114µs\nSELECT * FROM users …; rows: 1, elapsed: 2.435ms\nSELECT\n  *\nFROM\n  users\nWHERE\n  name LIKE $1\n  AND grade = $2\n```", "```rs\n #[crate::async_trait]\n```", "```rs\npub trait Fairing: Send + Sync + Any + 'static {\n```", "```rs\n    fn info(&self) -> Info;\n```", "```rs\n    async fn on_ignite(&self, rocket: Rocket<Build>) ->\n```", "```rs\n    Result { Ok(rocket) }\n```", "```rs\n    async fn on_liftoff(&self, _rocket: &Rocket<Orbit>) { }\n```", "```rs\n    async fn on_request(&self, _req: &mut Request<'_>, \n```", "```rs\n    _data: &mut Data<'_>) {}\n```", "```rs\n    async fn on_response<'r>(&self, _req: &'r Request<'_>, \n```", "```rs\n    _res: &mut Response<'r>) {}\n```", "```rs\n}\n```", "```rs\n#[launch]\n```", "```rs\nasync fn rocket() -> Rocket<Build> {\n```", "```rs\n    let our_rocket = rocket::build();\n```", "```rs\n    …\n```", "```rs\n    our_rocket\n```", "```rs\n        .manage(visitor_counter)\n```", "```rs\n        .manage(pool)\n```", "```rs\n        .mount(\"/\", routes![user, users, favicon])\n```", "```rs\n        .register(\"/\", catchers![not_found, forbidden])\n```", "```rs\n}\n```", "```rs\npub struct Info {\n```", "```rs\n    pub name: &'static str,\n```", "```rs\n    pub kind: Kind,\n```", "```rs\n}\n```", "```rs\nstruct Something {\n```", "```rs\n    item: u8\n```", "```rs\n}\n```", "```rs\nimpl Something {\n```", "```rs\n    fn new() -> Something {\n```", "```rs\n        Something {\n```", "```rs\n            item: 8,\n```", "```rs\n        }\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\ntrait SuperTrait {\n```", "```rs\n    type Super;\n```", "```rs\n}\n```", "```rs\nstruct Something;\n```", "```rs\nstruct Some;\n```", "```rs\nimpl SuperTrait for Something {\n```", "```rs\n    type Super = Some;\n```", "```rs\n}\n```", "```rs\npub struct Kind(usize);\n```", "```rs\nimpl Kind {\n```", "```rs\n    pub const Ignite: Kind = Kind(1 << 0);\n```", "```rs\n    pub const Liftoff: Kind = Kind(1 << 1);\n```", "```rs\n    pub const Request: Kind = Kind(1 << 2);\n```", "```rs\n    pub const Response: Kind = Kind(1 << 3);\n```", "```rs\n    pub const Singleton: Kind = Kind(1 << 4);\n```", "```rs\n    ...\n```", "```rs\n}\n```", "```rs\nInfo {\n```", "```rs\n    name: \"Request Response Tracker\",\n```", "```rs\n    kind: Kind::Request | Kind::Response,\n```", "```rs\n}\n```", "```rs\nuse rocket::fairing::{self, Fairing, Info, Kind};\n```", "```rs\nuse rocket::fs::{relative, NamedFile};\n```", "```rs\nuse rocket::http::{ContentType, Header, Status};\n```", "```rs\nuse rocket::request::{FromParam, Request};\n```", "```rs\nuse rocket::response::{self, Responder, Response};\n```", "```rs\nuse rocket::{Build, Data, Orbit, Rocket, State};\n```", "```rs\n#[rocket::async_trait]\n```", "```rs\nimpl Fairing for VisitorCounter {\n```", "```rs\n    fn info(&self) -> Info {\n```", "```rs\n        Info {\n```", "```rs\n            name: \"Visitor Counter\",\n```", "```rs\n            kind: Kind::Ignite | Kind::Liftoff | Kind::\n```", "```rs\n            Request,\n```", "```rs\n        }\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nasync fn on_ignite(&self, rocket: Rocket<Build>) -> fairing::Result {\n```", "```rs\n    println!(\"Setting up visitor counter\");\n```", "```rs\n    Ok(rocket)\n```", "```rs\n}\n```", "```rs\nasync fn on_liftoff(&self, _: &Rocket<Orbit>) {\n```", "```rs\n    println!(\"Finish setting up visitor counter\");\n```", "```rs\n}\n```", "```rs\nasync fn on_request(&self, _: &mut Request<'_>, _: &mut Data<'_>) {\n```", "```rs\n    self.increment_counter();\n```", "```rs\n}\n```", "```rs\n> cargo run\n...\nSetting up visitor counter\n Configured for debug.\n...\n Fairings:\n   >> Visitor Counter (ignite, liftoff, request)\n...\nFinish setting up visitor counter\n Rocket has launched from http://127.0.0.1:8000\n```", "```rs\n> curl http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28\n```", "```rs\nThe number of visitor is: 2\n```", "```rs\nuuid = {version = \"0.8.2\", features = [\"v4\"]}\n```", "```rs\nconst X_TRACE_ID: &str = \"X-TRACE-ID\";\n```", "```rs\nstruct XTraceId {}\n```", "```rs\n#[rocket::async_trait]\n```", "```rs\nimpl Fairing for XTraceId {\n```", "```rs\n    fn info(&self) -> Info {\n```", "```rs\n        Info {\n```", "```rs\n            name: \"X-TRACE-ID Injector\",\n```", "```rs\n            kind: Kind::Request | Kind::Response,\n```", "```rs\n        }\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nasync fn on_request(&self, req: &mut Request<'_>, _: &mut Data<'_>) {\n```", "```rs\n    let header = Header::new(X_TRACE_ID, \n```", "```rs\n    Uuid::new_v4().to_hyphenated().to_string());\n```", "```rs\n    req.add_header(header);\n```", "```rs\n}\n```", "```rs\nasync fn on_response<'r>(&self, req: &'r Request<'_>, res: &mut Response<'r>) {\n```", "```rs\n    let header = req.headers().get_one(X_TRACE_ID).\n```", "```rs\n    unwrap();\n```", "```rs\n    res.set_header(Header::new(X_TRACE_ID, header));\n```", "```rs\n}\n```", "```rs\nlet x_trace_id = XTraceId {};\n```", "```rs\nour_rocket\n```", "```rs\n    ...\n```", "```rs\n    .attach(visitor_counter)\n```", "```rs\n    .attach(x_trace_id)\n```", "```rs\n    ...\n```", "```rs\n...\n Fairings:\n   >> X-TRACE-ID Injector (request, response)\n   >> Visitor Counter (ignite, liftoff, request)\n...\n```", "```rs\ncurl -v http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28\n...\n< x-trace-id: 28c0d523-13cc-4132-ab0a-3bb9ae6153a9\n...\n```", "```rs\n    [dependencies]\n    rocket = \"0.5.0-rc.1\"\n    rocket_db_pools = {version = \"0.5.0-rc.1\", features = [\"sqlx_postgres\"]}\n    ...\n    ```", "```rs\n    [debug.databases.main_connection]\n    url = \"postgres://username:password@localhost/rocket\"\n    ```", "```rs\n    use serde::Deserialize;\n    ...\n    use sqlx::postgres::{PgPool, PgPoolOptions};\n    use sqlx::FromRow;\n    ```", "```rs\n    use rocket_db_pools::{\n        sqlx,\n        sqlx::{FromRow, PgPool},\n        Connection, Database,\n    };\n    ```", "```rs\n    #[derive(Database)]\n    #[database(\"main_connection\")]\n    struct DBConnection(PgPool);\n    ```", "```rs\n    let config: Config = our_rocket\n        .figment()\n        .extract()\n        .expect(\"Incorrect Rocket.toml configuration\");\n    let pool = PgPoolOptions::new()\n        .max_connections(5)\n        .connect(&config.database_url)\n        .await\n        .expect(\"Failed to connect to database\");\n    ```", "```rs\n    async fn rocket() -> Rocket<Build> {\n        ...\n        rocket::build()\n            .attach(DBConnection::init())\n            .attach(visitor_counter)\n            ...\n    }\n    ```", "```rs\n    async fn user(mut db: Connection<DBConnection>, uuid: &str) -> Result<User, Status> {\n        ...\n        let user = sqlx::query_as!(User, \"SELECT * FROM \n        users WHERE uuid = $1\", parsed_uuid)\n            .fetch_one(&mut *db)\n            .await;\n        ...\n    }\n    ...\n    #[get(\"/users/<name_grade>?<filters..>\")]\n    async fn users(\n        mut db: Connection<DBConnection>,\n        ...\n    ) -> Result<NewUser, Status> {\n        ...\n        let unwrapped_users = query.fetch_all(&mut \n        *db).await;\n        ...\n    }\n    ```", "```rs\n Fairings:\n   ...\n   >> 'main_connection' Database Pool (ignite)\n```"]