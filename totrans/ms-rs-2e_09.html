<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Metaprogramming with Macros</h1>
                </header>
            
            <article>
                
<p>Metaprogramming is a concept that changes the way you look at instructions and data in a program. It allows you to generate new code by treating instructions like any other piece of data. Many languages have support for metaprogramming, for example, Lisp's macros, C's <kbd>#define</kbd> construct, and Python's metaclasses. Rust is no different and provides many forms of metaprogramming, which we'll explore in this chapter.</p>
<p>In this chapter, we will look at the following topics:</p>
<ul>
<li>What is metaprogramming?</li>
<li>Macros in Rust and their forms</li>
<li>Declarative macros, macro variables, and types</li>
<li>Repeating constructs</li>
<li>Procedural macros</li>
<li>Macro use case</li>
<li>Available macro crates</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is metaprogramming?</h1>
                </header>
            
            <article>
                
<div class="packt_quote">"Lisp isn't a language, it's a building material."</div>
<p class="CDPAlignRight CDPAlign"><span><em>– Alan Kay</em></span></p>
<p>Any program, regardless of the language used, contains two entities: data and instructions that manipulate the data. The usual flow of a program is mostly concerned with manipulating data. The issue with instructions, though, is that once you write them, it's like they've been carved into stone, and so they are non-malleable. It would be more enabling if we could treat instructions as data and generate new instructions using code. Metaprogramming provides exactly that!</p>
<p class="mce-root"/>
<p>It's a programming technique where you can write code that has the ability to generate new code. Depending on the language, it can be approached in two ways: at runtime or at compile time. Runtime metaprogramming is available in dynamic languages such as Python, Javascript, and Lisp. For compiled languages, it's not possible to generate instructions at runtime because these languages perform the ahead of time compilation of programs. However, you have the option of generating code at compile time, which is what C macros provide. Rust also provides compile time code generation capabilities, and these are more capable and sound than C macros.</p>
<p>In many languages, metaprogramming constructs are often denoted by the umbrella term <strong>macros</strong>, which for some languages are a built-in feature. For others, they are provided as a separate compilation phase. In general, a macro takes an arbitrary sequence of code as input and outputs valid code that can be compiled or executed by the language, along with other code. The input to the macro doesn't need to be a valid syntax and you are free to define your own custom syntax for the macro input. Also, how you invoke a macro and the syntax for defining them is different across languages. For instance, C macros works at the preprocessor stage, which reads tags starting with <kbd>#define</kbd> and expands them before forwarding the source file to the compiler. Here, expanding means generating code by substituting inputs that are provided to the macro. Lisp, on the other hand, provides function-like macros that are defined with <kbd>defmacro</kbd> (a macro itself), which takes the name of the macro being created and one or more parameters, and returns new Lisp code. However, C and Lisp macros lack a property that's referred to as hygiene. They are non-hygienic in the sense that they can capture and interfere with code outside the macro upon expansion, which can lead to unexpected behavior and logical errors when the macro is invoked at certain places in the code.</p>
<p>To demonstrate the problem with a lack of hygiene, we'll take the example of a C macro. These macros simply copy/paste code with simple variable substitutions and are not context aware. Macros written in C are not hygienic in the sense that they can refer to variables defined anywhere, as long as those variables are in scope at the macro invocation site. For instance, the following is a macro <kbd>SWITCH</kbd> defined in C that can swap two values, but ignorantly modifies other values in doing so:</p>
<pre>// c_macros.c<br/><br/>#include &lt;stdio.h&gt; <br/><br/>#define SWITCH(a, b) { temp = b; b = a; a = temp; } <br/><br/>int main() { <br/>    int x=1; <br/>    int y=2; <br/>    int temp = 3; <br/><br/>    SWITCH(x, y); <br/>    printf("x is now %d. y is now %d. temp is now %d\n", x, y, temp); <br/>}</pre>
<p>Compiling this with <kbd>gcc c_macros.c -o macro &amp;&amp; ./macro</kbd> gives the following output:</p>
<pre>x is now 2. y is now 1. temp is now 2</pre>
<p>In the preceding code, unless we declare our own <kbd>temp</kbd> variable inside the <kbd>SWITCH</kbd> macro, the original <kbd>temp</kbd> variable in <kbd>main</kbd> is modified by the expansion of the <kbd>SWITCH</kbd> macro. This unhygienic nature makes C macros unsound and brittle, and can easily make a mess unless special precautions are taken, such as using a different name for the <kbd>temp</kbd> variable within the macro.</p>
<p>Rust macros on the other hand are hygienic and also more context aware than just performing simple string substitution and expansion. They are aware of the scope of the variables that have been referenced within the macro and do not shadow any identifiers that have already been declared outside. Consider the following Rust program, which tries to implement the macro we used previously:</p>
<pre>// c_macros_rust.rs<br/><br/>macro_rules! switch {<br/>    ($a:expr, $b:expr) =&gt; {<br/>        temp = $b; $b = $a; $a = temp;<br/>    };<br/>}<br/><br/>fn main() { <br/>    let x = 1; <br/>    let y = 2; <br/>    let temp = 3;<br/>    switch!(x, y);<br/>}</pre>
<p>In the preceding code, we created a macro called <kbd>switch!</kbd> and later invoked that in <kbd>main</kbd> with two values, <kbd>x</kbd> and <kbd>y</kbd>. We'll skip explaining the details in the macro definition, as we will cover them in detail later in this chapter.</p>
<p>However, to our surprise, this doesn't compile and fails with the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e46aaef8-a1c3-4398-8ed3-d837348112f8.png" style="width:29.42em;height:9.92em;"/></p>
<p>From the error message, our <kbd>switch!</kbd> macro doesn't know anything about the <kbd>temp</kbd> variable that's declared in <kbd>main</kbd>. As we can see, Rust macros don't capture variables from their environment as they work differently compared to C macros. Even if it would have, we will be saved from modification as <kbd>temp</kbd> is declared immutable in the preceding program. Neat!</p>
<p>Before we get into writing more macros like these in Rust, it's important to have an idea of when to use a macro-based solution for your problem and when not to!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to use and not use Rust macros</h1>
                </header>
            
            <article>
                
<p>One of the advantages of using macros is that they don't evaluate their arguments eagerly like functions do, which is one of the motivations to use macros other than functions.</p>
<div class="packt_infobox">By eager evaluation, we mean that a function call like <kbd>foo(bar(2))</kbd> will first evaluate <kbd>bar(2)</kbd> and then pass its value to <kbd>foo</kbd>. Contrary to that, this is a lazy evaluation, which is what you see in iterators.</div>
<p>A general <em>rule of thumb</em> is that macros can be used in situations where functions fail to provide the desired solution, where you have code that is quite repetitive, or in cases where you need to inspect the structure of your types and generate code at compile time. Taking examples from real use cases, Rust macros are used in a lot of cases, such as the following:</p>
<ul>
<li>Augmenting the language syntax by creating custom <strong>Domain-Specific Languages</strong> (<strong><span>DSLs</span></strong>)</li>
<li>Writing compile time serialization code, like serde does </li>
<li>Moving computation to compile-time, thereby reducing runtime overhead</li>
<li>Writing boilerplate test code and automating test cases</li>
<li>Providing zero cost logging abstractions such as the log crate</li>
</ul>
<p>At the same time, macros should be used sparingly as they make the code difficult to maintain and reason about, as they work at the meta level and not many developers will be comfortable using them. They make the code harder to read and from a maintainability perspective, readability should always be preferred. Also, heavy use of macros can result in performance penalties due to a lot of duplicate code generation, which affects the CPU instruction cache.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Macros in Rust and their types</h1>
                </header>
            
            <article>
                
<p>Rust macros do their magic of code generation before the program compiles to a binary object file. They take input, known as <strong>token trees</strong>, and are expanded at the end of the second pass of parsing during <strong>Abstract Syntax Tree</strong> (<strong>AST</strong>) construction. These are pieces of jargon from the compiler world and need some explanation, so let's do that. To understand how macros work, we need to be familiar with how source code is processed by the compiler to understand a program. This will help us in understanding how a macro processes its input and the error messages they emit when we use them incorrectly. We'll only cover parts that are relevant to our understanding of macros.</p>
<p>First, the compiler reads the source code byte by byte and groups characters into meaningful chunks, which are called <strong>tokens</strong>. This is done by a component of the compiler that's generally referred to as the <strong>tokenizer</strong>. Therefore, an <kbd>a + 3 * 6</kbd> expression gets converted to <kbd>"a", "+", "3", "*", "6"</kbd>, which is a sequence of tokens. Other tokens can be the <kbd>fn</kbd> keyword, any identifier, braces <kbd>{}</kbd> <kbd>()</kbd>, an assignment operator <kbd>=</kbd>, and so on. These tokens are called <strong>token trees</strong> in macro parlance. There are also tokens trees such as <kbd>"(", ")", "}","{"</kbd>, which can group other tokens. Now, at this stage, the token sequences by themselves don't convey any meaning on how to process and interpret the program. For that, we need a <strong>parser</strong>.</p>
<p>A parser converts this flat stream of tokens into a hierarchical structure that guides the compiler on how to interpret the program. The token trees are passed on to the parser, which constructs an in-memory representation of the program called the Abstract Syntax Tree. For instance, our sequence of tokens, <kbd>a + 3 * 6</kbd>, which is an expression, can be evaluated with the value <kbd>20</kbd> when <kbd>a</kbd> is <kbd>2</kbd>.</p>
<p>However, the compiler doesn't know how to evaluate this expression correctly unless we separate the precedence of operators (that is,<span> </span><kbd>*</kbd> comes before <kbd>+</kbd>) and represent them with a tree structure, as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/5ae0a294-4e3c-4870-a569-9c690d823729.png" style="width:32.83em;height:18.08em;"/></div>
<p class="mce-root"/>
<p>When we have represented the expression as a tree structure in code so that multiplication happens before addition, we can do a post order traversal of this tree to correctly evaluate the expression. So, given that explanation, where does our macro expansion fit here? Rust macros are parsed at the end of the second phase of Abstract Syntax Tree construction, which is a phase where name resolution happens. Name resolution is the stage where variables that are defined in the expression are looked up for their existence in the scope. In the preceding expression, name resolution will happen for the <kbd>a</kbd> variable. Now, if the <kbd>a</kbd> <span>variable </span>in our preceding expression was assigned a value from a macro invocation such as <kbd>let a = foo!(2 + 0);</kbd>, then the parser goes on to expand the macro before proceeding to the name resolution. The name resolution phase catches errors in the program, such as using a variable that is not in scope. However, there are more complex cases than this.</p>
<p>This entails Rust macros being context aware and, depending on what your macro expands into, they can only appear in supported places, as defined in the language's grammar. For example, you cannot write a <kbd>let</kbd> statement at the item level, that is, within a module.</p>
<div class="packt_infobox">Grammar defines valid ways to write programs, just like grammar in a spoken language guides construction of meaningful sentences. For those who are curious, Rust's grammar is defined at <a href="https://doc.rust-lang.org/grammar.html">https://doc.rust-lang.org/grammar.html</a>.</div>
<p>One instance of macros that we've seen several times already is the <kbd>println!</kbd> macro. It is implemented as a macro because it allows Rust to check at compile time that its arguments are valid and that the string interpolation variables that have been passed to it are correct in number. Another advantage of using a macro for printing strings is that it allows us to pass as many arguments to <kbd>println!</kbd> as possible, which would not have been possible if it were implemented as a regular function. This is because Rust does not support variadic arguments for functions. Consider the following example:</p>
<pre>println("The result of 1 + 1 is {}", 1 + 1); <br/>println!("The result of 1 + 1 is {}"); </pre>
<p>As you already know, the second form will fail at compile time because it's missing an argument that matches the format string. This is reported at compile time. In this way, it is far safer than C's <kbd>printf</kbd> function, which can lead to memory vulnerabilities such as the format string attack. Other feature of the <kbd>println!</kbd> macro is that we can customize how we want to print values within strings:</p>
<pre>// print_formatting.rs<br/><br/>use std::collections::HashMap;<br/><br/>fn main() {<br/>    let a = 3669732608;<br/>    println!("{:p}", &amp;a);<br/>    println!("{:x}", a);<br/><br/>    // pretty printing<br/>    let mut map = HashMap::new();<br/>    map.insert("foo", "bar");<br/>    println!("{:#?}", map);<br/>}</pre>
<p>In the preceding code, we can print the memory address and hexadecimal representation of the value stored in <kbd>a</kbd> via <kbd>"{:p}"</kbd> and <kbd>"{:x}"</kbd>, respectively. These are called <strong>format specifiers</strong>. We can also print non-primitive types in more of a JSON-like format with the <kbd>"{:#?}"</kbd> format specifier within <kbd>println!</kbd>. Let's compile and run our preceding program:</p>
<pre>error[E0277]: the trait bound `{integer}: std::fmt::Pointer` is not satisfied<br/> --&gt; print_formatting.rs:7:22<br/>  |<br/>7 |     println!("{:p}", a);<br/>  |                      ^ the trait `std::fmt::Pointer` is not implemented for `{integer}`</pre>
<p>Ok, we have an error. As you may have noticed, in the first <kbd>println!</kbd> macro call, we are trying to print the address of <kbd>a</kbd> using the <kbd>"{:p}"</kbd> specifier, but the variable we mentioned is a number. We need to pass a reference such as <kbd>&amp;a</kbd> to the format specifier. With that change, the preceding program compiles. All of this formatting and checking for proper values for string interpolation happens at compile time, thanks to the implementation of macros as part of the parsing phase.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of macros</h1>
                </header>
            
            <article>
                
<p>There are different forms of macros in Rust. Some allow you to call them like functions, while others allow you to conditionally include code, depending on compile-time conditions. Another class of macros allows you to implement traits on methods at compile time. They can be broadly divided into two forms:</p>
<ul>
<li><strong>Declarative macros:</strong> These are the simplest form of macros. These are created using <kbd>macro_rules!</kbd>, which itself is a macro. They provide the same ergonomics of a calling a function, but are easily distinguished by a <kbd>!</kbd> at the end. They are the go-to approach for writing quick small macros within a project. The syntax for defining them is very similar to how you would write match expressions. They are called <strong>declarative</strong> in the sense that you already have a mini DSL, along with recognized token types and repetition constructs, using which you can declaratively express what code you want to generate. You don't write how you generate the code as that is taken care of by the DSL.</li>
<li><strong>Procedural macros</strong><strong>:</strong> Procedural macros are a more advanced form of macros and give complete control over the manipulation and generation of code. These macros don't come with any DSL support and are procedural in the sense that you have to write how you want the code to be generated or transformed for a given token tree input. The downside is that they are complex to implement and require a bit of understanding of compiler internals and how a program is represented in memory within the compiler. While <kbd>macro_rules!</kbd> can be defined anywhere in your project, procedural macros as of now are required to be created as separate crates with the special attribute of <kbd>proc-macro = true</kbd> in <kbd>Cargo.toml</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating your first macro with macro_rules!</h1>
                </header>
            
            <article>
                
<p>Let's start with declarative macros first by building one using the <kbd>macro_rules!</kbd> macro. Rust already has the <kbd>println!</kbd> macro, which is used to print things to the standard output. However, it doesn't have an equivalent macro for reading input from the standard input. To read from the standard input, you have to write something like the following:</p>
<pre>let mut input = String::new();<br/>io::stdin().read_line(&amp;mut input).unwrap();</pre>
<p>These lines of code can be easily abstracted away with a macro. We'll name our macro <kbd>scanline!</kbd>. Here's the code that shows us how we want to use this macro:</p>
<pre>// first_macro.rs<br/>     <br/>fn main() {<br/>    let mut input = String::new();<br/>    scanline!(input);<br/>    println!("{:?}", input);<br/>}</pre>
<p>We want to be able to create a <kbd>String</kbd> instance and just pass it to <kbd>scanline!</kbd>, which handles all the details of reading from standard input. If we compile the preceding code by running <kbd>rustc first_macro.rs</kbd>, we get the following error:</p>
<pre>error: cannot find macro `scanline!` in this scope<br/> --&gt; first_macro.rs:5:5<br/>  |<br/>5 |     scanline!(input);<br/>  |     ^^^^^^^^<br/><br/>error: aborting due to previous error</pre>
<p><kbd>rustc</kbd> cannot find the <kbd>scanline!</kbd> macro, because we haven't defined it yet, so let's do that:</p>
<pre>// first_macro.rs<br/><br/>use std::io::stdin;<br/>     <br/>// A convenient macro to read input as string into a buffer<br/>macro_rules! scanline {<br/>    ($x:expr) =&gt; ({<br/>        stdin().read_line(&amp;mut $x).unwrap();<br/>        $x.trim();<br/>    });<br/>}</pre>
<p>To create the <kbd>scanline!</kbd> macro, we use the <kbd>macro_rules!</kbd> macro, followed by the macro name <kbd>scanline!</kbd>, followed by a pair of braces. Within the braces, we have things that look similar to match arms. These are called <strong>matching rules</strong>. Every matching rule consists of three parts. The first is the pattern matcher, that is, the <kbd>($x:expr)</kbd> part, followed by a <kbd>=&gt;</kbd>, and then the code generation block, which can be delimited either with <kbd>()</kbd>, <kbd>{}</kbd>, or even <kbd>[]</kbd>. A matching rule has to end with a semicolon when there is more than one rule to match.</p>
<p>In the preceding code, the notation on the left, <kbd>($x:expr)</kbd>, within parentheses is the rules, where <kbd>$x</kbd> is a token tree variable that needs to have a type specified after the colon <kbd>:</kbd>, which is an <kbd>expr</kbd> token tree type. Their syntax is similar to how we specify parameters in functions. When we invoke the <kbd>scanline!</kbd> macro with any token sequence as input, it gets captured in <kbd>$x</kbd> and is referred to by the same variable within the code generation block on the right. The <kbd>expr</kbd> token type means that this macro can only accept things that are expressions. We'll cover other kinds of token types that are accepted by <kbd>macro_rules!</kbd> in a moment. In the code generation block, we have multi-line code to generate, so we have a pair of braces, which are there to account for multi-line expressions. The matching rule ends with a semicolon. We can also omit braces if we have a single line of code that needs to be generated. The generated code we want is as follows:</p>
<pre>io::stdin().read_line(&amp;mut $x).unwrap();</pre>
<p>Notice that <kbd>read_line</kbd> accepts something that doesn't look like a proper mutable reference to some identifier, that is, it's a <kbd>&amp;mut $x</kbd> . The <kbd>$x</kbd> gets substituted with an actual expression that we pass to our macro on invocation. That's it; we just wrote our first macro! The complete code is as follows:</p>
<pre>// first_macro.rs<br/>     <br/>use std::io;<br/>     <br/>// A convenient macro to read input as string into a buffer<br/>macro_rules! scanline {<br/>    ($x:expr) =&gt; ({<br/>        io::stdin().read_line(&amp;mut $x).unwrap();<br/>    });<br/>}<br/><br/>fn main() {<br/>    let mut input = String::new();<br/>    scanline!(input);<br/>    println!("I read: {:?}", input);<br/>}</pre>
<p>In <kbd>main</kbd>, we first create our <kbd>input</kbd> string, which will store our input from the user. Next, our <kbd>scanline!</kbd> macro is invoked where we pass the <kbd>input</kbd> variable. Within this macro, this is then referred to as <kbd>$x</kbd>, as we saw in the preceding definition. With the invocation of <kbd>scanline</kbd>, when the compiler sees the invocation, it replaces that with the following:</p>
<pre>io::stdin().read_line(&amp;mut input).unwrap();</pre>
<p>Here's the output on running the preceding code with an input string of <kbd>Alice</kbd> from the standard input:</p>
<pre>$ Alice<br/>I read: "Alice\n"</pre>
<p>Following code generation, the compiler also checks whether the generated code makes any sense. For example, if we were to invoke <kbd>scanline!</kbd> with some other item that is not accounted for in the matching rules (say, passing an <kbd>fn</kbd> keyword, such as <kbd>scanline!(fn)</kbd>), we would get the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/90c97a40-a22c-4879-b9f1-02275ad3edbb.png" style="width:30.00em;height:9.33em;"/></p>
<p>Also, even if we pass an expression (say, <kbd>2</kbd>), which is valid to pass (as it's also an <kbd>expr</kbd> ) to this macro but doesn't make sense in this context, Rust will catch this and report as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e7617a02-277a-4ed8-88d1-050170cb1e96.png"/></p>
<p>This is neat! Now, we can also add multiple matching rules to our macro. So, let's add an empty rule that covers the case where we just want <kbd>scanline!</kbd> to allocate the <kbd>String</kbd> for us, read from <kbd>stdin</kbd>, and return the string back. To add a new rule, we modify the code like so:</p>
<pre>// first_macro.rs<br/><br/>macro_rules! scanline {<br/>    ($x:expr) =&gt; ({<br/>        io::stdin().read_line(&amp;mut $x).unwrap();<br/>    });<br/>    () =&gt; ({<br/>        let mut s = String::new();<br/>        stdin().read_line(&amp;mut s).unwrap();<br/>        s<br/>    });<br/>}</pre>
<p>We added an empty match rule, <kbd>() =&gt; {}</kbd>. Within the braces, we generate a bunch of code where we first create a <kbd>String</kbd> instance in <kbd>s</kbd>, call <kbd>read_line</kbd>, and pass <kbd>&amp;mut s</kbd>. Finally, we return <kbd>s</kbd> to the caller. Now, we can call our <kbd>scanline!</kbd> without a pre-allocated <kbd>String</kbd> buffer:</p>
<pre>// first_macro.rs<br/><br/>fn main() {<br/>    let mut input = String::new();<br/>    scanline!(input);<br/>    println!("Hi {}",input);<br/>    let a = scanline!();<br/>    println!("Hi {}", a);<br/>}</pre>
<p>It's also important to note that we cannot invoke this macro anywhere outside functions. For instance, the <kbd>scanline!</kbd> invocation at the root of a module will fail, as it is invalid to write a <kbd>let</kbd> statement within a <kbd>mod {}</kbd> declaration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Built-in macros in the standard library</h1>
                </header>
            
            <article>
                
<p>Apart from <kbd>println!</kbd>, there are other useful macros in the standard library that are implemented using the <kbd>macro_rules!</kbd> macro. Knowing about them will help us appreciate the places and situations where using a macro is a cleaner solution, while not sacrificing readability.</p>
<p>Some of these macros are as follows:</p>
<ul>
<li><kbd>dbg!</kbd>: This allows you to print the value of expressions with their values. This macro moves whatever is passed to it, so if you only want to give read access to their types, you need to pass a reference to this macro instead. It's quite handy as a tracing macro for expressions during runtime.</li>
<li><kbd>compile_error!</kbd><span>: This macro can be used to report an error from code at compile time. This is a handy macro to use when you are building your own macro and want to report any syntactic or semantic errors to the user.</span></li>
<li><kbd>concat!</kbd><span>: This macro can be used to concatenate any number of literals passed to it and returns the concatenated literals as a</span> <kbd>&amp;'static str</kbd><span>.</span></li>
<li><kbd>env!</kbd><span>: This inspects an environment variable at compile time. In a lot of languages, accessing values from the environment variable is mostly done at runtime. In Rust, by using this macro, you can resolve environment variables at compile time. Note that this method panics when it cannot find the variable that's defined, so a safe version of this is the </span><kbd>option_env!</kbd> <span>macro.</span></li>
<li><kbd>eprint!</kbd> <span>and</span> <kbd>eprintln!</kbd><span>: This is similar to</span> <kbd>println!</kbd><span>, but outputs messages to the standard error stream.</span></li>
<li><kbd>include_bytes!</kbd><span>: This macro can be used as a quick way to read files as an array of bytes, such as </span><kbd>&amp;'static [u8; N]</kbd><span>. The file path given to it is resolved relative to the current file in which this macro is invoked.</span></li>
<li><kbd>stringify!</kbd><span>: This macro is useful if you want to get a literal translation of a type or a token as a string. We'll use this when we write our own procedural macro.</span></li>
</ul>
<p>If you want to explore the full set of macros that are available in the standard library, they can be found at <a href="https://doc.rust-lang.org/std/#macros">https://doc.rust-lang.org/std/#macros</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">macro_rules! token types</h1>
                </header>
            
            <article>
                
<p>Before we build more complex macros, it's important to become familiar with the valid inputs that <kbd>macro_rules!</kbd> can take. Since <kbd>macro_rules!</kbd> work at the syntactic level, it needs to provide users, a handle to these syntactic elements, and distinguish what can and cannot be included within a macro and how we can interact with them.</p>
<p class="mce-root"/>
<p>The following are some important token tree types that you can pass into a macro as input:</p>
<ul>
<li><kbd>block</kbd>: This is a sequence of statements. We have already used <kbd>block</kbd> in the debugging example. It matches any sequence of statements, delimited by braces, such as what we were using before:</li>
</ul>
<pre style="padding-left: 60px">{ silly; things; } </pre>
<p>This block includes the statements <kbd>silly</kbd> and <kbd>things</kbd>.</p>
<ul>
<li><kbd>expr</kbd><strong>:</strong> This matches any expression, for example:
<ul>
<li><kbd>1</kbd></li>
<li><kbd>x + 1</kbd></li>
<li><kbd>if x == 4 { 1 } else { 2 }</kbd></li>
</ul>
</li>
<li><kbd>ident</kbd>: This matches an identifier. Identifiers are any unicode strings that are not keywords (such as <kbd>if</kbd> or <kbd>let</kbd>). As an exception, the underscore character alone is not an identifier in Rust. Examples of identifiers are as follows:
<ul>
<li><kbd>x</kbd></li>
<li><kbd>long_identifier</kbd></li>
<li><kbd>SomeSortOfAStructType</kbd></li>
</ul>
</li>
<li><kbd>item</kbd>: This matches an item. Module-level things are idenitified as items<strong>.</strong> These include functions, use declarations, type definitions, and so on. Here are some examples:
<ul>
<li><kbd>use std::io;</kbd></li>
<li><kbd>fn main() { println!("hello") }</kbd></li>
<li><kbd>const X: usize = 8;</kbd></li>
</ul>
</li>
</ul>
<p>These do not have to be one-liners, of course. The <kbd>main</kbd> function could be a single item, even if it spanned several lines.</p>
<ul>
<li><kbd>meta</kbd><strong>:</strong> A <kbd>meta</kbd> item. The parameters inside attributes are called meta items, which are captured by <kbd>meta</kbd>. The attributes themselves look as follows:
<ul>
<li><kbd>#![foo]</kbd></li>
<li><kbd>#[baz]</kbd></li>
<li><kbd>#[foo(bar)]</kbd></li>
<li><kbd>#[foo(bar="baz")]</kbd></li>
<li>Meta items are the things that are found inside brackets. So, for each of the preceding attributes, the corresponding meta items are as follows:
<ul>
<li><kbd>foo</kbd></li>
<li><kbd>baz</kbd></li>
<li><kbd>foo(baz)</kbd></li>
<li><kbd>foo(bar="baz")</kbd></li>
</ul>
</li>
</ul>
</li>
<li><kbd>pat</kbd><strong>:</strong> This is a pattern. Match expressions have patterns on the left-hand side of each match, which <kbd>pat</kbd> captures. Here are some examples:
<ul>
<li><kbd>1</kbd></li>
<li><kbd>"x"</kbd></li>
<li><kbd>t</kbd></li>
<li><kbd>*t</kbd></li>
<li><kbd>Some(t)</kbd></li>
<li><kbd>1 | 2 | 3</kbd></li>
<li><kbd>1 ... 3</kbd></li>
<li><kbd>_</kbd></li>
</ul>
</li>
<li><kbd>path</kbd><strong>:</strong> It matches a qualified name<strong>.</strong> Paths are qualified names, that is, names with a namespace attached to them. They're quite similar to identifiers, except that they allow the double colon in their names because they signify paths. Here are some examples:
<ul>
<li><kbd>foo</kbd></li>
<li><kbd>foo::bar</kbd></li>
<li><kbd>Foo</kbd></li>
<li><kbd>Foo::Bar::baz</kbd></li>
</ul>
</li>
</ul>
<p>This is useful in cases where you need to capture the path of some type so that you can use it later in code generation, such as when aliasing complex types with paths.</p>
<ul>
<li><kbd>stmt</kbd><strong>:</strong> This is a statement. Statements are like expressions, except that more patterns are accepted by <kbd>stmt</kbd>. The following are some examples of this:
<ul>
<li><kbd>let x = 1</kbd></li>
<li><kbd>1</kbd></li>
<li><kbd>foo</kbd></li>
<li><kbd>1+2</kbd></li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<p>In contrast to the first example, <kbd>let x = 1</kbd> wouldn't be accepted by <kbd>expr.</kbd></p>
<ul>
<li><kbd>tt</kbd><strong>:</strong> This is a token tree, which is a sequence of other tokens. The <kbd>tt</kbd> keyword captures a single token tree. A token tree is either a single token (such as <kbd>1</kbd>, <kbd>+</kbd>, or <kbd>"foo bar"</kbd>) or several tokens surrounded by any of the braces, <kbd>()</kbd>, <kbd>[]</kbd>, or <kbd>{}</kbd>. The following are some examples:
<ul>
<li><kbd>foo</kbd></li>
<li><kbd>{ bar; if x == 2 { 3 } else { 4 }; baz }</kbd></li>
<li><kbd>{ bar; fi x == 2 ( 3 ] ulse ) 4 {; baz }</kbd></li>
</ul>
</li>
</ul>
<p>As you can see, the insides of the token tree do not have to make semantic sense; they just have to be a sequence of tokens. Specifically, what does not match this are two or more tokens not enclosed in braces (such as <kbd>1 + 2</kbd>). This is the most general sequence of code or tokens <kbd>macro_rules!</kbd> can capture.</p>
<ul>
<li><kbd>ty</kbd>: This is a Rust type. The <kbd>ty</kbd> keyword captures things that look like types. Here are some examples:
<ul>
<li><kbd>u32</kbd></li>
<li><kbd>u33</kbd></li>
<li><kbd>String</kbd></li>
</ul>
</li>
</ul>
<p>No semantic checking that the type is actually a type is done in the macro expansion phase, so <kbd>"u33"</kbd> is accepted just as well as <kbd>"u32"</kbd>. However, once the code gets generated and goes to the semantic analysis phase, the type is checked, giving an error message of <kbd>error: expected type, found `u33`</kbd>. This is used when you are generating code to create a function or implementing methods of a trait on a type.</p>
<ul>
<li><kbd>vis</kbd>: This represents a visibility modifier. This captures visibility modifiers <kbd>pub</kbd>, <kbd>pub(crate)</kbd>, and so on. This is helpful when you are generating module-level code and need to capture privacy modifiers in code fragments that have been passed to the macro.</li>
<li><kbd>lifetime</kbd>: Identifies a lifetime such as <kbd>'a</kbd>, <kbd>'ctx</kbd>, <kbd>'foo</kbd>, and so on.</li>
<li><kbd>literal</kbd>: A literal that can be any token, like a string literal such as <kbd>"foo"</kbd> or an identifier such as <kbd>bar</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Repetitions in macros</h1>
                </header>
            
            <article>
                
<p>Apart from token tree types, we also need a way to repeatedly generate certain parts of our code. One of the practical examples from the standard library is the <kbd>vec![]</kbd> macro, which relies on repetition to give an illusion of variadic arguments, and allows you to create Vecs in any of the following manners:</p>
<pre>vec![1, 2, 3];<br/>vec![9, 8, 7, 6, 5, 4];</pre>
<p>Let's see how <kbd>vec!</kbd> does this. Here's vec's <kbd>macro_rules!</kbd> definition from the standard library:</p>
<pre>macro_rules! vec {<br/>    ($elem:expr; $n:expr) =&gt; (<br/>        $crate::vec::from_elem($elem, $n)<br/>    );<br/>    ($($x:expr),*) =&gt; (<br/>        &lt;[_]&gt;::into_vec(box [$($x),*])<br/>    );<br/>    ($($x:expr,)*) =&gt; (vec![$($x),*])<br/>}</pre>
<p>By ignoring the details to the right of <kbd>=&gt;</kbd> and focusing on the last two matching rules on the left-hand side, we can see something new in these rules:</p>
<pre>($($x:expr),*)<br/>($($x:expr,)*)</pre>
<p>These are repeating rules. The repeating pattern rule follows:</p>
<ul>
<li> <strong>pattern</strong>: <kbd>$($var:type)*</kbd>. Notice the <kbd>$()*</kbd>. For the sake of referring to them, we'll call them <strong>repeaters</strong>. Also, let's denote the inner <kbd>($x:expr)</kbd> as <kbd>X</kbd>. Repeaters come in three forms:
<ul>
<li><kbd>*</kbd>, meaning the repetition needs to happen zero or more times</li>
<li><kbd>+</kbd>, meaning the repetition needs to happen at least one or more times</li>
<li><kbd>?</kbd>, meaning the token can repeat once at most</li>
</ul>
</li>
</ul>
<p>Repeaters can also include extra literal characters that can be part of the repetition. In the case of <kbd>vec!</kbd>, there is the comma character, which we need to support to distinguish each element in <kbd>Vec</kbd> in the macro invocation.</p>
<p>In the first matching rule, the comma character is after <kbd>X</kbd>. This allows for expressions such as <kbd>vec![1, 2, 3,]</kbd>.</p>
<p>The second matching rule has the comma inside <kbd>X</kbd> after the elements. This is a typical case and will match sequences such as <kbd>1, 2, 3</kbd>. We needed two rules here because the first rule cannot account for cases such as where we don't have the trailing comma, which is the common case. Also, the patterns in <kbd>vec!</kbd> use <kbd>*</kbd>, which implies that <kbd>vec![]</kbd> is also an allowed invocation of the macro. With <kbd>+</kbd>, it wouldn't be.</p>
<p>Now, let's look at how the captured repetition rule is forwarded on the right-hand side in the code generation block. In the second matching rule, the <kbd>vec!</kbd> macro just forwards them into a <kbd>Box</kbd> type using an identical syntax:</p>
<pre>($($x:expr),*) =&gt; (&lt;[_]&gt;::into_vec(box [$($x),*])); </pre>
<p>The only difference we can see between the token tree variable declaration on the left-hand side and the usage on the right-hand side is that the right-hand side does not include the type (<kbd>expr</kbd>) of the token variable. The third matching rule just piggybacks on the second rule's code generation block and calls <kbd>vec![$($x),*]</kbd>, thus changing the comma placement and calling it again. This means that we can also call a macro within a macro, which is a really powerful feature. All of this can get pretty meta-level and you should aim for simpler maintainable macros as much as possible.</p>
<p>Now, let's take a look at how to build a macro that uses repetitions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A more involved macro – writing a DSL for HashMap initialization</h1>
                </header>
            
            <article>
                
<p>Armed with the knowledge of repetitions and token tree types, let's build something practical using repetitions in <kbd>macro_rules!</kbd>. In this section, we'll build a crate that exposes a macro that allows you to create HashMaps such as the following:</p>
<pre>let my_map = map! {<br/>    1 =&gt; 2,<br/>    2 =&gt; 3<br/>};</pre>
<p>This is more concise and readable compared to manually calling <kbd>HashMap::new()</kbd>, followed by one or more <kbd>insert</kbd> calls. Let's  create a new <kbd>cargo</kbd> project by running <kbd>cargo new macro_map --lib</kbd> with the initial block for <kbd>macro_rules!</kbd>:</p>
<pre>// macro_map/lib.rs<br/><br/>#[macro_export]<br/>macro_rules! map {<br/>    // todo<br/>}</pre>
<p>Since we want the users to use our macros, we need to add a <kbd>#[macro_export]</kbd> attribute on this macro definition. Macros are private by default in a module, which is similar to other items. We'll call our macro <kbd>map!</kbd> and since we are building our own syntax to initialize HashMap, we'll go with the <kbd>k =&gt; v</kbd> syntax, where <kbd>k</kbd> is the key and <kbd>v</kbd> is the value in our HashMap. Here's our implementation within <kbd>map! {}</kbd>:</p>
<pre>macro_rules! map {<br/>    ( $( $k:expr =&gt; $v:expr ),* ) =&gt; {<br/>        {<br/>            let mut map = ::std::collections::HashMap::new();<br/>            $(<br/>                map.insert($k, $v);<br/>            )*<br/>            map<br/>        }<br/>    };<br/>}</pre>
<p>Let's understand the matching rule here. First, we'll examine the inner part, which is <kbd>( $k:expr =&gt; $v:expr )</kbd>. Let's denote this part of the rule as <kbd>Y</kbd>. So, <kbd>Y</kbd> captures our key <kbd>k</kbd> and value <kbd>v</kbd> literals as <kbd>expr</kbd> with a <kbd>=&gt;</kbd> in between them. Surrounding <kbd>Y</kbd>, we have <kbd>($(Y),*)</kbd>, which denotes the repetition of <kbd>Y</kbd> zero or more times, delimited by a comma. On the right of the matching rule within braces, we first create a <kbd>HashMap</kbd> instance. Then, we write the repeaters <kbd>$()*</kbd>, which have our <kbd>map.insert($k, $v)</kbd> code fragment within them, which will be repeated the same number of times as in our macro input.</p>
<p>Let's quickly write a test for that:</p>
<pre>// macro_map/lib.rs<br/><br/>#[cfg(test)]<br/>mod tests {<br/>    #[test]<br/>    fn test_map_macro() {<br/>        let a = map! {<br/>            "1" =&gt; 1,<br/>            "2" =&gt; 2<br/>        };<br/><br/>        assert_eq!(a["1"], 1);<br/>        assert_eq!(a["2"], 2);<br/>    }<br/>}</pre>
<p>By running a cargo test, we get the following output:</p>
<pre>running 1 test<br/>test tests::test_map_macro ... ok</pre>
<p>Nice! Our test passes and we can now initialize HashMaps in a convenient way using our shiny new <kbd>map!</kbd> macro!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Macro use case – writing tests</h1>
                </header>
            
            <article>
                
<p>Macros are used quite a lot when writing test cases for unit tests. Let's say you were writing a HTTP client library and you would like to test your client on various HTTP verbs such as <kbd>GET</kbd> or <kbd>POST</kbd> and on a variety of different URLs. The usual way you would write your tests is to create functions for each type of request and the URL. However, there's a better way to do this. Using macros, you can cut down your testing time by many folds by building a small DSL to perform the tests, which is readable and can also be type checked at compiled time. To demonstrate this, let's create a new crate by running <kbd>cargo new http_tester --lib</kbd>, which contains our macro definition. This macro implements a small language that's designed for describing simple HTTP <kbd>GET</kbd>/<kbd>POST</kbd> tests to a URL. Here's a sample of what the language looks like:</p>
<pre>http://duckduckgo.com GET =&gt; 200<br/>http://httpbin.org/post POST =&gt; 200, "key" =&gt; "value"</pre>
<p class="mce-root"/>
<p>The first line makes a <kbd>GET</kbd> request to <kbd>duckduckgo.com</kbd>, and expects a return code of <kbd>200</kbd> (<kbd>Status Ok</kbd>). The second one makes a <kbd>POST</kbd> request to <kbd>httpbin.org</kbd>, along with form parameters <kbd>"key"="value"</kbd> with a custom syntax. It also expects a return code of <kbd>200</kbd>. This is very simplistic but sufficient for demonstration purposes.</p>
<p>We'll assume that we already have our library implemented and will use a HTTP request library called <kbd>reqwest</kbd>. We'll add a dependency on <kbd>reqwest</kbd> in our <kbd>Cargo.toml</kbd> file:</p>
<pre># http_tester/Cargo.toml<br/><br/>[dependencies]<br/>reqwest = "0.9.5"</pre>
<p>Here's <kbd>lib.rs</kbd>:</p>
<pre>// http_tester/src/lib.rs<br/><br/>#[macro_export]<br/>macro_rules! http_test { <br/>    ($url:tt GET =&gt; $code:expr) =&gt; { <br/>        let request = reqwest::get($url).unwrap(); <br/>        println!("Testing GET {} =&gt; {}", $url, $code);<br/>        assert_eq!(request.status().as_u16(), $code); <br/>    }; <br/>    ($url:tt POST =&gt; $code:expr, $($k:expr =&gt; $v:expr),*) =&gt; {<br/>        let params = [$(($k, $v),)*];<br/>        let client = reqwest::Client::new();<br/>        let res = client.post($url)<br/>            .form(&amp;params)<br/>            .send().unwrap();<br/>        println!("Testing POST {} =&gt; {}", $url, $code); <br/>        assert_eq!(res.status().as_u16(), $code);<br/>    };<br/>}<br/><br/>#[cfg(test)]<br/>mod tests {<br/>    #[test]<br/>    fn test_http_verbs() {<br/>        http_test!("http://duckduckgo.com" GET =&gt; 200);<br/>        http_test!("http://httpbin.org/post" POST =&gt; 200, "hello" =&gt; "world", "foo" =&gt; "bar");<br/>    }<br/>}</pre>
<p>Within the macro definition, we just match on the rules, which is where <kbd>GET</kbd> and <kbd>POST</kbd> are treated as literal tokens. Within the arms, we create our request client and assert on the status code that's returned by the input, which is provided to the macro. The POST test case also has a custom syntax for providing query parameters such as <kbd>key =&gt; value</kbd>, which is collected as an array in the <kbd>params</kbd> variable. This is then passed to the <kbd>form</kbd> method of the <kbd>reqwest::post</kbd> builder method. We'll explore the request library more when we get to <a href="ea972b20-1dc0-46d2-a0b8-d4186b0fe2c7.xhtml">Chapter 13</a>, <em>Building Web Applications in Rust</em>.</p>
<p>Let's run <kbd>cargo test</kbd> and see the output:</p>
<pre>running 1 test<br/>test tests::test_http_verbs ... ok</pre>
<p>Take a moment to think about what the benefit of using a macro here is. This could be implemented as a <kbd>#[test]</kbd> annotated function call as well, but the macro has a few benefits, even in this basic form. One benefit is that the HTTP verb is checked at compile time and our tests are now more declarative. If we try to invoke the macro with a test case that is not accounted for (say, HTTP <kbd>DELETE</kbd>), we'll get the following error:</p>
<pre>error: no rules expected the token `DELETE`</pre>
<p>Apart from using them for enumerating tests cases, macros are also used to generate Rust code based on some outside environmental state (such as database tables, time and date, and so on). They can be used to decorate structures with custom attributes, generating arbitrary code for them at compile time, or to create new linter plugins for making additional static analysis that the Rust compiler itself does not support. A great example is the clippy lint tool, which we've used already. Macros are also used to generate code that invokes native C libraries. We'll see how that happens when we get to <a href="9e9ce701-5f35-4351-b76b-a5f2bd541059.xhtml">Chapter 10</a>, <em>Unsafe Rust and Foreign Function Interfaces</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>If you are already finding macros empowering, here are some exercises for you to try so that you can tinker with macros some more:</p>
<ol>
<li>Write a macro that accepts the following language:</li>
</ol>
<pre>        language = HELLO recipient;<br/>        recipient = &lt;String&gt;;</pre>
<p style="padding-left: 60px">For instance, the following strings would be acceptable in this language:</p>
<pre>        HELLO world!<br/>        HELLO Rustaceans!</pre>
<p style="padding-left: 60px">Make the macro generate code that outputs a greeting that's directed to the recipient.</p>
<ol start="2">
<li>Write a macro that takes an arbitrary number of elements and outputs an unordered HTML list in a literal string, for instance, <kbd>html_list!([1, 2]) =&gt; &lt;ul&gt;&lt;li&gt;1/&lt;li&gt;&lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Procedural macros</h1>
                </header>
            
            <article>
                
<p>Declarative macros can become tedious to read and maintain when your code generation logic becomes complex, as you need to write your logic with its own DSL to manipulate tokens. There are better, more flexible ways than using <kbd>macro_rules!</kbd>. For complex problems, you can leverage procedural macros as they are better suited to writing something non-trivial. They are suitable for cases where you need full control of code generation.</p>
<p>These macros are implemented as functions. These functions receive the macro input as a <kbd>TokenStream</kbd> type and return the generated code as a <kbd>TokenStream</kbd> after undergoing any transformation at compile time. To mark a function as a procedural macro, we need to annotate it with the <kbd>#[proc_macro]</kbd> attribute. At the time of writing this book, procedural macros come in three forms, which are categorized by how they are invoked:</p>
<ul>
<li><strong>Function-like procedural macros:</strong> These use <kbd>#[proc_macro]</kbd> attribute on functions. The <kbd>lazy_static!</kbd> macro from the <kbd>lazy_static</kbd> crate uses function-like macros.</li>
<li><strong>Attribute-like procedural macros:</strong> These use <kbd>#[proc_macro_attribute]</kbd> attribute on functions. The <kbd>#[wasm-bindgen]</kbd> attribute in the <kbd>wasm-bindgen</kbd> crate uses this form of macro.</li>
<li><strong>Derive procedural macros:</strong> These use <kbd>#[proc_macro_derive]</kbd>. These are the most frequently implemented macros in the majority of Rust crates, such as <kbd>serde</kbd>. They are also known as <strong>derive macros</strong> or <strong>macros 1.1</strong> due to the name of the RFC that introduced them.</li>
</ul>
<p>At the time of writing this book, the procedural macro API is very limited on what can be done with a <kbd>TokenStream</kbd>, so we need to use third-party crates such as <kbd>syn</kbd> and <kbd>quote</kbd> to parse the input as a Rust code data structure, which can then be analyzed according to your needs for code generation. Also, procedural macros need to be created as a separate crate with the special crate attribute of <kbd>proc-macro = true</kbd>, which is specified in <kbd>Cargo.toml</kbd>. To use the macro, we can depend on the macro in the same way as other crates by specifying it under dependencies in <kbd>Cargo.toml</kbd> and importing the macro with <kbd>use</kbd> statements.</p>
<p>Among all three forms, derive macros are the most widely used form of procedural macros. We'll take a deep dive into them next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Derive macros</h1>
                </header>
            
            <article>
                
<p>We already saw that we can write <kbd>#[derive(Copy, Debug)]</kbd> on any struct, enum, or union type to get the <kbd>Copy</kbd> and <kbd>Debug</kbd> traits implemented for it, but this auto-derive feature is limited only to a few built-in traits in the compiler. With derive macros or macros 1.1, you get the ability to derive your own custom trait on any struct or enum or union type, thereby reducing the amount of boilerplate code that you would have written by hand. This may seem like a niche use case, but it is the most used procedural macro form, which high performance crates such as <kbd>serde</kbd> and <kbd>diesel</kbd> use. The derive macros only apply to data types such as structs, enums, or unions. Creating a custom derive macro for implementing a trait on a type requires the following steps:</p>
<ol>
<li>First, you need your type and the trait that you want to implement on the type. These can come from any crate, either locally defined or from a third party, provided that one of them has to be defined by you, because of the orphan rule.</li>
<li>Next, we need to create a new crate with the <kbd>proc-macro</kbd> attribute set to <kbd>true</kbd> in <kbd>Cargo.toml</kbd>. This marks the crate as a procedural macro crate. This is done because procedural macros need to live in their own crate, as per the current implementation. This separation as a crate might change in the future, though.</li>
<li>Then, within this crate, we need to create a function that's annotated with the <kbd>proc_macro_derive</kbd> attribute. To the <kbd>proc_macro_derive</kbd> attribute, we pass in the trait name <kbd>Foo</kbd> as an argument. This function is what will get called when we write <kbd>#[derive(Foo)]</kbd> on any <kbd>struct</kbd>, <kbd>enum</kbd>, or <kbd>union</kbd>.</li>
</ol>
<div class="packt_tip">Only functions that have the <kbd>proc_macro_derive</kbd> attribute are allowed to be exported from this crate.</div>
<p>However, all of this is a bit vague until we see it in real code. So, let's build our own derive macro crate. The macro that we are going to build will be able to convert any given struct to a dynamic map of key values, such as <kbd>BTreeMap&lt;String, String&gt;</kbd>. The choice of <kbd>BtreeMaps</kbd> is just to have a sorted iteration on the fields, which is not the case with <kbd>HashMap</kbd>, though you can use hashmaps too.</p>
<p>We'll also make use of two crates, <kbd>syn</kbd> and <kbd>quote</kbd>, which will allow us to parse our code into a convenient data structure that we can examine and manipulate. We'll build three crates for this project. First, we'll create a binary crate by running <kbd>cargo new into_map_demo</kbd>, which uses our library crate and the derive macro crate. The following are the dependencies in our <kbd>Cargo.toml</kbd> file:</p>
<pre># into_map_demo/Cargo.toml<br/><br/>[dependencies]<br/>into_map = { path = "into_map" }<br/>into_map_derive = { path = "into_map_derive" }</pre>
<p>The preceding <kbd>into_map</kbd> and <kbd>into_map_derive</kbd> crates are specified as local to this crate as path dependencies. However, we don't have them yet, so let's create them in the same directory by running the following commands:</p>
<ul>
<li><kbd>cargo new into_map</kbd>: This crate will contain our trait as a separate library</li>
<li><kbd>cargo new into_map_derive</kbd>: This is our derive macro crate</li>
</ul>
<p>Now, let's examine our <kbd>main.rs</kbd>, which contains the following initial code:</p>
<pre>// into_map_demo/src/main.rs<br/><br/>use into_map_derive::IntoMap;<br/><br/>#[derive(IntoMap)]<br/>struct User {<br/>    name: String,<br/>    id: usize,<br/>    active: bool<br/>}<br/><br/>fn main() {<br/>    let my_bar = User { name: "Alice".to_string(), id: 35, active: false };<br/>    let map = my_bar.into_map();<br/>    println!("{:?}", map);<br/>}</pre>
<p>In the preceding code, we have our <kbd>User</kbd> struct annotated with <kbd>#[derive(IntoMap)]</kbd>. <kbd>#[derive(IntoMap)]</kbd> will invoke our procedural macro from the <kbd>into_map_derive</kbd> crate. This does not compile as we don't have the <kbd>IntoMap</kbd> derive macro implemented yet. However, this shows us how we want to use the macro as a consumer of this crate. Next, let's see what we have in our <kbd>into_map</kbd> crate's <kbd>lib.rs</kbd> file:</p>
<pre>// into_map_demo/into_map/src/lib.rs<br/><br/>use std::collections::BTreeMap;<br/><br/>pub trait IntoMap {<br/>    fn into_map(&amp;self) -&gt; BTreeMap&lt;String, String&gt;;<br/>}</pre>
<p>Our <kbd>lib.rs</kbd> file simply contains an <kbd>IntoMap</kbd> trait definition with a single method named <kbd>into_map</kbd> that takes a reference to <kbd>self</kbd> and returns a <kbd>BTreeMap&lt;String, String&gt;</kbd>. We want to derive the <kbd>IntoMap</kbd> trait for our <kbd>User</kbd> struct through our derive macro.</p>
<p>Let's examine our <kbd>into_map_derive</kbd> crate next. In this crate, we have the following dependencies in <kbd>Cargo.toml</kbd>:</p>
<pre># into_map_demo/into_map_derive/src/Cargo.toml<br/><br/>[lib]<br/>proc-macro = true<br/><br/>[dependencies]<br/>syn = { version = "0.15.22", features = ["extra-traits"] }<br/>quote = "0.6.10"<br/>into_map = { path="../into_map" }</pre>
<p>As we mentioned previously, we annotate the <kbd>[lib]</kbd> section with the <kbd>proc-macro</kbd> attribute set to <kbd>true</kbd>. We also use <kbd>syn</kbd> and <kbd>quote</kbd> as they help us parse Rust code from the <kbd>TokenStream</kbd> instance. The <kbd>syn</kbd> crate creates an in-memory data structure called the AST, which represents a piece of Rust code. We can then use this structure to examine our source code and extract information programmatically. The <kbd>quote</kbd> crate is a complement to the <kbd>syn</kbd> crate in the sense that it allows you to generate Rust code within the provided <kbd>quote!</kbd> macro, and also allows you to substitute values from <kbd>syn</kbd> data types. We also depend on the <kbd>into_map</kbd> crate, from where we bring the <kbd>IntoMap</kbd> trait into scope within our macro definition.</p>
<p>The code we want this macro to generate will look something like the following:</p>
<pre>impl IntoMap for User {<br/>    fn into_map(&amp;self) -&gt; BTreeMap&lt;String, String&gt; {<br/>        let mut map = BTreeMap::new();<br/>        map.insert("name".to_string(), self.name.to_string());<br/>        map.insert("id".to_string(), self.id.to_string());<br/>        map.insert("active".to_string(), self.active.to_string());<br/>        map<br/>    }<br/>}</pre>
<p>We want to implement the <kbd>into_map</kbd> method on our <kbd>User</kbd> struct, but we want it to be generated automatically for us. This is something that is quite tedious to hand code for cases where we have a struct with lots of fields. Derive macros are tremendously helpful in such cases. Let's look at an implementation.</p>
<p>At a high level, the code generation in the <kbd>into_map_derive</kbd> crate is divided into two phases. In the first phase, we iterate over the fields of the struct and collect code for inserting items into the <kbd>BTreeMap</kbd>. The generated <kbd>insert</kbd> code tokens will look something like this:</p>
<pre>map.insert(field_name, field_value);</pre>
<p>This will be collected into a vector. In the second phase, we take all of the generated <kbd>insert</kbd> code tokens and expand them into another token sequence, which is the <kbd>impl</kbd> block for the <kbd>User</kbd> struct.</p>
<p>Let's start by exploring the implementation in <kbd>lib.rs</kbd>:</p>
<pre>// into_map_demo/into_map_derive/src/lib.rs<br/><br/>extern crate proc_macro;<br/>use proc_macro::TokenStream;<br/>use quote::quote;<br/>use syn::{parse_macro_input, Data, DeriveInput, Fields};<br/><br/>#[proc_macro_derive(IntoMap)]<br/>pub fn into_map_derive(input: TokenStream) -&gt; TokenStream {<br/>    let mut insert_tokens = vec![];<br/>    let parsed_input: DeriveInput = parse_macro_input!(input);<br/>    let struct_name = parsed_input.ident;<br/>    match parsed_input.data {<br/>        Data::Struct(s) =&gt; {<br/>            if let Fields::Named(named_fields) = s.fields {<br/>                let a = named_fields.named;<br/>                for i in a {<br/>                    let field = i.ident.unwrap();<br/>                    let insert_token = quote! {<br/>                        map.insert(<br/>                            stringify!(#field).to_string(),<br/>                            self.#field.to_string()<br/>                        );<br/>                    };<br/>                    insert_tokens.push(insert_token);<br/>                }<br/>            }<br/>        }<br/>        other =&gt; panic!("IntoMap is not yet implemented for: {:?}", other),<br/>    }</pre>
<p>Whew, that's a lot of strange looking code! Let's go through this line by line. First, we have our <kbd>into_map_derive</kbd> function annotated with the <kbd>#[proc_macro_derive(IntoMap)]</kbd> attribute. We can give any name this function, though. This function receives a <kbd>TokenStream</kbd> as input, which will be our <kbd>User</kbd> struct declaration. We then create an <kbd>insert_tokens</kbd> list to store our input tokens, which is part of the actual code generation. We'll explain that in a moment.</p>
<p>We then call the <kbd>parse_macro_input!</kbd> macro from the <kbd>syn</kbd> crate, passing the <kbd>input</kbd> token stream. This gives us back a <kbd>DeriveInput</kbd> instance in the <kbd>parsed_input</kbd> variable. <kbd>parsed_input</kbd> represents our <kbd>User</kbd> struct definition as a token data structure. From that, we pull out the struct name with the <kbd>parsed_input.ident</kbd> field. Next, we match on the <kbd>parsed_input.data</kbd> field, which returns what kind of item it is: struct, enum, or union.</p>
<p>To keep our implementation simpler, we are only implementing the <kbd>IntoMap</kbd> trait for structs, so we match only when our <kbd>parsed_input.data</kbd> is a <kbd>Data::Struct(s)</kbd>. The inner <kbd>s</kbd> is, again, a struct that represents the items that constitute a struct definition. We are interested in what fields <kbd>s</kbd> has, particularly named fields, so we use an <kbd>if let</kbd> to specifically match for that. Inside the <kbd>if</kbd> block, we get a reference to all the fields of our struct and then iterate over them. For each field, we generate an insert code for our <kbd>btree</kbd> map using the <kbd>quote!</kbd> macro from the <kbd>quote</kbd> crate:</p>
<pre>map.insert(<br/>    stringify!(#field).to_string(),<br/>    self.#field.to_string()<br/>);<br/>insert_tokens.push(insert_token);</pre>
<p>Notice the <kbd>#field</kbd> symbol. Within the <kbd>quote!</kbd> macro, we can have template variables that will be substituted with their value in the generated code. In this case, <kbd>#field</kbd> gets replaced with whatever field is present in our struct. First, we convert <kbd>#field</kbd> to a string literal by using the <kbd>stringify!</kbd> macro, which is an <kbd>Ident</kbd> type from the <kbd>syn</kbd> crate. We then push this generated chunk of code into the <kbd>insert_tokens</kbd> vec.</p>
<p>Following that, we come to our final phase of code generation:</p>
<pre>    let tokens = quote! {<br/>        use std::collections::BTreeMap;<br/>        use into_map::IntoMap;<br/><br/>        impl IntoMap for #struct_name {<br/>            /// Converts the given struct into a dynamic map<br/>            fn into_map(&amp;self) -&gt; BTreeMap&lt;String, String&gt; {<br/>                let mut map = BTreeMap::new();<br/>                #(#insert_tokens)*<br/>                map<br/>            }<br/>        }<br/>    };<br/><br/>    proc_macro::TokenStream::from(tokens)<br/>}</pre>
<p>Here, we are finally generating our final <kbd>impl</kbd> block for our struct. Within the <kbd>quote!</kbd> block, whatever we write will be generated exactly as written, including the indentation and code comments. First, we do the imports of the <kbd>BtreeMap</kbd> type and the <kbd>IntoMap</kbd> trait. Then, we have the <kbd>IntoMap</kbd> implementation. Within that, we create our <kbd>map</kbd>, and just expand out the <kbd>insert_tokens</kbd> that we collected in the first phase of code generation. Here, the outer <kbd>#()*</kbd> repeater tells the <kbd>quote!</kbd> macro to repeat the same code zero or more times. For iterable items such as our <kbd>insert_tokens</kbd>, this will repeat all the items within it. This generates code for inserting the field name and field value from the struct into the <kbd>map</kbd>. Finally, we take the whole implementation code that's stored in the <kbd>tokens</kbd> variable and return this as a <kbd>TokenStream</kbd> by calling <kbd>TokenStream::from(tokens)</kbd>. That's it! Let's try this macro in <kbd>main.rs</kbd>:</p>
<pre>// into_map_demo/src/main.rs<br/><br/>use into_map_derive::IntoMap;<br/><br/>#[derive(IntoMap)]<br/>struct User {<br/>    name: String,<br/>    id: usize,<br/>    active: bool<br/>}<br/><br/>fn main() {<br/>    let my_bar = User { name: "Alice".to_string(), id: 35, active: false };<br/>    let map = my_bar.into_map();<br/>    println!("{:?}", map);<br/>}</pre>
<p>Running <kbd>cargo run</kbd> gives us the following output:</p>
<pre>{"active": "false", "id": "35", "name": "Alice"}</pre>
<p>Great! It works. Next, let's look at how we can debug macros.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging macros</h1>
                </header>
            
            <article>
                
<p>When developing complex macros, most of the time you need ways to analyze how your code expands to the inputs you gave to the macro. You can always use <kbd>println!</kbd> or <kbd>panic!</kbd> at the places you want to see the generated code, but it's a very crude way to debug it. There's are better way, though. The Rust community provides us with a subcommand called <kbd>cargo-expand</kbd>. This subcommand was developed by David Tonlay at <a href="https://github.com/dtolnay/cargo-expand">https://github.com/dtolnay/cargo-expand</a>, who is also the author of the <kbd>syn</kbd> and <kbd>quote</kbd> crates. This command internally calls the nightly compiler flag <kbd><span class="pl-s1">-Zunstable-options --pretty=expanded</span></kbd>, but the design of the subcommand was done in such a way that it doesn't require you to manually switch to the nightly tool chain as it finds and switches to it automatically. To demonstrate this command, we'll take the example of our <kbd>IntoMap</kbd> derive macro and observe what code it generated for us. By switching into the directory and running <kbd>cargo expand</kbd>, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0bdd3a71-91b6-49d8-b60c-0b9d50665e4e.png" style="width:35.58em;height:34.08em;"/></p>
<p>As you can see, the <kbd>impl</kbd> block at the bottom is what was generated by the <kbd>IntoMap</kbd> derive macro. <kbd>cargo-expand</kbd> also includes pretty printed syntax highlighted output. This command is a must-have tool for someone writing complex macros.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Useful procedural macro crates</h1>
                </header>
            
            <article>
                
<p>As procedural macros can be distributed as crates, a lot of emerging helpful macro crates are available, which can be found at <kbd>crates.io</kbd>. Using them can greatly reduce the boilerplate you need to write for generating Rust code. Some of them are as follows:</p>
<ul>
<li><kbd>derive-new</kbd>: A derive macro provides a default all-fields constructor for structs and is quite customizable.</li>
<li><kbd>derive-more</kbd>: A derive macro that circumvents the limitation where we wrap a type for which we already have a lot of traits auto-implemented, but lose the ability to create our own type wrapping for it. This crate helps us provide the same set of traits, even on these wrapper types.</li>
<li><kbd>lazy_static</kbd>: This crate provides a function-like procedural macro called <kbd>lazy_static!</kbd>, where you can declare <kbd>static</kbd> values that require dynamically initialized types. For example, you can declare a configuration object as a <kbd>HashMap</kbd> and can access it globally across the code base.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the metaprogramming abilities of Rust and looked at many kinds of macros. The most frequently used macro is <kbd>macro_rules!</kbd>, which is a declarative macro. Declarative macros work at the abstract syntax tree level, which means that they do not support arbitrary expansions, but require that the macro expansions are well-formed in the AST. For more complex use cases, you can use procedural macros where you get complete control of manipulating the input and generating the desired code. We also looked at ways to debug macros using the cargo subcommand <kbd>cargo-expand</kbd>.</p>
<p>Macros are indeed a powerful tool, but not something that should be used heavily. Only when the more usual mechanisms of abstraction such as functions, traits, and generics do not suffice for the problem at hand should we turn to macros. Also, macros make the code less readable for newcomers to a code base and should be avoided. Having said that, they are quite useful in writing test case conditions and are widely used by developers.</p>
<p>In the next chapter, we'll get a glimpse of another side of Rust, the unsafe bits, which are less recommended but unavoidable if you want to interoperate Rust with different languages.</p>


            </article>

            
        </section>
    </body></html>