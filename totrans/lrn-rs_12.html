<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Now It&amp;#x27;s Your Turn!</h1>
                
            
            <article>
                
<p class="calibre1">We're rapidly approaching the end of the book and it is time for you to put what we've covered and you've learned into practice. As with <a href="part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 6</a>, <em class="calibre9">Creating Your Own Rust Applications</em>, this chapter will take the form of a number of challenges for you. There is no sample code for this chapter, so it's all down to you. The majority of the challenges will be based around the <kbd class="calibre10">mathlib</kbd> library covered in <span><a href="part0238.html#72V5S0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 10</a>, <em class="calibre9">Creating Your Own Crate</em>,</span> as well as using code created in <span><a href="part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 6</a>, <em class="calibre9">Creating Your Own Rust Applications</em></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Task 1 – cleaning the code (part 1)</h1>
                
            
            <article>
                
<p class="calibre1">If you consider the code examples in <kbd class="calibre10">temperature.rs</kbd>, you will see that some use a tuple and some use a single type <kbd class="calibre10">return</kbd>. While for development this is a fairly acceptable approach, for a release we may want something more structured.</p>
<p class="calibre1">Consider the two functions <kbd class="calibre10">kelvin_to_celcius</kbd> and <kbd class="calibre10">celcius_to_farenheit</kbd>; in order to use them, we need to have two variables:</p>
<pre class="calibre21">let ktoc = kelvin_to_celcius(14.5f32); 
let ctof = celcius_to_fahrenheit(24.3f32); </pre>
<p class="calibre1">There are a number of possible solutions to this problem.</p>
<ul class="calibre12">
<li class="calibre13">Do nothing! Many libraries use multiple variables when the function returns different types.</li>
<li class="calibre13">Implement a trait within the module that tests the return for false and returns either a <kbd class="calibre10">String</kbd> containing the answer or <em class="calibre9">calculation failed</em>.</li>
<li class="calibre13">Define a single <kbd class="calibre10">struct</kbd> for the answer of the form, which is then passed back to the caller, as follows:</li>
</ul>
<pre class="calibre36">pub struct maths_answersMathsAnswers { 
    calc_complete : bool, 
    fanswer : f32, 
    ianswer : i32, 
}  </pre>
<p class="calibre1">If we remove the first option (after all, what would be the point in doing this as part of a chapter given over to testing what we have covered?), we are left with options 2 - 4 or 3.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The problems with each option</h1>
                
            
            <article>
                
<p class="calibre1">Each option has its own unique associated problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The String option</h1>
                
            
            <article>
                
<p class="calibre1">The issue with the second option is that, if we return a <kbd class="calibre10">String</kbd> and then want to do something else with the answer (possibly a further calculation from one of the other modules within the crate), we will need some method of converting the string (after checking it doesn't contain the error code) back to an <kbd class="calibre10">f32</kbd> to pass into the second function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The struct option</h1>
                
            
            <article>
                
<p class="calibre1">The problem with the third option is that, when we call within the library, we either have a return type of <kbd class="calibre10">tuple(bool, f32)</kbd> or <kbd class="calibre10">f32</kbd>. Therefore, in a function that only returns a single type, we will need to set <kbd class="calibre10">calc_completed</kbd> to <kbd class="calibre10">true</kbd>.</p>
<p class="calibre1">It is possible to set a default value on the <kbd class="calibre10">struct</kbd> by deriving or implementing <kbd class="calibre10">std::Default</kbd> (we will cover the standard library in <span><a href="part0303.html#90UQE0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 13</a>, <em class="calibre9">The Standard Library</em>,  and <a href="part0359.html#AMBPU0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 14</a>, <em class="calibre9">Foreign Function Interfaces</em></span>). Here's a derived version:</p>
<pre class="calibre21">#[derive(Default)] 
pub struct MathsAnswers { 
    calc_complete : bool, 
    fanswer : f32, 
    ianswer : i32, 
}  </pre>
<p class="calibre1">All primitive types in Rust have a sensible default value: numbers are zeroes, bool is false, Strings are empty strings, and so on. The preceding code is equivalent to the following manually implemented <kbd class="calibre10">Default</kbd> :</p>
<pre class="calibre21">impl Default for MathsAnswers { 
  fn default () -&gt; MathsAnswers { 
    MathsAnswers {calc_complete: false, fanswer: 0f32, ianswer: 0i32 } 
  } 
} </pre>
<p class="calibre1">However, we want the calc_complete default to be true, so we'll use this implementation instead:</p>
<pre class="calibre21">impl Default for MathsAnswers { 
  fn default () -&gt; MathsAnswers { 
    MathsAnswers {calc_complete: false, fanswer: 0f32, ianswer: 0i32 } 
  } 
} </pre>
<p class="calibre1">After the <kbd class="calibre10">Default</kbd> implementation, we may choose to only fill in some of the values when creating an instance and supply <kbd class="calibre10">Default::default()</kbd> for the rest:</p>
<pre class="calibre21"><span>// do calculation then</span><br class="calibre2"/>let answers =  MathsAnswers { fanswer: calc_ans, ..Default::default() }; 
return MathsAnswers; </pre>
<p class="calibre1">The potential problem is where to put the struct in terms of scope. Where would it be best to place it?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The task</h1>
                
            
            <article>
                
<p class="calibre1">You are to decide which one of the options for refactoring the code would work best and then implement it. You should create a number of unit tests to ensure the sanity checks work and then test it in your own test rig application to ensure nothing has broken with the crate and scope.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Task 2 – cleaning the code (part 2)</h1>
                
            
            <article>
                
<p class="calibre1">While each function is kept apart in the crate, we can always clean up the code to make it safer (we have a single public function and keep the calculations away from prying eyes).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The task</h1>
                
            
            <article>
                
<p class="calibre1">Each function takes a single parameter of either the <kbd class="calibre10">f32</kbd> or <kbd class="calibre10">i32</kbd> type and thankfully, we can separate out the modules to be those that return an <kbd class="calibre10">f32</kbd> or <kbd class="calibre10">i32</kbd> (the bases all return <kbd class="calibre10">i32</kbd>: all of the others have their answers in <kbd class="calibre10">f32</kbd>).</p>
<p class="calibre1">If we look at the temperatures module, everything will return the answer as <kbd class="calibre10">f32</kbd> (after task 1, how it does this is up to you). We can therefore create a single function that takes as the first parameter the conversion to be performed and as the second the value.</p>
<p class="calibre1">When the single function recognizes the first parameter, it calls the now private functions and returns the value.</p>
<p class="calibre1">As with the first task, you will need to implement this and create documentation for the new library. You should create a new unit test for the crate and test it in your test rig application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Task 3 – extending the crate (part 1)</h1>
                
            
            <article>
                
<p class="calibre1">You will have noticed that, in the example library, there is no code at all for the <kbd class="calibre10">regression_analysis</kbd> module. This is deliberate.</p>
<p class="calibre1">Back in <a href="part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d" class="calibre3"><span>Chapter 6</span></a>, <em class="calibre9">Creating Your Own Rust Applications</em>, one of the tasks was to create code that enabled you to perform a regression analysis based on formulae provided. The code created can now be firmly split into two parts:</p>
<ul class="calibre12">
<li class="calibre13">The equation for the straight line, <em class="calibre9">y = mx + c</em><span>,</span> which will also give the intercepts on the <em class="calibre9">x</em> and <em class="calibre9">y</em> axis</li>
<li class="calibre13">The standard deviation and regression analysis</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The task</h1>
                
            
            <article>
                
<p class="calibre1">In this task, you are to take your code and put it into the <kbd class="calibre10">mathslib</kbd> crate. This may not be as simple as it seems. The library will need to take:</p>
<ul class="calibre12">
<li class="calibre13">A filename for the file containing the data</li>
<li class="calibre13">A vector containing either a <kbd class="calibre10">struct</kbd> or <kbd class="calibre10">tuple</kbd> that holds the data</li>
</ul>
<p class="calibre1">However, the problem doesn't lie in the data, but rather in the fact that, each time a calculation is made, the whole regression analysis has to be performed. For example, to calculate the standard deviation, you can't just pass in the results for the equation of a straight line—that won't work, but will cause the whole calculation to be performed again.</p>
<p class="calibre1">In terms of the speed of a library, this is very inefficient; you should calculate once and be able to draw out all answers from there. In terms of your code, this will require some re-organization.</p>
<p class="calibre1">Once you have done this, you should create the unit tests for each function and test them in your test rig app with both a vector then the filename.</p>
<p class="calibre1">You will need to add the documentation for this task to your current documentation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Task 4 – extending the crate (part 2)</h1>
                
            
            <article>
                
<p class="calibre1">By now, you will have a firm grasp of how crates work, the required testing regime, and creating a test rig. Your final task in this section is to create your own extension to the crate. There are some criteria though to your extension:</p>
<ul class="calibre12">
<li class="calibre13">One of the functions must return a non-primitive type</li>
<li class="calibre13">The calculations should be private; there should be some form of interface to the function call</li>
<li class="calibre13">There should be a single function that takes an XML file as a parameter to perform the calculation</li>
<li class="calibre13">The new module must be fully documented and complete with its own tests</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1">We've finished the main part of the book. We've covered the majority of the Rust language and these end-of-section chapters should have helped you consolidate your knowledge.</p>
<p class="calibre1">In the final part of the book, we'll cover the standard libraries and how to interface your Rust application to an external library.</p>


            </article>

            
        </section>
    </body></html>