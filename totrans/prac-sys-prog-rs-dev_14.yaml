- en: '*Chapter 11*: Learning Network Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to communicate with peripheral devices
    from Rust programs. In this chapter, we will switch our focus to another important
    system programming topic – networking.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern operating systems, including Unix/Linux and Windows variants, have
    native support for networking using TCP/IP. Do you know how you can use TCP/IP
    to send byte streams or messages from one computer to another? Do you want to
    know what kind of language support Rust provides for synchronous network communications
    between two processes running on different machines? Are you interested in learning
    the basics of configuring TCP and UDP sockets, and working with network addresses
    and listeners in Rust? Then, read on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover these topics in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing networking basics in Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding networking primitives in the Rust standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming with TCP and UDP in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a TCP reverse proxy (project)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to work with network addresses,
    determine address types, and do address conversions. You will also learn how to
    create and configure sockets and query on them. You will work with TCP listeners,
    create a TCP socket server, and receive data. Lastly, you'll put these concepts
    into practice through an example project.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to learn these topics because sockets-based programming using
    TCP or UDP forms the basis for writing distributed programs. Sockets help two
    processes on different (or even the same) machines to establish communication
    with each other and exchange information. They form the foundation for practically
    all web and distributed applications on the internet, including how an internet
    browser accesses a web page and how a mobile application retrieves data from an
    API server. In this chapter, you will learn what kind of support is provided by
    the Rust standard library for *socket-based* network communications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify that `rustup`, `rustc`, and `cargo` have been installed correctly with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter11](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing networking basics in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The internet connects several different networks across the globe, enabling
    machines across networks to communicate with each other in different ways, including
    the **request-response** model (synchronous), **asynchronous messaging**, and
    **publish-subscribe**-style notifications. *Figure 11.1* shows an example of a
    connection between two networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Internet router connecting two networks](img/Figure_11.1_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Internet router connecting two networks
  prefs: []
  type: TYPE_NORMAL
- en: The internet also provides abstractions in the form of **networking protocols
    and standards** to make it easy for hosts on different networks to communicate
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of standards include a common *host addressing format*, a combination
    of host address and port to define a *network endpoint*. The IP address of a host
    is a *32-bit* number for IPv4 addresses and a *128-bit* number for IPv6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of network protocols include for web browsers to retrieve documents
    from web servers, **domain name system** (**DNS**) to map domain names to host
    addresses, the IP protocol to package and route packets of data across the internet,
    and TCP to add reliability and error handling for IP data packets.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, *networking protocols* are very important in defining how information
    is transmitted and interpreted by programs running in different host computers
    across different networks. The **TCP/IP protocol suite** is the foundation of
    how the internet, which we use on a daily basis, enables our digital world of
    information, transactions, and entertainment.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.2* shows the layered TCP/IP protocol suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Internet router connecting two networks](img/Figure_11.2_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Internet router connecting two networks
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed device drivers. In *Figure 11.2*, the
    lowest layer of the *TCP/IP protocol suite* shown – the **data link layer** –
    comprises the **device driver** and **network interface card** corresponding to
    the network medium used for communication between the hosts (for example, coax
    cable, fiber, or wireless). The data link layer assembles data packets received
    from the higher network (IP) layer into **data frames**, and transmits them over
    the physical link.
  prefs: []
  type: TYPE_NORMAL
- en: The next layer up in the TCP/IP protocol suite is the **IP layer**, which is
    the most important layer in the TCP/IP stack. It assembles data into packets and
    sends them to the data link layer. The IP layer is also responsible for routing
    data across the internet. This is achieved by adding a header for each datagram
    (packet) transmitted, which includes the address of the remote host to which the
    packet should be transmitted. Two packets sent from host A to host B can take
    different routes through the internet. IP is a connectionless protocol, which
    means there is no communication channel created between two hosts to have multi-step
    communication. This layer just sends a data packet from one host IP address to
    another host IP address without any guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: The next layer up in the TCP/IP protocol suite is the **transport layer**. Here,
    there are two popular protocols used on the internet – TCP and UDP. **TCP** stands
    for **transmission control protocol** and **UDP** is **user datagram protocol**.
    While the network (IP) layer is concerned with sending data packets between two
    hosts, the transport layer (TCP and UDP) is concerned with sending data streams
    between two processes (applications or programs) running on the same host or different
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: If there are two applications running on a single host IP address, the way to
    uniquely identify each application is by using a *port number*. Each application
    that is involved in network communications listens on a specific port, which is
    a 16-bit number.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of popular ports are `80` for the *HTTP* protocol, `443` for the *HTTPS*
    protocol, and `22` for the *SSH* protocol. The combination of an IP address and
    a port number is called a **socket**. We'll see in this chapter how to work with
    sockets using the Rust standard library. UDP, like IP, is connectionless and does
    not incorporate any reliability mechanisms. But it is fast and has a low overhead
    compared to TCP. It is used in higher-level services, such as DNS, to get host
    IP addresses corresponding to a domain name.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to UDP, TCP provides a connection-oriented, reliable communication
    channel between two endpoints (application/user space programs) over which byte
    streams can be exchanged while preserving the sequence of data. It incorporates
    features such as **retransmission** in the case of errors, **acknowledgments**
    of packets received, and **timeouts**. We'll discuss TCP-based communication in
    detail in this chapter and later build a reverse proxy using TCP socket-based
    communications.
  prefs: []
  type: TYPE_NORMAL
- en: The uppermost layer in the TCP/IP protocol suite is the **application layer**.
    While the TCP layer is connection-oriented and works with byte streams, it has
    no knowledge of the semantics of a message transmitted. This is provided by the
    application layer. For example, HTTP, which is the most popular application protocol
    on the internet, uses HTTP request and response messages to communicate between
    **HTTP clients** (for example, internet browsers) and **HTTP servers** (for example,
    web servers). The application layer reads the byte streams received from the TCP
    layer and interprets them into HTTP messages, which are then processed by the
    application program that we write in Rust or other languages. There are several
    libraries (or crates) available in the Rust ecosystem that implement the HTTP
    protocol, so Rust programs can leverage them (or write their own) to send and
    receive HTTP messages. In the example project for this chapter, we will write
    some code to interpret an incoming HTTP request message and send back an HTTP
    response message.
  prefs: []
  type: TYPE_NORMAL
- en: The primary Rust Standard Library module for networking communications is `std::net`.
    This focuses on writing code for communicating using TCP and UDP. The Rust `std::net`
    module does not deal directly with the data link layer or application layer of
    the TCP/IP protocol suite. With this background, we are ready to understand the
    networking primitives provided in the Rust standard library for TCP and UDP communications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding networking primitives in the Rust standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll discuss the foundational data structures in the Rust
    standard library for networking. *Figure 11.3* lists the commonly used data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Networking primitives in the Rust standard library](img/Figure_11.3_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Networking primitives in the Rust standard library
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the data structures one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ipv4Addr`: This is a struct that stores a 32-bit integer representing an IPv4
    address, and provides associated functions and methods to set and query address
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ipv6Add`: This is a struct that stores a 128-bit integer representing an IPv6
    address, and provides associated functions and methods to query and set address
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SocketAddrv4`: This is a struct representing an internet domain socket. It
    stores an IPv4 address and a 16-bit port number and provides associated functions
    and methods to set and query socket values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SocketAddrv6`: This is a struct representing an internet domain socket. It
    stores an IPv6 address and a 16-bit port number and provides associated functions
    and methods to set and query socket values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IpAddr`: This is an enum with two variants – `V4(Ipv4Addr)` and `V6(Ipv6Addr)`.
    This means that it can hold either an IPv4 host address or an IPv6 host address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SocketAddr`: This is an enum with two variants – `V4(SocketAddrV4)` and `V6(SocketAddrV6)`.
    This means that it can hold either an IPv4 socket address or an IPv6 socket address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The size of an *Ipv6* address might vary, depending on the target operating
    system architecture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's now see a few examples of how to use them. We'll start by creating IPv4
    and IPv6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example shown next, we''re creating IPv4 and IPv6 addresses using the
    `std::net` module and using built-in methods to query on the created addresses.
    The `is_loopback()` method confirms whether the address corresponds to `localhost`,
    and the `segments()` method returns the various segments of the IP address. Note
    also that the `std::net` module provides a special constant, `Ipv4Addr::LOCALHOST`,
    which can be used to initialize the IP address with the `localhost` (loopback)
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to use the `IpAddr` enum. In this example,
    usage of the `IpAddr` enum is shown to create IPv4 and IPv6 addresses. The `IpAddr`
    enum helps us to define IP addresses in a more generic way in our program data
    structures and gives us the flexibility to work with both IPv4 and IPv6 addresses
    in our programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now turn our attention to sockets. As discussed earlier, sockets comprise
    an IP address and a port. Rust has separate data structures for both IPv4 and
    IPv6 sockets. Let''s see an example next. Here, we''re creating a new IPv4 socket,
    and querying for the IP address and port numbers from the constructed socket,
    using the `ip()` and `port()` methods, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: IP addresses and sockets represent the foundational data structures for network
    programming using the Rust standard library. In the next section, we'll see how
    to write programs in Rust that can communicate over TCP and UDP protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Programming with TCP and UDP in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, TCP and UDP are the fundamental transport layer network
    protocols for the internet. In this section, let's first write a UDP server and
    client. Then we'll look at doing the same using TCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project called `tcpudp` where we will write the TCP and UDP servers
    and clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's first look at network communication using UDP.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a UDP server and client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll learn how to configure UDP sockets, and how to send and
    receive data. We'll write both a UDP server and a UDP client.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the UDP server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the example shown, we''re creating a UDP server by binding to a local socket
    using `UdpSocket::bind`. We''re then creating a fixed-size buffer, and listening
    for incoming data streams in a loop. If data is received, we are spawning a new
    thread to process the data by echoing it back to the sender. As we already covered
    how to spawn new threads in [*Chapter 9*](B16405_09_Final_NM_ePUB.xhtml#_idTextAnchor150),
    *Managing Concurrency*, it shouldn''t need explanation again here:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpudp/src/bin/[udp-server.rs](http://udp-server.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Writing a UDP client to send data packets to the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the code shown, we''re first asking the standard library to bind to a local
    port (by providing an address port combination of `0.0.0.0:0`, which allows the
    operating system to pick a transient IP address/port to send the datagram from).
    Then, we are trying to connect to the remote socket where the server is running,
    and displaying an error in the case of failure to connect. In the case of a successful
    connection, we are printing out the socket address of the peer using the `peer_addr()`
    method. Lastly, we are using the `send()` method to send a message to the remote
    socket (server):'
  prefs: []
  type: TYPE_NORMAL
- en: tcpudp/src/bin/[udp-client.rs](http://udp-client.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the UDP server with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From a separate terminal, run the UDP client with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You'll see the message received at the server, which was sent from the client.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen so far how to write programs in Rust to do communications over UDP.
    Let's now look at how TCP communications are done.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a TCP server and client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll learn how to configure TCP listeners, create a TCP socket
    server, and send and receive data over TCP. We'll write both a TCP server and
    a TCP client.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the TCP server. In the code shown next, we''re using `TcpListener::bind`
    to create a TCP server listening on a socket. Then, we use the `incoming()` method,
    which returns an iterator of incoming connections. Each connection returns a TCP
    stream that can be read from using the `stream.read()` method. We''re reading
    the data and printing out the values. Also, we''re echoing back the received data
    over the connection using the `stream.write()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpudp/src/bin/[tcp-server.rs](http://tcp-server.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the code for the TCP server. Let's now write a TCP client to
    send some data to the TCP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the TCP client code shown next, we''re using the `TcpStream::connect` function
    to connect to a **remote socket** where the server is listening. This function
    returns a **TCP stream**, which can be *read from* and *written to* (as we saw
    in the previous example). Here, we''re first going to write some data to the TCP
    stream, and then read back the response received from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpudp/src/bin/[tcp-client.rs](http://tcp-client.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the TCP server with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From a separate terminal, run the TCP client with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You'll see the message that was sent from the client being received at the server
    and echoed back.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this section on performing TCP and UDP communications using the
    Rust standard library. In the next section, let's use the concepts learned so
    far to build a TCP reverse proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a TCP reverse proxy (project)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will demonstrate the basic functionality of a **TCP reverse
    proxy** using just the Rust standard library, without the use of any external
    libraries or frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A proxy server is an intermediary software service that is used while navigating
    across multiple networks on the internet. There are two types of proxy servers
    – a **forward proxy** and a **reverse proxy**. A forward proxy acts as an intermediary
    for clients making requests out to the internet, and a reverse proxy acts as an
    intermediary for servers. *Figure 11.4* illustrates the usage of forward and reverse
    proxy servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Types of proxy servers](img/Figure_11.4_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Types of proxy servers
  prefs: []
  type: TYPE_NORMAL
- en: Forward proxies act as gateways to the internet for a group of client machines.
    They help individual client machines to hide their IP addresses while browsing
    the internet. They also help to enforce organizational policies for machines within
    a network to access the internet, such as restricting websites to visit.
  prefs: []
  type: TYPE_NORMAL
- en: While a forward proxy acts on behalf of clients, a reverse proxy acts on behalf
    of hosts (for example, web servers). They hide the identity of the backend servers
    from the clients. The clients only make a request to the reverse proxy server
    address/domain, and the reverse proxy server, in turn, knows how to route that
    request to the backend server (also sometimes called the **origin server**), and
    returns the response received from the origin server to the requesting client.
    A reverse proxy can also be used to perform other functions, such as load balancing,
    caching, and compression. We will, however, just focus on demonstrating the core
    concept of a reverse proxy by directing requests received from clients to the
    backend origin servers and routing responses back to the requesting client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate a working *reverse proxy*, we will build two servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Origin server**: TCP server (which understands limited HTTP semantics).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverse proxy server**: Client requests coming to this server will be directed
    to the *origin server*, and responses from the origin server will be routed back
    to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new project to write the origin and proxy servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two files: `tcpproxy/src/bin/`[origin.rs](http://origin.rs) and `tcpproxy/src/bin/`[proxy.rs](http://proxy.rs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the code for the origin server. This server will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive an incoming HTTP request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the first line of the request (called the **HTTP request line**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept a `GET HTTP` request on a specific route (for example, `/order/status/1`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return the status of the order. We will demonstrate parsing of the HTTP request
    line to retrieve the order number and just send back a response stating **Order
    status for order number 1 is: Shipped**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see the code now for the origin server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the origin server – structs and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll first see the code for module imports, struct definitions and methods.
    Then, we'll see the code for the `main()` function. All the code for the origin
    server can be found in `tcpproxy/src/bin/`[origin.rs](http://origin.rs).
  prefs: []
  type: TYPE_NORMAL
- en: 'The module imports are shown first in the code snippet. We''re importing various
    modules from the standard library here. The `std::io` module will be used to read
    and write to the TCP stream, and the `std::net` module provides the primitives
    for the TCP listener, sockets, and addresses. The string modules (`std::str` and
    `std::String`) are used for string manipulations and handling string parsing errors:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's declare a struct to hold the incoming HTTP request line (the first
    line of the multi-line HTTP request message). We'll also write some helper methods
    for this struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code shown next, we''ll declare a `RequestLine` struct consisting of
    three fields – the HTTP method, the path of the resource requested, and the HTTP
    protocol version supported by the internet browser or another HTTP client sending
    the request. We''ll also write some methods to return the values of the struct
    members. Custom logic will be implemented for the `get_order_number()` method.
    If we get a request for a resource with the `/order/status/1` path, we will split
    this string by `/`, and return the last part of the string, which is order number
    `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also implement the `FromStr` trait for the `RequestLine` struct so that
    we can convert the incoming HTTP request line (string) into our internal Rust
    data structure – `RequestLine`. The structure of the HTTP request line is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These three values are separated by white spaces and are all present in the
    first line of an HTTP request message. In the program shown, we''re going to parse
    these three values and load them into the `RequestLine` struct. Later, we will
    further parse the path member and extract the order number from it, for processing:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We've so far seen the module imports, struct definition, and methods for the
    `RequestLine` struct. Let's now write the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the origin server – the main() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `main` function of the origin server, we are going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the TCP server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listen for incoming connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each incoming connection, we will then perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the first line of the incoming HTTP request message and convert it into
    a `RequestLine` struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct the HTTP response message and write it to the TCP stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now see the code for the main function in two parts – starting the TCP
    server and listening for connections, and processing incoming HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the TCP server and listening for connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start the TCP server, we will construct a socket address, and bind to a
    socket using `TcpStream::bind`:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll listen for incoming connections, and read from the stream for
    each connection:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's now see the processing of the incoming request.
  prefs: []
  type: TYPE_NORMAL
- en: Processing incoming HTTP requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For processing incoming requests, the first step is to retrieve the first line
    of the request message and convert it into a `RequestLine` struct. In the code
    shown next, we''re using the `lines()` method to return an iterator of lines.
    We''re then retrieving the first line of the HTTP request using `lines().next()`.
    We are converting this into a `RequestLine` struct using `RequestLine::from_str()`.
    This is possible only because we have implemented the `FromStr` trait for the
    `RequestLine` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have parsed the required data into the `RequestLine` struct, we
    can process it and send the HTTP response back. Let''s see the code. If the message
    received is not a `GET` request, if the path in the request message does not start
    with `/order/status`, or if the order number is not provided, construct an HTTP
    response message with the `404 Not found` HTTP status code:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the request is correctly formatted to retrieve the order status for an order
    number, we should construct an HTML response message with the `200 OK` HTTP status
    code for sending the response back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s write the constructed HTTP response message to the TCP stream:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the code for the origin server. The complete code can be found
    in the Packt GitHub repo for `Chapter12` at `tcpproxy/src/bin/`[origin.rs](http://origin.rs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the server start with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running on port: 3000**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a browser window, enter the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response displayed on the browser screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Order status for order number 2 is: Shipped**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try entering a URL with an invalid path, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following message displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorry, this page is not found**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, you can provide a valid path but without an order number, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see the following error message displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Please provide valid order number**'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we conclude the section on the origin server. Let's now write the
    code for the *reverse proxy*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the reverse proxy server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's dive into the code for the reverse proxy, starting with the module imports.
    All of the code for this reverse proxy server can be found in `tcpproxy/src/bin/`[proxy.rs](http://proxy.rs).
  prefs: []
  type: TYPE_NORMAL
- en: Let's first look at the module imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::env` module is used to read command-line parameters. `std::io` is
    used to read and write to TCP streams. `std::net` is the main module for communications,
    as we have seen. `std::process` is used to exit the program in case of unrecoverable
    errors. `std::thread` is used to spawn a new thread for processing incoming requests:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's write the `main()` function next. When we start the reverse proxy server,
    let's accept two command-line parameters, corresponding to socket addresses of
    the *reverse proxy* and *origin server*, respectively. If two command-line parameters
    are not provided by the user, then print out an error message and exit the program.
    Then, let's parse the command-line inputs and start the server using `TcpListener::bind`.
    After binding to the local port, we connect to the origin server and print out
    an error message in the case of failure to connect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following code within the `main()` function block:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After starting the server, we must listen for incoming connections. For every
    connection, spawn a separate thread to handle the connection. The thread in turn
    calls the `handle_connection()` function, which we will describe shortly. Then,
    join the child thread handles with the main thread to make sure that the `main()`
    function does not *exit* before the child threads are completed:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This concludes the `main()` function. Let''s now write the code for `handle_function()`.
    This contains the core logic for proxying to the origin server:'
  prefs: []
  type: TYPE_NORMAL
- en: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For ease of debugging, the four key steps involved in the proxy functionality
    are marked in the code and also printed out to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we read the incoming data from the incoming *client connection*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second step, we open a new TCP stream with the *origin server*, and send
    the data we received from the *client* to the origin server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the third step, we are reading the response we received from the origin server
    and store the data in a buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the final step, we are using the data received in the previous step to write
    to the TCP stream corresponding to the client that sent the original request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This concludes the code for reverse proxy. We've kept the functionality simple
    and handled only the base case. As an extra exercise, you can add edge cases to
    make the server more robust, and also add additional functionality such as load-balancing
    and caching.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the code for the origin server. The complete code can be found
    in the Packt GitHub repo for `Chapter12` at `tcpproxy/src/bin/`[proxy.rs](http://proxy.rs).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start the origin server with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the proxy server with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first command-line parameter that we pass is used by the *reverse proxy*
    server to bind to the specified socket address. The second command-line parameter
    corresponds to the socket address at which the *origin server* is running. This
    is the address to which we have to proxy the incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now run the same tests from a browser that we did for the origin server,
    only this time we'll send the request to port `3001`, where the reverse proxy
    server is running. You'll notice that you will get similar response messages.
    This demonstrates that the requests sent by the internet browser client are being
    proxied by the reverse proxy server to the backend origin server, and the response
    received from the origin server is being routed back to the browser client.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the server start with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running on Addr:127.0.0.1, Port:3001**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a browser window, enter the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response displayed on the browser screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Order status for order number 2 is: Shipped**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try entering a URL with an invalid path, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following message displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorry, this page is not found**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, you can provide a valid path but without an order number, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see the following error message displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Please provide valid order number**'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this example project, where we wrote two servers – a TCP origin
    server and a simple TCP reverse proxy server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the basics of networking in Linux/Unix. We learned
    about the networking primitives in the Rust standard library, including data structures
    for IPv4 and IPv6 addresses, IPv4 and IPv6 sockets, and associated methods. We
    learned how to create addresses, as well as create sockets and query them.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how to use UDP sockets and wrote a UDP client and server. We
    also reviewed the TCP communication basics, including how to configure TCP listeners,
    how to create a TCP socket server, and how to send and receive data. Lastly, we
    wrote a project consisting of two servers – an *origin server* and a *reverse
    proxy server* that routes requests to the origin server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter of the book, we'll cover another important topic
    for system programming – **unsafe Rust and FFI**.
  prefs: []
  type: TYPE_NORMAL
