- en: '*Chapter 11*: Learning Network Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：学习网络编程'
- en: In the previous chapter, we learned how to communicate with peripheral devices
    from Rust programs. In this chapter, we will switch our focus to another important
    system programming topic – networking.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在Rust程序中与外围设备通信。在本章中，我们将关注另一个重要的系统编程主题——网络。
- en: Most modern operating systems, including Unix/Linux and Windows variants, have
    native support for networking using TCP/IP. Do you know how you can use TCP/IP
    to send byte streams or messages from one computer to another? Do you want to
    know what kind of language support Rust provides for synchronous network communications
    between two processes running on different machines? Are you interested in learning
    the basics of configuring TCP and UDP sockets, and working with network addresses
    and listeners in Rust? Then, read on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代操作系统，包括Unix/Linux和Windows变体，都原生支持使用TCP/IP进行网络。你知道如何使用TCP/IP将字节流或消息从一台计算机发送到另一台计算机吗？你想了解Rust为在不同机器上运行的两个进程之间的同步网络通信提供的语言支持吗？你对学习配置TCP和UDP套接字、在Rust中处理网络地址和监听器的基础感兴趣吗？那么，继续阅读。
- en: 'We will cover these topics in the following order:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下顺序介绍这些主题：
- en: Reviewing networking basics in Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux中回顾网络基础知识
- en: Understanding networking primitives in the Rust standard library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Rust标准库中的网络原语
- en: Programming with TCP and UDP in Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rust中使用TCP和UDP进行编程
- en: Writing a TCP reverse proxy (project)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写TCP反向代理（项目）
- en: By the end of this chapter, you will have learned how to work with network addresses,
    determine address types, and do address conversions. You will also learn how to
    create and configure sockets and query on them. You will work with TCP listeners,
    create a TCP socket server, and receive data. Lastly, you'll put these concepts
    into practice through an example project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何处理网络地址、确定地址类型以及进行地址转换。你还将学习如何创建和配置套接字以及查询它们。你将使用TCP监听器、创建TCP套接字服务器并接收数据。最后，你将通过一个示例项目将这些概念付诸实践。
- en: It is important to learn these topics because sockets-based programming using
    TCP or UDP forms the basis for writing distributed programs. Sockets help two
    processes on different (or even the same) machines to establish communication
    with each other and exchange information. They form the foundation for practically
    all web and distributed applications on the internet, including how an internet
    browser accesses a web page and how a mobile application retrieves data from an
    API server. In this chapter, you will learn what kind of support is provided by
    the Rust standard library for *socket-based* network communications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 学习这些主题非常重要，因为基于套接字的编程使用TCP或UDP构成了编写分布式程序的基础。套接字帮助不同（甚至相同）机器上的两个进程相互建立通信并交换信息。它们构成了互联网上几乎所有Web和分布式应用的基础，包括互联网浏览器如何访问网页以及移动应用程序如何从API服务器检索数据。在本章中，你将了解Rust标准库为基于套接字的网络通信提供的支持类型。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Verify that `rustup`, `rustc`, and `cargo` have been installed correctly with
    the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证`rustup`、`rustc`和`cargo`是否已正确安装：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter11](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter11).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中代码的Git仓库可以在[https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter11](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter11)找到。
- en: Reviewing networking basics in Linux
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux中回顾网络基础知识
- en: 'The internet connects several different networks across the globe, enabling
    machines across networks to communicate with each other in different ways, including
    the **request-response** model (synchronous), **asynchronous messaging**, and
    **publish-subscribe**-style notifications. *Figure 11.1* shows an example of a
    connection between two networks:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网连接全球的多个不同网络，使网络中的机器能够以不同的方式相互通信，包括**请求-响应**模型（同步）、**异步消息**和**发布-订阅**风格的通告。*图11.1*展示了两个网络之间连接的一个示例：
- en: '![Figure 11.1 – Internet router connecting two networks](img/Figure_11.1_B16405.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 连接两个网络的互联网路由器](img/Figure_11.1_B16405.jpg)'
- en: Figure 11.1 – Internet router connecting two networks
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 连接两个网络的互联网路由器
- en: The internet also provides abstractions in the form of **networking protocols
    and standards** to make it easy for hosts on different networks to communicate
    with each other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网还提供了**网络协议和标准**的抽象形式，以简化不同网络上的主机之间的通信。
- en: Examples of standards include a common *host addressing format*, a combination
    of host address and port to define a *network endpoint*. The IP address of a host
    is a *32-bit* number for IPv4 addresses and a *128-bit* number for IPv6 addresses.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的例子包括一个通用的**主机寻址格式**，一个由主机地址和端口号组合来定义**网络端点**。IPv4地址的主机地址是一个**32位**数字，IPv6地址的主机地址是一个**128位**数字。
- en: Examples of network protocols include for web browsers to retrieve documents
    from web servers, **domain name system** (**DNS**) to map domain names to host
    addresses, the IP protocol to package and route packets of data across the internet,
    and TCP to add reliability and error handling for IP data packets.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议的例子包括网络浏览器从网络服务器检索文档，**域名系统**（**DNS**）将域名映射到主机地址，IP协议将数据包打包并在互联网上路由，以及TCP为IP数据包添加可靠性和错误处理。
- en: In particular, *networking protocols* are very important in defining how information
    is transmitted and interpreted by programs running in different host computers
    across different networks. The **TCP/IP protocol suite** is the foundation of
    how the internet, which we use on a daily basis, enables our digital world of
    information, transactions, and entertainment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，**网络协议**在定义不同网络上的不同主机上运行的程序如何传输和解释信息方面非常重要。**TCP/IP协议栈**是我们日常使用的互联网的基础，它使我们能够实现信息、交易和娱乐的数字世界。
- en: '*Figure 11.2* shows the layered TCP/IP protocol suite:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.2*显示了分层TCP/IP协议栈：'
- en: '![Figure 11.2 – Internet router connecting two networks](img/Figure_11.2_B16405.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 连接两个网络的互联网路由器](img/Figure_11.2_B16405.jpg)'
- en: Figure 11.2 – Internet router connecting two networks
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 连接两个网络的互联网路由器
- en: In the previous chapter, we discussed device drivers. In *Figure 11.2*, the
    lowest layer of the *TCP/IP protocol suite* shown – the **data link layer** –
    comprises the **device driver** and **network interface card** corresponding to
    the network medium used for communication between the hosts (for example, coax
    cable, fiber, or wireless). The data link layer assembles data packets received
    from the higher network (IP) layer into **data frames**, and transmits them over
    the physical link.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了设备驱动程序。在*图11.2*中，显示的*TCP/IP协议栈*的最低层——**数据链路层**——包括与用于主机之间通信的网络介质（例如，同轴电缆、光纤或无线）对应的**设备驱动程序**和**网络接口卡**。数据链路层将来自更高网络（IP）层的数据包组装成**数据帧**，并通过物理链路传输它们。
- en: The next layer up in the TCP/IP protocol suite is the **IP layer**, which is
    the most important layer in the TCP/IP stack. It assembles data into packets and
    sends them to the data link layer. The IP layer is also responsible for routing
    data across the internet. This is achieved by adding a header for each datagram
    (packet) transmitted, which includes the address of the remote host to which the
    packet should be transmitted. Two packets sent from host A to host B can take
    different routes through the internet. IP is a connectionless protocol, which
    means there is no communication channel created between two hosts to have multi-step
    communication. This layer just sends a data packet from one host IP address to
    another host IP address without any guarantees.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP协议栈的下一层是**IP层**，这是TCP/IP堆栈中最重要的一层。它将数据组装成数据包并发送到数据链路层。IP层还负责在互联网上路由数据。这是通过为每个传输的数据报（数据包）添加一个头部来实现的，该头部包括应将数据包传输到的远程主机的地址。从主机A发送到主机B的两个数据包可以通过互联网采取不同的路由。IP是一种无连接协议，这意味着在两个主机之间没有创建用于多步通信的通信通道。这一层只是将数据包从一个主机的IP地址发送到另一个主机的IP地址，而不提供任何保证。
- en: The next layer up in the TCP/IP protocol suite is the **transport layer**. Here,
    there are two popular protocols used on the internet – TCP and UDP. **TCP** stands
    for **transmission control protocol** and **UDP** is **user datagram protocol**.
    While the network (IP) layer is concerned with sending data packets between two
    hosts, the transport layer (TCP and UDP) is concerned with sending data streams
    between two processes (applications or programs) running on the same host or different
    hosts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP协议栈的下一层是**传输层**。在这里，互联网上使用两种流行的协议——TCP和UDP。**TCP**代表**传输控制协议**，而**UDP**是**用户数据报协议**。虽然网络（IP）层关注在两个主机之间发送数据包，但传输层（TCP和UDP）关注在同一个主机或不同主机上运行的两个进程（应用程序或程序）之间的数据流发送。
- en: If there are two applications running on a single host IP address, the way to
    uniquely identify each application is by using a *port number*. Each application
    that is involved in network communications listens on a specific port, which is
    a 16-bit number.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个应用程序运行在单个主机的IP地址上，唯一标识每个应用程序的方法是通过使用一个*端口号*。每个参与网络通信的应用程序都会监听一个特定的端口，它是一个16位的数字。
- en: Examples of popular ports are `80` for the *HTTP* protocol, `443` for the *HTTPS*
    protocol, and `22` for the *SSH* protocol. The combination of an IP address and
    a port number is called a **socket**. We'll see in this chapter how to work with
    sockets using the Rust standard library. UDP, like IP, is connectionless and does
    not incorporate any reliability mechanisms. But it is fast and has a low overhead
    compared to TCP. It is used in higher-level services, such as DNS, to get host
    IP addresses corresponding to a domain name.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 流行端口的例子有`80`用于*HTTP*协议，`443`用于*HTTPS*协议，以及`22`用于*SSH*协议。IP地址和端口号的组合称为**套接字**。我们将在本章中看到如何使用Rust标准库来处理套接字。UDP，像IP一样，是无连接的，并且不包含任何可靠性机制。但它的速度比TCP快，开销低。它用于高级服务，如DNS，以获取与域名对应的宿主IP地址。
- en: Compared to UDP, TCP provides a connection-oriented, reliable communication
    channel between two endpoints (application/user space programs) over which byte
    streams can be exchanged while preserving the sequence of data. It incorporates
    features such as **retransmission** in the case of errors, **acknowledgments**
    of packets received, and **timeouts**. We'll discuss TCP-based communication in
    detail in this chapter and later build a reverse proxy using TCP socket-based
    communications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP相比，TCP为两个端点（应用程序/用户空间程序）提供了一个面向连接、可靠的通信通道，可以在其中交换字节流，同时保持数据序列。它包含诸如错误情况下的**重传**、接收到的数据包的**确认**和**超时**等特性。我们将在本章详细讨论基于TCP的通信，并在稍后构建一个使用TCP套接字通信的反向代理。
- en: The uppermost layer in the TCP/IP protocol suite is the **application layer**.
    While the TCP layer is connection-oriented and works with byte streams, it has
    no knowledge of the semantics of a message transmitted. This is provided by the
    application layer. For example, HTTP, which is the most popular application protocol
    on the internet, uses HTTP request and response messages to communicate between
    **HTTP clients** (for example, internet browsers) and **HTTP servers** (for example,
    web servers). The application layer reads the byte streams received from the TCP
    layer and interprets them into HTTP messages, which are then processed by the
    application program that we write in Rust or other languages. There are several
    libraries (or crates) available in the Rust ecosystem that implement the HTTP
    protocol, so Rust programs can leverage them (or write their own) to send and
    receive HTTP messages. In the example project for this chapter, we will write
    some code to interpret an incoming HTTP request message and send back an HTTP
    response message.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP协议栈的最高层是**应用层**。虽然TCP层是面向连接的，并且与字节流一起工作，但它对传输的消息的语义一无所知。这是由应用层提供的。例如，HTTP，这是互联网上最受欢迎的应用协议，使用HTTP请求和响应消息在**HTTP客户端**（例如，互联网浏览器）和**HTTP服务器**（例如，Web服务器）之间进行通信。应用层读取从TCP层接收到的字节流，并将它们解释为HTTP消息，然后由我们用Rust或其他语言编写的应用程序程序处理。Rust生态系统中有几个库（或crate）实现了HTTP协议，因此Rust程序可以利用它们（或编写自己的）来发送和接收HTTP消息。在本章的示例项目中，我们将编写一些代码来解释传入的HTTP请求消息，并发送HTTP响应消息。
- en: The primary Rust Standard Library module for networking communications is `std::net`.
    This focuses on writing code for communicating using TCP and UDP. The Rust `std::net`
    module does not deal directly with the data link layer or application layer of
    the TCP/IP protocol suite. With this background, we are ready to understand the
    networking primitives provided in the Rust standard library for TCP and UDP communications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 标准库中用于网络通信的主要模块是 `std::net`。它专注于编写使用 TCP 和 UDP 进行通信的代码。Rust 的 `std::net`
    模块不直接处理 TCP/IP 协议套件的链路层或应用层。有了这个背景，我们就可以理解 Rust 标准库为 TCP 和 UDP 通信提供的网络原语。
- en: Understanding networking primitives in the Rust standard library
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Rust 标准库中的网络原语
- en: 'In this section, we''ll discuss the foundational data structures in the Rust
    standard library for networking. *Figure 11.3* lists the commonly used data structures:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论 Rust 标准库中用于网络的基础数据结构。*图 11.3* 列出了常用的数据结构：
- en: '![Figure 11.3 – Networking primitives in the Rust standard library](img/Figure_11.3_B16405.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – Rust 标准库中的网络原语](img/Figure_11.3_B16405.jpg)'
- en: Figure 11.3 – Networking primitives in the Rust standard library
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – Rust 标准库中的网络原语
- en: 'Let''s look at the data structures one by one:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个查看数据结构：
- en: '`Ipv4Addr`: This is a struct that stores a 32-bit integer representing an IPv4
    address, and provides associated functions and methods to set and query address
    values.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ipv4Addr`：这是一个结构体，用于存储表示 IPv4 地址的 32 位整数，并提供相关函数和方法来设置和查询地址值。'
- en: '`Ipv6Add`: This is a struct that stores a 128-bit integer representing an IPv6
    address, and provides associated functions and methods to query and set address
    values.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ipv6Addr`：这是一个结构体，用于存储表示 IPv6 地址的 128 位整数，并提供相关函数和方法来查询和设置地址值。'
- en: '`SocketAddrv4`: This is a struct representing an internet domain socket. It
    stores an IPv4 address and a 16-bit port number and provides associated functions
    and methods to set and query socket values.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocketAddrV4`：这是一个表示互联网域套接字的结构体。它存储一个 IPv4 地址和一个 16 位端口号，并提供相关函数和方法来设置和查询套接字值。'
- en: '`SocketAddrv6`: This is a struct representing an internet domain socket. It
    stores an IPv6 address and a 16-bit port number and provides associated functions
    and methods to set and query socket values.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocketAddrV6`：这是一个表示互联网域套接字的结构体。它存储一个 IPv6 地址和一个 16 位端口号，并提供相关函数和方法来设置和查询套接字值。'
- en: '`IpAddr`: This is an enum with two variants – `V4(Ipv4Addr)` and `V6(Ipv6Addr)`.
    This means that it can hold either an IPv4 host address or an IPv6 host address.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IpAddr`：这是一个枚举，有两个变体 – `V4(Ipv4Addr)` 和 `V6(Ipv6Addr)`。这意味着它可以存储 IPv4 主机地址或
    IPv6 主机地址。'
- en: '`SocketAddr`: This is an enum with two variants – `V4(SocketAddrV4)` and `V6(SocketAddrV6)`.
    This means that it can hold either an IPv4 socket address or an IPv6 socket address.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocketAddr`：这是一个枚举，有两个变体 – `V4(SocketAddrV4)` 和 `V6(SocketAddrV6)`。这意味着它可以存储
    IPv4 套接字地址或 IPv6 套接字地址。'
- en: Note
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The size of an *Ipv6* address might vary, depending on the target operating
    system architecture.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IPv6 地址的大小可能会根据目标操作系统架构而变化。
- en: Let's now see a few examples of how to use them. We'll start by creating IPv4
    and IPv6 addresses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用它们的几个示例。我们将从创建 IPv4 和 IPv6 地址开始。
- en: 'In the example shown next, we''re creating IPv4 and IPv6 addresses using the
    `std::net` module and using built-in methods to query on the created addresses.
    The `is_loopback()` method confirms whether the address corresponds to `localhost`,
    and the `segments()` method returns the various segments of the IP address. Note
    also that the `std::net` module provides a special constant, `Ipv4Addr::LOCALHOST`,
    which can be used to initialize the IP address with the `localhost` (loopback)
    address:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用 `std::net` 模块创建 IPv4 和 IPv6 地址，并使用内置方法查询创建的地址。`is_loopback()` 方法确认地址是否对应于
    `localhost`，而 `segments()` 方法返回 IP 地址的各个段。注意，`std::net` 模块提供了一个特殊常量，`Ipv4Addr::LOCALHOST`，它可以用来使用
    `localhost`（环回）地址初始化 IP 地址：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following example shows how to use the `IpAddr` enum. In this example,
    usage of the `IpAddr` enum is shown to create IPv4 and IPv6 addresses. The `IpAddr`
    enum helps us to define IP addresses in a more generic way in our program data
    structures and gives us the flexibility to work with both IPv4 and IPv6 addresses
    in our programs:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用 `IpAddr` 枚举。在这个示例中，展示了如何使用 `IpAddr` 枚举创建 IPv4 和 IPv6 地址。`IpAddr`
    枚举帮助我们以更通用的方式在我们的程序数据结构中定义 IP 地址，并允许我们在程序中灵活地处理 IPv4 和 IPv6 地址：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now turn our attention to sockets. As discussed earlier, sockets comprise
    an IP address and a port. Rust has separate data structures for both IPv4 and
    IPv6 sockets. Let''s see an example next. Here, we''re creating a new IPv4 socket,
    and querying for the IP address and port numbers from the constructed socket,
    using the `ip()` and `port()` methods, respectively:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向套接字。如前所述，套接字由一个 IP 地址和一个端口号组成。Rust 为 IPv4 和 IPv6 套接字都有单独的数据结构。接下来，让我们看一个示例。在这里，我们创建了一个新的
    IPv4 套接字，并使用 `ip()` 和 `port()` 方法分别查询构建的套接字中的 IP 地址和端口号：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: IP addresses and sockets represent the foundational data structures for network
    programming using the Rust standard library. In the next section, we'll see how
    to write programs in Rust that can communicate over TCP and UDP protocols.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址和套接字是使用 Rust 标准库进行网络编程的基础数据结构。在下一节中，我们将看到如何编写可以在 TCP 和 UDP 协议上通信的 Rust
    程序。
- en: Programming with TCP and UDP in Rust
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 编程 TCP 和 UDP
- en: As discussed earlier, TCP and UDP are the fundamental transport layer network
    protocols for the internet. In this section, let's first write a UDP server and
    client. Then we'll look at doing the same using TCP.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TCP 和 UDP 是互联网的基本传输层网络协议。在本节中，我们首先编写一个 UDP 服务器和客户端。然后，我们将看看如何使用 TCP 做同样的事情。
- en: 'Create a new project called `tcpudp` where we will write the TCP and UDP servers
    and clients:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `tcpudp` 的新项目，我们将在此项目中编写 TCP 和 UDP 服务器和客户端：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's first look at network communication using UDP.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看使用 UDP 的网络通信。
- en: Writing a UDP server and client
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 UDP 服务器和客户端
- en: In this section, we'll learn how to configure UDP sockets, and how to send and
    receive data. We'll write both a UDP server and a UDP client.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何配置 UDP 套接字，以及如何发送和接收数据。我们将编写一个 UDP 服务器和一个 UDP 客户端。
- en: Starting with the UDP server
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 UDP 服务器开始
- en: 'In the example shown, we''re creating a UDP server by binding to a local socket
    using `UdpSocket::bind`. We''re then creating a fixed-size buffer, and listening
    for incoming data streams in a loop. If data is received, we are spawning a new
    thread to process the data by echoing it back to the sender. As we already covered
    how to spawn new threads in [*Chapter 9*](B16405_09_Final_NM_ePUB.xhtml#_idTextAnchor150),
    *Managing Concurrency*, it shouldn''t need explanation again here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们通过使用 `UdpSocket::bind` 将其绑定到本地套接字来创建一个 UDP 服务器。然后，我们创建一个固定大小的缓冲区，并在循环中监听传入的数据流。如果收到数据，我们将通过将数据回显给发送者来创建一个新的线程以处理数据。由于我们已经介绍了如何在
    [*第 9 章*](B16405_09_Final_NM_ePUB.xhtml#_idTextAnchor150) 中创建新线程，*管理并发*，这里不再需要解释：
- en: tcpudp/src/bin/[udp-server.rs](http://udp-server.rs)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: tcpudp/src/bin/[udp-server.rs](http://udp-server.rs)
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Writing a UDP client to send data packets to the server
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个 UDP 客户端以向服务器发送数据包
- en: 'In the code shown, we''re first asking the standard library to bind to a local
    port (by providing an address port combination of `0.0.0.0:0`, which allows the
    operating system to pick a transient IP address/port to send the datagram from).
    Then, we are trying to connect to the remote socket where the server is running,
    and displaying an error in the case of failure to connect. In the case of a successful
    connection, we are printing out the socket address of the peer using the `peer_addr()`
    method. Lastly, we are using the `send()` method to send a message to the remote
    socket (server):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们首先要求标准库绑定到本地端口（通过提供一个地址端口组合 `0.0.0.0:0`，这允许操作系统选择一个临时的 IP 地址/端口来发送数据报）。然后，我们尝试连接到运行服务器的远程套接字，并在连接失败时显示错误。在成功连接的情况下，我们使用
    `peer_addr()` 方法打印出对等方的套接字地址。最后，我们使用 `send()` 方法向远程套接字（服务器）发送消息：
- en: tcpudp/src/bin/[udp-client.rs](http://udp-client.rs)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: tcpudp/src/bin/[udp-client.rs](http://udp-client.rs)
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the UDP server with the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行 UDP 服务器：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From a separate terminal, run the UDP client with the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，运行以下 UDP 客户端：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You'll see the message received at the server, which was sent from the client.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到服务器接收到的消息，该消息是从客户端发送的。
- en: We've seen so far how to write programs in Rust to do communications over UDP.
    Let's now look at how TCP communications are done.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何编写 Rust 程序来进行 UDP 通信。现在，让我们看看 TCP 通信是如何进行的。
- en: Writing a TCP server and client
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 TCP 服务器和客户端
- en: In this section, we'll learn how to configure TCP listeners, create a TCP socket
    server, and send and receive data over TCP. We'll write both a TCP server and
    a TCP client.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何配置 TCP 监听器，创建 TCP 套接字服务器，并在 TCP 上发送和接收数据。我们将编写一个 TCP 服务器和一个 TCP
    客户端。
- en: 'We''ll start with the TCP server. In the code shown next, we''re using `TcpListener::bind`
    to create a TCP server listening on a socket. Then, we use the `incoming()` method,
    which returns an iterator of incoming connections. Each connection returns a TCP
    stream that can be read from using the `stream.read()` method. We''re reading
    the data and printing out the values. Also, we''re echoing back the received data
    over the connection using the `stream.write()` method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 TCP 服务器开始。在下面的代码中，我们使用 `TcpListener::bind` 创建一个监听套接字的 TCP 服务器。然后，我们使用 `incoming()`
    方法，该方法返回一个传入连接的迭代器。每个连接返回一个可以通过 `stream.read()` 方法读取的 TCP 流。我们正在读取数据并打印出值。此外，我们使用
    `stream.write()` 方法通过连接回显接收到的数据：
- en: tcpudp/src/bin/[tcp-server.rs](http://tcp-server.rs)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: tcpudp/src/bin/[tcp-server.rs](http://tcp-server.rs)
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This concludes the code for the TCP server. Let's now write a TCP client to
    send some data to the TCP server.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 TCP 服务器的代码。现在让我们编写一个 TCP 客户端，向 TCP 服务器发送一些数据。
- en: 'In the TCP client code shown next, we''re using the `TcpStream::connect` function
    to connect to a **remote socket** where the server is listening. This function
    returns a **TCP stream**, which can be *read from* and *written to* (as we saw
    in the previous example). Here, we''re first going to write some data to the TCP
    stream, and then read back the response received from the server:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 TCP 客户端代码中，我们使用 `TcpStream::connect` 函数连接到服务器正在监听的**远程套接字**。此函数返回一个**TCP
    流**，可以*读取*和*写入*（如前例所示）。在这里，我们首先将一些数据写入 TCP 流，然后读取从服务器收到的响应：
- en: tcpudp/src/bin/[tcp-client.rs](http://tcp-client.rs)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: tcpudp/src/bin/[tcp-client.rs](http://tcp-client.rs)
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the TCP server with the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行 TCP 服务器：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From a separate terminal, run the TCP client with the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，使用以下命令运行 TCP 客户端：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You'll see the message that was sent from the client being received at the server
    and echoed back.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到客户端发送的消息在服务器上被接收并回显。
- en: This concludes this section on performing TCP and UDP communications using the
    Rust standard library. In the next section, let's use the concepts learned so
    far to build a TCP reverse proxy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了关于使用 Rust 标准库进行 TCP 和 UDP 通信的章节。在下一节中，我们将使用到目前为止学到的概念来构建一个 TCP 反向代理。
- en: Writing a TCP reverse proxy (project)
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 TCP 反向代理（项目）
- en: In this section, we will demonstrate the basic functionality of a **TCP reverse
    proxy** using just the Rust standard library, without the use of any external
    libraries or frameworks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将仅使用 Rust 标准库演示 **TCP 反向代理**的基本功能，而不使用任何外部库或框架。
- en: 'A proxy server is an intermediary software service that is used while navigating
    across multiple networks on the internet. There are two types of proxy servers
    – a **forward proxy** and a **reverse proxy**. A forward proxy acts as an intermediary
    for clients making requests out to the internet, and a reverse proxy acts as an
    intermediary for servers. *Figure 11.4* illustrates the usage of forward and reverse
    proxy servers:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代理服务器是一种在互联网上跨越多个网络导航时使用的中间件软件服务。代理服务器有两种类型——**正向代理**和**反向代理**。正向代理作为向互联网发出请求的客户端的中介，而反向代理作为服务器的中介。*图
    11.4* 展示了正向和反向代理服务器的作用：
- en: '![Figure 11.4 – Types of proxy servers](img/Figure_11.4_B16405.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 代理服务器类型](img/Figure_11.4_B16405.jpg)'
- en: Figure 11.4 – Types of proxy servers
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 代理服务器类型
- en: Forward proxies act as gateways to the internet for a group of client machines.
    They help individual client machines to hide their IP addresses while browsing
    the internet. They also help to enforce organizational policies for machines within
    a network to access the internet, such as restricting websites to visit.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正向代理作为一组客户端机器访问互联网的网关。它们帮助单个客户端机器在浏览互联网时隐藏其 IP 地址。它们还帮助在网络内的机器强制执行访问互联网的组织策略，例如限制访问的网站。
- en: While a forward proxy acts on behalf of clients, a reverse proxy acts on behalf
    of hosts (for example, web servers). They hide the identity of the backend servers
    from the clients. The clients only make a request to the reverse proxy server
    address/domain, and the reverse proxy server, in turn, knows how to route that
    request to the backend server (also sometimes called the **origin server**), and
    returns the response received from the origin server to the requesting client.
    A reverse proxy can also be used to perform other functions, such as load balancing,
    caching, and compression. We will, however, just focus on demonstrating the core
    concept of a reverse proxy by directing requests received from clients to the
    backend origin servers and routing responses back to the requesting client.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当正向代理代表客户端行动时，反向代理代表主机（例如，Web服务器）行动。它们隐藏后端服务器的身份信息，让客户端无法得知。客户端只向反向代理服务器地址/域名发送请求，而反向代理服务器则知道如何将这个请求路由到后端服务器（有时也称为**原始服务器**），并将从原始服务器接收到的响应返回给请求的客户端。反向代理还可以用于执行其他功能，如负载均衡、缓存和压缩。然而，我们将只通过将客户端接收到的请求定向到后端原始服务器，并将响应路由回请求的客户端来演示反向代理的核心概念。
- en: 'To demonstrate a working *reverse proxy*, we will build two servers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个工作的**反向代理**，我们将构建两个服务器：
- en: '**Origin server**: TCP server (which understands limited HTTP semantics).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始服务器**：TCP服务器（理解有限的HTTP语义）。'
- en: '**Reverse proxy server**: Client requests coming to this server will be directed
    to the *origin server*, and responses from the origin server will be routed back
    to the client.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反向代理服务器**：到达此服务器的客户端请求将被定向到**原始服务器**，原始服务器的响应将被路由回客户端。'
- en: 'Create a new project to write the origin and proxy servers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目来编写原始和代理服务器：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create two files: `tcpproxy/src/bin/`[origin.rs](http://origin.rs) and `tcpproxy/src/bin/`[proxy.rs](http://proxy.rs).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个文件：`tcpproxy/src/bin/`[origin.rs](http://origin.rs) 和 `tcpproxy/src/bin/`[proxy.rs](http://proxy.rs)。
- en: 'Let''s start with the code for the origin server. This server will do the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从原始服务器的代码开始。这个服务器将执行以下操作：
- en: Receive an incoming HTTP request.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收传入的HTTP请求。
- en: Extract the first line of the request (called the **HTTP request line**).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取请求的第一行（称为**HTTP请求行**）。
- en: Accept a `GET HTTP` request on a specific route (for example, `/order/status/1`).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定的路由上接受`GET HTTP`请求（例如，`/order/status/1`）。
- en: 'Return the status of the order. We will demonstrate parsing of the HTTP request
    line to retrieve the order number and just send back a response stating **Order
    status for order number 1 is: Shipped**.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回订单的状态。我们将演示解析HTTP请求行以检索订单号，并仅发送一个响应，声明**订单号1的状态为：已发货**。
- en: Let's see the code now for the origin server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看原始服务器的代码。
- en: Writing the origin server – structs and methods
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写原始服务器 – 结构体和方法
- en: We'll first see the code for module imports, struct definitions and methods.
    Then, we'll see the code for the `main()` function. All the code for the origin
    server can be found in `tcpproxy/src/bin/`[origin.rs](http://origin.rs).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将看到模块导入、结构体定义和方法的代码。然后，我们将看到`main()`函数的代码。原始服务器的所有代码都可以在`tcpproxy/src/bin/`[origin.rs](http://origin.rs)中找到。
- en: 'The module imports are shown first in the code snippet. We''re importing various
    modules from the standard library here. The `std::io` module will be used to read
    and write to the TCP stream, and the `std::net` module provides the primitives
    for the TCP listener, sockets, and addresses. The string modules (`std::str` and
    `std::String`) are used for string manipulations and handling string parsing errors:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段首先显示了模块导入。我们在这里从标准库中导入各种模块。`std::io`模块将用于读取和写入TCP流，`std::net`模块提供了TCP监听器、套接字和地址的原语。字符串模块（`std::str`和`std::String`）用于字符串操作和处理字符串解析错误：
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[origin.rs](http://origin.rs)
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, let's declare a struct to hold the incoming HTTP request line (the first
    line of the multi-line HTTP request message). We'll also write some helper methods
    for this struct.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们声明一个结构体来保存传入的HTTP请求行（多行HTTP请求消息的第一行）。我们还将为这个结构体编写一些辅助方法。
- en: 'In the code shown next, we''ll declare a `RequestLine` struct consisting of
    three fields – the HTTP method, the path of the resource requested, and the HTTP
    protocol version supported by the internet browser or another HTTP client sending
    the request. We''ll also write some methods to return the values of the struct
    members. Custom logic will be implemented for the `get_order_number()` method.
    If we get a request for a resource with the `/order/status/1` path, we will split
    this string by `/`, and return the last part of the string, which is order number
    `1`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将声明一个包含三个字段的`RequestLine`结构体——HTTP方法、请求的资源路径以及发送请求的互联网浏览器或其他HTTP客户端支持的HTTP协议版本。我们还将编写一些方法来返回结构体成员的值。`get_order_number()`方法将实现自定义逻辑。如果我们收到一个请求`/order/status/1`路径的资源，我们将通过`/`分割这个字符串，并返回字符串的最后一部分，即顺序号`1`：
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[origin.rs](http://origin.rs)
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s also implement the `FromStr` trait for the `RequestLine` struct so that
    we can convert the incoming HTTP request line (string) into our internal Rust
    data structure – `RequestLine`. The structure of the HTTP request line is shown
    here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也为`RequestLine`结构体实现`FromStr`特质，这样我们就可以将传入的HTTP请求行（字符串）转换为我们的内部Rust数据结构——`RequestLine`。HTTP请求行的结构如下所示：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These three values are separated by white spaces and are all present in the
    first line of an HTTP request message. In the program shown, we''re going to parse
    these three values and load them into the `RequestLine` struct. Later, we will
    further parse the path member and extract the order number from it, for processing:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个值由空格分隔，并且都出现在HTTP请求消息的第一行中。在下面的程序中，我们将解析这三个值并将它们加载到`RequestLine`结构体中。稍后，我们将进一步解析路径成员并从中提取顺序号，以进行处理：
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[origin.rs](http://origin.rs)
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've so far seen the module imports, struct definition, and methods for the
    `RequestLine` struct. Let's now write the `main()` function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了模块导入、结构体定义和`RequestLine`结构体的方法。现在让我们编写`main()`函数。
- en: Writing the origin server – the main() function
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写原始服务器——`main`函数
- en: 'In the `main` function of the origin server, we are going to do the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始服务器的`main`函数中，我们将执行以下操作：
- en: Start the TCP server.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动TCP服务器。
- en: Listen for incoming connections.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听传入的连接。
- en: 'For each incoming connection, we will then perform the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个传入的连接，我们将执行以下操作：
- en: Read the first line of the incoming HTTP request message and convert it into
    a `RequestLine` struct.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取传入的HTTP请求消息的第一行并将其转换为`RequestLine`结构体。
- en: Construct the HTTP response message and write it to the TCP stream.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建HTTP响应消息并将其写入TCP流。
- en: Let's now see the code for the main function in two parts – starting the TCP
    server and listening for connections, and processing incoming HTTP requests.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们分两部分看看`main`函数的代码——启动TCP服务器并监听连接，以及处理传入的HTTP请求。
- en: Starting the TCP server and listening for connections
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动TCP服务器并监听连接
- en: 'To start the TCP server, we will construct a socket address, and bind to a
    socket using `TcpStream::bind`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动TCP服务器，我们将构建一个套接字地址，并使用`TcpStream::bind`将其绑定到套接字：
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[origin.rs](http://origin.rs)
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we''ll listen for incoming connections, and read from the stream for
    each connection:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将监听传入的连接，并从每个连接的流中读取：
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[origin.rs](http://origin.rs)
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's now see the processing of the incoming request.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看传入请求的处理过程。
- en: Processing incoming HTTP requests
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理传入的HTTP请求
- en: 'For processing incoming requests, the first step is to retrieve the first line
    of the request message and convert it into a `RequestLine` struct. In the code
    shown next, we''re using the `lines()` method to return an iterator of lines.
    We''re then retrieving the first line of the HTTP request using `lines().next()`.
    We are converting this into a `RequestLine` struct using `RequestLine::from_str()`.
    This is possible only because we have implemented the `FromStr` trait for the
    `RequestLine` struct:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理传入的请求，第一步是检索请求消息的第一行并将其转换为`RequestLine`结构体。在下面的代码中，我们使用`lines()`方法返回一个行迭代器。然后，我们使用`lines().next()`获取HTTP请求的第一行。我们使用`RequestLine::from_str()`将其转换为`RequestLine`结构体。这之所以可能，是因为我们已经为`RequestLine`结构体实现了`FromStr`特质：
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[origin.rs](http://origin.rs)
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have parsed the required data into the `RequestLine` struct, we
    can process it and send the HTTP response back. Let''s see the code. If the message
    received is not a `GET` request, if the path in the request message does not start
    with `/order/status`, or if the order number is not provided, construct an HTTP
    response message with the `404 Not found` HTTP status code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所需数据解析到`RequestLine`结构体中，我们可以处理它并发送HTTP响应。让我们看看代码。如果接收到的消息不是`GET`请求，如果请求消息中的路径不以`/order/status`开头，或者如果未提供订单号，则使用`404
    Not found` HTTP状态码构造HTTP响应消息：
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[origin.rs](http://origin.rs)
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the request is correctly formatted to retrieve the order status for an order
    number, we should construct an HTML response message with the `200 OK` HTTP status
    code for sending the response back to the client:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求格式正确，用于检索订单号的订单状态，我们应该构造一个带有`200 OK` HTTP状态码的HTML响应消息，以将响应发送回客户端：
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[origin.rs](http://origin.rs)
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, let''s write the constructed HTTP response message to the TCP stream:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将构造的HTTP响应消息写入TCP流：
- en: tcpproxy/src/bin/[origin.rs](http://origin.rs)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[origin.rs](http://origin.rs)
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This concludes the code for the origin server. The complete code can be found
    in the Packt GitHub repo for `Chapter12` at `tcpproxy/src/bin/`[origin.rs](http://origin.rs).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了原始服务器的代码。完整的代码可以在Packt GitHub仓库的`Chapter12`目录下的`tcpproxy/src/bin/`[origin.rs](http://origin.rs)中找到。
- en: 'Run the program with the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see the server start with the following message:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到服务器启动时显示以下消息：
- en: '**Running on port: 3000**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行在端口：3000**'
- en: 'In a browser window, enter the following URL:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，输入以下URL：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should see the following response displayed on the browser screen:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在浏览器屏幕上看到以下响应：
- en: '**Order status for order number 2 is: Shipped**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**订单号2的订单状态是：已发货**'
- en: 'Try entering a URL with an invalid path, such as the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试输入一个无效路径的URL，如下所示：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see the following message displayed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下消息显示：
- en: '**Sorry, this page is not found**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**抱歉，此页面未找到**'
- en: 'Further, you can provide a valid path but without an order number, such as
    the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以提供一个有效的路径，但不包含订单号，如下所示：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You''ll see the following error message displayed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下错误消息显示：
- en: '**Please provide valid order number**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**请提供有效的订单号**'
- en: With this, we conclude the section on the origin server. Let's now write the
    code for the *reverse proxy*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了原始服务器部分的编写。现在让我们编写*反向代理*的代码。
- en: Writing the reverse proxy server
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写反向代理服务器
- en: Let's dive into the code for the reverse proxy, starting with the module imports.
    All of the code for this reverse proxy server can be found in `tcpproxy/src/bin/`[proxy.rs](http://proxy.rs).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到反向代理的代码，从模块导入开始。这个反向代理服务器的所有代码都可以在`tcpproxy/src/bin/`[proxy.rs](http://proxy.rs)中找到。
- en: Let's first look at the module imports.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看模块导入。
- en: 'The `std::env` module is used to read command-line parameters. `std::io` is
    used to read and write to TCP streams. `std::net` is the main module for communications,
    as we have seen. `std::process` is used to exit the program in case of unrecoverable
    errors. `std::thread` is used to spawn a new thread for processing incoming requests:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::env`模块来读取命令行参数。`std::io`用于读取和写入TCP流。`std::net`是我们看到的主要通信模块。`std::process`用于在无法恢复的错误情况下退出程序。`std::thread`用于为处理传入请求创建新线程：
- en: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let's write the `main()` function next. When we start the reverse proxy server,
    let's accept two command-line parameters, corresponding to socket addresses of
    the *reverse proxy* and *origin server*, respectively. If two command-line parameters
    are not provided by the user, then print out an error message and exit the program.
    Then, let's parse the command-line inputs and start the server using `TcpListener::bind`.
    After binding to the local port, we connect to the origin server and print out
    an error message in the case of failure to connect.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来编写`main()`函数。当我们启动反向代理服务器时，让我们接受两个命令行参数，分别对应于*反向代理*和*原始服务器*的套接字地址。如果用户没有提供两个命令行参数，则打印出错误消息并退出程序。然后，让我们解析命令行输入并使用`TcpListener::bind`启动服务器。在绑定到本地端口后，我们连接到原始服务器，并在连接失败时打印出错误消息。
- en: 'Place the following code within the `main()` function block:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放在`main()`函数块中：
- en: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After starting the server, we must listen for incoming connections. For every
    connection, spawn a separate thread to handle the connection. The thread in turn
    calls the `handle_connection()` function, which we will describe shortly. Then,
    join the child thread handles with the main thread to make sure that the `main()`
    function does not *exit* before the child threads are completed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动服务器后，我们必须监听传入的连接。对于每个连接，创建一个单独的线程来处理连接。该线程随后调用`handle_connection()`函数，我们将在稍后描述。然后，将子线程处理与主线程连接起来，以确保在子线程完成之前`main()`函数不会*退出*：
- en: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This concludes the `main()` function. Let''s now write the code for `handle_function()`.
    This contains the core logic for proxying to the origin server:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`main()`函数。现在让我们编写`handle_function()`的代码。这包含了代理到原始服务器的核心逻辑：
- en: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: tcpproxy/src/bin/[proxy.rs](http://proxy.rs)
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For ease of debugging, the four key steps involved in the proxy functionality
    are marked in the code and also printed out to the console:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于调试，涉及代理功能的四个关键步骤已在代码中标记，并打印到控制台：
- en: In the first step, we read the incoming data from the incoming *client connection*.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步，我们从传入的*客户端连接*读取数据。
- en: In the second step, we open a new TCP stream with the *origin server*, and send
    the data we received from the *client* to the origin server.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步，我们与*原始服务器*打开一个新的TCP流，并将我们从*客户端*收到的数据发送到原始服务器。
- en: In the third step, we are reading the response we received from the origin server
    and store the data in a buffer.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三步，我们正在读取我们从原始服务器收到的响应，并将数据存储在缓冲区中。
- en: In the final step, we are using the data received in the previous step to write
    to the TCP stream corresponding to the client that sent the original request.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，我们使用上一步收到的数据写入对应于发送原始请求的客户端的TCP流。
- en: This concludes the code for reverse proxy. We've kept the functionality simple
    and handled only the base case. As an extra exercise, you can add edge cases to
    make the server more robust, and also add additional functionality such as load-balancing
    and caching.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了反向代理的代码。我们保持了功能的简单性，并只处理了基本案例。作为额外的练习，你可以添加边缘情况以使服务器更健壮，还可以添加如负载均衡和缓存等附加功能。
- en: This concludes the code for the origin server. The complete code can be found
    in the Packt GitHub repo for `Chapter12` at `tcpproxy/src/bin/`[proxy.rs](http://proxy.rs).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了原始服务器的代码。完整的代码可以在Packt GitHub仓库的`Chapter12`目录下的`tcpproxy/src/bin/`[proxy.rs](http://proxy.rs)中找到。
- en: 'First, start the origin server with the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令启动原始服务器：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, run the proxy server with the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令运行代理服务器：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first command-line parameter that we pass is used by the *reverse proxy*
    server to bind to the specified socket address. The second command-line parameter
    corresponds to the socket address at which the *origin server* is running. This
    is the address to which we have to proxy the incoming requests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的第一个命令行参数被*反向代理*服务器用于绑定到指定的套接字地址。第二个命令行参数对应于*原始服务器*运行的套接字地址。这是我们必须代理传入请求的地址。
- en: Let's now run the same tests from a browser that we did for the origin server,
    only this time we'll send the request to port `3001`, where the reverse proxy
    server is running. You'll notice that you will get similar response messages.
    This demonstrates that the requests sent by the internet browser client are being
    proxied by the reverse proxy server to the backend origin server, and the response
    received from the origin server is being routed back to the browser client.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从浏览器运行与原始服务器相同的测试，但这次我们将请求发送到运行反向代理服务器的端口`3001`。你会注意到你会得到类似的消息响应。这表明由互联网浏览器客户端发送的请求正在由反向代理服务器代理到后端原始服务器，并且从原始服务器收到的响应正在被路由回浏览器客户端。
- en: 'You should see the server start with the following message:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到服务器以以下消息启动：
- en: '**Running on Addr:127.0.0.1, Port:3001**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行在地址：127.0.0.1，端口：3001**'
- en: 'In a browser window, enter the following URL:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，输入以下URL：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see the following response displayed on the browser screen:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在浏览器屏幕上看到以下响应显示：
- en: '**Order status for order number 2 is: Shipped**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**订单号2的订单状态为：已发货**'
- en: 'Try entering a URL with an invalid path, such as the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试输入一个无效路径的URL，例如以下内容：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see the following message displayed:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下消息显示：
- en: '**Sorry, this page is not found**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**抱歉，此页面未找到**'
- en: 'Further, you can provide a valid path but without an order number, such as
    the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以提供一个有效的路径，但不包括订单号，例如以下内容：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You''ll see the following error message displayed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下错误信息显示：
- en: '**Please provide valid order number**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**请提供有效的订单号**'
- en: This concludes this example project, where we wrote two servers – a TCP origin
    server and a simple TCP reverse proxy server.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这个示例项目，其中我们编写了两个服务器——一个TCP源服务器和一个简单的TCP反向代理服务器。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the basics of networking in Linux/Unix. We learned
    about the networking primitives in the Rust standard library, including data structures
    for IPv4 and IPv6 addresses, IPv4 and IPv6 sockets, and associated methods. We
    learned how to create addresses, as well as create sockets and query them.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了Linux/Unix中的网络基础知识。我们学习了Rust标准库中的网络原语，包括IPv4和IPv6地址的数据结构，IPv4和IPv6套接字以及相关方法。我们学习了如何创建地址，以及如何创建套接字并查询它们。
- en: We then learned how to use UDP sockets and wrote a UDP client and server. We
    also reviewed the TCP communication basics, including how to configure TCP listeners,
    how to create a TCP socket server, and how to send and receive data. Lastly, we
    wrote a project consisting of two servers – an *origin server* and a *reverse
    proxy server* that routes requests to the origin server.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何使用UDP套接字，并编写了UDP客户端和服务器。我们还回顾了TCP通信的基础知识，包括如何配置TCP监听器，如何创建TCP套接字服务器，以及如何发送和接收数据。最后，我们编写了一个由两个服务器组成的项目——一个*源服务器*和一个*反向代理服务器*，该服务器将请求路由到源服务器。
- en: In the next and final chapter of the book, we'll cover another important topic
    for system programming – **unsafe Rust and FFI**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章和最后一章中，我们将涵盖系统编程的另一个重要主题——**不安全Rust和FFI**。
