<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-98"><em class="italic"><a id="_idTextAnchor114"/>Chapter 9</em>: Crossing the Boundary between Rust and WebAssembly</h1>
			<p>So far, we have only seen examples of sharing simple numbers between JavaScript and WebAssembly. In the last section, we saw how <strong class="source-inline">wasm-bindgen</strong> helps to pass a string from Rust to JavaScript with ease. In this chapter, we will explore how <strong class="source-inline">wasm-bindgen</strong> makes it easier to convert more complex data types between JavaScript and WebAssembly via Rust. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Sharing classes from Rust with JavaScript</li>
				<li>Sharing classes from JavaScript with Rust</li>
				<li>Calling the JavaScript API via WebAssembly</li>
				<li>Calling closures via WebAssembly</li>
				<li>Importing the JavaScript function into Rust</li>
				<li>Calling a web API via WebAssembly</li>
			</ul>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor115"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/09-rust-wasm-boundary">https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/09-rust-wasm-boundary</a>.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor116"/>Sharing classes from Rust with JavaScript </h1>
			<p><strong class="source-inline">wasm-bindgen</strong> enables <a id="_idIndexMarker381"/>sharing classes <a id="_idIndexMarker382"/>from JavaScript with Rust and vice versa <a id="_idIndexMarker383"/>using simple annotations. It handles all the boilerplate stuff, such as translating a value from JavaScript to WebAssembly or WebAssembly to JavaScript, complex memory manipulations, and error-prone pointer arithmetic. Thus, <strong class="source-inline">wasm-bindgen</strong> makes everything easier.</p>
			<p>Let's see how <a id="_idIndexMarker384"/>easy it is to share classes <a id="_idIndexMarker385"/>between JavaScript and WebAssembly <a id="_idIndexMarker386"/>(from Rust):</p>
			<ol>
				<li>Create a new project:<p class="source-code"><strong class="bold">$ cargo new --lib class_world</strong></p><p class="source-code"><strong class="bold">Created library `class_world` package</strong></p></li>
				<li>Define the <strong class="source-inline">wasm-bindgen</strong> dependency for the project. Open the <strong class="source-inline">cargo.toml</strong> file and add the following content:<p class="source-code">[package]</p><p class="source-code">name = "class_world"</p><p class="source-code">version = "0.1.0"</p><p class="source-code">authors = ["Sendil Kumar"]</p><p class="source-code">edition = "2018"</p><p class="source-code">[lib]</p><p class="source-code">crate-type = ["cdylib"]</p><p class="source-code">[dependencies]</p><p class="source-code">wasm-bindgen = "0.2.68"</p></li>
				<li>Open the <strong class="source-inline">src/lib.rs</strong> file and replace the content with the following:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub struct Point {</p><p class="source-code">    x: i32,</p><p class="source-code">    y: i32,</p><p class="source-code">}</p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">impl Point {</p><p class="source-code">    pub fn new(x: i32, y: i32) -&gt; Point {</p><p class="source-code">        Point { x: x, y: y}</p><p class="source-code">    }</p><p class="source-code">    pub fn get_x(&amp;self) -&gt; i32 {</p><p class="source-code">        self.x</p><p class="source-code">    }</p><p class="source-code">    pub fn get_y(&amp;self) -&gt; i32 {</p><p class="source-code">        self.y</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    pub fn set_x(&amp;mut self, x: i32) {</p><p class="source-code">        self.x = x;</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    pub fn set_y(&amp;mut self, y:i32) {</p><p class="source-code">        self.y = y;</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    pub fn add(&amp;mut self, p: Point) {</p><p class="source-code">        self.x = self.x + p.x;</p><p class="source-code">        self.y = self.y + p.y;</p><p class="source-code">     }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">&amp;mut</strong> before the argument specifies that the argument (in this case, <strong class="source-inline">self</strong>) is a mutable reference.</p></li>
			</ol>
			<p>Rust does not have classes but we can define a class via a struct. The <strong class="source-inline">Point</strong> struct contains getters, setters, and an <strong class="source-inline">add</strong> function. This is normal Rust code with only the <strong class="source-inline">#[wasm_bindgen]</strong> annotation added. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The functions and struct were explicitly marked <strong class="source-inline">pub</strong>. The <strong class="source-inline">pub</strong> modifier means the function is public and will be exported.</p>
			<ol>
				<li value="4">Generate the WebAssembly module using Cargo:<p class="source-code">$ cargo build --target=wasm32-unknown-unknown</p></li>
				<li>Use the <strong class="source-inline">wasm-bindgen</strong> CLI to generate the binding file for the WebAssembly module generated:<p class="source-code">$ wasm-bindgen target/wasm32-unknown-</p><p class="source-code">  unknown/debug/class_world.wasm --out-dir .</p></li>
			</ol>
			<p>This will <a id="_idIndexMarker387"/>generate the binding files <a id="_idIndexMarker388"/>and type definition files as we <a id="_idIndexMarker389"/>have seen in the previous chapter. Let's look at the <strong class="source-inline">class_world.js</strong> file first. This file will be similar to the file generated in previous chapters except for the <strong class="source-inline">Point</strong> class. The <strong class="source-inline">Point</strong> class has all the getters, the setters, and the <strong class="source-inline">add</strong> function in it. The functions use the pointer to their references.</p>
			<p>Additionally, <strong class="source-inline">wasm-bindgen</strong> produces a static method called <strong class="source-inline">__wrap</strong> that creates the <strong class="source-inline">Point</strong> class object and attaches a pointer to it. It adds a free method that in turn calls the <strong class="source-inline">__wbg_point_free</strong> method inside the WebAssembly module. This method is responsible for freeing up the memory taken by the <strong class="source-inline">Point</strong> object or class.</p>
			<p>Create <a id="_idIndexMarker390"/>the following files. We will use <a id="_idIndexMarker391"/>them in the other sections too:</p>
			<ol>
				<li value="1">Create <strong class="source-inline">webpack.config.js</strong>. This <a id="_idIndexMarker392"/>holds the webpack configuration:<p class="source-code">const path = require('path');</p><p class="source-code">const HtmlWebpackPlugin = require('html-webpack-</p><p class="source-code">  plugin');</p><p class="source-code">module.exports = {</p><p class="source-code">    entry: './index.js',</p><p class="source-code">    output: {</p><p class="source-code">        path: path.resolve(__dirname, 'dist'),</p><p class="source-code">        filename: 'bundle.js',</p><p class="source-code">    },</p><p class="source-code">    plugins: [</p><p class="source-code">        new HtmlWebpackPlugin(),</p><p class="source-code">    ],</p><p class="source-code">    mode: 'development'</p><p class="source-code">};</p></li>
				<li>Create <strong class="source-inline">package.json</strong> and add the following content:<p class="source-code">{</p><p class="source-code">    "scripts": {</p><p class="source-code">        "build": "webpack",</p><p class="source-code">        "serve": "webpack-dev-server"</p><p class="source-code">    },</p><p class="source-code">    "dependencies": {</p><p class="source-code">        "html-webpack-plugin": "^3.2.0",</p><p class="source-code">        "webpack": "^4.41.5",</p><p class="source-code">        "webpack-cli": "^3.3.10",</p><p class="source-code">        "webpack-dev-server": "^3.10.1"</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create an <strong class="source-inline">index.js</strong> file:<p class="source-code">$ touch index.js</p></li>
				<li>Then, run <strong class="source-inline">npm install</strong>. Modify <strong class="source-inline">index.js</strong> with the following content:<p class="source-code">import("./class_world").then(({Point}) =&gt; {</p><p class="source-code">const p1 = Point.new(10, 10);</p><p class="source-code">console.log(p1.get_x(), p1.get_y());</p><p class="source-code">const p2 = Point.new(3, 3);</p><p class="source-code">p1.add(p2);</p><p class="source-code">console.log(p1.get_x(), p1.get_y());</p><p class="source-code">});</p></li>
			</ol>
			<p>We call <a id="_idIndexMarker393"/>the new method in the <strong class="source-inline">Point</strong> class <a id="_idIndexMarker394"/>and pass it <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>. We <a id="_idIndexMarker395"/>print the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> coordinates. This will print <strong class="source-inline">10, 10</strong>. Then, we will create another point (<strong class="source-inline">p2</strong>). Finally, we call the <strong class="source-inline">add</strong> function and pass it point <strong class="source-inline">p2</strong>. This will print <strong class="source-inline">13, 13</strong>. </p>
			<ol>
				<li value="5">The getter method uses the pointer and fetches the value from the shared array:<p class="source-code">get_x() {</p><p class="source-code">    return wasm.point_get_x(this.ptr);</p><p class="source-code">}</p></li>
				<li>In the <a id="_idIndexMarker396"/>setter method, we pass in the pointer and the value. Since <a id="_idIndexMarker397"/>we are just passing in a number here, there is no extra conversion needed:<p class="source-code">set_x(arg0) {</p><p class="source-code">    return wasm.point_set_x(this.ptr, arg0);</p><p class="source-code">}</p></li>
				<li>In the <a id="_idIndexMarker398"/>case of <strong class="source-inline">add</strong>, we take the argument, get the pointer to the <strong class="source-inline">Point</strong> object, and pass it to the WebAssembly module:<p class="source-code">add(arg0) {</p><p class="source-code">    const ptr0 = arg0.ptr;</p><p class="source-code">    arg0.ptr = 0;</p><p class="source-code">    return wasm.point_add(this.ptr, ptr0);</p><p class="source-code">}</p></li>
			</ol>
			<p><strong class="source-inline">wasm-bindgen</strong> makes it simple to convert a class into a WebAssembly module. We have seen how to share a class in Rust with JavaScript. Now, we will see how to share a class from JavaScript with Rust.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor117"/>Sharing classes from JavaScript with Rust </h1>
			<p>Sharing <a id="_idIndexMarker399"/>JavaScript classes with Rust is also made <a id="_idIndexMarker400"/>easy with <strong class="source-inline">#[wasm_bindgen]</strong>. Let's <a id="_idIndexMarker401"/>look at how to achieve it.</p>
			<p>JavaScript classes are objects with some methods. Rust is a strictly typed language. This means the Rust compiler needs to have concrete bindings. Without them, the compiler complains, because it needs to know about the lifetime of an object. We need a way to ensure the compiler has this API available at runtime.</p>
			<p>The extern <a id="_idIndexMarker402"/>C function block helps out here. The <a id="_idIndexMarker403"/>extern C makes a function name <a id="_idIndexMarker404"/>available in Rust.</p>
			<p>In this example, let's see how to share a class from JavaScript with Rust:</p>
			<ol>
				<li value="1">Let's create a new project:<p class="source-code"><strong class="bold">$ cargo new --lib class_from_js_world</strong></p><p class="source-code"><strong class="bold">Created library `class_from_js_world` package</strong></p></li>
				<li>Define the <strong class="source-inline">wasm-bindgen</strong> dependency for the project. Open the <strong class="source-inline">cargo.toml</strong> file and add the following content:<p class="source-code">[package]</p><p class="source-code">name = "class_from_js_world"</p><p class="source-code">version = "0.1.0"</p><p class="source-code">authors = ["Sendil Kumar"]</p><p class="source-code">edition = "2018"</p><p class="source-code">[lib]</p><p class="source-code">crate-type = ["cdylib"]</p><p class="source-code">[dependencies]</p><p class="source-code">wasm-bindgen = "0.2.68"</p></li>
			</ol>
			<p>Please copy over <strong class="source-inline">package.json</strong>, <strong class="source-inline">index.js</strong>, and <strong class="source-inline">webpack-config.js</strong> from the previous section. Then, run <strong class="source-inline">npm install</strong>.</p>
			<ol>
				<li value="3">Open the <strong class="source-inline">src/lib.rs</strong> file and replace the contents with the following:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code">#[wasm_bindgen(module = "./point")] . // 1</p><p class="source-code">extern "C" {</p><p class="source-code">     pub type Point; // 2</p><p class="source-code"> </p><p class="source-code">    #[wasm_bindgen(constructor)] //3</p><p class="source-code">    fn new(x: i32, y: i32) -&gt; Point;</p><p class="source-code"> </p><p class="source-code">    #[wasm_bindgen(method, getter)] //4</p><p class="source-code">    fn get_x(this: &amp;Point) -&gt; i32;</p><p class="source-code"> </p><p class="source-code">    #[wasm_bindgen(method, getter)]</p><p class="source-code">    fn get_y(this: &amp;Point) -&gt; i32;</p><p class="source-code"> </p><p class="source-code">    #[wasm_bindgen(method, setter)] //5</p><p class="source-code">    fn set_x(this: &amp;Point, x:i32) -&gt; i32;</p><p class="source-code"> </p><p class="source-code">    #[wasm_bindgen(method, setter)]</p><p class="source-code">    fn set_y(this: &amp;Point, y:i32) -&gt; i32;</p><p class="source-code"> </p><p class="source-code">    #[wasm_bindgen(method)] // 6</p><p class="source-code">    fn add(this: &amp;Point, p: Point);</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">fn get_precious_point() -&gt; Point { //7</p><p class="source-code">    let p = Point::new(10, 10);</p><p class="source-code">    let p1 = Point::new(3, 3);</p><p class="source-code">    p.add(p1); // 8</p><p class="source-code">    p</p><p class="source-code">}</p></li>
			</ol>
			<p>At <strong class="source-inline">//1</strong>, we are importing the JavaScript module. This will import a JavaScript file, <strong class="source-inline">point.js</strong>. Note that this file should be present in the same directory as <strong class="source-inline">Cargo.toml</strong>. Then, we create an extern C block to define the methods that we need to use.</p>
			<p>We first declare a type in the block (<strong class="source-inline">pub type Point;</strong>). Now, we can use this as <a id="_idIndexMarker405"/>any other type in the Rust <a id="_idIndexMarker406"/>code. After that, we define a <a id="_idIndexMarker407"/>list of functions. We first define the constructor. We pass in the constructor as an argument to the <strong class="source-inline">#[wasm_bindgen]</strong> annotation. Define a function that takes in arguments and returns the type declared previously. This will bind to the namespace of the Point type, and we can call <strong class="source-inline">Point::new(x, y);</strong> inside the Rust function.</p>
			<p>Then, we define getters and setters (<strong class="source-inline">//4</strong> and <strong class="source-inline">//5</strong>, respectively). We can even define a method; these are analogous to the function on the JavaScript side. Then, we have the <strong class="source-inline">add</strong> function.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">All the functions inside the extern C block are completely typed.</p>
			<p>Finally, we are exporting the <strong class="source-inline">get_precious_point()</strong> function using the <strong class="source-inline">#[wasm_bindgen]</strong> annotation. In the <strong class="source-inline">get_precious_point</strong> function, we create two <strong class="source-inline">Point</strong> with <strong class="source-inline">Point::new(x, y)</strong>, then add two points using <strong class="source-inline">p1.add(p2)</strong>.</p>
			<p>We can call this from JavaScript just like we did before. We also have to define a <strong class="source-inline">Point</strong> class on the JavaScript side.</p>
			<ol>
				<li value="4">Create <strong class="source-inline">Point.js</strong> with <a id="_idIndexMarker408"/>the following <a id="_idIndexMarker409"/>content:<p class="source-code">export class Point {</p><p class="source-code">    constructor(x, y) {</p><p class="source-code">        this.x = x;</p><p class="source-code">        this.y = y;</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    get_x() {</p><p class="source-code">        return this.x;</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    get_y() {</p><p class="source-code">        return this.y;</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    set_x(x) {</p><p class="source-code">        this.x = x;</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    set_y(y) {</p><p class="source-code">        this.y = y;</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    add(p1) {</p><p class="source-code">        this.x += p1.x;</p><p class="source-code">        this.y += p1.y;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Finally, replace <strong class="source-inline">index.js</strong> with the following:<p class="source-code">import("./class_from_js_world").then(module =&gt; {</p><p class="source-code">    console.log(module.get_precious_point());</p><p class="source-code">});</p></li>
				<li>Now, run the following command to start the server: <p class="source-code"><strong class="bold">$ npm run serve</strong></p></li>
				<li>Open <a id="_idIndexMarker410"/>the browser and run <strong class="source-inline">http://localhost:8000</strong>. Open <a id="_idIndexMarker411"/>the developer <a id="_idIndexMarker412"/>console to see the printed object class.</li>
				<li>Let's see how the <strong class="source-inline">#[wasm_bindgen]</strong> macro is expanding the code:<p class="source-code">$ cargo expand --target=wasm32-unknown-unknown &gt;</p><p class="source-code">  expanded.rs</p></li>
			</ol>
			<p>There are a few interesting things happening here.</p>
			<p>First, the <strong class="source-inline">type</strong> point is converted into a struct. This is similar to what we did in the previous example. But the struct's members are JsValue instead of <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>. This is because <strong class="source-inline">wasm_bindgen</strong> will not know what this Point class is instantiating. So, it creates a JavaScript object and makes that its member:</p>
			<p class="source-code">pub struct Point {</p>
			<p class="source-code">    obj: ::wasm_bindgen::JsValue,</p>
			<p class="source-code">}</p>
			<p>It also defines how to construct the Point object and how to dereference it. This is useful for the WebAssembly runtime to know when to allocate and when to dereference it.</p>
			<p>All the <a id="_idIndexMarker413"/>methods that are defined <a id="_idIndexMarker414"/>are converted into the <a id="_idIndexMarker415"/>implementation of the Point struct. As you can see, there is a lot of unsafe code in the method declaration. This is because the Rust code interacts directly with the raw pointers:</p>
			<p class="source-code">fn new(x: i32, y: i32) -&gt; Point {</p>
			<p class="source-code">#[link(wasm_import_module =</p>
			<p class="source-code">  "__wbindgen_placeholder__")]</p>
			<p class="source-code">extern "C" {</p>
			<p class="source-code">fn __wbg_new_3ffc5ccd013f4db7(x:&lt;i32 as</p>
			<p class="source-code"> ::wasm_bindgen::convert::IntoWasmAbi&gt;::Abi, y:&lt;i32 as</p>
			<p class="source-code"> ::wasm_bindgen::convert::IntoWasmAbi&gt;::Abi) -&gt; &lt;Point</p>
			<p class="source-code"> as ::wasm_bindgen::convert::FromWasmAbi&gt;::Abi;</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">unsafe {</p>
			<p class="source-code">let _ret = {</p>
			<p class="source-code">let mut __stack =</p>
			<p class="source-code">  ::wasm_bindgen::convert::GlobalStack::new();</p>
			<p class="source-code">let x = &lt;i32 as</p>
			<p class="source-code">  ::wasm_bindgen::convert::IntoWasmAbi&gt;::into_abi</p>
			<p class="source-code">  (x, &amp;mut __stack);</p>
			<p class="source-code">let y = &lt;i32 as</p>
			<p class="source-code">  ::wasm_bindgen::convert::IntoWasmAbi&gt;::into_abi</p>
			<p class="source-code">  (y, &amp;mut __stack);</p>
			<p class="source-code">__wbg_new_3ffc5ccd013f4db7(x, y)</p>
			<p class="source-code">};</p>
			<p class="source-code">&lt;Point as</p>
			<p class="source-code"> ::wasm_bindgen::convert::FromWasmAbi&gt;::from_abi(_ret,</p>
			<p class="source-code"> &amp;mut ::wasm_bindgen::convert::GlobalStack::new())</p>
			<p class="source-code">}</p>
			<p class="source-code">}</p>
			<p>Shown in the previous code is the code generated by the <strong class="source-inline">#[wasm_bindgen(constructor)]</strong> macro. It first links the code with the extern C block. The arguments are then cast such that they are inferred in WebAssembly.</p>
			<p>Then, we <a id="_idIndexMarker416"/>have the unsafe block. First, space <a id="_idIndexMarker417"/>is reserved in the <a id="_idIndexMarker418"/>global stack. Then, both <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> are converted into the <strong class="source-inline">IntoWasmAbi</strong> type.</p>
			<p><strong class="source-inline">IntoWasmAbi</strong> is a trait for anything that can be converted into a type that can cross the WebAssembly ABI directly, for example, u32 or f64. Then, the function in JavaScript is called. The returned value is then cast into a <strong class="source-inline">Point</strong> type using <strong class="source-inline">FromWasmAbi</strong>.</p>
			<p><strong class="source-inline">FromWasmAbi</strong> is a trait for anything that can be recovered by value from the WebAssembly ABI boundary; for example, a Rust u8 can be recovered from the WebAssembly ABI u32 type.</p>
			<p>We have seen how to share a class in JavaScript with Rust. Now, we will see how we can call a JavaScript API in Rust.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor118"/>Calling the JavaScript API via WebAssembly </h1>
			<p>JavaScript provides a rich API to work with objects, arrays, maps, sets, and so on. If we want to use <a id="_idIndexMarker419"/>or define them in Rust, then we need to <a id="_idIndexMarker420"/>provide the necessary bindings. Handcrafting those bindings will be a huge process. But what if we have bindings to those APIs? That is a common API for both Node.js and a browser environment that will create a platform where we can write the code completely in Rust and use <strong class="source-inline">wasm_bindgen</strong> to create necessary code.</p>
			<p>The rustwasm team's answer to that is the js-sys crate.</p>
			<p class="author-quote">The js-sys crate contains raw <strong class="source-inline">#[wasm_bindgen]</strong> bindings to all the global APIs guaranteed to exist in every JavaScript environment by the ECMAScript standard. – RustWASM</p>
			<p>They provide bindings to JavaScript's standard built-in objects, including their methods and properties.</p>
			<p>In this example, let's see how to call a JavaScript API via WebAssembly:</p>
			<ol>
				<li value="1">Create a default project with the <strong class="source-inline">cargo new</strong> command:<p class="source-code"><strong class="bold">$ cargo new --lib jsapi</strong></p></li>
				<li>Copy over <strong class="source-inline">webpack.config.js</strong>, <strong class="source-inline">index.js</strong>, and <strong class="source-inline">package.json</strong> similarly to the previous example. Then, open the generated project in your favorite editor.</li>
				<li>Change the contents of <strong class="source-inline">Cargo.toml</strong>:<p class="source-code">[package]</p><p class="source-code">name = "jsapi"</p><p class="source-code">version = "0.1.0"</p><p class="source-code">authors = ["Sendil Kumar"]</p><p class="source-code">edition = "2018"</p><p class="source-code"> </p><p class="source-code">[lib]</p><p class="source-code">crate-type = ["cdylib"]</p><p class="source-code"> </p><p class="source-code">[dependencies]</p><p class="source-code">wasm-bindgen = "0.2.68"</p><p class="source-code">js-sys = "0.3.45"</p></li>
			</ol>
			<ol>
				<li value="4">Now, open <strong class="source-inline">src/lib.rs</strong> and <a id="_idIndexMarker421"/>replace the file <a id="_idIndexMarker422"/>with the following content. We can create a JavaScript map inside Rust using the following snippet:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code"> </p><p class="source-code">use js_sys::Map;</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn new_js_map() -&gt; Map {</p><p class="source-code">    Map::new()</p><p class="source-code">}</p></li>
			</ol>
			<p>Added to the <strong class="source-inline">wasm_bindgen</strong> import, we imported the map from the <strong class="source-inline">js_sys</strong> crate using <strong class="source-inline">use js_sys::Map;</strong>.</p>
			<ol>
				<li value="5">Then, we define the <strong class="source-inline">new_js_map</strong> function, which will return a new map:<p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn set_get_js_map() -&gt; JsValue {</p><p class="source-code">    let map = Map::new();</p><p class="source-code">    map.set(&amp;"foo".into(), &amp;"bar".into());</p><p class="source-code">    map.get(&amp;"foo".into())</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">set_get_js_map</strong> function creates a new map, sets a value in the map, and then returns the value set.</p>
			<p>Note that the <a id="_idIndexMarker423"/>return type here is <strong class="source-inline">JsValue</strong>. This is <a id="_idIndexMarker424"/>a wrapper in Rust for specifying the JavaScript values. Also, note that we are passing the string into the trait functions get and set. This will return <strong class="source-inline">bar</strong> as the output when called in JavaScript.</p>
			<ol>
				<li value="6">We now also run through the map using <strong class="source-inline">for_each</strong> inside the Rust code like this:<p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn run_through_map() -&gt; f64 {</p><p class="source-code">    let map = Map::new();</p><p class="source-code">    map.set(&amp;1.into(), &amp;1.into());</p><p class="source-code">    map.set(&amp;2.into(), &amp;2.into());</p><p class="source-code">    map.set(&amp;3.into(), &amp;3.into());</p><p class="source-code">    map.set(&amp;4.into(), &amp;4.into());</p><p class="source-code">    map.set(&amp;5.into(), &amp;5.into());</p><p class="source-code">    let mut res: f64 = 0.0;</p><p class="source-code"> </p><p class="source-code">    map.for_each(&amp;mut |value, _| {</p><p class="source-code">        res = res + value.as_f64().unwrap();</p><p class="source-code">    });</p><p class="source-code"> </p><p class="source-code">    res</p><p class="source-code">}</p></li>
			</ol>
			<p>This creates a map and then loads the map with the values <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, <strong class="source-inline">4</strong>, and <strong class="source-inline">5</strong>. Then, it runs <a id="_idIndexMarker425"/>over the created map and adds <a id="_idIndexMarker426"/>the value together. This will produce an output of <strong class="source-inline">15</strong> (that is, 1 + 2 + 3 + 4 + 5).</p>
			<ol>
				<li value="7">Lastly, we replace <strong class="source-inline">index.js</strong> with the following content:<p class="source-code">import("./jsapi").then(module =&gt; {</p><p class="source-code">    let m = module.new_js_map();</p><p class="source-code">    m.set("Hi", "Hi");</p><p class="source-code">    console.log(m); // prints Map { "Hi" -&gt;  "Hi" }</p><p class="source-code">    console.log(module.set_get_js_map());  // prints</p><p class="source-code">      "bar"</p><p class="source-code">    console.log(module.run_through_map()); // prints</p><p class="source-code">      15</p><p class="source-code">});</p></li>
			</ol>
			<p>Running this on the browser will print the result. Refer to the comments near the console log statements.</p>
			<p>Let's start with the generated JavaScript binding file. The generated binding JavaScript file has almost the same structure as in the previous section, but with a few more functions exported.</p>
			<p>The heap object is used as a stack here. All the JavaScript objects that are shared or referenced with the WebAssembly modules are stored in this heap. It is also important to note that once a value is accessed, it is popped out from the heap.</p>
			<p class="source-code">function takeObject(idx) {</p>
			<p class="source-code">    const ret = getObject(idx);</p>
			<p class="source-code">    dropObject(idx);</p>
			<p class="source-code">    return ret;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">takeObject</strong> function is used to fetch the object from the heap. It first gets the object at the given index. Then, it removes the object from that heap index (that is, it pops it out). Finally, it returns the value <strong class="source-inline">ret</strong>. </p>
			<p>Similarly, we <a id="_idIndexMarker427"/>can use JavaScript APIs inside Rust. The <a id="_idIndexMarker428"/>bindings are only generated for the common JavaScript API (including Node.js and the browser).</p>
			<p>We have seen how to call the JavaScript API in Rust. Now, we will see how we can call a Rust closure via WebAssembly.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor119"/>Calling closures via WebAssembly </h1>
			<p>The official <a id="_idIndexMarker429"/>Rust book defines closures as follows:</p>
			<p class="author-quote">Closures are anonymous functions which you can save in a variable or can be passed as arguments to other functions. - The Rust Programming Language (Covers Rust 2018) by Steve Klabnik and Carol Nichols (<a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">https://doc.rust-lang.org/book/ch13-00-functional-features.html</a>)</p>
			<p>MDN defines <a id="_idIndexMarker430"/>a closure for JavaScript as follows:</p>
			<p class="author-quote">A closure is the combination of a function and lexical environment within which that function was declared.- MDN Web Docs (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#closure">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#closure</a>)</p>
			<p>In general, closures are self-contained blocks of functionality that are tossed around and used in the code. They can capture and store references to the variables from the context in which they are defined.</p>
			<p>Closures and functions are similar except for a subtle difference. Closures will capture the state when it is first created. Then, whenever a closure is called, it closes over that captured state.</p>
			<p>Closures are functions with a state. When you create a closure, it captures the state. Then, we can pass around closures just like any other function. When a closure is then invoked, it closes over this captured state and executes (even when the closure is invoked outside of their captured state). That is one of the important reasons why the use of closures is increasing on the functional side of JavaScript.</p>
			<p>Closures make it easy to do data encapsulation, higher-order functions, and memoization. (Sounds functional, right? ;))</p>
			<p>Let's see how to share closures from JavaScript to Rust and vice versa:</p>
			<ol>
				<li value="1">Create a new project:<p class="source-code"><strong class="bold">$ cargo new --lib closure_world</strong></p><p class="source-code"><strong class="bold">     Created library `closure_world` package</strong></p></li>
				<li>Define the <strong class="source-inline">wasm-bindgen</strong> dependency for the project. Let's open the <strong class="source-inline">cargo.toml</strong> file and add the content highlighted in bold:<p class="source-code">[package]</p><p class="source-code">name = "closure_world"</p><p class="source-code">version = "0.1.0"</p><p class="source-code">authors = ["Sendil Kumar"]</p><p class="source-code">edition = "2018"</p><p class="source-code"> </p><p class="source-code">[lib]</p><p class="source-code">crate-type = ["cdylib"]</p><p class="source-code"> </p><p class="source-code">[dependencies]</p><p class="source-code"><strong class="bold">wasm-bindgen = "0.2.38"</strong></p><p class="source-code"><strong class="bold">js-sys = "0.3.15"</strong></p></li>
			</ol>
			<p>We will need <a id="_idIndexMarker431"/>the js-sys crate to copy over the <a id="_idIndexMarker432"/>closures from JavaScript into Rust. Please copy over <strong class="source-inline">package.json</strong>, <strong class="source-inline">index.js</strong>, and <strong class="source-inline">webpack-config.js</strong> from the previous section. Then, run <strong class="source-inline">npm install</strong>.</p>
			<ol>
				<li value="3">We then open the <strong class="source-inline">src/lib.rs</strong> file and add the content from our <strong class="source-inline">Point</strong> class example <a id="_idIndexMarker433"/>with an additional method that takes in JavaScript's closure function as its argument:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub struct Point {</p><p class="source-code">    x: i32,</p><p class="source-code">    y: i32,</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">impl Point {</p><p class="source-code">    pub fn new(x: i32, y: i32) -&gt; Point {</p><p class="source-code">        Point { x: x, y: y}</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    pub fn get_x(&amp;self) -&gt; i32 {</p><p class="source-code">        self.x</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    pub fn get_y(&amp;self) -&gt; i32 {</p><p class="source-code">        self.y</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    pub fn set_x(&amp;mut self, x: i32) {</p><p class="source-code">        self.x = x;</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    pub fn set_y(&amp;mut self, y:i32) {</p><p class="source-code">        self.y = y;</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    pub fn add(&amp;mut self, p: Point) {</p><p class="source-code">        self.x = self.x + p.x;</p><p class="source-code">        self.y = self.y + p.y;</p><p class="source-code">     }</p><p class="source-code"> </p><p class="source-code">    pub fn distance(&amp;self, js_func: js_sys::Function)</p><p class="source-code">      -&gt; JsValue {</p><p class="source-code">        let this = JsValue::NULL;</p><p class="source-code">        let x = JsValue::from(self.x);</p><p class="source-code">        let y = JsValue::from(self.y);</p><p class="source-code">        js_func.call2(&amp;this, &amp;x, &amp;y).unwrap()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, we will <a id="_idIndexMarker434"/>change <strong class="source-inline">index.js</strong> to call the <a id="_idIndexMarker435"/><strong class="source-inline">distance</strong> function with a closure:</p>
			<p class="source-code">import("./closure_world").then(({Point}) =&gt; {</p>
			<p class="source-code">     const p1 = Point.new(13, 10);</p>
			<p class="source-code">     console.log(p1.distance((x, y) =&gt; x - y));</p>
			<p class="source-code">});</p>
			<p>Let's spin the webpack server with <strong class="source-inline">npm run serve</strong>. This will print out <strong class="source-inline">3</strong>.</p>
			<p>The js-sys crate offers an option to invoke the JavaScript function using the apply and call method. That is what we have done by calling <strong class="source-inline">js_func.call2(&amp;this, &amp;x, &amp;y)</strong>.</p>
			<p>Rust does not <a id="_idIndexMarker436"/>have function overloading. This means that we <a id="_idIndexMarker437"/>have to use different method names based on the number of arguments that we pass. So, <strong class="source-inline">js-sys</strong> offers us <strong class="source-inline">call1</strong>, <strong class="source-inline">call2</strong>, <strong class="source-inline">call3</strong>, and so on, each taking <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, and so on arguments, respectively.</p>
			<p>Invoking a JavaScript function in Rust will return <strong class="source-inline">Result&lt;JsValue, Error&gt;</strong>. We will unwrap the result to get the JsValue and return it. <strong class="source-inline">wasm-bindgen</strong> will create the necessary binding to return the value as a number in JavaScript.</p>
			<p>On the other hand, passing a closure from Rust to JavaScript will need some extra information and options.</p>
			<p><strong class="source-inline">wasm-bindgen</strong> supports two variants here:</p>
			<ul>
				<li>Stack lifetime closures</li>
				<li>Heap-allocated closures</li>
			</ul>
			<p>Let's see what they actually mean:</p>
			<ul>
				<li>Stack lifetime closures should not be invoked by JavaScript again once the imported JavaScript function that the closure was passed to returns. This is because once the function (closure) returns, the closure will be invalidated by Rust. Any future invocations will lead to an exception. In other words, stack lifetime closures are short-lived and they go out of context once they are accessed.</li>
				<li>On the other hand, heap-allocated closures are useful for invoking the memory multiple times. Here, the validity is tied to the lifetime of the closure in Rust. Once the closure in Rust is dropped, the closure will deallocate and garbage will be collected. This will in turn invalidate the closure (function) in JavaScript. Once invalidated, any further attempts to access the closure or memory will raise an exception.</li>
			</ul>
			<p>Both the stack lifetime <a id="_idIndexMarker438"/>and heap-allocated closures support <a id="_idIndexMarker439"/>both <strong class="source-inline">Fn</strong> and <strong class="source-inline">FnMut</strong> closures, arguments, and return values.</p>
			<p>We have seen how to call a closure function. Now, we will see how to import a function from JavaScript into Rust.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor120"/>Importing the JavaScript function into Rust </h1>
			<p>In certain places, JavaScript is faster than WebAssembly because there is no overhead of boundary <a id="_idIndexMarker440"/>crossing and instantiating a separate <a id="_idIndexMarker441"/>runtime environment. JavaScript runs more naturally in its own environment.</p>
			<p>The JavaScript ecosystem is huge. There are millions of libraries created and battle tested (not all of them, of course) with JavaScript. This makes JavaScript easy (easy here is subjective).</p>
			<p>WebAssembly addresses the most important problem that we have in the frontend world, that of "consistent" performance. But it is not a complete replacement for JavaScript. WebAssembly helps JavaScript to deliver better and more consistent performance.</p>
			<p>JavaScript will be a default choice in most places. It is important to provide an ecosystem that allows seamless integration between the two. We have already seen how to import a class from JavaScript into Rust. Similarly, we can import anything from JavaScript into Rust using <strong class="source-inline">wasm-bindgen</strong>. The most important part is that we can more naturally use these imported JavaScript functions inside Rust code.</p>
			<p>In this example, let's see how to import a JavaScript function into Rust:</p>
			<ol>
				<li value="1">Create a new project:<p class="source-code"><strong class="bold">$ cargo new --lib import_js_world</strong></p><p class="source-code"><strong class="bold">     Created library `import_js_world` package</strong></p></li>
				<li>Define the <strong class="source-inline">wasm-bindgen</strong> dependency for the project. Let's open the <strong class="source-inline">cargo.toml</strong> file and add the content highlighted in bold:<p class="source-code"> </p><p class="source-code">[package]</p><p class="source-code">name = "import_js_world"</p><p class="source-code">version = "0.1.0"</p><p class="source-code">authors = ["Sendil Kumar"]</p><p class="source-code">edition = "2018"</p><p class="source-code"> </p><p class="source-code"><strong class="bold">[lib]</strong></p><p class="source-code"><strong class="bold">crate-type = ["cdylib"]</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">[dependencies]</strong></p><p class="source-code"><strong class="bold">wasm-bindgen = "0.2.38"</strong></p></li>
				<li>Please <a id="_idIndexMarker442"/>copy over <strong class="source-inline">package.json</strong>, <strong class="source-inline">index.js</strong>, and <strong class="source-inline">webpack-config.js</strong> from the previous section. Then, run <strong class="source-inline">npm install</strong>. Then, open the <strong class="source-inline">src/lib.rs</strong> file and replace <a id="_idIndexMarker443"/>its content with the following:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen(module = "./array")]</p><p class="source-code">extern "C" {</p><p class="source-code">    fn topArray() -&gt; f64;</p><p class="source-code">    fn getNumber() -&gt; i32;</p><p class="source-code">    fn lowerCase(str: &amp;str) -&gt; String;</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn sum_of_square_root() -&gt; f64 {</p><p class="source-code">    let n = getNumber();</p><p class="source-code">    let mut sum = 0;</p><p class="source-code"> </p><p class="source-code">    for _ in 0..n {</p><p class="source-code">        sum = sum + (topArray().sqrt() as i64);</p><p class="source-code">    } </p><p class="source-code">    sum</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn some_string_to_share() -&gt; String {</p><p class="source-code">    lowerCase("HEYA! I AM ALL CAPS")</p><p class="source-code">}</p></li>
			</ol>
			<p>We start by importing the <strong class="source-inline">wasm_bindgen</strong> library. Then, we define the extern C block to <a id="_idIndexMarker444"/>define the FFI functions (that is, the functions that we import from JavaScript). Inside the extern C <a id="_idIndexMarker445"/>block, we define the function signature similar to what the Rust compiler understands. We also annotate the extern C block with <strong class="source-inline">#[wasm_bindgen(module ="./array")]</strong>. This helps the <strong class="source-inline">wasm-bindgen</strong> CLI to understand where the functions are defined and exported. It will use this information and create the necessary link.</p>
			<ol>
				<li value="4">The <strong class="source-inline">array.js</strong> file is in the same directory as the <strong class="source-inline">cargo.toml</strong> file. We will define <strong class="source-inline">array.js</strong> as follows:<p class="source-code">let someGlobalArray = [1, 4, 9, 16, 25];</p><p class="source-code"> </p><p class="source-code">export function getNumber() {</p><p class="source-code">    return someGlobalArray.length;</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">export function topArray() {</p><p class="source-code">    return someGlobalArray.sort().pop();</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">export lowerCase(str) {</p><p class="source-code">    return str.toLowerCase();</p><p class="source-code">}</p></li>
			</ol>
			<p>The functions mentioned previously should be exported in the JavaScript file.</p>
			<p>We then declare a function (<strong class="source-inline">sum_of_square_root</strong>) in Rust and export it as a function <a id="_idIndexMarker446"/>in the WebAssembly module <a id="_idIndexMarker447"/>that is generated. We first call the <strong class="source-inline">getNumber()</strong> method from JavaScript. We use the return value and then run the <strong class="source-inline">for</strong> loop for the length of the array. For each loop, we call <strong class="source-inline">topArray</strong> to get the lowest element from the array. Then, we take the square root of the number (this happens in Rust code). Sum them up and return the sum (<strong class="source-inline">15</strong> for the example that we saw previously).</p>
			<ol>
				<li value="5">We will replace <strong class="source-inline">index.js</strong> with the following content:<p class="source-code">import("./import_js_world").then(module =&gt; {</p><p class="source-code">    console.log(module.sum_of_square_root());</p><p class="source-code">    console.log(module.some_string_to_share());</p><p class="source-code">});</p></li>
				<li>Let's run the previous code with <strong class="source-inline">npm run serve</strong>. Go to the URL and open the developer console. <strong class="source-inline">15</strong> and <strong class="source-inline">HEYA! I AM ALL CAPS</strong> will be printed in the console. </li>
				<li>Open the generated binding JavaScript file. It will be interesting to see that both the <strong class="source-inline">getNumber</strong> and <strong class="source-inline">topArray</strong> functions are not available in the generated binding <a id="_idIndexMarker448"/>JavaScript file. The main reason for <a id="_idIndexMarker449"/>this is we are just sharing numbers between the JavaScript and the WebAssembly module. Hence, the boundary crossing happens more naturally in this case.</li>
			</ol>
			<p>But there will be a function exported for the <strong class="source-inline">some_string_to_share</strong> function. This is because we are sharing a string, which needs conversion. So, the binding file will make the necessary conversion to work with the string. It is also important to note that there is a <strong class="source-inline">getInt64Memory</strong> function. This is because we are returning <strong class="source-inline">f64</strong> as output. <strong class="source-inline">wasm-bindgen</strong> converts the number into <strong class="source-inline">bigInt</strong> and returns it to JavaScript.</p>
			<ol>
				<li value="8"><strong class="source-inline">wasm-bindgen</strong> also does the necessary shifting and parsing of the byte buffer based on the byte size of the memory object. For <strong class="source-inline">Uint32Array</strong>, the pointer and memory are calculated as follows:<p class="source-code">const rustptr = mem[retptr / 4];</p><p class="source-code">const rustlen = mem[retptr / 4 + 1];</p></li>
				<li>For <strong class="source-inline">BigInt64Array</strong>, the pointer and memory are calculated as follows:<p class="source-code">const rustptr = mem[retptr / 8];</p><p class="source-code">const rustlen = mem[retptr / 8 + 1];</p></li>
			</ol>
			<p>We have seen how to import a JavaScript function into Rust. Now, we will see how we can call a web API in Rust.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor121"/>Calling a web API via WebAssembly</h1>
			<p>The evolution of <a id="_idIndexMarker450"/>the web has been phenomenal, with its growth being attributed to its open standards. Today, the web provides hundreds of APIs, which makes it easy for web developers to develop for audio, video, canvases, SVGs, USBs, batteries, and so on.</p>
			<p>The web is universal and omnipresent. It is continuously experimented with and changed to make it desirable and easy for developers and companies to use, respectively. The web-sys crate provides access to almost all the APIs that are available on the web at the moment.</p>
			<p class="author-quote">The <strong class="source-inline">web-sys</strong> crate provides raw bindings to all the Web's APIs: everything from DOM manipulation to WebGL to Web Audio to timers to fetch and more! – web-sys crates.io (<a href="https://crates.io/crates/web-sys">https://crates.io/crates/web-sys</a>)</p>
			<p>The<a id="_idIndexMarker451"/> WebIDL interface definitions are converted into <strong class="source-inline">wasm-bindgen</strong>'s internal <strong class="bold">abstract syntax trees</strong> (<strong class="bold">ASTs</strong>). Then, these ASTs are used to create zero-overhead Rust and JavaScript glue code.</p>
			<p>With the help of this binding code, we can call and manipulate the web APIs. Converting the web APIs into Rust ensures the type information of parameters and return values is handled correctly and safely.</p>
			<p>In this example, let's call a web API via WebAssembly:</p>
			<ol>
				<li value="1">Create a default project with the <strong class="source-inline">cargo new</strong> command:<p class="source-code"><strong class="bold">$ cargo new --lib web_sys_api</strong></p><p class="source-code"><strong class="bold">    Created library `web_sys_api` package</strong></p></li>
				<li>Copy over <strong class="source-inline">webpack.config.js</strong>, <strong class="source-inline">index.js</strong>, and <strong class="source-inline">package.json</strong> similarly to the <strong class="source-inline">jsapi</strong> section (in the above section). We'll now open the generated project in our favorite editor. Let's change the contents of <strong class="source-inline">cargo.toml</strong>:<p class="source-code">[package]</p><p class="source-code">name = "web_sys_api"</p><p class="source-code">version = "0.1.0"</p><p class="source-code">authors = ["Sendil Kumar"]</p><p class="source-code">edition = "2018"</p><p class="source-code"> </p><p class="source-code">[lib]</p><p class="source-code">crate-type = ["cdylib"]</p><p class="source-code"> </p><p class="source-code">[dependencies]</p><p class="source-code">wasm-bindgen = "0.2.38"</p><p class="source-code"> </p><p class="source-code">[dependencies.web-sys]</p><p class="source-code">version = "0.3.4"</p><p class="source-code">features = [</p><p class="source-code">    'Document',</p><p class="source-code">    'Element',</p><p class="source-code">    'HtmlElement',</p><p class="source-code">    'Node',</p><p class="source-code">    'Window',</p><p class="source-code">]</p></li>
			</ol>
			<p>The major difference <a id="_idIndexMarker452"/>here is that instead of just defining the dependency and its version, we also defined the features that we will be using in this example.</p>
			<p>Why do we need it? Since there is a huge number of APIs in the web ecosystem, we do not want to carry bindings for all of them. The binding files are created and used only for the listed features.</p>
			<ol>
				<li value="3">Let's <a id="_idIndexMarker453"/>open <strong class="source-inline">src/lib.rs</strong> and replace the file with the following content:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code"> </p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn draw(percent: i32) -&gt; Result&lt;web_sys::Element,</p><p class="source-code">  JsValue&gt; {</p><p class="source-code">    let window = web_sys::window().unwrap();</p><p class="source-code">    let document = window.document().unwrap();</p><p class="source-code"> </p><p class="source-code">    let div = document.create_element("div")?;</p><p class="source-code">    let ns = Some("http://www.w3.org/2000/svg");</p><p class="source-code"> </p><p class="source-code">    div.set_attribute("class", "pie")?;</p><p class="source-code"> </p><p class="source-code">    let svg = document.create_element_ns( ns, "svg")?;</p><p class="source-code">    svg.set_attribute("height", "100")?;</p><p class="source-code">    svg.set_attribute("width", "100")?;</p><p class="source-code">    svg.set_attribute("viewBox", "0 0 32 32")?;</p><p class="source-code"> </p><p class="source-code">    let circle = document.create_element_ns(ns,</p><p class="source-code">      "circle")?;</p><p class="source-code">    circle.set_attribute("r", "16")?;</p><p class="source-code">    circle.set_attribute("cx", "16")?;</p><p class="source-code">    circle.set_attribute("cy", "16")?;</p><p class="source-code">    circle.set_attribute("stroke-dasharray",</p><p class="source-code">      &amp;(percent.to_string().to_owned() +" 100"))?;</p><p class="source-code"> </p><p class="source-code">    svg.append_child(&amp;circle)?;</p><p class="source-code"> </p><p class="source-code">    div.append_child(&amp;svg)?;</p><p class="source-code"> </p><p class="source-code">    Ok(div)</p><p class="source-code">}</p></li>
			</ol>
			<p>We first fetch the window using <strong class="source-inline">web_sys::window()</strong>. The unwrap at the end makes sure the window is available. If it is not, it will throw an error. After that, we get <a id="_idIndexMarker454"/>the document from the window object. We then create a <strong class="source-inline">div</strong> element with <strong class="source-inline">document.createElement</strong>. Then, we create an SVG and circle document element and append the circle to the SVG element. Finally, we append the SVG as a child to the <strong class="source-inline">div</strong> element and return the <strong class="source-inline">div</strong> element.</p>
			<p>The API is quite similar to the web API except for the fact that the method names are using snake case instead of camel case.</p>
			<ol>
				<li value="4">We will change <strong class="source-inline">index.js</strong> to use this element as a web component:<p class="source-code">import("./web_sys_api").then(module =&gt; {</p><p class="source-code">    class Pie extends HTMLElement {</p><p class="source-code">        constructor() {</p><p class="source-code">            super();</p><p class="source-code">            let shadow = this.attachShadow({ mode:</p><p class="source-code">              'open' });</p><p class="source-code">            let style =</p><p class="source-code">              document.createElement('style');</p><p class="source-code"> </p><p class="source-code">            style.textContent = `</p><p class="source-code">                    svg {</p><p class="source-code">                        width:100px;</p><p class="source-code">                        height: 100px;</p><p class="source-code">                        background: yellowgreen;</p><p class="source-code">                        border-radius: 50%;</p><p class="source-code">                    }</p><p class="source-code"> </p><p class="source-code">                    circle {</p><p class="source-code">                        fill: yellowgreen;</p><p class="source-code">                        stroke: #655;</p><p class="source-code">                        stroke-width: 32;</p><p class="source-code">                    }`;</p><p class="source-code"> </p><p class="source-code">           shadow.appendChild(module.draw(this.</p><p class="source-code">           getAttribute</p><p class="source-code">           ('value'));</p><p class="source-code">           shadow.appendChild(style);</p><p class="source-code">       }</p><p class="source-code">   }</p><p class="source-code"> </p><p class="source-code">    customElements.define('pie-chart', Pie);</p><p class="source-code"> </p><p class="source-code">    setInterval(() =&gt; {</p><p class="source-code">        let r = Math.floor(Math.random() * 100);</p><p class="source-code">        document.getElementsByTagName('body')[0].</p><p class="source-code">          innerHTML = `</p><p class="source-code">            &lt;pie-chart value='${r}' /&gt;`;</p><p class="source-code">    }, 1000);</p><p class="source-code">});</p></li>
			</ol>
			<p>So, what have we done here? We first imported the binding file, which will, in turn, initialize the WebAssembly module. Once the WebAssembly module is initialized, we <a id="_idIndexMarker455"/>create a <strong class="source-inline">Pie</strong> class that extends the HTML element. Inside the class' constructor, we call the <strong class="source-inline">super</strong> method. Then, we create a shadow DOM. We add a style element to the shadow DOM, and then define the style for the element.</p>
			<p>We go on to append the style element to the shadow element, and then add the element that is exported from the Rust code. We then register it as a custom element named <strong class="source-inline">pie-chart</strong>. Finally, we append the custom element to our document's body to see the pie chart getting displayed. </p>
			<ol>
				<li value="5">Now, run the following command:<p class="source-code"><strong class="bold">$ npm run serve</strong></p></li>
			</ol>
			<p>Open the browser to see the pie chart. </p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor122"/>Summary</h1>
			<p>In this chapter, we saw how <strong class="source-inline">wasm-bindgen</strong> makes it easy to share complex objects between JavaScript and Rust. The annotations make it easy to mark a function to export/import between JavaScript and WebAssembly. We also saw how js-sys and web-sys Cargo make it easier to call JavaScript and web APIs inside Rust code easily.</p>
			<p>In the next chapter, we will see how to optimize the generated WebAssembly module in Rust.</p>
		</div>
	</body></html>