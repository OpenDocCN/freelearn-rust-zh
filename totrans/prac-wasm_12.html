<html><head></head><body>
		<div><h1 id="_idParaDest-98"><em class="italic"><a id="_idTextAnchor114"/>Chapter 9</em>: Crossing the Boundary between Rust and WebAssembly</h1>
			<p>So far, we have only seen examples of sharing simple numbers between JavaScript and WebAssembly. In the last section, we saw how <code>wasm-bindgen</code> helps to pass a string from Rust to JavaScript with ease. In this chapter, we will explore how <code>wasm-bindgen</code> makes it easier to convert more complex data types between JavaScript and WebAssembly via Rust. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Sharing classes from Rust with JavaScript</li>
				<li>Sharing classes from JavaScript with Rust</li>
				<li>Calling the JavaScript API via WebAssembly</li>
				<li>Calling closures via WebAssembly</li>
				<li>Importing the JavaScript function into Rust</li>
				<li>Calling a web API via WebAssembly</li>
			</ul>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor115"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/09-rust-wasm-boundary">https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/09-rust-wasm-boundary</a>.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor116"/>Sharing classes from Rust with JavaScript </h1>
			<p><code>wasm-bindgen</code> enables <a id="_idIndexMarker381"/>sharing classes <a id="_idIndexMarker382"/>from JavaScript with Rust and vice versa <a id="_idIndexMarker383"/>using simple annotations. It handles all the boilerplate stuff, such as translating a value from JavaScript to WebAssembly or WebAssembly to JavaScript, complex memory manipulations, and error-prone pointer arithmetic. Thus, <code>wasm-bindgen</code> makes everything easier.</p>
			<p>Let's see how <a id="_idIndexMarker384"/>easy it is to share classes <a id="_idIndexMarker385"/>between JavaScript and WebAssembly <a id="_idIndexMarker386"/>(from Rust):</p>
			<ol>
				<li>Create a new project:<pre><strong class="bold">$ cargo new --lib class_world</strong>
<strong class="bold">Created library `class_world` package</strong></pre></li>
				<li>Define the <code>wasm-bindgen</code> dependency for the project. Open the <code>cargo.toml</code> file and add the following content:<pre>[package]
name = "class_world"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
[lib]
crate-type = ["cdylib"]
[dependencies]
wasm-bindgen = "0.2.68"</pre></li>
				<li>Open the <code>src/lib.rs</code> file and replace the content with the following:<pre>use wasm_bindgen::prelude::*;
#[wasm_bindgen]
pub struct Point {
    x: i32,
    y: i32,
}
#[wasm_bindgen]
impl Point {
    pub fn new(x: i32, y: i32) -&gt; Point {
        Point { x: x, y: y}
    }
    pub fn get_x(&amp;self) -&gt; i32 {
        self.x
    }
    pub fn get_y(&amp;self) -&gt; i32 {
        self.y
    }
 
    pub fn set_x(&amp;mut self, x: i32) {
        self.x = x;
    }
 
    pub fn set_y(&amp;mut self, y:i32) {
        self.y = y;
    }
 
    pub fn add(&amp;mut self, p: Point) {
        self.x = self.x + p.x;
        self.y = self.y + p.y;
     }
}</pre><p class="callout-heading">Note</p><p class="callout">The <code>&amp;mut</code> before the argument specifies that the argument (in this case, <code>self</code>) is a mutable reference.</p></li>
			</ol>
			<p>Rust does not have classes but we can define a class via a struct. The <code>Point</code> struct contains getters, setters, and an <code>add</code> function. This is normal Rust code with only the <code>#[wasm_bindgen]</code> annotation added. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The functions and struct were explicitly marked <code>pub</code>. The <code>pub</code> modifier means the function is public and will be exported.</p>
			<ol>
				<li value="4">Generate the WebAssembly module using Cargo:<pre>$ cargo build --target=wasm32-unknown-unknown</pre></li>
				<li>Use the <code>wasm-bindgen</code> CLI to generate the binding file for the WebAssembly module generated:<pre>$ wasm-bindgen target/wasm32-unknown-
  unknown/debug/class_world.wasm --out-dir .</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker387"/>generate the binding files <a id="_idIndexMarker388"/>and type definition files as we <a id="_idIndexMarker389"/>have seen in the previous chapter. Let's look at the <code>class_world.js</code> file first. This file will be similar to the file generated in previous chapters except for the <code>Point</code> class. The <code>Point</code> class has all the getters, the setters, and the <code>add</code> function in it. The functions use the pointer to their references.</p>
			<p>Additionally, <code>wasm-bindgen</code> produces a static method called <code>__wrap</code> that creates the <code>Point</code> class object and attaches a pointer to it. It adds a free method that in turn calls the <code>__wbg_point_free</code> method inside the WebAssembly module. This method is responsible for freeing up the memory taken by the <code>Point</code> object or class.</p>
			<p>Create <a id="_idIndexMarker390"/>the following files. We will use <a id="_idIndexMarker391"/>them in the other sections too:</p>
			<ol>
				<li value="1">Create <code>webpack.config.js</code>. This <a id="_idIndexMarker392"/>holds the webpack configuration:<pre>const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-
  plugin');
module.exports = {
    entry: './index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js',
    },
    plugins: [
        new HtmlWebpackPlugin(),
    ],
    mode: 'development'
};</pre></li>
				<li>Create <code>package.json</code> and add the following content:<pre>{
    "scripts": {
        "build": "webpack",
        "serve": "webpack-dev-server"
    },
    "dependencies": {
        "html-webpack-plugin": "^3.2.0",
        "webpack": "^4.41.5",
        "webpack-cli": "^3.3.10",
        "webpack-dev-server": "^3.10.1"
    }
}</pre></li>
				<li>Create an <code>index.js</code> file:<pre>$ touch index.js</pre></li>
				<li>Then, run <code>npm install</code>. Modify <code>index.js</code> with the following content:<pre>import("./class_world").then(({Point}) =&gt; {
const p1 = Point.new(10, 10);
console.log(p1.get_x(), p1.get_y());
const p2 = Point.new(3, 3);
p1.add(p2);
console.log(p1.get_x(), p1.get_y());
});</pre></li>
			</ol>
			<p>We call <a id="_idIndexMarker393"/>the new method in the <code>Point</code> class <a id="_idIndexMarker394"/>and pass it <code>x</code> and <code>y</code>. We <a id="_idIndexMarker395"/>print the <code>x</code> and <code>y</code> coordinates. This will print <code>10, 10</code>. Then, we will create another point (<code>p2</code>). Finally, we call the <code>add</code> function and pass it point <code>p2</code>. This will print <code>13, 13</code>. </p>
			<ol>
				<li value="5">The getter method uses the pointer and fetches the value from the shared array:<pre>get_x() {
    return wasm.point_get_x(this.ptr);
}</pre></li>
				<li>In the <a id="_idIndexMarker396"/>setter method, we pass in the pointer and the value. Since <a id="_idIndexMarker397"/>we are just passing in a number here, there is no extra conversion needed:<pre>set_x(arg0) {
    return wasm.point_set_x(this.ptr, arg0);
}</pre></li>
				<li>In the <a id="_idIndexMarker398"/>case of <code>add</code>, we take the argument, get the pointer to the <code>Point</code> object, and pass it to the WebAssembly module:<pre>add(arg0) {
    const ptr0 = arg0.ptr;
    arg0.ptr = 0;
    return wasm.point_add(this.ptr, ptr0);
}</pre></li>
			</ol>
			<p><code>wasm-bindgen</code> makes it simple to convert a class into a WebAssembly module. We have seen how to share a class in Rust with JavaScript. Now, we will see how to share a class from JavaScript with Rust.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor117"/>Sharing classes from JavaScript with Rust </h1>
			<p>Sharing <a id="_idIndexMarker399"/>JavaScript classes with Rust is also made <a id="_idIndexMarker400"/>easy with <code>#[wasm_bindgen]</code>. Let's <a id="_idIndexMarker401"/>look at how to achieve it.</p>
			<p>JavaScript classes are objects with some methods. Rust is a strictly typed language. This means the Rust compiler needs to have concrete bindings. Without them, the compiler complains, because it needs to know about the lifetime of an object. We need a way to ensure the compiler has this API available at runtime.</p>
			<p>The extern <a id="_idIndexMarker402"/>C function block helps out here. The <a id="_idIndexMarker403"/>extern C makes a function name <a id="_idIndexMarker404"/>available in Rust.</p>
			<p>In this example, let's see how to share a class from JavaScript with Rust:</p>
			<ol>
				<li value="1">Let's create a new project:<pre><strong class="bold">$ cargo new --lib class_from_js_world</strong>
<strong class="bold">Created library `class_from_js_world` package</strong></pre></li>
				<li>Define the <code>wasm-bindgen</code> dependency for the project. Open the <code>cargo.toml</code> file and add the following content:<pre>[package]
name = "class_from_js_world"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
[lib]
crate-type = ["cdylib"]
[dependencies]
wasm-bindgen = "0.2.68"</pre></li>
			</ol>
			<p>Please copy over <code>package.json</code>, <code>index.js</code>, and <code>webpack-config.js</code> from the previous section. Then, run <code>npm install</code>.</p>
			<ol>
				<li value="3">Open the <code>src/lib.rs</code> file and replace the contents with the following:<pre>use wasm_bindgen::prelude::*;
#[wasm_bindgen(module = "./point")] . // 1
extern "C" {
     pub type Point; // 2
 
    #[wasm_bindgen(constructor)] //3
    fn new(x: i32, y: i32) -&gt; Point;
 
    #[wasm_bindgen(method, getter)] //4
    fn get_x(this: &amp;Point) -&gt; i32;
 
    #[wasm_bindgen(method, getter)]
    fn get_y(this: &amp;Point) -&gt; i32;
 
    #[wasm_bindgen(method, setter)] //5
    fn set_x(this: &amp;Point, x:i32) -&gt; i32;
 
    #[wasm_bindgen(method, setter)]
    fn set_y(this: &amp;Point, y:i32) -&gt; i32;
 
    #[wasm_bindgen(method)] // 6
    fn add(this: &amp;Point, p: Point);
}
 
#[wasm_bindgen]
fn get_precious_point() -&gt; Point { //7
    let p = Point::new(10, 10);
    let p1 = Point::new(3, 3);
    p.add(p1); // 8
    p
}</pre></li>
			</ol>
			<p>At <code>//1</code>, we are importing the JavaScript module. This will import a JavaScript file, <code>point.js</code>. Note that this file should be present in the same directory as <code>Cargo.toml</code>. Then, we create an extern C block to define the methods that we need to use.</p>
			<p>We first declare a type in the block (<code>pub type Point;</code>). Now, we can use this as <a id="_idIndexMarker405"/>any other type in the Rust <a id="_idIndexMarker406"/>code. After that, we define a <a id="_idIndexMarker407"/>list of functions. We first define the constructor. We pass in the constructor as an argument to the <code>#[wasm_bindgen]</code> annotation. Define a function that takes in arguments and returns the type declared previously. This will bind to the namespace of the Point type, and we can call <code>Point::new(x, y);</code> inside the Rust function.</p>
			<p>Then, we define getters and setters (<code>//4</code> and <code>//5</code>, respectively). We can even define a method; these are analogous to the function on the JavaScript side. Then, we have the <code>add</code> function.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">All the functions inside the extern C block are completely typed.</p>
			<p>Finally, we are exporting the <code>get_precious_point()</code> function using the <code>#[wasm_bindgen]</code> annotation. In the <code>get_precious_point</code> function, we create two <code>Point</code> with <code>Point::new(x, y)</code>, then add two points using <code>p1.add(p2)</code>.</p>
			<p>We can call this from JavaScript just like we did before. We also have to define a <code>Point</code> class on the JavaScript side.</p>
			<ol>
				<li value="4">Create <code>Point.js</code> with <a id="_idIndexMarker408"/>the following <a id="_idIndexMarker409"/>content:<pre>export class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
 
    get_x() {
        return this.x;
    }
 
    get_y() {
        return this.y;
    }
 
    set_x(x) {
        this.x = x;
    }
 
    set_y(y) {
        this.y = y;
    }
 
    add(p1) {
        this.x += p1.x;
        this.y += p1.y;
    }
}</pre></li>
				<li>Finally, replace <code>index.js</code> with the following:<pre>import("./class_from_js_world").then(module =&gt; {
    console.log(module.get_precious_point());
});</pre></li>
				<li>Now, run the following command to start the server: <pre><strong class="bold">$ npm run serve</strong></pre></li>
				<li>Open <a id="_idIndexMarker410"/>the browser and run <code>http://localhost:8000</code>. Open <a id="_idIndexMarker411"/>the developer <a id="_idIndexMarker412"/>console to see the printed object class.</li>
				<li>Let's see how the <code>#[wasm_bindgen]</code> macro is expanding the code:<pre>$ cargo expand --target=wasm32-unknown-unknown &gt;
  expanded.rs</pre></li>
			</ol>
			<p>There are a few interesting things happening here.</p>
			<p>First, the <code>type</code> point is converted into a struct. This is similar to what we did in the previous example. But the struct's members are JsValue instead of <code>x</code> and <code>y</code>. This is because <code>wasm_bindgen</code> will not know what this Point class is instantiating. So, it creates a JavaScript object and makes that its member:</p>
			<pre>pub struct Point {
    obj: ::wasm_bindgen::JsValue,
}</pre>
			<p>It also defines how to construct the Point object and how to dereference it. This is useful for the WebAssembly runtime to know when to allocate and when to dereference it.</p>
			<p>All the <a id="_idIndexMarker413"/>methods that are defined <a id="_idIndexMarker414"/>are converted into the <a id="_idIndexMarker415"/>implementation of the Point struct. As you can see, there is a lot of unsafe code in the method declaration. This is because the Rust code interacts directly with the raw pointers:</p>
			<pre>fn new(x: i32, y: i32) -&gt; Point {
#[link(wasm_import_module =
  "__wbindgen_placeholder__")]
extern "C" {
fn __wbg_new_3ffc5ccd013f4db7(x:&lt;i32 as
 ::wasm_bindgen::convert::IntoWasmAbi&gt;::Abi, y:&lt;i32 as
 ::wasm_bindgen::convert::IntoWasmAbi&gt;::Abi) -&gt; &lt;Point
 as ::wasm_bindgen::convert::FromWasmAbi&gt;::Abi;
}
 
unsafe {
let _ret = {
let mut __stack =
  ::wasm_bindgen::convert::GlobalStack::new();
let x = &lt;i32 as
  ::wasm_bindgen::convert::IntoWasmAbi&gt;::into_abi
  (x, &amp;mut __stack);
let y = &lt;i32 as
  ::wasm_bindgen::convert::IntoWasmAbi&gt;::into_abi
  (y, &amp;mut __stack);
__wbg_new_3ffc5ccd013f4db7(x, y)
};
&lt;Point as
 ::wasm_bindgen::convert::FromWasmAbi&gt;::from_abi(_ret,
 &amp;mut ::wasm_bindgen::convert::GlobalStack::new())
}
}</pre>
			<p>Shown in the previous code is the code generated by the <code>#[wasm_bindgen(constructor)]</code> macro. It first links the code with the extern C block. The arguments are then cast such that they are inferred in WebAssembly.</p>
			<p>Then, we <a id="_idIndexMarker416"/>have the unsafe block. First, space <a id="_idIndexMarker417"/>is reserved in the <a id="_idIndexMarker418"/>global stack. Then, both <code>x</code> and <code>y</code> are converted into the <code>IntoWasmAbi</code> type.</p>
			<p><code>IntoWasmAbi</code> is a trait for anything that can be converted into a type that can cross the WebAssembly ABI directly, for example, u32 or f64. Then, the function in JavaScript is called. The returned value is then cast into a <code>Point</code> type using <code>FromWasmAbi</code>.</p>
			<p><code>FromWasmAbi</code> is a trait for anything that can be recovered by value from the WebAssembly ABI boundary; for example, a Rust u8 can be recovered from the WebAssembly ABI u32 type.</p>
			<p>We have seen how to share a class in JavaScript with Rust. Now, we will see how we can call a JavaScript API in Rust.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor118"/>Calling the JavaScript API via WebAssembly </h1>
			<p>JavaScript provides a rich API to work with objects, arrays, maps, sets, and so on. If we want to use <a id="_idIndexMarker419"/>or define them in Rust, then we need to <a id="_idIndexMarker420"/>provide the necessary bindings. Handcrafting those bindings will be a huge process. But what if we have bindings to those APIs? That is a common API for both Node.js and a browser environment that will create a platform where we can write the code completely in Rust and use <code>wasm_bindgen</code> to create necessary code.</p>
			<p>The rustwasm team's answer to that is the js-sys crate.</p>
			<p class="author-quote">The js-sys crate contains raw <code>#[wasm_bindgen]</code> bindings to all the global APIs guaranteed to exist in every JavaScript environment by the ECMAScript standard. – RustWASM</p>
			<p>They provide bindings to JavaScript's standard built-in objects, including their methods and properties.</p>
			<p>In this example, let's see how to call a JavaScript API via WebAssembly:</p>
			<ol>
				<li value="1">Create a default project with the <code>cargo new</code> command:<pre><strong class="bold">$ cargo new --lib jsapi</strong></pre></li>
				<li>Copy over <code>webpack.config.js</code>, <code>index.js</code>, and <code>package.json</code> similarly to the previous example. Then, open the generated project in your favorite editor.</li>
				<li>Change the contents of <code>Cargo.toml</code>:<pre>[package]
name = "jsapi"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
 
[lib]
crate-type = ["cdylib"]
 
[dependencies]
wasm-bindgen = "0.2.68"
js-sys = "0.3.45"</pre></li>
			</ol>
			<ol>
				<li value="4">Now, open <code>src/lib.rs</code> and <a id="_idIndexMarker421"/>replace the file <a id="_idIndexMarker422"/>with the following content. We can create a JavaScript map inside Rust using the following snippet:<pre>use wasm_bindgen::prelude::*;
 
use js_sys::Map;
 
#[wasm_bindgen]
pub fn new_js_map() -&gt; Map {
    Map::new()
}</pre></li>
			</ol>
			<p>Added to the <code>wasm_bindgen</code> import, we imported the map from the <code>js_sys</code> crate using <code>use js_sys::Map;</code>.</p>
			<ol>
				<li value="5">Then, we define the <code>new_js_map</code> function, which will return a new map:<pre>#[wasm_bindgen]
pub fn set_get_js_map() -&gt; JsValue {
    let map = Map::new();
    map.set(&amp;"foo".into(), &amp;"bar".into());
    map.get(&amp;"foo".into())
}</pre></li>
			</ol>
			<p>The <code>set_get_js_map</code> function creates a new map, sets a value in the map, and then returns the value set.</p>
			<p>Note that the <a id="_idIndexMarker423"/>return type here is <code>JsValue</code>. This is <a id="_idIndexMarker424"/>a wrapper in Rust for specifying the JavaScript values. Also, note that we are passing the string into the trait functions get and set. This will return <code>bar</code> as the output when called in JavaScript.</p>
			<ol>
				<li value="6">We now also run through the map using <code>for_each</code> inside the Rust code like this:<pre>#[wasm_bindgen]
pub fn run_through_map() -&gt; f64 {
    let map = Map::new();
    map.set(&amp;1.into(), &amp;1.into());
    map.set(&amp;2.into(), &amp;2.into());
    map.set(&amp;3.into(), &amp;3.into());
    map.set(&amp;4.into(), &amp;4.into());
    map.set(&amp;5.into(), &amp;5.into());
    let mut res: f64 = 0.0;
 
    map.for_each(&amp;mut |value, _| {
        res = res + value.as_f64().unwrap();
    });
 
    res
}</pre></li>
			</ol>
			<p>This creates a map and then loads the map with the values <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code>. Then, it runs <a id="_idIndexMarker425"/>over the created map and adds <a id="_idIndexMarker426"/>the value together. This will produce an output of <code>15</code> (that is, 1 + 2 + 3 + 4 + 5).</p>
			<ol>
				<li value="7">Lastly, we replace <code>index.js</code> with the following content:<pre>import("./jsapi").then(module =&gt; {
    let m = module.new_js_map();
    m.set("Hi", "Hi");
    console.log(m); // prints Map { "Hi" -&gt;  "Hi" }
    console.log(module.set_get_js_map());  // prints
      "bar"
    console.log(module.run_through_map()); // prints
      15
});</pre></li>
			</ol>
			<p>Running this on the browser will print the result. Refer to the comments near the console log statements.</p>
			<p>Let's start with the generated JavaScript binding file. The generated binding JavaScript file has almost the same structure as in the previous section, but with a few more functions exported.</p>
			<p>The heap object is used as a stack here. All the JavaScript objects that are shared or referenced with the WebAssembly modules are stored in this heap. It is also important to note that once a value is accessed, it is popped out from the heap.</p>
			<pre>function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}</pre>
			<p>The <code>takeObject</code> function is used to fetch the object from the heap. It first gets the object at the given index. Then, it removes the object from that heap index (that is, it pops it out). Finally, it returns the value <code>ret</code>. </p>
			<p>Similarly, we <a id="_idIndexMarker427"/>can use JavaScript APIs inside Rust. The <a id="_idIndexMarker428"/>bindings are only generated for the common JavaScript API (including Node.js and the browser).</p>
			<p>We have seen how to call the JavaScript API in Rust. Now, we will see how we can call a Rust closure via WebAssembly.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor119"/>Calling closures via WebAssembly </h1>
			<p>The official <a id="_idIndexMarker429"/>Rust book defines closures as follows:</p>
			<p class="author-quote">Closures are anonymous functions which you can save in a variable or can be passed as arguments to other functions. - The Rust Programming Language (Covers Rust 2018) by Steve Klabnik and Carol Nichols (<a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">https://doc.rust-lang.org/book/ch13-00-functional-features.html</a>)</p>
			<p>MDN defines <a id="_idIndexMarker430"/>a closure for JavaScript as follows:</p>
			<p class="author-quote">A closure is the combination of a function and lexical environment within which that function was declared.- MDN Web Docs (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#closure">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#closure</a>)</p>
			<p>In general, closures are self-contained blocks of functionality that are tossed around and used in the code. They can capture and store references to the variables from the context in which they are defined.</p>
			<p>Closures and functions are similar except for a subtle difference. Closures will capture the state when it is first created. Then, whenever a closure is called, it closes over that captured state.</p>
			<p>Closures are functions with a state. When you create a closure, it captures the state. Then, we can pass around closures just like any other function. When a closure is then invoked, it closes over this captured state and executes (even when the closure is invoked outside of their captured state). That is one of the important reasons why the use of closures is increasing on the functional side of JavaScript.</p>
			<p>Closures make it easy to do data encapsulation, higher-order functions, and memoization. (Sounds functional, right? ;))</p>
			<p>Let's see how to share closures from JavaScript to Rust and vice versa:</p>
			<ol>
				<li value="1">Create a new project:<pre><strong class="bold">$ cargo new --lib closure_world</strong>
<strong class="bold">     Created library `closure_world` package</strong></pre></li>
				<li>Define the <code>wasm-bindgen</code> dependency for the project. Let's open the <code>cargo.toml</code> file and add the content highlighted in bold:<pre>[package]
name = "closure_world"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
 
[lib]
crate-type = ["cdylib"]
 
[dependencies]
<strong class="bold">wasm-bindgen = "0.2.38"</strong>
<strong class="bold">js-sys = "0.3.15"</strong></pre></li>
			</ol>
			<p>We will need <a id="_idIndexMarker431"/>the js-sys crate to copy over the <a id="_idIndexMarker432"/>closures from JavaScript into Rust. Please copy over <code>package.json</code>, <code>index.js</code>, and <code>webpack-config.js</code> from the previous section. Then, run <code>npm install</code>.</p>
			<ol>
				<li value="3">We then open the <code>src/lib.rs</code> file and add the content from our <code>Point</code> class example <a id="_idIndexMarker433"/>with an additional method that takes in JavaScript's closure function as its argument:<pre>use wasm_bindgen::prelude::*;
 
#[wasm_bindgen]
pub struct Point {
    x: i32,
    y: i32,
}
 
#[wasm_bindgen]
impl Point {
    pub fn new(x: i32, y: i32) -&gt; Point {
        Point { x: x, y: y}
    }
 
    pub fn get_x(&amp;self) -&gt; i32 {
        self.x
    }
 
    pub fn get_y(&amp;self) -&gt; i32 {
        self.y
    }
 
    pub fn set_x(&amp;mut self, x: i32) {
        self.x = x;
    }
 
    pub fn set_y(&amp;mut self, y:i32) {
        self.y = y;
    }
 
    pub fn add(&amp;mut self, p: Point) {
        self.x = self.x + p.x;
        self.y = self.y + p.y;
     }
 
    pub fn distance(&amp;self, js_func: js_sys::Function)
      -&gt; JsValue {
        let this = JsValue::NULL;
        let x = JsValue::from(self.x);
        let y = JsValue::from(self.y);
        js_func.call2(&amp;this, &amp;x, &amp;y).unwrap()
    }
}</pre></li>
			</ol>
			<p>Now, we will <a id="_idIndexMarker434"/>change <code>index.js</code> to call the <a id="_idIndexMarker435"/><code>distance</code> function with a closure:</p>
			<pre>import("./closure_world").then(({Point}) =&gt; {
     const p1 = Point.new(13, 10);
     console.log(p1.distance((x, y) =&gt; x - y));
});</pre>
			<p>Let's spin the webpack server with <code>npm run serve</code>. This will print out <code>3</code>.</p>
			<p>The js-sys crate offers an option to invoke the JavaScript function using the apply and call method. That is what we have done by calling <code>js_func.call2(&amp;this, &amp;x, &amp;y)</code>.</p>
			<p>Rust does not <a id="_idIndexMarker436"/>have function overloading. This means that we <a id="_idIndexMarker437"/>have to use different method names based on the number of arguments that we pass. So, <code>js-sys</code> offers us <code>call1</code>, <code>call2</code>, <code>call3</code>, and so on, each taking <code>1</code>, <code>2</code>, <code>3</code>, and so on arguments, respectively.</p>
			<p>Invoking a JavaScript function in Rust will return <code>Result&lt;JsValue, Error&gt;</code>. We will unwrap the result to get the JsValue and return it. <code>wasm-bindgen</code> will create the necessary binding to return the value as a number in JavaScript.</p>
			<p>On the other hand, passing a closure from Rust to JavaScript will need some extra information and options.</p>
			<p><code>wasm-bindgen</code> supports two variants here:</p>
			<ul>
				<li>Stack lifetime closures</li>
				<li>Heap-allocated closures</li>
			</ul>
			<p>Let's see what they actually mean:</p>
			<ul>
				<li>Stack lifetime closures should not be invoked by JavaScript again once the imported JavaScript function that the closure was passed to returns. This is because once the function (closure) returns, the closure will be invalidated by Rust. Any future invocations will lead to an exception. In other words, stack lifetime closures are short-lived and they go out of context once they are accessed.</li>
				<li>On the other hand, heap-allocated closures are useful for invoking the memory multiple times. Here, the validity is tied to the lifetime of the closure in Rust. Once the closure in Rust is dropped, the closure will deallocate and garbage will be collected. This will in turn invalidate the closure (function) in JavaScript. Once invalidated, any further attempts to access the closure or memory will raise an exception.</li>
			</ul>
			<p>Both the stack lifetime <a id="_idIndexMarker438"/>and heap-allocated closures support <a id="_idIndexMarker439"/>both <code>Fn</code> and <code>FnMut</code> closures, arguments, and return values.</p>
			<p>We have seen how to call a closure function. Now, we will see how to import a function from JavaScript into Rust.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor120"/>Importing the JavaScript function into Rust </h1>
			<p>In certain places, JavaScript is faster than WebAssembly because there is no overhead of boundary <a id="_idIndexMarker440"/>crossing and instantiating a separate <a id="_idIndexMarker441"/>runtime environment. JavaScript runs more naturally in its own environment.</p>
			<p>The JavaScript ecosystem is huge. There are millions of libraries created and battle tested (not all of them, of course) with JavaScript. This makes JavaScript easy (easy here is subjective).</p>
			<p>WebAssembly addresses the most important problem that we have in the frontend world, that of "consistent" performance. But it is not a complete replacement for JavaScript. WebAssembly helps JavaScript to deliver better and more consistent performance.</p>
			<p>JavaScript will be a default choice in most places. It is important to provide an ecosystem that allows seamless integration between the two. We have already seen how to import a class from JavaScript into Rust. Similarly, we can import anything from JavaScript into Rust using <code>wasm-bindgen</code>. The most important part is that we can more naturally use these imported JavaScript functions inside Rust code.</p>
			<p>In this example, let's see how to import a JavaScript function into Rust:</p>
			<ol>
				<li value="1">Create a new project:<pre><strong class="bold">$ cargo new --lib import_js_world</strong>
<strong class="bold">     Created library `import_js_world` package</strong></pre></li>
				<li>Define the <code>wasm-bindgen</code> dependency for the project. Let's open the <code>cargo.toml</code> file and add the content highlighted in bold:<pre> 
[package]
name = "import_js_world"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
 
<strong class="bold">[lib]</strong>
<strong class="bold">crate-type = ["cdylib"]</strong>
<strong class="bold"> </strong>
<strong class="bold">[dependencies]</strong>
<strong class="bold">wasm-bindgen = "0.2.38"</strong></pre></li>
				<li>Please <a id="_idIndexMarker442"/>copy over <code>package.json</code>, <code>index.js</code>, and <code>webpack-config.js</code> from the previous section. Then, run <code>npm install</code>. Then, open the <code>src/lib.rs</code> file and replace <a id="_idIndexMarker443"/>its content with the following:<pre>use wasm_bindgen::prelude::*;
 
#[wasm_bindgen(module = "./array")]
extern "C" {
    fn topArray() -&gt; f64;
    fn getNumber() -&gt; i32;
    fn lowerCase(str: &amp;str) -&gt; String;
}
 
#[wasm_bindgen]
pub fn sum_of_square_root() -&gt; f64 {
    let n = getNumber();
    let mut sum = 0;
 
    for _ in 0..n {
        sum = sum + (topArray().sqrt() as i64);
    } 
    sum
}
 
#[wasm_bindgen]
pub fn some_string_to_share() -&gt; String {
    lowerCase("HEYA! I AM ALL CAPS")
}</pre></li>
			</ol>
			<p>We start by importing the <code>wasm_bindgen</code> library. Then, we define the extern C block to <a id="_idIndexMarker444"/>define the FFI functions (that is, the functions that we import from JavaScript). Inside the extern C <a id="_idIndexMarker445"/>block, we define the function signature similar to what the Rust compiler understands. We also annotate the extern C block with <code>#[wasm_bindgen(module ="./array")]</code>. This helps the <code>wasm-bindgen</code> CLI to understand where the functions are defined and exported. It will use this information and create the necessary link.</p>
			<ol>
				<li value="4">The <code>array.js</code> file is in the same directory as the <code>cargo.toml</code> file. We will define <code>array.js</code> as follows:<pre>let someGlobalArray = [1, 4, 9, 16, 25];
 
export function getNumber() {
    return someGlobalArray.length;
}
 
export function topArray() {
    return someGlobalArray.sort().pop();
}
 
export lowerCase(str) {
    return str.toLowerCase();
}</pre></li>
			</ol>
			<p>The functions mentioned previously should be exported in the JavaScript file.</p>
			<p>We then declare a function (<code>sum_of_square_root</code>) in Rust and export it as a function <a id="_idIndexMarker446"/>in the WebAssembly module <a id="_idIndexMarker447"/>that is generated. We first call the <code>getNumber()</code> method from JavaScript. We use the return value and then run the <code>for</code> loop for the length of the array. For each loop, we call <code>topArray</code> to get the lowest element from the array. Then, we take the square root of the number (this happens in Rust code). Sum them up and return the sum (<code>15</code> for the example that we saw previously).</p>
			<ol>
				<li value="5">We will replace <code>index.js</code> with the following content:<pre>import("./import_js_world").then(module =&gt; {
    console.log(module.sum_of_square_root());
    console.log(module.some_string_to_share());
});</pre></li>
				<li>Let's run the previous code with <code>npm run serve</code>. Go to the URL and open the developer console. <code>15</code> and <code>HEYA! I AM ALL CAPS</code> will be printed in the console. </li>
				<li>Open the generated binding JavaScript file. It will be interesting to see that both the <code>getNumber</code> and <code>topArray</code> functions are not available in the generated binding <a id="_idIndexMarker448"/>JavaScript file. The main reason for <a id="_idIndexMarker449"/>this is we are just sharing numbers between the JavaScript and the WebAssembly module. Hence, the boundary crossing happens more naturally in this case.</li>
			</ol>
			<p>But there will be a function exported for the <code>some_string_to_share</code> function. This is because we are sharing a string, which needs conversion. So, the binding file will make the necessary conversion to work with the string. It is also important to note that there is a <code>getInt64Memory</code> function. This is because we are returning <code>f64</code> as output. <code>wasm-bindgen</code> converts the number into <code>bigInt</code> and returns it to JavaScript.</p>
			<ol>
				<li value="8"><code>wasm-bindgen</code> also does the necessary shifting and parsing of the byte buffer based on the byte size of the memory object. For <code>Uint32Array</code>, the pointer and memory are calculated as follows:<pre>const rustptr = mem[retptr / 4];
const rustlen = mem[retptr / 4 + 1];</pre></li>
				<li>For <code>BigInt64Array</code>, the pointer and memory are calculated as follows:<pre>const rustptr = mem[retptr / 8];
const rustlen = mem[retptr / 8 + 1];</pre></li>
			</ol>
			<p>We have seen how to import a JavaScript function into Rust. Now, we will see how we can call a web API in Rust.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor121"/>Calling a web API via WebAssembly</h1>
			<p>The evolution of <a id="_idIndexMarker450"/>the web has been phenomenal, with its growth being attributed to its open standards. Today, the web provides hundreds of APIs, which makes it easy for web developers to develop for audio, video, canvases, SVGs, USBs, batteries, and so on.</p>
			<p>The web is universal and omnipresent. It is continuously experimented with and changed to make it desirable and easy for developers and companies to use, respectively. The web-sys crate provides access to almost all the APIs that are available on the web at the moment.</p>
			<p class="author-quote">The <code>web-sys</code> crate provides raw bindings to all the Web's APIs: everything from DOM manipulation to WebGL to Web Audio to timers to fetch and more! – web-sys crates.io (<a href="https://crates.io/crates/web-sys">https://crates.io/crates/web-sys</a>)</p>
			<p>The<a id="_idIndexMarker451"/> WebIDL interface definitions are converted into <code>wasm-bindgen</code>'s internal <strong class="bold">abstract syntax trees</strong> (<strong class="bold">ASTs</strong>). Then, these ASTs are used to create zero-overhead Rust and JavaScript glue code.</p>
			<p>With the help of this binding code, we can call and manipulate the web APIs. Converting the web APIs into Rust ensures the type information of parameters and return values is handled correctly and safely.</p>
			<p>In this example, let's call a web API via WebAssembly:</p>
			<ol>
				<li value="1">Create a default project with the <code>cargo new</code> command:<pre><strong class="bold">$ cargo new --lib web_sys_api</strong>
<strong class="bold">    Created library `web_sys_api` package</strong></pre></li>
				<li>Copy over <code>webpack.config.js</code>, <code>index.js</code>, and <code>package.json</code> similarly to the <code>jsapi</code> section (in the above section). We'll now open the generated project in our favorite editor. Let's change the contents of <code>cargo.toml</code>:<pre>[package]
name = "web_sys_api"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
 
[lib]
crate-type = ["cdylib"]
 
[dependencies]
wasm-bindgen = "0.2.38"
 
[dependencies.web-sys]
version = "0.3.4"
features = [
    'Document',
    'Element',
    'HtmlElement',
    'Node',
    'Window',
]</pre></li>
			</ol>
			<p>The major difference <a id="_idIndexMarker452"/>here is that instead of just defining the dependency and its version, we also defined the features that we will be using in this example.</p>
			<p>Why do we need it? Since there is a huge number of APIs in the web ecosystem, we do not want to carry bindings for all of them. The binding files are created and used only for the listed features.</p>
			<ol>
				<li value="3">Let's <a id="_idIndexMarker453"/>open <code>src/lib.rs</code> and replace the file with the following content:<pre>use wasm_bindgen::prelude::*;
 
#[wasm_bindgen]
pub fn draw(percent: i32) -&gt; Result&lt;web_sys::Element,
  JsValue&gt; {
    let window = web_sys::window().unwrap();
    let document = window.document().unwrap();
 
    let div = document.create_element("div")?;
    let ns = Some("http://www.w3.org/2000/svg");
 
    div.set_attribute("class", "pie")?;
 
    let svg = document.create_element_ns( ns, "svg")?;
    svg.set_attribute("height", "100")?;
    svg.set_attribute("width", "100")?;
    svg.set_attribute("viewBox", "0 0 32 32")?;
 
    let circle = document.create_element_ns(ns,
      "circle")?;
    circle.set_attribute("r", "16")?;
    circle.set_attribute("cx", "16")?;
    circle.set_attribute("cy", "16")?;
    circle.set_attribute("stroke-dasharray",
      &amp;(percent.to_string().to_owned() +" 100"))?;
 
    svg.append_child(&amp;circle)?;
 
    div.append_child(&amp;svg)?;
 
    Ok(div)
}</pre></li>
			</ol>
			<p>We first fetch the window using <code>web_sys::window()</code>. The unwrap at the end makes sure the window is available. If it is not, it will throw an error. After that, we get <a id="_idIndexMarker454"/>the document from the window object. We then create a <code>div</code> element with <code>document.createElement</code>. Then, we create an SVG and circle document element and append the circle to the SVG element. Finally, we append the SVG as a child to the <code>div</code> element and return the <code>div</code> element.</p>
			<p>The API is quite similar to the web API except for the fact that the method names are using snake case instead of camel case.</p>
			<ol>
				<li value="4">We will change <code>index.js</code> to use this element as a web component:<pre>import("./web_sys_api").then(module =&gt; {
    class Pie extends HTMLElement {
        constructor() {
            super();
            let shadow = this.attachShadow({ mode:
              'open' });
            let style =
              document.createElement('style');
 
            style.textContent = `
                    svg {
                        width:100px;
                        height: 100px;
                        background: yellowgreen;
                        border-radius: 50%;
                    }
 
                    circle {
                        fill: yellowgreen;
                        stroke: #655;
                        stroke-width: 32;
                    }`;
 
           shadow.appendChild(module.draw(this.
           getAttribute
           ('value'));
           shadow.appendChild(style);
       }
   }
 
    customElements.define('pie-chart', Pie);
 
    setInterval(() =&gt; {
        let r = Math.floor(Math.random() * 100);
        document.getElementsByTagName('body')[0].
          innerHTML = `
            &lt;pie-chart value='${r}' /&gt;`;
    }, 1000);
});</pre></li>
			</ol>
			<p>So, what have we done here? We first imported the binding file, which will, in turn, initialize the WebAssembly module. Once the WebAssembly module is initialized, we <a id="_idIndexMarker455"/>create a <code>Pie</code> class that extends the HTML element. Inside the class' constructor, we call the <code>super</code> method. Then, we create a shadow DOM. We add a style element to the shadow DOM, and then define the style for the element.</p>
			<p>We go on to append the style element to the shadow element, and then add the element that is exported from the Rust code. We then register it as a custom element named <code>pie-chart</code>. Finally, we append the custom element to our document's body to see the pie chart getting displayed. </p>
			<ol>
				<li value="5">Now, run the following command:<pre><strong class="bold">$ npm run serve</strong></pre></li>
			</ol>
			<p>Open the browser to see the pie chart. </p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor122"/>Summary</h1>
			<p>In this chapter, we saw how <code>wasm-bindgen</code> makes it easy to share complex objects between JavaScript and Rust. The annotations make it easy to mark a function to export/import between JavaScript and WebAssembly. We also saw how js-sys and web-sys Cargo make it easier to call JavaScript and web APIs inside Rust code easily.</p>
			<p>In the next chapter, we will see how to optimize the generated WebAssembly module in Rust.</p>
		</div>
	</body></html>