- en: '*Chapter 5*: Designing a User-Generated Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to write a Rocket application in order to learn more about the
    Rocket web framework. In this chapter, we are going to design the application
    and create an application skeleton. Then, we are going to split the application
    skeleton into smaller manageable modules.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will be able to design and create an application
    skeleton and modularize your own application to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a user-generated web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning the user struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating application routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularizing a Rocket application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we have the same technical requirements as the previous chapter.
    We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database
    server.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter05](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Designing a user-generated web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, we have gained some fundamental knowledge about the Rocket framework,
    such as routes, requests, responses, states, and fairings. Let's expand on that
    knowledge and learn more about the Rocket framework's other capabilities, such
    as request guards, cookies systems, forms, uploading, and templating, by creating
    a full-fledged application.
  prefs: []
  type: TYPE_NORMAL
- en: The idea for our application is one that handles various operations for the
    user, and each user can create and delete user-generated content such as text,
    photos, or videos.
  prefs: []
  type: TYPE_NORMAL
- en: We can start by creating requirements for what we want to do. In various development
    methodologies, there are many forms and names for defining requirements, such
    as user stories, use cases, software requirements, or software requirement specifications.
  prefs: []
  type: TYPE_NORMAL
- en: After specifying the requirements, we can usually create an application skeleton.
    We can then implement the application and test the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, because we want to be practical and understand what is going on
    at the code level, we will specify the requirements and create the application
    skeleton in the same step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new application. Then, name the application `"our_application"`
    and include the `rocket` and `rocket_db_pools` crates in `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `src/main.rs` file to remove the `main()` function and make sure
    we have the most basic Rocket application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's go to the next step by planning what user data we want to have in our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the user struct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write the struct for the user in the application. At the most basic level,
    we want to have `uuid` with the `Uuid` type as a unique identifier, and `username`
    with the `String` type as a human-rememberable identifier. Then, we can add extra
    columns such as `email` and `description` with a `String` type to store a little
    bit more information about our user.
  prefs: []
  type: TYPE_NORMAL
- en: We also want to have `password` for the user data but having a cleartxt `password`
    field is not an option. There are a couple of hashing options, but obviously,
    we cannot use insecure old hashing functions such as `md5` or `sha1`. We can,
    however, use newer secure hashing encryptions such as `bcrypt`, `scrypt`, or `argon2`.
    In this book, we will use the `argon2id` function, as it is more resistant to
    `String` as the `password_hash` type.
  prefs: []
  type: TYPE_NORMAL
- en: We also want a `status` column for our users. The status can be either `active`
    or `inactive`, so we can use the `bool` type. But, in the future, we might want
    it to be expandable and have other statuses, such as `confirmed` if we require
    the user to include email information and confirm their email before they can
    use our application. We have to use another type.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, we have `enum`, a type with many variants. We can either have an enum
    with an **implicit discriminator** or an **explicit discriminator**.
  prefs: []
  type: TYPE_NORMAL
- en: An implicit discriminator enum is an enum in which the member is not given a
    discriminator; it automatically starts from `0`, for example, `enum Status {Active,
    Inactive}`. Using an implicit discriminator enum means we have to add a new data
    type in PostgreSQL using the `CREATE TYPE` SQL statement, for example, `CREATE
    TYPE status AS ENUM ('active', 'inactive');`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use an explicit discriminator enum, that is, an enum in which the member
    is given a discriminator, we can use the PostgreSQL `INTEGER` type and map it
    to `rust i32`. An explicit discriminator enum looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Because it's simpler to use an explicit discriminator enum, we will choose this
    type for the user status column.
  prefs: []
  type: TYPE_NORMAL
- en: We also want to keep track of when user data is created and when it is updated.
    The Rust standard library provides `std::time` for temporal quantification types,
    but this module is very primitive and not usable for day-to-day operations. There
    are several attempts to create a good date and time library for Rust, such as
    the `time` or `chrono` crates, and fortunately, `sqlx` already supports both crates.
    We chose to use `chrono` for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on those requirements, let''s write the struct definition and the `sqlx`
    migration for the `User` type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Cargo.toml`, add the `sqlx`, `chrono`, and `uuid` crates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/main.rs`, add the `UserStatus` enum and the `User` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we set the `UserStatus` enum with an explicit discriminator and,
    in the `User` struct, we used `UserStatus` as the status type.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, let''s set the database URL configuration in the `Rocket.toml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterward, create the database migration using the `sqlx migrate add` command
    again, and modify the generated migration file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we set `INTEGER`, which corresponds to `i32` in Rust as a `status`
    column type. One more thing to notice is because the `UNIQUE` constraints in PostgreSQL
    already automatically create an index for `username` and `email`, we don't need
    to add custom indices for those two columns.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to run the `sqlx migrate run` command line again to run this migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s initialize the database connection pool fairing by adding these lines
    in `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After our `User` struct is ready, the next thing we can do is write the code
    skeleton for user-related routes, such as creating or deleting users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating user routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous application, we dealt primarily with getting user data, but
    in a real-world application, we also want other operations such as inserting,
    updating, and deleting data. We can expand the two functions to get user data
    (user and users) into **create, read, update, and delete** (**CRUD**) functions.
    These four basic functions can be considered fundamental operations of persistent
    data storage.
  prefs: []
  type: TYPE_NORMAL
- en: In a web application, an architecture style exists to perform operations based
    on the HTTP method. If we want to get an entity or a collection of entities, we
    use the `HTTP GET` method. If we want to create an entity, we use the `HTTP POST`
    method. If we want to update an entity, we use the `HTTP PUT` or `PATCH` method.
    And finally, if we want to delete an entity, we use the `HTTP DELETE` method.
    Using those HTTP methods to deliver data uniformly is called **representational
    state transfer** (**REST**), and an application following that constraint is called
    **RESTful**.
  prefs: []
  type: TYPE_NORMAL
- en: Before we create RESTful user routes for our application, let's think about
    what incoming parameters we want to handle and what responses we want to return.
    In the previous chapters, we have created routes that returned `String`, but most
    of the web is composed of HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'For user route responses, we want HTML, so we can use `rocket::response::content::RawHtml`.
    We can wrap it in `Result`, with `Status` as the error type. Let''s make a type
    alias to avoid writing `Result<RawHtml<String>, Status>` every time we use it
    as a route function return type. Add this in `src/main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For user route requests, the request payload will be different depending on
    what the request is. For a function that uses GET to obtain a particular user
    information, we would need to know the identifier of the user, in our case, it
    would be `uuid` in the `&str` type. We just need the reference (`&str`) because
    we are not going to process `uuid`, so we don''t need the `String` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will emit a warning if we define a variable or pass a parameter
    but do not use it, so we use an underscore (`_`) before the variable name in the
    function argument to suppress the compiler warning for now. We will change the
    variable to one without an underscore in front of it when we are implementing
    the function later.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the `unimplemented!` macro, the `todo!` macro is useful for prototyping.
    The semantic difference is that if we use `todo!`, we are saying that the code
    will be implemented, but if we use `unimplemented!`, we are not making any promises.
  prefs: []
  type: TYPE_NORMAL
- en: Mount the route and try running the application now and make the HTTP request
    to this endpoint. You can see how the application will panic, but fortunately,
    Rocket handles catching the panic in the server using the `std::panic::catch_unwind`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: For the list of users, we have to think about the scalability of our application.
    If we have a lot of users, it would not be very efficient if we tried to query
    all the users. We need to introduce some kind of pagination in our application.
  prefs: []
  type: TYPE_NORMAL
- en: One of the weaknesses of using `Uuid` as an entity ID is that we cannot sort
    and order the entity by its ID. We have to use another ordered field. Fortunately,
    we have defined the `created_at` field with `TIMESTAMPZ`, which has a 1-microsecond
    resolution and can be ordered.
  prefs: []
  type: TYPE_NORMAL
- en: But, be aware that if your application is handling high traffic or will be in
    distributed systems, the microsecond resolution might not be enough. You can calculate
    the chance of collision of `TIMESTAMPZ` using a formula to calculate the *birthday
    paradox*. You can solve this problem with a monotonic ID or hardware and a database
    supporting a nanosecond resolution, but a highly-scalable application is beyond
    the scope of this book for the Rocket web framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the `Pagination` struct for now and then we will implement this
    struct later. As we want to use `Pagination` in the list of users and we will
    use it as a `request` parameter, we can automatically use `#[derive(FromForm)]`
    to make auto-generation for the `rocket::form::FromForm` implementation. But,
    we have to create a new type, `OurDateTime`, because orphan rules mean we cannot
    implement `rocket::form::FromForField` for `DateTime<Utc>;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make an unimplemented function for the list of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a page to fill in the form for inputting new user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can create a function to handle the creation of user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a page to modify existing user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We need functions to handle updating user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: What's the difference between `PUT` and `PATCH`? Simply put, in REST, a `PUT`
    request is used if we want to replace the resource completely, and `PATCH` is
    used to update data partially.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last user-related function is a function to execute `HTTP DELETE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: After creating user-related route handling functions, we can expand our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Making user-generated contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An application that only handles user data is not fun, so we will add the capability
    for our users to upload and delete posts. Each post can be either a text post,
    a photo post, or a video post. Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the definition for `Post`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to differentiate the type, so we added the `post_type` column. We also
    want to make a relationship between the user and posts. As we want the user to
    be able to create many posts, we can create a `user_uuid` field in the struct.
    The content will be used to store either text content or the file path where we
    store the uploaded file. We will deal with the data migration on application implementation
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way each post is presented might be different on our HTML, but it will
    occupy the same part on the web page, so let''s make a `DisplayPostContent` trait
    and three `DisplayPostContent` for each newtype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can add the routes for handling `Post`. We can create `get_post`,
    `get_posts`, `create_post`, and `delete_post`. We also want these routes to be
    under a user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After adding post-related types and functions, we can finalize creating the
    application skeleton in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Don''t forget to add these routes to the Rocket initialization process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to serve the uploaded file through a route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to add our default error handling! Other frameworks usually have a default
    error handler for HTTP status codes `404`, `422`, and `500`. Let''s make a handler
    for these codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: When we run the application using Cargo's `run` command, the application should
    launch correctly. But, when we look at `src/main.rs`, the file has a lot of functions
    and type definitions. We will modularize our application in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing the Rocket application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember in [*Chapter 1*](B16825_01_ePub.xhtml#_idTextAnchor014), *Introducing
    the Rust Language*, when we made an application with modules? One of the functions
    of the application source code is to use it as documentation for the people working
    on the application. A good readable code can be easily further developed and shared
    with other people on the team.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler does not care whether the program is in one file or multiple files;
    the resulting application binary is the same. However, people working on a single,
    long file can get confused very easily.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to split our application source code into smaller files and categorize
    the files into different modules. Programmers come from various backgrounds and
    may have their own paradigm on how to split the source code of the application.
    For example, programmers who are used to writing Java programs may prefer organizing
    their code based on the logical entities or classes. People who are used to Model-Viev-Controller
    (MVC) frameworks may prefer putting files in models, views, and controllers folders.
    People who are used to clean architecture may try to organize their code into
    layers. But, at the end of the day, what really matters is that the way you organize
    your code is accepted by the people you work with, and they can all comfortably
    and easily use the same source code.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket does not have specific guidelines on how to organize the code, but there
    are two things that we can observe to modularize our application. The first one
    is the `Cargo` project package layout convention, and the second one is the Rocket
    parts themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Cargo documentation ([https://doc.rust-lang.org/cargo/guide/project-layout.html](https://doc.rust-lang.org/cargo/guide/project-layout.html)),
    the package layout should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Since we don't have benchmarks, examples, or tests yet, let's focus on the `src`
    folder. We can split the application into an executable in `src/main.rs` and a
    library in `src/lib.rs`. It's very common in an executable project to make a small
    executable code that only calls the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know Rocket has different parts, so it''s a good idea to split the
    Rocket components into their own module. Let''s organize our source code into
    these files and folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'First, edit the `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `src/lib.rs` file and the following folders: `src/catchers`, `src/fairings`,
    `src/models`, `src/routes`, `src/states`, `src/traits`, and `src/views`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, create a `mod.rs` file inside each folder: `src/catchers/mod.rs`,
    `src/fairings/mod.rs`, `src/models/mod.rs`, `src/routes/mod.rs`, `src/states/mod.rs`,
    `src/traits/mod.rs`, and `src/views/mod.rs`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, edit `src/lib.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the connection for our database first. Edit `src/fairings/mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make a new file, `src/fairings/db.rs`, and write the file just like the connection
    we defined earlier in `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we use only use a smaller number of modules compared to `src/main.rs`.
    We also added the `pub` keyword in order to make the struct accessible from other
    modules or from `src/main.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the trait is going to be used by the structs, we need to define the
    trait first. In `src/traits/mod.rs`, copy the trait from `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, let''s move all of our structs for requests and responses to the
    `src/models` folder. Edit `src/models/mod.rs` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the files and copy the definition from `src/main.rs` to those
    files. The first one is `src/models/our_date_time.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next is `src/models/pagination.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the `use` declaration uses the `super` keyword. The Rust module is organized
    by hierarchy, with a module containing other modules. The `super` keyword is used
    to access the module containing the current module. The `super` keyword can be
    chained, for example, `use super::super::SomeModule;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, write `src/models/post_type.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, write `src/models/post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then, write `src/models/user_status.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Write `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then, write the three `post` newtypes, `src/models/photo_post.rs`, `src/models/text_post.rs`,
    and `src/models/video_post.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: In all three files, we use the `crate` keyword in the `use` declaration. We
    have discussed the `super` keyword before; the `crate` keyword is referring to
    the current library we are working on, which is the `our_application` library.
    In Rust 2015 edition, it's written as a double semicolon (`::`), but since Rust
    2018 edition, `::` changed to `crate`. Now, `::` means the root path of the external
    crate, for example, `::rocket::fs::NamedFile;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `super`, `::`, and `crate`, there are a couple more `use` declaration:
    `self` and `Self`. We can use `self` to avoid ambiguity when referring to items
    in code, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '`Self` is used to refer to an associated type in a trait, as shown in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s get back to the application skeleton. After all the structs, it''s
    time to write routes for the application. Modify `src/routes/mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could put the function handling assets in their own Rust file, but since
    there's only one function and it's very simple, we can just put the function in
    the `mod.rs` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create and write `src/routes/post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and write `src/routes/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And, to finalize the library, add the catchers in `src/catchers/mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the library is ready, we can modify `src/main.rs` itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `src/main.rs` file has become cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we want to add more structs or routes, we can easily add new modules
    in the corresponding folders. We can also add more states or fairings and easily
    find the file location for those items.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to design an application, create a Rocket application
    skeleton, and organize the Rust application into smaller manageable modules.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about concepts such as CRUD and RESTful applications, Rust `enum`
    discriminators, and Rust path qualifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, after reading this chapter, you can apply those concepts to help
    you organize your code better.
  prefs: []
  type: TYPE_NORMAL
- en: We will start implementing this application and learn more about Rust and Rocket
    concepts such as templating, request guards, cookies, and JSON, in the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
