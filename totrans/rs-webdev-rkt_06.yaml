- en: '*Chapter 5*: Designing a User-Generated Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：设计用户生成型应用程序'
- en: We are going to write a Rocket application in order to learn more about the
    Rocket web framework. In this chapter, we are going to design the application
    and create an application skeleton. Then, we are going to split the application
    skeleton into smaller manageable modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个Rocket应用程序，以便更多地了解Rocket网络框架。在本章中，我们将设计应用程序并创建应用程序骨架。然后，我们将把应用程序骨架拆分成更小的可管理模块。
- en: After reading this chapter, you will be able to design and create an application
    skeleton and modularize your own application to your liking.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将能够设计和创建应用程序骨架，并将您的应用程序模块化到您喜欢的程度。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Designing a user-generated web application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用户生成型网络应用程序
- en: Planning the user struct
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划用户结构
- en: Creating application routes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建应用程序路由
- en: Modularizing a Rocket application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化Rocket应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we have the same technical requirements as the previous chapter.
    We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database
    server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们与上一章有相同的技术要求。我们需要一个Rust编译器、一个文本编辑器、一个HTTP客户端和一个PostgreSQL数据库服务器。
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter05](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter05](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter05)找到本章的源代码。
- en: Designing a user-generated web application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计用户生成型网络应用程序
- en: Up to now, we have gained some fundamental knowledge about the Rocket framework,
    such as routes, requests, responses, states, and fairings. Let's expand on that
    knowledge and learn more about the Rocket framework's other capabilities, such
    as request guards, cookies systems, forms, uploading, and templating, by creating
    a full-fledged application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经获得了一些关于Rocket框架的基本知识，例如路由、请求、响应、状态和公平性。让我们在此基础上扩展知识，并通过创建一个完整的应用程序来学习Rocket框架的其他功能，如请求守卫、cookies系统、表单、上传和模板。
- en: The idea for our application is one that handles various operations for the
    user, and each user can create and delete user-generated content such as text,
    photos, or videos.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的想法是处理用户的各种操作，并且每个用户都可以创建和删除用户生成的内容，例如文本、照片或视频。
- en: We can start by creating requirements for what we want to do. In various development
    methodologies, there are many forms and names for defining requirements, such
    as user stories, use cases, software requirements, or software requirement specifications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先创建我们想要执行的要求。在各种开发方法中，有许多形式和名称用于定义要求，例如用户故事、用例、软件要求或软件需求规范。
- en: After specifying the requirements, we can usually create an application skeleton.
    We can then implement the application and test the implementation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要求后，我们通常可以创建应用程序骨架。然后，我们可以实现应用程序并测试实现。
- en: In our case, because we want to be practical and understand what is going on
    at the code level, we will specify the requirements and create the application
    skeleton in the same step.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，因为我们希望实用并理解代码层面的情况，我们将指定要求并在同一步骤中创建应用程序骨架。
- en: 'Let''s start by creating a new application. Then, name the application `"our_application"`
    and include the `rocket` and `rocket_db_pools` crates in `Cargo.toml`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的应用程序开始。然后，将应用程序命名为`"our_application"`，并在`Cargo.toml`中包含`rocket`和`rocket_db_pools`crate：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Modify the `src/main.rs` file to remove the `main()` function and make sure
    we have the most basic Rocket application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`src/main.rs`文件以删除`main()`函数，并确保我们拥有最基本Rocket应用程序：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's go to the next step by planning what user data we want to have in our
    application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过规划我们希望在应用程序中拥有的用户数据来进入下一步。
- en: Planning the user struct
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规划用户结构
- en: Let's write the struct for the user in the application. At the most basic level,
    we want to have `uuid` with the `Uuid` type as a unique identifier, and `username`
    with the `String` type as a human-rememberable identifier. Then, we can add extra
    columns such as `email` and `description` with a `String` type to store a little
    bit more information about our user.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序中编写用户结构。在最基本层面上，我们希望有一个`uuid`字段，其类型为`Uuid`，作为唯一标识符，以及一个`username`字段，其类型为`String`，作为人类可记忆的标识符。然后，我们可以添加额外的列，例如`email`和`description`，其类型为`String`，以存储有关我们用户的一些更多信息。
- en: We also want to have `password` for the user data but having a cleartxt `password`
    field is not an option. There are a couple of hashing options, but obviously,
    we cannot use insecure old hashing functions such as `md5` or `sha1`. We can,
    however, use newer secure hashing encryptions such as `bcrypt`, `scrypt`, or `argon2`.
    In this book, we will use the `argon2id` function, as it is more resistant to
    `String` as the `password_hash` type.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望用户数据中包含 `password`，但是拥有明文 `password` 字段不是一个选择。有几个哈希选项，但是显然，我们不能使用不安全的旧哈希函数，如
    `md5` 或 `sha1`。然而，我们可以使用更安全的哈希加密，如 `bcrypt`、`scrypt` 或 `argon2`。在这本书中，我们将使用 `argon2id`
    函数，因为它对 `String` 作为 `password_hash` 类型具有更强的抵抗力。
- en: We also want a `status` column for our users. The status can be either `active`
    or `inactive`, so we can use the `bool` type. But, in the future, we might want
    it to be expandable and have other statuses, such as `confirmed` if we require
    the user to include email information and confirm their email before they can
    use our application. We have to use another type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望为我们的用户添加一个 `status` 列。状态可以是 `active` 或 `inactive`，因此我们可以使用 `bool` 类型。但是，在未来，我们可能希望它具有可扩展性，并具有其他状态，例如，如果要求用户在可以使用我们的应用程序之前包含电子邮件信息并确认他们的电子邮件，则可以使用
    `confirmed`。我们必须使用另一种类型。
- en: In Rust, we have `enum`, a type with many variants. We can either have an enum
    with an **implicit discriminator** or an **explicit discriminator**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，我们有 `enum`，这是一个具有多个变体的类型。我们可以有一个具有隐式区分符或显式区分符的枚举。
- en: An implicit discriminator enum is an enum in which the member is not given a
    discriminator; it automatically starts from `0`, for example, `enum Status {Active,
    Inactive}`. Using an implicit discriminator enum means we have to add a new data
    type in PostgreSQL using the `CREATE TYPE` SQL statement, for example, `CREATE
    TYPE status AS ENUM ('active', 'inactive');`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式区分符枚举是一个成员没有被赋予区分符的枚举；它自动从 `0` 开始，例如，`enum Status {Active, Inactive}`。使用隐式区分符枚举意味着我们必须在
    PostgreSQL 中使用 `CREATE TYPE` SQL 语句添加一个新的数据类型，例如，`CREATE TYPE status AS ENUM ('active',
    'inactive');`。
- en: 'If we use an explicit discriminator enum, that is, an enum in which the member
    is given a discriminator, we can use the PostgreSQL `INTEGER` type and map it
    to `rust i32`. An explicit discriminator enum looks like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用显式区分符枚举，即成员被赋予区分符的枚举，我们可以使用 PostgreSQL 的 `INTEGER` 类型并将其映射到 `rust i32`。一个显式区分符枚举看起来如下所示：
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because it's simpler to use an explicit discriminator enum, we will choose this
    type for the user status column.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用显式区分符枚举更简单，所以我们将选择这种类型作为用户状态列。
- en: We also want to keep track of when user data is created and when it is updated.
    The Rust standard library provides `std::time` for temporal quantification types,
    but this module is very primitive and not usable for day-to-day operations. There
    are several attempts to create a good date and time library for Rust, such as
    the `time` or `chrono` crates, and fortunately, `sqlx` already supports both crates.
    We chose to use `chrono` for this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望跟踪用户数据何时创建以及何时更新。Rust 标准库提供了 `std::time` 用于时间量化类型，但这个模块非常原始，不适合日常操作。有几个尝试为
    Rust 创建好的日期和时间库，例如 `time` 或 `chrono` 依赖项，幸运的是，`sqlx` 已经支持这两个依赖项。我们选择使用 `chrono`
    作为这本书。
- en: 'Based on those requirements, let''s write the struct definition and the `sqlx`
    migration for the `User` type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些要求，让我们编写 `User` 类型的结构定义和 `sqlx` 迁移：
- en: 'In `Cargo.toml`, add the `sqlx`, `chrono`, and `uuid` crates:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 中，添加 `sqlx`、`chrono` 和 `uuid` 依赖项：
- en: '[PRE18]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In `src/main.rs`, add the `UserStatus` enum and the `User` struct:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中，添加 `UserStatus` 枚举和 `User` 结构体：
- en: '[PRE19]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that we set the `UserStatus` enum with an explicit discriminator and,
    in the `User` struct, we used `UserStatus` as the status type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们设置了具有显式区分符的 `UserStatus` 枚举，并在 `User` 结构体中使用了 `UserStatus` 作为状态类型。
- en: 'After that, let''s set the database URL configuration in the `Rocket.toml`
    file:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，让我们在 `Rocket.toml` 文件中设置数据库 URL 配置：
- en: '[PRE20]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Afterward, create the database migration using the `sqlx migrate add` command
    again, and modify the generated migration file as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次使用 `sqlx migrate add` 命令创建数据库迁移，并按如下方式修改生成的迁移文件：
- en: '[PRE21]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we set `INTEGER`, which corresponds to `i32` in Rust as a `status`
    column type. One more thing to notice is because the `UNIQUE` constraints in PostgreSQL
    already automatically create an index for `username` and `email`, we don't need
    to add custom indices for those two columns.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们设置了 `INTEGER`，它在 Rust 中对应于 `i32` 作为 `status` 列类型。还有一点需要注意，因为 PostgreSQL
    中的 `UNIQUE` 约束已经自动为 `username` 和 `email` 创建了索引，所以我们不需要为这两个列添加自定义索引。
- en: Don't forget to run the `sqlx migrate run` command line again to run this migration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记再次运行 `sqlx migrate run` 命令行以运行此迁移。
- en: 'Let''s initialize the database connection pool fairing by adding these lines
    in `src/main.rs`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `src/main.rs` 中添加这些行来初始化数据库连接池公平处理：
- en: '[PRE22]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After our `User` struct is ready, the next thing we can do is write the code
    skeleton for user-related routes, such as creating or deleting users.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `User` 结构体准备好之后，接下来我们可以编写与用户相关的路由的代码框架，例如创建或删除用户。
- en: Creating user routes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户路由
- en: In the previous application, we dealt primarily with getting user data, but
    in a real-world application, we also want other operations such as inserting,
    updating, and deleting data. We can expand the two functions to get user data
    (user and users) into **create, read, update, and delete** (**CRUD**) functions.
    These four basic functions can be considered fundamental operations of persistent
    data storage.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的应用程序中，我们主要处理获取用户数据，但在现实世界的应用程序中，我们还想进行其他操作，如插入、更新和删除数据。我们可以将获取用户数据（用户和用户列表）的两个函数扩展为
    **创建、读取、更新和删除** (**CRUD**) 函数。这四个基本函数可以被认为是持久数据存储的基本操作。
- en: In a web application, an architecture style exists to perform operations based
    on the HTTP method. If we want to get an entity or a collection of entities, we
    use the `HTTP GET` method. If we want to create an entity, we use the `HTTP POST`
    method. If we want to update an entity, we use the `HTTP PUT` or `PATCH` method.
    And finally, if we want to delete an entity, we use the `HTTP DELETE` method.
    Using those HTTP methods to deliver data uniformly is called **representational
    state transfer** (**REST**), and an application following that constraint is called
    **RESTful**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个Web应用程序中，存在一种基于HTTP方法的架构风格来执行操作。如果我们想获取一个实体或一组实体，我们使用 `HTTP GET` 方法。如果我们想创建一个实体，我们使用
    `HTTP POST` 方法。如果我们想更新一个实体，我们使用 `HTTP PUT` 或 `PATCH` 方法。最后，如果我们想删除一个实体，我们使用 `HTTP
    DELETE` 方法。使用这些HTTP方法来统一传递数据被称为 **表征状态转移** (**REST**)，遵循该约束的应用程序被称为 **RESTful**。
- en: Before we create RESTful user routes for our application, let's think about
    what incoming parameters we want to handle and what responses we want to return.
    In the previous chapters, we have created routes that returned `String`, but most
    of the web is composed of HTML.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为应用程序创建RESTful用户路由之前，让我们考虑我们想要处理哪些传入参数以及我们想要返回哪些响应。在前面的章节中，我们创建了返回 `String`
    的路由，但大多数Web都是由HTML组成的。
- en: 'For user route responses, we want HTML, so we can use `rocket::response::content::RawHtml`.
    We can wrap it in `Result`, with `Status` as the error type. Let''s make a type
    alias to avoid writing `Result<RawHtml<String>, Status>` every time we use it
    as a route function return type. Add this in `src/main.rs`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户路由响应，我们希望得到HTML，所以我们可以使用 `rocket::response::content::RawHtml`。我们可以将其包裹在
    `Result` 中，以 `Status` 作为错误类型。让我们创建一个类型别名以避免每次使用它作为路由函数返回类型时都写 `Result<RawHtml<String>,
    Status>`。在 `src/main.rs` 中添加以下内容：
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For user route requests, the request payload will be different depending on
    what the request is. For a function that uses GET to obtain a particular user
    information, we would need to know the identifier of the user, in our case, it
    would be `uuid` in the `&str` type. We just need the reference (`&str`) because
    we are not going to process `uuid`, so we don''t need the `String` type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户路由请求，请求的有效负载将根据请求的内容而有所不同。对于使用GET获取特定用户信息的函数，我们需要知道用户的标识符，在我们的例子中，它将是 `uuid`
    类型中的 `&str`。我们只需要引用（`&str`），因为我们不会处理 `uuid`，所以不需要 `String` 类型：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The compiler will emit a warning if we define a variable or pass a parameter
    but do not use it, so we use an underscore (`_`) before the variable name in the
    function argument to suppress the compiler warning for now. We will change the
    variable to one without an underscore in front of it when we are implementing
    the function later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义了一个变量或传递了一个参数但没有使用它，编译器会发出警告，所以我们现在在函数参数的变量名前使用下划线（`_`）来抑制编译器警告。在我们稍后实现函数时，我们会将变量改为前面没有下划线的变量。
- en: Just like the `unimplemented!` macro, the `todo!` macro is useful for prototyping.
    The semantic difference is that if we use `todo!`, we are saying that the code
    will be implemented, but if we use `unimplemented!`, we are not making any promises.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `unimplemented!` 宏一样，`todo!` 宏对于原型设计很有用。语义上的区别是，如果我们使用 `todo!`，我们是在说代码将会被实现，而如果我们使用
    `unimplemented!`，我们并没有做出任何承诺。
- en: Mount the route and try running the application now and make the HTTP request
    to this endpoint. You can see how the application will panic, but fortunately,
    Rocket handles catching the panic in the server using the `std::panic::catch_unwind`
    function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载路由并尝试现在运行应用程序，并对该端点进行HTTP请求。你可以看到应用程序将如何引发恐慌，但幸运的是，Rocket使用`std::panic::catch_unwind`函数在服务器中处理捕获恐慌。
- en: For the list of users, we have to think about the scalability of our application.
    If we have a lot of users, it would not be very efficient if we tried to query
    all the users. We need to introduce some kind of pagination in our application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户列表，我们必须考虑我们应用程序的可扩展性。如果我们有很多用户，如果我们尝试查询所有用户，这不会非常高效。我们需要在我们的应用程序中引入某种分页。
- en: One of the weaknesses of using `Uuid` as an entity ID is that we cannot sort
    and order the entity by its ID. We have to use another ordered field. Fortunately,
    we have defined the `created_at` field with `TIMESTAMPZ`, which has a 1-microsecond
    resolution and can be ordered.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Uuid`作为实体ID的一个弱点是我们不能按其ID对实体进行排序和排序。我们必须使用另一个有序字段。幸运的是，我们已经定义了具有1微秒分辨率的`created_at`字段，它可以进行排序。
- en: But, be aware that if your application is handling high traffic or will be in
    distributed systems, the microsecond resolution might not be enough. You can calculate
    the chance of collision of `TIMESTAMPZ` using a formula to calculate the *birthday
    paradox*. You can solve this problem with a monotonic ID or hardware and a database
    supporting a nanosecond resolution, but a highly-scalable application is beyond
    the scope of this book for the Rocket web framework.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，如果你的应用程序正在处理高流量或在分布式系统中，微秒级的分辨率可能不够。你可以使用一个公式来计算`TIMESTAMPZ`的碰撞概率，该公式用于计算*生日悖论*。你可以通过使用单调ID或支持纳秒级分辨率的硬件和数据库来解决这个问题，但高度可扩展的应用程序超出了本书关于Rocket
    Web框架的范围。
- en: 'Let''s define the `Pagination` struct for now and then we will implement this
    struct later. As we want to use `Pagination` in the list of users and we will
    use it as a `request` parameter, we can automatically use `#[derive(FromForm)]`
    to make auto-generation for the `rocket::form::FromForm` implementation. But,
    we have to create a new type, `OurDateTime`, because orphan rules mean we cannot
    implement `rocket::form::FromForField` for `DateTime<Utc>;`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们先定义`Pagination`结构体，然后我们将在稍后实现这个结构体。因为我们想在用户列表中使用`Pagination`，并将其用作`request`参数，所以我们可以自动使用`#[derive(FromForm)]`来自动生成`rocket::form::FromForm`的实现。但是，我们必须创建一个新的类型，`OurDateTime`，因为孤儿规则意味着我们无法为`DateTime<Utc>`实现`rocket::form::FromForField`：
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we can make an unimplemented function for the list of users:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为用户列表创建一个未实现的功能：
- en: '[PRE59]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We need a page to fill in the form for inputting new user data:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个页面来填写输入新用户数据的表单：
- en: '[PRE63]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After that, we can create a function to handle the creation of user data:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以创建一个处理创建用户数据的函数：
- en: '[PRE67]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We need a page to modify existing user data:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个页面来修改现有的用户数据：
- en: '[PRE73]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We need functions to handle updating user data:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理更新用户数据的函数：
- en: '[PRE77]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: What's the difference between `PUT` and `PATCH`? Simply put, in REST, a `PUT`
    request is used if we want to replace the resource completely, and `PATCH` is
    used to update data partially.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`和`PATCH`之间的区别是什么？简单来说，在REST中，如果我们想完全替换资源，则使用`PUT`请求，而`PATCH`用于部分更新数据。'
- en: 'The last user-related function is a function to execute `HTTP DELETE`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个与用户相关的函数是执行`HTTP DELETE`的函数：
- en: '[PRE89]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: After creating user-related route handling functions, we can expand our requirements.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建与用户相关的路由处理函数之后，我们可以扩展我们的需求。
- en: Making user-generated contents
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作用户生成内容
- en: 'An application that only handles user data is not fun, so we will add the capability
    for our users to upload and delete posts. Each post can be either a text post,
    a photo post, or a video post. Let''s look at the steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 只处理用户数据的应用程序并不有趣，所以我们将添加我们的用户上传和删除帖子的能力。每个帖子可以是文本帖子、照片帖子或视频帖子。让我们看看步骤：
- en: 'Create the definition for `Post`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Post`的结构：
- en: '[PRE93]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We want to differentiate the type, so we added the `post_type` column. We also
    want to make a relationship between the user and posts. As we want the user to
    be able to create many posts, we can create a `user_uuid` field in the struct.
    The content will be used to store either text content or the file path where we
    store the uploaded file. We will deal with the data migration on application implementation
    later.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望区分类型，因此我们添加了 `post_type` 列。我们还想在用户和帖子之间建立关系。因为我们希望用户能够创建许多帖子，我们可以在结构体中创建一个
    `user_uuid` 字段。内容将用于存储文本内容或存储上传文件的文件路径。我们将在应用程序实现时处理数据迁移。
- en: 'The way each post is presented might be different on our HTML, but it will
    occupy the same part on the web page, so let''s make a `DisplayPostContent` trait
    and three `DisplayPostContent` for each newtype:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个帖子在 HTML 上的呈现方式可能不同，但它们将在网页上占据相同的位置，所以让我们创建一个 `DisplayPostContent` 特性和三个 `DisplayPostContent`
    用于每个新类型：
- en: '[PRE94]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Finally, we can add the routes for handling `Post`. We can create `get_post`,
    `get_posts`, `create_post`, and `delete_post`. We also want these routes to be
    under a user:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以添加处理 `Post` 的路由。我们可以创建 `get_post`、`get_posts`、`create_post` 和 `delete_post`。我们还希望这些路由位于用户下：
- en: '[PRE95]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: After adding post-related types and functions, we can finalize creating the
    application skeleton in the next subsection.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加与帖子相关的类型和函数后，我们可以在下一小节中最终创建应用程序骨架。
- en: Finalizing the application
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成应用程序
- en: 'Don''t forget to add these routes to the Rocket initialization process:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将这些路由添加到 Rocket 初始化过程中：
- en: '[PRE96]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We also want to serve the uploaded file through a route:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望通过路由提供上传的文件：
- en: '[PRE115]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Time to add our default error handling! Other frameworks usually have a default
    error handler for HTTP status codes `404`, `422`, and `500`. Let''s make a handler
    for these codes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加我们的默认错误处理了！其他框架通常为 HTTP 状态码 `404`、`422` 和 `500` 提供默认错误处理器。让我们为这些代码创建一个处理器：
- en: '[PRE126]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: When we run the application using Cargo's `run` command, the application should
    launch correctly. But, when we look at `src/main.rs`, the file has a lot of functions
    and type definitions. We will modularize our application in the next section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Cargo 的 `run` 命令运行应用程序时，应用程序应该能够正确启动。但是，当我们查看 `src/main.rs` 文件时，该文件包含许多函数和类型定义。我们将在下一节中将我们的应用程序模块化。
- en: Modularizing the Rocket application
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化 Rocket 应用程序
- en: Remember in [*Chapter 1*](B16825_01_ePub.xhtml#_idTextAnchor014), *Introducing
    the Rust Language*, when we made an application with modules? One of the functions
    of the application source code is to use it as documentation for the people working
    on the application. A good readable code can be easily further developed and shared
    with other people on the team.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在 [*第 1 章*](B16825_01_ePub.xhtml#_idTextAnchor014)，*介绍 Rust 语言*，当我们使用模块创建应用程序时？应用程序源代码的一个功能是将其用作应用程序开发人员的文档。易于阅读的代码可以轻松进一步开发并与团队中的其他人共享。
- en: The compiler does not care whether the program is in one file or multiple files;
    the resulting application binary is the same. However, people working on a single,
    long file can get confused very easily.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不关心程序是在一个文件中还是多个文件中；生成的应用程序二进制文件是相同的。然而，在单个长文件上工作的程序员很容易感到困惑。
- en: We are going to split our application source code into smaller files and categorize
    the files into different modules. Programmers come from various backgrounds and
    may have their own paradigm on how to split the source code of the application.
    For example, programmers who are used to writing Java programs may prefer organizing
    their code based on the logical entities or classes. People who are used to Model-Viev-Controller
    (MVC) frameworks may prefer putting files in models, views, and controllers folders.
    People who are used to clean architecture may try to organize their code into
    layers. But, at the end of the day, what really matters is that the way you organize
    your code is accepted by the people you work with, and they can all comfortably
    and easily use the same source code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把应用程序源代码拆分成更小的文件，并将文件分类到不同的模块中。程序员来自不同的背景，他们可能有自己关于如何拆分应用程序源代码的范式。例如，习惯于编写
    Java 程序的程序员可能更喜欢根据逻辑实体或类组织代码。习惯于模型-视图-控制器（MVC）框架的人可能更喜欢将文件放在模型、视图和控制器文件夹中。习惯于清洁架构的人可能会尝试将代码组织成层。但最终，真正重要的是你组织代码的方式被你合作的人接受，并且他们都能舒适且容易地使用相同的源代码。
- en: Rocket does not have specific guidelines on how to organize the code, but there
    are two things that we can observe to modularize our application. The first one
    is the `Cargo` project package layout convention, and the second one is the Rocket
    parts themselves.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket没有关于如何组织代码的具体指南，但我们可以观察到两个可以用来模块化应用程序的东西。第一个是`Cargo`项目包布局约定，第二个是Rocket组件本身。
- en: 'According to Cargo documentation ([https://doc.rust-lang.org/cargo/guide/project-layout.html](https://doc.rust-lang.org/cargo/guide/project-layout.html)),
    the package layout should be as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`Cargo`文档([https://doc.rust-lang.org/cargo/guide/project-layout.html](https://doc.rust-lang.org/cargo/guide/project-layout.html))，包布局应该是这样的：
- en: '[PRE149]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Since we don't have benchmarks, examples, or tests yet, let's focus on the `src`
    folder. We can split the application into an executable in `src/main.rs` and a
    library in `src/lib.rs`. It's very common in an executable project to make a small
    executable code that only calls the library.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有基准测试、示例或测试，让我们专注于`src`文件夹。我们可以将应用程序拆分为`src/main.rs`中的可执行文件和`src/lib.rs`中的库。在可执行项目中，制作一个只调用库的小型可执行代码是非常常见的。
- en: 'We already know Rocket has different parts, so it''s a good idea to split the
    Rocket components into their own module. Let''s organize our source code into
    these files and folders:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道Rocket有不同部分，所以将Rocket组件拆分到它们自己的模块中是个好主意。让我们将源代码组织到这些文件和文件夹中：
- en: '[PRE175]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'First, edit the `Cargo.toml` file:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑`Cargo.toml`文件：
- en: '[PRE194]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Create the `src/lib.rs` file and the following folders: `src/catchers`, `src/fairings`,
    `src/models`, `src/routes`, `src/states`, `src/traits`, and `src/views`.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`src/lib.rs`文件以及以下文件夹：`src/catchers`、`src/fairings`、`src/models`、`src/routes`、`src/states`、`src/traits`和`src/views`。
- en: 'After that, create a `mod.rs` file inside each folder: `src/catchers/mod.rs`,
    `src/fairings/mod.rs`, `src/models/mod.rs`, `src/routes/mod.rs`, `src/states/mod.rs`,
    `src/traits/mod.rs`, and `src/views/mod.rs`.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在每个文件夹内创建一个`mod.rs`文件：`src/catchers/mod.rs`、`src/fairings/mod.rs`、`src/models/mod.rs`、`src/routes/mod.rs`、`src/states/mod.rs`、`src/traits/mod.rs`和`src/views/mod.rs`。
- en: 'Then, edit `src/lib.rs`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编辑`src/lib.rs`：
- en: '[PRE195]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Write the connection for our database first. Edit `src/fairings/mod.rs`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先编写数据库连接。编辑`src/fairings/mod.rs`：
- en: '[PRE196]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Make a new file, `src/fairings/db.rs`, and write the file just like the connection
    we defined earlier in `src/main.rs`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`src/fairings/db.rs`，并像在`src/main.rs`中之前定义的连接一样编写文件：
- en: '[PRE197]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Notice that we use only use a smaller number of modules compared to `src/main.rs`.
    We also added the `pub` keyword in order to make the struct accessible from other
    modules or from `src/main.rs`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只使用了比`src/main.rs`更少的模块。我们还添加了`pub`关键字，以便从其他模块或`src/main.rs`中访问结构体。
- en: 'Because the trait is going to be used by the structs, we need to define the
    trait first. In `src/traits/mod.rs`, copy the trait from `src/main.rs`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为特质将要被结构体使用，我们需要先定义特质。在`src/traits/mod.rs`中，从`src/main.rs`复制特质：
- en: '[PRE198]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'After that, let''s move all of our structs for requests and responses to the
    `src/models` folder. Edit `src/models/mod.rs` as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，让我们将所有用于请求和响应的结构体移动到`src/models`文件夹中。按照以下方式编辑`src/models/mod.rs`：
- en: '[PRE199]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Then, create the files and copy the definition from `src/main.rs` to those
    files. The first one is `src/models/our_date_time.rs`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建文件并将`src/main.rs`中的定义复制到这些文件中。第一个是`src/models/our_date_time.rs`：
- en: '[PRE200]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Next is `src/models/pagination.rs`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`src/models/pagination.rs`：
- en: '[PRE201]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Notice the `use` declaration uses the `super` keyword. The Rust module is organized
    by hierarchy, with a module containing other modules. The `super` keyword is used
    to access the module containing the current module. The `super` keyword can be
    chained, for example, `use super::super::SomeModule;`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`use`声明使用了`super`关键字。Rust模块按照层次结构组织，一个模块包含其他模块。`super`关键字用于访问包含当前模块的模块。`super`关键字可以链式使用，例如，`use
    super::super::SomeModule;`。
- en: 'After that, write `src/models/post_type.rs`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，编写`src/models/post_type.rs`：
- en: '[PRE202]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Also, write `src/models/post.rs`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要编写`src/models/post.rs`：
- en: '[PRE203]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'And then, write `src/models/user_status.rs`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编写`src/models/user_status.rs`：
- en: '[PRE204]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Write `src/models/user.rs`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`src/models/user.rs`：
- en: '[PRE205]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'And then, write the three `post` newtypes, `src/models/photo_post.rs`, `src/models/text_post.rs`,
    and `src/models/video_post.rs`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编写三个`post`新类型，`src/models/photo_post.rs`、`src/models/text_post.rs`和`src/models/video_post.rs`：
- en: '[PRE206]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: In all three files, we use the `crate` keyword in the `use` declaration. We
    have discussed the `super` keyword before; the `crate` keyword is referring to
    the current library we are working on, which is the `our_application` library.
    In Rust 2015 edition, it's written as a double semicolon (`::`), but since Rust
    2018 edition, `::` changed to `crate`. Now, `::` means the root path of the external
    crate, for example, `::rocket::fs::NamedFile;`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三个文件中，我们在`use`声明中使用`crate`关键字。我们之前已经讨论过`super`关键字；`crate`关键字是指我们正在工作的当前库，即`our_application`库。在Rust
    2015版本中，它写作双分号（`::`），但自从Rust 2018版本以来，`::`变为了`crate`。现在，`::`表示外部crate的根路径，例如，`::rocket::fs::NamedFile;`。
- en: 'Besides `super`, `::`, and `crate`, there are a couple more `use` declaration:
    `self` and `Self`. We can use `self` to avoid ambiguity when referring to items
    in code, as shown in this example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`super`、`::`和`crate`之外，还有一些其他的`use`声明：`self`和`Self`。我们可以使用`self`来避免在代码中引用项目时的歧义，如下面的例子所示：
- en: '[PRE207]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '`Self` is used to refer to an associated type in a trait, as shown in this
    example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Self`用于在特性中引用关联类型，如下面的例子所示：'
- en: '[PRE208]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Now, let''s get back to the application skeleton. After all the structs, it''s
    time to write routes for the application. Modify `src/routes/mod.rs`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到应用程序骨架。在所有结构体之后，是时候为应用程序编写路由了。修改`src/routes/mod.rs`：
- en: '[PRE209]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: We could put the function handling assets in their own Rust file, but since
    there's only one function and it's very simple, we can just put the function in
    the `mod.rs` file.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将处理资产的函数放在它们自己的Rust文件中，但由于只有一个函数且非常简单，我们只需将函数放在`mod.rs`文件中。
- en: 'Next, create and write `src/routes/post.rs`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建并编写`src/routes/post.rs`：
- en: '[PRE210]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Create and write `src/routes/user.rs`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并编写`src/routes/user.rs`：
- en: '[PRE211]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'And, to finalize the library, add the catchers in `src/catchers/mod.rs`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了最终完成库，请在`src/catchers/mod.rs`中添加捕获器：
- en: '[PRE212]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'When the library is ready, we can modify `src/main.rs` itself:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当库准备就绪时，我们可以修改`src/main.rs`本身：
- en: '[PRE213]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Our `src/main.rs` file has become cleaner.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`src/main.rs`文件变得更加简洁。
- en: Now, if we want to add more structs or routes, we can easily add new modules
    in the corresponding folders. We can also add more states or fairings and easily
    find the file location for those items.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想添加更多的结构体或路由，我们可以在相应的文件夹中轻松地添加新的模块。我们还可以添加更多的状态或公平性，并轻松找到这些项目的文件位置。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to design an application, create a Rocket application
    skeleton, and organize the Rust application into smaller manageable modules.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何设计应用程序、创建Rocket应用程序骨架以及将Rust应用程序组织成更小的可管理模块。
- en: We also learned about concepts such as CRUD and RESTful applications, Rust `enum`
    discriminators, and Rust path qualifiers.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了诸如CRUD和RESTful应用程序、Rust `enum`区分符以及Rust路径限定符等概念。
- en: Hopefully, after reading this chapter, you can apply those concepts to help
    you organize your code better.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在阅读本章之后，您可以将这些概念应用到帮助您更好地组织代码中。
- en: We will start implementing this application and learn more about Rust and Rocket
    concepts such as templating, request guards, cookies, and JSON, in the following
    chapters.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中开始实现这个应用程序，并学习更多关于Rust和Rocket概念，如模板、请求守卫、cookies和JSON。
