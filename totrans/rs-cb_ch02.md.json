["```rs\n        // main point of execution \n        fn main() {\n\n          // expression\n          let x_val = 5u32;\n\n          // y block \n          let y_val = {\n            let x_squared = x_val * x_val;\n            let x_cube = x_squared * x_val;\n\n            // This expression will be assigned to `y_val`\n            x_cube + x_squared + x_val\n          };\n\n          // z block\n          let z_val = {\n            // The semicolon suppresses this expression and `()` is\n            assigned to `z`\n            2 * x_val;\n          };\n\n          // printing the final outcomes\n          println!(\"x is {:?}\", x_val);\n          println!(\"y is {:?}\", y_val);\n          println!(\"z is {:?}\", z_val);\n        }\n\n```", "```rs\n        // Global variables are declared outside scopes of other \n        function\n        const UPPERLIMIT: i32 = 12;\n\n```", "```rs\n        // function to check if bunber \n        fn is_big(n: i32) -> bool {\n          // Access constant in some function\n          n > UPPERLIMIT\n        }\n\n```", "```rs\n        fn main() {\n          let random_number = 15;\n\n          // Access constant in the main thread\n          println!(\"The threshold is {}\", UPPERLIMIT);\n          println!(\"{} is {}\", random_number, if\n          is_big(random_number) { \"big\" } else { \"small\"\n          });\n\n          // Error! Cannot modify a `const`.\n          // UPPERLIMIT = 5;\n\n        }\n\n```", "```rs\n        fn main() {\n          // Simplest variable binding\n          let a = 5;\n          // pattern\n          let (b, c) = (1, 2);\n          // type annotation\n          let x_val: i32 = 5;\n          // shadow example\n          let y_val: i32 = 8;\n          {\n            println!(\"Value assigned when entering the \n            scope : {}\", y_val); // Prints \"8\".\n            let y_val = 12;\n            println!(\"Value modified within scope :{}\", y_val);\n            // Prints \"12\".\n          }\n          println!(\"Value which was assigned first : {}\", y_val);\n          // Prints \"8\".\n          let y_val = 42;\n          println!(\"New value assigned : {}\", y_val);\n          //Prints \"42\".\n        }\n\n```", "```rs\n        use std::{i32,f32};\n\n        // Sample function for assigning values to\n        confusion matrix\n        fn main() {\n\n          // assigning random values to the confusion matrix\n          let(true_positive,true_negative,false_positive,\n          false_negative)=(100,50,10,5);\n\n          // define a total closure\n          let total = true_positive + true_negative +\n          false_positive + false_negative;\n\n          println!(\"The total predictions {}\",total);\n\n          // Calculating the accuracy of the model\n          println!(\"Accuracy of the model\n          {:.2}\",percentage(accuracy(true_positive,\n          true_negative,total)));\n\n        }\n\n```", "```rs\n        // Accuracy Measures the overall performance of \n        the model\n        fn accuracy(tp:i32,tn:i32,total:i32) -> f32 {\n          // if semi-colon is not put then that returns \n          // No automatic type cast in rust \n          (tp as f32 + tn as f32 )/(total as f32)\n        }\n\n        // Converting to percentage \n        fn percentage(value:f32) -> f32 {\n        value *100.0\n        }\n\n```", "```rs\n        let a = 3;\n        /*\n        let b = a * 0.2; //Won't compile\n        */\n\n```", "```rs\n        let b = a as f64 * 0.2;\n\n```", "```rs\n        use std::{i32};\n        fn main() {\n          let age : i32= 10;\n          // If else statements\n          if age <= 18{\n            println!(\"Go to School\");\n          } else if (age >18) && (age <= 28){\n          println!(\"Go to college\");\n        } else {\n          println!(\"Do something with your life\");\n        }\n\n        // if/ else statement in one line\n        let can_vote = if (age >= 18) {true} else\n        {false};\n        println!(\"Can vote {}\",can_vote );\n        }\n\n```", "```rs\n    let variable = if (condition 1 ) {true} else {false};\n\n```", "```rs\n        fn main() {\n\n          // mutuable variable whose value can be changed\n          let mut x =1;\n          println!(\" Loop even numbers \");\n\n          // Continously loops \n          loop {\n            // Check if x is an even number or not\n            if (x % 2 == 0){\n              println!(\"{}\",x);\n              x += 1;\n              // goes to the loop again\n              continue;\n            }\n            // exit if the number is greater than 10\n            if (x > 10) {\n            break;\n          }\n          // increment the number when not even\n          x+=1;\n        }\n\n```", "```rs\n        let mut y = 1;\n         // while loop\n         println!(\"while 1 to 9 \");\n         while y < 10 {\n         println!(\"{}\",y );\n         y +=1;\n         }\n\n```", "```rs\n        let mut z = 1;\n         //for loop \n         println!(\" For 1 to 9\");\n         for z in 1 .. 10 {\n         println!(\"{}\",z );\n         }\n        }\n\n```", "```rs\n        fn main() {\n\n         let hulk = Hero::Strong(100);\n         let fasty = Hero::Fast;\n         //converting from \n         let spiderman = Hero::Info\n        {name:\"spiderman\".to_owned(),secret:\"peter\n        parker\".to_owned()};\n        get_info(spiderman);\n        get_info(hulk);\n        get_info(fasty);\n        }\n\n```", "```rs\n        // declaring the enum \n        enum Hero {\n        Fast,\n        Strong(i32),\n        Info {name : String, secret : String}\n        }\n\n```", "```rs\n        // function to perform for each types\n        fn get_info(h:Hero){\n        match h {\n        Hero::Fast => println!(\"Fast\"),\n        Hero::Strong(i) => println!(\"Lifts {} tons\",i ),\n        Hero::Info {name,secret} => { println!(\" name is: {0} secret is\n        : {1}\", name,secret);} ,\n        }\n       }\n\n```", "```rs\n        use std::{i32};\n        fn main() {\n\n```", "```rs\n        // define a closure\n        let sum_num = |x:i32 , y:i32| x+y;\n        println!(\"7 + 8 ={}\", sum_num(7,8));\n\n```", "```rs\n        // example 2\n         let num_ten = 10;\n         let add_ten = |x:i32| x+num_ten;\n         println!(\"3 + 10 ={}\", add_ten(3));\n        }\n\n```", "```rs\n        use std::{i32};\n        fn main() {\n\n```", "```rs\n        let vect1 = vec![1,2,3];\n\n         // Error in case you are doing this in case of non primitive\n         value\n         // let vec2 = vec1\n         // println!(\"vec1[0] : {:?}\", vec1[0]);\n\n         let prim_val = 1;\n         let prim_val2 = prim_val;\n         println!(\"primitive value :- {}\", prim_val);\n\n```", "```rs\n         // passing the ownership to the function\n         println!(\"Sum of vects : {}\", sum_vects(&vect1));\n         // Able to pass the non primitive data type\n         println!(\"vector 1 {:?}\", vect1);\n        }\n\n```", "```rs\n         // Added a reference in the argument\n         fn sum_vects (v1: &Vec<i32>) -> i32 {\n         // apply a closure and iterator\n         let sum = v1.iter().fold(0, |mut sum, &x | {sum += x; sum});\n         return sum;\n        }\n\n```", "```rs\n        use std::{f64};\n        fn main() {\n\n        // create a struct variable\n         let mut circle1 = Circle {\n         x:10.0,radius : 10.0\n         };\n\n        // print radius and variable x\n        println!(\"x:{},radius : {}\", circle1.x,\n        circle1.radius );\n        println!(\"Radius : {}\", get_radius(&circle1) );\n        }\n\n```", "```rs\n        // define your custom user data type\n        struct Circle {\n        x : f64,\n        radius : f64,\n        }\n\n```", "```rs\n        // get radius function \n        fn get_radius(c1 : &Circle) -> f64{ \n        c1.radius \n        }\n\n```", "```rs\n        use std::{f64};\n\n        fn main() {\n         // create a struct variable\n         let mut circle1 = Circle {\n         x:10.0,radius : 10.0\n         };\n        println!(\"x:{},radius : {}\", circle1.x,\n        circle1.radius );\n        println!(\"x : {}\", circle1.get_x());\n        }\n\n```", "```rs\n        // define your custom user data type\n        struct Circle {\n         x : f64,\n         radius : f64,\n        }\n\n```", "```rs\n        // recommended way of creating structs\n         impl Circle {\n         // pub makes this function public which makes it \n         accessible outsite the scope {}\n         pub fn get_x(&self) -> f64 {\n         self.x\n         }\n        }\n\n```", "```rs\n        use std::{f64};\n        fn main() {\n        // variable of circle data type\n         let mut circle1 = Circle {\n         r : 10.0\n         };\n         println!(\"Area of circle {}\", circle1.area() );\n\n         // variable of rectangle data type\n         let mut rect = Rectangle {\n         h:10.0,b : 10.0\n         };\n         println!(\"Area of rectangle {}\", rect.area() );\n         }\n\n```", "```rs\n        // userdefined data type rectangle\n        struct Rectangle {\n         h: f64,\n         b: f64,\n        }\n\n```", "```rs\n        // userdefined data type circle\n        struct Circle {\n         r: f64,\n        }\n\n```", "```rs\n        // create a functionality for the data types \n        trait HasArea {\n         fn area(&self) -> f64;\n        }\n\n```", "```rs\n        // implement area for circle\n        impl HasArea for Circle {\n         fn area(&self) -> f64 {\n         3.14 * (self.r *self.r)\n         }\n        }\n\n```", "```rs\n        // implement area for rectangle\n        impl HasArea for Rectangle {\n         fn area(&self) -> f64 {\n         self.h *self.b\n         }\n        }\n\n```"]