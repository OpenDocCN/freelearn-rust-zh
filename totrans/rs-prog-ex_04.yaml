- en: Adding All Game Mechanisms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加所有游戏机制
- en: In the previous chapters, [Chapter 1](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7), *Basics
    of Rust*, [Chapter 2](part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7), 
    *Starting with SDL*, and [Chapter 3](part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7), *Events
    and Basic Game Mechanisms*, we wrote all the mechanisms that we needed. The only
    missing parts are the UI rendering and the font management. In short, the easy
    parts So in this chapter, we'll add the drawing of the game and some fonts handling
    as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，[第 1 章](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7)，*Rust
    基础*，[第 2 章](part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7)，*从 SDL 开始*，和
    [第 3 章](part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7)，*事件和基本游戏机制*，我们编写了所有需要的机制。唯一缺少的部分是
    UI 渲染和字体管理。简而言之，是容易的部分。所以在本章中，我们将添加游戏的绘制和一些字体处理。
- en: Let's go!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Getting started with game mechanisms
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始游戏机制
- en: Let's start with the UI rendering first and then add the font management in
    order to display the game information in real time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从 UI 渲染开始，然后添加字体管理，以便实时显示游戏信息。
- en: Rendering UI
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染 UI
- en: With the current code base, very few changes are required in order to be able
    to have a fully working Tetris.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的代码库中，为了能够拥有一个完全工作的俄罗斯方块，需要做的改动非常少。
- en: Rendering initialization
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染初始化
- en: 'For now, the `main` function is very small. First, let''s add the following
    lines at the top of the function:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`main` 函数非常小。首先，让我们在函数顶部添加以下几行：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: No need for explanations, we've already explained everything in the previous
    chapters, so let's continue.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要解释，我们已经在前面的章节中解释了一切，所以让我们继续。
- en: 'Just after the following lines:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几行之后：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s add the following ones:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加以下几行：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There's even a macro in the middle, so yes, a few explanations are required!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 中间甚至有一个宏，所以，确实需要一些解释！
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ve already seen all this, so we''ll just go very quickly through each:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了所有这些，所以我们将快速浏览每个：
- en: We create the window.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建窗口。
- en: We initialize the area where we'll draw.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化我们将要绘制的区域。
- en: We initialize the texture engine.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化纹理引擎。
- en: 'The two next calls are more interesting and are the start of the actual UI
    rendering:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个调用更有趣，是实际 UI 渲染的开始：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'They both call a function defined in [Chapter 2](part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7), *Starting
    with SDL*. `grid` is where we''ll draw the tetriminoes and border to represent
    the borders of the game area. The first one is black, whereas the other one is
    white. The following is a screenshot of what they''ll look like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都调用在第 2 章[从 SDL 开始](part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7)中定义的函数。`grid`
    是我们将要绘制俄罗斯方块和边框以表示游戏区域边界的地方。第一个是黑色，而另一个是白色。以下是他们将看起来像的截图：
- en: '![](img/00024.jpeg)*Figure 4.1*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00024.jpeg)*图 4.1*'
- en: 'So now let''s write down the code to load more easily:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在让我们写下代码以便更容易地加载：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We already introduced macros in [Chapter 1](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7), *Basics
    of Rust*, so we will assume you'll understand pretty easily what this one is doing.
    (It calls the `create_texture_rect` function with `$r`, `$g`, and `$b` being the
    color we want the texture to be.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第 1 章](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7)，*Rust 基础*中介绍了宏，所以我们将假设你很容易理解这个宏的作用。（它使用
    `$r`，`$g` 和 `$b` 作为我们想要纹理的颜色来调用 `create_texture_rect` 函数。）
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In here, we create the textures for our tetriminoes blocks. So seven textures
    for seven types of tetrimino blocks.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为我们的俄罗斯方块块创建纹理。所以七种类型的俄罗斯方块块有七个纹理。
- en: We initialized everything we needed for the rendering. So now, let's render!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了所有需要的渲染。所以现在，让我们开始渲染！
- en: Rendering
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: 'Still in the `main` function, but this time we''re going into the main loop
    (no wordplay!). Just after the `is_time_over` if condition, let''s add:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 `main` 函数中，但这次我们要进入主循环（没有文字游戏！）。就在 `is_time_over` 条件之后，让我们添加：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we want to change the background depending on the player's actual level,
    we can just change the first line. No sweat.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要根据玩家的实际等级更改背景，我们只需更改第一行即可。没问题。
- en: 'About the following formulas:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于以下公式：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'I think a small explanation might come in handy here. As you certainly remember,
    `Rect::new` takes the four following arguments:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这里可能需要一个小解释。正如你肯定记得，`Rect::new` 接受以下四个参数：
- en: '*x* position'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x* 位置'
- en: '*y* position'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*y* 位置'
- en: width
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽度
- en: height
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度
- en: 'For the first two, we center our game map. For example, for the *x* position,
    we need to first compute how much width it''ll take (so a width of `10` tetriminoes):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前两个，我们将游戏地图居中。例如，对于 *x* 位置，我们需要首先计算它将占用多少宽度（因此是 `10` 个俄罗斯方块）：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we subtract this from the total width:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从总宽度中减去这个值：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What remains is what isn''t the game map. So if we use it as *x* position,
    the game map will be fully on the left. Not pretty. Luckily, centering is quite
    easy, we just have to divide this result by 2, which is shown as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是不是游戏地图的部分。所以如果我们用它作为 *x* 位置，游戏地图将完全位于左侧。看起来不太美观。幸运的是，居中相当容易，我们只需要将这个结果除以2，如下所示：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And here we go! Now, about the subtraction of 10; it''s because of the borders.
    It has a width of `10`, so we need to subtract it as well to be *really* centered:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，关于减去10的原因；这是因为边框。它的宽度是 `10`，所以我们也需要减去它以实现真正的居中：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Not very complicated, but it can be hard to read the first time. The same goes
    for the height, so we won''t make the same explanations twice. Time to speak about
    the width and height computation! I think that you already got it from the previous
    explanations, but just in case:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是很复杂，但第一次阅读时可能难以理解。高度也是如此，所以我们不会重复相同的解释。现在是时候讨论宽度和高度的计算了！我认为你已经从之前的解释中得到了它，但以防万一：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A `Tetris` has a width of ten blocks. Therefore, our game map must have the
    same as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Tetris` 有十块宽度。因此，我们的游戏地图也必须有相同的宽度。
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We've now added the width of the total borders as well (since there is a border
    on each side and a border has a width of 10 pixels, `10 * 2 = 20`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还添加了总边框的宽度（因为每边都有一个边框，而边框的宽度为10像素，`10 * 2 = 20`）。
- en: The same goes for the height.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 高度也是如此。
- en: Once you get how these formulas work, you'll get how all the others are working
    as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了这些公式的原理，你也会了解其他所有公式的原理。
- en: 'Since we''ve drawn the game environment, it''s time to draw the tetriminoes.
    First, let''s draw the current one! In order to do this, we need to update the
    `for` loop inside the `handle_events` condition:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经绘制了游戏环境，现在是时候绘制俄罗斯方块了。首先，让我们绘制当前的方块！为了做到这一点，我们需要更新 `handle_events` 条件内的
    `for` 循环：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For each block of the current tetrimino, we paste a texture corresponding to
    its ID. From the explanations of the preceding formulas, we can suppose it's not
    necessary to go back on those *new* ones.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前俄罗斯方块中的每一块，我们粘贴一个与其ID对应的纹理。从前面公式的解释中，我们可以假设没有必要回到那些 *新* 的公式上。
- en: 'With this, only the last part is remaining; drawing all the other tetriminoes
    blocks:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，只剩下最后一部分了；绘制所有其他俄罗斯方块块：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code, we iterate over a block of each line of the game map and paste
    the corresponding texture, if the game map's *occupied*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码中，我们遍历游戏地图每一行的每一块，并粘贴相应的纹理，如果游戏地图的 *占用*。
- en: 'Once done, we apply all the changes to the display, with:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们通过以下方式将所有更改应用到显示上：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this, our `Tetris` is now complete! You can now play by launching the
    command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的 `Tetris` 现在就完成了！你现在可以通过运行命令来玩游戏：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `--release` is for starting the program in non-debug mode.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`--release` 是用于以非调试模式启动程序。'
- en: 'The full code of the `main` function is now the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数的完整代码现在如下所示：'
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And here is an example of the current output of this code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个代码当前输出的一个示例：
- en: '![](img/00025.jpeg)*Figure 4.2*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00025.jpeg)*图4.2*'
- en: It's now working, but what about displaying the game information, such as the
    current score, level, or the number of lines sent?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它正在工作，但关于显示游戏信息，比如当前分数、等级或发送的行数，怎么办？
- en: Playing with fonts
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转字体
- en: 'To display these pieces of information, we''ll need to use fonts. No additional
    external dependencies are required, however, we''ll need to use a feature, so
    we need to update our `Cargo.toml`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示这些信息，我们需要使用字体。然而，不需要额外的外部依赖，但我们需要使用一个功能，因此我们需要更新我们的 `Cargo.toml`：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By default, the `sdl2` crate doesn''t provide the `ttf` module, you need to
    enable it by adding the `ttf` feature to the compilation process. That''s what
    we did by saying to `cargo`: *by default, I want the `ttf` feature of the `sdl2`
    crate enabled*. You can try with and without it to see the difference, after adding
    this new context initialization:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sdl2` 包不提供 `ttf` 模块，你需要通过在编译过程中添加 `ttf` 功能来启用它。这就是我们通过告诉 `cargo`：“默认情况下，我想启用
    `sdl2` 包的 `ttf` 功能”。你可以尝试添加和不添加这个新上下文初始化后的差异。
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you get a missing library compilation error, it means you didn't install
    the corresponding library. To fix this issue, you need to install it through your
    favorite package manager.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到缺少库的编译错误，这意味着你没有安装相应的库。要解决这个问题，你需要通过你喜欢的包管理器安装它。
- en: Install on OS X
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 OS X 上安装
- en: 'Run the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Install on Linux
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 上安装
- en: 'Run the following command (depending on your package manager, of course):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令（当然，取决于你的包管理器）：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Other system/package manager
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他系统/包管理器
- en: You can download the library at [https://www.libsdl.org/projects/SDL_ttf/.](https://www.libsdl.org/projects/SDL_ttf/)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.libsdl.org/projects/SDL_ttf/](https://www.libsdl.org/projects/SDL_ttf/)下载库。
- en: Follow the instructions and install it on your system, then just run the projects.
    If no errors appear, then it means you installed it correctly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明在你的系统上安装它，然后只需运行项目。如果没有错误出现，那么这意味着你已经正确安装了它。
- en: Time to start the real thing!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始真正的事情了！
- en: Loading font
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载字体
- en: 'Before going any further, we actually need a font. I chose **Lucida console**,
    but pick the one you prefer, it doesn''t really matter. Once downloaded, put it
    in the `assets` folder as well. Now, time to actually load the font:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们实际上需要一个字体。我选择了 **Lucida console**，但选择你喜欢的字体，这并不重要。下载后，将其也放入 `assets`
    文件夹中。现在，是时候实际加载字体了：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that if you want to apply a style to your font (such as bold, italic,
    strikethrough, or underline), that''s the object on which you need to apply it.
    Here is an example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你想给你的字体应用样式（例如粗体、斜体、删除线或下划线），那么你需要应用的对象就是它。以下是一个例子：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, two steps are remaining to be able to actually display text:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了实际显示文本，我们还需要完成两个步骤：
- en: Render the text.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染文本。
- en: Create a texture from it.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从它创建一个纹理。
- en: 'Let''s write a function in order to do so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数来完成这个任务：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Looks a lot like `create_texture_rect`, right?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很像 `create_texture_rect`，对吧？
- en: 'Why not test it? Let''s call the function and paste the texture onto the screen
    to see:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不测试一下呢？让我们调用这个函数并将纹理粘贴到屏幕上看看：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And it looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '![](img/00026.jpeg)*Figure 4.3*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.3](img/00026.jpeg)*图 4.3*'
- en: 'For the texture rectangle, I use the following rule: one character is a block
    of 10 x 30 pixels. So in this example, since `test` has 4 letters, we need a block
    of 40 x 30 pixels. Let''s write a function to make this easier:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于纹理矩形，我使用以下规则：一个字符是一个 10 x 30 像素的块。所以在这个例子中，因为 `test` 有 4 个字母，我们需要一个 40 x 30
    像素的块。让我们写一个函数来简化这个过程：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Ok, so now is the time to render the game information and write a new function
    to do it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以现在是我们渲染游戏信息并编写一个新函数来执行此操作的时候了：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And then we call it, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将其称为如下：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And now it looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来是这样的：
- en: '![](img/00027.jpeg)*Figure 4.4*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.4](img/00027.jpeg)*图 4.4*'
- en: Wonderful, we have the game information in real time! Isn't it awesome? What?
    It's ugly and overlaps the game? Let's move the game then! Instead of centering
    it, we'll give it a fixed `x` position (which will make our formula way simpler).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们现在有了实时游戏信息！不是吗？什么？它看起来很丑，还与游戏重叠？让我们移动游戏！我们不会将其居中，而是给它一个固定的 `x` 位置（这将使我们的公式变得非常简单）。
- en: 'First, let''s update our `grid_x` variable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新我们的 `grid_x` 变量：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, let''s update so `canvas.copy` calls:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们更新 `canvas.copy` 调用：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And that''s it. You now have a nice Tetris playing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。你现在有一个不错的俄罗斯方块可以玩：
- en: '![](img/00028.jpeg)**Figure 4.5**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.5](img/00028.jpeg)**图 4.5**'
- en: We could improve the display a bit by adding a border around the text, or even
    display a preview of the next piece, or even add a *ghost*, but I think that,
    from this point, you can add them easily.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加文本周围的边框来稍微改进显示效果，或者甚至显示下一个部件的预览，或者甚至添加一个 *幽灵*，但我认为从这个点开始，你可以轻松地添加它们。
- en: That's it for this Tetris, have fun while playing with the `sdl2`!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，这个俄罗斯方块就完成了，玩得开心，享受与 `sdl2` 的互动！
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now have a fully working Tetris. In the last three chapters, we saw how to
    use the `sdl2` crate, how to add dependencies to Rust projects, how to handle
    I/O (with files), and how modules were working.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个完全工作的俄罗斯方块。在过去的三个章节中，我们看到了如何使用 `sdl2` crate，如何向 Rust 项目添加依赖项，如何处理 I/O（使用文件），以及模块是如何工作的。
- en: 'Even if we stop here for this Tetris project, you can continue this project (and
    it''d be even a good idea to improve yourself in `sdl2`!).  A few ideas of missing
    things you could add:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们现在停止这个俄罗斯方块项目，你仍然可以继续这个项目（而且提高自己在 `sdl2` 方面的技能也是一个好主意！）一些你可以添加的缺失功能的想法：
- en: Change the background depending on the current level
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据当前级别更改背景
- en: Asking the players, once the game is over, if they want to start a new game
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏结束后询问玩家是否想要开始新游戏
- en: Adding the next tetrimino preview
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加下一个四元形的预览
- en: Adding a ghost (to see where the tetrimino will fall)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个幽灵（以查看四元形将落在何处）
- en: And so much more. Just have fun while adding new features!
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及更多。在添加新功能的同时，尽情享受乐趣吧！
- en: As you can see, a lot of things are possible. Have fun!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有很多事情是可能的。尽情享受吧！
