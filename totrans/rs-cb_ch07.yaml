- en: Hacking Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building macros in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing matching in macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with common Rust macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing designators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overloading macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing repeat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing DRY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have seen many statements in Rust ending with an exclamation mark
    (`!`), such as `println!`, `try!`, and so on. These commands have performed powerful
    operations to execute specific tasks. Rust provides a powerful macro system that
    allows metaprogramming. Macros look like functions but their names end with an
    exclamation mark (`!`). Macros are expanded into source code which, gets compiled
    into the program. In this recipe, we will look into the various aspects of macros,
    ranging from defining your own application-specific macros to testing them.
  prefs: []
  type: TYPE_NORMAL
- en: Building macros in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn about `macro_rules!`--the syntax that will help
    us define our custom application-specific macro, which can have a unique name
    according to the application terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_macro.rs`, and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a macro named `Welcome_RustBook`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and call the `Welcome_RustBook` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9056cadb-1379-455d-a5d8-6fe573a8b6d6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the `macro_rules!` macro to create a custom-named macro; here, we made
    a macro named `Welcome_RustBook!`. The general syntax of `macro_rules!` is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `macro_rules!` macro, we match the arguments. In the case of this
    recipe, we do not accept any arguments from the user, so we match `()` `=>` (a
    certain set of action items). The empty parentheses, `()`, in the code indicate
    that the macro takes no argument. The macro will expand into the contents of the
    block of no arguments at compile time, where we have `println!("Welcome to Rust
    Cookbook!");`, which basically prints a default statement.
  prefs: []
  type: TYPE_NORMAL
- en: In the main function, we call `Welcome_RustBook!` macro in the function definition,
    just like we would call any other macro. We will see the default statement printed
    in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing matching in macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go ahead and make our macro a bit more complex by adding more rules in
    our macro, the rules are basically pattern matching cases. In this recipe, the
    key takes-away will be to learn how we can define pattern matching cases in macro
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the mentioned steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_match.rs`, and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a macro named `Check_Val`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and call the `Check_Val` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f198960-7a48-47d9-9fff-32b184e1de29.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we create a macro named `Check_Val!`, which basically plays
    the role as a `match` expression arm, but the matching happens through the Rust
    syntax trees during compilation time. The common syntax of a pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the term *pattern* refers to the left-hand side of `=>`, which is known
    as *matcher* in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: The `$x:expr` matcher will match any Rust expression and will bind that to syntax
    tree to the metavariable `$x`, any Rust tokens that appear in a matcher must match
    exactly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two pattern matching cases here: `x => $e:expr` and `y => $e:expr`.
    The metavariable is `$e`, which is used in macro definitions for operations to
    be done following the successful pattern matching of a macro rule. When we call
    `Check_Val!(y => 3);` in the `main` function, the output is `mode Y:3`. Here the
    second case is passed and the value of `$e` is the same as that of the arguments
    passed to the `Check_Val!` macro in the `main` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had called `Check-Val!(z => 3);` we would have got `` error: no rules
    expected the token `z` ``, as we haven''t defined a rule for the token `z` and
    surrounding the matcher with `$(...),*` will match zero or more expressions, separated
    by commas.'
  prefs: []
  type: TYPE_NORMAL
- en: Playing with common Rust macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have defined and used common Rust macros that will
    help us perform basic operations, such as printing, and so on. Rust offers these
    macros by default, as these are very complex to be implemented by the user. In
    this recipe, we will learn a few common Rust macros.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_common_macros.rs`, and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `main` function where we implement a few inbuilt standard Rust macros:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8790c421-3afa-4ae1-befb-351ef1a3543e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We declared all the standard macros in the main function. Let,s deep dive into
    each one of them in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: We used the `vec!` macro to create a vector in Rust. It creates `Vec<T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next two macros are extensively used in tests: the first one is `assert!`,
    which takes a Boolean value to pass and the second one is `assert_eq!`, which
    takes two values and checks for their equality. The true value passes and the
    false one leads to the `panic!` macro, which causes the thread to panic or break.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we have used the `Vec!` macro to create a vector, `v`. The conditions
    inside the `assert!` and `assert_eq!` macros pass. The failure cases have been
    commented out, as they would cause panic during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing designators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust provides a list of designators, which help us create units, such as functions,
    and execute expressions in macros.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the mentioned steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_designator.rs`, and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a macro named `create_function`, which accepts a designator as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `create_function` macro to create two functions, `foo` and `bar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a macro named `print_result`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function, where we play around with the macros we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae8ce396-57b6-4596-8848-4ab739a2c959.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, the arguments of a macro are prefixed by a dollar sign (`$`) and
    a type annotated with a designator. Here, in this recipe, we have used two commonly
    used designators, which are `expr`, used for expressions, and `ident`, which is
    used for variable/function names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the two main macros that we have created to implement the
    designator in the Rust code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_function`: This macro takes an argument of the `ident` designator and
    creates a function named `$func_name`, which is used across the code for creating
    the function. The `ident` designator, as mentioned previously, is used for variable/function
    names. Inside the block of the `($func_name:ident)`, pattern, we define the function
    `fn $func_name`, and we have the `stringify!` macro in its body, which converts
    a `$func_name` into a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_result`: This macro takes an expression of the `expr` type and prints
    it as a string along with its result. The `expr` designator is used for expressions.
    In the block for the expression pattern, we use the `stringify!` macro, which
    converts the expression into a string and also executes it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create functions named `foo` and `bar` with the preceding macro by using
    `create_function!(foo);` and `create_function!(bar);`. In the `main` function,
    where we called the two functions, that is, `foo` and `bar`, which return the
    string. We call `function_name`. Next, we call `print_result!`, with a block of
    expression as an argument, where we create a variable, `x`, and assign it a value
    of `1u32`, which is a 32-bit unsigned integer type. We then run `x * x + 2 * x
    - 1`, which gives us the output of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overloading macros in Rust is the process of providing multiple combinations
    of similar arguments, where we expect the macro to handle them and provide custom
    results according to the combination passed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_overloading_macros.rs`, and open it in your text
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a macro named `test`, for which we will implement overloading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function in which we''ll implement the features of the macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e2f8a0d-4b1c-4e57-b993-992ed28acd69.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we create a macro named `test`, which takes two `expr` designators
    used for taking an expression as arguments and assigning it to two variables,
    `$left` and `$right`, where `$left` is assigned to the first expression and `$right`,
    to the second expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the macros, we have two rules, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`($left:expr; and $right:expr)`: In this rule, we want to return a Boolean
    value. Here, we evaluate both the expressions and pass the values to the `&&`
    operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`($left:expr; or $right:expr)`: In this rule, we want to return a Boolean value.
    Here, we evaluate both the expressions and pass the values to the `||` operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments don't need to be separated by a comma and each arm must end with a
    semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we call the `test!` macro two times with different arguments,
    where we have the combinations. The `test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);`
    combination returns the string form of the expression along with the result, which
    is `true`; `test!(true; or false);` similarly returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing repeat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repeat is the ability of a particular macro to accept arguments that repeat
    at least once. In this recipe, you will learn the syntax to implement repeat in
    Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_repeat.rs`, and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a macro named `find_min`, in which we implement `repeat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `main` function in which we pass multiple arguments to `find_min`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c2a0dbd-a0e4-49b4-9bd8-96f610c451dd.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros can use `+` in the argument list to indicate that an argument may repeat
    at least once or `*` to indicate that the argument may repeat zero or more times.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we have a macro named `find_min`, which has two rules in which
    the matcher with `$(...),+` will match one or more expressions, separated by commas.
    In the first case, we have `($x:expr)`, which just executes the expression and
    returns the output; this will be matched if we pass only one expression to the
    `find_min` macro. In the second case, we have `($x:expr, $($y:expr),+)`. Here,
    `$x` is followed by at least one `$y`, and inside the block, we call the `find_min!`
    macro on the tail `$y`; these values are fed to `std::cmp::min`, which returns
    the smallest value from the argument list. On the second call, it would execute
    the first case of the macro and return the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` function, we run the following cases and print the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find_min!(1u32)`: This will execute the first case and return `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_min!(1u32 + 2 , 2u32)`: This will go to the second case, where the macro
    will be called again for the second expression and the `min` result of those two
    expressions will be returned, which is `2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_min!(5u32, 2u32 * 3, 4u32)`: This is similar to the second case, but
    here the macro will be called two times and the `min` result of all the expressions
    will be returned, which is `4` in this case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing DRY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Don't Repeat Yourself (DRY), in this recipe, we are going to create a
    test case for some basic standard arithmetic operations in Rust. The catch is,
    however, that we are going to work on automating them using macros and their features
    so that we can reduce redundant code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_dry.rs`, and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard operation crate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a macro named `assert_equal_len`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a macro named `op`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `add_assign`, `mul_assign`, and `sub_assign` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a module named `test:mod test {`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the successful execution of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45339c3f-4419-4064-a81b-2f4c1fcd2cab.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros allow developers to write DRY code by factoring out the common parts
    of functions and/or test suites. In this recipe, we implemented tested for the
    `+=`, `*=`, and `-=` operators on `Vec<T>`. We have used a new designator in this
    recipe, `tt`; which stands for token tree and is used for operators and tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first understand all the functional macro units in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert_equal_len`: This macro takes in four arguments as inputs, which are
    `$a`, `$b`, and `$func`, of the `ident` type, and `$op` of the `tt` type. If the
    macro receives these arguments, then it will check whether `$a` and `$b` are of
    the same length by using the `len()` method inside the `assert!` macro, which
    will return a Boolean value of `true` in the case of success or else, it prints
    a failure statement saying `dimension mismatch`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`op`: This macro takes in four arguments as input, which are `$func`, `$bound`,
    and `$method`, of the `ident` type, and `$op` of the `tt` type. We create the
    corresponding operator function with this macro, where `$func` is the name of
    the function and is the first argument in the list, with two arguments of the
    `Vec<T>` type: `xs` and `ys`. Both the variables are shared with the macros, and
    `xs` is provided with a mutable permission while it is shared. Inside the function,
    we perform the operation with `$bound::$method` for all the values of the vectors
    `xs` and `ys`, and the results are stored in `x` as it has mutable access. Here,
    `$bound` is the standard module and its `$method` corresponds to its unit. With
    this macro, we are able to perform a lot of methods on the data passed, which
    reduces the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: This macro takes in four arguments as input, which are `$func`, of
    the `ident` type, and `$x`, `$y`, and `$z`, which are `expr` of the `ident` type,
    and are present inside the `test` module, which is invoked while we run our test
    cases. Inside the `test` macro, we create the function with the name of `$func`.
    By doing so, it will become a function or unit of the parent `test` module. We
    iterate across the values to create vectors in which we perform `super::$func(&mut
    x, &y)`. The `super` here refers to the function that we created by using the
    `op` macro, which updates the value of `x` based on the operation we wanted to
    perform. In the last step, we validate `test` by comparing the updated `x` vector
    with the `z` vector, which is the desired value. The `assert_eq!` macro will return
    `true` if the values match; else it will panic out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this code, we use a certain set of standard libraries, which are `ops` and
    `item`. First, we create the different operations that we want to implement, so
    we call the `op!` and create `add_assign`, `mul_assign`, and `sub_assign`. Later
    in the test module, we call the test case for the different functions that we
    have created. Here, we give all the cases for passing and run the `--test` option
    during compilation to run the test cases.
  prefs: []
  type: TYPE_NORMAL
