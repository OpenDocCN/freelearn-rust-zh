<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Functional Programming – a Comparison</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1"><strong>Functional programm</strong><strong>ing</strong> (<strong>FP</strong>) is the second most popular programming paradigm, behind only <strong>obje</strong><strong>ct-oriented programming</strong> (<strong>OOP</strong>). For many years, these two paradigms have been separated into different languages, so as not to be mixed. <span><span>M</span></span>ulti-paradigm languages have attempted to support both approaches. Rust is one such language.</span></p>
<p class="p1"><span class="s1">As a broad definition, functional programming emphasizes the use of composable and maximally reusable functions to define program behavior. Using these techniques, we will show how functional programming has adapted clever solutions to many common yet difficult problems. This chapter will outline most of the concepts presented in this book. The remaining chapters will be dedicated to helping you master each technique.</span></p>
<p>The learning outcomes we hope to provide are as follows:</p>
<ul>
<li>Being able to use functional style to reduce code weight and complexity</li>
<li>Being able to write robust safe code by utilizing safe abstractions</li>
<li>Being able to engineer complex projects using functional principles</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>A recent version of Rust is necessary to run the examples provided, and can be found here:</p>
<p><a href="https://www.rust-lang.org/en-US/install.html">https://www.rust-lang.org/en-US/install.html</a></p>
<p>This chapter's code is also available on GitHub, here:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST">https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST</a></p>
<p>Specific installation and build instructions are also included in each chapter's <kbd>README.md</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducing code weight and complexity</h1>
                </header>
            
            <article>
                
<p>Functional programming can greatly reduce the amount and complexity of code required to accomplish tasks. Particularly in Rust, proper application of functional principles may simplify the often complex design requirements, and make programming a much more productive and rewarding experience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making generics more generic</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">Making generics more generic relates to the practice of</span> parameterizing <span class="s1">data structures and functions originated in functional languages. In Rust, and other languages, this is called <strong>generics</strong>. Types and functions can all be parameterized. One or more constraints may be placed on generic types to indicate requirements of a trait or lifetime.</span></p>
<p class="p2"><span class="s1">Struct definitions can become redundant without generics. Here is a definition of three structs that define a common concept of a <kbd>Point</kbd>. However, the structs use different numerical types, so the singular concept is expanded into three separate <kbd>PointN</kbd> type definitions in <kbd>intro_generics.rs</kbd>:</span></p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct PointU32 <br/>{<br/>    x: u32,<br/>    y: u32<br/>}<br/><br/>struct PointF32<br/>{<br/>    x: f32,<br/>    y: f32<br/>}<br/><br/>struct PointI32<br/>{<br/>    x: i32,<br/>    y: i32<br/>}</span></pre>
<p class="p2"><span class="s1">Instead, we can use generics to remove duplicate code and make the code more robust. Generic code is more easily adaptable to new requirements because many behaviors (and thus requirements) can be parameterized. If a change is needed, it is better to only change one line rather than a hundred.</span></p>
<p>This code snippet defines a parameterized <kbd>Point</kbd> struct. Now, a single definition can capture all possible numerical types for a <kbd>Point</kbd> in <kbd>intro_generics.rs</kbd>:</p>
<pre style="padding-left: 30px">struct Point&lt;T&gt;<br/>{<br/>    x: T,<br/>    y: T<br/>}</pre>
<p class="p2"><span class="s1">Functions are also problematic without generics.</span></p>
<p>Here is a simple function to square a number. However, to capture possible numerical types, we define three different functions in <kbd>intro_generics.rs</kbd>:</p>
<pre style="padding-left: 30px">fn foo_u32(x: u32) -&gt; u32<br/>{<br/>    x*x<br/>}<br/><br/>fn foo_f32(x: f32) -&gt; f32<br/>{<br/>    x*x<br/>}<br/><br/>fn foo_i32(x: i32) -&gt; i32<br/>{<br/>    x*x<br/>}</pre>
<p class="p2"><span class="s1">Function parameters, such as this one, may need trait bounds (a constraint specifying one or more traits) to permit any behavior on that type that is used in the function body.</span></p>
<p>Here is the <kbd>foo</kbd> function, redefined with a parameterized type. A single function can define the operation for all numerical types. Explicit bounds must be set for even basic operations, such as multiply or even copy, in <kbd>intro_generics.rs</kbd>:</p>
<pre style="padding-left: 30px">fn foo&lt;T&gt;(x: T) -&gt; T<br/>where T: std::ops::Mul&lt;Output=T&gt; + Copy<br/>{<br/>    x*x<br/>}</pre>
<p class="p2"><span class="s1">Even functions can be sent as parameters. We call these higher-order functions.</span></p>
<p>Here is a trivial function that accepts a function and argument, then calls the function with the argument, returning the result. Note the trait bound  <kbd>Fn</kbd>, indicating that the provided function is a closure. For an object to be callable, it must implement one of the <kbd>fn</kbd>, <kbd>Fn</kbd>, <kbd>FnMut</kbd>, or <kbd>FnOnce</kbd> traits in <kbd>intro_generics.rs</kbd>:</p>
<pre style="padding-left: 30px">fn bar&lt;F,T&gt;(f: F, x: T) -&gt; T<br/>where F: Fn(T) -&gt; T<br/>{<br/>    f(x)<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions as values</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">Functions are nominally the big feature of functional programming. Specifically, functions as values are the keystone of the whole paradigm. Glossing over much detail, we will also introduce the term <strong>closure</strong> here for future reference. A closure is an object that acts as a function, implementing <kbd>fn</kbd>, <kbd>Fn</kbd>, <kbd>FnMut</kbd>, or <kbd>FnOnce</kbd>.</span></p>
<p class="p2"><span class="s1">Simple closures can be defined with the built-in closure syntax. This syntax is also beneficial because the <kbd>fn</kbd>, <kbd>Fn</kbd>, <kbd>FnMut</kbd>, and <kbd>FnOnce</kbd> traits are automatically implemented if permitted. This syntax is great for shorthand manipulation of data.</span></p>
<p>Here is an iterator over the range <kbd>0</kbd> to <kbd>10</kbd>, mapped to the squared value. The square operation is applied using an inline closure definition sent to the <kbd>map</kbd> function of the iterator. The result of this expression will be an iterator. Here is an expression in <kbd>intro_functions.rs</kbd>:</p>
<pre class="p3" style="padding-left: 30px"><span class="s2">(0..10).map(|x| x*x);</span></pre>
<p class="p2"><span class="s1">Closures can also have complex bodies with statements if the block syntax is used.</span></p>
<p>Here is an iterator from <kbd>0</kbd> to <kbd>10</kbd>, mapped with a complex equation. The closure provided to map includes a function definition and a variable binding in <kbd>intro_functions.rs</kbd>:</p>
<pre style="padding-left: 30px"><span>(0..10).map(|x| {<br/>    fn f(y: u32) -&gt; u32 {<br/>        y*y<br/>    }<br/>    let z = f(x+1) * f(x+2);<br/>    z*z<br/>}</span></pre>
<p class="p2"><span class="s1">It is possible to define functions or methods that accept closures as arguments. To use the closure as a callable function, a bound of <kbd>Fn</kbd>, <kbd>FnMut</kbd>, or <kbd>FnOnce</kbd> must be specified.</span></p>
<p>Here is a HoF definition accepting a function <kbd>g</kbd> and an argument <kbd>x</kbd>. The definition constrains <kbd>g</kbd> and <kbd>x</kbd> to process <kbd>u32</kbd> types, and defines some mathematical operations involving calls to <kbd>g</kbd>. An invocation of the <kbd>f</kbd> HoF is also provided, as follows, using a simple inline closure definition in <kbd>intro_functions.rs</kbd>:</p>
<pre style="padding-left: 30px">fn f&lt;T&gt;(g: T, x: u32) -&gt; u32<br/>where T: Fn(u32) -&gt; u32<br/>{<br/>    g(x+1) * g(x+2)<br/>}<br/><br/>fn main()<br/>{<br/>   f(|x|{ x*x }, 2);<br/>}</pre>
<p class="p2"><span class="s1">Many parts of the standard library, particularly iterators, encourage heavy use of functions as arguments.</span></p>
<p>Here is an iterator from <kbd>0</kbd> to <kbd>10</kbd> followed by many chained iterator combinators. The <kbd>map</kbd> function returns a new value from an original. <kbd>inspect</kbd> looks at a value, does not change it, but permits side-effects. <kbd>filter</kbd> omits all values that do not satisfy a predicate. <kbd>filter_map</kbd> filters and maps with a single function. The <kbd>fold</kbd> reduces all results to a single value, starting from an initial value, working left to right. Here is the expression in <kbd>intro_functions.rs</kbd>:</p>
<pre style="padding-left: 30px">(0..10<span>).map(|x| x*x)<br/></span><span>       .inspect(|x|{ println!("value {}", *x) })<br/>       .filter(|x| *x&lt;3)<br/>       .filter_map(|x| Some(x))<br/>       .fold(0, |x,y| x+y);<br/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iterators</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">Iterators are a common feature of OOP languages, and Rust supports this concept well. Rust iterators are also designed with functional programming in mind, allowing programmers to write more legible code. The specific concept emphasized here is <strong>composability</strong>. When iterators can be manipulated, transformed, and combined, the mess of <kbd>for</kbd> loops can be replaced by individual function calls. These examples can be found in the <kbd>intro_iterators.rs</kbd> file. This is depicted in the following table:</span></p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Function name with description</strong></td>
<td><strong>Example</strong></td>
</tr>
<tr>
<td>Chain concatenates<span> t</span>wo itera<span>tors: <kbd>first...second</kbd></span></td>
<td>
<p><kbd>(0..10).chain(10..20);</kbd></p>
</td>
</tr>
<tr>
<td>The <kbd>zip</kbd><span> function combines two iterators into tuple</span> pairs, iterating until the end of the shortest iterator: <span>(a1,b1), (a2, b2), ...</span></td>
<td>
<p><kbd>(0..10).zip(10..20);</kbd></p>
</td>
</tr>
<tr>
<td>The <kbd>enumerate</kbd><span> function is a special case of </span><kbd>zip</kbd><span> that creates numbered tuples (0, a1),(1,a2), …</span></td>
<td>
<p class="p3" style="padding-left: 30px"><kbd><span class="s2">(0..10).enumerate();</span></kbd></p>
</td>
</tr>
<tr>
<td>The <kbd>inspect</kbd><span> function applies a function to all values in the iterator during iteration</span></td>
<td>
<p class="p3" style="padding-left: 30px"><kbd><span class="s2">(0..10).inspect(|x|{ println!("value {}", *x) });</span></kbd></p>
</td>
</tr>
<tr>
<td>The <kbd>map</kbd><span> function applies a function to each element, returning the result in place</span></td>
<td>
<p class="p3" style="padding-left: 30px"><kbd><span class="s2">(0..10).map(|x| x*x);</span></kbd></p>
</td>
</tr>
<tr>
<td>The <kbd>filter</kbd><span> function restricts elements to those satisfying a predicate</span></td>
<td>
<p class="p3" style="padding-left: 30px"><kbd><span class="s2">(0..10).filter(|x| *x&lt;3);</span></kbd></p>
</td>
</tr>
<tr>
<td>The <kbd>fold</kbd><span> function accumulates all values into a single result</span></td>
<td>
<p class="p3" style="padding-left: 30px"><kbd><span class="s2">(0..10).fold(0, |x,y| x+y);</span></kbd></p>
</td>
</tr>
<tr>
<td><span class="s1">When you want to apply the iterator, you can use a<span> </span><kbd>for</kbd><span> </span>loop or call<span> </span><kbd>collect</kbd></span></td>
<td>
<p><kbd>for i in (0..10) {}</kbd><br/>
<br/>
<kbd>(0..10).collect::&lt;Vec&lt;u64&gt;&gt;();</kbd></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compact legible expressions</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In functional languages, all terms are expressions. There are no statements in function bodies, only a single expression. All control flow operators are then formulated as expressions with a return value. In Rust, this is almost the case; the only non-expressions are <kbd>let</kbd> statements and item declarations.</span></p>
<p class="p1"><span class="s1">Both of these statements can be wrapped in blocks to create an expression along with any other term. An example for this is the following, in <kbd>intro_expressions.rs</kbd>:</span></p>
<pre style="padding-left: 30px">let x = {<br/>    fn f(x: u32) -&gt; u32 {<br/>        x * x<br/>    }<br/>    let y = f(5);<br/>    y * 3<br/>};</pre>
<p class="p1"><span class="s1">This nested format is uncommon in the wild, but it illustrates the permissive nature of Rust grammar.</span></p>
<p class="p1"><span class="s1">Returning to the concept of functional style expressions, the emphasis should always be on writing legible literate code without much hassle or bloat. When someone else, or you at a later time, comes to read your code, it should be immediately understandable. Ideally, the  code should document itself. If you find yourself constantly writing code twice, once in code and again as comments, then you should reconsider how effective your programming practices really are.</span></p>
<p class="p1"><span class="s1">To start with some examples of functional expressions, let's look at an expression that exists in most languages, the ternary conditional operator. In a normal <kbd>if</kbd> statement, the condition must occupy its own line and thus cannot be used as a sub-expression.</span></p>
<p>The following is a traditional <kbd>if</kbd> statement, initializing a variable in <kbd>intro_expressions.rs</kbd>:</p>
<pre class="p2" style="padding-left: 30px"><span class="s2">let x;<br/>if true {<br/>    x = 1;<br/>} else {<br/>    x = 2;<br/>}</span></pre>
<p class="p1"><span class="s1">With the ternary operator, this assignment can be moved to a single line, shown as follows in <kbd>intro_expressions.rs</kbd>:</span></p>
<pre class="p2" style="padding-left: 30px"><span class="s2">let x = if true { 1 } else { 2 };</span></pre>
<p class="p1"><span class="s1"><span>Almost</span> every statement from OOP in Rust is also an expression—<kbd>if</kbd>, <kbd>for</kbd>, <kbd>while</kbd>, and so on. One of the more unique expressions to see in Rust that is uncommon in OOP languages is direct constructor expressions. All Rust types can be instantiated by single expressions. Constructors are only necessary in specific cases, for example, when an internal field requires complex initialization. The following is a simple <kbd>struct</kbd> and an equivalent tuple in <kbd>intro_expressions.rs</kbd>:</span></p>
<pre class="p2" style="padding-left: 30px"><span class="s2">struct MyStruct<br/>{<br/>    a: u32,<br/>    b: f32,<br/>    c: String<br/>}<br/><br/>fn main()<br/>{<br/>    MyStruct {<br/>        a: 1,<br/>        b: 1.0,<br/>        c: "".to_string()<br/>    };<br/><br/><span>    (1, 1.0, "".to_string());<br/>}</span></span></pre>
<p class="p1"><span class="s1">Another distinctive expression from functional languages is pattern matching. Pattern matching can be thought of as a more powerful version of a <kbd>switch</kbd> statement. Any expression can be sent into a pattern expression and</span> de-structured <span class="s1">to bind internal information into local variables before executing a <kbd>branch</kbd> expression. Pattern expressions are uniquely suited for working with enums. The two make a perfect pair.</span></p>
<p>The following snippet defines a <kbd>Term</kbd> as a tagged union of expression options. In the main function, a <kbd>Term</kbd> <kbd>t</kbd> is constructed, then matched with a pattern expression. Note the syntax similarity between the definition of a tagged union and the matching inside of a pattern expression in <kbd>intro_expressions.rs</kbd>:</p>
<pre class="p2" style="padding-left: 30px"><span class="s2">enum Term<br/>{<br/>    TermVal { value: String },<br/>    TermVar { symbol: String },<br/>    TermApp { f: Box&lt;Term&gt;, x: Box&lt;Term&gt; },<br/>    TermAbs { arg: String, body: Box&lt;Term&gt; }<br/>}<br/><br/>fn main()<br/>{<br/>    let mut t = Term::TermVar {<br/>        symbol: "".to_string()<br/>    };<br/>    match t {<br/>        Term::<span>TermVal { value: v1 } =&gt; v1,<br/>        Term::TermVar { symbol: v1 } =&gt; v1,<br/>        Term::TermApp { f: ref v1, x: ref v2 } =&gt;<br/>            "TermApp(?,?)".to_string(),<br/>        Term::TermAbs { arg: ref mut v1, body: ref mut v2 } =&gt;  <br/>            "TermAbs(?,?)".to_string()<br/>    };<br/>}</span></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strict abstraction means safe abstraction</h1>
                </header>
            
            <article>
                
<p>Having a stricter type system does not imply that code will have more requirements or be any more complex. Rather than strict typing, consider using the term expressive typing. Expressive typing provides more information to the compiler. This extra information allows the compiler to provide extra assistance while programming. This extra information also permits a very rich metaprogramming system. This is all in addition to the obvious benefit of safer, more robust code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scoped data binding</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Variables in Rust are treated much more strictly than in most other languages. Global variables are almost entirely disallowed. Local variables are put under close watch to ensure that allocated data structures are properly deconstructed before going out of scope, but not sooner. This concept of tracking a variable's proper scope is known as <strong>ownership</strong> and <strong>lifetime</strong>.</span></p>
<p class="p1"><span class="s1">In a simple example, data structures that allocate memory will deconstruct automatically when they go out of scope. No manual memory management is required in <kbd>intro_binding.rs</kbd>:</span></p>
<pre style="padding-left: 30px">fn scoped() {<br/>    vec![1, 2, 3];<br/>}</pre>
<p class="p1"><span class="s1">In a slightly more complex example, allocated data structures can be passed around as return values, or referenced, and so on. These exceptions to simple scoping must also be accounted for in <kbd>intro_binding.rs</kbd>:</span></p>
<pre style="padding-left: 30px">fn scoped2() -&gt; Vec&lt;u32&gt;<br/>{<br/>    vec![1, 2, 3]<br/>}</pre>
<p class="p1"><span class="s1">This usage tracking can get complicated (and undecidable), so Rust has some rules that restrict when a variable can escape a context. We call this <strong>complex rules ownership</strong>. It can be explained with the following code, in <kbd>intro_binding.rs</kbd>:</span></p>
<pre style="padding-left: 30px">fn scoped3()<br/>{<br/>    let v1 = vec![1, 2, 3];<br/>    let v2 = v1;<br/>    //it is now illegal to reference v1<br/>    //ownership has been transferred to v2<br/>}</pre>
<p class="p1"><span class="s1">When it is not possible or desirable to transfer ownership, the <kbd>clone</kbd> trait is encouraged to create a duplicate copy of whatever data is referenced in <kbd>intro_binding.rs</kbd>:</span></p>
<pre style="padding-left: 30px">fn scoped4()<br/>{<br/>    vec![1, 2, 3].clone();<br/>    "".to_string().clone();<br/>}</pre>
<p class="p1">Cloning or copying <span class="s1">is not a perfect solution, and comes with a performance overhead. To make Rust faster, and it is pretty fast, we also have the concept of borrowing. Borrowing is a mechanism to receive a direct reference to some data with the promise that ownership will be returned by some specific point. References are indicated by an ampersand. Consider the following example, in <kbd>intro_binding.rs</kbd>:</span></p>
<pre style="padding-left: 30px">fn scoped5()<br/>{<br/>   fn foo(v1: &amp;Vec&lt;u32&gt;)<br/>   {<br/>       for v in v1<br/>       {<br/>           println!("{}", v);<br/>       }<br/>   }<br/><br/>   let v1 = vec![1, 2, 3];<br/>   foo(&amp;v1);<br/><br/>   //v1 is still valid<br/>   //ownership has been returned<br/>   v1;<br/>}</pre>
<p>Another benefit of strict ownership is safe concurrency. Each binding is owned by a particular thread, and that ownership can be transferred to new threads with the <kbd>move</kbd> keyword. This has been explained with the following code, in <kbd>intro_binding.rs</kbd>:</p>
<pre style="padding-left: 30px"><span class="hljs-keyword">use</span><span> std::thread;<br/></span><span class="hljs-function"><span class="hljs-keyword"><br/>fn</span> thread1</span><span>()<br/>{<br/></span><span class="hljs-keyword">   let</span><span> v = </span><span class="hljs-built_in">vec!</span><span>[</span><span class="hljs-number">1</span><span>, </span><span class="hljs-number">2</span><span>, </span><span class="hljs-number">3</span><span>];<br/></span><span class="hljs-keyword"><br/>   let</span><span> handle = thread::spawn(</span><span class="hljs-keyword">move</span><span> || {<br/></span><span class="hljs-built_in">      println!</span><span>(</span><span class="hljs-string">"Here's a vector: {:?}"</span><span>, v);<br/>   });<br/><br/>   handle.join().ok();<br/>}<br/></span></pre>
<p>To share information between threads, programmers have two main options.</p>
<p>First, programmers may use the traditional combination of locks and atomic references. This is explained with the following code, in <kbd>intro_binding.rs</kbd>:</p>
<pre style="padding-left: 30px"><span class="hljs-keyword">use</span><span> std::sync::{Mutex, Arc};<br/></span><span class="hljs-keyword">use</span><span> std::thread;<br/></span><span class="hljs-function"><span class="hljs-keyword"><br/>fn</span> thread2</span><span>()<br/>{<br/></span><span class="hljs-keyword"><br/>   let</span><span> counter = Arc::new(Mutex::new(</span><span class="hljs-number">0</span><span>));<br/></span><span class="hljs-keyword">   let</span><span> </span><span class="hljs-keyword">mut</span><span> handles = </span><span class="hljs-built_in">vec!</span><span>[];<br/></span><span class="hljs-keyword"><br/>   for</span><span> _ </span><span class="hljs-keyword">in</span><span> </span><span class="hljs-number">0</span><span>..</span><span class="hljs-number">10</span><span> {</span><span class="hljs-keyword"><br/>      let</span><span> counter = Arc::clone(&amp;counter);<br/></span><span class="hljs-keyword">      let</span><span> handle = thread::spawn(</span><span class="hljs-keyword">move</span><span> || {<br/></span><span class="hljs-keyword">         let</span><span> </span><span class="hljs-keyword">mut</span><span> num = counter.lock().unwrap();<br/>         *num += </span><span class="hljs-number">1</span><span>;<br/>      });<br/>      handles.push(handle);<br/>   }<br/></span><span class="hljs-keyword"><br/>   for</span><span> handle </span><span class="hljs-keyword">in</span><span> handles {<br/>      handle.join().unwrap();<br/>   }<br/></span><span class="hljs-built_in"><br/>   println!</span><span>(</span><span class="hljs-string">"Result: {}"</span><span>, *counter.lock().unwrap());<br/>}</span></pre>
<p>Second, channels provide a nice mechanism for message passing and job queuing between threads. The <kbd>send</kbd> trait is also implemented automatically for most objects. Consider the following code, in <kbd>intro_binding.rs</kbd>:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">use std::thread;<br/></span><span class="s1">use std::sync::mpsc::channel;</span><span class="s1"><br/><br/>fn thread3() {<br/><br/>    let (sender, receiver) = channel();<br/>    let handle = thread::spawn(move ||{<br/><br/>        //do work<br/>        let v = vec![1, 2, 3];<br/>        sender.send(v).unwrap();<br/><br/>    });<br/><br/>    handle.join().ok();<br/>    receiver.recv().unwrap();<br/>}</span></pre>
<p>All of this concurrency is type-safe and compiler-enforced. Use threads as much as you want, and if you accidentally try to create a race condition or simple deadlock, then the compiler will stop you. We call this <strong>fearless concurrency</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Algebraic datatypes</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In addition to structs/objects and functions/methods, Rust functional programming includes some rich additions to definable types and structures. Tuples provide a shorthand for defining simple anonymous structs. Enums provide a type-safe approach to unions of complex data structures with the added bonus of a constructor tag to help in pattern matching. The standard library has extensive support for generic programming, from base types to collections. Even the object system traits are a hybrid cross between the OOP concept of a class and the FP concept of type classes. Functional style lurks around every corner, and even if you don't seek them in Rust, you will probably find yourself unknowingly using the features.</span></p>
<p class="p1">The <kbd>type</kbd> aliases <span class="s1">can be helpful to create shorthand names for complex types. Alternatively, the <kbd>newtype</kbd> struct pattern can be used to create an alias with different non-equivalent types. Consider the following example, in <kbd>intro_datatypes.rs</kbd>:</span></p>
<pre class="p2" style="padding-left: 30px"><span class="s2">//alias<br/>type Name = String;<br/><br/>//newtype<br/>struct NewName(String);</span></pre>
<p class="p1">A <kbd>struct</kbd><span class="s1">, even when parameterized, can be repetitive when used simply to store multiple values into a single object. This can be seen in<span> </span><kbd>intro_datatypes.rs</kbd>:</span></p>
<pre style="padding-left: 30px">struct Data1<br/>{<br/>    a: i32,<br/>    b: f64,<br/>    c: String<br/>}<br/><br/>struct Data2<br/>{<br/>    a: u32,<br/>    b: String,<br/>    c: f64<br/>}</pre>
<p class="p1">A tuple <span class="s1">helps eliminate redundant struct definitions. No prior type definitions are necessary to use tuples. Consider the following example, <span>in </span><kbd>intro_datatypes.rs</kbd>:</span></p>
<pre style="padding-left: 30px">//alias to tuples<br/>type Tuple1 = (i32, f64, String);<br/>type Tuple2 = (u32, String, f64);<br/><br/>//named tuples<br/>struct New1(i32, f64, String);<br/>struct New2(u32, String, f64);</pre>
<p class="p1"><span class="s1">Standard operators can be implemented for any type by implementing the correct trait. Consider the following example for this, <span>in </span><kbd>intro_datatypes.rs</kbd>:</span></p>
<pre style="padding-left: 30px"><span>use std::ops::Mul;<br/><br/>struct Point<br/>{<br/>    x: i32,<br/>    y: i32<br/>}<br/><br/>impl Mul for Point<br/>{<br/>    type Output = Point;<br/>    fn mul(self, other: Point) -&gt; Point<br/>    {<br/>        Point<br/>        {<br/>            x: self.x * other.x,<br/>            y: self.y * other.y<br/>        }<br/>    }<br/>}</span></pre>
<p class="p1"><span class="s1">Standard library collections and many other built-in types are generic, such as <kbd>HashMap</kbd> in <kbd>intro_datatypes.rs</kbd>:</span></p>
<pre style="padding-left: 30px"><span>use std::collections::HashMap;<br/><br/></span>type CustomHashMap = HashMap&lt;i32,u32&gt;;</pre>
<p class="p1"><span class="s1">Enums are a type-safe union of multiple types. Note that recursive <kbd>enum</kbd> definitions must wrap the inner value in a container such as <kbd>Box</kbd>, otherwise the size would be infinite. This is depicted as follows, <span>in </span><kbd>intro_datatypes.rs</kbd>:</span></p>
<pre style="padding-left: 30px">enum BTree&lt;T&gt;<br/>{<br/>    <span>Branch { val:T, left:Box&lt;BTree&lt;T&gt;&gt;, right:Box&lt;BTree&lt;T&gt;&gt; },</span><br/>    Leaf { val: T }<br/>}</pre>
<p class="p1"><span class="s1">Tagged unions are also used for more complex data structures. Consider the following code, <span>in </span><kbd>intro_datatypes.rs</kbd>:</span></p>
<pre style="padding-left: 30px">enum Term<br/>{<br/>    TermVal { value: String },<br/>    TermVar { symbol: String },<br/>    TermApp { f: Box&lt;Term&gt;, x: Box&lt;Term&gt; },<br/>    TermAbs { arg: String, body: Box&lt;Term&gt; }<br/>}</pre>
<p class="p1">Traits are a bit like object classes (OOP), shown with the following code example, in <kbd>intro_datatypes.rs</kbd>:</p>
<pre style="padding-left: 30px">trait Data1Trait<br/>{<br/>    //constructors<br/>    fn new(a: i32, b: f64, c: String) -&gt; Self;<br/>    <br/>    //methods<br/>    fn get_a(&amp;self) -&gt; i32;<br/>    fn get_b(&amp;self) -&gt; f64;<br/>    fn get_c(&amp;self) -&gt; String;<br/>}</pre>
<p class="p1">Traits are also like type classes (FP), shown with the following code snippet, in <kbd>intro_datatypes.rs</kbd>:</p>
<pre style="padding-left: 30px">trait BehaviorOfShow<br/>{<br/>    fn show(&amp;self) -&gt; String;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mixing object-oriented programming and functional programming</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As mentioned before, Rust supports much of both object-oriented and functional programming styles. Datatypes and functions are neutral to either paradigm. Traits specifically support a hybrid blend of both styles.</span></p>
<p class="p1"><span class="s1">First, in an object-oriented style, defining a simple class with a constructor and some methods can be accomplished with a <kbd>struct</kbd>, <kbd>trait</kbd>, and <kbd>impl</kbd>. This is explained using the following code snippet, in <kbd>intro_mixoopfp.rs</kbd>:</span></p>
<pre style="padding-left: 30px">struct MyObject<br/>{<br/>    a: u32,<br/>    b: f32,<br/>    c: String<br/>}<br/><br/>trait MyObjectTrait<br/>{<br/>    fn new(a: u32, b: f32, c: String) -&gt; Self;<br/>    fn get_a(&amp;self) -&gt; u32;<br/>    fn get_b(&amp;self) -&gt; f32;<br/>    fn get_c(&amp;self) -&gt; String;<br/>}<br/><br/>impl MyObjectTrait for MyObject<br/>{<br/>    fn new(a: u32, b: f32, c: String) -&gt; Self<br/>    {<br/>        MyObject { a:a, b:b, c:c }<br/>    }<br/><br/>    fn get_a(&amp;self) -&gt; u32<br/>    {<br/>        self.a<br/>    }<br/><br/>    fn get_b(&amp;self) -&gt; f32<br/>    {<br/>        self.b<br/>    }<br/><br/>    fn get_c(&amp;self) -&gt; String<br/>    {<br/>        self.c.clone()<br/>    }<br/>}</pre>
<p class="p1"><span class="s1">Adding support for functional programming onto an object is as simple as defining traits and methods that use functional language features. For example, accepting a closure can become a great abstraction when used appropriately. Consider the following example, in <kbd>intro_mixoopfp.rs</kbd>:</span></p>
<pre style="padding-left: 30px">trait MyObjectApply<br/>{<br/>    fn apply&lt;F,R&gt;(&amp;self, f:F) -&gt; R<br/>    where F: Fn(u32,f32,String) -&gt; R;<br/>}<br/><br/>impl MyObjectApply for MyObject<br/>{<br/>    fn apply&lt;F,R&gt;(&amp;self, f:F) -&gt; R<br/>    where F: Fn(u32,f32,String) -&gt; R<br/>    {<br/>        f(self.a, self.b, self.c.clone())<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving project architecture</h1>
                </header>
            
            <article>
                
<p>Functional programs encourage good project architecture and principled design patterns. Using the building blocks of functional programming often reduces the number of design choices to be made in such a way that good options become obvious.</p>
<div class="packt_quote">"There should be one - and preferably only one - obvious way to do it."</div>
<div class="packt_quote"><span>                                                                                                                         –</span> <em>PEP 20</em></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">File hierarchy, modules, and namespace design</h1>
                </header>
            
            <article>
                
<p>Rust programs are compiled primarily in one of two ways. The first is to use <kbd>rustc</kbd> to compile individual files. The second is to describe an entire package for compilation using <kbd>cargo</kbd>. We will assume here that projects are built using <kbd>cargo</kbd>, as follows:</p>
<ol>
<li>To start a package, you first create a <kbd>Cargo.toml</kbd> file in a directory. That directory will be your package directory from now on. This is a configuration file that will tell the compiler what code, assets, and extra information should be included into the package:</li>
</ol>
<pre style="padding-left: 60px"><span class="hljs-section">[package]<br/></span><span class="hljs-attr">name</span><span> = </span><span class="hljs-string">"fp_rust"<br/></span><span class="hljs-attr">version</span><span> = </span><span class="hljs-string">"0.0.1"<br/></span></pre>
<ol start="2">
<li>After this basic configuration, you can now use <kbd>cargo build</kbd> to compile the entire project. Where you decide to place your code files, and what to name them, is determined by how you want to refer to them in the module namespace. Each file will be given its own module <kbd>mod</kbd>. You can also nest modules inside files:</li>
</ol>
<pre style="padding-left: 60px"><span class="hljs-keyword">mod</span><span> inner_module<br/>{<br/></span><span class="hljs-function"><span class="hljs-keyword">    fn</span> f1</span><span>()<br/>    {<br/></span><span class="hljs-built_in">        println!</span><span>("inner module function"</span><span>);<br/>    }<br/>}<br/></span></pre>
<ol start="3">
<li>After these steps, projects can then be added as cargo dependencies, and namespaces can be used inside of modules to expose public symbols. Consider the following code snippet:</li>
</ol>
<pre style="padding-left: 60px">extern crate package;<br/>use package::inner_module::f1;</pre>
<p>These are the basic building blocks of Rust modules, but what does this have to do with functional programming?</p>
<p>Architecting a project in functional style is a process, and lends itself to certain routines. Typically, the project architect will start by designing the core data structures and in complex cases also the physical structure (where code/services will operationally be run). Once the data layout has been outlined in sufficient detail, then core functions/routines can be planned (such as how the program behaves). Up to this point, there may be code left unimplemented if coding is happening during the architecting stage. The final stage involves replacing this mock code with correct behaviors.</p>
<p>Following this stage-by-stage development process, we can also see an archetypical file layout forming. It is common to see these stages written top to bottom in actual programs. Though it is unlikely the authors went through planning in these explicit stages, it still is a common pattern due to simplicity's sake. Consider the following example:</p>
<pre style="padding-left: 30px">//trait definitions<br/><br/>//data structure and trait implementations<br/><br/>//functions<br/><br/>//main</pre>
<p>Grouping definitions like this may be helpful to standardize file layout and improve readability. Searching back and forth through a long file for symbol definitions is a common but unpleasant part of programming. It is also a preventable problem.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional design patterns</h1>
                </header>
            
            <article>
                
<p>Aside from file layout, there are a number of functional design patterns that help reduce code weight and redundancy. When used properly, these principles can help clarify design decisions and also enable robust architecture. Most design patterns are variants of the single responsibility principle. This can take many forms depending on the context, but the intent is the same; write code that does one thing well, then reuse that code as needed. I have explained this as follows:</p>
<ul>
<li><strong>Pure functions</strong>: These are functions with no side effects or logical dependencies other than function arguments. A side effect is a change of state that affects anything outside of the function, aside from the return value. Pure functions are useful because they can be tossed around and combined and generally used carelessly without the risk of unintended effects.</li>
</ul>
<div class="packt_infobox">The worst thing that can go wrong with a pure function is a bad return value or, in extreme cases, a stack overflow.</div>
<p style="padding-left: 60px">It is harder to cause bugs with pure functions, even when used recklessly. Consider the following example of pure functions, in <kbd>intro_patterns.rs</kbd>:</p>
<pre style="padding-left: 60px">fn pure_function1(x: u32) -&gt; u32<br/>{<br/>    x * x<br/>}<br/><br/>fn impure_function(x: u32) -&gt; u32<br/>{<br/>    println!("x = {}", x);<br/>    x * x<br/>}</pre>
<ul>
<li><strong>Immutability</strong>: Immutability is a pattern that helps encourage pure functions. Rust variable bindings are immutable <span>by default. This is Rust's not-so-subtle way of encouraging you to avoid mutable state. Don't do it. If you absolutely must, it is possible to tag variables with the</span> <kbd>mut</kbd> key<span>word to allow reassignment. This is shown with the following example, in <kbd>intro_patterns.rs</kbd>:</span></li>
</ul>
<pre class="p1" style="padding-left: 60px"><span class="s1">let immutable_v1 = 1;<br/>//immutable_v1 = 2; //invalid<br/><br/>let mut mutable_v2 = 1;<br/>mutable_v2 = 2;</span></pre>
<ul>
<li><strong>Functional composition</strong>: Functional composition is a pattern where the output of one function is connected to the input of another function. In this fashion, functions can be chained together to create complex effects from simple steps. This is shown with the following code snippet, <span>in </span><kbd>intro_patterns.rs</kbd>:</li>
</ul>
<pre style="padding-left: 60px"><span>let fsin = |x: f64| x.sin();<br/></span><span>let fabs = |x: f64| x.abs();<br/><br/>//feed output of one into the other<br/>let transform = |x: f64| fabs(fsin(x));</span></pre>
<ul>
<li><strong>Higher-order functions</strong><span>: These</span> have already been mentioned before, but we haven't used the term yet. A HoF is a function that accepts a function as a parameter. Many iterator methods are HoFs. Consider the following example, <span>in </span><kbd>intro_patterns.rs</kbd>:</li>
</ul>
<pre class="rust trait" style="padding-left: 60px">fn filter&lt;P&gt;(self, <strong>predicate</strong>: P) -&gt; Filter&lt;Self, P&gt;<br/>where P: FnMut(&amp;Self::Item) -&gt; bool<br/>{ ... }</pre>
<ul>
<li><strong>Functors</strong>: If you can get past the name, these are a simple and effective design pattern. They are also very versatile. The concept is somewhat difficult to capture in its entirety, but you may think of functors as <em>the inverse of functions</em>. A function defines a transformation, accepts data, and returns the result of the transformation. A functor defines data, accepts a function, and returns the result of the transformation. A common example of a functor is the bound <kbd>map</kbd> method that frequently appears on containers, such as for a <kbd>Vec</kbd>. Here is an example, in <kbd>intro_patterns.rs</kbd>:</li>
</ul>
<pre class="rust rust-example-rendered" style="padding-left: 60px"><span class="macro">let mut c = 0;<br/>for _ in vec</span><span class="macro">!</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].<span class="ident">into_iter</span>()
   .<span class="ident">map</span>(<span class="op">|</span><span class="ident">letter</span><span class="op">|</span> {<br/><span class="ident">      c</span> <span class="op">+=</span> <span class="number">1</span>; (<span class="ident">letter</span>, <span class="ident">c</span>)<br/>   }){};</pre>
<div class="packt_quote" style="padding-left: 60px"><span>"A monad is a monoid in the category of endofunctors, what's the problem?"</span></div>
<div class="mce-root packt_quote">                                                                                                – <em>Philip Wadler</em></div>
<ul>
<li><strong>Monads</strong>: Monads are a common stumbling block for people learning FP. Monads and functors are maybe the first words that you may encounter on a journey that goes deep into theoretical mathematics. We won't go there. For our purposes, monads are simply a <kbd>trait</kbd> with two methods. This is shown in the following code, <span>in </span><kbd>intro_patterns.rs</kbd>:</li>
</ul>
<pre class="p1" style="padding-left: 60px"><span class="s1">trait Monad&lt;A&gt; {<br/>    fn return_(t: A) -&gt; Self;<br/>    //:: A -&gt; Monad&lt;A&gt;<br/><br/>    fn bind&lt;MB,B&gt;(m: Self, f: Fn(A) -&gt; MB) -&gt; MB<br/>    where MB: Monad&lt;B&gt;;<br/>    //:: Monad&lt;A&gt; -&gt; (A -&gt; Monad&lt;B&gt;) -&gt; Monad&lt;B&gt;<br/>}</span></pre>
<p style="padding-left: 60px">If that doesn't help clarify things (and it probably doesn't), a monad has two methods. The first method is the constructor. The second method lets you bind an operation to create another monad. Many common traits have hidden semi-monads but, by making the concept explicit, the concept becomes a strong design pattern instead of a messy anti-pattern. Don't try to reinvent what you don't have to.</p>
<ul>
<li><strong>Function currying</strong>: Function currying is a technique that may seem strange for anyone coming from a background in object-oriented or imperative languages. The reason for this confusion is that in many functional languages, functions are curried by default, whereas this is not the case for other languages. Rust functions are not curried by default.</li>
</ul>
<p style="padding-left: 60px">The difference between curried and non-curried functions are that curried functions send in parameters one by one, whereas non-curried functions send in parameters all at once. Looking at a normal Rust function definition, we can see that it is not curried. Consider the following code, <span>in </span><kbd>intro_patterns.rs</kbd>:</p>
<pre style="padding-left: 60px">fn not_curried(p1: u32, p2: u32) -&gt; u32<br/>{<br/>    p1 + p2<br/>}<br/><br/>fn main()<br/>{<br/>   //and calling it<br/>   not_curried(1, 2);<br/>}</pre>
<p style="padding-left: 60px">A <kbd>curried</kbd> function takes each parameter one by one, as shown in the following, in <kbd>intro_patterns.rs</kbd>:</p>
<pre style="padding-left: 60px">fn curried(p1: u32) -&gt; Box&lt;Fn(u32) -&gt; u32&gt;<br/>{<br/>    Box::new(move |p2: u32| {<br/>        p1 + p2<br/>    })<br/>}<br/><br/>fn main()<br/>{<br/>   //and calling it<br/>   curried(1)(2);<br/>}</pre>
<p style="padding-left: 60px">Curried functions can be used as a function factory. The first few arguments configure how the final function should behave. The result is a pattern that allows shorthand configuration of complex operators. Currying complements all the other design patterns by converting individual functions into multiple components.</p>
<ul>
<li><strong>Lazy evaluation</strong>: Lazy evaluation is a pattern that is technically possible in other languages. However, it is uncommon to see it outside of FP, <span>due to language barriers. The difference between a normal expression and a lazy expression is that a lazy expression will not be evaluated until accessed. Here is a simple implementation of laziness, implemented behind a function call in <kbd>intro_patterns.rs</kbd>:</span></li>
</ul>
<pre style="padding-left: 60px">let x = { println!("side effect"); 1 + 2 };<br/><br/>let y = ||{ println!("side effect"); 1 + 2 };</pre>
<p>The second expression will not be evaluated until the function is called, at which point the code resolves. For lazy expressions, side effects happen at time of resolution instead of at initialization. This is a poor implementation of laziness, so we will go into further detail in later chapters. The pattern is fairly common, and some operators and data structures require laziness to work. A simple example of necessary laziness is a lazy list that may not otherwise be possible to create. The built-in Rust numerical iterator (lazy list) uses this well: <kbd>(0..)</kbd>.</p>
<p>Memoization is the last pattern that we will introduce here. It may be considered as more of an optimization than design pattern, but due to how common it is, we should mention it here. A memoized function only computes unique results once. A simple implementation would be a function guarded by a hash table. If the parameters and result are already in the hash table, then skip the function call and directly return the result from the hash table. Otherwise, compute the result, put it in the hash table, and return. This process can be implemented manually in any language, but Rust macros allow us to write the memoization code once, and reuse that code by applying this macro. This is shown using the following code snippet, in <kbd>intro_patterns.rs</kbd>:</p>
<pre class="rust rust-example-rendered" style="padding-left: 30px"><span>#[macro_use] extern crate cached;<br/>#[macro_use] extern crate lazy_static;</span><br/><br/>cached! {<br/>    FIB;<br/>    fn fib(n: u64) -&gt; u64 = {<br/>        if n==0 || n==1 { return n }<br/>        fib(n-1) + fib(n-2)<br/>    }<br/>}<br/><br/><span class="s1">fn main()<br/></span><span class="s1">{<br/>   fib(30);<br/></span><span class="s1">}</span></pre>
<p>This example makes use of two crates and many macros. We won't fully explain everything that is happening here until the very end of this book. There is much that is possible with macros and metaprogramming. Caching function results is just a start.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Metaprogramming</h1>
                </header>
            
            <article>
                
<p>The term metaprogramming in Rust often overlaps with the term macros. There are two primary types of macros available in Rust:</p>
<ul>
<li>Recursive</li>
<li>Procedural</li>
</ul>
<p>Both types of macros take as input an <strong>abstract syntax tree</strong> (<strong>AST</strong>), and produce one or more AST.</p>
<p>A commonly used macro is <kbd>println</kbd>. A variable number of arguments and types are joined with the format string through the use of a macro to produce formatted output. To invoke recursive macros like this, invoke the macro just like a function with the addition of a <kbd>!</kbd> before the arguments. Macro applications may alternatively be surrounded by <kbd>[]</kbd> or <kbd>{}</kbd>:</p>
<pre style="padding-left: 30px">vec!["this is a macro", 1, 2];</pre>
<p>Recursive macros are defined by <kbd>macro_rules!</kbd> statements. The inside of a <kbd>macro_rules</kbd> definition is very similar to that of a pattern-matching expression. The only difference is that <kbd>macro_rules!</kbd> matches syntax instead of data. We can use this format to define a reduced version of the <kbd>vec</kbd> macro. This is shown in the following code snippet, in <kbd>intro_metaprogramming.rs</kbd>:</p>
<pre style="padding-left: 30px">macro_rules! my_vec_macro<br/>{<br/>    ( $( $x:expr ),* ) =&gt;<br/>    {<br/>        {<br/>            let mut temp_vec = Vec::new();<br/>            $(<br/>                temp_vec.push($x);<br/>            )*<br/>            temp_vec<br/>        }<br/>    }<br/>}</pre>
<p>This definition accepts and matches only one pattern. It expects a comma-separated list of expressions. The syntax pattern <kbd>( $( $x: expr ),* )</kbd> matches against a comma-separated list of expressions and stores the result in the plural variable <kbd>$x</kbd>. In the body of the expression, there is a single block. The block defines a new <kbd>vec</kbd>, then iterates through <kbd>$x*</kbd> to push each <kbd>$x</kbd> into the <kbd>vec</kbd>, and, finally, the block returns the <kbd>vec</kbd> as its result. The macro and its expansion are as follows, in <kbd>intro_metaprogramming.rs</kbd>:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">//this<br/>my_vec_macro!(1, 2, 3);<br/><br/>//is the same as this<br/>{<br/>    let mut temp_vec = Vec::new();<br/>    temp_vec.push(1);<br/>    temp_vec.push(2);<br/>    temp_vec.push(3);<br/>    temp_vec<br/>}</span></pre>
<p>It is important to note that expressions are moved as code, not as values, so side effects will be moved to the evaluating context, not the defining context.</p>
<p>Recursive macro patterns match against token strings. It is possible to execute separate branches depending on which tokens are matched. A simple case match looks like the following, <span>in </span><kbd>intro_metaprogramming.rs</kbd>:</p>
<pre style="padding-left: 30px"><span class="hljs-built_in">macro_rules!</span><span> my_macro_branch<br/>{</span><span><br/>    (1 $e:expr) =&gt; (</span><span class="hljs-built_in">println!</span><span>(</span><span class="hljs-string">"mode 1: {}"</span><span>, $e));<br/>    (2 $e:expr) =&gt; (</span><span class="hljs-built_in">println!</span><span>(</span><span class="hljs-string">"mode 2: {}"</span><span>, $e));<br/>}<br/><br/></span><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span><span>()<br/>{<br/>    my_macro_branch!(1 "abc"</span><span>);<br/>    my_macro_branch!(2 "def");<br/>}<br/></span></pre>
<p>The name recursive macros comes from recursion in the macros, so of course we can call into the macro that we are defining. Recursive macros could be a quick way to define a domain-specific language. Consider the following code snippet, in <kbd>intro_metaprogramming.rs</kbd>:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">enum DSLTerm {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>TVar { symbol: String },<br/></span><span class="s1"><span class="Apple-converted-space">    </span>TAbs { param: String, body: Box&lt;DSLTerm&gt; },<br/></span><span class="s1"><span class="Apple-converted-space">    </span>TApp { f: Box&lt;DSLTerm&gt;, x: Box&lt;DSLTerm&gt; }<br/></span><span class="s1">}<br/><br/></span><span class="s1">macro_rules! dsl<br/></span><span class="s1">{<br/></span><span class="s1">    ( ( $($e:tt)* ) ) =&gt; (dsl!( $($e)* ));</span><span class="s1"><br/></span><span class="s1">    ( $e:ident ) =&gt; (DSLTerm::TVar {<br/>        symbol: stringify!($e).to_string()<br/>    });<br/></span><span class="s1">    ( fn $p:ident . $b:tt ) =&gt; (DSLTerm::TAbs {<br/>        param: stringify!($p).to_string(),<br/>        body: Box::new(dsl!($b))<br/>    });<br/></span><span class="s1">    ( $f:tt $x:tt ) =&gt; (DSLTerm::TApp {<br/>        f: Box::new(dsl!($f)),<br/>        x: Box::new(dsl!($x))<br/>    });<br/></span>} </pre>
<p>The second form of macro definitions is procedural macros. Recursive macros can be thought of as a nice syntax to help define procedural macros. Procedural macros, on the other hand, are the most general form. There are many things you can do with procedural macros that are simply impossible with the recursive form.</p>
<p>Here, we can grab the <kbd>TypeName</kbd> of a <kbd>struct</kbd> and use that to automatically generate a trait implementation. Here is the macro definition, <span>in </span><kbd>intro_metaprogramming.rs</kbd>:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#![crate_type = "proc-macro"]<br/></span><span class="s1">extern crate proc_macro;<br/></span><span class="s1">extern crate syn;<br/></span><span class="s1">#[macro_use]<br/>extern crate quote;<br/></span><span class="s1">use proc_macro::TokenStream;<br/></span><span class="s1">#[proc_macro_derive(TypeName)]<br/><br/></span><span class="s1">pub fn type_name(input: TokenStream) -&gt; TokenStream<br/>{<br/></span><span class="s1">    // Parse token stream into input AST<br/></span><span class="s1">    let ast = syn::parse(input).unwrap();<br/></span><span class="s1">    // Generate output AST<br/></span><span class="s1">    impl_typename(&amp;ast).into()<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn impl_typename(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens<br/>{<br/></span><span class="s1">    let name = &amp;ast.ident;<br/></span><span class="s1">    quote!<br/>    {<br/></span><span class="s1">        impl TypeName for #name<br/>        {<br/></span><span class="s1">            fn typename() -&gt; String<br/>            {<br/></span><span class="s1">                stringify!(#name).to_string()<br/></span><span class="s1">            }<br/>        }<br/>    }<br/>}</span></pre>
<p class="p1">The corresponding macro invocation looks like the following, in <kbd>intro_metaprogramming.rs</kbd>:</p>
<pre style="padding-left: 30px">#[macro_use]<br/>extern crate metaderive;<br/><br/>pub trait TypeName<br/>{<br/>    fn typename() -&gt; String;<br/>}<br/><br/>#[derive(TypeName)]<br/>struct MyStructA<br/>{<br/>    a: u32,<br/>    b: f32<br/>}</pre>
<p>As you can see, procedural macros are a bit more complicated to set up. However, the benefit is then that all processing is done directly with normal Rust code. These macros permit use of any syntactic information in unstructured format to <span>generate more code structures before compilation.</span></p>
<p>Procedural macros are handled as separate modules to be precompiled and executed during normal compiler execution. The information provided to each macro is localized, so<br/>
whole program consideration is not possible. However, the available local information is sufficient to achieve some fairly complicated effects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we briefly outlined the major concepts that will appear throughout this book. From the code examples, you should now be able to visually identify functional style. We also mentioned some of the reasons why these concepts are useful. In the remaining chapters, we will provide full context to when and why each technique would be appropriate. In that context, we will also provide the knowledge required to master the techniques and start using functional practices.</p>
<p>From this chapter, we learned to parameterize as much as possible, and that functions can be used as parameters, to define complex behavior by combining simple behaviors, and that it is safe to use threads however you want in Rust as long as it compiles.</p>
<p>This book is structured to introduce simpler concepts first, then, as the book continues, some concepts may become more abstract or technical. Also, all techniques will be introduced in the context of an ongoing project. The project will control an elevator system, and the requirements will gradually become more demanding as the book progresses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is a function?</li>
<li>What is a functor?</li>
<li>What is a tuple?</li>
<li>What control flow expression was designed for use with tagged unions?</li>
<li>What is the name for a function with a function as a parameter?</li>
<li>How many times will <kbd>fib</kbd> be called in memoized <kbd>fib(20)</kbd>?</li>
<li>What datatypes can be sent over a channel?</li>
<li>Why do functions need to be boxed when returned from a function?</li>
<li>What does the <kbd>move</kbd> keyword do?</li>
<li>How could two variables share ownership of a single variable?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Packt has many other great resources for learning Rust:</p>
<ul>
<li><a href="https://www.packtpub.com/application-development/rust-programming-example">https://www.packtpub.com/application-development/rust-programming-example</a></li>
<li><a href="https://www.packtpub.com/application-development/learning-rust">https://www.packtpub.com/application-development/learning-rust</a></li>
</ul>
<p>For basic documentation and a tutorial, please refer here:</p>
<ul>
<li>Tutorial: <a href="https://doc.rust-lang.org/book/first-edition/">https://doc.rust-lang.org/book/first-edition/</a></li>
<li>Documentation: <a href="https://doc.rust-lang.org/stable/reference/">https://doc.rust-lang.org/stable/reference/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>