<html><head></head><body>
        

                            
                    <h1 class="header-title">Error Handling</h1>
                
            
            
                
<p>In this chapter, we'll take a look at how fallible and unexpected situations are handled in Rust, gain an understanding of the error handling with errors as types, and look at how to design interfaces that compose well with error types. We aim to cover the first two error scenarios as they are under our control and languages generally provide mechanisms for handling these errors. If fatal errors occur, our program gets aborted by the operating system kernel and so we don't have much control over them.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Error handling prelude</li>
<li>Recovering from errors using the <kbd>Option</kbd> and <kbd>Result</kbd> types</li>
<li>Combinator methods for <kbd>Option</kbd> and <kbd>Result</kbd></li>
<li>Propagating errors</li>
<li>Non-recoverable errors</li>
<li>Custom errors and the <kbd>Error</kbd> trait</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Error handling prelude</h1>
                
            
            
                
<p>"From then on, when anything went wrong with a computer, we said it had bugs in it."</p>
<p class="CDPAlignRight CDPAlign">- <em>Grace Hopper</em></p>
<p>Writing programs that behave well under expected conditions is a good start. It's when a program encounters unexpected situations where it gets really challenging. Proper error handling is an important but often overlooked practice in software development. Most error handling, in general, falls into three categories:</p>
<ul>
<li>Recoverable errors that are expected to happen due to the user and the environment interacting with the program, for example, a file not found error or a number parse error.</li>
<li>Non-recoverable errors that violate the contracts or invariants of the program, for example, index out of bounds or divide by zero.</li>
<li>Fatal errors that abort the program immediately. Such situations include running out of memory, and stack overflow.</li>
</ul>
<p>Programming in the real world often entails dealing with errors. Examples include malicious input to a web application, connection failures in network clients, filesystem corruption, and integer overflow errors in numerical applications. In the event of there being no error handling, the program just crashes or is aborted by the OS when it hits an unexpected situation. Most of the time, this is not the behavior we want our programs to exhibit in unexpected situation. Consider, for example, a real-time stream processing service that fails to receive messages from clients at some point in time due to a failure in parsing messages from a client who is sending malformed messages. If we have no way to handle this, our service will abort every time we have parsing errors. This is not good from a usability perspective and is definitely not a characteristic of network applications. The ideal way for the service to handle this situation is to catch the error, act upon it, pass the error log to a log-aggregation service for later analysis and continue receiving messages from other clients. That's when a recoverable way of handling errors comes into the picture, and is often the practical way to model error handling. In this case, the language's error handling constructs enable programmers to intercept errors and take action against them, which saves the program from being aborted.</p>
<p>Two paradigms that are quite popular when approaching error handling are return codes and exceptions. The C language embraces the return code model. This is a very trivial form of error handling, where functions use integers as return values to signify whether an operation succeeded or failed. A lot of C functions return a <kbd>-1</kbd> or <kbd>NULL</kbd> in the event of an error. For errors when invoking system calls, C sets the global <kbd>errno</kbd> variable upon failure. But, being a global variable, nothing stops you from modifying the <kbd>errno</kbd> variable from anywhere in the program. It's then for the programmer to check for this error value and handle it. Often, this gets really cryptic, error-prone, and is not a very flexible solution. The compiler does not warn us if we forget to check the return value either, unless you use a static analysis tool.</p>
<p>Another approach to handling errors is via exceptions. Higher-level programming languages such as Java and C# use this form of error handling. In this paradigm, code that might fail should be wrapped in a <kbd>try {}</kbd> block and any failure within the <kbd>try{}</kbd> block must be caught in a <kbd>catch {}</kbd> block (ideally, with the <kbd>catch</kbd> block immediately after the <kbd>try</kbd> block). But, exceptions also have their downsides. Throwing an exception is expensive, as the program has to unwind the stack, find the appropriate exception handler, and run the associated code. To avoid this overhead, programmers often adopt the defensive code style of checking for exception-throwing code and then proceeding forward. Also, the implementation of exceptions is flawed in many languages, because it allows ignorant programmers to swallow exceptions with a catch all block with a base exception class such as a throwable in Java, thereby resulting in a possibly inconsistent state in the program if they just log and ignore the exception. Also, in these languages, there is no way for a programmer to know by looking at the code whether a method could throw an exception, unless they are using methods with checked exceptions. This makes it hard for programmers to write safe code. Due to this, programmers often need to rely on the documentation (if it exists at all) of methods to figure out whether they could throw an exception.</p>
<p>Rust, on the other hand, embraces type-based error handling, which is seen in functional languages such as OCaml and Haskell, and at the same time also appears similar to C's returning error code model. But in RUST, the return values are proper error types and can be user-defined, The language's type system mandates handling error states at compile time. If you know Haskell, it is quite similar to its <kbd>Maybe</kbd> and <kbd>Either</kbd> types; Rust just has different names for them, that is, <kbd>Option</kbd> and <kbd>Result</kbd> for recoverable errors. For non-recoverable errors, there's a mechanism called <strong>panic</strong>, which is a fail-hard error handling strategy and it is advisable to use it as a last resort when there is a bug or violation of an invariant in the program.</p>
<p>Why did Rust choose this form of error handling? Well, as we have already said, exceptions and their associated stack unwinding have an overhead. This goes against Rust's central philosophy of zero runtime costs. Secondly, exception-style error handling, as it is typically implemented, allows ignoring these errors via catch-all exception handlers. This creates the potential for program state inconsistency, which goes against Rust's safety tenet.</p>
<p>With the prelude aside, let's dig into some recoverable error handling strategies!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Recoverable errors</h1>
                
            
            
                
<p>As we have already said, the majority of error handling in Rust is done via two generic types, <kbd>Option</kbd> and <kbd>Result</kbd>. They act as wrapper types in the sense that it is recommended that APIs that can fail return the actual values by putting them inside these types. These types are built with a combination of enums and generics. As an enum, they get the ability to store a success state and an error state, while generics allow them to specialize at compile time so that they store any value in either state. These types also come with a lot of convenient methods (commonly known as <strong>combinators</strong><em>)</em> implemented on them, allowing you to consume, compose, or transform the inner values easily. One thing to note about the <kbd>Option</kbd> and <kbd>Result</kbd> types is that they are ordinary types from the standard library in the sense that they aren't compiler built-ins that are treated differently by the compiler. Anyone can create a similar error abstraction using the power of enums and generics. Let's start exploring them by first looking at the simplest one, that is, <kbd>Option</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Option</h1>
                
            
            
                
<p>In languages that have the notion of nullable values, there is a defensive code style that programmers adopt to perform operations on any value that can possibly be null. Taking an example from Kotlin/Java, it appears something like this:</p>
<pre>// kotlin pseudocode<br/><br/>val container = collection.get("some_id")<br/><br/>if (container != null) {<br/>    container.process_item();<br/>} else {<br/>    // no luck<br/>}</pre>
<p>First, we check that <kbd>container</kbd> is not <kbd>null</kbd> and then call <kbd>process_item</kbd> on it. If we forget the null safety check, we'll get the infamous <kbd>NullPointerException</kbd> when we try to invoke <kbd>container.process_item()</kbd> – you only get to know this at runtime when it throws the exception. Another downside is the fact that we can't deduce right away whether <kbd>container</kbd> is <kbd>null</kbd> just by looking at the code. To save against that, the code base needs to be sprinkled with these null checks, which hinder its readability to a great extent.</p>
<p>Rust does not have the notion of null values, which is infamously quoted as being the billion-dollar mistake by <em>Tony Hoare</em>, who introduced <kbd>null</kbd> references in the ALGOL W language back in 1965. In Rust, APIs that might fail and want to indicate a missing value are meant to return <kbd>Option</kbd>. This error type is suitable when any of our APIs, along with a succeeding value, want to signify the absence of a value. To put it simply, it's quite analogous to nullable values, but here, the <kbd>null</kbd> check is explicit and is enforced by the type system at compile time.</p>
<p><kbd>Option</kbd> has the following type signature:</p>
<pre class="rust">pub enum Option&lt;T&gt; {
    /// No value
    None,
    /// Some value `T`
    Some(T),
}</pre>
<p>It's an enum with two variants and is generic over <kbd>T</kbd>. We create an <kbd>Option</kbd> value by using either <kbd>let wrapped_i32 = Some(2);</kbd> or <kbd>let empty: Option&lt;i32&gt; = None;</kbd>.</p>
<p>Operations that succeed can use the <kbd>Some(T)</kbd> variable to store any value, <kbd>T</kbd>, or use the <kbd>None</kbd> variable to signify that the value is <kbd>null</kbd> in the case of a failed state. Though we are less likely to create <kbd>None</kbd> values explicitly, when we need to create a <kbd>None</kbd> value, we need to specify the type on the left, as Rust is unable to infer the type from the right-hand side. We could have also initialized it on the right, as <kbd>None::&lt;i32&gt;;</kbd> using the <kbd>turbofish</kbd> operator, but specifying the type on the left is identified as idiomatic Rust code.</p>
<p>As you may have noticed, we didn't create the <kbd>Option</kbd> values through the full syntax, that is, <kbd>Option::Some(2)</kbd>, but directly as <kbd>Some(2)</kbd>. This is because both of its variants are automatically re-exported from the <kbd>std</kbd> crate (Rust's standard library crate) as part of the prelude module (<a href="https://doc.rust-lang.org/std/prelude/">https://doc.rust-lang.org/std/prelude/</a>). The prelude module contains re-exports of most commonly used types, functions, and any modules from the standard library. These re-exports are just a convenience that's provided by the <kbd>std</kbd> crate. Without them, we would have to write the full syntax every time we needed to use these frequently used types. As a result, this allows us to instantiate <kbd>Option</kbd> values directly through the variants. This is also the case with the <kbd>Result</kbd> type.</p>
<p>So, creating them is easy, but what does it look like when you are interacting with an <kbd>Option</kbd> value? From the standard library, we have the <kbd>get</kbd> method on the <kbd>HashMap</kbd> type, which returns an <kbd>Option</kbd>:</p>
<pre class="rust rust-example-rendered">// using_options.rs<br/><br/>use std::collections::HashMap;<br/><br/>fn main() {<br/>    let mut map = HashMap::new();<br/>    map.insert("one", 1);<br/>    map.insert("two", 2);<br/><br/>    let value = map.get("one");<br/>    let incremented_value = value + 1;<br/>}</pre>
<p>Here, we create a new <kbd>HashMap</kbd> <kbd>map</kbd> of <kbd>&amp;str</kbd> as the key and <kbd>i32</kbd> as the value, and later, we retrieve the value for the <kbd>"one"</kbd> key and assign it to the <kbd>value</kbd> . After compiling, we get the following error message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c2e0f097-9a67-4fa3-8ce1-b971da33f80c.png"/></p>
<p>Why can't we add <kbd>1</kbd> to our <kbd>value</kbd>? As someone familiar with imperative languages, we expect <kbd>map.get()</kbd> to return an <kbd>i32</kbd> value if the key exists or a null otherwise. But here, <kbd>value</kbd> is an <kbd>Option&lt;&amp;i32&gt;</kbd>. The <kbd>get()</kbd> method returns an <kbd>Option&lt;&amp;T&gt;</kbd>, and not the inner value (a <kbd>&amp;i32</kbd>) because there is also the possibility that we might not have the key we are looking for and so <kbd>get</kbd> can return <kbd>None</kbd> in that case. It gives a misleading error message, though, because Rust doesn't know how to add an <kbd>i32</kbd> to a <kbd>Option&lt;&amp;i32&gt;</kbd>, as no such implementation of the <kbd>Add</kbd> trait exists for these two types. However, it indeed exists for two i32's or two &amp;i32's.</p>
<p>So, to add <kbd>1</kbd> to our <kbd>value</kbd>, we need to extract <kbd>i32</kbd> from <kbd>Option</kbd>. Here, we can see Rust's explicit error handling behavior spring into action. We can only interact with the inner <kbd>i32</kbd> value after we check whether <kbd>map.get()</kbd> is a <kbd>Some</kbd> variant or a <kbd>None</kbd> variant.</p>
<p>To check for the variants, we have two approaches; one of which is pattern matching or <kbd>if let</kbd>:</p>
<pre>// using_options_match.rs<br/><br/>use std::collections::HashMap;<br/><br/>fn main() {<br/>    let mut map = HashMap::new();<br/>    map.insert("one", 1);<br/>    map.insert("two", 2);<br/><br/>    let incremented_value = match map.get("one") {<br/>        Some(val) =&gt; val + 1,<br/>        None =&gt; 0<br/>    };<br/>    <br/>    println!("{}", incremented_value);<br/>}</pre>
<p>With this approach, we match against the return value of <kbd>map.get()</kbd> and take actions based on the variant. In the case of <kbd>None</kbd>, we simply assign <kbd>0</kbd> to <kbd>incremented_value</kbd>. Another way we could have done this is by using <kbd>if let</kbd>:</p>
<pre>let incremented_value = if let Some(v) = map.get("one") {<br/>    v + 1<br/>} else {<br/>    0<br/>};</pre>
<p>This is recommended for cases where we are only interested in one variant of our value and want to do a common operation for other variants. In those cases, <kbd>if let</kbd> is much cleaner.</p>
<p><strong>Unwrapping:</strong> The other, less safe, approach is to use unwrapping methods on <kbd>Option</kbd>, that is, the <kbd>unwrap()</kbd> and the <kbd>expect()</kbd> methods. Calling these methods will extract the inner value if it's a <kbd>Some</kbd>, but will panic if it's a <kbd>None</kbd>. These methods are recommended only when we are really sure that the <kbd>Option</kbd> value is indeed a <kbd>Some</kbd> value:</p>
<pre>// using_options_unwrap.rs<br/><br/>use std::collections::HashMap;<br/><br/>fn main() {<br/>    let mut map = HashMap::new();<br/>    map.insert("one", 1);<br/>    map.insert("two", 2);<br/>    let incremented_value = map.get("three").unwrap() + 1;<br/>    println!("{}", incremented_value);<br/>}</pre>
<p>Running the preceding code panics, showing the following message because we unwrapped a <kbd>None</kbd> value as we don't have any value for the <kbd>three</kbd> key:</p>
<pre>thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', libcore/option.rs:345:21<br/>note: Run with `RUST_BACKTRACE=1` for a backtrace.</pre>
<p>Between the two, <kbd>expect()</kbd> is preferred because it allows you to pass a string as a message to be printed upon panic, and shows the exact line number in your source file where the panic happened, whereas <kbd>unwrap()</kbd> does not allow you to pass debug messages as arguments and shows a line number in the standard library source file where the <kbd>unwrap()</kbd> method of <kbd>Option</kbd> is defined, which is not very helpful. These methods are also present on the <kbd>Result</kbd> type.</p>
<p>Next, let's look at the <kbd>Result</kbd> type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Result</h1>
                
            
            
                
<p><kbd>Result</kbd> is similar to <kbd>Option</kbd>, but with the added advantage of storing arbitrary error values with more context on the error, instead of just <kbd>None</kbd>. This type is suitable when we want the user to know why an operation failed. Here's the type signature of <kbd>Result</kbd>:</p>
<pre>enum Result&lt;T, E&gt; {<br/>   Ok(T), <br/>   Err(E), <br/>} </pre>
<p>It has two variants, both of which are generic. <kbd>Ok(T)</kbd> is the variant we use for the success state putting in any value, <kbd>T</kbd>, while <kbd>Err(E)</kbd> is what we use in the error state putting in any error value, <kbd>E</kbd>. We can create them like so:</p>
<pre>// create_result.rs<br/><br/>fn main() {<br/>    let my_result = Ok(64);<br/>    let my_err = Err("oh no!");<br/>}</pre>
<p>However, this does not compile, and we receive the following error message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/09947ae7-e662-4651-9d33-96684ecc8016.png" style="width:25.50em;height:10.00em;"/></p>
<p>As <kbd>Result</kbd> has two generic variants and we gave the concrete type for only the <kbd>Ok</kbd> variant for <kbd>my_result</kbd>; it doesn't know the concrete type of <kbd>E</kbd>. This is similar for the <kbd>my_err</kbd> value. We need to specify concrete types for both, like so:</p>
<pre>// create_result_fixed.rs<br/><br/>fn main() {<br/>    let _my_result: Result&lt;_, ()&gt; = Ok(64);<br/>    // or<br/>    let _my_result = Ok::&lt;_, ()&gt;(64);<br/><br/>    // similarly we create Err variants<br/><br/>    let _my_err = Err::&lt;(), f32&gt;(345.3);<br/>    let _other_err: Result&lt;bool, String&gt; = Err("Wait, what ?".to_string());<br/>}</pre>
<p>In the first case of creating values of the rgw <kbd>Ok</kbd> variant, we used <kbd>()</kbd> to specify the type, <kbd>E</kbd>, of the <kbd>Err</kbd> variant. In the second part of the snippet, we created values of the <kbd>Err</kbd> variant in a similar way, this time specifying a concrete type for the <kbd>Ok</kbd> variant. We can use underscores to ask Rust to infer types for us in obvious cases.</p>
<p>Next, we'll see how we can interact with <kbd>Result</kbd> values. Many file manipulation APIs in the standard library return a <kbd>Result</kbd> type, because there can be different reasons for failure such as file not found, directory does not exists, and permission errors. These can be put into the <kbd>Err</kbd> variant to let the user know of the exact cause. For the demo, we'll try to open a file, read its contents into a <kbd>String</kbd>, and print the contents, as shown in the following snippet:</p>
<pre>// result_basics.rs<br/><br/>use std::fs::File;<br/>use std::io::Read;<br/>use std::path::Path;<br/><br/>fn main() {<br/>    let path = Path::new("data.txt");<br/>    let file = File::open(&amp;path);<br/>    let mut s = String::new();<br/>    file.read_to_string(&amp;mut s);<br/>    println!("Message: {}", s);<br/>}</pre>
<p>This is how the compiler responds:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cd85fcd2-2e08-4cb5-a062-cb40bb2c7943.png"/></p>
<p>We created a new file by calling <kbd>open</kbd> from <kbd>File</kbd>, providing our path to <kbd>data.txt</kbd>, which doesn't exist. When we call <kbd>read_to_string</kbd> on <kbd>file</kbd>, and try to read it into <kbd>s</kbd>, we get the preceding error. Examining the error message, it appears that <kbd>file</kbd> has a type of <kbd>Result&lt;File, Error&gt;</kbd>. From its documentation, the <kbd>open</kbd> method is defined like so:</p>
<pre>fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;File&gt; </pre>
<p>To astute observers, there may be a source of confusion, as it looks like <kbd>Result</kbd> is missing the generic <kbd>E</kbd> type for the error variant, but it's simply hidden away by a type alias. If we look at the <kbd>type</kbd> alias definition in the <kbd>std::io</kbd> module, it is defined as follows:</p>
<pre>type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;; </pre>
<p>So, it is type aliased with a common error type of <kbd>std::io::Error.</kbd> This is because a lot of APIs in the standard library use this as an error type. This is another benefit of type aliases, where we can extract common parts from our type signature. Putting that tip aside, to be able to call the <kbd>read_to_string</kbd> method on our <kbd>file</kbd>, we need to extract the inner <kbd>File</kbd> instance, that is, perform pattern matching on variants. By doing this, the preceding code changes, as follows:</p>
<pre>// result_basics_fixed.rs<br/><br/>use std::fs::File;<br/>use std::io::Read;<br/>use std::path::Path;<br/><br/>fn main() {<br/>    let path = Path::new("data.txt");<br/>    let mut file = match File::open(&amp;path) {<br/>        Ok(file) =&gt; file,<br/>        Err(err) =&gt; panic!("Error while opening file: {}", err),<br/>    };<br/><br/>    let mut s = String::new();<br/>    file.read_to_string(&amp;mut s);<br/>    println!("Message: {}", s);<br/>}</pre>
<p>Here, we made two changes. First, we made the <kbd>file</kbd> variable mutable. Why? Because the function signature of <kbd>read_to_string</kbd> is as follows:</p>
<pre>fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;</pre>
<p>The first parameter being <kbd>&amp;mut self</kbd> means that the instance we are calling this method on needs to be mutable because reading the file changes, internal pointers of the file handle. Secondly, we handled both the variants, where, in the <kbd>Ok</kbd> case, we return the actual <kbd>File</kbd> object if everything was good, but crash when we get an <kbd>Err</kbd> value and display an error message.</p>
<p>With this change, let's compile and run this program:</p>
<div><img src="img/862acb83-a83c-4579-929a-5e0a3d752c2e.png"/></div>
<p>This panics because we don't have a file named <kbd>data.txt</kbd> in our directory. Try creating a file with the same name with any arbitrary text in it and run this program again to see it succeed. First, though, let's do something about that warning. Warnings are always a sign of poor code quality, and we ideally want to have none of them. The warning is there because <kbd>File::read_to_string</kbd> (a method from the <kbd>Read</kbd> trait) returns a value of type <kbd>Result&lt;usize&gt;</kbd>. Rust warns you whenever a return value from a function call is ignored. Here, the <kbd>usize</kbd> value in <kbd>Result&lt;usize&gt;</kbd> tells us how many bytes were read into the string.</p>
<p>We have two ways of handling this warning:</p>
<ul>
<li>Handle both the <kbd>Ok</kbd> and <kbd>Err</kbd> cases as before for the <kbd>Result</kbd> value returned by the <kbd>read_to_string</kbd> method</li>
<li>Assign the return value to a special variable <kbd>_</kbd> (<strong>underscore</strong>), which lets the compiler know that we want to ignore the value</li>
</ul>
<p>For cases where we don't care about the value, we can use the second approach and so the <kbd>read_to_string</kbd> line changes as follows:</p>
<pre>let _ = file.read_to_string(&amp;mut s);</pre>
<p>With that change, the code compiles without warnings. However, you should handle the return value and try not to use the catch all underscore variable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Combinators on Option/Result</h1>
                
            
            
                
<p>As <kbd>Option</kbd> and <kbd>Result</kbd> are wrapper types, the only way to safely interact with their inner values is either through pattern matching or <kbd>if let</kbd>. This paradigm of using matching and then acting on the inner values is a very common operation and, as such, it becomes very tedious having to write them every time. Fortunately, these wrapper types come with lots of helper methods, also known as combinators, implemented on them that allow you to manipulate the inner values easily.</p>
<p>These are generic methods and there are many kinds depending on the use case. Some methods act on success values, such as <kbd>Ok(T)</kbd>/<kbd>Some(T)</kbd>, while some of them act on failed values, such as <kbd>Err(E)</kbd>/<kbd>None</kbd>. Some methods unwrap and extract the inner value, while some preserve the structure of the wrapper type modifying just the inner values.</p>
<div><strong>Note</strong>: In this section, when we talk about success values, we are commonly referring to <kbd>Ok(T)</kbd>/<kbd>Some(T)</kbd> variants and when we talk about failed values, we are referring to <kbd>Err(T)</kbd>/<kbd>None</kbd> variants.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Common combinators</h1>
                
            
            
                
<p>Let's look at some of the useful combinators that are available for both the <kbd>Option</kbd> and <kbd>Result</kbd> types:</p>
<p style="padding-left: 30px"><kbd>map</kbd>: This method allows you to transform the success value, <kbd>T</kbd>, to another value, <kbd>U</kbd>. The following is the type signature of <kbd>map</kbd> for the <kbd>Option</kbd> type:</p>
<pre>pub fn map&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt;<br/>where F: FnOnce(T) -&gt; U {<br/>    match self {<br/>        Some(x) =&gt; Some(f(x)),<br/>        None =&gt; None,<br/>    }<br/>}</pre>
<p>The following is the signature for the <kbd>Result</kbd> type:</p>
<pre>pub fn map&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt;<br/>where F: FnOnce(T) -&gt; U {<br/>    match self {<br/>        Ok(t) =&gt; Ok(f(t)),<br/>        Err(e) =&gt; Err(e)<br/>    }<br/>}</pre>
<p>This method's type signature can be read as follows: <kbd>map</kbd> is a generic method over <kbd>U</kbd> and <kbd>F</kbd>, and takes <kbd>self</kbd> by value. It then takes a parameter, <kbd>f</kbd>, of type <kbd>F</kbd> and returns an <kbd>Option&lt;U&gt;</kbd>, where <kbd>F</kbd> is constrained by the <kbd>FnOnce</kbd> trait, which has an input parameter, <kbd>T</kbd>, and a return type of <kbd>U</kbd>. Phew! That was quite a mouthful.</p>
<p>Let's make this simpler to understand. There are two parts to understand about the <kbd>map</kbd> method. First, it takes a parameter as <kbd>self</kbd>, which means the value on which this method is called is consumed after the call. Second, it takes in a parameter, <kbd>f</kbd>, of type <kbd>F</kbd>. This is a closure that's provided to <kbd>map</kbd>, which tells it how to do the conversion from <kbd>T</kbd> to <kbd>U</kbd>. The closure is generically represented as <kbd>F</kbd> and the <kbd>where</kbd> clause says that <kbd>F</kbd> is <kbd>FnOnce(T) -&gt; U</kbd>. This is a special type of trait that is only applicable to closures and hence has a function like the signature of <kbd>(T) -&gt; U</kbd> . The <kbd>FnOnce</kbd> prefix just means that this closure takes ownership of the input parameter, <kbd>T</kbd>, signifying that we can only call this closure once with <kbd>T</kbd> as <kbd>T</kbd> will be consumed upon invocation. We'll look into closures in more depth in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts.</em> The <kbd>map</kbd> method does nothing if the value is a failed value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using combinators</h1>
                
            
            
                
<p>Using the <kbd>map</kbd> method is simple:</p>
<pre>// using_map.rs<br/><br/>fn get_nth(items: &amp;Vec&lt;usize&gt;, nth: usize) -&gt; Option&lt;usize&gt; {<br/>    if nth &lt; items.len() {<br/>        Some(items[nth])<br/>    } else {<br/>        None<br/>    }<br/>}<br/><br/>fn double(val: usize) -&gt; usize {<br/>    val * val<br/>}<br/><br/>fn main() {<br/>    let items = vec![7, 6, 4, 3, 5, 3, 10, 3, 2, 4];<br/>    println!("{}", items.len());<br/>    let doubled = get_nth(&amp;items, 4).map(double);<br/>    println!("{:?}", doubled);<br/>}</pre>
<p>In the preceding code, we have a method called <kbd>get_nth</kbd> that gives us the <kbd>nth</kbd> element from <kbd>Vec&lt;usize&gt;</kbd> and returns <kbd>None</kbd> if it couldn't find one. We then have a use case where we want to double the value. We can use the <kbd>map</kbd> method on the return value of <kbd>get_nth</kbd>, passing in the <kbd>double</kbd> function we defined previously. Alternatively, we could have provided a closure written inline, like the following:</p>
<pre>let doubled = get_nth(&amp;items, 10).map(|v| v * v);</pre>
<p>This is quite a concise way to chain operations! This is less verbose than using <kbd>match</kbd> or <kbd>if let</kbd>.</p>
<p>The preceding explanation of the <kbd>map</kbd> method is very much applicable to the next set of methods that we'll look at, so we'll skip explaining their type signature as it would be too noisy for us to go through every one of them. Instead, we'll just explain briefly the functionality that's provided by these methods. You are encouraged to read and become familiar with their type signature by referring to their documentation:</p>
<ul>
<li><kbd>map_err</kbd>: This method acts only on <kbd>Result</kbd> types and allows transforming the failed value from <kbd>E</kbd> to some other type, <kbd>H</kbd>, but only if the value is an <kbd>Err</kbd> value. <kbd>map_err</kbd> is not defined for <kbd>Option</kbd> types, as doing anything with <kbd>None</kbd> would be pointless.</li>
<li><kbd>and_then</kbd>: In the case of a failed value, this returns the value as is, but in the case of a successful value, this takes in a closure as the second argument, which acts on the wrapped value and returns the wrapped type. This is useful when you need to perform transformations on the inner values, one after another.</li>
<li><kbd>unwrap_or</kbd>: This method extracts the inner success value, or returns a default one if it's a failed value. You provide the default value to it as a second argument.</li>
<li><kbd>unwrap_or_else</kbd>: This method acts the same as the preceding method but computes a different value when it is a failed value by taking a closure as the second argument.</li>
<li><kbd>as_ref</kbd>: This method converts the inner value to a reference and returns the wrapped value, that is, an <kbd>Option&lt;&amp;T&gt;</kbd> or a <kbd>Result&lt;&amp;T, &amp;E&gt;</kbd>.</li>
<li><kbd>or/ or_else</kbd>: These methods return the value as is if it's a success value, or returns an alternative <kbd>Ok</kbd>/<kbd>Some</kbd> value, which is provided as the second argument. <kbd>or_else</kbd> accepts a closure within which you need to return a success value.</li>
<li><kbd>as_mut</kbd>: This method converts the inner value into a mutable reference and returns the wrapped value, that is, an <kbd>Option&lt;&amp;mut T&gt;</kbd> or a <kbd>Result&lt;&amp;mut T, &amp;mut E&gt;</kbd>.</li>
</ul>
<p>There are many more that are unique to the <kbd>Option</kbd> and <kbd>Result</kbd> types. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting between Option and Result</h1>
                
            
            
                
<p>We also have methods where one wrapper type can be converted into another, depending on how you want to compose those values with your APIs. They become really handy in situations where we are interacting with third-party crates, where we have a value as an <kbd>Option</kbd>, but the crate's method we are using accepts a <kbd>Result</kbd> as a type, as follows:</p>
<ul>
<li><kbd>ok_or</kbd>: This method converts an <kbd>Option</kbd> value to a <kbd>Result</kbd> value, by taking in an error value as a second parameter. A similar variant to this is the <kbd>ok_or_else</kbd> method, which should be preferred over this, as it computes the value lazily by taking in a closure.</li>
<li><kbd>ok</kbd>: This method converts a <kbd>Result</kbd> into an <kbd>Option</kbd> consuming <kbd>self</kbd>, and discards the <kbd>Err</kbd> value.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Early returns and the ? operator</h1>
                
            
            
                
<p>This is another pattern that is quite common when we interact with <kbd>Result</kbd> types. The pattern goes as follows: when we have a success value, we immediately want to extract it, but when we have an error value, we want to make an early return and propagate the error to the caller. To illustrate this pattern, we will use the following snippet, which uses the usual match expression to act on the <kbd>Result</kbd> type:</p>
<pre>// result_common_pattern.rs<br/><br/>use std::string::FromUtf8Error;<br/><br/>fn str_upper_match(str: Vec&lt;u8&gt;) -&gt; Result&lt;String, FromUtf8Error&gt; { <br/>    let ret = match String::from_utf8(str) { <br/>        Ok(str) =&gt; str.to_uppercase(), <br/>        Err(err) =&gt; return Err(err) <br/>    }; <br/><br/>    println!("Conversion succeeded: {}", ret); <br/>    Ok(ret) <br/>}<br/><br/>fn main() {<br/>    let invalid_str = str_upper_match(vec![197, 198]);<br/>    println!("{:?}", invalid_str);<br/>}</pre>
<p>The <kbd>?</kbd> operator abstracts this pattern, making it possible to write the <kbd>bytes_to_str</kbd> method in a more concise way:</p>
<pre>// using_question_operator.rs<br/><br/>use std::string::FromUtf8Error;<br/><br/>fn str_upper_concise(str: Vec&lt;u8&gt;) -&gt; Result&lt;String, FromUtf8Error&gt; { <br/>    let ret = String::from_utf8(str).map(|s| s.to_uppercase())?;<br/>    println!("Conversion succeeded: {}", ret);<br/>    Ok(ret) <br/>}<br/><br/>fn main() {<br/>    let valid_str = str_upper_concise(vec![121, 97, 89]);<br/>    println!("{:?}", valid_str);<br/>}</pre>
<p>This operator becomes even nicer if you have a sequence of <kbd>Result</kbd>/<kbd>Option</kbd> returning method calls, where a failure in each operator should mean a failure of the whole. For instance, we could write the whole operation of creating a file and writing to it as follows:</p>
<pre>let _ = File::create("foo.txt")?.write_all(b"Hello world!")?;</pre>
<p>It works pretty much as a replacement for the <kbd>try!</kbd> macro, which does the same thing as before <kbd>?</kbd> was implemented in the compiler. Now, <kbd>?</kbd> is a replacement for that, but there are some plans to make it more generic and usable for other cases, too.</p>
<p><strong>Bonus tip</strong>: The <kbd>main</kbd> function also allows you to return <kbd>Result</kbd> types. Specifically, it allows you to return types that implement the <kbd>Termination</kbd> trait. This means that we can also write <kbd>main</kbd> as follows:</p>
<pre>// main_result.rs<br/><br/>fn main() -&gt; Result&lt;(), &amp;'static str&gt; {<br/>    let s = vec!["apple", "mango", "banana"];<br/>    let fourth = s.get(4).ok_or("I got only 3 fruits")?;<br/>    Ok(())<br/>}</pre>
<p>Next, let's move on to dealing with non-recoverable errors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Non-recoverable errors</h1>
                
            
            
                
<p>When code that's in the execution phase encounters a bug, or one of its variants is violated, it has the potential to corrupt the program state in unexpected ways if it's ignored. These situations are deemed non-recoverable because of their inconsistent program state, which may lead to faulty outputs or unexpected behavior later. This means that a fail-stop approach is the best way to recover from them so as to not harm other parts or systems indirectly. For these kinds of cases, Rust provides us with a mechanism called <strong>panic</strong>, which aborts the thread on which it is invoked and does not affect any other threads. If the main thread is the one facing the panic, then the program aborts with a non-zero exit code of <kbd>101</kbd>. If it's a child thread, the panic does not propagate to the parent thread and halts at the thread boundary. A panic in one thread does not affect the other threads and is isolated, except in cases where they corrupt a mutex lock on some shared data; it is implemented as a macro by the same <kbd>panic!</kbd> mechanism.</p>
<p>When <kbd>panic!</kbd> is called, the panicking thread starts unwinding the function call stack, starting from the place at which it was invoked, all the way until the entry point in the thread. It also generates a stack trace or a backtrace for all functions that are invoked in this process, just like exceptions. But in this case, it does not have to look for any exception handlers, as they don't exist in Rust. Unwinding is the process of moving up the function call chain while cleaning up or freeing resource, from each function call stack. These resources can be stack allocated or heap allocated. Stack allocated resources automatically get released once the function ends. For variables pointing to heap allocated resources, Rust calls the <kbd>drop</kbd> method on them, which frees up the memory used by the resource. This cleanup is necessary to avoid memory leaks. Apart from code calling <kbd>panic</kbd> explicitly, <kbd>Result</kbd>/<kbd>Option</kbd> error types also call <kbd>panic</kbd> if any code does unwrap on failed values, that is, <kbd>Err</kbd>/<kbd>None</kbd>. <kbd>panic</kbd> is also the choice that's used for failing assertions in unit tests, and it's encouraged to fail tests with panics by using the <kbd>#[should_panic]</kbd> attribute.</p>
<p>In the case of single-threaded code having panics on the main thread, unwinding doesn't provide much of a benefit, as the operating system reclaims all the memory after the process aborts. Fortunately, there are options to turn off unwinding in <kbd>panic</kbd>, which may be required on platforms such as embedded systems, where we have a single main thread doing all the work and where unwinding is an expensive operation that isn't of much use.</p>
<p>To figure out the sequence of calls that led to the panic, we can view the backtrace from the thread by running any panicking program and setting the <kbd>RUST_BACKTRACE=1</kbd> environment variable from our command-line shell. Here's an example where we have two threads, where both of them panic:</p>
<pre>// panic_unwinding.rs<br/><br/>use std::thread;<br/><br/>fn alice() -&gt; thread::JoinHandle&lt;()&gt; {<br/>    thread::spawn(move || {<br/>        bob();<br/>    })<br/>}<br/><br/>fn bob() {<br/>    malice();<br/>}<br/><br/>fn malice() {<br/>    panic!("malice is panicking!");<br/>}<br/><br/>fn main() {<br/>    let child = alice();<br/>    let _ = child.join();<br/><br/>    bob();<br/>    println!("This is unreachable code");<br/>}</pre>
<p><kbd>alice</kbd> spawns a new thread using <kbd>thread::spawn</kbd> and calls <kbd>bob</kbd> within the closure. <kbd>bob</kbd> calls <kbd>malice</kbd>, which in turn panics. <kbd>main</kbd> also calls <kbd>bob</kbd>, which panics.</p>
<p class="CDPAlignLeft CDPAlign">Here's the output of running this program:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a5de47cc-5038-42f9-be7a-3893269e6dbb.png"/></p>
<p>We join the thread by calling <kbd>join()</kbd> and expect everything to go fine in our child thread, which is definitely not the case. We get two backtraces, one for the panic that happened in the child thread and the other from calling <kbd>bob</kbd> in the main thread.</p>
<p>If you need more control over how unwinding in panics is handled in a thread, you can use the <kbd>std::panic::catch_unwind</kbd> function. Even though it's recommended to handle errors via the <kbd>Option</kbd>/<kbd>Result</kbd> mechanism, you can use this method to handle fatal errors in worker threads; you can do this by restoring any violated invariants, letting the workers die, and restarting them. However, <kbd>catch_unwind</kbd> doesn't prevent the panic – it only allows you to customize the unwind behavior associated with panic. <kbd>panic</kbd> with <kbd>catch_unwind</kbd> is not recommended as a general error handling method for Rust programs.</p>
<p>The <kbd>catch_unwind</kbd> function takes a closure and handles any panics that happen inside it. Here's its type signature:</p>
<pre>fn catch_unwind&lt;F: FnOnce() -&gt; R + UnwindSafe, R&gt;(f: F) -&gt; Result&lt;R&gt; </pre>
<p>As you can see, the return value of <kbd>catch_unwind</kbd> has an additional constraint, <kbd>UnwindSafe</kbd>. This means that the variables in the closure must be exception-safe, which most types are, but notable exceptions are mutable references (<kbd>&amp;mut T</kbd>). A value is exception safe if exception-throwing code cannot lead to the value being left in an inconsistent state. This means that the code inside the closure must not <kbd>panic!()</kbd> itself.</p>
<p>Here's a simple example that uses <kbd>catch_unwind</kbd>:</p>
<pre>// catch_unwind.rs<br/><br/>use std::panic; <br/><br/>fn main() { <br/>    panic::catch_unwind(|| { <br/>        panic!("Panicking!"); <br/>    }).ok();<br/><br/>    println!("Survived that panic."); <br/>}</pre>
<p>Here's the output after running the preceding program:</p>
<div><img src="img/0479182e-a4a9-4297-b1d2-18df52426b4a.png" style="width:36.00em;height:6.33em;"/></div>
<p>As you can see, <kbd>catch_unwind</kbd> does not prevent the panic from happening; it just stops the unwinding associated with the panicking thread. Note again that <kbd>catch_unwind</kbd> is not the recommended method for error management in Rust. It is not guaranteed to catch all panics, such as panics that abort the program. Catching panic unwinding is necessary in situations where Rust code is communicating with other languages such as C, where unwinding to C code is an undefined behavior. In those cases, the programmer has to handle the unwind and do what C expects by returning an error code. The program can then resume the unwind by using the <kbd>resume_unwind</kbd> function from the same <kbd>panic</kbd> module.</p>
<p>For rare cases where the default unwinding behavior of panic can get too expensive, such as when writing programs for microcontrollers, there's a compiler flag that can be configured to turn all panics into aborts. To do that, your project's <kbd>Cargo.toml</kbd> needs to have the following attribute under the <kbd>profile.release</kbd> section:</p>
<pre>[profile.release]<br/>panic = "abort"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">User-friendly panics</h1>
                
            
            
                
<p>As we saw in the preceding code, panic messages and backtraces can be very cryptic, but it does not have to be like that. If you are an author of a command-line tool, <kbd>human_panic</kbd> is a crate from the community that replaces verbose, cryptic panic messages with human-readable messages. It also writes the backtrace to a file to allow it to be reported to the tool author by users. More information about <kbd>human_panic</kbd> can be found on the project repository page: <a href="https://github.com/rust-clique/human-panic">https://github.com/rust-clique/human-panic</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom errors and the Error trait</h1>
                
            
            
                
<p>A non-trivial project that has varied functionality is often spread across modules. With an organization, it's more informative to provide module-specific error messages and information for the user. Rust allows us to create custom error types that can help us achieve more granular error reports from our application. Without custom errors that are specific to our project, we might have to use existing error types in the standard library, which may not be relevant to our API's operations and will not give precise information to users if things go wrong with an operation in our module.</p>
<p>In languages that have exceptions, such as Java, the way you create custom exceptions is by inheriting from the base <kbd>Exception</kbd> class and overriding its methods and member variables. While Rust doesn't have type-level inheritance, it has trait inheritance and provides us with the <kbd>Error</kbd> trait that any type can implement, making the type a custom error type. This type can now be composed with existing standard library error types when using a trait object such as <kbd>Box&lt;dyn Error&gt;</kbd> as the return type of functions returning <kbd>Result</kbd> for the <kbd>Err</kbd> variant. Here's the type signature of the <kbd>Error</kbd> trait:</p>
<pre>pub trait Error: Debug + Display {<br/>    fn description(&amp;self) -&gt; &amp;str { ... }<br/>    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; { ... }<br/>}</pre>
<p>To create our own error type, the type must implement the <kbd>Error</kbd> trait. If we look at the trait's definition, it also requires that we implement the <kbd>Debug</kbd> and <kbd>Display</kbd> traits for our type. The <kbd>description</kbd> method returns a string slice reference, which is a human-readable form describing what the error is about. The <kbd>cause</kbd> method returns an optional reference to another <kbd>Error</kbd> trait object, representing a possible lower-level reason for the error. The cause method from custom error types allows you to get information on the chain of errors right from the source, making precise logging of the error possible. For instance, let's take an HTTP query as an example of a fallible operation. Our hypothetical library has a <kbd>get</kbd> method that can perform <kbd>GET</kbd> requests. The query might fail due to a lot of different reasons:</p>
<ul>
<li>The DNS query might fail because of networking failures or because of an incorrect address</li>
<li>The actual transfer of packets might fail</li>
<li>The data might be received correctly, but there could be something wrong with the received HTTP headers, and so on and so forth</li>
</ul>
<p>If it were the first case, we might imagine three levels of errors, chained together by the <kbd>cause</kbd> fields:</p>
<ul>
<li>The UDP connection failing due to the network being down (<kbd>cause = None</kbd>)</li>
<li>The DNS lookup failing due to a UDP connection failure (<kbd>cause = UDPError</kbd>)</li>
<li>The <kbd>GET</kbd> query failing due to a DNS lookup failure (<kbd>cause = DNSError</kbd>)</li>
</ul>
<p>The <kbd>cause</kbd> method comes in handy when the developer wants to know the root cause of a failure.</p>
<p>Now, to demonstrate integrating a custom error type in to a project, we have created a crate called <kbd>todolist_parser</kbd> using cargo, which exposes an API to parse a list of todos from a text file. The parsing of todos can fail in different ways, such as file not found, an empty todo, or because it contains non-text characters. We'll use a custom error type to model these situations. Under <kbd>src/error.rs</kbd>, we have defined the following error types:</p>
<pre>// todolist_parser/src/error.rs<br/><br/>use std::error::Error;<br/>use std::fmt;<br/>use std::fmt::Display;<br/><br/>#[derive(Debug)]<br/>pub enum ParseErr {<br/>    Malformed,<br/>    Empty<br/>}<br/><br/>#[derive(Debug)]<br/>pub struct ReadErr {<br/>    pub child_err: Box&lt;dyn Error&gt;<br/>}<br/><br/>// Required by error trait<br/>impl Display for ReadErr {<br/>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br/>        write!(f, "Failed reading todo file")<br/>    }<br/>}<br/><br/>// Required by error trait<br/>impl Display for ParseErr {<br/>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br/>        write!(f, "Todo list parsing failed")<br/>    }<br/>}<br/><br/>impl Error for ReadErr {<br/>    fn description(&amp;self) -&gt; &amp;str {<br/>        "Todolist read failed: "<br/>    }<br/><br/>    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; {<br/>        Some(&amp;*self.child_err)<br/>    }<br/>}<br/><br/>impl Error for ParseErr {<br/>    fn description(&amp;self) -&gt; &amp;str {<br/>        "Todolist parse failed: "<br/>    }<br/><br/>    fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; {<br/>        None<br/>    }<br/>}</pre>
<p>As of now, we are modelling two errors, which are very basic:</p>
<ul>
<li>Failing to read the list of todos modeled as <kbd>ReadErr</kbd></li>
<li>Failing to parse the todos modeled as <kbd>ParseErr</kbd>, which has two variants, where it can fail either due to the file being <kbd>Empty</kbd> or the file containing non-text/binary symbols, which means that it's <kbd>Malformed</kbd></li>
</ul>
<p>Following that, we implement the <kbd>Error</kbd> trait and the required super traits, <kbd>Display</kbd> and <kbd>Debug</kbd>. <kbd>lib.rs</kbd> contains the required parsing methods, as well as the declaration of the <kbd>TodoList</kbd> struct, as shown in the following code:</p>
<pre>// todolist_parser/src/lib.rs<br/><br/>//! This crate provides an API to parse list of todos<br/><br/>use std::fs::read_to_string;<br/>use std::path::Path;<br/><br/>mod error;<br/>use error::ParseErr;<br/>use error::ReadErr;<br/><br/>use std::error::Error;<br/><br/>/// This struct contains a list of todos parsed as a Vec&lt;String&gt;<br/>#[derive(Debug)]<br/>pub struct TodoList {<br/>    tasks: Vec&lt;String&gt;,<br/>}<br/><br/>impl TodoList {<br/>    pub fn get_todos&lt;P&gt;(path: P) -&gt; Result&lt;TodoList, Box&lt;dyn Error&gt;&gt;<br/>    where<br/>    P: AsRef&lt;Path&gt;, {<br/>        let read_todos: Result&lt;String, Box&lt;dyn Error&gt;&gt; = read_todos(path);<br/>        let parsed_todos = parse_todos(&amp;read_todos?)?;<br/>        Ok(parsed_todos)<br/>    }<br/>}<br/><br/>pub fn read_todos&lt;P&gt;(path: P) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt;<br/>where<br/>    P: AsRef&lt;Path&gt;,<br/>{<br/>    let raw_todos = read_to_string(path)<br/>        .map_err(|e| ReadErr {<br/>            child_err: Box::new(e),<br/>        })?;<br/>    Ok(raw_todos)<br/>}<br/><br/>pub fn parse_todos(todo_str: &amp;str) -&gt; Result&lt;TodoList, Box&lt;dyn Error&gt;&gt; {<br/>    let mut tasks: Vec&lt;String&gt; = vec![];<br/>    for i in todo_str.lines() {<br/>        tasks.push(i.to_string());<br/>    }<br/>    if tasks.is_empty() {<br/>        Err(ParseErr::Empty.into())<br/>    } else {<br/>        Ok(TodoList { tasks })<br/>    }<br/>}</pre>
<p>We have two top-level functions, <kbd>read_todos</kbd> and <kbd>parse_todos</kbd>, which are invoked by the <kbd>get_todos</kbd> method of <kbd>TodoList</kbd>.</p>
<p>We have an example usage of <kbd>TodoList</kbd> under <kbd>examples/basics.rs</kbd>, as follows:</p>
<pre>// todolist_parser/examples/basics.rs<br/><br/>extern crate todolist_parser;<br/><br/>use todolist_parser::TodoList;<br/><br/>fn main() {<br/>    let todos = TodoList::get_todos("examples/todos");<br/>    match todos {<br/>        Ok(list) =&gt; println!("{:?}", list),<br/>        Err(e) =&gt; {<br/>            println!("{}", e.description());<br/>            println!("{:?}", e)<br/>        }<br/>    }<br/>}</pre>
<p>If we run our <kbd>basics.rs</kbd> example via the <kbd>cargo run --example basics</kbd> command, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f4067e12-740d-405f-a483-678cf1708524.png"/></p>
<p>If you look at the error value being printed, it wraps the actual cause of error within the <kbd>ReadErr</kbd> value.</p>
<p>Rust has decent built-ins for defining custom error types. If you're writing your own crates, you should define your own error types to make debugging easier. However, implementing the <kbd>Error</kbd> trait for all of your types can often become redundant and time-consuming. Fortunately, we have a crate from the Rust community called <strong>failure</strong> (<a href="https://github.com/rust-lang-nursery/failure">https://github.com/rust-lang-nursery/failure</a>), which automates the creation of custom error types, along with the necessary implementation of traits that are auto-derived through the use of procedural macros. If you are feeling more ambitious, you are encouraged to refactor this library to use the <kbd>failure</kbd> crate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned that,  error handling in Rust is explicit: operations that can fail have a two-part return value via the <kbd>Result</kbd> or <kbd>Option</kbd> generic types. You must handle errors in some way, either by unpacking the <kbd>Result</kbd>/<kbd>Option</kbd> values with a <kbd>match</kbd> statement, or by using combinator methods. Unwrapping should be avoided on error types. Instead, use combinators or match expressions to take appropriate action or propagate the error to the caller by using the <kbd>?</kbd> operator. It is okay to panic when programming errors are so fatal that recovery would be impossible. Panics are mostly non-recoverable, which means that they crash your thread. Their default behavior is unwinding, which can be expensive and can be turned off if programs don't want this overhead. It is advised to be as descriptive as possible when communicating errors, and authors are encouraged to use custom error types in their crates.</p>
<p>In the next chapter, we'll cover some of the advanced aspects of the language and explore more of the guts of the type system.</p>


            

            
        
    </body></html>