- en: Basics of Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 基础
- en: 'This chapter introduces you to the basics of Rust, a systems programming language
    designed to be secure and fast. Rust is a good candidate to write concurrent software
    and it helps to prevent bugs. After reading this chapter, you''ll be ready to
    code cool projects in the subsequent chapters. After learning about the language
    itself, you''ll install its compiler and package manager, and you''ll start programming
    right away. You''ll also learn about the following concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了 Rust 的基础知识，这是一种旨在安全且快速的系统编程语言。Rust 是编写并发软件的好选择，并有助于防止错误。阅读本章后，你将准备好在后续章节中编写酷炫的项目。在了解语言本身之后，你将安装其编译器和包管理器，并立即开始编程。你还将学习以下概念：
- en: Variables
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Built-in data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据类型
- en: Control flow (conditions and loops)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流（条件和循环）
- en: Functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Custom data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义数据类型
- en: References
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用
- en: Pattern matching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Traits and Generics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性和泛型
- en: Arrays and Slices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和切片
- en: Macros
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏
- en: Getting to know Rust
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Rust
- en: Rust is a system programming language developed by Mozilla, whose version 1.0
    appeared in 2015\. A system language means that you have control over the memory
    used by the program—you decide whether you want to allocate the memory on the
    stack or the heap, and when the memory is freed. But don't worry; in Rust, the
    compiler is very helpful and prevents you from making the many mistakes you can
    make in C and C++ that lead to segmentation faults. A segmentation fault arises
    when the programmer tries to access some memory that is not accessible to its
    process. Memory unsafety leads to bugs and security flaws.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是由 Mozilla 开发的一种系统编程语言，其 1.0 版本于 2015 年发布。系统语言意味着你可以控制程序使用的内存——你可以决定是否在栈上或堆上分配内存，以及何时释放内存。但不用担心；在
    Rust 中，编译器非常有帮助，可以防止你犯在 C 和 C++ 中容易犯的错误，这些错误会导致段错误。当程序员尝试访问其进程无法访问的内存时，就会发生段错误。内存不安全会导致错误和安全漏洞。
- en: Moreover, the compiler is smart enough to know where to insert the memory deallocation
    instructions so that you don't need to manually free your memory, all of that
    without a garbage collector, which is one of its greatest features. Since Rust
    is safe and fast, it is the perfect candidate for writing operating systems, embedded
    programs, servers, and games, but you can also use it to develop desktop applications
    and websites. A great example of this power is the [Servo web engine](https://servo.org/),
    also developed by Mozilla.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编译器足够智能，知道在哪里插入内存释放指令，这样你就不需要手动释放内存，所有这些都不需要垃圾回收器，这是其最伟大的特性之一。由于 Rust 安全且快速，它是编写操作系统、嵌入式程序、服务器和游戏的理想选择，但你也可以用它来开发桌面应用程序和网站。这个强大功能的绝佳例子是
    [Servo 网络引擎](https://servo.org/)，它也是由 Mozilla 开发的。
- en: 'Rust is multi-paradigm: it can be used in an imperative or functional way and
    you can even write concurrent applications safely. It is statically typed, meaning
    that every type must be known at compile time, but since it uses type inference,
    we can omit the type for most local variables. It is also strongly typed, which
    means that its type system prevents the programmer from some kinds of errors,
    such as using the wrong type for a function parameter. And Rust is very good at
    writing concurrent software because it prevents data races, which is concurrent
    access to a variable where one is a write; this is an undefined behavior in other
    languages. One thing to remember when reading this book is that Rust prevents
    you from shooting yourself in the foot. For instance, Rust doesn''t have:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是多范式的：它可以以命令式或函数式的方式使用，你甚至可以安全地编写并发应用程序。它是静态类型的，这意味着每个类型必须在编译时已知，但由于它使用类型推断，我们可以省略大多数局部变量的类型。它也是强类型的，这意味着其类型系统可以防止程序员犯某些类型的错误，例如为函数参数使用错误类型。而且
    Rust 在编写并发软件方面非常出色，因为它可以防止数据竞争，这是对变量的并发访问，其中一个是在写入；这在其他语言中是未定义的行为。在阅读这本书时，要记住的一件事是
    Rust 可以防止你自作自受。例如，Rust 没有如下内容：
- en: null pointers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空指针
- en: data races
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据竞争
- en: use after free
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: use after free
- en: use before initialization
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: use before initialization
- en: goto
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: goto
- en: automatic coercion of Boolean, numbers and enumerations
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动转换布尔值、数字和枚举
- en: Also, Rust helps to prevent memory leaks. However, all of this is possible with
    `unsafe` code, which is explained in [Chapter 3](part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7),
    *Events and Basic Game Mechanisms*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Rust 还有助于防止内存泄漏。然而，所有这些都可以通过 `unsafe` 代码实现，这在第 3 章[事件和基本游戏机制](part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7)中有解释。
- en: Without further ado, let's install the tools we'll need throughout the book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们安装本书中需要的工具。
- en: Installing Rust
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Rust
- en: In this section we'll install `rustup`, which allows us to install different
    versions of the compiler and package manager.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装`rustup`，它允许我们安装不同版本的编译器和包管理器。
- en: Windows
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: Go to [https://rustup.rs](https://rustup.rs) and follow the instructions in
    order to download `rustup-init.exe`, then run it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://rustup.rs](https://rustup.rs)，按照说明下载`rustup-init.exe`，然后运行它。
- en: Linux/Mac
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux/Mac
- en: 'Unless your distribution provides a package for `rustup`, you''ll need to install
    `rustup` by typing the following command in your terminal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的发行版没有提供`rustup`的包，你需要在终端中键入以下命令来安装`rustup`：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This downloaded `rustup` and asked you whether you want to customize the installation.
    Unless you have particular needs, you'll be okay with the default.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载`rustup`并询问你是否想要自定义安装。除非你有特殊需求，否则默认设置就足够了。
- en: 'Note: The `$` represents your shell prompt and should not be typed; you must
    type the text following it. Also, a line of text that doesn''t start with `$`
    represents the text output of the program.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`$`代表你的shell提示符，不应键入；你必须键入它后面的文本。另外，不以`$`开头的文本行代表程序的文本输出。
- en: 'To proceed with the installation, enter `1` and press *Enter*. This will install
    the `rustc` compiler, and the `cargo` package manager, among other things:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续安装，请输入`1`并按*Enter*键。这将安装`rustc`编译器和`cargo`包管理器，以及其他工具：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As pointed out by the installer, you need to execute the following command
    in order to add the directory containing these tools in your `PATH`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如安装程序所指出的，你需要执行以下命令以将包含这些工具的目录添加到你的`PATH`中：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (This is only needed once because the rustup installer added it to your `~/.profile`
    file.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: （这只需要做一次，因为rustup安装程序已经将其添加到你的`~/.profile`文件中。）
- en: 'Now, test that you have both `cargo` and `rustc`, as you''ll need them very
    soon:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试你是否已经安装了`cargo`和`rustc`，因为你很快就会需要它们：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Cargo is Rust''s package manager and build tool: it allows you to compile and
    run your projects, as well as managing their dependencies.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo是Rust的包管理器和构建工具：它允许你编译和运行你的项目，以及管理它们的依赖关系。
- en: At the time of writing this book, the stable Rust version was 1.22.0.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，稳定的Rust版本是1.22.0。
- en: Test your installation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的安装
- en: 'Let''s try to build a Rust program. First, create a new project with `cargo`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建一个Rust程序。首先，使用`cargo`创建一个新的项目：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `--bin` flag indicates that we want to create an executable project, as
    opposed to a library (which is the default without this flag). In the Rust world,
    a **crate** is a package of libraries and/or executable binaries.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`--bin`标志表示我们想要创建一个可执行项目，而不是库（默认情况下没有这个标志）。在Rust的世界里，一个**crate**是一个包含库和/或可执行二进制的包。'
- en: 'This created a `hello_world` directory containing the following files and directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含以下文件和目录的`hello_world`目录：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Cargo.toml` file is where the metadata (name, version, and so on) of your
    project resides, as well as its dependencies. The source files of your project
    are in the `src` directory. It''s now time to run this project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cargo.toml`文件是存储你的项目元数据（名称、版本等）以及其依赖关系的地方。你的项目源文件位于`src`目录中。现在是时候运行这个项目了：'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first three lines printed after `cargo run` are lines printed by `cargo`
    indicating what it did: it compiled the project and ran it. The last line, `Hello,
    world!`, is the line printed by our project. As you can see, `cargo` generates
    a Rust file that prints text to `stdout` (standard output):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cargo run`之后打印出的前三行是`cargo`打印的，表示它做了什么：编译了项目并运行了它。最后一行`Hello, world!`是我们项目打印的行。正如你所看到的，`cargo`生成一个Rust文件，该文件将文本打印到`stdout`（标准输出）。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you only want to compile the project without running it, type the following
    instead:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想编译项目而不运行它，请键入以下命令代替：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This time, we didn't see `Compiling hello_world` because `cargo` did not see
    any changes to the project's files, thus, there's no need to compile again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们没有看到`Compiling hello_world`，因为`cargo`没有看到项目文件的任何更改，因此不需要再次编译。
- en: Documentation and reference
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档和参考
- en: 'You can find the API documentation here: [https://doc.rust-lang.org/stable/std/](https://doc.rust-lang.org/stable/std/).
    The reference can be found here: [https://doc.rust-lang.org/stable/reference/](https://doc.rust-lang.org/stable/reference/).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到API文档：[https://doc.rust-lang.org/stable/std/](https://doc.rust-lang.org/stable/std/)。参考文档可以在这里找到：[https://doc.rust-lang.org/stable/reference/](https://doc.rust-lang.org/stable/reference/)。
- en: Main function
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'Let''s look again at our first project source code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的第一个项目源代码：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It only contains a `main` function—this is where the execution of the program
    begins. It is a function that takes no arguments (hence the empty parentheses)
    and returns a unit, also written `()`. The body of the function, between curly
    brackets, contains a call to the `println!()` macro—we can see this is a macro
    because it ends with `!`, as opposed to a function. This macro prints the text
    between parentheses, followed by a new line. We'll see what is a macro in the
    Macros section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它只包含一个 `main` 函数——这是程序执行开始的地方。这是一个不接受任何参数（因此是空括号）并返回单元（也写作 `()`）的函数。函数体，在花括号之间，包含对
    `println!()` 宏的调用——我们可以看到这是一个宏，因为它以 `!` 结尾，而不是函数。这个宏打印括号内的文本，然后换行。我们将在宏部分看到什么是宏。
- en: Variables
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'We''ll now change the previous program to add a variable:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将之前的程序修改一下，添加一个变量：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `{}` part in the string literal is replaced by the content of the `name` variable.
    Here, we see the type inference in action—we don''t have to specify the type of
    the `name` variable and the compiler will infer it for us. We could have also
    written the type ourselves:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量中的 `{}` 部分被 `name` 变量的内容替换。在这里，我们看到类型推断的作用——我们不必指定 `name` 变量的类型，编译器会为我们推断。我们也可以自己写出类型：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (From now on, I'll omit the `main` function, but this code should be written
    inside the function.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: （从现在开始，我将省略 `main` 函数，但此代码应写在函数内部。）
- en: 'In Rust, variables are immutable by default. As such, writing the following
    will cause a compile-time error:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，变量默认是不可变的。因此，编写以下内容将导致编译时错误：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The compiler gives us a very helpful error message:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会给出一个非常有用的错误信息：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To make a variable mutable, we need to use the `mut` keyword:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要使变量可变，我们需要使用 `mut` 关键字：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Built-in data types
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置数据类型
- en: Let's look at the basic types provided by the language, such as integers, floats,
    Booleans, and characters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看语言提供的基本类型，例如整数、浮点数、布尔值和字符。
- en: Integer types
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数类型
- en: 'The following integer types are available in Rust:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中提供了以下整数类型：
- en: '| Unsigned | Signed |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 无符号 | 有符号 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `u8` | `i8` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `u8` | `i8` |'
- en: '| `u16` | `i16` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `u16` | `i16` |'
- en: '| `u32` | `i32` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `u32` | `i32` |'
- en: '| `u64` | `i64` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `u64` | `i64` |'
- en: '| `usize` | `isize` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `usize` | `isize` |'
- en: 'The `u` means unsigned, while the `i` means signed, and the number following
    it is the number of bits. For instance, a number of the `u8` type can be between
    0 and 255, inclusive. And a number of the `i16` type can be between -32768 and
    32767, inclusive. The size variants are the pointer-sized integer types: `usize`
    and `isize` are 64-bit on a 64-bit CPU. The default integer type is `i32`, which
    means that this type will be used by the type inference when it cannot choose
    a more specific type.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`u` 表示无符号，而 `i` 表示有符号，其后的数字表示位数。例如，`u8` 类型的数字可以在 0 到 255（包含）之间。`i16` 类型的数字可以在
    -32768 到 32767（包含）之间。大小变体是指针大小的整数类型：`usize` 和 `isize` 在 64 位 CPU 上是 64 位。默认整数类型是
    `i32`，这意味着当类型推断无法选择更具体的类型时，将使用此类型。'
- en: Floating-point types
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点数类型
- en: 'There are two floating-point types: `f32` and `f64`, the latter being the default.
    The number following `f` represents the number of bits for the type. An example
    value is `0.31415e1`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种浮点数类型：`f32` 和 `f64`，后者是默认类型。`f` 后面的数字表示该类型的位数。一个示例值是 `0.31415e1`。
- en: Boolean type
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'The `bool` type admits two values: `true` and `false`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool` 类型接受两个值：`true` 和 `false`。'
- en: Character type
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符类型
- en: The `char` type represents a Unicode character. An example unicode scalar value
    is `'€'`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 类型表示一个 Unicode 字符。一个示例 Unicode 标量值是 `''€''`。'
- en: Control flow
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: We'll now look at how to write conditions and loops in Rust. Conditions are
    useful to execute a block of code when a certain situation happens, and loops
    allow you to repeat a block of code a number of times, until a condition is met.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看看如何在 Rust 中编写条件和循环。条件在特定情况发生时执行代码块非常有用，而循环允许你重复执行代码块多次，直到满足条件。
- en: Writing a condition
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写条件
- en: 'Similar to other languages, Rust conditions are expressed with the `if` and
    `else` keywords:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言类似，Rust 使用 `if` 和 `else` 关键字表达条件：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, they do not require parentheses around the conditional expression.
    Also, this expression must be of the `bool` type: you cannot use a number as you
    would in other languages.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们不需要在条件表达式中使用括号。此外，此表达式必须是 `bool` 类型：你不能像在其他语言中那样使用数字。
- en: 'One particularity of Rust conditions, like many other constructs, is that they
    are expressions. The last expression of each branch is the value of this branch.
    Be careful though, the type of each branch must be the same. For instance, we
    can get the minimum number of the two numbers and put it into a variable:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的条件语句有一个特性，就像许多其他构造一样，即它们是表达式。每个分支的最后表达式是这个分支的值。不过要小心，每个分支的类型必须相同。例如，我们可以获取两个数字中的最小值并将其放入变量中：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating while loops
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建while循环
- en: There are multiple kinds of loop in Rust. One of them is the `while` loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中有多种循环类型。其中之一是`while`循环。
- en: 'Let''s see how to compute the greatest common divisor using the Euclidean algorithm:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用欧几里得算法计算最大公约数：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code executes successive divisions and stops doing so when the remainder
    is `0`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行连续的除法，当余数为`0`时停止。
- en: Creating functions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建函数
- en: We had a brief introduction to functions when we saw the `main` function. Let's
    see how to create functions with parameters and a return value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到`main`函数时，我们对函数有一个简要的介绍。让我们看看如何创建具有参数和返回值的函数。
- en: 'Here''s how to write a function that returns the maximum of two numbers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何编写一个返回两个数字中最大值的函数：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The parameters are between parentheses and must be explicitly typed since the
    type inference only infers the types of local variables. This is a good thing
    since this acts as a documentation. Moreover, this can prevent bugs when we change
    how we use the parameters or change the value that is returned. The function can
    be defined after it is used without any issue. The return type is after `->`.
    When we return `()`, we can omit the `->` and type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 参数位于括号内，并且必须显式指定类型，因为类型推断只能推断局部变量的类型。这是好事，因为这充当了文档。此外，这可以防止我们在更改参数的使用方式或更改返回的值时出现错误。函数可以在使用后定义，而不会出现任何问题。返回类型位于`->`之后。当我们返回`()`时，我们可以省略`->`和类型。
- en: The last expression in the body of a function is the value returned from the
    function. You don't need to use `return`. The `return` keyword is only needed
    when you want to return early.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体中的最后一个表达式是函数返回的值。你不需要使用`return`。只有当你想提前返回时才需要`return`关键字。
- en: Creating structures
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建结构体
- en: Sometimes, we have multiple values that only make sense together, such as the
    two coordinates of a point. Structures are a way to create new types that contains
    multiple members.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们有多组值，这些值只有在一起才有意义，例如一个点的两个坐标。结构体是一种创建包含多个成员的新类型的方法。
- en: 'Here is how we would create the aforementioned `Point` structure:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们创建上述`Point`结构体的方法：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To create a new point and access its members, we use the following syntax:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新点并访问其成员，我们使用以下语法：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What if we want to print the `point` as a whole?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想打印整个`point`呢？
- en: 'Let''s try the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下代码：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The compiler does not accept this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不接受以下内容：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `{}` syntax is used to display a value to the end user of the application.
    Nevertheless, there''s no standard way to display arbitrary structures. We can
    do what the compiler suggests: using the `{:?}` syntax. That requires you to add
    an attribute to the structure, so let''s change it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`{}`语法用于向应用程序的最终用户显示值。尽管如此，没有标准的方式来显示任意结构。我们可以做编译器建议的事情：使用`{:?}`语法。这需要你向结构添加一个属性，所以让我们改变它：'
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `#[derive(Debug)]` attribute tells the compiler to automatically generate
    the code to be able to print a debug representation of the structure. We''ll see
    how this works in the section about traits. It prints the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[derive(Debug)]`属性告诉编译器自动生成代码，以便能够打印出结构的调试表示。我们将在关于特质的章节中看到它是如何工作的。它打印以下内容：'
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Sometimes, the structure contains a lot of nested fields and this representation
    is hard to read. To remedy that, we can use the `{:#?}` syntax to pretty-print
    the value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，结构体包含很多嵌套字段，这种表示难以阅读。为了解决这个问题，我们可以使用`{:#?}`语法来美化打印值：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This gives the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The documentation describes what other formatting syntax can be used: [https://doc.rust-lang.org/stable/std/fmt/](https://doc.rust-lang.org/stable/std/fmt/).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 文档描述了可以使用哪些其他格式化语法：[https://doc.rust-lang.org/stable/std/fmt/](https://doc.rust-lang.org/stable/std/fmt/)。
- en: References
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Let''s try the following code, which would work in other programming languages:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下代码，这在其他编程语言中是可行的：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can see that Rust doesn''t accept this. It gives the following error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Rust不接受这个。它给出了以下错误：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This means that we cannot use a value after it is moved. In Rust, values are
    moved by default instead of being copied, except in some cases, as we'll see in
    the next sub-section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在值被移动之后，我们无法再使用它。在Rust中，默认情况下值是通过移动而不是复制来传递的，除非在某些情况下，我们将在下一小节中看到。
- en: 'To avoid moving a value, we can take a reference to it by prefixing it with `&`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免移动一个值，我们可以通过在它前面加上`&`来获取它的引用：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code compiles and, in this case, `p2` is a reference to `p1`, which means
    that it points to the same memory location. Rust ensures that it is always safe
    to use a reference, since references are not pointers, they cannot be `NULL`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可以编译，在这种情况下，`p2`是`p1`的引用，这意味着它指向相同的内存位置。Rust确保始终可以使用引用，因为引用不是指针，它们不能是`NULL`。
- en: 'References can also be used in the type of a function parameter. This is a
    function that prints a `point`, without moving the value:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 引用也可以用于函数参数的类型。这是一个打印`point`的函数，它不会移动值：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can use it this way:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can still use the `point` after calling `print_point`, because we send a
    reference to the function instead of moving the `point` into the function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`print_point`之后，我们仍然可以使用`point`，因为我们向函数发送了一个引用而不是将`point`移动到函数中。
- en: Clone types
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆类型
- en: 'An alternative to using references is to clone values. By cloning a value,
    we don''t move it. To be able to clone a `point`, we can add `derive` to it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用引用的另一种方法是克隆值。通过克隆一个值，我们不会移动它。要能够克隆一个`point`，我们可以在它上面添加`derive`：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can now call the `clone()` method to avoid moving our `p1` point:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以调用`clone()`方法来避免移动我们的`p1`点：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Copy types
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制类型
- en: 'Some types are not moved when we assigned a value of these types to another
    variable. This is the case for basic types such as integers. For instance, the
    following code is perfectly valid:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这些类型的值赋给另一个变量时，有些类型不会被移动。这对于基本类型，如整数来说就是这种情况。例如，以下代码是完全有效的：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can still use `num1` even thought we assigned it to `num2`. This is because
    the basic types implement a special marker: `Copy`. Copy types are copied instead
    of moved.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将它赋值给了`num2`，我们仍然可以使用`num1`。这是因为基本类型实现了一个特殊的标记：`Copy`。复制类型是复制的而不是移动的。
- en: 'We can make our own types `Copy` by adding `derive` to them:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加`derive`来使我们的自定义类型成为`Copy`类型：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Since `Copy` requires `Clone`, we also implement the latter for our `Point`
    type. We cannot derive `Copy` for a type containing a value that does not implement
    `Copy`. Now, we can use a `Point` without having to bother with references:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Copy`需要`Clone`，我们也为我们的`Point`类型实现了后者。我们不能为包含不实现`Copy`的值的类型推导出`Copy`。现在，我们可以使用`Point`而无需担心引用：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Mutable references
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变引用
- en: 'If we want to be able to mutable thought a reference, we need a mutable reference,
    since everything is immutable by default in Rust. To get a mutable reference,
    simply replace `&` with `&mut`. Let''s write a function that will increment the
    `x` field of a `Point`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要能够对引用进行可变操作，我们需要一个可变引用，因为在Rust中默认情况下一切都是不可变的。要获取一个可变引用，只需将`&`替换为`&mut`。让我们编写一个函数，该函数将增加`Point`的`x`字段：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we see that the `Point` type is now `&mut`, which allows us to update
    the point in the method. To use this method, our `p1` variable needs to be `mut`
    and we also need to take a mutable reference for this variable:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`Point`类型现在是`&mut`，这允许我们在方法中更新点。要使用此方法，我们的`p1`变量需要是`mut`，并且我们还需要为此变量提供一个可变引用：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Methods
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'We can add methods on custom types. Let''s write a method to compute the distance
    of a `point` to the origin:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在自定义类型上添加方法。让我们编写一个计算`point`到原点距离的方法：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are a lot of new syntaxes here (`impl Point`, `as`, and `.method()`),
    so let''s explain all of them. First of all, methods of a type are declared within
    the `impl Type {}` construct. This method takes a special parameter: `&self`.
    This parameter is the instance the method is called on, like `this` in other programming
    languages. The `&` operator before `self` means that the instance is passed by
    immutable reference. As we can see, it is possible to call methods on basic types
    in Rust—`self.x.pow(2)` computes the power of two of the `x` field. We can find
    this method, and many others, in the documentation, at [https://doc.rust-lang.org/stable/std/primitive.i32.html#method.pow](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.pow)
    . In the last expression of the method, we cast the `sum_of_squares` integer to `f64`
    before computing its square root, because the `sqrt()` method is defined only
    on floating points.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多新的语法（`impl Point`、`as`和`.method()`），所以让我们解释所有这些。首先，类型的方法定义在`impl Type {}`构造中。此方法接受一个特殊参数：`&self`。此参数是方法被调用的实例，就像其他编程语言中的`this`。在`self`之前的`&`运算符表示实例是通过不可变引用传递的。正如我们所见，在Rust中可以在基本类型上调用方法——`self.x.pow(2)`计算`x`字段的平方。我们可以在文档中找到此方法以及许多其他方法，请参阅[https://doc.rust-lang.org/stable/std/primitive.i32.html#method.pow](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.pow)
    。在方法的最后一个表达式中，我们在计算平方根之前将`sum_of_squares`整数转换为`f64`，因为`sqrt()`方法仅在浮点数上定义。
- en: 'Let''s create a method that will update the fields of the structure:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个方法来更新结构体的字段：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The difference with the previous method is that `self` is now a mutable reference, `&mut`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法不同的是，现在`self`是一个可变引用，`&mut`。
- en: Constructors
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Rust does not provide constructors, but a common idiom is to create a `new()`
    static method, also called an associated function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Rust不提供构造函数，但一个常见的习惯是创建一个`new()`静态方法，也称为关联函数：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The difference with a normal method is that it does not take `&self` (or one
    of its variations) as a parameter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通方法的不同之处在于它不取`&self`（或其变体）作为参数。
- en: '`Self` is the type of the `self` value; we could have used `Point` instead
    of `Self`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Self`是`self`值的类型；我们本可以使用`Point`代替`Self`。'
- en: 'When the field name is the same as the value assigned, it is possible to omit
    the value, as a shorthand:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当字段名与分配的值相同时，可以省略值，作为缩写：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When we create an instance of `Point` with the call to its constructor (`let
    point = Point::new();`), this will allocate the value on the stack.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过调用其构造函数（`let point = Point::new();`）创建`Point`的一个实例时，这将在栈上分配值。
- en: 'We can provide multiple constructors:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供多个构造函数：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tuples
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples and structures are similar, except that tuples'' fields are unnamed.
    Tuples are declared inside parentheses, with the element separated by a comma:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 元组和结构体相似，但元组的字段是无名的。元组在括号内声明，元素之间用逗号分隔：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see on the second line, we can access the elements of a tuple with
    `.index`, where `index` is a constant and this index starts at 0.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在第二行所见，我们可以使用`.index`访问元组的元素，其中`index`是一个常量，此索引从0开始。
- en: 'Tuples can be used to return multiple values from a function. For instance,
    the `str::split_at()` method returns two strings:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以用来从函数中返回多个值。例如，`str::split_at()`方法返回两个字符串：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we assign the two elements of the tuple to the `hello` and `world` variables.
    We'll see why this works in the *Pattern matching* section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将元组的两个元素赋值给`hello`和`world`变量。我们将在*模式匹配*部分看到这是为什么。
- en: Enumerations
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: While a structure allows us to get multiple values under the same variable,
    enumerations allow us to choose one value from different types of values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当结构体允许我们在同一个变量下获取多个值时，枚举允许我们从不同类型的值中选择一个。
- en: 'For example, let''s write a type representing an expression:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们编写一个表示表达式的类型：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Null` variant does not have a value associated with it, `Val` has one associated
    value, and `Add` has two. `Div` also has two associated values, but they are named,
    similar to how we define a structure.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Null`变体没有与之关联的值，`Val`有一个关联值，而`Add`有两个。`Div`也有两个关联值，但它们是有名称的，类似于我们定义结构体的方式。'
- en: Pattern matching
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'So how can we know which variant is in a variable whose type is an enumeration
    and how to get the values out of it? For that, we need to use pattern matching.
    The `match` expression is one way to do pattern matching. Let''s see how to use
    it to compute the result of an expression:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何知道一个枚举类型的变量中包含哪个变体，以及如何从中获取值呢？为此，我们需要使用模式匹配。`match` 表达式是进行模式匹配的一种方式。让我们看看如何使用它来计算表达式的结果：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A `match` expression is a way to check whether a value follows a certain pattern
    and executes different codes for different patterns. In this case, we match over
    an enumerated type, so we check for each variant. If the expression is `Expr::Add`,
    the code on the right of `=>` is executed: `println!("{}", x + y)`. By writing
    variable names inside the parentheses next to `Expr::Add`, we specify that the
    actual values of this variant are bound to these names. By doing so, we can use
    these variable names on the right side of `=>`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 表达式是一种检查值是否遵循某种模式并针对不同模式执行不同代码的方式。在这种情况下，我们匹配枚举类型，因此检查每个变体。如果表达式是 `Expr::Add`，则执行
    `=>` 右侧的代码：`println!("{}", x + y)`。通过在 `Expr::Add` 旁边括号内的括号中写入变量名，我们指定这个变体的实际值绑定到这些名称上。通过这样做，我们可以在
    `=>` 右侧使用这些变量名。'
- en: '*Figure* 1.1 is a diagram showing how pattern matching works:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图* 1.1 展示了模式匹配的工作原理：'
- en: '![](img/00005.jpeg)*Figure 1.1*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1](img/00005.jpeg)*图 1.1*'
- en: 'A `match` can also be used to check whether a number is within a range. This
    function converts an ASCII character (represented by `u8` in Rust) to uppercase:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 也可以用来检查一个数字是否在某个范围内。这个函数将 ASCII 字符（在 Rust 中用 `u8` 表示）转换为大写：'
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, the `...` syntax represents an inclusive range. And the underscore (`_`)
    is used to mean literally everything else, this is very useful in Rust because
    `match` needs to be exhaustive.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`...` 语法表示一个包含范围。而下划线 (`_`) 用于表示字面意义上的所有其他内容，这在 Rust 中非常有用，因为 `match` 需要穷尽所有可能。
- en: 'You can convert `u8` to `char` using the `as` syntax, as shown earlier:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `as` 语法将 `u8` 转换为 `char`，如前所述：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It is also possible to match against different patterns in a `match` by using
    the `|` operator:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `match` 中，也可以通过使用 `|` 运算符来匹配不同的模式：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are alternative syntaxes to do pattern matching. One of them is the `if
    let` construct. Let''s rewrite our `uppercase` function using `if let`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 进行模式匹配还有其他语法。其中之一是 `if let` 构造。让我们用 `if let` 重新编写我们的 `uppercase` 函数：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Unlike a `match`, `if let` does not need to be exhaustive. It does not even
    require an `else` branch, the rules used for the normal `if` expression also applies
    to `if let`. This construct can be more appropriate than `match` when you only
    want to match against one or two patterns.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `match` 不同，`if let` 不需要穷尽所有可能。它甚至不需要 `else` 分支，用于正常 `if` 表达式的规则也适用于 `if let`。当您只想匹配一个或两个模式时，这个构造可能比
    `match` 更合适。
- en: Irrefutable patterns
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可反驳的模式
- en: 'Another form of pattern matching is **irrefutable patterns**. A pattern is
    irrefutable when there''s only one way to match it and it always succeeds. For
    instance, another way to get the elements of a tuple is with an irrefutable pattern:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种模式匹配的形式是**不可反驳模式**。当一个模式只有一种匹配方式并且总是成功时，它就是不可反驳的。例如，获取元组元素的一种方式是使用不可反驳模式：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the second line, we assign the first element of the tuple to `a` and the
    second to `b`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们将元组的第一个元素赋值给 `a`，第二个元素赋值给 `b`。
- en: Traits
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质
- en: Traits are a way to specify that a type must implement some methods and/or some
    types. They are similar to interfaces in Java. We can implement a trait on a type
    and we'll be able to use the methods of this trait on this type as long as this
    trait is imported. This is how we can add methods to types defined in other crates
    or even the standard library.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 特质是一种指定类型必须实现某些方法以及/或某些类型的方式。它们与 Java 中的接口类似。我们可以在类型上实现一个特质，只要这个特质被导入，我们就可以使用这个特质的这些方法。这就是我们可以在其他包或标准库中定义的类型上添加方法的方式。
- en: 'Let''s write a trait representing a bit set:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个表示位集的特质：
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we don't write the body of the methods, as they will be defined when we
    implement this trait for a type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不需要编写方法的主体，因为它们将在为类型实现这个特质时定义。
- en: 'Now, let''s implement this trait for the `u64` type:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为 `u64` 类型实现这个特质：
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As you can see, the bitwise `not` operator is `!` in Rust, as opposed to `~`
    in other languages. With this code, we can call these methods on `u64`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Rust 中的按位非运算符是 `!`，与其他语言的 `~` 相反。使用这段代码，我们可以在 `u64` 上调用这些方法：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Remember the `#[derive(Debug)]` attribute? This actually implements the `Debug` trait
    on the following type. We could also manually implement the `Debug` trait on our
    type, using the same `impl` syntax, if the default implement does not suit our
    use case.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 记得`#[derive(Debug)]`属性吗？这实际上是在以下类型上实现了`Debug`特质。如果我们默认的实现不适合我们的用例，我们也可以手动使用相同的`impl`语法在我们的类型上实现`Debug`特质。
- en: Default methods
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认方法
- en: 'Traits can contain default methods, which can be convenient for the implementor
    of the trait since fewer methods will need to be implemented. Let''s add a `toggle()`
    default method in the trait:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 特质可以包含默认方法，这对于特质的实现者来说很方便，因为不需要实现的方法更少。让我们在特质中添加一个`toggle()`默认方法：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Since the new method has a body, we don''t need to update our previous implementation.
    However, we could do it to provide a more efficient implementation, for instance:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新方法有一个主体，我们不需要更新我们之前的实现。然而，我们可以这样做以提供更高效的实现，例如：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Associated types
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联类型
- en: 'We can also have types in a trait that need to be specified. For instance,
    let''s implement the `Add` trait from the standard library on our `Point` type
    that we declared earlier, which allows us to use the `+` operator on our own types:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在特质中有需要指定的类型。例如，让我们在我们的之前声明的`Point`类型上实现标准库中的`Add`特质，这允许我们在自己的类型上使用`+`运算符：
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first line is to import the `Add` trait from the standard library so that
    we can implement it on our type. Here we specify that the associated `Output` type
    is `Point`. Associated types are most useful for return types. Here, the `Output`
    of the `add()` method is the associated `Self::Output` type.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是导入标准库中的`Add`特质，这样我们就可以在我们的类型上实现它。这里我们指定关联的`Output`类型是`Point`。关联类型对于返回类型最有用。在这里，`add()`方法的`Output`是关联的`Self::Output`类型。
- en: 'Now, we can use the `+` operator on `Point`s:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`Point`s上使用`+`运算符：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Having to specify the output parameter with an associated type (instead of setting
    it to `Self`) gives us more flexibility. For instance, we could implement the
    scalar product for the `*` operator, which takes two `Point`s and returns a number.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用关联类型（而不是将其设置为`Self`）来指定输出参数，这为我们提供了更多的灵活性。例如，我们可以为`*`运算符实现标量积，它接受两个`Point`并返回一个数字。
- en: You can find all the operators that can be overloaded on this page, at [https://doc.rust-lang.org/stable/std/ops/index.html](https://doc.rust-lang.org/stable/std/ops/index.html).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本页面上找到所有可以重载的运算符，链接为[https://doc.rust-lang.org/stable/std/ops/index.html](https://doc.rust-lang.org/stable/std/ops/index.html)。
- en: Since Rust 1.20, Rust also supports associated constants in addition to associated
    types.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Rust 1.20以来，Rust还支持关联常量，除了关联类型。
- en: Rules
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则
- en: 'There are some rules that must be followed in order to use traits. The compiler
    will throw an error if they are not respected:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用特质，必须遵循一些规则。如果它们不被尊重，编译器将抛出错误：
- en: The trait must be imported in order to use its methods
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使用特质的方 法，必须导入该特质
- en: The implementation of a trait must be in the same crate as the trait or the
    type
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特质的实现必须在特质或类型的同一crate中
- en: The second rule is to avoid conflicts that could otherwise happen when using
    multiple libraries. We can have such a conflict when two imported traits provide
    the same method for the same type.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则是避免在使用多个库时可能发生的冲突。当两个导入的特质为同一类型提供相同的方法时，我们可能会遇到这样的冲突。
- en: Generics
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: 'Generics are a way to make a function or a type work for multiple types to
    avoid code duplication. Let''s rewrite our `max` function to make it generic:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一种使函数或类型能够为多种类型工作以避免代码重复的方法。让我们重写我们的`max`函数以使其泛型化：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The first thing to note is that there''s a new part after the function name:
    this is where we declare the generic types. We declare a generic `T` type, `:
    PartialOrd` after it means that this `T` type must implement the `PartialOrd`
    trait. This is called a trait bound. We then use this `T` type for both of our
    parameters and the return type. Then, we see the same function body as the one
    from our non-generic function. We needed to add the trait bound because, by default,
    no operation is allowed on a generic type. The `PartialOrd` trait allows us to
    use the comparison operators.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '首先要注意的是，在函数名之后有一个新的部分：这是我们声明泛型类型的地方。我们声明一个泛型`T`类型，在它后面`: PartialOrd`意味着这个`T`类型必须实现`PartialOrd`特质。这被称为特质界限。然后我们使用这个`T`类型作为我们的两个参数和返回类型。然后，我们看到与我们的非泛型函数相同的函数体。我们需要添加特质界限，因为默认情况下，不允许在泛型类型上进行任何操作。`PartialOrd`特质允许我们使用比较运算符。'
- en: 'We can then use this function with any type that implements `PartialOrd`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此函数与任何实现了 `PartialOrd` 的类型：
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is using static dispatch as opposed to dynamic dispatch, meaning that the
    compiler will generate a `max` function specific to `char` in the resulting binary.
    Dynamic dispatch is another approach that resolves the right function to call
    at runtime, which is less efficient.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使用静态分派而不是动态分派，这意味着编译器将在生成的二进制文件中生成一个针对 `char` 的特定 `max` 函数。动态分派是另一种在运行时解决要调用哪个函数的方法，这效率较低。
- en: The Option type
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项类型
- en: 'Generics can also be used in a type. The `Option` type from the standard library
    is a generic type, defined as such:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型也可以用于类型。标准库中的 `Option` 类型是一个泛型类型，定义为如下：
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This type is useful to encode the possibility of the absence of a value. `None`
    means no value, while `Some(value)` is used when there's a value.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型用于编码值不存在的情况。`None` 表示没有值，而 `Some(value)` 用于存在值的情况。
- en: Arrays
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is a fixed-size collection of elements of the same type. We declare
    them with square brackets:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个固定大小的相同类型元素的集合。我们用方括号声明它们：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The second line shows how to specify the type of an array. An alternative way
    to do that is to use a literal suffix:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行显示了如何指定数组的类型。另一种方法是使用文字后缀：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A literal suffix is the composition of a literal (that is, a constant) and
    a type suffix, so with the `1` constant and the `u8` type, we get `1u8`. Literal
    suffixes can only be used on numbers. This declares an array of `4` elements of
    the `u8` type. Array indexing starts at 0 and bounds checking is done at runtime.
    Bounds checking is used to prevent accessing memory that is out of bounds, for
    instance, trying to access the element after the end of an array. While this can
    slow down the software a bit, it can be optimized in many cases. The following
    code will trigger a panic because the `4` index is one past the end of the array:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 文字后缀是由一个文字（即，一个常量）和一个类型后缀组成的，因此，对于 `1` 常量和 `u8` 类型，我们得到 `1u8`。文字后缀只能用于数字。这声明了一个包含
    `4` 个 `u8` 类型元素的数组。数组索引从 `0` 开始，边界检查在运行时进行。边界检查用于防止访问超出范围的内存，例如，尝试访问数组末尾之后的元素。虽然这可能会稍微减慢软件的速度，但在许多情况下可以进行优化。以下代码将触发一个恐慌，因为
    `4` 索引超出了数组的末尾：
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'At runtime, we see the following message:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，我们看到以下消息：
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Another way to declare an array is:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种声明数组的方法是：
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This declares an array of 100 elements, where all of them are `0`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个包含 `100` 个元素且所有元素都是 `0` 的数组。
- en: Slices
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: 'Arrays are fixed-size, but if we want to create a function that works with
    arrays of any size, we need to use another type: a slice.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是固定大小的，但如果我们想创建一个可以与任何大小的数组一起工作的函数，我们需要使用另一种类型：切片。
- en: 'A slice is a view into a contiguous sequence: it can be a view of the whole
    array, or a part of it. Slices are fat pointers, in addition to the pointer to
    the data, they contain a size. Here''s a function that returns a reference to
    the first element of a slice:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是连续序列的视图：它可以是对整个数组的视图，也可以是其一部分。切片是胖指针，除了指向数据的指针外，它们还包含一个大小。以下是一个返回切片第一个元素引用的函数：
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here, we use a generic type without bound since we don''t use any operation
    on values of the `T` type. The `&[T]` parameter type is a slice of `T`. The return
    type is `&T`, which is a reference on values of the `T` type. The body of the
    function is `&slice[0]`, which returns a reference to the first element of the
    slice. Here''s how to call this function with an array:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用一个未加界泛型类型，因为我们没有在 `T` 类型的值上使用任何操作。`&[T]` 参数类型是 `T` 的切片。返回类型是 `&T`，它是对
    `T` 类型值的引用。函数体是 `&slice[0]`，它返回切片的第一个元素的引用。以下是如何使用数组调用此函数的方法：
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can create `slice` for only a portion of an array, as shown in the following
    example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以只为数组的一部分创建 `slice`，如下面的示例所示：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`&array[2..]` creates a slice that starts at the `2` index until the end of
    the array (hence no index after `..`). Both indices are optional, so we could
    also write `&array[..10]` for the first 10 elements of the array, `&array[5..10]`
    for the elements with the 5 to 9 index (inclusive), or `&array[..]` for all the
    elements.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`&array[2..]` 创建了一个从 `2` 索引开始直到数组末尾的切片（因此 `..` 后没有索引）。两个索引都是可选的，因此我们也可以写 `&array[..10]`
    以获取数组的前 10 个元素，`&array[5..10]` 以获取索引为 5 到 9 的元素（包括），或者 `&array[..]` 以获取所有元素。'
- en: For loops
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'The for loop is another form of loops that can be used in Rust. It is used
    to loop over elements of an iterator. An iterator is a structure that produces
    a sequence of value: it could produce the same value indefinitely or produce the
    elements of a collection. We can get an iterator from a slice, so let''s do that
    to compute the sum of the elements in a slice:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环是 Rust 中可以使用的一种循环形式。它用于遍历迭代器的元素。迭代器是一个结构，它产生一系列值：它可以无限期地产生相同的值，或者产生集合的元素。我们可以从切片中获取迭代器，所以让我们这样做来计算切片中元素的总和：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The only surprising part here is `*` in `sum += *element`. Since we get a reference
    to the elements of the slice, we need to dereference them in order to access the
    integers. We used `&` in front of `array` to avoid moving it, indeed, we may still
    want to use this variable after the loop.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一令人惊讶的部分是 `sum += *element` 中的 `*`。由于我们得到了切片元素的引用，我们需要解引用它们才能访问整数。我们在 `array`
    前面使用了 `&` 来避免移动它，实际上，我们可能仍然想在循环之后使用这个变量。
- en: 'Let''s write a function that returns the index of an element in a slice, or
    `None` if it is not in the slice:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数，它返回切片中元素的索引，或者如果它不在切片中则返回 `None`：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Note: A partial equivalence relation is both symmetric and transitive, but
    not reflexive. The `Eq` trait is used when these three properties are satisfied.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：部分等价关系既是对称的也是传递的，但不是自反的。当这三个属性都满足时，使用 `Eq` 特征。
- en: Here, we use again a generic type, but this time we use the `PartialEq` trait
    bound to be able to use the `==` operator on values of the `T` type. This function
    returns `Option<usize>`, meaning that it can either return no value (`None`) or
    the index (`Some(index)`). In the first line of the body, we use `slice.iter().enumerate()`
    to get the index in addition to the element of the slice. We use pattern matching
    right after the `for` keyword in order to assign the index and the element to
    variables. Inside the condition, we use the `return` keyword to return a value
    early. So if the value is found, it will return the index; otherwise, the loop
    will end and the `None` value is returned afterward.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用了一个泛型类型，但这次我们使用了 `PartialEq` 特征约束，以便能够在 `T` 类型的值上使用 `==` 操作符。这个函数返回
    `Option<usize>`，这意味着它可以返回没有值（`None`）或索引（`Some(index)`）。在主体第一行中，我们使用 `slice.iter().enumerate()`
    来获取索引以及切片的元素。我们使用 `for` 关键字后面的模式匹配来将索引和元素分配给变量。在条件内部，我们使用 `return` 关键字来提前返回一个值。所以如果找到了值，它将返回索引；否则，循环将结束，随后返回
    `None` 值。
- en: 'Let''s write another function that uses a `for` loop. It returns the minimum
    and the maximum of a slice, or `None` if the slice is empty:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个函数，它使用 `for` 循环。它返回切片的最小值和最大值，如果切片为空则返回 `None`：
- en: '[PRE73]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here we return multiple values from a function by using a tuple. This time, `&`
    is on the left side of `in`, while previously it was on the right side of it;
    this is because this `for` loop is pattern matching against a reference by using
    `&element`. This is something we can do in Rust, thus we don't need to dereference
    the element anymore with `*`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用元组从函数中返回多个值。这次，`&` 在 `in` 的左侧，而之前它在右侧；这是因为这个 `for` 循环通过使用 `&element`
    来对引用进行模式匹配。这是我们可以在 Rust 中做到的，因此我们不再需要使用 `*` 来解引用元素。
- en: Macros
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: 'Macro rules, also called macros by example, are a way to avoid code duplication
    by generating code at compile time. We will implement a simple macro to implement
    our `BitSet` trait for integer types:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 宏规则，也称为示例宏，是一种通过在编译时生成代码来避免代码重复的方法。我们将实现一个简单的宏来为整数类型实现我们的 `BitSet` 特征：
- en: '[PRE74]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The name of the `int_bitset` macro is written after `macro_rules!`. A macro
    can have multiple rules, similar to match arms, but it matches on Rust syntactic
    elements instead, with types, expressions, blocks of code, and so on. Here we
    only have one rule and it matches against a single type since we use `:ty`. The
    part before `:ty` (`$ty`) is the name for the element that was matched. Inside
    the curly brackets, after the `=>` symbol, we see the actual code that will be
    generated. It is the same as our previous implementation of `BitSet` for `u64`,
    except that it uses the meta-variable `$ty` instead of `u64`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_bitset` 宏的名称写在 `macro_rules!` 之后。宏可以有多个规则，类似于匹配臂，但它匹配 Rust 语法元素，而不是类型、表达式、代码块等。这里我们只有一个规则，并且它匹配单个类型，因为我们使用了
    `:ty`。`:ty` 之前的部分（`$ty`）是匹配的元素的名称。在 `=>` 符号后面的花括号内，我们看到将生成实际代码。它与我们对 `u64` 的 `BitSet`
    的先前实现相同，只是它使用元变量 `$ty` 而不是 `u64`。'
- en: 'To avoid a lot of boilerplate code, we can then use this macro as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免大量的样板代码，我们可以使用此宏如下：
- en: '[PRE75]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Multiple pattern rules
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个模式规则
- en: 'Let''s write a macro that will simplify the implementation of the traits to
    overload operators. This macro will have two rules: one for the `+` and one for
    the `-` operators. Here''s the first rule of the macro:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个宏，它将简化重载运算符的特质的实现。这个宏将有两个规则：一个用于 `+` 运算符，另一个用于 `-` 运算符。以下是宏的第一个规则：
- en: '[PRE76]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In this pattern, we use other types of syntactic elements: `ident`, which is
    an identifier, and `<span&gt;expr`, which is an expression. The trait (`::std::ops::Add`)
    is fully qualified so that the code using this macro won''t need to import the
    `Add` trait.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，我们使用其他类型的语法元素：`ident`，它是一个标识符，以及 `<span>expr`，它是一个表达式。特质（`::std::ops::Add`）是全称的，这样使用此宏的代码就不需要导入
    `Add` 特质。
- en: 'And here''s the rest of the macro:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是宏的其余部分：
- en: '[PRE77]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can then use this macro with our `Point` type, like this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这个宏与我们的 `Point` 类型一起使用，如下所示：
- en: '[PRE78]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let''s see how the matching works:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看匹配是如何工作的：
- en: For the first macro call, we start with `+`, so the first branch is taken because
    it matches `+`, which is the start of this branch. Next we have `self`, which
    is an identifier, so it matches the `ident` pattern and this is assigned to the `$_self` meta-variable.
    Then, we have `:` which matches the colon in the pattern. After that, we have
    `Point`, which matches the `$self_type` meta-variable of the `ty` type (for matching
    on a type). Then we have `,` which matches the comma in the pattern. Next, we
    have `other`, which matches the next item in the pattern, which is the `$other` meta-variable
    of the `ident` type. Finally, we have `{ Point { … } }`, which matches the expression
    required at the end of the pattern. This is why these macros are called macros
    by example, we write what the call should look like and the user must match the
    example (or pattern).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个宏调用，我们以 `+` 开始，因此第一个分支被选中，因为它匹配 `+`，这是该分支的开始。接下来是 `self`，它是一个标识符，因此它匹配
    `ident` 模式，并将其分配给 `$_self` 元变量。然后，我们有 `:`，它匹配模式中的冒号。之后，我们有 `Point`，它匹配 `ty` 类型的
    `$self_type` 元变量（用于类型匹配）。然后我们有 `,`，它匹配模式中的逗号。接下来是 `other`，它匹配模式中的下一个项目，即 `ident`
    类型的 `$other` 元变量。最后，我们有 `{ Point { … } }`，它匹配模式末尾所需的表达式。这就是为什么这些宏被称为示例宏，我们编写调用应该看起来像什么，用户必须匹配示例（或模式）。
- en: 'As an exercise to the reader, try the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对读者的练习，尝试以下操作：
- en: 'Add the missing operators: `*` and `/`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加缺失的运算符：`*` 和 `/`
- en: Add the ability to specify the types of `$other` and the return type in the
    pattern
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模式中添加指定 `$other` 类型以及返回类型的能力
- en: 'If you haven''t already done this in the previous point, add more tokens so
    that it looks more like a function declaration: `+(self: Point, other: Point)
    -> Point { … }`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果在前一点中还没有这样做，请添加更多标记，使其看起来更像一个函数声明：`+(self: Point, other: Point) -> Point
    { … }`'
- en: Try moving the operator in the pattern after the `$self_type` meta-variable
    to see the limitations of `macro_rules`
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将模式中的运算符移动到 `$self_type` 元变量之后，以查看 `macro_rules` 的局限性
- en: Repetitions
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复
- en: 'In a macro pattern, it is also possible to match against an unlimited number
    of patterns, using the repetition operators `+` and `*`. They behave exactly like
    the same operators in regular expressions:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏模式中，也可以使用重复运算符 `+` 和 `*` 来匹配无限数量的模式。它们的行为与正则表达式中的相同运算符完全一样：
- en: '`+` matches 1 or more times.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 匹配 1 次或更多次。'
- en: '`*` matches 0, 1, or more times.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 匹配 0、1 或多次。'
- en: 'Let''s write a very useful macro, a macro to provide syntactic sugar to create
    `HashMap`s:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个非常有用的宏，一个用于提供创建 `HashMap` 语法糖的宏：
- en: 'Note: A `HashMap` is a data structure from Rust''s standard library that maps
    keys to values.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`HashMap` 是 Rust 标准库中的一个数据结构，它将键映射到值。
- en: '[PRE79]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As we can see, we use the `*` operator here. The comma before it specify the
    separator token: this token must be present between each occurrence of the pattern
    between parentheses (which is the pattern that can be repeated). Don''t forget
    the leading `$` before the opening parenthesis; without it, the macro will match
    the literal `(`. Inside the parentheses, we see a normal pattern, an expression,
    followed by the `=>` operator, followed by another expression. The body of this
    rule is particular, since it uses two pairs of curly brackets instead of only
    one.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们在这里使用`*`运算符。它前面的逗号指定了分隔符：这个分隔符必须存在于括号中每个模式出现的间隔（这是可以重复的模式）。不要忘记在括号前的开头的`$`；如果没有它，宏将匹配字面量`(`。在括号内，我们看到一个正常的模式，一个表达式，后面跟着`=>`运算符，然后是另一个表达式。这个规则的正文是特别的，因为它使用了两对花括号而不是一对。
- en: 'First, let''s look at how we use this macro, and we''ll go back to this peculiarity
    right after:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们如何使用这个宏，然后我们将在稍后回到这个特殊性：
- en: '[PRE80]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If we were to use only one pair of curly brackets, like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只使用一对花括号，就像这样：
- en: '[PRE81]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The compiler will try to generate the following code, which doesn''t compile:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将尝试生成以下代码，但无法编译：
- en: '[PRE82]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'It doesn''t compile because Rust wants an expression on the right-hand side
    of `=`. To transform this code into an expression, we simply need to add the curly
    brackets:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 它无法编译，因为Rust希望在`=`的右侧有一个表达式。为了将此代码转换为表达式，我们只需添加花括号：
- en: '[PRE83]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Hence the second pair of curly brackets.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要第二对花括号。
- en: 'There''s one remaining line that requires an explanation in the body of the
    macro:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏的正文部分还有一行需要解释：
- en: '[PRE84]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This means that the statement will be repeated as many times as there are pairs
    of key/values. Notice that `;` is inside the parentheses; and there''s no separator
    before `*` because every statement needs to end with a semicolon. But it''s still
    possible to specify a separator here, as shown in the following example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着该语句将被重复，直到有键/值对的配对。注意，`;`在括号内；并且`*`之前没有分隔符，因为每个语句都需要以分号结束。但仍然可以在此处指定分隔符，如下面的示例所示：
- en: '[PRE85]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This will expand all the `$key`s, separating them by a comma. For instance,
    with a call like:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这将展开所有的`$key`，用逗号分隔。例如，使用如下调用：
- en: '[PRE86]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'It will results in:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 它将产生：
- en: '[PRE87]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Optional quantifier
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选量词
- en: 'In the `macro_rules` system, there''s no way to specify that a pattern is optional,
    like with the `?` quantifier in regular expressions. If we wanted to allow the
    user of our `hash` macro to use a trailing comma, we could change the rule by
    moving the comma inside the parentheses: `($( $key:expr => $value:expr,)*)`.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在`macro_rules`系统中，没有办法指定一个模式是可选的，就像正则表达式中的`?`量词一样。如果我们想让我们的`hash`宏的用户使用尾随逗号，我们可以通过将逗号移动到括号内来更改规则：`($(
    $key:expr => $value:expr,)* $(,)* )`。
- en: 'However, it will force the user to write a trailing macro. If we want to allow
    both variants, we can use the following trick, which uses the `*` operator: `($(
    $key:expr => $value:expr ),* $(,)* )`.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将强制用户编写尾随宏。如果我们想允许两种变体，我们可以使用以下技巧，它使用`*`运算符：`($( $key:expr => $value:expr
    ),* $(,)* )`。
- en: This means that a comma must be used between each pattern and we can use any
    number of commas after the last pattern, including no comma at all.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个模式之间必须使用逗号分隔，我们可以在最后一个模式之后使用任意数量的逗号，包括一个逗号都不用。
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduced you to the basics of Rust by showing you how to use
    variables, functions, control flow structures, and types. You also learned more
    advanced concepts such as references and ownership to manage the memory, and you
    saw how you can use traits, generics, and macros to avoid code repetition.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这章通过向你展示如何使用变量、函数、控制流结构和类型来介绍Rust的基础知识。你还学习了更高级的概念，如引用和所有权来管理内存，以及你看到了如何使用特性、泛型和宏来避免代码重复。
- en: In the next chapter, you'll practise what you've just learned by creating a
    video game.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将通过创建一个视频游戏来练习你刚刚学到的知识。
