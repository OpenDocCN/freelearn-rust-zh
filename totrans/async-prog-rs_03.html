<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-64" class="chapter-number"><a id="_idTextAnchor063"/>3</h1>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Understanding OS-Backed Event Queues, System Calls, and Cross-Platform Abstractions</h1>
			<p>In this chapter, we’ll take a look at how an OS-backed event queue works and how three different operating systems handle this task in different ways. The reason for going through this is that most async runtimes I know of use OS-backed event queues such as this as a fundamental part of achieving high-performance I/O. You’ll most likely hear references to these frequently when reading about how async code <span class="No-Break">really works.</span></p>
			<p>Event queues based on the technology we discuss in this chapter is used in many popular <span class="No-Break">libraries like:</span></p>
			<ul>
				<li>mio (<a href="https://github.com/tokio-rs/mio">https://github.com/tokio-rs/mio</a>), a key part of popular runtimes <span class="No-Break">like Tokio</span></li>
				<li>polling (<a href="https://github.com/smol-rs/polling">https://github.com/smol-rs/polling</a>), the event queue used in Smol <span class="No-Break">and async-std</span></li>
				<li>libuv (<a href="https://libuv.org/">https://libuv.org/</a>), the library used to create the event queue used in Node.js (a JavaScript runtime) and the Julia <span class="No-Break">programming language</span></li>
				<li>C# for its asynchronous <span class="No-Break">network calls</span></li>
				<li>Boost.Asio, a library for asynchronous network I/O <span class="No-Break">for C++</span></li>
			</ul>
			<p>All our interactions with the host operating system are done through <strong class="bold">system calls</strong> (<strong class="bold">syscalls</strong>). To<a id="_idIndexMarker152"/> make a system call using Rust, we need to know how to use<a id="_idIndexMarker153"/> Rust’s <strong class="bold">foreign function </strong><span class="No-Break"><strong class="bold">interface</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">FFI</strong></span><span class="No-Break">).</span></p>
			<p>In addition to knowing how to use FFI and make syscalls, we need to cover cross-platform abstractions. When creating an event queue, whether you create it yourself or use a library, you’ll notice that the abstractions might seem a bit unintuitive if you only have a high-level overview of how, for example, IOCP works on Windows. The reason for this is that these abstractions need to provide one API that covers the fact that different operating systems handle the same task differently. This process often involves identifying a common denominator between the platforms and building a new abstraction on top <span class="No-Break">of that.</span></p>
			<p>Instead of using a rather complex and lengthy example to explain FFI, syscalls, and cross-platform abstractions, we’ll ease into the topic using a simple example. When we encounter these concepts later on, we’ll already know these subjects well enough, so we’re well prepared for the more interesting examples in the <span class="No-Break">following chapters.</span></p>
			<p>In this chapter, we’ll go through the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Why use an OS-backed <span class="No-Break">event queue?</span></li>
				<li>Readiness-based <span class="No-Break">event queues</span></li>
				<li>Completion-based <span class="No-Break">event queues</span></li>
				<li><span class="No-Break">epoll</span></li>
				<li><span class="No-Break">kqueue</span></li>
				<li><span class="No-Break">IOCP</span></li>
				<li>Syscalls, FFI, and <span class="No-Break">cross-platform abstractions</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">There are popular, although lesser-used, alternatives you should know about even though we don’t cover <span class="No-Break">them here:</span></p>
			<p class="callout"><strong class="bold">wepoll</strong>: This uses <a id="_idIndexMarker154"/>specific APIs on Windows and wraps IOCP so it closely resembles how epoll works on Linux in contrast to regular IOCP. This makes it easier to create an abstraction layer with the same API on top of the two different technologies. It’s used by both <strong class="bold">libuv </strong>and <span class="No-Break"><strong class="bold">mio </strong></span><span class="No-Break">.</span></p>
			<p class="callout"><strong class="bold">io_uring</strong>: This is a <a id="_idIndexMarker155"/>relatively new API on Linux with many similarities to IOCP <span class="No-Break">on Windows.</span></p>
			<p class="callout">I’m pretty confident that after you’ve gone through the next two chapters, you will have an easy time reading up on these if you want to learn more <span class="No-Break">about them.</span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Technical requirements</h1>
			<p>This chapter doesn’t require you to set up anything new, but since we’re writing some low-level code for three different platforms, you need access to these platforms if you want to run all <span class="No-Break">the examples.</span></p>
			<p>The best way to follow along is to open the accompanying repository on your computer and navigate to the <span class="No-Break"><strong class="source-inline">ch03</strong></span><span class="No-Break"> folder.</span></p>
			<p>This chapter is a little special since we build some basic understanding from the ground up, which means some of it is quite low-level and requires a specific operating system and CPU family to run. Don’t worry; I’ve chosen the most used and popular CPU, so this shouldn’t be a problem, but it is something you need to be <span class="No-Break">aware of.</span></p>
			<p>The machine must use a CPU using the x86-64 instruction set on Windows and Linux. Intel and AMD desktop CPUs use this architecture, but if you run Linux (or WSL) on a machine using an ARM processor you might encounter issues with some of the examples using inline assembly. On macOS, the example in the book targets the newer M-family of chips, but the repository also contains examples targeting the older <span class="No-Break">Intel-based Macs.</span></p>
			<p>Unfortunately, some examples targeting specific platforms require that specific operating system to run. However, this will be the only chapter where you need access to three different platforms to run all the examples. Going forward, we’ll create examples that will run on all platforms either natively or using <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>), but to <a id="_idIndexMarker156"/>understand the basics of cross-platform abstractions, we need to actually create examples that target these <span class="No-Break">different platforms.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Running the Linux examples</h2>
			<p>If you don’t have a <a id="_idIndexMarker157"/>Linux machine set up, you can run the Linux example on the Rust Playground, or if you’re on a Windows system, my suggestion is to set up WSL and run the code there. You can find the instructions on how to do that at <a href="https://learn.microsoft.com/en-us/windows/wsl/install">https://learn.microsoft.com/en-us/windows/wsl/install</a>. Remember, you have to install Rust in the WSL environment as well, so follow the instructions in the <em class="italic">Preface</em> section of this book on how to install Rust <span class="No-Break">on Linux.</span></p>
			<p>If you use VS Code as your editor, there is a very simple way of switching your environment to WSL. Press <em class="italic">Ctrl</em>+<em class="italic">Shift</em>+<em class="italic">P</em> and write <strong class="source-inline">Reopen folder in WSL</strong>. This way, you can easily open<a id="_idIndexMarker158"/> the example folder in WSL and run the code examples using <span class="No-Break">Linux there.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Why use an OS-backed event queue?</h1>
			<p>You already know <a id="_idIndexMarker159"/>by now that we need to cooperate closely with the OS to make I/O operations as efficient as possible. Operating systems such as Linux, macOS, and Windows provide several ways of performing I/O, both blocking <span class="No-Break">and non-blocking.</span></p>
			<p>I/O operations need to go through the operating system since they are dependent on resources that our operating system abstracts over. This can be the disk drive, the network card, or other peripherals. Especially in the case of network calls, we’re not only dependent on our own hardware, but we also depend on resources that might reside far away from our own, causing a <span class="No-Break">significant delay.</span></p>
			<p>In the previous chapter, we covered different ways to handle asynchronous operations when programming, and while they’re all different, they all have one thing in common: they need control over when and if they should yield to the OS scheduler when making <span class="No-Break">a syscall.</span></p>
			<p>In practice, this means that syscalls that normally would yield to the OS scheduler (blocking calls) needs to be avoided and we need to use non-blocking calls instead. We also need an efficient way to know the status of each call so we know when the task that made the otherwise blocking call is ready to progress. This is the main reason for using an OS-backed event queue in an <span class="No-Break">asynchronous runtime.</span></p>
			<p>We’ll look at three different ways of handling an I/O operation as <span class="No-Break">an example.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Blocking I/O</h2>
			<p>When we ask the<a id="_idIndexMarker160"/> operating system to perform a blocking operation, it will suspend the OS thread that makes the call. It will then store the CPU state it had at the point where we made the call and go on to do other things. When data arrives for us through the network, it will wake up our thread again, restore the CPU state, and let us resume as if nothing <span class="No-Break">has happened.</span></p>
			<p>Blocking operations are the least flexible to use for us as programmers since we yield control to the OS at every call. The big advantage is that our thread gets woken up once the event we’re waiting for is ready so we can continue. If we take the whole system running on the OS into account, it’s a pretty efficient solution since the OS will give threads that have work to do time on the CPU to progress. However, if we narrow the scope to look at our process in isolation, we find that every time we make a blocking call, we put a thread to sleep, even if we still have work that our process could do. This leaves us with the choice of spawning new threads to do work on or just accepting that we have to wait for the blocking call to return. We’ll go a little more into detail about <span class="No-Break">this later.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Non-blocking I/O</h2>
			<p>Unlike a <a id="_idIndexMarker161"/>blocking I/O operation, the OS will not suspend the thread that made an I/O request, but instead give it a handle that the thread can use to ask the operating system if the event is ready <span class="No-Break">or not.</span></p>
			<p>We call the process of querying for<a id="_idIndexMarker162"/> <span class="No-Break">status </span><span class="No-Break"><strong class="bold">polling</strong></span><span class="No-Break">.</span></p>
			<p>Non-blocking I/O operations give us as programmers more freedom, but, as usual, that comes with a responsibility. If we poll too often, such as in a loop, we will occupy a lot of CPU time just to ask for an updated status, which is very wasteful. If we poll too infrequently, there will be a significant delay between an event being ready and us doing something about it, thus limiting <span class="No-Break">our throughput.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Event queuing via epoll/kqueue and IOCP</h2>
			<p>This is a<a id="_idIndexMarker163"/> sort of <a id="_idIndexMarker164"/>hybrid <a id="_idIndexMarker165"/>of the <a id="_idIndexMarker166"/>previous approaches. In the case of a network call, the call itself will be non-blocking. However, instead of polling the handle regularly, we can add that handle to an event queue, and we can do that with thousands of handles with very <span class="No-Break">little overhead.</span></p>
			<p>As programmers, we now have a new choice. We can either query the queue with regular intervals to check if any of the events we added have changed status or we can make a blocking call to the queue, telling the OS that we want to be woken up when at least one event in our queue has changed status so that the task that was waiting for that specific event <span class="No-Break">can continue.</span></p>
			<p>This allows us to only yield control to the OS when there is no more work to do and all tasks are waiting for an event to occur before they can progress. We can decide exactly when we want<a id="_idIndexMarker167"/> to<a id="_idIndexMarker168"/> issue<a id="_idIndexMarker169"/> such a<a id="_idIndexMarker170"/> blocking <span class="No-Break">call ourselves.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will not cover methods such as <strong class="bold">poll</strong> and <strong class="bold">select</strong>. Most operating systems have methods that are older and not widely used in modern async runtimes today. Just know that there are other calls we can make that essentially seek to give the same flexibility as the event queues we <span class="No-Break">just discussed.</span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Readiness-based event queues</h1>
			<p><strong class="bold">epoll </strong>and <strong class="bold">kqueue</strong> are<a id="_idIndexMarker171"/> known <a id="_idIndexMarker172"/>as <strong class="bold">readiness-based event queues</strong>, which<a id="_idIndexMarker173"/> means they let you know when an action is ready to be performed. An example of this is a socket that is ready to be <span class="No-Break">read from.</span></p>
			<p>To give an idea about how this works in practice, we can take a look at what happens when we read data from a socket <span class="No-Break">using epoll/kqueue:</span></p>
			<ol>
				<li>We create an event queue by calling the syscall <strong class="source-inline">epoll_create</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">kqueue</strong></span><span class="No-Break">.</span></li>
				<li>We ask the OS for a file descriptor representing a <span class="No-Break">network socket.</span></li>
				<li>Through another syscall, we register an interest in <strong class="source-inline">Read</strong> events on this socket. It’s important that we also inform the OS that we’ll be expecting to receive a notification when the event is ready in the event queue we created in <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">.</span></li>
				<li>Next, we call <strong class="source-inline">epoll_wait</strong> or <strong class="source-inline">kevent</strong> to wait for an event. This will block (suspend) the thread it’s <span class="No-Break">called on.</span></li>
				<li>When the event is ready, our thread is unblocked (resumed) and we return from our <strong class="source-inline">wait</strong> call with data about the event <span class="No-Break">that occurred.</span></li>
				<li>We call <strong class="source-inline">read</strong> on the<a id="_idIndexMarker174"/> socket we created in <span class="No-Break"><em class="italic">step 2</em></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B20892_Figure_03.1.jpg" alt="Figure 3.1 – A simplified view of the epoll and kqueue flow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – A simplified view of the epoll and kqueue flow</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Completion-based event queues</h1>
			<p>IOCP stands<a id="_idIndexMarker175"/> for <strong class="bold">input/output completion port</strong>. This is a <a id="_idIndexMarker176"/>completion-based event queue. This type of queue notifies you when events are completed. An example of this is when data has been read into <span class="No-Break">a buffer.</span></p>
			<p>The following is a basic breakdown of what happens in this type of <span class="No-Break">event queue:</span></p>
			<ol>
				<li>We create an event queue by calling the <span class="No-Break">syscall </span><span class="No-Break"><strong class="source-inline">CreateIoCompletionPort</strong></span><span class="No-Break">.</span></li>
				<li>We create a buffer and ask the OS to give us a handle to <span class="No-Break">a socket.</span></li>
				<li>We register an interest in <strong class="source-inline">Read</strong> events on this socket with another syscall, but this time we also pass in the buffer we created in (step 2) , which the data will be <span class="No-Break">read to.</span></li>
				<li>Next, we call <strong class="source-inline">GetQueuedCompletionStatusEx</strong>, which will block until an event has <span class="No-Break">been completed.</span></li>
				<li>Our thread is <a id="_idIndexMarker177"/>unblocked and our buffer is now filled with the data we’re <span class="No-Break">interested in.</span></li>
			</ol>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B20892_Figure_03.2.jpg" alt="Figure 3.2 – A simplified view of the IOCP flow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – A simplified view of the IOCP flow</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>epoll, kqueue, and IOCP</h1>
			<p><strong class="bold">epoll</strong> is the<a id="_idIndexMarker178"/> Linux way <a id="_idIndexMarker179"/>of implementing<a id="_idIndexMarker180"/> an event queue. In terms of functionality, it has a lot in common with kqueue. The advantage of using epoll over other similar methods on Linux, such as select or poll, is that epoll was designed to work very efficiently with a large number <span class="No-Break">of events.</span></p>
			<p><strong class="bold">kqueue</strong> is the macOS way of implementing an event queue (which originated from BSD) in operating systems such as FreeBSD and OpenBSD. In terms of high-level functionality, it’s similar to epoll in concept but different in <span class="No-Break">actual use.</span></p>
			<p><strong class="bold">IOCP</strong> is the way Windows handle this type of event queue. In Windows, a <strong class="bold">completion port</strong> will let <a id="_idIndexMarker181"/>you know when an event has been completed. Now, this might sound like a minor difference, but it’s not. This is especially apparent when you want to write a library since abstracting over both means you’ll either have to model IOCP as readiness-based or model epoll/kqueue <span class="No-Break">as completion-based.</span></p>
			<p>Lending out a buffer to the OS also provides some challenges since it’s very important that this buffer stays untouched while waiting for an operation <span class="No-Break">to return.</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Windows</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Linux</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">macOS</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">IOCP</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">epoll</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">kqueue</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Completion based</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Readiness based</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Readiness based</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1 – Different platforms and event queues</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Cross-platform event queues</h1>
			<p>When creating a<a id="_idIndexMarker182"/> cross-platform event queue, you have to deal with the fact that you have to create one unified API that’s the same whether it’s used on Windows (IOCP), macOS (kqueue), or Linux (epoll). The most obvious difference is that IOCP is completion-based while kqueue and epoll <span class="No-Break">are readiness-based.</span></p>
			<p>This fundamental difference means that you have to make <span class="No-Break">a choice:</span></p>
			<ul>
				<li>You can create an abstraction that treats kqueue and epoll as completion-based <span class="No-Break">queues, or</span></li>
				<li>You can create an abstraction that treats IOCP as a <span class="No-Break">readiness-based queue</span></li>
			</ul>
			<p>From my personal experience, it’s a lot easier to create an abstraction that mimics a completion-based queue and handle the fact that kqueue and epoll are readiness-based behind the scenes than the other way around. The use of wepoll, as I alluded to earlier, is one way of creating a readiness-based queue on Windows. It will simplify creating such an API greatly, but we’ll leave that out for now because it’s less well known and not an approach that’s <a id="_idIndexMarker183"/>officially documented <span class="No-Break">by Microsoft.</span></p>
			<p>Since IOCP is completion-based, it needs a buffer to read data into since it returns when data is read into that buffer. Kqueue and epoll, on the other hand, don’t require that. They’ll only return when you can read data into a buffer <span class="No-Break">without blocking.</span></p>
			<p>By requiring the user to supply a buffer of their preferred size to our API, we let the user control how they want to manage their memory. The user defines the size of the buffers, and the re-usages and controls all the aspects of the memory that will be passed to the OS when <span class="No-Break">using IOCP.</span></p>
			<p>In the case of epoll and kqueue in such an API, you can simply call read for the user and fill the same buffers, making it appear to the user that the API <span class="No-Break">is completion-based.</span></p>
			<p>If you wanted to present a readiness-based API instead, you have to create an illusion of having two separate operations when doing I/O on Windows. First, request a notification when the data is ready to be read on a socket, and then actually read the data. While possible to do, you’ll most likely find yourself having to create a very complex API or accept some inefficiencies on Windows platforms due to having intermediate buffers to keep the illusion of having a <span class="No-Break">readiness-based API.</span></p>
			<p>We’ll leave the topic of event queues for when we go on to create a simple example showing how exactly they work. Before we do that, we need to become really comfortable with FFI and syscalls, and we’ll do that by writing an example of a syscall on three <span class="No-Break">different platforms.</span></p>
			<p>We’ll also use this<a id="_idIndexMarker184"/> opportunity to talk about abstraction levels and how we can create a unified API that works on the three <span class="No-Break">different platforms.</span></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>System calls, FFI, and cross-platform abstractions</h1>
			<p>We’ll<a id="_idIndexMarker185"/> implement <a id="_idIndexMarker186"/>a very basic syscall for<a id="_idIndexMarker187"/> the <a id="_idIndexMarker188"/>three <a id="_idIndexMarker189"/>architectures: <strong class="bold">BSD/macOS</strong>, <strong class="bold">Linux</strong>, and <strong class="bold">Windows</strong>. We’ll also<a id="_idIndexMarker190"/> see how this is implemented in three levels <span class="No-Break">of abstraction.</span></p>
			<p>The syscall we’ll implement is the one used when we write something to the <strong class="bold">standard output </strong>(<strong class="bold">stdout</strong>) since <a id="_idIndexMarker191"/>that is such a common operation and it’s interesting to see how it <span class="No-Break">really works.</span></p>
			<p>We’ll start off by looking at the lowest level of abstraction we can use to make system calls and build our understanding of them from the <span class="No-Break">ground up.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>The lowest level of abstraction</h2>
			<p>The lowest level of <a id="_idIndexMarker192"/>abstraction is to write what is often referred to as a “raw” syscall. A raw syscall is one that bypasses the OS-provided library for making syscalls and instead relies on the OS having<a id="_idIndexMarker193"/> a stable <strong class="bold">syscall ABI</strong>. A stable syscall ABI means it guarantees that if you put the right data in certain registers and call a specific CPU instruction that passes control to the OS, it will always do the <span class="No-Break">same thing.</span></p>
			<p>To make a raw syscall, we need to write<a id="_idIndexMarker194"/> a little <strong class="bold">inline assembly</strong>, but don’t worry. Even though we introduce it abruptly here, we’ll go through it line by line, and in <a href="B20892_05.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we’ll introduce inline assembly in more detail so you become familiar <span class="No-Break">with it.</span></p>
			<p>At this level of abstraction, we need to write different code for BSD/macOS, Linux, and Windows. We also <a id="_idIndexMarker195"/>need to write different code if the OS is running on different <span class="No-Break">CPU architectures.</span></p>
			<h3>Raw syscall on Linux</h3>
			<p>On Linux and <a id="_idIndexMarker196"/>macOS, the syscall we want to<a id="_idIndexMarker197"/> invoke<a id="_idIndexMarker198"/> is called <strong class="source-inline">write</strong>. Both systems operate based on the concept of <strong class="bold">file descriptors</strong>, and <strong class="source-inline">stdout</strong> is already<a id="_idIndexMarker199"/> present when you start <span class="No-Break">a process.</span></p>
			<p>If you don’t run Linux on your machine, you have some options to run this example. You can copy and paste the code into the Rust Playground or you can run it using WSL <span class="No-Break">in Windows.</span></p>
			<p>As mentioned in the introduction, I’ll list what example you need to go to at the start of each example and you can run the example there by writing <strong class="source-inline">cargo run</strong>. The source code itself is always located in the example folder <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">src/main.rs</strong></span><span class="No-Break">.</span></p>
			<p>The first thing we do is to pull in the standard library module that gives us access to the <span class="No-Break"><strong class="source-inline">asm!</strong></span><span class="No-Break"> macro.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Repository reference: ch03/a-raw-syscall</p>
			<pre class="source-code">
use std::arch::asm;</pre>			<p>The next step is to write our <span class="No-Break">syscall function:</span></p>
			<pre class="source-code">
#[inline(never)]
fn syscall(message: String) {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    unsafe {
        asm!(
            "mov rax, 1",
            "mov rdi, 1",
            "syscall",
            in("rsi") msg_ptr,
            in("rdx") len,
            out("rax") _,
            out("rdi") _,
            lateout("rsi") _,
            lateout("rdx") _
        );
    }
}</pre>			<p>We’ll go through this<a id="_idIndexMarker200"/> first one line by line. The <a id="_idIndexMarker201"/>next <a id="_idIndexMarker202"/>ones will be pretty similar, so we only need to cover this in great <span class="No-Break">detail once.</span></p>
			<p>First, we have an attribute named <strong class="source-inline">#[inline(never)]</strong> that tells the compiler that we never want this function to be inlined during optimization. Inlining is when the compiler omits the function call and simply copies the body of the function instead of calling it. In this case, we don’t want that to <span class="No-Break">ever happen.</span></p>
			<p>Next, we have our function call. The first two lines in the function simply get the raw pointer to the memory location where our text is stored and the length of the <span class="No-Break">text buffer.</span></p>
			<p>The next line is an unsafe block since there is no way to call assembly such as this safely <span class="No-Break">in Rust.</span></p>
			<p>The first line of assembly puts the value <strong class="source-inline">1</strong> in the <strong class="source-inline">rax</strong> register. When the CPU traps our call later on and passes control to the OS, the kernel knows that a value of one in <strong class="source-inline">rax</strong> means that we want to make <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">write</strong></span><span class="No-Break">.</span></p>
			<p>The second line puts the value <strong class="source-inline">1</strong> in the <strong class="source-inline">rdi</strong> register. This tells the kernel where we want to write to, and a value of one means that we want to write <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">stdout</strong></span><span class="No-Break">.</span></p>
			<p>The third line calls the <strong class="source-inline">syscall</strong> instruction. This instruction issues a software interrupt, and the CPU passes on control to <span class="No-Break">the OS.</span></p>
			<p>Rust’s inline assembly syntax will look a little intimidating at first, but bear with me. We’ll cover this in detail a little later in this book so that you get comfortable with it. For now, I’ll just briefly explain what <span class="No-Break">it does.</span></p>
			<p>The fourth line writes the address to the buffer where our text is stored in the <span class="No-Break"><strong class="source-inline">rsi</strong></span><span class="No-Break"> register.</span></p>
			<p>The fifth line writes the length (in bytes) of our text buffer to the <span class="No-Break"><strong class="source-inline">rdx</strong></span><span class="No-Break"> register.</span></p>
			<p>The next four lines are not instructions to the CPU; they’re meant to tell the compiler that it can’t store anything in these registers and assume the data is untouched when we exit the inline<a id="_idIndexMarker203"/> assembly block. We do that <a id="_idIndexMarker204"/>by <a id="_idIndexMarker205"/>telling the compiler that there will be some unspecified data (indicated by the underscore) written to <span class="No-Break">these registers.</span></p>
			<p>Finally, it’s time to call our <span class="No-Break">raw syscall:</span></p>
			<pre class="source-code">
fn main() {
    let message = "Hello world from raw syscall!\n";
    let message = String::from(message);
    syscall(message);
}</pre>			<p>This function simply creates a <strong class="source-inline">String</strong> and calls our <strong class="source-inline">syscall</strong> function, passing it in as <span class="No-Break">an argument.</span></p>
			<p>If you run this on<a id="_idIndexMarker206"/> Linux, you should now <a id="_idIndexMarker207"/>see<a id="_idIndexMarker208"/> the following message in <span class="No-Break">your console:</span></p>
			<pre class="source-code">
Hello world from raw syscall!</pre>			<h3>Raw syscall on macOS</h3>
			<p>Now, since we <a id="_idIndexMarker209"/>use instructions that are specific<a id="_idIndexMarker210"/> to <a id="_idIndexMarker211"/>the CPU architecture, we’ll need different functions depending on if you run an older Mac with an intel CPU or if you run a newer Mac with an Arm 64-based CPU. We only present the one working for the new M series of chips using an ARM 64 architecture, but don’t worry, if you’ve cloned the Github repository, you’ll find code that works on both versions of <span class="No-Break">Mac there.</span></p>
			<p>Since there are only minor changes, I’ll present the whole example here and just go through <span class="No-Break">the differences.</span></p>
			<p>Remember, you need to run this code on a machine with macOS and an M-series chip. You can’t try this in the Rust playground. </p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">ch03/a-raw-syscall</p>
			<pre class="source-code">
use std::arch::asm;
fn main() {
    let message = "Hello world from raw syscall!\n"
    let message = String::from(message);
    syscall(message);
}
#[inline(never)]
fn syscall(message: String) {
    let ptr = message.as_ptr();
    let len = message.len();
    unsafe {
        asm!(
            "mov x16, 4",
            "mov x0, 1",
            "svc 0",
            in("x1") ptr,
            in("x2") len,
            out("x16") _,
            out("x0") _,
            lateout("x1") _,
            lateout("x2") _
        );
    }
}</pre>			<p>Aside from different <a id="_idIndexMarker212"/>register naming, there<a id="_idIndexMarker213"/> is <a id="_idIndexMarker214"/>not that much difference from the one we wrote for Linux, with the exception of the fact that a <strong class="source-inline">write</strong> operation has the code <strong class="source-inline">4</strong> on macOS instead of <strong class="source-inline">1</strong> as it did on Linux. Also, the CPU instruction that issues a software interrupt is <strong class="source-inline">svc 0</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">syscall</strong></span><span class="No-Break">.</span></p>
			<p>Again, if you run this on macOS, you’ll get the following printed to <span class="No-Break">your console:</span></p>
			<pre class="console">
Hello world from raw syscall!</pre>			<h3>What about raw syscalls on Windows?</h3>
			<p>This is a good<a id="_idIndexMarker215"/> opportunity to explain why writing<a id="_idIndexMarker216"/> raw syscalls, as we just did, is a bad idea if you want your program or library to work <span class="No-Break">across platforms.</span></p>
			<p>You see, if you want your code to work far into the future, you have to worry about what guarantees the OS gives. Linux guarantees that, for example, the value <strong class="source-inline">1</strong> written to the <strong class="source-inline">rax</strong> register will always refer to <strong class="source-inline">write</strong>, but Linux works on many platforms, and not everyone uses the same CPU architecture. We have the same problem with macOS that just recently changed from using an Intel-based x86_64 architecture to an ARM <span class="No-Break">64-based architecture.</span></p>
			<p>Windows gives absolutely zero guarantees when it comes to low-level internals such as this. Windows has changed its internals numerous times and provides no official documentation on this matter. The only things we have are reverse-engineered tables that you can find on the internet, but these are not a robust solution since what was a <strong class="source-inline">write</strong> syscall can be changed to a <strong class="source-inline">delete</strong> syscall the next time you run Windows update. Even if that’s unlikely, you have no guarantee, which in turn makes it impossible for you to guarantee to users of your program that it’s going to work in <span class="No-Break">the future.</span></p>
			<p>So, while raw syscalls in theory do work and are good to be familiar with, they mostly serve as an example <a id="_idIndexMarker217"/>of why we’d rather link <a id="_idIndexMarker218"/>to the<a id="_idIndexMarker219"/> libraries that the different operating systems supply for us when making syscalls. The next segment will show how we do <span class="No-Break">just that.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>The next level of abstraction</h2>
			<p>The next level of <a id="_idIndexMarker220"/>abstraction is to use the API, which all three operating systems provide <span class="No-Break">for us.</span></p>
			<p>We’ll soon see that this abstraction helps us remove some code. In this specific example, the syscall is the same on Linux and on macOS, so we only need to worry if we’re on Windows. We can differentiate between the platforms by using the <strong class="source-inline">#[cfg(target_family = "windows")]</strong> and <strong class="source-inline">#[cfg(target_family = "unix")]</strong> conditional compilation flags. You’ll see these used in the example in <span class="No-Break">the repository.</span></p>
			<p>Our main function will look the same as it <span class="No-Break">did before:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">ch03/b-normal-syscall</p>
			<pre class="source-code">
use std::io;
fn main() {
    let message = "Hello world from syscall!\n";
    let message = String::from(message);
    syscall(message).unwrap();
}</pre>			<p>The only difference is <a id="_idIndexMarker221"/>that instead of pulling in the <strong class="source-inline">asm</strong> module, we pull in the <span class="No-Break"><strong class="source-inline">io</strong></span><span class="No-Break"> module.</span></p>
			<h3>Using the OS-provided API in Linux and macOS</h3>
			<p>You can run <a id="_idIndexMarker222"/>this code <a id="_idIndexMarker223"/>directly<a id="_idIndexMarker224"/> in <a id="_idIndexMarker225"/>the <a id="_idIndexMarker226"/>Rust playground since it runs on Linux, or you can run it locally on a Linux machine using WSL or <span class="No-Break">on macOS:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">ch03/b-normal-syscall</p>
			<pre class="source-code">
#[cfg(target_family = "unix")]
#[link(name = "c")]
extern "C" {
    fn write(fd: u32, buf: *const u8, count: usize) -&gt; i32;
}
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    let res = unsafe { write(1, msg_ptr, len) };
    if res == -1 {
        return Err(io::Error::last_os_error());
    }
    Ok(())
}</pre>			<p>Let’s go through the different steps one by one. Knowing how to do a proper syscall will be very useful for us later on in <span class="No-Break">this book.</span></p>
			<pre class="source-code">
#[link(name = "c")]</pre>			<p>Every Linux (and macOS) installation comes with a version of <strong class="source-inline">libc</strong>, which is a C library for communicating with the operating system. Having <strong class="source-inline">libc</strong>, with a consistent API, allows us to program the same way without worrying about the underlying platform architecture. Kernel developers can also make changes to the underlying ABI without breaking everyone’s program. This flag tells the compiler to link to the <strong class="source-inline">"c"</strong> library on <span class="No-Break">the system.</span></p>
			<p>Next up is the definition<a id="_idIndexMarker227"/> of <a id="_idIndexMarker228"/>what <a id="_idIndexMarker229"/>functions<a id="_idIndexMarker230"/> in the linked library we <a id="_idIndexMarker231"/>want <span class="No-Break">to call:</span></p>
			<pre class="source-code">
extern "C" {
 fn write(fd: u32, buf: *const u8, count: usize);
}</pre>			<p><strong class="source-inline">extern "C"</strong> (sometimes written without the <strong class="source-inline">"C"</strong>, since <strong class="source-inline">"C"</strong> is assumed if nothing is specified) means we want to use the <strong class="source-inline">"C"</strong> <strong class="bold">calling convention</strong> when calling the function <strong class="source-inline">write</strong> in the <strong class="source-inline">"C"</strong> library we’re<a id="_idIndexMarker232"/> linking to. This function needs to have the exact same name as the function in the library we’re linking to. The parameters don’t have to have the same name, but they must be in the same order. It’s good practice to name them the same as in the library you’re <span class="No-Break">linking to.</span></p>
			<p>Here, we use Rusts FFI, so when you read about using FFI to call external functions, it’s exactly what we’re <span class="No-Break">doing here.</span></p>
			<p>The <strong class="source-inline">write</strong> function takes a file descriptor, <strong class="source-inline">fd</strong>, which in this case is a handle to <strong class="source-inline">stdout</strong>. In addition, it expects us to provide a pointer to an array of u8, <strong class="source-inline">buf</strong> values and the length of that <span class="No-Break">buffer, </span><span class="No-Break"><strong class="source-inline">count</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Calling convention</p>
			<p class="callout">This is the first <a id="_idIndexMarker233"/>time we’ve encountered this term, so I’ll go over a brief explanation, even though we dive deeper into this topic later in <span class="No-Break">the book.</span></p>
			<p class="callout">A calling convention defines how function calls are performed and will, amongst other <span class="No-Break">things, specify:</span></p>
			<p class="callout">- How arguments are passed into <span class="No-Break">the function</span></p>
			<p class="callout">- What registers the function is expected to store at the start and restore <span class="No-Break">before returning</span></p>
			<p class="callout">- How the function returns <span class="No-Break">its result</span></p>
			<p class="callout">- How the stack is set up (we’ll get back to this <span class="No-Break">one later)</span></p>
			<p class="callout">So, before you call a foreign function you need to specify what calling convention to use since there is no way for the compiler to know if we don’t tell it. The C calling convention is by far the most common one <span class="No-Break">to encounter.</span></p>
			<p>Next, we wrap <a id="_idIndexMarker234"/>the call <a id="_idIndexMarker235"/>to <a id="_idIndexMarker236"/>our<a id="_idIndexMarker237"/> linked <a id="_idIndexMarker238"/>function in a normal <span class="No-Break">Rust function.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">ch03/b-normal-syscall</p>
			<pre class="source-code">
#[cfg(target_family = "unix")]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    let res = unsafe { write(1, msg_ptr, len) };
    if res == -1 {
        return Err(io::Error::last_os_error());
    }
    Ok(())
}</pre>			<p>You’ll probably be familiar with the first two lines now, as they’re the same as we wrote for our raw syscall example. We get the pointer to the buffer where our text is stored and the length of <span class="No-Break">that buffer.</span></p>
			<p>Next is our call to the <strong class="source-inline">write</strong> function in <strong class="source-inline">libc</strong>, which needs to be wrapped in an <strong class="source-inline">unsafe</strong> block since Rust can’t guarantee safety when calling <span class="No-Break">external functions.</span></p>
			<p>You might wonder how we know that the value <strong class="source-inline">1</strong> refers to the file handle <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">stdout</strong></span><span class="No-Break">.</span></p>
			<p>You’ll meet this situation a lot when writing syscalls from Rust. Usually, constants are defined in the <strong class="source-inline">C</strong> header files, so we need to manually search them up and look for these definitions. <strong class="source-inline">1</strong> is always the file handle to <strong class="source-inline">stdout</strong> on UNIX systems, so it’s easy <span class="No-Break">to remember.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Wrapping the <strong class="source-inline">libc</strong> functions and providing these constants is exactly what the create <strong class="source-inline">libc</strong> (<a href="https://github.com/rust-lang/libc">https://github.com/rust-lang/libc</a>) provides for us. Most of the time, you can use that instead of doing all the manual work of linking to and defining functions as we <span class="No-Break">do here.</span></p>
			<p>Lastly, we <a id="_idIndexMarker239"/>have <a id="_idIndexMarker240"/>the error <a id="_idIndexMarker241"/>handling, and<a id="_idIndexMarker242"/> you’ll <a id="_idIndexMarker243"/>see this all the time when using FFI. <strong class="source-inline">C</strong> functions often use a specific integer to indicate if the function call was successful or not. In the case of this <strong class="source-inline">write</strong> call, the function will either return the number of bytes written or, if there is an error, it will return the value <strong class="source-inline">–1</strong>. You’ll find this information easily by reading the <em class="italic">man-pages</em> (<a href="https://man7.org/linux/man-pages/index.html">https://man7.org/linux/man-pages/index.html</a>) <span class="No-Break">for Linux.</span></p>
			<p>If there is an error, we use the built-in function in Rust’s standard library to query the OS for the last error it reported for this process and convert that to a rust <span class="No-Break"><strong class="source-inline">io::Error</strong></span><span class="No-Break"> type.</span></p>
			<p>If you run<a id="_idIndexMarker244"/> this<a id="_idIndexMarker245"/> function<a id="_idIndexMarker246"/> using <strong class="source-inline">cargo run</strong>, you <a id="_idIndexMarker247"/>will see <span class="No-Break">this output:</span></p>
			<pre class="source-code">
Hello world from syscall!</pre>			<h3>Using Windows API</h3>
			<p>On Windows, things <a id="_idIndexMarker248"/>work a bit differently. While <a id="_idIndexMarker249"/>UNIX models almost everything as “files” you interact with, Windows uses other abstractions. On Windows, you get a <strong class="bold">handle</strong> that represents some object you can interact with in specific ways depending on exactly what kind of handle <span class="No-Break">you have.</span></p>
			<p>We will use the same <strong class="source-inline">main</strong> function as before, but we need to link to different functions in the Windows API and make changes to our <span class="No-Break"><strong class="source-inline">syscall</strong></span><span class="No-Break"> function.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">ch03/b-normal-syscall</p>
			<pre class="source-code">
#[link(name = "kernel32")]
extern "system" {
    fn GetStdHandle(nStdHandle: i32) -&gt; i32;
    fn WriteConsoleW(
        hConsoleOutput: i32,
        lpBuffer: *const u16,
        numberOfCharsToWrite: u32,
        lpNumberOfCharsWritten: *mut u32,
        lpReserved: *const std::ffi::c_void,
    ) -&gt; i32;
}</pre>			<p>The first thing you notice is that we no longer link to the <strong class="source-inline">"C"</strong> library. Instead, we link to the <strong class="source-inline">kernel32</strong> library. The next change is the use of the system calling convention. This calling convention is a bit peculiar. You see, Windows uses different calling conventions depending on whether you write for a 32-bit x86 Windows version or a 64-bit x86_64 Windows version. Newer Windows versions running on x86_64 use the <strong class="source-inline">"C"</strong> calling convention, so if you have a newer system you can try changing that out and see that it still works. “Specifying system” lets the compiler figure out the right one to use based on <span class="No-Break">the system.</span></p>
			<p>We link to two different syscalls <span class="No-Break">in Windows:</span></p>
			<ul>
				<li><strong class="source-inline">GetStdHandle</strong>: This retrieves a reference to a standard device <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">stdout</strong></span></li>
				<li><strong class="source-inline">WriteConsoleW</strong>: WriteConsole comes in two types. <strong class="source-inline">WriteConsoleW</strong> takes Unicode text and <strong class="source-inline">WriteConsoleA</strong> takes ANSI-encoded text. We’re using the one that takes Unicode text in <span class="No-Break">our program.</span></li>
			</ul>
			<p>Now, <strong class="bold">ANSI-encoded</strong> text works fine if you only write English text, but as soon as you write text in other languages, you might need to use special characters that are not possible to represent in ANSI but possible in <strong class="bold">Unicode</strong>. If you mix them up, your program will not work as <span class="No-Break">you expect.</span></p>
			<p>Next is <a id="_idIndexMarker250"/>our<a id="_idIndexMarker251"/> new <span class="No-Break"><strong class="source-inline">syscall</strong></span><span class="No-Break"> function:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">ch03/b-normal-syscall</p>
			<pre class="source-code">
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    let msg: Vec&lt;u16&gt; = message.encode_utf16().collect();
    let msg_ptr = msg.as_ptr();
    let len = msg.len() as u32;
    let mut output: u32 = 0;
        let handle = unsafe { GetStdHandle(-11) };
        if handle  == -1 {
            return Err(io::Error::last_os_error())
        }
        let res = unsafe {
            WriteConsoleW(
                handle,
                msg_ptr,
                len,
                &amp;mut output,
                std::ptr::null()
            )};
        if res  == 0 {
            return Err(io::Error::last_os_error());
        }
    Ok(())
}</pre>			<p>The first thing we do is convert the text to <strong class="source-inline">utf-16</strong>-encoded text, which Windows uses. Fortunately, Rust has a<a id="_idIndexMarker252"/> built-in function to convert our <strong class="source-inline">utf-8</strong>-encoded text to <strong class="source-inline">utf-16</strong> code points. <strong class="source-inline">encode_utf16</strong> returns an iterator over  <strong class="source-inline">u16</strong> code points that we can collect to <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Vec</strong></span><span class="No-Break">.</span></p>
			<p>The next two lines should be familiar by now. We get the pointer to where the text is stored and the length of the text <span class="No-Break">in bytes.</span></p>
			<p>The next thing we do is call <strong class="source-inline">GetStdHandle</strong> and pass in the value <strong class="source-inline">–11</strong>. The values we need to pass in for the different standard devices are described together with the GetStdHandle documentation at <a href="https://learn.microsoft.com/en-us/windows/console/getstdhandle">https://learn.microsoft.com/en-us/windows/console/getstdhandle</a>. This is convenient, as we don’t have to dig through C header files to find all the constant values <span class="No-Break">we need.</span></p>
			<p>The return code to<a id="_idIndexMarker253"/> expect is also documented thoroughly for all functions, so we handle potential errors here in the same way as we did for the <span class="No-Break">Linux/macOS syscalls.</span></p>
			<p>Finally, we have the call to the <strong class="source-inline">WriteConsoleW</strong> function. There is nothing too fancy about this, and you’ll notice similarities with the <strong class="source-inline">write</strong> syscall we used for Linux. One difference is that the output is not returned from the function but written to an address location we pass in in the form of a pointer to our <span class="No-Break">output variable.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Now that you’ve seen how we create cross-platform syscalls, you will probably also understand why we’re not including the code to make every example in this book cross-platform. It’s simply the case that the book would be extremely long if we did, and it’s not apparent that all that extra information will actually benefit our understanding of the <span class="No-Break">key concepts.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>The highest level of abstraction</h2>
			<p>This is simple, but I <a id="_idIndexMarker254"/>wanted to add this just for completeness. Rust standard library wraps the calls to the underlying OS APIs for us, so we don’t have to care about what syscalls <span class="No-Break">to invoke.</span></p>
			<pre class="source-code">
fn main() {
 println!("Hello world from the standard library");
}</pre>			<p>Congratulations! You’ve now written the same syscall using three levels of abstraction. You now know what FFI looks like, you’ve seen some inline assembly (which we’ll cover in greater detail later), and you’ve made a proper syscall to print something to the console. You’ve also seen one of the things our standard library tries to solve by wrapping these calls for different platforms so we don’t have to know these syscalls to print something<a id="_idIndexMarker255"/> to <span class="No-Break">the console.</span></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Summary</h1>
			<p>In this chapter, we went through what OS-backed event queues are and gave a high-level overview of how they work. We also went through the defining characteristics of epoll, kqueue, and IOCP and focused on how they differ from <span class="No-Break">each other.</span></p>
			<p>In the last half of this chapter, we introduced some examples of syscalls. We discussed raw syscalls, and “normal” syscalls so that you know what they are and have seen examples of both. We also took the opportunity to talk about abstraction levels and the advantages of relying on good abstractions when they’re available <span class="No-Break">to us.</span></p>
			<p>As a part of making system calls, you also got an introduction to <span class="No-Break">Rusts FFI.</span></p>
			<p>Finally, we created a cross-platform abstraction. You also saw some of the challenges that come with creating a unifying API that works across several <span class="No-Break">operating systems.</span></p>
			<p>The next chapter will walk you through an example using epoll to create a simple event queue, so you get to see exactly how this works in practice. In the repository, you’ll also find the same example for both Windows and macOS, so you have that available if you ever want to implement an event queue for either of <span class="No-Break">those platforms.</span></p>
		</div>
	

		<div id="_idContainer017" class="Content">
			<h1 id="_idParaDest-81" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor080"/>Part 2:Event Queues and Green Threads</h1>
			<p>In this part, we’ll present two examples. The first example demonstrates the creation of an event queue using epoll. We will design the API to closely resemble the one used by mio, allowing us to grasp the fundamentals of both mio and epoll. The second example illustrates the use of fibers/green threads, similar to the approach employed by Go. This method is one of the popular alternatives to Rust’s asynchronous programming using futures and async/await. Rust also utilized green threads before reaching version 1.0, making it a part of Rust’s asynchronous history. Throughout the exploration, we will delve into fundamental programming concepts such as ISAs, ABIs, calling conventions, stacks, and touch on assembly programming. This section comprises the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B20892_04.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a><em class="italic">, Create Your Own Event Queue</em></li>
				<li><a href="B20892_05.xhtml#_idTextAnchor092"><em class="italic">Chapter 5</em></a><em class="italic">, Creating Our Own Fibers</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer018" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>