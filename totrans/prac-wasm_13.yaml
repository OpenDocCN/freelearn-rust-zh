- en: '*Chapter 10*: Optimizing Rust and WebAssembly'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：优化Rust和WebAssembly'
- en: 'So far, we have seen how Rust makes it easy to create and run WebAssembly modules
    and various tools provided by the Rust community. We will cover the following
    sections in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了Rust如何使创建和运行WebAssembly模块变得容易，以及Rust社区提供的各种工具。在本章中，我们将涵盖以下部分：
- en: Minimizing the WebAssembly modules
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化WebAssembly模块
- en: Analyzing the memory model in the WebAssembly module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析WebAssembly模块中的内存模型
- en: Analyzing the WebAssembly module with Twiggy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Twiggy分析WebAssembly模块
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中存在的代码文件，地址为[https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly)。
- en: Minimizing the WebAssembly modules
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化WebAssembly模块
- en: '`wasm-bindgen` is a complete suite that generates the binding JavaScript file
    (along with polyfills) for the WebAssembly module. In previous chapters, we saw
    how `wasm-bindgen` provides libraries and makes it easy to pass complex objects
    between JavaScript and WebAssembly. But in the WebAssembly world, it is important
    to optimize the generated binary for size and performance.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-bindgen`是一个完整的套件，为WebAssembly模块生成绑定JavaScript文件（包括polyfills）。在前几章中，我们看到了`wasm-bindgen`如何提供库，并使得在JavaScript和WebAssembly之间传递复杂对象变得容易。但在WebAssembly的世界里，优化生成的二进制文件的大小和性能非常重要。'
- en: 'Let''s see how we can further optimize the WebAssembly modules:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何进一步优化WebAssembly模块：
- en: 'Create a WebAssembly application with all the necessary toolchains:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有必要的工具链创建WebAssembly应用程序：
- en: '[PRE0]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This previous command creates a new Rust and JavaScript-based application with
    webpack as the bundler.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此前命令创建了一个新的基于Rust和JavaScript的应用程序，webpack作为打包器。
- en: 'Go into the generated `wasm-rust` directory:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入生成的`wasm-rust`目录：
- en: '[PRE1]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Rust source files are present in the `src` directory and the JavaScript
    files are available in the `js` directory. We have webpack configured for running
    the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rust源文件位于`src`目录中，JavaScript文件位于`js`目录中。我们已经为运行应用程序配置了webpack。
- en: 'Remove all the code from `src/lib.rs` and replace it with the following:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`src/lib.rs`中删除所有代码，并用以下内容替换：
- en: '[PRE2]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We import `wasm_bindgen` and then enable `wee_alloc`, which does a much smaller
    memory allocation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`wasm_bindgen`并启用`wee_alloc`，它进行更小的内存分配。
- en: We go on to define the `is_palindrome` function, which takes `&str` as input
    and returns `bool`. Inside this function, we check whether the given string is
    a palindrome or not.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续定义`is_palindrome`函数，它接受`&str`作为输入并返回`bool`。在这个函数内部，我们检查给定的字符串是否是回文。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Find out more about the difference between `&str` and `String` at [https://users.rust-lang.org/t/whats-the-difference-between-string-and-str/10177/9](https://users.rust-lang.org/t/whats-the-difference-between-string-and-str/10177/9).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://users.rust-lang.org/t/whats-the-difference-between-string-and-str/10177/9](https://users.rust-lang.org/t/whats-the-difference-between-string-and-str/10177/9)了解更多关于`&str`和`String`之间的区别。
- en: 'Now, remove all the lines from `js/index.js` and replace them with the following
    content:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`js/index.js`中删除所有行，并用以下内容替换：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We are importing from `../pkg/index.js` here. The `wasm-pack` command will generate
    the `binding` file and `wasm` file inside the `pkg` folder.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里从`../pkg/index.js`导入。`wasm-pack`命令将在`pkg`文件夹内生成`binding`文件和`wasm`文件。
- en: 'Next, build the application with the following command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令构建应用程序：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can run the application with the `npm run start` command. This command opens
    the browser and loads the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`npm run start`命令运行应用程序。此命令打开浏览器并加载应用程序。
- en: Now, open the developer tools and check the logs in the console.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开开发者工具并检查控制台中的日志。
- en: The WebAssembly module generated by the Rust compiler is not completely optimized.
    We can optimize the WebAssembly modules further. In the JavaScript world, every
    byte matters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Rust编译器生成的WebAssembly模块并未完全优化。我们可以进一步优化WebAssembly模块。在JavaScript的世界里，每个字节都很重要。
- en: 'Now, open `Cargo.toml` and add the following content:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`Cargo.toml`并添加以下内容：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Also, remove the `[profile.release]` section completely. The `[profile.dev]`
    section instructs the compiler on how to profile the code generated in the dev
    build. The `[profile.release]` section is used only for the release build.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，完全删除`[profile.release]`部分。`[profile.dev]`部分指导编译器如何对dev构建中生成的代码进行性能分析。`[profile.release]`部分仅用于发布构建。
- en: We instruct the compiler to use `opt-level = z` for generating the code. The
    `opt-level` setting is similar to the LLVM compiler's `-O1/2/3/...`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指示编译器使用`opt-level = z`来生成代码。`opt-level`设置类似于LLVM编译器的`-O1/2/3/...`。
- en: 'The valid options of the `opt-level` setting are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`opt-level`设置的合法选项如下：'
- en: '`0` – no optimizations; also turns on `cfg(debug_assertions)`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` – 没有优化；同时开启`cfg(debug_assertions)`'
- en: '`1` – basic optimizations'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` – 基本优化'
- en: '`2` – some optimizations'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` – 一些优化'
- en: '`3` – all optimizations'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3` – 所有优化'
- en: '`s` – optimize for binary size'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` – 优化二进制大小'
- en: '`z` – optimize for binary size, but also turn off loop vectorization'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z` – 优化二进制大小，但关闭循环向量化'
- en: LLVM supports link-time optimizations to better optimize code by using whole
    program analysis. But link-time optimization comes at the cost of longer linking
    time. We can enable LLVMs link-time optimization using the lto option.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM支持链接时优化，通过使用整个程序分析来更好地优化代码。但链接时优化是以更长的链接时间为代价的。我们可以通过使用lto选项来启用LLVM的链接时优化。
- en: 'The lto supports the following options:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: LTO支持以下选项：
- en: '`false` – performs "thin local LTO”. This means the link-time optimizations
    are done only on the local crate. Note: there will not be any link-time optimizations
    when the number of Codegen units is 1 or `opt-level` is 0\.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false` – 执行“thin local LTO”。这意味着链接时优化仅在本地crate上完成。注意：当Codegen单元数量为1或`opt-level`为0时，将不会进行链接时优化。'
- en: '`true` or "fat" – performs "fat" LTO. This means the link-time optimizations
    are done across all crates in the dependency graph.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`或“fat” – 执行“fat”LTO。这意味着链接时优化是在依赖图中的所有crates上完成的。'
- en: '`thin` – performs "thin" LTO. This is a faster version of “fat”, that optimizes
    at a faster rate.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thin` – 执行“thin”LTO。这是“fat”的一个更快版本，优化速度更快。'
- en: '`off` – disables LTO.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`off` – 禁用LTO（链接时优化）。'
- en: 'Next, run `npm run build`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行`npm run build`：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The generated WebAssembly binary is 50.8 KB. The generated binary is ~44% smaller
    in size. That is a huge win for us. We can further optimize the binary using Binaryen''s
    `wasm-opt` tool:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的WebAssembly二进制文件大小为50.8 KB。生成的二进制文件大小减少了约44%。这对我们来说是一个巨大的胜利。我们可以使用Binaryen的`wasm-opt`工具进一步优化二进制文件：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It reduces another 5 KB. We have used the `-Oz` pass, but we can pass in other
    passes to further optimize the generated binary.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它又减少了5 KB。我们已经使用了`-Oz`传递，但我们还可以传递其他传递来进一步优化生成的二进制文件。
- en: We have seen how to minimize the WebAssembly module using Rust. Next, we will
    analyze the memory model in the WebAssembly module.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用Rust最小化WebAssembly模块。接下来，我们将分析WebAssembly模块中的内存模型。
- en: Analyzing the memory model in the WebAssembly module
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析WebAssembly模块中的内存模型
- en: Inside the JavaScript engine, WebAssembly and JavaScript run at different locations.
    Crossing the boundaries between JavaScript and WebAssembly will always have a
    cost attached to it. The browser vendors implemented cool hacks and workarounds
    to reduce this cost, but when your applications cross this boundary, this boundary
    crossing will often soon become a major performance bottleneck for your application.
    It is very important to design WebAssembly applications in a way that reduces
    boundary crossing. But once the application grows, it becomes difficult to manage
    this boundary crossing. To prevent boundary crossing, WebAssembly modules come
    with the memory module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript引擎内部，WebAssembly和JavaScript在不同的位置运行。跨越JavaScript和WebAssembly之间的边界总会有一些成本。浏览器厂商实现了酷炫的技巧和解决方案来减少这种成本，但当你应用程序跨越这个边界时，这个边界跨越很快就会成为你应用程序的主要性能瓶颈。设计WebAssembly应用程序时，减少边界跨越非常重要。但一旦应用程序增长，管理这个边界跨越就变得困难。为了防止边界跨越，WebAssembly模块附带内存模块。
- en: The memory section in the WebAssembly module is a vector of linear memories.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly模块中的内存部分是一个线性内存的向量。
- en: A linear memory model is a memory-addressing technique in which the memory is
    organized in a single contagious address space. It is also known as the Flat memory
    model.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 线性内存模型是一种内存寻址技术，其中内存组织在一个单一的连续地址空间中。它也被称为平面内存模型。
- en: The linear memory model makes it easier to understand, program, and represent
    the memory. But it also has huge disadvantages, such as high execution time for
    rearranging elements in memory and wasting a lot of memory area.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 线性内存模型使得理解、编程和表示内存变得更加容易。但它也有巨大的缺点，例如在内存中重新排列元素的高执行时间和浪费大量内存区域。
- en: Here, the memory represents a vector of raw bytes containing uninterpreted data.
    WebAssembly uses resizable array buffers to hold the raw bytes of memory. It is
    important to note that this memory that is created is accessible and mutable from
    both JavaScript and WebAssembly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内存代表一个包含未解释数据的原始字节的向量。WebAssembly 使用可调整大小的数组缓冲区来存储内存的原始字节。需要注意的是，创建的这种内存可以从
    JavaScript 和 WebAssembly 中访问和修改。
- en: Sharing memory between JavaScript and WebAssembly using Rust
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Rust 在 JavaScript 和 WebAssembly 之间共享内存
- en: 'We have already seen how to share the memory between JavaScript and WebAssembly.
    Let''s share memory using Rust in this example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在 JavaScript 和 WebAssembly 之间共享内存。让我们在这个例子中使用 Rust 来共享内存：
- en: 'Create a new Rust project using Cargo:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 创建一个新的 Rust 项目：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the project in your favorite editor and replace `src/lib.rs` with the
    following content:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的编辑器中打开项目，并将 `src/lib.rs` 替换为以下内容：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Rust file starts with `#![no_std]`. This instructs the compiler not to include
    the Rust Standard Library while generating the WebAssembly module. This will reduce
    the binary size a lot. Next, we define a function called `memory_to_js`. This
    function creates an `obj` in memory and shares it with JavaScript. In the function
    definition, we create a slice of `u32` called `obj`. Next, we assign some raw
    memory to `obj`. Here, we are dealing with raw memory. Hence, we wrap the code
    inside an `unsafe` block. The memory object is global and it is mutable by both
    JavaScript and WebAssembly. Hence, we use `from_raw_parts_mut` to instantiate
    the object. Finally, we assign a value to the first element in the shared array
    buffer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 文件以 `#![no_std]` 开始。这指示编译器在生成 WebAssembly 模块时不要包含 Rust 标准库。这将大大减少二进制文件的大小。接下来，我们定义一个名为
    `memory_to_js` 的函数。这个函数在内存中创建一个 `obj` 并与 JavaScript 共享。在函数定义中，我们创建一个名为 `obj` 的
    `u32` 切片。接下来，我们将一些原始内存分配给 `obj`。在这里，我们处理原始内存。因此，我们将代码包裹在一个 `unsafe` 块中。内存对象是全局的，并且可以被
    JavaScript 和 WebAssembly 同时修改。因此，我们使用 `from_raw_parts_mut` 来实例化对象。最后，我们将共享数组缓冲区的第一个元素赋值为一个值。
- en: 'Create an `index.html` file and add the following content:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `index.html` 文件，并添加以下内容：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We create an anonymous asynchronous JavaScript function that will be invoked
    as soon as the script is loaded. We fetch the WebAssembly binary inside the anonymous
    function. Next, we create `ArrayBuffer` and instantiate the module to the `result`
    object. We then call the `memory_to_js` method in the WebAssembly module (note
    the `exports` keyword, since the function is exported from the WebAssembly module).
    This instantiates the memory and assigns the first element in the shared array
    buffer to `13`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个匿名异步 JavaScript 函数，该函数在脚本加载时立即被调用。在匿名函数中，我们获取 WebAssembly 二进制文件。接下来，我们创建
    `ArrayBuffer` 并将模块实例化到 `result` 对象中。然后，我们在 WebAssembly 模块中调用 `memory_to_js` 方法（注意
    `exports` 关键字，因为该函数是从 WebAssembly 模块导出的）。这实例化了内存并将共享数组缓冲区的第一个元素赋值为 `13`：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we call the memory object that is exported from WebAssembly using `result.export.memory.buffer`
    and convert it into `UInt8Array` using a new `UInt8Array()`. Next, we extract
    the first element using `slice(0,1)`. This way, we can pass and retrieve values
    between JavaScript and WebAssembly without any overhead. The memory is accessed
    via `load` and `store` binary instructions. The `load` operation copies data from
    the main memory to register. The `store` operation copies data from the main memory.
    These binary instructions are accessed with the offset and the alignment. The
    alignment is in base-2 logarithmic representation. The memory address should be
    a multiple of four. This is called alignment restriction. This alignment restriction
    makes the hardware much faster.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `result.export.memory.buffer` 调用从 WebAssembly 导出的内存对象，并使用一个新的 `UInt8Array()`
    将其转换为 `UInt8Array`。然后，我们使用 `slice(0,1)` 提取第一个元素。这样，我们可以在 JavaScript 和 WebAssembly
    之间传递和检索值，而无需任何开销。内存通过 `load` 和 `store` 二进制指令访问。`load` 操作将数据从主内存复制到寄存器。`store`
    操作将数据从主内存复制。这些二进制指令通过偏移量和对齐方式访问。对齐是以 2 为底的对数表示。内存地址应该是 4 的倍数。这被称为对齐限制。这种对齐限制使硬件运行得更快。
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that WebAssembly currently provides only a 32-bit address
    range. In the future, WebAssembly might provide a 64-bit address range.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，WebAssembly 目前只提供 32 位地址范围。在未来，WebAssembly 可能会提供 64 位地址范围。
- en: We have seen how to share memory between JavaScript and WebAssembly by creating
    the memory in Rust. Next, we will create a memory object on the JavaScript side
    and use it inside the Rust application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何通过在 Rust 中创建内存来在 JavaScript 和 WebAssembly 之间共享内存。接下来，我们将在 JavaScript
    端创建内存对象并在 Rust 应用程序中使用它。
- en: Creating a memory object in JavaScript to use in the Rust application
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JavaScript 中创建内存对象以在 Rust 应用程序中使用
- en: Unlike JavaScript, Rust is not dynamically typed. The memory created in JavaScript
    has no way to tell WebAssembly (or the Rust code) what to allocate and when to
    free them. We need to explicitly inform WebAssembly how to allocate the memory
    and, most importantly, when and how to free them (to avoid any leaks).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 不同，Rust 不是动态类型。在 JavaScript 中创建的内存无法告诉 WebAssembly（或 Rust 代码）要分配什么以及何时释放它们。我们需要明确告知
    WebAssembly 如何分配内存，最重要的是，何时以及如何释放它们（以避免任何泄漏）。
- en: 'We use the `WebAssembly.memory()` constructor to create the memory in JavaScript.
    The memory constructor takes in an object to set the defaults. The object has
    the following options:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `WebAssembly.memory()` 构造函数在 JavaScript 中创建内存。内存构造函数接收一个对象来设置默认值。该对象具有以下选项：
- en: '`initial` – the initial size of the memory'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial` – 内存初始大小'
- en: '`maximum` – the maximum size of the memory (optional)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maximum` – 内存的最大大小（可选）'
- en: '`shared` – to denote whether to use the shared memory'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared` – 表示是否使用共享内存'
- en: The units for `initial` and `maximum` are WebAssembly pages, where a page refers
    to 64 KB.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`initial` 和 `maximum` 的单位是 WebAssembly 页面，其中页面指的是 64 KB。'
- en: 'We change the HTML file as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按如下方式更改 HTML 文件：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In `// -> 1`, the memory is initialized with the `WebAssembly.Memory()` constructor.
    We passed in the initial and maximum size of the memory, that is, 640 KB and 6.4
    MB, respectively.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `// -> 1` 中，我们使用 `WebAssembly.Memory()` 构造函数初始化内存。我们传递了内存的初始和最大大小，即 640 KB
    和 6.4 MB。
- en: In `// -> 2`, we're instantiating the WebAssembly module along with the memory
    object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `// -> 2` 中，我们正在实例化 WebAssembly 模块以及内存对象。
- en: In `// -> 3`, we then create `typedArray` (`UInt8Array`) with values `1`, `2`,
    and `3`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `// -> 3` 中，我们随后创建具有值 `1`、`2` 和 `3` 的 `typedArray` (`UInt8Array`)。
- en: In `// -> 4`, we see how, as WebAssembly modules do not have any clue about
    the objects that are created out of the memory, the memory needs to be allocated.
    We have to manually write the allocation and freeing of memory in WebAssembly.
    In this step, we send the length of the array and allocate that memory. This gives
    us a pointer to the location of the memory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `// -> 4` 中，我们看到，由于 WebAssembly 模块对从内存中创建的对象没有任何线索，因此需要分配内存。我们必须在 WebAssembly
    中手动编写内存的分配和释放。在这个步骤中，我们发送数组的长度并分配该内存。这给了我们内存位置的指针。
- en: In `// -> 5`, we create a new `typedArray` with the buffer (total available
    memory), the memory offset (`wasmAttrPtr`), and the length of the memory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `// -> 5` 中，我们使用缓冲区（总可用内存）、内存偏移量（`wasmAttrPtr`）和内存长度创建一个新的 `typedArray`。
- en: In `// -> 6`, we set the locally created `typedArray` (in *step 3*) to `typedArray`
    created in *step 5*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `// -> 6` 中，我们将本地创建的 `typedArray`（在第 *3* 步中创建）设置为在第 *5* 步中创建的 `typedArray`。
- en: In `//-> 7`, finally, we send the pointer to the memory and the length to the
    WebAssembly module, where we fetch the value from the memory by using the pointer
    to the memory and the length.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `//-> 7` 中，最后，我们将内存指针和长度发送到 WebAssembly 模块，通过使用内存指针和长度从内存中获取值。
- en: 'On the Rust side, replace the contents of `src/lib.rs` with the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 端，将 `src/lib.rs` 的内容替换为以下内容：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We imported `alloc`, `dealloc`, and `Layout` from `std::alloc` and `std::mem`
    to play with the raw memory. The first function, `accumulate`, takes in `data`,
    which is the pointer where the data starts, and `len`, the length of the memory
    to read. First, we create a slice from the raw memory using `std::slice::from_raw_parts`
    by passing the pointer, `data`, and length, `len`. Note that this is an unsafe
    operation. Next, we run through the items in the array and add all the elements.
    Finally, we return the value as `i32`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `std::alloc` 和 `std::mem` 中导入了 `alloc`、`dealloc` 和 `Layout` 来操作原始内存。第一个函数
    `accumulate` 接收 `data`，这是数据开始的指针，以及 `len`，要读取的内存长度。首先，我们使用 `std::slice::from_raw_parts`
    通过传递指针 `data` 和长度 `len` 从原始内存中创建一个切片。请注意，这是一个不安全操作。接下来，我们遍历数组中的项并将所有元素相加。最后，我们将值作为
    `i32` 返回。
- en: The `malloc` function is used to custom-allocate the memory since the WebAssembly
    module has no clue about the type of information sent and how to read/understand
    it. `malloc` helps us to allocate the memory as required without any panic.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc`函数用于自定义分配内存，因为WebAssembly模块对发送的信息类型以及如何读取/理解它一无所知。`malloc`帮助我们按需分配内存，而无需任何恐慌。'
- en: Run the previous code using `python -m http.server` and load the web page in
    a browser to see the results in the developer tools.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`python -m http.server`运行前面的代码，并在浏览器中加载网页以在开发者工具中查看结果。
- en: Analyzing the WebAssembly module with Twiggy
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Twiggy分析WebAssembly模块
- en: The Rust-to-WebAssembly binaries are more likely to create a bloated binary.
    Proper care should be taken when creating WebAssembly binaries. The trade-off
    between the level of optimization, the time to compile, and various other factors
    should be considered while producing binaries. But most of the preceding work
    is done by the compiler by default. Either Emscripten or the `rustc` compiler
    ensures the elimination of dead code along with various options on the optimization
    level (`-O0` to `z`). We can choose the one that fits us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Rust到WebAssembly的二进制文件更有可能创建一个臃肿的二进制文件。在创建WebAssembly二进制文件时，应采取适当的注意。在生成二进制文件时，应考虑优化级别、编译时间以及各种其他因素之间的权衡。但大多数先前的工作默认由编译器完成。无论是Emscripten还是`rustc`编译器，都会确保消除死代码，并提供各种优化级别的选项（从`-O0`到`z`）。我们可以选择适合我们的一个。
- en: Twiggy is a code size profiler. It uses the call graph to determine the origins
    of a function and provides meta-information about the function. The meta-information
    includes the size of each function in binary and its cost. Twiggy provides an
    overview of what is in the binary. With that information, we can optimize the
    binary further Let's install and use Twiggy to optimize the binary:.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Twiggy是一个代码大小分析器。它使用调用图来确定函数的来源，并提供关于函数的元信息。元信息包括每个函数的二进制大小及其成本。Twiggy提供了二进制内容的概述。有了这些信息，我们可以进一步优化二进制文件。让我们安装并使用Twiggy来优化二进制文件：
- en: 'Install Twiggy by running the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装Twiggy：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once installed, the `twiggy` command will be available in the command line,
    which we can check with the following command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，`twiggy`命令将在命令行中可用，我们可以通过以下命令来检查：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a folder to test-drive Twiggy:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件夹来测试驱动Twiggy：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a file called `add.wat` and add the following content:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`add.wat`的文件，并添加以下内容：
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once you have defined the WebAssembly text format, compile it to the WebAssembly
    module using `wabt`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦定义了WebAssembly文本格式，就可以使用`wabt`将其编译为WebAssembly模块：
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding command generates an `add.wasm` file. To get the call paths in
    the binary, run Twiggy with the `paths` option:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的命令生成一个`add.wasm`文件。要获取二进制中的调用路径，请使用`paths`选项运行Twiggy：
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `twiggy paths` command shows the call path for the functions, the number
    of bytes they occupy inside the binary, and their percentage. The actual added
    code is 9 bytes and it occupies 21.95% of the total binary size.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`twiggy paths`命令显示函数的调用路径、它们在二进制文件中占用的字节数以及它们的百分比。实际添加的代码是9字节，它占整个二进制文件大小的21.95%。'
- en: 'Let''s explore various subcommands in Twiggy:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索Twiggy的各种子命令：
- en: '`top`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`'
- en: '`monos`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monos`'
- en: '`garbage`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`garbage`'
- en: top
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: top
- en: 'The `twiggy top` command will list the code size of each block. It lists, in
    descending order, the size of the function, the percentage of the size in the
    end binary and the block section:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`twiggy top`命令将列出每个代码块的大小。它按降序列出函数的大小、在最终二进制文件中的大小百分比以及块部分：'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'List the top n details using `-n` followed by the number of entries to show:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-n`后跟要显示的条目数来列出前n个详细信息：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similarly, we can format the output to JSON format using the `--format` flag:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用`--format`标志将输出格式化为JSON格式：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `top` command is extremely useful when you want to track down the biggest
    code blocks and then optimize them separately.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想追踪最大的代码块并单独优化它们时，`top`命令非常有用。
- en: monos
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: monos
- en: In the JavaScript world, monomorphization increases performance. But it also
    bloats the code size (for example, in generics). Since we have to create the implementation
    of a generic function dynamically for every type, we have to be very careful when
    using generics and monomorphic code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript世界中，单态化可以提高性能。但它也会增加代码大小（例如，在泛型中）。由于我们必须为每种类型动态创建泛型函数的实现，因此在使用泛型和单态代码时必须非常小心。
- en: 'Twiggy has a subcommand called `monos` that will list the code bloating due
    to monomorphization:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Twiggy有一个名为`monos`的子命令，它将列出由于单态化导致的代码膨胀：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are using the `index_bg.wasm` example from the *Minimizing the WebAssembly
    modules* section of this chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用本章“最小化 WebAssembly 模块”部分中的 `index_bg.wasm` 示例。
- en: '`monos` is extremely useful for us to understand the occurrence of any bloating
    caused by generic parameters, which can then be changed to a simpler function
    with generics.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`monos` 对于我们理解由泛型参数引起的任何膨胀现象非常有用，这些膨胀现象随后可以被更简单的泛型函数所替代。'
- en: garbage
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: garbage
- en: At times, it is important to find code that is not used anymore but is kept
    in the final binary due to some other reasons. These functions are referenced
    somewhere but not used anywhere and the compiler will not know when and where
    to remove them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，找到不再使用但出于某些其他原因保留在最终二进制文件中的代码是很重要的。这些函数在某个地方被引用，但未在任何地方使用，编译器将不知道何时何地删除它们。
- en: 'We can use Twiggy''s `garbage` command to list all the code and data that is
    not transitively referenced:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Twiggy 的 `garbage` 命令列出所有非传递性引用的代码和数据：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: WebAssembly modules consist of a data section. But sometimes, we might not use
    the data straight away in the WebAssembly module but in some other places where
    it is imported. As you can see here, Twiggy's `garbage` subcommand shows those
    potentially false values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 模块由一个数据部分组成。但有时，我们可能不会立即在 WebAssembly 模块中使用这些数据，而是在其他导入数据的地方使用。正如你所看到的，Twiggy
    的 `garbage` 子命令显示了这些可能错误的数据值。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to optimize the WebAssembly binary using Rust,
    how to map memory between JavaScript and Rust, and finally, how to analyze a WebAssembly
    module using Twiggy.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 Rust 优化 WebAssembly 二进制文件，如何映射 JavaScript 和 Rust 之间的内存，最后是如何使用
    Twiggy 分析 WebAssembly 模块。
- en: The WebAssembly ecosystem is still in its early days and it promises better
    performance. The WebAssembly binary addresses a few gaps in the JavaScript ecosystem,
    such as size-efficient compact binaries, enabling streaming compilation, and properly
    typed binaries. These features make WebAssembly smaller and faster. Rust, on the
    other hand, provides first-in-class support for generating a WebAssembly module
    and `wasm-bindgen` is the best tool available that makes it easier to transfer
    complex objects in Rust and WebAssembly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 生态系统仍处于早期阶段，它承诺提供更好的性能。WebAssembly 二进制文件解决了 JavaScript 生态系统中的几个差距，例如大小高效的紧凑二进制文件、启用流式编译和正确类型化的二进制文件。这些功能使
    WebAssembly 更小、更快。另一方面，Rust 提供了生成 WebAssembly 模块的一流支持，而 `wasm-bindgen` 是目前最好的工具，它使得在
    Rust 和 WebAssembly 之间传输复杂对象变得更加容易。
- en: I hope that you now understand the basics of WebAssembly and how Rust makes
    it easier to generate WebAssembly modules. I can't wait to see what you will be
    shipping with Rust and WebAssembly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你现在已经理解了 WebAssembly 的基础知识以及 Rust 如何使其生成 WebAssembly 模块变得更加容易。我迫不及待地想看看你将使用
    Rust 和 WebAssembly 发行的内容。
