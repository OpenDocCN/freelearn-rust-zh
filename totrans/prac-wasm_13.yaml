- en: '*Chapter 10*: Optimizing Rust and WebAssembly'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how Rust makes it easy to create and run WebAssembly modules
    and various tools provided by the Rust community. We will cover the following
    sections in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing the WebAssembly modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the memory model in the WebAssembly module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the WebAssembly module with Twiggy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly).
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing the WebAssembly modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`wasm-bindgen` is a complete suite that generates the binding JavaScript file
    (along with polyfills) for the WebAssembly module. In previous chapters, we saw
    how `wasm-bindgen` provides libraries and makes it easy to pass complex objects
    between JavaScript and WebAssembly. But in the WebAssembly world, it is important
    to optimize the generated binary for size and performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can further optimize the WebAssembly modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a WebAssembly application with all the necessary toolchains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This previous command creates a new Rust and JavaScript-based application with
    webpack as the bundler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the generated `wasm-rust` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Rust source files are present in the `src` directory and the JavaScript
    files are available in the `js` directory. We have webpack configured for running
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove all the code from `src/lib.rs` and replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We import `wasm_bindgen` and then enable `wee_alloc`, which does a much smaller
    memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: We go on to define the `is_palindrome` function, which takes `&str` as input
    and returns `bool`. Inside this function, we check whether the given string is
    a palindrome or not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about the difference between `&str` and `String` at [https://users.rust-lang.org/t/whats-the-difference-between-string-and-str/10177/9](https://users.rust-lang.org/t/whats-the-difference-between-string-and-str/10177/9).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remove all the lines from `js/index.js` and replace them with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are importing from `../pkg/index.js` here. The `wasm-pack` command will generate
    the `binding` file and `wasm` file inside the `pkg` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, build the application with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can run the application with the `npm run start` command. This command opens
    the browser and loads the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, open the developer tools and check the logs in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The WebAssembly module generated by the Rust compiler is not completely optimized.
    We can optimize the WebAssembly modules further. In the JavaScript world, every
    byte matters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open `Cargo.toml` and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, remove the `[profile.release]` section completely. The `[profile.dev]`
    section instructs the compiler on how to profile the code generated in the dev
    build. The `[profile.release]` section is used only for the release build.
  prefs: []
  type: TYPE_NORMAL
- en: We instruct the compiler to use `opt-level = z` for generating the code. The
    `opt-level` setting is similar to the LLVM compiler's `-O1/2/3/...`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The valid options of the `opt-level` setting are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` – no optimizations; also turns on `cfg(debug_assertions)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` – basic optimizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` – some optimizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` – all optimizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` – optimize for binary size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z` – optimize for binary size, but also turn off loop vectorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LLVM supports link-time optimizations to better optimize code by using whole
    program analysis. But link-time optimization comes at the cost of longer linking
    time. We can enable LLVMs link-time optimization using the lto option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lto supports the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`false` – performs "thin local LTO”. This means the link-time optimizations
    are done only on the local crate. Note: there will not be any link-time optimizations
    when the number of Codegen units is 1 or `opt-level` is 0\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`true` or "fat" – performs "fat" LTO. This means the link-time optimizations
    are done across all crates in the dependency graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thin` – performs "thin" LTO. This is a faster version of “fat”, that optimizes
    at a faster rate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`off` – disables LTO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, run `npm run build`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The generated WebAssembly binary is 50.8 KB. The generated binary is ~44% smaller
    in size. That is a huge win for us. We can further optimize the binary using Binaryen''s
    `wasm-opt` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It reduces another 5 KB. We have used the `-Oz` pass, but we can pass in other
    passes to further optimize the generated binary.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to minimize the WebAssembly module using Rust. Next, we will
    analyze the memory model in the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the memory model in the WebAssembly module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the JavaScript engine, WebAssembly and JavaScript run at different locations.
    Crossing the boundaries between JavaScript and WebAssembly will always have a
    cost attached to it. The browser vendors implemented cool hacks and workarounds
    to reduce this cost, but when your applications cross this boundary, this boundary
    crossing will often soon become a major performance bottleneck for your application.
    It is very important to design WebAssembly applications in a way that reduces
    boundary crossing. But once the application grows, it becomes difficult to manage
    this boundary crossing. To prevent boundary crossing, WebAssembly modules come
    with the memory module.
  prefs: []
  type: TYPE_NORMAL
- en: The memory section in the WebAssembly module is a vector of linear memories.
  prefs: []
  type: TYPE_NORMAL
- en: A linear memory model is a memory-addressing technique in which the memory is
    organized in a single contagious address space. It is also known as the Flat memory
    model.
  prefs: []
  type: TYPE_NORMAL
- en: The linear memory model makes it easier to understand, program, and represent
    the memory. But it also has huge disadvantages, such as high execution time for
    rearranging elements in memory and wasting a lot of memory area.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the memory represents a vector of raw bytes containing uninterpreted data.
    WebAssembly uses resizable array buffers to hold the raw bytes of memory. It is
    important to note that this memory that is created is accessible and mutable from
    both JavaScript and WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing memory between JavaScript and WebAssembly using Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen how to share the memory between JavaScript and WebAssembly.
    Let''s share memory using Rust in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Rust project using Cargo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the project in your favorite editor and replace `src/lib.rs` with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Rust file starts with `#![no_std]`. This instructs the compiler not to include
    the Rust Standard Library while generating the WebAssembly module. This will reduce
    the binary size a lot. Next, we define a function called `memory_to_js`. This
    function creates an `obj` in memory and shares it with JavaScript. In the function
    definition, we create a slice of `u32` called `obj`. Next, we assign some raw
    memory to `obj`. Here, we are dealing with raw memory. Hence, we wrap the code
    inside an `unsafe` block. The memory object is global and it is mutable by both
    JavaScript and WebAssembly. Hence, we use `from_raw_parts_mut` to instantiate
    the object. Finally, we assign a value to the first element in the shared array
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `index.html` file and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create an anonymous asynchronous JavaScript function that will be invoked
    as soon as the script is loaded. We fetch the WebAssembly binary inside the anonymous
    function. Next, we create `ArrayBuffer` and instantiate the module to the `result`
    object. We then call the `memory_to_js` method in the WebAssembly module (note
    the `exports` keyword, since the function is exported from the WebAssembly module).
    This instantiates the memory and assigns the first element in the shared array
    buffer to `13`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we call the memory object that is exported from WebAssembly using `result.export.memory.buffer`
    and convert it into `UInt8Array` using a new `UInt8Array()`. Next, we extract
    the first element using `slice(0,1)`. This way, we can pass and retrieve values
    between JavaScript and WebAssembly without any overhead. The memory is accessed
    via `load` and `store` binary instructions. The `load` operation copies data from
    the main memory to register. The `store` operation copies data from the main memory.
    These binary instructions are accessed with the offset and the alignment. The
    alignment is in base-2 logarithmic representation. The memory address should be
    a multiple of four. This is called alignment restriction. This alignment restriction
    makes the hardware much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that WebAssembly currently provides only a 32-bit address
    range. In the future, WebAssembly might provide a 64-bit address range.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to share memory between JavaScript and WebAssembly by creating
    the memory in Rust. Next, we will create a memory object on the JavaScript side
    and use it inside the Rust application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a memory object in JavaScript to use in the Rust application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike JavaScript, Rust is not dynamically typed. The memory created in JavaScript
    has no way to tell WebAssembly (or the Rust code) what to allocate and when to
    free them. We need to explicitly inform WebAssembly how to allocate the memory
    and, most importantly, when and how to free them (to avoid any leaks).
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `WebAssembly.memory()` constructor to create the memory in JavaScript.
    The memory constructor takes in an object to set the defaults. The object has
    the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initial` – the initial size of the memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maximum` – the maximum size of the memory (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared` – to denote whether to use the shared memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The units for `initial` and `maximum` are WebAssembly pages, where a page refers
    to 64 KB.
  prefs: []
  type: TYPE_NORMAL
- en: 'We change the HTML file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In `// -> 1`, the memory is initialized with the `WebAssembly.Memory()` constructor.
    We passed in the initial and maximum size of the memory, that is, 640 KB and 6.4
    MB, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In `// -> 2`, we're instantiating the WebAssembly module along with the memory
    object.
  prefs: []
  type: TYPE_NORMAL
- en: In `// -> 3`, we then create `typedArray` (`UInt8Array`) with values `1`, `2`,
    and `3`.
  prefs: []
  type: TYPE_NORMAL
- en: In `// -> 4`, we see how, as WebAssembly modules do not have any clue about
    the objects that are created out of the memory, the memory needs to be allocated.
    We have to manually write the allocation and freeing of memory in WebAssembly.
    In this step, we send the length of the array and allocate that memory. This gives
    us a pointer to the location of the memory.
  prefs: []
  type: TYPE_NORMAL
- en: In `// -> 5`, we create a new `typedArray` with the buffer (total available
    memory), the memory offset (`wasmAttrPtr`), and the length of the memory.
  prefs: []
  type: TYPE_NORMAL
- en: In `// -> 6`, we set the locally created `typedArray` (in *step 3*) to `typedArray`
    created in *step 5*.
  prefs: []
  type: TYPE_NORMAL
- en: In `//-> 7`, finally, we send the pointer to the memory and the length to the
    WebAssembly module, where we fetch the value from the memory by using the pointer
    to the memory and the length.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Rust side, replace the contents of `src/lib.rs` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We imported `alloc`, `dealloc`, and `Layout` from `std::alloc` and `std::mem`
    to play with the raw memory. The first function, `accumulate`, takes in `data`,
    which is the pointer where the data starts, and `len`, the length of the memory
    to read. First, we create a slice from the raw memory using `std::slice::from_raw_parts`
    by passing the pointer, `data`, and length, `len`. Note that this is an unsafe
    operation. Next, we run through the items in the array and add all the elements.
    Finally, we return the value as `i32`.
  prefs: []
  type: TYPE_NORMAL
- en: The `malloc` function is used to custom-allocate the memory since the WebAssembly
    module has no clue about the type of information sent and how to read/understand
    it. `malloc` helps us to allocate the memory as required without any panic.
  prefs: []
  type: TYPE_NORMAL
- en: Run the previous code using `python -m http.server` and load the web page in
    a browser to see the results in the developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the WebAssembly module with Twiggy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust-to-WebAssembly binaries are more likely to create a bloated binary.
    Proper care should be taken when creating WebAssembly binaries. The trade-off
    between the level of optimization, the time to compile, and various other factors
    should be considered while producing binaries. But most of the preceding work
    is done by the compiler by default. Either Emscripten or the `rustc` compiler
    ensures the elimination of dead code along with various options on the optimization
    level (`-O0` to `z`). We can choose the one that fits us.
  prefs: []
  type: TYPE_NORMAL
- en: Twiggy is a code size profiler. It uses the call graph to determine the origins
    of a function and provides meta-information about the function. The meta-information
    includes the size of each function in binary and its cost. Twiggy provides an
    overview of what is in the binary. With that information, we can optimize the
    binary further Let's install and use Twiggy to optimize the binary:.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Twiggy by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once installed, the `twiggy` command will be available in the command line,
    which we can check with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a folder to test-drive Twiggy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file called `add.wat` and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have defined the WebAssembly text format, compile it to the WebAssembly
    module using `wabt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command generates an `add.wasm` file. To get the call paths in
    the binary, run Twiggy with the `paths` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `twiggy paths` command shows the call path for the functions, the number
    of bytes they occupy inside the binary, and their percentage. The actual added
    code is 9 bytes and it occupies 21.95% of the total binary size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore various subcommands in Twiggy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`top`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monos`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`garbage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: top
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `twiggy top` command will list the code size of each block. It lists, in
    descending order, the size of the function, the percentage of the size in the
    end binary and the block section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'List the top n details using `-n` followed by the number of entries to show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can format the output to JSON format using the `--format` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `top` command is extremely useful when you want to track down the biggest
    code blocks and then optimize them separately.
  prefs: []
  type: TYPE_NORMAL
- en: monos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the JavaScript world, monomorphization increases performance. But it also
    bloats the code size (for example, in generics). Since we have to create the implementation
    of a generic function dynamically for every type, we have to be very careful when
    using generics and monomorphic code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Twiggy has a subcommand called `monos` that will list the code bloating due
    to monomorphization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `index_bg.wasm` example from the *Minimizing the WebAssembly
    modules* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`monos` is extremely useful for us to understand the occurrence of any bloating
    caused by generic parameters, which can then be changed to a simpler function
    with generics.'
  prefs: []
  type: TYPE_NORMAL
- en: garbage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At times, it is important to find code that is not used anymore but is kept
    in the final binary due to some other reasons. These functions are referenced
    somewhere but not used anywhere and the compiler will not know when and where
    to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Twiggy''s `garbage` command to list all the code and data that is
    not transitively referenced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: WebAssembly modules consist of a data section. But sometimes, we might not use
    the data straight away in the WebAssembly module but in some other places where
    it is imported. As you can see here, Twiggy's `garbage` subcommand shows those
    potentially false values.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to optimize the WebAssembly binary using Rust,
    how to map memory between JavaScript and Rust, and finally, how to analyze a WebAssembly
    module using Twiggy.
  prefs: []
  type: TYPE_NORMAL
- en: The WebAssembly ecosystem is still in its early days and it promises better
    performance. The WebAssembly binary addresses a few gaps in the JavaScript ecosystem,
    such as size-efficient compact binaries, enabling streaming compilation, and properly
    typed binaries. These features make WebAssembly smaller and faster. Rust, on the
    other hand, provides first-in-class support for generating a WebAssembly module
    and `wasm-bindgen` is the best tool available that makes it easier to transfer
    complex objects in Rust and WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you now understand the basics of WebAssembly and how Rust makes
    it easier to generate WebAssembly modules. I can't wait to see what you will be
    shipping with Rust and WebAssembly.
  prefs: []
  type: TYPE_NORMAL
