<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Hacking Macros</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Hacking Macros</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will be covering the following recipes:</p>
<ul>
<li>Building macros in Rust</li>
<li>Implementing matching in macros</li>
<li>Playing with common Rust macros</li>
<li>Implementing designators</li>
<li>Overloading macros</li>
<li>Implementing repeat</li>
<li>Implementing DRY</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Until now, we have seen many statements in Rust ending with an exclamation mark (<kbd>!</kbd>), such as <kbd>println!</kbd>, <kbd>try!</kbd>, and so on. These commands have performed powerful operations to execute specific tasks. Rust provides a powerful macro system that allows metaprogramming. Macros look like functions but their names end with an exclamation mark (<kbd>!</kbd>). Macros are expanded into source code which, gets compiled into the program. In this recipe, we will look into the various aspects of macros, ranging from defining your own application-specific macros to testing them.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building macros in Rust</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn about <kbd>macro_rules!</kbd>--the syntax that will help us define our custom application-specific macro, which can have a unique name according to the application terminology.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor to develop the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_macro.rs</kbd>, and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Building your first macro in Rust<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create a macro named <kbd>Welcome_RustBook</kbd>:</li>
</ol>
<pre class="mce-root">        // This is a simple macro named `say_hello`.<br/>        macro_rules! Welcome_RustBook {<br/>          () =&gt; (<br/>          // The macro will expand into the contents of this block.<br/>          println!("Welcome to Rust Cookbook!");<br/>          )<br/>        }
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function and call the <kbd>Welcome_RustBook</kbd> macro:</li>
</ol>
<pre class="mce-root"><span>        fn main() {</span><br/><span>          // This call will expand into`println!("Hello");`</span><br/><span>          Welcome_RustBook!()</span><br/><span>        }</span>
</pre>
<p>We will get the following output on the successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="42" width="518" class="image-border" src="images/9056cadb-1379-455d-a5d8-6fe573a8b6d6.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We use the <kbd>macro_rules!</kbd> macro to create a custom-named macro; here, we made a macro named <kbd>Welcome_RustBook!</kbd>. The general syntax of <kbd>macro_rules!</kbd> is as follows:</p>
<pre class="rust rust-example-rendered"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">macro_name</span> { ... }
</pre>
<p>Inside the <kbd>macro_rules!</kbd> macro, we match the arguments. In the case of this recipe, we do not accept any arguments from the user, so we match <kbd>()</kbd> <kbd>=&gt;</kbd> (a certain set of action items). The empty parentheses, <kbd>()</kbd>, in the code indicate that the macro takes no argument. The macro will expand into the contents of the block of no arguments at compile time, where we have <kbd>println!("Welcome to Rust Cookbook!");</kbd>, which basically prints a default statement.</p>
<p>In the main function, we call <kbd>Welcome_RustBook!</kbd> macro in the function definition, just like we would call any other macro. We will see the default statement printed in the terminal.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing matching in macros</h1>
                </header>
            
            <article>
                
<p>Let's go ahead and make our macro a bit more complex by adding more rules in our macro, the rules are basically pattern matching cases. In this recipe, the key takes-away will be to learn how we can define pattern matching cases in macro rules.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor to develop the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the mentioned steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_match.rs</kbd>, and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implement matching<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create a macro named <kbd>Check_Val</kbd>:</li>
</ol>
<pre class="mce-root"><span>        macro_rules! Check_Val {</span><br/><span>          (x =&gt; $e:expr) =&gt; (println!("mode X: {}", $e));</span><br/><span>          (y =&gt; $e:expr) =&gt; (println!("mode Y: {}", $e));</span><br/><span>        }</span>
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function and call the <kbd>Check_Val</kbd> macro:</li>
</ol>
<pre class="mce-root"><span>        fn main() {</span><br/><span>          Check_Val!(y =&gt; 3);</span><br/><span>        }</span>
</pre>
<p style="padding-left: 60px" class="mce-root">We will get the following output on the successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="36" width="487" class="image-border" src="images/5f198960-7a48-47d9-9fff-32b184e1de29.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we create a macro named <kbd>Check_Val!</kbd>, which basically plays the role as a <kbd>match</kbd> expression arm, but the matching happens through the Rust syntax trees during compilation time. The common syntax of a pattern is as follows:</p>
<pre>( $( $x:expr ),* ) =&gt; { ... };
</pre>
<p>Here, the term <em>pattern</em> refers to the left-hand side of <kbd>=&gt;</kbd>, which is known as <em>matcher</em> in Rust.</p>
<p>The <kbd>$x:expr</kbd> matcher will match any Rust expression and will bind that to syntax tree to the metavariable <kbd>$x</kbd>, any Rust tokens that appear in a matcher must match exactly.</p>
<p>We have two pattern matching cases here: <kbd>x =&gt; $e:expr</kbd> and <kbd>y =&gt; $e:expr</kbd>. The metavariable is <kbd>$e</kbd>, which is used in macro definitions for operations to be done following the successful pattern matching of a macro rule. When we call <kbd>Check_Val!(y =&gt; 3);</kbd> in the <kbd>main</kbd> function, the output is <kbd>mode Y:3</kbd>. Here the second case is passed and the value of <kbd>$e</kbd> is the same as that of the arguments passed to the <kbd>Check_Val!</kbd> macro in the <kbd>main</kbd> function.</p>
<div class="packt_tip packt_infobox">If we had called <kbd>Check-Val!(z =&gt; 3);</kbd> we would have got <kbd>error: no rules expected the token `z`</kbd>, as we haven't defined a rule for the token <kbd>z</kbd> and surrounding the matcher with <kbd>$(...),*</kbd> will match zero or more expressions, separated by commas.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Playing with common Rust macros</h1>
                </header>
            
            <article>
                
<p>Throughout this book, we have defined and used common Rust macros that will help us perform basic operations, such as printing, and so on. Rust offers these macros by default, as these are very complex to be implemented by the user. In this recipe, we will learn a few common Rust macros.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor to develop the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_common_macros.rs</kbd>, and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre class="mce-root"><span>        //-- #########################</span><br/><span>        //-- Task: Implementing common macros in rust</span><br/><span>        //-- Author: Vigneshwer.D</span><br/><span>        //-- Version: 1.0.0</span><br/><span>        //-- Date: 26 March 17</span><br/><span>        //-- #########################</span>
</pre>
<ol start="3">
<li>Create the <kbd>main</kbd> function where we implement a few inbuilt standard Rust macros:</li>
</ol>
<pre class="mce-root"><span>        fn main() {</span><br/><br/><span>          // Creating a vector </span><br/><span>          let v = vec![1, 2, 3, 4, 5];</span><br/><span>          print!("Vector :- {:?}", v);</span><br/><span>    </span><br/><span>          // Macros used for testing</span><br/><span>          assert!(true);</span><br/><span>          assert_eq!(5, 3 + 2);</span><br/><br/><span>          // assert!(5 &lt; 3);</span><br/><span>          // assert_eq!(5, 3);</span><br/><br/><span>          // Gives a message to panic</span><br/><span>          // panic!("oh no!");</span><br/><span>        }</span>
</pre>
<p>We will get the following output on successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="40" width="599" class="image-border" src="images/8790c421-3afa-4ae1-befb-351ef1a3543e.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We declared all the standard macros in the main function. Let,s deep dive into each one of them in the following order:</p>
<ul>
<li>We used the <kbd>vec!</kbd> macro to create a vector in Rust. It creates <kbd>Vec&lt;T&gt;</kbd>.</li>
</ul>
<ul>
<li>The next two macros are extensively used in tests: the first one is <kbd>assert!</kbd>, which takes a Boolean value to pass and the second one is <kbd>assert_eq!</kbd>, which takes two values and checks for their equality. The true value passes and the false one leads to the <kbd>panic!</kbd> macro, which causes the thread to panic or break.</li>
</ul>
<p>In this recipe, we have used the <kbd>Vec!</kbd> macro to create a vector, <kbd>v</kbd>. The conditions inside the <kbd>assert!</kbd> and <kbd>assert_eq!</kbd> macros pass. The failure cases have been commented out, as they would cause panic during runtime.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing designators</h1>
                </header>
            
            <article>
                
<p>Rust provides a list of designators, which help us create units, such as functions, and execute expressions in macros.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor to develop the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the mentioned steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_designator.rs</kbd>, and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implementing designator<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create a macro named <kbd>create_function</kbd>, which accepts a designator as an argument:</li>
</ol>
<pre>        macro_rules! create_function {<br/>          ($func_name:ident) =&gt; (<br/>            fn $func_name() {<br/>              // The `stringify!` macro converts an `ident`<br/>              into a string.<br/>              println!("You called {:?}()",<br/>              stringify!($func_name))<br/>            }<br/>          )<br/>        }
</pre>
<ol start="4">
<li>Call the <kbd>create_function</kbd> macro to create two functions, <kbd>foo</kbd> and <kbd>bar</kbd>:</li>
</ol>
<pre>        create_function!(foo);<br/>        create_function!(bar);
</pre>
<ol start="5">
<li>Create a macro named <kbd>print_result</kbd>:</li>
</ol>
<pre>        macro_rules! print_result {<br/>          ($expression:expr) =&gt; (<br/>          println!("{:?} = {:?}",<br/>          stringify!($expression),<br/>          $expression)<br/>          )<br/>        }
</pre>
<ol start="6">
<li>Define the <kbd>main</kbd> function, where we play around with the macros we created:</li>
</ol>
<pre>        fn main() {<br/>          foo();<br/>          bar();<br/><br/>          print_result!(1u32 + 1);<br/><br/>          // Recall that blocks are expressions too!<br/>          print_result!({<br/>          let x = 1u32;<br/><br/>          x * x + 2 * x - 1<br/>          });<br/>        }
</pre>
<p>We will get the following output on successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="74" width="504" class="image-border" src="images/ae8ce396-57b6-4596-8848-4ab739a2c959.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In general, the arguments of a macro are prefixed by a dollar sign (<kbd>$</kbd>) and a type annotated with a designator. Here, in this recipe, we have used two commonly used designators, which are <kbd>expr</kbd>, used for expressions, and <kbd>ident</kbd>, which is used for variable/function names.</p>
<p>Let's understand the two main macros that we have created to implement the designator in the Rust code:</p>
<ul>
<li><kbd>create_function</kbd>: This macro takes an argument of the <kbd>ident</kbd> designator and creates a function named <kbd>$func_name</kbd>, which is used across the code for creating the function. The <kbd>ident</kbd> designator, as mentioned previously, is used for variable/function names. Inside the block of the <kbd>($func_name:ident)</kbd>, pattern, we define the function <kbd>fn $func_name</kbd>, and we have the <kbd>stringify!</kbd> macro in its body, which converts a <kbd>$func_name</kbd> into a string.</li>
<li><kbd>print_result</kbd>: This macro takes an expression of the <kbd>expr</kbd> type and prints it as a string along with its result. The <kbd>expr</kbd> designator is used for expressions. In the block for the expression pattern, we use the <kbd>stringify!</kbd> macro, which converts the expression into a string and also executes it.</li>
</ul>
<p>We create functions named <kbd>foo</kbd> and <kbd>bar</kbd> with the preceding macro by using <kbd>create_function!(foo);</kbd> and <kbd>create_function!(bar);</kbd>. In the <kbd>main</kbd> function, where we called the two functions, that is, <kbd>foo</kbd> and <kbd>bar</kbd>, which return the string. We call <kbd>function_name</kbd>. Next, we call <kbd>print_result!</kbd>, with a block of expression as an argument, where we create a variable, <kbd>x</kbd>, and assign it a value of <kbd>1u32</kbd>, which is a 32-bit unsigned integer type. We then run <kbd>x * x + 2 * x - 1</kbd>, which gives us the output of <kbd>2</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Overloading macros</h1>
                </header>
            
            <article>
                
<p>Overloading macros in Rust is the process of providing multiple combinations of similar arguments, where we expect the macro to handle them and provide custom results according to the combination passed.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor to develop the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_overloading_macros.rs</kbd>, and open it in your text editor.</li>
<li><span>Write the code header with the relevant information:</span></li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implementing <br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create a macro named <kbd>test</kbd>, for which we will implement overloading:</li>
</ol>
<pre class="mce-root"><span>        macro_rules! test {</span><br/><br/><span>          ($left:expr; and $right:expr) =&gt; (</span><br/><span>          println!("{:?} and {:?} is {:?}",</span><br/><span>          stringify!($left),</span><br/><span>          stringify!($right),</span><br/><span>          $left &amp;&amp; $right)</span><br/><span>          );</span><br/><br/><span>          ($left:expr; or $right:expr) =&gt; (</span><br/><span>          println!("{:?} or {:?} is {:?}",</span><br/><span>          stringify!($left),</span><br/><span>          stringify!($right),</span><br/><span>          $left || $right)</span><br/><span>          );</span><br/><span>        }</span>
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function in which we'll implement the features of the macro:</li>
</ol>
<pre class="mce-root"><span>        fn main() {</span><br/><span>          test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);</span><br/><span>          test!(true; or false);</span><br/><span>        }</span>
</pre>
<p>We will get the following output on the successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="54" width="571" class="image-border" src="images/5e2f8a0d-4b1c-4e57-b993-992ed28acd69.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we create a macro named <kbd>test</kbd>, which takes two <kbd>expr</kbd> designators used for taking an expression as arguments and assigning it to two variables, <kbd>$left</kbd> and <kbd>$right</kbd>, where <kbd>$left</kbd> is assigned to the first expression and <kbd>$right</kbd>, to the second expression.</p>
<p>Inside the macros, we have two rules, which are as follows:</p>
<ul>
<li><kbd>($left:expr; and $right:expr)</kbd>: In this rule, we want to return a Boolean value. Here, we evaluate both the expressions and pass the values to the <kbd>&amp;&amp;</kbd> operator.</li>
<li><kbd>($left:expr; or $right:expr)</kbd>: In this rule, we want to return a Boolean value. Here, we evaluate both the expressions and pass the values to the <kbd>||</kbd> operator.</li>
</ul>
<div class="packt_infobox">Arguments don't need to be separated by a comma and each arm must end with a semicolon.</div>
<p>In the <kbd>main</kbd> function, we call the <kbd>test!</kbd> macro two times with different arguments, where we have the combinations. The <kbd>test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);</kbd> combination returns the string form of the expression along with the result, which is <kbd>true</kbd>; <kbd>test!(true; or false);</kbd> similarly returns <kbd>true</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing repeat</h1>
                </header>
            
            <article>
                
<p>Repeat is the ability of a particular macro to accept arguments that repeat at least once. In this recipe, you will learn the syntax to implement repeat in Rust.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor to develop the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_repeat.rs</kbd>, and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre class="mce-root"><span>        //-- #########################</span><br/><span>        //-- Task: Implementing repeat</span><br/><span>        //-- Author: Vigneshwer.D</span><br/><span>        //-- Version: 1.0.0</span><br/><span>        //-- Date: 26 March 17</span><br/><span>        //-- #########################</span>
</pre>
<ol start="3">
<li>Create a macro named <kbd>find_min</kbd>, in which we implement <kbd>repeat</kbd>:</li>
</ol>
<pre class="mce-root"><span>        macro_rules! find_min {</span><br/><span>          // Base case:</span><br/><span>          ($x:expr) =&gt; ($x);</span><br/><span>          // `$x` followed by at least one `$y,`</span><br/><span>          ($x:expr, $($y:expr),+) =&gt; (</span><br/><span>          // Call `find_min!` on the tail `$y`</span><br/><span>          std::cmp::min($x, find_min!($($y),+))</span><br/><span>          )</span><br/><span>        }</span>
</pre>
<ol start="4">
<li>Create a <kbd>main</kbd> function in which we pass multiple arguments to <kbd>find_min</kbd>:</li>
</ol>
<pre class="mce-root"><span>        fn main() {</span><br/><span>          println!("{}", find_min!(1u32));</span><br/><span>          println!("{}", find_min!(1u32 + 2 , 2u32));</span><br/><span>          println!("{}", find_min!(5u32, 2u32 * 3, 4u32));</span><br/><span>        }</span>
</pre>
<p>We will get the following output on the successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="63" width="516" class="image-border" src="images/8c2a0dbd-a0e4-49b4-9bd8-96f610c451dd.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Macros can use <kbd>+</kbd> in the argument list to indicate that an argument may repeat at least once or <kbd>*</kbd> to indicate that the argument may repeat zero or more times.</p>
<p>In the recipe, we have a macro named <kbd>find_min</kbd>, which has two rules in which the matcher with <kbd>$(...),+</kbd> will match one or more expressions, separated by commas. In the first case, we have <kbd>($x:expr)</kbd>, which just executes the expression and returns the output; this will be matched if we pass only one expression to the <kbd>find_min</kbd> macro. In the second case, we have <kbd>($x:expr, $($y:expr),+)</kbd>. Here, <kbd>$x</kbd> is followed by at least one <kbd>$y</kbd>, and inside the block, we call the <kbd>find_min!</kbd> macro on the tail <kbd>$y</kbd>; these values are fed to <kbd>std::cmp::min</kbd>, which returns the smallest value from the argument list. On the second call, it would execute the first case of the macro and return the expression.</p>
<p>In the <kbd>main</kbd> function, we run the following cases and print the results:</p>
<ul>
<li><kbd>find_min!(1u32)</kbd>: This will execute the first case and return <kbd>1</kbd></li>
<li><kbd>find_min!(1u32 + 2 , 2u32)</kbd>: This will go to the second case, where the macro will be called again for the second expression and the <kbd>min</kbd> result of those two expressions will be returned, which is <kbd>2</kbd></li>
<li><kbd>find_min!(5u32, 2u32 * 3, 4u32)</kbd>: This is similar to the second case, but here the macro will be called two times and the <kbd>min</kbd> result of all the expressions will be returned, which is <kbd>4</kbd> in this case</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing DRY</h1>
                </header>
            
            <article>
                
<p>Using Don't Repeat Yourself (DRY), in this recipe, we are going to create a test case for some basic standard arithmetic operations in Rust. The catch is, however, that we are going to work on automating them using macros and their features so that we can reduce redundant code.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor to develop the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the given steps to implement this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_dry.rs</kbd>, and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre class="mce-root"><span>        //-- #########################</span><br/><span>        //-- Task: Implementing </span><br/><span>        //-- Author: Vigneshwer.D</span><br/><span>        //-- Version: 1.0.0</span><br/><span>        //-- Date: 26 March 17</span><br/><span>        //-- #########################</span>
</pre>
<ol start="3">
<li>Call the standard operation crate:</li>
</ol>
<pre class="mce-root"><span>        use std::ops::{Add, Mul, Sub};</span>
</pre>
<ol start="4">
<li>Create a macro named <kbd>assert_equal_len</kbd>:</li>
</ol>
<pre class="mce-root"><span>        macro_rules! assert_equal_len {</span><br/><span>          ($a:ident, $b: ident, $func:ident, $op:tt) =&gt; (</span><br/><span>          assert!($a.len() == $b.len(),</span><br/><span>          "{:?}: dimension mismatch: {:?} {:?} {:?}",</span><br/><span>          stringify!($func),</span><br/><span>          ($a.len(),),</span><br/><span>          stringify!($op),</span><br/><span>          ($b.len(),));</span><br/><span>          )</span><br/><span>        }</span>
</pre>
<ol start="5">
<li>Create a macro named <kbd>op</kbd>:</li>
</ol>
<pre class="mce-root"><span>        macro_rules! op {</span><br/><span>          ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; (</span><br/><span>          fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys:<br/></span>          &amp;Vec&lt;T&gt;) {<br/>            assert_equal_len!(xs, ys, $func, $op);<br/><span>            for (x, y) in xs.iter_mut().zip(ys.iter()) {</span><br/><span>            *x = $bound::$method(*x, *y);</span><br/><span>            // *x = x.$method(*y);</span><br/><span>            }</span><br/><span>          }</span><br/><span>          )</span><br/><span>        }</span>
</pre>
<ol start="6">
<li>Implement the <kbd>add_assign</kbd>, <kbd>mul_assign</kbd>, and <kbd>sub_assign</kbd> functions:</li>
</ol>
<pre class="mce-root"><span>        op!(add_assign, Add, +=, add);</span><br/><span>        op!(mul_assign, Mul, *=, mul);</span><br/><span>        op!(sub_assign, Sub, -=, sub);</span>
</pre>
<ol start="7">
<li>Create a module named <kbd>test:mod test {</kbd>:</li>
</ol>
<pre class="mce-root"><span>        use std::iter;</span><br/><span>        macro_rules! test {</span><br/><span>          ($func: ident, $x:expr, $y:expr, $z:expr) =&gt; {</span><br/><span>            #[test]</span><br/><span>            fn $func() {</span><br/><span>              for size in 0usize..10 {</span><br/><span>                let mut x: Vec&lt;_&gt; =<br/>                iter::repeat($x).take(size).collect();</span><br/><span>                let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();</span><br/><span>                let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();</span><br/><br/><span>                super::$func(&amp;mut x, &amp;y);</span><br/><br/><span>                assert_eq!(x, z);</span><br/><span>                }</span><br/><span>              }</span><br/><span>            }</span><br/><span>          }</span><br/><br/><span>          // Test `add_assign`, `mul_assign` and `sub_assign`</span><br/><span>          test!(add_assign, 1u32, 2u32, 3u32);</span><br/><span>          test!(mul_assign, 2u32, 3u32, 6u32);</span><br/><span>          test!(sub_assign, 3u32, 2u32, 1u32);</span><br/><span>        }</span>
</pre>
<p>We will get the following output on the successful execution of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="133" width="483" class="image-border" src="images/45339c3f-4419-4064-a81b-2f4c1fcd2cab.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Macros allow developers to write DRY code by factoring out the common parts of functions and/or test suites. In this recipe, we implemented tested for the <kbd>+=</kbd>, <kbd>*=</kbd>, and <kbd>-=</kbd> operators on <kbd>Vec&lt;T&gt;</kbd>. We have used a new designator in this recipe, <kbd>tt</kbd>; which stands for token tree and is used for operators and tokens.</p>
<p>Let's first understand all the functional macro units in the code:</p>
<ul>
<li><kbd>assert_equal_len</kbd>: This macro takes in four arguments as inputs, which are <kbd>$a</kbd>, <kbd>$b</kbd>, and <kbd>$func</kbd>, of the <kbd>ident</kbd> type, and <kbd>$op</kbd> of the <kbd>tt</kbd> type. If the macro receives these arguments, then it will check whether <kbd>$a</kbd> and <kbd>$b</kbd> are of the same length by using the <kbd>len()</kbd> method inside the <kbd>assert!</kbd> macro, which will return a Boolean value of <kbd>true</kbd> in the case of success or else, it prints a failure statement saying <kbd>dimension mismatch</kbd>.</li>
<li><kbd>op</kbd>: This macro takes in four arguments as input, which are <kbd>$func</kbd>, <kbd>$bound</kbd>, and <kbd>$method</kbd>, of the <kbd>ident</kbd> type, and <kbd>$op</kbd> of the <kbd>tt</kbd> type. We create the corresponding operator function with this macro, where <kbd>$func</kbd> is the name of the function and is the first argument in the list, with two arguments of the <kbd>Vec&lt;T&gt;</kbd> type: <kbd>xs</kbd> and <kbd>ys</kbd>. Both the variables are shared with the macros, and <kbd>xs</kbd> is provided with a mutable permission while it is shared. Inside the function, we perform the operation with <kbd>$bound::$method</kbd> for all the values of the vectors <kbd>xs</kbd> and <kbd>ys</kbd>, and the results are stored in <kbd>x</kbd> as it has mutable access. Here, <kbd>$bound</kbd> is the standard module and its <kbd>$method</kbd> corresponds to its unit. With this macro, we are able to perform a lot of methods on the data passed, which reduces the code.</li>
<li><kbd>test</kbd>: This macro takes in four arguments as input, which are <kbd>$func</kbd>, of the <kbd>ident</kbd> type, and <kbd>$x</kbd>, <kbd>$y</kbd>, and <kbd>$z</kbd>, which are <kbd>expr</kbd> of the <kbd>ident</kbd> type, and are present inside the <kbd>test</kbd> module, which is invoked while we run our test cases. Inside the <kbd>test</kbd> macro, we create the function with the name of <kbd>$func</kbd>. By doing so, it will become a function or unit of the parent <kbd>test</kbd> module. We iterate across the values to create vectors in which we perform <kbd>super::$func(&amp;mut x, &amp;y)</kbd>. The <kbd>super</kbd> here refers to the function that we created by using the <kbd>op</kbd> macro, which updates the value of <kbd>x</kbd> based on the operation we wanted to perform. In the last step, we validate <kbd>test</kbd> by comparing the updated <kbd>x</kbd> vector with the <kbd>z</kbd> vector, which is the desired value. The <kbd>assert_eq!</kbd> macro will return <kbd>true</kbd> if the values match; else it will panic out.</li>
</ul>
<p>In this code, we use a certain set of standard libraries, which are <kbd>ops</kbd> and <kbd>item</kbd>. First, we create the different operations that we want to implement, so we call the <kbd>op!</kbd> and create <kbd>add_assign</kbd>, <kbd>mul_assign</kbd>, and <kbd>sub_assign</kbd>. Later in the test module, we call the test case for the different functions that we have created. Here, we give all the cases for passing and run the <kbd>--test</kbd> option <span>during</span> compilation to run the test cases.</p>


            </article>

            
        </section>
    </div>
</body>
</html>