<html><head></head><body>
		<div id="_idContainer191">
			<h1 id="_idParaDest-305" class="chapter-number"><a id="_idTextAnchor306"/>16</h1>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor307"/>Building Protocols on Top of TCP</h1>
			<p>In the previous chapter, we used the Tokio framework to support an async actor model. Our Tokio framework accepted basic traffic and then sent those messages to actors once the messages were processed. However, our TCP processing was basic. You should not be comfortable building complex systems on this basic TCP process if this book is the only exposure you have had to TCP. In this chapter, we will completely focus on how to package, send, and read data over a <span class="No-Break">TCP connection.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Setting up a TCP client and <span class="No-Break">echo server</span></li>
				<li>Processing bytes over TCP <span class="No-Break">using structs</span></li>
				<li>Creating frames to separate messages <span class="No-Break">over TCP</span></li>
				<li>Building an HTTP frame on top <span class="No-Break">of TCP</span></li>
			</ul>
			<p>By the end of this chapter, you will be able to package, send, and read data sent over TCP using a range of different approaches. You will be able to understand how to split your data into frames that can be handled as structs. Finally, you will be able to build an HTTP frame that has a header containing the URL and method, and a body containing data. This will enable you to build whatever data structure you require when sending data <span class="No-Break">over TCP.</span></p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor308"/>Technical requirements</h1>
			<p>In this chapter, we will be purely focusing on how to process data over a TCP connection. Therefore, we will not be relying on any previous code as we are building our own <span class="No-Break">echo server.</span></p>
			<p>The code for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter16"><span class="No-Break">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter16</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor309"/>Setting up our TCP client and server</h1>
			<p>To explore sending<a id="_idIndexMarker1359"/> and processing<a id="_idIndexMarker1360"/> bytes over TCP, we will create a basic echo server and client. We will be dropping any complex logic that we built in the previous chapter because we do not need the distraction of the complex logic when trying to explore the ideas around sending, receiving, and <span class="No-Break">processing bytes.</span></p>
			<p>In a new directory, we should have two cargo projects – one for the server and another for the client. They can take the following <span class="No-Break">file structure:</span></p>
			<pre class="source-code">
├── client
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── server
    ├── Cargo.toml
    └── src
        └── main.rs</pre>
			<p>Both projects will be using the same dependency of Tokio, so both projects should have the following dependency defined in their <span class="No-Break"><strong class="source-inline">Cargo.toml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
[dependencies]
tokio = { version = "1", features = ["full"] }</pre>
			<p>We now need to construct the basic mechanism of an echo server. This is where a message is sent to the server from the client. The server then processes the message sent by the client, re-packages the message, and sends the same message back to the client. We will start by building out <span class="No-Break">our server.</span></p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor310"/>Setting up our TCP server</h2>
			<p>We can define<a id="_idIndexMarker1361"/> the server in the <strong class="source-inline">server/src/main.rs</strong> file by initially importing everything we need with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use tokio::net::TcpListener;
use tokio::io::{BufReader, AsyncBufReadExt, AsyncWriteExt};</pre>
			<p>This is so we can listen<a id="_idIndexMarker1362"/> to incoming TCP traffic, read bytes from that traffic, and write it back to the client sending the message. Then, we need to utilize the Tokio runtime to listen to incoming traffic, spinning up a thread if we get a message. If you completed the previous chapter, this is a good opportunity for you to attempt to do this yourself as we covered the concepts needed to create a TCP server listening for <span class="No-Break">incoming traffic.</span></p>
			<p>If you have attempted to write the basics for your TCP server, your code should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:8080".to_string();
    let socket = TcpListener::bind(&amp;addr).await.unwrap();
    println!("Listening on: {}", addr);
    while let Ok((mut stream, peer)) =
        socket.accept().await {
        println!("Incoming connection from: {}",
                  peer.to_string());
        tokio::spawn(async move {
            . . .
        });
    }
}</pre>
			<p>Here, we should be familiar with the concept that we create a listener, bind it to an address, and then wait for incoming messages, creating a thread when a message is sent. Inside the thread, we loop<a id="_idIndexMarker1363"/> through the incoming message until there is a new line with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
println!("thread starting {} starting", peer.to_string());
let (reader, mut writer) = stream.split();
let mut buf_reader = BufReader::new(reader);
let mut buf = vec![];
loop {
    match buf_reader.read_until(b'\n', &amp;mut buf).await {
        Ok(n) =&gt; {
            if n == 0 {
                println!("EOF received");
                break;
            }
            let buf_string = String::from_utf8_lossy(&amp;buf);
            writer.write_all(buf_string.as_bytes())
                .await.unwrap();
            buf.clear();
        },
        Err(e) =&gt; println!("Error receiving message: {}", e)
    }
}
println!("thread {} finishing", peer.to_string());</pre>
			<p>This code should not be a surprise by now. If you are unfamiliar with any of the concepts the preceding code covers, it is advised that you read the <span class="No-Break">previous chapter.</span></p>
			<p>We now have a basic echo server defined, and it is ready to run, which means we can turn our attention to creating our client code in the <strong class="source-inline">client/src/main.rs</strong> file. The same structs and traits will be needed to get the client working. Then, we need to send a standard text message<a id="_idIndexMarker1364"/> to the TCP server. This is a good time to try and implement the client yourself, and there is nothing that has not been covered multiple times before to build <span class="No-Break">the client.</span></p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor311"/>Setting up our TCP client</h2>
			<p>If you attempted to build<a id="_idIndexMarker1365"/> the client yourself, you should have imported the following structs <span class="No-Break">and traits:</span></p>
			<pre class="source-code">
use tokio::net::TcpStream;
use tokio::io::{BufReader, AsyncBufReadExt, AsyncWriteExt};
use std::error::Error;</pre>
			<p>Then, we must make the TCP connection, send a message, wait for the message to be sent back, and then print it out using the <span class="No-Break">Tokio runtime:</span></p>
			<pre class="source-code">
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut stream =
        TcpStream::connect("127.0.0.1:8080").await?;
    let (reader, mut writer) = stream.split();
    println!("stream starting");
    writer.write_all(b"this is a test\n").await?;
    println!("sent data");
    let mut buf_reader = BufReader::new(reader);
    let mut buf = vec![];
    println!("reading data");
    let _ = buf_reader.read_until(b'\n', &amp;mut
        buf).await.unwrap();
    let message = String::from_utf8_lossy(&amp;buf);
    println!("{}", message);
    Ok(())
}</pre>
			<p>We now have a functioning client and server. To test if the client and server are working, we must start the server in one terminal, and then run the client in another terminal by running <strong class="source-inline">cargo run</strong>. The server will have the <span class="No-Break">following printout:</span></p>
			<pre class="console">
stream starting
sent data
reading data
this is a test</pre>
			<p>Our server printout will have the <span class="No-Break">following printout:</span></p>
			<pre class="console">
Listening on: 127.0.0.1:8080
Incoming connection from: 127.0.0.1:60545
thread starting 127.0.0.1:60545 starting
EOF received
thread 127.0.0.1:60545 finishing</pre>
			<p>With that, we have a basic echo server<a id="_idIndexMarker1366"/> and client working. We can now focus on packaging, unpacking, and processing bytes. In the next section, we will explore the basic method of using structs to standardize <span class="No-Break">processing messages.</span></p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor312"/>Processing bytes using structs</h1>
			<p>In the previous<a id="_idIndexMarker1367"/> chapter, we were sending<a id="_idIndexMarker1368"/> strings to the server. However, the result is that we had to parse individual values into the type that we needed. As string parsing was not well structured, it is not clear to other developers what structure our messages are. We can make our message structure clearer by defining a struct that can be sent over the TCP channel. Sending a struct over a TCP channel can be achieved by converting the message struct into a binary format before sending the struct itself. This is also known as serializing<a id="_idIndexMarker1369"/> <span class="No-Break">the data.</span></p>
			<p>If we are to convert a struct into a binary format, first, we will need to utilize the <strong class="source-inline">serde</strong> and <strong class="source-inline">bincode</strong> crates. With our new crates, both the client and server <strong class="source-inline">Cargo.toml</strong> file should contain the <span class="No-Break">following dependencies:</span></p>
			<pre class="source-code">
[dependencies]
serde = { version = "1.0.144", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
bincode = "1.3.3"</pre>
			<p>The <strong class="source-inline">serde</strong> crate will be used to serialize the struct, while the <strong class="source-inline">bincode</strong> crate will be used to convert our message struct into a binary format. Now that our dependencies have been defined, we can start creating a message <span class="No-Break">sender client.</span></p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor313"/>Creating a message sender client</h2>
			<p>We can build<a id="_idIndexMarker1370"/> out our <strong class="source-inline">client/src/main.rs</strong> file to send structs over TCP. First, we must import what <span class="No-Break">we need:</span></p>
			<pre class="source-code">
. . .
use serde::{Serialize, Deserialize};
use bincode;</pre>
			<p>With our imports ready, we can define our <strong class="source-inline">Message</strong> struct with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[derive(Serialize, Deserialize, Debug)]
struct Message {
    pub ticker: String,
    pub amount: f32
}</pre>
			<p>The definition of our <strong class="source-inline">Message</strong> struct takes a similar<a id="_idIndexMarker1371"/> form to the structs that we use to process the JSON bodies of HTTP requests on our Actix server. However, this time, we will not be using the Actix Web structs and traits to process <span class="No-Break">the struct.</span></p>
			<p>Our <strong class="source-inline">Message</strong> struct can now be used in our <strong class="source-inline">main</strong> function. Remember that inside our <strong class="source-inline">main</strong> function, we have a TCP stream that was created by the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
let (reader, mut writer) = stream.split();</pre>
			<p>Now that we have made a connection, we can create our <strong class="source-inline">Message</strong> struct and convert the <strong class="source-inline">Message</strong> struct into <span class="No-Break">binary format:</span></p>
			<pre class="source-code">
let message = Message{ticker: String::from("BYND"),
                      amount: 3.2};
let message_bin = bincode::serialize(&amp;message).unwrap();</pre>
			<p>Our <strong class="source-inline">Message</strong> struct is now in binary format. Then, we must send our message over the TCP stream with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
println!("stream starting");
writer.write_all(&amp;message_bin).await?;
writer.write_all(b"\n").await?;
println!("sent data");</pre>
			<p>Note that we have sent the message and then a new line. This is because our server is going to read until there is a new line. If we do not send the new line, then the program will hang and <span class="No-Break">never complete.</span></p>
			<p>Now that we have sent our message, we can wait until we see receive the message back again. Then, we must construct the <strong class="source-inline">Message</strong> struct from the binary format and print out the constructed <strong class="source-inline">Message</strong> struct with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let mut buf_reader = BufReader::new(reader);
let mut buf = vec![];
println!("reading data");
let _ = buf_reader.read_until(b'\n',
    &amp;mut buf).await.unwrap();
println!("{:?}", bincode::deserialize::&lt;Message&gt;(&amp;buf));</pre>
			<p>Our client<a id="_idIndexMarker1372"/> is now ready to send a message to <span class="No-Break">the server.</span></p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor314"/>Processing messages in the server</h2>
			<p>When it comes to updating<a id="_idIndexMarker1373"/> our server<a id="_idIndexMarker1374"/> code, we will aim to unpack the message, print out the message, and then convert the message into binary format to be sent back to the client. At this stage, you should be able to implement the change yourself. This is a good opportunity to revise what we <span class="No-Break">have covered.</span></p>
			<p>If you did attempt to implement the processing of the message on the server in the <strong class="source-inline">server/src/main.rs</strong> file first, you should have imported the following <span class="No-Break">additional requirements:</span></p>
			<pre class="source-code">
use serde::{Serialize, Deserialize};
use bincode;</pre>
			<p>Then, you should have defined the <strong class="source-inline">Message</strong> struct, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
#[derive(Serialize, Deserialize, Debug)]
struct Message {
    pub ticker: String,
    pub amount: f32
}</pre>
			<p>Now, we only need to process the message, print out the message, and then return the message to the client. We can manage<a id="_idIndexMarker1375"/> all the processes with the message in the loop<a id="_idIndexMarker1376"/> inside the thread with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let message =
    bincode::deserialize::&lt;Message&gt;(&amp;buf).unwrap();
println!("{:?}", message);
let message_bin = bincode::serialize(&amp;message).unwrap();
writer.write_all(&amp;message_bin).await.unwrap();
writer.write_all(b"\n").await.unwrap();
buf.clear();</pre>
			<p>Here, we are using the same approach that we used in the client but vice versa – that is, we convert from binary format first and then convert into binary format at <span class="No-Break">the end.</span></p>
			<p>If we run our server and then our client, our server will give us the <span class="No-Break">following printout:</span></p>
			<pre class="console">
Listening on: 127.0.0.1:8080
Incoming connection from: 127.0.0.1:50973
thread starting 127.0.0.1:50973 starting
Message { ticker: "BYND", amount: 3.2 }
EOF received
thread 127.0.0.1:50973 finishing</pre>
			<p>Our client gives us the <span class="No-Break">following printout:</span></p>
			<pre class="console">
stream starting
sent data
reading data
Ok(Message { ticker: "BYND", amount: 3.2 })</pre>
			<p>Here, we can see that our <strong class="source-inline">Message</strong> struct can be sent, received, and then sent back again without any compromise. This gives our TCP traffic another level of sophistication as we can have more complex structures for our messages. For instance, one field of our message could be a HashMap, and another field of the message could be a vector of another struct if the struct in the vector has implemented the <strong class="source-inline">serde</strong> traits. We can chop and change the structure of our <strong class="source-inline">Message</strong> struct without having to rewrite our protocol for unpacking and packing a message. Other developers can merely look at our <strong class="source-inline">Message</strong> struct and know<a id="_idIndexMarker1377"/> what is being sent<a id="_idIndexMarker1378"/> over the TCP channel. Now that we have improved how we send messages over TCP, we can chunk our stream into frames <span class="No-Break">with framing.</span></p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor315"/>Utilizing framing</h1>
			<p>So far, we are sending structs over TCP<a id="_idIndexMarker1379"/> and separating these messages with a new line. Essentially, this is the most basic form of framing. However, there are some drawbacks. We must remember to put in a delimiter such as a new line; otherwise, our program will hang indefinitely. We also run the risk of prematurely splitting the message into two messages by having a delimiter in the data of the message. For instance, when we split our messages up with the new line delimiter, it is not inconceivable to have a chunk of text in a message that has new lines or any special character or byte to denote the need to separate the stream into serializable packages. To prevent such issues, we can use the built-in framing support that <span class="No-Break">Tokio provides.</span></p>
			<p>In this section, we will be rewriting the client and server as the sending and receiving of messages will change. If we try and insert our new approach into existing code of the client, it can easily lead to confusion. Before we write our client and server, we must update the dependencies in the <strong class="source-inline">Cargo.toml</strong> file of both the client <span class="No-Break">and server:</span></p>
			<pre class="source-code">
[dependencies]
tokio-util = {version = "0.7.4", features = ["full"] }
serde = { version = "1.0.144", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
futures = "0.3.24"
bincode = "1.3.3"
bytes = "1.2.1"</pre>
			<p>Here, we are using a couple more crates. We will cover their needs as we go through the rest of the code in this section. To get to grips<a id="_idIndexMarker1380"/> with framing, we will start with a simple task, which is rewriting our client so that it <span class="No-Break">supports framing.</span></p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor316"/>Rewriting our client so that it supports framing</h2>
			<p>Remember we are writing<a id="_idIndexMarker1381"/> our entire client<a id="_idIndexMarker1382"/> in the <strong class="source-inline">client/src/main.rs</strong> file. First, we must import what we need from Tokio with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use tokio::net::TcpStream;
use tokio_util::codec::{BytesCodec, Decoder};</pre>
			<p><strong class="source-inline">TcpStream</strong> is for connecting to our server. The <strong class="source-inline">BytesCodec</strong> struct is for shipping raw bytes through connections. We will be using the <strong class="source-inline">BytesCodec</strong> struct to configure the framing. <strong class="source-inline">Decoder</strong> is a trait that decodes bytes that we accept through our connection. However, when it comes to sending data through a connection, we could pass in structs, strings, or anything else that must be converted into bytes. Therefore, we must inspect what is implemented for the <strong class="source-inline">BytesCodec</strong> struct by looking at the source code for <strong class="source-inline">BytesCodec</strong>. The source code can be inspected by looking at the documentation or merely control-clicking or hovering over the <strong class="source-inline">BytesCodec</strong> struct in your editor. When we inspect the source code of the <strong class="source-inline">BytesCodec</strong> struct, we will see the following <span class="No-Break"><strong class="source-inline">Encode</strong></span><span class="No-Break"> implementations:</span></p>
			<pre class="source-code">
impl Encoder&lt;Bytes&gt; for BytesCodec {
    . . .
}
impl Encoder&lt;BytesMut&gt; for BytesCodec {
    . . .
}</pre>
			<p>Here, we can only send <strong class="source-inline">Bytes</strong> or <strong class="source-inline">BytesMut</strong> through a connection using a <strong class="source-inline">BytesCodec</strong> struct. We could implement <strong class="source-inline">Encode</strong> for <strong class="source-inline">BytesCodec</strong> for sending other types of data; however, for our use case, this is excessive, and it just makes sense to send <strong class="source-inline">Bytes</strong> over our connection. However, before we write any more code, we might as well inspect the <strong class="source-inline">Bytes</strong> implementation to get an appreciation for how framing works. The implementation of <strong class="source-inline">Encode</strong> for <strong class="source-inline">Bytes</strong> takes the <span class="No-Break">following form:</span></p>
			<pre class="source-code">
impl Encoder&lt;Bytes&gt; for BytesCodec {
    type Error = io::Error;
    fn encode(&amp;mut self, data: Bytes, buf: &amp;mut BytesMut)
              -&gt; Result&lt;(), io::Error&gt; {
        buf.reserve(data.len());
        buf.put(data);
        Ok(())
    }
}</pre>
			<p>Here, we can see<a id="_idIndexMarker1383"/> that the length of the data being passed is reserved<a id="_idIndexMarker1384"/> in the buffer. The data is then put into <span class="No-Break">the buffer.</span></p>
			<p>Now that we understand how we are going to encode and decode our messages using framing, we need to import traits from both the <strong class="source-inline">futures</strong> and <strong class="source-inline">bytes</strong> crates to enable us to process <span class="No-Break">our messages:</span></p>
			<pre class="source-code">
use futures::sink::SinkExt;
use futures::StreamExt;
use bytes::Bytes;</pre>
			<p>The <strong class="source-inline">SinkExt</strong> and <strong class="source-inline">StreamExt</strong> traits essentially enable us to receive messages from the stream asynchronously. The <strong class="source-inline">Bytes</strong> struct will wrap our serialized message to be sent. Then, we must import the traits to enable the serialization of messages and define our <span class="No-Break">message struct:</span></p>
			<pre class="source-code">
use serde::{Serialize, Deserialize};
use bincode;
use std::error::Error;
#[derive(Serialize, Deserialize, Debug)]
struct Message {
    pub ticker: String,
    pub amount: f32
}</pre>
			<p>We now have everything<a id="_idIndexMarker1385"/> we need to start working<a id="_idIndexMarker1386"/> on our runtime. Remember that our main runtime has the <span class="No-Break">following outline:</span></p>
			<pre class="source-code">
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    . . .
    Ok(())
}</pre>
			<p>Inside our runtime, we initially make a TCP connection and define the framing with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let stream = TcpStream::connect("127.0.0.1:8080").await?;
let mut framed = BytesCodec::new().framed(stream);</pre>
			<p>Then, we define our message, serialize the message, and then wrap the message in <strong class="source-inline">Bytes</strong> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let message = Message{ticker: String::from("BYND"),
                      amount: 3.2};
let message_bin = bincode::serialize(&amp;message).unwrap();
let sending_message = Bytes::from(message_bin);</pre>
			<p>Then, we can send our message, wait for the message to be sent back, and then deserialize the message to print it out with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
framed.send(sending_message).await.unwrap();
let message = framed.next().await.unwrap().unwrap();
let message =
    bincode::deserialize::&lt;Message&gt;(&amp;message).unwrap();
println!("{:?}", message);</pre>
			<p>With all this, our client<a id="_idIndexMarker1387"/> is built. We can see that we do not have to worry<a id="_idIndexMarker1388"/> about new lines or any other delimiters. Our code is clean and straightforward when it comes to sending and receiving messages over TCP. Now that our client has been built, we can move on to building our server so that it <span class="No-Break">handles framing.</span></p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor317"/>Rewriting our server so that it supports framing</h2>
			<p>When it comes to building<a id="_idIndexMarker1389"/> our server to support<a id="_idIndexMarker1390"/> framing, there is a lot of overlap with what we have coded in the previous section. At this point, it is a good time to try and build the server yourself. Building the server requires implementing the framing logic that we coded in the previous section into the existing <span class="No-Break">server code.</span></p>
			<p>If you attempted to rewrite the server, first, you should have imported the following structs <span class="No-Break">and traits:</span></p>
			<pre class="source-code">
use tokio::net::TcpListener;
use tokio_util::codec::{BytesCodec, Decoder};
use futures::StreamExt;
use futures::sink::SinkExt;
use bytes::Bytes;
use serde::{Serialize, Deserialize};
use bincode;</pre>
			<p>Note that the <strong class="source-inline">Decoder</strong> trait that we imported allows us to call <strong class="source-inline">.framed</strong> on the bytes codec. There is nothing here that should be new to you. Once we have the necessary imports, we must define the same <strong class="source-inline">Message</strong> struct with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[derive(Serialize, Deserialize, Debug)]
struct Message {
    pub ticker: String,
    pub amount: f32
}</pre>
			<p>Now, we must define<a id="_idIndexMarker1391"/> the outline of the server runtime<a id="_idIndexMarker1392"/> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:8080".to_string();
    let listener = TcpListener::bind(&amp;addr).await.unwrap();
    println!("Listening on: {}", addr);
    loop {
        let (socket, _) = listener.accept().await.unwrap();
        tokio::spawn(async move {
            . . .
        });
    }
}</pre>
			<p>Here, we can see that the listener is looping to accept traffic and spawning threads when messages are received, as in previous server implementations. Inside our thread, we read our framed message with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let mut framed = BytesCodec::new().framed(socket);
let message = framed.next().await.unwrap();
    match message {
        Ok(bytes) =&gt; {
            . . .
        },
        Err(err) =&gt; println!("Socket closed with error:
                              {:?}", err),
    }
println!("Socket received FIN packet and closed
           connection");</pre>
			<p>As we can see, we do not have a <strong class="source-inline">while</strong> loop anymore. This is because our framing manages the splitting <span class="No-Break">between messages.</span></p>
			<p>Once we have extracted<a id="_idIndexMarker1393"/> our bytes from our connection, we must implement<a id="_idIndexMarker1394"/> the same logic that we did in our client, where we process our message, print it out, process it again, and then send it back to <span class="No-Break">the client:</span></p>
			<pre class="source-code">
let message =
    bincode::deserialize::&lt;Message&gt;(&amp;bytes).unwrap();
println!("{:?}", message);
let message_bin = bincode::serialize(&amp;message).unwrap();
let sending_message = Bytes::from(message_bin);
framed.send(sending_message).await.unwrap();</pre>
			<p>We now have a working client and server that utilizes framing. If we were to start the server and then run the client, the client will give us the <span class="No-Break">following printout:</span></p>
			<pre class="console">
Message { ticker: "BYND", amount: 3.2 }</pre>
			<p>Our server will give us the <span class="No-Break">following printout:</span></p>
			<pre class="console">
Listening on: 127.0.0.1:8080
Message { ticker: "BYND", amount: 3.2 }
Socket received FIN packet and closed connection</pre>
			<p>Our server and client<a id="_idIndexMarker1395"/> now support framing. We have<a id="_idIndexMarker1396"/> come a long way. Now, we only have one more concept to explore in this chapter, and this is building an HTTP frame <span class="No-Break">using TCP.</span></p>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor318"/>Building an HTTP frame on top of TCP</h1>
			<p>Before we explored the Tokio framework<a id="_idIndexMarker1397"/> in this book, we used HTTP<a id="_idIndexMarker1398"/> to send and receive data to and from servers. The HTTP protocol is essentially built on top of TCP. In this section, while we will create an HTTP frame, we will not mimic the HTTP protocol completely. Instead, to prevent excessive code, we will create a basic HTTP frame to understand the mechanisms utilized when creating an HTTP frame. It also must be stressed that this is for educational purposes. TCP is good for our protocols, but if you want to use HTTP handlers, it is quicker, safer, and less error-prone to use out-of-the-box HTTP handlers such as Hyper. We will cover how to use Hyper HTTP handlers with Tokio in the <span class="No-Break">next chapter.</span></p>
			<p>When it comes to an HTTP request, a request generally has a header and a body. When we send over a request, the header will tell us what method is being used and the URL associated with the request. To define our HTTP frame, we need the same structs defining the frame on both the server and client. Therefore, we must have the same code for the <strong class="source-inline">client/src/http_frame.rs</strong> and <strong class="source-inline">server/src/http_frame.rs</strong> files. First, we must import the serialization traits that are needed with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use serde::{Serialize, Deserialize};</pre>
			<p>Then, we must define our HTTP frame with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[derive(Serialize, Deserialize, Debug)]
pub struct HttpFrame {
    pub header: Header,
    pub body: Body
}</pre>
			<p>As we can see, we have defined a header and body within our <strong class="source-inline">HttpFrame</strong> struct. We define the header and body structs with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[derive(Serialize, Deserialize, Debug)]
pub struct Header {
    pub method: String,
    pub uri: String,
}
#[derive(Serialize, Deserialize, Debug)]
pub struct Body {
    pub ticker: String,
    pub amount: f32,
}</pre>
			<p>Our basic HTTP frame<a id="_idIndexMarker1399"/> is now complete, and we<a id="_idIndexMarker1400"/> can import the HTTP frame into the <strong class="source-inline">main.rs</strong> file of both the client and server with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
mod http_frame;
use http_frame::{HttpFrame, Header, Body};</pre>
			<p>We will start by sending our HTTP frame in the <strong class="source-inline">main.rs</strong> file of our client with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let stream = TcpStream::connect("127.0.0.1:8080").await?;
let mut framed = BytesCodec::new().framed(stream);
let message = HttpFrame{
    header: Header{
        method: "POST".to_string(),
        uri: "www.freshcutswags.com/stock/purchase".to_string()
    },
    body: Body{
        ticker: "BYND".to_string(),
        amount: 3.2,
    }
};
let message_bin = bincode::serialize(&amp;message).unwrap();
let sending_message = Bytes::from(message_bin);
framed.send(sending_message).await.unwrap();</pre>
			<p>We can see that our HTTP frame<a id="_idIndexMarker1401"/> is starting to look like an HTTP request that we would handle<a id="_idIndexMarker1402"/> when receiving requests in our Actix servers. For the <strong class="source-inline">main.rs</strong> file in our server, there is little change. All we must do is redefine the struct that is being deserialized with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let message = bincode::deserialize::&lt;HttpFrame&gt;(&amp;bytes).unwrap();
println!("{:?}", message);
let message_bin = bincode::serialize(&amp;message).unwrap();
let sending_message = Bytes::from(message_bin);
framed.send(sending_message).await.unwrap();</pre>
			<p>We now have a basic HTTP frame that we can use to send information. If we were to run our server and then client programs, we would get the following printout for <span class="No-Break">the server:</span></p>
			<pre class="console">
Listening on: 127.0.0.1:8080
HttpFrame { header: Header {
                method: "POST",
                uri: "www.freshcutswags.com/stock/purchase"
            },
            body: Body {
                ticker: "BYND",
                amount: 3.2
            }
        }
Socket received FIN packet and closed connection</pre>
			<p>Our client program will then give us the <span class="No-Break">following printout:</span></p>
			<pre class="console">
HttpFrame { header: Header {
                method: "POST",
                uri: "www.freshcutswags.com/stock/purchase"
            },
            body: Body {
                ticker: "BYND",
                amount: 3.2
            }
        }</pre>
			<p>We can see that there is no corruption<a id="_idIndexMarker1403"/> in our data. We have now covered<a id="_idIndexMarker1404"/> all the core essential approaches and methods needed to be versatile in packaging, sending, and reading data <span class="No-Break">over TCP.</span></p>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor319"/>Summary</h1>
			<p>In this chapter, we built a basic TCP client that sends and receives data to an echo server. We started by sending over basic string data and separating the messages with delimiters. Then, we increased the complexity of the data that we sent over a TCP connection by serializing structs. This enabled us to have more complex data structures. This serialization also reduced the handling needed to get the message data in the format that we needed it to be in. For instance, in the previous chapter, we were parsing strings into floats after receiving the message. With structs, nothing is stopping us from having a list of floats as a field, and after the serialization of the message, we would have that field housing a list of floats without any extra lines <span class="No-Break">of code.</span></p>
			<p>The serialization of structs is enough for us to handle most problems, but we explored framing so that we did not have to rely on delimiters to separate the messages that we send over TCP. With framing, we built a basic HTTP frame to visualize what we can do with frames and how HTTP is built on top of TCP. We must remember that implementing an HTTP protocol is more complicated than what we did in this chapter, and it is advised that we utilize established HTTP handlers from crates to handle and process <span class="No-Break">HTTP traffic.</span></p>
			<p>In the next chapter, we will use the established Hyper crate to handle HTTP traffic with the Tokio <span class="No-Break">runtime framework.</span></p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor320"/>Further reading</h1>
			<p>Tokio framing <span class="No-Break">documentation: </span><a href="https://tokio.rs/tokio/tutorial/framing"><span class="No-Break">https://tokio.rs/tokio/tutorial/framing</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor321"/>Questions</h1>
			<ol>
				<li>What is the advantage of framing over using <span class="No-Break">a delimiter?</span></li>
				<li>Why did we wrap our serialized message in a <span class="No-Break"><strong class="source-inline">Bytes</strong></span><span class="No-Break"> struct?</span></li>
				<li>How would we be able to send over a string as <span class="No-Break">a frame?</span></li>
			</ol>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor322"/>Answers</h1>
			<ol>
				<li value="1">If we use a delimiter such as a new line, the data that we send over TCP might contain a new line in the message. The problem with having a new line in the message means that the message is split before the end of the message is received. Framing gets rid of <span class="No-Break">this issue.</span></li>
				<li>We had to wrap our serialized message in a <strong class="source-inline">Bytes</strong> struct because the <strong class="source-inline">Encode</strong> trait is not implemented for any other <span class="No-Break">data type.</span></li>
				<li>The simplest way to do this is to implement the <strong class="source-inline">Encode</strong> trait for a string. When implementing the <strong class="source-inline">Encode</strong> trait, we serialize the string and then wrap the string into a <strong class="source-inline">Bytes</strong> struct, reserve the length of the serialized string in the buffer, and then place the serialized string in <span class="No-Break">the buffer.</span></li>
			</ol>
		</div>
	</body></html>