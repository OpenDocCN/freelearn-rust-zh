<html><head></head><body>
		<div><h1 id="_idParaDest-305" class="chapter-number"><a id="_idTextAnchor306"/>16</h1>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor307"/>Building Protocols on Top of TCP</h1>
			<p>In the previous chapter, we used the Tokio framework to support an async actor model. Our Tokio framework accepted basic traffic and then sent those messages to actors once the messages were processed. However, our TCP processing was basic. You should not be comfortable building complex systems on this basic TCP process if this book is the only exposure you have had to TCP. In this chapter, we will completely focus on how to package, send, and read data over a TCP connection.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Setting up a TCP client and echo server</li>
				<li>Processing bytes over TCP using structs</li>
				<li>Creating frames to separate messages over TCP</li>
				<li>Building an HTTP frame on top of TCP</li>
			</ul>
			<p>By the end of this chapter, you will be able to package, send, and read data sent over TCP using a range of different approaches. You will be able to understand how to split your data into frames that can be handled as structs. Finally, you will be able to build an HTTP frame that has a header containing the URL and method, and a body containing data. This will enable you to build whatever data structure you require when sending data over TCP.</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor308"/>Technical requirements</h1>
			<p>In this chapter, we will be purely focusing on how to process data over a TCP connection. Therefore, we will not be relying on any previous code as we are building our own echo server.</p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter16">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter16</a>.</p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor309"/>Setting up our TCP client and server</h1>
			<p>To explore sending<a id="_idIndexMarker1359"/> and processing<a id="_idIndexMarker1360"/> bytes over TCP, we will create a basic echo server and client. We will be dropping any complex logic that we built in the previous chapter because we do not need the distraction of the complex logic when trying to explore the ideas around sending, receiving, and processing bytes.</p>
			<p>In a new directory, we should have two cargo projects – one for the server and another for the client. They can take the following file structure:</p>
			<pre class="source-code">
├── client
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── server
    ├── Cargo.toml
    └── src
        └── main.rs</pre>
			<p>Both projects will be using the same dependency of Tokio, so both projects should have the following dependency defined in their <code>Cargo.toml</code> file:</p>
			<pre class="source-code">
[dependencies]
tokio = { version = "1", features = ["full"] }</pre>
			<p>We now need to construct the basic mechanism of an echo server. This is where a message is sent to the server from the client. The server then processes the message sent by the client, re-packages the message, and sends the same message back to the client. We will start by building out our server.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor310"/>Setting up our TCP server</h2>
			<p>We can define<a id="_idIndexMarker1361"/> the server in the <code>server/src/main.rs</code> file by initially importing everything we need with the following code:</p>
			<pre class="source-code">
use tokio::net::TcpListener;
use tokio::io::{BufReader, AsyncBufReadExt, AsyncWriteExt};</pre>
			<p>This is so we can listen<a id="_idIndexMarker1362"/> to incoming TCP traffic, read bytes from that traffic, and write it back to the client sending the message. Then, we need to utilize the Tokio runtime to listen to incoming traffic, spinning up a thread if we get a message. If you completed the previous chapter, this is a good opportunity for you to attempt to do this yourself as we covered the concepts needed to create a TCP server listening for incoming traffic.</p>
			<p>If you have attempted to write the basics for your TCP server, your code should look like this:</p>
			<pre class="source-code">
#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:8080".to_string();
    let socket = TcpListener::bind(&amp;addr).await.unwrap();
    println!("Listening on: {}", addr);
    while let Ok((mut stream, peer)) =
        socket.accept().await {
        println!("Incoming connection from: {}",
                  peer.to_string());
        tokio::spawn(async move {
            . . .
        });
    }
}</pre>
			<p>Here, we should be familiar with the concept that we create a listener, bind it to an address, and then wait for incoming messages, creating a thread when a message is sent. Inside the thread, we loop<a id="_idIndexMarker1363"/> through the incoming message until there is a new line with the following code:</p>
			<pre class="source-code">
println!("thread starting {} starting", peer.to_string());
let (reader, mut writer) = stream.split();
let mut buf_reader = BufReader::new(reader);
let mut buf = vec![];
loop {
    match buf_reader.read_until(b'\n', &amp;mut buf).await {
        Ok(n) =&gt; {
            if n == 0 {
                println!("EOF received");
                break;
            }
            let buf_string = String::from_utf8_lossy(&amp;buf);
            writer.write_all(buf_string.as_bytes())
                .await.unwrap();
            buf.clear();
        },
        Err(e) =&gt; println!("Error receiving message: {}", e)
    }
}
println!("thread {} finishing", peer.to_string());</pre>
			<p>This code should not be a surprise by now. If you are unfamiliar with any of the concepts the preceding code covers, it is advised that you read the previous chapter.</p>
			<p>We now have a basic echo server defined, and it is ready to run, which means we can turn our attention to creating our client code in the <code>client/src/main.rs</code> file. The same structs and traits will be needed to get the client working. Then, we need to send a standard text message<a id="_idIndexMarker1364"/> to the TCP server. This is a good time to try and implement the client yourself, and there is nothing that has not been covered multiple times before to build the client.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor311"/>Setting up our TCP client</h2>
			<p>If you attempted to build<a id="_idIndexMarker1365"/> the client yourself, you should have imported the following structs and traits:</p>
			<pre class="source-code">
use tokio::net::TcpStream;
use tokio::io::{BufReader, AsyncBufReadExt, AsyncWriteExt};
use std::error::Error;</pre>
			<p>Then, we must make the TCP connection, send a message, wait for the message to be sent back, and then print it out using the Tokio runtime:</p>
			<pre class="source-code">
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut stream =
        TcpStream::connect("127.0.0.1:8080").await?;
    let (reader, mut writer) = stream.split();
    println!("stream starting");
    writer.write_all(b"this is a test\n").await?;
    println!("sent data");
    let mut buf_reader = BufReader::new(reader);
    let mut buf = vec![];
    println!("reading data");
    let _ = buf_reader.read_until(b'\n', &amp;mut
        buf).await.unwrap();
    let message = String::from_utf8_lossy(&amp;buf);
    println!("{}", message);
    Ok(())
}</pre>
			<p>We now have a functioning client and server. To test if the client and server are working, we must start the server in one terminal, and then run the client in another terminal by running <code>cargo run</code>. The server will have the following printout:</p>
			<pre class="console">
stream starting
sent data
reading data
this is a test</pre>
			<p>Our server printout will have the following printout:</p>
			<pre class="console">
Listening on: 127.0.0.1:8080
Incoming connection from: 127.0.0.1:60545
thread starting 127.0.0.1:60545 starting
EOF received
thread 127.0.0.1:60545 finishing</pre>
			<p>With that, we have a basic echo server<a id="_idIndexMarker1366"/> and client working. We can now focus on packaging, unpacking, and processing bytes. In the next section, we will explore the basic method of using structs to standardize processing messages.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor312"/>Processing bytes using structs</h1>
			<p>In the previous<a id="_idIndexMarker1367"/> chapter, we were sending<a id="_idIndexMarker1368"/> strings to the server. However, the result is that we had to parse individual values into the type that we needed. As string parsing was not well structured, it is not clear to other developers what structure our messages are. We can make our message structure clearer by defining a struct that can be sent over the TCP channel. Sending a struct over a TCP channel can be achieved by converting the message struct into a binary format before sending the struct itself. This is also known as serializing<a id="_idIndexMarker1369"/> the data.</p>
			<p>If we are to convert a struct into a binary format, first, we will need to utilize the <code>serde</code> and <code>bincode</code> crates. With our new crates, both the client and server <code>Cargo.toml</code> file should contain the following dependencies:</p>
			<pre class="source-code">
[dependencies]
serde = { version = "1.0.144", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
bincode = "1.3.3"</pre>
			<p>The <code>serde</code> crate will be used to serialize the struct, while the <code>bincode</code> crate will be used to convert our message struct into a binary format. Now that our dependencies have been defined, we can start creating a message sender client.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor313"/>Creating a message sender client</h2>
			<p>We can build<a id="_idIndexMarker1370"/> out our <code>client/src/main.rs</code> file to send structs over TCP. First, we must import what we need:</p>
			<pre class="source-code">
. . .
use serde::{Serialize, Deserialize};
use bincode;</pre>
			<p>With our imports ready, we can define our <code>Message</code> struct with the following code:</p>
			<pre class="source-code">
#[derive(Serialize, Deserialize, Debug)]
struct Message {
    pub ticker: String,
    pub amount: f32
}</pre>
			<p>The definition of our <code>Message</code> struct takes a similar<a id="_idIndexMarker1371"/> form to the structs that we use to process the JSON bodies of HTTP requests on our Actix server. However, this time, we will not be using the Actix Web structs and traits to process the struct.</p>
			<p>Our <code>Message</code> struct can now be used in our <code>main</code> function. Remember that inside our <code>main</code> function, we have a TCP stream that was created by the following code:</p>
			<pre class="source-code">
let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
let (reader, mut writer) = stream.split();</pre>
			<p>Now that we have made a connection, we can create our <code>Message</code> struct and convert the <code>Message</code> struct into binary format:</p>
			<pre class="source-code">
let message = Message{ticker: String::from("BYND"),
                      amount: 3.2};
let message_bin = bincode::serialize(&amp;message).unwrap();</pre>
			<p>Our <code>Message</code> struct is now in binary format. Then, we must send our message over the TCP stream with the following code:</p>
			<pre class="source-code">
println!("stream starting");
writer.write_all(&amp;message_bin).await?;
writer.write_all(b"\n").await?;
println!("sent data");</pre>
			<p>Note that we have sent the message and then a new line. This is because our server is going to read until there is a new line. If we do not send the new line, then the program will hang and never complete.</p>
			<p>Now that we have sent our message, we can wait until we see receive the message back again. Then, we must construct the <code>Message</code> struct from the binary format and print out the constructed <code>Message</code> struct with the following code:</p>
			<pre class="source-code">
let mut buf_reader = BufReader::new(reader);
let mut buf = vec![];
println!("reading data");
let _ = buf_reader.read_until(b'\n',
    &amp;mut buf).await.unwrap();
println!("{:?}", bincode::deserialize::&lt;Message&gt;(&amp;buf));</pre>
			<p>Our client<a id="_idIndexMarker1372"/> is now ready to send a message to the server.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor314"/>Processing messages in the server</h2>
			<p>When it comes to updating<a id="_idIndexMarker1373"/> our server<a id="_idIndexMarker1374"/> code, we will aim to unpack the message, print out the message, and then convert the message into binary format to be sent back to the client. At this stage, you should be able to implement the change yourself. This is a good opportunity to revise what we have covered.</p>
			<p>If you did attempt to implement the processing of the message on the server in the <code>server/src/main.rs</code> file first, you should have imported the following additional requirements:</p>
			<pre class="source-code">
use serde::{Serialize, Deserialize};
use bincode;</pre>
			<p>Then, you should have defined the <code>Message</code> struct, like so:</p>
			<pre class="source-code">
#[derive(Serialize, Deserialize, Debug)]
struct Message {
    pub ticker: String,
    pub amount: f32
}</pre>
			<p>Now, we only need to process the message, print out the message, and then return the message to the client. We can manage<a id="_idIndexMarker1375"/> all the processes with the message in the loop<a id="_idIndexMarker1376"/> inside the thread with the following code:</p>
			<pre class="source-code">
let message =
    bincode::deserialize::&lt;Message&gt;(&amp;buf).unwrap();
println!("{:?}", message);
let message_bin = bincode::serialize(&amp;message).unwrap();
writer.write_all(&amp;message_bin).await.unwrap();
writer.write_all(b"\n").await.unwrap();
buf.clear();</pre>
			<p>Here, we are using the same approach that we used in the client but vice versa – that is, we convert from binary format first and then convert into binary format at the end.</p>
			<p>If we run our server and then our client, our server will give us the following printout:</p>
			<pre class="console">
Listening on: 127.0.0.1:8080
Incoming connection from: 127.0.0.1:50973
thread starting 127.0.0.1:50973 starting
Message { ticker: "BYND", amount: 3.2 }
EOF received
thread 127.0.0.1:50973 finishing</pre>
			<p>Our client gives us the following printout:</p>
			<pre class="console">
stream starting
sent data
reading data
Ok(Message { ticker: "BYND", amount: 3.2 })</pre>
			<p>Here, we can see that our <code>Message</code> struct can be sent, received, and then sent back again without any compromise. This gives our TCP traffic another level of sophistication as we can have more complex structures for our messages. For instance, one field of our message could be a HashMap, and another field of the message could be a vector of another struct if the struct in the vector has implemented the <code>serde</code> traits. We can chop and change the structure of our <code>Message</code> struct without having to rewrite our protocol for unpacking and packing a message. Other developers can merely look at our <code>Message</code> struct and know<a id="_idIndexMarker1377"/> what is being sent<a id="_idIndexMarker1378"/> over the TCP channel. Now that we have improved how we send messages over TCP, we can chunk our stream into frames with framing.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor315"/>Utilizing framing</h1>
			<p>So far, we are sending structs over TCP<a id="_idIndexMarker1379"/> and separating these messages with a new line. Essentially, this is the most basic form of framing. However, there are some drawbacks. We must remember to put in a delimiter such as a new line; otherwise, our program will hang indefinitely. We also run the risk of prematurely splitting the message into two messages by having a delimiter in the data of the message. For instance, when we split our messages up with the new line delimiter, it is not inconceivable to have a chunk of text in a message that has new lines or any special character or byte to denote the need to separate the stream into serializable packages. To prevent such issues, we can use the built-in framing support that Tokio provides.</p>
			<p>In this section, we will be rewriting the client and server as the sending and receiving of messages will change. If we try and insert our new approach into existing code of the client, it can easily lead to confusion. Before we write our client and server, we must update the dependencies in the <code>Cargo.toml</code> file of both the client and server:</p>
			<pre class="source-code">
[dependencies]
tokio-util = {version = "0.7.4", features = ["full"] }
serde = { version = "1.0.144", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
futures = "0.3.24"
bincode = "1.3.3"
bytes = "1.2.1"</pre>
			<p>Here, we are using a couple more crates. We will cover their needs as we go through the rest of the code in this section. To get to grips<a id="_idIndexMarker1380"/> with framing, we will start with a simple task, which is rewriting our client so that it supports framing.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor316"/>Rewriting our client so that it supports framing</h2>
			<p>Remember we are writing<a id="_idIndexMarker1381"/> our entire client<a id="_idIndexMarker1382"/> in the <code>client/src/main.rs</code> file. First, we must import what we need from Tokio with the following code:</p>
			<pre class="source-code">
use tokio::net::TcpStream;
use tokio_util::codec::{BytesCodec, Decoder};</pre>
			<p><code>TcpStream</code> is for connecting to our server. The <code>BytesCodec</code> struct is for shipping raw bytes through connections. We will be using the <code>BytesCodec</code> struct to configure the framing. <code>Decoder</code> is a trait that decodes bytes that we accept through our connection. However, when it comes to sending data through a connection, we could pass in structs, strings, or anything else that must be converted into bytes. Therefore, we must inspect what is implemented for the <code>BytesCodec</code> struct by looking at the source code for <code>BytesCodec</code>. The source code can be inspected by looking at the documentation or merely control-clicking or hovering over the <code>BytesCodec</code> struct in your editor. When we inspect the source code of the <code>BytesCodec</code> struct, we will see the following <code>Encode</code> implementations:</p>
			<pre class="source-code">
impl Encoder&lt;Bytes&gt; for BytesCodec {
    . . .
}
impl Encoder&lt;BytesMut&gt; for BytesCodec {
    . . .
}</pre>
			<p>Here, we can only send <code>Bytes</code> or <code>BytesMut</code> through a connection using a <code>BytesCodec</code> struct. We could implement <code>Encode</code> for <code>BytesCodec</code> for sending other types of data; however, for our use case, this is excessive, and it just makes sense to send <code>Bytes</code> over our connection. However, before we write any more code, we might as well inspect the <code>Bytes</code> implementation to get an appreciation for how framing works. The implementation of <code>Encode</code> for <code>Bytes</code> takes the following form:</p>
			<pre class="source-code">
impl Encoder&lt;Bytes&gt; for BytesCodec {
    type Error = io::Error;
    fn encode(&amp;mut self, data: Bytes, buf: &amp;mut BytesMut)
              -&gt; Result&lt;(), io::Error&gt; {
        buf.reserve(data.len());
        buf.put(data);
        Ok(())
    }
}</pre>
			<p>Here, we can see<a id="_idIndexMarker1383"/> that the length of the data being passed is reserved<a id="_idIndexMarker1384"/> in the buffer. The data is then put into the buffer.</p>
			<p>Now that we understand how we are going to encode and decode our messages using framing, we need to import traits from both the <code>futures</code> and <code>bytes</code> crates to enable us to process our messages:</p>
			<pre class="source-code">
use futures::sink::SinkExt;
use futures::StreamExt;
use bytes::Bytes;</pre>
			<p>The <code>SinkExt</code> and <code>StreamExt</code> traits essentially enable us to receive messages from the stream asynchronously. The <code>Bytes</code> struct will wrap our serialized message to be sent. Then, we must import the traits to enable the serialization of messages and define our message struct:</p>
			<pre class="source-code">
use serde::{Serialize, Deserialize};
use bincode;
use std::error::Error;
#[derive(Serialize, Deserialize, Debug)]
struct Message {
    pub ticker: String,
    pub amount: f32
}</pre>
			<p>We now have everything<a id="_idIndexMarker1385"/> we need to start working<a id="_idIndexMarker1386"/> on our runtime. Remember that our main runtime has the following outline:</p>
			<pre class="source-code">
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    . . .
    Ok(())
}</pre>
			<p>Inside our runtime, we initially make a TCP connection and define the framing with the following code:</p>
			<pre class="source-code">
let stream = TcpStream::connect("127.0.0.1:8080").await?;
let mut framed = BytesCodec::new().framed(stream);</pre>
			<p>Then, we define our message, serialize the message, and then wrap the message in <code>Bytes</code> with the following code:</p>
			<pre class="source-code">
let message = Message{ticker: String::from("BYND"),
                      amount: 3.2};
let message_bin = bincode::serialize(&amp;message).unwrap();
let sending_message = Bytes::from(message_bin);</pre>
			<p>Then, we can send our message, wait for the message to be sent back, and then deserialize the message to print it out with the following code:</p>
			<pre class="source-code">
framed.send(sending_message).await.unwrap();
let message = framed.next().await.unwrap().unwrap();
let message =
    bincode::deserialize::&lt;Message&gt;(&amp;message).unwrap();
println!("{:?}", message);</pre>
			<p>With all this, our client<a id="_idIndexMarker1387"/> is built. We can see that we do not have to worry<a id="_idIndexMarker1388"/> about new lines or any other delimiters. Our code is clean and straightforward when it comes to sending and receiving messages over TCP. Now that our client has been built, we can move on to building our server so that it handles framing.</p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor317"/>Rewriting our server so that it supports framing</h2>
			<p>When it comes to building<a id="_idIndexMarker1389"/> our server to support<a id="_idIndexMarker1390"/> framing, there is a lot of overlap with what we have coded in the previous section. At this point, it is a good time to try and build the server yourself. Building the server requires implementing the framing logic that we coded in the previous section into the existing server code.</p>
			<p>If you attempted to rewrite the server, first, you should have imported the following structs and traits:</p>
			<pre class="source-code">
use tokio::net::TcpListener;
use tokio_util::codec::{BytesCodec, Decoder};
use futures::StreamExt;
use futures::sink::SinkExt;
use bytes::Bytes;
use serde::{Serialize, Deserialize};
use bincode;</pre>
			<p>Note that the <code>Decoder</code> trait that we imported allows us to call <code>.framed</code> on the bytes codec. There is nothing here that should be new to you. Once we have the necessary imports, we must define the same <code>Message</code> struct with the following code:</p>
			<pre class="source-code">
#[derive(Serialize, Deserialize, Debug)]
struct Message {
    pub ticker: String,
    pub amount: f32
}</pre>
			<p>Now, we must define<a id="_idIndexMarker1391"/> the outline of the server runtime<a id="_idIndexMarker1392"/> with the following code:</p>
			<pre class="source-code">
#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:8080".to_string();
    let listener = TcpListener::bind(&amp;addr).await.unwrap();
    println!("Listening on: {}", addr);
    loop {
        let (socket, _) = listener.accept().await.unwrap();
        tokio::spawn(async move {
            . . .
        });
    }
}</pre>
			<p>Here, we can see that the listener is looping to accept traffic and spawning threads when messages are received, as in previous server implementations. Inside our thread, we read our framed message with the following code:</p>
			<pre class="source-code">
let mut framed = BytesCodec::new().framed(socket);
let message = framed.next().await.unwrap();
    match message {
        Ok(bytes) =&gt; {
            . . .
        },
        Err(err) =&gt; println!("Socket closed with error:
                              {:?}", err),
    }
println!("Socket received FIN packet and closed
           connection");</pre>
			<p>As we can see, we do not have a <code>while</code> loop anymore. This is because our framing manages the splitting between messages.</p>
			<p>Once we have extracted<a id="_idIndexMarker1393"/> our bytes from our connection, we must implement<a id="_idIndexMarker1394"/> the same logic that we did in our client, where we process our message, print it out, process it again, and then send it back to the client:</p>
			<pre class="source-code">
let message =
    bincode::deserialize::&lt;Message&gt;(&amp;bytes).unwrap();
println!("{:?}", message);
let message_bin = bincode::serialize(&amp;message).unwrap();
let sending_message = Bytes::from(message_bin);
framed.send(sending_message).await.unwrap();</pre>
			<p>We now have a working client and server that utilizes framing. If we were to start the server and then run the client, the client will give us the following printout:</p>
			<pre class="console">
Message { ticker: "BYND", amount: 3.2 }</pre>
			<p>Our server will give us the following printout:</p>
			<pre class="console">
Listening on: 127.0.0.1:8080
Message { ticker: "BYND", amount: 3.2 }
Socket received FIN packet and closed connection</pre>
			<p>Our server and client<a id="_idIndexMarker1395"/> now support framing. We have<a id="_idIndexMarker1396"/> come a long way. Now, we only have one more concept to explore in this chapter, and this is building an HTTP frame using TCP.</p>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor318"/>Building an HTTP frame on top of TCP</h1>
			<p>Before we explored the Tokio framework<a id="_idIndexMarker1397"/> in this book, we used HTTP<a id="_idIndexMarker1398"/> to send and receive data to and from servers. The HTTP protocol is essentially built on top of TCP. In this section, while we will create an HTTP frame, we will not mimic the HTTP protocol completely. Instead, to prevent excessive code, we will create a basic HTTP frame to understand the mechanisms utilized when creating an HTTP frame. It also must be stressed that this is for educational purposes. TCP is good for our protocols, but if you want to use HTTP handlers, it is quicker, safer, and less error-prone to use out-of-the-box HTTP handlers such as Hyper. We will cover how to use Hyper HTTP handlers with Tokio in the next chapter.</p>
			<p>When it comes to an HTTP request, a request generally has a header and a body. When we send over a request, the header will tell us what method is being used and the URL associated with the request. To define our HTTP frame, we need the same structs defining the frame on both the server and client. Therefore, we must have the same code for the <code>client/src/http_frame.rs</code> and <code>server/src/http_frame.rs</code> files. First, we must import the serialization traits that are needed with the following code:</p>
			<pre class="source-code">
use serde::{Serialize, Deserialize};</pre>
			<p>Then, we must define our HTTP frame with the following code:</p>
			<pre class="source-code">
#[derive(Serialize, Deserialize, Debug)]
pub struct HttpFrame {
    pub header: Header,
    pub body: Body
}</pre>
			<p>As we can see, we have defined a header and body within our <code>HttpFrame</code> struct. We define the header and body structs with the following code:</p>
			<pre class="source-code">
#[derive(Serialize, Deserialize, Debug)]
pub struct Header {
    pub method: String,
    pub uri: String,
}
#[derive(Serialize, Deserialize, Debug)]
pub struct Body {
    pub ticker: String,
    pub amount: f32,
}</pre>
			<p>Our basic HTTP frame<a id="_idIndexMarker1399"/> is now complete, and we<a id="_idIndexMarker1400"/> can import the HTTP frame into the <code>main.rs</code> file of both the client and server with the following code:</p>
			<pre class="source-code">
mod http_frame;
use http_frame::{HttpFrame, Header, Body};</pre>
			<p>We will start by sending our HTTP frame in the <code>main.rs</code> file of our client with the following code:</p>
			<pre class="source-code">
let stream = TcpStream::connect("127.0.0.1:8080").await?;
let mut framed = BytesCodec::new().framed(stream);
let message = HttpFrame{
    header: Header{
        method: "POST".to_string(),
        uri: "www.freshcutswags.com/stock/purchase".to_string()
    },
    body: Body{
        ticker: "BYND".to_string(),
        amount: 3.2,
    }
};
let message_bin = bincode::serialize(&amp;message).unwrap();
let sending_message = Bytes::from(message_bin);
framed.send(sending_message).await.unwrap();</pre>
			<p>We can see that our HTTP frame<a id="_idIndexMarker1401"/> is starting to look like an HTTP request that we would handle<a id="_idIndexMarker1402"/> when receiving requests in our Actix servers. For the <code>main.rs</code> file in our server, there is little change. All we must do is redefine the struct that is being deserialized with the following code:</p>
			<pre class="source-code">
let message = bincode::deserialize::&lt;HttpFrame&gt;(&amp;bytes).unwrap();
println!("{:?}", message);
let message_bin = bincode::serialize(&amp;message).unwrap();
let sending_message = Bytes::from(message_bin);
framed.send(sending_message).await.unwrap();</pre>
			<p>We now have a basic HTTP frame that we can use to send information. If we were to run our server and then client programs, we would get the following printout for the server:</p>
			<pre class="console">
Listening on: 127.0.0.1:8080
HttpFrame { header: Header {
                method: "POST",
                uri: "www.freshcutswags.com/stock/purchase"
            },
            body: Body {
                ticker: "BYND",
                amount: 3.2
            }
        }
Socket received FIN packet and closed connection</pre>
			<p>Our client program will then give us the following printout:</p>
			<pre class="console">
HttpFrame { header: Header {
                method: "POST",
                uri: "www.freshcutswags.com/stock/purchase"
            },
            body: Body {
                ticker: "BYND",
                amount: 3.2
            }
        }</pre>
			<p>We can see that there is no corruption<a id="_idIndexMarker1403"/> in our data. We have now covered<a id="_idIndexMarker1404"/> all the core essential approaches and methods needed to be versatile in packaging, sending, and reading data over TCP.</p>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor319"/>Summary</h1>
			<p>In this chapter, we built a basic TCP client that sends and receives data to an echo server. We started by sending over basic string data and separating the messages with delimiters. Then, we increased the complexity of the data that we sent over a TCP connection by serializing structs. This enabled us to have more complex data structures. This serialization also reduced the handling needed to get the message data in the format that we needed it to be in. For instance, in the previous chapter, we were parsing strings into floats after receiving the message. With structs, nothing is stopping us from having a list of floats as a field, and after the serialization of the message, we would have that field housing a list of floats without any extra lines of code.</p>
			<p>The serialization of structs is enough for us to handle most problems, but we explored framing so that we did not have to rely on delimiters to separate the messages that we send over TCP. With framing, we built a basic HTTP frame to visualize what we can do with frames and how HTTP is built on top of TCP. We must remember that implementing an HTTP protocol is more complicated than what we did in this chapter, and it is advised that we utilize established HTTP handlers from crates to handle and process HTTP traffic.</p>
			<p>In the next chapter, we will use the established Hyper crate to handle HTTP traffic with the Tokio runtime framework.</p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor320"/>Further reading</h1>
			<p>Tokio framing documentation: <a href="https://tokio.rs/tokio/tutorial/framing">https://tokio.rs/tokio/tutorial/framing</a>.</p>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor321"/>Questions</h1>
			<ol>
				<li>What is the advantage of framing over using a delimiter?</li>
				<li>Why did we wrap our serialized message in a <code>Bytes</code> struct?</li>
				<li>How would we be able to send over a string as a frame?</li>
			</ol>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor322"/>Answers</h1>
			<ol>
				<li value="1">If we use a delimiter such as a new line, the data that we send over TCP might contain a new line in the message. The problem with having a new line in the message means that the message is split before the end of the message is received. Framing gets rid of this issue.</li>
				<li>We had to wrap our serialized message in a <code>Bytes</code> struct because the <code>Encode</code> trait is not implemented for any other data type.</li>
				<li>The simplest way to do this is to implement the <code>Encode</code> trait for a string. When implementing the <code>Encode</code> trait, we serialize the string and then wrap the string into a <code>Bytes</code> struct, reserve the length of the serialized string in the buffer, and then place the serialized string in the buffer.</li>
			</ol>
		</div>
	</body></html>