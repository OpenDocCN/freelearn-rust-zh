<html><head></head><body>
        

                            
                    <h1 class="header-title">Debugging</h1>
                
            
            
                
<p>This chapter will cover various approaches to debugging Rust programs. Rust programs, at the binary level, are very similar to C programs. This means that we can leverage the strong legacy of industry standard debuggers such as gdb and lldb that are used for debugging C/C++ programs and use the same tools to debug Rust code as well. In this chapter, we'll interactively walk through some basic debugging workflow and commands with gdb. We'll also cover integrating the gdb debugger with <strong>Visual Studio Code</strong> (<strong>vscode</strong>) editor and, later, give a quick overview of another debugger, called <strong>rr</strong>.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introduction to debugging</li>
<li>The gdb basics and debugging a Rust program</li>
<li>The gdb integration with Visual Studio Code</li>
<li>RR debugger—a quick overview</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to debugging</h1>
                
            
            
                
<p>"If debugging is the process of removing bugs, then programming must be the process of putting them in."                                                                                                                                                                                                                                                                                       - Edsger W. Dijkstra</p>
<p>Here's the situation: your program doesn't work, and you have no idea why. To fix this mysterious issue in your code, you have added several print statements and enabled trace logging, too. Still no luck. Worry not, for you are not alone! Every programmer has been there and has spent countless hours finding that one nasty bug that brought havoc into production.</p>
<p class="mce-root"/>
<p>Errors and deviations in software are referred to as bugs, and the act of removing them is termed debugging. Debugging is a controlled and systematic approach to examining the cause and effect of a fault in software. It's an essential skill to learn for anybody that's interested in gaining more insight into how their program behaves and runs. However, debugging is often not an easy task without the right tools, and the developer can lose track of what the actual bug is or might even be looking for bugs in the wrong place. The approaches we use to identify bugs in software can greatly affect the time taken to squash them and continue on a happy path. Depending on how complex a bug is, debugging is usually approached in one of the following ways:</p>
<ul>
<li><strong>Print-line debugging</strong>: In this method, we sprinkle print statements in the required places in the code, where we suspect the bug may possibly modify application state, and monitor the output when the program is run. This is simple, crude, and often effective, but it's not possible in every situation. This technique requires no extra tools, and everybody knows how to do it. It's actually the starting point of debugging for most bugs. To aid with print-line debugging, Rust provides the <kbd>Debug</kbd> trait, which we have already used many times before, and the <kbd>dbg!</kbd>, <kbd>println!</kbd>, and <kbd>eprintln!</kbd> family of macros.</li>
<li><strong>Read-Evaluate-Print-Loop-based debugging</strong>: Languages that are interpreted, such as Python, often come with their own interpreter. An interpreter provides you with a <strong>Read-Evaluate-Print-Loop (REPL)</strong> interface, where you can load your program in an interactive session and examine the state of variables step by step. It is very useful in debugging, especially if you've managed to properly modularize your code so that it can be invoked independently as functions. Unfortunately, Rust does not have an official REPL, and its overall design doesn't really support one. However, there have been some efforts on this with the miri project, which can be found at <a href="https://github.com/solson/miri">https://github.com/solson/miri</a>.</li>
<li><strong>Debuggers</strong>: With this approach, we compile our program with special debugging symbols in the resulting binary and use an external program to monitor its execution. These external programs are called debuggers and the most popular ones are gdb and lldb. They are the most powerful and efficient methods of debugging, allowing you to inspect a lot of details about your program at runtime. Debuggers give you the ability to pause a running program and examine its state in memory to find out the specific line of code that introduced the bug.</li>
</ul>
<p class="mce-root"/>
<p>The first two approaches are quite obvious, and so we don't need to go through them here. This leaves us with the third approach: debuggers. Debuggers as a tool are very simple to use, but they are not easy to understand and are often not introduced properly to programmers early in their careers. In the next section, we'll go through a step-by-step process of debugging a program written in Rust with gdb. But before that, let's get to know a little about debuggers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debuggers in general</h1>
                
            
            
                
<p>Debuggers are programs that can inspect a program's internal state at runtime, provided that the program has been compiled – debug symbols included. They rely on process introspection system calls such as <strong>ptrace</strong> in Linux. They allow you to pause the execution of a program at runtime. To achieve this, they provide a feature called a breakpoint. A breakpoint represents a suspension point in a running program. A breakpoint can be put on any function or line of code in the program. Once the debugger hits the breakpoint, it pauses and waits for the user to input further instructions. At this point, the program is not running and is in the middle of its execution. Here, you can examine the state of variables, the active stack frames of a program, and other things such as the program counter and the assembly instructions. Debuggers also come with watchpoints, which are similar to breakpoints but work on variables. They trigger and stop the execution when the variable is read or written to.</p>
<p>To use a debugger on a program, we need some prerequisites, though. Let's discuss them next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Prerequisites for debugging</h1>
                
            
            
                
<p>A compiled program or object file is a sequence of zeros and ones that has no mapping of the original source from which it was compiled. To enable a program to be inspected by a debugger, we need to map the compiled binary instructions to the source file somehow. This is done by injecting extra bookkeeping symbols and instrumentation code during compilation, which the debugger can then latch onto. These symbols are maintained in a symbol table that contains information about the elements of the program, such as the names of variables, functions, and types. They follow a standard format called <strong>Debugging With Attributed Record Format</strong> (<strong>DWARF</strong>), which most standard debuggers know how to parse and understand. These symbols give developers the capability to examine the program, such as the ability to match the source code to the running binary, keeping information on call frames, register values the memory map of the program, and so on.</p>
<p class="mce-root"/>
<p>To debug our program, we need to compile it in debug mode. In debug mode, a compiled binary will include debugging symbols in the DWARF debugging format. Here, the binary gains a bit of size and runs more slowly because it has to update the debugging symbol table as it runs. When compiling C programs, you need to compile with the <kbd>-g</kbd> flag to tell the compiler to compile with debug symbols included. With Cargo, a debug build of the project is compiled by default in the <kbd>target/debug/</kbd> directory, with debugging symbols included.</p>
<div><strong>Note</strong>: You can also pass a <kbd>-g</kbd> flag to <kbd>rustc</kbd> when using a package manager other than Cargo.</div>
<p>Running the debugger is possible against a release build too, but the selection of operations is very limited. If you want to enable <kbd>DWARF</kbd> debugging symbols, even in release builds, you can configure that in <kbd>Cargo.toml</kbd> by modifying the <kbd>profile.release</kbd> section, like so:</p>
<pre>[profile.release]<br/>debug = true</pre>
<p>With that said, let's dive into setting up gdb.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up gdb</h1>
                
            
            
                
<p>To get started with gdb, we first need to install it. Usually, it is installed by default on Linux systems, but if it isn't, refer to guides on the internet for setting it up on your machine. On Ubuntu, it's just a matter of running an installation command such as <kbd>apt-get install gdb</kbd>. We'll be using gdb version <kbd>7.11.1</kbd> for our demo here.</p>
<p>While gdb has amazing support for Rust programs, there are some Rust-specific things that it doesn't handle correctly, such as getting tidier output. The Rust toolchain, rustup, also installs wrappers for both gdb and lldb debuggers, <kbd>rust-gdb</kbd> and <kbd>rust-lldb</kbd>. It does this to account for some of the limitations in handling Rust code such as getting tidier output for mangled types and some pretty printing of user-defined types. Let's explore debugging a Rust program with gdb.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">A sample program – buggie</h1>
                
            
            
                
<p>We'll need a program to debug to experience gdb. Let's create a new project by running <kbd>cargo new buggie</kbd>. Our program will have a single function, <kbd>fibonacci</kbd>, which takes a position of <kbd>n</kbd> as <kbd>usize</kbd>, and gives us the <em>nth</em> Fibonacci number. This function assumes that the initial values of the Fibonacci numbers are <kbd>0</kbd> and <kbd>1</kbd>. The following code is the program in its entirety:</p>
<pre>1 // buggie/src/main.rs<br/>2 <br/>3 use std::env;<br/>4 <br/>5 pub fn fibonacci(n: u32) -&gt; u32 {<br/>6     let mut a = 0;<br/>7     let mut b = 1;<br/>8     let mut c = 0;<br/>9     for _ in 2..n {<br/>10        let c = a + b;<br/>11        a = b;<br/>12        b = c;<br/>13    }<br/>14    c<br/>15 }<br/>16 <br/>17 fn main() {<br/>18     let arg = env::args().skip(1).next().unwrap();<br/>19     let pos = str::parse::&lt;u32&gt;(&amp;arg).unwrap();<br/>20     let nth_fib = fibonacci(pos);<br/>21     println!("Fibonacci number at {} is {}", pos, nth_fib);<br/>22 }</pre>
<p>Let's take this program for a spin:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/655ea2ad-b1da-4292-94dd-4089ff58dd2e.png" style="width:38.75em;height:3.92em;"/></p>
<p>We ran the program with <kbd>4</kbd> as the argument, but we can see a <kbd>0</kbd> as the output, which should have been <kbd>3</kbd>. We have a bug here. While we could use the <kbd>println!</kbd> or <kbd>dbg!</kbd> macro to easily tackle this bug, we'll use gdb this time.</p>
<p>Before we run gdb, we need to plan our debugging session. This includes deciding where to look inside our program and what to look for. As a starting point, we'll examine the contents of the <kbd>main</kbd> function and then step into the <kbd>fibonacci</kbd> function. We'll set two breakpoints, one at <kbd>main</kbd> and another within <kbd>fibonacci</kbd>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The gdb basics</h1>
                
            
            
                
<p>We'll run our program again, this time with gdb using the <kbd>rust-gdb</kbd> wrapper by running <kbd>rust-gdb --args target/debug/buggie 4</kbd>. The <kbd>--args</kbd> flags are used to pass arguments to the program. Here, we pass the number <kbd>4</kbd>. Here's the output from gdb:</p>
<div><img class="image-border" src="img/f3b532f6-1453-4e4d-a53c-6b3438e7319a.png" style="width:32.42em;height:13.25em;"/></div>
<p class="mce-root"/>
<p>After loading our program, gdb throws us into the <kbd>(gdb)</kbd> prompt. At this point, the program is not running—it's just been loaded. Let's take a quick look at the scope of gdb's features. Try using the <kbd>help</kbd> command (which displays high-level sections of commands) and the <kbd>help all</kbd> command(which displays a help message for all available commands):</p>
<div><img class="image-border" src="img/ce3e6048-7f4a-43e9-9812-636eb0a4ff29.png" style="width:33.33em;height:25.75em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Okay, so it seems that gdb can do a lot: there are <kbd>32</kbd> pages of these commands. Next, let's run the program and see the outcome by invoking <kbd>run</kbd> on the gdb prompt:</p>
<div><img class="image-border" src="img/84e23af9-a02d-4f37-80c2-746d56e20078.png" style="width:38.83em;height:6.75em;"/></div>
<p class="mce-root"/>
<p>That's how our program runs within the context of gdb. As you can see, in the middle, we have the same faulty output of <kbd>0</kbd> for the fourth Fibonacci number. We'll debug this now. Let's clear the screen by pressing <em>Ctrl</em> + <em>L</em>. Let's also quit gdb by invoking <kbd>q</kbd> and start afresh by running <kbd>rust-gdb --args target/debug/buggie 4</kbd>.</p>
<p>As a starting point in our debugging session, and to see whether we are passing the correct number to our Fibonacci function, we'll add a breakpoint at the start of <kbd>main</kbd>, which is line <kbd>18</kbd> in our program. To add a breakpoint on that line, we'll run the following code:</p>
<pre><strong>(gdb) break 18</strong></pre>
<p>This gives us the following output:</p>
<pre><strong>Breakpoint 1 at 0x9147: file src/main.rs, line 18.</strong></pre>
<p>The gdb has now set a breakpoint on the same line that we requested, that is, <kbd>18</kbd>. Let's run our program by invoking <kbd>run</kbd>:</p>
<pre><strong>(gdb) run</strong></pre>
<p>This gives us the following output:</p>
<pre><strong>(gdb) run</strong><br/>Starting program: /home/creativcoder/buggie/target/debug/buggie 4<br/>[Thread debugging using libthread_db enabled]<br/>Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".<br/><br/>Breakpoint 1, buggie::main::h8018d7420dbab31b () at src/main.rs:18<br/>18        let arg = env::args().skip(1).next().unwrap();<br/><strong>(gdb)</strong></pre>
<p>Our program is now paused at the breakpoint, awaiting its next instruction.</p>
<p class="mce-root"/>
<p>You'll see that the symbols from Rust are prefixed with their module and suffixed by some random IDs, for example, <kbd>buggie::main::h8018d7420dbab31</kbd>. Now, to view where we are in our program, we can run the <kbd>list</kbd> command to view the source code, or we can use a more visual TUI mode by running the following code:</p>
<pre><strong>(gdb) tui enable</strong></pre>
<p>This opens gdb with some nice feedback, along with our Command Prompt still on the bottom half:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/341bd30a-1ad4-4a5f-8392-e7cfdad9e198.png" style="width:67.42em;height:26.33em;"/></p>
<p>As you can see, the TUI indicates that we have a breakpoint on the left, with the <kbd>B+&gt;</kbd> symbol on line 18. We can scroll through the code listing in the TUI panel to view our entire source code.</p>
<div><strong>Note</strong>: If the TUI screen renders incorrectly, you can type in <kbd>refresh</kbd> and it will redraw the panels and code listing afresh.</div>
<p>Now, we'll go through our program line by line. To do that, we have two available commands: <kbd>next</kbd> and <kbd>step</kbd>. The first is for running through the program line by line, while <kbd>step</kbd> allows you to jump within a function and go through the instructions within it line by line. We want to use <kbd>next</kbd>, which will take us to the next line 19, instead of stepping inside the details of Rust's standard library API calls. Run the following code:</p>
<pre><strong>(gdb) next</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>We have to do this two more times before we reach the Fibonacci function. We can run the last command by just pressing <em>Enter</em> on the keyboard. In this case, pressing <em>Enter</em> two times will run the next two lines of code. Now, we're right before the Fibonacci invocation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b9b705eb-db3d-42ea-8d03-d91d22b353b2.png" style="width:30.00em;height:4.67em;"/></p>
<p>Before we step inside the Fibonacci function, let's examine the <kbd>pos</kbd> variable to check that it's not some garbage or a <kbd>0</kbd>. We can do this with the <kbd>print</kbd> command:</p>
<pre><strong>(gdb) print pos</strong><br/>$1 = 4<br/>(gdb) </pre>
<p>Okay, our <kbd>pos</kbd> is correct. Now, we are at line 20, which is right before our <kbd>fibonacci</kbd> invocation. Now, use the <kbd>step</kbd> command to walk inside the <kbd>fibonacci</kbd> function:</p>
<pre><strong>(gdb) step</strong></pre>
<p>We are now at line 6:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/51897497-e5fb-4cc6-b9ef-a56533d39b0c.png" style="width:32.42em;height:27.75em;"/></p>
<p class="mce-root"/>
<p>Next, let's step through the code line by line. While we are stepping through code in our Fibonacci function, we can examine the variables by using the <kbd>info locals</kbd> and <kbd>info args</kbd> commands:</p>
<pre><strong>(gdb) info locals</strong><br/>iter = Range&lt;u32&gt; = {start = 3, end = 4}<br/>c = 0<br/>b = 1<br/>a = 1<br/><strong>(gdb) info args</strong><br/>n = 4<br/><strong>(gdb)</strong> </pre>
<p>The preceding output shows the <kbd>iter</kbd> variable in the third iteration. The next line shows all the other variables being used in our function. We can see that, on every iteration, the <kbd>c</kbd> variable is being reassigned <kbd>0</kbd>. This is because we have <kbd>let c = a + b;</kbd>, which shadows the <kbd>c</kbd> variable that was declared outside of the loop. Rust allows you to redeclare a variable with the same name. We have found our bug here.</p>
<p>We'll remove our bug by removing the redeclaration of <kbd>c</kbd>. The Fibonacci function changes to the following:</p>
<pre>pub fn fibonacci(n: u32) -&gt; u32 {<br/>    let mut a = 0;<br/>    let mut b = 1;<br/>    let mut c = 0;<br/>    for _ in 2..n {<br/>        c = a + b;<br/>        a = b;<br/>        b = c;<br/>    }<br/>    c<br/>}</pre>
<p>With that, let's take the program for another spin. This time, we'll run it without the gdb debugger:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/334ac92a-d281-48bc-bfc4-2ac17048ea79.png" style="width:50.92em;height:4.83em;"/></p>
<p>We now have the correct output, that is, <kbd>2</kbd>, for the fourth Fibonacci number. Those are the basics of using gdb to debug Rust code.</p>
<p>Similar to gdb, lldb is another debugger that is compatible with Rust.</p>
<p>Next, let's look at how to integrate gdb with a code editor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debugger integration with Visual Studio Code</h1>
                
            
            
                
<p>Using debuggers from the command line is the usual way to debug your program. This is also an important skill, as you could easily wind up in a situation where your more advanced coding platform is not available. For instance, you may need to debug a program that is already running in production. Attaching to a running process is possible with both <kbd>gdb</kbd> and <kbd>lldb</kbd>, but you may not be able to attach to the running program from within your editor.</p>
<p>Nevertheless, in a typical development environment setting, you would use a code editor or an IDE, which is convenient if you can debug your program from the editor right away, without leaving your editor. In this way, you get a much smoother debugging experience and a faster feedback loop with editors that are properly integrated with debuggers. In this section, we'll look at how to integrate gdb with <strong>vscode</strong>.</p>
<p class="mce-root"/>
<p>To set up gdb with vscode, we need to install the <strong>Native Debug</strong> extension. With our vscode editor open, we'll press <em>Ctrl</em> + <em>Shift</em> + <em>P</em> and type <kbd>install extension</kbd>. Alternatively, you can select the extension icon at the bottom left, as shown in the following screenshot, and type <kbd>native debug</kbd>. By doing this, we get the page for the Native Debug extension:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e65e9ec-80b0-49d4-ab17-5bdde34a90b9.png" style="width:62.92em;height:33.67em;"/></p>
<p>We'll click on Install and wait for the installation to complete. Once the extension has been installed, we'll click on reload to restart Visual Studio Code. This enables any newly installed extension. Next up, we'll open our <kbd>buggie</kbd> directory inside vscode, click on the <strong>Debug</strong> menu at the top, and select <strong>Start Debugging</strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="image-border" src="img/f68dd9ef-df43-4207-87fa-727fe6f24c73.png" style="width:65.83em;height:35.33em;"/></p>
<p class="mce-root"/>
<p>From here, we'll be asked to choose an environment, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f0deef13-5c32-4c8c-bb0a-6e4a1d1881ae.png" style="width:66.17em;height:35.25em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>NativeDebug</kbd> extension supports both gdb and lldb. We'll choose gdb from this menu. This will open up a new <kbd>launch.json</kbd> configuration file for configuring our debug session for this project. It's created in the same project root, under a directory called <kbd>.vscode/</kbd>. If it doesn't open, we can manually create the <kbd>.vscode/</kbd> directory with a <kbd>launch.json</kbd> inside it. We'll fill this <kbd>launch.json</kbd> with the following configuration:</p>
<pre>// buggie/.vscode/launch.json<br/><br/>{<br/>    "version": "0.2.0",<br/>    "configurations": [<br/>        {<br/>            "name": "Buggie demo",<br/>            "type": "gdb",<br/>            "request": "launch",<br/>            "target": "target/debug/buggie",<br/>            "cwd": "${workspaceRoot}",<br/>            "arguments": "4",<br/>            "gdbpath": "rust-gdb",<br/>            "printCalls": true<br/>        }<br/>    ]<br/>}</pre>
<p>The <kbd>launch.json</kbd> file sets up important details for gdb and vscode, such as the target to invoke and the arguments to use. The other fields will be automatically populated for you in most cases. The only configuration that's specific to our project is as follows:</p>
<ul>
<li>We added a name to our configuration, that is, <kbd>"Buggie demo"</kbd>.</li>
<li>We added a <kbd>gdbpath</kbd> variable pointing to <kbd>rust-gdb</kbd>. This will launch <kbd>gdb</kbd> via the <kbd>rust-gdb</kbd> wrapper, which knows how to pretty-print complex data types in Rust.</li>
<li>We pointed the <kbd>target</kbd> field to our debugging binary, that is, <kbd>target/debug/buggie</kbd>.</li>
</ul>
<p>We'll save this file. Next, let's add a breakpoint to our program in the editor. We can do this by clicking on the left-hand side of the text area in vscode, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2f3acd8e-479c-494b-92ee-75fc725e7419.png" style="width:41.25em;height:28.33em;"/></p>
<p>In the preceding screenshot, if you hover over the left-hand side, you will see a faded red mark appear. We can click to the left of this to set our breakpoint, which will then show up as a red blip. Once we've done that, we'll press <em>F5</em> to start gdb inside vscode. Once gdb runs and hits our breakpoint, our code editor will look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0d6b967c-c135-4946-9989-ea8790bd49e4.png" style="width:58.75em;height:31.42em;"/></p>
<p>At the top center, we can see the usual controls, such as step over, step into, or to pause/stop the debugging in our code. On the left-hand pane, we can get information about the variables in the current stack frame. At the bottom left, we have information about our call stack. In the middle on the left, we can watch for any variable. In the preceding code, I added a watch to our <kbd>c</kbd> variable.</p>
<p>The program is now paused at line 9. We can also hover over our variables in the code to view their values, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/17996914-cf81-4a50-a5c3-dc9239d74b78.png" style="width:50.67em;height:16.67em;"/></p>
<p>This is quite helpful. Those were the basics of using gdb with vscode. Next, let's go through a brief overview of another debugger that is very helpful in debugging multi-threaded code: the RR debugger.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RR debugger – a quick overview</h1>
                
            
            
                
<p>Apart from gdb and lldb, rr is another powerful debugger that is quite helpful in debugging multi-threaded code which is harder to debug due to its non-determinism. Often, when debugging multi-threaded code, a certain section of code triggers a bug but fails to reproduce in subsequent executions of the program.</p>
<p>Bugs arising due to multi-threaded code are also referred to as heisenbugs.</p>
<p>The rr debugger can perform a reproducible debugging session for non-deterministic, multi-threaded code. It does this by recording the debugging session, which you can replay and track incrementally to close in on the issue. It does this by first saving the trace of the program to disk with all the required information to reproduce the program execution.</p>
<p>One of the limitations of rr is that it is only supported on Linux and on Intel CPUs as of now. To set up the rr debugger on Ubuntu 16.04, we'll pull the latest <kbd>.deb</kbd> package from <a href="https://github.com/mozilla/rr/releases">https://github.com/mozilla/rr/releases</a>. At the time of writing, the rr version is at <kbd>5.2.0</kbd>. Having downloaded the <kbd>deb</kbd> package, we can then install rr by running the following code:</p>
<pre><strong>sudo dpkg -i https://github.com/mozilla/rr/releases/download/5.2.0/rr-5.2.0-Linux-x86_64.deb</strong></pre>
<p><strong>Note</strong>: It's a prerequisite to install perf tools. You can install them as follows:</p>
<pre><strong>sudo apt-get install linux-tools-4.15.0-43-generic</strong></pre>
<p>Replace linux-tools-(version) as applicable for your kernel version. You can get the kernel version with the <kbd>uname -a</kbd> command on Linux. Another prerequisite is to set the <kbd>sysctl</kbd> flag in <kbd>perf_event_paranoid</kbd> from <kbd>3</kbd> to <kbd>-1</kbd>. It's recommended that you set this temporarily by running the following code:</p>
<pre><strong>sudo sysctl -w kernel.perf_event_paranoid=-1</strong></pre>
<p>With that done, let's quickly create a new project by running <kbd>cargo new rr_demo</kbd> and go through a debugging session with rr. We'll explore how to use the rr debugger for a sample program which demonstrates non-determinism. We'll depend on the <kbd>rand</kbd> crate, which we can add to the <kbd>Cargo.toml</kbd> file by running <kbd>cargo add rand</kbd>. We have the following code in our <kbd>main.rs</kbd> file:</p>
<pre>// rr_demo/src/main.rs<br/><br/>use rand::prelude::*;<br/><br/>use std::thread;<br/>use std::time::Duration;<br/><br/>fn main() {<br/>    for i in 0..10 {<br/>        thread::spawn(move || {<br/>            let mut rng = rand::thread_rng();<br/>            let y: f64 = rng.gen();<br/>            let a: u64 = rand::thread_rng().gen_range(0, 100); <br/>            thread::sleep(Duration::from_millis(a));<br/>            print!("{} ", i);<br/>        });<br/>    }<br/>    thread::sleep(Duration::from_millis(1000));<br/>    println!("Hello, world!");<br/>}</pre>
<p>This is a minimal, non-deterministic program that spawns <kbd>10</kbd> threads and prints them to stdout. To highlight the reproducibility aspect of rr, we'll spawn threads and sleep for a random duration.</p>
<p>First, we need to record the program's execution with rr. This is done by running the following code:</p>
<pre>rr record target/debug/rr_demo</pre>
<p>This gives us the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/13721b87-e2d2-4c9e-a94b-fa2db2030ac4.png" style="width:52.00em;height:3.00em;"/></p>
<p>On my machine, this records and stores the program execution trace at the following location:</p>
<pre>rr: Saving execution to trace directory `/home/creativcoder/.local/share/rr/rr_demo-15'</pre>
<p>The recorded file, <kbd>rr_demo-15</kbd>, might be named differently on your machine. We can now replay the recorded program by running the following code:</p>
<pre><strong>rr replay -d rust-gdb /home/creativcoder/.local/share/rr/rr_demo-15</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The following is the session with gdb running under rr:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c4c6279b-155f-47d8-b1ff-9f65d0a5de8d.png" style="width:60.92em;height:28.75em;"/></p>
<p>As you can see, the same sequence of numbers gets printed every time, as the program is being run from the recorded session in the previous run. This helps to debug a multi-threaded program where threads run out of order and might not reproduce the bug when you run your program next time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we took a hands-on approach to debugging Rust code using existing debuggers with GNU's <kbd>gdb</kbd>. We also configured gdb with vscode, giving us a convenient click-based UI for debugging our code. Finally, we got a glimpse of how the rr debugger can make debugging multi-threaded code deterministic.</p>
<p>With this, we have come to the end of our programming journey with Rust.<br/></p>


            

            
        
    </body></html>