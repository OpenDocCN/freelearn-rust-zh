- en: '*Chapter 5*: Collision Detection'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make our game fun, our little **Red Hat Boy** (**RHB**) needs to run, jump,
    and slide. Fortunately, we just implemented all that, but he also needs to have
    something to jump on, something to slide under, and something to crash into. To
    make this game fun, we'll need to add **collision detection**, which is one of
    the most fun and most complicated aspects of game design.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection begins with math, detecting whether or not two shapes intersect,
    but leads to all kinds of interesting questions. We'll deal with some of those
    in this chapter, such as, how do we handle transparency in sprites? What do we
    do to make sure a player lands on a platform from above but crashes into a platform
    if they're underneath it? What about sprites that have shapes that aren't a simple
    box? It's going to be a blast!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a real scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axis-aligned bounding boxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting bounding boxes from the sprite sheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crashing into a stone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Landing on and falling off a platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a real game, although it will be a short
    one. You'll have the skills to build your own scenes with good-looking collision
    detection, and you'll know how to integrate collision events with your own programs.
    You'll be able to, if you want, add your own new objects to the scene and crash
    into them or jump off them, or even fall off the world. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need to download the latest assets for this chapter from [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
  prefs: []
  type: TYPE_NORMAL
- en: You can get the source code for this chapter at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5).
  prefs: []
  type: TYPE_NORMAL
- en: No new assets are in the download, so if you downloaded them earlier, you don't
    need to do it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/36BJYJd](https://bit.ly/36BJYJd)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a real scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, RHB can move anywhere he wants, in an empty void, such as the
    one in *The Matrix*. It's progress; all that animation was real work, but it's
    not a game. It's time we put RHB in a setting – a background, platforms, maybe
    something to jump over. Let's start with a background.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, our game can only render images from a sprite sheet, which we can
    use for a background, but that''s overkill for one image. Instead, we''ll add
    a new `struct` that draws a simple image from a `.png` file. Then, we''ll add
    that to the `draw` and `initialize` functions in `WalkTheDog`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `Image` struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can work bottom-up for these changes, adding code to the engine and then
    integrating it into the game. Our `Image` `struct` will use a lot of the same
    code that we wrote in [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038),
    *Drawing Sprites*, but with a simpler setup because we won't be using a sheet.
    All of this code should go into the `engine` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a `struct` holding `HtmlImageElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing here you haven''t seen before in another form. The `Image
    struct` holds the image element, presumably loaded via the `load_image` function,
    and its position in the scene. `Image` will also need a draw function, but there''s
    no simple way to draw the entire image as it is in `Renderer`. That will need
    a new method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function is very similar to the `draw_image` function we wrote earlier,
    but it's using the simpler version of the JavaScript `drawImage` function that
    only takes an image and a position. To use this method, you'll need to be aware
    of how large the image you're drawing is. If it's too big or too small, it will
    show up just as big or small as the source image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''ve added a method to `Renderer`, go ahead and update the `Image`
    implementation to draw an image with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you can draw an image, let's load it.
  prefs: []
  type: TYPE_NORMAL
- en: Load the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The background image can be found in the downloaded assets, in `original/freetileset/png/BG/BG.png`,
    and can be copied into the `static` directory. Then, it can be loaded and used
    to create an `Image` `struct`. That will be done in the `game` module, in the
    `initialize` function of `WalkTheDog`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, only the highlighted last line is new, which
    loads the background from a file. Our `WalkTheDog` `enum` only holds `RedHatBoy`,
    so we're going to have to restructure the code a little. While we could have the
    `WalkTheDog::Loaded` state hold a tuple of `RedHatBoy` and `Background`, that's
    going to get real annoying, real fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, change `enum` to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll have `WalkTheDog` represent our game, but I decided that RHB takes the
    dog for "`Walk`. In a generic framework, I might call this a "`Walk` should work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Walk` struct will need to have the RHB and the background, so go ahead
    and add that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you've imported `Image` from the `engine` module. Now, you can work
    your way down the `game` module and follow the compiler errors. In the `initialize`
    function for `WalkTheDog`, you should see an error for "`` expected struct `Walk`,
    found struct `RedHatBoy` ``".
  prefs: []
  type: TYPE_NORMAL
- en: 'Fix that by creating `Walk` with the background we already loaded and setting
    it in `WalkTheDog::Loaded` that''s returned. This will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create `Walk` with a boy and `background` positioned at the upper-left
    corner, but you should still have several compiler errors in the `update` method
    of `WalkTheDog` because those all assume that `WalkTheDog::Loaded` contains `RedHatBoy`.
    Each of those can be changed in the exact same way. The first looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if let WalkTheDog::Loaded` line is unchanged, except now the variable
    name is `walk` instead of `rhb`. Then, we call `run_right` on `boy` but via the
    `walk` structure. You could argue that we should add methods to `Walk` instead
    of delegating to `boy`, but we''ll hold off on that for now. After all, `walk.run_right()`
    doesn''t really make sense. After fixing all the similar compiler errors in `update`,
    you can also fix a similar error in `draw`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Having done all that, you'll now be drawing… well, you'll be drawing RHB again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go ahead and draw the background for our game. Drawing the background
    is a matter of using our new draw function, so let''s add that right before the
    `walk.boy.draw` function call, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After doing that, you should see RHB standing in front of the background, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Standing in the forest'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Standing in the forest
  prefs: []
  type: TYPE_NORMAL
- en: Looking at it, you might wonder, how come RHB is so far to the right if his
    *x* coordinate is `0`? Hang on to that thought, as we'll deal with it soon. First,
    let's get a platform onto the screen, using our sprite sheet from [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038),
    *Drawing Sprites*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an obstacle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's great that we have RHB in front of a background, and it looks great, but
    the scene is still a little empty. What if there was something else in the scene?
    Something grand, something innovative, something larger than life. Well, the budget
    for art is low, so how about a stone?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new `Image` class means we won''t need much code, and you''ve seen all
    of it before. To add an obstacle, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by copying `Stone.png` from `original/freetileset/png/Object/Stone.png`
    in the assets and into the `static` directory. Now, you can add it to `Walk` in
    the same way you added `Background`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That will start causing compiler errors again because `Walk` is created without
    a stone.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `initialize`, go ahead and load the stone, just as you loaded the background,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you need to take the stone that we just loaded and add it to `Walk`.
    We''ll make sure the stone is on the ground by taking the `FLOOR` value (`600`)
    and subtracting the height of the stone image, which happens to be `54` pixels.
    If we position the stone at a *y* position of `546`, it should be sitting right
    on the ground. Here''s the update for creating `Walk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The stone is `150` pixels to the right, so it will be in front of RHB. Finally,
    draw the stone using the `draw` method. That addition is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code change is small, just drawing the stone with the same call to `draw`
    that we''ve used for `boy` and `background`. Do that, and you''ll have RHB walking
    toward the stone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Look out for that stone!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Look out for that stone!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if RHB walks into that stone, he''ll go safely behind it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Easiest game ever'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Easiest game ever
  prefs: []
  type: TYPE_NORMAL
- en: That's not much fun. While we've learned how to add new objects into the game,
    and drawn them for a more interactive experience, the game doesn't have any challenges
    yet. We want the boy to crash into the stone and fall over, ending the game. To
    do that, we'll need to learn a little about bounding boxes and collision detection,
    so let's do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Axis-aligned bounding boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking whether two objects in our game have collided can, theoretically, be
    done by checking every pixel in every object and seeing whether they share a location.
    That logic, in addition to being very complicated to write, would be computationally
    extremely expensive. We need to run at `60` frames a second and can't spend our
    precious processing power trying to get that kind of perfection – not if we want
    the game to be fun, anyway. Fortunately, we can use a simplification that will
    be close enough to fool our silly eyes, the same way we can't tell that animation
    is really just a series of still images. That simplification is called the *bounding
    box*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bounding box is just a rectangle we''ll use for collisions, instead of checking
    each pixel on the sprite. You can think of every sprite having a box around it,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Bounding boxes](img/Figure_5.04_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Bounding boxes
  prefs: []
  type: TYPE_NORMAL
- en: These boxes aren't actually drawn; they only exist in the memory of the game,
    except when you want to debug them. When you use boxes, you only have to check
    for the values of the box – top (*y*), left (*x*), right (*x* + width), and bottom
    (*y* + height). It makes for a much faster comparison. Let's talk in a little
    more detail about how to detect when two boxes intersect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The term "**axis-aligned**" sounds pretty fancy, but all it means is that the
    boxes aren't rotated. *Y* will be up and down, *X* left to right, and always aligned
    with the game's coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Collision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to detect whether two boxes collide or overlap, they will exist in
    the same 2D coordinate space we''ve been using since the beginning of this book.
    They may not be visible, but they are there, sitting where the stone is or running
    along with RHB. They''ll need a position in *x* and *y*, just like a sprite already
    has, and also a width and height. When we check whether two boxes are colliding,
    we check in both the *x* and *y* axes. Let''s first look at how you can tell whether
    two boxes intersect in the *x* axis. Given there are two boxes, box 1 intersects
    box 2 if the left side (or *x* position) of box 1 is less than the right side
    of box 2 but the right side of box 1 is greater than the left side of box 2\.
    This is easier to explain visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Collisions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Collisions
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows three sets of two boxes that could potentially collide,
    in a space where *x* increases as you move to the right, just like our canvas.
    The first two comparisons don't collide, but the third does.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the first comparison where box 1 is to the left of box 2, with
    a gap in between them. As you can see, the left side of box 1 is well to the left
    of the right side of box 2, as shown by the arrows. This passes the first condition
    for collision – the left side of box 1 must be less than the right side of box
    2\. However, the right side of box 1 is to the left of box 2's left side, which
    violates our second condition. To collide, the right side of box 1 must be greater
    than (to the right) of the left side of box 2, so these two boxes don't collide.
  prefs: []
  type: TYPE_NORMAL
- en: In the second comparison, box 1 has been moved to the right of box 2, again
    without overlapping. Box 1's right side is now to the right of box 2's left side,
    so they meet the second condition of colliding, but the left side of box 1 is
    now also to the right of box 2's right side, so the boxes don't meet the first
    condition and still don't collide.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the third comparison, the left side of box 1 is again to the right
    of box 2's right side, but the left side of box 1 is to the left of box 2's right
    side. These two boxes collide. Box 1 and box 2 have overlapping *x* values, so
    they collide.
  prefs: []
  type: TYPE_NORMAL
- en: 'If images aren''t your style, it can also help to look at real numbers to see
    how this algorithm works. Assuming box 1 and box 2 are both 10 x 10, squares we
    can form a table, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_5.01_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In every row of this table – that is, every example set of coordinates – box
    2 is in the same place. There are actually four examples here. In the first row,
    box 1 is completely to the left of box 2\. In the second, the boxes collide because
    box 1''s right edge hits box 2''s left edge. In the third, they collide because
    box 1''s left edge is hitting box 2''s right edge. Finally, in the fourth row,
    box 1 is not completely to the right of box 2\. The values hold the same properties
    of the images; either the left edge or right edge of the first box is between
    the left and right edge of the second box. This long explanation leads to the
    following short pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This satisfies two of the conditions I mentioned at the beginning, but what
    about the vertical axis (*y*)? That works in a similar way, only instead of using
    the left and right sides, we use the top and bottom values respectively. The top
    of box 1 must be above, which means less than, the bottom of box 2\. The bottom
    of box 1 must be below the top of box 2\. If both of those are true, the boxes
    collide. Remember that *y* goes up as we go down the screen in our coordinate
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Vertical collisions](img/Figure_5.06_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Vertical collisions
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a moment to work through these three comparisons, just as we did
    before. For the first comparison, the top of box 1 is above the bottom of box
    2, but the bottom of box 1 is also above the top of box 2, so they do not overlap.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, box 1 is completely below box 2, with no collision. The
    bottom of box 1 is below the top of box 2, which must be true for a collision,
    but the top of box 1 is also below the bottom of box 2, so our first rule of vertical
    collisions does not hold.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third comparison, the top of box 1 is above the bottom of box 2, and
    the bottom of box 1 is below the top of box 2, so we have a collision. This means
    we can extend our pseudocode to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Those are the four things that must be true to get a collision. So, now that
    we know our collisions, we can apply bounding boxes to RHB and a stone so that
    they can collide. Unfortunately, a naive approach will lead to really difficult
    collisions and a nearly impossible game. That problem can be summarized in one
    word – transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Transparency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Figure 5.7*, I''ve drawn bounding boxes in red for both RHB and the stone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Bounding boxes](img/Figure_5.07_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Bounding boxes
  prefs: []
  type: TYPE_NORMAL
- en: These bounding boxes were created by using the size of the entire sprite after
    it was loaded, using the width and height properties of `HTMLImageElement`. As
    you can see, the boxes are far larger than their corresponding sprites, especially
    the one for RHB. This is because the sprite has transparency, which we do not
    want to include in our bounding boxes. Right now, the boxes collide, and RHB would
    be knocked over by the stone well before touching it. That's not what we want!
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of the primary debugging technique for bounding box collisions
    – drawing the boxes so that you can see what's wrong. In this case, RHB's box
    is just way too big. It should be the minimum size required to contain the entire
    image, and the bug this is revealing is that the sprite sheet we used in [*Chapter
    2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*, contains
    a lot of transparency. We'll need to fix that before RHB will properly collide
    with the stone, so let's start trimming the sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Trimming the sprite sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to have RHB crash into a stone, we''re going to have to deal with
    the transparency. Let''s take a look at the raw `.png` file that RHB is coming
    from. A portion of the image is shown in *Figure 5.8*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The sprite sheet](img/Figure_5.08_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The sprite sheet
  prefs: []
  type: TYPE_NORMAL
- en: This is two frames of the *idle* animation, with black lines showing the image
    borders. As you can see, there is a **ton** of extra space in these images, so
    using a bounding box that's the same size as the image won't work. That's the
    problem you see with the bounding boxes in *Figure 5.7*. We have two choices to
    fix it. The simplest, although annoying, would be to open our sprite sheet in
    a graphics editor and find out the actual pixels for the bounding boxes for each
    sprite. Then, we would store that in code or a separate file and use those bounding
    boxes. That's faster in development time, but it means loading a much larger image
    than is necessary and rendering a bunch of transparency for no reason. It's a
    big performance hit to avoid writing some code, but we might do that if we were
    in a game jam and needed to finish the game in a hurry.
  prefs: []
  type: TYPE_NORMAL
- en: What we're going to do is use a *trimmed* sprite sheet, which has the transparency
    taken out. This will mean writing a little code to make sure the sprites still
    line up, but the memory savings alone (because of a smaller graphic file) will
    be worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our trimmed sprite sheet will look like the following (this is a segment):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The trimmed sheet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.09_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – The trimmed sheet
  prefs: []
  type: TYPE_NORMAL
- en: Note that while the white space is trimmed, it's not all removed. That's because
    each rectangle is still the same size across the entire sheet. Look at how the
    knocked-out version of RHB takes up the entire rectangle horizontally but the
    idle RHB takes it up vertically. This means that we'll have to account for some
    transparency with our bounding box, but fortunately, our sprite sheet JSON will
    also have that data. We'll also need to make sure that the sprites are lined up
    properly so that the animations don't jerk around the screen. Fortunately, the
    JSON provides that data as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'All the sprite sheets used here are generated with a tool called **TexturePacker**.
    That includes the JSON that goes along with the graphics. While you can make your
    own texture maps, why would you? TexturePacker (with both free and paid-for versions)
    can be found here: [https://bit.ly/3hvZtDQ](https://bit.ly/3hvZtDQ). TexturePacker
    has built-in tools for trimming a sprite sheet and exporting the data we need
    to make them useful in our game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The trimmed version of the sprite sheet data file will have a little more information
    to go along with what we used in [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038),
    *Drawing Sprites*. Here''s an example of the first two idle sprites from the new
    JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Both frames have the `frame` data that we used previously to cut out our sprite,
    but they also include a `spriteSourceSize` field. That field contains the bounding
    box for the non-transparent portion of the sprite. In other words, the first two
    idle frames had their sprite start with `57` transparent pixels on the left and
    `8` on top. This information is vital to line up the trimmed sprites, which both
    start at `0,0`. Failing to use this will result in an animation that jumps all
    over the page and looks terrible. Fortunately, this is rectified by taking the
    position of the sprite and adding the `spriteSourceSize` *x* and *y* coordinates
    to it. This will result in the sprite not looking like it''s in the right place
    intuitively – that is, when we position the sprite at `0`, it will show up `58`
    pixels to the right, but as long as we also account for `spriteSourceSize` when
    doing collision detection, it won''t matter. Once we''ve accounted for `spriteSourceSize`,
    our bounding boxes will be tight around our sprite sheet, with minimal transparency
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The correct bounding boxes](img/Figure_5.10_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – The correct bounding boxes
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to draw your own bounding boxes for debugging, and I recommend that
    you do, you can add a `draw_rect` function to `Renderer` and draw the rectangle
    on the context. The code can be found in the source for [*Chapter 5*](B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114),
    *Collision Detection*, at [https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/).
  prefs: []
  type: TYPE_NORMAL
- en: With these new, corrected bounding boxes, RHB and the stone don't collide, and
    jumping over the stone safely is eventually possible. In the next section, we'll
    start by adding the new trimmed sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the trimmed sheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `sprite_sheets` directory of the `assets` folder, you can find new versions
    of the sprite sheet named `rhb_trimmed.png` and `rhb_trimmed.json`. Copy those
    over to `static`, but make sure you rename the files `rhb.png` and `rhb.json`
    respectively. Start your server if it isn''t already running, and you should see
    RHB bouncing around on screen because the sprites in the sheet aren''t lined up
    correctly anymore. He''ll also be hovering a little bit over the ground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Shaking RHB](img/Figure_5.11_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Shaking RHB
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first priority will be to fix up his animation so that it isn''t so jerky.
    This is why we spent so much time discussing `spriteSourceSize` earlier – so that
    we can fix his animation. First, we''ll add that field to `Cell`, which you may
    or may not recall is in the `engine` module, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The changes are the additions of the `#[serde(rename_all)]` directive and a
    `sprite_source_size` field. While `spriteSourceSize` is the name in the JSON,
    this is Rust, and in Rust, we use snake case for variable names, which is why
    we use the `serde(rename_all)` directive. `rename_all = "camelCase"` may seem
    backward because we're actually renaming to snake case, but that's because the
    directive refers to serialization, not deserialization. If we were to write out
    this structure to a JSON file, we'd want to rename any variables to be camelCase,
    which means to deserialize, we do the opposite. Thanks to the work we did earlier,
    `sprite_source_size` will be loaded up from the new JSON file, so next, we'll
    need to adjust the drawing so that the animation lines up again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `game` module and the `RedHatBoy` implementation, we''ll change the
    `draw` function slightly to account for the trimming. It looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve reproduced the entire `draw_image` call for context, but only two lines
    have changed. Remember that the `draw_image` call takes two rectangles – the source,
    which is unchanged, and the destination, which is what we changed. Both the *x*
    and *y* coordinates are adjusted by `sprite_source_size` and its respective coordinates.
    The cast to `i16` might make you nervous because it could cause math errors if
    the *x* or *y* position in the sprite sheet is over 215, but that would be a very
    strange sheet. Finally, the `into` call is on the computed result, to turn `i16`
    back into `f32` for the `Rect` struct. After making those changes, you should
    see the animation play correctly, and RHB should return to where he was originally,
    next to the stone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Good bounding boxes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – Good bounding boxes
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re drawing the bounding boxes with `draw_rect`, make sure it''s using
    the same bounding box as the images. Note how the bounding boxes don''t overlap
    anymore. Still, it''s very close, and RHB does hover over the ground a little
    bit. So, let''s adjust his starting position just a bit. At the top of the `red_hat_boy_states`
    module, we are going to change one constant and add a new one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, `FLOOR` was `475`, but let''s push RHB down just a few pixels.
    We''ll also give RHB a negative *x* position, to give a little room between him
    and the stone. Remember that RHB is adjusted back to the right to account for
    animation, so he won''t actually be drawn off screen. Next, we''ll modify the
    `RedHatBoyState<Idle>` implementation, specifically the `new` function, to move
    RHB''s starting point. That change is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, I''ve included the entire `impl` for context, but the only changes are
    the initial position of RHB''s `RedHatBoyContext`, using the new constants. Do
    this, and you''ll have RHB standing with a little bit of runway so that he can
    jump the stone, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Get a running start'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – Get a running start
  prefs: []
  type: TYPE_NORMAL
- en: The bounding boxes are correct in our images, but we're not actually using them
    yet. That's why if you push the right arrow, RHB will still start running and
    pass right behind the stone. It's time to give the stone and RHB proper axis-aligned
    bounding boxes, rather than just drawing them, and then use them to knock RHB
    right over. What fun!
  prefs: []
  type: TYPE_NORMAL
- en: Colliding with an obstacle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have collisions, we'll have to actually put the bounding boxes we've seen
    on both RHB and the stone. Then, in the `update` function of `WalkTheDog`, we'll
    need to detect that collision, and when that collision happens, we'll move RHB
    into the `Falling` and `KnockedOut` states, which correspond to the `Dead` animation
    in the sprite sheet. Much of that code, particularly the state machine, will be
    very familiar, so I'll refrain from reproducing the parts that are repetitive
    and highlight the differences. I will remind you of what needs to change in new
    states, and you can always check the final code at [https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the easiest bounding box, the one for the stone.
  prefs: []
  type: TYPE_NORMAL
- en: A bounding box for a stone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stone is the simplest of the bounding boxes because we can just use the
    size of `HTMLImageElement`. This won't always be the case. If you look at the
    images of the stone with a bounding box around it, you will notice that it is
    larger than the stone's actual size, particularly at the corners. For the time
    being, this will be good enough, but as we proceed, we'll need to keep this in
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a bounding box to the `Image` implementation, which is in the `engine`
    module, we''ll want to calculate the bounding box when `Image` is created, in
    its `new` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added `bounding_box` to the `Image` `struct`, and we construct it
    in the `new` function using `width` and `height` from its `HTMLImageElement` backing.
    It's worth noting that we had to cast the `element.width()` and `element.height()`
    calls to `f32`. This should be safe, but if later we're drawing a very large image,
    then it may become a problem. It's also worth noting that by creating the bounding
    box in the `new` function, we're ensuring that anytime `position` is updated,
    we also need to update `bounding_box`. We could work around this by calculating
    `bounding_box` every time, and that's a fine solution, but it does mean potentially
    losing performance. In this case, we'll keep both `position` and `bounding_box`
    private in `struct` to ensure they don't get out of sync. `Image` objects don't
    move yet, anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that `bounding_box` is private, we''ll need to give it an accessor, so
    let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That takes care of the stone; now, let's give RHB a bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: A bounding box for RedHatBoy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bounding box on `RedHatBoy` is a little more complicated for the same reasons
    that the sprite sheet was more complicated. It needs to align with where the sheet
    is, and it needs to adjust based on the animation. Therefore, we won''t be able
    to do what we did for `Image` and store one `bounding_box` tied to the object.
    Instead, we''ll calculate its bounding box based on its current state and the
    sprite sheet. The code will actually look very similar to `draw`, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate `bounding_box`, we start by creating `frame_name` from the state
    name and the current frame, just like how we did in the `draw`, and then we calculate
    `Rect` from those values using the same calculations we did when we updated the
    `draw` function. In fact, it''s a good time to clean up some of the duplications
    in those two pieces of code, using refactoring. Let''s extract functions to get
    the frame and sprite name, still in the `RedHatBoy` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For `current_sprite`, you''ll need to make sure you import `engine::Cell`.
    Now, we can replace the duplicated code in the `bounding_box` implementation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Going further, we can shrink `draw` by removing the duplicated code from `bounding_box`
    and making a much smaller `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This makes for must smaller, cleaner implementations, but it's worth paying
    attention to the fact that we're looking up `current_sprite` twice on every frame.
    We won't work to fix it now because we're not seeing any troubles, but we may
    want to memoize this value later.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have both bounding boxes, we can actually see whether RHB collides
    with the stone.
  prefs: []
  type: TYPE_NORMAL
- en: Crashing on the collision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To crash on a collision, we''ll need to check whether the two rectangles intersect
    using the pseudocode from earlier, only with real code. We''ll add that code to
    `Rect`, which if you recall is part of the `engine` module. That code is the implementation
    on the `Rect` struct, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This reproduces the previous pseudocode, checking to see whether there is any
    overlap and returning `true` if there is. Every time you see `rect.x + rect.width`,
    that''s the right side, and `rect.y + height` is the bottom. Personally, I prefer
    to put the same rectangle on the left-hand side of this function for every condition,
    as I find it easier to read and think about. We''ll use this code in the `update`
    function of `WalkTheDog`. That code is small, but it will cause a chain reaction.
    The collision code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The check for collisions will happen right after the call to `update` on `boy`.
    We check whether the boy's bounding box has intersected the stone's with our brand
    new `intersects` function, and if it has, we use `knock_out` on the RHB. Poor
    RHB; fortunately, you can always refresh.
  prefs: []
  type: TYPE_NORMAL
- en: The `knock_out` function doesn't exist yet; creating it will mean updating our
    state machine. The `KnockOut` event will cause a transition into the `Falling`
    state, which will then transition into the `KnockedOut` state when the `Falling`
    animation has completed. What are we waiting for? Let's knock out RHB!
  prefs: []
  type: TYPE_NORMAL
- en: A KnockOut event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we did in [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093),
    *Managing Animations with State Machines*, we'll add new states to `RedHatBoyStateMachine`
    and "follow the compiler" to know where to fill in the necessary code. Rust's
    type system does a great job of making this kind of work easy, giving useful error
    messages along the way, so I'm only going to highlight passages that are unique.
    Remember that you can always peek ahead using the source code at [https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly),
    although I highly recommend you try writing the implementation yourself first.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get started in the `game` module by adding a `KnockOut` event to `Event`
    `enum` and a `knock_out` method onto `RedHatBoy` as with the other state machine
    transitions, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will just move the compiler error into `RedHatBoyStateMachine` because
    match statements are incomplete, so you''ll need to add a `KnockOut` event to
    `RedHatBoyStateMachine` that will transition from `Running` to `Falling`. That
    transition is like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder why we also have transitions from `Jumping` and `Sliding` to
    `Falling`; that's because if we don't do that, then the user can simply hold down
    the spacebar to jump continuously, or slide at the right time, and they will pass
    right through the stone. So, we need to make sure that all three of those states
    will transition to `Falling` in order for the game not to have any bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there''s still a lot missing. `Falling` doesn''t exist yet, neither
    as a member of the `RedHatBoyStateMachine` `enum` nor as a struct. The typestates
    for `Sliding`, `Jumping`, or `Running` don''t have `knock_out` methods, and there''s
    no `From` trait implemented to convert from `Falling` into `RedHatBoyStateMachine::Falling`.
    You''ll need to add both of those, just like before, and fill in the rest of the
    compiler errors. You''ll find that you need two new constants, the number of frames
    in the falling animation and the name of the falling animation in the sprite sheet.
    You can look at `rhb.json` and figure out the values, or look at the following
    listings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''ve made all the proper boilerplate changes, you''ll end up making a
    transition from `Running` to `Falling` that looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you''re only transitioning states at this point, not making any changes
    to `RedHatBoyContext`. This is why things get weird because when RHB collides
    with the stone, he falls over… and keeps sliding and falling over forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Sliding while falling?](img/Figure_5.14_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Sliding while falling?
  prefs: []
  type: TYPE_NORMAL
- en: 'The transition properly moves into the `Dead` animation, but it doesn''t stop
    RHB''s forward motion. Let''s change the transition to stop `RedHatBoy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when setting the new state, we call `reset_frame()` to set the frame to
    `0`, as we always do when changing animations, and call the new `stop` function
    that will halt the character''s forward motion. Of course, that function isn''t
    written yet. It''s attached to the `RedHatBoyContext` implementation, setting
    the `velocity.x` to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll want to do the same transition when going from `Sliding` to `Falling`
    and `Jumping` to `Falling` as well so that the transitions match. That will halt
    the character''s forward motion but will not stop the death animation from playing
    over and over again. That''s because we never transition out of the `Falling`
    state and into `KnockedOut`, which itself doesn''t exist yet. Fortunately, we''ve
    done code like this before. Remember in [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093),
    *Managing Animations with State Machines*, we transitioned out of the `Sliding`
    animation and back into the `Running` animation when the slide animation was complete.
    That code, which is in the `update` function of `RedHatBoyState<Sliding>`, is
    reproduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we check every update and see whether the `Sliding` animation
    is complete via `if state_machine.context.frame>= SLIDING_FRAMES`. If it is, we
    return the `Running` state instead of the `Sliding` state. In order to get this
    far, you already had to add an `update` method to `RedHatBoyState<Falling>`, likely
    with a generic default that played the animation. Now, you''ll need to mimic this
    behavior and transition into the new `KnockedOut` state. Specifically, you''ll
    need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `KnockedOut` state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a transition from `Falling` to `KnockedOut`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check in the `update` action whether the `Falling` animation is complete, and
    if so, transition to the `KnockedOut` state instead of staying in `Falling`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `enum` to handle both end states of the `update` method in `RedHatBoyState<Falling>`,
    as well as the corresponding `From` trait, to convert from that to the `RedHatBoyStateMachine`-appropriate
    `enum` variant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only thing new here is that `RedHatBoyState<KnockedOut>` will not need
    the `update` method because, in the `KnockedOut` state, RHB doesn''t do anything.
    We won''t go through that code step by step, and instead, I highly encourage you
    to try it yourself. If you get stuck, you can look at the code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5).
    When you''re done, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Just taking a nap](img/Figure_5.15_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Just taking a nap
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, I'll assume you did it because you're awesome, so we'll move
    on to jumping onto a platform.
  prefs: []
  type: TYPE_NORMAL
- en: Jumping onto a platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that RHB crashes into a stone, we'll need to find a way to go over it. Play
    the game and try jumping the rock; you'll that notice it's really difficult. The
    timing has to be just right, reminiscent of the scorpions in the classic game
    *Pitfall* for the Atari 2600\. Later in this chapter, we'll adjust that by shrinking
    the bounding boxes and increasing the horizontal speed of RHB, but first, we're
    going to put a platform above the stone that RHB can jump on to avoid the rock.
    In addition to putting a platform on screen with a new sprite sheet and giving
    it a bounding box, we'll have to handle a new type of collision. Specifically,
    we'll need to handle collisions coming from above the platform so that we can
    land on it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by adding the platform from a new sprite sheet. This sprite sheet
    actually contains the elements that will make up our map in the upcoming chapters,
    but we''ll use it for just one platform for now. The sprite sheet looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Our platforms'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – Our platforms
  prefs: []
  type: TYPE_NORMAL
- en: 'The image is divided up into squares that aren''t outlined but are visible
    in the way the shapes are arranged, called tiles. Those squares are the sprites
    that we''ll be mixing and matching to make various obstacles for RHB to jump over
    and slide under. The tiles are also jammed together nice and tight, so we won''t
    have to concern ourselves with any offsets. For the time being, we''ll only need
    the platform at the lower-right corner, which will float over the stone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – One platform](img/Figure_5.17_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – One platform
  prefs: []
  type: TYPE_NORMAL
- en: 'This one is conveniently set up with the sprites in order, so it will be easy
    to access in the sprite sheet. You can see those dotted lines now marking the
    three sprites. Let''s get it into our game. In the `sprite_sheets` directory of
    the assets, you''ll find two files, `tiles.json` and `tiles.png`. This is the
    sheet for the tiles, which we''ll need to load at startup. So that we have something
    to load it into, we''ll start by creating a `Platform` struct in the `game` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So far, this just loads up the expected data. At this point, you may note that
    `sheet` and `image` are paired together repeatedly, which means they are good
    candidates for refactoring into a new structure, such as `SpriteSheet`. We won't
    do that now because we don't want to be premature and refactor to a bad abstraction,
    but we'll keep an eye out for the duplication if it shows up again.
  prefs: []
  type: TYPE_NORMAL
- en: The platform is going to need two things. It's going to need to be drawn, and
    it's going to need a bounding box so that we can land on it. To draw the box,
    we'll need to draw the three tiles that make that platform on the bottom together.
    Looking at `tiles.json`, it's hard to tell which platforms we want because the
    frame names are all just numbers such as `14.png`, so just take my word for it
    that the tiles are `13.png`, `14.png`, and `15.png`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It's significantly easier to tell which tiles you need to look at using a tool
    such as TexturePacker. If you don't have that available, you can just draw each
    of the images from the sheet, with their names displayed as well, and then modify
    their names in the JSON file to be more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive into the `draw` function for `Platform` now, which has a little
    trick in it, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The cheat is that we know that the three tiles happen to be next to each other
    in the sheet, so instead of getting all three sprites out of the sheet, we''ll
    just get three times the width of the first sprite. That will happen to include
    the other two tiles. Don''t forget that the second `Rect` is the destination and,
    as such, should use the `position` field. That second rectangle also corresponds
    to the bounding box of the platform, so let''s create the platform''s bounding
    box function and use it there instead. These changes are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This code has the same troubles as other code where we search for the frame
    on every draw and we're doing it twice. We're also constructing `Rect` on every
    `bounding_box` call, which we explicitly avoided earlier. Why the change? Because
    I know the future, and we'll be changing how we construct this shortly, so it's
    not worth worrying about saving an extra cycle or two here. Trust me.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve made a platform that could theoretically be drawn, let''s actually
    draw it. First, we''ll add it to the `Walk` struct, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, that won''t compile because when we create `Walk`, we don''t have
    a platform. We need to update the `initialize` function in `WalkTheDog` to include
    the new `Platform`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'There are only a few small changes here, which I''ve highlighted. We then fetch
    the `tiles.json` and create a new `Platform` with it and `tiles.png`. Finally,
    we create `Walk` with `platform`. Drawing the platform is a one-line change, adding
    it to the `draw` function of `WalkTheDog`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''ve done this correctly, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – An escape!](img/Figure_5.18_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – An escape!
  prefs: []
  type: TYPE_NORMAL
- en: But while the platform has a bounding box, you aren't using it yet, so we'll
    need to add that collision to the `update` function of `WalkTheDog`. When colliding
    with the platform, you'll want to transition from `Jumping` back to `Running`.
    This transition is already written – we do it when we land on the floor – so you'll
    just need to add a check and an event that can perform the transition.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need to make sure that RHB stays on the platform. Currently, gravity
    would just pull him right through it, regardless of whether or not there's a collision
    or the player is in the `Running` state. That solution is a little more complex.
    A naive solution, and I know because I wrote it, is to stop applying gravity when
    the player is on the platform. This works until it doesn't, causing a **Wile E.
    Coyote** effect when RHB runs off the platform and stays in the air. Presumably,
    if he could look down, he would hold up a sign and then crash to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, what we do is continue to apply gravity on every frame and check whether
    RHB is still landing on the platform. If he is, then we adjust him right back
    onto the top of it. This effectively means that RHB "lands" repeatedly until he
    reaches the end of the platform, when he falls off. Fortunately, this isn't visible
    to the user, since we calculate RHB's new position on every update, and this results
    in him moving to the right until he falls off the edge, as he should.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the check to the `update` function so that RHB can land
    on a platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve reproduced the check for the boy intersecting the stone as well so that
    you can see that we checked the bounding box before checking the stone. It doesn''t
    really matter which check comes first, but I prefer to check things that can kill
    the player last. That way we won''t kill the player when we really want them to
    land on a platform. Just as when we created the `knock_out` method on `RedHatBoy`,
    the `land` method and its corresponding `Event` don''t exist yet. You can create
    them both now, and follow the compiler until you have to write the transition
    in the state machines, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we already wrote a transition method from `Jumping` to `Running`,
    so you won't need to write it, but as I mentioned previously, this isn't enough
    to land on the platform. The transition will happen, but RHB will fall right through
    the platform and crash into the ground. Not cool. In order to keep RHB on the
    platform, we need to set its *y* position to the top of the bounding box. This
    will mean changing the `Land` event to store the *y* position of the platform's
    bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Because we used `enum` for the events, we can pass any data we need by adding
    it as part of the variant we are using. The Rust `enum` is a great feature of
    Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'On every intersection with the platform, we''ll transition with the `Land`
    event. This means that the `Update` event will pull the player down a bit because
    of gravity, but then the `Land` event will push them right back up. Since we don''t
    draw the in-between state, it will look fine. This system isn''t perfect, but
    we aren''t writing a physics engine. Let''s do that now; we''ll start by modifying
    the `land` function to be `land_on`, taking a *y* position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `land_on` instead of `land` takes the *y* position of `bounding_box` for
    the platform. If you just follow the compiler errors for that, you will eventually
    need to modify the `Land` event to hold the position and modify the `land` method
    on the `Jumping` typestate. It will probably look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As an initial attempt, this seems fine. It''s unfortunate that `self` had to
    be made mutable, but the transition sets RHB''s position back to the top of the
    platform. The problem is that the *y* position of RHB actually represents his
    top-left corner. This means that if you followed this to its conclusion, you''d
    get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – This does not look right](img/Figure_5.19_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – This does not look right
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, `RedHatBoy` knows his height, so we can adjust for the height
    when setting the *y* position. We would need to include `self.bounding_box.height()`
    as a parameter in the `Land` event and then account for it during the transition,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This sort of works, but it has another problem. The bounding box is actually
    changing size during the animation, based on the current frame of the animation,
    because the trimmed sprite shrinks and grows slightly. As we check collisions
    on every frame, we'll call `Land` repeatedly while RHB is on the platform. If
    we continually change the landing position based on the current frame's height,
    the walk ends up looking very "bouncy." Even though the bounding box is changing
    slightly, it looks better if we use a constant value for the player's height for
    this calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Game development frequently has a lot of trial and error. When the mathematically
    correct solution doesn't play well or look right, remember that the feel of the
    game is more important than mathematical accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have the player height adjustment; we just created it as the `FLOOR`
    constant. In the `game` module, you''ll see that the `FLOOR` constant is set at
    `479`. Well, that means that we can use the height of the game (which is `600`)
    and subtract `FLOOR` to get the player''s height. We can use that info to create
    two new constants. The first, `HEIGHT`, can be defined in the game module as `const
    HEIGHT: i16 = 600` and used wherever we''ve hardcoded the `600` value. The second,
    `PLAYER_HEIGHT`, can be defined in the `red_hat_boy_states` module, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`PLAYER_HEIGHT` belongs in the `red_hat_boy_states` module, since it will only
    be used there, but to calculate it, we need to import `game::HEIGHT` into the
    `red_hat_boy_states module`. We do that with the highlighted `use` statement.
    Now that we have the proper value to adjust RHB when he lands, we can account
    for it in the `land_on` method and `RedHatBoyContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We've moved the adjustment of RHB's position into a `set_on` method in `RedHatBoyContext`.
    The `set_on` method always adjusts for the player's height, which is why it's
    named `set_on` and not `set_position_y`. It also returns `self` so that we won't
    require `mut self` anymore, fitting with the rest of the operations on `RedHatBoyContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the `land` method to the `land_on` method also requires you to modify
    what it is called within the `update` method of `RedHatBoyState<Jumping>`. After
    all, there is no `land` method anymore. Keep in mind that we have to account for
    the height when calling `set_on`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are checking whether RHB is past `FLOOR` and pushing it back up to
    `HEIGHT`. Remember that When we call land_on we send the position of RHB's feet,
    not his head. You could argue that the `update` method shouldn't check for hitting
    the ground and that the higher-level `update` method in `WalkTheDog` should check
    for collisions with the ground and use the `Land` event when appropriate. I think
    I'd agree, but we've made more than enough changes for this chapter, so we'll
    stick with it as it is for now.
  prefs: []
  type: TYPE_NORMAL
- en: This adjusts the position of RHB for landing. He'll be positioned on the platform
    or the ground at the end of his jump. Now, we need to make sure that the `Land`
    event prevents RHB from falling through the platform right after he lands. The
    `Land` event will happen while `Running` occurs on the platform, but it isn't
    handled, so you'll fall right through because gravity takes effect. We're going
    to need a `Land` transition for every state that is valid on the platform, where
    the state stays the same but the `y` position is forced back to the top of the
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If I might steal a line from the *Big Nerd Ranch* series of books, programming
    is hard and you are not stupid. It may appear that these changes emerged fully
    formed because I am a super-expert, but in many cases, these only came about through
    much trial and error, rereading old books, and luck. So, don't worry if you wouldn't
    have come up with this solution off the top of your head or things have gotten
    a little confusing. Take another try at the code, slow down, and have fun. We're
    making a game!
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it''s harder to explain why we need this code than to actually
    write it. We''ll handle the `Land` event for `Running` in the `transition` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll add a `land_on` method to the `RedHatBoyState<Running>` typestate,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For every `Land` event in the `Running` state, you adjust the position and
    stay in the `Running` state. With that, you should see RHB jump onto a platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Running on the platform'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.20_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – Running on the platform
  prefs: []
  type: TYPE_NORMAL
- en: Running on the platform is beginning to work, but you'll find a strange bug
    if you try to run past the edge of the platform. RHB falls through the bottom!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – My God! How did I get here?](img/Figure_5.21_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – My God! How did I get here?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out there is a fairly sneaky bug with the way we are handling gravity,
    which we'll call the "terminal velocity" bug, and we can address that next.
  prefs: []
  type: TYPE_NORMAL
- en: Terminal velocity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you log RHB''s `velocity` in *y* in the `update` method as you jump on the
    platform and walk across it, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Gravity forever!](img/Figure_5.22_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Gravity forever!
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, we add `1` to the gravity on every update until the player jumps
    again. This means that, eventually, the gravity gets so large that the player
    is pulled completely below the platform on an update, and he actually stops intersecting
    it. Our platform is currently at `400`. When the player lands on it, he is at
    `279`, the platform's *y-axis* minus the player's height. On the first frame,
    we pull him down by `1` for gravity, check whether that intersects the platform
    (it does), and land. On the next frame, we pull him down by `2`, the next by `3`,
    and so on. Eventually, we actually pull him completely beneath the platform, he
    does not intersect it, and boom – he's suddenly below the platform. We need to
    fix that by giving gravity a **terminal velocity**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real-world, terminal velocity is the fastest attainable speed by an
    object as it falls because of the drag of the air around it (see [https://go.nasa.gov/3roAWGL](https://go.nasa.gov/3roAWGL)
    for more information). We aren''t going to calculate RHB''s true terminal velocity,
    as there''s no air in his world, but we can use the very scientific method of
    picking a number and seeing whether it works. We''ll set a maximum positive *y*
    velocity of RHB to `20` and clamp his updates to that. That will live in the `RedHatBoyContext`
    `update` method, where we are already modifying *y* for gravity. The code for
    that is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Clamping the velocity at `20` fixes our issue with falling through the platform,
    and now RHB falls off the platform at the end as he should. However, if you try
    to slide (push the arrow down), you'll see that RHB falls right through the platform.
    That's because the `Sliding` state doesn't respond to the `Land` event. You can
    fix that in the exact same way you fixed `Running`, which is an exercise for you.
    Give it a try, and remember that if you get stuck, the final source code is available
    at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5).
    One hint – when you stay in the same state, you don't call `reset_frame`!
  prefs: []
  type: TYPE_NORMAL
- en: That's almost the end of it, but there are two more things to take care of –
    crashing into the bottom of the platform and transparency in the bounding boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Collision from below
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the moment, if RHB collides with the platform, he is set on the top, which
    is great for landing but not so great if he comes from beneath the platform. If
    you were to comment out the collision with the stone right now and run straight
    ahead, you'd actually find yourself suddenly pop up onto the platform! Why? Because
    RHB's head actually bumps into the bottom of the platform, and that collision
    causes the `land_on` event to fire. Instead of banging his head and falling over,
    he teleports onto the platform!
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to have special collision detection here. RHB can only land on the
    platform if he comes from above it; otherwise, it''s game over. Fortunately, this
    can be handled in the `update` function with two small changes to the way we check
    collisions. Collisions with the platform where `RedHatBoy` is *above* the platform
    means landing; otherwise, it''s the same as hitting a stone, and you get knocked
    out. You also need to be *descending*; otherwise, you''ll get this weird effect
    where you stick to the platform while still going up in your jump. Let''s see
    that change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes are to check whether the `RedHatBoy` velocity, in *y*, is greater
    than `0` and, therefore, RHB is moving down. We also check whether the position
    in *y* is less than the top of the platform''s *y* position. This means that the
    boy is above the platform, so he''s landing on it; otherwise, the boy has crashed
    into it, and we knock him out. The `pos_y` and `velocity_y` functions don''t exist
    yet, so we''ll add those to `RedHatBoy`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It's a little tricky to get the *y* values for `RedHatBoy` because they are
    actually on `RedHatBoyContext`, but we are able to pull it off here and wrap them
    in a getter for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of the book, the code here is pretty explicit, but you can make
    it more expressive by extracting a method for `falling` on `RedHatBoy`. We'll
    leave it as it is for now, but you will want to consider some more expressive
    names in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, RHB can finally run, jump over stones, land on platforms, and fall
    off them. However, you''ve probably noticed that the collisions are really crude.
    He crashes into the bottom of the platform easily because the transparent parts
    of the images collide. He also can walk past the edge of the platform, again because
    of the transparent parts of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Believe it or not, I''m walking on air'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.23_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.23 – Believe it or not, I'm walking on air
  prefs: []
  type: TYPE_NORMAL
- en: Let's spend a little time tweaking our bounding boxes to deal with the transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Transparency in bounding boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem with our bounding boxes is that we''re using the image dimensions
    as the bounding box. That means we''ll have a lot of extra space around our characters
    for our bounding boxes. In this screenshot, I''ve used the `draw_rect` method
    from earlier in this chapter to show the bounding boxes for all three objects
    in our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Bounding boxes everywhere'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.24_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.24 – Bounding boxes everywhere
  prefs: []
  type: TYPE_NORMAL
- en: The platform has a lot of white space in the bounding box, particularly at the
    lower-left and lower-right corners. RHB also has white space near the corners
    of his hat. When we turn off the collision checks on the stone and try to walk
    under the platform, RHB "collides" with the lower-left corner of the platform
    well before he actually hits it.
  prefs: []
  type: TYPE_NORMAL
- en: The white space around RHB's feet is a problem too; they are what cause the
    landing on air effect. The far-right edge of his bounding box intersects with
    the platform, so he lands before he's really in the right position. If you could
    see him walk off the edge of the platform, you'd see that it has the same problem
    when he walks off. He takes several steps in mid-air before he begins to fall.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by dealing with RHB's bounding box to make landing and falling off
    the platform look a little more realistic.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the game to fit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are algorithms we can use to make the bounding box better match the actual
    pixels in the image, but ultimately, none of them are necessary. Spend a little
    time with most platformers and you'll see that the collisions aren't perfect,
    and 99% of the time, it's just fine. After spending a little time "researching"
    by playing video games, I determined that if we simply make the box only as wide
    as the feet, he develops a much more realistic landing. This is a little counter-intuitive.
    If we narrow the box, his arm and hat will stick out past the edge of the box;
    we'll miss collisions! Does this matter?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – A narrow bounding box](img/Figure_5.25_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – A narrow bounding box
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, "maybe." Bounding boxes and collision detection are not just
    mathematical problems. They are also game design problems. Making the bounding
    box wrap just around the feet felt right to me when playing the game. Maybe when
    you play it, that will feel too hard when you land on a platform or the hand not
    colliding will bother you, so change the box! It's not written in stone.
  prefs: []
  type: TYPE_NORMAL
- en: 'After experimenting, I found that I wanted to shorten the box as well so that
    RHB couldn''t be knocked out by grazing his hat. To mimic that, we can start by
    renaming `bounding_box` `destination_box`, because that represents where the sprite
    is rendered *to*. It needs to be at the position of `RedHatBoy` in the game but
    with the width and height of the source image; otherwise, the image will appear
    squished. Then, we can re-implement the `RedHatBoy` bounding box, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We start with the original dimensions of the image, `destination_box`, and simply
    shrink it by some offsets. I chose the numbers by using the high-tech system of
    picking numbers and looking at them. This gave me a bounding box that looked natural
    jumping and falling off the cliff while not being so small that RHB never hits
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: If you did a global find and replace on `bounding_box` and changed it to `destination_box`,
    then the collision detection is incorrect. We need to use `bounding_box` for checking
    collisions and `destination_box` for drawing. Drawing should already be complete;
    you'll need to go into the `update` method in `WalkTheDog` and make sure that
    every `intersects` call is on the `bounding_box`, not `destination_box`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new `bounding_box` method and a properly drawn image, you get a bounding
    box that looks like this for RHB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26 – A tight-fit bounding box](img/Figure_5.26_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.26 – A tight-fit bounding box
  prefs: []
  type: TYPE_NORMAL
- en: You can see that it's a lot smaller than the image, which makes the game look
    better and play a little more forgiving. He lands on and falls off the platform
    much more accurately, without a hovering effect. You also might find it easier
    to jump the stone now because the transparent part of RHB doesn't crash into the
    rock.
  prefs: []
  type: TYPE_NORMAL
- en: That leaves us with the white space around the edges of the platform. We can
    shrink the bounding box for it, but that would cause the player to fall through
    the top of the platform when he lands on the edges. The platform is narrower on
    the bottom than the top, which is a problem because we crash into the bottom and
    land on the top. What we really want to do is take the platform and make it into
    multiple bounding boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Subdividing bounding boxes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subdividing the bounding boxes is just like it sounds – we're going to take
    the one bounding box that is currently used for the platform and divide it into
    several. This will dramatically reduce the amount of extra space in the boxes
    and improve our collision detection. You might think that we'll use a complex
    algorithm or tool to determine what boxes to use, and we will – it's our eyeballs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll look at the platform, see the white space, and then try
    out a few versions of the bounding boxes divided up until we find a solution we
    like. We can begin that process by making it possible for `Platform` to have more
    than one bounding box. We''ll do that by, again, renaming `bounding_box` to `destination_box`
    and then creating a new method to construct a vector of `bounding_boxes` from
    that original box, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we create three Rects, each meant to match the platform, starting
    from the destination box of the platform. It''s two small rectangles on the edges
    and one bigger one in the middle. When we draw those boxes, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27 – Platform bounding boxes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.27_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.27 – Platform bounding boxes
  prefs: []
  type: TYPE_NORMAL
- en: That's a lot less white space that you can collide with. You might wonder where
    the values for `X_OFFSET` and `END_HEIGHT` came from, and the truth is that I
    just drew the boxes and looked at them until I was happy. It's not fancy; it's
    just good enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re using a vector of bounding boxes instead of just one, we''ll
    need to change the logic in the `update` method of `WalkTheDog` to make sure that
    RHB can collide with any of the boxes and make the code compile. That code is
    reproduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The change here is to loop through all the bounding boxes and check for a collision
    on any box. There are only three boxes here, so we're not worried about checking
    all three every time. If the computer can't count to three, you probably need
    a new computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you temporarily comment out collisions with the stone again, you''ll see
    that you can just barely walk underneath the platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28 – Just short enough'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.28_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.28 – Just short enough
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might wonder whether this should be a collision. After all,
    his hat does kind of scrape the bottom of the platform. It might be hard for the
    player to tell if they will fit under the the platform. Can we find a workaround
    for this?
  prefs: []
  type: TYPE_NORMAL
- en: Game design through constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we've gone through this section, we've been introducing more and more constants
    for values such as `FLOOR` and `PLAYER_HEIGHT`. Most of the time, we treat magic
    numbers as "bad" in code because they lead to duplication and bugs. That's true,
    but for most of the numbers we've been using, we haven't had duplication. No,
    in this situation, we can use constants to both clarify what the numbers mean
    and use those for game design. We can then use game design to hide little quirks,
    such as our platform being at a height that barely clears the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used `Point { x: 200, y: 400 }` as the location of `Platform` when we originally
    created it. Those were magic numbers – sorry about that. We actually know that
    the *y* value of `400` positions the platform at a pretty confusing location.
    If *y* was `370`, then you would need to go under it, and if it''s `420`, you
    need to go over it. We can create two constants for that and set up the position.
    That change is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 5.29 – You''re not gonna make it!](img/Figure_5.29_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.29 – You're not gonna make it!
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that the platform is a little to the right in this screenshot.
    I wanted to be able to jump over the rock and then jump onto the platform. It's
    impossible to do that with the way we constructed it originally, so I moved the
    platform to the right. I created a constant named `FIRST_PLATFORM` for the *x*
    location of the platform, set it to `370`, and then set the *x* position of `Platform`
    to that.
  prefs: []
  type: TYPE_NORMAL
- en: I also found it nearly impossible to actually just jump the stone with the user's
    combination of speed and gravity. Even after narrowing RHB's collision box, he
    jumps high but not very far. Fortunately, that was very tweakable with constants
    – by simply upping `RUNNING_SPEED` from `3` to `4`, he moved quickly enough to
    make jumping the rock easy.
  prefs: []
  type: TYPE_NORMAL
- en: As we're designing our endless runner, we're going to find that we can hide
    any imperfections in collisions through game design. You'll constantly need to
    tweak values such as the speed of the player, bounding box heights, and obstacle
    locations. The more of the game you can encode into constants, the easier that
    will be.
  prefs: []
  type: TYPE_NORMAL
- en: A quick challenge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we wrote the code to cause RHB to get knocked out if he jumps from below
    the platform, we introduced a bug seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30 – How did he get there?'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.30_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.30 – How did he get there?
  prefs: []
  type: TYPE_NORMAL
- en: What's happening is that when RHB collides with the bottom of the platform,
    he transitions into the `Falling` state, but he doesn't change his velocity, so
    he continues the jump. Then, gravity stops being applied to RHB in the `KnockedOut`
    state. Your challenge is to fix this defect. You'll need to modify the states
    to reflect those changes. Give it a try before you check [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5).
    The changes are small and all in the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made `WalkTheDog` more closely resemble a game by making
    RHB run into obstacles and jump onto platforms. We did all of this with axis-aligned
    bounding boxes and in a scene that looks like a real game, with a background,
    instead of an empty void. We also dealt with some quirks for dealing with trimmed
    sprite sheets, properly handled bounding boxes, and utilized the state machine
    we built in [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing
    Animations with State Machines*, to handle the new animations and manage the state
    of `RedHatBoy`.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how collisions are more than just drawing a box around an image.
    Yes, it's the math behind intersecting boxes, but it's also checking to see whether
    the player is landing or crashing into the platform. We debugged our collision
    boxes with rectangles and used those rectangles to make a better fitting box.
    We even subdivided one image into multiple collision boxes!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was big, we did a lot, and I encourage you to fiddle with and tweak
    the code as you see fit. Have RHB jump lower, or higher, or have him move more
    slowly. Try making the bounding boxes smaller so that it's easier to jump over
    the stone or put the stone on the platform. Use your imagination!
  prefs: []
  type: TYPE_NORMAL
- en: All in all, we've set up the game so that it's ready to become an endless runner,
    with randomly generated terrain and a convincing scroll from left to right. We'll
    develop that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
