- en: '*Chapter 5*: Collision Detection'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make our game fun, our little **Red Hat Boy** (**RHB**) needs to run, jump,
    and slide. Fortunately, we just implemented all that, but he also needs to have
    something to jump on, something to slide under, and something to crash into. To
    make this game fun, we'll need to add **collision detection**, which is one of
    the most fun and most complicated aspects of game design.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection begins with math, detecting whether or not two shapes intersect,
    but leads to all kinds of interesting questions. We'll deal with some of those
    in this chapter, such as, how do we handle transparency in sprites? What do we
    do to make sure a player lands on a platform from above but crashes into a platform
    if they're underneath it? What about sprites that have shapes that aren't a simple
    box? It's going to be a blast!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Creating a real scene
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axis-aligned bounding boxes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting bounding boxes from the sprite sheet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crashing into a stone
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Landing on and falling off a platform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a real game, although it will be a short
    one. You'll have the skills to build your own scenes with good-looking collision
    detection, and you'll know how to integrate collision events with your own programs.
    You'll be able to, if you want, add your own new objects to the scene and crash
    into them or jump off them, or even fall off the world. Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need to download the latest assets for this chapter from [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: You can get the source code for this chapter at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: No new assets are in the download, so if you downloaded them earlier, you don't
    need to do it again.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/36BJYJd](https://bit.ly/36BJYJd)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Creating a real scene
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, RHB can move anywhere he wants, in an empty void, such as the
    one in *The Matrix*. It's progress; all that animation was real work, but it's
    not a game. It's time we put RHB in a setting – a background, platforms, maybe
    something to jump over. Let's start with a background.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Adding the background
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, our game can only render images from a sprite sheet, which we can
    use for a background, but that''s overkill for one image. Instead, we''ll add
    a new `struct` that draws a simple image from a `.png` file. Then, we''ll add
    that to the `draw` and `initialize` functions in `WalkTheDog`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Create an `Image` struct.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can work bottom-up for these changes, adding code to the engine and then
    integrating it into the game. Our `Image` `struct` will use a lot of the same
    code that we wrote in [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038),
    *Drawing Sprites*, but with a simpler setup because we won't be using a sheet.
    All of this code should go into the `engine` module.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自下而上地处理这些更改，先在引擎中添加代码，然后将其集成到游戏中。我们的 `Image` `struct` 将会使用我们在 [*第2章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)，*绘制精灵*
    中编写的很多相同代码，但设置会更简单，因为我们不会使用表格。所有这些代码都应该放入 `engine` 模块中。
- en: 'Start with a `struct` holding `HtmlImageElement`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个持有 `HtmlImageElement` 的 `struct` 开始：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There''s nothing here you haven''t seen before in another form. The `Image
    struct` holds the image element, presumably loaded via the `load_image` function,
    and its position in the scene. `Image` will also need a draw function, but there''s
    no simple way to draw the entire image as it is in `Renderer`. That will need
    a new method, as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有你以前在其他形式中没有看到过的内容。`Image struct` 包含图像元素，假设是通过 `load_image` 函数加载的，以及它在场景中的位置。`Image`
    还需要一个绘制函数，但在 `Renderer` 中没有简单的方法可以绘制整个图像。这需要一个新的方法，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function is very similar to the `draw_image` function we wrote earlier,
    but it's using the simpler version of the JavaScript `drawImage` function that
    only takes an image and a position. To use this method, you'll need to be aware
    of how large the image you're drawing is. If it's too big or too small, it will
    show up just as big or small as the source image.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与我们之前写的 `draw_image` 函数非常相似，但它使用的是更简单的 JavaScript `drawImage` 函数版本，该版本只接受一个图像和一个位置。要使用这种方法，你需要知道你正在绘制的图像有多大。如果它太大或太小，它将显示得与源图像一样大或一样小。
- en: 'Now that you''ve added a method to `Renderer`, go ahead and update the `Image`
    implementation to draw an image with it:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经为 `Renderer` 添加了一个方法，请继续更新 `Image` 实现以使用它来绘制图像：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that you can draw an image, let's load it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以绘制图像了，让我们来加载它。
- en: Load the image.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载图像。
- en: 'The background image can be found in the downloaded assets, in `original/freetileset/png/BG/BG.png`,
    and can be copied into the `static` directory. Then, it can be loaded and used
    to create an `Image` `struct`. That will be done in the `game` module, in the
    `initialize` function of `WalkTheDog`, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 背景图像可以在下载的资产中找到，在 `original/freetileset/png/BG/BG.png` 中，可以将其复制到 `static` 目录。然后，它可以被加载并用于创建一个
    `Image` `struct`。这将在 `game` 模块的 `WalkTheDog` 的 `initialize` 函数中完成，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, only the highlighted last line is new, which
    loads the background from a file. Our `WalkTheDog` `enum` only holds `RedHatBoy`,
    so we're going to have to restructure the code a little. While we could have the
    `WalkTheDog::Loaded` state hold a tuple of `RedHatBoy` and `Background`, that's
    going to get real annoying, real fast.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，只有高亮显示的最后一行是新的，它从文件中加载背景。我们的 `WalkTheDog` `enum` 只包含 `RedHatBoy`，所以我们将不得不稍微重构一下代码。虽然我们可以在
    `WalkTheDog::Loaded` 状态中持有 `RedHatBoy` 和 `Background` 的元组，但这会变得非常烦人，而且会很快。
- en: 'To do that, change `enum` to look like this:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，将 `enum` 改成如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll have `WalkTheDog` represent our game, but I decided that RHB takes the
    dog for "`Walk`. In a generic framework, I might call this a "`Walk` should work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用 `WalkTheDog` 来代表我们的游戏，但我决定让 RHB 带狗去"`Walk"。在一个通用框架中，我可能会称这个为"`Walk`应该可以工作。
- en: 'The `Walk` struct will need to have the RHB and the background, so go ahead
    and add that:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Walk` 结构将需要包含 RHB 和背景，所以请继续添加：'
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Make sure you've imported `Image` from the `engine` module. Now, you can work
    your way down the `game` module and follow the compiler errors. In the `initialize`
    function for `WalkTheDog`, you should see an error for "`` expected struct `Walk`,
    found struct `RedHatBoy` ``".
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经从 `engine` 模块导入了 `Image`。现在，你可以沿着 `game` 模块向下工作，并跟随编译器错误。在 `WalkTheDog`
    的 `initialize` 函数中，你应该看到一个错误，即 "`` expected struct `Walk`, found struct `RedHatBoy`
    ``"。
- en: 'Fix that by creating `Walk` with the background we already loaded and setting
    it in `WalkTheDog::Loaded` that''s returned. This will look as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建带有我们已加载的背景的 `Walk` 并将其设置在返回的 `WalkTheDog::Loaded` 中来修复这个问题。这看起来如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will create `Walk` with a boy and `background` positioned at the upper-left
    corner, but you should still have several compiler errors in the `update` method
    of `WalkTheDog` because those all assume that `WalkTheDog::Loaded` contains `RedHatBoy`.
    Each of those can be changed in the exact same way. The first looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有男孩和位于左上角的`background`的`Walk`，但你仍然会在`WalkTheDog`的`update`方法中看到几个编译错误，因为所有这些假设`WalkTheDog::Loaded`包含`RedHatBoy`。每个都可以以完全相同的方式更改。第一个看起来像这样：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `if let WalkTheDog::Loaded` line is unchanged, except now the variable
    name is `walk` instead of `rhb`. Then, we call `run_right` on `boy` but via the
    `walk` structure. You could argue that we should add methods to `Walk` instead
    of delegating to `boy`, but we''ll hold off on that for now. After all, `walk.run_right()`
    doesn''t really make sense. After fixing all the similar compiler errors in `update`,
    you can also fix a similar error in `draw`, like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`if let WalkTheDog::Loaded`这一行没有变化，除了现在变量名是`walk`而不是`rhb`。然后，我们在`boy`上调用`run_right`，但通过`walk`结构。你可以争论我们应该在`Walk`上添加方法而不是委托给`boy`，但我们现在先不这么做。毕竟，`walk.run_right()`并没有真正意义。在修复`update`中的所有类似编译错误后，你还可以像这样修复`draw`中的类似错误：'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Having done all that, you'll now be drawing… well, you'll be drawing RHB again.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 做完所有这些，你现在将再次绘制……嗯，你将再次绘制RHB。
- en: 'Next, go ahead and draw the background for our game. Drawing the background
    is a matter of using our new draw function, so let''s add that right before the
    `walk.boy.draw` function call, as shown here:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，继续绘制我们游戏的背景。绘制背景只是使用我们新的绘制函数的问题，所以让我们在`walk.boy.draw`函数调用之前添加它，如下所示：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After doing that, you should see RHB standing in front of the background, like
    this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些后，你应该看到RHB站在背景前面，就像这样：
- en: '![Figure 5.1 – Standing in the forest'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 站在森林中'
- en: '](img/Figure_5.01_B17151.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.01_B17151.jpg)'
- en: Figure 5.1 – Standing in the forest
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 站在森林中
- en: Looking at it, you might wonder, how come RHB is so far to the right if his
    *x* coordinate is `0`? Hang on to that thought, as we'll deal with it soon. First,
    let's get a platform onto the screen, using our sprite sheet from [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038),
    *Drawing Sprites*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，你可能会想，为什么RHB的`x`坐标是`0`时却这么靠右？请记住这个想法，因为我们很快就会处理它。首先，让我们使用我们的精灵图集从[*第2章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)，*绘制精灵*，将一个平台放到屏幕上。
- en: Adding an obstacle
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加障碍物
- en: It's great that we have RHB in front of a background, and it looks great, but
    the scene is still a little empty. What if there was something else in the scene?
    Something grand, something innovative, something larger than life. Well, the budget
    for art is low, so how about a stone?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有RHB站在背景前面真是太好了，看起来也很棒，但场景仍然有点空。如果场景中还有其他东西会怎样？一些宏伟的、创新的、超越生命的东西。嗯，艺术预算很低，所以为什么不放一块石头呢？
- en: 'Our new `Image` class means we won''t need much code, and you''ve seen all
    of it before. To add an obstacle, follow these steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的`Image`类意味着我们不需要很多代码，而且你之前都见过。要添加障碍物，请按照以下步骤操作：
- en: 'Start by copying `Stone.png` from `original/freetileset/png/Object/Stone.png`
    in the assets and into the `static` directory. Now, you can add it to `Walk` in
    the same way you added `Background`, like so:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从`assets`中的`original/freetileset/png/Object/Stone.png`复制`Stone.png`到`static`目录。现在，你可以像添加`Background`一样将其添加到`Walk`中，如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That will start causing compiler errors again because `Walk` is created without
    a stone.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次开始引起编译错误，因为`Walk`是在没有石头的情况下创建的。
- en: 'In `initialize`, go ahead and load the stone, just as you loaded the background,
    as shown here:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initialize`中，像加载背景一样加载石头，如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, you need to take the stone that we just loaded and add it to `Walk`.
    We''ll make sure the stone is on the ground by taking the `FLOOR` value (`600`)
    and subtracting the height of the stone image, which happens to be `54` pixels.
    If we position the stone at a *y* position of `546`, it should be sitting right
    on the ground. Here''s the update for creating `Walk`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要拿起我们刚刚加载的石头，并将其添加到`Walk`中。我们将通过取`FLOOR`值（`600`）并减去石头图像的高度（恰好是`54`像素）来确保石头在地面上。如果我们把石头放在`y`位置`546`，它应该正好坐在地面上。以下是创建`Walk`的更新：
- en: '[PRE12]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The stone is `150` pixels to the right, so it will be in front of RHB. Finally,
    draw the stone using the `draw` method. That addition is as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 石头距离右边`150`像素，所以它将在RHB前面。最后，使用`draw`方法绘制石头。这个添加如下：
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code change is small, just drawing the stone with the same call to `draw`
    that we''ve used for `boy` and `background`. Do that, and you''ll have RHB walking
    toward the stone:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更改很小，只是用与`boy`和`background`相同的`draw`调用绘制石头。这样做，你将看到RHB走向石头：
- en: '![Figure 5.2 – Look out for that stone!'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 注意那块石头！'
- en: '](img/Figure_5.02_B17151.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.02_B17151.jpg)'
- en: Figure 5.2 – Look out for that stone!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 注意那块石头！
- en: 'Now, if RHB walks into that stone, he''ll go safely behind it, like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果RHB走进那块石头，他会安全地躲在它后面，就像这样：
- en: '![Figure 5.3 – Easiest game ever'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 世界上最简单的游戏'
- en: '](img/Figure_5.03_B17151.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.03_B17151.jpg)'
- en: Figure 5.3 – Easiest game ever
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 世界上最简单的游戏
- en: That's not much fun. While we've learned how to add new objects into the game,
    and drawn them for a more interactive experience, the game doesn't have any challenges
    yet. We want the boy to crash into the stone and fall over, ending the game. To
    do that, we'll need to learn a little about bounding boxes and collision detection,
    so let's do that in the next section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这没什么意思。虽然我们已经学会了如何将新对象添加到游戏中，并为更互动的体验绘制它们，但游戏还没有任何挑战。我们想让男孩撞到石头上并倒下，结束游戏。为此，我们需要了解一些关于边界框和碰撞检测的知识，所以让我们在下一节中学习这些内容。
- en: Axis-aligned bounding boxes
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轴对齐边界框
- en: Checking whether two objects in our game have collided can, theoretically, be
    done by checking every pixel in every object and seeing whether they share a location.
    That logic, in addition to being very complicated to write, would be computationally
    extremely expensive. We need to run at `60` frames a second and can't spend our
    precious processing power trying to get that kind of perfection – not if we want
    the game to be fun, anyway. Fortunately, we can use a simplification that will
    be close enough to fool our silly eyes, the same way we can't tell that animation
    is really just a series of still images. That simplification is called the *bounding
    box*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中检查两个对象是否发生碰撞，理论上可以通过检查每个对象中的每个像素，看它们是否共享一个位置来实现。这种逻辑不仅编写起来非常复杂，而且在计算上也非常昂贵。我们需要以每秒`60`帧的速度运行，不能浪费我们宝贵的处理能力去追求那种完美——至少如果我们想让游戏有趣的话。幸运的是，我们可以使用一种简化方法，它足够接近以欺骗我们愚蠢的眼睛，就像我们无法分辨动画实际上只是一系列静态图像一样。这种简化方法被称为*边界框*。
- en: 'A bounding box is just a rectangle we''ll use for collisions, instead of checking
    each pixel on the sprite. You can think of every sprite having a box around it,
    which looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 边界框只是一个矩形，我们将用它来进行碰撞，而不是检查精灵上的每个像素。你可以想象每个精灵周围都有一个盒子，看起来像这样：
- en: '![Figure 5.4 – Bounding boxes](img/Figure_5.04_B17151.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 边界框](img/Figure_5.04_B17151.jpg)'
- en: Figure 5.4 – Bounding boxes
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 边界框
- en: These boxes aren't actually drawn; they only exist in the memory of the game,
    except when you want to debug them. When you use boxes, you only have to check
    for the values of the box – top (*y*), left (*x*), right (*x* + width), and bottom
    (*y* + height). It makes for a much faster comparison. Let's talk in a little
    more detail about how to detect when two boxes intersect.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些盒子实际上并没有绘制出来；它们只存在于游戏的内存中，除非你想调试它们。当你使用盒子时，你只需要检查盒子的值——顶部(*y*)，左边(*x*)，右边(*x*
    + 宽度)，和底部(*y* + 高度)。这使比较变得更快。让我们更详细地谈谈如何检测两个盒子是否相交。
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The term "**axis-aligned**" sounds pretty fancy, but all it means is that the
    boxes aren't rotated. *Y* will be up and down, *X* left to right, and always aligned
    with the game's coordinate system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“**轴对齐**”听起来很复杂，但实际上它只是意味着盒子没有旋转。*Y*将向上和向下，*X*从左到右，并且始终与游戏的坐标系对齐。
- en: Collision
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞
- en: 'In order to detect whether two boxes collide or overlap, they will exist in
    the same 2D coordinate space we''ve been using since the beginning of this book.
    They may not be visible, but they are there, sitting where the stone is or running
    along with RHB. They''ll need a position in *x* and *y*, just like a sprite already
    has, and also a width and height. When we check whether two boxes are colliding,
    we check in both the *x* and *y* axes. Let''s first look at how you can tell whether
    two boxes intersect in the *x* axis. Given there are two boxes, box 1 intersects
    box 2 if the left side (or *x* position) of box 1 is less than the right side
    of box 2 but the right side of box 1 is greater than the left side of box 2\.
    This is easier to explain visually:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Collisions'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B17151.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Collisions
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows three sets of two boxes that could potentially collide,
    in a space where *x* increases as you move to the right, just like our canvas.
    The first two comparisons don't collide, but the third does.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the first comparison where box 1 is to the left of box 2, with
    a gap in between them. As you can see, the left side of box 1 is well to the left
    of the right side of box 2, as shown by the arrows. This passes the first condition
    for collision – the left side of box 1 must be less than the right side of box
    2\. However, the right side of box 1 is to the left of box 2's left side, which
    violates our second condition. To collide, the right side of box 1 must be greater
    than (to the right) of the left side of box 2, so these two boxes don't collide.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: In the second comparison, box 1 has been moved to the right of box 2, again
    without overlapping. Box 1's right side is now to the right of box 2's left side,
    so they meet the second condition of colliding, but the left side of box 1 is
    now also to the right of box 2's right side, so the boxes don't meet the first
    condition and still don't collide.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the third comparison, the left side of box 1 is again to the right
    of box 2's right side, but the left side of box 1 is to the left of box 2's right
    side. These two boxes collide. Box 1 and box 2 have overlapping *x* values, so
    they collide.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'If images aren''t your style, it can also help to look at real numbers to see
    how this algorithm works. Assuming box 1 and box 2 are both 10 x 10, squares we
    can form a table, like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_5.01_B17151.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'In every row of this table – that is, every example set of coordinates – box
    2 is in the same place. There are actually four examples here. In the first row,
    box 1 is completely to the left of box 2\. In the second, the boxes collide because
    box 1''s right edge hits box 2''s left edge. In the third, they collide because
    box 1''s left edge is hitting box 2''s right edge. Finally, in the fourth row,
    box 1 is not completely to the right of box 2\. The values hold the same properties
    of the images; either the left edge or right edge of the first box is between
    the left and right edge of the second box. This long explanation leads to the
    following short pseudocode:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张表的每一行中——也就是说，每一组坐标的示例集——框 2 处于相同的位置。这里实际上有四个示例。在第一行中，框 1 完全位于框 2 的左侧。在第二行中，框
    1 的右边缘撞到了框 2 的左边缘，因此它们发生了碰撞。在第三行中，它们发生碰撞是因为框 1 的左边缘撞到了框 2 的右边缘。最后，在第四行中，框 1 并不完全位于框
    2 的右侧。这些值具有与图像相同的属性；第一个框的左边缘或右边缘位于第二个框的左边缘和右边缘之间。这个长篇的解释导致以下简短的伪代码：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This satisfies two of the conditions I mentioned at the beginning, but what
    about the vertical axis (*y*)? That works in a similar way, only instead of using
    the left and right sides, we use the top and bottom values respectively. The top
    of box 1 must be above, which means less than, the bottom of box 2\. The bottom
    of box 1 must be below the top of box 2\. If both of those are true, the boxes
    collide. Remember that *y* goes up as we go down the screen in our coordinate
    space:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这满足了我在一开始提到的两个条件，但关于垂直轴（*y*）呢？它的工作方式类似，只是我们不是使用左右两侧，而是分别使用顶部和底部值。框 1 的顶部必须位于框
    2 的底部之上，这意味着小于框 2 的底部。框 1 的底部必须位于框 2 的顶部之下。如果这两个条件都成立，则框发生碰撞。记住，在我们的坐标系中，*y* 值随着屏幕向下移动而增加：
- en: '![Figure 5.6 – Vertical collisions](img/Figure_5.06_B17151.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 垂直碰撞](img/Figure_5.06_B17151.jpg)'
- en: Figure 5.6 – Vertical collisions
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 垂直碰撞
- en: Let's take a moment to work through these three comparisons, just as we did
    before. For the first comparison, the top of box 1 is above the bottom of box
    2, but the bottom of box 1 is also above the top of box 2, so they do not overlap.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来处理这三个比较，就像我们之前做的那样。对于第一个比较，框 1 的顶部在框 2 的底部之上，但框 1 的底部也在框 2 的顶部之上，所以它们没有重叠。
- en: In the second case, box 1 is completely below box 2, with no collision. The
    bottom of box 1 is below the top of box 2, which must be true for a collision,
    but the top of box 1 is also below the bottom of box 2, so our first rule of vertical
    collisions does not hold.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，框 1 完全位于框 2 下方，没有发生碰撞。框 1 的底部在框 2 的顶部下方，这是碰撞必须满足的条件，但框 1 的顶部也在框 2 的底部下方，因此我们的第一条垂直碰撞规则不成立。
- en: 'In the third comparison, the top of box 1 is above the bottom of box 2, and
    the bottom of box 1 is below the top of box 2, so we have a collision. This means
    we can extend our pseudocode to look like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个比较中，框 1 的顶部在框 2 的底部之上，框 1 的底部在框 2 的顶部之下，所以我们有碰撞。这意味着我们可以扩展我们的伪代码，使其看起来像以下这样：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Those are the four things that must be true to get a collision. So, now that
    we know our collisions, we can apply bounding boxes to RHB and a stone so that
    they can collide. Unfortunately, a naive approach will lead to really difficult
    collisions and a nearly impossible game. That problem can be summarized in one
    word – transparency.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个条件必须同时满足才能发生碰撞。既然我们已经知道了碰撞，现在我们可以将约束框应用到 RHB 和石头上，以便它们可以发生碰撞。不幸的是，一种天真方法会导致非常困难的碰撞和几乎不可能的游戏。这个问题可以用一个词来概括——透明度。
- en: Transparency
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透明度
- en: 'In *Figure 5.7*, I''ve drawn bounding boxes in red for both RHB and the stone:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.7* 中，我为 RHB 和石头画了红色的约束框：
- en: '![Figure 5.7 – Bounding boxes](img/Figure_5.07_B17151.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 约束框](img/Figure_5.07_B17151.jpg)'
- en: Figure 5.7 – Bounding boxes
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 约束框
- en: These bounding boxes were created by using the size of the entire sprite after
    it was loaded, using the width and height properties of `HTMLImageElement`. As
    you can see, the boxes are far larger than their corresponding sprites, especially
    the one for RHB. This is because the sprite has transparency, which we do not
    want to include in our bounding boxes. Right now, the boxes collide, and RHB would
    be knocked over by the stone well before touching it. That's not what we want!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束框是通过使用加载后的整个精灵的大小创建的，使用了 `HTMLImageElement` 的宽度和高度属性。正如你所见，框的大小远大于它们对应的精灵，特别是
    RHB 的那个。这是因为精灵具有透明度，我们不想将其包含在我们的约束框中。目前，框发生了碰撞，RHB 会在接触到石头之前就被撞倒。这不是我们想要的！
- en: This is an example of the primary debugging technique for bounding box collisions
    – drawing the boxes so that you can see what's wrong. In this case, RHB's box
    is just way too big. It should be the minimum size required to contain the entire
    image, and the bug this is revealing is that the sprite sheet we used in [*Chapter
    2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*, contains
    a lot of transparency. We'll need to fix that before RHB will properly collide
    with the stone, so let's start trimming the sprite sheet.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是边界框碰撞的主要调试技术的一个例子——绘制边界框以便可以看到哪里出了问题。在这种情况下，RHB的框太大了。它应该是包含整个图像所需的最小尺寸，而这个错误揭示的是我们在[*第2章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)，*绘制精灵*中使用的精灵表包含了很多透明度。在RHB能够正确与石头碰撞之前，我们需要修复这个问题，所以让我们开始剪辑精灵表。
- en: Trimming the sprite sheet
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剪辑精灵表
- en: 'In order to have RHB crash into a stone, we''re going to have to deal with
    the transparency. Let''s take a look at the raw `.png` file that RHB is coming
    from. A portion of the image is shown in *Figure 5.8*, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让RHB撞到石头上，我们得处理透明度问题。让我们看一下RHB所来源的原始`.png`文件。图像的一部分如图*图5.8*所示，如下：
- en: '![Figure 5.8 – The sprite sheet](img/Figure_5.08_B17151.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 5.8 – The sprite sheet](img/Figure_5.08_B17151.jpg)'
- en: Figure 5.8 – The sprite sheet
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 精灵表
- en: This is two frames of the *idle* animation, with black lines showing the image
    borders. As you can see, there is a **ton** of extra space in these images, so
    using a bounding box that's the same size as the image won't work. That's the
    problem you see with the bounding boxes in *Figure 5.7*. We have two choices to
    fix it. The simplest, although annoying, would be to open our sprite sheet in
    a graphics editor and find out the actual pixels for the bounding boxes for each
    sprite. Then, we would store that in code or a separate file and use those bounding
    boxes. That's faster in development time, but it means loading a much larger image
    than is necessary and rendering a bunch of transparency for no reason. It's a
    big performance hit to avoid writing some code, but we might do that if we were
    in a game jam and needed to finish the game in a hurry.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*空闲*动画的两个帧，黑色线条显示了图像的边界。正如你所见，这些图像中有很多额外的空间，所以使用与图像相同大小的边界框是不行的。这就是你在*图5.7*中看到的边界框问题。我们有两个选择来解决这个问题。最简单的方法，尽管有点烦人，就是在我们图形编辑器中打开精灵表，找出每个精灵的实际边界框像素。然后，我们将这些信息存储在代码或单独的文件中，并使用这些边界框。这会加快开发速度，但意味着需要加载比必要的更大的图像，并且渲染大量的透明度而没有理由。避免编写一些代码而造成的性能损失是很大的，但如果我们处于游戏马拉松中并且需要匆忙完成游戏，我们可能会这样做。
- en: What we're going to do is use a *trimmed* sprite sheet, which has the transparency
    taken out. This will mean writing a little code to make sure the sprites still
    line up, but the memory savings alone (because of a smaller graphic file) will
    be worth it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用一个*剪辑后的*精灵表，其中已经移除了透明度。这意味着需要写一点代码来确保精灵仍然对齐，但仅仅因为图形文件更小而节省的内存就足够补偿了。
- en: 'Our trimmed sprite sheet will look like the following (this is a segment):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剪辑后的精灵表将看起来如下（这是一个片段）：
- en: '![Figure 5.9 – The trimmed sheet'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.9 – The trimmed sheet](img/Figure_5.09_B17151.jpg)'
- en: '](img/Figure_5.09_B17151.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.09_B17151.jpg](img/Figure_5.09_B17151.jpg)'
- en: Figure 5.9 – The trimmed sheet
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 剪辑后的纸张
- en: Note that while the white space is trimmed, it's not all removed. That's because
    each rectangle is still the same size across the entire sheet. Look at how the
    knocked-out version of RHB takes up the entire rectangle horizontally but the
    idle RHB takes it up vertically. This means that we'll have to account for some
    transparency with our bounding box, but fortunately, our sprite sheet JSON will
    also have that data. We'll also need to make sure that the sprites are lined up
    properly so that the animations don't jerk around the screen. Fortunately, the
    JSON provides that data as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然空白区域被剪辑了，但并没有全部移除。这是因为整个表中的每个矩形大小都是相同的。看看RHB被击出的版本在水平方向上占据了整个矩形，而空闲的RHB在垂直方向上占据了它。这意味着我们将在边界框中考虑到一些透明度，但幸运的是，我们的精灵表JSON也将包含这些数据。我们还需要确保精灵正确对齐，以便动画不会在屏幕上跳动。幸运的是，JSON也提供了这些数据。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'All the sprite sheets used here are generated with a tool called **TexturePacker**.
    That includes the JSON that goes along with the graphics. While you can make your
    own texture maps, why would you? TexturePacker (with both free and paid-for versions)
    can be found here: [https://bit.ly/3hvZtDQ](https://bit.ly/3hvZtDQ). TexturePacker
    has built-in tools for trimming a sprite sheet and exporting the data we need
    to make them useful in our game.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的所有精灵图集都是使用一个名为**TexturePacker**的工具生成的。这包括与图形一起的JSON文件。虽然你可以制作自己的纹理图，但你为什么要这么做呢？TexturePacker（包括免费和付费版本）可以在以下网址找到：[https://bit.ly/3hvZtDQ](https://bit.ly/3hvZtDQ)。TexturePacker内置了裁剪精灵图集和导出我们需要的用于在游戏中使用的数据的工具。
- en: 'The trimmed version of the sprite sheet data file will have a little more information
    to go along with what we used in [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038),
    *Drawing Sprites*. Here''s an example of the first two idle sprites from the new
    JSON file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 裁剪版本的精灵图集数据文件将包含比我们在[*第2章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)，“绘制精灵”中使用的更多一些信息。以下是新JSON文件中前两个空闲精灵的示例：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Both frames have the `frame` data that we used previously to cut out our sprite,
    but they also include a `spriteSourceSize` field. That field contains the bounding
    box for the non-transparent portion of the sprite. In other words, the first two
    idle frames had their sprite start with `57` transparent pixels on the left and
    `8` on top. This information is vital to line up the trimmed sprites, which both
    start at `0,0`. Failing to use this will result in an animation that jumps all
    over the page and looks terrible. Fortunately, this is rectified by taking the
    position of the sprite and adding the `spriteSourceSize` *x* and *y* coordinates
    to it. This will result in the sprite not looking like it''s in the right place
    intuitively – that is, when we position the sprite at `0`, it will show up `58`
    pixels to the right, but as long as we also account for `spriteSourceSize` when
    doing collision detection, it won''t matter. Once we''ve accounted for `spriteSourceSize`,
    our bounding boxes will be tight around our sprite sheet, with minimal transparency
    started:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 两个框架都包含了我们之前用来裁剪精灵的`frame`数据，但它们还包含了一个`spriteSourceSize`字段。该字段包含了精灵不透明部分的边界框。换句话说，前两个空闲帧的精灵从左侧的`57`个透明像素和顶部的`8`个像素开始。这些信息对于对齐裁剪后的精灵至关重要，因为它们都从`0,0`开始。如果没有使用这些信息，动画就会在页面上到处跳跃，看起来非常糟糕。幸运的是，通过将精灵的位置与`spriteSourceSize`的*x*和*y*坐标相加，就可以纠正这个问题。这将导致精灵看起来没有在正确的位置上——也就是说，当我们把精灵定位在`0`时，它会在右侧显示`58`个像素，但只要我们在进行碰撞检测时也考虑到`spriteSourceSize`，那就没关系了。一旦我们考虑了`spriteSourceSize`，我们的边界框就会紧贴精灵图集，透明度最小化：
- en: '![Figure 5.10 – The correct bounding boxes](img/Figure_5.10_B17151.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – 正确的边界框](img/Figure_5.10_B17151.jpg)'
- en: Figure 5.10 – The correct bounding boxes
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 正确的边界框
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to draw your own bounding boxes for debugging, and I recommend that
    you do, you can add a `draw_rect` function to `Renderer` and draw the rectangle
    on the context. The code can be found in the source for [*Chapter 5*](B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114),
    *Collision Detection*, at [https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为调试绘制自己的边界框，我建议你这么做，你可以在`Renderer`中添加一个`draw_rect`函数并在上下文中绘制矩形。代码可以在[*第5章*](B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114)，“碰撞检测”的源代码中找到，网址为[https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/)。
- en: With these new, corrected bounding boxes, RHB and the stone don't collide, and
    jumping over the stone safely is eventually possible. In the next section, we'll
    start by adding the new trimmed sprite sheet.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些新的、修正后的边界框，RHB和石头不会发生碰撞，最终可以安全地跳过石头。在下一节中，我们将开始添加新的裁剪精灵图集。
- en: Adding the trimmed sheet
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加裁剪图集
- en: 'In the `sprite_sheets` directory of the `assets` folder, you can find new versions
    of the sprite sheet named `rhb_trimmed.png` and `rhb_trimmed.json`. Copy those
    over to `static`, but make sure you rename the files `rhb.png` and `rhb.json`
    respectively. Start your server if it isn''t already running, and you should see
    RHB bouncing around on screen because the sprites in the sheet aren''t lined up
    correctly anymore. He''ll also be hovering a little bit over the ground:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Shaking RHB](img/Figure_5.11_B17151.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Shaking RHB
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first priority will be to fix up his animation so that it isn''t so jerky.
    This is why we spent so much time discussing `spriteSourceSize` earlier – so that
    we can fix his animation. First, we''ll add that field to `Cell`, which you may
    or may not recall is in the `engine` module, as shown in the following code snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The changes are the additions of the `#[serde(rename_all)]` directive and a
    `sprite_source_size` field. While `spriteSourceSize` is the name in the JSON,
    this is Rust, and in Rust, we use snake case for variable names, which is why
    we use the `serde(rename_all)` directive. `rename_all = "camelCase"` may seem
    backward because we're actually renaming to snake case, but that's because the
    directive refers to serialization, not deserialization. If we were to write out
    this structure to a JSON file, we'd want to rename any variables to be camelCase,
    which means to deserialize, we do the opposite. Thanks to the work we did earlier,
    `sprite_source_size` will be loaded up from the new JSON file, so next, we'll
    need to adjust the drawing so that the animation lines up again.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `game` module and the `RedHatBoy` implementation, we''ll change the
    `draw` function slightly to account for the trimming. It looks like the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I''ve reproduced the entire `draw_image` call for context, but only two lines
    have changed. Remember that the `draw_image` call takes two rectangles – the source,
    which is unchanged, and the destination, which is what we changed. Both the *x*
    and *y* coordinates are adjusted by `sprite_source_size` and its respective coordinates.
    The cast to `i16` might make you nervous because it could cause math errors if
    the *x* or *y* position in the sprite sheet is over 215, but that would be a very
    strange sheet. Finally, the `into` call is on the computed result, to turn `i16`
    back into `f32` for the `Rect` struct. After making those changes, you should
    see the animation play correctly, and RHB should return to where he was originally,
    next to the stone:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Good bounding boxes'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B17151.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – Good bounding boxes
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re drawing the bounding boxes with `draw_rect`, make sure it''s using
    the same bounding box as the images. Note how the bounding boxes don''t overlap
    anymore. Still, it''s very close, and RHB does hover over the ground a little
    bit. So, let''s adjust his starting position just a bit. At the top of the `red_hat_boy_states`
    module, we are going to change one constant and add a new one, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Previously, `FLOOR` was `475`, but let''s push RHB down just a few pixels.
    We''ll also give RHB a negative *x* position, to give a little room between him
    and the stone. Remember that RHB is adjusted back to the right to account for
    animation, so he won''t actually be drawn off screen. Next, we''ll modify the
    `RedHatBoyState<Idle>` implementation, specifically the `new` function, to move
    RHB''s starting point. That change is shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Again, I''ve included the entire `impl` for context, but the only changes are
    the initial position of RHB''s `RedHatBoyContext`, using the new constants. Do
    this, and you''ll have RHB standing with a little bit of runway so that he can
    jump the stone, like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Get a running start'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B17151.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – Get a running start
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The bounding boxes are correct in our images, but we're not actually using them
    yet. That's why if you push the right arrow, RHB will still start running and
    pass right behind the stone. It's time to give the stone and RHB proper axis-aligned
    bounding boxes, rather than just drawing them, and then use them to knock RHB
    right over. What fun!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Colliding with an obstacle
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have collisions, we'll have to actually put the bounding boxes we've seen
    on both RHB and the stone. Then, in the `update` function of `WalkTheDog`, we'll
    need to detect that collision, and when that collision happens, we'll move RHB
    into the `Falling` and `KnockedOut` states, which correspond to the `Dead` animation
    in the sprite sheet. Much of that code, particularly the state machine, will be
    very familiar, so I'll refrain from reproducing the parts that are repetitive
    and highlight the differences. I will remind you of what needs to change in new
    states, and you can always check the final code at [https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the easiest bounding box, the one for the stone.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: A bounding box for a stone
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stone is the simplest of the bounding boxes because we can just use the
    size of `HTMLImageElement`. This won't always be the case. If you look at the
    images of the stone with a bounding box around it, you will notice that it is
    larger than the stone's actual size, particularly at the corners. For the time
    being, this will be good enough, but as we proceed, we'll need to keep this in
    mind.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a bounding box to the `Image` implementation, which is in the `engine`
    module, we''ll want to calculate the bounding box when `Image` is created, in
    its `new` function, as shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we've added `bounding_box` to the `Image` `struct`, and we construct it
    in the `new` function using `width` and `height` from its `HTMLImageElement` backing.
    It's worth noting that we had to cast the `element.width()` and `element.height()`
    calls to `f32`. This should be safe, but if later we're drawing a very large image,
    then it may become a problem. It's also worth noting that by creating the bounding
    box in the `new` function, we're ensuring that anytime `position` is updated,
    we also need to update `bounding_box`. We could work around this by calculating
    `bounding_box` every time, and that's a fine solution, but it does mean potentially
    losing performance. In this case, we'll keep both `position` and `bounding_box`
    private in `struct` to ensure they don't get out of sync. `Image` objects don't
    move yet, anyway.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that `bounding_box` is private, we''ll need to give it an accessor, so
    let''s do that now:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That takes care of the stone; now, let's give RHB a bounding box.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: A bounding box for RedHatBoy
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bounding box on `RedHatBoy` is a little more complicated for the same reasons
    that the sprite sheet was more complicated. It needs to align with where the sheet
    is, and it needs to adjust based on the animation. Therefore, we won''t be able
    to do what we did for `Image` and store one `bounding_box` tied to the object.
    Instead, we''ll calculate its bounding box based on its current state and the
    sprite sheet. The code will actually look very similar to `draw`, as seen here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To calculate `bounding_box`, we start by creating `frame_name` from the state
    name and the current frame, just like how we did in the `draw`, and then we calculate
    `Rect` from those values using the same calculations we did when we updated the
    `draw` function. In fact, it''s a good time to clean up some of the duplications
    in those two pieces of code, using refactoring. Let''s extract functions to get
    the frame and sprite name, still in the `RedHatBoy` implementation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For `current_sprite`, you''ll need to make sure you import `engine::Cell`.
    Now, we can replace the duplicated code in the `bounding_box` implementation,
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Going further, we can shrink `draw` by removing the duplicated code from `bounding_box`
    and making a much smaller `draw` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This makes for must smaller, cleaner implementations, but it's worth paying
    attention to the fact that we're looking up `current_sprite` twice on every frame.
    We won't work to fix it now because we're not seeing any troubles, but we may
    want to memoize this value later.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have both bounding boxes, we can actually see whether RHB collides
    with the stone.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Crashing on the collision
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To crash on a collision, we''ll need to check whether the two rectangles intersect
    using the pseudocode from earlier, only with real code. We''ll add that code to
    `Rect`, which if you recall is part of the `engine` module. That code is the implementation
    on the `Rect` struct, shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This reproduces the previous pseudocode, checking to see whether there is any
    overlap and returning `true` if there is. Every time you see `rect.x + rect.width`,
    that''s the right side, and `rect.y + height` is the bottom. Personally, I prefer
    to put the same rectangle on the left-hand side of this function for every condition,
    as I find it easier to read and think about. We''ll use this code in the `update`
    function of `WalkTheDog`. That code is small, but it will cause a chain reaction.
    The collision code is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The check for collisions will happen right after the call to `update` on `boy`.
    We check whether the boy's bounding box has intersected the stone's with our brand
    new `intersects` function, and if it has, we use `knock_out` on the RHB. Poor
    RHB; fortunately, you can always refresh.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The `knock_out` function doesn't exist yet; creating it will mean updating our
    state machine. The `KnockOut` event will cause a transition into the `Falling`
    state, which will then transition into the `KnockedOut` state when the `Falling`
    animation has completed. What are we waiting for? Let's knock out RHB!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: A KnockOut event
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we did in [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093),
    *Managing Animations with State Machines*, we'll add new states to `RedHatBoyStateMachine`
    and "follow the compiler" to know where to fill in the necessary code. Rust's
    type system does a great job of making this kind of work easy, giving useful error
    messages along the way, so I'm only going to highlight passages that are unique.
    Remember that you can always peek ahead using the source code at [https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly),
    although I highly recommend you try writing the implementation yourself first.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get started in the `game` module by adding a `KnockOut` event to `Event`
    `enum` and a `knock_out` method onto `RedHatBoy` as with the other state machine
    transitions, as shown below:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will just move the compiler error into `RedHatBoyStateMachine` because
    match statements are incomplete, so you''ll need to add a `KnockOut` event to
    `RedHatBoyStateMachine` that will transition from `Running` to `Falling`. That
    transition is like so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You might wonder why we also have transitions from `Jumping` and `Sliding` to
    `Falling`; that's because if we don't do that, then the user can simply hold down
    the spacebar to jump continuously, or slide at the right time, and they will pass
    right through the stone. So, we need to make sure that all three of those states
    will transition to `Falling` in order for the game not to have any bugs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there''s still a lot missing. `Falling` doesn''t exist yet, neither
    as a member of the `RedHatBoyStateMachine` `enum` nor as a struct. The typestates
    for `Sliding`, `Jumping`, or `Running` don''t have `knock_out` methods, and there''s
    no `From` trait implemented to convert from `Falling` into `RedHatBoyStateMachine::Falling`.
    You''ll need to add both of those, just like before, and fill in the rest of the
    compiler errors. You''ll find that you need two new constants, the number of frames
    in the falling animation and the name of the falling animation in the sprite sheet.
    You can look at `rhb.json` and figure out the values, or look at the following
    listings:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you''ve made all the proper boilerplate changes, you''ll end up making a
    transition from `Running` to `Falling` that looks like the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that you''re only transitioning states at this point, not making any changes
    to `RedHatBoyContext`. This is why things get weird because when RHB collides
    with the stone, he falls over… and keeps sliding and falling over forever:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Sliding while falling?](img/Figure_5.14_B17151.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Sliding while falling?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The transition properly moves into the `Dead` animation, but it doesn''t stop
    RHB''s forward motion. Let''s change the transition to stop `RedHatBoy`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, when setting the new state, we call `reset_frame()` to set the frame to
    `0`, as we always do when changing animations, and call the new `stop` function
    that will halt the character''s forward motion. Of course, that function isn''t
    written yet. It''s attached to the `RedHatBoyContext` implementation, setting
    the `velocity.x` to `0`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You''ll want to do the same transition when going from `Sliding` to `Falling`
    and `Jumping` to `Falling` as well so that the transitions match. That will halt
    the character''s forward motion but will not stop the death animation from playing
    over and over again. That''s because we never transition out of the `Falling`
    state and into `KnockedOut`, which itself doesn''t exist yet. Fortunately, we''ve
    done code like this before. Remember in [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093),
    *Managing Animations with State Machines*, we transitioned out of the `Sliding`
    animation and back into the `Running` animation when the slide animation was complete.
    That code, which is in the `update` function of `RedHatBoyState<Sliding>`, is
    reproduced here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this code, we check every update and see whether the `Sliding` animation
    is complete via `if state_machine.context.frame>= SLIDING_FRAMES`. If it is, we
    return the `Running` state instead of the `Sliding` state. In order to get this
    far, you already had to add an `update` method to `RedHatBoyState<Falling>`, likely
    with a generic default that played the animation. Now, you''ll need to mimic this
    behavior and transition into the new `KnockedOut` state. Specifically, you''ll
    need to do the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Create a `KnockedOut` state.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a transition from `Falling` to `KnockedOut`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check in the `update` action whether the `Falling` animation is complete, and
    if so, transition to the `KnockedOut` state instead of staying in `Falling`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `enum` to handle both end states of the `update` method in `RedHatBoyState<Falling>`,
    as well as the corresponding `From` trait, to convert from that to the `RedHatBoyStateMachine`-appropriate
    `enum` variant.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only thing new here is that `RedHatBoyState<KnockedOut>` will not need
    the `update` method because, in the `KnockedOut` state, RHB doesn''t do anything.
    We won''t go through that code step by step, and instead, I highly encourage you
    to try it yourself. If you get stuck, you can look at the code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5).
    When you''re done, it should look like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Just taking a nap](img/Figure_5.15_B17151.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Just taking a nap
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, I'll assume you did it because you're awesome, so we'll move
    on to jumping onto a platform.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Jumping onto a platform
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that RHB crashes into a stone, we'll need to find a way to go over it. Play
    the game and try jumping the rock; you'll that notice it's really difficult. The
    timing has to be just right, reminiscent of the scorpions in the classic game
    *Pitfall* for the Atari 2600\. Later in this chapter, we'll adjust that by shrinking
    the bounding boxes and increasing the horizontal speed of RHB, but first, we're
    going to put a platform above the stone that RHB can jump on to avoid the rock.
    In addition to putting a platform on screen with a new sprite sheet and giving
    it a bounding box, we'll have to handle a new type of collision. Specifically,
    we'll need to handle collisions coming from above the platform so that we can
    land on it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Adding a platform
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by adding the platform from a new sprite sheet. This sprite sheet
    actually contains the elements that will make up our map in the upcoming chapters,
    but we''ll use it for just one platform for now. The sprite sheet looks like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Our platforms'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B17151.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – Our platforms
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The image is divided up into squares that aren''t outlined but are visible
    in the way the shapes are arranged, called tiles. Those squares are the sprites
    that we''ll be mixing and matching to make various obstacles for RHB to jump over
    and slide under. The tiles are also jammed together nice and tight, so we won''t
    have to concern ourselves with any offsets. For the time being, we''ll only need
    the platform at the lower-right corner, which will float over the stone:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – One platform](img/Figure_5.17_B17151.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – One platform
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'This one is conveniently set up with the sprites in order, so it will be easy
    to access in the sprite sheet. You can see those dotted lines now marking the
    three sprites. Let''s get it into our game. In the `sprite_sheets` directory of
    the assets, you''ll find two files, `tiles.json` and `tiles.png`. This is the
    sheet for the tiles, which we''ll need to load at startup. So that we have something
    to load it into, we''ll start by creating a `Platform` struct in the `game` module:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So far, this just loads up the expected data. At this point, you may note that
    `sheet` and `image` are paired together repeatedly, which means they are good
    candidates for refactoring into a new structure, such as `SpriteSheet`. We won't
    do that now because we don't want to be premature and refactor to a bad abstraction,
    but we'll keep an eye out for the duplication if it shows up again.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The platform is going to need two things. It's going to need to be drawn, and
    it's going to need a bounding box so that we can land on it. To draw the box,
    we'll need to draw the three tiles that make that platform on the bottom together.
    Looking at `tiles.json`, it's hard to tell which platforms we want because the
    frame names are all just numbers such as `14.png`, so just take my word for it
    that the tiles are `13.png`, `14.png`, and `15.png`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: It's significantly easier to tell which tiles you need to look at using a tool
    such as TexturePacker. If you don't have that available, you can just draw each
    of the images from the sheet, with their names displayed as well, and then modify
    their names in the JSON file to be more readable.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive into the `draw` function for `Platform` now, which has a little
    trick in it, as seen here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The cheat is that we know that the three tiles happen to be next to each other
    in the sheet, so instead of getting all three sprites out of the sheet, we''ll
    just get three times the width of the first sprite. That will happen to include
    the other two tiles. Don''t forget that the second `Rect` is the destination and,
    as such, should use the `position` field. That second rectangle also corresponds
    to the bounding box of the platform, so let''s create the platform''s bounding
    box function and use it there instead. These changes are shown here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This code has the same troubles as other code where we search for the frame
    on every draw and we're doing it twice. We're also constructing `Rect` on every
    `bounding_box` call, which we explicitly avoided earlier. Why the change? Because
    I know the future, and we'll be changing how we construct this shortly, so it's
    not worth worrying about saving an extra cycle or two here. Trust me.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve made a platform that could theoretically be drawn, let''s actually
    draw it. First, we''ll add it to the `Walk` struct, as shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Of course, that won''t compile because when we create `Walk`, we don''t have
    a platform. We need to update the `initialize` function in `WalkTheDog` to include
    the new `Platform`, as shown here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There are only a few small changes here, which I''ve highlighted. We then fetch
    the `tiles.json` and create a new `Platform` with it and `tiles.png`. Finally,
    we create `Walk` with `platform`. Drawing the platform is a one-line change, adding
    it to the `draw` function of `WalkTheDog`, as shown here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you''ve done this correctly, you should see the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – An escape!](img/Figure_5.18_B17151.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – An escape!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: But while the platform has a bounding box, you aren't using it yet, so we'll
    need to add that collision to the `update` function of `WalkTheDog`. When colliding
    with the platform, you'll want to transition from `Jumping` back to `Running`.
    This transition is already written – we do it when we land on the floor – so you'll
    just need to add a check and an event that can perform the transition.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need to make sure that RHB stays on the platform. Currently, gravity
    would just pull him right through it, regardless of whether or not there's a collision
    or the player is in the `Running` state. That solution is a little more complex.
    A naive solution, and I know because I wrote it, is to stop applying gravity when
    the player is on the platform. This works until it doesn't, causing a **Wile E.
    Coyote** effect when RHB runs off the platform and stays in the air. Presumably,
    if he could look down, he would hold up a sign and then crash to the ground.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Instead, what we do is continue to apply gravity on every frame and check whether
    RHB is still landing on the platform. If he is, then we adjust him right back
    onto the top of it. This effectively means that RHB "lands" repeatedly until he
    reaches the end of the platform, when he falls off. Fortunately, this isn't visible
    to the user, since we calculate RHB's new position on every update, and this results
    in him moving to the right until he falls off the edge, as he should.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the check to the `update` function so that RHB can land
    on a platform:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'I''ve reproduced the check for the boy intersecting the stone as well so that
    you can see that we checked the bounding box before checking the stone. It doesn''t
    really matter which check comes first, but I prefer to check things that can kill
    the player last. That way we won''t kill the player when we really want them to
    land on a platform. Just as when we created the `knock_out` method on `RedHatBoy`,
    the `land` method and its corresponding `Event` don''t exist yet. You can create
    them both now, and follow the compiler until you have to write the transition
    in the state machines, as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Remember that we already wrote a transition method from `Jumping` to `Running`,
    so you won't need to write it, but as I mentioned previously, this isn't enough
    to land on the platform. The transition will happen, but RHB will fall right through
    the platform and crash into the ground. Not cool. In order to keep RHB on the
    platform, we need to set its *y* position to the top of the bounding box. This
    will mean changing the `Land` event to store the *y* position of the platform's
    bounding box.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Because we used `enum` for the events, we can pass any data we need by adding
    it as part of the variant we are using. The Rust `enum` is a great feature of
    Rust.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'On every intersection with the platform, we''ll transition with the `Land`
    event. This means that the `Update` event will pull the player down a bit because
    of gravity, but then the `Land` event will push them right back up. Since we don''t
    draw the in-between state, it will look fine. This system isn''t perfect, but
    we aren''t writing a physics engine. Let''s do that now; we''ll start by modifying
    the `land` function to be `land_on`, taking a *y* position:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, `land_on` instead of `land` takes the *y* position of `bounding_box` for
    the platform. If you just follow the compiler errors for that, you will eventually
    need to modify the `Land` event to hold the position and modify the `land` method
    on the `Jumping` typestate. It will probably look something like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As an initial attempt, this seems fine. It''s unfortunate that `self` had to
    be made mutable, but the transition sets RHB''s position back to the top of the
    platform. The problem is that the *y* position of RHB actually represents his
    top-left corner. This means that if you followed this to its conclusion, you''d
    get something like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – This does not look right](img/Figure_5.19_B17151.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – This does not look right
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, `RedHatBoy` knows his height, so we can adjust for the height
    when setting the *y* position. We would need to include `self.bounding_box.height()`
    as a parameter in the `Land` event and then account for it during the transition,
    like so:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This sort of works, but it has another problem. The bounding box is actually
    changing size during the animation, based on the current frame of the animation,
    because the trimmed sprite shrinks and grows slightly. As we check collisions
    on every frame, we'll call `Land` repeatedly while RHB is on the platform. If
    we continually change the landing position based on the current frame's height,
    the walk ends up looking very "bouncy." Even though the bounding box is changing
    slightly, it looks better if we use a constant value for the player's height for
    this calculation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Game development frequently has a lot of trial and error. When the mathematically
    correct solution doesn't play well or look right, remember that the feel of the
    game is more important than mathematical accuracy.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have the player height adjustment; we just created it as the `FLOOR`
    constant. In the `game` module, you''ll see that the `FLOOR` constant is set at
    `479`. Well, that means that we can use the height of the game (which is `600`)
    and subtract `FLOOR` to get the player''s height. We can use that info to create
    two new constants. The first, `HEIGHT`, can be defined in the game module as `const
    HEIGHT: i16 = 600` and used wherever we''ve hardcoded the `600` value. The second,
    `PLAYER_HEIGHT`, can be defined in the `red_hat_boy_states` module, as shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`PLAYER_HEIGHT` belongs in the `red_hat_boy_states` module, since it will only
    be used there, but to calculate it, we need to import `game::HEIGHT` into the
    `red_hat_boy_states module`. We do that with the highlighted `use` statement.
    Now that we have the proper value to adjust RHB when he lands, we can account
    for it in the `land_on` method and `RedHatBoyContext`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've moved the adjustment of RHB's position into a `set_on` method in `RedHatBoyContext`.
    The `set_on` method always adjusts for the player's height, which is why it's
    named `set_on` and not `set_position_y`. It also returns `self` so that we won't
    require `mut self` anymore, fitting with the rest of the operations on `RedHatBoyContext`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the `land` method to the `land_on` method also requires you to modify
    what it is called within the `update` method of `RedHatBoyState<Jumping>`. After
    all, there is no `land` method anymore. Keep in mind that we have to account for
    the height when calling `set_on`, as shown here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we are checking whether RHB is past `FLOOR` and pushing it back up to
    `HEIGHT`. Remember that When we call land_on we send the position of RHB's feet,
    not his head. You could argue that the `update` method shouldn't check for hitting
    the ground and that the higher-level `update` method in `WalkTheDog` should check
    for collisions with the ground and use the `Land` event when appropriate. I think
    I'd agree, but we've made more than enough changes for this chapter, so we'll
    stick with it as it is for now.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: This adjusts the position of RHB for landing. He'll be positioned on the platform
    or the ground at the end of his jump. Now, we need to make sure that the `Land`
    event prevents RHB from falling through the platform right after he lands. The
    `Land` event will happen while `Running` occurs on the platform, but it isn't
    handled, so you'll fall right through because gravity takes effect. We're going
    to need a `Land` transition for every state that is valid on the platform, where
    the state stays the same but the `y` position is forced back to the top of the
    platform.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: If I might steal a line from the *Big Nerd Ranch* series of books, programming
    is hard and you are not stupid. It may appear that these changes emerged fully
    formed because I am a super-expert, but in many cases, these only came about through
    much trial and error, rereading old books, and luck. So, don't worry if you wouldn't
    have come up with this solution off the top of your head or things have gotten
    a little confusing. Take another try at the code, slow down, and have fun. We're
    making a game!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it''s harder to explain why we need this code than to actually
    write it. We''ll handle the `Land` event for `Running` in the `transition` method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we''ll add a `land_on` method to the `RedHatBoyState<Running>` typestate,
    as shown here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For every `Land` event in the `Running` state, you adjust the position and
    stay in the `Running` state. With that, you should see RHB jump onto a platform:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Running on the platform'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.20_B17151.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – Running on the platform
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Running on the platform is beginning to work, but you'll find a strange bug
    if you try to run past the edge of the platform. RHB falls through the bottom!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – My God! How did I get here?](img/Figure_5.21_B17151.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – My God! How did I get here?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: It turns out there is a fairly sneaky bug with the way we are handling gravity,
    which we'll call the "terminal velocity" bug, and we can address that next.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Terminal velocity
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you log RHB''s `velocity` in *y* in the `update` method as you jump on the
    platform and walk across it, it looks like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Gravity forever!](img/Figure_5.22_B17151.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Gravity forever!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, we add `1` to the gravity on every update until the player jumps
    again. This means that, eventually, the gravity gets so large that the player
    is pulled completely below the platform on an update, and he actually stops intersecting
    it. Our platform is currently at `400`. When the player lands on it, he is at
    `279`, the platform's *y-axis* minus the player's height. On the first frame,
    we pull him down by `1` for gravity, check whether that intersects the platform
    (it does), and land. On the next frame, we pull him down by `2`, the next by `3`,
    and so on. Eventually, we actually pull him completely beneath the platform, he
    does not intersect it, and boom – he's suddenly below the platform. We need to
    fix that by giving gravity a **terminal velocity**.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real-world, terminal velocity is the fastest attainable speed by an
    object as it falls because of the drag of the air around it (see [https://go.nasa.gov/3roAWGL](https://go.nasa.gov/3roAWGL)
    for more information). We aren''t going to calculate RHB''s true terminal velocity,
    as there''s no air in his world, but we can use the very scientific method of
    picking a number and seeing whether it works. We''ll set a maximum positive *y*
    velocity of RHB to `20` and clamp his updates to that. That will live in the `RedHatBoyContext`
    `update` method, where we are already modifying *y* for gravity. The code for
    that is shown here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Clamping the velocity at `20` fixes our issue with falling through the platform,
    and now RHB falls off the platform at the end as he should. However, if you try
    to slide (push the arrow down), you'll see that RHB falls right through the platform.
    That's because the `Sliding` state doesn't respond to the `Land` event. You can
    fix that in the exact same way you fixed `Running`, which is an exercise for you.
    Give it a try, and remember that if you get stuck, the final source code is available
    at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5).
    One hint – when you stay in the same state, you don't call `reset_frame`!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: That's almost the end of it, but there are two more things to take care of –
    crashing into the bottom of the platform and transparency in the bounding boxes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Collision from below
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the moment, if RHB collides with the platform, he is set on the top, which
    is great for landing but not so great if he comes from beneath the platform. If
    you were to comment out the collision with the stone right now and run straight
    ahead, you'd actually find yourself suddenly pop up onto the platform! Why? Because
    RHB's head actually bumps into the bottom of the platform, and that collision
    causes the `land_on` event to fire. Instead of banging his head and falling over,
    he teleports onto the platform!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to have special collision detection here. RHB can only land on the
    platform if he comes from above it; otherwise, it''s game over. Fortunately, this
    can be handled in the `update` function with two small changes to the way we check
    collisions. Collisions with the platform where `RedHatBoy` is *above* the platform
    means landing; otherwise, it''s the same as hitting a stone, and you get knocked
    out. You also need to be *descending*; otherwise, you''ll get this weird effect
    where you stick to the platform while still going up in your jump. Let''s see
    that change:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The changes are to check whether the `RedHatBoy` velocity, in *y*, is greater
    than `0` and, therefore, RHB is moving down. We also check whether the position
    in *y* is less than the top of the platform''s *y* position. This means that the
    boy is above the platform, so he''s landing on it; otherwise, the boy has crashed
    into it, and we knock him out. The `pos_y` and `velocity_y` functions don''t exist
    yet, so we''ll add those to `RedHatBoy`, as shown here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It's a little tricky to get the *y* values for `RedHatBoy` because they are
    actually on `RedHatBoyContext`, but we are able to pull it off here and wrap them
    in a getter for convenience.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Info
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of the book, the code here is pretty explicit, but you can make
    it more expressive by extracting a method for `falling` on `RedHatBoy`. We'll
    leave it as it is for now, but you will want to consider some more expressive
    names in your own code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, RHB can finally run, jump over stones, land on platforms, and fall
    off them. However, you''ve probably noticed that the collisions are really crude.
    He crashes into the bottom of the platform easily because the transparent parts
    of the images collide. He also can walk past the edge of the platform, again because
    of the transparent parts of the image:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Believe it or not, I''m walking on air'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.23_B17151.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.23 – Believe it or not, I'm walking on air
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Let's spend a little time tweaking our bounding boxes to deal with the transparency.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Transparency in bounding boxes
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem with our bounding boxes is that we''re using the image dimensions
    as the bounding box. That means we''ll have a lot of extra space around our characters
    for our bounding boxes. In this screenshot, I''ve used the `draw_rect` method
    from earlier in this chapter to show the bounding boxes for all three objects
    in our scene:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Bounding boxes everywhere'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.24_B17151.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.24 – Bounding boxes everywhere
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The platform has a lot of white space in the bounding box, particularly at the
    lower-left and lower-right corners. RHB also has white space near the corners
    of his hat. When we turn off the collision checks on the stone and try to walk
    under the platform, RHB "collides" with the lower-left corner of the platform
    well before he actually hits it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The white space around RHB's feet is a problem too; they are what cause the
    landing on air effect. The far-right edge of his bounding box intersects with
    the platform, so he lands before he's really in the right position. If you could
    see him walk off the edge of the platform, you'd see that it has the same problem
    when he walks off. He takes several steps in mid-air before he begins to fall.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by dealing with RHB's bounding box to make landing and falling off
    the platform look a little more realistic.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the game to fit
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are algorithms we can use to make the bounding box better match the actual
    pixels in the image, but ultimately, none of them are necessary. Spend a little
    time with most platformers and you'll see that the collisions aren't perfect,
    and 99% of the time, it's just fine. After spending a little time "researching"
    by playing video games, I determined that if we simply make the box only as wide
    as the feet, he develops a much more realistic landing. This is a little counter-intuitive.
    If we narrow the box, his arm and hat will stick out past the edge of the box;
    we'll miss collisions! Does this matter?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – A narrow bounding box](img/Figure_5.25_B17151.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – A narrow bounding box
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, "maybe." Bounding boxes and collision detection are not just
    mathematical problems. They are also game design problems. Making the bounding
    box wrap just around the feet felt right to me when playing the game. Maybe when
    you play it, that will feel too hard when you land on a platform or the hand not
    colliding will bother you, so change the box! It's not written in stone.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'After experimenting, I found that I wanted to shorten the box as well so that
    RHB couldn''t be knocked out by grazing his hat. To mimic that, we can start by
    renaming `bounding_box` `destination_box`, because that represents where the sprite
    is rendered *to*. It needs to be at the position of `RedHatBoy` in the game but
    with the width and height of the source image; otherwise, the image will appear
    squished. Then, we can re-implement the `RedHatBoy` bounding box, like so:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We start with the original dimensions of the image, `destination_box`, and simply
    shrink it by some offsets. I chose the numbers by using the high-tech system of
    picking numbers and looking at them. This gave me a bounding box that looked natural
    jumping and falling off the cliff while not being so small that RHB never hits
    anything.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: If you did a global find and replace on `bounding_box` and changed it to `destination_box`,
    then the collision detection is incorrect. We need to use `bounding_box` for checking
    collisions and `destination_box` for drawing. Drawing should already be complete;
    you'll need to go into the `update` method in `WalkTheDog` and make sure that
    every `intersects` call is on the `bounding_box`, not `destination_box`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new `bounding_box` method and a properly drawn image, you get a bounding
    box that looks like this for RHB:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26 – A tight-fit bounding box](img/Figure_5.26_B17151.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: Figure 5.26 – A tight-fit bounding box
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: You can see that it's a lot smaller than the image, which makes the game look
    better and play a little more forgiving. He lands on and falls off the platform
    much more accurately, without a hovering effect. You also might find it easier
    to jump the stone now because the transparent part of RHB doesn't crash into the
    rock.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: That leaves us with the white space around the edges of the platform. We can
    shrink the bounding box for it, but that would cause the player to fall through
    the top of the platform when he lands on the edges. The platform is narrower on
    the bottom than the top, which is a problem because we crash into the bottom and
    land on the top. What we really want to do is take the platform and make it into
    multiple bounding boxes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Subdividing bounding boxes
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subdividing the bounding boxes is just like it sounds – we're going to take
    the one bounding box that is currently used for the platform and divide it into
    several. This will dramatically reduce the amount of extra space in the boxes
    and improve our collision detection. You might think that we'll use a complex
    algorithm or tool to determine what boxes to use, and we will – it's our eyeballs.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll look at the platform, see the white space, and then try
    out a few versions of the bounding boxes divided up until we find a solution we
    like. We can begin that process by making it possible for `Platform` to have more
    than one bounding box. We''ll do that by, again, renaming `bounding_box` to `destination_box`
    and then creating a new method to construct a vector of `bounding_boxes` from
    that original box, as shown here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In this method, we create three Rects, each meant to match the platform, starting
    from the destination box of the platform. It''s two small rectangles on the edges
    and one bigger one in the middle. When we draw those boxes, it looks like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27 – Platform bounding boxes'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.27_B17151.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.27 – Platform bounding boxes
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: That's a lot less white space that you can collide with. You might wonder where
    the values for `X_OFFSET` and `END_HEIGHT` came from, and the truth is that I
    just drew the boxes and looked at them until I was happy. It's not fancy; it's
    just good enough.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re using a vector of bounding boxes instead of just one, we''ll
    need to change the logic in the `update` method of `WalkTheDog` to make sure that
    RHB can collide with any of the boxes and make the code compile. That code is
    reproduced here:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The change here is to loop through all the bounding boxes and check for a collision
    on any box. There are only three boxes here, so we're not worried about checking
    all three every time. If the computer can't count to three, you probably need
    a new computer.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'If you temporarily comment out collisions with the stone again, you''ll see
    that you can just barely walk underneath the platform:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28 – Just short enough'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.28_B17151.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.28 – Just short enough
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might wonder whether this should be a collision. After all,
    his hat does kind of scrape the bottom of the platform. It might be hard for the
    player to tell if they will fit under the the platform. Can we find a workaround
    for this?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Game design through constants
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we've gone through this section, we've been introducing more and more constants
    for values such as `FLOOR` and `PLAYER_HEIGHT`. Most of the time, we treat magic
    numbers as "bad" in code because they lead to duplication and bugs. That's true,
    but for most of the numbers we've been using, we haven't had duplication. No,
    in this situation, we can use constants to both clarify what the numbers mean
    and use those for game design. We can then use game design to hide little quirks,
    such as our platform being at a height that barely clears the player.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'We used `Point { x: 200, y: 400 }` as the location of `Platform` when we originally
    created it. Those were magic numbers – sorry about that. We actually know that
    the *y* value of `400` positions the platform at a pretty confusing location.
    If *y* was `370`, then you would need to go under it, and if it''s `420`, you
    need to go over it. We can create two constants for that and set up the position.
    That change is shown here:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![Figure 5.29 – You''re not gonna make it!](img/Figure_5.29_B17151.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: Figure 5.29 – You're not gonna make it!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that the platform is a little to the right in this screenshot.
    I wanted to be able to jump over the rock and then jump onto the platform. It's
    impossible to do that with the way we constructed it originally, so I moved the
    platform to the right. I created a constant named `FIRST_PLATFORM` for the *x*
    location of the platform, set it to `370`, and then set the *x* position of `Platform`
    to that.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: I also found it nearly impossible to actually just jump the stone with the user's
    combination of speed and gravity. Even after narrowing RHB's collision box, he
    jumps high but not very far. Fortunately, that was very tweakable with constants
    – by simply upping `RUNNING_SPEED` from `3` to `4`, he moved quickly enough to
    make jumping the rock easy.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: As we're designing our endless runner, we're going to find that we can hide
    any imperfections in collisions through game design. You'll constantly need to
    tweak values such as the speed of the player, bounding box heights, and obstacle
    locations. The more of the game you can encode into constants, the easier that
    will be.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: A quick challenge
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we wrote the code to cause RHB to get knocked out if he jumps from below
    the platform, we introduced a bug seen here:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30 – How did he get there?'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.30_B17151.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.30 – How did he get there?
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: What's happening is that when RHB collides with the bottom of the platform,
    he transitions into the `Falling` state, but he doesn't change his velocity, so
    he continues the jump. Then, gravity stops being applied to RHB in the `KnockedOut`
    state. Your challenge is to fix this defect. You'll need to modify the states
    to reflect those changes. Give it a try before you check [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5).
    The changes are small and all in the existing code.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made `WalkTheDog` more closely resemble a game by making
    RHB run into obstacles and jump onto platforms. We did all of this with axis-aligned
    bounding boxes and in a scene that looks like a real game, with a background,
    instead of an empty void. We also dealt with some quirks for dealing with trimmed
    sprite sheets, properly handled bounding boxes, and utilized the state machine
    we built in [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing
    Animations with State Machines*, to handle the new animations and manage the state
    of `RedHatBoy`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how collisions are more than just drawing a box around an image.
    Yes, it's the math behind intersecting boxes, but it's also checking to see whether
    the player is landing or crashing into the platform. We debugged our collision
    boxes with rectangles and used those rectangles to make a better fitting box.
    We even subdivided one image into multiple collision boxes!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was big, we did a lot, and I encourage you to fiddle with and tweak
    the code as you see fit. Have RHB jump lower, or higher, or have him move more
    slowly. Try making the bounding boxes smaller so that it's easier to jump over
    the stone or put the stone on the platform. Use your imagination!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: All in all, we've set up the game so that it's ready to become an endless runner,
    with randomly generated terrain and a convincing scroll from left to right. We'll
    develop that in the next chapter.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
