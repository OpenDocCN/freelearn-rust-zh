<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Creating Crates and Modules</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating Crates and Modules</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Defining a module in Rust</li>
<li>Building a nested module</li>
<li>Creating a module with struct</li>
<li>Controlling modules</li>
<li>Accessing modules</li>
<li>Creating a file hierarchy</li>
<li>Building libraries in Rust</li>
<li>Calling external crates</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>This chapter focuses on introducing modules and crates in Rust. It will help you develop a highly modular and production-grade Rust application. With this, you will have a great file hierarchy, which will compliment the development of features in a modular fashion. The recipes in the chapter will also help you build libraries in Rust and define, control, and access features through external programs.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining a module in Rust</h1>
                </header>
            
            <article>
                
<p>All the applications must be modularized so that they become easy to maintain and develop. In Rust, we can have a powerful module system for our application that could hierarchically split the application source code into logical units, which we call modules, and manage their visibility (public/private) across the application.</p>
<p><span>The dictionary description of a module is that it's a collection of items, such as functions, structs, traits,</span> impl <span>blocks, and even other modules.</span></p>
<p>You will learn how to create a sample module and understand the concept of visibility in this recipe.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>We will require the Rust compiler and any text editor for coding.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a file named <kbd>sample_mod.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To create a sample module to illustrate<br/>        how to use a module in rust<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create a module named <kbd>sample_mod</kbd> using the <kbd>mod</kbd> keyword and define a function named <kbd>private_function</kbd> in it:</li>
</ol>
<pre>        // Defined module named `sample_mod`<br/>        mod sample_mod {<br/>          // By default all the items in module have private<br/>          visibility<br/> <br/>        fn private_function() {<br/>          println!("called `sample_mod::private_function()`<br/>          \n");<br/>        }
</pre>
<ol start="4">
<li>Define a function named <kbd>sample_function</kbd> by marking its visibility as public, using the <kbd>pub</kbd> keyword in the module:</li>
</ol>
<pre>        // Using the `pub` keyword changes it visibility to public<br/>        pub fn sample_function() {<br/>          println!("called `sample_mod::sample_function()` \n");<br/>        }
</pre>
<ol start="5">
<li>Declare a public function <kbd>indirect_private_fn</kbd>, which would call <kbd>private_function</kbd>:</li>
</ol>
<pre>        // Public items of the module can access the private visible<br/>        items <br/>        pub fn indirect_private_fn() {<br/>          print!("called `sample_mod::indirect_access()`, that \n ");<br/>          private_function();<br/>        }<br/>       }
</pre>
<ol start="6">
<li>Define <kbd>sample_function</kbd> outside the scope of the <kbd>sample_mod</kbd> module:</li>
</ol>
<pre>        // Created a sample function to illustrate calling of <br/>        fn sample_function() {<br/>          println!("Called the `sample_function()` which is not a part<br/>          of<br/>          mod `sample_mod` \n");<br/>        }
</pre>
<ol start="7">
<li>Declare the <kbd>main</kbd> function, in which we will call each item of the <kbd>sample_mod</kbd> module to understand how they work and print the output:</li>
</ol>
<pre>        // Execution of the program starts from here<br/>        fn main() {<br/>          // Calling the sample_function which is outside module<br/>          sample_function();<br/> <br/>          // Calling the public visible sample_mod's sample_function<br/>          sample_mod::sample_function();<br/><br/>          // Accessing the private function indirectly<br/>          sample_mod::indirect_private_fn();<br/><br/>          // Error! `private_function` is private<br/>          //sample_mod::private_function(); // TODO ^ Try uncommenting<br/>          this line <br/>        }
</pre>
<p>Upon the correct setup of the preceding code, you should get the following screenshot output when you compile and run the program:</p>
<div class="CDPAlignCenter CDPAlign"><img style="font-size: 1em" height="132" width="560" src="images/9b6ad408-6aed-42c1-80af-fa537251a934.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, you learned how to create a sample module in Rust and how you are allowed to call the items of the module.</p>
<p>From this chapter onward we will follow the header style, which is our first step. It basically describes what the code or part of the application unit does. This is a very good code practice to follow, as it helps when another person starts off from where you develop.</p>
<p>We created a module named <kbd>sample_mod</kbd> using the <kbd>mod</kbd> keyword, followed by the braces <kbd>{}</kbd>. The content of the module is its items. Each item is designed to perform a specific task. By default, all the items in the module have private visibility, which means that they cannot be accessed directly outside the scope. In the <kbd>sample_mod</kbd> module, we explicitly created two functions with public visibility using the <kbd>pub</kbd> keyword. We added the keyword before creating or declaring the function using the <kbd>fn</kbd> keyword. This makes the item publicly visible outside the scope of the module. The private function or items can be accessed inside the scope of the module, where all the items can call each other, so we can indirectly call a public item to access a private item from it.</p>
<p>We create four functions in this code, where three are inside the module and one is accessible globally. The first function we created inside <kbd>sample_mod</kbd> was <kbd>private_function</kbd>, which, by default, has private visibility. Then we created two public functions, namely <kbd>sample_function</kbd> and <kbd>indirect_private_fn</kbd>, where <kbd>indirect_private_fn</kbd> calls <kbd>private_function</kbd> in its body.</p>
<p>To call an item of the module outside its scope, we have to follow a particular syntax--<kbd>module_name::publically_visible_function name</kbd>. In the <kbd>main</kbd> function, we call <kbd>sample_fucntion</kbd>, which is a regular function, and the two publicly visible items of the <kbd>sample_mode</kbd> module: <kbd>function sample_mod::sample_function()</kbd> and <kbd>sample_mod::indirect_private_fn()</kbd>. These items will execute the content inside their respective scope.</p>
<div class="packt_infobox">On calling the private item of the module, it will throw an error saying that the particular item is private. For example, in the preceding recipe, we got an error when we directly called <kbd>sample_mod::private_function();</kbd> from the <kbd>main</kbd> function.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a nested module</h1>
                </header>
            
            <article>
                
<p>A nested module is where we want to have modules inside modules, performing different tasks. You will learn how to declare and access the items of a nested module.</p>
<p>Nested modules are a great way of having similar items or functional units in an application together, which helps in maintaining features and debugging crashes.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a file named <kbd>sample_nested.rs</kbd> in the project workspace</li>
<li>Write the code header information, which will provide an overview of the code:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To create a sample nested_mod module<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create a module named <kbd>sample_mod</kbd> using the <kbd>mod</kbd> keyword:</li>
</ol>
<pre>        // Defined module named `sample_mod`<br/>        mod sample_mod {
</pre>
<ol start="4">
<li>Create another module named <kbd>nested_mod</kbd> with <kbd>function</kbd> and public visibility under the <kbd>sample_mod</kbd> module, which makes <kbd>sample_mod</kbd> a nested module:</li>
</ol>
<pre>        // Defined public Nested module named `nested_mod`<br/>         pub mod nested_mod {<br/>           pub fn function() {<br/>             println!("called `sample_mod::nested_mod::function()`");<br/>           }
</pre>
<ol start="5">
<li>Create a function named <kbd>private_function</kbd> under the <kbd>nested_mod</kbd> module:</li>
</ol>
<pre>        #[allow(dead_code)]<br/>        fn private_function() {<br/>          println!("called<br/>          `sample_mod::nested_mod::private_function()`");<br/>        }<br/>        }
</pre>
<ol start="6">
<li>Define another module named <kbd>private_nested_mod</kbd> with a public function named <kbd>function</kbd> inside <kbd>sample_mod</kbd>:</li>
</ol>
<pre>        // Nested modules follow the same rules for visibility<br/>        mod private_nested_mod {<br/>          #[allow(dead_code)]<br/>          pub fn function() {<br/>            println!("called<br/>            `sample_mod::private_nested_mod::function()`");<br/>          }<br/>        }<br/>        }
</pre>
<ol start="7">
<li>Define the <kbd>main</kbd> function and call the nested modules with different items declared in them:</li>
</ol>
<pre>        // Execution starts from main function<br/>        fn main() {<br/>          sample_mod::nested_mod::function();<br/>          // Private items of a module cannot be directly accessed,even<br/>          if nested_mod in a public module<br/><br/>          // Error! `private_function` is private<br/>          //sample_mod::nested_mod::private_function(); // TODO ^ Try<br/>          uncommenting this line<br/><br/>          // Error! `private_nested_mod` is a private module<br/>          //sample_mod::private_nested_mod::function(); // TODO ^ Try<br/>          uncommenting this line<br/>        }
</pre>
<p style="padding-left: 60px">Upon the correct setup of the preceding code, you should get the following output when you compile and run the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="50" width="647" src="images/12cab925-0611-405f-8ea7-fa5949698ca2.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The nested module is a concept where you have a module inside another module. This feature is helpful in having a collection of units of application placed inside a common header.</p>
<p>In this recipe, we created a module named <kbd>sample_mod</kbd> using the <kbd>mod</kbd> keyword; in this module, we created two more modules, namely <kbd>nested_mod</kbd> and <kbd>private_nested_mod</kbd>, with different visibility. The rules of modules' visibility follow the same rules as those of the items of the modules: we have to explicitly mention the <kbd>pub</kbd> keyword to mention the visibility of the module. If we do not mention anything, it will be considered private by the Rust compiler.</p>
<p>We then create the items inside the nested modules, which are under the <kbd>sample_mod</kbd> module. In <kbd>nested_mod</kbd>, which is a public nested module, we created two items: a public method named <kbd>function</kbd> and a private method named <kbd>private_function</kbd>. In the other private nested module <kbd>private_nested_mod</kbd>, we created a public method named <kbd>function</kbd>.</p>
<div class="packt_infobox">We can have the same name for items/units residing inside different modules. In the preceding recipe, we had an item named <kbd>function</kbd>, which was present in both the nested modules.</div>
<p>In the <kbd>main</kbd> function, we call the respective items that follow the standard syntax for accessing items. The only difference here is that the items reside inside different nested modules. In this case, we follow the <kbd>module_name::nested_module_name:item_name</kbd> syntax. Here, we first call the module name, followed by the nested module name and its items.</p>
<p>We call a public nested module a public item, which is <kbd>sample_mod::nested_mod::function()</kbd>. It will run fine and execute the contents of the item. On calling a private nested module, which in our recipe is <kbd>sample_mod::nested_mod::private_function()</kbd>, and similar private items of the public nested module, which in our recipe is <kbd>sample_mod::private_nested_mod::function()</kbd>, we will get an error mentioning that these items are private, as privately visible units cannot be directly accessed outside the scope.</p>
<p>We have the <kbd>#[allow(dead_code)]</kbd> attribute for the item <kbd>function</kbd> in the <kbd>private_nested_mod</kbd> module. The idea is to disable the <kbd>dead_code</kbd> lint of the compiler, which will warn about the unused function. In simple terms, lint is software which flags bugs in the code.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a module with struct</h1>
                </header>
            
            <article>
                
<p>This recipe covers the structs that have an extra level of visibility with their fields. The visibility defaults to private and can be overridden with the pub modifier. This visibility only matters when a <kbd>struct</kbd> is accessed from outside the module, where it is defined and has the goal of hiding information (encapsulation).</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a file named <kbd>sample_struct.rs</kbd> in the project workspace</li>
<li>Write the code header with the details of the code:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To create a sample nested_mod module<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create a sample module named <kbd>sample_struct</kbd>, in which you can declare a public <kbd>struct</kbd> named <kbd>WhiteBox</kbd>:</li>
</ol>
<pre>        // Sample module which has struct item<br/>        mod sample_struct {<br/>          // A public struct with a public field of generic type `T`<br/>          pub struct WhiteBox&lt;T&gt; {<br/>            pub information: T,<br/>          }
</pre>
<ol start="4">
<li>Declare a public <kbd>struct</kbd> named <kbd>BlackBox</kbd> with a private generic type <kbd>T</kbd>:</li>
</ol>
<pre>        // A public struct with a private field of generic type `T`<br/>        #[allow(dead_code)]<br/>        pub struct BlackBox&lt;T&gt; {<br/>        information: T,<br/>        }
</pre>
<ol start="5">
<li>Create a public constructor named <kbd>const_new</kbd> using the <kbd>impl</kbd> keyword, which takes the generic <kbd>T</kbd> type as input:</li>
</ol>
<pre>        impl&lt;T&gt; BlackBox&lt;T&gt; {<br/>          // A public constructor method<br/>          pub fn const_new(information: T) -&gt; BlackBox&lt;T&gt; {<br/>            BlackBox {<br/>              information: information,<br/>            }<br/>          }<br/>        }<br/>        }
</pre>
<ol start="6">
<li>Declare the <kbd>main</kbd> function by calling the <kbd>struct</kbd> items of the<kbd>sample_struct</kbd> module, which is the <kbd>whitebox</kbd> <kbd>struct</kbd> item:</li>
</ol>
<pre>        // Execution starts here<br/>        fn main() {<br/> <br/>          // Public structs with public fields can be constructed as<br/>          usual<br/>          let white_box = sample_struct::WhiteBox { information:<br/>          "public<br/>          information n" };<br/><br/>        // and their fields can be normally accessed.<br/>        println!("The white box contains: {} \n",<br/>        white_box.information);<br/>        // Public structs with private fields cannot be constructed<br/>        using field names.<br/>        // Error! `BlackBox` has private fields<br/>        //let black_box = sample_struct::BlackBox { information:<br/>        "classified information" };<br/>        // TODO ^ Try uncommenting this line<br/>        // However, structs with private fields can be created using<br/> <br/>        // public constructors<br/>        let _black_box = sample_struct::BlackBox::const_new("classified<br/>        information \n");<br/> <br/>        // and the private fields of a public struct cannot be<br/>        accessed.<br/>        // Error! The `information` field is private<br/>        //println!("The black box contains: {}",<br/>        _black_box.information);<br/>        // TODO ^ Try uncommenting this line<br/>        }
</pre>
<p>Upon the correct setup of the preceding code, you should get the following output when you compile and run the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="55" width="701" src="images/72c586e8-b773-412f-86f0-dc9e5fc4820c.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Until now, in the preceding recipes, we were only looking into modules that had functions that acted as their items. In this recipe, we will create <kbd>struct</kbd> items that have an extra level of visibility with their fields.</p>
<p>The visibility, by default, is private and can be changed using the <kbd>pub</kbd> keyword. The visibility allows us to hide information when we try to access a modules', items out of the scope of the module.</p>
<p>We created a module named <kbd>sample_struct</kbd> using the <kbd>mod</kbd> keyword. We created two structs with public visibility, named <kbd>WhiteBox</kbd> and <kbd>BlackBox</kbd>, using the <kbd>pub</kbd> and <kbd>struct</kbd> keywords. In both the <kbd>struct</kbd> items, we had a generic type <kbd>T</kbd>.</p>
<div class="packt_infobox">In Rust, generic means that the particular unit can accept one or more generic type parameters, <kbd>&lt;T&gt;</kbd>. For example, consider <kbd>fn foo&lt;T&gt;(T) { ... }</kbd>. Here, <kbd>T</kbd> is the argument that is specified as a generic type parameter using <kbd>&lt;T&gt;</kbd>, and it allows it to take any argument of any type.</div>
<p>In both structs, we had a field named <kbd>information</kbd>, which was tied up with <kbd>T</kbd>, which is the argument we received. The only difference is that we mentioned <kbd>information</kbd> in <kbd>WhiteBox</kbd> as public inside the <kbd>struct</kbd> and <kbd>information</kbd> inside <kbd>BlackBox</kbd> as private by default.</p>
<p>Next up, we created an implementation block for <kbd>BlackBox</kbd> where we explicitly specified the generic type <kbd>T</kbd> in the <kbd>impl</kbd> block. Inside it, we created a method named <kbd>const_new</kbd>, which we made publically visible, that accepted the generic type <kbd>T</kbd> as an argument and returned a <kbd>BlackBox</kbd> <kbd>struct</kbd>. The <kbd>const_new</kbd> acts as a public constructor for <kbd>BlackBox</kbd>, where we wanted to create the data type.</p>
<p>In the <kbd>main</kbd> block, we created the <kbd>WhiteBox</kbd> structure first and assigned it to a variable named <kbd>white_box</kbd> by <kbd>sample_struct::WhiteBox { information: "public information \n" }</kbd>. Here, we were calling the module, creating a complex data structure and printing the <kbd>white_box</kbd>, information field, which was delivered in the preceding step. Next, we tried to create a variable with the data structure of <kbd>BlackBox</kbd> in a similar manner. This led to an error saying the field name is private. This is the reason why we created a public method <kbd>const_new</kbd>, which is a constructor for the <kbd>BlackBox</kbd> data type. We performed this step by <kbd>sample_struct::BlackBox::const_new("classified information \n")</kbd> and assigned it to <kbd>_black_box</kbd>.</p>
<p>This passed the argument from <kbd>main</kbd> to the <kbd>impl</kbd> block and created the structure. In this way, we were able to define a public <kbd>struct</kbd> with private fields, but we were still not able to publically access the information field by <kbd>_black_box.information</kbd>, as it was a private field originally.</p>
<p>The private members can be accessed by indirect methods in the module. Consider the following code snippet:</p>
<pre>pub mod root {<br/>    use self::foo::create_foo;<br/>    mod foo {<br/>        pub struct Foo {<br/>            i: i32,<br/>        }<br/>        impl Foo{<br/>            pub fn hello_foo(&amp;self){<br/>                println!("Hello foo");<br/>            }<br/>        }<br/>        pub fn create_foo(i: i32) -&gt; Foo{<br/>            Foo { i: i }<br/>        }<br/>    }<br/>    pub mod bar {<br/>        pub struct Bar {<br/>            pub f: ::root::foo::Foo,<br/>        }<br/>        impl Bar {<br/>            pub fn new(i: i32) -&gt; Self {<br/>                Bar { f: ::root::foo::create_foo(i) }<br/>            }<br/>        }<br/>    }<br/>}<br/>fn main() {<br/>    //still private<br/>    //let f = root::foo::create_foo(42);<br/>    let b = root::bar::Bar::new(42);<br/>    b.f.hello_foo();<br/>}
</pre>
<p class="mce-root">We expose a public constructor <kbd>create_foo</kbd> in the <kbd>foo</kbd> module, but the module <kbd>foo</kbd> still remains private and we only expose <kbd>create_foo</kbd> in <kbd>root</kbd> by the <kbd>use</kbd> keyword, which means that <kbd>bar</kbd> can now create a <kbd>Foo</kbd> <kbd>struct</kbd> but <kbd>create_foo</kbd> is still private outside of <kbd>root</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling modules</h1>
                </header>
            
            <article>
                
<p>This recipe focuses on the usage of the <kbd>use</kbd> keyword in the Rust module, which will help in binding long and tiresome module call paths to a simple single entity. This will improve code readability and provide more control to the developer to call module units. We will also go through the scope of <kbd>use</kbd> and the concept of shadowing.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a file named <kbd>sample_control.rs</kbd> in the project workspace.</li>
<li>Write the code header with the details of the code:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To create a sample module to illustrating `use`<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create <kbd>other_function</kbd> using the <kbd>use</kbd> keyword, in order to create the binding for the <kbd>deeply</kbd> module's items:</li>
</ol>
<pre>        // Bind the `deeply::nested::function` path to<br/>        `other_function`.<br/>        use deeply::nested::sample_function as other_function;
</pre>
<ol start="4">
<li>Declare the nested module <kbd>deeply</kbd> with the nested module named <kbd>nested</kbd> containing the public function <kbd>sample_function</kbd>:</li>
</ol>
<pre>        // Defined a nested <br/>        mod deeply {<br/>          pub mod nested {<br/>            pub fn sample_function() {<br/>              println!("called `deeply::nested::function()` \n")<br/>            }<br/>          }<br/>        }
</pre>
<ol start="5">
<li>Create a function named <kbd>sample_function</kbd>:</li>
</ol>
<pre>        fn sample_function() {<br/>          println!("called `function()` \n");<br/>        } 
</pre>
<ol start="6">
<li>Declare the <kbd>main</kbd> function by calling <kbd>other_function</kbd>:</li>
</ol>
<pre>        fn main() {<br/>          // Easier access to `deeply::nested::function`<br/>          other_function();
</pre>
<ol start="7">
<li>Create a block. In this block, use the <kbd>use</kbd> keyword and declare <kbd>deeply :: nested :: sample_function</kbd>, which is equivalent to binding it to <kbd>sample_function</kbd>:</li>
</ol>
<pre>        println!("Entering a block n");<br/>        {<br/>          // This is equivalent to `use deeply::nested::sample_function<br/>          as sample_function`.<br/>          // This `sample_function()` will shadow the outer one.<br/>          use deeply::nested::sample_function;<br/>          sample_function();<br/><br/>        // `use` bindings have a local scope. In this case, the<br/>        // shadowing of `function()` is only in this block.<br/>        println!("Leaving the block \n");<br/>        }
</pre>
<ol start="8">
<li>Call <kbd>sample_function</kbd> outside the block that is created:</li>
</ol>
<pre>        sample_function();<br/>        }
</pre>
<p style="padding-left: 30px">Upon the correct setup of the preceding code, you should get the following output when you compile and run the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="136" width="474" src="images/56deda1c-814d-4cbf-ae51-2eadc68a3039.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We focused on the <kbd>use</kbd> keyword in this recipe, which is really handy when your modules get deeper (which means there are a lot of nested modules and units). In short, <kbd>use</kbd> helps bind a long module call to a single name. In the preceding recipe, we had a nested module named <kbd>deeply</kbd>, where <kbd>nested</kbd> is the module inside <kbd>deeply</kbd> that has a public function named <kbd>sample_function</kbd>. Conventionally, we can call this function by <kbd>deeply::nested::sample_function</kbd>; however, using the <kbd>use</kbd> keyword, we can bind this to a single entity and call it in the <kbd>main</kbd> function, which provides much easier access. Here, we bound this path to <kbd>other_function()</kbd> and we also created a normal function named <kbd>sample_function</kbd> to understand the concept of shadowing.</p>
<p>We created a block inside the <kbd>main</kbd> function and explicitly mentioned <kbd>use deeply::nested::sample_function</kbd> . We also called <kbd>sample_function</kbd> after that. This calls the <kbd>deeply</kbd> module's <kbd>sample_function</kbd> item rather than the globally available function and the <kbd>use</kbd> mentioned in the block ends once it goes outside the scope. Calling <kbd>sample_function</kbd> outside the block will lead to calling the global function, as <kbd>use</kbd> is not active anymore.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accessing modules</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use the <kbd>self</kbd> and <kbd>super</kbd> keywords in Rust to provide better access to the module's units and learn about the scope of Rust units. In this recipe, we will create various module units across the code with similar names, to create ambiguity in the unit name. We will check out how the <kbd>self</kbd> and <kbd>super</kbd> keywords help the developer overcome these problems.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for coding. Also, create a file named <kbd>sample_module.rs</kbd> in the project workspace.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a file named <kbd>sample_access.rs</kbd> in the project workspace.</li>
<li>Write the code header with the details of the code:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To create a sample module to illustrating `self` and<br/>        `super`<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create a function named <kbd>sample_function</kbd> and print <kbd>"called `sample_function()`"</kbd> in its scope:</li>
</ol>
<pre>        fn sample_function() {<br/>          println!("called `sample_function()`");<br/>        }
</pre>
<ol start="4">
<li>Declare a module named <kbd>cool</kbd> using the <kbd>mod</kbd> keyword and create a function named <kbd>sample_function</kbd> with public visibility. Then, print <kbd>called `cool::sample_function()` n</kbd> in its scope:</li>
</ol>
<pre>        // Ddefined a module names cool<br/>        mod cool {<br/>          pub fn sample_function() {<br/>            println!("called `cool::sample_function()` \n");<br/>          }<br/>        }
</pre>
<ol start="5">
<li>Create another module using the <kbd>mod</kbd> keyword named <kbd>sample_mod</kbd> and create a function item named <kbd>sample_function</kbd> by printing <kbd>"called `sample_mod::sample_function()` n"</kbd>:</li>
</ol>
<pre>        mod sample_mod {<br/>          fn sample_function() {<br/>            println!("called `sample_mod::sample_function()` \n");<br/>          }
</pre>
<ol start="6">
<li>Create a module named <kbd>cool</kbd> with the function item <kbd>sample_function</kbd> by marking its visibility as public using the <kbd>pub</kbd> keyword, and printing <kbd>"called `sample_mod::cool::sample_function()` n"</kbd>:</li>
</ol>
<pre>        mod cool {<br/>          pub fn sample_function() {<br/>            println!("called `sample_mod::cool::sample_function()`<br/>            \n");<br/>          }<br/>        }
</pre>
<ol start="7">
<li>Create another function inside the <kbd>cool</kbd> module named <kbd>indirect_call</kbd> by marking its visibility as public using the <kbd>pub</kbd> keyword, and printing <kbd>"called `sample_mod::indirect_call()`, thatn&gt; "</kbd>:</li>
</ol>
<pre>        pub fn indirect_call() {<br/>          // Let's access all the sample_functions named<br/>          `sample_function` from<br/>          this scope!<br/>          print!("called `sample_mod::indirect_call()`, that \n &gt; ");
</pre>
<p style="padding-left: 60px">Call <kbd>sample_function</kbd> using the <kbd>self</kbd> and <kbd>super</kbd> keywords:</p>
<pre>        // The `self` keyword refers to the current module scope - in<br/>        this case<br/>        `sample_mod`.<br/>        // Calling `self::sample_function()` and calling<br/>        `sample_function()`<br/>        directly both give<br/>        // the same result, because they refer to the same<br/>        sample_function.<br/>        self::sample_function();<br/>        sample_function();<br/><br/>        // We can also use `self` to access another module inside<br/>        `sample_mod`:<br/>        self::cool::sample_function();<br/><br/>        // The `super` keyword refers to the parent scope (outside the<br/>        `sample_mod` module).<br/>        super::sample_function();
</pre>
<ol start="8">
<li>Create a block and call <kbd>root_sample_function</kbd>, which is bound to <kbd>cool::sample_function</kbd>:</li>
</ol>
<pre>        // This will bind to the `cool::sample_function` in the *crate*<br/>        scope.<br/>        // In this case the crate scope is the outermost scope.<br/>        {<br/>          use cool::sample_function as root_sample_function;<br/>          root_sample_function();<br/>        }<br/>        }<br/>        }
</pre>
<ol start="9">
<li>Define the <kbd>main</kbd> function and call the sample module's <kbd>indirect_call</kbd> function:</li>
</ol>
<pre>        // Execution starts here<br/>        fn main() {<br/>          // Calling the sample_mod module's item <br/>          sample_mod::indirect_call();<br/>        }
</pre>
<p>Upon the correct setup of the preceding code, you should get the following screenshot as output when you compile and run the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="166" width="595" src="images/0a32d7ae-7916-4997-a740-7e2ef7ab8b59.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Using the <kbd>super</kbd> and <kbd>self</kbd> keywords, we can remove ambiguity when accessing items across modules. This can help us eliminate a lot of hardcoding of paths.</p>
<p>We started off by creating a function named <kbd>sample_function</kbd>. In all the functions, we print how the function should be called. Then, we created a module named <kbd>cool</kbd> with a public function named <kbd>sample_function</kbd>, which had the same name as that of the declared outside the scope of <kbd>cool</kbd>. Lastly, we created a module named <kbd>sample_mod</kbd> consisting of a private function named <kbd>sample_function</kbd> and a public nested module <kbd>cool</kbd>, and a public function named <kbd>sample_function</kbd> and publicly visible function <kbd>indirect_call</kbd>.</p>
<p>All of the action in this recipe happens in the <kbd>indirect_call</kbd> function, which we call from the <kbd>main</kbd> function by <span><kbd>sample_mod::indirect_call()</kbd></span>. <span>When we start to execute the</span> <kbd>indirect_call</kbd> <span>function, it first has a print statement that prints how the function was called, and then proceeds ahead with calling <kbd>self::sample_function()</kbd>. T</span><span>he <kbd>self</kbd> keyword refers to the current module scope. In this case, it was <kbd>sample_mod</kbd>,</span> <span>and calling <kbd>sample_function()</kbd> or <kbd>self::sample_function()</kbd> would have given</span> <span>the same result as they referred to the same <kbd>sample_function</kbd>.</span></p>
<p>To access <kbd>sample_function</kbd> of other modules (which in this case is <kbd>cool</kbd>) inside the scope of <kbd>sample_mod</kbd>, we have to mention the call using the <kbd>self</kbd> keyword, which is <span><kbd>self::cool::sample_function()</kbd></span>. <span>To call the items/units outside the scope of the <kbd>sample_mod</kbd> module, we use <kbd>super</kbd>, which basically helps in calling the items outside the scope of the current module. Here, we called <kbd>sample_function</kbd> using the <kbd>super</kbd> keyword, which fetched the function that could be accessed by any units of the code. We achieved this by calling <kbd>super::sample_function()</kbd>. Next, we created a block in which we had the code chunk</span> <kbd>use</kbd> <span><kbd>cool::sample_function</kbd> as</span> <span><kbd>root_sample_function</kbd>, which used the <kbd>use</kbd> keyword to call <kbd>sample_function</kbd> of the <kbd>cool</kbd> module outside the scope and bind the path to <kbd>root_sample_function</kbd>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a file hierarchy</h1>
                </header>
            
            <article>
                
<p>This recipe discusses how to create a file structure for complex and bigger code bases so that it would be easier for the developer to manage application feature development. We will learn about the rules enforced by the Rust compiler to create a file hierarchy successfully so that the developer can utilize and get the same flexibility while using modules' units.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor to code. Also, create a file named <kbd>sample_module.rs</kbd> in the project workspace.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a file named <kbd>sample_split.rs</kbd> and a folder named <kbd>sample_module</kbd> in the project workspace:</li>
</ol>
<pre><strong>      touch sample_split.rs &amp;&amp; mkdir sample_module</strong>
</pre>
<ol start="2">
<li>Create the <kbd>mod.rs</kbd>, <kbd>nested_mod.rs</kbd>, and <kbd>sample_private.rs</kbd> files inside the <kbd>sample_module</kbd> folder:</li>
</ol>
<pre><strong>      cd sample_module &amp;&amp; touch mod.rs nested_mod.rs</strong><br/><strong>      sample_private.rs</strong>
</pre>
<p style="padding-left: 60px">We should get a folder structure, as shown in the following screenshot:</p>
<div style="padding-left: 60px" class="CDPAlignCenter CDPAlign"><img height="109" width="484" src="images/aaf93d7d-a35b-423a-a127-199ea0e6ad76.png"/></div>
<ol start="3">
<li>Write the code header with the details of the code in <kbd>sample_split.rs</kbd>:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To create a sample file structure<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="4">
<li>Create a folder named <kbd>sample_module</kbd> containing the content of the <kbd>sample_mod</kbd> module in <kbd>sample_split.rs</kbd>:</li>
</ol>
<pre>        // Using the contents of sample_module<br/>        mod sample_module;
</pre>
<ol start="5">
<li>Declare a local function named <kbd>sample_function</kbd> that will print <kbd>"called `sample_function()`"</kbd>, which will help in understanding the scope:</li>
</ol>
<pre>        // Defining a local sample_function<br/>        fn sample_function() {<br/>          println!("called `sample_function()`");<br/>        }
</pre>
<ol start="6">
<li>Define the <kbd>main</kbd> function, where we can call various items that will help in understanding the code workflow in the modules:</li>
</ol>
<pre>        // Execution starts here<br/>        fn main() {<br/>          sample_module::sample_function();<br/>          sample_function();<br/>          sample_module::indirect_access();<br/>          sample_module::nested_mod::sample_function();<br/>        }
</pre>
<ol start="7">
<li>Write the code header with the details of the code in <kbd>sample_module/mod.rs</kbd>:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To create a sample file structure<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="8">
<li>Declare the different modules that are <kbd>sample_private</kbd> and the publicly visible module <kbd>nested_mod</kbd> from the files inside the <kbd>sample_module</kbd> folder.</li>
</ol>
<div class="packt_infobox"><kbd>mod.rs</kbd> is an essential Rust script file inside the module folder that helps the compiler understand the different contents of the module:</div>
<pre>        // Similarly `mod sample_private` and `mod nested_mod` will<br/>        locate the<br/>        `nested_mod.rs`<br/>        // and `sample_private.rs` files and insert them here under<br/>        their<br/>        respective<br/>        // modules<br/>        mod sample_private;<br/>        pub mod nested_mod;
</pre>
<ol start="9">
<li>Declare a public function named <kbd>sample_function</kbd> and print the called <kbd>`sample_module::sample_function()`</kbd>:</li>
</ol>
<pre>        pub fn sample_function() {<br/>          println!("called `sample_module::sample_function()`");<br/>        }
</pre>
<ol start="10">
<li>Define a function named <kbd>private_function</kbd> and print the <kbd>"called `sample_module::private_function()`"</kbd>:</li>
</ol>
<pre>        fn private_function() {<br/>          println!("called `sample_module::private_function()`");<br/>        }
</pre>
<ol start="11">
<li>Declare a function named <kbd>indirect_access</kbd>, which calls <kbd>private_function</kbd> inside its scope:</li>
</ol>
<pre>        pub fn indirect_access() {<br/>          print!("called `sample_module::indirect_access()`, that \n&gt;<br/>          ");<br/>          private_function();<br/>        }
</pre>
<ol start="12">
<li><span>Write the code header with the details of the code in</span> <kbd>sample_module/nested_mod.rs</kbd>:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Nested module<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="13">
<li>Declare the items of the <kbd>nested_mod</kbd> module in this script. We start with defining the publicly visible <kbd>sample_function</kbd> and print <kbd>"called `sample_module::nested::sample_function()`"</kbd>:</li>
</ol>
<pre>        // sample_mod/nested.rs<br/>        pub fn sample_function() {<br/>          println!("called<br/>          `sample_module::nested::sample_function()`");<br/>        }
</pre>
<ol start="14">
<li>Define a private function named <kbd>private_function</kbd> and print <kbd>"called `sample_module::nested::private_function()`"</kbd>:</li>
</ol>
<pre>        #[allow(dead_code)]<br/>        fn private_function() {<br/>          println!("called<br/>          `sample_module::nested::private_function()`");<br/>        }
</pre>
<ol start="15">
<li><span>Write the code header with the details of the code in</span> <kbd>sample_module/sample_private.rs</kbd>:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Inaccessible script<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="16">
<li>Define a publicly visible function named <kbd>public_function</kbd> inside the script and print <kbd>"called `sample_module::sample_private::public_function()`"</kbd>:</li>
</ol>
<pre>        #[allow(dead_code)]<br/>        pub fn public_function() {<br/>          println!("called<br/>          `sample_module::sample_private::public_function()`");<br/>        }
</pre>
<p>Upon the correct setup of the preceding code, you should get the following screenshot as output when you compile and run the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="145" width="638" src="images/a7c3afe0-1f3d-4032-b807-9aa2fe172d1d.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>It is not possible to have all the modules inside the same script for a large application, so we definitely need to follow a file hierarchy to maintain different units. We also need to learn the mapping to create a <strong>file hierarchy</strong>.</p>
<p>In the preceding recipe, we created the following files, which are <kbd>rs</kbd>, and a folder named <kbd>sample_module</kbd>, which has <kbd>mod.rs</kbd>, <kbd>nested_mod.rs</kbd>, and <kbd>sample_private.rs</kbd>.</p>
<p>The <kbd>mod.rs</kbd> is a mandatory file inside the directory where we mention other modules that the <kbd>sample_split.rs</kbd> function would use in the file. The <kbd>sample_module</kbd> uses the private module <kbd>sample_private</kbd> and public module <kbd>nested_mod</kbd>, which are declared at the top of the file. We also created two public functions <kbd>sample_function</kbd> and <kbd>indirect_access</kbd>, which call the private function named <kbd>private_function</kbd>. These items are part of <kbd>sample_module</kbd> and can be directly called by <kbd>sample_module</kbd> in the <kbd>sample_split.rs</kbd> file.</p>
<p>In the <kbd>nested_mod.rs</kbd> file, we created a public function named <kbd>sample_function</kbd>, which can be called, and a private function named <kbd>private_function</kbd>, which cannot be called. Because <kbd>sample_module</kbd> is a private element of <kbd>nested_mod</kbd> and, similarly, the <kbd>sample_private.rs</kbd> file, we have a public function named <kbd>public_function</kbd> that cannot be accessed, as the <kbd>sample_private</kbd> module is private.</p>
<p>In <kbd>sample_split.rs</kbd>, which is outside the <kbd>sample_module</kbd> directory, we used this script as the gateway to call the modules that were inside the <kbd>sample_module</kbd> folder. We started off by calling <kbd>mod</kbd> <kbd>sample_module</kbd>, which is the module name to call the contents of the directory. We also created a function named <kbd>sample_function</kbd>, local to <kbd>sample_split.rs</kbd>, for understanding the purpose. Then, in the <kbd>main</kbd> function, we called all the units.</p>
<p>First, we called <kbd>sample_module::sample_function()</kbd>, which is the element of the <kbd>sample_function</kbd> module itself. The working of <kbd>sample_module::indirect_access()</kbd>, which would call the private item of <kbd>sample_module</kbd>, would be similar. To call the <kbd>nested_mod</kbd> public element, we called <kbd>sample_module::nested_mod::sample_function()</kbd>, which has the same syntax as that of the nested module.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building libraries in Rust</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn how to build libraries that will contain the functional units of the Rust application, and the way we can compile the application in a library format so that we can access it externally from other programs.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor to code. Also, create a file named <kbd>sample_module.rs</kbd> in the project workspace.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a file named <kbd>sample_lib.rs</kbd> in the project workspace</li>
<li>Write the code header with the details of the code:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To create a sample library in rust<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Define a public visible function named <kbd>public_function</kbd> and print <kbd>"called sample_lib `public_function()`"</kbd>:</li>
</ol>
<pre>        pub fn public_function() {<br/>          println!("called sample_lib `public_function()`");<br/>        }
</pre>
<ol start="4">
<li>Define a private function named <kbd>private_function</kbd> and print <kbd>"called sample_lib `private_function()`"</kbd>:</li>
</ol>
<pre>        fn private_function() {<br/>          println!("called sample_lib `private_function()`");<br/>        }
</pre>
<ol start="5">
<li>Define another public function named <kbd>indirect_access</kbd> that will call <kbd>private_function</kbd>, declared in the preceding step, in its scope:</li>
</ol>
<pre>        pub fn indirect_access() {<br/>          print!("called sample_lib `indirect_access()`, that \n &gt; ");<br/>          private_function();<br/>        }
</pre>
<p>Once the preceding code is set up, compile and run the project by the following command:</p>
<pre><strong>rustc --crate-type=lib sample_lib.rs</strong>
</pre>
<p>We should get the following screenshot as output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="51" width="819" src="images/150c8c6a-0f15-4fda-adf5-cb382d564ba9.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a sample library and made a <kbd>.rlib</kbd> extension package of the code. This will help us call the units of the library in other crates or Rust programs.</p>
<p>We created two public functions named <kbd>public_function</kbd> and <kbd>indirect_access</kbd> and a private function named <kbd>private_function</kbd>. We called <kbd>private_function</kbd> from <kbd>indirect_access</kbd>, which is a way through which we can call it outside the scope. Then, we created the library using the Rust compiler and passed a few command-line arguments to it, which tells the compiler to create the library format of the script.</p>
<p>While compiling the program, we ran <kbd>rustc --crate-type=lib sample_lib.rs</kbd>, which created a package named <kbd>libsample_lib.rlib</kbd> in the same directory. This file can be externally used at other crates. Alternatively, we can use Cargo to ship libraries by adding the <kbd>[lib]</kbd> tag in the <kbd>Cargo.toml</kbd> file.</p>
<div class="packt_infobox">Usually, libraries get prefixed with <kbd>lib</kbd>, and by default, they get the name of their crate file. But this default name can be overridden using the <kbd>crate_name</kbd> attribute while creating the library using rustc.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calling external crates</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn how to use the external module units, libraries, or crates created from another Rust project. During the process, you will understand some basic syntax that allows external crate resources to be utilized as modules in the code, as well as the <kbd>extern crate</kbd> keyword, which provides a smooth way to call external crate resources.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor to code. Also, create a file named <kbd>sample_module.rs</kbd> in the project workspace.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a file named <kbd>sample_exec.rs</kbd> in the project workspace</li>
<li>Write the code header with the details of the code:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To create a sample executor of sample_lib in rust<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 4 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>The previous script creates <kbd>libsample_lib.rlib</kbd>, which uses the <kbd>extern</kbd> <kbd>crate</kbd> keyword we are calling in this particular script:</li>
</ol>
<pre>        // Imports all items under sample_lib<br/>        extern crate sample_lib;
</pre>
<ol start="4">
<li>Declare the <kbd>main</kbd> function that calls all the public items of <kbd>sample_lib</kbd>, which are <kbd>public_function</kbd> and <kbd>indirect_access</kbd>:</li>
</ol>
<pre>        fn main() {<br/>          // Calling public_function<br/>          sample_lib::public_function();<br/>          // Calling indirect_access to private_function<br/>          sample_lib::indirect_access();<br/>        }
</pre>
<p>Once the preceding code is setup, compile and run the project by the following command:</p>
<pre><strong>rustc sample_exec.rs --extern sample_lib=libsample_lib.rlib</strong>
</pre>
<p>We should get the following screenshot as output:</p>
<p><img src="images/fac5f416-2018-457e-b04d-b18f82c83098.png"/></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The aim of this recipe is to reuse the units created in the <kbd>libsample_lib.rlib</kbd> library in the code to link a crate to a new Rust script. We have to use the <kbd>extern crate</kbd> declaration to call the units. This will not only link the library, but also import all its items/units under the same module name as the library name, which in our case is <kbd>sample_lib</kbd>.</p>
<div class="packt_infobox">The visibility rules that apply to modules also apply to libraries.</div>
<p>Our first statement is <kbd>extern crate sample_lib</kbd>, which imports all the units. Now, we can call the units of the external library the way we call module items. In the <kbd>main</kbd> function, we call the units by <kbd>sample_lib::public_function()</kbd>; this would call <kbd>public_function</kbd> of <kbd>sample_lib</kbd> and <kbd>sample_lib::indirect_access()</kbd> would call <kbd>private_function</kbd> of <kbd>sample_lib</kbd>.</p>


            </article>

            
        </section>
    </div>
</body>
</html>