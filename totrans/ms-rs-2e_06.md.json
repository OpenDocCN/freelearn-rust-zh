["```rs\n// kotlin pseudocode\n\nval container = collection.get(\"some_id\")\n\nif (container != null) {\n    container.process_item();\n} else {\n    // no luck\n}\n```", "```rs\npub enum Option<T> {\n    /// No value\n    None,\n    /// Some value `T`\n    Some(T),\n}\n```", "```rs\n// using_options.rs\n\nuse std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"one\", 1);\n    map.insert(\"two\", 2);\n\n    let value = map.get(\"one\");\n    let incremented_value = value + 1;\n}\n```", "```rs\n// using_options_match.rs\n\nuse std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"one\", 1);\n    map.insert(\"two\", 2);\n\n    let incremented_value = match map.get(\"one\") {\n        Some(val) => val + 1,\n        None => 0\n    };\n\n    println!(\"{}\", incremented_value);\n}\n```", "```rs\nlet incremented_value = if let Some(v) = map.get(\"one\") {\n    v + 1\n} else {\n    0\n};\n```", "```rs\n// using_options_unwrap.rs\n\nuse std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"one\", 1);\n    map.insert(\"two\", 2);\n    let incremented_value = map.get(\"three\").unwrap() + 1;\n    println!(\"{}\", incremented_value);\n}\n```", "```rs\nthread 'main' panicked at 'called `Option::unwrap()` on a `None` value', libcore/option.rs:345:21\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n```", "```rs\nenum Result<T, E> {\n   Ok(T), \n   Err(E), \n} \n```", "```rs\n// create_result.rs\n\nfn main() {\n    let my_result = Ok(64);\n    let my_err = Err(\"oh no!\");\n}\n```", "```rs\n// create_result_fixed.rs\n\nfn main() {\n    let _my_result: Result<_, ()> = Ok(64);\n    // or\n    let _my_result = Ok::<_, ()>(64);\n\n    // similarly we create Err variants\n\n    let _my_err = Err::<(), f32>(345.3);\n    let _other_err: Result<bool, String> = Err(\"Wait, what ?\".to_string());\n}\n```", "```rs\n// result_basics.rs\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new(\"data.txt\");\n    let file = File::open(&path);\n    let mut s = String::new();\n    file.read_to_string(&mut s);\n    println!(\"Message: {}\", s);\n}\n```", "```rs\nfn open<P: AsRef<Path>>(path: P) -> Result<File> \n```", "```rs\ntype Result<T> = Result<T, std::io::Error>; \n```", "```rs\n// result_basics_fixed.rs\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new(\"data.txt\");\n    let mut file = match File::open(&path) {\n        Ok(file) => file,\n        Err(err) => panic!(\"Error while opening file: {}\", err),\n    };\n\n    let mut s = String::new();\n    file.read_to_string(&mut s);\n    println!(\"Message: {}\", s);\n}\n```", "```rs\nfn read_to_string(&mut self, buf: &mut String) -> Result<usize>\n```", "```rs\nlet _ = file.read_to_string(&mut s);\n```", "```rs\npub fn map<U, F>(self, f: F) -> Option<U>\nwhere F: FnOnce(T) -> U {\n    match self {\n        Some(x) => Some(f(x)),\n        None => None,\n    }\n}\n```", "```rs\npub fn map<U, F>(self, f: F) -> Option<U>\nwhere F: FnOnce(T) -> U {\n    match self {\n        Ok(t) => Ok(f(t)),\n        Err(e) => Err(e)\n    }\n}\n```", "```rs\n// using_map.rs\n\nfn get_nth(items: &Vec<usize>, nth: usize) -> Option<usize> {\n    if nth < items.len() {\n        Some(items[nth])\n    } else {\n        None\n    }\n}\n\nfn double(val: usize) -> usize {\n    val * val\n}\n\nfn main() {\n    let items = vec![7, 6, 4, 3, 5, 3, 10, 3, 2, 4];\n    println!(\"{}\", items.len());\n    let doubled = get_nth(&items, 4).map(double);\n    println!(\"{:?}\", doubled);\n}\n```", "```rs\nlet doubled = get_nth(&items, 10).map(|v| v * v);\n```", "```rs\n// result_common_pattern.rs\n\nuse std::string::FromUtf8Error;\n\nfn str_upper_match(str: Vec<u8>) -> Result<String, FromUtf8Error> { \n    let ret = match String::from_utf8(str) { \n        Ok(str) => str.to_uppercase(), \n        Err(err) => return Err(err) \n    }; \n\n    println!(\"Conversion succeeded: {}\", ret); \n    Ok(ret) \n}\n\nfn main() {\n    let invalid_str = str_upper_match(vec![197, 198]);\n    println!(\"{:?}\", invalid_str);\n}\n```", "```rs\n// using_question_operator.rs\n\nuse std::string::FromUtf8Error;\n\nfn str_upper_concise(str: Vec<u8>) -> Result<String, FromUtf8Error> { \n    let ret = String::from_utf8(str).map(|s| s.to_uppercase())?;\n    println!(\"Conversion succeeded: {}\", ret);\n    Ok(ret) \n}\n\nfn main() {\n    let valid_str = str_upper_concise(vec![121, 97, 89]);\n    println!(\"{:?}\", valid_str);\n}\n```", "```rs\nlet _ = File::create(\"foo.txt\")?.write_all(b\"Hello world!\")?;\n```", "```rs\n// main_result.rs\n\nfn main() -> Result<(), &'static str> {\n    let s = vec![\"apple\", \"mango\", \"banana\"];\n    let fourth = s.get(4).ok_or(\"I got only 3 fruits\")?;\n    Ok(())\n}\n```", "```rs\n// panic_unwinding.rs\n\nuse std::thread;\n\nfn alice() -> thread::JoinHandle<()> {\n    thread::spawn(move || {\n        bob();\n    })\n}\n\nfn bob() {\n    malice();\n}\n\nfn malice() {\n    panic!(\"malice is panicking!\");\n}\n\nfn main() {\n    let child = alice();\n    let _ = child.join();\n\n    bob();\n    println!(\"This is unreachable code\");\n}\n```", "```rs\nfn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> \n```", "```rs\n// catch_unwind.rs\n\nuse std::panic; \n\nfn main() { \n    panic::catch_unwind(|| { \n        panic!(\"Panicking!\"); \n    }).ok();\n\n    println!(\"Survived that panic.\"); \n}\n```", "```rs\n[profile.release]\npanic = \"abort\"\n```", "```rs\npub trait Error: Debug + Display {\n    fn description(&self) -> &str { ... }\n    fn cause(&self) -> Option<&dyn Error> { ... }\n}\n```", "```rs\n// todolist_parser/src/error.rs\n\nuse std::error::Error;\nuse std::fmt;\nuse std::fmt::Display;\n\n#[derive(Debug)]\npub enum ParseErr {\n    Malformed,\n    Empty\n}\n\n#[derive(Debug)]\npub struct ReadErr {\n    pub child_err: Box<dyn Error>\n}\n\n// Required by error trait\nimpl Display for ReadErr {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Failed reading todo file\")\n    }\n}\n\n// Required by error trait\nimpl Display for ParseErr {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Todo list parsing failed\")\n    }\n}\n\nimpl Error for ReadErr {\n    fn description(&self) -> &str {\n        \"Todolist read failed: \"\n    }\n\n    fn cause(&self) -> Option<&dyn Error> {\n        Some(&*self.child_err)\n    }\n}\n\nimpl Error for ParseErr {\n    fn description(&self) -> &str {\n        \"Todolist parse failed: \"\n    }\n\n    fn cause(&self) -> Option<&Error> {\n        None\n    }\n}\n```", "```rs\n// todolist_parser/src/lib.rs\n\n//! This crate provides an API to parse list of todos\n\nuse std::fs::read_to_string;\nuse std::path::Path;\n\nmod error;\nuse error::ParseErr;\nuse error::ReadErr;\n\nuse std::error::Error;\n\n/// This struct contains a list of todos parsed as a Vec<String>\n#[derive(Debug)]\npub struct TodoList {\n    tasks: Vec<String>,\n}\n\nimpl TodoList {\n    pub fn get_todos<P>(path: P) -> Result<TodoList, Box<dyn Error>>\n    where\n    P: AsRef<Path>, {\n        let read_todos: Result<String, Box<dyn Error>> = read_todos(path);\n        let parsed_todos = parse_todos(&read_todos?)?;\n        Ok(parsed_todos)\n    }\n}\n\npub fn read_todos<P>(path: P) -> Result<String, Box<dyn Error>>\nwhere\n    P: AsRef<Path>,\n{\n    let raw_todos = read_to_string(path)\n        .map_err(|e| ReadErr {\n            child_err: Box::new(e),\n        })?;\n    Ok(raw_todos)\n}\n\npub fn parse_todos(todo_str: &str) -> Result<TodoList, Box<dyn Error>> {\n    let mut tasks: Vec<String> = vec![];\n    for i in todo_str.lines() {\n        tasks.push(i.to_string());\n    }\n    if tasks.is_empty() {\n        Err(ParseErr::Empty.into())\n    } else {\n        Ok(TodoList { tasks })\n    }\n}\n```", "```rs\n// todolist_parser/examples/basics.rs\n\nextern crate todolist_parser;\n\nuse todolist_parser::TodoList;\n\nfn main() {\n    let todos = TodoList::get_todos(\"examples/todos\");\n    match todos {\n        Ok(list) => println!(\"{:?}\", list),\n        Err(e) => {\n            println!(\"{}\", e.description());\n            println!(\"{:?}\", e)\n        }\n    }\n}\n```"]