<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-107"><em class="italic"><a id="_idTextAnchor123"/>Chapter 10</em>: Optimizing Rust and WebAssembly</h1>
			<p>So far, we have seen how Rust makes it easy to create and run WebAssembly modules and various tools provided by the Rust community. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Minimizing the WebAssembly modules</li>
				<li>Analyzing the memory model in the WebAssembly module </li>
				<li>Analyzing the WebAssembly module with Twiggy</li>
			</ul>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor124"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor125"/>Minimizing the WebAssembly modules </h1>
			<p><strong class="source-inline">wasm-bindgen</strong> is a complete suite that generates the binding JavaScript file (along with polyfills) for <a id="_idIndexMarker456"/>the WebAssembly module. In previous chapters, we saw how <strong class="source-inline">wasm-bindgen</strong> provides libraries and makes it easy to pass complex objects between JavaScript and WebAssembly. But in the WebAssembly world, it is important to optimize the generated binary for size and performance. </p>
			<p>Let's see how we can further optimize the WebAssembly modules:</p>
			<ol>
				<li>Create a WebAssembly application with all the necessary toolchains:<p class="source-code">$ npm init rust-webpack wasm-rust</p><p class="source-code">🦀 Rust + 🕸 WebAssembly + Webpack = ❤</p></li>
			</ol>
			<p>This previous command creates a new Rust and JavaScript-based application with webpack as the bundler.</p>
			<ol>
				<li value="2">Go into the generated <strong class="source-inline">wasm-rust</strong> directory:<p class="source-code">cd wasm-rust</p></li>
			</ol>
			<p>The Rust source files are present in the <strong class="source-inline">src</strong> directory and the JavaScript files are available in the <strong class="source-inline">js</strong> directory. We have webpack configured for running the application.</p>
			<ol>
				<li value="3">Remove all <a id="_idIndexMarker457"/>the code from <strong class="source-inline">src/lib.rs</strong> and replace it with the following:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code"> </p><p class="source-code">#[cfg(feature = "wee_alloc")]</p><p class="source-code">#[global_allocator]</p><p class="source-code">static ALLOC: wee_alloc::WeeAlloc =</p><p class="source-code">  wee_alloc::WeeAlloc::INIT;</p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn is_palindrome(input: &amp;str) -&gt; bool {</p><p class="source-code">    let s = input.to_string().to_lowercase();</p><p class="source-code">    s == s.chars().rev().collect::&lt;String&gt;()</p><p class="source-code">}</p></li>
			</ol>
			<p>We import <strong class="source-inline">wasm_bindgen</strong> and then enable <strong class="source-inline">wee_alloc</strong>, which does a much smaller memory allocation.</p>
			<p>We go on to define the <strong class="source-inline">is_palindrome</strong> function, which takes <strong class="source-inline">&amp;str</strong> as input and returns <strong class="source-inline">bool</strong>. Inside this function, we check whether the given string is a palindrome or not.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Find <a id="_idIndexMarker458"/>out more about the difference between <strong class="source-inline">&amp;str</strong> and <strong class="source-inline">String</strong> at <a href="https://users.rust-lang.org/t/whats-the-difference-between-string-and-str/10177/9">https://users.rust-lang.org/t/whats-the-difference-between-string-and-str/10177/9</a>.</p>
			<ol>
				<li value="4">Now, remove all the lines from <strong class="source-inline">js/index.js</strong> and replace them with the following content:<p class="source-code">const rust = import('../pkg/index.js');</p><p class="source-code">rust.then(module =&gt; {</p><p class="source-code">    console.log(module.is_palindrome('tattarrattat'));</p><p class="source-code">  // returns true</p><p class="source-code">});</p><p class="callout-heading">Note</p><p class="callout">We are importing from <strong class="source-inline">../pkg/index.js</strong> here. The <strong class="source-inline">wasm-pack</strong> command will generate the <strong class="source-inline">binding</strong> file and <strong class="source-inline">wasm</strong> file inside the <strong class="source-inline">pkg</strong> folder.</p></li>
				<li>Next, build <a id="_idIndexMarker459"/>the application with the following command:<p class="source-code"><strong class="bold">$ npm run build</strong></p><p class="source-code"><strong class="bold">// comments, logs are elided</strong></p><p class="source-code"><strong class="bold">   Asset     Size   Chunks    Chunk Names</strong></p><p class="source-code"><strong class="bold">   0.js   9.84 KiB       0  [emitted]</strong></p><p class="source-code"><strong class="bold">   0fd5cbc32a547ac3295c.module.wasm    115 KiB       0</strong></p><p class="source-code"><strong class="bold">     [emitted] [immutable]</strong></p><p class="source-code"><strong class="bold">   index.html  179 bytes          [emitted]</strong></p><p class="source-code"><strong class="bold">   index.js    901 KiB   index  [emitted]</strong></p><p class="source-code"><strong class="bold">     index</strong></p></li>
			</ol>
			<p>You can run the application with the <strong class="source-inline">npm run start</strong> command. This command opens the browser and loads the application. </p>
			<ol>
				<li value="6">Now, open the developer tools and check the logs in the console.</li>
			</ol>
			<p>The WebAssembly module generated by the Rust compiler is not completely optimized. We can optimize the WebAssembly modules further. In the JavaScript world, every byte matters.</p>
			<ol>
				<li value="7">Now, open <strong class="source-inline">Cargo.toml</strong> and add the following content:<p class="source-code">[profile.dev]</p><p class="source-code">opt-level = 'z'</p><p class="source-code">lto = true</p><p class="source-code">debug = false</p></li>
			</ol>
			<p>Also, remove the <strong class="source-inline">[profile.release]</strong> section completely. The <strong class="source-inline">[profile.dev]</strong> section instructs the compiler on how to profile the code generated <a id="_idIndexMarker460"/>in the dev build. The <strong class="source-inline">[profile.release]</strong> section is used only for the release build.</p>
			<p>We instruct the compiler to use <strong class="source-inline">opt-level = z</strong> for generating the code. The <strong class="source-inline">opt-level</strong> setting is similar to the LLVM compiler's <strong class="source-inline">-O1/2/3/...</strong>.</p>
			<p>The valid <a id="_idIndexMarker461"/>options of the <strong class="source-inline">opt-level</strong> setting are as follows:</p>
			<ul>
				<li><strong class="source-inline">0</strong> – no optimizations; also turns on <strong class="source-inline">cfg(debug_assertions)</strong></li>
				<li><strong class="source-inline">1</strong> – basic optimizations </li>
				<li><strong class="source-inline">2</strong> – some optimizations </li>
				<li><strong class="source-inline">3</strong> – all optimizations </li>
				<li><strong class="source-inline">s</strong> – optimize for binary size </li>
				<li><strong class="source-inline">z</strong> – optimize for binary size, but also turn off loop vectorization</li>
			</ul>
			<p>LLVM supports link-time optimizations to better optimize code by using whole program analysis. But link-time optimization comes at the cost of longer linking time. We can enable LLVMs link-time optimization using the lto option.</p>
			<p>The lto supports <a id="_idIndexMarker462"/> the following options:</p>
			<ul>
				<li><strong class="source-inline">false</strong> – performs "thin local LTO”.  This means the link-time optimizations are done only on the local crate. Note: there will not be any link-time optimizations when the number of Codegen units is 1 or <strong class="source-inline">opt-level</strong> is 0. </li>
				<li><strong class="source-inline">true</strong> or "fat" – performs "fat" LTO.  This means the link-time optimizations are done across all crates in the dependency graph.  </li>
				<li><strong class="source-inline">thin</strong> – performs "thin" LTO. This is a faster version of “fat”, that optimizes at a faster rate. </li>
				<li><strong class="source-inline">off</strong> – disables LTO.</li>
			</ul>
			<ol>
				<li value="8">Next, run <strong class="source-inline">npm run build</strong>:<p class="source-code"><strong class="bold">$ npm run build</strong></p><p class="source-code"><strong class="bold">// comments, logs are elided</strong></p><p class="source-code"><strong class="bold">   Asset   Size   Chunks   Chunk Names</strong></p><p class="source-code"><strong class="bold">   0.js  9.84 KiB     0  [emitted]</strong></p><p class="source-code"><strong class="bold">   b5e867dd3d25627d7122.module.wasm  50.8 KiB       0</strong></p><p class="source-code"><strong class="bold">     [emitted] [immutable]</strong></p><p class="source-code"><strong class="bold">   index.js   901 KiB   index  [emitted]</strong></p><p class="source-code"><strong class="bold">     index</strong></p></li>
			</ol>
			<p>The generated <a id="_idIndexMarker463"/>WebAssembly binary is 50.8 KB. The generated binary is ~44% smaller in size. That is a huge win for us. We can further optimize the binary using Binaryen's <strong class="source-inline">wasm-opt</strong> tool:</p>
			<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-opt -Oz</strong></p>
			<p class="source-code"><strong class="bold">  b5e867dd3d25627d7122.module.wasm -o opt-gen.wasm</strong></p>
			<p class="source-code"><strong class="bold">$ l</strong></p>
			<p class="source-code"><strong class="bold">-rw-r--r--    1 sendilkumar  staff    45K May  8 17:43</strong></p>
			<p class="source-code"><strong class="bold"> opt-gen.wasm</strong></p>
			<p>It reduces another 5 KB. We have used the <strong class="source-inline">-Oz</strong> pass, but we can pass in other passes to further optimize the generated binary.</p>
			<p>We have <a id="_idIndexMarker464"/>seen how to minimize the WebAssembly module using Rust. Next, we will analyze the memory model in the WebAssembly module.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor126"/>Analyzing the memory model in the WebAssembly module  </h1>
			<p>Inside the JavaScript engine, WebAssembly and JavaScript run at different locations. Crossing <a id="_idIndexMarker465"/>the boundaries between JavaScript and WebAssembly will always have a cost attached to it. The browser <a id="_idIndexMarker466"/>vendors implemented cool hacks and workarounds to reduce this cost, but when your applications cross this boundary, this boundary crossing will often soon become a major performance bottleneck for your application. It is very important to design WebAssembly applications in a way that reduces boundary crossing. But once the application grows, it becomes difficult to manage this boundary crossing. To prevent boundary crossing, WebAssembly modules come with the memory module.</p>
			<p>The memory section in the WebAssembly module is a vector of linear memories.</p>
			<p>A linear memory <a id="_idIndexMarker467"/>model is a memory-addressing technique in which the memory is organized in a single contagious address space. It is also<a id="_idTextAnchor127"/> known as the Flat memory model.</p>
			<p>The linear memory model makes it easier to understand, program, and represent the memory. But it also has huge disadvantages, such as high execution time for rearranging elements in memory and wasting a lot of memory area.</p>
			<p>Here, the memory represents a vector of raw bytes containing uninterpreted data. WebAssembly uses resizable array buffers to hold the raw bytes of memory. It is important to note that this memory that is created is accessible and mutable from both JavaScript and WebAssembly.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor128"/>Sharing memory between JavaScript and WebAssembly using Rust</h2>
			<p>We have <a id="_idIndexMarker468"/>already seen how to share <a id="_idIndexMarker469"/>the memory between JavaScript and WebAssembly. Let's share memory using Rust in this example:</p>
			<ol>
				<li value="1">Create a new Rust project using Cargo:<p class="source-code"><strong class="bold">$ cargo new --lib memory_world</strong></p></li>
				<li>Open the project in your favorite editor and replace <strong class="source-inline">src/lib.rs</strong> with the following content:<p class="source-code">#![no_std]</p><p class="source-code"> </p><p class="source-code">use core::panic::PanicInfo;</p><p class="source-code">use core::slice::from_raw_parts_mut;</p><p class="source-code"> </p><p class="source-code">#[no_mangle]</p><p class="source-code">fn memory_to_js() {</p><p class="source-code">    let obj: &amp;mut [u8];</p><p class="source-code"> </p><p class="source-code">    unsafe {</p><p class="source-code">      obj = from_raw_parts_mut::&lt;u8&gt;(0 as *mut u8, 1);</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">    obj[0] = 13;</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">#[panic_handler]</p><p class="source-code">fn panic(_info: &amp;PanicInfo) -&gt; !{</p><p class="source-code">    loop{}</p><p class="source-code">} </p></li>
			</ol>
			<p>The Rust file starts with <strong class="source-inline">#![no_std]</strong>. This instructs the compiler not<a id="_idTextAnchor129"/> to include the Rust Standard Library while generating the WebAssembly module. This will reduce the binary size a lot. Next, we define a function called <strong class="source-inline">memory_to_js</strong>. This function creates an <strong class="source-inline">obj</strong> in memory and shares it with JavaScript. In the function definition, we create a slice of <strong class="source-inline">u32</strong> called <strong class="source-inline">obj</strong>. Next, we assign <a id="_idIndexMarker470"/>some raw memory to <strong class="source-inline">obj</strong>. Here, we are dealing with raw memory. Hence, we wrap the code <a id="_idIndexMarker471"/>inside an <strong class="source-inline">unsafe</strong> block. The memory object is global and it is mutable by both JavaScript and WebAssembly. Hence, we use <strong class="source-inline">from_raw_parts_mut</strong> to instantiate the object. Finally, we assign a value to the first element in the shared array buffer.</p>
			<ol>
				<li value="3">Create an <strong class="source-inline">index.html</strong> file and add the following content:<p class="source-code">&lt;script&gt;</p><p class="source-code">    ( async() =&gt; {</p><p class="source-code">         const bytes = await fetch("target/wasm32-</p><p class="source-code">         unknown-unknown/debug/memory_world.wasm");</p><p class="source-code">         const response = await bytes.arrayBuffer();</p><p class="source-code">         const result = await</p><p class="source-code">           WebAssembly.instantiate(response, {});</p><p class="source-code">         result.exports.memory_to_js();</p><p class="source-code">         const memObj = new</p><p class="source-code">           UInt8Array(result.exports.memory.buffer, 0)</p><p class="source-code">           .slice(0, 1);</p><p class="source-code">         console.log(memObj[0]); // 13</p><p class="source-code">    })();</p><p class="source-code">&lt;/script&gt;</p></li>
			</ol>
			<p>We create an anonymous asynchronous JavaScript function that will be invoked as soon as the script is loaded. We fetch the WebAssembly binary inside the anonymous function. Next, we create <strong class="source-inline">ArrayBuffer</strong> and instantiate the module <a id="_idIndexMarker472"/>to the <strong class="source-inline">result</strong> object. We then <a id="_idIndexMarker473"/>call the <strong class="source-inline">memory_to_js</strong> method in the WebAssembly module (note the <strong class="source-inline">exports</strong> keyword, since the function is exported from the WebAssembly module). This instantiates the memory and assigns the first element in the shared array buffer to <strong class="source-inline">13</strong>:</p>
			<p class="source-code">const memObj = new</p>
			<p class="source-code"> UInt8Array(result.exports.memory.buffer, 0)</p>
			<p class="source-code">   .slice(0, 1);</p>
			<p class="source-code">console.log(memObj[0]); // 13</p>
			<p>Next, we call the memory object that is exported from WebAssembly using <strong class="source-inline">result.export.memory.buffer</strong> and convert it into <strong class="source-inline">UInt8Array</strong> using a new <strong class="source-inline">UInt8Array()</strong>. Next, we extract the first element using <strong class="source-inline">slice(0,1)</strong>. This way, we can pass and retrieve values between JavaScript and WebAssembly without any overhead. The memory is accessed via <strong class="source-inline">load</strong> and <strong class="source-inline">store</strong> binary instructions. The <strong class="source-inline">load</strong> operation copies data from the main memory to register. The <strong class="source-inline">store</strong> operation copies data from the main memory. These binary instructions are accessed with the offset and the alignment. The alignment is in base-2 logarithmic representation. The memory address should be a multiple of four. This is called alignment restriction. This alignment restriction makes the hardware much faster.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is important to note that WebAssembly currently provides only a 32-bit address range. In the future, WebAssembly might provide a 64-bit address range.</p>
			<p>We have seen how to share memory between JavaScript and WebAssembly by creating the memory in Rust. Next, we will create a memory object on the JavaScript side and use it inside the Rust application.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor130"/>Creating a memory object in JavaScript to use in the Rust application</h2>
			<p>Unlike JavaScript, Rust is not dynamically typed. The memory created in JavaScript has no way to tell WebAssembly (or the Rust code) what to allocate and when to free them. We need <a id="_idIndexMarker474"/>to explicitly inform WebAssembly <a id="_idIndexMarker475"/>how to allocate the memory and, most importantly, when and how to free them (to avoid any leaks).</p>
			<p>We use the <strong class="source-inline">WebAssembly.memory()</strong> constructor to create the memory in JavaScript. The memory constructor takes in an object to set the defaults. The object has the following options:</p>
			<ul>
				<li><strong class="source-inline">initial</strong> – the initial size of the memory</li>
				<li><strong class="source-inline">maximum</strong> – the maximum size of the memory (optional)</li>
				<li><strong class="source-inline">shared</strong> – to denote whether to use the shared memory</li>
			</ul>
			<p>The units for <strong class="source-inline">initial</strong> and <strong class="source-inline">maximum</strong> are WebAssembly pages, where a page refers to 64 KB.</p>
			<p>We change the HTML file as follows:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">     ( async() =&gt; {</p>
			<p class="source-code">        const memory = new WebAssembly.Memory({initial: 10,</p>
			<p class="source-code">          maximum:100}); // -&gt; 1</p>
			<p class="source-code">        const bytes = await fetch("target/wasm32-unknown-</p>
			<p class="source-code">          unknown/debug/memory_world.wasm");</p>
			<p class="source-code">        const response = await bytes.arrayBuffer();</p>
			<p class="source-code">        const instance = await</p>
			<p class="source-code">          WebAssembly.instantiate(response, </p>
			<p class="source-code">          { js: { mem: memory } }); // -&gt;2</p>
			<p class="source-code">        const s = new Set([1, 2, 3]);</p>
			<p class="source-code">        let jsArr = Uint8Array.from(s); // -&gt; 3</p>
			<p class="source-code">        const len = jsArr.length;</p>
			<p class="source-code">        let wasmArrPtr = instance.exports.malloc(length);</p>
			<p class="source-code">          // -&gt; 4</p>
			<p class="source-code">        let wasmArr = new</p>
			<p class="source-code">          Uint8Array(instance.exports.memory.buffer,</p>
			<p class="source-code">          wasmArrPtr, len); // -&gt; 5</p>
			<p class="source-code">        wasmArr.set(jsArr); // -&gt; 6</p>
			<p class="source-code">        const sum = instance.exports.accumulate</p>
			<p class="source-code">          (wasmArrPtr, len); // -&gt; 7</p>
			<p class="source-code">        console.log(sum);</p>
			<p class="source-code">    })();</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>In <strong class="source-inline">// -&gt; 1</strong>, the memory is initialized with the <strong class="source-inline">WebAssembly.Memory()</strong> constructor. We <a id="_idIndexMarker476"/>passed in the initial and <a id="_idIndexMarker477"/>maximum size of the memory, that is, 640 KB and 6.4 MB, respectively.</p>
			<p>In <strong class="source-inline">// -&gt; 2</strong>, we're instantiating the WebAssembly module along with the memory object.</p>
			<p>In <strong class="source-inline">// -&gt; 3</strong>, we then create <strong class="source-inline">typedArray</strong> (<strong class="source-inline">UInt8Array</strong>) with values <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">3</strong>.</p>
			<p>In <strong class="source-inline">// -&gt; 4</strong>, we see how, as WebAssembly modules do not have any clue about the objects that are created out of the memory, the memory needs to be allocated. We have to manually write the allocation and freeing of memory in WebAssembly. In this step, we send the length of the array and allocate that memory. This gives us a pointer to the location of the memory.</p>
			<p>In <strong class="source-inline">// -&gt; 5</strong>, we create a new <strong class="source-inline">typedArray</strong> with the buffer (total available memory), the memory offset (<strong class="source-inline">wasmAttrPtr</strong>), and the length of the memory.</p>
			<p>In <strong class="source-inline">// -&gt; 6</strong>, we set the locally created <strong class="source-inline">typedArray</strong> (in <em class="italic">step 3</em>) to <strong class="source-inline">typedArray</strong> created in <em class="italic">step 5</em>.</p>
			<p>In <strong class="source-inline">//-&gt; 7</strong>, finally, we send the pointer to the memory and the length to the WebAssembly module, where we fetch the value from the memory by using the pointer to the memory and the length.</p>
			<p>On the <a id="_idIndexMarker478"/>Rust side, replace the contents <a id="_idIndexMarker479"/>of <strong class="source-inline">src/lib.rs</strong> with the following:</p>
			<p class="source-code">use std::alloc::{alloc, dealloc,  Layout};</p>
			<p class="source-code">use std::mem;</p>
			<p class="source-code"> </p>
			<p class="source-code">#[no_mangle]</p>
			<p class="source-code">fn accumulate(data: *mut u8, len: usize) -&gt; i32 {</p>
			<p class="source-code">    let y = unsafe { std::slice::from_raw_parts(data as</p>
			<p class="source-code">      *const u8, len) };</p>
			<p class="source-code">    let mut sum = 0;</p>
			<p class="source-code">    for i in 0..len {</p>
			<p class="source-code">        sum = sum + y[i];</p>
			<p class="source-code">    }</p>
			<p class="source-code">    sum as i32</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">#[no_mangle]</p>
			<p class="source-code">fn malloc(size: usize) -&gt; *mut u8 {</p>
			<p class="source-code">    let align = std::mem::align_of::&lt;usize&gt;();</p>
			<p class="source-code">    if let Ok(layout) = Layout::from_size_align(size,</p>
			<p class="source-code">      align) {</p>
			<p class="source-code">        unsafe {</p>
			<p class="source-code">            if layout.size() &gt; 0 {</p>
			<p class="source-code">                let ptr = alloc(layout);</p>
			<p class="source-code">                if !ptr.is_null() {</p>
			<p class="source-code">                    return ptr</p>
			<p class="source-code">                }</p>
			<p class="source-code">            } else {</p>
			<p class="source-code">                return align as *mut u8</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    std::process::abort</p>
			<p class="source-code">}</p>
			<p>We imported <strong class="source-inline">alloc</strong>, <strong class="source-inline">dealloc</strong>, and <strong class="source-inline">Layout</strong> from <strong class="source-inline">std::alloc</strong> and <strong class="source-inline">std::mem</strong> to play with <a id="_idIndexMarker480"/>the raw memory. The first <a id="_idIndexMarker481"/>function, <strong class="source-inline">accumulate</strong>, takes in <strong class="source-inline">data</strong>, which is the pointer where the data starts, and <strong class="source-inline">len</strong>, the length of the memory to read. First, we create a slice from the raw memory using <strong class="source-inline">std::slice::from_raw_parts</strong> by passing the pointer, <strong class="source-inline">data</strong>, and length, <strong class="source-inline">len</strong>. Note that this is an unsafe operation. Next, we run through the items in the array and add all the elements. Finally, we return the value as <strong class="source-inline">i32</strong>.</p>
			<p>The <strong class="source-inline">malloc</strong> function is used to custom-allocate the memory since the WebAssembly module has no clue about the type of information sent and how to read/understand it. <strong class="source-inline">malloc</strong> helps us to allocate the memory as required without any panic.</p>
			<p>Run the previous code using <strong class="source-inline">python -m http.server</strong> and load the web page in a browser to see the results in the developer tools.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor131"/>Analyzing the WebAssembly module with Twiggy</h1>
			<p>The Rust-to-WebAssembly binaries are more likely to create a bloated binary. Proper care should <a id="_idIndexMarker482"/>be taken when creating WebAssembly binaries. The trade-off between the level of optimization, the time <a id="_idIndexMarker483"/>to compile, and various other factors should be considered while producing binaries. But most of the preceding work is done by the compiler by defa<a id="_idTextAnchor132"/>ult. Either Emscripten or the <strong class="source-inline">rustc</strong> compiler ensures the elimination of dead code along with various options on the optimization level (<strong class="source-inline">-O0</strong> to <strong class="source-inline">z</strong>). We can choose the one that fits us.</p>
			<p>Twiggy is a code size profiler. It uses the call graph to determine the origins of a function and provides meta-information about the function. The meta-information includes the size of each function in binary and its cost. Twiggy provides an overview of what is in the binary. With that information, we can optimize the binary further Let's install and use Twiggy to optimize the binary:.</p>
			<ol>
				<li value="1">Install Twiggy by running the following command:<p class="source-code"><strong class="bold">$ cargo install twiggy</strong></p></li>
				<li>Once installed, the <strong class="source-inline">twiggy</strong> command will be available in the command line, which we can check with the following command:<p class="source-code"><strong class="bold">$ twiggy</strong></p><p class="source-code"><strong class="bold">twiggy-opt 0.6.0</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">Use `twiggy` to make your binaries slim!</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">USAGE:</strong></p><p class="source-code"><strong class="bold">    twiggy &lt;SUBCOMMAND&gt;</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">FLAGS:</strong></p><p class="source-code"><strong class="bold">    -h, --help Prints help information</strong></p><p class="source-code"><strong class="bold">    -V, --version Prints version information</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">SUBCOMMANDS:</strong></p><p class="source-code"><strong class="bold">    diff         Diff the old and new versions of a</strong></p><p class="source-code"><strong class="bold">                 binary to see what sizes changed.</strong></p><p class="source-code"><strong class="bold">    dominators   Compute and display the dominator</strong></p><p class="source-code"><strong class="bold">                 tree for a binary's call graph.</strong></p><p class="source-code"><strong class="bold">    garbage      Find and display code and data that</strong></p><p class="source-code"><strong class="bold">                 is not transitively referenced by any</strong></p><p class="source-code"><strong class="bold">                 exports or public functions.</strong></p><p class="source-code"><strong class="bold">    help         Prints this message or the help of</strong></p><p class="source-code"><strong class="bold">                 the given subcommand(s)</strong></p><p class="source-code"><strong class="bold">    monos        List the generic function</strong></p><p class="source-code"><strong class="bold">                 monomorphizations that are</strong></p><p class="source-code"><strong class="bold">                 contributing to code bloat.</strong></p><p class="source-code"><strong class="bold">    paths        Find and display the call paths </strong></p><p class="source-code"><strong class="bold">                 to a function in the given binary's</strong></p><p class="source-code"><strong class="bold">                 call graph.</strong></p><p class="source-code"><strong class="bold">    top          List the top code size offenders in a</strong></p><p class="source-code"><strong class="bold">                 binary.</strong></p></li>
				<li>Create <a id="_idIndexMarker484"/>a folder to test-drive <a id="_idIndexMarker485"/>Twiggy:<p class="source-code"><strong class="bold">$ mkdir twiggy-world</strong></p></li>
				<li>Create a file called <strong class="source-inline">add.wat</strong> and add the following content:<p class="source-code"><strong class="bold">$ touch add.wat</strong></p><p class="source-code"><strong class="bold">(module</strong></p><p class="source-code"><strong class="bold">    (func $add (param $lhs i32) (param $rhs i32)</strong></p><p class="source-code"><strong class="bold">      (result i32)</strong></p><p class="source-code"><strong class="bold">        get_local $lhs</strong></p><p class="source-code"><strong class="bold">        get_local $rhs</strong></p><p class="source-code"><strong class="bold">        i32.add)</strong></p><p class="source-code"><strong class="bold">    (export "add" (func $add))</strong></p><p class="source-code"><strong class="bold">)</strong></p></li>
				<li>Once <a id="_idIndexMarker486"/>you have defined the WebAssembly <a id="_idIndexMarker487"/>text format, compile it to the WebAssembly module using <strong class="source-inline">wabt</strong>:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/wabt/wat2wasm add.wat</strong></p></li>
				<li>The preceding command generates an <strong class="source-inline">add.wasm</strong> file. To get the call paths in the binary, run Twiggy with the <strong class="source-inline">paths</strong> option:<p class="source-code"><strong class="bold">$ twiggy paths add.wasm</strong></p><p class="source-code"><strong class="bold">Shallow Bytes │ Shallow % │ Retaining Paths</strong></p><p class="source-code"><strong class="bold">───────────────┼───────────┼───────────────────────────</strong></p><p class="source-code"><strong class="bold">             9 </strong><strong class="bold">┊</strong><strong class="bold">    21.95% </strong><strong class="bold">┊</strong><strong class="bold"> code[0]</strong></p><p class="source-code"><strong class="bold">               </strong><strong class="bold">┊</strong><strong class="bold">           </strong><strong class="bold">┊</strong><strong class="bold">   </strong><strong class="bold">⬑</strong><strong class="bold"> export "add"</strong></p><p class="source-code"><strong class="bold">             8 </strong><strong class="bold">┊</strong><strong class="bold">    19.51% </strong><strong class="bold">┊</strong><strong class="bold"> wasm magic bytes</strong></p><p class="source-code"><strong class="bold">             6 </strong><strong class="bold">┊</strong><strong class="bold">    14.63% </strong><strong class="bold">┊</strong><strong class="bold"> type[0]: (i32, i32) -&gt; i32</strong></p><p class="source-code"><strong class="bold">               </strong><strong class="bold">┊</strong><strong class="bold">           </strong><strong class="bold">┊</strong><strong class="bold">   </strong><strong class="bold">⬑</strong><strong class="bold"> code[0]</strong></p><p class="source-code"><strong class="bold">               </strong><strong class="bold">┊</strong><strong class="bold">           </strong><strong class="bold">┊</strong><strong class="bold">       </strong><strong class="bold">⬑</strong><strong class="bold"> export "add"</strong></p><p class="source-code"><strong class="bold">             6 </strong><strong class="bold">┊</strong><strong class="bold">    14.63% </strong><strong class="bold">┊</strong><strong class="bold"> export "add"</strong></p><p class="source-code"><strong class="bold">             6 </strong><strong class="bold">┊</strong><strong class="bold">    14.63% </strong><strong class="bold">┊</strong><strong class="bold"> code section headers</strong></p><p class="source-code"><strong class="bold">             3 </strong><strong class="bold">┊</strong><strong class="bold">     7.32% </strong><strong class="bold">┊</strong><strong class="bold"> type section headers</strong></p><p class="source-code"><strong class="bold">             3 </strong><strong class="bold">┊</strong><strong class="bold">     7.32% </strong><strong class="bold">┊</strong><strong class="bold"> export section headers</strong></p></li>
			</ol>
			<p>The <strong class="source-inline">twiggy paths</strong> command shows the call path for the functions, the number of bytes <a id="_idIndexMarker488"/>they occupy inside the binary, and <a id="_idIndexMarker489"/>their percentage. The actual added code is 9 bytes and it occupies 21.95% of the total binary size.</p>
			<p>Let's explore various subcommands in Twiggy:</p>
			<ul>
				<li><strong class="source-inline">top</strong></li>
				<li><strong class="source-inline">monos</strong></li>
				<li><strong class="source-inline">garbage</strong></li>
			</ul>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor133"/>top</h2>
			<p>The <strong class="source-inline">twiggy top</strong> command <a id="_idIndexMarker490"/>will list the code size of <a id="_idIndexMarker491"/>each block. It lists, in descending order, the size of the function, the percentage of the size in the end binary and the block section:</p>
			<p class="source-code"><strong class="bold">$ twiggy top add.wasm</strong></p>
			<p class="source-code"><strong class="bold">Shallow Bytes │ Shallow % │ Item</strong></p>
			<p class="source-code"><strong class="bold">───────────────┼───────────┼───────────────────────────</strong></p>
			<p class="source-code"><strong class="bold">             9 </strong><strong class="bold">┊</strong><strong class="bold">    21.95% </strong><strong class="bold">┊</strong><strong class="bold"> code[0]</strong></p>
			<p class="source-code"><strong class="bold">             8 </strong><strong class="bold">┊</strong><strong class="bold">    19.51% </strong><strong class="bold">┊</strong><strong class="bold"> wasm magic bytes</strong></p>
			<p class="source-code"><strong class="bold">             6 </strong><strong class="bold">┊</strong><strong class="bold">    14.63% </strong><strong class="bold">┊</strong><strong class="bold"> type[0]: (i32, i32) -&gt; i32</strong></p>
			<p class="source-code"><strong class="bold">             6 </strong><strong class="bold">┊</strong><strong class="bold">    14.63% </strong><strong class="bold">┊</strong><strong class="bold"> export "add"</strong></p>
			<p class="source-code"><strong class="bold">             6 </strong><strong class="bold">┊</strong><strong class="bold">    14.63% </strong><strong class="bold">┊</strong><strong class="bold"> code section headers</strong></p>
			<p class="source-code"><strong class="bold">             3 </strong><strong class="bold">┊</strong><strong class="bold">     7.32% </strong><strong class="bold">┊</strong><strong class="bold"> type section headers</strong></p>
			<p class="source-code"><strong class="bold">             3 </strong><strong class="bold">┊</strong><strong class="bold">     7.32% </strong><strong class="bold">┊</strong><strong class="bold"> export section headers</strong></p>
			<p class="source-code"><strong class="bold">            41 </strong><strong class="bold">┊</strong><strong class="bold">   100.00% </strong><strong class="bold">┊</strong><strong class="bold"> </strong><strong class="bold">Σ</strong><strong class="bold"> [7 Total Rows]</strong></p>
			<p class="source-code"><strong class="bold">The usage of the twiggy top is as follows</strong></p>
			<p class="source-code"><strong class="bold">USAGE: twiggy top &lt;input&gt; -n &lt;max_items&gt; -o</strong></p>
			<p class="source-code"><strong class="bold"> &lt;output_destination&gt; --format &lt;output_format&gt; <a id="_idTextAnchor134"/>--mode</strong></p>
			<p class="source-code"><strong class="bold"> &lt;parse_mode&gt;</strong></p>
			<p>List the <a id="_idIndexMarker492"/>top n details using <strong class="source-inline">-n</strong> followed by the number of entries to show:</p>
			<p class="source-code"><strong class="bold">$ twiggy top add.wasm -n 3</strong></p>
			<p class="source-code"><strong class="bold">Shallow Bytes │ Shallow % │ Item</strong></p>
			<p class="source-code"><strong class="bold">───────────────┼───────────┼───────────────────────────</strong></p>
			<p class="source-code"><strong class="bold">             9 </strong><strong class="bold">┊</strong><strong class="bold">    21.95% </strong><strong class="bold">┊</strong><strong class="bold"> code[0]</strong></p>
			<p class="source-code"><strong class="bold">             8 </strong><strong class="bold">┊</strong><strong class="bold">    19.51% </strong><strong class="bold">┊</strong><strong class="bold"> wasm magic bytes</strong></p>
			<p class="source-code">             <strong class="bold">6 </strong><strong class="bold">┊</strong><strong class="bold">    14.63% </strong><strong class="bold">┊</strong><strong class="bold"> type[0]: (i32, i32) -&gt; i32</strong></p>
			<p class="source-code"><strong class="bold">            18 </strong><strong class="bold">┊</strong><strong class="bold">    43.90% </strong><strong class="bold">┊</strong><strong class="bold"> ... and 4 more.</strong></p>
			<p class="source-code"><strong class="bold">            41 </strong><strong class="bold">┊</strong><strong class="bold">   100.00% </strong><strong class="bold">┊</strong><strong class="bold"> </strong><strong class="bold">Σ</strong><strong class="bold"> [7 Total Rows]</strong></p>
			<p>Similarly, we can <a id="_idIndexMarker493"/>format the output to JSON format using the <strong class="source-inline">--format</strong> flag:</p>
			<p class="source-code">$ twiggy top add.wasm -n 3 --format json</p>
			<p class="source-code">[{"name":"code[0]","shallow_size":9,"shallow_size_percent":</p>
			<p class="source-code">21.951219512195124},{"name":"wasm magic</p>
			<p class="source-code">bytes","shallow_size":8,"shallow_size_percent":19.512195121</p>
			<p class="source-code">95122},{"name":"type[0]: (i32, i32) -&gt;</p>
			<p class="source-code">i32","shallow_size":6,"shallow_size_percent":14.63414634146</p>
			<p class="source-code">3413}]</p>
			<p>The <strong class="source-inline">top</strong> command is extremely useful when you want to track down the biggest code blocks and then optimize them separately.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor135"/>monos</h2>
			<p>In the <a id="_idIndexMarker494"/>JavaScript world, monomorphization increases performance. But it also bloats the code size (for example, in generics). Since we have to create the implementation of a generic function dynamically for every type, we have to be very careful when using generics and monomorphic code.</p>
			<p>Twiggy has a <a id="_idIndexMarker495"/>subcommand called <strong class="source-inline">monos</strong> that will list the code bloating due to monomorphization:</p>
			<p class="source-code">$ twiggy monos pkg/index_bg.wasm</p>
			<p class="source-code">Apprx. Bloat Bytes │ Apprx. Bloat % │ Bytes │ %      │ Monomorphizations</p>
			<p class="source-code">────────────────────┼────────────────┼───────┼────────┼───────────────────────────────────────────────────────────────────</p>
			<p class="source-code">                  4 ┊          0.01% ┊    32 ┊  0.06% ┊ core::ptr::drop_in_place</p>
			<p class="source-code">                    ┊                ┊    28 ┊  0.05% ┊     core::ptr::drop_in_place::h9684ba572bb4c2f9</p>
			<p class="source-code">                    ┊                ┊     4 ┊  0.01% ┊     core::ptr::drop_in_place::h00c08aab80423b88</p>
			<p class="source-code">                  0 ┊          0.00% ┊  5437 ┊ 10.44% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc</p>
			<p class="source-code">                    ┊                ┊  5437 ┊ 10.44% ┊     dlmalloc::dlmalloc::Dlmalloc::malloc::hb0329e71e24f7e2f</p>
			<p class="source-code">                  0 ┊          0.00% ┊  1810 ┊  3.48% ┊ &lt;char as core::fmt::Debug&gt;::fmt</p>
			<p class="source-code">                    ┊                ┊  1810 ┊  3.48% ┊     &lt;char as core::fmt::Debug&gt;::fmt::h5472f29c33f4c4c9</p>
			<p class="source-code">                  0 ┊          0.00% ┊  1126 ┊  2.16% ┊ dlmalloc::dlmalloc::Dlmalloc::free</p>
			<p class="source-code">                    ┊                ┊  1126 ┊  2.16% ┊     dlmalloc::dlmalloc::Dlmalloc::free::h7ab57ecacfa2b1c3</p>
			<p class="source-code">                  0 ┊          0.00% ┊  1123 ┊  2.16% ┊ core::str::slice_error_fail</p>
			<p class="source-code">                    ┊                ┊  1123 ┊  2.16% ┊     core::str::slice_error_fail::h26278b2259fb6582</p>
			<p class="source-code">                  0 ┊          0.00% ┊   921 ┊  1.77% ┊ core::fmt::Formatter::pad</p>
			<p class="source-code">                    ┊                ┊   921 ┊  1.77% ┊     core::fmt::Formatter::pad::hb011277a1901f9f7</p>
			<p class="source-code">                  0 ┊          0.00% ┊   833 ┊  1.60% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk</p>
			<p class="source-code">                    ┊                ┊   833 ┊  1.60% ┊     dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::he00c681454a3c3b7</p>
			<p class="source-code">                  0 ┊          0.00% ┊   787 ┊  1.51% ┊ core::fmt::write</p>
			<p class="source-code">                    ┊                ┊   787 ┊  1.51% ┊     core::fmt::write::hb395f946a5ce2cab</p>
			<p class="source-code">                  0 ┊          0.00% ┊   754 ┊  1.45% ┊ core::fmt::Formatter::pad_integral</p>
			<p class="source-code">                    ┊                ┊   754 ┊  1.45% ┊     core::fmt::Formatter::pad_integral::h05ee6133195a52bc</p>
			<p class="source-code">                  0 ┊          0.00% ┊   459 ┊  0.88% ┊ alloc::string::String::push</p>
			<p class="source-code">                    ┊                ┊   459 ┊  0.88% ┊     alloc::string::String::push::he03a5b89b77597a1</p>
			<p class="source-code">                  0 ┊          0.00% ┊  4276 ┊  8.21% ┊ ... and 64 more.</p>
			<p class="source-code">                  4 ┊          0.01% ┊ 17558 ┊ 33.73% ┊ Σ [85 Total Rows]</p>
			<p class="source-code">....</p>
			<p>We are <a id="_idIndexMarker496"/>using the <strong class="source-inline">index_bg.wasm</strong> example <a id="_idIndexMarker497"/>from the <em class="italic">Minimizing the WebAssembly modules</em> section of this chapter.</p>
			<p><strong class="source-inline">monos</strong> is extremely useful for us to understand the occurrence of any bloating caused by generic parameters, which can then be changed to a simpler function with generics.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor136"/>garbage</h2>
			<p>At times, it is <a id="_idIndexMarker498"/>important to find code that is not used anymore but is kept <a id="_idIndexMarker499"/>in the final binary due to some other reasons. These functions are referenced somewhere but not used anywhere and the compiler will not know when and where to remove them.</p>
			<p>We can use Twiggy's <strong class="source-inline">garbage</strong> command to list all the code and data that is not transitively referenced:</p>
			<p class="source-code">$ twiggy garbage add.wasm</p>
			<p class="source-code">Bytes │ Size % │ Garbage Item</p>
			<p class="source-code">───────┼────────┼─────────────────────────────────────────</p>
			<p class="source-code">   109 ┊  0.21% ┊ custom section 'producers'</p>
			<p class="source-code">   109 ┊  0.21% ┊ Σ [1 Total Rows]</p>
			<p class="source-code">27818 ┊ 53.44% ┊ 1 potential false-positive data segments</p>
			<p>WebAssembly modules consist of a data section. But sometimes, we might not use the data straight away in the WebAssembly module but in some other places where it is imported. As you can see here, Twiggy's <strong class="source-inline">garbage</strong> subcommand shows those potentially false values.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor137"/>Summary</h1>
			<p>In this chapter, we have seen how to optimize the WebAssembly binary using Rust, how to map memory between JavaScript and Rust, and finally, how to analyze a WebAssembly module using Twiggy. </p>
			<p>The WebAssembly ecosystem is still in its early days and it promises better performance. The WebAssembly binary addresses a few gaps in the JavaScript ecosystem, such as size-efficient compact binaries, enabling streaming compilation, and properly typed binaries. These features make WebAssembly smaller and faster. Rust, on the other hand, provides first-in-class support for generating a WebAssembly module and <strong class="source-inline">wasm-bindgen</strong> is the best tool available that makes it easier to transfer complex objects in Rust and WebAssembly. </p>
			<p>I hope that you now understand the basics of WebAssembly and how Rust makes it easier to generate WebAssembly modules. I can't wait to see what you will be shipping with Rust and WebAssembly.</p>
		</div>
	</body></html>