["```rs\nrustup --version\nrustc --version \ncargo --version\n```", "```rs\ngcc --version\n```", "```rs\nfn main() {\n    let num = 23;\n    let borrowed_num = &num; // immutable reference to num\n    let raw_ptr = borrowed_num as *const i32; // cast the \n    // reference borrowed_num to raw pointer\n    assert!(*raw_ptr == 23);\n}\n```", "```rs\nerror[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n```", "```rs\nfn main() {\n    let num = 23;\n    let borrowed_num = &num; // immutable reference to num\n    let raw_ptr = borrowed_num as *const i32; // cast \n    // reference borrowed_num to raw pointer\n    unsafe {\n        assert!(*raw_ptr == 23);\n    }\n}\n```", "```rs\n    fn main() {\n        let mut a_number = 5;\n        // Create an immutable pointer to the value 5\n        let raw_ptr1 = &a_number as *const i32;\n        // Create a mutable pointer to the value 5\n        let raw_ptr2 = &mut a_number as *mut i32;\n\n        unsafe {\n            println!(\"raw_ptr1 is: {}\", *raw_ptr1);\n            println!(\"raw_ptr2 is: {}\", *raw_ptr2);\n        }\n    }\n    ```", "```rs\n    static mut THREAD_COUNT: u32 = 4;\n    use std::env::var;\n    fn change_thread_count(count: u32) {\n        unsafe {\n            THREAD_COUNT = count;\n        }\n    }\n    fn main() {\n        if let Some(thread_count) = \n            var(\"THREAD_COUNT\").ok() {\n            change_thread_count(thread_count.parse::\n                <u32>()\n                .unwrap());\n        };\n        unsafe {\n            println!(\"Thread count is: {}\", THREAD_COUNT);\n        }\n    }\n    ```", "```rs\n    struct MyStruct(*mut u16);\n    unsafe impl Send for MyStruct {}\n    unsafe impl Sync for MyStruct {}\n    ```", "```rs\nuse std::ffi::{CStr, CString};\nuse std::os::raw::c_char;\nextern \"C\" {\n    fn getenv(s: *const c_char) -> *mut c_char;\n}\nfn main() {\n    let c1 = CString::new(\"MY_VAR\").expect(\"Error\");\n    unsafe {\n        println!(\"env got is {:?}\", CStr::from_ptr(getenv(\n            c1.as_ptr())));\n    }\n}\n```", "```rs\nMY_VAR=\"My custom value\" cargo -v run --bin ffi\n```", "```rs\n#[repr(C)]\nunion MyUnion {\n    f1: u32,\n    f2: f32,\n}\nfn main() {\n    let float_num = MyUnion {f2: 2.0};\n    let f = unsafe { float_num.f2 };\n    println!(\"f is {:.3}\",f);\n}\n```", "```rs\ncargo run \n```", "```rs\nlet f = unsafe { float_num.f2 };\n```", "```rs\nlet f = unsafe { float_num.f1 };\n```", "```rs\nf is 1073741824\n```", "```rs\n    cargo new --lib ffi && cd ffi\n    ```", "```rs\n    [lib]\n    name = \"ffitest\"\n    crate-type = [\"dylib\"]\n    ```", "```rs\n    #[no_mangle]\n    pub extern \"C\" fn see_ffi_in_action() {\n        println!(\"Congrats! You have successfully invoked \n            Rust shared library from a C program\");\n    }\n    ```", "```rs\n    libffitest.so, created in the target/release directory.\n    ```", "```rs\n    nm command-line utility is used to examine binary files (including libraries and executables) and view the symbols in these object files. Here, we are checking whether the function that we have written is included in the shared library. You should see a result similar to this:\n\n    ```", "```rs\n\n    ```", "```rs\n    #include \"rustffi.h\"\n    int main(void) {\n            see_ffi_in_action();\n    }\n    ```", "```rs\n    void see_ffi_in_action();\n    ```", "```rs\n    gcc: Invokes the GCC compiler.`-Ltarget/release`: The `–L` flag specifies to the compiler to look for the shared library in the folder target/release.`-lffitest`: The `–l` flag tells the compiler that the name of the shared library is `ffitest`. Note that the actual library built is called `libffitest.so`, but the compiler knows that the `lib` prefix and `.so` suffix are part of the standard shared library name, so it is sufficient to specify `ffitest` for the `–l` flag.`rustffi.c`: This is the source file to be compiled.`-o ffitest`: Tells the compiler to generate the output executable with the name `ffitest`.\n    ```", "```rs\n    export LD_LIBRARY_PATH=$(rustc --print sysroot)/lib:target/release:$LD_ LIBRARY_PATH\n    ```", "```rs\n    ./ffitest\n    ```", "```rs\nCongrats! You have successfully invoked Rust shared library from a C program\n```", "```rs\n    #[cfg(target_arch = \"x86_64\")]  \n    #[cfg(target_os = \"linux\")] \n    #[cfg(target_family = \"windows\")] \n    #[cfg(target_env = \"gnu\")] \n    #[cfg(target_pointer_width = \"32\")]\n    ```", "```rs\n    // Only if target OS is Linux and architecture is x86, \n    // include this function in build \n    #[cfg(all(target_os = \"linux\", target_arch = \"x86\"))] \n    // all conditions must be true  \n    fn do_something() { // ... }\n    ```", "```rs\n    #[link(name = \"my_library\")]\n    extern {\n        static a_c_function() -> c_int;\n    }\n    ```", "```rs\n    #[link(name = \"my_other_library\", kind = \"static\")]\n    ```"]