["```rs\n// see code in Chapter 5/code/higher_functions.rs\nlet mut strength = 26;\nprintln!(\"My tripled strength equals {}\",triples(strength)); // 78\nprintln!(\"My strength is still {}\", strength); // 26\nstrength = triples(strength);\nprintln!(\"My strength is now {}\", strength); // 78\n```", "```rs\nfn again (f: F, s: i32) -> i32  { f(f(s)) }\n```", "```rs\nfn again<F: Fn(i32) -> i32>(f: F , s: i32) -> i32 {\n f(f(s))\n}\n\n```", "```rs\nstrength = again(triples, strength);\nprintln!(\"I got so lucky to turn my strength into {}\", strength); // 702 (= 3 * 3 * 78)\n```", "```rs\n  strength = 78;\n let triples = |n| { 3 * n };\n  strength = again(triples, strength);\n  println!(\"My strength is now {}\", strength); // 702\n```", "```rs\n  strength = 78;\n strength = again(|n| { 3 * n }, strength);\n  println!(\"My strength is now {}\", strength); // 702\n```", "```rs\nstrength = again(|n| 3 * n , strength);\n```", "```rs\n   let x: i32 = 42;\n   let print_add = |s| { \n      println!(\"x is {}\", x); \n      x + s\n    }; \n   let res = print_add(strength);\n   // here the closure is called and \"x is 42\" is printed\n   assert_eq!(res, 744); // 42 + 702\n```", "```rs\n    let m: i32 = 42;\n let print_add_move = move |s| { \n      println!(\"m is {}\", m); \n      m + s\n    };\n    let res = print_add_move(strength); // strength == 702\n    assert_eq!(res, 744); // 42 + 702\n```", "```rs\n// see code in Chapter 5/code/iterators.rs\n    let mut rng = 0..7;\n println!(\"> {:?}\", rng.next()); // prints Some(0)\n    println!(\"> {:?}\", rng.next()); // prints Some(1)\n    for n in rng {\n      print!(\"{} - \", n);\n    } // prints 2 - 3 - 4 - 5 - 6 -\n```", "```rs\nfor alien in aliens.iter() {\n print!(\"{} / \", alien)\n // process alien\n}\n\n```", "```rs\nfor alien in &aliens {\n  print!(\"{} / \", alien)\n}\n```", "```rs\nlet rng = 0..1000_000; // _ makes the number 1000000 more readable\n```", "```rs\n// see code in Chapter 5/code/adapters_consumers.rs\nlet rng = 0..1000;\nlet rngvec = rng.collect::<Vec<i32>>();\nprintln!(\"{:?}\", rngvec);\n```", "```rs\nlet rngvec: Vec<i32> = rng.collect();\n```", "```rs\n  let forty_two = rng.find(|n| *n >= 42);\n println!(\"{:?}\", forty_two);  // prints out Some(42)\n\n```", "```rs\n  let rng_even = rng.filter(|n| is_even(*n))\n .collect::<Vec<i32>>();\n  println!(\"{:?}\", rng_even);\n```", "```rs\nfn is_even(n: i32) -> bool {\n  n % 2 == 0\n}\n```", "```rs\n  let rng_even_pow3 = rng.filter(|n| is_even(*n))\n .map(|n| n * n * n)\n                         .collect::<Vec<i32>>();\n  println!(\"{:?}\", rng_even_pow3);\n```", "```rs\nlet sum = (0..101).fold(0, |sum, n| sum + n);\nprintln!(\"{}\", sum); // prints out 5050\n```", "```rs\n// see code in Chapter 5/code/generics.rs\nstruct Pair<T> {\n first: T,\n second: T,\n}\n\n```", "```rs\nlet magic_pair: Pair<u32> = Pair { first: 7, second: 42 };\nlet pair_of_magicians: Pair<&str> = Pair { first: \"Gandalf\", second: \"Sauron\" };\n```", "```rs\nfn second<T>(pair: Pair<T>) {\n pair.second;\n}\n```", "```rs\nenum Option<T> {\n    Some(T),\n    None\n}\n```", "```rs\nlet x: Option<i8> = Some(5);\nlet pi: Option<f64> = Some(3.14159265359);\nlet none: Option<f64> = None;\nlet none2 = None::<f64>;\nlet name: Option<&str> = Some(\"Joyce\");\n```", "```rs\nstruct Person {\n  name: &'static str,\n  id:   i32\n}\n```", "```rs\nlet p1 = Person{ name: \"James Bond\", id: 7 };\nlet p2 = Person{ name: \"Vin Diesel\", id: 12 };\nlet p3 = Person{ name: \"Robin Hood\", id: 42 };\n```", "```rs\nlet op1: Option<Person> = Some(p1);\nlet pvec: Vec<Person> = vec![p2, p3];\n```", "```rs\nenum Result<T, E> {\n    Ok(T),\n    Err(E)\n}\n```", "```rs\nlet input_num: Result<u32, _> = buf.trim().parse();\n```", "```rs\nmatch input_num {\n Ok(num) => println!(\"{}\", num),\n Err(ex) => println!(\"Please input an integer number! {}\", ex)\n};\n```", "```rs\nfn sqroot(r: f32) -> Result<f32, String> {\n  if r < 0.0 { \n    return Err(\"Number cannot be negative!\".to_string()); \n  }\n  Ok(Float::sqrt(r))\n}\n```", "```rs\nlet m = sqroot(42.0);\n```", "```rs\nmatch m {\n   Ok(sq) => println!(\"The square root of 42 is {}\", sq),\n   Err(str) => println!(\"{}\", str)\n}\n```", "```rs\n// see code in Chapter 5/code/errors.rs\nlet x = 3;\nlet y = 0;\nx / y; \n```", "```rs\nif (y == 0) { panic!(\"Division by 0 occurred, exiting\"); }\nprintln!(\"{}\", div(x, y));\n```", "```rs\nfn div(x: i32, y: i32) -> f32 {\n  (x / y) as f32\n}\n```", "```rs\nassert!(x == 5); //thread <main> panicked at assertion failed: x == 5\nassert!( x == 5, \"x is not equal to 5!\");\n// thread <main> panicked at \"x is not equal to 5!\"\nassert_eq!(x, 5); // thread '<main>' panicked at 'assertion failed: (left: `3`, right: `5`)',\n```", "```rs\nunreachable!(); \n// thread '<main>' panicked at 'internal error: entered unreachable code'\n\n```", "```rs\n// see code in Chapter 5/code/methods.rs\nstruct Alien {\n  health: u32,\n  damage: u32\n}\n```", "```rs\nlet mut bork = Alien{ health: 100, damage: 5 }; \n```", "```rs\nimpl Alien {\n fn new(mut h: u32, d: u32) -> Alien {\n // constraints:\n if h > 100 { h = 100; }\n Alien { health: h, damage: d }\n }\n}\n\n```", "```rs\nlet mut berserk = Alien::new(150, 15);\n\n```", "```rs\n  fn warn() -> &'static str {\n    \"Leave this planet immediately or perish!\"\n  }\n```", "```rs\nprintln!(\"{}\", Alien::warn());\n\n```", "```rs\nfn attack(&self) {\n  println!(\"I attack! Your health lowers with {} damage points.\", self.damage);\n}\n```", "```rs\nfn attack(&self) {\n  self.health -= 10;\n}\n```", "```rs\nfn attack_and_suffer(&mut self, damage_from_other: u32) {\n  self.health -= damage_from_other;\n}\n```", "```rs\n// see code in Chapter 5/code/traits.rs\ntrait Monster {\n fn attack(&self);\n}\n\n```", "```rs\nimpl Monster for Alien {\n\n}\n\n```", "```rs\nimpl Monster for Alien {\n  fn attack(&self) {\n    println!(\"I attack! Your health lowers with {} damage points.\", self.damage);\n  }\n}\n```", "```rs\nimpl Monster for Zombies {\n  fn attack(&self) {\n    println!(\"I bite you! Your health lowers with {} damage points.\", 2 * self.damage);\n  }\n}\n```", "```rs\ntrait Monster {\n    fn new(hlt: u32, dam: u32) -> Self;\n    fn attack(&self);\n    fn noise(&self) -> &'static str;\n fn attacks_with_sound(&self) {\n println!(\"The Monster attacks by making an awkward sound {}\", self.noise());\n }\n}\n```", "```rs\nimpl Monster for Zombie {\n  fn new(mut h: u32, d: u32) -> Zombie {\n    // constraints:\n    if h > 100 { h = 100; }\n    Zombie { health: h, damage: d }\n  }\n  fn attack(&self) {\n    println!(\"The Zombie bites! Your health lowers with {} damage points.\", 2 * self.damage);\n  }\n  fn noise(&self) -> &'static str {\n    \"Aaargh!\"\n  }\n}\n```", "```rs\nlet zmb1 = Zombie { health: 75, damage: 15 };\nprintln!(\"Oh no, I hear: {}\", zmb1.noise());\nzmb1.attack();\n```", "```rs\nprintln!(\"{:?}\", zmb1);\n```", "```rs\n#[derive(Debug)]\nstruct Zombie { health: u32, damage: u32 }\n```", "```rs\nfn sqroot(r: f32) -> Result<f32, String> {\n  if r < 0.0 {\n    return Err(\"Number cannot be negative!\".to_string()); \n  }\n  Ok(f32::sqrt(r))\n}\n```", "```rs\n// see code in Chapter 5/code/trait_constraints.rs\nextern crate num;\nuse num::traits::Float;\nfn sqroot<T>(r: T) -> Result<T, String> {\n  if r < 0.0 { \n    return Err(\"Number cannot be negative!\".to_string()); \n  }\n  Ok(num::traits::Float::sqrt(r))\n}\n```", "```rs\nbinary operation `<` cannot be applied to type `T`\nthe trait `core::marker::Copy` is not implemented for the type `T`\nthe trait `core::num::NumCast` is not implemented for the type `T`\n…\n\n```", "```rs\nfn sqroot<T: num::traits::Float>(r: T) -> Result<T, String> {\n  if r < num::zero() { \n    return Err(\"Number cannot be negative!\".to_string()); \n  }\n  Ok(num::traits::Float::sqrt(r))\n}\n```", "```rs\nprintln!(\"The square root of {} is {:?}\", 42.0f32, sqroot(42.0f32) );\nprintln!(\"The square root of {} is {:?}\", 42.0f64, sqroot(42.0f64) );\n```", "```rs\nThe square root of 42 is Ok(6.480741)\nThe square root of 42 is Ok(6.480741)\n\n```", "```rs\nprintln!(\"The square root of {} is {:?}\", 42, sqroot(42) );\n```", "```rs\nfn sqroot<T>(r: T) -> Result<T, String> where T: num::traits::Float { … }\n\n```", "```rs\nfn multc<T: Trait1, U: Trait1 + Trait2>(x: T, y: U) {}\n```", "```rs\nfn multc<T, U>(x: T, y: U) where T: Trait1, U: Trait1 + Trait2 {}\n```"]