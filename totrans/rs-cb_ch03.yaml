- en: Deep Diving into Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project using Cargo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading an external crate from crates.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working on existing Cargo projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests with Cargo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the project on the Travis CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading to crates.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cargo is one of the unique selling points of Rust, which is the first of its
    kind in the system programming space. Cargo is Rust's package manager, and it
    makes a developer's life easy in regard to creating, developing, packaging, maintaining,
    testing, and deploying application code or tools to production, without great
    effort. In this chapter, we will cover recipes that will enable a developer to
    utilize all the features of Cargo and make a production-grade Rust application
    from day one of development.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project using Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cargo is a unique offering from Rust and is very new in the sphere of system
    programming. It is also one of the selling points of Rust, as it enables developers
    to package, ship, and test their Rust application.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover a lot of functionalities of Cargo in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We require the Rust compiler, Cargo, and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the directory where you want to create the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following command to create a new Rust project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a project named `hello_world`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b17cd26-363d-47a8-84a9-838bc8711661.png)'
  prefs: []
  type: TYPE_IMG
- en: You should have a new folder created with the name of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, get into the project and examine it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5dc8dbc-18b3-45ab-8dc7-4e094c7d4062.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the whole structure of the newly created project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the content of the `Cargo.toml` file using the `cat` command in Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd799fce-392e-489c-ac2c-e958fe9d2a4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the `src` directory inside the project where you will find the default
    `main.rs` file and print its content using the `cat` command in Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce80257d-ccc6-4036-88d5-226eb35e414e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Build the sample project that comes with the `cargo new` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c519252-e025-470e-9fa4-c1e86cb9e4d7.png)'
  prefs: []
  type: TYPE_IMG
- en: The Cargo build will create a new directory named `target` and a file named
    `cargo.lock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the compiled project, which is a executable file present in the target directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since this is an executable, you should be able to see the output of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fae32c88-7b4a-4aed-b76a-148cf0cbd9a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have to follow the preceding two steps in order to build the executable
    code and then execute the Rust application, but with the `cargo run` command we
    can perform both simultaneously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c35b8e5-eb65-41b2-93ba-56c606a1cc0f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cargo is a command-line tool that comes with the installation of Rust. It''s
    essential for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It introduces metadata files that convey all the details about the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls the `rustc` compiler to build the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps the developer structure and maintain the code better
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cargo new` commands create the complete folder structure for us. For our
    project, the `--bin` indicates the binary file. This means we are creating a Rust
    application that is expected to work out of the box in regard to solving a real-world
    problem. However, in this case, we created a library that would not use the `--bin`
    option as a command-line tool. Libraries are known as crates in Rust. We will
    create a crate in Rust later, in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '`Cargo.toml` is a manifest file that contains all the metadata that Cargo needs
    to compile your project. When you run the `cargo build` command, you will see
    that the source code is converted into an executable byte code, which would be
    the end application; this creates the `target` directory and places the executable
    in the `debug` folder inside it. Inside the `debug` folder, we mainly have `deps`
    directory which contains the different dependent crates which were downloaded
    to execute the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Your project can optionally contain folders named `example`, `test`, and `bench`,
    which Cargo will treat as containing examples, integration tests, and benchmarks
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is very smart and only compiles when there are changes in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling `cargo build --release` in debug mode is suitable for development,
    and its compilation time is shorter since the compiler does not do any optimizations
    and checks. However, when you run the code in release mode, it will take longer
    to compile, but the code will run faster in production. The release mode will
    prepare the build in the `release` folder inside `target` instead of `debug` directory.
  prefs: []
  type: TYPE_NORMAL
- en: We see that the build process created a `Cargo.lock` file. This file contains
    all the information about our dependencies. We will cover this file in detail
    in an upcoming recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to compile multiple binaries in the same Rust project, we have to
    make certain entries in the `Cargo.toml` file where we explicitly mention the
    target that we want to build. By default, Cargo compiles the `main.rs` file in
    the `src` folder with the same name of the project, but for compiling multiple
    binaries, say `daemon` and `client`, which need to be built, we make the following
    mention changes in the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This would build an additional two binaries named `daemon` and `client`, along
    with the project binary.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly we can have sections such as`[lib]`, `[[bench]]`, `[[test]]`, and
    `[[example]]` in a configuration file to build libraries, benchmarks, tests, and
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading an external crate from crates.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create complex applications for solving real-world problems, we need to reuse
    other open source projects and dependencies for faster development.
  prefs: []
  type: TYPE_NORMAL
- en: The [https://crates.io/](https://crates.io/) is the Rust community's central
    repository that serves as a location for discovering and downloading packages.
    The command-line tool **`cargo`** is configured to find requested packages and
    download and use them. You will learn how to download and maintain external crates
    (dependencies) in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We require the Rust compiler, Cargo, and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `Cargo.toml` file in your favorite text editor; in this recipe, we
    will use the `nano` editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6051ead3-0ccc-4386-aeaa-2521cb2d287a.png)'
  prefs: []
  type: TYPE_IMG
- en: Add a `[dependencies]` section to the `cargo.toml` file and enter `time = "0.1.12"`
    and `regex = "0.1.41"` below it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b796fa21-2c3b-4cec-8373-624992ff2f0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the `cat` command to see the configuration list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e08a465-a5b1-4268-8108-4f528522de23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Build the project to pull the dependencies from [https://crates.io/](https://crates.io/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f0112ef-2dd0-47bd-a639-7435f462de6f.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the existing crates pulled in our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `main.rs` file in the `src` directory using `nano` and enter the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8670d72-1184-40aa-af86-3aa889e7e9d3.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following state output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f65fce94-30df-438c-b170-a280a3f699c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Compile and run the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5eef42b-b7d7-4e98-bfc7-6e6a79251300.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We enter the dependencies we require for the project in the `Cargo.toml` file.
    This file fetches us the package and version mentioned in the [https://crates.io/](https://crates.io/)
    central repository. In the preceding recipe, we downloaded the time and regex
    crates and also mentioned the desired version that we would like to work on.
  prefs: []
  type: TYPE_NORMAL
- en: When we build a project after modifying the `Cargo.toml` file, it downloads
    all the modules inside the crate of our local development system and makes an
    entry in the `Cargo.lock` file, which would contain all the details about the
    downloaded dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: If you are planning to create a library or improve upon an existing library
    implementation, it is advisable that you check out whether there are any similar
    ideas or projects implemented in [https://crates.io/](https://crates.io/) to evaluate
    the value of your open project. All the projects put up on the [https://crates.io/](https://crates.io/)
    repository are open source projects available on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The fun part about using other dependencies is that you get to reuse the available
    working version of an application or function you would like to use in the project
    and reduce your project development time.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `extern crate` command in our Rust script to call the downloaded
    crates.
  prefs: []
  type: TYPE_NORMAL
- en: '`extern crate regex` or crate and import all its functions inside the modules
    it has. We then call them in the code by passing our data.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, we explicitly mentioned the need for using the
    `use` command to call the `Regex` module in the `regex` crate using `regex::Regex`
    and checking whether the dates match and print the Boolean value in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `unwrap` and `is_match` functions to check whether both the strings
    are the same or not. We return `true` if they are similar and `false` if they
    are not.
  prefs: []
  type: TYPE_NORMAL
- en: Working on existing Cargo projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cargo is a tool that allows the Rust application to declare their various dependencies
    to ensure that you will able to recreate the build by following the same dependencies
    and version.
  prefs: []
  type: TYPE_NORMAL
- en: At a higher level, it offers configuration management to the Rust project and
    helps in reproducing the development environment. Usually, in other languages,
    it's a very tedious and time-consuming process to maintain the different dependencies
    and configure them each and every time we deploy the application in a different
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Cargo provides features out of the box which enables developers and project
    managers to ship/deploy Rust projects/applications very quickly and without much
    hassle; this is a very big advantage over other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We require the Rust compiler, Cargo, and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clone the project from the project repo in this recipe. Close the `rand` crate
    from GitHub where it is hosted. Do this by typing the following command in the
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79c2d53c-b3f6-4d0f-a16d-3982f2b1324d.png)'
  prefs: []
  type: TYPE_IMG
- en: This would clone the repo from the GitHub to the local system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the newly created project `rand` and check out the complex production-level
    package details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/536d9e70-2807-4680-ba72-03e76860cd04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Build the project using the Cargo build command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9b328bc-4e9a-4b23-9aa2-af02a4ebf30d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding three steps would set up a complete Rust project in your local
    development environment. This is the power of the Cargo command-line tool, which
    makes the post- development application life cycle so easy for a developer.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have basically cloned an existing project and built it. Cargo looked
    into the manifest file to fetch all the metadata that was required to understand
    the various dependencies of the project and build them.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests with Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests are important for complex production-grade applications as they validate
    the working of a functional unit of the project. Cargo provides Rust with all
    the testing functionalities that help in unit and integration tests out of the
    box.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We require the Rust compiler, Cargo, and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the `cargo test` command inside the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e559e26-ec7d-4bb6-b031-11e7e88e7ae0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Mention the name to run a particular test-- `cargo test test_name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1b65b95-746d-4ddc-a7cc-b4ade4c82414.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cargo looks for tests to run in two places: they are in the `src` directory,
    where we can have our unit tests'' code placed, and the `tests` directory, where
    we place the integration tests.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we did not have any tests for the project, but we have a dedicated
    chapter for tests later, where we will deep dive into the various aspects of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management of the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will thoroughly explore the use of `Cargo.lock` and `Cargo.toml` in this
    recipe and we'll see how they help in configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management here refers to the ability to have version control,
    which includes uploading and downloading the desired version of your project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We require the Rust compiler, Cargo, and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to the `hello_world` project and enter the GitHub repo link of the `rand`
    library in the `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following `Cargo.toml`, enter the mentioned dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/888b1472-3683-4d04-b400-6219e1e330da.png)'
  prefs: []
  type: TYPE_IMG
- en: In the same `Cargo.toml` file, enter `rev` and the `SHA` value for the `rand`
    crate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ce3e951-eab1-481a-af2b-78933a648990.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Type the `cargo update` command to implement the new changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/037b0a26-c710-4b81-9665-7869631b5969.png)'
  prefs: []
  type: TYPE_IMG
- en: Enter `Cargo.lock` and look through the `rand` package details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e0d7eab-a66c-4f71-8328-57788d72b405.png)'
  prefs: []
  type: TYPE_IMG
- en: Never make any manual changes in the `Cargo.lock` file. It is not intended to
    be edited manually.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cargo parses through the manifest file data, and, based on the data entered,
    it performs certain tasks.
  prefs: []
  type: TYPE_NORMAL
- en: First, we entered the GitHub repo link of the project in the `Cargo.toml` file
    to install the particular crate. Since we did not mention any other detail--for
    example, which version--Cargo will pull all the modules and resources of the latest
    commit to the master branch of the project.
  prefs: []
  type: TYPE_NORMAL
- en: However, the problem with this approach is that, if the project changes its
    layout or code tomorrow, our current implementation may be affected when we update
    the package.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, we assigned the `rev` value to the commit ID of the project whose
    resource we have used for our current build. This seems to solve our problem,
    but we still have to remember the commit ID, which is error-prone when we enter
    a wrong ID.
  prefs: []
  type: TYPE_NORMAL
- en: Enter `Cargo.lock` using the `nano` command. Since the `lock` file exists, we
    don't need to manually keep track of the revision of the dependencies. Cargo will
    create entries in the `Cargo.lock` file with the details of the revision for each
    package used in the application.
  prefs: []
  type: TYPE_NORMAL
- en: When you build for the first time, Cargo will take the latest commit and write
    that information to `Cargo.lock`. Imagine that we are shipping the project to
    a new host where we want to configure the Rust application. Cargo will use the
    exact `SHA` from the `Cargo.lock` file even though you should not have mentioned
    it in the `Cargo.toml` file. We can see there is a lot of information about the
    package in the `lock` file, which will help us reproduce the same dependencies
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Building the project on the Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Travis CI is a continuous integrated software that reads the `yml` file in your
    project repository. It provides instructions or commands to the tools on how you
    should build, test, and ship.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to build a Rust application using the `TravisCI`
    tool whose code is hosted on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We require the Rust compiler, Cargo, and any text editor for coding. Host the
    Rust application in a GitHub repo and integrate the `TravisCI` tool to the GitHub
    repo.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `.travis.yml` file in the project using the `touch` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following configuration for testing the application in different
    Rust builds by opening the file using any text editor; we are using `nano` in
    this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/032afcbc-7057-416c-924b-8783879c2a02.png)'
  prefs: []
  type: TYPE_IMG
- en: Make a change in the project and push the project to the GitHub repo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `build` process is triggered on TravisCI platform each and every time we
    push a commit in the project repository. This process is configurable by the advance
    options available in the TravisCI platform, where you can schedule the build or
    select repo branches to build from.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get the following screenshot as output in the Travis CI platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/412c70cd-313e-4df3-8fa0-30a8802780ca.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Travis CI tools read the instruction specified in the `.travis.yml` file of
    the project and prepare the environment in which you want to build, test, and
    release the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will break down and understand what each of the commands
    does in the `build` pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This downloads and installs the latest stable version of the Rust release when
    setting up the machine. If you only want to test the application in a stable version,
    you just need the preceding command and there is no need to specify the versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For specifying the versions in which you want to test the application, you
    can use the preceding command where you built the project in the `beta` and `nightly`
    channels. Even if you are only targeting stable, the Rust team encourages you
    to test it on other channels as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will test all three channels, and any breakage in `nightly` will not fail
    your overall build.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding `build` logs, if you look closely, you will see the default
    test script is run by the Travis CI, and it uses the Cargo tool to run your build
    and test the application using `cargo build` and `cargo test` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading to crates.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [https://crates.io/](https://crates.io/) is a website that acts as a central
    repository for hosting all the crates made by the amazing Rust community. It contains
    various projects of various domains.
  prefs: []
  type: TYPE_NORMAL
- en: This helps in instantly publishing the crate and installing them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We require the Rust compiler, Cargo, and any text editor to code and create
    an account on the [https://crates.io/](https://crates.io/) website using the GitHub
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to the project location from where you want to upload your project to [https://crates.io/](https://crates.io/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The [https://crates.io/](https://crates.io/) provides an API token on the accounts
    setting page when you create a new account or log in with your existing GitHub
    ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Package the Rust application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Publish the Rust application to [https://crates.io/](https://crates.io/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cargo login command takes the API token provided and stores it in the `~/.cargo/config`
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the API token should be kept secret and should not be shared, as it
    is the way by which we can manage the crates uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the name that you used to create the project is going to be
    the name of the crate, and names of crates are based on a first come, first served
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: When our project is ready to be packaged, we use the preceding step to create
    a new folder, named `/target/package`.
  prefs: []
  type: TYPE_NORMAL
- en: The content inside the package is what is going to be uploaded to the [https://crates.io/](https://crates.io/)
    website. There will be a file with the naming convention `project_name-version.crate`
    and a folder `project_name-version`. These names are based on the information
    given by the developer to `cargo.toml`. We can tweak the value in the configuration
    file and use the package command until we get the correct name and version number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In packaging, we have to make sure that we do not upload unnecessary files,
    such as test script or text files and so on, which were used for testing the library.
    For this purpose, the `*.crate` file provides a lot of tags or keys that tell
    about the various features, examples, and resources of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding section, we explicitly mentioned that all the resources in
    the `assets` and `videos` folders be excluded; on the other hand, we had a tag
    named `include` that will help to make sure all the important files are packaged.
  prefs: []
  type: TYPE_NORMAL
- en: The final command, `cargo publish`, looks into the `*.crate` file and publishes
    the crate in the account created.
  prefs: []
  type: TYPE_NORMAL
