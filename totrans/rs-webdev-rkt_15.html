<html><head></head><body>
		<div><h1 id="_idParaDest-132"><em class="italic"><a id="_idTextAnchor133"/>Chapter 12</em>: Testing Your Application</h1>
			<p>Ensuring that a program runs correctly is an important part of programming. In this chapter, we are going to learn about testing the Rust application. We are going to implement a simple unit test for a function, and a functional test for creating a user in our application. </p>
			<p>We are going to learn a simple technique to debug and find where a problem occurs in our code.</p>
			<p>After learning the information in this chapter, you will be able to create a unit test and functional test for Rust and Rocket applications to ensure the applications work as expected. You will also learn how to use a debugger such as <code>gdb</code> or <code>lldb</code> to debug Rust programs.</p>
			<p>In this chapter, we are going to cover these main topics:</p>
			<ul>
				<li>Testing the Rust program</li>
				<li>Testing the Rocket application</li>
				<li>Debugging the Rust application</li>
			</ul>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor134"/>Technical requirements</h1>
			<p>In this chapter, we are going to do a test and debug, so we need a debugger. Please install <code>gdb</code>, the GNU Debugger (<a href="https://www.sourceware.org/gdb/download/">https://www.sourceware.org/gdb/download/</a>), for your operating system.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter12">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter12</a>.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor135"/>Testing the Rust program</h1>
			<p>One important part of programming is testing the application. There are many kinds of tests, such as <a id="_idIndexMarker653"/>unit tests (to test a single function or method), functional tests (to test the function of an application), and integration testing (to test various units and functions as a single combined entity). Various tests should be conducted in order to make the application as correct as intended.</p>
			<p>In the Rust standard library, there are three macros to use in testing: <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code>. The <code>assert!</code> macro accepts one or more parameters. The first parameter is any statement that evaluates to Boolean, and the rest is for debugging if the result is not what is expected.</p>
			<p>The <code>assert_eq!</code> macro compares equality between the first parameter and second parameter, and the rest is for debugging if the result is not what is expected. The <code>assert_ne!</code> macro is the opposite of <code>assert_eq!</code>; this macro tests the inequality between the first and the second parameters.</p>
			<p>Let's see those macros in action. We want to test the <code>raw_html()</code> method of the <code>TextPost</code> model in <code>src/models/text_post.rs</code>. We want to ensure that the result of the method is the string we want to have. Follow these steps to test the method:</p>
			<ol>
				<li>In <code>src/models/text_post.rs</code>, add the following <code>use</code> declarations:<pre>use crate::models::our_date_time::OurDateTime;
use crate::models::post_type::PostType;
use chrono::{offset::Utc, TimeZone};
use uuid::Uuid;</pre></li>
				<li>In the same <code>src/models/text_post.rs</code> file, we want to have a function for testing. To make a function a test function, annotate the function with the <code>#[test]</code> attribute. Add the function declaration:<pre>#[test]
fn test_raw_html() {
}</pre></li>
				<li>Inside the function, initialize a <code>TextPost</code> instance as follows:<pre>let created_at = OurDateTime(Utc.timestamp_nanos(1431648000000000));
let post = Post {
    uuid: Uuid::new_v4(),
    user_uuid: Uuid::new_v4(),
    post_type: PostType::Text,
    content: String::from("hello"),
    created_at: created_at,
};
let text_post = TextPost::new(&amp;post);</pre></li>
				<li>Add the <code>assert!</code> macro to ensure the resulting string is what we want:<pre>assert!(
    text_post.raw_html() == 
    String::from("&lt;p&gt;hel1lo&lt;/p&gt;"),
    "String is not equal, {}, {}",
    text_post.raw_html(),
    String::from("&lt;p&gt;hello&lt;/p&gt;")
);</pre></li>
				<li>Save the file and run the test by running <code>cargo test</code> on the Terminal. As we made a <a id="_idIndexMarker654"/>mistake in our test code, <code>"&lt;p&gt;hel1lo&lt;/p&gt;"</code>, the test should fail, as in the following example:<pre><strong class="bold">$ cargo test</strong>
<strong class="bold">   Compiling our_application v0.1.0 (/workspace/</strong>
<strong class="bold">   rocketbook/Chapter12/01RustTesting)</strong>
<strong class="bold">…</strong>
<strong class="bold">running 1 test</strong>
<strong class="bold">test models::text_post::test_raw_html ... FAILED</strong>
<strong class="bold">failures:</strong>
<strong class="bold">---- models::text_post::test_raw_html stdout ----</strong>
<strong class="bold">thread 'models::text_post::test_raw_html' panicked at 'String is not equal, &lt;p&gt;hello&lt;/p&gt;, &lt;p&gt;hello&lt;/p&gt;', src/models/text_post.rs:33:5</strong>
<strong class="bold">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</strong>
<strong class="bold">failures:</strong>
<strong class="bold">    models::text_post::test_raw_html</strong>
<strong class="bold">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong>
<strong class="bold">error: test failed, to rerun pass '--lib' </strong></pre></li>
				<li>Fix <code>"&lt;p&gt;hel1lo&lt;/p&gt;"</code> by replacing it with <code>"&lt;p&gt;hello&lt;/p&gt;"</code>. Save the file and run <a id="_idIndexMarker655"/>the test again. The test should work fine now:<pre><strong class="bold">$ cargo test</strong>
<strong class="bold">   Compiling our_application v0.1.0 (/workspace/</strong>
<strong class="bold">   rocketbook/Chapter12/01RustTesting)</strong>
<strong class="bold">…</strong>
<strong class="bold">running 1 test</strong>
<strong class="bold">test models::text_post::test_raw_html ... ok</strong>
<strong class="bold">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong>
<strong class="bold">     Running unittests (target/debug/deps/our_</strong>
<strong class="bold">     application-43a2db5b02032f30)</strong>
<strong class="bold">running 0 tests</strong>
<strong class="bold">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong>
<strong class="bold">   Doc-tests our_application</strong>
<strong class="bold">running 0 tests</strong>
<strong class="bold">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong></pre></li>
				<li>We want to use the <code>assert_eq!</code> and <code>assert_ne!</code> macros. The <code>assert_eq!</code> macro is used to check that the first parameter is equal to the second parameter. The <code>assert_ne!</code> macro is used to make sure that the first parameter is <a id="_idIndexMarker656"/>not equal to the second parameter. Add the macros in the <code>test_raw_html()</code> function to see them in action:<pre>assert_eq!(text_post.raw_html(), String::from("&lt;p&gt;hello&lt;/p&gt;"));
assert_ne!(text_post.raw_html(), String::from("&lt;img&gt;hello&lt;/img&gt;"));</pre></li>
				<li>Run the test again; it should pass. But, if we look at the test output, there are warnings, as follows:<pre><strong class="bold">warning: unused import: `crate::models::our_date_time::OurDateTime`</strong>
<strong class="bold"> --&gt; src/models/text_post.rs:1:5</strong>
<strong class="bold">  |</strong>
<strong class="bold">1 | use crate::models::our_date_time::OurDateTime;</strong>
<strong class="bold">  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</strong>
<strong class="bold">  |</strong>
<strong class="bold">  = note: `#[warn(unused_imports)]` on by default</strong></pre></li>
				<li>One of the conventions for unit testing is to create a test module and mark the module as a test so <a id="_idIndexMarker657"/>it will not be compiled. In <code>src/models/text_post.rs</code>, add a new module:<pre>#[cfg(test)]
mod tests {
}</pre></li>
				<li>In <code>src/models/text_post.rs</code>, remove these unused <code>use</code> declarations:<pre>use crate::models::our_date_time::OurDateTime;
use crate::models::post_type::PostType;
use chrono::{offset::Utc, TimeZone};
use uuid::Uuid;</pre></li>
				<li>Vice versa, add the required <code>use</code> declarations in <code>src/models/text_post.rs</code> in the <code>tests</code> module: <pre>use super::TextPost;
use crate::models::our_date_time::OurDateTime;
use crate::models::post::Post;
use crate::models::post_type::PostType;
use crate::traits::DisplayPostContent;
use chrono::{offset::Utc, TimeZone};
use uuid::Uuid;</pre></li>
				<li>Move the <code>test_raw_html()</code> function into the <code>tests</code> module. Run <code>cargo test</code> again in <a id="_idIndexMarker658"/>the Terminal. The tests should pass with no warnings, as in the following example:<pre><strong class="bold">$ cargo test</strong>
<strong class="bold">    Finished test [unoptimized + debuginfo] target(s) </strong>
<strong class="bold">    in 0.34s</strong>
<strong class="bold">     Running unittests (target/debug/deps/our_</strong>
<strong class="bold">     application-40cf18b02419edd7)</strong>
<strong class="bold">running 1 test</strong>
<strong class="bold">test models::text_post::tests::test_raw_html ... ok</strong>
<strong class="bold">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong>
<strong class="bold">     Running unittests (target/debug/deps/our_</strong>
<strong class="bold">     application-77e614e023a036bf)</strong>
<strong class="bold">running 0 tests</strong>
<strong class="bold">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong>
<strong class="bold">   Doc-tests our_application</strong>
<strong class="bold">running 0 tests</strong>
<strong class="bold">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong></pre></li>
			</ol>
			<p>Now that we have <a id="_idIndexMarker659"/>learned how to perform unit tests in Rust, we can continue by testing the application with functional testing in the next section.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor136"/>Testing the Rocket application</h1>
			<p>Besides putting the test in the <code>src</code> directory, we can create a test in Rust files in the <code>tests</code> directory inside the root directory of the application. When we run <code>cargo test</code>, the command <a id="_idIndexMarker660"/>line will look into the <code>tests</code> directory and run any test found there. People usually use tests in the <code>src</code> directory for unit testing and write functional tests in the <code>tests</code> directory.</p>
			<p>The Rocket framework provides a <code>rocket::local</code> module, which contains modules, structs, and methods to send requests to the local Rocket application. The main purpose of sending a non-networked request to the local Rocket application is to inspect the response and ensure that the response is what we expected, mainly for testing. </p>
			<p>Let's try implementing integration testing for our application by following these steps:</p>
			<ol>
				<li value="1">In the root directory of the application, add a new directory named <code>tests</code>. Inside the <code>tests</code> directory, create a file named <code>functional_tests.rs</code>.</li>
				<li>Inside <code>tests/functional_tests.rs</code>, add a new test function as follows:<pre>#[test]
fn some_test() {
    assert_eq!(2, 1 + 1);
}</pre></li>
				<li>After that, save and run <code>cargo test</code> from the command line. The tests should pass, and the <code>cargo test</code> output should show that it was running the test inside the <code>tests</code> directory, as follows:<pre>...
<strong class="bold">Running tests/functional_tests.rs</strong>
...</pre></li>
				<li>Let's continue with testing the Rocket application. Create a test function named <code>test_rocket</code>, but since the application is <code>async</code>, we need a different test annotation, as follows:<pre>#[rocket::async_test]
async fn test_rocket() {
}</pre></li>
				<li>We are <a id="_idIndexMarker661"/>going to put the Rocket instance in the <code>rocket::local::asynchronous::Client</code> instance. Later, we can use the <code>Client</code> instance to send a request and verify the response. But, one problem is that the Rocket initialization is in <code>src/main.rs</code>, not in the <code>our_application</code> library. We can work around this problem by moving the Rocket initialization from <code>src/main.rs</code> to <code>src/lib.rs</code>. Move the code from <code>src/main.rs</code> to <code>src/lib.rs</code> under the <code>pub mod</code> declaration, then change any <code>use our_application::</code> to <code>use crate::</code>.</li>
			</ol>
			<p>After that, rename the <code>rocket()</code> function to <code>setup_rocket()</code>. Also, add  <code>pub</code> in front of the function and remove <code>#[launch]</code> from the top of the <code>setup_rocket()</code> function.</p>
			<p>We want a method to get the database URL, so implement the <code>get_database_url</code> method for <code>Config</code> in <code>src/lib.rs</code>:</p>
			<pre>impl Config {
    pub fn get_database_url(&amp;self) -&gt; String {
        self.databases.main_connection.url.clone()
    }
}</pre>
			<ol>
				<li value="6">In <code>src/main.rs</code>, change the application to use <code>setup_rocket()</code>, as follows:<pre>use our_application::setup_rocket;
use rocket::{Build, Rocket};
#[launch]
async fn rocket() -&gt; Rocket&lt;Build&gt; {
    setup_rocket().await
}</pre></li>
				<li>Going back to <code>tests/functional_test.rs</code>, add the <code>our_application</code> library:<pre>use our_application;</pre></li>
			</ol>
			<p>Then, initialize a <a id="_idIndexMarker662"/>Rocket instance in <code>test_rocket()</code> as follows:</p>
			<pre>let rocket = our_application::setup_rocket().await;</pre>
			<ol>
				<li value="8">We want to get a database connection to truncate the database table to ensure a clean state for the testing. Add the required <code>use</code> declarations:<pre>use our_application::Config;
use rocket_db_pools::sqlx::PgConnection;
use sqlx::postgres::PgPoolOptions;</pre></li>
			</ol>
			<p>Then, add the following lines inside the <code>test_rocket()</code> function:</p>
			<pre>let config_wrapper = rocket.figment().extract();
assert!(config_wrapper.is_ok());
let config: Config = config_wrapper.unwrap();
let db_url = config.get_database_url();
let db_wrapper = PgPoolOptions::new()
    .max_connections(5)
    .connect(&amp;db_url)
    .await;
assert!(db_wrapper.is_ok());
let db = db_wrapper.unwrap();</pre>
			<ol>
				<li value="9">We want to truncate the content of the <code>users</code> table. We want a method for <code>User</code> to remove <a id="_idIndexMarker663"/>all data, but the method should only be available for tests. Let's add a trait to extend the <code>User</code> model. Add the <code>use</code> declaration:<pre>use our_application::models::user::User;</pre></li>
			</ol>
			<p>Add the <code>ModelCleaner</code> trait and implement <code>ModelCleaner</code> for <code>User</code> as follows:</p>
			<pre>#[rocket::async_trait]
trait ModelCleaner {
    async fn clear_all(connection: &amp;mut PgConnection) 
    -&gt; Result&lt;(), String&gt;;
}
#[rocket::async_trait]
impl ModelCleaner for User {
    async fn clear_all(connection: &amp;mut PgConnection) 
    -&gt; Result&lt;(), String&gt; {
        let _ = sqlx::query("TRUNCATE users RESTART 
        IDENTITY CASCADE")
            .execute(connection)
            .await
            .map_err(|_| String::from("error 
            truncating databasse"))?;
        Ok(())
    }
}</pre>
			<ol>
				<li value="10">Continuing in the <code>test_rocket()</code> function, append the following lines:<pre>let pg_connection_wrapper = db.acquire().await;
assert!(pg_connection_wrapper.is_ok());
let mut pg_connection = pg_connection_wrapper.unwrap();
let clear_result_wrapper = User::clear_all(&amp;mut pg_connection).await;
assert!(clear_result_wrapper.is_ok());</pre></li>
				<li>In the <code>tests/functional_tests.rs</code> file, add the <code>use</code> declaration:<pre>use rocket::local::asynchronous::Client;</pre></li>
			</ol>
			<p>Then, create <a id="_idIndexMarker664"/>a <code>Client</code> instance inside the <code>test_rocket()</code> function:</p>
			<pre>let client_wrapper = Client::tracked(rocket).await;
assert!(client_wrapper.is_ok());
let client = client_wrapper.unwrap();</pre>
			<ol>
				<li value="12">Right now, the number of users in the database is <code>0</code>. We want to make a test by getting <code>"/users"</code> and parsing the HTML. One crate to parse HTML is <code>scraper</code>. Because we only want to use the <code>scraper</code> crate for testing, add a new part in <code>Cargo.toml</code> called <code>[dev-dependencies]</code>, as follows:<pre>[dev-dependencies]
scraper = "0.12.0"</pre></li>
				<li>Going back to <code>tests/functional_test.rs</code>, we want to get the <code>"/users"</code> response. Add the <code>use</code> declaration:<pre>use rocket::http::Status;</pre></li>
			</ol>
			<p>Then, append <a id="_idIndexMarker665"/>the following lines inside the <code>test_rocket()</code> function:</p>
			<pre>let req = client.get("/users");
let resp = req.dispatch().await;
assert_eq!(resp.status(), Status::Ok);</pre>
			<ol>
				<li value="14">We want to verify that the response body does not contain any users. If we look at the <code>src/views/users/index.html.tera</code> template, we see there's a <code>mark</code> HTML tag for each user. Let's use <code>scraper</code> to verify the response by adding the <code>use</code> declaration:<pre>use scraper::{Html, Selector}; </pre></li>
			</ol>
			<p>Then, append the following lines inside the <code>test_rocket()</code> function:</p>
			<pre>let body_wrapper = resp.into_string().await;
assert!(body_wrapper.is_some());
let body = Html::parse_document(&amp;body_wrapper.unwrap());
let selector = Selector::parse(r#"mark.tag"#).unwrap();
let containers = body.select(&amp;selector);
let num_of_elements = containers.count();
assert_eq!(num_of_elements, 0);</pre>
			<ol>
				<li value="15">We want to create a <code>post</code> request to create a new user, but one problem is that the application will do an token authenticity check, so we need to get the value from the <code>"/users/new"</code> page first. Append the following lines to get the token from <a id="_idIndexMarker666"/>the response body:<pre>let req = client.get("/users/new");
let resp = req.dispatch().await;
assert_eq!(resp.status(), Status::Ok);
let body_wrapper = resp.into_string().await;
assert!(body_wrapper.is_some());
let body = Html::parse_document(&amp;body_wrapper.unwrap());
let authenticity_token_selector = Selector::parse(r#"input[name="authenticity_token"]"#).unwrap();
let element_wrapper = body.select(&amp;authenticity_token_selector).next();
assert!(element_wrapper.is_some());
let element = element_wrapper.unwrap();
let value_wrapper = element.value().attr("value");
assert!(value_wrapper.is_some());
let authenticity_token = value_wrapper.unwrap();</pre></li>
				<li>Use <code>authenticity_token</code> to send the <code>post</code> request. Add the <code>use</code> declaration:<pre>use rocket::http::ContentType;</pre></li>
				<li>Then, append the following lines to the <code>test_rocket()</code> function:<pre>let username = "testing123";
let password = "lkjKLAJ09231478mlasdfkjsdkj";
let req = client.post("/users")
    .header(ContentType::Form)
    .body(
        format!("authenticity_token={
        }&amp;username={}&amp;email={}@{}
        .com&amp;password={}&amp;password_confirmation={}
        &amp;description=",
    authenticity_token, username, username, username, 
    password, password,
));
let resp = req.dispatch().await;
assert_eq!(resp.status(), Status::SeeOther);</pre></li>
				<li>Finally <a id="_idIndexMarker667"/>check the <code>"/users"</code> page again; you should see one user. Append the following lines:<pre>let req = client.get("/users");
let resp = req.dispatch().await;
assert_eq!(resp.status(), Status::Ok);
let body_wrapper = resp.into_string().await;
assert!(body_wrapper.is_some());
let body = Html::parse_document(&amp;body_wrapper.unwrap());
let selector = Selector::parse(r#"mark.tag"#).unwrap();
let containers = body.select(&amp;selector);
let num_of_elements = containers.count();
assert_eq!(num_of_elements, 1);</pre></li>
			</ol>
			<p>Try running the test again. Sometimes the test works:</p>
			<pre>$ cargo test
...
     Running tests/functional_tests.rs (target/debug/deps/functional_tests-625b16e4b25b72de)
running 2 tests
test some_test ... ok
...
test test_rocket ... ok
test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.43s</pre>
			<p>But, sometimes, the <a id="_idIndexMarker668"/>test doesn't work:</p>
			<pre>$ cargo test
...
     Running tests/functional_tests.rs (target/
     debug/deps/functional_tests-625b16e4b25b72de)
running 2 tests
test some_test ... ok
...
test test_rocket ... FAILED
failures:
---- test_rocket stdout ----
thread 'test_rocket' panicked at 'assertion failed: `(left == right)`
  left: `0`,
 right: `1`', tests/functional_tests.rs:115:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
thread 'rocket-worker-test-thread' panicked at 'called `Result::unwrap()` on an `Err` value: Disconnected',
/workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs:137:28
failures:
    test_rocket
test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.09s</pre>
			<p>Why did the test fail? We <a id="_idIndexMarker669"/>will learn how to debug the Rust program in the next section.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor137"/>Debugging the Rust application</h1>
			<p>In the previous section, we learned about writing functional tests, but sometimes, the test fails. We want <a id="_idIndexMarker670"/>to know why the test failed. There are two possible places where the error might occur. One is in the user creation process, and the other is in finding users after creating the user.</p>
			<p>One way to debug is by logging where the error might occur. If we log all the possible errors in the user creation process (for example, in <code>src/routes/user.rs</code> in the <code>create_user()</code> function), we will find out that the authenticity token verification sometimes produces an error. An example of logging the error is as follows:</p>
			<pre class="source-code">csrf_token</pre>
			<pre class="source-code">    .verify(&amp;new_user.authenticity_token)</pre>
			<pre class="source-code">    .map_err(|<strong class="bold">err</strong>| {</pre>
			<pre class="source-code">        <strong class="bold">log::error!("Verify authenticity_token error: {}", </strong></pre>
			<pre class="source-code"><strong class="bold">        err);</strong></pre>
			<pre class="source-code">        Flash::error(</pre>
			<pre class="source-code">            Redirect::to("/users/new"),</pre>
			<pre class="source-code">            "Something went wrong when creating user",</pre>
			<pre class="source-code">        )</pre>
			<pre class="source-code">    })?;</pre>
			<p>If we continue logging the <code>verify()</code> method and continue tracing the source of the problem, we will eventually find out that the <code>from_request()</code> method of the token is not producing <a id="_idIndexMarker671"/>the correct result. We can fix the problem by changing the <code>from_request()</code> method in <code>src/fairings/csrf.rs</code> with the following lines:</p>
			<pre class="source-code">async fn from_request(request: &amp;'r Request&lt;'_&gt;) -&gt; Outcome&lt;Self, Self::Error&gt; {</pre>
			<pre class="source-code">    match request.get_csrf_token() {</pre>
			<pre class="source-code">        None =&gt; Outcome::Failure((Status::Forbidden, ())),</pre>
			<pre class="source-code">        Some(token) =&gt; Outcome::Success(Self(<strong class="bold">base64::</strong></pre>
			<pre class="source-code"><strong class="bold">        encode_config(token, base64::URL_SAFE)</strong>)),</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Obviously, logging the code and finding the problem is not efficient. We can also use a debugger such as <code>gdb</code> (GNU Debugger) or <code>lldb</code> to debug Rust programs. <code>gdb</code> can be used on the Linux operating system, and <code>lldb</code> (Debugger of LLVM Project) can be used on macOS and Linux operating systems. Please install one of those debuggers if you want to use a debugger for the Rust programming language.</p>
			<p>Rust provides <code>rust-gdb</code> (a wrapper to <code>gdb</code>) and <code>rust-lldb</code> (a wrapper to <code>lldb</code>). Those programs should be installed with the Rust compiler. Let's see an example of how to use <code>rust-gdb</code> by following these steps:</p>
			<ol>
				<li value="1">First, build the application by using the <code>cargo build</code> command on the Terminal. Since we are not building the release version, debugging symbols should be in the resulting binary.</li>
				<li>Check the location of the generated binary in the source directory target directory; for example, if the source code for the application is in <code>/workspace/rocketbook/Chapter12/03RocketTesting/</code>, we can find the generated binary in <code>/workspace/rocketbook/Chapter12/03RocketTesting/target/debug/our_application</code>.</li>
				<li>Run <code>rust-gdb</code> on the Terminal just like you would run <code>gdb</code>. Here is an example: <pre>rust-gdb -q target/debug/our_application</pre></li>
				<li>You'll <a id="_idIndexMarker672"/>see a <code>gdb</code> prompt as follows:<pre><strong class="bold">Reading symbols from target/debug/our_application...</strong>
<strong class="bold">Reading symbols from /workspace/rocketbook/Chapter12/03RocketTesting/target/debug/our_application/Contents/Resources/DWARF/our_application...</strong>
<strong class="bold">(gdb)</strong></pre></li>
				<li>Set the breakpoint of the application, as in this example:<pre><strong class="bold">b /workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs:143</strong></pre></li>
				<li>You'll see a prompt to set a breakpoint on the <code>our_application</code> library as follows:<pre><strong class="bold">No source file named /workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs.</strong>
<strong class="bold">Make breakpoint pending on future shared library load? (y or [n])</strong></pre></li>
				<li>Reply with <code>y</code> and notice <code>Breakpoint 1</code> set as follows:<pre><strong class="bold">(y or [n]) y</strong>
<strong class="bold">Breakpoint 1 (/workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs:143) pending.</strong></pre></li>
				<li>Run the application by writing the <code>r</code> command and pressing the <em class="italic">Enter</em> key on the <code>gdb</code> prompt:<pre><strong class="bold">(gdb) r</strong></pre></li>
				<li>The application should run and because it hit the breakpoint, the execution stopped. <a id="_idIndexMarker673"/>We can use the <code>gdb</code> prompt again to inspect final_rocket, as in the following example:<pre><strong class="bold">Starting program: /workspace/rocketbook/Chapter12/03RocketTesting/target/debug/our_application </strong>
<strong class="bold">  [Thread debugging using libthread_db enabled]</strong>
<strong class="bold">  Using host libthread_db library </strong>
<strong class="bold">  "/usr/lib/libthread_db.so.1".</strong>
<strong class="bold">  [New Thread 0x7ffff7c71640 (LWP 50269)]</strong>
<strong class="bold">  ...</strong>
<strong class="bold">  [New Thread 0x7ffff746d640 (LWP 50273)]</strong>
<strong class="bold">  Thread 1 "our_application" hit Breakpoint 1, our_</strong>
<strong class="bold">  application::main::{generator#0} () at </strong>
<strong class="bold">  src/lib.rs:143</strong>
<strong class="bold">  143         final_rocket</strong></pre></li>
				<li>Try printing some variables in the debugger prompt:<pre><strong class="bold">(gdb) p config</strong></pre></li>
			</ol>
			<p>We can see the result printed as follows:</p>
			<pre><strong class="bold">$1 = our_application::Config {databases: our_application::Databases {main_connection: our_application::MainConnection {url: "postgres://username:password@localhost/rocket"}}, jwt_secret: "+/xbAZJs+e1BA4</strong>
<strong class="bold">gbv2zPrtkkkOhrYmHUGnJIoaL9Qsk="}</strong></pre>
			<ol>
				<li value="11">To quit from <code>gdb</code>, just type <code>quit</code> on prompt and confirm quitting the debugger as follows:<pre>(gdb) quit
A debugging session is active.
        Inferior 1 [process 50265] will be killed.
Quit anyway? (y or n) y</pre></li>
			</ol>
			<p>There are many more functionalities in these debuggers, such as setting multiple breakpoints and stepping <a id="_idIndexMarker674"/>through the breakpoints. You can find more information <a id="_idIndexMarker675"/>about <code>gdb</code> at <a href="https://www.sourceware.org/gdb/">https://www.sourceware.org/gdb/</a>, and <a id="_idIndexMarker676"/>about <code>lldb</code> at <a href="https://lldb.llvm.org/">https://lldb.llvm.org/</a>. </p>
			<p>There are also debuggers for IDEs or code editors, for example, users of Visual Studio Code can <a id="_idIndexMarker677"/>use CodeLLDB (<a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb</a>) to conveniently click on the line and mark the breakpoints from the editor and inspect the variables through a dedicated panel:</p>
			<div><div><img src="img/Figure_12.1_B16825.jpg" alt="Figure 12.1 – CodeLLDB inspecting our application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – CodeLLDB inspecting our application</p>
			<p>In any case, using a <a id="_idIndexMarker678"/>debugger is an indispensable tool for programming. Learning to use debuggers properly can help in working with the Rust programming language.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor138"/>Summary</h1>
			<p>In this chapter, we learned about testing the Rust program and Rocket application. We learned about using macros such as <code>assert!</code> to do the testing. We also learned the difference between unit testing and functional testing.</p>
			<p>We created a functional test and learned about modules to do functional testing on a Rocket application. Finally, we learned a little bit about the technique to debug a Rust application to help fix it.</p>
			<p>Testing and debugging are important parts of programming, as these techniques can improve the correctness of the application.</p>
			<p>After all the development is done, in the next chapter, we are going to learn several ways to set the Rocket application available to serve real-world users.</p>
		</div>
	</body></html>