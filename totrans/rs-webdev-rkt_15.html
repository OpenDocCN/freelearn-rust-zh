<html><head></head><body>
		<div id="_idContainer041">
			<h1 id="_idParaDest-132"><em class="italic"><a id="_idTextAnchor133"/>Chapter 12</em>: Testing Your Application</h1>
			<p>Ensuring that a program runs correctly is an important part of programming. In this chapter, we are going to learn about testing the Rust application. We are going to implement a simple unit test for a function, and a functional test for creating a user in our application. </p>
			<p>We are going to learn a simple technique to debug and find where a problem occurs in our code.</p>
			<p>After learning the information in this chapter, you will be able to create a unit test and functional test for Rust and Rocket applications to ensure the applications work as expected. You will also learn how to use a debugger such as <strong class="source-inline">gdb</strong> or <strong class="source-inline">lldb</strong> to debug Rust programs.</p>
			<p>In this chapter, we are going to cover these main topics:</p>
			<ul>
				<li>Testing the Rust program</li>
				<li>Testing the Rocket application</li>
				<li>Debugging the Rust application</li>
			</ul>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor134"/>Technical requirements</h1>
			<p>In this chapter, we are going to do a test and debug, so we need a debugger. Please install <strong class="source-inline">gdb</strong>, the GNU Debugger (<a href="https://www.sourceware.org/gdb/download/">https://www.sourceware.org/gdb/download/</a>), for your operating system.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter12">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter12</a>.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor135"/>Testing the Rust program</h1>
			<p>One important part of programming is testing the application. There are many kinds of tests, such as <a id="_idIndexMarker653"/>unit tests (to test a single function or method), functional tests (to test the function of an application), and integration testing (to test various units and functions as a single combined entity). Various tests should be conducted in order to make the application as correct as intended.</p>
			<p>In the Rust standard library, there are three macros to use in testing: <strong class="source-inline">assert!</strong>, <strong class="source-inline">assert_eq!</strong>, and <strong class="source-inline">assert_ne!</strong>. The <strong class="source-inline">assert!</strong> macro accepts one or more parameters. The first parameter is any statement that evaluates to Boolean, and the rest is for debugging if the result is not what is expected.</p>
			<p>The <strong class="source-inline">assert_eq!</strong> macro compares equality between the first parameter and second parameter, and the rest is for debugging if the result is not what is expected. The <strong class="source-inline">assert_ne!</strong> macro is the opposite of <strong class="source-inline">assert_eq!</strong>; this macro tests the inequality between the first and the second parameters.</p>
			<p>Let's see those macros in action. We want to test the <strong class="source-inline">raw_html()</strong> method of the <strong class="source-inline">TextPost</strong> model in <strong class="source-inline">src/models/text_post.rs</strong>. We want to ensure that the result of the method is the string we want to have. Follow these steps to test the method:</p>
			<ol>
				<li>In <strong class="source-inline">src/models/text_post.rs</strong>, add the following <strong class="source-inline">use</strong> declarations:<p class="source-code">use crate::models::our_date_time::OurDateTime;</p><p class="source-code">use crate::models::post_type::PostType;</p><p class="source-code">use chrono::{offset::Utc, TimeZone};</p><p class="source-code">use uuid::Uuid;</p></li>
				<li>In the same <strong class="source-inline">src/models/text_post.rs</strong> file, we want to have a function for testing. To make a function a test function, annotate the function with the <strong class="source-inline">#[test]</strong> attribute. Add the function declaration:<p class="source-code">#[test]</p><p class="source-code">fn test_raw_html() {</p><p class="source-code">}</p></li>
				<li>Inside the function, initialize a <strong class="source-inline">TextPost</strong> instance as follows:<p class="source-code">let created_at = OurDateTime(Utc.timestamp_nanos(1431648000000000));</p><p class="source-code">let post = Post {</p><p class="source-code">    uuid: Uuid::new_v4(),</p><p class="source-code">    user_uuid: Uuid::new_v4(),</p><p class="source-code">    post_type: PostType::Text,</p><p class="source-code">    content: String::from("hello"),</p><p class="source-code">    created_at: created_at,</p><p class="source-code">};</p><p class="source-code">let text_post = TextPost::new(&amp;post);</p></li>
				<li>Add the <strong class="source-inline">assert!</strong> macro to ensure the resulting string is what we want:<p class="source-code">assert!(</p><p class="source-code">    text_post.raw_html() == </p><p class="source-code">    String::from("&lt;p&gt;hel1lo&lt;/p&gt;"),</p><p class="source-code">    "String is not equal, {}, {}",</p><p class="source-code">    text_post.raw_html(),</p><p class="source-code">    String::from("&lt;p&gt;hello&lt;/p&gt;")</p><p class="source-code">);</p></li>
				<li>Save the file and run the test by running <strong class="source-inline">cargo test</strong> on the Terminal. As we made a <a id="_idIndexMarker654"/>mistake in our test code, <strong class="source-inline">"&lt;p&gt;hel1lo&lt;/p&gt;"</strong>, the test should fail, as in the following example:<p class="source-code"><strong class="bold">$ cargo test</strong></p><p class="source-code"><strong class="bold">   Compiling our_application v0.1.0 (/workspace/</strong></p><p class="source-code"><strong class="bold">   rocketbook/Chapter12/01RustTesting)</strong></p><p class="source-code"><strong class="bold">…</strong></p><p class="source-code"><strong class="bold">running 1 test</strong></p><p class="source-code"><strong class="bold">test models::text_post::test_raw_html ... FAILED</strong></p><p class="source-code"><strong class="bold">failures:</strong></p><p class="source-code"><strong class="bold">---- models::text_post::test_raw_html stdout ----</strong></p><p class="source-code"><strong class="bold">thread 'models::text_post::test_raw_html' panicked at 'String is not equal, &lt;p&gt;hello&lt;/p&gt;, &lt;p&gt;hello&lt;/p&gt;', src/models/text_post.rs:33:5</strong></p><p class="source-code"><strong class="bold">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</strong></p><p class="source-code"><strong class="bold">failures:</strong></p><p class="source-code"><strong class="bold">    models::text_post::test_raw_html</strong></p><p class="source-code"><strong class="bold">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong></p><p class="source-code"><strong class="bold">error: test failed, to rerun pass '--lib' </strong></p></li>
				<li>Fix <strong class="source-inline">"&lt;p&gt;hel1lo&lt;/p&gt;"</strong> by replacing it with <strong class="source-inline">"&lt;p&gt;hello&lt;/p&gt;"</strong>. Save the file and run <a id="_idIndexMarker655"/>the test again. The test should work fine now:<p class="source-code"><strong class="bold">$ cargo test</strong></p><p class="source-code"><strong class="bold">   Compiling our_application v0.1.0 (/workspace/</strong></p><p class="source-code"><strong class="bold">   rocketbook/Chapter12/01RustTesting)</strong></p><p class="source-code"><strong class="bold">…</strong></p><p class="source-code"><strong class="bold">running 1 test</strong></p><p class="source-code"><strong class="bold">test models::text_post::test_raw_html ... ok</strong></p><p class="source-code"><strong class="bold">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong></p><p class="source-code"><strong class="bold">     Running unittests (target/debug/deps/our_</strong></p><p class="source-code"><strong class="bold">     application-43a2db5b02032f30)</strong></p><p class="source-code"><strong class="bold">running 0 tests</strong></p><p class="source-code"><strong class="bold">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong></p><p class="source-code"><strong class="bold">   Doc-tests our_application</strong></p><p class="source-code"><strong class="bold">running 0 tests</strong></p><p class="source-code"><strong class="bold">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong></p></li>
				<li>We want to use the <strong class="source-inline">assert_eq!</strong> and <strong class="source-inline">assert_ne!</strong> macros. The <strong class="source-inline">assert_eq!</strong> macro is used to check that the first parameter is equal to the second parameter. The <strong class="source-inline">assert_ne!</strong> macro is used to make sure that the first parameter is <a id="_idIndexMarker656"/>not equal to the second parameter. Add the macros in the <strong class="source-inline">test_raw_html()</strong> function to see them in action:<p class="source-code">assert_eq!(text_post.raw_html(), String::from("&lt;p&gt;hello&lt;/p&gt;"));</p><p class="source-code">assert_ne!(text_post.raw_html(), String::from("&lt;img&gt;hello&lt;/img&gt;"));</p></li>
				<li>Run the test again; it should pass. But, if we look at the test output, there are warnings, as follows:<p class="source-code"><strong class="bold">warning: unused import: `crate::models::our_date_time::OurDateTime`</strong></p><p class="source-code"><strong class="bold"> --&gt; src/models/text_post.rs:1:5</strong></p><p class="source-code"><strong class="bold">  |</strong></p><p class="source-code"><strong class="bold">1 | use crate::models::our_date_time::OurDateTime;</strong></p><p class="source-code"><strong class="bold">  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</strong></p><p class="source-code"><strong class="bold">  |</strong></p><p class="source-code"><strong class="bold">  = note: `#[warn(unused_imports)]` on by default</strong></p></li>
				<li>One of the conventions for unit testing is to create a test module and mark the module as a test so <a id="_idIndexMarker657"/>it will not be compiled. In <strong class="source-inline">src/models/text_post.rs</strong>, add a new module:<p class="source-code">#[cfg(test)]</p><p class="source-code">mod tests {</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">src/models/text_post.rs</strong>, remove these unused <strong class="source-inline">use</strong> declarations:<p class="source-code">use crate::models::our_date_time::OurDateTime;</p><p class="source-code">use crate::models::post_type::PostType;</p><p class="source-code">use chrono::{offset::Utc, TimeZone};</p><p class="source-code">use uuid::Uuid;</p></li>
				<li>Vice versa, add the required <strong class="source-inline">use</strong> declarations in <strong class="source-inline">src/models/text_post.rs</strong> in the <strong class="source-inline">tests</strong> module: <p class="source-code">use super::TextPost;</p><p class="source-code">use crate::models::our_date_time::OurDateTime;</p><p class="source-code">use crate::models::post::Post;</p><p class="source-code">use crate::models::post_type::PostType;</p><p class="source-code">use crate::traits::DisplayPostContent;</p><p class="source-code">use chrono::{offset::Utc, TimeZone};</p><p class="source-code">use uuid::Uuid;</p></li>
				<li>Move the <strong class="source-inline">test_raw_html()</strong> function into the <strong class="source-inline">tests</strong> module. Run <strong class="source-inline">cargo test</strong> again in <a id="_idIndexMarker658"/>the Terminal. The tests should pass with no warnings, as in the following example:<p class="source-code"><strong class="bold">$ cargo test</strong></p><p class="source-code"><strong class="bold">    Finished test [unoptimized + debuginfo] target(s) </strong></p><p class="source-code"><strong class="bold">    in 0.34s</strong></p><p class="source-code"><strong class="bold">     Running unittests (target/debug/deps/our_</strong></p><p class="source-code"><strong class="bold">     application-40cf18b02419edd7)</strong></p><p class="source-code"><strong class="bold">running 1 test</strong></p><p class="source-code"><strong class="bold">test models::text_post::tests::test_raw_html ... ok</strong></p><p class="source-code"><strong class="bold">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong></p><p class="source-code"><strong class="bold">     Running unittests (target/debug/deps/our_</strong></p><p class="source-code"><strong class="bold">     application-77e614e023a036bf)</strong></p><p class="source-code"><strong class="bold">running 0 tests</strong></p><p class="source-code"><strong class="bold">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong></p><p class="source-code"><strong class="bold">   Doc-tests our_application</strong></p><p class="source-code"><strong class="bold">running 0 tests</strong></p><p class="source-code"><strong class="bold">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</strong></p></li>
			</ol>
			<p>Now that we have <a id="_idIndexMarker659"/>learned how to perform unit tests in Rust, we can continue by testing the application with functional testing in the next section.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor136"/>Testing the Rocket application</h1>
			<p>Besides putting the test in the <strong class="source-inline">src</strong> directory, we can create a test in Rust files in the <strong class="source-inline">tests</strong> directory inside the root directory of the application. When we run <strong class="source-inline">cargo test</strong>, the command <a id="_idIndexMarker660"/>line will look into the <strong class="source-inline">tests</strong> directory and run any test found there. People usually use tests in the <strong class="source-inline">src</strong> directory for unit testing and write functional tests in the <strong class="source-inline">tests</strong> directory.</p>
			<p>The Rocket framework provides a <strong class="source-inline">rocket::local</strong> module, which contains modules, structs, and methods to send requests to the local Rocket application. The main purpose of sending a non-networked request to the local Rocket application is to inspect the response and ensure that the response is what we expected, mainly for testing. </p>
			<p>Let's try implementing integration testing for our application by following these steps:</p>
			<ol>
				<li value="1">In the root directory of the application, add a new directory named <strong class="source-inline">tests</strong>. Inside the <strong class="source-inline">tests</strong> directory, create a file named <strong class="source-inline">functional_tests.rs</strong>.</li>
				<li>Inside <strong class="source-inline">tests/functional_tests.rs</strong>, add a new test function as follows:<p class="source-code">#[test]</p><p class="source-code">fn some_test() {</p><p class="source-code">    assert_eq!(2, 1 + 1);</p><p class="source-code">}</p></li>
				<li>After that, save and run <strong class="source-inline">cargo test</strong> from the command line. The tests should pass, and the <strong class="source-inline">cargo test</strong> output should show that it was running the test inside the <strong class="source-inline">tests</strong> directory, as follows:<p class="source-code">...</p><p class="source-code"><strong class="bold">Running tests/functional_tests.rs</strong></p><p class="source-code">...</p></li>
				<li>Let's continue with testing the Rocket application. Create a test function named <strong class="source-inline">test_rocket</strong>, but since the application is <strong class="source-inline">async</strong>, we need a different test annotation, as follows:<p class="source-code">#[rocket::async_test]</p><p class="source-code">async fn test_rocket() {</p><p class="source-code">}</p></li>
				<li>We are <a id="_idIndexMarker661"/>going to put the Rocket instance in the <strong class="source-inline">rocket::local::asynchronous::Client</strong> instance. Later, we can use the <strong class="source-inline">Client</strong> instance to send a request and verify the response. But, one problem is that the Rocket initialization is in <strong class="source-inline">src/main.rs</strong>, not in the <strong class="source-inline">our_application</strong> library. We can work around this problem by moving the Rocket initialization from <strong class="source-inline">src/main.rs</strong> to <strong class="source-inline">src/lib.rs</strong>. Move the code from <strong class="source-inline">src/main.rs</strong> to <strong class="source-inline">src/lib.rs</strong> under the <strong class="source-inline">pub mod</strong> declaration, then change any <strong class="source-inline">use our_application::</strong> to <strong class="source-inline">use crate::</strong>.</li>
			</ol>
			<p>After that, rename the <strong class="source-inline">rocket()</strong> function to <strong class="source-inline">setup_rocket()</strong>. Also, add  <strong class="source-inline">pub</strong> in front of the function and remove <strong class="source-inline">#[launch]</strong> from the top of the <strong class="source-inline">setup_rocket()</strong> function.</p>
			<p>We want a method to get the database URL, so implement the <strong class="source-inline">get_database_url</strong> method for <strong class="source-inline">Config</strong> in <strong class="source-inline">src/lib.rs</strong>:</p>
			<p class="source-code">impl Config {</p>
			<p class="source-code">    pub fn get_database_url(&amp;self) -&gt; String {</p>
			<p class="source-code">        self.databases.main_connection.url.clone()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<ol>
				<li value="6">In <strong class="source-inline">src/main.rs</strong>, change the application to use <strong class="source-inline">setup_rocket()</strong>, as follows:<p class="source-code">use our_application::setup_rocket;</p><p class="source-code">use rocket::{Build, Rocket};</p><p class="source-code">#[launch]</p><p class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</p><p class="source-code">    setup_rocket().await</p><p class="source-code">}</p></li>
				<li>Going back to <strong class="source-inline">tests/functional_test.rs</strong>, add the <strong class="source-inline">our_application</strong> library:<p class="source-code">use our_application;</p></li>
			</ol>
			<p>Then, initialize a <a id="_idIndexMarker662"/>Rocket instance in <strong class="source-inline">test_rocket()</strong> as follows:</p>
			<p class="source-code">let rocket = our_application::setup_rocket().await;</p>
			<ol>
				<li value="8">We want to get a database connection to truncate the database table to ensure a clean state for the testing. Add the required <strong class="source-inline">use</strong> declarations:<p class="source-code">use our_application::Config;</p><p class="source-code">use rocket_db_pools::sqlx::PgConnection;</p><p class="source-code">use sqlx::postgres::PgPoolOptions;</p></li>
			</ol>
			<p>Then, add the following lines inside the <strong class="source-inline">test_rocket()</strong> function:</p>
			<p class="source-code">let config_wrapper = rocket.figment().extract();</p>
			<p class="source-code">assert!(config_wrapper.is_ok());</p>
			<p class="source-code">let config: Config = config_wrapper.unwrap();</p>
			<p class="source-code">let db_url = config.get_database_url();</p>
			<p class="source-code">let db_wrapper = PgPoolOptions::new()</p>
			<p class="source-code">    .max_connections(5)</p>
			<p class="source-code">    .connect(&amp;db_url)</p>
			<p class="source-code">    .await;</p>
			<p class="source-code">assert!(db_wrapper.is_ok());</p>
			<p class="source-code">let db = db_wrapper.unwrap();</p>
			<ol>
				<li value="9">We want to truncate the content of the <strong class="source-inline">users</strong> table. We want a method for <strong class="source-inline">User</strong> to remove <a id="_idIndexMarker663"/>all data, but the method should only be available for tests. Let's add a trait to extend the <strong class="source-inline">User</strong> model. Add the <strong class="source-inline">use</strong> declaration:<p class="source-code">use our_application::models::user::User;</p></li>
			</ol>
			<p>Add the <strong class="source-inline">ModelCleaner</strong> trait and implement <strong class="source-inline">ModelCleaner</strong> for <strong class="source-inline">User</strong> as follows:</p>
			<p class="source-code">#[rocket::async_trait]</p>
			<p class="source-code">trait ModelCleaner {</p>
			<p class="source-code">    async fn clear_all(connection: &amp;mut PgConnection) </p>
			<p class="source-code">    -&gt; Result&lt;(), String&gt;;</p>
			<p class="source-code">}</p>
			<p class="source-code">#[rocket::async_trait]</p>
			<p class="source-code">impl ModelCleaner for User {</p>
			<p class="source-code">    async fn clear_all(connection: &amp;mut PgConnection) </p>
			<p class="source-code">    -&gt; Result&lt;(), String&gt; {</p>
			<p class="source-code">        let _ = sqlx::query("TRUNCATE users RESTART </p>
			<p class="source-code">        IDENTITY CASCADE")</p>
			<p class="source-code">            .execute(connection)</p>
			<p class="source-code">            .await</p>
			<p class="source-code">            .map_err(|_| String::from("error </p>
			<p class="source-code">            truncating databasse"))?;</p>
			<p class="source-code">        Ok(())</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<ol>
				<li value="10">Continuing in the <strong class="source-inline">test_rocket()</strong> function, append the following lines:<p class="source-code">let pg_connection_wrapper = db.acquire().await;</p><p class="source-code">assert!(pg_connection_wrapper.is_ok());</p><p class="source-code">let mut pg_connection = pg_connection_wrapper.unwrap();</p><p class="source-code">let clear_result_wrapper = User::clear_all(&amp;mut pg_connection).await;</p><p class="source-code">assert!(clear_result_wrapper.is_ok());</p></li>
				<li>In the <strong class="source-inline">tests/functional_tests.rs</strong> file, add the <strong class="source-inline">use</strong> declaration:<p class="source-code">use rocket::local::asynchronous::Client;</p></li>
			</ol>
			<p>Then, create <a id="_idIndexMarker664"/>a <strong class="source-inline">Client</strong> instance inside the <strong class="source-inline">test_rocket()</strong> function:</p>
			<p class="source-code">let client_wrapper = Client::tracked(rocket).await;</p>
			<p class="source-code">assert!(client_wrapper.is_ok());</p>
			<p class="source-code">let client = client_wrapper.unwrap();</p>
			<ol>
				<li value="12">Right now, the number of users in the database is <strong class="source-inline">0</strong>. We want to make a test by getting <strong class="source-inline">"/users"</strong> and parsing the HTML. One crate to parse HTML is <strong class="source-inline">scraper</strong>. Because we only want to use the <strong class="source-inline">scraper</strong> crate for testing, add a new part in <strong class="source-inline">Cargo.toml</strong> called <strong class="source-inline">[dev-dependencies]</strong>, as follows:<p class="source-code">[dev-dependencies]</p><p class="source-code">scraper = "0.12.0"</p></li>
				<li>Going back to <strong class="source-inline">tests/functional_test.rs</strong>, we want to get the <strong class="source-inline">"/users"</strong> response. Add the <strong class="source-inline">use</strong> declaration:<p class="source-code">use rocket::http::Status;</p></li>
			</ol>
			<p>Then, append <a id="_idIndexMarker665"/>the following lines inside the <strong class="source-inline">test_rocket()</strong> function:</p>
			<p class="source-code">let req = client.get("/users");</p>
			<p class="source-code">let resp = req.dispatch().await;</p>
			<p class="source-code">assert_eq!(resp.status(), Status::Ok);</p>
			<ol>
				<li value="14">We want to verify that the response body does not contain any users. If we look at the <strong class="source-inline">src/views/users/index.html.tera</strong> template, we see there's a <strong class="source-inline">mark</strong> HTML tag for each user. Let's use <strong class="source-inline">scraper</strong> to verify the response by adding the <strong class="source-inline">use</strong> declaration:<p class="source-code">use scraper::{Html, Selector}; </p></li>
			</ol>
			<p>Then, append the following lines inside the <strong class="source-inline">test_rocket()</strong> function:</p>
			<p class="source-code">let body_wrapper = resp.into_string().await;</p>
			<p class="source-code">assert!(body_wrapper.is_some());</p>
			<p class="source-code">let body = Html::parse_document(&amp;body_wrapper.unwrap());</p>
			<p class="source-code">let selector = Selector::parse(r#"mark.tag"#).unwrap();</p>
			<p class="source-code">let containers = body.select(&amp;selector);</p>
			<p class="source-code">let num_of_elements = containers.count();</p>
			<p class="source-code">assert_eq!(num_of_elements, 0);</p>
			<ol>
				<li value="15">We want to create a <strong class="source-inline">post</strong> request to create a new user, but one problem is that the application will do an token authenticity check, so we need to get the value from the <strong class="source-inline">"/users/new"</strong> page first. Append the following lines to get the token from <a id="_idIndexMarker666"/>the response body:<p class="source-code">let req = client.get("/users/new");</p><p class="source-code">let resp = req.dispatch().await;</p><p class="source-code">assert_eq!(resp.status(), Status::Ok);</p><p class="source-code">let body_wrapper = resp.into_string().await;</p><p class="source-code">assert!(body_wrapper.is_some());</p><p class="source-code">let body = Html::parse_document(&amp;body_wrapper.unwrap());</p><p class="source-code">let authenticity_token_selector = Selector::parse(r#"input[name="authenticity_token"]"#).unwrap();</p><p class="source-code">let element_wrapper = body.select(&amp;authenticity_token_selector).next();</p><p class="source-code">assert!(element_wrapper.is_some());</p><p class="source-code">let element = element_wrapper.unwrap();</p><p class="source-code">let value_wrapper = element.value().attr("value");</p><p class="source-code">assert!(value_wrapper.is_some());</p><p class="source-code">let authenticity_token = value_wrapper.unwrap();</p></li>
				<li>Use <strong class="source-inline">authenticity_token</strong> to send the <strong class="source-inline">post</strong> request. Add the <strong class="source-inline">use</strong> declaration:<p class="source-code">use rocket::http::ContentType;</p></li>
				<li>Then, append the following lines to the <strong class="source-inline">test_rocket()</strong> function:<p class="source-code">let username = "testing123";</p><p class="source-code">let password = "lkjKLAJ09231478mlasdfkjsdkj";</p><p class="source-code">let req = client.post("/users")</p><p class="source-code">    .header(ContentType::Form)</p><p class="source-code">    .body(</p><p class="source-code">        format!("authenticity_token={</p><p class="source-code">        }&amp;username={}&amp;email={}@{}</p><p class="source-code">        .com&amp;password={}&amp;password_confirmation={}</p><p class="source-code">        &amp;description=",</p><p class="source-code">    authenticity_token, username, username, username, </p><p class="source-code">    password, password,</p><p class="source-code">));</p><p class="source-code">let resp = req.dispatch().await;</p><p class="source-code">assert_eq!(resp.status(), Status::SeeOther);</p></li>
				<li>Finally <a id="_idIndexMarker667"/>check the <strong class="source-inline">"/users"</strong> page again; you should see one user. Append the following lines:<p class="source-code">let req = client.get("/users");</p><p class="source-code">let resp = req.dispatch().await;</p><p class="source-code">assert_eq!(resp.status(), Status::Ok);</p><p class="source-code">let body_wrapper = resp.into_string().await;</p><p class="source-code">assert!(body_wrapper.is_some());</p><p class="source-code">let body = Html::parse_document(&amp;body_wrapper.unwrap());</p><p class="source-code">let selector = Selector::parse(r#"mark.tag"#).unwrap();</p><p class="source-code">let containers = body.select(&amp;selector);</p><p class="source-code">let num_of_elements = containers.count();</p><p class="source-code">assert_eq!(num_of_elements, 1);</p></li>
			</ol>
			<p>Try running the test again. Sometimes the test works:</p>
			<p class="source-code">$ cargo test</p>
			<p class="source-code">...</p>
			<p class="source-code">     Running tests/functional_tests.rs (target/debug/deps/functional_tests-625b16e4b25b72de)</p>
			<p class="source-code">running 2 tests</p>
			<p class="source-code">test some_test ... ok</p>
			<p class="source-code">...</p>
			<p class="source-code">test test_rocket ... ok</p>
			<p class="source-code">test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.43s</p>
			<p>But, sometimes, the <a id="_idIndexMarker668"/>test doesn't work:</p>
			<p class="source-code">$ cargo test</p>
			<p class="source-code">...</p>
			<p class="source-code">     Running tests/functional_tests.rs (target/</p>
			<p class="source-code">     debug/deps/functional_tests-625b16e4b25b72de)</p>
			<p class="source-code">running 2 tests</p>
			<p class="source-code">test some_test ... ok</p>
			<p class="source-code">...</p>
			<p class="source-code">test test_rocket ... FAILED</p>
			<p class="source-code">failures:</p>
			<p class="source-code">---- test_rocket stdout ----</p>
			<p class="source-code">thread 'test_rocket' panicked at 'assertion failed: `(left == right)`</p>
			<p class="source-code">  left: `0`,</p>
			<p class="source-code"> right: `1`', tests/functional_tests.rs:115:5</p>
			<p class="source-code">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</p>
			<p class="source-code">thread 'rocket-worker-test-thread' panicked at 'called `Result::unwrap()` on an `Err` value: Disconnected',</p>
			<p class="source-code">/workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs:137:28</p>
			<p class="source-code">failures:</p>
			<p class="source-code">    test_rocket</p>
			<p class="source-code">test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.09s</p>
			<p>Why did the test fail? We <a id="_idIndexMarker669"/>will learn how to debug the Rust program in the next section.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor137"/>Debugging the Rust application</h1>
			<p>In the previous section, we learned about writing functional tests, but sometimes, the test fails. We want <a id="_idIndexMarker670"/>to know why the test failed. There are two possible places where the error might occur. One is in the user creation process, and the other is in finding users after creating the user.</p>
			<p>One way to debug is by logging where the error might occur. If we log all the possible errors in the user creation process (for example, in <strong class="source-inline">src/routes/user.rs</strong> in the <strong class="source-inline">create_user()</strong> function), we will find out that the authenticity token verification sometimes produces an error. An example of logging the error is as follows:</p>
			<pre class="source-code">csrf_token</pre>
			<pre class="source-code">    .verify(&amp;new_user.authenticity_token)</pre>
			<pre class="source-code">    .map_err(|<strong class="bold">err</strong>| {</pre>
			<pre class="source-code">        <strong class="bold">log::error!("Verify authenticity_token error: {}", </strong></pre>
			<pre class="source-code"><strong class="bold">        err);</strong></pre>
			<pre class="source-code">        Flash::error(</pre>
			<pre class="source-code">            Redirect::to("/users/new"),</pre>
			<pre class="source-code">            "Something went wrong when creating user",</pre>
			<pre class="source-code">        )</pre>
			<pre class="source-code">    })?;</pre>
			<p>If we continue logging the <strong class="source-inline">verify()</strong> method and continue tracing the source of the problem, we will eventually find out that the <strong class="source-inline">from_request()</strong> method of the token is not producing <a id="_idIndexMarker671"/>the correct result. We can fix the problem by changing the <strong class="source-inline">from_request()</strong> method in <strong class="source-inline">src/fairings/csrf.rs</strong> with the following lines:</p>
			<pre class="source-code">async fn from_request(request: &amp;'r Request&lt;'_&gt;) -&gt; Outcome&lt;Self, Self::Error&gt; {</pre>
			<pre class="source-code">    match request.get_csrf_token() {</pre>
			<pre class="source-code">        None =&gt; Outcome::Failure((Status::Forbidden, ())),</pre>
			<pre class="source-code">        Some(token) =&gt; Outcome::Success(Self(<strong class="bold">base64::</strong></pre>
			<pre class="source-code"><strong class="bold">        encode_config(token, base64::URL_SAFE)</strong>)),</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Obviously, logging the code and finding the problem is not efficient. We can also use a debugger such as <strong class="source-inline">gdb</strong> (GNU Debugger) or <strong class="source-inline">lldb</strong> to debug Rust programs. <strong class="source-inline">gdb</strong> can be used on the Linux operating system, and <strong class="source-inline">lldb</strong> (Debugger of LLVM Project) can be used on macOS and Linux operating systems. Please install one of those debuggers if you want to use a debugger for the Rust programming language.</p>
			<p>Rust provides <strong class="source-inline">rust-gdb</strong> (a wrapper to <strong class="source-inline">gdb</strong>) and <strong class="source-inline">rust-lldb</strong> (a wrapper to <strong class="source-inline">lldb</strong>). Those programs should be installed with the Rust compiler. Let's see an example of how to use <strong class="source-inline">rust-gdb</strong> by following these steps:</p>
			<ol>
				<li value="1">First, build the application by using the <strong class="source-inline">cargo build</strong> command on the Terminal. Since we are not building the release version, debugging symbols should be in the resulting binary.</li>
				<li>Check the location of the generated binary in the source directory target directory; for example, if the source code for the application is in <strong class="source-inline">/workspace/rocketbook/Chapter12/03RocketTesting/</strong>, we can find the generated binary in <strong class="source-inline">/workspace/rocketbook/Chapter12/03RocketTesting/target/debug/our_application</strong>.</li>
				<li>Run <strong class="source-inline">rust-gdb</strong> on the Terminal just like you would run <strong class="source-inline">gdb</strong>. Here is an example: <p class="source-code">rust-gdb -q target/debug/our_application</p></li>
				<li>You'll <a id="_idIndexMarker672"/>see a <strong class="source-inline">gdb</strong> prompt as follows:<p class="source-code"><strong class="bold">Reading symbols from target/debug/our_application...</strong></p><p class="source-code"><strong class="bold">Reading symbols from /workspace/rocketbook/Chapter12/03RocketTesting/target/debug/our_application/Contents/Resources/DWARF/our_application...</strong></p><p class="source-code"><strong class="bold">(gdb)</strong></p></li>
				<li>Set the breakpoint of the application, as in this example:<p class="source-code"><strong class="bold">b /workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs:143</strong></p></li>
				<li>You'll see a prompt to set a breakpoint on the <strong class="source-inline">our_application</strong> library as follows:<p class="source-code"><strong class="bold">No source file named /workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs.</strong></p><p class="source-code"><strong class="bold">Make breakpoint pending on future shared library load? (y or [n])</strong></p></li>
				<li>Reply with <strong class="source-inline">y</strong> and notice <strong class="source-inline">Breakpoint 1</strong> set as follows:<p class="source-code"><strong class="bold">(y or [n]) y</strong></p><p class="source-code"><strong class="bold">Breakpoint 1 (/workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs:143) pending.</strong></p></li>
				<li>Run the application by writing the <strong class="source-inline">r</strong> command and pressing the <em class="italic">Enter</em> key on the <strong class="source-inline">gdb</strong> prompt:<p class="source-code"><strong class="bold">(gdb) r</strong></p></li>
				<li>The application should run and because it hit the breakpoint, the execution stopped. <a id="_idIndexMarker673"/>We can use the <strong class="source-inline">gdb</strong> prompt again to inspect final_rocket, as in the following example:<p class="source-code"><strong class="bold">Starting program: /workspace/rocketbook/Chapter12/03RocketTesting/target/debug/our_application </strong></p><p class="source-code"><strong class="bold">  [Thread debugging using libthread_db enabled]</strong></p><p class="source-code"><strong class="bold">  Using host libthread_db library </strong></p><p class="source-code"><strong class="bold">  "/usr/lib/libthread_db.so.1".</strong></p><p class="source-code"><strong class="bold">  [New Thread 0x7ffff7c71640 (LWP 50269)]</strong></p><p class="source-code"><strong class="bold">  ...</strong></p><p class="source-code"><strong class="bold">  [New Thread 0x7ffff746d640 (LWP 50273)]</strong></p><p class="source-code"><strong class="bold">  Thread 1 "our_application" hit Breakpoint 1, our_</strong></p><p class="source-code"><strong class="bold">  application::main::{generator#0} () at </strong></p><p class="source-code"><strong class="bold">  src/lib.rs:143</strong></p><p class="source-code"><strong class="bold">  143         final_rocket</strong></p></li>
				<li>Try printing some variables in the debugger prompt:<p class="source-code"><strong class="bold">(gdb) p config</strong></p></li>
			</ol>
			<p>We can see the result printed as follows:</p>
			<p class="source-code"><strong class="bold">$1 = our_application::Config {databases: our_application::Databases {main_connection: our_application::MainConnection {url: "postgres://username:password@localhost/rocket"}}, jwt_secret: "+/xbAZJs+e1BA4</strong></p>
			<p class="source-code"><strong class="bold">gbv2zPrtkkkOhrYmHUGnJIoaL9Qsk="}</strong></p>
			<ol>
				<li value="11">To quit from <strong class="source-inline">gdb</strong>, just type <strong class="source-inline">quit</strong> on prompt and confirm quitting the debugger as follows:<p class="source-code">(gdb) quit</p><p class="source-code">A debugging session is active.</p><p class="source-code">        Inferior 1 [process 50265] will be killed.</p><p class="source-code">Quit anyway? (y or n) y</p></li>
			</ol>
			<p>There are many more functionalities in these debuggers, such as setting multiple breakpoints and stepping <a id="_idIndexMarker674"/>through the breakpoints. You can find more information <a id="_idIndexMarker675"/>about <strong class="source-inline">gdb</strong> at <a href="https://www.sourceware.org/gdb/">https://www.sourceware.org/gdb/</a>, and <a id="_idIndexMarker676"/>about <strong class="source-inline">lldb</strong> at <a href="https://lldb.llvm.org/">https://lldb.llvm.org/</a>. </p>
			<p>There are also debuggers for IDEs or code editors, for example, users of Visual Studio Code can <a id="_idIndexMarker677"/>use CodeLLDB (<a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb</a>) to conveniently click on the line and mark the breakpoints from the editor and inspect the variables through a dedicated panel:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_12.1_B16825.jpg" alt="Figure 12.1 – CodeLLDB inspecting our application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – CodeLLDB inspecting our application</p>
			<p>In any case, using a <a id="_idIndexMarker678"/>debugger is an indispensable tool for programming. Learning to use debuggers properly can help in working with the Rust programming language.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor138"/>Summary</h1>
			<p>In this chapter, we learned about testing the Rust program and Rocket application. We learned about using macros such as <strong class="source-inline">assert!</strong> to do the testing. We also learned the difference between unit testing and functional testing.</p>
			<p>We created a functional test and learned about modules to do functional testing on a Rocket application. Finally, we learned a little bit about the technique to debug a Rust application to help fix it.</p>
			<p>Testing and debugging are important parts of programming, as these techniques can improve the correctness of the application.</p>
			<p>After all the development is done, in the next chapter, we are going to learn several ways to set the Rocket application available to serve real-world users.</p>
		</div>
	</body></html>